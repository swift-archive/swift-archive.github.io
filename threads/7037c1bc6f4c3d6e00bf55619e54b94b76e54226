<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ca02c0ca5c5d6a28bc48eebb3b000c7?s=50"></div><header><strong>[Proposal] Set literal and Set type syntax</strong> from <string>Michael Henson</string> &lt;mikehenson at gmail.com&gt;<p>January 18, 2016 at 01:00:00pm</p></header><div class="content"><p>Swift currently has literal and type shorthand syntax for native Array and<br>Dictionary types, but not the Set type. It would be useful to have a<br>literal shorthand for Set as well.<br></p><p>The existing productions for array and dictionary literals and types share<br>brackets as delimiters, differing only in the contents between the<br>brackets. That poses a slight problem for Set because any syntax, to be<br>useful, must also be easily distinguishable from the other types.<br></p><p>Consider that Arrays and Dictionaries are both naturally indexed<br>collections. Arrays by the integer value of the order of items in the<br>collection, usually implicitly, and Dictionaries by the hashed key<br>associated with each value.<br></p><p>Arrays, implicit index:<br></p><p>let array = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]<br>var array: [String]<br>var empty: [String] = []<br></p><p>Dictionaries, explicit index:<br></p><p>let dictionary = [&quot;a&quot;: 1, &quot;b&quot;: 5, &quot;c&quot;: 9]<br>var dictionary: [String: Int]<br>var empty: [String: Int] = [:]<br></p><p>Sets, by contrast, have no particular order and no &quot;key&quot;. Even though the<br>Set is enumerable and iterable, it isn&#39;t indexed. With that in mind, we can<br>declare that a Set literal or Set type literal should distinguish itself by<br>declaring that it has no index.<br></p><p>The Set literal could be:<br></p><p>let set = [ _: &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]<br>var set = [ _: String ]<br>var empty: [ _: String ] = [_:]<br></p><p>In the grammar:<br></p><p>set-literal -&gt; [ _ : array-literal-items[opt] ]<br>literal-expression -&gt; array-literal | dictionary-literal | set-literal<br></p><p>set-type -&gt; [ _ : type ]<br>type -&gt; array-type | dictionary-type | set-type | ... etc.<br></p><p><br>Examples:<br></p><p>let x = [ _: &quot;A&quot;, &quot;B&quot;, &quot;C&quot; ]<br>let y: [ _: String ] = [ _: ]<br></p><p><br>Alternatives considered:<br></p><p>Without literals, declaring a Set type is straightforward, easy to<br>recognize, and not much more verbose. There might not be enough of a<br>difference to justify special syntax in the core language.<br></p><p>Mike<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160118/70374226/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a1faea18be9eb2d50c4edcd223f2d685?s=50"></div><header><strong>[Proposal] Set literal and Set type syntax</strong> from <string>Seth Friedman</string> &lt;sethfri at gmail.com&gt;<p>January 18, 2016 at 01:00:00pm</p></header><div class="content"><p>I dig the idea of Sets having a literal syntax, rather than continuing to<br>be the ugly stepchild of CollectionTypes. I&#39;m not sure, though, that this<br>particular literal syntax is very obvious. While the Array and Dictionary<br>syntaxes are similar enough to many other languages in which arrays and<br>maps exist, I might be confused if I saw your proposed syntax in Swift.<br></p><p>Not to mention that it&#39;s not the prettiest syntax, but that&#39;s more<br>subjective.<br></p><p>On Mon, Jan 18, 2016 at 1:24 PM, Michael Henson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Swift currently has literal and type shorthand syntax for native Array and<br>&gt; Dictionary types, but not the Set type. It would be useful to have a<br>&gt; literal shorthand for Set as well.<br>&gt;<br>&gt; The existing productions for array and dictionary literals and types share<br>&gt; brackets as delimiters, differing only in the contents between the<br>&gt; brackets. That poses a slight problem for Set because any syntax, to be<br>&gt; useful, must also be easily distinguishable from the other types.<br>&gt;<br>&gt; Consider that Arrays and Dictionaries are both naturally indexed<br>&gt; collections. Arrays by the integer value of the order of items in the<br>&gt; collection, usually implicitly, and Dictionaries by the hashed key<br>&gt; associated with each value.<br>&gt;<br>&gt; Arrays, implicit index:<br>&gt;<br>&gt; let array = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]<br>&gt; var array: [String]<br>&gt; var empty: [String] = []<br>&gt;<br>&gt; Dictionaries, explicit index:<br>&gt;<br>&gt; let dictionary = [&quot;a&quot;: 1, &quot;b&quot;: 5, &quot;c&quot;: 9]<br>&gt; var dictionary: [String: Int]<br>&gt; var empty: [String: Int] = [:]<br>&gt;<br>&gt; Sets, by contrast, have no particular order and no &quot;key&quot;. Even though the<br>&gt; Set is enumerable and iterable, it isn&#39;t indexed. With that in mind, we can<br>&gt; declare that a Set literal or Set type literal should distinguish itself by<br>&gt; declaring that it has no index.<br>&gt;<br>&gt; The Set literal could be:<br>&gt;<br>&gt; let set = [ _: &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]<br>&gt; var set = [ _: String ]<br>&gt; var empty: [ _: String ] = [_:]<br>&gt;<br>&gt; In the grammar:<br>&gt;<br>&gt; set-literal -&gt; [ _ : array-literal-items[opt] ]<br>&gt; literal-expression -&gt; array-literal | dictionary-literal | set-literal<br>&gt;<br>&gt; set-type -&gt; [ _ : type ]<br>&gt; type -&gt; array-type | dictionary-type | set-type | ... etc.<br>&gt;<br>&gt;<br>&gt; Examples:<br>&gt;<br>&gt; let x = [ _: &quot;A&quot;, &quot;B&quot;, &quot;C&quot; ]<br>&gt; let y: [ _: String ] = [ _: ]<br>&gt;<br>&gt;<br>&gt; Alternatives considered:<br>&gt;<br>&gt; Without literals, declaring a Set type is straightforward, easy to<br>&gt; recognize, and not much more verbose. There might not be enough of a<br>&gt; difference to justify special syntax in the core language.<br>&gt;<br>&gt; Mike<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p><p><br>-- <br>Seth Friedman<br>*Software Development Engineer II*<br>*Amazon.com*<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160118/16c4d679/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Proposal] Set literal and Set type syntax</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January 19, 2016 at 09:00:00am</p></header><div class="content"><p>Sorry -1 from me. Doesn&#39;t seem worth it. Not much wrong with Set(&quot;a&quot;, &quot;b&quot;,<br>&quot;c&quot;).<br></p><p>On Tuesday, 19 January 2016, Seth Friedman via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I dig the idea of Sets having a literal syntax, rather than continuing to<br>&gt; be the ugly stepchild of CollectionTypes. I&#39;m not sure, though, that this<br>&gt; particular literal syntax is very obvious. While the Array and Dictionary<br>&gt; syntaxes are similar enough to many other languages in which arrays and<br>&gt; maps exist, I might be confused if I saw your proposed syntax in Swift.<br>&gt;<br>&gt; Not to mention that it&#39;s not the prettiest syntax, but that&#39;s more<br>&gt; subjective.<br>&gt;<br>&gt; On Mon, Jan 18, 2016 at 1:24 PM, Michael Henson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt;&gt; Swift currently has literal and type shorthand syntax for native Array<br>&gt;&gt; and Dictionary types, but not the Set type. It would be useful to have a<br>&gt;&gt; literal shorthand for Set as well.<br>&gt;&gt;<br>&gt;&gt; The existing productions for array and dictionary literals and types<br>&gt;&gt; share brackets as delimiters, differing only in the contents between the<br>&gt;&gt; brackets. That poses a slight problem for Set because any syntax, to be<br>&gt;&gt; useful, must also be easily distinguishable from the other types.<br>&gt;&gt;<br>&gt;&gt; Consider that Arrays and Dictionaries are both naturally indexed<br>&gt;&gt; collections. Arrays by the integer value of the order of items in the<br>&gt;&gt; collection, usually implicitly, and Dictionaries by the hashed key<br>&gt;&gt; associated with each value.<br>&gt;&gt;<br>&gt;&gt; Arrays, implicit index:<br>&gt;&gt;<br>&gt;&gt; let array = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]<br>&gt;&gt; var array: [String]<br>&gt;&gt; var empty: [String] = []<br>&gt;&gt;<br>&gt;&gt; Dictionaries, explicit index:<br>&gt;&gt;<br>&gt;&gt; let dictionary = [&quot;a&quot;: 1, &quot;b&quot;: 5, &quot;c&quot;: 9]<br>&gt;&gt; var dictionary: [String: Int]<br>&gt;&gt; var empty: [String: Int] = [:]<br>&gt;&gt;<br>&gt;&gt; Sets, by contrast, have no particular order and no &quot;key&quot;. Even though the<br>&gt;&gt; Set is enumerable and iterable, it isn&#39;t indexed. With that in mind, we can<br>&gt;&gt; declare that a Set literal or Set type literal should distinguish itself by<br>&gt;&gt; declaring that it has no index.<br>&gt;&gt;<br>&gt;&gt; The Set literal could be:<br>&gt;&gt;<br>&gt;&gt; let set = [ _: &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]<br>&gt;&gt; var set = [ _: String ]<br>&gt;&gt; var empty: [ _: String ] = [_:]<br>&gt;&gt;<br>&gt;&gt; In the grammar:<br>&gt;&gt;<br>&gt;&gt; set-literal -&gt; [ _ : array-literal-items[opt] ]<br>&gt;&gt; literal-expression -&gt; array-literal | dictionary-literal | set-literal<br>&gt;&gt;<br>&gt;&gt; set-type -&gt; [ _ : type ]<br>&gt;&gt; type -&gt; array-type | dictionary-type | set-type | ... etc.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Examples:<br>&gt;&gt;<br>&gt;&gt; let x = [ _: &quot;A&quot;, &quot;B&quot;, &quot;C&quot; ]<br>&gt;&gt; let y: [ _: String ] = [ _: ]<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Alternatives considered:<br>&gt;&gt;<br>&gt;&gt; Without literals, declaring a Set type is straightforward, easy to<br>&gt;&gt; recognize, and not much more verbose. There might not be enough of a<br>&gt;&gt; difference to justify special syntax in the core language.<br>&gt;&gt;<br>&gt;&gt; Mike<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Seth Friedman<br>&gt; *Software Development Engineer II*<br>&gt; *Amazon.com*<br>&gt;<br></p><p><br>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160119/fafe62df/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f7877c384b6a5494c1b0283eb805831c?s=50"></div><header><strong>[Proposal] Set literal and Set type syntax</strong> from <string>Liam Butler-Lawrence</string> &lt;liamdunn at me.com&gt;<p>January 18, 2016 at 05:00:00pm</p></header><div class="content"><p>Set(&quot;a&quot;, &quot;b&quot;, &quot;c”) doesn’t compile. It currently has to be  Set(arrayLiteral: &quot;a&quot;, &quot;b&quot;, &quot;c”). That said, I’d be satisfied with removing the external parameter name “arrayLiteral”. Not only is it unnecessary, but it’s confusing too: variadic parameters are not the same as an Array.<br></p><p>Liam<br></p><p>&gt; On Jan 18, 2016, at 5:43 PM, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Sorry -1 from me. Doesn&#39;t seem worth it. Not much wrong with Set(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).<br>&gt; <br>&gt; On Tuesday, 19 January 2016, Seth Friedman via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; I dig the idea of Sets having a literal syntax, rather than continuing to be the ugly stepchild of CollectionTypes. I&#39;m not sure, though, that this particular literal syntax is very obvious. While the Array and Dictionary syntaxes are similar enough to many other languages in which arrays and maps exist, I might be confused if I saw your proposed syntax in Swift. <br>&gt; <br>&gt; Not to mention that it&#39;s not the prettiest syntax, but that&#39;s more subjective.<br>&gt; <br>&gt; On Mon, Jan 18, 2016 at 1:24 PM, Michael Henson via swift-evolution &lt;swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt; Swift currently has literal and type shorthand syntax for native Array and Dictionary types, but not the Set type. It would be useful to have a literal shorthand for Set as well.<br>&gt; <br>&gt; The existing productions for array and dictionary literals and types share brackets as delimiters, differing only in the contents between the brackets. That poses a slight problem for Set because any syntax, to be useful, must also be easily distinguishable from the other types.<br>&gt; <br>&gt; Consider that Arrays and Dictionaries are both naturally indexed collections. Arrays by the integer value of the order of items in the collection, usually implicitly, and Dictionaries by the hashed key associated with each value.<br>&gt; <br>&gt; Arrays, implicit index:<br>&gt; <br>&gt; let array = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]<br>&gt; var array: [String]<br>&gt; var empty: [String] = []<br>&gt; <br>&gt; Dictionaries, explicit index:<br>&gt; <br>&gt; let dictionary = [&quot;a&quot;: 1, &quot;b&quot;: 5, &quot;c&quot;: 9]<br>&gt; var dictionary: [String: Int]<br>&gt; var empty: [String: Int] = [:]<br>&gt; <br>&gt; Sets, by contrast, have no particular order and no &quot;key&quot;. Even though the Set is enumerable and iterable, it isn&#39;t indexed. With that in mind, we can declare that a Set literal or Set type literal should distinguish itself by declaring that it has no index.<br>&gt; <br>&gt; The Set literal could be:<br>&gt; <br>&gt; let set = [ _: &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]<br>&gt; var set = [ _: String ]<br>&gt; var empty: [ _: String ] = [_:]<br>&gt; <br>&gt; In the grammar:<br>&gt; <br>&gt; set-literal -&gt; [ _ : array-literal-items[opt] ]<br>&gt; literal-expression -&gt; array-literal | dictionary-literal | set-literal<br>&gt; <br>&gt; set-type -&gt; [ _ : type ]<br>&gt; type -&gt; array-type | dictionary-type | set-type | ... etc.<br>&gt; <br>&gt; <br>&gt; Examples:<br>&gt; <br>&gt; let x = [ _: &quot;A&quot;, &quot;B&quot;, &quot;C&quot; ]<br>&gt; let y: [ _: String ] = [ _: ]<br>&gt; <br>&gt; <br>&gt; Alternatives considered:<br>&gt; <br>&gt; Without literals, declaring a Set type is straightforward, easy to recognize, and not much more verbose. There might not be enough of a difference to justify special syntax in the core language.<br>&gt; <br>&gt; Mike<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Seth Friedman<br>&gt; Software Development Engineer II<br>&gt; Amazon.com<br>&gt; <br>&gt; <br>&gt; -- <br>&gt;   -- Howard.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160118/8acd8122/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Proposal] Set literal and Set type syntax</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January 19, 2016 at 09:00:00am</p></header><div class="content"><p>Thanks for the correction and I agree that removing the argument label<br>would be a good idea.<br></p><p>On Tuesday, 19 January 2016, Liam Butler-Lawrence &lt;liamdunn at me.com&gt; wrote:<br></p><p>&gt; Set(&quot;a&quot;, &quot;b&quot;, &quot;c”) doesn’t compile. It currently has to be  Set(arrayLiteral:<br>&gt; &quot;a&quot;, &quot;b&quot;, &quot;c”). That said, I’d be satisfied with removing the external<br>&gt; parameter name “arrayLiteral”. Not only is it unnecessary, but it’s<br>&gt; confusing too: variadic parameters are not the same as an Array.<br>&gt;<br>&gt; Liam<br>&gt;<br>&gt; On Jan 18, 2016, at 5:43 PM, Howard Lovatt via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt; Sorry -1 from me. Doesn&#39;t seem worth it. Not much wrong with Set(&quot;a&quot;, &quot;b&quot;,<br>&gt; &quot;c&quot;).<br>&gt;<br>&gt; On Tuesday, 19 January 2016, Seth Friedman via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt;&gt; I dig the idea of Sets having a literal syntax, rather than continuing to<br>&gt;&gt; be the ugly stepchild of CollectionTypes. I&#39;m not sure, though, that this<br>&gt;&gt; particular literal syntax is very obvious. While the Array and Dictionary<br>&gt;&gt; syntaxes are similar enough to many other languages in which arrays and<br>&gt;&gt; maps exist, I might be confused if I saw your proposed syntax in Swift.<br>&gt;&gt;<br>&gt;&gt; Not to mention that it&#39;s not the prettiest syntax, but that&#39;s more<br>&gt;&gt; subjective.<br>&gt;&gt;<br>&gt;&gt; On Mon, Jan 18, 2016 at 1:24 PM, Michael Henson via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Swift currently has literal and type shorthand syntax for native Array<br>&gt;&gt;&gt; and Dictionary types, but not the Set type. It would be useful to have a<br>&gt;&gt;&gt; literal shorthand for Set as well.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The existing productions for array and dictionary literals and types<br>&gt;&gt;&gt; share brackets as delimiters, differing only in the contents between the<br>&gt;&gt;&gt; brackets. That poses a slight problem for Set because any syntax, to be<br>&gt;&gt;&gt; useful, must also be easily distinguishable from the other types.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Consider that Arrays and Dictionaries are both naturally indexed<br>&gt;&gt;&gt; collections. Arrays by the integer value of the order of items in the<br>&gt;&gt;&gt; collection, usually implicitly, and Dictionaries by the hashed key<br>&gt;&gt;&gt; associated with each value.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Arrays, implicit index:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let array = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]<br>&gt;&gt;&gt; var array: [String]<br>&gt;&gt;&gt; var empty: [String] = []<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Dictionaries, explicit index:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let dictionary = [&quot;a&quot;: 1, &quot;b&quot;: 5, &quot;c&quot;: 9]<br>&gt;&gt;&gt; var dictionary: [String: Int]<br>&gt;&gt;&gt; var empty: [String: Int] = [:]<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Sets, by contrast, have no particular order and no &quot;key&quot;. Even though<br>&gt;&gt;&gt; the Set is enumerable and iterable, it isn&#39;t indexed. With that in mind, we<br>&gt;&gt;&gt; can declare that a Set literal or Set type literal should distinguish<br>&gt;&gt;&gt; itself by declaring that it has no index.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The Set literal could be:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let set = [ _: &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]<br>&gt;&gt;&gt; var set = [ _: String ]<br>&gt;&gt;&gt; var empty: [ _: String ] = [_:]<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In the grammar:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; set-literal -&gt; [ _ : array-literal-items[opt] ]<br>&gt;&gt;&gt; literal-expression -&gt; array-literal | dictionary-literal | set-literal<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; set-type -&gt; [ _ : type ]<br>&gt;&gt;&gt; type -&gt; array-type | dictionary-type | set-type | ... etc.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Examples:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let x = [ _: &quot;A&quot;, &quot;B&quot;, &quot;C&quot; ]<br>&gt;&gt;&gt; let y: [ _: String ] = [ _: ]<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Alternatives considered:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Without literals, declaring a Set type is straightforward, easy to<br>&gt;&gt;&gt; recognize, and not much more verbose. There might not be enough of a<br>&gt;&gt;&gt; difference to justify special syntax in the core language.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Mike<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Seth Friedman<br>&gt;&gt; *Software Development Engineer II*<br>&gt;&gt; *Amazon.com &lt;http://amazon.com&gt;*<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt;   -- Howard.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br></p><p>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160119/935fec23/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ec21faaf010581d3b9d6ef507644e622?s=50"></div><header><strong>[Proposal] Set literal and Set type syntax</strong> from <string>Jack Lawrence</string> &lt;jackl at apple.com&gt;<p>January 18, 2016 at 02:00:00pm</p></header><div class="content"><p>init(arrayLiteral:) is there to satisfy ArrayLiteralConvertible. Set([“a”, “b”, “c”]) works just fine.<br></p><p>Jack<br>&gt; On Jan 18, 2016, at 2:50 PM, Liam Butler-Lawrence via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Set(&quot;a&quot;, &quot;b&quot;, &quot;c”) doesn’t compile. It currently has to be  Set(arrayLiteral: &quot;a&quot;, &quot;b&quot;, &quot;c”). That said, I’d be satisfied with removing the external parameter name “arrayLiteral”. Not only is it unnecessary, but it’s confusing too: variadic parameters are not the same as an Array.<br>&gt; <br>&gt; Liam<br>&gt; <br>&gt;&gt; On Jan 18, 2016, at 5:43 PM, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Sorry -1 from me. Doesn&#39;t seem worth it. Not much wrong with Set(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).<br>&gt;&gt; <br>&gt;&gt; On Tuesday, 19 January 2016, Seth Friedman via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; I dig the idea of Sets having a literal syntax, rather than continuing to be the ugly stepchild of CollectionTypes. I&#39;m not sure, though, that this particular literal syntax is very obvious. While the Array and Dictionary syntaxes are similar enough to many other languages in which arrays and maps exist, I might be confused if I saw your proposed syntax in Swift. <br>&gt;&gt; <br>&gt;&gt; Not to mention that it&#39;s not the prettiest syntax, but that&#39;s more subjective.<br>&gt;&gt; <br>&gt;&gt; On Mon, Jan 18, 2016 at 1:24 PM, Michael Henson via swift-evolution &lt;swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;&gt; Swift currently has literal and type shorthand syntax for native Array and Dictionary types, but not the Set type. It would be useful to have a literal shorthand for Set as well.<br>&gt;&gt; <br>&gt;&gt; The existing productions for array and dictionary literals and types share brackets as delimiters, differing only in the contents between the brackets. That poses a slight problem for Set because any syntax, to be useful, must also be easily distinguishable from the other types.<br>&gt;&gt; <br>&gt;&gt; Consider that Arrays and Dictionaries are both naturally indexed collections. Arrays by the integer value of the order of items in the collection, usually implicitly, and Dictionaries by the hashed key associated with each value.<br>&gt;&gt; <br>&gt;&gt; Arrays, implicit index:<br>&gt;&gt; <br>&gt;&gt; let array = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]<br>&gt;&gt; var array: [String]<br>&gt;&gt; var empty: [String] = []<br>&gt;&gt; <br>&gt;&gt; Dictionaries, explicit index:<br>&gt;&gt; <br>&gt;&gt; let dictionary = [&quot;a&quot;: 1, &quot;b&quot;: 5, &quot;c&quot;: 9]<br>&gt;&gt; var dictionary: [String: Int]<br>&gt;&gt; var empty: [String: Int] = [:]<br>&gt;&gt; <br>&gt;&gt; Sets, by contrast, have no particular order and no &quot;key&quot;. Even though the Set is enumerable and iterable, it isn&#39;t indexed. With that in mind, we can declare that a Set literal or Set type literal should distinguish itself by declaring that it has no index.<br>&gt;&gt; <br>&gt;&gt; The Set literal could be:<br>&gt;&gt; <br>&gt;&gt; let set = [ _: &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]<br>&gt;&gt; var set = [ _: String ]<br>&gt;&gt; var empty: [ _: String ] = [_:]<br>&gt;&gt; <br>&gt;&gt; In the grammar:<br>&gt;&gt; <br>&gt;&gt; set-literal -&gt; [ _ : array-literal-items[opt] ]<br>&gt;&gt; literal-expression -&gt; array-literal | dictionary-literal | set-literal<br>&gt;&gt; <br>&gt;&gt; set-type -&gt; [ _ : type ]<br>&gt;&gt; type -&gt; array-type | dictionary-type | set-type | ... etc.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Examples:<br>&gt;&gt; <br>&gt;&gt; let x = [ _: &quot;A&quot;, &quot;B&quot;, &quot;C&quot; ]<br>&gt;&gt; let y: [ _: String ] = [ _: ]<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Alternatives considered:<br>&gt;&gt; <br>&gt;&gt; Without literals, declaring a Set type is straightforward, easy to recognize, and not much more verbose. There might not be enough of a difference to justify special syntax in the core language.<br>&gt;&gt; <br>&gt;&gt; Mike<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Seth Friedman<br>&gt;&gt; Software Development Engineer II<br>&gt;&gt; Amazon.com &lt;http://amazon.com/&gt;<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt;   -- Howard.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160118/edc99fc6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Proposal] Set literal and Set type syntax</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January 19, 2016 at 09:00:00am</p></header><div class="content"><p>Sure, but you could add another overload without the label.<br></p><p>On Tuesday, 19 January 2016, Jack Lawrence &lt;jackl at apple.com&gt; wrote:<br></p><p>&gt; init(arrayLiteral:) is there to satisfy ArrayLiteralConvertible. Set([“a”,<br>&gt; “b”, “c”]) works just fine.<br>&gt;<br>&gt; Jack<br>&gt;<br>&gt; On Jan 18, 2016, at 2:50 PM, Liam Butler-Lawrence via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt; Set(&quot;a&quot;, &quot;b&quot;, &quot;c”) doesn’t compile. It currently has to be  Set(arrayLiteral:<br>&gt; &quot;a&quot;, &quot;b&quot;, &quot;c”). That said, I’d be satisfied with removing the external<br>&gt; parameter name “arrayLiteral”. Not only is it unnecessary, but it’s<br>&gt; confusing too: variadic parameters are not the same as an Array.<br>&gt;<br>&gt; Liam<br>&gt;<br>&gt; On Jan 18, 2016, at 5:43 PM, Howard Lovatt via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt; Sorry -1 from me. Doesn&#39;t seem worth it. Not much wrong with Set(&quot;a&quot;, &quot;b&quot;,<br>&gt; &quot;c&quot;).<br>&gt;<br>&gt; On Tuesday, 19 January 2016, Seth Friedman via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt;&gt; I dig the idea of Sets having a literal syntax, rather than continuing to<br>&gt;&gt; be the ugly stepchild of CollectionTypes. I&#39;m not sure, though, that this<br>&gt;&gt; particular literal syntax is very obvious. While the Array and Dictionary<br>&gt;&gt; syntaxes are similar enough to many other languages in which arrays and<br>&gt;&gt; maps exist, I might be confused if I saw your proposed syntax in Swift.<br>&gt;&gt;<br>&gt;&gt; Not to mention that it&#39;s not the prettiest syntax, but that&#39;s more<br>&gt;&gt; subjective.<br>&gt;&gt;<br>&gt;&gt; On Mon, Jan 18, 2016 at 1:24 PM, Michael Henson via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Swift currently has literal and type shorthand syntax for native Array<br>&gt;&gt;&gt; and Dictionary types, but not the Set type. It would be useful to have a<br>&gt;&gt;&gt; literal shorthand for Set as well.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The existing productions for array and dictionary literals and types<br>&gt;&gt;&gt; share brackets as delimiters, differing only in the contents between the<br>&gt;&gt;&gt; brackets. That poses a slight problem for Set because any syntax, to be<br>&gt;&gt;&gt; useful, must also be easily distinguishable from the other types.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Consider that Arrays and Dictionaries are both naturally indexed<br>&gt;&gt;&gt; collections. Arrays by the integer value of the order of items in the<br>&gt;&gt;&gt; collection, usually implicitly, and Dictionaries by the hashed key<br>&gt;&gt;&gt; associated with each value.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Arrays, implicit index:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let array = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]<br>&gt;&gt;&gt; var array: [String]<br>&gt;&gt;&gt; var empty: [String] = []<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Dictionaries, explicit index:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let dictionary = [&quot;a&quot;: 1, &quot;b&quot;: 5, &quot;c&quot;: 9]<br>&gt;&gt;&gt; var dictionary: [String: Int]<br>&gt;&gt;&gt; var empty: [String: Int] = [:]<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Sets, by contrast, have no particular order and no &quot;key&quot;. Even though<br>&gt;&gt;&gt; the Set is enumerable and iterable, it isn&#39;t indexed. With that in mind, we<br>&gt;&gt;&gt; can declare that a Set literal or Set type literal should distinguish<br>&gt;&gt;&gt; itself by declaring that it has no index.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The Set literal could be:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let set = [ _: &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]<br>&gt;&gt;&gt; var set = [ _: String ]<br>&gt;&gt;&gt; var empty: [ _: String ] = [_:]<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In the grammar:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; set-literal -&gt; [ _ : array-literal-items[opt] ]<br>&gt;&gt;&gt; literal-expression -&gt; array-literal | dictionary-literal | set-literal<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; set-type -&gt; [ _ : type ]<br>&gt;&gt;&gt; type -&gt; array-type | dictionary-type | set-type | ... etc.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Examples:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let x = [ _: &quot;A&quot;, &quot;B&quot;, &quot;C&quot; ]<br>&gt;&gt;&gt; let y: [ _: String ] = [ _: ]<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Alternatives considered:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Without literals, declaring a Set type is straightforward, easy to<br>&gt;&gt;&gt; recognize, and not much more verbose. There might not be enough of a<br>&gt;&gt;&gt; difference to justify special syntax in the core language.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Mike<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Seth Friedman<br>&gt;&gt; *Software Development Engineer II*<br>&gt;&gt; *Amazon.com &lt;http://amazon.com/&gt;*<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt;   -- Howard.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br></p><p>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160119/9e23438f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>[Proposal] Set literal and Set type syntax</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>January 19, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jan 18, 2016, at 2:55 PM, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Tuesday, 19 January 2016, Jack Lawrence &lt;jackl at apple.com &lt;mailto:jackl at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 18, 2016, at 2:50 PM, Liam Butler-Lawrence via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Set(&quot;a&quot;, &quot;b&quot;, &quot;c”) doesn’t compile. It currently has to be  Set(arrayLiteral: &quot;a&quot;, &quot;b&quot;, &quot;c”). That said, I’d be satisfied with removing the external parameter name “arrayLiteral”. Not only is it unnecessary, but it’s confusing too: variadic parameters are not the same as an Array.<br>&gt;&gt; <br>&gt;&gt; init(arrayLiteral:) is there to satisfy ArrayLiteralConvertible. Set([“a”, “b”, “c”]) works just fine.<br>&gt; <br></p><p>&gt; Sure, but you could add another overload without the label.<br></p><p><br>Only if you break existing code. Consider this expression:<br></p><p>    Set([&quot;a&quot;, &quot;b&quot;])<br></p><p>Is this<br>1. a Set&lt;String&gt; with two elements &quot;a&quot; and &quot;b&quot;<br>2. a Set&lt;Array&lt;String&gt;&gt; with one element [&quot;a&quot;, &quot;b&quot;]<br></p><p>Currently it means #1. You could change it to mean #2, but that breaks existing code that expects #1. You could try to overload the no-name initializer, but that will be confusing to humans in some cases.<br></p><p><br>-- <br>Greg Parker     gparker at apple.com     Runtime Wrangler<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160119/748a264d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Proposal] Set literal and Set type syntax</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>January 19, 2016 at 05:00:00pm</p></header><div class="content"><p>I agree that the probably isn&#39;t a better story for literals and Sets and<br>that I wish that there were a better story.<br></p><p>The best that I can think of is some sort of flag outside of the Array<br>literal, for instance, #[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;] or just using keys that people<br>aren&#39;t already accustomed to like option-&#39;\&#39; and option-shift-&#39;\&#39;.  «&quot;A&quot;,<br>&quot;B&quot;, &quot;C&quot;]»<br></p><p><br>TJ<br></p><p>On Tue, Jan 19, 2016 at 4:55 PM, Greg Parker via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Jan 18, 2016, at 2:55 PM, Howard Lovatt via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Tuesday, 19 January 2016, Jack Lawrence &lt;jackl at apple.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Jan 18, 2016, at 2:50 PM, Liam Butler-Lawrence via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; Set(&quot;a&quot;, &quot;b&quot;, &quot;c”) doesn’t compile. It currently has to be<br>&gt;  Set(arrayLiteral: &quot;a&quot;, &quot;b&quot;, &quot;c”). That said, I’d be satisfied with<br>&gt; removing the external parameter name “arrayLiteral”. Not only is it<br>&gt; unnecessary, but it’s confusing too: variadic parameters are not the same<br>&gt; as an Array.<br>&gt;<br>&gt;<br>&gt; init(arrayLiteral:) is there to satisfy ArrayLiteralConvertible. Set([“a”,<br>&gt; “b”, “c”]) works just fine.<br>&gt;<br>&gt;<br>&gt; Sure, but you could add another overload without the label.<br>&gt;<br>&gt;<br>&gt; Only if you break existing code. Consider this expression:<br>&gt;<br>&gt;     Set([&quot;a&quot;, &quot;b&quot;])<br>&gt;<br>&gt; Is this<br>&gt; 1. a Set&lt;String&gt; with two elements &quot;a&quot; and &quot;b&quot;<br>&gt; 2. a Set&lt;Array&lt;String&gt;&gt; with one element [&quot;a&quot;, &quot;b&quot;]<br>&gt;<br>&gt; Currently it means #1. You could change it to mean #2, but that breaks<br>&gt; existing code that expects #1. You could try to overload the no-name<br>&gt; initializer, but that will be confusing to humans in some cases.<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Greg Parker     gparker at apple.com     Runtime Wrangler<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160119/ed34ab28/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>[Proposal] Set literal and Set type syntax</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>January 19, 2016 at 11:00:00pm</p></header><div class="content"><p>What about the mathematical Set notation?:<br></p><p>let numbers = {3, 1, 4, 1, 5, 9, 2, 6, 5, 3}<br></p><p>But this is highly ambiguous in those cases:<br>let numbers = {} // closure ()-&gt;()<br>let numbers = {3} // closure ()-&gt;Int<br></p><p>So a type annotation is still needed at least for empty Sets and single element ones. There could be also some difficulties while parsing the swift file.<br></p><p>As some others have said I&#39;m not sure whether such additional syntax pays off.<br></p><p>- Maximilian<br></p><p>&gt; Am 19.01.2016 um 23:00 schrieb T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; I agree that the probably isn&#39;t a better story for literals and Sets and that I wish that there were a better story.<br>&gt; <br>&gt; The best that I can think of is some sort of flag outside of the Array literal, for instance, #[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;] or just using keys that people aren&#39;t already accustomed to like option-&#39;\&#39; and option-shift-&#39;\&#39;.  «&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]»<br>&gt; <br>&gt; <br>&gt; TJ<br>&gt; <br>&gt;&gt; On Tue, Jan 19, 2016 at 4:55 PM, Greg Parker via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 18, 2016, at 2:55 PM, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Tuesday, 19 January 2016, Jack Lawrence &lt;jackl at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 18, 2016, at 2:50 PM, Liam Butler-Lawrence via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Set(&quot;a&quot;, &quot;b&quot;, &quot;c”) doesn’t compile. It currently has to be  Set(arrayLiteral: &quot;a&quot;, &quot;b&quot;, &quot;c”). That said, I’d be satisfied with removing the external parameter name “arrayLiteral”. Not only is it unnecessary, but it’s confusing too: variadic parameters are not the same as an Array.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; init(arrayLiteral:) is there to satisfy ArrayLiteralConvertible. Set([“a”, “b”, “c”]) works just fine.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Sure, but you could add another overload without the label.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Only if you break existing code. Consider this expression:<br>&gt;&gt; <br>&gt;&gt;     Set([&quot;a&quot;, &quot;b&quot;])<br>&gt;&gt; <br>&gt;&gt; Is this<br>&gt;&gt; 1. a Set&lt;String&gt; with two elements &quot;a&quot; and &quot;b&quot;<br>&gt;&gt; 2. a Set&lt;Array&lt;String&gt;&gt; with one element [&quot;a&quot;, &quot;b&quot;]<br>&gt;&gt; <br>&gt;&gt; Currently it means #1. You could change it to mean #2, but that breaks existing code that expects #1. You could try to overload the no-name initializer, but that will be confusing to humans in some cases.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Greg Parker     gparker at apple.com     Runtime Wrangler<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160119/2b2c57bd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>[Proposal] Set literal and Set type syntax</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>January 20, 2016 at 10:00:00am</p></header><div class="content"><p>This also works (currently):<br>    [1, 2] as Set<br></p><p>I think this is unambiguous, works with lots of things and doesn&#39;t need<br>to introduce new Set-specific syntax. The downside is that it&#39;s slightly<br>more verbose. I generally don&#39;t use Set literals often, and when I do it&#39;s<br>as a static let; so I don&#39;t consider the extra few characters from this<br>expression to be an issue.<br></p><p>If you can represent it concisely with an existing literal type then I<br>think it&#39;s worthwhile doing that, it keeps the language simple.<br></p><p>Andrew<br></p><p>On Wed, Jan 20, 2016 at 9:31 AM, Maximilian Hünenberger &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; What about the mathematical Set notation?:<br>&gt;<br>&gt; let numbers = {3, 1, 4, 1, 5, 9, 2, 6, 5, 3}<br>&gt;<br>&gt; But this is highly ambiguous in those cases:<br>&gt; let numbers = {} // closure ()-&gt;()<br>&gt; let numbers = {3} // closure ()-&gt;Int<br>&gt;<br>&gt; So a type annotation is still needed at least for empty Sets and single<br>&gt; element ones. There could be also some difficulties while parsing the swift<br>&gt; file.<br>&gt;<br>&gt; As some others have said I&#39;m not sure whether such additional syntax pays<br>&gt; off.<br>&gt;<br>&gt; - Maximilian<br>&gt;<br>&gt; Am 19.01.2016 um 23:00 schrieb T.J. Usiyan via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt;<br>&gt; I agree that the probably isn&#39;t a better story for literals and Sets and<br>&gt; that I wish that there were a better story.<br>&gt;<br>&gt; The best that I can think of is some sort of flag outside of the Array<br>&gt; literal, for instance, #[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;] or just using keys that people<br>&gt; aren&#39;t already accustomed to like option-&#39;\&#39; and option-shift-&#39;\&#39;.  «&quot;A&quot;,<br>&gt; &quot;B&quot;, &quot;C&quot;]»<br>&gt;<br>&gt;<br>&gt; TJ<br>&gt;<br>&gt; On Tue, Jan 19, 2016 at 4:55 PM, Greg Parker via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Jan 18, 2016, at 2:55 PM, Howard Lovatt via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Tuesday, 19 January 2016, Jack Lawrence &lt;jackl at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Jan 18, 2016, at 2:50 PM, Liam Butler-Lawrence via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Set(&quot;a&quot;, &quot;b&quot;, &quot;c”) doesn’t compile. It currently has to be<br>&gt;&gt;  Set(arrayLiteral: &quot;a&quot;, &quot;b&quot;, &quot;c”). That said, I’d be satisfied with<br>&gt;&gt; removing the external parameter name “arrayLiteral”. Not only is it<br>&gt;&gt; unnecessary, but it’s confusing too: variadic parameters are not the same<br>&gt;&gt; as an Array.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; init(arrayLiteral:) is there to satisfy ArrayLiteralConvertible.<br>&gt;&gt; Set([“a”, “b”, “c”]) works just fine.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Sure, but you could add another overload without the label.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Only if you break existing code. Consider this expression:<br>&gt;&gt;<br>&gt;&gt;     Set([&quot;a&quot;, &quot;b&quot;])<br>&gt;&gt;<br>&gt;&gt; Is this<br>&gt;&gt; 1. a Set&lt;String&gt; with two elements &quot;a&quot; and &quot;b&quot;<br>&gt;&gt; 2. a Set&lt;Array&lt;String&gt;&gt; with one element [&quot;a&quot;, &quot;b&quot;]<br>&gt;&gt;<br>&gt;&gt; Currently it means #1. You could change it to mean #2, but that breaks<br>&gt;&gt; existing code that expects #1. You could try to overload the no-name<br>&gt;&gt; initializer, but that will be confusing to humans in some cases.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Greg Parker     gparker at apple.com     Runtime Wrangler<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160120/8ffe103b/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Proposal] Set literal and Set type syntax</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January 20, 2016 at 12:00:00pm</p></header><div class="content"><p>The horse has probably bolted on this one, but in general array literals<br>can be confusing when used for anything other than an array. A compromise<br>position might be to remove the array literal `init` from `Set` and replace<br>it with a var arg `init`. It would break code, but not that much since<br>`Set` is new and a migration tool could find it easily. This gives:<br></p><p>    let sI = Set(1) // Set of Int<br>    let sAI = Set([1]) // Set of array of Int<br></p><p>On Wednesday, 20 January 2016, Greg Parker &lt;gparker at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Jan 18, 2016, at 2:55 PM, Howard Lovatt via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt; On Tuesday, 19 January 2016, Jack Lawrence &lt;jackl at apple.com<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;jackl at apple.com&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Jan 18, 2016, at 2:50 PM, Liam Butler-Lawrence via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt;<br>&gt; Set(&quot;a&quot;, &quot;b&quot;, &quot;c”) doesn’t compile. It currently has to be<br>&gt;  Set(arrayLiteral: &quot;a&quot;, &quot;b&quot;, &quot;c”). That said, I’d be satisfied with<br>&gt; removing the external parameter name “arrayLiteral”. Not only is it<br>&gt; unnecessary, but it’s confusing too: variadic parameters are not the same<br>&gt; as an Array.<br>&gt;<br>&gt;<br>&gt; init(arrayLiteral:) is there to satisfy ArrayLiteralConvertible. Set([“a”,<br>&gt; “b”, “c”]) works just fine.<br>&gt;<br>&gt;<br>&gt; Sure, but you could add another overload without the label.<br>&gt;<br>&gt;<br>&gt; Only if you break existing code. Consider this expression:<br>&gt;<br>&gt;     Set([&quot;a&quot;, &quot;b&quot;])<br>&gt;<br>&gt; Is this<br>&gt; 1. a Set&lt;String&gt; with two elements &quot;a&quot; and &quot;b&quot;<br>&gt; 2. a Set&lt;Array&lt;String&gt;&gt; with one element [&quot;a&quot;, &quot;b&quot;]<br>&gt;<br>&gt; Currently it means #1. You could change it to mean #2, but that breaks<br>&gt; existing code that expects #1. You could try to overload the no-name<br>&gt; initializer, but that will be confusing to humans in some cases.<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Greg Parker     gparker at apple.com<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;gparker at apple.com&#39;);&gt;     Runtime Wrangler<br>&gt;<br>&gt;<br>&gt;<br></p><p>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160120/ac260b41/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[Proposal] Set literal and Set type syntax</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>January 19, 2016 at 09:00:00pm</p></header><div class="content"><p>Keep in mind Array&lt;T&gt; cannot currently be stored in a Set (it will bridge to NSArray if the contained elements are compatible, which then supports Hashable.)<br></p><p>The non-labelled initializer expects a formed SequenceType.<br></p><p>If you want to use varargs, you can use Set(arrayLiteral:[1], [2], [3]) - so no removal of the array literal convertible conformance needed, it does what you want already<br></p><p>-DW<br> <br>&gt; On Jan 19, 2016, at 6:56 PM, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The horse has probably bolted on this one, but in general array literals can be confusing when used for anything other than an array. A compromise position might be to remove the array literal `init` from `Set` and replace it with a var arg `init`. It would break code, but not that much since `Set` is new and a migration tool could find it easily. This gives:<br>&gt; <br>&gt;     let sI = Set(1) // Set of Int<br>&gt;     let sAI = Set([1]) // Set of array of Int<br>&gt; <br>&gt; On Wednesday, 20 January 2016, Greg Parker &lt;gparker at apple.com &lt;mailto:gparker at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 18, 2016, at 2:55 PM, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org &lt;&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Tuesday, 19 January 2016, Jack Lawrence &lt;jackl at apple.com &lt;&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 18, 2016, at 2:50 PM, Liam Butler-Lawrence via swift-evolution &lt;swift-evolution at swift.org &lt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Set(&quot;a&quot;, &quot;b&quot;, &quot;c”) doesn’t compile. It currently has to be  Set(arrayLiteral: &quot;a&quot;, &quot;b&quot;, &quot;c”). That said, I’d be satisfied with removing the external parameter name “arrayLiteral”. Not only is it unnecessary, but it’s confusing too: variadic parameters are not the same as an Array.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; init(arrayLiteral:) is there to satisfy ArrayLiteralConvertible. Set([“a”, “b”, “c”]) works just fine.<br>&gt;&gt; <br>&gt; <br>&gt;&gt; Sure, but you could add another overload without the label.<br>&gt; <br>&gt; <br>&gt; Only if you break existing code. Consider this expression:<br>&gt; <br>&gt;     Set([&quot;a&quot;, &quot;b&quot;])<br>&gt; <br>&gt; Is this<br>&gt; 1. a Set&lt;String&gt; with two elements &quot;a&quot; and &quot;b&quot;<br>&gt; 2. a Set&lt;Array&lt;String&gt;&gt; with one element [&quot;a&quot;, &quot;b&quot;]<br>&gt; <br>&gt; Currently it means #1. You could change it to mean #2, but that breaks existing code that expects #1. You could try to overload the no-name initializer, but that will be confusing to humans in some cases.<br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Greg Parker     gparker at apple.com &lt;&gt;     Runtime Wrangler<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt;   -- Howard.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160119/658c19ed/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Proposal] Set literal and Set type syntax</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January 21, 2016 at 10:00:00am</p></header><div class="content"><p>Sure, as I said I think the horse has bolted on this one and as you<br>correctly point out you can get round the problem. Its just not as neat as<br>just having a var arg initialiser and no array literal initialiser.<br></p><p>On 20 January 2016 at 15:59, David Waite &lt;david at alkaline-solutions.com&gt;<br>wrote:<br></p><p>&gt; Keep in mind Array&lt;T&gt; cannot currently be stored in a Set (it will bridge<br>&gt; to NSArray if the contained elements are compatible, which then supports<br>&gt; Hashable.)<br>&gt;<br>&gt; The non-labelled initializer expects a formed SequenceType.<br>&gt;<br>&gt; If you want to use varargs, you can use Set(arrayLiteral:[1], [2], [3]) -<br>&gt; so no removal of the array literal convertible conformance needed, it does<br>&gt; what you want already<br>&gt;<br>&gt; -DW<br>&gt;<br>&gt;<br>&gt; On Jan 19, 2016, at 6:56 PM, Howard Lovatt via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; The horse has probably bolted on this one, but in general array literals<br>&gt; can be confusing when used for anything other than an array. A compromise<br>&gt; position might be to remove the array literal `init` from `Set` and replace<br>&gt; it with a var arg `init`. It would break code, but not that much since<br>&gt; `Set` is new and a migration tool could find it easily. This gives:<br>&gt;<br>&gt;     let sI = Set(1) // Set of Int<br>&gt;     let sAI = Set([1]) // Set of array of Int<br>&gt;<br>&gt; On Wednesday, 20 January 2016, Greg Parker &lt;gparker at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Jan 18, 2016, at 2:55 PM, Howard Lovatt via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Tuesday, 19 January 2016, Jack Lawrence &lt;jackl at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Jan 18, 2016, at 2:50 PM, Liam Butler-Lawrence via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Set(&quot;a&quot;, &quot;b&quot;, &quot;c”) doesn’t compile. It currently has to be<br>&gt;&gt;  Set(arrayLiteral: &quot;a&quot;, &quot;b&quot;, &quot;c”). That said, I’d be satisfied with<br>&gt;&gt; removing the external parameter name “arrayLiteral”. Not only is it<br>&gt;&gt; unnecessary, but it’s confusing too: variadic parameters are not the same<br>&gt;&gt; as an Array.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; init(arrayLiteral:) is there to satisfy ArrayLiteralConvertible.<br>&gt;&gt; Set([“a”, “b”, “c”]) works just fine.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Sure, but you could add another overload without the label.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Only if you break existing code. Consider this expression:<br>&gt;&gt;<br>&gt;&gt;     Set([&quot;a&quot;, &quot;b&quot;])<br>&gt;&gt;<br>&gt;&gt; Is this<br>&gt;&gt; 1. a Set&lt;String&gt; with two elements &quot;a&quot; and &quot;b&quot;<br>&gt;&gt; 2. a Set&lt;Array&lt;String&gt;&gt; with one element [&quot;a&quot;, &quot;b&quot;]<br>&gt;&gt;<br>&gt;&gt; Currently it means #1. You could change it to mean #2, but that breaks<br>&gt;&gt; existing code that expects #1. You could try to overload the no-name<br>&gt;&gt; initializer, but that will be confusing to humans in some cases.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Greg Parker     gparker at apple.com     Runtime Wrangler<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; --<br>&gt;   -- Howard.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br></p><p><br>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160121/89ec9ca4/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ec21faaf010581d3b9d6ef507644e622?s=50"></div><header><strong>[Proposal] Set literal and Set type syntax</strong> from <string>Jack Lawrence</string> &lt;jackl at apple.com&gt;<p>January 18, 2016 at 02:00:00pm</p></header><div class="content"><p>It doesn’t seem like a big enough win over:<br></p><p>let x: Set = [1, 2, 3, 4] // x inferred to be Set&lt;Int&gt;<br></p><p>Especially since sets are used so infrequently compared to Array and Dictionary.<br>Jack<br>&gt; On Jan 18, 2016, at 1:24 PM, Michael Henson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Swift currently has literal and type shorthand syntax for native Array and Dictionary types, but not the Set type. It would be useful to have a literal shorthand for Set as well.<br>&gt; <br>&gt; The existing productions for array and dictionary literals and types share brackets as delimiters, differing only in the contents between the brackets. That poses a slight problem for Set because any syntax, to be useful, must also be easily distinguishable from the other types.<br>&gt; <br>&gt; Consider that Arrays and Dictionaries are both naturally indexed collections. Arrays by the integer value of the order of items in the collection, usually implicitly, and Dictionaries by the hashed key associated with each value.<br>&gt; <br>&gt; Arrays, implicit index:<br>&gt; <br>&gt; let array = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]<br>&gt; var array: [String]<br>&gt; var empty: [String] = []<br>&gt; <br>&gt; Dictionaries, explicit index:<br>&gt; <br>&gt; let dictionary = [&quot;a&quot;: 1, &quot;b&quot;: 5, &quot;c&quot;: 9]<br>&gt; var dictionary: [String: Int]<br>&gt; var empty: [String: Int] = [:]<br>&gt; <br>&gt; Sets, by contrast, have no particular order and no &quot;key&quot;. Even though the Set is enumerable and iterable, it isn&#39;t indexed. With that in mind, we can declare that a Set literal or Set type literal should distinguish itself by declaring that it has no index.<br>&gt; <br>&gt; The Set literal could be:<br>&gt; <br>&gt; let set = [ _: &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]<br>&gt; var set = [ _: String ]<br>&gt; var empty: [ _: String ] = [_:]<br>&gt; <br>&gt; In the grammar:<br>&gt; <br>&gt; set-literal -&gt; [ _ : array-literal-items[opt] ]<br>&gt; literal-expression -&gt; array-literal | dictionary-literal | set-literal<br>&gt; <br>&gt; set-type -&gt; [ _ : type ]<br>&gt; type -&gt; array-type | dictionary-type | set-type | ... etc.<br>&gt; <br>&gt; <br>&gt; Examples:<br>&gt; <br>&gt; let x = [ _: &quot;A&quot;, &quot;B&quot;, &quot;C&quot; ]<br>&gt; let y: [ _: String ] = [ _: ]<br>&gt; <br>&gt; <br>&gt; Alternatives considered:<br>&gt; <br>&gt; Without literals, declaring a Set type is straightforward, easy to recognize, and not much more verbose. There might not be enough of a difference to justify special syntax in the core language.<br>&gt; <br>&gt; Mike<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/957b675456a66c394945a7361aedd51d?s=50"></div><header><strong>[Proposal] Set literal and Set type syntax</strong> from <string>Zhao Xin</string> &lt;owenzx at gmail.com&gt;<p>January 19, 2016 at 09:00:00am</p></header><div class="content"><p>I choose let x: Set = [1, 2, 3, 4] // x inferred to be Set&lt;Int&gt;. The<br>current way. Unless the output of print(a set) change its format.<br></p><p>zhaoxin<br></p><p>On Tue, Jan 19, 2016 at 6:51 AM, Jack Lawrence via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; It doesn’t seem like a big enough win over:<br>&gt;<br>&gt; let x: Set = [1, 2, 3, 4] // x inferred to be Set&lt;Int&gt;<br>&gt;<br>&gt; Especially since sets are used so infrequently compared to Array and<br>&gt; Dictionary.<br>&gt; Jack<br>&gt; &gt; On Jan 18, 2016, at 1:24 PM, Michael Henson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Swift currently has literal and type shorthand syntax for native Array<br>&gt; and Dictionary types, but not the Set type. It would be useful to have a<br>&gt; literal shorthand for Set as well.<br>&gt; &gt;<br>&gt; &gt; The existing productions for array and dictionary literals and types<br>&gt; share brackets as delimiters, differing only in the contents between the<br>&gt; brackets. That poses a slight problem for Set because any syntax, to be<br>&gt; useful, must also be easily distinguishable from the other types.<br>&gt; &gt;<br>&gt; &gt; Consider that Arrays and Dictionaries are both naturally indexed<br>&gt; collections. Arrays by the integer value of the order of items in the<br>&gt; collection, usually implicitly, and Dictionaries by the hashed key<br>&gt; associated with each value.<br>&gt; &gt;<br>&gt; &gt; Arrays, implicit index:<br>&gt; &gt;<br>&gt; &gt; let array = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]<br>&gt; &gt; var array: [String]<br>&gt; &gt; var empty: [String] = []<br>&gt; &gt;<br>&gt; &gt; Dictionaries, explicit index:<br>&gt; &gt;<br>&gt; &gt; let dictionary = [&quot;a&quot;: 1, &quot;b&quot;: 5, &quot;c&quot;: 9]<br>&gt; &gt; var dictionary: [String: Int]<br>&gt; &gt; var empty: [String: Int] = [:]<br>&gt; &gt;<br>&gt; &gt; Sets, by contrast, have no particular order and no &quot;key&quot;. Even though<br>&gt; the Set is enumerable and iterable, it isn&#39;t indexed. With that in mind, we<br>&gt; can declare that a Set literal or Set type literal should distinguish<br>&gt; itself by declaring that it has no index.<br>&gt; &gt;<br>&gt; &gt; The Set literal could be:<br>&gt; &gt;<br>&gt; &gt; let set = [ _: &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]<br>&gt; &gt; var set = [ _: String ]<br>&gt; &gt; var empty: [ _: String ] = [_:]<br>&gt; &gt;<br>&gt; &gt; In the grammar:<br>&gt; &gt;<br>&gt; &gt; set-literal -&gt; [ _ : array-literal-items[opt] ]<br>&gt; &gt; literal-expression -&gt; array-literal | dictionary-literal | set-literal<br>&gt; &gt;<br>&gt; &gt; set-type -&gt; [ _ : type ]<br>&gt; &gt; type -&gt; array-type | dictionary-type | set-type | ... etc.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Examples:<br>&gt; &gt;<br>&gt; &gt; let x = [ _: &quot;A&quot;, &quot;B&quot;, &quot;C&quot; ]<br>&gt; &gt; let y: [ _: String ] = [ _: ]<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Alternatives considered:<br>&gt; &gt;<br>&gt; &gt; Without literals, declaring a Set type is straightforward, easy to<br>&gt; recognize, and not much more verbose. There might not be enough of a<br>&gt; difference to justify special syntax in the core language.<br>&gt; &gt;<br>&gt; &gt; Mike<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160119/5f383182/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/32ed5b32826658f01df18fa220fa090e?s=50"></div><header><strong>[Proposal] Set literal and Set type syntax</strong> from <string>Haravikk</string> &lt;me at haravikk.com&gt;<p>January 19, 2016 at 09:00:00am</p></header><div class="content"><p>Same here, as you long as you specify Set as a type then the standard array syntax works just fine, the only case in which it doesn’t work is when you want to do something like:<br></p><p>[1,2,3,4].someMethod()<br></p><p>But that isn’t usually a great way to use array/set constants anyway so I don’t think it’s a big deal.<br></p><p>A more interesting question IMO is whether we could extend the array syntax to apply to any sequence type, for example:<br></p><p>let mySequence:SomeProtocol = [1, 2, 3, 4]<br></p><p>i.e- could we add a protocol that Array and Set conform to in order to support that style of initialisation, that we could also apply to other types as well. Is that worth its own proposal?<br></p><p>&gt; On 19 Jan 2016, at 01:43, zhaoxin肇鑫 via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I choose let x: Set = [1, 2, 3, 4] // x inferred to be Set&lt;Int&gt;. The current way. Unless the output of print(a set) change its format.<br>&gt; <br>&gt; zhaoxin<br>&gt; <br>&gt; On Tue, Jan 19, 2016 at 6:51 AM, Jack Lawrence via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; It doesn’t seem like a big enough win over:<br>&gt; <br>&gt; let x: Set = [1, 2, 3, 4] // x inferred to be Set&lt;Int&gt;<br>&gt; <br>&gt; Especially since sets are used so infrequently compared to Array and Dictionary.<br>&gt; Jack<br>&gt; &gt; On Jan 18, 2016, at 1:24 PM, Michael Henson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Swift currently has literal and type shorthand syntax for native Array and Dictionary types, but not the Set type. It would be useful to have a literal shorthand for Set as well.<br>&gt; &gt;<br>&gt; &gt; The existing productions for array and dictionary literals and types share brackets as delimiters, differing only in the contents between the brackets. That poses a slight problem for Set because any syntax, to be useful, must also be easily distinguishable from the other types.<br>&gt; &gt;<br>&gt; &gt; Consider that Arrays and Dictionaries are both naturally indexed collections. Arrays by the integer value of the order of items in the collection, usually implicitly, and Dictionaries by the hashed key associated with each value.<br>&gt; &gt;<br>&gt; &gt; Arrays, implicit index:<br>&gt; &gt;<br>&gt; &gt; let array = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]<br>&gt; &gt; var array: [String]<br>&gt; &gt; var empty: [String] = []<br>&gt; &gt;<br>&gt; &gt; Dictionaries, explicit index:<br>&gt; &gt;<br>&gt; &gt; let dictionary = [&quot;a&quot;: 1, &quot;b&quot;: 5, &quot;c&quot;: 9]<br>&gt; &gt; var dictionary: [String: Int]<br>&gt; &gt; var empty: [String: Int] = [:]<br>&gt; &gt;<br>&gt; &gt; Sets, by contrast, have no particular order and no &quot;key&quot;. Even though the Set is enumerable and iterable, it isn&#39;t indexed. With that in mind, we can declare that a Set literal or Set type literal should distinguish itself by declaring that it has no index.<br>&gt; &gt;<br>&gt; &gt; The Set literal could be:<br>&gt; &gt;<br>&gt; &gt; let set = [ _: &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]<br>&gt; &gt; var set = [ _: String ]<br>&gt; &gt; var empty: [ _: String ] = [_:]<br>&gt; &gt;<br>&gt; &gt; In the grammar:<br>&gt; &gt;<br>&gt; &gt; set-literal -&gt; [ _ : array-literal-items[opt] ]<br>&gt; &gt; literal-expression -&gt; array-literal | dictionary-literal | set-literal<br>&gt; &gt;<br>&gt; &gt; set-type -&gt; [ _ : type ]<br>&gt; &gt; type -&gt; array-type | dictionary-type | set-type | ... etc.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Examples:<br>&gt; &gt;<br>&gt; &gt; let x = [ _: &quot;A&quot;, &quot;B&quot;, &quot;C&quot; ]<br>&gt; &gt; let y: [ _: String ] = [ _: ]<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Alternatives considered:<br>&gt; &gt;<br>&gt; &gt; Without literals, declaring a Set type is straightforward, easy to recognize, and not much more verbose. There might not be enough of a difference to justify special syntax in the core language.<br>&gt; &gt;<br>&gt; &gt; Mike<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160119/2eea079a/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: smime.p7s<br>Type: application/pkcs7-signature<br>Size: 1567 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160119/2eea079a/attachment.p7s&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/57885cfd0c4b4db16653e76d9e6f0266?s=50"></div><header><strong>[Proposal] Set literal and Set type syntax</strong> from <string>Johan Jensen</string> &lt;jj at johanjensen.dk&gt;<p>January 19, 2016 at 11:00:00am</p></header><div class="content"><p>Isn&#39;t that exactly what ArrayLiteralConvertible does?<br></p><p>extension CustomType: ArrayLiteralConvertible {<br>    typealias Element = Int<br>    init(arrayLiteral elements: Element...) {<br></p><p>    }<br>}<br></p><p>let c: CustomType = [1,2,3,4]<br></p><p><br>On Tue, Jan 19, 2016 at 10:18 AM, Haravikk via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Same here, as you long as you specify Set as a type then the standard<br>&gt; array syntax works just fine, the only case in which it doesn’t work is<br>&gt; when you want to do something like:<br>&gt;<br>&gt; [1,2,3,4].someMethod()<br>&gt;<br>&gt; But that isn’t usually a great way to use array/set constants anyway so I<br>&gt; don’t think it’s a big deal.<br>&gt;<br>&gt; A more interesting question IMO is whether we could extend the array<br>&gt; syntax to apply to any sequence type, for example:<br>&gt;<br>&gt; let mySequence:SomeProtocol = [1, 2, 3, 4]<br>&gt;<br>&gt; i.e- could we add a protocol that Array and Set conform to in order to<br>&gt; support that style of initialisation, that we could also apply to other<br>&gt; types as well. Is that worth its own proposal?<br>&gt;<br>&gt; On 19 Jan 2016, at 01:43, zhaoxin肇鑫 via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I choose let x: Set = [1, 2, 3, 4] // x inferred to be Set&lt;Int&gt;. The<br>&gt; current way. Unless the output of print(a set) change its format.<br>&gt;<br>&gt; zhaoxin<br>&gt;<br>&gt; On Tue, Jan 19, 2016 at 6:51 AM, Jack Lawrence via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; It doesn’t seem like a big enough win over:<br>&gt;&gt;<br>&gt;&gt; let x: Set = [1, 2, 3, 4] // x inferred to be Set&lt;Int&gt;<br>&gt;&gt;<br>&gt;&gt; Especially since sets are used so infrequently compared to Array and<br>&gt;&gt; Dictionary.<br>&gt;&gt; Jack<br>&gt;&gt; &gt; On Jan 18, 2016, at 1:24 PM, Michael Henson via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Swift currently has literal and type shorthand syntax for native Array<br>&gt;&gt; and Dictionary types, but not the Set type. It would be useful to have a<br>&gt;&gt; literal shorthand for Set as well.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The existing productions for array and dictionary literals and types<br>&gt;&gt; share brackets as delimiters, differing only in the contents between the<br>&gt;&gt; brackets. That poses a slight problem for Set because any syntax, to be<br>&gt;&gt; useful, must also be easily distinguishable from the other types.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Consider that Arrays and Dictionaries are both naturally indexed<br>&gt;&gt; collections. Arrays by the integer value of the order of items in the<br>&gt;&gt; collection, usually implicitly, and Dictionaries by the hashed key<br>&gt;&gt; associated with each value.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Arrays, implicit index:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; let array = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]<br>&gt;&gt; &gt; var array: [String]<br>&gt;&gt; &gt; var empty: [String] = []<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Dictionaries, explicit index:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; let dictionary = [&quot;a&quot;: 1, &quot;b&quot;: 5, &quot;c&quot;: 9]<br>&gt;&gt; &gt; var dictionary: [String: Int]<br>&gt;&gt; &gt; var empty: [String: Int] = [:]<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Sets, by contrast, have no particular order and no &quot;key&quot;. Even though<br>&gt;&gt; the Set is enumerable and iterable, it isn&#39;t indexed. With that in mind, we<br>&gt;&gt; can declare that a Set literal or Set type literal should distinguish<br>&gt;&gt; itself by declaring that it has no index.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The Set literal could be:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; let set = [ _: &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]<br>&gt;&gt; &gt; var set = [ _: String ]<br>&gt;&gt; &gt; var empty: [ _: String ] = [_:]<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; In the grammar:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; set-literal -&gt; [ _ : array-literal-items[opt] ]<br>&gt;&gt; &gt; literal-expression -&gt; array-literal | dictionary-literal | set-literal<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; set-type -&gt; [ _ : type ]<br>&gt;&gt; &gt; type -&gt; array-type | dictionary-type | set-type | ... etc.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Examples:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; let x = [ _: &quot;A&quot;, &quot;B&quot;, &quot;C&quot; ]<br>&gt;&gt; &gt; let y: [ _: String ] = [ _: ]<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Alternatives considered:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Without literals, declaring a Set type is straightforward, easy to<br>&gt;&gt; recognize, and not much more verbose. There might not be enough of a<br>&gt;&gt; difference to justify special syntax in the core language.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Mike<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160119/f9329623/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0fc40f95a5c6b063df44b3bc136d764b?s=50"></div><header><strong>[Proposal] Set literal and Set type syntax</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.com&gt;<p>January 19, 2016 at 12:00:00pm</p></header><div class="content"><p>Yes indeed, in that case please disregard that comment, I drew a mental blank for some reason!<br></p><p>Thinking about it I’m just not sure about a syntax specifically for sets. That said, I’m kind of interested by the idea of the proposed syntax in terms of being able to specify a type of index for any indexed type (with underscore indicating no index as proposed). For example:<br></p><p>let x:SomeIndexedType = [Int:1, 2, 3, 4] // An indexed collection where the index type is Int (e.g- a regular Array)<br>let x:SomeIndexedType = [UInt8: 1, 2, 3, 4] // Similar to above, but limited to Uint8 indexes the type is incapable of storing more than 256 elements, coincidentally if you convert your indices from a larger integer type by truncating then you get automatic round-robin storage.<br>let x = [_: 1, 2, 3, 4] // Set as a special case (otherwise indexed types would need to handle optional index types)<br></p><p>Given that the collection types are already written to use the index paradigm externally rather than just assuming the use of Int for indices, this could allow for some interesting possibilities from using custom index types, e.g- allowing an Array to store elements by alphabetic letters. Of course internally some changes might be needed as collections would need to use the distance from the start index to perform lookups, but for integer types this should optimise away I think, and shouldn&#39;t be a difficult change to make.<br></p><p>But yeah; for Sets only I’m not convinced the need is worth it given that array syntax works in most cases, but if the same syntax can be useful for a broader range of types it could be interesting.<br></p><p>&gt; On 19 Jan 2016, at 10:35, Johan Jensen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Isn&#39;t that exactly what ArrayLiteralConvertible does?<br>&gt; <br>&gt; extension CustomType: ArrayLiteralConvertible {<br>&gt;     typealias Element = Int<br>&gt;     init(arrayLiteral elements: Element...) {<br>&gt;         <br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; let c: CustomType = [1,2,3,4]<br>&gt; <br>&gt; <br>&gt; On Tue, Jan 19, 2016 at 10:18 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Same here, as you long as you specify Set as a type then the standard array syntax works just fine, the only case in which it doesn’t work is when you want to do something like:<br>&gt; <br>&gt; [1,2,3,4].someMethod()<br>&gt; <br>&gt; But that isn’t usually a great way to use array/set constants anyway so I don’t think it’s a big deal.<br>&gt; <br>&gt; A more interesting question IMO is whether we could extend the array syntax to apply to any sequence type, for example:<br>&gt; <br>&gt; let mySequence:SomeProtocol = [1, 2, 3, 4]<br>&gt; <br>&gt; i.e- could we add a protocol that Array and Set conform to in order to support that style of initialisation, that we could also apply to other types as well. Is that worth its own proposal?<br>&gt; <br>&gt;&gt; On 19 Jan 2016, at 01:43, zhaoxin肇鑫 via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I choose let x: Set = [1, 2, 3, 4] // x inferred to be Set&lt;Int&gt;. The current way. Unless the output of print(a set) change its format.<br>&gt;&gt; <br>&gt;&gt; zhaoxin<br>&gt;&gt; <br>&gt;&gt; On Tue, Jan 19, 2016 at 6:51 AM, Jack Lawrence via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; It doesn’t seem like a big enough win over:<br>&gt;&gt; <br>&gt;&gt; let x: Set = [1, 2, 3, 4] // x inferred to be Set&lt;Int&gt;<br>&gt;&gt; <br>&gt;&gt; Especially since sets are used so infrequently compared to Array and Dictionary.<br>&gt;&gt; Jack<br>&gt;&gt; &gt; On Jan 18, 2016, at 1:24 PM, Michael Henson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Swift currently has literal and type shorthand syntax for native Array and Dictionary types, but not the Set type. It would be useful to have a literal shorthand for Set as well.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The existing productions for array and dictionary literals and types share brackets as delimiters, differing only in the contents between the brackets. That poses a slight problem for Set because any syntax, to be useful, must also be easily distinguishable from the other types.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Consider that Arrays and Dictionaries are both naturally indexed collections. Arrays by the integer value of the order of items in the collection, usually implicitly, and Dictionaries by the hashed key associated with each value.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Arrays, implicit index:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; let array = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]<br>&gt;&gt; &gt; var array: [String]<br>&gt;&gt; &gt; var empty: [String] = []<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Dictionaries, explicit index:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; let dictionary = [&quot;a&quot;: 1, &quot;b&quot;: 5, &quot;c&quot;: 9]<br>&gt;&gt; &gt; var dictionary: [String: Int]<br>&gt;&gt; &gt; var empty: [String: Int] = [:]<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Sets, by contrast, have no particular order and no &quot;key&quot;. Even though the Set is enumerable and iterable, it isn&#39;t indexed. With that in mind, we can declare that a Set literal or Set type literal should distinguish itself by declaring that it has no index.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The Set literal could be:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; let set = [ _: &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]<br>&gt;&gt; &gt; var set = [ _: String ]<br>&gt;&gt; &gt; var empty: [ _: String ] = [_:]<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; In the grammar:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; set-literal -&gt; [ _ : array-literal-items[opt] ]<br>&gt;&gt; &gt; literal-expression -&gt; array-literal | dictionary-literal | set-literal<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; set-type -&gt; [ _ : type ]<br>&gt;&gt; &gt; type -&gt; array-type | dictionary-type | set-type | ... etc.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Examples:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; let x = [ _: &quot;A&quot;, &quot;B&quot;, &quot;C&quot; ]<br>&gt;&gt; &gt; let y: [ _: String ] = [ _: ]<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Alternatives considered:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Without literals, declaring a Set type is straightforward, easy to recognize, and not much more verbose. There might not be enough of a difference to justify special syntax in the core language.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Mike<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160119/4ea91127/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Proposal] Set literal and Set type syntax</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>January 19, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; Especially since sets are used so infrequently compared to Array and Dictionary.<br>I guess this is (at least partially) some kind of chicken or the egg problem:<br>Arrays are easy to declare, so they are often used even if you actually want set characteristics.<br></p><p>If you don&#39;t care for indices, and your collection should not contain duplicates, you still can use an array (and there was a time where the situation was even worse - afair Swift 1 had no native set-type).<br></p><p>So, I think propagating the correct use of collection types is good, but there is no natural syntax for sets, and &quot;Set(…)&quot; isn&#39;t that bad (I&#39;d rather vote for removing the array-shortcut: Swift lacks the concept of fixed-size arrays, and this would be way more typing than &quot;Set&quot; ;-)<br></p><p>Tino<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ca02c0ca5c5d6a28bc48eebb3b000c7?s=50"></div><header><strong>[Proposal] Set literal and Set type syntax</strong> from <string>Michael Henson</string> &lt;mikehenson at gmail.com&gt;<p>January 19, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt;<br>&gt; It doesn’t seem like a big enough win over:<br></p><p><br></p><p>let x: Set = [1, 2, 3, 4] // x inferred to be Set&lt;Int&gt;<br></p><p><br></p><p>Especially since sets are used so infrequently compared to Array and<br>&gt; Dictionary<br></p><p><br>It&#39;s true that that works and is easy to understand. The two strongest<br>arguments I can come up with for a Set-specific syntax are:<br></p><p>1. The Set collection has no duplicate values, but the Array-literal<br>initialization syntax allows them. Disappearing values could lead to<br>difficult-to-diagnose problems. A Set literal type could allow the tools to<br>detect and notify if duplicates are given.<br></p><p>2.  This initialization syntax is clear in this particular case, but only<br>because the type declaration is right there. Initializing Sets isn&#39;t as<br>obvious when the code is passing an argument to a function or setting the<br>value on structs or classes that have been declared elsewhere.<br></p><p>Mike<br></p><p>On Mon, Jan 18, 2016 at 2:51 PM, Jack Lawrence &lt;jackl at apple.com&gt; wrote:<br></p><p>&gt; It doesn’t seem like a big enough win over:<br>&gt;<br>&gt; let x: Set = [1, 2, 3, 4] // x inferred to be Set&lt;Int&gt;<br>&gt;<br>&gt; Especially since sets are used so infrequently compared to Array and<br>&gt; Dictionary.<br>&gt; Jack<br>&gt; &gt; On Jan 18, 2016, at 1:24 PM, Michael Henson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Swift currently has literal and type shorthand syntax for native Array<br>&gt; and Dictionary types, but not the Set type. It would be useful to have a<br>&gt; literal shorthand for Set as well.<br>&gt; &gt;<br>&gt; &gt; The existing productions for array and dictionary literals and types<br>&gt; share brackets as delimiters, differing only in the contents between the<br>&gt; brackets. That poses a slight problem for Set because any syntax, to be<br>&gt; useful, must also be easily distinguishable from the other types.<br>&gt; &gt;<br>&gt; &gt; Consider that Arrays and Dictionaries are both naturally indexed<br>&gt; collections. Arrays by the integer value of the order of items in the<br>&gt; collection, usually implicitly, and Dictionaries by the hashed key<br>&gt; associated with each value.<br>&gt; &gt;<br>&gt; &gt; Arrays, implicit index:<br>&gt; &gt;<br>&gt; &gt; let array = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]<br>&gt; &gt; var array: [String]<br>&gt; &gt; var empty: [String] = []<br>&gt; &gt;<br>&gt; &gt; Dictionaries, explicit index:<br>&gt; &gt;<br>&gt; &gt; let dictionary = [&quot;a&quot;: 1, &quot;b&quot;: 5, &quot;c&quot;: 9]<br>&gt; &gt; var dictionary: [String: Int]<br>&gt; &gt; var empty: [String: Int] = [:]<br>&gt; &gt;<br>&gt; &gt; Sets, by contrast, have no particular order and no &quot;key&quot;. Even though<br>&gt; the Set is enumerable and iterable, it isn&#39;t indexed. With that in mind, we<br>&gt; can declare that a Set literal or Set type literal should distinguish<br>&gt; itself by declaring that it has no index.<br>&gt; &gt;<br>&gt; &gt; The Set literal could be:<br>&gt; &gt;<br>&gt; &gt; let set = [ _: &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]<br>&gt; &gt; var set = [ _: String ]<br>&gt; &gt; var empty: [ _: String ] = [_:]<br>&gt; &gt;<br>&gt; &gt; In the grammar:<br>&gt; &gt;<br>&gt; &gt; set-literal -&gt; [ _ : array-literal-items[opt] ]<br>&gt; &gt; literal-expression -&gt; array-literal | dictionary-literal | set-literal<br>&gt; &gt;<br>&gt; &gt; set-type -&gt; [ _ : type ]<br>&gt; &gt; type -&gt; array-type | dictionary-type | set-type | ... etc.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Examples:<br>&gt; &gt;<br>&gt; &gt; let x = [ _: &quot;A&quot;, &quot;B&quot;, &quot;C&quot; ]<br>&gt; &gt; let y: [ _: String ] = [ _: ]<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Alternatives considered:<br>&gt; &gt;<br>&gt; &gt; Without literals, declaring a Set type is straightforward, easy to<br>&gt; recognize, and not much more verbose. There might not be enough of a<br>&gt; difference to justify special syntax in the core language.<br>&gt; &gt;<br>&gt; &gt; Mike<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160119/03832307/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/47e3aeeaf151d4f51ee15fc7871bf584?s=50"></div><header><strong>[Proposal] Set literal and Set type syntax</strong> from <string>Rudolf Adamkovič</string> &lt;salutis at me.com&gt;<p>January 21, 2016 at 11:00:00am</p></header><div class="content"><p>This is a great point. The compiler should emit a warning in case of duplicate values:<br></p><p>let numbers: Set&lt;Int&gt; = [0, 0]<br></p><p>R+<br></p><p>Sent from my iPhone<br></p><p>On 19 Jan 2016, at 21:19, Michael Henson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; It doesn’t seem like a big enough win over: <br>&gt;&gt;  <br>&gt;&gt; let x: Set = [1, 2, 3, 4] // x inferred to be Set&lt;Int&gt; <br>&gt;&gt;  <br>&gt;&gt; Especially since sets are used so infrequently compared to Array and Dictionary<br>&gt; <br>&gt; It&#39;s true that that works and is easy to understand. The two strongest arguments I can come up with for a Set-specific syntax are:<br>&gt; <br>&gt; 1. The Set collection has no duplicate values, but the Array-literal initialization syntax allows them. Disappearing values could lead to difficult-to-diagnose problems. A Set literal type could allow the tools to detect and notify if duplicates are given.<br>&gt; <br>&gt; 2.  This initialization syntax is clear in this particular case, but only because the type declaration is right there. Initializing Sets isn&#39;t as obvious when the code is passing an argument to a function or setting the value on structs or classes that have been declared elsewhere.<br>&gt; <br>&gt; Mike<br>&gt; <br>&gt;&gt; On Mon, Jan 18, 2016 at 2:51 PM, Jack Lawrence &lt;jackl at apple.com&gt; wrote:<br>&gt;&gt; It doesn’t seem like a big enough win over:<br>&gt;&gt; <br>&gt;&gt; let x: Set = [1, 2, 3, 4] // x inferred to be Set&lt;Int&gt;<br>&gt;&gt; <br>&gt;&gt; Especially since sets are used so infrequently compared to Array and Dictionary.<br>&gt;&gt; Jack<br>&gt;&gt; &gt; On Jan 18, 2016, at 1:24 PM, Michael Henson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Swift currently has literal and type shorthand syntax for native Array and Dictionary types, but not the Set type. It would be useful to have a literal shorthand for Set as well.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The existing productions for array and dictionary literals and types share brackets as delimiters, differing only in the contents between the brackets. That poses a slight problem for Set because any syntax, to be useful, must also be easily distinguishable from the other types.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Consider that Arrays and Dictionaries are both naturally indexed collections. Arrays by the integer value of the order of items in the collection, usually implicitly, and Dictionaries by the hashed key associated with each value.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Arrays, implicit index:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; let array = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]<br>&gt;&gt; &gt; var array: [String]<br>&gt;&gt; &gt; var empty: [String] = []<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Dictionaries, explicit index:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; let dictionary = [&quot;a&quot;: 1, &quot;b&quot;: 5, &quot;c&quot;: 9]<br>&gt;&gt; &gt; var dictionary: [String: Int]<br>&gt;&gt; &gt; var empty: [String: Int] = [:]<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Sets, by contrast, have no particular order and no &quot;key&quot;. Even though the Set is enumerable and iterable, it isn&#39;t indexed. With that in mind, we can declare that a Set literal or Set type literal should distinguish itself by declaring that it has no index.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The Set literal could be:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; let set = [ _: &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]<br>&gt;&gt; &gt; var set = [ _: String ]<br>&gt;&gt; &gt; var empty: [ _: String ] = [_:]<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; In the grammar:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; set-literal -&gt; [ _ : array-literal-items[opt] ]<br>&gt;&gt; &gt; literal-expression -&gt; array-literal | dictionary-literal | set-literal<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; set-type -&gt; [ _ : type ]<br>&gt;&gt; &gt; type -&gt; array-type | dictionary-type | set-type | ... etc.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Examples:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; let x = [ _: &quot;A&quot;, &quot;B&quot;, &quot;C&quot; ]<br>&gt;&gt; &gt; let y: [ _: String ] = [ _: ]<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Alternatives considered:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Without literals, declaring a Set type is straightforward, easy to recognize, and not much more verbose. There might not be enough of a difference to justify special syntax in the core language.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Mike<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160121/69fde8a0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Proposal] Set literal and Set type syntax</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>January 21, 2016 at 02:00:00am</p></header><div class="content"><p>I agree that this is a desirable property, but it would only work for literals. In the most general sense, `Hashable` instances are only guaranteed to be comparable for equality at runtime.<br></p><p>Austin<br></p><p>&gt; On Jan 21, 2016, at 2:09 AM, Rudolf Adamkovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This is a great point. The compiler should emit a warning in case of duplicate values:<br>&gt; <br>&gt; let numbers: Set&lt;Int&gt; = [0, 0]<br>&gt; <br>&gt; R+<br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt; On 19 Jan 2016, at 21:19, Michael Henson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; It doesn’t seem like a big enough win over: <br>&gt;&gt;  <br>&gt;&gt; let x: Set = [1, 2, 3, 4] // x inferred to be Set&lt;Int&gt; <br>&gt;&gt;  <br>&gt;&gt; Especially since sets are used so infrequently compared to Array and Dictionary<br>&gt;&gt; <br>&gt;&gt; It&#39;s true that that works and is easy to understand. The two strongest arguments I can come up with for a Set-specific syntax are:<br>&gt;&gt; <br>&gt;&gt; 1. The Set collection has no duplicate values, but the Array-literal initialization syntax allows them. Disappearing values could lead to difficult-to-diagnose problems. A Set literal type could allow the tools to detect and notify if duplicates are given.<br>&gt;&gt; <br>&gt;&gt; 2.  This initialization syntax is clear in this particular case, but only because the type declaration is right there. Initializing Sets isn&#39;t as obvious when the code is passing an argument to a function or setting the value on structs or classes that have been declared elsewhere.<br>&gt;&gt; <br>&gt;&gt; Mike<br>&gt;&gt; <br>&gt;&gt; On Mon, Jan 18, 2016 at 2:51 PM, Jack Lawrence &lt;jackl at apple.com &lt;mailto:jackl at apple.com&gt;&gt; wrote:<br>&gt;&gt; It doesn’t seem like a big enough win over:<br>&gt;&gt; <br>&gt;&gt; let x: Set = [1, 2, 3, 4] // x inferred to be Set&lt;Int&gt;<br>&gt;&gt; <br>&gt;&gt; Especially since sets are used so infrequently compared to Array and Dictionary.<br>&gt;&gt; Jack<br>&gt;&gt; &gt; On Jan 18, 2016, at 1:24 PM, Michael Henson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Swift currently has literal and type shorthand syntax for native Array and Dictionary types, but not the Set type. It would be useful to have a literal shorthand for Set as well.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The existing productions for array and dictionary literals and types share brackets as delimiters, differing only in the contents between the brackets. That poses a slight problem for Set because any syntax, to be useful, must also be easily distinguishable from the other types.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Consider that Arrays and Dictionaries are both naturally indexed collections. Arrays by the integer value of the order of items in the collection, usually implicitly, and Dictionaries by the hashed key associated with each value.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Arrays, implicit index:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; let array = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]<br>&gt;&gt; &gt; var array: [String]<br>&gt;&gt; &gt; var empty: [String] = []<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Dictionaries, explicit index:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; let dictionary = [&quot;a&quot;: 1, &quot;b&quot;: 5, &quot;c&quot;: 9]<br>&gt;&gt; &gt; var dictionary: [String: Int]<br>&gt;&gt; &gt; var empty: [String: Int] = [:]<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Sets, by contrast, have no particular order and no &quot;key&quot;. Even though the Set is enumerable and iterable, it isn&#39;t indexed. With that in mind, we can declare that a Set literal or Set type literal should distinguish itself by declaring that it has no index.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The Set literal could be:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; let set = [ _: &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]<br>&gt;&gt; &gt; var set = [ _: String ]<br>&gt;&gt; &gt; var empty: [ _: String ] = [_:]<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; In the grammar:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; set-literal -&gt; [ _ : array-literal-items[opt] ]<br>&gt;&gt; &gt; literal-expression -&gt; array-literal | dictionary-literal | set-literal<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; set-type -&gt; [ _ : type ]<br>&gt;&gt; &gt; type -&gt; array-type | dictionary-type | set-type | ... etc.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Examples:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; let x = [ _: &quot;A&quot;, &quot;B&quot;, &quot;C&quot; ]<br>&gt;&gt; &gt; let y: [ _: String ] = [ _: ]<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Alternatives considered:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Without literals, declaring a Set type is straightforward, easy to recognize, and not much more verbose. There might not be enough of a difference to justify special syntax in the core language.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Mike<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160121/6da2ec28/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce6825f55ba05353e3652d8989b6137?s=50"></div><header><strong>[Proposal] Set literal and Set type syntax</strong> from <string>Will Entriken</string> &lt;fulldecent at gmail.com&gt;<p>January 18, 2016 at 05:00:00pm</p></header><div class="content"><p>Another interpretation is that a Set *is* indexed, and its value is<br>nonexistent. Or, in other words:<br></p><p>var x = [String: ()]<br>var y = [String: ()]()<br></p><p>Literals might be<br></p><p>var z = [&quot;bourbon&quot;: (), &quot;scotch&quot;: (), &quot;beer&quot;: ()]<br></p><p>or more succinctly<br></p><p>var a = [&quot;bourbon&quot;: (), &quot;scotch&quot;, &quot;beer&quot;]<br></p><p>Other choices like Void or nil may be more appropriate.<br></p><p><br>On Mon, Jan 18, 2016 at 4:24 PM, Michael Henson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Swift currently has literal and type shorthand syntax for native Array and<br>&gt; Dictionary types, but not the Set type. It would be useful to have a<br>&gt; literal shorthand for Set as well.<br>&gt;<br>&gt; The existing productions for array and dictionary literals and types share<br>&gt; brackets as delimiters, differing only in the contents between the<br>&gt; brackets. That poses a slight problem for Set because any syntax, to be<br>&gt; useful, must also be easily distinguishable from the other types.<br>&gt;<br>&gt; Consider that Arrays and Dictionaries are both naturally indexed<br>&gt; collections. Arrays by the integer value of the order of items in the<br>&gt; collection, usually implicitly, and Dictionaries by the hashed key<br>&gt; associated with each value.<br>&gt;<br>&gt; Arrays, implicit index:<br>&gt;<br>&gt; let array = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]<br>&gt; var array: [String]<br>&gt; var empty: [String] = []<br>&gt;<br>&gt; Dictionaries, explicit index:<br>&gt;<br>&gt; let dictionary = [&quot;a&quot;: 1, &quot;b&quot;: 5, &quot;c&quot;: 9]<br>&gt; var dictionary: [String: Int]<br>&gt; var empty: [String: Int] = [:]<br>&gt;<br>&gt; Sets, by contrast, have no particular order and no &quot;key&quot;. Even though the<br>&gt; Set is enumerable and iterable, it isn&#39;t indexed. With that in mind, we can<br>&gt; declare that a Set literal or Set type literal should distinguish itself by<br>&gt; declaring that it has no index.<br>&gt;<br>&gt; The Set literal could be:<br>&gt;<br>&gt; let set = [ _: &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]<br>&gt; var set = [ _: String ]<br>&gt; var empty: [ _: String ] = [_:]<br>&gt;<br>&gt; In the grammar:<br>&gt;<br>&gt; set-literal -&gt; [ _ : array-literal-items[opt] ]<br>&gt; literal-expression -&gt; array-literal | dictionary-literal | set-literal<br>&gt;<br>&gt; set-type -&gt; [ _ : type ]<br>&gt; type -&gt; array-type | dictionary-type | set-type | ... etc.<br>&gt;<br>&gt;<br>&gt; Examples:<br>&gt;<br>&gt; let x = [ _: &quot;A&quot;, &quot;B&quot;, &quot;C&quot; ]<br>&gt; let y: [ _: String ] = [ _: ]<br>&gt;<br>&gt;<br>&gt; Alternatives considered:<br>&gt;<br>&gt; Without literals, declaring a Set type is straightforward, easy to<br>&gt; recognize, and not much more verbose. There might not be enough of a<br>&gt; difference to justify special syntax in the core language.<br>&gt;<br>&gt; Mike<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160118/4bc11465/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1696913cf1335685a75e63e11b459ae3?s=50"></div><header><strong>[Proposal] Set literal and Set type syntax</strong> from <string>Sune Foldager</string> &lt;cyano at me.com&gt;<p>January 19, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On 18 Jan 2016, at 23:12, Will Entriken via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Another interpretation is that a Set *is* indexed, and its value is nonexistent. Or, in other words:<br>&gt; <br>&gt; var x = [String: ()]<br>&gt; var y = [String: ()]()<br>&gt; <br>&gt; Literals might be<br>&gt; <br>&gt; var z = [&quot;bourbon&quot;: (), &quot;scotch&quot;: (), &quot;beer&quot;: ()]<br>&gt; <br>&gt; or more succinctly<br>&gt; <br>&gt; var a = [&quot;bourbon&quot;: (), &quot;scotch&quot;, &quot;beer”]<br></p><p>Yes, but it still looks weird. I don’t see what’s so horrible about var a : Set = [1, 2, 3, …]. -1 from me unless a better syntax is worked out, at least.<br></p><p>-Sune<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2861bfeb71de9de58206bb6ae750bc2f?s=50"></div><header><strong>[Proposal] Set literal and Set type syntax</strong> from <string>ilya</string> &lt;ilya.nikokoshev at gmail.com&gt;<p>January 21, 2016 at 03:00:00pm</p></header><div class="content"><p>Indeed, Set&lt;T&gt; is basically Dictionary&lt;T, Void&gt;<br>If we really need a separate syntax for sets then perhaps<br></p><p>var set1: [Int:]<br>var set2 = [2, 3, 5:]<br>set1= set2<br></p><p>will be most logical.<br></p><p>On Tue, Jan 19, 2016 at 20:12 Will Entriken via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Another interpretation is that a Set *is* indexed, and its value is<br>&gt; nonexistent. Or, in other words:<br>&gt;<br>&gt; var x = [String: ()]<br>&gt; var y = [String: ()]()<br>&gt;<br>&gt; Literals might be<br>&gt;<br>&gt; var z = [&quot;bourbon&quot;: (), &quot;scotch&quot;: (), &quot;beer&quot;: ()]<br>&gt;<br>&gt; or more succinctly<br>&gt;<br>&gt; var a = [&quot;bourbon&quot;: (), &quot;scotch&quot;, &quot;beer&quot;]<br>&gt;<br>&gt; Other choices like Void or nil may be more appropriate.<br>&gt;<br>&gt;<br>&gt; On Mon, Jan 18, 2016 at 4:24 PM, Michael Henson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Swift currently has literal and type shorthand syntax for native Array<br>&gt;&gt; and Dictionary types, but not the Set type. It would be useful to have a<br>&gt;&gt; literal shorthand for Set as well.<br>&gt;&gt;<br>&gt;&gt; The existing productions for array and dictionary literals and types<br>&gt;&gt; share brackets as delimiters, differing only in the contents between the<br>&gt;&gt; brackets. That poses a slight problem for Set because any syntax, to be<br>&gt;&gt; useful, must also be easily distinguishable from the other types.<br>&gt;&gt;<br>&gt;&gt; Consider that Arrays and Dictionaries are both naturally indexed<br>&gt;&gt; collections. Arrays by the integer value of the order of items in the<br>&gt;&gt; collection, usually implicitly, and Dictionaries by the hashed key<br>&gt;&gt; associated with each value.<br>&gt;&gt;<br>&gt;&gt; Arrays, implicit index:<br>&gt;&gt;<br>&gt;&gt; let array = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]<br>&gt;&gt; var array: [String]<br>&gt;&gt; var empty: [String] = []<br>&gt;&gt;<br>&gt;&gt; Dictionaries, explicit index:<br>&gt;&gt;<br>&gt;&gt; let dictionary = [&quot;a&quot;: 1, &quot;b&quot;: 5, &quot;c&quot;: 9]<br>&gt;&gt; var dictionary: [String: Int]<br>&gt;&gt; var empty: [String: Int] = [:]<br>&gt;&gt;<br>&gt;&gt; Sets, by contrast, have no particular order and no &quot;key&quot;. Even though the<br>&gt;&gt; Set is enumerable and iterable, it isn&#39;t indexed. With that in mind, we can<br>&gt;&gt; declare that a Set literal or Set type literal should distinguish itself by<br>&gt;&gt; declaring that it has no index.<br>&gt;&gt;<br>&gt;&gt; The Set literal could be:<br>&gt;&gt;<br>&gt;&gt; let set = [ _: &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]<br>&gt;&gt; var set = [ _: String ]<br>&gt;&gt; var empty: [ _: String ] = [_:]<br>&gt;&gt;<br>&gt;&gt; In the grammar:<br>&gt;&gt;<br>&gt;&gt; set-literal -&gt; [ _ : array-literal-items[opt] ]<br>&gt;&gt; literal-expression -&gt; array-literal | dictionary-literal | set-literal<br>&gt;&gt;<br>&gt;&gt; set-type -&gt; [ _ : type ]<br>&gt;&gt; type -&gt; array-type | dictionary-type | set-type | ... etc.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Examples:<br>&gt;&gt;<br>&gt;&gt; let x = [ _: &quot;A&quot;, &quot;B&quot;, &quot;C&quot; ]<br>&gt;&gt; let y: [ _: String ] = [ _: ]<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Alternatives considered:<br>&gt;&gt;<br>&gt;&gt; Without literals, declaring a Set type is straightforward, easy to<br>&gt;&gt; recognize, and not much more verbose. There might not be enough of a<br>&gt;&gt; difference to justify special syntax in the core language.<br>&gt;&gt;<br>&gt;&gt; Mike<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160121/5d6aa52c/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
