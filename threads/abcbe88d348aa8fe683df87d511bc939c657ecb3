<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f9e638540251a5a2a70ae516ad544281?s=50"></div><header><strong>Polymorphic behavior for overloaded == (and other) operators</strong> from <string>Frederick Kellison-Linn</string> &lt;fred.kl at me.com&gt;<p>December  9, 2015 at 01:00:00am</p></header><div class="content"><p>Currently, implementing an ‘==‘ function for a custom class can be somewhat cumbersome. In the simple hierarchy:<br></p><p>class A {<br>    var a: Int<br>    init(_ a: Int) {<br>        self.a = a<br>    }<br>}<br></p><p>class B : A {<br>    var b: Int<br>    init(_ b: Int, _ a: Int) {<br>        self.b = b<br>        super.init(a)<br>    }<br>}<br></p><p>A reasonable implementation of == would seem to be<br></p><p>func ==(lhs: A, rhs: A) -&gt; Bool {<br>    return lhs.a == rhs.a<br>}<br></p><p>func ==(lhs: B, rhs: B) -&gt; Bool {<br>    return lhs.a == rhs.a &amp;&amp;<br>           lhs.b == rhs.b<br>}<br></p><p>However, this fails in the case that the static type of compared variables differs from their dynamic type. E.g:<br></p><p>let x = A(3)<br>let y: A = B(3, 4)<br></p><p>x == y // true<br></p><p>The immediately obvious solution is to add a check to every == implementation that may need to be implemented for a subtype:<br></p><p>func ==(lhs: A, rhs: A) -&gt; Bool {<br>    if (lhs.dynamicType != rhs.dynamicType) {<br>        return false<br>    }<br>    return lhs.a == rhs.a<br>}<br></p><p>But this results in annoying boilerplate for what should be a simple computation, and furthermore fails to solve every case:<br></p><p>let w: A = B(1, 2)<br>var z: A = B(1, 3)<br></p><p>w == z // still true<br></p><p>I’d be interested to know if there is any interest taken in this problem and whether possible solutions have been discussed. If == were instead behaved as if it were a method of its first argument (as in a .equals(other) method) then the solution above is sufficient to avoid returning the wrong result, but being forced to use .dynamicType for something as basic as equality checking seems cumbersome to me.<br></p><p>FKL<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/abcbecb3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Polymorphic behavior for overloaded == (and other) operators</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 10, 2015 at 10:00:00pm</p></header><div class="content"><p>On Dec 8, 2015, at 10:32 PM, Frederick Kellison-Linn via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Currently, implementing an ‘==‘ function for a custom class can be somewhat cumbersome. In the simple hierarchy:<br>&gt; <br>&gt; class A {<br>&gt;     var a: Int<br>&gt;     init(_ a: Int) {<br>&gt;         self.a = a<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; class B : A {<br>&gt;     var b: Int<br>&gt;     init(_ b: Int, _ a: Int) {<br>&gt;         self.b = b<br>&gt;         super.init(a)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; A reasonable implementation of == would seem to be<br>&gt; <br>&gt; func ==(lhs: A, rhs: A) -&gt; Bool {<br>&gt;     return lhs.a == rhs.a<br>&gt; }<br>&gt; <br>&gt; func ==(lhs: B, rhs: B) -&gt; Bool {<br>&gt;     return lhs.a == rhs.a &amp;&amp;<br>&gt;            lhs.b == rhs.b<br>&gt; }<br>&gt; <br>&gt; I’d be interested to know if there is any interest taken in this problem and whether possible solutions have been discussed. If == were instead behaved as if it were a method of its first argument (as in a .equals(other) method) then the solution above is sufficient to avoid returning the wrong result, but being forced to use .dynamicType for something as basic as equality checking seems cumbersome to me.<br></p><p>Hi Frederick,<br></p><p>The preferred approach is to allow operators to be defined inside of types.  This would allow them to be dynamically dispatched inside of classes.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/915f3370/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f9e638540251a5a2a70ae516ad544281?s=50"></div><header><strong>Polymorphic behavior for overloaded == (and other) operators</strong> from <string>Frederick Kellison-Linn</string> &lt;fred.kl at me.com&gt;<p>December 11, 2015 at 12:00:00pm</p></header><div class="content"><p>Hi Chris,<br></p><p>Thanks for the response, I’m glad to hear that. Is this something that is planned/feasible for Swift 3?<br></p><p>FKL<br></p><p>&gt; On Dec 11, 2015, at 1:02 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; On Dec 8, 2015, at 10:32 PM, Frederick Kellison-Linn via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Currently, implementing an ‘==‘ function for a custom class can be somewhat cumbersome. In the simple hierarchy:<br>&gt;&gt; <br>&gt;&gt; class A {<br>&gt;&gt;     var a: Int<br>&gt;&gt;     init(_ a: Int) {<br>&gt;&gt;         self.a = a<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class B : A {<br>&gt;&gt;     var b: Int<br>&gt;&gt;     init(_ b: Int, _ a: Int) {<br>&gt;&gt;         self.b = b<br>&gt;&gt;         super.init(a)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; A reasonable implementation of == would seem to be<br>&gt;&gt; <br>&gt;&gt; func ==(lhs: A, rhs: A) -&gt; Bool {<br>&gt;&gt;     return lhs.a == rhs.a<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func ==(lhs: B, rhs: B) -&gt; Bool {<br>&gt;&gt;     return lhs.a == rhs.a &amp;&amp;<br>&gt;&gt;            lhs.b == rhs.b<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I’d be interested to know if there is any interest taken in this problem and whether possible solutions have been discussed. If == were instead behaved as if it were a method of its first argument (as in a .equals(other) method) then the solution above is sufficient to avoid returning the wrong result, but being forced to use .dynamicType for something as basic as equality checking seems cumbersome to me.<br>&gt; <br>&gt; Hi Frederick,<br>&gt; <br>&gt; The preferred approach is to allow operators to be defined inside of types.  This would allow them to be dynamically dispatched inside of classes.<br>&gt; <br>&gt; -Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/f276eb6a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Polymorphic behavior for overloaded == (and other) operators</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 11, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 11, 2015, at 9:00 AM, Frederick Kellison-Linn &lt;fred.kl at me.com&gt; wrote:<br>&gt; <br>&gt; Hi Chris,<br>&gt; <br>&gt; Thanks for the response, I’m glad to hear that. Is this something that is planned/feasible for Swift 3?<br></p><p>It’s desired, but not considered critical for Swift 3, so it will depend on how times work out.  If ABI stability ends up taking more time than expected, it will probably get pushed out.<br></p><p>-Chris<br></p><p>&gt; <br>&gt; FKL<br>&gt; <br>&gt;&gt; On Dec 11, 2015, at 1:02 AM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Dec 8, 2015, at 10:32 PM, Frederick Kellison-Linn via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Currently, implementing an ‘==‘ function for a custom class can be somewhat cumbersome. In the simple hierarchy:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class A {<br>&gt;&gt;&gt;     var a: Int<br>&gt;&gt;&gt;     init(_ a: Int) {<br>&gt;&gt;&gt;         self.a = a<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class B : A {<br>&gt;&gt;&gt;     var b: Int<br>&gt;&gt;&gt;     init(_ b: Int, _ a: Int) {<br>&gt;&gt;&gt;         self.b = b<br>&gt;&gt;&gt;         super.init(a)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A reasonable implementation of == would seem to be<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func ==(lhs: A, rhs: A) -&gt; Bool {<br>&gt;&gt;&gt;     return lhs.a == rhs.a<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func ==(lhs: B, rhs: B) -&gt; Bool {<br>&gt;&gt;&gt;     return lhs.a == rhs.a &amp;&amp;<br>&gt;&gt;&gt;            lhs.b == rhs.b<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’d be interested to know if there is any interest taken in this problem and whether possible solutions have been discussed. If == were instead behaved as if it were a method of its first argument (as in a .equals(other) method) then the solution above is sufficient to avoid returning the wrong result, but being forced to use .dynamicType for something as basic as equality checking seems cumbersome to me.<br>&gt;&gt; <br>&gt;&gt; Hi Frederick,<br>&gt;&gt; <br>&gt;&gt; The preferred approach is to allow operators to be defined inside of types.  This would allow them to be dynamically dispatched inside of classes.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/b2bda330/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
