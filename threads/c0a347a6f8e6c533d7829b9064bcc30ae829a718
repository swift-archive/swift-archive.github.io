<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2ff1daab58cd5e44a457908d1905c322?s=50"></div><header><strong>Proposal: extend Optional-specific syntax to arbitrary types with CustomOptionalConvertible</strong> from <string>Krzysztof Siejkowski</string> &lt;krzysztof at siejkowski.net&gt;<p>December  7, 2015 at 09:00:00pm</p></header><div class="content"><p>Hi,<br></p><p><br># Introduction<br></p><p>I&#39;d like to propose a non-invasive way of extending the funtionality of `if let` conditional binding (and potencially other Optional-related language constructs) by introducing `CustomOptionalConvertible` protocol. The idea is basically the same as with `CustomStringConvertible` protocol used to provide string interpolation or with `~=` operator used in `switch` statement pattern matching.  I believe it&#39;s going to simplity and unify the use of the Optional-related family of Swift syntax constructs for custom types.<br></p><p>The proposal is in a draft stage right now, I&#39;ll clear it up if it proves worth to be pull-requested.<br></p><p><br># Motivation<br></p><p>One of the Swift features that are core to it&#39;s safety and readability are Optionals. They&#39;re important enough to be given special place in the language syntax. Special operators like `?`, `!` or `??`, special casting keywords like `as?`, special conditional binding `if let`. The Optionals, however, might be also seen as a member of larger family of constructs: call them monads, boxes, value containers, computational context bearers. One example of those would be a very similar type going by the name of  Either, Try or Result. It can be seen as an Optional that carries some additional information about the reason why the value is absent. That information is not always of our interest and in those cases conditional binding  for Either type makes a lot of sense. However, the `if let` syntax is currently exclusively working only for optionals.<br></p><p><br># Proposed solution<br></p><p>While I&#39;d love to see Swift introducing a powerful construct similar to Haskell&#39;s `do-notation` or Scala&#39;s `for-comprehension`, I believe it&#39;d require a significant invasive change in the language implementation (and, possibly, vision). Therefore the proposed solutions is much more humble. Let&#39;s introduce the `CustomOptionalConvertible` protocol with signature:<br></p><p>```<br>protocol CustomOptionalConvertible {<br>	typealias Wrapped<br>	public var optional: Optional&lt;Wrapped&gt; { get }<br>}<br>```<br></p><p>Such a protocol will provide a way for an arbitrary type to convert to the Optional. All the types implementing this protocol could then be used in conditional binding syntax without explicit declaration of conversion. I do not propose the introduction of general implicit conversion construct, just a special case. The same as `CustomStringConvertible` is a special case of allowing the value to express itself in the string interpolation.`CustomOptionalConvertible` will allow the author of an arbitratry type to integrate with Swift syntax:<br></p><p>```<br>enum Either&lt;Value&gt; {<br>	case Left(ErrorType)<br>	case Right(Value)<br>}<br></p><p>extension Either : CustomOptionalConvertible {<br>	typealias Wrapped = Value<br>	public var optional: Optional&lt;Value&gt; {<br>		get {<br>			switch (self) {<br>			case .Left(_): return .None<br>			case .Right(let value): return .Some(value)<br>			}<br>		}<br>	} <br>}<br></p><p>func foo(either: Either&lt;String&gt;) -&gt; String {<br>	if let string = either {<br>		return string<br>	} else {<br>		return &quot;No value&quot;<br>	}<br>}<br>```<br></p><p>There is already a similar mechanism available in the context of pattern matching: `~=` operator.<br></p><p><br># Impact on the language<br></p><p>While I cannot say much about the impact on the compiler, I believe the introduction will bring no breaking change to the Swift language itself. All the places that are currently requiring Optionals will still require Optionals. <br></p><p>For the language users it&#39;ll make it easier to integrate the constructs used in the program with the native syntax, making them easier to use and read. Current solution, namely:<br>```<br>func foo(either: Either&lt;String&gt;) -&gt; String {<br>	if let string = either.optional {<br>		return string<br>	} else {<br>		return &quot;No value&quot;<br>	}<br>}<br>```<br>is introducing unnecessary noise in the otherwise neat syntax. The problem escalates when `if let` cascade is used:<br>```<br>if let string = eitherString.optional<br>           int = eitherInt.optional<br>           array = eitherArray.optional <br>// ...<br>```<br></p><p><br># Alternatives considered<br></p><p>The equivalent of Haskell’s `do-notation`. It’s a powerful construct (some say even too powerful, see https://wiki.haskell.org/Do_notation_considered_harmful). However, I can’t imagine it without significant changes to the language syntax (`if let` should return value) and vision (I believe that Optional are syntactic unicorns by design).<br></p><p><br>All the best,<br>Krzysztof<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/c0a3a718/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Proposal: extend Optional-specific syntax to arbitrary types with CustomOptionalConvertible</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>December  7, 2015 at 03:00:00pm</p></header><div class="content"><p>I like the sentiment of this proposal, but I’m not sure it provides clear value. We already have a generalized version of “if let” in the form of “if case”:<br></p><p>    func foo(either: Either&lt;String&gt;) -&gt; String {<br>        if case .Right(let string) = either {<br>            return string<br>        } else {<br>            return &quot;No value&quot;<br>        }<br>    }<br></p><p>This works with cascades just fine:<br></p><p>    if case .Right(let string0) = either0,<br>            .Right(let string1) = either1,<br>            .Right(let string2) = either2 {<br></p><p>Leaving aside that Swift’s “if case” syntax is a bit clumsy and hard to remember at first, does a CustomOptionalConvertible really grant additional benefit in terms of either safety or readability?<br></p><p>Cheers,<br></p><p>Paul<br></p><p><br>&gt; On Dec 7, 2015, at 2:58 PM, krzysztof at siejkowski.net via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; <br>&gt; # Introduction<br>&gt; <br>&gt; I&#39;d like to propose a non-invasive way of extending the funtionality of `if let` conditional binding (and potencially other Optional-related language constructs) by introducing `CustomOptionalConvertible` protocol. The idea is basically the same as with `CustomStringConvertible` protocol used to provide string interpolation or with `~=` operator used in `switch` statement pattern matching.  I believe it&#39;s going to simplity and unify the use of the Optional-related family of Swift syntax constructs for custom types.<br>&gt; <br>&gt; The proposal is in a draft stage right now, I&#39;ll clear it up if it proves worth to be pull-requested.<br>&gt; <br>&gt; <br>&gt; # Motivation<br>&gt; <br>&gt; One of the Swift features that are core to it&#39;s safety and readability are Optionals. They&#39;re important enough to be given special place in the language syntax. Special operators like `?`, `!` or `??`, special casting keywords like `as?`, special conditional binding `if let`. The Optionals, however, might be also seen as a member of larger family of constructs: call them monads, boxes, value containers, computational context bearers. One example of those would be a very similar type going by the name of  Either, Try or Result. It can be seen as an Optional that carries some additional information about the reason why the value is absent. That information is not always of our interest and in those cases conditional binding  for Either type makes a lot of sense. However, the `if let` syntax is currently exclusively working only for optionals.<br>&gt; <br>&gt; <br>&gt; # Proposed solution<br>&gt; <br>&gt; While I&#39;d love to see Swift introducing a powerful construct similar to Haskell&#39;s `do-notation` or Scala&#39;s `for-comprehension`, I believe it&#39;d require a significant invasive change in the language implementation (and, possibly, vision). Therefore the proposed solutions is much more humble. Let&#39;s introduce the `CustomOptionalConvertible` protocol with signature:<br>&gt; <br>&gt; ```<br>&gt; protocol CustomOptionalConvertible {<br>&gt; 	typealias Wrapped<br>&gt; 	public var optional: Optional&lt;Wrapped&gt; { get }<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; Such a protocol will provide a way for an arbitrary type to convert to the Optional. All the types implementing this protocol could then be used in conditional binding syntax without explicit declaration of conversion. I do not propose the introduction of general implicit conversion construct, just a special case. The same as `CustomStringConvertible` is a special case of allowing the value to express itself in the string interpolation.`CustomOptionalConvertible` will allow the author of an arbitratry type to integrate with Swift syntax:<br>&gt; <br>&gt; ```<br>&gt; enum Either&lt;Value&gt; {<br>&gt; 	case Left(ErrorType)<br>&gt; 	case Right(Value)<br>&gt; }<br>&gt; <br>&gt; extension Either : CustomOptionalConvertible {<br>&gt; 	typealias Wrapped = Value<br>&gt; 	public var optional: Optional&lt;Value&gt; {<br>&gt; 		get {<br>&gt; 			switch (self) {<br>&gt; 			case .Left(_): return .None<br>&gt; 			case .Right(let value): return .Some(value)<br>&gt; 			}<br>&gt; 		}<br>&gt; 	} <br>&gt; }<br>&gt; <br>&gt; func foo(either: Either&lt;String&gt;) -&gt; String {<br>&gt; 	if let string = either {<br>&gt; 		return string<br>&gt; 	} else {<br>&gt; 		return &quot;No value&quot;<br>&gt; 	}<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; There is already a similar mechanism available in the context of pattern matching: `~=` operator.<br>&gt; <br>&gt; <br>&gt; # Impact on the language<br>&gt; <br>&gt; While I cannot say much about the impact on the compiler, I believe the introduction will bring no breaking change to the Swift language itself. All the places that are currently requiring Optionals will still require Optionals. <br>&gt; <br>&gt; For the language users it&#39;ll make it easier to integrate the constructs used in the program with the native syntax, making them easier to use and read. Current solution, namely:<br>&gt; ```<br>&gt; func foo(either: Either&lt;String&gt;) -&gt; String {<br>&gt; 	if let string = either.optional {<br>&gt; 		return string<br>&gt; 	} else {<br>&gt; 		return &quot;No value&quot;<br>&gt; 	}<br>&gt; }<br>&gt; ```<br>&gt; is introducing unnecessary noise in the otherwise neat syntax. The problem escalates when `if let` cascade is used:<br>&gt; ```<br>&gt; if let string = eitherString.optional<br>&gt;            int = eitherInt.optional<br>&gt;            array = eitherArray.optional <br>&gt; // ...<br>&gt; ```<br>&gt; <br>&gt; <br>&gt; # Alternatives considered<br>&gt; <br>&gt; The equivalent of Haskell’s `do-notation`. It’s a powerful construct (some say even too powerful, see https://wiki.haskell.org/Do_notation_considered_harmful &lt;https://wiki.haskell.org/Do_notation_considered_harmful&gt;). However, I can’t imagine it without significant changes to the language syntax (`if let` should return value) and vision (I believe that Optional are syntactic unicorns by design).<br>&gt; <br>&gt; <br>&gt; All the best,<br>&gt; Krzysztof<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/9d974b33/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: extend Optional-specific syntax to arbitrary types with CustomOptionalConvertible</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December  7, 2015 at 01:00:00pm</p></header><div class="content"><p>I agree. The motivation of this proposal is laudable, but I&#39;m not sure it actually gains anything over just defining a property of optional type on the type in question. For example, with your Either enum, you might have:<br></p><p>var left: ErrorType?    var right: Value?<br></p><p>This requires no language changes and allows the use of if-let and<br>optional chaining. It also allows you to expose your different variants<br>as optional, instead of assuming that only one variant is special.<br></p><p>-Kevin Ballard<br></p><p>On Mon, Dec 7, 2015, at 01:38 PM, Paul Cantrell via swift-evolution wrote:<br>&gt; I like the sentiment of this proposal, but I’m not sure it provides<br>&gt; clear value. We already have a generalized version of “if let” in the<br>&gt; form of “if case”:<br>&gt;<br>&gt; func foo(either: Either&lt;String&gt;) -&gt; String { if case .Right(let<br>&gt; string) = either { return string        } else { return &quot;No<br>&gt; value&quot;        }    }<br>&gt;<br>&gt; This works with cascades just fine:<br>&gt;<br>&gt; if case .Right(let string0) = either0,            .Right(let string1)<br>&gt; = either1,            .Right(let string2) = either2 {<br>&gt;<br>&gt; Leaving aside that Swift’s “if case” syntax is a bit clumsy and hard<br>&gt; to remember at first, does a CustomOptionalConvertible really grant<br>&gt; additional benefit in terms of either safety or readability?<br>&gt;<br>&gt; Cheers,<br>&gt;<br>&gt; Paul<br>&gt;<br>&gt;<br>&gt;&gt; On Dec 7, 2015, at 2:58 PM, krzysztof at siejkowski.net via swift-<br>&gt;&gt; evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Hi,<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; # Introduction<br>&gt;&gt;<br>&gt;&gt; I&#39;d like to propose a non-invasive way of extending the funtionality<br>&gt;&gt; of `if let` conditional binding (and potencially other Optional-<br>&gt;&gt; related language constructs) by introducing<br>&gt;&gt; `CustomOptionalConvertible` protocol. The idea is basically the same<br>&gt;&gt; as with `CustomStringConvertible` protocol used to provide string<br>&gt;&gt; interpolation or with `~=` operator used in `switch` statement<br>&gt;&gt; pattern matching.  I believe it&#39;s going to simplity and unify the<br>&gt;&gt; use of the Optional-related family of Swift syntax constructs for<br>&gt;&gt; custom types.<br>&gt;&gt;<br>&gt;&gt; The proposal is in a draft stage right now, I&#39;ll clear it up if it<br>&gt;&gt; proves worth to be pull-requested.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; # Motivation<br>&gt;&gt;<br>&gt;&gt; One of the Swift features that are core to it&#39;s safety and<br>&gt;&gt; readability are Optionals. They&#39;re important enough to be given<br>&gt;&gt; special place in the language syntax. Special operators like `?`, `!`<br>&gt;&gt; or `??`, special casting keywords like `as?`, special conditional<br>&gt;&gt; binding `if let`. The Optionals, however, might be also seen as a<br>&gt;&gt; member of larger family of constructs: call them monads, boxes, value<br>&gt;&gt; containers, computational context bearers. One example of those would<br>&gt;&gt; be a very similar type going by the name of  Either, Try or Result.<br>&gt;&gt; It can be seen as an Optional that carries some additional<br>&gt;&gt; information about the reason why the value is absent. That<br>&gt;&gt; information is not always of our interest and in those cases<br>&gt;&gt; conditional binding  for Either type makes a lot of sense. However,<br>&gt;&gt; the `if let` syntax is currently exclusively working only for<br>&gt;&gt; optionals.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; # Proposed solution<br>&gt;&gt;<br>&gt;&gt; While I&#39;d love to see Swift introducing a powerful construct similar<br>&gt;&gt; to Haskell&#39;s `do-notation` or Scala&#39;s `for-comprehension`, I believe<br>&gt;&gt; it&#39;d require a significant invasive change in the language<br>&gt;&gt; implementation (and, possibly, vision). Therefore the proposed<br>&gt;&gt; solutions is much more humble. Let&#39;s introduce the<br>&gt;&gt; `CustomOptionalConvertible` protocol with signature:<br>&gt;&gt;<br>&gt;&gt; ``` protocol CustomOptionalConvertible { typealias Wrapped public var<br>&gt;&gt; optional: Optional&lt;Wrapped&gt; { get } } ```<br>&gt;&gt;<br>&gt;&gt; Such a protocol will provide a way for an arbitrary type to convert<br>&gt;&gt; to the Optional. All the types implementing this protocol could then<br>&gt;&gt; be used in conditional binding syntax without explicit declaration of<br>&gt;&gt; conversion. I do not propose the introduction of general implicit<br>&gt;&gt; conversion construct, just a special case. The same as<br>&gt;&gt; `CustomStringConvertible` is a special case of allowing the value to<br>&gt;&gt; express itself in the string<br>&gt;&gt; interpolation.`CustomOptionalConvertible` will allow the author of an<br>&gt;&gt; arbitratry type to integrate with Swift syntax:<br>&gt;&gt;<br>&gt;&gt; ``` enum Either&lt;Value&gt; { case Left(ErrorType) case Right(Value) }<br>&gt;&gt;<br>&gt;&gt; extension Either : CustomOptionalConvertible { typealias Wrapped =<br>&gt;&gt; Value public var optional: Optional&lt;Value&gt; { get { switch (self) {<br>&gt;&gt; case .Left(_): return .None case .Right(let value): return<br>&gt;&gt; .Some(value) } } } }<br>&gt;&gt;<br>&gt;&gt; func foo(either: Either&lt;String&gt;) -&gt; String { if let string = either {<br>&gt;&gt; return string } else { return &quot;No value&quot; } } ```<br>&gt;&gt;<br>&gt;&gt; There is already a similar mechanism available in the context of<br>&gt;&gt; pattern matching: `~=` operator.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; # Impact on the language<br>&gt;&gt;<br>&gt;&gt; While I cannot say much about the impact on the compiler, I believe<br>&gt;&gt; the introduction will bring no breaking change to the Swift language<br>&gt;&gt; itself. All the places that are currently requiring Optionals will<br>&gt;&gt; still require Optionals.<br>&gt;&gt;<br>&gt;&gt; For the language users it&#39;ll make it easier to integrate the<br>&gt;&gt; constructs used in the program with the native syntax, making them<br>&gt;&gt; easier to use and read. Current solution, namely: ``` func<br>&gt;&gt; foo(either: Either&lt;String&gt;) -&gt; String { if let string =<br>&gt;&gt; either.optional { return string } else { return &quot;No value&quot; } } ``` is<br>&gt;&gt; introducing unnecessary noise in the otherwise neat syntax. The<br>&gt;&gt; problem escalates when `if let` cascade is used: ``` if let string =<br>&gt;&gt; eitherString.optional           int = eitherInt.optional<br>&gt;&gt; array = eitherArray.optional // ... ```<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; # Alternatives considered<br>&gt;&gt;<br>&gt;&gt; The equivalent of Haskell’s `do-notation`. It’s a powerful construct<br>&gt;&gt; (some say even too powerful, see<br>&gt;&gt; https://wiki.haskell.org/Do_notation_considered_harmful). However, I<br>&gt;&gt; can’t imagine it without significant changes to the language syntax<br>&gt;&gt; (`if let` should return value) and vision (I believe that Optional<br>&gt;&gt; are syntactic unicorns by design).<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; All the best, Krzysztof<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/1388daba/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2ff1daab58cd5e44a457908d1905c322?s=50"></div><header><strong>Proposal: extend Optional-specific syntax to arbitrary types with CustomOptionalConvertible</strong> from <string>Krzysztof Siejkowski</string> &lt;krzysztof at siejkowski.net&gt;<p>December  7, 2015 at 11:00:00pm</p></header><div class="content"><p>First, thanks for the feedback! By no means is a `CustomOptionalConvertible` an essential addition to Swift, I just think it’s a low-hanging fruit in terms of unifying the usage of `if let` syntax. <br></p><p>The main idea would be to enable `if let` for predefined types (for example, provided by a third-party framework) without exposing their inner structure. I think it’s beneficial in terms of readability and clarity. Of course it might turn to be an unpopular opinion :)<br></p><p><br>Addressing Paul’s concerns: there are two drawback that I can see:<br></p><p>1) As far as I know, `if case` can be used only with enums (I&#39;d love to proven wrong)<br>2) It explicitly cites the inner structure of the type in the conditional binding. In the particular example - the existence of .Right cause and how many associated values it has.<br></p><p><br>Addressing Kevin’s concerns: I’ve already used a similar solution, namely:<br></p><p>    if let string = eitherString.optional<br></p><p>which is of course just a renaming of<br></p><p>    if let string = eitherString.right<br></p><p>There’s nothing wrong with that solution functionality-wise, I just find the ability to use<br></p><p>    if let string = someValue<br></p><p>consistently for all the types that the idea of conditional binding applies to more consistent and more readable. Please consider the conditional binding cascade for multiple types:<br></p><p>    if let string0 = eitherString.right<br>            string1 = optionalString<br>            string2 = futureString.get {<br></p><p>versus<br></p><p>    if let string0 = possibleString0<br>            string1 = possibleString1<br>            string2 = possileString2 {<br></p><p>where no knowledge about the inner structure of the possibleStringN values is exposed - the only thing that matters here is the applicability of conditional binding.<br></p><p><br>All the best,<br>Krzysztof<br></p><p><br>From: Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt;<br>Reply: Kevin Ballard &lt;kevin at sb.org&gt;<br>Date: December 7, 2015 at 10:47:23 PM<br>To: swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;<br>Subject:  Re: [swift-evolution] Proposal: extend Optional-specific syntax to arbitrary types with CustomOptionalConvertible  <br></p><p>I agree. The motivation of this proposal is laudable, but I&#39;m not sure it actually gains anything over just defining a property of optional type on the type in question. For example, with your Either enum, you might have:<br> <br>    var left: ErrorType?<br>    var right: Value?<br> <br>This requires no language changes and allows the use of if-let and optional chaining. It also allows you to expose your different variants as optional, instead of assuming that only one variant is special. <br> <br>-Kevin Ballard<br> <br>On Mon, Dec 7, 2015, at 01:38 PM, Paul Cantrell via swift-evolution wrote:<br>I like the sentiment of this proposal, but I’m not sure it provides clear value. We already have a generalized version of “if let” in the form of “if case”:<br> <br>func foo(either: Either&lt;String&gt;) -&gt; String {<br>if case .Right(let string) = either {<br>return string<br>        } else {<br>return &quot;No value&quot;<br>        }<br>    }<br> <br>This works with cascades just fine:<br> <br>if case .Right(let string0) = either0,<br>            .Right(let string1) = either1,<br>            .Right(let string2) = either2 {<br> <br>Leaving aside that Swift’s “if case” syntax is a bit clumsy and hard to remember at first, does a CustomOptionalConvertible really grant additional benefit in terms of either safety or readability?<br> <br>Cheers,<br> <br>Paul<br> <br> <br>On Dec 7, 2015, at 2:58 PM, krzysztof at siejkowski.net via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br> <br>Hi,<br> <br> <br># Introduction<br> <br>I&#39;d like to propose a non-invasive way of extending the funtionality of `if let` conditional binding (and potencially other Optional-related language constructs) by introducing `CustomOptionalConvertible` protocol. The idea is basically the same as with `CustomStringConvertible` protocol used to provide string interpolation or with `~=` operator used in `switch` statement pattern matching.  I believe it&#39;s going to simplity and unify the use of the Optional-related family of Swift syntax constructs for custom types.<br> <br>The proposal is in a draft stage right now, I&#39;ll clear it up if it proves worth to be pull-requested.<br> <br> <br># Motivation<br> <br>One of the Swift features that are core to it&#39;s safety and readability are Optionals. They&#39;re important enough to be given special place in the language syntax. Special operators like `?`, `!` or `??`, special casting keywords like `as?`, special conditional binding `if let`. The Optionals, however, might be also seen as a member of larger family of constructs: call them monads, boxes, value containers, computational context bearers. One example of those would be a very similar type going by the name of  Either, Try or Result. It can be seen as an Optional that carries some additional information about the reason why the value is absent. That information is not always of our interest and in those cases conditional binding  for Either type makes a lot of sense. However, the `if let` syntax is currently exclusively working only for optionals.<br> <br> <br># Proposed solution<br> <br>While I&#39;d love to see Swift introducing a powerful construct similar to Haskell&#39;s `do-notation` or Scala&#39;s `for-comprehension`, I believe it&#39;d require a significant invasive change in the language implementation (and, possibly, vision). Therefore the proposed solutions is much more humble. Let&#39;s introduce the `CustomOptionalConvertible` protocol with signature:<br> <br>```<br>protocol CustomOptionalConvertible {<br>typealias Wrapped<br>public var optional: Optional&lt;Wrapped&gt; { get }<br>}<br>```<br> <br>Such a protocol will provide a way for an arbitrary type to convert to the Optional. All the types implementing this protocol could then be used in conditional binding syntax without explicit declaration of conversion. I do not propose the introduction of general implicit conversion construct, just a special case. The same as `CustomStringConvertible` is a special case of allowing the value to express itself in the string interpolation.`CustomOptionalConvertible` will allow the author of an arbitratry type to integrate with Swift syntax:<br> <br>```<br>enum Either&lt;Value&gt; {<br>case Left(ErrorType)<br>case Right(Value)<br>}<br> <br>extension Either : CustomOptionalConvertible {<br>typealias Wrapped = Value<br>public var optional: Optional&lt;Value&gt; {<br>get {<br>switch (self) {<br>case .Left(_): return .None<br>case .Right(let value): return .Some(value)<br>}<br>}<br>} <br>}<br> <br>func foo(either: Either&lt;String&gt;) -&gt; String {<br>if let string = either {<br>return string<br>} else {<br>return &quot;No value&quot;<br>}<br>}<br>```<br> <br>There is already a similar mechanism available in the context of pattern matching: `~=` operator.<br> <br> <br># Impact on the language<br> <br>While I cannot say much about the impact on the compiler, I believe the introduction will bring no breaking change to the Swift language itself. All the places that are currently requiring Optionals will still require Optionals. <br> <br>For the language users it&#39;ll make it easier to integrate the constructs used in the program with the native syntax, making them easier to use and read. Current solution, namely:<br>```<br>func foo(either: Either&lt;String&gt;) -&gt; String {<br>if let string = either.optional {<br>return string<br>} else {<br>return &quot;No value&quot;<br>}<br>}<br>```<br>is introducing unnecessary noise in the otherwise neat syntax. The problem escalates when `if let` cascade is used:<br>```<br>if let string = eitherString.optional<br>           int = eitherInt.optional<br>           array = eitherArray.optional <br>// ...<br>```<br> <br> <br># Alternatives considered<br> <br>The equivalent of Haskell’s `do-notation`. It’s a powerful construct (some say even too powerful, seehttps://wiki.haskell.org/Do_notation_considered_harmful). However, I can’t imagine it without significant changes to the language syntax (`if let` should return value) and vision (I believe that Optional are syntactic unicorns by design).<br> <br> <br>All the best,<br>Krzysztof<br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br> <br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br> <br> _______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/7023428c/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: extend Optional-specific syntax to arbitrary types with CustomOptionalConvertible</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December  7, 2015 at 09:00:00pm</p></header><div class="content"><p>For what it&#39;s worth, I filed a radar for a protocol along these lines epic the early days OS Swift, but took a slightly different approach.  It looked something like this:<br></p><p>protocol PossibleValueType {<br>     typealias Value<br>    var hasValue: Bool { get }<br>    var value: Value // implementations call fatalError or similar if hasValue is false<br>}<br></p><p>Rather than returning an Optional that wraps the value we allow presence or absence of value to be detected and if a value is present we allow it to be extracted.<br></p><p>Matthew<br></p><p>Sent from my iPad<br></p><p>&gt; On Dec 7, 2015, at 3:38 PM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I like the sentiment of this proposal, but I’m not sure it provides clear value. We already have a generalized version of “if let” in the form of “if case”:<br>&gt; <br>&gt;     func foo(either: Either&lt;String&gt;) -&gt; String {<br>&gt;         if case .Right(let string) = either {<br>&gt;             return string<br>&gt;         } else {<br>&gt;             return &quot;No value&quot;<br>&gt;         }<br>&gt;     }<br>&gt; <br>&gt; This works with cascades just fine:<br>&gt; <br>&gt;     if case .Right(let string0) = either0,<br>&gt;             .Right(let string1) = either1,<br>&gt;             .Right(let string2) = either2 {<br>&gt; <br>&gt; Leaving aside that Swift’s “if case” syntax is a bit clumsy and hard to remember at first, does a CustomOptionalConvertible really grant additional benefit in terms of either safety or readability?<br>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; Paul<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 7, 2015, at 2:58 PM, krzysztof at siejkowski.net via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi,<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; # Introduction<br>&gt;&gt; <br>&gt;&gt; I&#39;d like to propose a non-invasive way of extending the funtionality of `if let` conditional binding (and potencially other Optional-related language constructs) by introducing `CustomOptionalConvertible` protocol. The idea is basically the same as with `CustomStringConvertible` protocol used to provide string interpolation or with `~=` operator used in `switch` statement pattern matching.  I believe it&#39;s going to simplity and unify the use of the Optional-related family of Swift syntax constructs for custom types.<br>&gt;&gt; <br>&gt;&gt; The proposal is in a draft stage right now, I&#39;ll clear it up if it proves worth to be pull-requested.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; # Motivation<br>&gt;&gt; <br>&gt;&gt; One of the Swift features that are core to it&#39;s safety and readability are Optionals. They&#39;re important enough to be given special place in the language syntax. Special operators like `?`, `!` or `??`, special casting keywords like `as?`, special conditional binding `if let`. The Optionals, however, might be also seen as a member of larger family of constructs: call them monads, boxes, value containers, computational context bearers. One example of those would be a very similar type going by the name of  Either, Try or Result. It can be seen as an Optional that carries some additional information about the reason why the value is absent. That information is not always of our interest and in those cases conditional binding  for Either type makes a lot of sense. However, the `if let` syntax is currently exclusively working only for optionals.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; # Proposed solution<br>&gt;&gt; <br>&gt;&gt; While I&#39;d love to see Swift introducing a powerful construct similar to Haskell&#39;s `do-notation` or Scala&#39;s `for-comprehension`, I believe it&#39;d require a significant invasive change in the language implementation (and, possibly, vision). Therefore the proposed solutions is much more humble. Let&#39;s introduce the `CustomOptionalConvertible` protocol with signature:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; protocol CustomOptionalConvertible {<br>&gt;&gt; 	typealias Wrapped<br>&gt;&gt; 	public var optional: Optional&lt;Wrapped&gt; { get }<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; Such a protocol will provide a way for an arbitrary type to convert to the Optional. All the types implementing this protocol could then be used in conditional binding syntax without explicit declaration of conversion. I do not propose the introduction of general implicit conversion construct, just a special case. The same as `CustomStringConvertible` is a special case of allowing the value to express itself in the string interpolation.`CustomOptionalConvertible` will allow the author of an arbitratry type to integrate with Swift syntax:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; enum Either&lt;Value&gt; {<br>&gt;&gt; 	case Left(ErrorType)<br>&gt;&gt; 	case Right(Value)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension Either : CustomOptionalConvertible {<br>&gt;&gt; 	typealias Wrapped = Value<br>&gt;&gt; 	public var optional: Optional&lt;Value&gt; {<br>&gt;&gt; 		get {<br>&gt;&gt; 			switch (self) {<br>&gt;&gt; 			case .Left(_): return .None<br>&gt;&gt; 			case .Right(let value): return .Some(value)<br>&gt;&gt; 			}<br>&gt;&gt; 		}<br>&gt;&gt; 	} <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func foo(either: Either&lt;String&gt;) -&gt; String {<br>&gt;&gt; 	if let string = either {<br>&gt;&gt; 		return string<br>&gt;&gt; 	} else {<br>&gt;&gt; 		return &quot;No value&quot;<br>&gt;&gt; 	}<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; There is already a similar mechanism available in the context of pattern matching: `~=` operator.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; # Impact on the language<br>&gt;&gt; <br>&gt;&gt; While I cannot say much about the impact on the compiler, I believe the introduction will bring no breaking change to the Swift language itself. All the places that are currently requiring Optionals will still require Optionals. <br>&gt;&gt; <br>&gt;&gt; For the language users it&#39;ll make it easier to integrate the constructs used in the program with the native syntax, making them easier to use and read. Current solution, namely:<br>&gt;&gt; ```<br>&gt;&gt; func foo(either: Either&lt;String&gt;) -&gt; String {<br>&gt;&gt; 	if let string = either.optional {<br>&gt;&gt; 		return string<br>&gt;&gt; 	} else {<br>&gt;&gt; 		return &quot;No value&quot;<br>&gt;&gt; 	}<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; is introducing unnecessary noise in the otherwise neat syntax. The problem escalates when `if let` cascade is used:<br>&gt;&gt; ```<br>&gt;&gt; if let string = eitherString.optional<br>&gt;&gt;            int = eitherInt.optional<br>&gt;&gt;            array = eitherArray.optional <br>&gt;&gt; // ...<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; # Alternatives considered<br>&gt;&gt; <br>&gt;&gt; The equivalent of Haskell’s `do-notation`. It’s a powerful construct (some say even too powerful, see https://wiki.haskell.org/Do_notation_considered_harmful). However, I can’t imagine it without significant changes to the language syntax (`if let` should return value) and vision (I believe that Optional are syntactic unicorns by design).<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; All the best,<br>&gt;&gt; Krzysztof<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/f02cd95a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2ff1daab58cd5e44a457908d1905c322?s=50"></div><header><strong>Proposal: extend Optional-specific syntax to arbitrary types with CustomOptionalConvertible</strong> from <string>Krzysztof Siejkowski</string> &lt;krzysztof at siejkowski.net&gt;<p>December  8, 2015 at 03:00:00pm</p></header><div class="content"><p>Was it a part of your idea to allow the `PossibleValueType` to be used in Optional-only syntax constructs like conditional binding? If so, do you see any advantages of such solution over `CustomOptionalConvertible`?<br></p><p>Cheers,<br>Krzysztof<br></p><p>On 8 December 2015 at 04:46:55, Matthew Johnson (matthew at anandabits.com) wrote:<br></p><p>For what it&#39;s worth, I filed a radar for a protocol along these lines epic the early days OS Swift, but took a slightly different approach.  It looked something like this:<br></p><p>protocol PossibleValueType {<br>     typealias Value<br>    var hasValue: Bool { get }<br>    var value: Value // implementations call fatalError or similar if hasValue is false<br>}<br></p><p>Rather than returning an Optional that wraps the value we allow presence or absence of value to be detected and if a value is present we allow it to be extracted.<br></p><p>Matthew<br></p><p>Sent from my iPad<br></p><p>On Dec 7, 2015, at 3:38 PM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>I like the sentiment of this proposal, but I’m not sure it provides clear value. We already have a generalized version of “if let” in the form of “if case”:<br></p><p>    func foo(either: Either&lt;String&gt;) -&gt; String {<br>        if case .Right(let string) = either {<br>            return string<br>        } else {<br>            return &quot;No value&quot;<br>        }<br>    }<br></p><p>This works with cascades just fine:<br></p><p>    if case .Right(let string0) = either0,<br>            .Right(let string1) = either1,<br>            .Right(let string2) = either2 {<br></p><p>Leaving aside that Swift’s “if case” syntax is a bit clumsy and hard to remember at first, does a CustomOptionalConvertible really grant additional benefit in terms of either safety or readability?<br></p><p>Cheers,<br></p><p>Paul<br></p><p><br>On Dec 7, 2015, at 2:58 PM, krzysztof at siejkowski.net via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>Hi,<br></p><p><br># Introduction<br></p><p>I&#39;d like to propose a non-invasive way of extending the funtionality of `if let` conditional binding (and potencially other Optional-related language constructs) by introducing `CustomOptionalConvertible` protocol. The idea is basically the same as with `CustomStringConvertible` protocol used to provide string interpolation or with `~=` operator used in `switch` statement pattern matching.  I believe it&#39;s going to simplity and unify the use of the Optional-related family of Swift syntax constructs for custom types.<br></p><p>The proposal is in a draft stage right now, I&#39;ll clear it up if it proves worth to be pull-requested.<br></p><p><br># Motivation<br></p><p>One of the Swift features that are core to it&#39;s safety and readability are Optionals. They&#39;re important enough to be given special place in the language syntax. Special operators like `?`, `!` or `??`, special casting keywords like `as?`, special conditional binding `if let`. The Optionals, however, might be also seen as a member of larger family of constructs: call them monads, boxes, value containers, computational context bearers. One example of those would be a very similar type going by the name of  Either, Try or Result. It can be seen as an Optional that carries some additional information about the reason why the value is absent. That information is not always of our interest and in those cases conditional binding  for Either type makes a lot of sense. However, the `if let` syntax is currently exclusively working only for optionals.<br></p><p><br># Proposed solution<br></p><p>While I&#39;d love to see Swift introducing a powerful construct similar to Haskell&#39;s `do-notation` or Scala&#39;s `for-comprehension`, I believe it&#39;d require a significant invasive change in the language implementation (and, possibly, vision). Therefore the proposed solutions is much more humble. Let&#39;s introduce the `CustomOptionalConvertible` protocol with signature:<br></p><p>```<br>protocol CustomOptionalConvertible {<br>typealias Wrapped<br>public var optional: Optional&lt;Wrapped&gt; { get }<br>}<br>```<br></p><p>Such a protocol will provide a way for an arbitrary type to convert to the Optional. All the types implementing this protocol could then be used in conditional binding syntax without explicit declaration of conversion. I do not propose the introduction of general implicit conversion construct, just a special case. The same as `CustomStringConvertible` is a special case of allowing the value to express itself in the string interpolation.`CustomOptionalConvertible` will allow the author of an arbitratry type to integrate with Swift syntax:<br></p><p>```<br>enum Either&lt;Value&gt; {<br>case Left(ErrorType)<br>case Right(Value)<br>}<br></p><p>extension Either : CustomOptionalConvertible {<br>typealias Wrapped = Value<br>public var optional: Optional&lt;Value&gt; {<br>get {<br>switch (self) {<br>case .Left(_): return .None<br>case .Right(let value): return .Some(value)<br>}<br>}<br>} <br>}<br></p><p>func foo(either: Either&lt;String&gt;) -&gt; String {<br>if let string = either {<br>return string<br>} else {<br>return &quot;No value&quot;<br>}<br>}<br>```<br></p><p>There is already a similar mechanism available in the context of pattern matching: `~=` operator.<br></p><p><br># Impact on the language<br></p><p>While I cannot say much about the impact on the compiler, I believe the introduction will bring no breaking change to the Swift language itself. All the places that are currently requiring Optionals will still require Optionals. <br></p><p>For the language users it&#39;ll make it easier to integrate the constructs used in the program with the native syntax, making them easier to use and read. Current solution, namely:<br>```<br>func foo(either: Either&lt;String&gt;) -&gt; String {<br>if let string = either.optional {<br>return string<br>} else {<br>return &quot;No value&quot;<br>}<br>}<br>```<br>is introducing unnecessary noise in the otherwise neat syntax. The problem escalates when `if let` cascade is used:<br>```<br>if let string = eitherString.optional<br>           int = eitherInt.optional<br>           array = eitherArray.optional <br>// ...<br>```<br></p><p><br># Alternatives considered<br></p><p>The equivalent of Haskell’s `do-notation`. It’s a powerful construct (some say even too powerful, see https://wiki.haskell.org/Do_notation_considered_harmful). However, I can’t imagine it without significant changes to the language syntax (`if let` should return value) and vision (I believe that Optional are syntactic unicorns by design).<br></p><p><br>All the best,<br>Krzysztof<br> _______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/c827f941/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: extend Optional-specific syntax to arbitrary types with CustomOptionalConvertible</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December  8, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; Was it a part of your idea to allow the `PossibleValueType` to be used in Optional-only syntax constructs like conditional binding? If so, do you see any advantages of such solution over `CustomOptionalConvertible`?<br>&gt; <br></p><p>Yes that was the point of it.  <br></p><p>The biggest difference is probably avoiding the need to wrap the value in an Optional.  I&#39;m not sure whether that would be a significant advantage or not but I believe it would avoid some copying and reference counting operations.<br></p><p>Matthew<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/6f506476/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
