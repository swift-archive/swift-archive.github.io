<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f13662914188bbe1364b8b910dd4aa8c?s=50"></div><header><strong>Swift incremental compile profiling</strong> from <string>Samantha John</string> &lt;sam at gethopscotch.com&gt;<p>March 31, 2016 at 02:00:00pm</p></header><div class="content"><p>I have a large project (308 swift files, 441 objective c, 66k lines of<br>code) where incremental builds can be extremely slow. I&#39;m trying to do some<br>profiling to figure out what type of things cause large scale recompiles.<br>The problem is that I can&#39;t find a good way of telling which files get<br>recompiled on an incremental build and which do not. It seems like files<br>that are not recompiled still get listed in xcode, but the compiler just<br>passes over them really fast.<br></p><p>Does anyone know if xctool or xcodebuild has this type of functionality? Or<br>is there some other way to get this info?<br></p><p>Thank you,<br>Sam<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160331/ec6531e5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Swift incremental compile profiling</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>April  5, 2016 at 06:00:00pm</p></header><div class="content"><p>Hi, Sam. I don&#39;t think we currently have a good answer for this built into xcodebuild or xctool, and it&#39;s a reasonable idea. (Ideally all builds would be fast enough that it wouldn&#39;t matter! That&#39;s obviously not where we are.)<br></p><p>Since &#39;-debug-time-function-bodies&#39; is now public knowledge, I&#39;ll share another one of our debugging flags, &#39;-driver-show-incremental&#39;. You can add this to your &quot;Other Swift Flags&quot;. The output isn&#39;t very detailed, though:<br></p><p>Queuing Tree.swift (initial)<br>Queuing AdventureScene.swift (initial)<br>Queuing AdventureScene.swift because of dependencies discovered later<br>Queuing AppDelegate.swift because of dependencies discovered later<br>Queuing ChaseArtificialIntelligence.swift because of dependencies discovered later<br>Queuing Character.swift because of dependencies discovered later<br>Queuing SpawnArtificialIntelligence.swift because of dependencies discovered later<br>Queuing Goblin.swift because of dependencies discovered later<br>Queuing Cave.swift because of dependencies discovered later<br>Queuing AdventureSceneOSXEvents.swift because of dependencies discovered later<br>Queuing HeroCharacter.swift because of dependencies discovered later<br>Queuing EnemyCharacter.swift because of dependencies discovered later<br>Queuing Boss.swift because of dependencies discovered later<br>Queuing SharedAssetManagement.swift because of dependencies discovered later<br>Queuing Warrior.swift because of dependencies discovered later<br>Queuing Archer.swift because of dependencies discovered later<br>Queuing Player.swift because of dependencies discovered later<br>Queuing ArtificialIntelligence.swift because of dependencies discovered later<br></p><p>In this case, I took a version of the Adventure sample project and modified &quot;Tree.swift&quot;; that triggered recompilation of several other files. Unfortunately this view doesn&#39;t tell you how they&#39;re related, only which ones are actually getting rebuilt.<br></p><p>The next step (and moving into the territory of &quot;working on Swift&quot; rather than just &quot;trying to figure out why it&#39;s repeating work&quot;) would be to look at the &quot;swiftdeps&quot; files stored in your DerivedData folder. These are currently just YAML files describing what Swift thinks the file depends on, as well as what will trigger rebuilding of other files. This is intended to be a conservative estimate, since not recompiling something would result in an invalid binary. (Unfortunately I say &quot;intended&quot; because there are known bugs; fortunately, archive builds are always clean builds anyway.)<br></p><p>There&#39;s a document in the Swift repo describing the logic behind Swift&#39;s dependency analysis: https://github.com/apple/swift/blob/master/docs/DependencyAnalysis.rst &lt;https://github.com/apple/swift/blob/master/docs/DependencyAnalysis.rst&gt;. The one thing that&#39;s not in there is the notion of changes that don&#39;t affect other files at all. This is accomplished by computing a hash of all the tokens that could affect other files, and seeing if that hash has changed.<br></p><p>We definitely have room for improvement here.<br></p><p>Jordan<br></p><p><br>&gt; On Mar 31, 2016, at 11:24 , Samantha John via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; I have a large project (308 swift files, 441 objective c, 66k lines of code) where incremental builds can be extremely slow. I&#39;m trying to do some profiling to figure out what type of things cause large scale recompiles. The problem is that I can&#39;t find a good way of telling which files get recompiled on an incremental build and which do not. It seems like files that are not recompiled still get listed in xcode, but the compiler just passes over them really fast. <br>&gt; <br>&gt; Does anyone know if xctool or xcodebuild has this type of functionality? Or is there some other way to get this info?<br>&gt; <br>&gt; Thank you,<br>&gt; Sam<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160405/667c1d5f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f13662914188bbe1364b8b910dd4aa8c?s=50"></div><header><strong>Swift incremental compile profiling</strong> from <string>Samantha John</string> &lt;sam at gethopscotch.com&gt;<p>April  7, 2016 at 05:00:00pm</p></header><div class="content"><p>Thank you Jordan! This is a great starting off point.<br></p><p>I&#39;m thinking about proposing a &quot;strict import&quot; mode in swift: A compile<br>flag that when turned on would require you to explicitly import any file<br>that contained a dependency you needed (like in objective-c).<br></p><p>I&#39;m going to spend more time looking over the docs and the output logs to<br>see if this would be a feasible. If anyone has opinions or insights into<br>this I would love to hear from you.<br></p><p>Sam<br></p><p>On Tue, Apr 5, 2016 at 9:08 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br></p><p>&gt; Hi, Sam. I don&#39;t think we currently have a good answer for this built into<br>&gt; xcodebuild or xctool, and it&#39;s a reasonable idea. (Ideally all builds would<br>&gt; be fast enough that it wouldn&#39;t matter! That&#39;s obviously not where we are.)<br>&gt;<br>&gt; Since &#39;-debug-time-function-bodies&#39; is now public knowledge, I&#39;ll share<br>&gt; another one of our debugging flags, &#39;-driver-show-incremental&#39;. You can add<br>&gt; this to your &quot;Other Swift Flags&quot;. The output isn&#39;t very detailed, though:<br>&gt;<br>&gt; Queuing Tree.swift (initial)<br>&gt; Queuing AdventureScene.swift (initial)<br>&gt; Queuing AdventureScene.swift because of dependencies discovered later<br>&gt; Queuing AppDelegate.swift because of dependencies discovered later<br>&gt; Queuing ChaseArtificialIntelligence.swift because of dependencies<br>&gt; discovered later<br>&gt; Queuing Character.swift because of dependencies discovered later<br>&gt; Queuing SpawnArtificialIntelligence.swift because of dependencies<br>&gt; discovered later<br>&gt; Queuing Goblin.swift because of dependencies discovered later<br>&gt; Queuing Cave.swift because of dependencies discovered later<br>&gt; Queuing AdventureSceneOSXEvents.swift because of dependencies discovered<br>&gt; later<br>&gt; Queuing HeroCharacter.swift because of dependencies discovered later<br>&gt; Queuing EnemyCharacter.swift because of dependencies discovered later<br>&gt; Queuing Boss.swift because of dependencies discovered later<br>&gt; Queuing SharedAssetManagement.swift because of dependencies discovered<br>&gt; later<br>&gt; Queuing Warrior.swift because of dependencies discovered later<br>&gt; Queuing Archer.swift because of dependencies discovered later<br>&gt; Queuing Player.swift because of dependencies discovered later<br>&gt; Queuing ArtificialIntelligence.swift because of dependencies discovered<br>&gt; later<br>&gt;<br>&gt; In this case, I took a version of the Adventure sample project and<br>&gt; modified &quot;Tree.swift&quot;; that triggered recompilation of several other files.<br>&gt; Unfortunately this view doesn&#39;t tell you how they&#39;re related, only which<br>&gt; ones are actually getting rebuilt.<br>&gt;<br>&gt; The next step (and moving into the territory of &quot;working on Swift&quot; rather<br>&gt; than just &quot;trying to figure out why it&#39;s repeating work&quot;) would be to look<br>&gt; at the &quot;swiftdeps&quot; files stored in your DerivedData folder. These are<br>&gt; currently just YAML files describing what Swift thinks the file depends on,<br>&gt; as well as what will trigger rebuilding of other files. This is intended to<br>&gt; be a conservative estimate, since *not* recompiling something would<br>&gt; result in an invalid binary. (Unfortunately I say &quot;intended&quot; because there<br>&gt; are known bugs; fortunately, archive builds are always clean builds anyway.)<br>&gt;<br>&gt; There&#39;s a document in the Swift repo describing the logic behind Swift&#39;s<br>&gt; dependency analysis:<br>&gt; https://github.com/apple/swift/blob/master/docs/DependencyAnalysis.rst.<br>&gt; The one thing that&#39;s *not* in there is the notion of changes that don&#39;t<br>&gt; affect other files at all. This is accomplished by computing a hash of all<br>&gt; the tokens that *could* affect other files, and seeing if that hash has<br>&gt; changed.<br>&gt;<br>&gt; We definitely have room for improvement here.<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt;<br>&gt; On Mar 31, 2016, at 11:24 , Samantha John via swift-dev &lt;<br>&gt; swift-dev at swift.org&gt; wrote:<br>&gt;<br>&gt; I have a large project (308 swift files, 441 objective c, 66k lines of<br>&gt; code) where incremental builds can be extremely slow. I&#39;m trying to do some<br>&gt; profiling to figure out what type of things cause large scale recompiles.<br>&gt; The problem is that I can&#39;t find a good way of telling which files get<br>&gt; recompiled on an incremental build and which do not. It seems like files<br>&gt; that are not recompiled still get listed in xcode, but the compiler just<br>&gt; passes over them really fast.<br>&gt;<br>&gt; Does anyone know if xctool or xcodebuild has this type of functionality?<br>&gt; Or is there some other way to get this info?<br>&gt;<br>&gt; Thank you,<br>&gt; Sam<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160407/693f9b75/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ab16ef0384ba9270ddc26abea6c0d413?s=50"></div><header><strong>Swift incremental compile profiling</strong> from <string>George King</string> &lt;gwk.lists at gmail.com&gt;<p>April  8, 2016 at 05:00:00pm</p></header><div class="content"><p>Hey Sam,<br></p><p>One thought: if you have an app with mixed objc and swift code, then the app-bridge.h and app-swift.h files might be creating massive choke points in your dependency graph. I have no idea how optimized the bridging functionality is but it has always seemed like a potentially weak part of the dependency management. I imagine that with an objc half and a swift half of the code base, every time you make a change in a swift file you trigger recompilation of the objc half, and vice versa. I&#39;d love to hear from the core team to what extent this is true!<br></p><p>George<br></p><p><br></p><p>&gt; On Apr 7, 2016, at 5:35 PM, Samantha John via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Thank you Jordan! This is a great starting off point.<br>&gt; <br>&gt; I&#39;m thinking about proposing a &quot;strict import&quot; mode in swift: A compile flag that when turned on would require you to explicitly import any file that contained a dependency you needed (like in objective-c).<br>&gt; <br>&gt; I&#39;m going to spend more time looking over the docs and the output logs to see if this would be a feasible. If anyone has opinions or insights into this I would love to hear from you. <br>&gt; <br>&gt; Sam<br>&gt; <br>&gt; On Tue, Apr 5, 2016 at 9:08 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt; Hi, Sam. I don&#39;t think we currently have a good answer for this built into xcodebuild or xctool, and it&#39;s a reasonable idea. (Ideally all builds would be fast enough that it wouldn&#39;t matter! That&#39;s obviously not where we are.)<br>&gt; <br>&gt; Since &#39;-debug-time-function-bodies&#39; is now public knowledge, I&#39;ll share another one of our debugging flags, &#39;-driver-show-incremental&#39;. You can add this to your &quot;Other Swift Flags&quot;. The output isn&#39;t very detailed, though:<br>&gt; <br>&gt; Queuing Tree.swift (initial)<br>&gt; Queuing AdventureScene.swift (initial)<br>&gt; Queuing AdventureScene.swift because of dependencies discovered later<br>&gt; Queuing AppDelegate.swift because of dependencies discovered later<br>&gt; Queuing ChaseArtificialIntelligence.swift because of dependencies discovered later<br>&gt; Queuing Character.swift because of dependencies discovered later<br>&gt; Queuing SpawnArtificialIntelligence.swift because of dependencies discovered later<br>&gt; Queuing Goblin.swift because of dependencies discovered later<br>&gt; Queuing Cave.swift because of dependencies discovered later<br>&gt; Queuing AdventureSceneOSXEvents.swift because of dependencies discovered later<br>&gt; Queuing HeroCharacter.swift because of dependencies discovered later<br>&gt; Queuing EnemyCharacter.swift because of dependencies discovered later<br>&gt; Queuing Boss.swift because of dependencies discovered later<br>&gt; Queuing SharedAssetManagement.swift because of dependencies discovered later<br>&gt; Queuing Warrior.swift because of dependencies discovered later<br>&gt; Queuing Archer.swift because of dependencies discovered later<br>&gt; Queuing Player.swift because of dependencies discovered later<br>&gt; Queuing ArtificialIntelligence.swift because of dependencies discovered later<br>&gt; <br>&gt; In this case, I took a version of the Adventure sample project and modified &quot;Tree.swift&quot;; that triggered recompilation of several other files. Unfortunately this view doesn&#39;t tell you how they&#39;re related, only which ones are actually getting rebuilt.<br>&gt; <br>&gt; The next step (and moving into the territory of &quot;working on Swift&quot; rather than just &quot;trying to figure out why it&#39;s repeating work&quot;) would be to look at the &quot;swiftdeps&quot; files stored in your DerivedData folder. These are currently just YAML files describing what Swift thinks the file depends on, as well as what will trigger rebuilding of other files. This is intended to be a conservative estimate, since not recompiling something would result in an invalid binary. (Unfortunately I say &quot;intended&quot; because there are known bugs; fortunately, archive builds are always clean builds anyway.)<br>&gt; <br>&gt; There&#39;s a document in the Swift repo describing the logic behind Swift&#39;s dependency analysis: https://github.com/apple/swift/blob/master/docs/DependencyAnalysis.rst &lt;https://github.com/apple/swift/blob/master/docs/DependencyAnalysis.rst&gt;. The one thing that&#39;s not in there is the notion of changes that don&#39;t affect other files at all. This is accomplished by computing a hash of all the tokens that could affect other files, and seeing if that hash has changed.<br>&gt; <br>&gt; We definitely have room for improvement here.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 31, 2016, at 11:24 , Samantha John via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I have a large project (308 swift files, 441 objective c, 66k lines of code) where incremental builds can be extremely slow. I&#39;m trying to do some profiling to figure out what type of things cause large scale recompiles. The problem is that I can&#39;t find a good way of telling which files get recompiled on an incremental build and which do not. It seems like files that are not recompiled still get listed in xcode, but the compiler just passes over them really fast. <br>&gt;&gt; <br>&gt;&gt; Does anyone know if xctool or xcodebuild has this type of functionality? Or is there some other way to get this info?<br>&gt;&gt; <br>&gt;&gt; Thank you,<br>&gt;&gt; Sam<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160408/63bf2e1b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f13662914188bbe1364b8b910dd4aa8c?s=50"></div><header><strong>Swift incremental compile profiling</strong> from <string>Samantha John</string> &lt;sam at gethopscotch.com&gt;<p>April 13, 2016 at 05:00:00pm</p></header><div class="content"><p>Hi Jordan,<br></p><p>The thing that sticks out in the dependency analysis is the treatment of<br>external dependencies. The entire module has the same list of external<br>dependencies which causes a lot of needless recompiles- especially if you<br>start with a large swift project and slowly start to move things into<br>modules.<br></p><p>So to me the lowest hanging fruit would be to only mark files for<br>recompilation that explicitly import the external dependency. This seems<br>pretty safe since you can&#39;t compile unless the dependency is explicitly<br>imported. Has anyone on the list tried this before?<br></p><p>A second idea would be to consider a file as changed only if its build<br>artifact actually changes. Obviously, we&#39;d have to actually build the file<br>to figure this out, so we wouldn&#39;t have the same level of parallelism<br>initially. Perhaps if it was an optional compiler flag this would be more<br>palatable? Also wondering if anyone has tried something along these lines.<br></p><p>Thanks!<br></p><p><br>George- The bridge between objective c and swift between is definitely a<br>choke point. We&#39;ve been able to mitigate objective-c recompiles somewhat by<br>limiting our imports of swift into objective-c. We&#39;ve even gone so far as<br>to make wrapper classes in objective c around some of our most commonly<br>used swift classes so as not to import swift.<br></p><p>It&#39;s also very true that changing an objective c .h file that is imported<br>into the bridging header will trigger massive recompiles. As more of our<br>app has transitioned to swift this has been less of an issue. Most of the<br>problems at this point have to do with recompiling a large portion of our<br>swift code due to small changes in unrelated parts of our other swift code.<br></p><p><br></p><p><br></p><p>Get the latest from Hopscotch!<br></p><p>Sign-up for our newsletter &lt;http://eepurl.com/Ui0eX&gt;<br></p><p>On Fri, Apr 8, 2016 at 5:34 PM, George King &lt;gwk.lists at gmail.com&gt; wrote:<br></p><p>&gt; Hey Sam,<br>&gt;<br>&gt; One thought: if you have an app with mixed objc and swift code, then the<br>&gt; app-bridge.h and app-swift.h files might be creating massive choke points<br>&gt; in your dependency graph. I have no idea how optimized the bridging<br>&gt; functionality is but it has always seemed like a potentially weak part of<br>&gt; the dependency management. I imagine that with an objc half and a swift<br>&gt; half of the code base, every time you make a change in a swift file you<br>&gt; trigger recompilation of the objc half, and vice versa. I&#39;d love to hear<br>&gt; from the core team to what extent this is true!<br>&gt;<br>&gt; George<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Apr 7, 2016, at 5:35 PM, Samantha John via swift-dev &lt;<br>&gt; swift-dev at swift.org&gt; wrote:<br>&gt;<br>&gt; Thank you Jordan! This is a great starting off point.<br>&gt;<br>&gt; I&#39;m thinking about proposing a &quot;strict import&quot; mode in swift: A compile<br>&gt; flag that when turned on would require you to explicitly import any file<br>&gt; that contained a dependency you needed (like in objective-c).<br>&gt;<br>&gt; I&#39;m going to spend more time looking over the docs and the output logs to<br>&gt; see if this would be a feasible. If anyone has opinions or insights into<br>&gt; this I would love to hear from you.<br>&gt;<br>&gt; Sam<br>&gt;<br>&gt; On Tue, Apr 5, 2016 at 9:08 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt; Hi, Sam. I don&#39;t think we currently have a good answer for this built<br>&gt;&gt; into xcodebuild or xctool, and it&#39;s a reasonable idea. (Ideally all builds<br>&gt;&gt; would be fast enough that it wouldn&#39;t matter! That&#39;s obviously not where we<br>&gt;&gt; are.)<br>&gt;&gt;<br>&gt;&gt; Since &#39;-debug-time-function-bodies&#39; is now public knowledge, I&#39;ll share<br>&gt;&gt; another one of our debugging flags, &#39;-driver-show-incremental&#39;. You can add<br>&gt;&gt; this to your &quot;Other Swift Flags&quot;. The output isn&#39;t very detailed, though:<br>&gt;&gt;<br>&gt;&gt; Queuing Tree.swift (initial)<br>&gt;&gt; Queuing AdventureScene.swift (initial)<br>&gt;&gt; Queuing AdventureScene.swift because of dependencies discovered later<br>&gt;&gt; Queuing AppDelegate.swift because of dependencies discovered later<br>&gt;&gt; Queuing ChaseArtificialIntelligence.swift because of dependencies<br>&gt;&gt; discovered later<br>&gt;&gt; Queuing Character.swift because of dependencies discovered later<br>&gt;&gt; Queuing SpawnArtificialIntelligence.swift because of dependencies<br>&gt;&gt; discovered later<br>&gt;&gt; Queuing Goblin.swift because of dependencies discovered later<br>&gt;&gt; Queuing Cave.swift because of dependencies discovered later<br>&gt;&gt; Queuing AdventureSceneOSXEvents.swift because of dependencies discovered<br>&gt;&gt; later<br>&gt;&gt; Queuing HeroCharacter.swift because of dependencies discovered later<br>&gt;&gt; Queuing EnemyCharacter.swift because of dependencies discovered later<br>&gt;&gt; Queuing Boss.swift because of dependencies discovered later<br>&gt;&gt; Queuing SharedAssetManagement.swift because of dependencies discovered<br>&gt;&gt; later<br>&gt;&gt; Queuing Warrior.swift because of dependencies discovered later<br>&gt;&gt; Queuing Archer.swift because of dependencies discovered later<br>&gt;&gt; Queuing Player.swift because of dependencies discovered later<br>&gt;&gt; Queuing ArtificialIntelligence.swift because of dependencies discovered<br>&gt;&gt; later<br>&gt;&gt;<br>&gt;&gt; In this case, I took a version of the Adventure sample project and<br>&gt;&gt; modified &quot;Tree.swift&quot;; that triggered recompilation of several other files.<br>&gt;&gt; Unfortunately this view doesn&#39;t tell you how they&#39;re related, only which<br>&gt;&gt; ones are actually getting rebuilt.<br>&gt;&gt;<br>&gt;&gt; The next step (and moving into the territory of &quot;working on Swift&quot; rather<br>&gt;&gt; than just &quot;trying to figure out why it&#39;s repeating work&quot;) would be to look<br>&gt;&gt; at the &quot;swiftdeps&quot; files stored in your DerivedData folder. These are<br>&gt;&gt; currently just YAML files describing what Swift thinks the file depends on,<br>&gt;&gt; as well as what will trigger rebuilding of other files. This is intended to<br>&gt;&gt; be a conservative estimate, since *not* recompiling something would<br>&gt;&gt; result in an invalid binary. (Unfortunately I say &quot;intended&quot; because there<br>&gt;&gt; are known bugs; fortunately, archive builds are always clean builds anyway.)<br>&gt;&gt;<br>&gt;&gt; There&#39;s a document in the Swift repo describing the logic behind Swift&#39;s<br>&gt;&gt; dependency analysis:<br>&gt;&gt; https://github.com/apple/swift/blob/master/docs/DependencyAnalysis.rst.<br>&gt;&gt; The one thing that&#39;s *not* in there is the notion of changes that don&#39;t<br>&gt;&gt; affect other files at all. This is accomplished by computing a hash of all<br>&gt;&gt; the tokens that *could* affect other files, and seeing if that hash has<br>&gt;&gt; changed.<br>&gt;&gt;<br>&gt;&gt; We definitely have room for improvement here.<br>&gt;&gt;<br>&gt;&gt; Jordan<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Mar 31, 2016, at 11:24 , Samantha John via swift-dev &lt;<br>&gt;&gt; swift-dev at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I have a large project (308 swift files, 441 objective c, 66k lines of<br>&gt;&gt; code) where incremental builds can be extremely slow. I&#39;m trying to do some<br>&gt;&gt; profiling to figure out what type of things cause large scale recompiles.<br>&gt;&gt; The problem is that I can&#39;t find a good way of telling which files get<br>&gt;&gt; recompiled on an incremental build and which do not. It seems like files<br>&gt;&gt; that are not recompiled still get listed in xcode, but the compiler just<br>&gt;&gt; passes over them really fast.<br>&gt;&gt;<br>&gt;&gt; Does anyone know if xctool or xcodebuild has this type of functionality?<br>&gt;&gt; Or is there some other way to get this info?<br>&gt;&gt;<br>&gt;&gt; Thank you,<br>&gt;&gt; Sam<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160413/0936dea0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f13662914188bbe1364b8b910dd4aa8c?s=50"></div><header><strong>Swift incremental compile profiling</strong> from <string>Samantha John</string> &lt;sam at gethopscotch.com&gt;<p>April 24, 2016 at 06:00:00pm</p></header><div class="content"><p>Hello List (cc/Jordan),<br></p><p>At a high level: Brian and I are looking into contributing to incremental<br>compilation in Swift. Right now we&#39;re trying to do an incremental compile<br>by invoking swiftc.<br></p><p>Our understanding so far:<br>- swiftc takes a list of input files.<br>- If swiftc is invoked with &#39;-incremental&#39;, it requires an<br>&#39;-output-file-map&#39; option to also be passed. We assume this is used to<br>determine where intermediate dependency files go.<br>- Looking at the tests in test/Driver/Dependencies/Inputs and the sorts of<br>files Xcode generates when building Swift projects, we determined<br>&#39;-output-file-map&#39; to be a JSON file (which is parsed by the llvm yaml<br>parser?<br>https://github.com/apple/swift/blob/95e3be665d9387eb0d354f3d0f313e44c7b4245d/lib/Driver/OutputFileMap.cpp#L100).<br>We tried writing our own, this is the shortest version that the compiler<br>didn&#39;t error on:<br></p><p>```<br>{<br>  &quot;&quot;: {<br>    &quot;swift-dependencies&quot;: &quot;MyModule-main.swiftdeps&quot;<br>  }<br>}<br>```<br></p><p>- When compiling with the above file (&#39;swiftc -incremental -output-file-map<br>OurFileMap.json *.swift&#39;), swiftc writes to MyModule-main.swiftdeps. The<br>end result looks like this:<br></p><p>```<br>version: &quot;Swift version 3.0-dev (LLVM 752e1430fc, Clang 3987718dae, Swift<br>a2cf18ba2f)&quot;<br>options: &quot;9277a78155e85019ce36a3c52e9f3f02&quot;<br>build_time: [514847765, 412105000]<br>inputs:<br>  &quot;Class1.swift&quot;: [514841531, 0]<br>  &quot;Class2.swift&quot;: [514844635, 0]<br>  &quot;main.swift&quot;: [514841821, 0]<br>```<br></p><p>- Where the [xxx, yyy] are timestamps with the first number representing<br>seconds, the second nanoseconds. (<br>https://github.com/apple/swift/blob/95e3be665d9387eb0d354f3d0f313e44c7b4245d/lib/Driver/Driver.cpp#L221<br>)<br></p><p>- We invoked &#39;swiftc -incremental -output-file-map OurFileMap.json *.swift<br>-parseable-output -save-temps&#39; to show us the paths to the generated<br>.swiftdeps files. We assume that to get incremental compiles to work for<br>us, we&#39;d need to pass these generated .swiftdeps files&#39; paths to the<br>compiler somehow. We can&#39;t figure out how to do this, so this is the point<br>where our incremental compile fails:<br>https://github.com/apple/swift/blob/95e3be665d9387eb0d354f3d0f313e44c7b4245d/lib/Driver/Compilation.cpp#L348<br></p><p>This is as far as we got. Would super appreciate if anyone on the list<br>could point us in the right direction from here, especially for the<br>following questions:<br></p><p>1. This would probably be easier if we could find the right test case. We<br>poked around in test/Driver/Dependencies which had a bunch of tests around<br>reading the .swiftdeps files, but we couldn&#39;t find tests that demonstrated<br>how incremental compilation worked at a high level.<br></p><p>2. &#39;-output-file-map&#39;: Is this file meant to be written by hand, or is<br>there a part of the swift compiler that writes this for you?<br></p><p>3. Specifying paths for .swiftdeps: We had assumed this was done based on<br>the &#39;-output-file-map&#39;, but writing the paths we wanted manually did not<br>seem to work. Any tips?<br></p><p>Thanks so much!<br>Sam and Brian<br></p><p>On Wed, Apr 13, 2016 at 5:18 PM, Samantha John &lt;sam at gethopscotch.com&gt; wrote:<br></p><p>&gt; Hi Jordan,<br>&gt;<br>&gt; The thing that sticks out in the dependency analysis is the treatment of<br>&gt; external dependencies. The entire module has the same list of external<br>&gt; dependencies which causes a lot of needless recompiles- especially if you<br>&gt; start with a large swift project and slowly start to move things into<br>&gt; modules.<br>&gt;<br>&gt; So to me the lowest hanging fruit would be to only mark files for<br>&gt; recompilation that explicitly import the external dependency. This seems<br>&gt; pretty safe since you can&#39;t compile unless the dependency is explicitly<br>&gt; imported. Has anyone on the list tried this before?<br>&gt;<br>&gt; A second idea would be to consider a file as changed only if its build<br>&gt; artifact actually changes. Obviously, we&#39;d have to actually build the file<br>&gt; to figure this out, so we wouldn&#39;t have the same level of parallelism<br>&gt; initially. Perhaps if it was an optional compiler flag this would be more<br>&gt; palatable? Also wondering if anyone has tried something along these lines.<br>&gt;<br>&gt; Thanks!<br>&gt;<br>&gt;<br>&gt; George- The bridge between objective c and swift between is definitely a<br>&gt; choke point. We&#39;ve been able to mitigate objective-c recompiles somewhat by<br>&gt; limiting our imports of swift into objective-c. We&#39;ve even gone so far as<br>&gt; to make wrapper classes in objective c around some of our most commonly<br>&gt; used swift classes so as not to import swift.<br>&gt;<br>&gt; It&#39;s also very true that changing an objective c .h file that is imported<br>&gt; into the bridging header will trigger massive recompiles. As more of our<br>&gt; app has transitioned to swift this has been less of an issue. Most of the<br>&gt; problems at this point have to do with recompiling a large portion of our<br>&gt; swift code due to small changes in unrelated parts of our other swift code.<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; Get the latest from Hopscotch!<br>&gt;<br>&gt; Sign-up for our newsletter &lt;http://eepurl.com/Ui0eX&gt;<br>&gt;<br>&gt; On Fri, Apr 8, 2016 at 5:34 PM, George King &lt;gwk.lists at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; Hey Sam,<br>&gt;&gt;<br>&gt;&gt; One thought: if you have an app with mixed objc and swift code, then the<br>&gt;&gt; app-bridge.h and app-swift.h files might be creating massive choke points<br>&gt;&gt; in your dependency graph. I have no idea how optimized the bridging<br>&gt;&gt; functionality is but it has always seemed like a potentially weak part of<br>&gt;&gt; the dependency management. I imagine that with an objc half and a swift<br>&gt;&gt; half of the code base, every time you make a change in a swift file you<br>&gt;&gt; trigger recompilation of the objc half, and vice versa. I&#39;d love to hear<br>&gt;&gt; from the core team to what extent this is true!<br>&gt;&gt;<br>&gt;&gt; George<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Apr 7, 2016, at 5:35 PM, Samantha John via swift-dev &lt;<br>&gt;&gt; swift-dev at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Thank you Jordan! This is a great starting off point.<br>&gt;&gt;<br>&gt;&gt; I&#39;m thinking about proposing a &quot;strict import&quot; mode in swift: A compile<br>&gt;&gt; flag that when turned on would require you to explicitly import any file<br>&gt;&gt; that contained a dependency you needed (like in objective-c).<br>&gt;&gt;<br>&gt;&gt; I&#39;m going to spend more time looking over the docs and the output logs to<br>&gt;&gt; see if this would be a feasible. If anyone has opinions or insights into<br>&gt;&gt; this I would love to hear from you.<br>&gt;&gt;<br>&gt;&gt; Sam<br>&gt;&gt;<br>&gt;&gt; On Tue, Apr 5, 2016 at 9:08 PM, Jordan Rose &lt;jordan_rose at apple.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Hi, Sam. I don&#39;t think we currently have a good answer for this built<br>&gt;&gt;&gt; into xcodebuild or xctool, and it&#39;s a reasonable idea. (Ideally all builds<br>&gt;&gt;&gt; would be fast enough that it wouldn&#39;t matter! That&#39;s obviously not where we<br>&gt;&gt;&gt; are.)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Since &#39;-debug-time-function-bodies&#39; is now public knowledge, I&#39;ll share<br>&gt;&gt;&gt; another one of our debugging flags, &#39;-driver-show-incremental&#39;. You can add<br>&gt;&gt;&gt; this to your &quot;Other Swift Flags&quot;. The output isn&#39;t very detailed, though:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Queuing Tree.swift (initial)<br>&gt;&gt;&gt; Queuing AdventureScene.swift (initial)<br>&gt;&gt;&gt; Queuing AdventureScene.swift because of dependencies discovered later<br>&gt;&gt;&gt; Queuing AppDelegate.swift because of dependencies discovered later<br>&gt;&gt;&gt; Queuing ChaseArtificialIntelligence.swift because of dependencies<br>&gt;&gt;&gt; discovered later<br>&gt;&gt;&gt; Queuing Character.swift because of dependencies discovered later<br>&gt;&gt;&gt; Queuing SpawnArtificialIntelligence.swift because of dependencies<br>&gt;&gt;&gt; discovered later<br>&gt;&gt;&gt; Queuing Goblin.swift because of dependencies discovered later<br>&gt;&gt;&gt; Queuing Cave.swift because of dependencies discovered later<br>&gt;&gt;&gt; Queuing AdventureSceneOSXEvents.swift because of dependencies discovered<br>&gt;&gt;&gt; later<br>&gt;&gt;&gt; Queuing HeroCharacter.swift because of dependencies discovered later<br>&gt;&gt;&gt; Queuing EnemyCharacter.swift because of dependencies discovered later<br>&gt;&gt;&gt; Queuing Boss.swift because of dependencies discovered later<br>&gt;&gt;&gt; Queuing SharedAssetManagement.swift because of dependencies discovered<br>&gt;&gt;&gt; later<br>&gt;&gt;&gt; Queuing Warrior.swift because of dependencies discovered later<br>&gt;&gt;&gt; Queuing Archer.swift because of dependencies discovered later<br>&gt;&gt;&gt; Queuing Player.swift because of dependencies discovered later<br>&gt;&gt;&gt; Queuing ArtificialIntelligence.swift because of dependencies discovered<br>&gt;&gt;&gt; later<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In this case, I took a version of the Adventure sample project and<br>&gt;&gt;&gt; modified &quot;Tree.swift&quot;; that triggered recompilation of several other files.<br>&gt;&gt;&gt; Unfortunately this view doesn&#39;t tell you how they&#39;re related, only which<br>&gt;&gt;&gt; ones are actually getting rebuilt.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The next step (and moving into the territory of &quot;working on Swift&quot;<br>&gt;&gt;&gt; rather than just &quot;trying to figure out why it&#39;s repeating work&quot;) would be<br>&gt;&gt;&gt; to look at the &quot;swiftdeps&quot; files stored in your DerivedData folder. These<br>&gt;&gt;&gt; are currently just YAML files describing what Swift thinks the file depends<br>&gt;&gt;&gt; on, as well as what will trigger rebuilding of other files. This is<br>&gt;&gt;&gt; intended to be a conservative estimate, since *not* recompiling<br>&gt;&gt;&gt; something would result in an invalid binary. (Unfortunately I say<br>&gt;&gt;&gt; &quot;intended&quot; because there are known bugs; fortunately, archive builds are<br>&gt;&gt;&gt; always clean builds anyway.)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; There&#39;s a document in the Swift repo describing the logic behind Swift&#39;s<br>&gt;&gt;&gt; dependency analysis:<br>&gt;&gt;&gt; https://github.com/apple/swift/blob/master/docs/DependencyAnalysis.rst.<br>&gt;&gt;&gt; The one thing that&#39;s *not* in there is the notion of changes that don&#39;t<br>&gt;&gt;&gt; affect other files at all. This is accomplished by computing a hash of all<br>&gt;&gt;&gt; the tokens that *could* affect other files, and seeing if that hash has<br>&gt;&gt;&gt; changed.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; We definitely have room for improvement here.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Mar 31, 2016, at 11:24 , Samantha John via swift-dev &lt;<br>&gt;&gt;&gt; swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I have a large project (308 swift files, 441 objective c, 66k lines of<br>&gt;&gt;&gt; code) where incremental builds can be extremely slow. I&#39;m trying to do some<br>&gt;&gt;&gt; profiling to figure out what type of things cause large scale recompiles.<br>&gt;&gt;&gt; The problem is that I can&#39;t find a good way of telling which files get<br>&gt;&gt;&gt; recompiled on an incremental build and which do not. It seems like files<br>&gt;&gt;&gt; that are not recompiled still get listed in xcode, but the compiler just<br>&gt;&gt;&gt; passes over them really fast.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Does anyone know if xctool or xcodebuild has this type of functionality?<br>&gt;&gt;&gt; Or is there some other way to get this info?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt; Sam<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt; swift-dev at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160424/ee572ac1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>Swift incremental compile profiling</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>April 24, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Apr 24, 2016, at 3:19 PM, Samantha John via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello List (cc/Jordan),  <br>&gt; <br>&gt; At a high level: Brian and I are looking into contributing to incremental compilation in Swift. Right now we&#39;re trying to do an incremental compile by invoking swiftc. <br>&gt; <br>&gt; Our understanding so far:<br>&gt; - swiftc takes a list of input files. <br>&gt; - If swiftc is invoked with &#39;-incremental&#39;, it requires an &#39;-output-file-map&#39; option to also be passed. We assume this is used to determine where intermediate dependency files go.<br>&gt; - Looking at the tests in test/Driver/Dependencies/Inputs and the sorts of files Xcode generates when building Swift projects, we determined &#39;-output-file-map&#39; to be a JSON file (which is parsed by the llvm yaml parser? https://github.com/apple/swift/blob/95e3be665d9387eb0d354f3d0f313e44c7b4245d/lib/Driver/OutputFileMap.cpp#L100 &lt;https://github.com/apple/swift/blob/95e3be665d9387eb0d354f3d0f313e44c7b4245d/lib/Driver/OutputFileMap.cpp#L100&gt;). We tried writing our own, this is the shortest version that the compiler didn&#39;t error on:<br>&gt; <br>&gt; ```<br>&gt; {<br>&gt;   &quot;&quot;: {<br>&gt;     &quot;swift-dependencies&quot;: &quot;MyModule-main.swiftdeps&quot;<br>&gt;   }<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; - When compiling with the above file (&#39;swiftc -incremental -output-file-map OurFileMap.json *.swift&#39;), swiftc writes to MyModule-main.swiftdeps. The end result looks like this:<br>&gt; <br>&gt; ```<br>&gt; version: &quot;Swift version 3.0-dev (LLVM 752e1430fc, Clang 3987718dae, Swift a2cf18ba2f)&quot;<br>&gt; options: &quot;9277a78155e85019ce36a3c52e9f3f02&quot;<br>&gt; build_time: [514847765, 412105000]<br>&gt; inputs:<br>&gt;   &quot;Class1.swift&quot;: [514841531, 0]<br>&gt;   &quot;Class2.swift&quot;: [514844635, 0]<br>&gt;   &quot;main.swift&quot;: [514841821, 0]<br>&gt; ```<br>&gt; <br>&gt; - Where the [xxx, yyy] are timestamps with the first number representing seconds, the second nanoseconds. (https://github.com/apple/swift/blob/95e3be665d9387eb0d354f3d0f313e44c7b4245d/lib/Driver/Driver.cpp#L221 &lt;https://github.com/apple/swift/blob/95e3be665d9387eb0d354f3d0f313e44c7b4245d/lib/Driver/Driver.cpp#L221&gt;)<br>&gt; <br>&gt; - We invoked &#39;swiftc -incremental -output-file-map OurFileMap.json *.swift -parseable-output -save-temps&#39; to show us the paths to the generated .swiftdeps files. We assume that to get incremental compiles to work for us, we&#39;d need to pass these generated .swiftdeps files&#39; paths to the compiler somehow. We can&#39;t figure out how to do this, so this is the point where our incremental compile fails: https://github.com/apple/swift/blob/95e3be665d9387eb0d354f3d0f313e44c7b4245d/lib/Driver/Compilation.cpp#L348 &lt;https://github.com/apple/swift/blob/95e3be665d9387eb0d354f3d0f313e44c7b4245d/lib/Driver/Compilation.cpp#L348&gt;<br>You don&#39;t need to point the compiler at the swiftdeps files, it reuses the ones passed in the output file map if -incremental is passed.<br></p><p>You didn&#39;t mention it (I don&#39;t think) but you also need to pass -emit-dependencies, however it sounds like you are doing this.<br></p><p>&gt; This is as far as we got. Would super appreciate if anyone on the list could point us in the right direction from here, especially for the following questions:<br>&gt; <br>&gt; 1. This would probably be easier if we could find the right test case. We poked around in test/Driver/Dependencies which had a bunch of tests around reading the .swiftdeps files, but we couldn&#39;t find tests that demonstrated how incremental compilation worked at a high level.<br>&gt; <br>&gt; 2. &#39;-output-file-map&#39;: Is this file meant to be written by hand, or is there a part of the swift compiler that writes this for you?<br></p><p>It is meant to be written by the build system which invokes Swift. See also:<br>  https://github.com/apple/swift-llbuild/blob/master/lib/BuildSystem/SwiftTools.cpp#L206<br>which is what the Swift package manager uses (which supports incremental compiles).<br></p><p>Your best bet is to take the exact command line used by xcodebuild, and then invoke swiftc with that to replicate the incremental build. If you run with -v you should be able to see exactly what files get built<br></p><p>HTH!<br> - Daniel<br></p><p>&gt; <br>&gt; 3. Specifying paths for .swiftdeps: We had assumed this was done based on the &#39;-output-file-map&#39;, but writing the paths we wanted manually did not seem to work. Any tips?<br>&gt; <br>&gt; Thanks so much!<br>&gt; Sam and Brian<br>&gt; <br>&gt; On Wed, Apr 13, 2016 at 5:18 PM, Samantha John &lt;sam at gethopscotch.com &lt;mailto:sam at gethopscotch.com&gt;&gt; wrote:<br>&gt; Hi Jordan, <br>&gt; <br>&gt; The thing that sticks out in the dependency analysis is the treatment of external dependencies. The entire module has the same list of external dependencies which causes a lot of needless recompiles- especially if you start with a large swift project and slowly start to move things into modules. <br>&gt; <br>&gt; So to me the lowest hanging fruit would be to only mark files for recompilation that explicitly import the external dependency. This seems pretty safe since you can&#39;t compile unless the dependency is explicitly imported. Has anyone on the list tried this before? <br>&gt; <br>&gt; A second idea would be to consider a file as changed only if its build artifact actually changes. Obviously, we&#39;d have to actually build the file to figure this out, so we wouldn&#39;t have the same level of parallelism initially. Perhaps if it was an optional compiler flag this would be more palatable? Also wondering if anyone has tried something along these lines.<br>&gt; <br>&gt; Thanks! <br>&gt; <br>&gt; <br>&gt; George- The bridge between objective c and swift between is definitely a choke point. We&#39;ve been able to mitigate objective-c recompiles somewhat by limiting our imports of swift into objective-c. We&#39;ve even gone so far as to make wrapper classes in objective c around some of our most commonly used swift classes so as not to import swift. <br>&gt; <br>&gt; It&#39;s also very true that changing an objective c .h file that is imported into the bridging header will trigger massive recompiles. As more of our app has transitioned to swift this has been less of an issue. Most of the problems at this point have to do with recompiling a large portion of our swift code due to small changes in unrelated parts of our other swift code. <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; Get the latest from Hopscotch!<br>&gt; <br>&gt; Sign-up for our newsletter &lt;http://eepurl.com/Ui0eX&gt;<br>&gt; <br>&gt; On Fri, Apr 8, 2016 at 5:34 PM, George King &lt;gwk.lists at gmail.com &lt;mailto:gwk.lists at gmail.com&gt;&gt; wrote:<br>&gt; Hey Sam,<br>&gt; <br>&gt; One thought: if you have an app with mixed objc and swift code, then the app-bridge.h and app-swift.h files might be creating massive choke points in your dependency graph. I have no idea how optimized the bridging functionality is but it has always seemed like a potentially weak part of the dependency management. I imagine that with an objc half and a swift half of the code base, every time you make a change in a swift file you trigger recompilation of the objc half, and vice versa. I&#39;d love to hear from the core team to what extent this is true!<br>&gt; <br>&gt; George<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Apr 7, 2016, at 5:35 PM, Samantha John via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Thank you Jordan! This is a great starting off point.<br>&gt;&gt; <br>&gt;&gt; I&#39;m thinking about proposing a &quot;strict import&quot; mode in swift: A compile flag that when turned on would require you to explicitly import any file that contained a dependency you needed (like in objective-c).<br>&gt;&gt; <br>&gt;&gt; I&#39;m going to spend more time looking over the docs and the output logs to see if this would be a feasible. If anyone has opinions or insights into this I would love to hear from you. <br>&gt;&gt; <br>&gt;&gt; Sam<br>&gt;&gt; <br>&gt;&gt; On Tue, Apr 5, 2016 at 9:08 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt; Hi, Sam. I don&#39;t think we currently have a good answer for this built into xcodebuild or xctool, and it&#39;s a reasonable idea. (Ideally all builds would be fast enough that it wouldn&#39;t matter! That&#39;s obviously not where we are.)<br>&gt;&gt; <br>&gt;&gt; Since &#39;-debug-time-function-bodies&#39; is now public knowledge, I&#39;ll share another one of our debugging flags, &#39;-driver-show-incremental&#39;. You can add this to your &quot;Other Swift Flags&quot;. The output isn&#39;t very detailed, though:<br>&gt;&gt; <br>&gt;&gt; Queuing Tree.swift (initial)<br>&gt;&gt; Queuing AdventureScene.swift (initial)<br>&gt;&gt; Queuing AdventureScene.swift because of dependencies discovered later<br>&gt;&gt; Queuing AppDelegate.swift because of dependencies discovered later<br>&gt;&gt; Queuing ChaseArtificialIntelligence.swift because of dependencies discovered later<br>&gt;&gt; Queuing Character.swift because of dependencies discovered later<br>&gt;&gt; Queuing SpawnArtificialIntelligence.swift because of dependencies discovered later<br>&gt;&gt; Queuing Goblin.swift because of dependencies discovered later<br>&gt;&gt; Queuing Cave.swift because of dependencies discovered later<br>&gt;&gt; Queuing AdventureSceneOSXEvents.swift because of dependencies discovered later<br>&gt;&gt; Queuing HeroCharacter.swift because of dependencies discovered later<br>&gt;&gt; Queuing EnemyCharacter.swift because of dependencies discovered later<br>&gt;&gt; Queuing Boss.swift because of dependencies discovered later<br>&gt;&gt; Queuing SharedAssetManagement.swift because of dependencies discovered later<br>&gt;&gt; Queuing Warrior.swift because of dependencies discovered later<br>&gt;&gt; Queuing Archer.swift because of dependencies discovered later<br>&gt;&gt; Queuing Player.swift because of dependencies discovered later<br>&gt;&gt; Queuing ArtificialIntelligence.swift because of dependencies discovered later<br>&gt;&gt; <br>&gt;&gt; In this case, I took a version of the Adventure sample project and modified &quot;Tree.swift&quot;; that triggered recompilation of several other files. Unfortunately this view doesn&#39;t tell you how they&#39;re related, only which ones are actually getting rebuilt.<br>&gt;&gt; <br>&gt;&gt; The next step (and moving into the territory of &quot;working on Swift&quot; rather than just &quot;trying to figure out why it&#39;s repeating work&quot;) would be to look at the &quot;swiftdeps&quot; files stored in your DerivedData folder. These are currently just YAML files describing what Swift thinks the file depends on, as well as what will trigger rebuilding of other files. This is intended to be a conservative estimate, since not recompiling something would result in an invalid binary. (Unfortunately I say &quot;intended&quot; because there are known bugs; fortunately, archive builds are always clean builds anyway.)<br>&gt;&gt; <br>&gt;&gt; There&#39;s a document in the Swift repo describing the logic behind Swift&#39;s dependency analysis: https://github.com/apple/swift/blob/master/docs/DependencyAnalysis.rst &lt;https://github.com/apple/swift/blob/master/docs/DependencyAnalysis.rst&gt;. The one thing that&#39;s not in there is the notion of changes that don&#39;t affect other files at all. This is accomplished by computing a hash of all the tokens that could affect other files, and seeing if that hash has changed.<br>&gt;&gt; <br>&gt;&gt; We definitely have room for improvement here.<br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 31, 2016, at 11:24 , Samantha John via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I have a large project (308 swift files, 441 objective c, 66k lines of code) where incremental builds can be extremely slow. I&#39;m trying to do some profiling to figure out what type of things cause large scale recompiles. The problem is that I can&#39;t find a good way of telling which files get recompiled on an incremental build and which do not. It seems like files that are not recompiled still get listed in xcode, but the compiler just passes over them really fast. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Does anyone know if xctool or xcodebuild has this type of functionality? Or is there some other way to get this info?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt; Sam<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160424/920f762d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f13662914188bbe1364b8b910dd4aa8c?s=50"></div><header><strong>Swift incremental compile profiling</strong> from <string>Samantha John</string> &lt;sam at gethopscotch.com&gt;<p>April 25, 2016 at 11:00:00pm</p></header><div class="content"><p>On Mon, Apr 25, 2016 at 12:11 AM, Daniel Dunbar &lt;daniel_dunbar at apple.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; On Apr 24, 2016, at 3:19 PM, Samantha John via swift-dev &lt;<br>&gt; swift-dev at swift.org&gt; wrote:<br>&gt;<br>&gt; Hello List (cc/Jordan),<br>&gt;<br>&gt; At a high level: Brian and I are looking into contributing to incremental<br>&gt; compilation in Swift. Right now we&#39;re trying to do an incremental compile<br>&gt; by invoking swiftc.<br>&gt;<br>&gt; Our understanding so far:<br>&gt; - swiftc takes a list of input files.<br>&gt; - If swiftc is invoked with &#39;-incremental&#39;, it requires an<br>&gt; &#39;-output-file-map&#39; option to also be passed. We assume this is used to<br>&gt; determine where intermediate dependency files go.<br>&gt; - Looking at the tests in test/Driver/Dependencies/Inputs and the sorts of<br>&gt; files Xcode generates when building Swift projects, we determined<br>&gt; &#39;-output-file-map&#39; to be a JSON file (which is parsed by the llvm yaml<br>&gt; parser?<br>&gt; https://github.com/apple/swift/blob/95e3be665d9387eb0d354f3d0f313e44c7b4245d/lib/Driver/OutputFileMap.cpp#L100).<br>&gt; We tried writing our own, this is the shortest version that the compiler<br>&gt; didn&#39;t error on:<br>&gt;<br>&gt; ```<br>&gt; {<br>&gt;   &quot;&quot;: {<br>&gt;     &quot;swift-dependencies&quot;: &quot;MyModule-main.swiftdeps&quot;<br>&gt;   }<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; - When compiling with the above file (&#39;swiftc -incremental<br>&gt; -output-file-map OurFileMap.json *.swift&#39;), swiftc writes to<br>&gt; MyModule-main.swiftdeps. The end result looks like this:<br>&gt;<br>&gt; ```<br>&gt; version: &quot;Swift version 3.0-dev (LLVM 752e1430fc, Clang 3987718dae, Swift<br>&gt; a2cf18ba2f)&quot;<br>&gt; options: &quot;9277a78155e85019ce36a3c52e9f3f02&quot;<br>&gt; build_time: [514847765, 412105000]<br>&gt; inputs:<br>&gt;   &quot;Class1.swift&quot;: [514841531, 0]<br>&gt;   &quot;Class2.swift&quot;: [514844635, 0]<br>&gt;   &quot;main.swift&quot;: [514841821, 0]<br>&gt; ```<br>&gt;<br>&gt; - Where the [xxx, yyy] are timestamps with the first number representing<br>&gt; seconds, the second nanoseconds. (<br>&gt; https://github.com/apple/swift/blob/95e3be665d9387eb0d354f3d0f313e44c7b4245d/lib/Driver/Driver.cpp#L221<br>&gt; )<br>&gt;<br>&gt; - We invoked &#39;swiftc -incremental -output-file-map OurFileMap.json *.swift<br>&gt; -parseable-output -save-temps&#39; to show us the paths to the generated<br>&gt; .swiftdeps files. We assume that to get incremental compiles to work for<br>&gt; us, we&#39;d need to pass these generated .swiftdeps files&#39; paths to the<br>&gt; compiler somehow. We can&#39;t figure out how to do this, so this is the point<br>&gt; where our incremental compile fails:<br>&gt; https://github.com/apple/swift/blob/95e3be665d9387eb0d354f3d0f313e44c7b4245d/lib/Driver/Compilation.cpp#L348<br>&gt;<br>&gt;<br>&gt; You don&#39;t need to point the compiler at the swiftdeps files, it reuses the<br>&gt; ones passed in the output file map if -incremental is passed.<br>&gt;<br>&gt; You didn&#39;t mention it (I don&#39;t think) but you also need to pass<br>&gt; -emit-dependencies, however it sounds like you are doing this.<br>&gt;<br>&gt; This is as far as we got. Would super appreciate if anyone on the list<br>&gt; could point us in the right direction from here, especially for the<br>&gt; following questions:<br>&gt;<br>&gt; 1. This would probably be easier if we could find the right test case. We<br>&gt; poked around in test/Driver/Dependencies which had a bunch of tests around<br>&gt; reading the .swiftdeps files, but we couldn&#39;t find tests that demonstrated<br>&gt; how incremental compilation worked at a high level.<br>&gt;<br>&gt; 2. &#39;-output-file-map&#39;: Is this file meant to be written by hand, or is<br>&gt; there a part of the swift compiler that writes this for you?<br>&gt;<br>&gt;<br>&gt; It is meant to be written by the build system which invokes Swift. See<br>&gt; also:<br>&gt;<br>&gt; https://github.com/apple/swift-llbuild/blob/master/lib/BuildSystem/SwiftTools.cpp#L206<br>&gt; which is what the Swift package manager uses (which supports incremental<br>&gt; compiles).<br>&gt;<br></p><p>This sounds perfect. I tried to install the llbuild but got stuck on<br>filecheck (and saw that you are trying to add it to the toolchain:<br>https://github.com/apple/swift-llbuild/pull/22/files#r61007286) Is there an<br>executable of llbuild I could download, or do you have any basic<br>instructions for what to do about filecheck?<br></p><p><br>&gt; Your best bet is to take the exact command line used by xcodebuild, and<br>&gt; then invoke swiftc with that to replicate the incremental build. If you run<br>&gt; with -v you should be able to see exactly what files get built<br>&gt;<br></p><p> I tried running xcodebuild with the verbose flag but wasn&#39;t getting much<br>useful. Is that what you meant here? -v didn&#39;t seem to be an option.<br></p><p>Thanks so much,<br>Sam<br></p><p><br>&gt; HTH!<br>&gt;  - Daniel<br>&gt;<br>&gt;<br>&gt; 3. Specifying paths for .swiftdeps: We had assumed this was done based on<br>&gt; the &#39;-output-file-map&#39;, but writing the paths we wanted manually did not<br>&gt; seem to work. Any tips?<br>&gt;<br>&gt; Thanks so much!<br>&gt; Sam and Brian<br>&gt;<br>&gt; On Wed, Apr 13, 2016 at 5:18 PM, Samantha John &lt;sam at gethopscotch.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; Hi Jordan,<br>&gt;&gt;<br>&gt;&gt; The thing that sticks out in the dependency analysis is the treatment of<br>&gt;&gt; external dependencies. The entire module has the same list of external<br>&gt;&gt; dependencies which causes a lot of needless recompiles- especially if you<br>&gt;&gt; start with a large swift project and slowly start to move things into<br>&gt;&gt; modules.<br>&gt;&gt;<br>&gt;&gt; So to me the lowest hanging fruit would be to only mark files for<br>&gt;&gt; recompilation that explicitly import the external dependency. This seems<br>&gt;&gt; pretty safe since you can&#39;t compile unless the dependency is explicitly<br>&gt;&gt; imported. Has anyone on the list tried this before?<br>&gt;&gt;<br>&gt;&gt; A second idea would be to consider a file as changed only if its build<br>&gt;&gt; artifact actually changes. Obviously, we&#39;d have to actually build the file<br>&gt;&gt; to figure this out, so we wouldn&#39;t have the same level of parallelism<br>&gt;&gt; initially. Perhaps if it was an optional compiler flag this would be more<br>&gt;&gt; palatable? Also wondering if anyone has tried something along these lines.<br>&gt;&gt;<br>&gt;&gt; Thanks!<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; George- The bridge between objective c and swift between is definitely a<br>&gt;&gt; choke point. We&#39;ve been able to mitigate objective-c recompiles somewhat by<br>&gt;&gt; limiting our imports of swift into objective-c. We&#39;ve even gone so far as<br>&gt;&gt; to make wrapper classes in objective c around some of our most commonly<br>&gt;&gt; used swift classes so as not to import swift.<br>&gt;&gt;<br>&gt;&gt; It&#39;s also very true that changing an objective c .h file that is imported<br>&gt;&gt; into the bridging header will trigger massive recompiles. As more of our<br>&gt;&gt; app has transitioned to swift this has been less of an issue. Most of the<br>&gt;&gt; problems at this point have to do with recompiling a large portion of our<br>&gt;&gt; swift code due to small changes in unrelated parts of our other swift code.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Get the latest from Hopscotch!<br>&gt;&gt;<br>&gt;&gt; Sign-up for our newsletter &lt;http://eepurl.com/Ui0eX&gt;<br>&gt;&gt;<br>&gt;&gt; On Fri, Apr 8, 2016 at 5:34 PM, George King &lt;gwk.lists at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Hey Sam,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; One thought: if you have an app with mixed objc and swift code, then the<br>&gt;&gt;&gt; app-bridge.h and app-swift.h files might be creating massive choke points<br>&gt;&gt;&gt; in your dependency graph. I have no idea how optimized the bridging<br>&gt;&gt;&gt; functionality is but it has always seemed like a potentially weak part of<br>&gt;&gt;&gt; the dependency management. I imagine that with an objc half and a swift<br>&gt;&gt;&gt; half of the code base, every time you make a change in a swift file you<br>&gt;&gt;&gt; trigger recompilation of the objc half, and vice versa. I&#39;d love to hear<br>&gt;&gt;&gt; from the core team to what extent this is true!<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; George<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Apr 7, 2016, at 5:35 PM, Samantha John via swift-dev &lt;<br>&gt;&gt;&gt; swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Thank you Jordan! This is a great starting off point.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;m thinking about proposing a &quot;strict import&quot; mode in swift: A compile<br>&gt;&gt;&gt; flag that when turned on would require you to explicitly import any file<br>&gt;&gt;&gt; that contained a dependency you needed (like in objective-c).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;m going to spend more time looking over the docs and the output logs<br>&gt;&gt;&gt; to see if this would be a feasible. If anyone has opinions or insights into<br>&gt;&gt;&gt; this I would love to hear from you.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Sam<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Tue, Apr 5, 2016 at 9:08 PM, Jordan Rose &lt;jordan_rose at apple.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Hi, Sam. I don&#39;t think we currently have a good answer for this built<br>&gt;&gt;&gt;&gt; into xcodebuild or xctool, and it&#39;s a reasonable idea. (Ideally all builds<br>&gt;&gt;&gt;&gt; would be fast enough that it wouldn&#39;t matter! That&#39;s obviously not where we<br>&gt;&gt;&gt;&gt; are.)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Since &#39;-debug-time-function-bodies&#39; is now public knowledge, I&#39;ll share<br>&gt;&gt;&gt;&gt; another one of our debugging flags, &#39;-driver-show-incremental&#39;. You can add<br>&gt;&gt;&gt;&gt; this to your &quot;Other Swift Flags&quot;. The output isn&#39;t very detailed, though:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Queuing Tree.swift (initial)<br>&gt;&gt;&gt;&gt; Queuing AdventureScene.swift (initial)<br>&gt;&gt;&gt;&gt; Queuing AdventureScene.swift because of dependencies discovered later<br>&gt;&gt;&gt;&gt; Queuing AppDelegate.swift because of dependencies discovered later<br>&gt;&gt;&gt;&gt; Queuing ChaseArtificialIntelligence.swift because of dependencies<br>&gt;&gt;&gt;&gt; discovered later<br>&gt;&gt;&gt;&gt; Queuing Character.swift because of dependencies discovered later<br>&gt;&gt;&gt;&gt; Queuing SpawnArtificialIntelligence.swift because of dependencies<br>&gt;&gt;&gt;&gt; discovered later<br>&gt;&gt;&gt;&gt; Queuing Goblin.swift because of dependencies discovered later<br>&gt;&gt;&gt;&gt; Queuing Cave.swift because of dependencies discovered later<br>&gt;&gt;&gt;&gt; Queuing AdventureSceneOSXEvents.swift because of dependencies<br>&gt;&gt;&gt;&gt; discovered later<br>&gt;&gt;&gt;&gt; Queuing HeroCharacter.swift because of dependencies discovered later<br>&gt;&gt;&gt;&gt; Queuing EnemyCharacter.swift because of dependencies discovered later<br>&gt;&gt;&gt;&gt; Queuing Boss.swift because of dependencies discovered later<br>&gt;&gt;&gt;&gt; Queuing SharedAssetManagement.swift because of dependencies discovered<br>&gt;&gt;&gt;&gt; later<br>&gt;&gt;&gt;&gt; Queuing Warrior.swift because of dependencies discovered later<br>&gt;&gt;&gt;&gt; Queuing Archer.swift because of dependencies discovered later<br>&gt;&gt;&gt;&gt; Queuing Player.swift because of dependencies discovered later<br>&gt;&gt;&gt;&gt; Queuing ArtificialIntelligence.swift because of dependencies discovered<br>&gt;&gt;&gt;&gt; later<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; In this case, I took a version of the Adventure sample project and<br>&gt;&gt;&gt;&gt; modified &quot;Tree.swift&quot;; that triggered recompilation of several other files.<br>&gt;&gt;&gt;&gt; Unfortunately this view doesn&#39;t tell you how they&#39;re related, only which<br>&gt;&gt;&gt;&gt; ones are actually getting rebuilt.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The next step (and moving into the territory of &quot;working on Swift&quot;<br>&gt;&gt;&gt;&gt; rather than just &quot;trying to figure out why it&#39;s repeating work&quot;) would be<br>&gt;&gt;&gt;&gt; to look at the &quot;swiftdeps&quot; files stored in your DerivedData folder. These<br>&gt;&gt;&gt;&gt; are currently just YAML files describing what Swift thinks the file depends<br>&gt;&gt;&gt;&gt; on, as well as what will trigger rebuilding of other files. This is<br>&gt;&gt;&gt;&gt; intended to be a conservative estimate, since *not* recompiling<br>&gt;&gt;&gt;&gt; something would result in an invalid binary. (Unfortunately I say<br>&gt;&gt;&gt;&gt; &quot;intended&quot; because there are known bugs; fortunately, archive builds are<br>&gt;&gt;&gt;&gt; always clean builds anyway.)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; There&#39;s a document in the Swift repo describing the logic behind<br>&gt;&gt;&gt;&gt; Swift&#39;s dependency analysis:<br>&gt;&gt;&gt;&gt; https://github.com/apple/swift/blob/master/docs/DependencyAnalysis.rst.<br>&gt;&gt;&gt;&gt; The one thing that&#39;s *not* in there is the notion of changes that<br>&gt;&gt;&gt;&gt; don&#39;t affect other files at all. This is accomplished by computing a hash<br>&gt;&gt;&gt;&gt; of all the tokens that *could* affect other files, and seeing if that<br>&gt;&gt;&gt;&gt; hash has changed.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; We definitely have room for improvement here.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Mar 31, 2016, at 11:24 , Samantha John via swift-dev &lt;<br>&gt;&gt;&gt;&gt; swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I have a large project (308 swift files, 441 objective c, 66k lines of<br>&gt;&gt;&gt;&gt; code) where incremental builds can be extremely slow. I&#39;m trying to do some<br>&gt;&gt;&gt;&gt; profiling to figure out what type of things cause large scale recompiles.<br>&gt;&gt;&gt;&gt; The problem is that I can&#39;t find a good way of telling which files get<br>&gt;&gt;&gt;&gt; recompiled on an incremental build and which do not. It seems like files<br>&gt;&gt;&gt;&gt; that are not recompiled still get listed in xcode, but the compiler just<br>&gt;&gt;&gt;&gt; passes over them really fast.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Does anyone know if xctool or xcodebuild has this type of<br>&gt;&gt;&gt;&gt; functionality? Or is there some other way to get this info?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt;&gt; Sam<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt; swift-dev at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt; swift-dev at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160425/b5e49943/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>Swift incremental compile profiling</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>April 25, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Apr 25, 2016, at 8:15 PM, Samantha John &lt;sam at gethopscotch.com&gt; wrote:<br>&gt; <br>&gt; On Mon, Apr 25, 2016 at 12:11 AM, Daniel Dunbar &lt;daniel_dunbar at apple.com &lt;mailto:daniel_dunbar at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Apr 24, 2016, at 3:19 PM, Samantha John via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello List (cc/Jordan),  <br>&gt;&gt; <br>&gt;&gt; At a high level: Brian and I are looking into contributing to incremental compilation in Swift. Right now we&#39;re trying to do an incremental compile by invoking swiftc. <br>&gt;&gt; <br>&gt;&gt; Our understanding so far:<br>&gt;&gt; - swiftc takes a list of input files. <br>&gt;&gt; - If swiftc is invoked with &#39;-incremental&#39;, it requires an &#39;-output-file-map&#39; option to also be passed. We assume this is used to determine where intermediate dependency files go.<br>&gt;&gt; - Looking at the tests in test/Driver/Dependencies/Inputs and the sorts of files Xcode generates when building Swift projects, we determined &#39;-output-file-map&#39; to be a JSON file (which is parsed by the llvm yaml parser? https://github.com/apple/swift/blob/95e3be665d9387eb0d354f3d0f313e44c7b4245d/lib/Driver/OutputFileMap.cpp#L100 &lt;https://github.com/apple/swift/blob/95e3be665d9387eb0d354f3d0f313e44c7b4245d/lib/Driver/OutputFileMap.cpp#L100&gt;). We tried writing our own, this is the shortest version that the compiler didn&#39;t error on:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; {<br>&gt;&gt;   &quot;&quot;: {<br>&gt;&gt;     &quot;swift-dependencies&quot;: &quot;MyModule-main.swiftdeps&quot;<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; - When compiling with the above file (&#39;swiftc -incremental -output-file-map OurFileMap.json *.swift&#39;), swiftc writes to MyModule-main.swiftdeps. The end result looks like this:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; version: &quot;Swift version 3.0-dev (LLVM 752e1430fc, Clang 3987718dae, Swift a2cf18ba2f)&quot;<br>&gt;&gt; options: &quot;9277a78155e85019ce36a3c52e9f3f02&quot;<br>&gt;&gt; build_time: [514847765, 412105000]<br>&gt;&gt; inputs:<br>&gt;&gt;   &quot;Class1.swift&quot;: [514841531, 0]<br>&gt;&gt;   &quot;Class2.swift&quot;: [514844635, 0]<br>&gt;&gt;   &quot;main.swift&quot;: [514841821, 0]<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; - Where the [xxx, yyy] are timestamps with the first number representing seconds, the second nanoseconds. (https://github.com/apple/swift/blob/95e3be665d9387eb0d354f3d0f313e44c7b4245d/lib/Driver/Driver.cpp#L221 &lt;https://github.com/apple/swift/blob/95e3be665d9387eb0d354f3d0f313e44c7b4245d/lib/Driver/Driver.cpp#L221&gt;)<br>&gt;&gt; <br>&gt;&gt; - We invoked &#39;swiftc -incremental -output-file-map OurFileMap.json *.swift -parseable-output -save-temps&#39; to show us the paths to the generated .swiftdeps files. We assume that to get incremental compiles to work for us, we&#39;d need to pass these generated .swiftdeps files&#39; paths to the compiler somehow. We can&#39;t figure out how to do this, so this is the point where our incremental compile fails: https://github.com/apple/swift/blob/95e3be665d9387eb0d354f3d0f313e44c7b4245d/lib/Driver/Compilation.cpp#L348 &lt;https://github.com/apple/swift/blob/95e3be665d9387eb0d354f3d0f313e44c7b4245d/lib/Driver/Compilation.cpp#L348&gt;<br>&gt; You don&#39;t need to point the compiler at the swiftdeps files, it reuses the ones passed in the output file map if -incremental is passed.<br>&gt; <br>&gt; You didn&#39;t mention it (I don&#39;t think) but you also need to pass -emit-dependencies, however it sounds like you are doing this.<br>&gt; <br>&gt;&gt; This is as far as we got. Would super appreciate if anyone on the list could point us in the right direction from here, especially for the following questions:<br>&gt;&gt; <br>&gt;&gt; 1. This would probably be easier if we could find the right test case. We poked around in test/Driver/Dependencies which had a bunch of tests around reading the .swiftdeps files, but we couldn&#39;t find tests that demonstrated how incremental compilation worked at a high level.<br>&gt;&gt; <br>&gt;&gt; 2. &#39;-output-file-map&#39;: Is this file meant to be written by hand, or is there a part of the swift compiler that writes this for you?<br>&gt; <br>&gt; It is meant to be written by the build system which invokes Swift. See also:<br>&gt;   https://github.com/apple/swift-llbuild/blob/master/lib/BuildSystem/SwiftTools.cpp#L206 &lt;https://github.com/apple/swift-llbuild/blob/master/lib/BuildSystem/SwiftTools.cpp#L206&gt;<br>&gt; which is what the Swift package manager uses (which supports incremental compiles).<br>&gt; <br>&gt; This sounds perfect. I tried to install the llbuild but got stuck on filecheck (and saw that you are trying to add it to the toolchain: https://github.com/apple/swift-llbuild/pull/22/files#r61007286 &lt;https://github.com/apple/swift-llbuild/pull/22/files#r61007286&gt;) Is there an executable of llbuild I could download, or do you have any basic instructions for what to do about file check? <br></p><p>You shouldn&#39;t need to download llbuild, you probably want to go the xcodebuild route...<br></p><p>&gt; <br>&gt; <br>&gt; Your best bet is to take the exact command line used by xcodebuild, and then invoke swiftc with that to replicate the incremental build. If you run with -v you should be able to see exactly what files get built <br>&gt; <br>&gt;  I tried running xcodebuild with the verbose flag but wasn&#39;t getting much useful. Is that what you meant here? -v didn&#39;t seem to be an option. <br></p><p>I wasn&#39;t very clear here. What you need to do is run xcodebuild from the command line, and then find the top-level line which is compiling the module you are about (this will be the line with `swiftc ... -incremental ...` in it but not including `-frontend). That is the command you can run with `-v`.<br></p><p> - Daniel<br></p><p>&gt;  <br>&gt; Thanks so much, <br>&gt; Sam<br>&gt; <br>&gt; <br>&gt; HTH!<br>&gt;  - Daniel<br>&gt; <br>&gt;&gt; <br>&gt;&gt; 3. Specifying paths for .swiftdeps: We had assumed this was done based on the &#39;-output-file-map&#39;, but writing the paths we wanted manually did not seem to work. Any tips?<br>&gt;&gt; <br>&gt;&gt; Thanks so much!<br>&gt;&gt; Sam and Brian<br>&gt;&gt; <br>&gt;&gt; On Wed, Apr 13, 2016 at 5:18 PM, Samantha John &lt;sam at gethopscotch.com &lt;mailto:sam at gethopscotch.com&gt;&gt; wrote:<br>&gt;&gt; Hi Jordan, <br>&gt;&gt; <br>&gt;&gt; The thing that sticks out in the dependency analysis is the treatment of external dependencies. The entire module has the same list of external dependencies which causes a lot of needless recompiles- especially if you start with a large swift project and slowly start to move things into modules. <br>&gt;&gt; <br>&gt;&gt; So to me the lowest hanging fruit would be to only mark files for recompilation that explicitly import the external dependency. This seems pretty safe since you can&#39;t compile unless the dependency is explicitly imported. Has anyone on the list tried this before? <br>&gt;&gt; <br>&gt;&gt; A second idea would be to consider a file as changed only if its build artifact actually changes. Obviously, we&#39;d have to actually build the file to figure this out, so we wouldn&#39;t have the same level of parallelism initially. Perhaps if it was an optional compiler flag this would be more palatable? Also wondering if anyone has tried something along these lines.<br>&gt;&gt; <br>&gt;&gt; Thanks! <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; George- The bridge between objective c and swift between is definitely a choke point. We&#39;ve been able to mitigate objective-c recompiles somewhat by limiting our imports of swift into objective-c. We&#39;ve even gone so far as to make wrapper classes in objective c around some of our most commonly used swift classes so as not to import swift. <br>&gt;&gt; <br>&gt;&gt; It&#39;s also very true that changing an objective c .h file that is imported into the bridging header will trigger massive recompiles. As more of our app has transitioned to swift this has been less of an issue. Most of the problems at this point have to do with recompiling a large portion of our swift code due to small changes in unrelated parts of our other swift code. <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Get the latest from Hopscotch!<br>&gt;&gt; <br>&gt;&gt; Sign-up for our newsletter &lt;http://eepurl.com/Ui0eX&gt;<br>&gt;&gt; <br>&gt;&gt; On Fri, Apr 8, 2016 at 5:34 PM, George King &lt;gwk.lists at gmail.com &lt;mailto:gwk.lists at gmail.com&gt;&gt; wrote:<br>&gt;&gt; Hey Sam,<br>&gt;&gt; <br>&gt;&gt; One thought: if you have an app with mixed objc and swift code, then the app-bridge.h and app-swift.h files might be creating massive choke points in your dependency graph. I have no idea how optimized the bridging functionality is but it has always seemed like a potentially weak part of the dependency management. I imagine that with an objc half and a swift half of the code base, every time you make a change in a swift file you trigger recompilation of the objc half, and vice versa. I&#39;d love to hear from the core team to what extent this is true!<br>&gt;&gt; <br>&gt;&gt; George<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Apr 7, 2016, at 5:35 PM, Samantha John via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thank you Jordan! This is a great starting off point.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m thinking about proposing a &quot;strict import&quot; mode in swift: A compile flag that when turned on would require you to explicitly import any file that contained a dependency you needed (like in objective-c).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m going to spend more time looking over the docs and the output logs to see if this would be a feasible. If anyone has opinions or insights into this I would love to hear from you. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sam<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Tue, Apr 5, 2016 at 9:08 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; Hi, Sam. I don&#39;t think we currently have a good answer for this built into xcodebuild or xctool, and it&#39;s a reasonable idea. (Ideally all builds would be fast enough that it wouldn&#39;t matter! That&#39;s obviously not where we are.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Since &#39;-debug-time-function-bodies&#39; is now public knowledge, I&#39;ll share another one of our debugging flags, &#39;-driver-show-incremental&#39;. You can add this to your &quot;Other Swift Flags&quot;. The output isn&#39;t very detailed, though:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Queuing Tree.swift (initial)<br>&gt;&gt;&gt; Queuing AdventureScene.swift (initial)<br>&gt;&gt;&gt; Queuing AdventureScene.swift because of dependencies discovered later<br>&gt;&gt;&gt; Queuing AppDelegate.swift because of dependencies discovered later<br>&gt;&gt;&gt; Queuing ChaseArtificialIntelligence.swift because of dependencies discovered later<br>&gt;&gt;&gt; Queuing Character.swift because of dependencies discovered later<br>&gt;&gt;&gt; Queuing SpawnArtificialIntelligence.swift because of dependencies discovered later<br>&gt;&gt;&gt; Queuing Goblin.swift because of dependencies discovered later<br>&gt;&gt;&gt; Queuing Cave.swift because of dependencies discovered later<br>&gt;&gt;&gt; Queuing AdventureSceneOSXEvents.swift because of dependencies discovered later<br>&gt;&gt;&gt; Queuing HeroCharacter.swift because of dependencies discovered later<br>&gt;&gt;&gt; Queuing EnemyCharacter.swift because of dependencies discovered later<br>&gt;&gt;&gt; Queuing Boss.swift because of dependencies discovered later<br>&gt;&gt;&gt; Queuing SharedAssetManagement.swift because of dependencies discovered later<br>&gt;&gt;&gt; Queuing Warrior.swift because of dependencies discovered later<br>&gt;&gt;&gt; Queuing Archer.swift because of dependencies discovered later<br>&gt;&gt;&gt; Queuing Player.swift because of dependencies discovered later<br>&gt;&gt;&gt; Queuing ArtificialIntelligence.swift because of dependencies discovered later<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In this case, I took a version of the Adventure sample project and modified &quot;Tree.swift&quot;; that triggered recompilation of several other files. Unfortunately this view doesn&#39;t tell you how they&#39;re related, only which ones are actually getting rebuilt.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The next step (and moving into the territory of &quot;working on Swift&quot; rather than just &quot;trying to figure out why it&#39;s repeating work&quot;) would be to look at the &quot;swiftdeps&quot; files stored in your DerivedData folder. These are currently just YAML files describing what Swift thinks the file depends on, as well as what will trigger rebuilding of other files. This is intended to be a conservative estimate, since not recompiling something would result in an invalid binary. (Unfortunately I say &quot;intended&quot; because there are known bugs; fortunately, archive builds are always clean builds anyway.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There&#39;s a document in the Swift repo describing the logic behind Swift&#39;s dependency analysis: https://github.com/apple/swift/blob/master/docs/DependencyAnalysis.rst &lt;https://github.com/apple/swift/blob/master/docs/DependencyAnalysis.rst&gt;. The one thing that&#39;s not in there is the notion of changes that don&#39;t affect other files at all. This is accomplished by computing a hash of all the tokens that could affect other files, and seeing if that hash has changed.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We definitely have room for improvement here.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mar 31, 2016, at 11:24 , Samantha John via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I have a large project (308 swift files, 441 objective c, 66k lines of code) where incremental builds can be extremely slow. I&#39;m trying to do some profiling to figure out what type of things cause large scale recompiles. The problem is that I can&#39;t find a good way of telling which files get recompiled on an incremental build and which do not. It seems like files that are not recompiled still get listed in xcode, but the compiler just passes over them really fast. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Does anyone know if xctool or xcodebuild has this type of functionality? Or is there some other way to get this info?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt;&gt; Sam<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160425/bc42e10c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f921fa5d507b31ef6984fd3d77ae710c?s=50"></div><header><strong>Swift incremental compile profiling</strong> from <string>Brian Gesiak</string> &lt;modocache at gmail.com&gt;<p>August 20, 2016 at 08:00:00pm</p></header><div class="content"><p>Sorry to resurrect an old thread, but:<br>Jordan, I&#39;m trying to learn more about swift/lib/Driver. I picked up a few tasks to get familiar with it:<br>- https://bugs.swift.org/browse/SR-1788- https://bugs.swift.org/browse/SR-2400- https://bugs.swift.org/browse/SR-656<br>I didn&#39;t find any tasks related to incremental builds, though. Are there any low hanging fruit or gardening tasks related to incremental builds? Maybe something you&#39;ve been meaning to do, but haven&#39;t written a task for yet?<br>- Brian Gesiak<br></p><p><br></p><p>On Mon, Apr 25, 2016 at 10:17 PM -0500, &quot;Daniel Dunbar via swift-dev&quot; &lt;swift-dev at swift.org&gt; wrote:<br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p>On Apr 25, 2016, at 8:15 PM, Samantha John &lt;sam at gethopscotch.com&gt; wrote:<br>On Mon, Apr 25, 2016 at 12:11 AM, Daniel Dunbar&lt;daniel_dunbar at apple.com&gt;wrote:<br></p><p>On Apr 24, 2016, at 3:19 PM, Samantha John via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>Hello List (cc/Jordan), <br>At a high level: Brian and I are looking into contributing to incremental compilation in Swift. Right now we&#39;re trying to do an incremental compile by invoking swiftc.<br>Our understanding so far:- swiftc takes a list of input files.- If swiftc is invoked with &#39;-incremental&#39;, it requires an &#39;-output-file-map&#39; option to also be passed. We assume this is used to determine where intermediate dependency files go.- Looking at the tests in test/Driver/Dependencies/Inputs and the sorts of files Xcode generates when building Swift projects, we determined &#39;-output-file-map&#39; to be a JSON file (which is parsed by the llvm yaml parser?https://github.com/apple/swift/blob/95e3be665d9387eb0d354f3d0f313e44c7b4245d/lib/Driver/OutputFileMap.cpp#L100). We tried writing our own, this is the shortest version that the compiler didn&#39;t error on:<br>```{&quot;&quot;: { &quot;swift-dependencies&quot;: &quot;MyModule-main.swiftdeps&quot;}}```<br>- When compiling with the above file (&#39;swiftc -incremental -output-file-map OurFileMap.json *.swift&#39;), swiftc writes to MyModule-main.swiftdeps. The end result looks like this:<br>```version: &quot;Swift version 3.0-dev (LLVM 752e1430fc, Clang 3987718dae, Swift a2cf18ba2f)&quot;options: &quot;9277a78155e85019ce36a3c52e9f3f02&quot;build_time: [514847765, 412105000]inputs:&quot;Class1.swift&quot;: [514841531, 0]&quot;Class2.swift&quot;: [514844635, 0]&quot;main.swift&quot;: [514841821, 0]```<br>- Where the [xxx, yyy] are timestamps with the first number representing seconds, the second nanoseconds. (https://github.com/apple/swift/blob/95e3be665d9387eb0d354f3d0f313e44c7b4245d/lib/Driver/Driver.cpp#L221)<br>- We invoked &#39;swiftc -incremental -output-file-map OurFileMap.json *.swift -parseable-output -save-temps&#39; to show us the paths to the generated .swiftdeps files. We assume that to get incremental compiles to work for us, we&#39;d need to pass these generated .swiftdeps files&#39; paths to the compiler somehow. We can&#39;t figure out how to do this, so this is the point where our incremental compile fails:https://github.com/apple/swift/blob/95e3be665d9387eb0d354f3d0f313e44c7b4245d/lib/Driver/Compilation.cpp#L348<br>You don&#39;t need to point the compiler at the swiftdeps files, it reuses the ones passed in the output file map if -incremental is passed.<br>You didn&#39;t mention it (I don&#39;t think) but you also need to pass -emit-dependencies, however it sounds like you are doing this.<br>This is as far as we got. Would super appreciate if anyone on the list could point us in the right direction from here, especially for the following questions:<br>1. This would probably be easier if we could find the right test case. We poked around in test/Driver/Dependencies which had a bunch of tests around reading the .swiftdeps files, but we couldn&#39;t find tests that demonstrated how incremental compilation worked at a high level.<br>2. &#39;-output-file-map&#39;: Is this file meant to be written by hand, or is there a part of the swift compiler that writes this for you?<br>It is meant to be written by the build system which invokes Swift. See also:https://github.com/apple/swift-llbuild/blob/master/lib/BuildSystem/SwiftTools.cpp#L206which is what the Swift package manager uses (which supports incremental compiles).<br>This sounds perfect. I tried to install the llbuild but got stuck on filecheck (and saw that you are trying to add it to the toolchain:https://github.com/apple/swift-llbuild/pull/22/files#r61007286) Is there an executable of llbuild I could download, or do you have any basic instructions for what to do about file check?<br>You shouldn&#39;t need to download llbuild, you probably want to go the xcodebuild route...<br></p><p><br>Your best bet is to take the exact command line used by xcodebuild, and then invoke swiftc with that to replicate the incremental build. If you run with -v you should be able to see exactly what files get built<br>I tried running xcodebuild with the verbose flag but wasn&#39;t getting much useful. Is that what you meant here? -v didn&#39;t seem to be an option.<br>I wasn&#39;t very clear here. What you need to do is run xcodebuild from the command line, and then find the top-level line which is compiling the module you are about (this will be the line with `swiftc ... -incremental ...` in it but not including `-frontend). That is the command you can run with `-v`.<br>- Daniel<br>Thanks so much,<br>Sam<br></p><p><br>HTH!- Daniel<br></p><p>3. Specifying paths for .swiftdeps: We had assumed this was done based on the &#39;-output-file-map&#39;, but writing the paths we wanted manually did not seem to work. Any tips?<br>Thanks so much!Sam and Brian<br>On Wed, Apr 13, 2016 at 5:18 PM, Samantha John&lt;sam at gethopscotch.com&gt;wrote:<br>Hi Jordan,<br>The thing that sticks out in the dependency analysis is the treatment of external dependencies. The entire module has the same list of external dependencies which causes a lot of needless recompiles- especially if you start with a large swift project and slowly start to move things into modules.<br>So to me the lowest hanging fruit would be to only mark files for recompilation that explicitly import the external dependency. This seems pretty safe since you can&#39;t compile unless the dependency is explicitly imported. Has anyone on the list tried this before?<br>A second idea would be to consider a file as changed only if its build artifact actually changes. Obviously, we&#39;d have to actually build the file to figure this out, so we wouldn&#39;t have the same level of parallelism initially. Perhaps if it was an optional compiler flag this would be more palatable? Also wondering if anyone has tried something along these lines.<br>Thanks!<br></p><p>George- The bridge between objective c and swift between is definitely a choke point. We&#39;ve been able to mitigate objective-c recompiles somewhat by limiting our imports of swift into objective-c. We&#39;ve even gone so far as to make wrapper classes in objective c around some of our most commonly used swift classes so as not to import swift.<br>It&#39;s also very true that changing an objective c .h file that is imported into the bridging header will trigger massive recompiles. As more of our app has transitioned to swift this has been less of an issue. Most of the problems at this point have to do with recompiling a large portion of our swift code due to small changes in unrelated parts of our other swift code.<br></p><p><br></p><p><br></p><p><br>Get the latest from Hopscotch!<br></p><p>Sign-up for our newsletter<br>On Fri, Apr 8, 2016 at 5:34 PM, George King&lt;gwk.lists at gmail.com&gt;wrote:<br>Hey Sam,<br>One thought: if you have an app with mixed objc and swift code, then the app-bridge.h and app-swift.h files might be creating massive choke points in your dependency graph. I have no idea how optimized the bridging functionality is but it has always seemed like a potentially weak part of the dependency management. I imagine that with an objc half and a swift half of the code base, every time you make a change in a swift file you trigger recompilation of the objc half, and vice versa. I&#39;d love to hear from the core team to what extent this is true!<br>George<br></p><p><br>On Apr 7, 2016, at 5:35 PM, Samantha John via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>Thank you Jordan! This is a great starting off point.<br>I&#39;m thinking about proposing a &quot;strict import&quot; mode in swift: A compile flag that when turned on would require you to explicitly import any file that contained a dependency you needed (like in objective-c).<br>I&#39;m going to spend more time looking over the docs and the output logs to see if this would be a feasible. If anyone has opinions or insights into this I would love to hear from you.<br>Sam<br>On Tue, Apr 5, 2016 at 9:08 PM, Jordan Rose&lt;jordan_rose at apple.com&gt;wrote:<br>Hi, Sam. I don&#39;t think we currently have a good answer for this built into xcodebuild or xctool, and it&#39;s a reasonable idea. (Ideally all builds would be fast enough that it wouldn&#39;t matter! That&#39;s obviously not where we are.)<br>Since &#39;-debug-time-function-bodies&#39; is now public knowledge, I&#39;ll share another one of our debugging flags, &#39;-driver-show-incremental&#39;. You can add this to your &quot;Other Swift Flags&quot;. The output isn&#39;t very detailed, though:<br>Queuing Tree.swift (initial)Queuing AdventureScene.swift (initial)Queuing AdventureScene.swift because of dependencies discovered laterQueuing AppDelegate.swift because of dependencies discovered laterQueuing ChaseArtificialIntelligence.swift because of dependencies discovered laterQueuing Character.swift because of dependencies discovered laterQueuing SpawnArtificialIntelligence.swift because of dependencies discovered laterQueuing Goblin.swift because of dependencies discovered laterQueuing Cave.swift because of dependencies discovered laterQueuing AdventureSceneOSXEvents.swift because of dependencies discovered laterQueuing HeroCharacter.swift because of dependencies discovered laterQueuing EnemyCharacter.swift because of dependencies discovered laterQueuing Boss.swift because of dependencies discovered laterQueuing SharedAssetManagement.swift because of dependencies discovered laterQueuing Warrior.swift because of dependencies discovered laterQueuing Archer.swift because of dependencies discovered laterQueuing Player.swift because of dependencies discovered laterQueuing ArtificialIntelligence.swift because of dependencies discovered later<br>In this case, I took a version of the Adventure sample project and modified &quot;Tree.swift&quot;; that triggered recompilation of several other files. Unfortunately this view doesn&#39;t tell you how they&#39;re related, only which ones are actually getting rebuilt.<br>The next step (and moving into the territory of &quot;working on Swift&quot; rather than just &quot;trying to figure out why it&#39;s repeating work&quot;) would be to look at the &quot;swiftdeps&quot; files stored in your DerivedData folder. These are currently just YAML files describing what Swift thinks the file depends on, as well as what will trigger rebuilding of other files. This is intended to be a conservative estimate, sincenotrecompiling something would result in an invalid binary. (Unfortunately I say &quot;intended&quot; because there are known bugs; fortunately, archive builds are always clean builds anyway.)<br>There&#39;s a document in the Swift repo describing the logic behind Swift&#39;s dependency analysis:https://github.com/apple/swift/blob/master/docs/DependencyAnalysis.rst. The one thing that&#39;snotin there is the notion of changes that don&#39;t affect other files at all. This is accomplished by computing a hash of all the tokens thatcouldaffect other files, and seeing if that hash has changed.<br>We definitely have room for improvement here.<br>Jordan<br></p><p>On Mar 31, 2016, at 11:24 , Samantha John via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>I have a large project (308 swift files, 441 objective c, 66k lines of code) where incremental builds can be extremely slow. I&#39;m trying to do some profiling to figure out what type of things cause large scale recompiles. The problem is that I can&#39;t find a good way of telling which files get recompiled on an incremental build and which do not. It seems like files that are not recompiled still get listed in xcode, but the compiler just passes over them really fast.<br>Does anyone know if xctool or xcodebuild has this type of functionality? Or is there some other way to get this info?<br></p><p>Thank you,<br>Sam_______________________________________________<br>swift-dev mailing list<br>swift-dev at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p><br>_______________________________________________<br>swift-dev mailing list<br>swift-dev at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p><br></p><p>_______________________________________________<br>swift-dev mailing list<br>swift-dev at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p><br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160820/82e73f2c/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
