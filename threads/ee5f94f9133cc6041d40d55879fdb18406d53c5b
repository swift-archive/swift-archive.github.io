<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Draft] Adding a Build Configuration Import Test</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March 22, 2016 at 04:00:00pm</p></header><div class="content"><p>Here&#39;s another one, hopefully with a little more grounding than the debug test. <br>I welcome feedback both positive and critical, -- E<br></p><p>Adding an Build Configuration Import Test<br></p><p>Proposal: SE-00XX<br>Author(s): Erica Sadun &lt;http://github.com/erica&gt;<br>Status: TBD<br>Review manager: TBD<br> &lt;https://gist.github.com/erica/b7f4226b8201945602f2#introduction&gt;Introduction<br></p><p>Expanding the build configuration suite to test for the ability to import certain modules was first introduced &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/7516/match=darwin&gt; on the Swift-Evolution list by Kevin Ballard. Although his initial idea (checking for Darwin to differentiate Apple targets from non-Apple targets) proved problematic, developers warmly greeted the notion of an import-based configuration test. Dmitri Gribenko wrote, &quot;There&#39;s a direction that we want to move to a unified name for the libc module for all platform, so &#39;can import Darwin&#39; might not be a viable long-term strategy.&quot; Testing for imports offers advantages that stand apart from this one use-case: to test for API availability before use.<br></p><p> &lt;https://gist.github.com/erica/b7f4226b8201945602f2#motivation&gt;Motivation<br></p><p>Swift&#39;s existing set of build configurations specify platform differences, not module commonalities. For example, UIKit enables you to write view code supported on both iOS and tvOS. SpriteKit allows common code to render on OS X, iOS, and tvOS that would require an alternate UI on Linux. Testing for Metal support or Media Player would guard code that will not function on the simulator. If the simulator adopted these modules at some future time, the code would naturally expand to provide compatible execution without source modification.<br></p><p>#if canImport(UIKit)<br>   // UIKit-based code<br>   #elseif canImport(Cocoa)<br>   // OSX code<br>   #elseif<br>   // Workaround/text, whatever<br>#endif<br>Guarding code with operating system tests can be less future-proofed than testing for module support. Excluding OS X to use UIColor creates code that might eventually find its way to a Linux plaform. Targeting Apple platforms by inverting a test for Linux essentially broke after the introduction of Windows and FreeBSD build configurations:<br></p><p>// Exclusive os tests are brittle<br>#if !os(Linux)<br>   // Matches OSX, iOS, watchOS, tvOS, Windows, FreeBSD<br>#endif<br>Inclusive OS tests (if os1 || os2 || os3...) must be audited each time the set of possible platforms expands. In addition, compound build statements are harder to write, to validate, and are more confusing to read. They are more prone to errors than a single test that&#39;s tied to the API capabilities used by the code it guards.<br></p><p>Evan Maloney writes, &quot;Being able to test for the importability of a given module/framework at runtime would be extremely helpful. We use several frameworks that are only available in a subset of the platforms we support, and on only certain OS versions. To work around this problem now, we dynamically load frameworks from Obj-C only when we&#39;re running on an OS version we know is supported by the framework(s) in question. We can&#39;t dynamically load them from Swift because if they&#39;re included in an import, the runtime tries to load it right away, leading to a crash on any unsupported platform. The only way to selectively load dynamic frameworks at runtime is to do it via Obj-C. Some sort of check like the ones you propose should let us avoid this.&quot;<br></p><p> &lt;https://gist.github.com/erica/b7f4226b8201945602f2#detail-design&gt;Detail Design<br></p><p>#if canImport(module-name) tests for module support by name. My proposed name uses lower camelCase, which is not currently used in the current build configuration vocabulary but is (in my opinion) clearer in intention than the other two terms brought up on the evolution list, #if imports() and #if supports(). <br></p><p>This build configuration does not import the module it names<br>This build configuration is intended to differentiate API access<br>This build configuration should not be used to differentiate platforms<br>The supplied module token is an arbitrary string. It does not belong to an enumerated set of known members as this configuration test is intended for use with both first and third party modules for the greatest flexibility. At compile time, Swift determines whether the module can or cannot be linked and builds accordingly.<br>#if canImport(module)<br>    import module<br>    // use module APIs safely<br>#endif<br></p><p>#if canImport(module)<br>    // provide solution with module APIs<br>    #else<br>    // provide alternative solution that does not depend on that module<br>#endif<br> &lt;https://gist.github.com/erica/b7f4226b8201945602f2#current-art&gt;Current Art<br></p><p>Swift currently supports the following configuration tests:<br></p><p>The literals true and false<br>The os() function that tests for OSX, iOS, watchOS, tvOS, Linux, Windows, and FreeBSD<br>The arch() function that tests for x86_64, arm, arm64, i386, powerpc64, and powerpc64le<br>The swift() function that tests for specific Swift language releases, e.g. swift(&gt;=2.2)<br> &lt;https://gist.github.com/erica/b7f4226b8201945602f2#alternatives-considered&gt;Alternatives Considered<br></p><p>There are no alternatives considered.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160322/ee5f3c5b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Draft] Adding a Build Configuration Import Test</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>March 23, 2016 at 12:00:00am</p></header><div class="content"><p>Strong +1, in my experience in other languages OS based tests (or worse, browser tests in Javascript, *shudders*) are far too often misused, modules are definitely the better way to go.<br></p><p>My only question is whether there should be a way to test minimum module versions? If I add support for a module but target a particularly recent version then that support won’t compile for platforms with older versions of the same module, so I should be able to prevent them from being a match.<br></p><p>&gt; On 22 Mar 2016, at 22:14, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Here&#39;s another one, hopefully with a little more grounding than the debug test. <br>&gt; I welcome feedback both positive and critical, -- E<br>&gt; <br>&gt; Adding an Build Configuration Import Test<br>&gt; <br>&gt; Proposal: SE-00XX<br>&gt; Author(s): Erica Sadun &lt;http://github.com/erica&gt;<br>&gt; Status: TBD<br>&gt; Review manager: TBD<br>&gt;  &lt;https://gist.github.com/erica/b7f4226b8201945602f2#introduction&gt;Introduction<br>&gt; <br>&gt; Expanding the build configuration suite to test for the ability to import certain modules was first introduced &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/7516/match=darwin&gt; on the Swift-Evolution list by Kevin Ballard. Although his initial idea (checking for Darwin to differentiate Apple targets from non-Apple targets) proved problematic, developers warmly greeted the notion of an import-based configuration test. Dmitri Gribenko wrote, &quot;There&#39;s a direction that we want to move to a unified name for the libc module for all platform, so &#39;can import Darwin&#39; might not be a viable long-term strategy.&quot; Testing for imports offers advantages that stand apart from this one use-case: to test for API availability before use.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/b7f4226b8201945602f2#motivation&gt;Motivation<br>&gt; <br>&gt; Swift&#39;s existing set of build configurations specify platform differences, not module commonalities. For example, UIKit enables you to write view code supported on both iOS and tvOS. SpriteKit allows common code to render on OS X, iOS, and tvOS that would require an alternate UI on Linux. Testing for Metal support or Media Player would guard code that will not function on the simulator. If the simulator adopted these modules at some future time, the code would naturally expand to provide compatible execution without source modification.<br>&gt; <br>&gt; #if canImport(UIKit)<br>&gt;    // UIKit-based code<br>&gt;    #elseif canImport(Cocoa)<br>&gt;    // OSX code<br>&gt;    #elseif<br>&gt;    // Workaround/text, whatever<br>&gt; #endif<br>&gt; Guarding code with operating system tests can be less future-proofed than testing for module support. Excluding OS X to use UIColor creates code that might eventually find its way to a Linux plaform. Targeting Apple platforms by inverting a test for Linux essentially broke after the introduction of Windows and FreeBSD build configurations:<br>&gt; <br>&gt; // Exclusive os tests are brittle<br>&gt; #if !os(Linux)<br>&gt;    // Matches OSX, iOS, watchOS, tvOS, Windows, FreeBSD<br>&gt; #endif<br>&gt; Inclusive OS tests (if os1 || os2 || os3...) must be audited each time the set of possible platforms expands. In addition, compound build statements are harder to write, to validate, and are more confusing to read. They are more prone to errors than a single test that&#39;s tied to the API capabilities used by the code it guards.<br>&gt; <br>&gt; Evan Maloney writes, &quot;Being able to test for the importability of a given module/framework at runtime would be extremely helpful. We use several frameworks that are only available in a subset of the platforms we support, and on only certain OS versions. To work around this problem now, we dynamically load frameworks from Obj-C only when we&#39;re running on an OS version we know is supported by the framework(s) in question. We can&#39;t dynamically load them from Swift because if they&#39;re included in an import, the runtime tries to load it right away, leading to a crash on any unsupported platform. The only way to selectively load dynamic frameworks at runtime is to do it via Obj-C. Some sort of check like the ones you propose should let us avoid this.&quot;<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/b7f4226b8201945602f2#detail-design&gt;Detail Design<br>&gt; <br>&gt; #if canImport(module-name) tests for module support by name. My proposed name uses lower camelCase, which is not currently used in the current build configuration vocabulary but is (in my opinion) clearer in intention than the other two terms brought up on the evolution list, #if imports() and #if supports(). <br>&gt; <br>&gt; This build configuration does not import the module it names<br>&gt; This build configuration is intended to differentiate API access<br>&gt; This build configuration should not be used to differentiate platforms<br>&gt; The supplied module token is an arbitrary string. It does not belong to an enumerated set of known members as this configuration test is intended for use with both first and third party modules for the greatest flexibility. At compile time, Swift determines whether the module can or cannot be linked and builds accordingly.<br>&gt; #if canImport(module)<br>&gt;     import module<br>&gt;     // use module APIs safely<br>&gt; #endif<br>&gt; <br>&gt; #if canImport(module)<br>&gt;     // provide solution with module APIs<br>&gt;     #else<br>&gt;     // provide alternative solution that does not depend on that module<br>&gt; #endif<br>&gt;  &lt;https://gist.github.com/erica/b7f4226b8201945602f2#current-art&gt;Current Art<br>&gt; <br>&gt; Swift currently supports the following configuration tests:<br>&gt; <br>&gt; The literals true and false<br>&gt; The os() function that tests for OSX, iOS, watchOS, tvOS, Linux, Windows, and FreeBSD<br>&gt; The arch() function that tests for x86_64, arm, arm64, i386, powerpc64, and powerpc64le<br>&gt; The swift() function that tests for specific Swift language releases, e.g. swift(&gt;=2.2)<br>&gt;  &lt;https://gist.github.com/erica/b7f4226b8201945602f2#alternatives-considered&gt;Alternatives Considered<br>&gt; <br>&gt; There are no alternatives considered.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160323/c5b82703/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Draft] Adding a Build Configuration Import Test</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March 22, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; #if canImport(UIKit)<br>&gt;    // UIKit-based code<br>&gt;    #elseif canImport(Cocoa)<br>&gt;    // OSX code<br>&gt;    #elseif<br>&gt;    // Workaround/text, whatever<br>&gt; #endif<br></p><p>My question is simple: Are there cases where you want to test if you can import something, but you don&#39;t want to *actually* import it? If not, should we perhaps just do this?<br></p><p>	#if import UIKit<br>		// UIKit-based code, has UIKit available<br>	#elseif import Cocoa<br>		// OS X code, has Cocoa available<br>	#else<br>		// Fallback<br>	#endif<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Draft] Adding a Build Configuration Import Test</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March 22, 2016 at 10:00:00pm</p></header><div class="content"><p>I&#39;m preparing a separate platform proposal. I want to make clear that the intent is to use the <br>framework being tested. However, the test that does the import may be separated from the code<br>that uses the framework, which is why the call does not import.<br></p><p>-- E<br></p><p><br>&gt; On Mar 22, 2016, at 10:24 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; #if canImport(UIKit)<br>&gt;&gt;   // UIKit-based code<br>&gt;&gt;   #elseif canImport(Cocoa)<br>&gt;&gt;   // OSX code<br>&gt;&gt;   #elseif<br>&gt;&gt;   // Workaround/text, whatever<br>&gt;&gt; #endif<br>&gt; <br>&gt; My question is simple: Are there cases where you want to test if you can import something, but you don&#39;t want to *actually* import it? If not, should we perhaps just do this?<br>&gt; <br>&gt; 	#if import UIKit<br>&gt; 		// UIKit-based code, has UIKit available<br>&gt; 	#elseif import Cocoa<br>&gt; 		// OS X code, has Cocoa available<br>&gt; 	#else<br>&gt; 		// Fallback<br>&gt; 	#endif<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4002684831b0a89736f4837d2e60f66a?s=50"></div><header><strong>[Draft] Adding a Build Configuration Import Test</strong> from <string>Pierre Monod-Broca</string> &lt;pierremonodbroca at gmail.com&gt;<p>March 23, 2016 at 07:00:00am</p></header><div class="content"><p>My guess is most often one will want to import exactly what one is testing (Brent example) but I guess it would be very handy to do something like<br></p><p>#if canImport(Foo)<br>    import Foo.Bar as FooBar<br>#endif<br></p><p>In this case both form would be relevant.<br></p><p>Also +1 on Haraviks point:<br>&gt; My only question is whether there should be a way to test minimum module versions? If I add support for a module but target a particularly recent version then that support won’t compile for platforms with older versions of the same module, so I should be able to prevent them from being a match.<br></p><p><br></p><p>Pierre<br></p><p>&gt; Le 23 mars 2016 à 05:28, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; I&#39;m preparing a separate platform proposal. I want to make clear that the intent is to use the <br>&gt; framework being tested. However, the test that does the import may be separated from the code<br>&gt; that uses the framework, which is why the call does not import.<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Mar 22, 2016, at 10:24 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; #if canImport(UIKit)<br>&gt;&gt;&gt;  // UIKit-based code<br>&gt;&gt;&gt;  #elseif canImport(Cocoa)<br>&gt;&gt;&gt;  // OSX code<br>&gt;&gt;&gt;  #elseif<br>&gt;&gt;&gt;  // Workaround/text, whatever<br>&gt;&gt;&gt; #endif<br>&gt;&gt; <br>&gt;&gt; My question is simple: Are there cases where you want to test if you can import something, but you don&#39;t want to *actually* import it? If not, should we perhaps just do this?<br>&gt;&gt; <br>&gt;&gt;    #if import UIKit<br>&gt;&gt;        // UIKit-based code, has UIKit available<br>&gt;&gt;    #elseif import Cocoa<br>&gt;&gt;        // OS X code, has Cocoa available<br>&gt;&gt;    #else<br>&gt;&gt;        // Fallback<br>&gt;&gt;    #endif<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Draft] Adding a Build Configuration Import Test</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March 23, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; My guess is most often one will want to import exactly what one is testing (Brent example) but I guess it would be very handy to do something like<br>&gt; <br>&gt; #if canImport(Foo)<br>&gt;    import Foo.Bar as FooBar<br>&gt; #endif<br></p><p>I don&#39;t see any particular reason you couldn&#39;t support anything `import` can support in an `#if import`.<br></p><p>&gt; Also +1 on Haraviks point:<br>&gt;&gt; My only question is whether there should be a way to test minimum module versions? If I add support for a module but target a particularly recent version then that support won’t compile for platforms with older versions of the same module, so I should be able to prevent them from being a match.<br></p><p>I think we&#39;d be better off extending our existing `@available` and `#availability` mechanisms to test module versions in addition to platform versions. Two small, orthogonal features are better than one big, confused one.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4002684831b0a89736f4837d2e60f66a?s=50"></div><header><strong>[Draft] Adding a Build Configuration Import Test</strong> from <string>Pierre Monod-Broca</string> &lt;pierremonodbroca at gmail.com&gt;<p>March 23, 2016 at 09:00:00am</p></header><div class="content"><p>Good points.<br></p><p>Should we allow the following then? And then should Bar be imported if Baz is not present?<br></p><p>#if import Foo.Bar &amp;&amp; import Foo.Baz<br>#endif<br></p><p><br>I also want to mention other forms for further discussion:<br></p><p>#if import Foo.Bar as FooBar<br>#endif<br></p><p>#if !import Foo<br>#endif<br></p><p><br></p><p>Pierre<br></p><p>Le 23 mars 2016 à 08:21, Brent Royal-Gordon &lt;brent at architechies.com&gt; a écrit :<br></p><p>&gt;&gt; My guess is most often one will want to import exactly what one is testing (Brent example) but I guess it would be very handy to do something like<br>&gt;&gt; <br>&gt;&gt; #if canImport(Foo)<br>&gt;&gt;   import Foo.Bar as FooBar<br>&gt;&gt; #endif<br>&gt; <br>&gt; I don&#39;t see any particular reason you couldn&#39;t support anything `import` can support in an `#if import`.<br>&gt; <br>&gt;&gt; Also +1 on Haraviks point:<br>&gt;&gt;&gt; My only question is whether there should be a way to test minimum module versions? If I add support for a module but target a particularly recent version then that support won’t compile for platforms with older versions of the same module, so I should be able to prevent them from being a match.<br>&gt; <br>&gt; I think we&#39;d be better off extending our existing `@available` and `#availability` mechanisms to test module versions in addition to platform versions. Two small, orthogonal features are better than one big, confused one.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Draft] Adding a Build Configuration Import Test</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March 23, 2016 at 05:00:00am</p></header><div class="content"><p>&gt; On Mar 23, 2016, at 12:59 AM, Pierre Monod-Broca &lt;pierremonodbroca at gmail.com&gt; wrote:<br>&gt; <br>&gt; My guess is most often one will want to import exactly what one is testing (Brent example) but I guess it would be very handy to do something like<br>&gt; <br>&gt; #if canImport(Foo)<br>&gt;    import Foo.Bar as FooBar<br>&gt; #endif<br>&gt; <br>&gt; In this case both form would be relevant.<br></p><p>`import as ` does not fall under the scope of this proposal. I have been already discussing it<br>as part of an existing issue about package name conflicts on -build-dev, with the understanding<br>that this portion would have to be raised in -evolution. It&#39;s on my list for separate pitching.<br>An early draft is here: https://gist.github.com/erica/c6553a5f6f35e7462074 &lt;https://gist.github.com/erica/c6553a5f6f35e7462074&gt;, and the most<br>likely pathway would something like:<br></p><p>1. No change in the originating package description.<br></p><p>import PackageDescription<br></p><p>let package = Package(<br>    name:   &quot;SwiftString&quot;,<br>)<br></p><p>2. No change in the consuming package description.<br></p><p>import PackageDescription<br>let package = Package (<br>    name: &quot;myutility&quot;,<br>    dependencies: [<br>       .Package(url: &quot;https://github.com/erica/SwiftString.git &lt;https://github.com/erica/SwiftString.git&gt;&quot;,<br>	        majorVersion: 1),<br>       .Package(url: &quot;https://github.com/nudas/SwiftString.git &lt;https://github.com/nudas/SwiftString.git&gt;&quot;,<br>	        majorVersion: 1),<br>       .Package(url: &quot;http://github.com/erica/SomeStringOtherPackage.git &lt;http://github.com/erica/SomeStringOtherPackage.git&gt;&quot;,<br>                majorVersion: 1), // just throwing some package in there<br>    ],<br>)<br></p><p>3. When unpacking, SwiftPM detects name overlap, automatically uses reverse domain name for unpacking<br></p><p>In the current Swift PM: <br>    fatal: destination path &#39;/home/erica/Work/test/Packages/SwiftString&#39; already exists and is not an empty directory.<br></p><p>Instead:<br>* Would unpack into com.github.erica.SwiftString and com.github.nudas.SwiftString, automatically reversing the url<br>* From Swift files, since &quot;import: SwiftString&quot; allow import as erica.SwiftString, github.erica.SwiftString, or com.github.erica.SwiftString<br></p><p>4. Propose separately, &quot;import as&quot; as a language enhancement.<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160323/f0f402ba/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Draft] Adding a Build Configuration Import Test</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>March 23, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Mar 22, 2016, at 3:14 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/b7f4226b8201945602f2#introduction&gt;Introduction<br>&gt; <br>&gt; Expanding the build configuration suite to test for the ability to import certain modules was first introduced &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/7516/match=darwin&gt; on the Swift-Evolution list by Kevin Ballard. Although his initial idea (checking for Darwin to differentiate Apple targets from non-Apple targets) proved problematic, developers warmly greeted the notion of an import-based configuration test. Dmitri Gribenko wrote, &quot;There&#39;s a direction that we want to move to a unified name for the libc module for all platform, so &#39;can import Darwin&#39; might not be a viable long-term strategy.&quot; Testing for imports offers advantages that stand apart from this one use-case: to test for API availability before use.<br>&gt; <br></p><p>Very interesting proposal.  Note that this is directly analogous to the Clang extension “__has_include”.  __has_include has been useful, and the C++ committee is discussing standardizing the functionality there.<br></p><p>http://clang.llvm.org/docs/LanguageExtensions.html#include-file-checking-macros<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160323/c517ea14/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>[Draft] Adding a Build Configuration Import Test</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>March 24, 2016 at 02:00:00am</p></header><div class="content"><p>Strong +1, very useful.<br></p><p>Perhaps importable instead of canImport? Looks and reads better:<br></p><p>// UXKit at WWDC&#39;16, pretty please!<br>#if importable(UIKit)<br>typealias UXColor = UIColor<br>#elseif importable(Cocoa)<br>typealias UXColor = NSColor<br>#else<br>// meh<br>#endif<br></p><p>A.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ab486d7597af4cfe0be33a762150848?s=50"></div><header><strong>[Draft] Adding a Build Configuration Import Test</strong> from <string>Dany St-Amant</string> &lt;dsa.mls at icloud.com&gt;<p>March 23, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; Le 22 mars 2016 à 18:14, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/b7f4226b8201945602f2#motivation&gt;Motivation<br>&gt; <br>&gt; Swift&#39;s existing set of build configurations specify platform differences, not module commonalities. For example, UIKit enables you to write view code supported on both iOS and tvOS. SpriteKit allows common code to render on OS X, iOS, and tvOS that would require an alternate UI on Linux. Testing for Metal support or Media Player would guard code that will not function on the simulator. If the simulator adopted these modules at some future time, the code would naturally expand to provide compatible execution without source modification.<br>&gt; <br>&gt; #if canImport(UIKit)<br>&gt;    // UIKit-based code<br>&gt;    #elseif canImport(Cocoa)<br>&gt;    // OSX code<br>&gt;    #elseif<br>&gt;    // Workaround/text, whatever<br>&gt; #endif<br>Not sure if its because I mainly live in a world of multi-architectures C cross-compiling, but for example if you canInclude some powerpc header, it does’t mean that your are compiling for powerpc. So, IMO, I think that #if didImport(Cocoa) would be a better wording. This effectively prevent one from doing:<br></p><p>#if didImport(Cocoa)<br>  import Cocoa // Pointless, won’t work<br>#endif<br></p><p>So for conditionally import, we would still be forced to use some form of #if os(OSX)<br></p><p>Dany<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160323/41dda4f0/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d92e9730c561c120200f34e7e50ed46?s=50"></div><header><strong>[Draft] Adding a Build Configuration Import Test</strong> from <string>Jeff Kelley</string> &lt;slaunchaman at gmail.com&gt;<p>March 29, 2016 at 12:00:00am</p></header><div class="content"><p>This might be crazy, but we could also reuse try here:<br></p><p>import Foundation<br>try import UIKit {<br>	// UIKit Code<br>}<br>else try import Cocoa<br>	// Cocoa Code<br>}<br></p><p>This would attempt to import UIKit and if it succeeded, run the code in the closure.<br></p><p><br>Jeff Kelley<br></p><p>SlaunchaMan at gmail.com | @SlaunchaMan &lt;https://twitter.com/SlaunchaMan&gt; | jeffkelley.org &lt;http://jeffkelley.org/&gt;<br>&gt; On Mar 23, 2016, at 9:27 PM, Dany St-Amant via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Le 22 mars 2016 à 18:14, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/erica/b7f4226b8201945602f2#motivation&gt;Motivation<br>&gt;&gt; <br>&gt;&gt; Swift&#39;s existing set of build configurations specify platform differences, not module commonalities. For example, UIKit enables you to write view code supported on both iOS and tvOS. SpriteKit allows common code to render on OS X, iOS, and tvOS that would require an alternate UI on Linux. Testing for Metal support or Media Player would guard code that will not function on the simulator. If the simulator adopted these modules at some future time, the code would naturally expand to provide compatible execution without source modification.<br>&gt;&gt; <br>&gt;&gt; #if canImport(UIKit)<br>&gt;&gt;    // UIKit-based code<br>&gt;&gt;    #elseif canImport(Cocoa)<br>&gt;&gt;    // OSX code<br>&gt;&gt;    #elseif<br>&gt;&gt;    // Workaround/text, whatever<br>&gt;&gt; #endif<br>&gt; Not sure if its because I mainly live in a world of multi-architectures C cross-compiling, but for example if you canInclude some powerpc header, it does’t mean that your are compiling for powerpc. So, IMO, I think that #if didImport(Cocoa) would be a better wording. This effectively prevent one from doing:<br>&gt; <br>&gt; #if didImport(Cocoa)<br>&gt;   import Cocoa // Pointless, won’t work<br>&gt; #endif<br>&gt; <br>&gt; So for conditionally import, we would still be forced to use some form of #if os(OSX)<br>&gt; <br>&gt; Dany<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160329/7bff677e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Draft] Adding a Build Configuration Import Test</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March 28, 2016 at 10:00:00pm</p></header><div class="content"><p>On Mar 28, 2016, at 10:37 PM, Jeff Kelley via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This might be crazy, but we could also reuse try here:<br>&gt; <br>&gt; import Foundation<br>&gt; try import UIKit {<br>&gt; 	// UIKit Code<br>&gt; }<br>&gt; else try import Cocoa<br>&gt; 	// Cocoa Code<br>&gt; }<br>&gt; <br>&gt; This would attempt to import UIKit and if it succeeded, run the code in the closure.<br>&gt; <br></p><p>The problem with your approach is that the Cocoa code would have to compile under iOS and <br>I&#39;m afraid that&#39;s a no-go. Build-configuration tests enable entire blocks of code to be removed<br>from compilation.<br></p><p>-- E<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d92e9730c561c120200f34e7e50ed46?s=50"></div><header><strong>[Draft] Adding a Build Configuration Import Test</strong> from <string>Jeff Kelley</string> &lt;slaunchaman at gmail.com&gt;<p>March 29, 2016 at 12:00:00am</p></header><div class="content"><p>Why would it have to compile under iOS? The “import Cocoa” bit is behind an else clause.<br></p><p><br>Jeff Kelley<br></p><p>SlaunchaMan at gmail.com | @SlaunchaMan &lt;https://twitter.com/SlaunchaMan&gt; | jeffkelley.org &lt;http://jeffkelley.org/&gt;<br>&gt; On Mar 29, 2016, at 12:44 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; On Mar 28, 2016, at 10:37 PM, Jeff Kelley via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This might be crazy, but we could also reuse try here:<br>&gt;&gt; <br>&gt;&gt; import Foundation<br>&gt;&gt; try import UIKit {<br>&gt;&gt; 	// UIKit Code<br>&gt;&gt; }<br>&gt;&gt; else try import Cocoa<br>&gt;&gt; 	// Cocoa Code<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This would attempt to import UIKit and if it succeeded, run the code in the closure.<br>&gt;&gt; <br>&gt; <br>&gt; The problem with your approach is that the Cocoa code would have to compile under iOS and <br>&gt; I&#39;m afraid that&#39;s a no-go. Build-configuration tests enable entire blocks of code to be removed<br>&gt; from compilation.<br>&gt; <br>&gt; -- E<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160329/56b8c7cb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Draft] Adding a Build Configuration Import Test</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March 28, 2016 at 11:00:00pm</p></header><div class="content"><p>`try` is a run-time call.<br></p><p>-- E<br></p><p>&gt; On Mar 28, 2016, at 10:51 PM, Jeff Kelley &lt;slaunchaman at gmail.com&gt; wrote:<br>&gt; <br>&gt; Why would it have to compile under iOS? The “import Cocoa” bit is behind an else clause.<br>&gt; <br>&gt; <br>&gt; Jeff Kelley<br>&gt; <br>&gt; SlaunchaMan at gmail.com &lt;mailto:SlaunchaMan at gmail.com&gt; | @SlaunchaMan &lt;https://twitter.com/SlaunchaMan&gt; | jeffkelley.org &lt;http://jeffkelley.org/&gt;<br>&gt;&gt; On Mar 29, 2016, at 12:44 AM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Mar 28, 2016, at 10:37 PM, Jeff Kelley via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This might be crazy, but we could also reuse try here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; import Foundation<br>&gt;&gt;&gt; try import UIKit {<br>&gt;&gt;&gt; 	// UIKit Code<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; else try import Cocoa<br>&gt;&gt;&gt; 	// Cocoa Code<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This would attempt to import UIKit and if it succeeded, run the code in the closure.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; The problem with your approach is that the Cocoa code would have to compile under iOS and <br>&gt;&gt; I&#39;m afraid that&#39;s a no-go. Build-configuration tests enable entire blocks of code to be removed<br>&gt;&gt; from compilation.<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160328/fc04e3c4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Draft] Adding a Build Configuration Import Test</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March 29, 2016 at 09:00:00am</p></header><div class="content"><p>Pull Request 229: https://github.com/apple/swift-evolution/pull/229 &lt;https://github.com/apple/swift-evolution/pull/229&gt;<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160329/b1122ff6/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
