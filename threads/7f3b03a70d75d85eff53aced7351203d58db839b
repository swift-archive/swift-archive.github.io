<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2dab83c03f62fa4eba08f6261ab4c0ab?s=50"></div><header><strong>do try catch?</strong> from <string>Don Arnel</string> &lt;dmarnel at gmail.com&gt;<p>December  7, 2015 at 09:00:00am</p></header><div class="content"><p>Is there a reason this format was adopted for error handling:<br></p><p>do {<br>    try makeASandwich()<br>    eatASandwich()<br>} catch Error.OutOfCleanDishes {<br>    washDishes()<br>} catch Error.MissingIngredients(let ingredients) {<br>    buyGroceries(ingredients)<br>}<br></p><p>rather than this format:<br></p><p>try {<br>    makeASandwich()<br>    eatASandwich()<br>} catch Error.OutOfCleanDishes {<br>    washDishes()<br>} catch Error.MissingIngredients(let ingredients) {<br>    buyGroceries(ingredients)<br>}<br></p><p>The second format is much more intuitive, and reads easier IMO.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/7f3b839b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2f21b9a585ac9bd93d60a14e6dc17139?s=50"></div><header><strong>do try catch?</strong> from <string>王巍</string> &lt;onevcat at gmail.com&gt;<p>December  7, 2015 at 11:00:00pm</p></header><div class="content"><p>The first (current) choice is better in fact.<br></p><p>With try closure out of the scope, you could not tell exactly which statement would throw. <br>In your example, only `makeSandwich` would throw, so there is no need to mark `eatASandwich` with a `try`.<br></p><p>Current design follows minimal conception very well, you could get to know that only the `makeASandwich` would throw an error, which reduce a lot of noise when reading this code.<br></p><p><br>Best regards.<br>---<br>Sincerely, <br>Wei Wang (王巍, @onevcat)<br>im.onevcat.com &lt;http://im.onevcat.com/&gt;<br>&gt; 在 2015年12月7日，下午11:30，Don Arnel via swift-evolution &lt;swift-evolution at swift.org&gt; 写道：<br>&gt; <br>&gt; Is there a reason this format was adopted for error handling:<br>&gt; <br>&gt; do {<br>&gt;     try makeASandwich()<br>&gt;     eatASandwich()<br>&gt; } catch Error.OutOfCleanDishes {<br>&gt;     washDishes()<br>&gt; } catch Error.MissingIngredients(let ingredients) {<br>&gt;     buyGroceries(ingredients)<br>&gt; }<br>&gt; <br>&gt; rather than this format:<br>&gt; <br>&gt; try {<br>&gt;     makeASandwich()<br>&gt;     eatASandwich()<br>&gt; } catch Error.OutOfCleanDishes {<br>&gt;     washDishes()<br>&gt; } catch Error.MissingIngredients(let ingredients) {<br>&gt;     buyGroceries(ingredients)<br>&gt; }<br>&gt; <br>&gt; The second format is much more intuitive, and reads easier IMO.<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/8b1092df/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f7877c384b6a5494c1b0283eb805831c?s=50"></div><header><strong>do try catch?</strong> from <string>Liam Butler-Lawrence</string> &lt;liamdunn at me.com&gt;<p>December  7, 2015 at 10:00:00am</p></header><div class="content"><p>I completely agree Wei. Using try as a keyword placed before every throwing function is one of the greatest strengths of Swift’s error-handling model.<br></p><p>I do have a new proposal regarding do/try/catch (if I should post this in a new thread, please let me know):<br></p><p>————<br></p><p>The problem:<br></p><p>In Swift 1.0, the only way to conditionally unwrap an optional was with if let. This ended up causing the “pyramid of doom” so often that in Swift 2.0, guard let was introduced.<br></p><p>The same problem is present with do/try/catch. Consider this code snippet:<br></p><p>let coordinator = NSPersistentStoreCoordinator(managedObjectModel: managedObjectModel)<br></p><p>do {<br>    <br>    let documentsDirectoryURL = try NSFileManager.defaultManager().URLForDirectory(.DocumentDirectory, inDomain: .UserDomainMask, appropriateForURL: nil, create: false)<br>    <br>    let persistentStoreFileName = &quot;CoreDataStore.sqlite&quot;<br>    let persistentStoreURL = documentsDirectoryURL.URLByAppendingPathComponent(persistentStoreFileName)<br>    <br>    do {<br>        try coordinator.addPersistentStoreWithType(NSSQLiteStoreType, configuration: nil, URL: persistentStoreURL, options: nil)<br>    }<br>    catch AnotherError.Case1 {<br>        <br>    }<br>    catch AnotherError.Case2 {<br>        <br>    }<br>    catch AnotherError.Case3 {<br>        <br>    }<br>    catch {<br>        <br>    }<br></p><p>}<br>catch MyError.Case1 {<br>    <br>}<br>catch MyError.Case2 {<br>    <br>}<br>catch MyError.Case3 {<br>    <br>}<br>catch {<br>    <br>}<br></p><p>First, yes, I know that URLForDirectory() doesn’t throw MyError. I’m illustrating the common pattern using actual function calls.<br></p><p>I see two problems with the above code:<br></p><p>1. The standard execution of code (if no errors are thrown) gets more and more nested with every call to a throwing function, causing a pyramid of doom. There’s only two levels in this example, but it could easily be four or five.<br></p><p>2. The first try NSFileManager.default… is no less than 20 lines away from its catch statement. Again, with more try statements, this number only increases, making the code very unreadable in my opinion.<br></p><p><br>A possible solution:<br></p><p>Allow a catch clause to be used directly after any function that throws. This clause includes all the catch x {} catch y {} error-handling code. Just like the else clause in a guard let, this catch clause has to return or otherwise break normal execution. Because of this, the overarching do {} catch {} blocks are no longer needed, and normal execution continues without continually increasing code indentation.<br></p><p>This is how the above code snippet might look if this solution was implemented:<br></p><p>let coordinator = NSPersistentStoreCoordinator(managedObjectModel: managedObjectModel)<br></p><p>let documentsDirectoryURL = try NSFileManager.defaultManager().URLForDirectory(.DocumentDirectory, inDomain: .UserDomainMask, appropriateForURL: nil, create: false) catch {<br>    catch MyError.Case1 {<br>        <br>    }<br>    catch MyError.Case2 {<br>        <br>    }<br>    catch MyError.Case3 {<br>        <br>    }<br>    catch {<br>        <br>    }<br>}<br>let persistentStoreFileName = &quot;CoreDataStore.sqlite&quot;<br>let persistentStoreURL = documentsDirectoryURL.URLByAppendingPathComponent(persistentStoreFileName)<br></p><p>try coordinator.addPersistentStoreWithType(NSSQLiteStoreType, configuration: nil, URL: persistentStoreURL, options: nil) catch {<br>    catch AnotherError.Case1 {<br>        <br>    }<br>    catch AnotherError.Case2 {<br>        <br>    }<br>    catch AnotherError.Case3 {<br>        <br>    }<br>    catch {<br>        <br>    }<br>}<br></p><p>The syntax of the new catch block could certainly be improved on (it might also benefit from typed throwing as discussed in another thread). However, even imperfect, this code is much more readable than what’s currently required, as one can instantly tell which try statement goes with which catch statements. In addition, the the pyramid of doom is gone, and the resulting code is reminiscent of a function with many guard lets.<br></p><p>If you have any feedback or know of potential issues that I’m not aware of, I look forward to hearing from you. Thanks so much!<br></p><p>Liam<br></p><p>&gt; On Dec 7, 2015, at 9:36 AM, 王巍 via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The first (current) choice is better in fact.<br>&gt; <br>&gt; With try closure out of the scope, you could not tell exactly which statement would throw. <br>&gt; In your example, only `makeSandwich` would throw, so there is no need to mark `eatASandwich` with a `try`.<br>&gt; <br>&gt; Current design follows minimal conception very well, you could get to know that only the `makeASandwich` would throw an error, which reduce a lot of noise when reading this code.<br>&gt; <br>&gt; <br>&gt; Best regards.<br>&gt; ---<br>&gt; Sincerely, <br>&gt; Wei Wang (王巍, @onevcat)<br>&gt; im.onevcat.com &lt;http://im.onevcat.com/&gt;<br>&gt;&gt; 在 2015年12月7日，下午11:30，Don Arnel via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; 写道：<br>&gt;&gt; <br>&gt;&gt; Is there a reason this format was adopted for error handling:<br>&gt;&gt; <br>&gt;&gt; do {<br>&gt;&gt;     try makeASandwich()<br>&gt;&gt;     eatASandwich()<br>&gt;&gt; } catch Error.OutOfCleanDishes {<br>&gt;&gt;     washDishes()<br>&gt;&gt; } catch Error.MissingIngredients(let ingredients) {<br>&gt;&gt;     buyGroceries(ingredients)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; rather than this format:<br>&gt;&gt; <br>&gt;&gt; try {<br>&gt;&gt;     makeASandwich()<br>&gt;&gt;     eatASandwich()<br>&gt;&gt; } catch Error.OutOfCleanDishes {<br>&gt;&gt;     washDishes()<br>&gt;&gt; } catch Error.MissingIngredients(let ingredients) {<br>&gt;&gt;     buyGroceries(ingredients)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The second format is much more intuitive, and reads easier IMO.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/72556a68/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0f5e460daedc625457bc16580ecdbc04?s=50"></div><header><strong>do try catch?</strong> from <string>Davide De Franceschi</string> &lt;defrenz98 at hotmail.com&gt;<p>December  7, 2015 at 03:00:00pm</p></header><div class="content"><p>I think what you want here (pretty desirable in many situations) is more like a &quot;guard catch&quot; alternative to the usual &quot;guard else&quot; :)<br></p><p>&gt; On 7 Dec 2015, at 15:24, Liam Butler-Lawrence via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I completely agree Wei. Using try as a keyword placed before every throwing function is one of the greatest strengths of Swift’s error-handling model.<br>&gt; <br>&gt; I do have a new proposal regarding do/try/catch (if I should post this in a new thread, please let me know):<br>&gt; <br>&gt; ————<br>&gt; <br>&gt; The problem:<br>&gt; <br>&gt; In Swift 1.0, the only way to conditionally unwrap an optional was with if let. This ended up causing the “pyramid of doom” so often that in Swift 2.0, guard let was introduced.<br>&gt; <br>&gt; The same problem is present with do/try/catch. Consider this code snippet:<br>&gt; <br>&gt; let coordinator = NSPersistentStoreCoordinator(managedObjectModel: managedObjectModel)<br>&gt; <br>&gt; do {<br>&gt;     <br>&gt;     let documentsDirectoryURL = try NSFileManager.defaultManager().URLForDirectory(.DocumentDirectory, inDomain: .UserDomainMask, appropriateForURL: nil, create: false)<br>&gt;     <br>&gt;     let persistentStoreFileName = &quot;CoreDataStore.sqlite&quot;<br>&gt;     let persistentStoreURL = documentsDirectoryURL.URLByAppendingPathComponent(persistentStoreFileName)<br>&gt;     <br>&gt;     do {<br>&gt;         try coordinator.addPersistentStoreWithType(NSSQLiteStoreType, configuration: nil, URL: persistentStoreURL, options: nil)<br>&gt;     }<br>&gt;     catch AnotherError.Case1 {<br>&gt;         <br>&gt;     }<br>&gt;     catch AnotherError.Case2 {<br>&gt;         <br>&gt;     }<br>&gt;     catch AnotherError.Case3 {<br>&gt;         <br>&gt;     }<br>&gt;     catch {<br>&gt;         <br>&gt;     }<br>&gt; <br>&gt; }<br>&gt; catch MyError.Case1 {<br>&gt;     <br>&gt; }<br>&gt; catch MyError.Case2 {<br>&gt;     <br>&gt; }<br>&gt; catch MyError.Case3 {<br>&gt;     <br>&gt; }<br>&gt; catch {<br>&gt;     <br>&gt; }<br>&gt; <br>&gt; First, yes, I know that URLForDirectory() doesn’t throw MyError. I’m illustrating the common pattern using actual function calls.<br>&gt; <br>&gt; I see two problems with the above code:<br>&gt; <br>&gt; 1. The standard execution of code (if no errors are thrown) gets more and more nested with every call to a throwing function, causing a pyramid of doom. There’s only two levels in this example, but it could easily be four or five.<br>&gt; <br>&gt; 2. The first try NSFileManager.default… is no less than 20 lines away from its catch statement. Again, with more try statements, this number only increases, making the code very unreadable in my opinion.<br>&gt; <br>&gt; <br>&gt; A possible solution:<br>&gt; <br>&gt; Allow a catch clause to be used directly after any function that throws. This clause includes all the catch x {} catch y {} error-handling code. Just like the else clause in a guard let, this catch clause has to return or otherwise break normal execution. Because of this, the overarching do {} catch {} blocks are no longer needed, and normal execution continues without continually increasing code indentation.<br>&gt; <br>&gt; This is how the above code snippet might look if this solution was implemented:<br>&gt; <br>&gt; let coordinator = NSPersistentStoreCoordinator(managedObjectModel: managedObjectModel)<br>&gt; <br>&gt; let documentsDirectoryURL = try NSFileManager.defaultManager().URLForDirectory(.DocumentDirectory, inDomain: .UserDomainMask, appropriateForURL: nil, create: false) catch {<br>&gt;     catch MyError.Case1 {<br>&gt;         <br>&gt;     }<br>&gt;     catch MyError.Case2 {<br>&gt;         <br>&gt;     }<br>&gt;     catch MyError.Case3 {<br>&gt;         <br>&gt;     }<br>&gt;     catch {<br>&gt;         <br>&gt;     }<br>&gt; }<br>&gt; let persistentStoreFileName = &quot;CoreDataStore.sqlite&quot;<br>&gt; let persistentStoreURL = documentsDirectoryURL.URLByAppendingPathComponent(persistentStoreFileName)<br>&gt; <br>&gt; try coordinator.addPersistentStoreWithType(NSSQLiteStoreType, configuration: nil, URL: persistentStoreURL, options: nil) catch {<br>&gt;     catch AnotherError.Case1 {<br>&gt;         <br>&gt;     }<br>&gt;     catch AnotherError.Case2 {<br>&gt;         <br>&gt;     }<br>&gt;     catch AnotherError.Case3 {<br>&gt;         <br>&gt;     }<br>&gt;     catch {<br>&gt;         <br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; The syntax of the new catch block could certainly be improved on (it might also benefit from typed throwing as discussed in another thread). However, even imperfect, this code is much more readable than what’s currently required, as one can instantly tell which try statement goes with which catch statements. In addition, the the pyramid of doom is gone, and the resulting code is reminiscent of a function with many guard lets.<br>&gt; <br>&gt; If you have any feedback or know of potential issues that I’m not aware of, I look forward to hearing from you. Thanks so much!<br>&gt; <br>&gt; Liam<br>&gt; <br>&gt;&gt; On Dec 7, 2015, at 9:36 AM, 王巍 via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The first (current) choice is better in fact.<br>&gt;&gt; <br>&gt;&gt; With try closure out of the scope, you could not tell exactly which statement would throw. <br>&gt;&gt; In your example, only `makeSandwich` would throw, so there is no need to mark `eatASandwich` with a `try`.<br>&gt;&gt; <br>&gt;&gt; Current design follows minimal conception very well, you could get to know that only the `makeASandwich` would throw an error, which reduce a lot of noise when reading this code.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Best regards.<br>&gt;&gt; ---<br>&gt;&gt; Sincerely, <br>&gt;&gt; Wei Wang (王巍, @onevcat)<br>&gt;&gt; im.onevcat.com &lt;http://im.onevcat.com/&gt;<br>&gt;&gt;&gt; 在 2015年12月7日，下午11:30，Don Arnel via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; 写道：<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is there a reason this format was adopted for error handling:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; do {<br>&gt;&gt;&gt;     try makeASandwich()<br>&gt;&gt;&gt;     eatASandwich()<br>&gt;&gt;&gt; } catch Error.OutOfCleanDishes {<br>&gt;&gt;&gt;     washDishes()<br>&gt;&gt;&gt; } catch Error.MissingIngredients(let ingredients) {<br>&gt;&gt;&gt;     buyGroceries(ingredients)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; rather than this format:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; try {<br>&gt;&gt;&gt;     makeASandwich()<br>&gt;&gt;&gt;     eatASandwich()<br>&gt;&gt;&gt; } catch Error.OutOfCleanDishes {<br>&gt;&gt;&gt;     washDishes()<br>&gt;&gt;&gt; } catch Error.MissingIngredients(let ingredients) {<br>&gt;&gt;&gt;     buyGroceries(ingredients)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The second format is much more intuitive, and reads easier IMO.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/f14febab/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4548eb4f3cff0c2a1cd388161f0ba001?s=50"></div><header><strong>do try catch?</strong> from <string>Kametrixom Tikara</string> &lt;kametrixom at icloud.com&gt;<p>December  7, 2015 at 04:00:00pm</p></header><div class="content"><p>Hi Liam<br></p><p>I really like that idea, maybe the syntax needs a bit of adjustment. What do you think about this:<br></p><p>guard let unwrapped = optional, result = try test() else {<br>    <br>} catch SomeError.SomeCase {<br>    <br>} catch {<br>    <br>}<br></p><p>However I don’t really know if this is needed since it’s possible to call as many throwing functions as you want in a do-catch block:<br></p><p>let coordinator = NSPersistentStoreCoordinator(managedObjectModel: managedObjectModel)<br></p><p>do {<br>    let documentsDirectoryURL = try NSFileManager.defaultManager().URLForDirectory(.DocumentDirectory, inDomain: .UserDomainMask, appropriateForURL: nil, create: false)<br>    <br>    let persistentStoreFileName = &quot;CoreDataStore.sqlite&quot;<br>    let persistentStoreURL = documentsDirectoryURL.URLByAppendingPathComponent(persistentStoreFileName)<br>    <br>    try coordinator.addPersistentStoreWithType(NSSQLiteStoreType, configuration: nil, URL: persistentStoreURL, options: nil)<br>    <br>} catch MyError.Case1 {<br>    <br>} catch MyError.Case2 {<br>    <br>} catch MyError.Case3 {<br>    <br>} catch AnotherError.Case1 {<br>    <br>} catch AnotherError.Case2 {<br>    <br>} catch AnotherError.Case3 {<br>    <br>} catch {<br>    <br>}<br></p><p>Which makes the need of such a feature redundant. I really like the idea and would love this to be added :)<br></p><p>&gt; On 07 Dec 2015, at 16:24, Liam Butler-Lawrence via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I completely agree Wei. Using try as a keyword placed before every throwing function is one of the greatest strengths of Swift’s error-handling model.<br>&gt; <br>&gt; I do have a new proposal regarding do/try/catch (if I should post this in a new thread, please let me know):<br>&gt; <br>&gt; ————<br>&gt; <br>&gt; The problem:<br>&gt; <br>&gt; In Swift 1.0, the only way to conditionally unwrap an optional was with if let. This ended up causing the “pyramid of doom” so often that in Swift 2.0, guard let was introduced.<br>&gt; <br>&gt; The same problem is present with do/try/catch. Consider this code snippet:<br>&gt; <br>&gt; let coordinator = NSPersistentStoreCoordinator(managedObjectModel: managedObjectModel)<br>&gt; <br>&gt; do {<br>&gt;     <br>&gt;     let documentsDirectoryURL = try NSFileManager.defaultManager().URLForDirectory(.DocumentDirectory, inDomain: .UserDomainMask, appropriateForURL: nil, create: false)<br>&gt;     <br>&gt;     let persistentStoreFileName = &quot;CoreDataStore.sqlite&quot;<br>&gt;     let persistentStoreURL = documentsDirectoryURL.URLByAppendingPathComponent(persistentStoreFileName)<br>&gt;     <br>&gt;     do {<br>&gt;         try coordinator.addPersistentStoreWithType(NSSQLiteStoreType, configuration: nil, URL: persistentStoreURL, options: nil)<br>&gt;     }<br>&gt;     catch AnotherError.Case1 {<br>&gt;         <br>&gt;     }<br>&gt;     catch AnotherError.Case2 {<br>&gt;         <br>&gt;     }<br>&gt;     catch AnotherError.Case3 {<br>&gt;         <br>&gt;     }<br>&gt;     catch {<br>&gt;         <br>&gt;     }<br>&gt; <br>&gt; }<br>&gt; catch MyError.Case1 {<br>&gt;     <br>&gt; }<br>&gt; catch MyError.Case2 {<br>&gt;     <br>&gt; }<br>&gt; catch MyError.Case3 {<br>&gt;     <br>&gt; }<br>&gt; catch {<br>&gt;     <br>&gt; }<br>&gt; <br>&gt; First, yes, I know that URLForDirectory() doesn’t throw MyError. I’m illustrating the common pattern using actual function calls.<br>&gt; <br>&gt; I see two problems with the above code:<br>&gt; <br>&gt; 1. The standard execution of code (if no errors are thrown) gets more and more nested with every call to a throwing function, causing a pyramid of doom. There’s only two levels in this example, but it could easily be four or five.<br>&gt; <br>&gt; 2. The first try NSFileManager.default… is no less than 20 lines away from its catch statement. Again, with more try statements, this number only increases, making the code very unreadable in my opinion.<br>&gt; <br>&gt; <br>&gt; A possible solution:<br>&gt; <br>&gt; Allow a catch clause to be used directly after any function that throws. This clause includes all the catch x {} catch y {} error-handling code. Just like the else clause in a guard let, this catch clause has to return or otherwise break normal execution. Because of this, the overarching do {} catch {} blocks are no longer needed, and normal execution continues without continually increasing code indentation.<br>&gt; <br>&gt; This is how the above code snippet might look if this solution was implemented:<br>&gt; <br>&gt; let coordinator = NSPersistentStoreCoordinator(managedObjectModel: managedObjectModel)<br>&gt; <br>&gt; let documentsDirectoryURL = try NSFileManager.defaultManager().URLForDirectory(.DocumentDirectory, inDomain: .UserDomainMask, appropriateForURL: nil, create: false) catch {<br>&gt;     catch MyError.Case1 {<br>&gt;         <br>&gt;     }<br>&gt;     catch MyError.Case2 {<br>&gt;         <br>&gt;     }<br>&gt;     catch MyError.Case3 {<br>&gt;         <br>&gt;     }<br>&gt;     catch {<br>&gt;         <br>&gt;     }<br>&gt; }<br>&gt; let persistentStoreFileName = &quot;CoreDataStore.sqlite&quot;<br>&gt; let persistentStoreURL = documentsDirectoryURL.URLByAppendingPathComponent(persistentStoreFileName)<br>&gt; <br>&gt; try coordinator.addPersistentStoreWithType(NSSQLiteStoreType, configuration: nil, URL: persistentStoreURL, options: nil) catch {<br>&gt;     catch AnotherError.Case1 {<br>&gt;         <br>&gt;     }<br>&gt;     catch AnotherError.Case2 {<br>&gt;         <br>&gt;     }<br>&gt;     catch AnotherError.Case3 {<br>&gt;         <br>&gt;     }<br>&gt;     catch {<br>&gt;         <br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; The syntax of the new catch block could certainly be improved on (it might also benefit from typed throwing as discussed in another thread). However, even imperfect, this code is much more readable than what’s currently required, as one can instantly tell which try statement goes with which catch statements. In addition, the the pyramid of doom is gone, and the resulting code is reminiscent of a function with many guard lets.<br>&gt; <br>&gt; If you have any feedback or know of potential issues that I’m not aware of, I look forward to hearing from you. Thanks so much!<br>&gt; <br>&gt; Liam<br>&gt; <br>&gt;&gt; On Dec 7, 2015, at 9:36 AM, 王巍 via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The first (current) choice is better in fact.<br>&gt;&gt; <br>&gt;&gt; With try closure out of the scope, you could not tell exactly which statement would throw. <br>&gt;&gt; In your example, only `makeSandwich` would throw, so there is no need to mark `eatASandwich` with a `try`.<br>&gt;&gt; <br>&gt;&gt; Current design follows minimal conception very well, you could get to know that only the `makeASandwich` would throw an error, which reduce a lot of noise when reading this code.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Best regards.<br>&gt;&gt; ---<br>&gt;&gt; Sincerely, <br>&gt;&gt; Wei Wang (王巍, @onevcat)<br>&gt;&gt; im.onevcat.com &lt;http://im.onevcat.com/&gt;<br>&gt;&gt;&gt; 在 2015年12月7日，下午11:30，Don Arnel via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; 写道：<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is there a reason this format was adopted for error handling:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; do {<br>&gt;&gt;&gt;     try makeASandwich()<br>&gt;&gt;&gt;     eatASandwich()<br>&gt;&gt;&gt; } catch Error.OutOfCleanDishes {<br>&gt;&gt;&gt;     washDishes()<br>&gt;&gt;&gt; } catch Error.MissingIngredients(let ingredients) {<br>&gt;&gt;&gt;     buyGroceries(ingredients)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; rather than this format:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; try {<br>&gt;&gt;&gt;     makeASandwich()<br>&gt;&gt;&gt;     eatASandwich()<br>&gt;&gt;&gt; } catch Error.OutOfCleanDishes {<br>&gt;&gt;&gt;     washDishes()<br>&gt;&gt;&gt; } catch Error.MissingIngredients(let ingredients) {<br>&gt;&gt;&gt;     buyGroceries(ingredients)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The second format is much more intuitive, and reads easier IMO.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/0d2e9ac8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f7877c384b6a5494c1b0283eb805831c?s=50"></div><header><strong>do try catch?</strong> from <string>Liam Butler-Lawrence</string> &lt;liamdunn at me.com&gt;<p>December  7, 2015 at 12:00:00pm</p></header><div class="content"><p>Hey Kametrixom,<br></p><p>Thanks for the feedback! I agree that the proposed syntax needs improvement.<br></p><p>&gt; guard let unwrapped = optional, result = try test() else {<br>&gt;     <br>&gt; } catch SomeError.SomeCase {<br>&gt;     <br>&gt; } catch {<br>&gt;     <br>&gt; }<br></p><p><br>I like this example, but it seems rather specific. Are you just using the  guard let unwrapped = optional to show how guard let and the catch block could be used together, or suggesting that guard let should be required for this functionality? If the latter, how would we handle throwing functions that don’t return a value?<br></p><p>I’m fine with removing the enclosing catch { } from my original suggestion; perhaps something like this? My only concern with this is that it’s slightly confusing to have the first catch X on the same line as the try call.<br></p><p>&gt; let result = try test() catch SomeError.SomeCase {<br>&gt;     <br>&gt; } catch {<br>&gt;     <br>&gt; }<br></p><p><br>Also, regarding the new syntax being redundant:<br></p><p>&gt; let coordinator = NSPersistentStoreCoordinator(managedObjectModel: managedObjectModel)<br>&gt; <br>&gt; do {<br>&gt;     let documentsDirectoryURL = try NSFileManager.defaultManager().URLForDirectory(.DocumentDirectory, inDomain: .UserDomainMask, appropriateForURL: nil, create: false)<br>&gt;     <br>&gt;     let persistentStoreFileName = &quot;CoreDataStore.sqlite&quot;<br>&gt;     let persistentStoreURL = documentsDirectoryURL.URLByAppendingPathComponent(persistentStoreFileName)<br>&gt;     <br>&gt;     try coordinator.addPersistentStoreWithType(NSSQLiteStoreType, configuration: nil, URL: persistentStoreURL, options: nil)<br>&gt;     <br>&gt; } catch MyError.Case1 {<br>&gt;     <br>&gt; } catch MyError.Case2 {<br>&gt;     <br>&gt; } catch MyError.Case3 {<br>&gt;     <br>&gt; } catch AnotherError.Case1 {<br>&gt;     <br>&gt; } catch AnotherError.Case2 {<br>&gt;     <br>&gt; } catch AnotherError.Case3 {<br>&gt;     <br>&gt; } catch {<br>&gt;     <br>&gt; }<br></p><p>Thanks for pointing out this possibility. However, this code makes it even harder to decipher where MyError will be thrown from. How about AnotherError– which function threw that? No way to know. In certain cases that may not be an issue, but what if the error handling code presented a UI error? I might want to know more than just what the error is, but the context in which it was generated as well. Putting all the catch blocks at the end directly impacts readability.<br></p><p>As an extension of this issue, suppose that both throwing functions threw the same kind of error. If I want to use a different response based on which function call actually threw the error, I simply can’t do that using this method.<br></p><p>Look forward to hearing your thoughts. Thanks again!<br></p><p>Liam<br></p><p>&gt; On Dec 7, 2015, at 10:49 AM, Kametrixom Tikara &lt;kametrixom at icloud.com&gt; wrote:<br>&gt; <br>&gt; Hi Liam<br>&gt; <br>&gt; I really like that idea, maybe the syntax needs a bit of adjustment. What do you think about this:<br>&gt; <br>&gt; guard let unwrapped = optional, result = try test() else {<br>&gt;     <br>&gt; } catch SomeError.SomeCase {<br>&gt;     <br>&gt; } catch {<br>&gt;     <br>&gt; }<br>&gt; <br>&gt; However I don’t really know if this is needed since it’s possible to call as many throwing functions as you want in a do-catch block:<br>&gt; <br>&gt; let coordinator = NSPersistentStoreCoordinator(managedObjectModel: managedObjectModel)<br>&gt; <br>&gt; do {<br>&gt;     let documentsDirectoryURL = try NSFileManager.defaultManager().URLForDirectory(.DocumentDirectory, inDomain: .UserDomainMask, appropriateForURL: nil, create: false)<br>&gt;     <br>&gt;     let persistentStoreFileName = &quot;CoreDataStore.sqlite&quot;<br>&gt;     let persistentStoreURL = documentsDirectoryURL.URLByAppendingPathComponent(persistentStoreFileName)<br>&gt;     <br>&gt;     try coordinator.addPersistentStoreWithType(NSSQLiteStoreType, configuration: nil, URL: persistentStoreURL, options: nil)<br>&gt;     <br>&gt; } catch MyError.Case1 {<br>&gt;     <br>&gt; } catch MyError.Case2 {<br>&gt;     <br>&gt; } catch MyError.Case3 {<br>&gt;     <br>&gt; } catch AnotherError.Case1 {<br>&gt;     <br>&gt; } catch AnotherError.Case2 {<br>&gt;     <br>&gt; } catch AnotherError.Case3 {<br>&gt;     <br>&gt; } catch {<br>&gt;     <br>&gt; }<br>&gt; <br>&gt; Which makes the need of such a feature redundant. I really like the idea and would love this to be added :)<br>&gt; <br>&gt;&gt; On 07 Dec 2015, at 16:24, Liam Butler-Lawrence via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I completely agree Wei. Using try as a keyword placed before every throwing function is one of the greatest strengths of Swift’s error-handling model.<br>&gt;&gt; <br>&gt;&gt; I do have a new proposal regarding do/try/catch (if I should post this in a new thread, please let me know):<br>&gt;&gt; <br>&gt;&gt; ————<br>&gt;&gt; <br>&gt;&gt; The problem:<br>&gt;&gt; <br>&gt;&gt; In Swift 1.0, the only way to conditionally unwrap an optional was with if let. This ended up causing the “pyramid of doom” so often that in Swift 2.0, guard let was introduced.<br>&gt;&gt; <br>&gt;&gt; The same problem is present with do/try/catch. Consider this code snippet:<br>&gt;&gt; <br>&gt;&gt; let coordinator = NSPersistentStoreCoordinator(managedObjectModel: managedObjectModel)<br>&gt;&gt; <br>&gt;&gt; do {<br>&gt;&gt;     <br>&gt;&gt;     let documentsDirectoryURL = try NSFileManager.defaultManager().URLForDirectory(.DocumentDirectory, inDomain: .UserDomainMask, appropriateForURL: nil, create: false)<br>&gt;&gt;     <br>&gt;&gt;     let persistentStoreFileName = &quot;CoreDataStore.sqlite&quot;<br>&gt;&gt;     let persistentStoreURL = documentsDirectoryURL.URLByAppendingPathComponent(persistentStoreFileName)<br>&gt;&gt;     <br>&gt;&gt;     do {<br>&gt;&gt;         try coordinator.addPersistentStoreWithType(NSSQLiteStoreType, configuration: nil, URL: persistentStoreURL, options: nil)<br>&gt;&gt;     }<br>&gt;&gt;     catch AnotherError.Case1 {<br>&gt;&gt;         <br>&gt;&gt;     }<br>&gt;&gt;     catch AnotherError.Case2 {<br>&gt;&gt;         <br>&gt;&gt;     }<br>&gt;&gt;     catch AnotherError.Case3 {<br>&gt;&gt;         <br>&gt;&gt;     }<br>&gt;&gt;     catch {<br>&gt;&gt;         <br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; catch MyError.Case1 {<br>&gt;&gt;     <br>&gt;&gt; }<br>&gt;&gt; catch MyError.Case2 {<br>&gt;&gt;     <br>&gt;&gt; }<br>&gt;&gt; catch MyError.Case3 {<br>&gt;&gt;     <br>&gt;&gt; }<br>&gt;&gt; catch {<br>&gt;&gt;     <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; First, yes, I know that URLForDirectory() doesn’t throw MyError. I’m illustrating the common pattern using actual function calls.<br>&gt;&gt; <br>&gt;&gt; I see two problems with the above code:<br>&gt;&gt; <br>&gt;&gt; 1. The standard execution of code (if no errors are thrown) gets more and more nested with every call to a throwing function, causing a pyramid of doom. There’s only two levels in this example, but it could easily be four or five.<br>&gt;&gt; <br>&gt;&gt; 2. The first try NSFileManager.default… is no less than 20 lines away from its catch statement. Again, with more try statements, this number only increases, making the code very unreadable in my opinion.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; A possible solution:<br>&gt;&gt; <br>&gt;&gt; Allow a catch clause to be used directly after any function that throws. This clause includes all the catch x {} catch y {} error-handling code. Just like the else clause in a guard let, this catch clause has to return or otherwise break normal execution. Because of this, the overarching do {} catch {} blocks are no longer needed, and normal execution continues without continually increasing code indentation.<br>&gt;&gt; <br>&gt;&gt; This is how the above code snippet might look if this solution was implemented:<br>&gt;&gt; <br>&gt;&gt; let coordinator = NSPersistentStoreCoordinator(managedObjectModel: managedObjectModel)<br>&gt;&gt; <br>&gt;&gt; let documentsDirectoryURL = try NSFileManager.defaultManager().URLForDirectory(.DocumentDirectory, inDomain: .UserDomainMask, appropriateForURL: nil, create: false) catch {<br>&gt;&gt;     catch MyError.Case1 {<br>&gt;&gt;         <br>&gt;&gt;     }<br>&gt;&gt;     catch MyError.Case2 {<br>&gt;&gt;         <br>&gt;&gt;     }<br>&gt;&gt;     catch MyError.Case3 {<br>&gt;&gt;         <br>&gt;&gt;     }<br>&gt;&gt;     catch {<br>&gt;&gt;         <br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; let persistentStoreFileName = &quot;CoreDataStore.sqlite&quot;<br>&gt;&gt; let persistentStoreURL = documentsDirectoryURL.URLByAppendingPathComponent(persistentStoreFileName)<br>&gt;&gt; <br>&gt;&gt; try coordinator.addPersistentStoreWithType(NSSQLiteStoreType, configuration: nil, URL: persistentStoreURL, options: nil) catch {<br>&gt;&gt;     catch AnotherError.Case1 {<br>&gt;&gt;         <br>&gt;&gt;     }<br>&gt;&gt;     catch AnotherError.Case2 {<br>&gt;&gt;         <br>&gt;&gt;     }<br>&gt;&gt;     catch AnotherError.Case3 {<br>&gt;&gt;         <br>&gt;&gt;     }<br>&gt;&gt;     catch {<br>&gt;&gt;         <br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The syntax of the new catch block could certainly be improved on (it might also benefit from typed throwing as discussed in another thread). However, even imperfect, this code is much more readable than what’s currently required, as one can instantly tell which try statement goes with which catch statements. In addition, the the pyramid of doom is gone, and the resulting code is reminiscent of a function with many guard lets.<br>&gt;&gt; <br>&gt;&gt; If you have any feedback or know of potential issues that I’m not aware of, I look forward to hearing from you. Thanks so much!<br>&gt;&gt; <br>&gt;&gt; Liam<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 7, 2015, at 9:36 AM, 王巍 via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The first (current) choice is better in fact.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With try closure out of the scope, you could not tell exactly which statement would throw. <br>&gt;&gt;&gt; In your example, only `makeSandwich` would throw, so there is no need to mark `eatASandwich` with a `try`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Current design follows minimal conception very well, you could get to know that only the `makeASandwich` would throw an error, which reduce a lot of noise when reading this code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Best regards.<br>&gt;&gt;&gt; ---<br>&gt;&gt;&gt; Sincerely, <br>&gt;&gt;&gt; Wei Wang (王巍, @onevcat)<br>&gt;&gt;&gt; im.onevcat.com &lt;http://im.onevcat.com/&gt;<br>&gt;&gt;&gt;&gt; 在 2015年12月7日，下午11:30，Don Arnel via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; 写道：<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Is there a reason this format was adopted for error handling:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; do {<br>&gt;&gt;&gt;&gt;     try makeASandwich()<br>&gt;&gt;&gt;&gt;     eatASandwich()<br>&gt;&gt;&gt;&gt; } catch Error.OutOfCleanDishes {<br>&gt;&gt;&gt;&gt;     washDishes()<br>&gt;&gt;&gt;&gt; } catch Error.MissingIngredients(let ingredients) {<br>&gt;&gt;&gt;&gt;     buyGroceries(ingredients)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; rather than this format:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; try {<br>&gt;&gt;&gt;&gt;     makeASandwich()<br>&gt;&gt;&gt;&gt;     eatASandwich()<br>&gt;&gt;&gt;&gt; } catch Error.OutOfCleanDishes {<br>&gt;&gt;&gt;&gt;     washDishes()<br>&gt;&gt;&gt;&gt; } catch Error.MissingIngredients(let ingredients) {<br>&gt;&gt;&gt;&gt;     buyGroceries(ingredients)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The second format is much more intuitive, and reads easier IMO.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/6be88e5e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4548eb4f3cff0c2a1cd388161f0ba001?s=50"></div><header><strong>do try catch?</strong> from <string>Kametrixom Tikara</string> &lt;kametrixom at icloud.com&gt;<p>December  7, 2015 at 08:00:00pm</p></header><div class="content"><p>Hi Liam, this is how I imagine it working, I proposed three slightly different syntax rules:<br></p><p>enum Error : ErrorType { case Some }<br></p><p>func test(bar: Int?, baz: Bool?, foo: String throws -&gt; Void, qux: () throws -&gt; Double) {<br>    // Currently possible:<br>    do {<br>        try foo(&quot;Hello&quot;)<br>        let x = try qux()<br>    } catch Error.Some {<br>        print(&quot;Error!&quot;)<br>    } catch {<br>        print(&quot;Error!&quot;)<br>    }<br>    <br>    // First syntax:<br>    guard let<br>        bar = bar,  // Has to be non-nil<br>        try foo(&quot;Hello&quot;),   // Has to not throw an error<br>        x = try qux()<br>        where bar &gt; 10<br>    else {    // Has to not throw an error<br>        return  // Bar or baz was nil<br>    } catch Error.Some {<br>        return  // Some Error occured<br>    } catch {<br>        return  // Another Error occured<br>    }<br>    <br>    // `else` has to be there for optional, `catch` for errors<br>    guard try foo(&quot;Hello&quot;), let x = try qux() where x &lt; 10 catch Error.Some {<br>        return<br>    } catch {<br>        return<br>    }<br>    <br>    // Results can be ignored; catch can be on new line<br>    guard let<br>        _ = try foo(&quot;Hello&quot;),<br>        _ = try qux()<br>    catch Error.Some {  // Not 100% beautiful<br>        return<br>    } catch {<br>        return<br>    }<br>    <br>    <br>    // Second syntax, no error matching, my personal preference<br>    <br>    guard try foo(&quot;Hello&quot;), let x = try qux() catch {<br>        switch error {<br>        case Error.Some: return<br>        default: return<br>        }<br>    }<br>    <br>    guard let bar = bar, let _ = try qux() where baz == true else {<br>        return<br>    } catch {<br>        return<br>    }<br>    <br>    <br>    // Third syntax, `else` for everything, implicit `error` variable when a `try` was used in the guard<br>    <br>    guard try foo(&quot;Hello&quot;) else {<br>        switch error {<br>        case Error.Some: return<br>        default: return<br>        }<br>    }<br>}<br></p><p>I think this feels right at home in Swift, `guard` indicating that some condition has to be met or else exit the scope. This syntax<br></p><p>&gt;&gt; let result = try test() catch SomeError.SomeCase {<br>&gt;&gt;     <br>&gt;&gt; } catch {<br>&gt;&gt;     <br>&gt;&gt; }<br></p><p>you proposed doesn’t make it really clear that the scope has to be exited but I like it nonetheless. This also is in the same spirit as the recent discussion on making `if else`, `switch case` and such work as expression.<br></p><p>– Kame<br></p><p><br>&gt; On 07 Dec 2015, at 18:40, Liam Butler-Lawrence &lt;liamdunn at me.com &lt;mailto:liamdunn at me.com&gt;&gt; wrote:<br>&gt; <br>&gt; Hey Kametrixom,<br>&gt; <br>&gt; Thanks for the feedback! I agree that the proposed syntax needs improvement.<br>&gt; <br>&gt;&gt; guard let unwrapped = optional, result = try test() else {<br>&gt;&gt;     <br>&gt;&gt; } catch SomeError.SomeCase {<br>&gt;&gt;     <br>&gt;&gt; } catch {<br>&gt;&gt;     <br>&gt;&gt; }<br>&gt; <br>&gt; <br>&gt; I like this example, but it seems rather specific. Are you just using the  guard let unwrapped = optional to show how guard let and the catch block could be used together, or suggesting that guard let should be required for this functionality? If the latter, how would we handle throwing functions that don’t return a value?<br>&gt; <br>&gt; I’m fine with removing the enclosing catch { } from my original suggestion; perhaps something like this? My only concern with this is that it’s slightly confusing to have the first catch X on the same line as the try call.<br>&gt; <br>&gt;&gt; let result = try test() catch SomeError.SomeCase {<br>&gt;&gt;     <br>&gt;&gt; } catch {<br>&gt;&gt;     <br>&gt;&gt; }<br>&gt; <br>&gt; <br>&gt; Also, regarding the new syntax being redundant:<br>&gt; <br>&gt;&gt; let coordinator = NSPersistentStoreCoordinator(managedObjectModel: managedObjectModel)<br>&gt;&gt; <br>&gt;&gt; do {<br>&gt;&gt;     let documentsDirectoryURL = try NSFileManager.defaultManager().URLForDirectory(.DocumentDirectory, inDomain: .UserDomainMask, appropriateForURL: nil, create: false)<br>&gt;&gt;     <br>&gt;&gt;     let persistentStoreFileName = &quot;CoreDataStore.sqlite&quot;<br>&gt;&gt;     let persistentStoreURL = documentsDirectoryURL.URLByAppendingPathComponent(persistentStoreFileName)<br>&gt;&gt;     <br>&gt;&gt;     try coordinator.addPersistentStoreWithType(NSSQLiteStoreType, configuration: nil, URL: persistentStoreURL, options: nil)<br>&gt;&gt;     <br>&gt;&gt; } catch MyError.Case1 {<br>&gt;&gt;     <br>&gt;&gt; } catch MyError.Case2 {<br>&gt;&gt;     <br>&gt;&gt; } catch MyError.Case3 {<br>&gt;&gt;     <br>&gt;&gt; } catch AnotherError.Case1 {<br>&gt;&gt;     <br>&gt;&gt; } catch AnotherError.Case2 {<br>&gt;&gt;     <br>&gt;&gt; } catch AnotherError.Case3 {<br>&gt;&gt;     <br>&gt;&gt; } catch {<br>&gt;&gt;     <br>&gt;&gt; }<br>&gt; <br>&gt; Thanks for pointing out this possibility. However, this code makes it even harder to decipher where MyError will be thrown from. How about AnotherError– which function threw that? No way to know. In certain cases that may not be an issue, but what if the error handling code presented a UI error? I might want to know more than just what the error is, but the context in which it was generated as well. Putting all the catch blocks at the end directly impacts readability.<br>&gt; <br>&gt; As an extension of this issue, suppose that both throwing functions threw the same kind of error. If I want to use a different response based on which function call actually threw the error, I simply can’t do that using this method.<br>&gt; <br>&gt; Look forward to hearing your thoughts. Thanks again!<br>&gt; <br>&gt; Liam<br>&gt; <br>&gt;&gt; On Dec 7, 2015, at 10:49 AM, Kametrixom Tikara &lt;kametrixom at icloud.com &lt;mailto:kametrixom at icloud.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi Liam<br>&gt;&gt; <br>&gt;&gt; I really like that idea, maybe the syntax needs a bit of adjustment. What do you think about this:<br>&gt;&gt; <br>&gt;&gt; guard let unwrapped = optional, result = try test() else {<br>&gt;&gt;     <br>&gt;&gt; } catch SomeError.SomeCase {<br>&gt;&gt;     <br>&gt;&gt; } catch {<br>&gt;&gt;     <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; However I don’t really know if this is needed since it’s possible to call as many throwing functions as you want in a do-catch block:<br>&gt;&gt; <br>&gt;&gt; let coordinator = NSPersistentStoreCoordinator(managedObjectModel: managedObjectModel)<br>&gt;&gt; <br>&gt;&gt; do {<br>&gt;&gt;     let documentsDirectoryURL = try NSFileManager.defaultManager().URLForDirectory(.DocumentDirectory, inDomain: .UserDomainMask, appropriateForURL: nil, create: false)<br>&gt;&gt;     <br>&gt;&gt;     let persistentStoreFileName = &quot;CoreDataStore.sqlite&quot;<br>&gt;&gt;     let persistentStoreURL = documentsDirectoryURL.URLByAppendingPathComponent(persistentStoreFileName)<br>&gt;&gt;     <br>&gt;&gt;     try coordinator.addPersistentStoreWithType(NSSQLiteStoreType, configuration: nil, URL: persistentStoreURL, options: nil)<br>&gt;&gt;     <br>&gt;&gt; } catch MyError.Case1 {<br>&gt;&gt;     <br>&gt;&gt; } catch MyError.Case2 {<br>&gt;&gt;     <br>&gt;&gt; } catch MyError.Case3 {<br>&gt;&gt;     <br>&gt;&gt; } catch AnotherError.Case1 {<br>&gt;&gt;     <br>&gt;&gt; } catch AnotherError.Case2 {<br>&gt;&gt;     <br>&gt;&gt; } catch AnotherError.Case3 {<br>&gt;&gt;     <br>&gt;&gt; } catch {<br>&gt;&gt;     <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Which makes the need of such a feature redundant. I really like the idea and would love this to be added :)<br>&gt;&gt; <br>&gt;&gt;&gt; On 07 Dec 2015, at 16:24, Liam Butler-Lawrence via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I completely agree Wei. Using try as a keyword placed before every throwing function is one of the greatest strengths of Swift’s error-handling model.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I do have a new proposal regarding do/try/catch (if I should post this in a new thread, please let me know):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ————<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The problem:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In Swift 1.0, the only way to conditionally unwrap an optional was with if let. This ended up causing the “pyramid of doom” so often that in Swift 2.0, guard let was introduced.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The same problem is present with do/try/catch. Consider this code snippet:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let coordinator = NSPersistentStoreCoordinator(managedObjectModel: managedObjectModel)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; do {<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     let documentsDirectoryURL = try NSFileManager.defaultManager().URLForDirectory(.DocumentDirectory, inDomain: .UserDomainMask, appropriateForURL: nil, create: false)<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     let persistentStoreFileName = &quot;CoreDataStore.sqlite&quot;<br>&gt;&gt;&gt;     let persistentStoreURL = documentsDirectoryURL.URLByAppendingPathComponent(persistentStoreFileName)<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     do {<br>&gt;&gt;&gt;         try coordinator.addPersistentStoreWithType(NSSQLiteStoreType, configuration: nil, URL: persistentStoreURL, options: nil)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     catch AnotherError.Case1 {<br>&gt;&gt;&gt;         <br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     catch AnotherError.Case2 {<br>&gt;&gt;&gt;         <br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     catch AnotherError.Case3 {<br>&gt;&gt;&gt;         <br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     catch {<br>&gt;&gt;&gt;         <br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; catch MyError.Case1 {<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; catch MyError.Case2 {<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; catch MyError.Case3 {<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; catch {<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; First, yes, I know that URLForDirectory() doesn’t throw MyError. I’m illustrating the common pattern using actual function calls.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I see two problems with the above code:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. The standard execution of code (if no errors are thrown) gets more and more nested with every call to a throwing function, causing a pyramid of doom. There’s only two levels in this example, but it could easily be four or five.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2. The first try NSFileManager.default… is no less than 20 lines away from its catch statement. Again, with more try statements, this number only increases, making the code very unreadable in my opinion.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A possible solution:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Allow a catch clause to be used directly after any function that throws. This clause includes all the catch x {} catch y {} error-handling code. Just like the else clause in a guard let, this catch clause has to return or otherwise break normal execution. Because of this, the overarching do {} catch {} blocks are no longer needed, and normal execution continues without continually increasing code indentation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is how the above code snippet might look if this solution was implemented:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let coordinator = NSPersistentStoreCoordinator(managedObjectModel: managedObjectModel)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let documentsDirectoryURL = try NSFileManager.defaultManager().URLForDirectory(.DocumentDirectory, inDomain: .UserDomainMask, appropriateForURL: nil, create: false) catch {<br>&gt;&gt;&gt;     catch MyError.Case1 {<br>&gt;&gt;&gt;         <br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     catch MyError.Case2 {<br>&gt;&gt;&gt;         <br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     catch MyError.Case3 {<br>&gt;&gt;&gt;         <br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     catch {<br>&gt;&gt;&gt;         <br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; let persistentStoreFileName = &quot;CoreDataStore.sqlite&quot;<br>&gt;&gt;&gt; let persistentStoreURL = documentsDirectoryURL.URLByAppendingPathComponent(persistentStoreFileName)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; try coordinator.addPersistentStoreWithType(NSSQLiteStoreType, configuration: nil, URL: persistentStoreURL, options: nil) catch {<br>&gt;&gt;&gt;     catch AnotherError.Case1 {<br>&gt;&gt;&gt;         <br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     catch AnotherError.Case2 {<br>&gt;&gt;&gt;         <br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     catch AnotherError.Case3 {<br>&gt;&gt;&gt;         <br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     catch {<br>&gt;&gt;&gt;         <br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The syntax of the new catch block could certainly be improved on (it might also benefit from typed throwing as discussed in another thread). However, even imperfect, this code is much more readable than what’s currently required, as one can instantly tell which try statement goes with which catch statements. In addition, the the pyramid of doom is gone, and the resulting code is reminiscent of a function with many guard lets.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you have any feedback or know of potential issues that I’m not aware of, I look forward to hearing from you. Thanks so much!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Liam<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/dc8c4345/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f7877c384b6a5494c1b0283eb805831c?s=50"></div><header><strong>do try catch?</strong> from <string>Liam Butler-Lawrence</string> &lt;liamdunn at me.com&gt;<p>December  7, 2015 at 11:00:00pm</p></header><div class="content"><p>Hi Kame,<br></p><p>Thanks for the work you put into this! I’ll give my thoughts on each proposed syntax:<br></p><p>&gt; // First syntax:<br>&gt;     guard let<br>&gt;         bar = bar,  // Has to be non-nil<br>&gt;         try foo(&quot;Hello&quot;),   // Has to not throw an error<br>&gt;         x = try qux()<br>&gt;         where bar &gt; 10<br>&gt;     else {    // Has to not throw an error<br>&gt;         return  // Bar or baz was nil<br>&gt;     } catch Error.Some {<br>&gt;         return  // Some Error occured<br>&gt;     } catch {<br>&gt;         return  // Another Error occured<br>&gt;     }<br>&gt;     <br>&gt;     // `else` has to be there for optional, `catch` for errors<br>&gt;     guard try foo(&quot;Hello&quot;), let x = try qux() where x &lt; 10 catch Error.Some {<br>&gt;         return<br>&gt;     } catch {<br>&gt;         return<br>&gt;     }<br>&gt;     <br>&gt;     // Results can be ignored; catch can be on new line<br>&gt;     guard let<br>&gt;         _ = try foo(&quot;Hello&quot;),<br>&gt;         _ = try qux()<br>&gt;     catch Error.Some {  // Not 100% beautiful<br>&gt;         return<br>&gt;     } catch {<br>&gt;         return<br>&gt;     }<br></p><p><br>This is comprehensive and seems (to me, anyway!) like it could definitely work. My only concern is that the similar-but-different syntaxes for the different optional/try combinations could be a bit confusing. I see the following three unique syntaxes in your proposal:<br></p><p>&gt;     guard let x = y, try z(a) else { } catch E { }... catch { }<br>&gt;     guard let x = try z(a) else { } catch E { }... catch { }<br>&gt;     guard try z(a) catch E { }... catch { }<br></p><p><br>That’s not even considering where conditions, or chaining more than a single optional and try together in a single guard expression. <br></p><p>What if one wanted to put a try clause before an optional? In that case, when is let required to prefix an unwrapped = optional clause? Currently, it is only required at the beginning of the chain. If the chain starts with a try, is let still required first, or simply at the first instance of an unwrapped = optional, or not at all? The second option might look something like this:<br></p><p>&gt;     guard try z(a), let x = y, c = d else { } catch E { }... catch { }<br></p><p><br>Note: I&#39;m ignoring the possibility of guard var… as proposal 0003 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0003-remove-var-parameters-patterns.md&gt; has already been accepted<br></p><p><br>****<br></p><p><br>&gt;     // Second syntax, no error matching, my personal preference<br>&gt;     <br>&gt;     guard try foo(&quot;Hello&quot;), let x = try qux() catch {<br>&gt;         switch error {<br>&gt;         case Error.Some: return<br>&gt;         default: return<br>&gt;         }<br>&gt;     }<br></p><p>I like this a lot. However, I think going with this version would move this proposal from a medium-level syntax change (changing or adding an option for where errors are caught) to a fundamental change to the error handling-model (how errors are caught). Accepting that, we could go one step further and eliminate the boilerplate switch { }:<br></p><p>&gt;     guard try foo(&quot;Hello&quot;), let x = try qux() catch {<br>&gt;         case Error.Some: return<br>&gt;         default: return<br>&gt;     }<br></p><p>This basically turns catch { } into a specialized switch statement. I don’t think this would cause any functionality issues, as case X: case Y: default: syntax already works in exactly the same manner as catch X { } catch Y { } catch { }. Even where conditions that can currently be applied to catch should work just fine as case X where X. The only thing to really consider would be the syntax when what was thrown is irrelevant. You proposed this:<br></p><p>&gt;     guard let bar = bar, let _ = try qux() where baz == true else {<br>&gt;         return<br>&gt;     } catch {<br>&gt;         return<br>&gt;     }<br></p><p><br>Unfortunately, this seems incongruent with my idea of turning catch into an implied switch statement. Perhaps<br></p><p>&gt;     guard let bar = bar, let _ = try qux() where baz == true else {<br>&gt;         return<br>&gt;     } catch {<br>&gt;         default: return<br>&gt;     }<br></p><p>though I can’t say I love this approach.<br></p><p>Of course, most of the considerations I mentioned from syntax #1 (regarding clarity in optional/try chaining) apply to both versions of #2 as well. That said, putting all the catch “cases&quot; in one { } block is far more concise and could possibly make those considerations less of an issue.<br></p><p><br>****<br></p><p><br>&gt;     // Third syntax, `else` for everything, implicit `error` variable when a `try` was used in the guard<br>&gt;     <br>&gt;     guard try foo(&quot;Hello&quot;) else {<br>&gt;         switch error {<br>&gt;         case Error.Some: return<br>&gt;         default: return<br>&gt;         }<br>&gt;     }<br></p><p>I think removing catch is a bad idea. Not just because almost every other language uses it for exception/error handling, but because it is a natural parallel to throw. It makes sense on an intuitive level, and I don’t think we should mess with that. Not to mention the else block could easily get very messy very fast. <br></p><p>Thanks again! I appreciate your comments on my suggestions as well :)<br></p><p>Liam<br></p><p>&gt; On Dec 7, 2015, at 2:35 PM, Kametrixom Tikara &lt;kametrixom at icloud.com &lt;mailto:kametrixom at icloud.com&gt;&gt; wrote:<br>&gt; <br>&gt; Hi Liam, this is how I imagine it working, I proposed three slightly different syntax rules:<br>&gt; <br>&gt; enum Error : ErrorType { case Some }<br>&gt; <br>&gt; func test(bar: Int?, baz: Bool?, foo: String throws -&gt; Void, qux: () throws -&gt; Double) {<br>&gt;     // Currently possible:<br>&gt;     do {<br>&gt;         try foo(&quot;Hello&quot;)<br>&gt;         let x = try qux()<br>&gt;     } catch Error.Some {<br>&gt;         print(&quot;Error!&quot;)<br>&gt;     } catch {<br>&gt;         print(&quot;Error!&quot;)<br>&gt;     }<br>&gt;     <br>&gt;     // First syntax:<br>&gt;     guard let<br>&gt;         bar = bar,  // Has to be non-nil<br>&gt;         try foo(&quot;Hello&quot;),   // Has to not throw an error<br>&gt;         x = try qux()<br>&gt;         where bar &gt; 10<br>&gt;     else {    // Has to not throw an error<br>&gt;         return  // Bar or baz was nil<br>&gt;     } catch Error.Some {<br>&gt;         return  // Some Error occured<br>&gt;     } catch {<br>&gt;         return  // Another Error occured<br>&gt;     }<br>&gt;     <br>&gt;     // `else` has to be there for optional, `catch` for errors<br>&gt;     guard try foo(&quot;Hello&quot;), let x = try qux() where x &lt; 10 catch Error.Some {<br>&gt;         return<br>&gt;     } catch {<br>&gt;         return<br>&gt;     }<br>&gt;     <br>&gt;     // Results can be ignored; catch can be on new line<br>&gt;     guard let<br>&gt;         _ = try foo(&quot;Hello&quot;),<br>&gt;         _ = try qux()<br>&gt;     catch Error.Some {  // Not 100% beautiful<br>&gt;         return<br>&gt;     } catch {<br>&gt;         return<br>&gt;     }<br>&gt;     <br>&gt;     <br>&gt;     // Second syntax, no error matching, my personal preference<br>&gt;     <br>&gt;     guard try foo(&quot;Hello&quot;), let x = try qux() catch {<br>&gt;         switch error {<br>&gt;         case Error.Some: return<br>&gt;         default: return<br>&gt;         }<br>&gt;     }<br>&gt;     <br>&gt;     guard let bar = bar, let _ = try qux() where baz == true else {<br>&gt;         return<br>&gt;     } catch {<br>&gt;         return<br>&gt;     }<br>&gt;     <br>&gt;     <br>&gt;     // Third syntax, `else` for everything, implicit `error` variable when a `try` was used in the guard<br>&gt;     <br>&gt;     guard try foo(&quot;Hello&quot;) else {<br>&gt;         switch error {<br>&gt;         case Error.Some: return<br>&gt;         default: return<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; I think this feels right at home in Swift, `guard` indicating that some condition has to be met or else exit the scope. This syntax<br>&gt; <br>&gt;&gt;&gt; let result = try test() catch SomeError.SomeCase {<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt; } catch {<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt; }<br>&gt; <br>&gt; you proposed doesn’t make it really clear that the scope has to be exited but I like it nonetheless. This also is in the same spirit as the recent discussion on making `if else`, `switch case` and such work as expression.<br>&gt; <br>&gt; – Kame<br>&gt; <br>&gt; <br>&gt;&gt; On 07 Dec 2015, at 18:40, Liam Butler-Lawrence &lt;liamdunn at me.com &lt;mailto:liamdunn at me.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hey Kametrixom,<br>&gt;&gt; <br>&gt;&gt; Thanks for the feedback! I agree that the proposed syntax needs improvement.<br>&gt;&gt; <br>&gt;&gt;&gt; guard let unwrapped = optional, result = try test() else {<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt; } catch SomeError.SomeCase {<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt; } catch {<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I like this example, but it seems rather specific. Are you just using the  guard let unwrapped = optional to show how guard let and the catch block could be used together, or suggesting that guard let should be required for this functionality? If the latter, how would we handle throwing functions that don’t return a value?<br>&gt;&gt; <br>&gt;&gt; I’m fine with removing the enclosing catch { } from my original suggestion; perhaps something like this? My only concern with this is that it’s slightly confusing to have the first catch X on the same line as the try call.<br>&gt;&gt; <br>&gt;&gt;&gt; let result = try test() catch SomeError.SomeCase {<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt; } catch {<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Also, regarding the new syntax being redundant:<br>&gt;&gt; <br>&gt;&gt;&gt; let coordinator = NSPersistentStoreCoordinator(managedObjectModel: managedObjectModel)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; do {<br>&gt;&gt;&gt;     let documentsDirectoryURL = try NSFileManager.defaultManager().URLForDirectory(.DocumentDirectory, inDomain: .UserDomainMask, appropriateForURL: nil, create: false)<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     let persistentStoreFileName = &quot;CoreDataStore.sqlite&quot;<br>&gt;&gt;&gt;     let persistentStoreURL = documentsDirectoryURL.URLByAppendingPathComponent(persistentStoreFileName)<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     try coordinator.addPersistentStoreWithType(NSSQLiteStoreType, configuration: nil, URL: persistentStoreURL, options: nil)<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt; } catch MyError.Case1 {<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt; } catch MyError.Case2 {<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt; } catch MyError.Case3 {<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt; } catch AnotherError.Case1 {<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt; } catch AnotherError.Case2 {<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt; } catch AnotherError.Case3 {<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt; } catch {<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Thanks for pointing out this possibility. However, this code makes it even harder to decipher where MyError will be thrown from. How about AnotherError– which function threw that? No way to know. In certain cases that may not be an issue, but what if the error handling code presented a UI error? I might want to know more than just what the error is, but the context in which it was generated as well. Putting all the catch blocks at the end directly impacts readability.<br>&gt;&gt; <br>&gt;&gt; As an extension of this issue, suppose that both throwing functions threw the same kind of error. If I want to use a different response based on which function call actually threw the error, I simply can’t do that using this method.<br>&gt;&gt; <br>&gt;&gt; Look forward to hearing your thoughts. Thanks again!<br>&gt;&gt; <br>&gt;&gt; Liam<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/ce87ef3f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f7877c384b6a5494c1b0283eb805831c?s=50"></div><header><strong>do try catch?</strong> from <string>Liam Butler-Lawrence</string> &lt;liamdunn at me.com&gt;<p>December 11, 2015 at 09:00:00pm</p></header><div class="content"><p>Bumping this up. If anyone on the Apple team (or anybody else!) has any feedback that would be much appreciated. Also, I’d be happy to write up an official proposal if requested- the suggested guideline was to have a thorough discussion first, which this really hasn’t had yet.<br></p><p>Thanks!<br>Liam<br></p><p>&gt; On Dec 7, 2015, at 11:30 PM, Liam Butler-Lawrence via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi Kame,<br>&gt; <br>&gt; Thanks for the work you put into this! I’ll give my thoughts on each proposed syntax:<br>&gt; <br>&gt;&gt; // First syntax:<br>&gt;&gt;     guard let<br>&gt;&gt;         bar = bar,  // Has to be non-nil<br>&gt;&gt;         try foo(&quot;Hello&quot;),   // Has to not throw an error<br>&gt;&gt;         x = try qux()<br>&gt;&gt;         where bar &gt; 10<br>&gt;&gt;     else {    // Has to not throw an error<br>&gt;&gt;         return  // Bar or baz was nil<br>&gt;&gt;     } catch Error.Some {<br>&gt;&gt;         return  // Some Error occured<br>&gt;&gt;     } catch {<br>&gt;&gt;         return  // Another Error occured<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     // `else` has to be there for optional, `catch` for errors<br>&gt;&gt;     guard try foo(&quot;Hello&quot;), let x = try qux() where x &lt; 10 catch Error.Some {<br>&gt;&gt;         return<br>&gt;&gt;     } catch {<br>&gt;&gt;         return<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     // Results can be ignored; catch can be on new line<br>&gt;&gt;     guard let<br>&gt;&gt;         _ = try foo(&quot;Hello&quot;),<br>&gt;&gt;         _ = try qux()<br>&gt;&gt;     catch Error.Some {  // Not 100% beautiful<br>&gt;&gt;         return<br>&gt;&gt;     } catch {<br>&gt;&gt;         return<br>&gt;&gt;     }<br>&gt; <br>&gt; <br>&gt; This is comprehensive and seems (to me, anyway!) like it could definitely work. My only concern is that the similar-but-different syntaxes for the different optional/try combinations could be a bit confusing. I see the following three unique syntaxes in your proposal:<br>&gt; <br>&gt;&gt;     guard let x = y, try z(a) else { } catch E { }... catch { }<br>&gt;&gt;     guard let x = try z(a) else { } catch E { }... catch { }<br>&gt;&gt;     guard try z(a) catch E { }... catch { }<br>&gt; <br>&gt; <br>&gt; That’s not even considering where conditions, or chaining more than a single optional and try together in a single guard expression. <br>&gt; <br>&gt; What if one wanted to put a try clause before an optional? In that case, when is let required to prefix an unwrapped = optional clause? Currently, it is only required at the beginning of the chain. If the chain starts with a try, is let still required first, or simply at the first instance of an unwrapped = optional, or not at all? The second option might look something like this:<br>&gt; <br>&gt;&gt;     guard try z(a), let x = y, c = d else { } catch E { }... catch { }<br>&gt; <br>&gt; <br>&gt; Note: I&#39;m ignoring the possibility of guard var… as proposal 0003 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0003-remove-var-parameters-patterns.md&gt; has already been accepted<br>&gt; <br>&gt; <br>&gt; ****<br>&gt; <br>&gt; <br>&gt;&gt;     // Second syntax, no error matching, my personal preference<br>&gt;&gt;     <br>&gt;&gt;     guard try foo(&quot;Hello&quot;), let x = try qux() catch {<br>&gt;&gt;         switch error {<br>&gt;&gt;         case Error.Some: return<br>&gt;&gt;         default: return<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt; <br>&gt; I like this a lot. However, I think going with this version would move this proposal from a medium-level syntax change (changing or adding an option for where errors are caught) to a fundamental change to the error handling-model (how errors are caught). Accepting that, we could go one step further and eliminate the boilerplate switch { }:<br>&gt; <br>&gt;&gt;     guard try foo(&quot;Hello&quot;), let x = try qux() catch {<br>&gt;&gt;         case Error.Some: return<br>&gt;&gt;         default: return<br>&gt;&gt;     }<br>&gt; <br>&gt; This basically turns catch { } into a specialized switch statement. I don’t think this would cause any functionality issues, as case X: case Y: default: syntax already works in exactly the same manner as catch X { } catch Y { } catch { }. Even where conditions that can currently be applied to catch should work just fine as case X where X. The only thing to really consider would be the syntax when what was thrown is irrelevant. You proposed this:<br>&gt; <br>&gt;&gt;     guard let bar = bar, let _ = try qux() where baz == true else {<br>&gt;&gt;         return<br>&gt;&gt;     } catch {<br>&gt;&gt;         return<br>&gt;&gt;     }<br>&gt; <br>&gt; <br>&gt; Unfortunately, this seems incongruent with my idea of turning catch into an implied switch statement. Perhaps<br>&gt; <br>&gt;&gt;     guard let bar = bar, let _ = try qux() where baz == true else {<br>&gt;&gt;         return<br>&gt;&gt;     } catch {<br>&gt;&gt;         default: return<br>&gt;&gt;     }<br>&gt; <br>&gt; though I can’t say I love this approach.<br>&gt; <br>&gt; Of course, most of the considerations I mentioned from syntax #1 (regarding clarity in optional/try chaining) apply to both versions of #2 as well. That said, putting all the catch “cases&quot; in one { } block is far more concise and could possibly make those considerations less of an issue.<br>&gt; <br>&gt; <br>&gt; ****<br>&gt; <br>&gt; <br>&gt;&gt;     // Third syntax, `else` for everything, implicit `error` variable when a `try` was used in the guard<br>&gt;&gt;     <br>&gt;&gt;     guard try foo(&quot;Hello&quot;) else {<br>&gt;&gt;         switch error {<br>&gt;&gt;         case Error.Some: return<br>&gt;&gt;         default: return<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt; <br>&gt; I think removing catch is a bad idea. Not just because almost every other language uses it for exception/error handling, but because it is a natural parallel to throw. It makes sense on an intuitive level, and I don’t think we should mess with that. Not to mention the else block could easily get very messy very fast. <br>&gt; <br>&gt; Thanks again! I appreciate your comments on my suggestions as well :)<br>&gt; <br>&gt; Liam<br>&gt; <br>&gt;&gt; On Dec 7, 2015, at 2:35 PM, Kametrixom Tikara &lt;kametrixom at icloud.com &lt;mailto:kametrixom at icloud.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi Liam, this is how I imagine it working, I proposed three slightly different syntax rules:<br>&gt;&gt; <br>&gt;&gt; enum Error : ErrorType { case Some }<br>&gt;&gt; <br>&gt;&gt; func test(bar: Int?, baz: Bool?, foo: String throws -&gt; Void, qux: () throws -&gt; Double) {<br>&gt;&gt;     // Currently possible:<br>&gt;&gt;     do {<br>&gt;&gt;         try foo(&quot;Hello&quot;)<br>&gt;&gt;         let x = try qux()<br>&gt;&gt;     } catch Error.Some {<br>&gt;&gt;         print(&quot;Error!&quot;)<br>&gt;&gt;     } catch {<br>&gt;&gt;         print(&quot;Error!&quot;)<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     // First syntax:<br>&gt;&gt;     guard let<br>&gt;&gt;         bar = bar,  // Has to be non-nil<br>&gt;&gt;         try foo(&quot;Hello&quot;),   // Has to not throw an error<br>&gt;&gt;         x = try qux()<br>&gt;&gt;         where bar &gt; 10<br>&gt;&gt;     else {    // Has to not throw an error<br>&gt;&gt;         return  // Bar or baz was nil<br>&gt;&gt;     } catch Error.Some {<br>&gt;&gt;         return  // Some Error occured<br>&gt;&gt;     } catch {<br>&gt;&gt;         return  // Another Error occured<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     // `else` has to be there for optional, `catch` for errors<br>&gt;&gt;     guard try foo(&quot;Hello&quot;), let x = try qux() where x &lt; 10 catch Error.Some {<br>&gt;&gt;         return<br>&gt;&gt;     } catch {<br>&gt;&gt;         return<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     // Results can be ignored; catch can be on new line<br>&gt;&gt;     guard let<br>&gt;&gt;         _ = try foo(&quot;Hello&quot;),<br>&gt;&gt;         _ = try qux()<br>&gt;&gt;     catch Error.Some {  // Not 100% beautiful<br>&gt;&gt;         return<br>&gt;&gt;     } catch {<br>&gt;&gt;         return<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     <br>&gt;&gt;     // Second syntax, no error matching, my personal preference<br>&gt;&gt;     <br>&gt;&gt;     guard try foo(&quot;Hello&quot;), let x = try qux() catch {<br>&gt;&gt;         switch error {<br>&gt;&gt;         case Error.Some: return<br>&gt;&gt;         default: return<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     guard let bar = bar, let _ = try qux() where baz == true else {<br>&gt;&gt;         return<br>&gt;&gt;     } catch {<br>&gt;&gt;         return<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     <br>&gt;&gt;     // Third syntax, `else` for everything, implicit `error` variable when a `try` was used in the guard<br>&gt;&gt;     <br>&gt;&gt;     guard try foo(&quot;Hello&quot;) else {<br>&gt;&gt;         switch error {<br>&gt;&gt;         case Error.Some: return<br>&gt;&gt;         default: return<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I think this feels right at home in Swift, `guard` indicating that some condition has to be met or else exit the scope. This syntax<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; let result = try test() catch SomeError.SomeCase {<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt; } catch {<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; you proposed doesn’t make it really clear that the scope has to be exited but I like it nonetheless. This also is in the same spirit as the recent discussion on making `if else`, `switch case` and such work as expression.<br>&gt;&gt; <br>&gt;&gt; – Kame<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 07 Dec 2015, at 18:40, Liam Butler-Lawrence &lt;liamdunn at me.com &lt;mailto:liamdunn at me.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hey Kametrixom,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks for the feedback! I agree that the proposed syntax needs improvement.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; guard let unwrapped = optional, result = try test() else {<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt; } catch SomeError.SomeCase {<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt; } catch {<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I like this example, but it seems rather specific. Are you just using the  guard let unwrapped = optional to show how guard let and the catch block could be used together, or suggesting that guard let should be required for this functionality? If the latter, how would we handle throwing functions that don’t return a value?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m fine with removing the enclosing catch { } from my original suggestion; perhaps something like this? My only concern with this is that it’s slightly confusing to have the first catch X on the same line as the try call.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let result = try test() catch SomeError.SomeCase {<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt; } catch {<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Also, regarding the new syntax being redundant:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let coordinator = NSPersistentStoreCoordinator(managedObjectModel: managedObjectModel)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; do {<br>&gt;&gt;&gt;&gt;     let documentsDirectoryURL = try NSFileManager.defaultManager().URLForDirectory(.DocumentDirectory, inDomain: .UserDomainMask, appropriateForURL: nil, create: false)<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;     let persistentStoreFileName = &quot;CoreDataStore.sqlite&quot;<br>&gt;&gt;&gt;&gt;     let persistentStoreURL = documentsDirectoryURL.URLByAppendingPathComponent(persistentStoreFileName)<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;     try coordinator.addPersistentStoreWithType(NSSQLiteStoreType, configuration: nil, URL: persistentStoreURL, options: nil)<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt; } catch MyError.Case1 {<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt; } catch MyError.Case2 {<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt; } catch MyError.Case3 {<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt; } catch AnotherError.Case1 {<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt; } catch AnotherError.Case2 {<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt; } catch AnotherError.Case3 {<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt; } catch {<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks for pointing out this possibility. However, this code makes it even harder to decipher where MyError will be thrown from. How about AnotherError– which function threw that? No way to know. In certain cases that may not be an issue, but what if the error handling code presented a UI error? I might want to know more than just what the error is, but the context in which it was generated as well. Putting all the catch blocks at the end directly impacts readability.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As an extension of this issue, suppose that both throwing functions threw the same kind of error. If I want to use a different response based on which function call actually threw the error, I simply can’t do that using this method.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Look forward to hearing your thoughts. Thanks again!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Liam<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/75b5cccb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>do try catch?</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December 11, 2015 at 06:00:00pm</p></header><div class="content"><p>&gt; On Dec 11, 2015, at 6:11 PM, Liam Butler-Lawrence via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Bumping this up. If anyone on the Apple team (or anybody else!) has any feedback that would be much appreciated. Also, I’d be happy to write up an official proposal if requested- the suggested guideline was to have a thorough discussion first, which this really hasn’t had yet.<br></p><p>I’m sorry, I’ve had a lot of other significant designs to look at recently, and I’ve been rate-limiting them so I don’t neglect all the other work on my plate. :)  I’ll try to take a look at this sometime next week; is that alright?<br></p><p>John.<br></p><p>&gt; <br>&gt; Thanks!<br>&gt; Liam<br>&gt; <br>&gt;&gt; On Dec 7, 2015, at 11:30 PM, Liam Butler-Lawrence via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi Kame,<br>&gt;&gt; <br>&gt;&gt; Thanks for the work you put into this! I’ll give my thoughts on each proposed syntax:<br>&gt;&gt; <br>&gt;&gt;&gt; // First syntax:<br>&gt;&gt;&gt;     guard let<br>&gt;&gt;&gt;         bar = bar,  // Has to be non-nil<br>&gt;&gt;&gt;         try foo(&quot;Hello&quot;),   // Has to not throw an error<br>&gt;&gt;&gt;         x = try qux()<br>&gt;&gt;&gt;         where bar &gt; 10<br>&gt;&gt;&gt;     else {    // Has to not throw an error<br>&gt;&gt;&gt;         return  // Bar or baz was nil<br>&gt;&gt;&gt;     } catch Error.Some {<br>&gt;&gt;&gt;         return  // Some Error occured<br>&gt;&gt;&gt;     } catch {<br>&gt;&gt;&gt;         return  // Another Error occured<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     // `else` has to be there for optional, `catch` for errors<br>&gt;&gt;&gt;     guard try foo(&quot;Hello&quot;), let x = try qux() where x &lt; 10 catch Error.Some {<br>&gt;&gt;&gt;         return<br>&gt;&gt;&gt;     } catch {<br>&gt;&gt;&gt;         return<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     // Results can be ignored; catch can be on new line<br>&gt;&gt;&gt;     guard let<br>&gt;&gt;&gt;         _ = try foo(&quot;Hello&quot;),<br>&gt;&gt;&gt;         _ = try qux()<br>&gt;&gt;&gt;     catch Error.Some {  // Not 100% beautiful<br>&gt;&gt;&gt;         return<br>&gt;&gt;&gt;     } catch {<br>&gt;&gt;&gt;         return<br>&gt;&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; This is comprehensive and seems (to me, anyway!) like it could definitely work. My only concern is that the similar-but-different syntaxes for the different optional/try combinations could be a bit confusing. I see the following three unique syntaxes in your proposal:<br>&gt;&gt; <br>&gt;&gt;&gt;     guard let x = y, try z(a) else { } catch E { }... catch { }<br>&gt;&gt;&gt;     guard let x = try z(a) else { } catch E { }... catch { }<br>&gt;&gt;&gt;     guard try z(a) catch E { }... catch { }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; That’s not even considering where conditions, or chaining more than a single optional and try together in a single guard expression. <br>&gt;&gt; <br>&gt;&gt; What if one wanted to put a try clause before an optional? In that case, when is let required to prefix an unwrapped = optional clause? Currently, it is only required at the beginning of the chain. If the chain starts with a try, is let still required first, or simply at the first instance of an unwrapped = optional, or not at all? The second option might look something like this:<br>&gt;&gt; <br>&gt;&gt;&gt;     guard try z(a), let x = y, c = d else { } catch E { }... catch { }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Note: I&#39;m ignoring the possibility of guard var… as proposal 0003 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0003-remove-var-parameters-patterns.md&gt; has already been accepted<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; ****<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;     // Second syntax, no error matching, my personal preference<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     guard try foo(&quot;Hello&quot;), let x = try qux() catch {<br>&gt;&gt;&gt;         switch error {<br>&gt;&gt;&gt;         case Error.Some: return<br>&gt;&gt;&gt;         default: return<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; I like this a lot. However, I think going with this version would move this proposal from a medium-level syntax change (changing or adding an option for where errors are caught) to a fundamental change to the error handling-model (how errors are caught). Accepting that, we could go one step further and eliminate the boilerplate switch { }:<br>&gt;&gt; <br>&gt;&gt;&gt;     guard try foo(&quot;Hello&quot;), let x = try qux() catch {<br>&gt;&gt;&gt;         case Error.Some: return<br>&gt;&gt;&gt;         default: return<br>&gt;&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; This basically turns catch { } into a specialized switch statement. I don’t think this would cause any functionality issues, as case X: case Y: default: syntax already works in exactly the same manner as catch X { } catch Y { } catch { }. Even where conditions that can currently be applied to catch should work just fine as case X where X. The only thing to really consider would be the syntax when what was thrown is irrelevant. You proposed this:<br>&gt;&gt; <br>&gt;&gt;&gt;     guard let bar = bar, let _ = try qux() where baz == true else {<br>&gt;&gt;&gt;         return<br>&gt;&gt;&gt;     } catch {<br>&gt;&gt;&gt;         return<br>&gt;&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Unfortunately, this seems incongruent with my idea of turning catch into an implied switch statement. Perhaps<br>&gt;&gt; <br>&gt;&gt;&gt;     guard let bar = bar, let _ = try qux() where baz == true else {<br>&gt;&gt;&gt;         return<br>&gt;&gt;&gt;     } catch {<br>&gt;&gt;&gt;         default: return<br>&gt;&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; though I can’t say I love this approach.<br>&gt;&gt; <br>&gt;&gt; Of course, most of the considerations I mentioned from syntax #1 (regarding clarity in optional/try chaining) apply to both versions of #2 as well. That said, putting all the catch “cases&quot; in one { } block is far more concise and could possibly make those considerations less of an issue.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; ****<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;     // Third syntax, `else` for everything, implicit `error` variable when a `try` was used in the guard<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     guard try foo(&quot;Hello&quot;) else {<br>&gt;&gt;&gt;         switch error {<br>&gt;&gt;&gt;         case Error.Some: return<br>&gt;&gt;&gt;         default: return<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; I think removing catch is a bad idea. Not just because almost every other language uses it for exception/error handling, but because it is a natural parallel to throw. It makes sense on an intuitive level, and I don’t think we should mess with that. Not to mention the else block could easily get very messy very fast. <br>&gt;&gt; <br>&gt;&gt; Thanks again! I appreciate your comments on my suggestions as well :)<br>&gt;&gt; <br>&gt;&gt; Liam<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 7, 2015, at 2:35 PM, Kametrixom Tikara &lt;kametrixom at icloud.com &lt;mailto:kametrixom at icloud.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi Liam, this is how I imagine it working, I proposed three slightly different syntax rules:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum Error : ErrorType { case Some }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func test(bar: Int?, baz: Bool?, foo: String throws -&gt; Void, qux: () throws -&gt; Double) {<br>&gt;&gt;&gt;     // Currently possible:<br>&gt;&gt;&gt;     do {<br>&gt;&gt;&gt;         try foo(&quot;Hello&quot;)<br>&gt;&gt;&gt;         let x = try qux()<br>&gt;&gt;&gt;     } catch Error.Some {<br>&gt;&gt;&gt;         print(&quot;Error!&quot;)<br>&gt;&gt;&gt;     } catch {<br>&gt;&gt;&gt;         print(&quot;Error!&quot;)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     // First syntax:<br>&gt;&gt;&gt;     guard let<br>&gt;&gt;&gt;         bar = bar,  // Has to be non-nil<br>&gt;&gt;&gt;         try foo(&quot;Hello&quot;),   // Has to not throw an error<br>&gt;&gt;&gt;         x = try qux()<br>&gt;&gt;&gt;         where bar &gt; 10<br>&gt;&gt;&gt;     else {    // Has to not throw an error<br>&gt;&gt;&gt;         return  // Bar or baz was nil<br>&gt;&gt;&gt;     } catch Error.Some {<br>&gt;&gt;&gt;         return  // Some Error occured<br>&gt;&gt;&gt;     } catch {<br>&gt;&gt;&gt;         return  // Another Error occured<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     // `else` has to be there for optional, `catch` for errors<br>&gt;&gt;&gt;     guard try foo(&quot;Hello&quot;), let x = try qux() where x &lt; 10 catch Error.Some {<br>&gt;&gt;&gt;         return<br>&gt;&gt;&gt;     } catch {<br>&gt;&gt;&gt;         return<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     // Results can be ignored; catch can be on new line<br>&gt;&gt;&gt;     guard let<br>&gt;&gt;&gt;         _ = try foo(&quot;Hello&quot;),<br>&gt;&gt;&gt;         _ = try qux()<br>&gt;&gt;&gt;     catch Error.Some {  // Not 100% beautiful<br>&gt;&gt;&gt;         return<br>&gt;&gt;&gt;     } catch {<br>&gt;&gt;&gt;         return<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     // Second syntax, no error matching, my personal preference<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     guard try foo(&quot;Hello&quot;), let x = try qux() catch {<br>&gt;&gt;&gt;         switch error {<br>&gt;&gt;&gt;         case Error.Some: return<br>&gt;&gt;&gt;         default: return<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     guard let bar = bar, let _ = try qux() where baz == true else {<br>&gt;&gt;&gt;         return<br>&gt;&gt;&gt;     } catch {<br>&gt;&gt;&gt;         return<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     // Third syntax, `else` for everything, implicit `error` variable when a `try` was used in the guard<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     guard try foo(&quot;Hello&quot;) else {<br>&gt;&gt;&gt;         switch error {<br>&gt;&gt;&gt;         case Error.Some: return<br>&gt;&gt;&gt;         default: return<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think this feels right at home in Swift, `guard` indicating that some condition has to be met or else exit the scope. This syntax<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let result = try test() catch SomeError.SomeCase {<br>&gt;&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;&gt; } catch {<br>&gt;&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; you proposed doesn’t make it really clear that the scope has to be exited but I like it nonetheless. This also is in the same spirit as the recent discussion on making `if else`, `switch case` and such work as expression.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; – Kame<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 07 Dec 2015, at 18:40, Liam Butler-Lawrence &lt;liamdunn at me.com &lt;mailto:liamdunn at me.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hey Kametrixom,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks for the feedback! I agree that the proposed syntax needs improvement.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; guard let unwrapped = optional, result = try test() else {<br>&gt;&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;&gt; } catch SomeError.SomeCase {<br>&gt;&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;&gt; } catch {<br>&gt;&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I like this example, but it seems rather specific. Are you just using the  guard let unwrapped = optional to show how guard let and the catch block could be used together, or suggesting that guard let should be required for this functionality? If the latter, how would we handle throwing functions that don’t return a value?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m fine with removing the enclosing catch { } from my original suggestion; perhaps something like this? My only concern with this is that it’s slightly confusing to have the first catch X on the same line as the try call.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let result = try test() catch SomeError.SomeCase {<br>&gt;&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;&gt; } catch {<br>&gt;&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Also, regarding the new syntax being redundant:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let coordinator = NSPersistentStoreCoordinator(managedObjectModel: managedObjectModel)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; do {<br>&gt;&gt;&gt;&gt;&gt;     let documentsDirectoryURL = try NSFileManager.defaultManager().URLForDirectory(.DocumentDirectory, inDomain: .UserDomainMask, appropriateForURL: nil, create: false)<br>&gt;&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;&gt;     let persistentStoreFileName = &quot;CoreDataStore.sqlite&quot;<br>&gt;&gt;&gt;&gt;&gt;     let persistentStoreURL = documentsDirectoryURL.URLByAppendingPathComponent(persistentStoreFileName)<br>&gt;&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;&gt;     try coordinator.addPersistentStoreWithType(NSSQLiteStoreType, configuration: nil, URL: persistentStoreURL, options: nil)<br>&gt;&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;&gt; } catch MyError.Case1 {<br>&gt;&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;&gt; } catch MyError.Case2 {<br>&gt;&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;&gt; } catch MyError.Case3 {<br>&gt;&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;&gt; } catch AnotherError.Case1 {<br>&gt;&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;&gt; } catch AnotherError.Case2 {<br>&gt;&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;&gt; } catch AnotherError.Case3 {<br>&gt;&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;&gt; } catch {<br>&gt;&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks for pointing out this possibility. However, this code makes it even harder to decipher where MyError will be thrown from. How about AnotherError– which function threw that? No way to know. In certain cases that may not be an issue, but what if the error handling code presented a UI error? I might want to know more than just what the error is, but the context in which it was generated as well. Putting all the catch blocks at the end directly impacts readability.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As an extension of this issue, suppose that both throwing functions threw the same kind of error. If I want to use a different response based on which function call actually threw the error, I simply can’t do that using this method.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Look forward to hearing your thoughts. Thanks again!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Liam<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/42cdf749/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f7877c384b6a5494c1b0283eb805831c?s=50"></div><header><strong>do try catch?</strong> from <string>Liam Butler-Lawrence</string> &lt;liamdunn at me.com&gt;<p>December 11, 2015 at 11:00:00pm</p></header><div class="content"><p>Hi John,<br></p><p>Sounds great. I appreciate the response!<br></p><p>Liam<br></p><p>Sent from my iPhone<br></p><p>&gt; On Dec 11, 2015, at 9:39 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 11, 2015, at 6:11 PM, Liam Butler-Lawrence via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Bumping this up. If anyone on the Apple team (or anybody else!) has any feedback that would be much appreciated. Also, I’d be happy to write up an official proposal if requested- the suggested guideline was to have a thorough discussion first, which this really hasn’t had yet.<br>&gt; <br>&gt; I’m sorry, I’ve had a lot of other significant designs to look at recently, and I’ve been rate-limiting them so I don’t neglect all the other work on my plate. :)  I’ll try to take a look at this sometime next week; is that alright?<br>&gt; <br>&gt; John.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Thanks!<br>&gt;&gt; Liam<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 7, 2015, at 11:30 PM, Liam Butler-Lawrence via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi Kame,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks for the work you put into this! I’ll give my thoughts on each proposed syntax:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // First syntax:<br>&gt;&gt;&gt;&gt;     guard let<br>&gt;&gt;&gt;&gt;         bar = bar,  // Has to be non-nil<br>&gt;&gt;&gt;&gt;         try foo(&quot;Hello&quot;),   // Has to not throw an error<br>&gt;&gt;&gt;&gt;         x = try qux()<br>&gt;&gt;&gt;&gt;         where bar &gt; 10<br>&gt;&gt;&gt;&gt;     else {    // Has to not throw an error<br>&gt;&gt;&gt;&gt;         return  // Bar or baz was nil<br>&gt;&gt;&gt;&gt;     } catch Error.Some {<br>&gt;&gt;&gt;&gt;         return  // Some Error occured<br>&gt;&gt;&gt;&gt;     } catch {<br>&gt;&gt;&gt;&gt;         return  // Another Error occured<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;     // `else` has to be there for optional, `catch` for errors<br>&gt;&gt;&gt;&gt;     guard try foo(&quot;Hello&quot;), let x = try qux() where x &lt; 10 catch Error.Some {<br>&gt;&gt;&gt;&gt;         return<br>&gt;&gt;&gt;&gt;     } catch {<br>&gt;&gt;&gt;&gt;         return<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;     // Results can be ignored; catch can be on new line<br>&gt;&gt;&gt;&gt;     guard let<br>&gt;&gt;&gt;&gt;         _ = try foo(&quot;Hello&quot;),<br>&gt;&gt;&gt;&gt;         _ = try qux()<br>&gt;&gt;&gt;&gt;     catch Error.Some {  // Not 100% beautiful<br>&gt;&gt;&gt;&gt;         return<br>&gt;&gt;&gt;&gt;     } catch {<br>&gt;&gt;&gt;&gt;         return<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is comprehensive and seems (to me, anyway!) like it could definitely work. My only concern is that the similar-but-different syntaxes for the different optional/try combinations could be a bit confusing. I see the following three unique syntaxes in your proposal:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     guard let x = y, try z(a) else { } catch E { }... catch { }<br>&gt;&gt;&gt;&gt;     guard let x = try z(a) else { } catch E { }... catch { }<br>&gt;&gt;&gt;&gt;     guard try z(a) catch E { }... catch { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That’s not even considering where conditions, or chaining more than a single optional and try together in a single guard expression. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What if one wanted to put a try clause before an optional? In that case, when is let required to prefix an unwrapped = optional clause? Currently, it is only required at the beginning of the chain. If the chain starts with a try, is let still required first, or simply at the first instance of an unwrapped = optional, or not at all? The second option might look something like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     guard try z(a), let x = y, c = d else { } catch E { }... catch { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Note: I&#39;m ignoring the possibility of guard var… as proposal 0003 has already been accepted<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ****<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     // Second syntax, no error matching, my personal preference<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;     guard try foo(&quot;Hello&quot;), let x = try qux() catch {<br>&gt;&gt;&gt;&gt;         switch error {<br>&gt;&gt;&gt;&gt;         case Error.Some: return<br>&gt;&gt;&gt;&gt;         default: return<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I like this a lot. However, I think going with this version would move this proposal from a medium-level syntax change (changing or adding an option for where errors are caught) to a fundamental change to the error handling-model (how errors are caught). Accepting that, we could go one step further and eliminate the boilerplate switch { }:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     guard try foo(&quot;Hello&quot;), let x = try qux() catch {<br>&gt;&gt;&gt;&gt;         case Error.Some: return<br>&gt;&gt;&gt;&gt;         default: return<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This basically turns catch { } into a specialized switch statement. I don’t think this would cause any functionality issues, as case X: case Y: default: syntax already works in exactly the same manner as catch X { } catch Y { } catch { }. Even where conditions that can currently be applied to catch should work just fine as case X where X. The only thing to really consider would be the syntax when what was thrown is irrelevant. You proposed this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     guard let bar = bar, let _ = try qux() where baz == true else {<br>&gt;&gt;&gt;&gt;         return<br>&gt;&gt;&gt;&gt;     } catch {<br>&gt;&gt;&gt;&gt;         return<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Unfortunately, this seems incongruent with my idea of turning catch into an implied switch statement. Perhaps<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     guard let bar = bar, let _ = try qux() where baz == true else {<br>&gt;&gt;&gt;&gt;         return<br>&gt;&gt;&gt;&gt;     } catch {<br>&gt;&gt;&gt;&gt;         default: return<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; though I can’t say I love this approach.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Of course, most of the considerations I mentioned from syntax #1 (regarding clarity in optional/try chaining) apply to both versions of #2 as well. That said, putting all the catch “cases&quot; in one { } block is far more concise and could possibly make those considerations less of an issue.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ****<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     // Third syntax, `else` for everything, implicit `error` variable when a `try` was used in the guard<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;     guard try foo(&quot;Hello&quot;) else {<br>&gt;&gt;&gt;&gt;         switch error {<br>&gt;&gt;&gt;&gt;         case Error.Some: return<br>&gt;&gt;&gt;&gt;         default: return<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think removing catch is a bad idea. Not just because almost every other language uses it for exception/error handling, but because it is a natural parallel to throw. It makes sense on an intuitive level, and I don’t think we should mess with that. Not to mention the else block could easily get very messy very fast. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks again! I appreciate your comments on my suggestions as well :)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Liam<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 7, 2015, at 2:35 PM, Kametrixom Tikara &lt;kametrixom at icloud.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi Liam, this is how I imagine it working, I proposed three slightly different syntax rules:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; enum Error : ErrorType { case Some }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func test(bar: Int?, baz: Bool?, foo: String throws -&gt; Void, qux: () throws -&gt; Double) {<br>&gt;&gt;&gt;&gt;     // Currently possible:<br>&gt;&gt;&gt;&gt;     do {<br>&gt;&gt;&gt;&gt;         try foo(&quot;Hello&quot;)<br>&gt;&gt;&gt;&gt;         let x = try qux()<br>&gt;&gt;&gt;&gt;     } catch Error.Some {<br>&gt;&gt;&gt;&gt;         print(&quot;Error!&quot;)<br>&gt;&gt;&gt;&gt;     } catch {<br>&gt;&gt;&gt;&gt;         print(&quot;Error!&quot;)<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;     // First syntax:<br>&gt;&gt;&gt;&gt;     guard let<br>&gt;&gt;&gt;&gt;         bar = bar,  // Has to be non-nil<br>&gt;&gt;&gt;&gt;         try foo(&quot;Hello&quot;),   // Has to not throw an error<br>&gt;&gt;&gt;&gt;         x = try qux()<br>&gt;&gt;&gt;&gt;         where bar &gt; 10<br>&gt;&gt;&gt;&gt;     else {    // Has to not throw an error<br>&gt;&gt;&gt;&gt;         return  // Bar or baz was nil<br>&gt;&gt;&gt;&gt;     } catch Error.Some {<br>&gt;&gt;&gt;&gt;         return  // Some Error occured<br>&gt;&gt;&gt;&gt;     } catch {<br>&gt;&gt;&gt;&gt;         return  // Another Error occured<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;     // `else` has to be there for optional, `catch` for errors<br>&gt;&gt;&gt;&gt;     guard try foo(&quot;Hello&quot;), let x = try qux() where x &lt; 10 catch Error.Some {<br>&gt;&gt;&gt;&gt;         return<br>&gt;&gt;&gt;&gt;     } catch {<br>&gt;&gt;&gt;&gt;         return<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;     // Results can be ignored; catch can be on new line<br>&gt;&gt;&gt;&gt;     guard let<br>&gt;&gt;&gt;&gt;         _ = try foo(&quot;Hello&quot;),<br>&gt;&gt;&gt;&gt;         _ = try qux()<br>&gt;&gt;&gt;&gt;     catch Error.Some {  // Not 100% beautiful<br>&gt;&gt;&gt;&gt;         return<br>&gt;&gt;&gt;&gt;     } catch {<br>&gt;&gt;&gt;&gt;         return<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;     // Second syntax, no error matching, my personal preference<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;     guard try foo(&quot;Hello&quot;), let x = try qux() catch {<br>&gt;&gt;&gt;&gt;         switch error {<br>&gt;&gt;&gt;&gt;         case Error.Some: return<br>&gt;&gt;&gt;&gt;         default: return<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;     guard let bar = bar, let _ = try qux() where baz == true else {<br>&gt;&gt;&gt;&gt;         return<br>&gt;&gt;&gt;&gt;     } catch {<br>&gt;&gt;&gt;&gt;         return<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;     // Third syntax, `else` for everything, implicit `error` variable when a `try` was used in the guard<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;     guard try foo(&quot;Hello&quot;) else {<br>&gt;&gt;&gt;&gt;         switch error {<br>&gt;&gt;&gt;&gt;         case Error.Some: return<br>&gt;&gt;&gt;&gt;         default: return<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think this feels right at home in Swift, `guard` indicating that some condition has to be met or else exit the scope. This syntax<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let result = try test() catch SomeError.SomeCase {<br>&gt;&gt;&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;&gt;&gt; } catch {<br>&gt;&gt;&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; you proposed doesn’t make it really clear that the scope has to be exited but I like it nonetheless. This also is in the same spirit as the recent discussion on making `if else`, `switch case` and such work as expression.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; – Kame<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 07 Dec 2015, at 18:40, Liam Butler-Lawrence &lt;liamdunn at me.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hey Kametrixom,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thanks for the feedback! I agree that the proposed syntax needs improvement.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; guard let unwrapped = optional, result = try test() else {<br>&gt;&gt;&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;&gt;&gt; } catch SomeError.SomeCase {<br>&gt;&gt;&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;&gt;&gt; } catch {<br>&gt;&gt;&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I like this example, but it seems rather specific. Are you just using the  guard let unwrapped = optional to show how guard let and the catch block could be used together, or suggesting that guard let should be required for this functionality? If the latter, how would we handle throwing functions that don’t return a value?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’m fine with removing the enclosing catch { } from my original suggestion; perhaps something like this? My only concern with this is that it’s slightly confusing to have the first catch X on the same line as the try call.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let result = try test() catch SomeError.SomeCase {<br>&gt;&gt;&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;&gt;&gt; } catch {<br>&gt;&gt;&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Also, regarding the new syntax being redundant:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let coordinator = NSPersistentStoreCoordinator(managedObjectModel: managedObjectModel)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; do {<br>&gt;&gt;&gt;&gt;&gt;&gt;     let documentsDirectoryURL = try NSFileManager.defaultManager().URLForDirectory(.DocumentDirectory, inDomain: .UserDomainMask, appropriateForURL: nil, create: false)<br>&gt;&gt;&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;&gt;&gt;     let persistentStoreFileName = &quot;CoreDataStore.sqlite&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;     let persistentStoreURL = documentsDirectoryURL.URLByAppendingPathComponent(persistentStoreFileName)<br>&gt;&gt;&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;&gt;&gt;     try coordinator.addPersistentStoreWithType(NSSQLiteStoreType, configuration: nil, URL: persistentStoreURL, options: nil)<br>&gt;&gt;&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;&gt;&gt; } catch MyError.Case1 {<br>&gt;&gt;&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;&gt;&gt; } catch MyError.Case2 {<br>&gt;&gt;&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;&gt;&gt; } catch MyError.Case3 {<br>&gt;&gt;&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;&gt;&gt; } catch AnotherError.Case1 {<br>&gt;&gt;&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;&gt;&gt; } catch AnotherError.Case2 {<br>&gt;&gt;&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;&gt;&gt; } catch AnotherError.Case3 {<br>&gt;&gt;&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;&gt;&gt; } catch {<br>&gt;&gt;&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thanks for pointing out this possibility. However, this code makes it even harder to decipher where MyError will be thrown from. How about AnotherError– which function threw that? No way to know. In certain cases that may not be an issue, but what if the error handling code presented a UI error? I might want to know more than just what the error is, but the context in which it was generated as well. Putting all the catch blocks at the end directly impacts readability.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; As an extension of this issue, suppose that both throwing functions threw the same kind of error. If I want to use a different response based on which function call actually threw the error, I simply can’t do that using this method.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Look forward to hearing your thoughts. Thanks again!<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Liam<br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/d5f9d945/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>do try catch?</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December 18, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 7, 2015, at 8:30 PM, Liam Butler-Lawrence via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Hi Kame,<br>&gt; <br>&gt; Thanks for the work you put into this! I’ll give my thoughts on each proposed syntax:<br>&gt; <br>&gt;&gt; // First syntax:<br>&gt;&gt;     guard let<br>&gt;&gt;         bar = bar,  // Has to be non-nil<br>&gt;&gt;         try foo(&quot;Hello&quot;),   // Has to not throw an error<br>&gt;&gt;         x = try qux()<br>&gt;&gt;         where bar &gt; 10<br>&gt;&gt;     else {    // Has to not throw an error<br>&gt;&gt;         return  // Bar or baz was nil<br>&gt;&gt;     } catch Error.Some {<br>&gt;&gt;         return  // Some Error occured<br>&gt;&gt;     } catch {<br>&gt;&gt;         return  // Another Error occured<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     // `else` has to be there for optional, `catch` for errors<br>&gt;&gt;     guard try foo(&quot;Hello&quot;), let x = try qux() where x &lt; 10 catch Error.Some {<br>&gt;&gt;         return<br>&gt;&gt;     } catch {<br>&gt;&gt;         return<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     // Results can be ignored; catch can be on new line<br>&gt;&gt;     guard let<br>&gt;&gt;         _ = try foo(&quot;Hello&quot;),<br>&gt;&gt;         _ = try qux()<br>&gt;&gt;     catch Error.Some {  // Not 100% beautiful<br>&gt;&gt;         return<br>&gt;&gt;     } catch {<br>&gt;&gt;         return<br>&gt;&gt;     }<br>&gt; <br>&gt; <br>&gt; This is comprehensive and seems (to me, anyway!) like it could definitely work. My only concern is that the similar-but-different syntaxes for the different optional/try combinations could be a bit confusing. I see the following three unique syntaxes in your proposal:<br>&gt; <br>&gt;&gt;     guard let x = y, try z(a) else { } catch E { }... catch { }<br>&gt;&gt;     guard let x = try z(a) else { } catch E { }... catch { }<br>&gt;&gt;     guard try z(a) catch E { }... catch { }<br>&gt; <br>&gt; <br>&gt; That’s not even considering where conditions, or chaining more than a single optional and try together in a single guard expression. <br></p><p>This proposal packs an awful lot into a single “guard” statement, but that might be okay; it’s just something that I personally am not totally comfortable with.<br></p><p>The larger problem that I see is that this changes the semantic behavior of “guard” quite a bit.  Normally, in something like:<br></p><p>  guard let x = foo(),<br>        bar()<br>    else { … }<br></p><p>these clauses are both expected to be conditional: that is, foo() is expected to return an optional type, bar() is expected to return a Bool, etc.  The guard protects against the exceptional conditions.  But this isn’t really what you want, because the exceptional condition you’re looking to guard against is whether the expression threw.  Thus, in the corresponding example:<br></p><p>  guard let x = try foo(),<br>        try bar()<br>    catch { … }<br>  <br>it should at the very least be acceptable for foo() to return a non-optional type, and if it doesn’t, it’s debatable whether you really want to unwrap it; and similarly, it might be reasonable for bar() to return Void, e.g.:<br></p><p>  guard try registerUser()<br>    catch { … }<br></p><p>Part of this is just the original sin that “if let” and “guard let” aren&#39;t very composable.  For example, you run into a very similar problem with normal “guard” just by trying to bind a non-optional value between two other conditions, e.g.:<br>  guard let resolver = factory.currentResolver,<br>        let numResolved = resolver.resolvedEntityCount,<br>        numResolved &lt; maxResolutionCount<br>    else { … }<br></p><p>However, this new pattern for guard really exacerbates the problem, both because it’s so common to have functions with non-optional results that throw errors, and because even when the function has an optional result, it’s ambiguous whether you really want to simultaneously unwrap it.  In other words, there’s too much magic in this syntax, and it seems to be colliding.<br></p><p>One possible solution is to say that “guard let&quot; only unwraps results if there’s an else clause.  (What happens with “guard try foo()” in this case?)  But that means that adding and removing an else clause has very subtle and hard-to-explain semantic effects on the semantics of “guard”.  I’m tempted to say that we just shouldn’t allow the combination of an else clause and catch clauses, but that’s just begging for people to ask for the combination, at which point we’ll have codified two incompatible models for the statement.<br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/990d689d/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>do try catch?</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>December  7, 2015 at 11:00:00am</p></header><div class="content"><p>Hi Don,<br></p><p>This is just my opinion, but I prefer the explicit &#39;try&#39; on each statement that can throw, because then it is easier to see where all the early returns are from a function, in case any resources have to be cleaned up with a &#39;defer&#39;.<br></p><p>Slava<br></p><p>&gt; On Dec 7, 2015, at 6:30 AM, Don Arnel via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Is there a reason this format was adopted for error handling:<br>&gt; <br>&gt; do {<br>&gt;     try makeASandwich()<br>&gt;     eatASandwich()<br>&gt; } catch Error.OutOfCleanDishes {<br>&gt;     washDishes()<br>&gt; } catch Error.MissingIngredients(let ingredients) {<br>&gt;     buyGroceries(ingredients)<br>&gt; }<br>&gt; <br>&gt; rather than this format:<br>&gt; <br>&gt; try {<br>&gt;     makeASandwich()<br>&gt;     eatASandwich()<br>&gt; } catch Error.OutOfCleanDishes {<br>&gt;     washDishes()<br>&gt; } catch Error.MissingIngredients(let ingredients) {<br>&gt;     buyGroceries(ingredients)<br>&gt; }<br>&gt; <br>&gt; The second format is much more intuitive, and reads easier IMO.<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/1fee6278/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>do try catch?</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December  7, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 7, 2015, at 6:30 AM, Don Arnel via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Is there a reason this format was adopted for error handling:<br></p><p>Yes:<br>https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst<br></p><p>-Chris<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
