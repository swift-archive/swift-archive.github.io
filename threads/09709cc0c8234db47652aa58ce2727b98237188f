<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d972db2b6ee8b77746ce7122663eb4f8?s=50"></div><header><strong>[Proposal] Generic and `throw`ing subscripts</strong> from <string>Robert Widmann</string> &lt;rwidmann at apple.com&gt;<p>June 20, 2016 at 11:00:00am</p></header><div class="content"><p>Good morning all.  Attached is the proposal Harlan Haskins and I will be submitting shortly about adding generic and `throw`ing subscript declarations to the language.  <br></p><p>Cheers,<br></p><p>~Robert Widmann<br></p><p>Generic and Throwing Subscripts<br></p><p>Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>Author(s): Harlan Haskins &lt;https://github.com/harlanhaskins&gt; and Robert Widmann &lt;https://github.com/codafi&gt;<br>Status: Awaiting review &lt;https://github.com/typelift/SwiftCheck/pull/168#rationale&gt;<br>Review manager: TBD<br>Introduction<br></p><p>Currently, subscripts cannot be declared [re]throws and cannot declare new generic parameters.<br>There isn&#39;t a clear reason why they aren&#39;t as capable as full-fledged functions, so we propose<br>adding generic constraints and throwing semantics to subscripts.<br></p><p>Motivation<br></p><p>On the throwing side, currently there are two ways to express a failing subscript:<br></p><p>Return an Optional, failing with nil.<br>Call fatalError(_:) on failure.<br>Both of these throw out useful information about the cause of the underlying error that using Swift&#39;s error handling mechanism can otherwise provide.<br></p><p>As for generics, to take an example, it has become a common pattern among JSON decoding DSL libraries to express a throwing generic extension on Dictionary like so<br></p><p>extension Dictionary {<br>    public func parse&lt;T&gt;(key: Key) throws -&gt; T {<br>        guard let value = self[key] else {<br>            throw JSONError.MissingKey(&quot;\(key)&quot;)<br>        }<br>        guard let ofType = value as? T else {<br>            throw JSONError.InvalidKey(key: &quot;\(key)&quot;, expectedType: T.self, foundType: value.dynamicType)<br>        }<br>        return ofType<br>    }<br>}<br></p><p>public enum JSONError: ErrorType, CustomStringConvertible {<br>    case InvalidKey(key: String, expectedType: Any.Type, foundType: Any.Type)<br>    case MissingKey(String)<br>    public var description: String {<br>        switch self {<br>        case .InvalidKey(let key, let expected, let found):<br>            return &quot;Invalid key \&quot;\(key)\&quot;. Expected value of type \&quot;\(expected)\&quot;, found \&quot;\(found)\&quot;.&quot;<br>        case .MissingKey(let key):<br>            return &quot;Key \(key) not found.&quot;<br>        }<br>    }<br>}<br>Given this, one can decode JSON with the full support of native type inference and exception handling. But when working with the DSL, one would expect to be able to express this as a subscript on Dictionary, allowing the following:<br></p><p>//...<br></p><p>extension Dictionary {<br>    public subscript&lt;T&gt;(key: Key) throws -&gt; T {<br>        guard let value = self[key] else {<br>            throw JSONError.MissingKey(&quot;\(key)&quot;)<br>        }<br>        guard let ofType = value as? T else {<br>            throw JSONError.InvalidKey(key: &quot;\(key)&quot;, expectedType: T.self, foundType: value.dynamicType)<br>        }<br>        return ofType<br>    }<br>}<br>We believe this is an even more natural way to write these kinds of libraries in Swift and that bringing subscript member declarations up to par with functions is a useful addition to the language as a whole.<br></p><p>Proposed solution<br></p><p>Add the ability to introduce new generic parameters and mark throws and rethrows on subscript members.<br></p><p>Detailed design<br></p><p>This change will modify and add the following productions in the Swift grammar<br></p><p>GRAMMAR OF A SUBSCRIPT DECLARATION<br></p><p>subscript-declaration → subscript-head subscript-result code-block<br>subscript-declaration → subscript-head subscript-result getter-setter-block<br>subscript-declaration → subscript-head subscript-result getter-setter-keyword-block<br>-subscript-head → attributes(opt) declaration-modifiers(opt) subscript parameter-clause<br>+subscript-head → attributes(opt) declaration-modifiers(opt) generic-parameter-clause(opt) subscript parameter-clause<br>+subscript-result → -&gt; attributes(opt) throws(opt) type<br>+subscript-result → -&gt; attributes(opt) rethrows(opt) type<br>Rationale<br></p><p>On [Date], the core team decided to (TBD) this proposal.<br>When the core team makes a decision regarding this proposal,<br>their rationale for the decision will be written here.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160620/0970188f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Generic and `throw`ing subscripts</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 20, 2016 at 02:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On Jun 20, 2016, at 1:10 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Good morning all.  Attached is the proposal Harlan Haskins and I will be submitting shortly about adding generic and `throw`ing subscript declarations to the language. <br></p><p>+1.  Thank you for bringing forward this proposal.  I ran into these limitations in exactly the context you mention in the proposal.<br></p><p>Another context where this will be useful is emulating higher-rank &quot;callable&quot; types (using subscript for function invocation).<br></p><p>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt; Generic and Throwing Subscripts<br>&gt; Proposal: SE-NNNN<br>&gt; Author(s): Harlan Haskins and Robert Widmann<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; Currently, subscripts cannot be declared [re]throws and cannot declare new generic parameters.<br>&gt; There isn&#39;t a clear reason why they aren&#39;t as capable as full-fledged functions, so we propose<br>&gt; adding generic constraints and throwing semantics to subscripts.<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; On the throwing side, currently there are two ways to express a failing subscript:<br>&gt; <br>&gt; Return an Optional, failing with nil.<br>&gt; Call fatalError(_:) on failure.<br>&gt; Both of these throw out useful information about the cause of the underlying error that using Swift&#39;s error handling mechanism can otherwise provide.<br>&gt; <br>&gt; As for generics, to take an example, it has become a common pattern among JSON decoding DSL libraries to express a throwing generic extension on Dictionary like so<br>&gt; <br>&gt; extension Dictionary {<br>&gt;     public func parse&lt;T&gt;(key: Key) throws -&gt; T {<br>&gt;         guard let value = self[key] else {<br>&gt;             throw JSONError.MissingKey(&quot;\(key)&quot;)<br>&gt;         }<br>&gt;         guard let ofType = value as? T else {<br>&gt;             throw JSONError.InvalidKey(key: &quot;\(key)&quot;, expectedType: T.self, foundType: value.dynamicType)<br>&gt;         }<br>&gt;         return ofType<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; public enum JSONError: ErrorType, CustomStringConvertible {<br>&gt;     case InvalidKey(key: String, expectedType: Any.Type, foundType: Any.Type)<br>&gt;     case MissingKey(String)<br>&gt;     public var description: String {<br>&gt;         switch self {<br>&gt;         case .InvalidKey(let key, let expected, let found):<br>&gt;             return &quot;Invalid key \&quot;\(key)\&quot;. Expected value of type \&quot;\(expected)\&quot;, found \&quot;\(found)\&quot;.&quot;<br>&gt;         case .MissingKey(let key):<br>&gt;             return &quot;Key \(key) not found.&quot;<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; Given this, one can decode JSON with the full support of native type inference and exception handling. But when working with the DSL, one would expect to be able to express this as a subscript on Dictionary, allowing the following:<br>&gt; <br>&gt; //...<br>&gt; <br>&gt; extension Dictionary {<br>&gt;     public subscript&lt;T&gt;(key: Key) throws -&gt; T {<br>&gt;         guard let value = self[key] else {<br>&gt;             throw JSONError.MissingKey(&quot;\(key)&quot;)<br>&gt;         }<br>&gt;         guard let ofType = value as? T else {<br>&gt;             throw JSONError.InvalidKey(key: &quot;\(key)&quot;, expectedType: T.self, foundType: value.dynamicType)<br>&gt;         }<br>&gt;         return ofType<br>&gt;     }<br>&gt; }<br>&gt; We believe this is an even more natural way to write these kinds of libraries in Swift and that bringing subscript member declarations up to par with functions is a useful addition to the language as a whole.<br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; Add the ability to introduce new generic parameters and mark throws and rethrows on subscript members.<br>&gt; <br>&gt; Detailed design<br>&gt; <br>&gt; This change will modify and add the following productions in the Swift grammar<br>&gt; <br>&gt; GRAMMAR OF A SUBSCRIPT DECLARATION<br>&gt; <br>&gt; subscript-declaration → subscript-head subscript-result code-block<br>&gt; subscript-declaration → subscript-head subscript-result getter-setter-block<br>&gt; subscript-declaration → subscript-head subscript-result getter-setter-keyword-block<br>&gt; -subscript-head → attributes(opt) declaration-modifiers(opt) subscript parameter-clause<br>&gt; +subscript-head → attributes(opt) declaration-modifiers(opt) generic-parameter-clause(opt) subscript parameter-clause<br>&gt; +subscript-result → -&gt; attributes(opt) throws(opt) type<br>&gt; +subscript-result → -&gt; attributes(opt) rethrows(opt) type<br>&gt; Rationale<br>&gt; On [Date], the core team decided to (TBD) this proposal.<br>&gt; When the core team makes a decision regarding this proposal,<br>&gt; their rationale for the decision will be written here.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160620/acced6f0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/15ed660cd9d971062f9dd5084932a698?s=50"></div><header><strong>[Proposal] Generic and `throw`ing subscripts</strong> from <string>David Rönnqvist</string> &lt;david.ronnqvist at gmail.com&gt;<p>June 20, 2016 at 10:00:00pm</p></header><div class="content"><p>Would this proposal in any way be related to `throw`ing properties (more specifically throwing setters)? Or would that be a completely different discussion/proposal?<br></p><p>- David<br></p><p>&gt; On 20 Jun 2016, at 21:27, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt;&gt; On Jun 20, 2016, at 1:10 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Good morning all.  Attached is the proposal Harlan Haskins and I will be submitting shortly about adding generic and `throw`ing subscript declarations to the language. <br>&gt; <br>&gt; +1.  Thank you for bringing forward this proposal.  I ran into these limitations in exactly the context you mention in the proposal.<br>&gt; <br>&gt; Another context where this will be useful is emulating higher-rank &quot;callable&quot; types (using subscript for function invocation).<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Cheers,<br>&gt;&gt; <br>&gt;&gt; ~Robert Widmann<br>&gt;&gt; <br>&gt;&gt; Generic and Throwing Subscripts<br>&gt;&gt; Proposal: SE-NNNN<br>&gt;&gt; Author(s): Harlan Haskins and Robert Widmann<br>&gt;&gt; Status: Awaiting review<br>&gt;&gt; Review manager: TBD<br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; Currently, subscripts cannot be declared [re]throws and cannot declare new generic parameters.<br>&gt;&gt; There isn&#39;t a clear reason why they aren&#39;t as capable as full-fledged functions, so we propose<br>&gt;&gt; adding generic constraints and throwing semantics to subscripts.<br>&gt;&gt; <br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; On the throwing side, currently there are two ways to express a failing subscript:<br>&gt;&gt; <br>&gt;&gt; Return an Optional, failing with nil.<br>&gt;&gt; Call fatalError(_:) on failure.<br>&gt;&gt; Both of these throw out useful information about the cause of the underlying error that using Swift&#39;s error handling mechanism can otherwise provide.<br>&gt;&gt; <br>&gt;&gt; As for generics, to take an example, it has become a common pattern among JSON decoding DSL libraries to express a throwing generic extension on Dictionary like so<br>&gt;&gt; <br>&gt;&gt; extension Dictionary {<br>&gt;&gt;     public func parse&lt;T&gt;(key: Key) throws -&gt; T {<br>&gt;&gt;         guard let value = self[key] else {<br>&gt;&gt;             throw JSONError.MissingKey(&quot;\(key)&quot;)<br>&gt;&gt;         }<br>&gt;&gt;         guard let ofType = value as? T else {<br>&gt;&gt;             throw JSONError.InvalidKey(key: &quot;\(key)&quot;, expectedType: T.self, foundType: value.dynamicType)<br>&gt;&gt;         }<br>&gt;&gt;         return ofType<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; public enum JSONError: ErrorType, CustomStringConvertible {<br>&gt;&gt;     case InvalidKey(key: String, expectedType: Any.Type, foundType: Any.Type)<br>&gt;&gt;     case MissingKey(String)<br>&gt;&gt;     public var description: String {<br>&gt;&gt;         switch self {<br>&gt;&gt;         case .InvalidKey(let key, let expected, let found):<br>&gt;&gt;             return &quot;Invalid key \&quot;\(key)\&quot;. Expected value of type \&quot;\(expected)\&quot;, found \&quot;\(found)\&quot;.&quot;<br>&gt;&gt;         case .MissingKey(let key):<br>&gt;&gt;             return &quot;Key \(key) not found.&quot;<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; Given this, one can decode JSON with the full support of native type inference and exception handling. But when working with the DSL, one would expect to be able to express this as a subscript on Dictionary, allowing the following:<br>&gt;&gt; <br>&gt;&gt; //...<br>&gt;&gt; <br>&gt;&gt; extension Dictionary {<br>&gt;&gt;     public subscript&lt;T&gt;(key: Key) throws -&gt; T {<br>&gt;&gt;         guard let value = self[key] else {<br>&gt;&gt;             throw JSONError.MissingKey(&quot;\(key)&quot;)<br>&gt;&gt;         }<br>&gt;&gt;         guard let ofType = value as? T else {<br>&gt;&gt;             throw JSONError.InvalidKey(key: &quot;\(key)&quot;, expectedType: T.self, foundType: value.dynamicType)<br>&gt;&gt;         }<br>&gt;&gt;         return ofType<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; We believe this is an even more natural way to write these kinds of libraries in Swift and that bringing subscript member declarations up to par with functions is a useful addition to the language as a whole.<br>&gt;&gt; <br>&gt;&gt; Proposed solution<br>&gt;&gt; <br>&gt;&gt; Add the ability to introduce new generic parameters and mark throws and rethrows on subscript members.<br>&gt;&gt; <br>&gt;&gt; Detailed design<br>&gt;&gt; <br>&gt;&gt; This change will modify and add the following productions in the Swift grammar<br>&gt;&gt; <br>&gt;&gt; GRAMMAR OF A SUBSCRIPT DECLARATION<br>&gt;&gt; <br>&gt;&gt; subscript-declaration → subscript-head subscript-result code-block<br>&gt;&gt; subscript-declaration → subscript-head subscript-result getter-setter-block<br>&gt;&gt; subscript-declaration → subscript-head subscript-result getter-setter-keyword-block<br>&gt;&gt; -subscript-head → attributes(opt) declaration-modifiers(opt) subscript parameter-clause<br>&gt;&gt; +subscript-head → attributes(opt) declaration-modifiers(opt) generic-parameter-clause(opt) subscript parameter-clause<br>&gt;&gt; +subscript-result → -&gt; attributes(opt) throws(opt) type<br>&gt;&gt; +subscript-result → -&gt; attributes(opt) rethrows(opt) type<br>&gt;&gt; Rationale<br>&gt;&gt; On [Date], the core team decided to (TBD) this proposal.<br>&gt;&gt; When the core team makes a decision regarding this proposal,<br>&gt;&gt; their rationale for the decision will be written here.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160620/b96f36df/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d972db2b6ee8b77746ce7122663eb4f8?s=50"></div><header><strong>[Proposal] Generic and `throw`ing subscripts</strong> from <string>Robert Widmann</string> &lt;rwidmann at apple.com&gt;<p>June 20, 2016 at 05:00:00pm</p></header><div class="content"><p>They are quite related considering a subscript can have a getter-setter pair.  Brent already has a proposal to cover throwing properties (and subscripts), so we’re overlapping in that regard. <br></p><p>&gt; On Jun 20, 2016, at 1:33 PM, David Rönnqvist &lt;david.ronnqvist at gmail.com&gt; wrote:<br>&gt; <br>&gt; Would this proposal in any way be related to `throw`ing properties (more specifically throwing setters)? Or would that be a completely different discussion/proposal?<br>&gt; <br>&gt; - David<br>&gt; <br>&gt; On 20 Jun 2016, at 21:27, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt; On Jun 20, 2016, at 1:10 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Good morning all.  Attached is the proposal Harlan Haskins and I will be submitting shortly about adding generic and `throw`ing subscript declarations to the language. <br>&gt;&gt; <br>&gt;&gt; +1.  Thank you for bringing forward this proposal.  I ran into these limitations in exactly the context you mention in the proposal.<br>&gt;&gt; <br>&gt;&gt; Another context where this will be useful is emulating higher-rank &quot;callable&quot; types (using subscript for function invocation).<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Generic and Throwing Subscripts<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>&gt;&gt;&gt; Author(s): Harlan Haskins &lt;https://github.com/harlanhaskins&gt; and Robert Widmann &lt;https://github.com/codafi&gt;<br>&gt;&gt;&gt; Status: Awaiting review &lt;https://github.com/typelift/SwiftCheck/pull/168#rationale&gt;<br>&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Currently, subscripts cannot be declared [re]throws and cannot declare new generic parameters.<br>&gt;&gt;&gt; There isn&#39;t a clear reason why they aren&#39;t as capable as full-fledged functions, so we propose<br>&gt;&gt;&gt; adding generic constraints and throwing semantics to subscripts.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On the throwing side, currently there are two ways to express a failing subscript:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Return an Optional, failing with nil.<br>&gt;&gt;&gt; Call fatalError(_:) on failure.<br>&gt;&gt;&gt; Both of these throw out useful information about the cause of the underlying error that using Swift&#39;s error handling mechanism can otherwise provide.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As for generics, to take an example, it has become a common pattern among JSON decoding DSL libraries to express a throwing generic extension on Dictionary like so<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Dictionary {<br>&gt;&gt;&gt;     public func parse&lt;T&gt;(key: Key) throws -&gt; T {<br>&gt;&gt;&gt;         guard let value = self[key] else {<br>&gt;&gt;&gt;             throw JSONError.MissingKey(&quot;\(key)&quot;)<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;         guard let ofType = value as? T else {<br>&gt;&gt;&gt;             throw JSONError.InvalidKey(key: &quot;\(key)&quot;, expectedType: T.self, foundType: value.dynamicType)<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;         return ofType<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public enum JSONError: ErrorType, CustomStringConvertible {<br>&gt;&gt;&gt;     case InvalidKey(key: String, expectedType: Any.Type, foundType: Any.Type)<br>&gt;&gt;&gt;     case MissingKey(String)<br>&gt;&gt;&gt;     public var description: String {<br>&gt;&gt;&gt;         switch self {<br>&gt;&gt;&gt;         case .InvalidKey(let key, let expected, let found):<br>&gt;&gt;&gt;             return &quot;Invalid key \&quot;\(key)\&quot;. Expected value of type \&quot;\(expected)\&quot;, found \&quot;\(found)\&quot;.&quot;<br>&gt;&gt;&gt;         case .MissingKey(let key):<br>&gt;&gt;&gt;             return &quot;Key \(key) not found.&quot;<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; Given this, one can decode JSON with the full support of native type inference and exception handling. But when working with the DSL, one would expect to be able to express this as a subscript on Dictionary, allowing the following:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; //...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Dictionary {<br>&gt;&gt;&gt;     public subscript&lt;T&gt;(key: Key) throws -&gt; T {<br>&gt;&gt;&gt;         guard let value = self[key] else {<br>&gt;&gt;&gt;             throw JSONError.MissingKey(&quot;\(key)&quot;)<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;         guard let ofType = value as? T else {<br>&gt;&gt;&gt;             throw JSONError.InvalidKey(key: &quot;\(key)&quot;, expectedType: T.self, foundType: value.dynamicType)<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;         return ofType<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; We believe this is an even more natural way to write these kinds of libraries in Swift and that bringing subscript member declarations up to par with functions is a useful addition to the language as a whole.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Add the ability to introduce new generic parameters and mark throws and rethrows on subscript members.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Detailed design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This change will modify and add the following productions in the Swift grammar<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; GRAMMAR OF A SUBSCRIPT DECLARATION<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; subscript-declaration → subscript-head subscript-result code-block<br>&gt;&gt;&gt; subscript-declaration → subscript-head subscript-result getter-setter-block<br>&gt;&gt;&gt; subscript-declaration → subscript-head subscript-result getter-setter-keyword-block<br>&gt;&gt;&gt; -subscript-head → attributes(opt) declaration-modifiers(opt) subscript parameter-clause<br>&gt;&gt;&gt; +subscript-head → attributes(opt) declaration-modifiers(opt) generic-parameter-clause(opt) subscript parameter-clause<br>&gt;&gt;&gt; +subscript-result → -&gt; attributes(opt) throws(opt) type<br>&gt;&gt;&gt; +subscript-result → -&gt; attributes(opt) rethrows(opt) type<br>&gt;&gt;&gt; Rationale<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On [Date], the core team decided to (TBD) this proposal.<br>&gt;&gt;&gt; When the core team makes a decision regarding this proposal,<br>&gt;&gt;&gt; their rationale for the decision will be written here.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160620/30b7ee9a/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Proposal] Generic and `throw`ing subscripts</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>June 21, 2016 at 12:00:00am</p></header><div class="content"><p>I may be wrong, but I think this proposal will not be merged or scheduled for review until August as it seems like post-Swift 3 material.<br></p><p>&gt; On 20 Jun 2016, at 20:10, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Good morning all.  Attached is the proposal Harlan Haskins and I will be submitting shortly about adding generic and `throw`ing subscript declarations to the language.  <br>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt; Generic and Throwing Subscripts<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>&gt; Author(s): Harlan Haskins &lt;https://github.com/harlanhaskins&gt; and Robert Widmann &lt;https://github.com/codafi&gt;<br>&gt; Status: Awaiting review &lt;https://github.com/typelift/SwiftCheck/pull/168#rationale&gt;<br>&gt; Review manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; Currently, subscripts cannot be declared [re]throws and cannot declare new generic parameters.<br>&gt; There isn&#39;t a clear reason why they aren&#39;t as capable as full-fledged functions, so we propose<br>&gt; adding generic constraints and throwing semantics to subscripts.<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; On the throwing side, currently there are two ways to express a failing subscript:<br>&gt; <br>&gt; Return an Optional, failing with nil.<br>&gt; Call fatalError(_:) on failure.<br>&gt; Both of these throw out useful information about the cause of the underlying error that using Swift&#39;s error handling mechanism can otherwise provide.<br>&gt; <br>&gt; As for generics, to take an example, it has become a common pattern among JSON decoding DSL libraries to express a throwing generic extension on Dictionary like so<br>&gt; <br>&gt; extension Dictionary {<br>&gt;     public func parse&lt;T&gt;(key: Key) throws -&gt; T {<br>&gt;         guard let value = self[key] else {<br>&gt;             throw JSONError.MissingKey(&quot;\(key)&quot;)<br>&gt;         }<br>&gt;         guard let ofType = value as? T else {<br>&gt;             throw JSONError.InvalidKey(key: &quot;\(key)&quot;, expectedType: T.self, foundType: value.dynamicType)<br>&gt;         }<br>&gt;         return ofType<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; public enum JSONError: ErrorType, CustomStringConvertible {<br>&gt;     case InvalidKey(key: String, expectedType: Any.Type, foundType: Any.Type)<br>&gt;     case MissingKey(String)<br>&gt;     public var description: String {<br>&gt;         switch self {<br>&gt;         case .InvalidKey(let key, let expected, let found):<br>&gt;             return &quot;Invalid key \&quot;\(key)\&quot;. Expected value of type \&quot;\(expected)\&quot;, found \&quot;\(found)\&quot;.&quot;<br>&gt;         case .MissingKey(let key):<br>&gt;             return &quot;Key \(key) not found.&quot;<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; Given this, one can decode JSON with the full support of native type inference and exception handling. But when working with the DSL, one would expect to be able to express this as a subscript on Dictionary, allowing the following:<br>&gt; <br>&gt; //...<br>&gt; <br>&gt; extension Dictionary {<br>&gt;     public subscript&lt;T&gt;(key: Key) throws -&gt; T {<br>&gt;         guard let value = self[key] else {<br>&gt;             throw JSONError.MissingKey(&quot;\(key)&quot;)<br>&gt;         }<br>&gt;         guard let ofType = value as? T else {<br>&gt;             throw JSONError.InvalidKey(key: &quot;\(key)&quot;, expectedType: T.self, foundType: value.dynamicType)<br>&gt;         }<br>&gt;         return ofType<br>&gt;     }<br>&gt; }<br>&gt; We believe this is an even more natural way to write these kinds of libraries in Swift and that bringing subscript member declarations up to par with functions is a useful addition to the language as a whole.<br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; Add the ability to introduce new generic parameters and mark throws and rethrows on subscript members.<br>&gt; <br>&gt; Detailed design<br>&gt; <br>&gt; This change will modify and add the following productions in the Swift grammar<br>&gt; <br>&gt; GRAMMAR OF A SUBSCRIPT DECLARATION<br>&gt; <br>&gt; subscript-declaration → subscript-head subscript-result code-block<br>&gt; subscript-declaration → subscript-head subscript-result getter-setter-block<br>&gt; subscript-declaration → subscript-head subscript-result getter-setter-keyword-block<br>&gt; -subscript-head → attributes(opt) declaration-modifiers(opt) subscript parameter-clause<br>&gt; +subscript-head → attributes(opt) declaration-modifiers(opt) generic-parameter-clause(opt) subscript parameter-clause<br>&gt; +subscript-result → -&gt; attributes(opt) throws(opt) type<br>&gt; +subscript-result → -&gt; attributes(opt) rethrows(opt) type<br>&gt; Rationale<br>&gt; <br>&gt; On [Date], the core team decided to (TBD) this proposal.<br>&gt; When the core team makes a decision regarding this proposal,<br>&gt; their rationale for the decision will be written here.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160621/fbb88d55/attachment-0001.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ab486d7597af4cfe0be33a762150848?s=50"></div><header><strong>[Proposal] Generic and `throw`ing subscripts</strong> from <string>Dany St-Amant</string> &lt;dsa.mls at icloud.com&gt;<p>June 20, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; Le 20 juin 2016 à 14:10, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; This change will modify and add the following productions in the Swift grammar<br>&gt; <br>&gt; GRAMMAR OF A SUBSCRIPT DECLARATION<br>&gt; <br>&gt; subscript-declaration → subscript-head subscript-result code-block<br>&gt; subscript-declaration → subscript-head subscript-result getter-setter-block<br>&gt; subscript-declaration → subscript-head subscript-result getter-setter-keyword-block<br>&gt; -subscript-head → attributes(opt) declaration-modifiers(opt) subscript parameter-clause<br>&gt; +subscript-head → attributes(opt) declaration-modifiers(opt) generic-parameter-clause(opt) subscript parameter-clause<br>&gt; +subscript-result → -&gt; attributes(opt) throws(opt) type<br>&gt; +subscript-result → -&gt; attributes(opt) rethrows(opt) type<br>I am no expert in throws, but since there&#39;s no closure involved I think that &#39;rethrows&#39; doesn&#39;t apply here.<br></p><p>Dany<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160620/c0f4c4b4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d972db2b6ee8b77746ce7122663eb4f8?s=50"></div><header><strong>[Proposal] Generic and `throw`ing subscripts</strong> from <string>Robert Widmann</string> &lt;rwidmann at apple.com&gt;<p>June 20, 2016 at 06:00:00pm</p></header><div class="content"><p>Closures are a valid argument to pass to a subscript.  Granted, I’m not sure of a use-case, but it’s certainly something that is possible.<br></p><p>&gt; On Jun 20, 2016, at 5:54 PM, Dany St-Amant &lt;dsa.mls at icloud.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Le 20 juin 2016 à 14:10, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt; <br>&gt;&gt; This change will modify and add the following productions in the Swift grammar<br>&gt;&gt; <br>&gt;&gt; GRAMMAR OF A SUBSCRIPT DECLARATION<br>&gt;&gt; <br>&gt;&gt; subscript-declaration → subscript-head subscript-result code-block<br>&gt;&gt; subscript-declaration → subscript-head subscript-result getter-setter-block<br>&gt;&gt; subscript-declaration → subscript-head subscript-result getter-setter-keyword-block<br>&gt;&gt; -subscript-head → attributes(opt) declaration-modifiers(opt) subscript parameter-clause<br>&gt;&gt; +subscript-head → attributes(opt) declaration-modifiers(opt) generic-parameter-clause(opt) subscript parameter-clause<br>&gt;&gt; +subscript-result → -&gt; attributes(opt) throws(opt) type<br>&gt;&gt; +subscript-result → -&gt; attributes(opt) rethrows(opt) type<br>&gt; I am no expert in throws, but since there&#39;s no closure involved I think that &#39;rethrows&#39; doesn&#39;t apply here.<br>&gt; <br>&gt; Dany<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160620/122c3dfc/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal] Generic and `throw`ing subscripts</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>June 21, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Jun 20, 2016, at 11:10 AM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Good morning all.  Attached is the proposal Harlan Haskins and I will be submitting shortly about adding generic and `throw`ing subscript declarations to the language.  <br></p><p>I mentioned this in the PR, but for everyone’s benefit: Swift 3 is in its late end game.  This is a very important release, and we need to stay focused on the goals for the release, at least until we pivot and start working on releases that follow it.  I expect this time to be sometime around August.  Until then, any evolution proposals that are strictly additive will need very strong rationale, explaining why they are critical for inclusion in Swift 3.<br></p><p>Here is my previous email about this:<br>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160516/017701.html<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal] Generic and `throw`ing subscripts</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>June 21, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Jun 21, 2016, at 10:41 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 20, 2016, at 11:10 AM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Good morning all.  Attached is the proposal Harlan Haskins and I will be submitting shortly about adding generic and `throw`ing subscript declarations to the language.  <br>&gt; <br>&gt; I mentioned this in the PR, but for everyone’s benefit: Swift 3 is in its late end game.  This is a very important release, and we need to stay focused on the goals for the release, at least until we pivot and start working on releases that follow it.  I expect this time to be sometime around August.  Until then, any evolution proposals that are strictly additive will need very strong rationale, explaining why they are critical for inclusion in Swift 3.<br>&gt; <br>&gt; Here is my previous email about this:<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160516/017701.html<br></p><p>I will pop this out to its own thread, since it is more general than this topic.<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Proposal] Generic and `throw`ing subscripts</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>June 22, 2016 at 08:00:00am</p></header><div class="content"><p>Prefacing the below with a “I am well-aware this proposal likely won’t make it into Swift 3”:<br></p><p>A feature like this would be nice to use, but before I could get behind any proposal along these lines it I’d want to see it include an explicit strategy for disambiguation.<br></p><p>EG: in your example, your generic subscript uses `self[key]`, and presumably expects that to use the “original” subscript…and not the generic subscript being defined.<br></p><p>I think that’s reasonable in that specific case, but it doesn’t seem unreasonable to anticipate this proposal introducing ambiguities that would need explicit disambiguation…and for which explicit type annotation may not always be adequate to resolve (I could be wrong here, though). <br></p><p>This would need addressing (either showing they won’t be an issue, or providing a reliable disambiguation mechanism).<br></p><p>Relatedly, in-re: “rethrows”: if the syntax supported it, this kind of thing would be another way of tackling the &quot;JSON problem&quot;:<br></p><p>  subscript&lt;T&gt;(key: Key, transform: (Value) throws -&gt; T) rethrows -&gt; T {<br>    guard let value = self[key] else { throw JSON.MissingKey(…) }<br>    return try transform(value)<br>  }<br></p><p>…so that e.g. you can write typical parsing-code as<br></p><p>  let asUserID = UserID.init(untrustedString:) // &lt;- assume this is a &quot;throwing constructor&quot;<br>  let sender = try json[“sender”,asUserID] <br>  let recipient = try json[“recipient”,asUserID]<br></p><p>…(modulo any syntax errors, etc.), which would benefit from a `rethrows` declaration.<br></p><p>That’s my 2c; thankfully (IMHO) there’s clearly a lot of time for this proposal to simmer.<br></p><p>&gt; On Jun 20, 2016, at 1:10 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Good morning all.  Attached is the proposal Harlan Haskins and I will be submitting shortly about adding generic and `throw`ing subscript declarations to the language.  <br>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt; Generic and Throwing Subscripts<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>&gt; Author(s): Harlan Haskins &lt;https://github.com/harlanhaskins&gt; and Robert Widmann &lt;https://github.com/codafi&gt;<br>&gt; Status: Awaiting review &lt;https://github.com/typelift/SwiftCheck/pull/168#rationale&gt;<br>&gt; Review manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; Currently, subscripts cannot be declared [re]throws and cannot declare new generic parameters.<br>&gt; There isn&#39;t a clear reason why they aren&#39;t as capable as full-fledged functions, so we propose<br>&gt; adding generic constraints and throwing semantics to subscripts.<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; On the throwing side, currently there are two ways to express a failing subscript:<br>&gt; <br>&gt; Return an Optional, failing with nil.<br>&gt; Call fatalError(_:) on failure.<br>&gt; Both of these throw out useful information about the cause of the underlying error that using Swift&#39;s error handling mechanism can otherwise provide.<br>&gt; <br>&gt; As for generics, to take an example, it has become a common pattern among JSON decoding DSL libraries to express a throwing generic extension on Dictionary like so<br>&gt; <br>&gt; extension Dictionary {<br>&gt;     public func parse&lt;T&gt;(key: Key) throws -&gt; T {<br>&gt;         guard let value = self[key] else {<br>&gt;             throw JSONError.MissingKey(&quot;\(key)&quot;)<br>&gt;         }<br>&gt;         guard let ofType = value as? T else {<br>&gt;             throw JSONError.InvalidKey(key: &quot;\(key)&quot;, expectedType: T.self, foundType: value.dynamicType)<br>&gt;         }<br>&gt;         return ofType<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; public enum JSONError: ErrorType, CustomStringConvertible {<br>&gt;     case InvalidKey(key: String, expectedType: Any.Type, foundType: Any.Type)<br>&gt;     case MissingKey(String)<br>&gt;     public var description: String {<br>&gt;         switch self {<br>&gt;         case .InvalidKey(let key, let expected, let found):<br>&gt;             return &quot;Invalid key \&quot;\(key)\&quot;. Expected value of type \&quot;\(expected)\&quot;, found \&quot;\(found)\&quot;.&quot;<br>&gt;         case .MissingKey(let key):<br>&gt;             return &quot;Key \(key) not found.&quot;<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; Given this, one can decode JSON with the full support of native type inference and exception handling. But when working with the DSL, one would expect to be able to express this as a subscript on Dictionary, allowing the following:<br>&gt; <br>&gt; //...<br>&gt; <br>&gt; extension Dictionary {<br>&gt;     public subscript&lt;T&gt;(key: Key) throws -&gt; T {<br>&gt;         guard let value = self[key] else {<br>&gt;             throw JSONError.MissingKey(&quot;\(key)&quot;)<br>&gt;         }<br>&gt;         guard let ofType = value as? T else {<br>&gt;             throw JSONError.InvalidKey(key: &quot;\(key)&quot;, expectedType: T.self, foundType: value.dynamicType)<br>&gt;         }<br>&gt;         return ofType<br>&gt;     }<br>&gt; }<br>&gt; We believe this is an even more natural way to write these kinds of libraries in Swift and that bringing subscript member declarations up to par with functions is a useful addition to the language as a whole.<br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; Add the ability to introduce new generic parameters and mark throws and rethrows on subscript members.<br>&gt; <br>&gt; Detailed design<br>&gt; <br>&gt; This change will modify and add the following productions in the Swift grammar<br>&gt; <br>&gt; GRAMMAR OF A SUBSCRIPT DECLARATION<br>&gt; <br>&gt; subscript-declaration → subscript-head subscript-result code-block<br>&gt; subscript-declaration → subscript-head subscript-result getter-setter-block<br>&gt; subscript-declaration → subscript-head subscript-result getter-setter-keyword-block<br>&gt; -subscript-head → attributes(opt) declaration-modifiers(opt) subscript parameter-clause<br>&gt; +subscript-head → attributes(opt) declaration-modifiers(opt) generic-parameter-clause(opt) subscript parameter-clause<br>&gt; +subscript-result → -&gt; attributes(opt) throws(opt) type<br>&gt; +subscript-result → -&gt; attributes(opt) rethrows(opt) type<br>&gt; Rationale<br>&gt; <br>&gt; On [Date], the core team decided to (TBD) this proposal.<br>&gt; When the core team makes a decision regarding this proposal,<br>&gt; their rationale for the decision will be written here.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160622/0854f98c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Proposal] Generic and `throw`ing subscripts</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>June 22, 2016 at 09:00:00am</p></header><div class="content"><p>plx: wouldn&#39;t the same overload resolution strategy be appropriate here?<br>&quot;most specific choice, otherwise diagnostic&quot;<br></p><p><br></p><p>separately:<br>Are there any subscripts in the standard library that would be<br>throwing/generic but can&#39;t be?<br></p><p><br>On Wed, Jun 22, 2016 at 9:13 AM, plx via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Prefacing the below with a “I am well-aware this proposal likely won’t<br>&gt; make it into Swift 3”:<br>&gt;<br>&gt; A feature like this would be nice to use, but before I could get behind<br>&gt; any proposal along these lines it I’d want to see it include an explicit<br>&gt; strategy for disambiguation.<br>&gt;<br>&gt; EG: in your example, your generic subscript uses `self[key]`, and<br>&gt; presumably expects that to use the “original” subscript…and not the generic<br>&gt; subscript being defined.<br>&gt;<br>&gt; I think that’s reasonable in that specific case, but it doesn’t seem<br>&gt; unreasonable to anticipate this proposal introducing ambiguities that would<br>&gt; need explicit disambiguation…and for which explicit type annotation may not<br>&gt; always be adequate to resolve (I could be wrong here, though).<br>&gt;<br>&gt; This would need addressing (either showing they won’t be an issue, or<br>&gt; providing a reliable disambiguation mechanism).<br>&gt;<br>&gt; Relatedly, in-re: “rethrows”: if the syntax supported it, this kind of<br>&gt; thing would be another way of tackling the &quot;JSON problem&quot;:<br>&gt;<br>&gt;   subscript&lt;T&gt;(key: Key, transform: (Value) throws -&gt; T) rethrows -&gt; T {<br>&gt;     guard let value = self[key] else { throw JSON.MissingKey(…) }<br>&gt;     return try transform(value)<br>&gt;   }<br>&gt;<br>&gt; …so that e.g. you can write typical parsing-code as<br>&gt;<br>&gt;   let asUserID = UserID.init(untrustedString:) // &lt;- assume this is a<br>&gt; &quot;throwing constructor&quot;<br>&gt;   let sender = try json[“sender”,asUserID]<br>&gt;   let recipient = try json[“recipient”,asUserID]<br>&gt;<br>&gt; …(modulo any syntax errors, etc.), which would benefit from a `rethrows`<br>&gt; declaration.<br>&gt;<br>&gt; That’s my 2c; thankfully (IMHO) there’s clearly a lot of time for this<br>&gt; proposal to simmer.<br>&gt;<br>&gt; On Jun 20, 2016, at 1:10 PM, Robert Widmann via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Good morning all.  Attached is the proposal Harlan Haskins and I will be<br>&gt; submitting shortly about adding generic and `throw`ing subscript<br>&gt; declarations to the language.<br>&gt;<br>&gt; Cheers,<br>&gt;<br>&gt; ~Robert Widmann<br>&gt;<br>&gt; Generic and Throwing Subscripts<br>&gt;<br>&gt;    - Proposal: SE-NNNN<br>&gt;    &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>&gt;    - Author(s): Harlan Haskins &lt;https://github.com/harlanhaskins&gt; and Robert<br>&gt;    Widmann &lt;https://github.com/codafi&gt;<br>&gt;    - Status: Awaiting review<br>&gt;    &lt;https://github.com/typelift/SwiftCheck/pull/168#rationale&gt;<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt; Introduction<br>&gt;<br>&gt; Currently, subscripts cannot be declared [re]throws and cannot declare<br>&gt; new generic parameters.<br>&gt; There isn&#39;t a clear reason why they aren&#39;t as capable as full-fledged<br>&gt; functions, so we propose<br>&gt; adding generic constraints and throwing semantics to subscripts.<br>&gt; Motivation<br>&gt;<br>&gt; On the throwing side, currently there are two ways to express a failing<br>&gt; subscript:<br>&gt;<br>&gt;    - Return an Optional, failing with nil.<br>&gt;    - Call fatalError(_:) on failure.<br>&gt;<br>&gt; Both of these throw out useful information about the cause of the<br>&gt; underlying error that using Swift&#39;s error handling mechanism can otherwise<br>&gt; provide.<br>&gt;<br>&gt; As for generics, to take an example, it has become a common pattern among<br>&gt; JSON decoding DSL libraries to express a throwing generic extension on<br>&gt; Dictionary like so<br>&gt;<br>&gt; extension Dictionary {<br>&gt;     public func parse&lt;T&gt;(key: Key) throws -&gt; T {<br>&gt;         guard let value = self[key] else {<br>&gt;             throw JSONError.MissingKey(&quot;\(key)&quot;)<br>&gt;         }<br>&gt;         guard let ofType = value as? T else {<br>&gt;             throw JSONError.InvalidKey(key: &quot;\(key)&quot;, expectedType: T.self, foundType: value.dynamicType)<br>&gt;         }<br>&gt;         return ofType<br>&gt;     }<br>&gt; }<br>&gt; public enum JSONError: ErrorType, CustomStringConvertible {<br>&gt;     case InvalidKey(key: String, expectedType: Any.Type, foundType: Any.Type)<br>&gt;     case MissingKey(String)<br>&gt;     public var description: String {<br>&gt;         switch self {<br>&gt;         case .InvalidKey(let key, let expected, let found):<br>&gt;             return &quot;Invalid key \&quot;\(key)\&quot;. Expected value of type \&quot;\(expected)\&quot;, found \&quot;\(found)\&quot;.&quot;<br>&gt;         case .MissingKey(let key):<br>&gt;             return &quot;Key \(key) not found.&quot;<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; Given this, one can decode JSON with the full support of native type<br>&gt; inference and exception handling. But when working with the DSL, one would<br>&gt; expect to be able to express this as a subscript on Dictionary, allowing<br>&gt; the following:<br>&gt;<br>&gt; //...<br>&gt; extension Dictionary {<br>&gt;     public subscript&lt;T&gt;(key: Key) throws -&gt; T {<br>&gt;         guard let value = self[key] else {<br>&gt;             throw JSONError.MissingKey(&quot;\(key)&quot;)<br>&gt;         }<br>&gt;         guard let ofType = value as? T else {<br>&gt;             throw JSONError.InvalidKey(key: &quot;\(key)&quot;, expectedType: T.self, foundType: value.dynamicType)<br>&gt;         }<br>&gt;         return ofType<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; We believe this is an even more natural way to write these kinds of<br>&gt; libraries in Swift and that bringing subscript member declarations up to<br>&gt; par with functions is a useful addition to the language as a whole.<br>&gt; Proposed solution<br>&gt;<br>&gt; Add the ability to introduce new generic parameters and mark throws and<br>&gt; rethrows on subscript members.<br>&gt; Detailed design<br>&gt;<br>&gt; This change will modify and add the following productions in the Swift<br>&gt; grammar<br>&gt;<br>&gt; GRAMMAR OF A SUBSCRIPT DECLARATION<br>&gt;<br>&gt; subscript-declaration → subscript-head subscript-result code-block<br>&gt; subscript-declaration → subscript-head subscript-result getter-setter-block<br>&gt; subscript-declaration → subscript-head subscript-result getter-setter-keyword-block-subscript-head → attributes(opt) declaration-modifiers(opt) subscript parameter-clause+subscript-head → attributes(opt) declaration-modifiers(opt) generic-parameter-clause(opt) subscript parameter-clause+subscript-result → -&gt; attributes(opt) throws(opt) type+subscript-result → -&gt; attributes(opt) rethrows(opt) type<br>&gt;<br>&gt; ------------------------------<br>&gt; Rationale<br>&gt; On [Date], the core team decided to (TBD) this proposal.<br>&gt; When the core team makes a decision regarding this proposal,<br>&gt; their rationale for the decision will be written here.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160622/6fe560d7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Proposal] Generic and `throw`ing subscripts</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>June 22, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jun 22, 2016, at 8:28 AM, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt; <br>&gt; plx: wouldn&#39;t the same overload resolution strategy be appropriate here? &quot;most specific choice, otherwise diagnostic”<br></p><p>I’d assume it’d be good enough for most cases, certainly; I’d love to turn out to be needlessly scaremongering here, too.<br></p><p>But (hopefully unintentionally!) it seems like you could easily wind up with scenarios like this:<br></p><p>  // from proposal:<br>  public subscript&lt;T&gt;(key: Key) throws -&gt; T {<br>    guard let value = self[key] else { throw ... }<br>    guard let ofType = value as? T else { throw ... }<br>    return ofType<br>  }<br></p><p>  // an annoying addition:<br>  public subscript&lt;T:RawRepresentable&gt;(key: Key) throws -&gt; T {<br>    guard let v = self[key] else { throw ... }<br>    guard let rawValue = v as? T.RawValue else { throw ... }<br>    guard let converted = T(rawValue: rawValue) else { throw ... }<br>    return converted<br>  }<br></p><p>  // assume `Foo:RawRepresentable`:<br>  let foo: Foo = json[&quot;foo&quot;]<br></p><p>…and similar, where I’d assume the `T:RawRepresentable` would “win”, but I’m not sure *how* you could force use of the *other* subscript in the above.<br></p><p>This isn’t really a new problem, but it seems likelier to be encountered if generic subscripts become allowed, due to all subscripts having the same “name”.<br></p><p>But again I’d like to be wrong about the issue (or at least the severity).<br></p><p>&gt; <br>&gt; separately:<br>&gt; Are there any subscripts in the standard library that would be throwing/generic but can&#39;t be?<br>&gt; <br>&gt; <br>&gt; On Wed, Jun 22, 2016 at 9:13 AM, plx via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Prefacing the below with a “I am well-aware this proposal likely won’t make it into Swift 3”:<br>&gt; <br>&gt; A feature like this would be nice to use, but before I could get behind any proposal along these lines it I’d want to see it include an explicit strategy for disambiguation.<br>&gt; <br>&gt; EG: in your example, your generic subscript uses `self[key]`, and presumably expects that to use the “original” subscript…and not the generic subscript being defined.<br>&gt; <br>&gt; I think that’s reasonable in that specific case, but it doesn’t seem unreasonable to anticipate this proposal introducing ambiguities that would need explicit disambiguation…and for which explicit type annotation may not always be adequate to resolve (I could be wrong here, though). <br>&gt; <br>&gt; This would need addressing (either showing they won’t be an issue, or providing a reliable disambiguation mechanism).<br>&gt; <br>&gt; Relatedly, in-re: “rethrows”: if the syntax supported it, this kind of thing would be another way of tackling the &quot;JSON problem&quot;:<br>&gt; <br>&gt;   subscript&lt;T&gt;(key: Key, transform: (Value) throws -&gt; T) rethrows -&gt; T {<br>&gt;     guard let value = self[key] else { throw JSON.MissingKey(…) }<br>&gt;     return try transform(value)<br>&gt;   }<br>&gt; <br>&gt; …so that e.g. you can write typical parsing-code as<br>&gt; <br>&gt;   let asUserID = UserID.init(untrustedString:) // &lt;- assume this is a &quot;throwing constructor&quot;<br>&gt;   let sender = try json[“sender”,asUserID] <br>&gt;   let recipient = try json[“recipient”,asUserID]<br>&gt; <br>&gt; …(modulo any syntax errors, etc.), which would benefit from a `rethrows` declaration.<br>&gt; <br>&gt; That’s my 2c; thankfully (IMHO) there’s clearly a lot of time for this proposal to simmer.<br>&gt; <br>&gt;&gt; On Jun 20, 2016, at 1:10 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Good morning all.  Attached is the proposal Harlan Haskins and I will be submitting shortly about adding generic and `throw`ing subscript declarations to the language.  <br>&gt;&gt; <br>&gt;&gt; Cheers,<br>&gt;&gt; <br>&gt;&gt; ~Robert Widmann<br>&gt;&gt; <br>&gt;&gt; Generic and Throwing Subscripts<br>&gt;&gt; <br>&gt;&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>&gt;&gt; Author(s): Harlan Haskins &lt;https://github.com/harlanhaskins&gt; and Robert Widmann &lt;https://github.com/codafi&gt;<br>&gt;&gt; Status: Awaiting review &lt;https://github.com/typelift/SwiftCheck/pull/168#rationale&gt;<br>&gt;&gt; Review manager: TBD<br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; Currently, subscripts cannot be declared [re]throws and cannot declare new generic parameters.<br>&gt;&gt; There isn&#39;t a clear reason why they aren&#39;t as capable as full-fledged functions, so we propose<br>&gt;&gt; adding generic constraints and throwing semantics to subscripts.<br>&gt;&gt; <br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; On the throwing side, currently there are two ways to express a failing subscript:<br>&gt;&gt; <br>&gt;&gt; Return an Optional, failing with nil.<br>&gt;&gt; Call fatalError(_:) on failure.<br>&gt;&gt; Both of these throw out useful information about the cause of the underlying error that using Swift&#39;s error handling mechanism can otherwise provide.<br>&gt;&gt; <br>&gt;&gt; As for generics, to take an example, it has become a common pattern among JSON decoding DSL libraries to express a throwing generic extension on Dictionary like so<br>&gt;&gt; <br>&gt;&gt; extension Dictionary {<br>&gt;&gt;     public func parse&lt;T&gt;(key: Key) throws -&gt; T {<br>&gt;&gt;         guard let value = self[key] else {<br>&gt;&gt;             throw JSONError.MissingKey(&quot;\(key)&quot;)<br>&gt;&gt;         }<br>&gt;&gt;         guard let ofType = value as? T else {<br>&gt;&gt;             throw JSONError.InvalidKey(key: &quot;\(key)&quot;, expectedType: T.self, foundType: value.dynamicType)<br>&gt;&gt;         }<br>&gt;&gt;         return ofType<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; public enum JSONError: ErrorType, CustomStringConvertible {<br>&gt;&gt;     case InvalidKey(key: String, expectedType: Any.Type, foundType: Any.Type)<br>&gt;&gt;     case MissingKey(String)<br>&gt;&gt;     public var description: String {<br>&gt;&gt;         switch self {<br>&gt;&gt;         case .InvalidKey(let key, let expected, let found):<br>&gt;&gt;             return &quot;Invalid key \&quot;\(key)\&quot;. Expected value of type \&quot;\(expected)\&quot;, found \&quot;\(found)\&quot;.&quot;<br>&gt;&gt;         case .MissingKey(let key):<br>&gt;&gt;             return &quot;Key \(key) not found.&quot;<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; Given this, one can decode JSON with the full support of native type inference and exception handling. But when working with the DSL, one would expect to be able to express this as a subscript on Dictionary, allowing the following:<br>&gt;&gt; <br>&gt;&gt; //...<br>&gt;&gt; <br>&gt;&gt; extension Dictionary {<br>&gt;&gt;     public subscript&lt;T&gt;(key: Key) throws -&gt; T {<br>&gt;&gt;         guard let value = self[key] else {<br>&gt;&gt;             throw JSONError.MissingKey(&quot;\(key)&quot;)<br>&gt;&gt;         }<br>&gt;&gt;         guard let ofType = value as? T else {<br>&gt;&gt;             throw JSONError.InvalidKey(key: &quot;\(key)&quot;, expectedType: T.self, foundType: value.dynamicType)<br>&gt;&gt;         }<br>&gt;&gt;         return ofType<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; We believe this is an even more natural way to write these kinds of libraries in Swift and that bringing subscript member declarations up to par with functions is a useful addition to the language as a whole.<br>&gt;&gt; <br>&gt;&gt; Proposed solution<br>&gt;&gt; <br>&gt;&gt; Add the ability to introduce new generic parameters and mark throws and rethrows on subscript members.<br>&gt;&gt; <br>&gt;&gt; Detailed design<br>&gt;&gt; <br>&gt;&gt; This change will modify and add the following productions in the Swift grammar<br>&gt;&gt; <br>&gt;&gt; GRAMMAR OF A SUBSCRIPT DECLARATION<br>&gt;&gt; <br>&gt;&gt; subscript-declaration → subscript-head subscript-result code-block<br>&gt;&gt; subscript-declaration → subscript-head subscript-result getter-setter-block<br>&gt;&gt; subscript-declaration → subscript-head subscript-result getter-setter-keyword-block<br>&gt;&gt; -subscript-head → attributes(opt) declaration-modifiers(opt) subscript parameter-clause<br>&gt;&gt; +subscript-head → attributes(opt) declaration-modifiers(opt) generic-parameter-clause(opt) subscript parameter-clause<br>&gt;&gt; +subscript-result → -&gt; attributes(opt) throws(opt) type<br>&gt;&gt; +subscript-result → -&gt; attributes(opt) rethrows(opt) type<br>&gt;&gt; Rationale<br>&gt;&gt; <br>&gt;&gt; On [Date], the core team decided to (TBD) this proposal.<br>&gt;&gt; When the core team makes a decision regarding this proposal,<br>&gt;&gt; their rationale for the decision will be written here.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160622/f65a2e4a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Generic and `throw`ing subscripts</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 22, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jun 22, 2016, at 9:11 AM, plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 22, 2016, at 8:28 AM, T.J. Usiyan &lt;griotspeak at gmail.com &lt;mailto:griotspeak at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; plx: wouldn&#39;t the same overload resolution strategy be appropriate here? &quot;most specific choice, otherwise diagnostic”<br>&gt; <br>&gt; I’d assume it’d be good enough for most cases, certainly; I’d love to turn out to be needlessly scaremongering here, too.<br>&gt; <br>&gt; But (hopefully unintentionally!) it seems like you could easily wind up with scenarios like this:<br>&gt; <br>&gt;   // from proposal:<br>&gt;   public subscript&lt;T&gt;(key: Key) throws -&gt; T {<br>&gt;     guard let value = self[key] else { throw ... }<br>&gt;     guard let ofType = value as? T else { throw ... }<br>&gt;     return ofType<br>&gt;   }<br>&gt; <br>&gt;   // an annoying addition:<br>&gt;   public subscript&lt;T:RawRepresentable&gt;(key: Key) throws -&gt; T {<br>&gt;     guard let v = self[key] else { throw ... }<br>&gt;     guard let rawValue = v as? T.RawValue else { throw ... }<br>&gt;     guard let converted = T(rawValue: rawValue) else { throw ... }<br>&gt;     return converted<br>&gt;   }<br>&gt; <br>&gt;   // assume `Foo:RawRepresentable`:<br>&gt;   let foo: Foo = json[&quot;foo&quot;]<br>&gt; <br>&gt; …and similar, where I’d assume the `T:RawRepresentable` would “win”, but I’m not sure *how* you could force use of the *other* subscript in the above.<br>&gt; <br>&gt; This isn’t really a new problem, but it seems likelier to be encountered if generic subscripts become allowed, due to all subscripts having the same “name”.<br></p><p>This isn’t exactly true.  External argument labels are considered part of the “name” in Swift.  Subscripts parameters don’t get external labels automatically like other functions / methods do, but you can still add one if you *want* the ability to disambiguate.  <br></p><p>Of course this won’t help if you require the ability to use both subscripts without a label but is worth noting.  It is also worth noting that this behavior is no different from that of any other function or method - if the name (including external argument labels) matches the most specific overload will always be selected.<br></p><p>One way to make your example work properly when `T` is `RawRepresentable` and the dictionary actually contains an instance of `T` is to add an extra check for that case:<br></p><p>  public subscript&lt;T:RawRepresentable&gt;(key: Key) throws -&gt; T {<br>    guard let v = self[key] else { throw … }<br></p><p>    // extra check here in case the value is *already* T and therefore does not require conversion.<br>    if let value = v as? T { return value }<br></p><p>    guard let rawValue = v as? T.RawValue else { throw ... }<br>    guard let converted = T(rawValue: rawValue) else { throw ... }<br>    return converted<br>  }<br></p><p>&gt; <br>&gt; But again I’d like to be wrong about the issue (or at least the severity).<br>&gt; <br>&gt;&gt; <br>&gt;&gt; separately:<br>&gt;&gt; Are there any subscripts in the standard library that would be throwing/generic but can&#39;t be?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Wed, Jun 22, 2016 at 9:13 AM, plx via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Prefacing the below with a “I am well-aware this proposal likely won’t make it into Swift 3”:<br>&gt;&gt; <br>&gt;&gt; A feature like this would be nice to use, but before I could get behind any proposal along these lines it I’d want to see it include an explicit strategy for disambiguation.<br>&gt;&gt; <br>&gt;&gt; EG: in your example, your generic subscript uses `self[key]`, and presumably expects that to use the “original” subscript…and not the generic subscript being defined.<br>&gt;&gt; <br>&gt;&gt; I think that’s reasonable in that specific case, but it doesn’t seem unreasonable to anticipate this proposal introducing ambiguities that would need explicit disambiguation…and for which explicit type annotation may not always be adequate to resolve (I could be wrong here, though). <br>&gt;&gt; <br>&gt;&gt; This would need addressing (either showing they won’t be an issue, or providing a reliable disambiguation mechanism).<br>&gt;&gt; <br>&gt;&gt; Relatedly, in-re: “rethrows”: if the syntax supported it, this kind of thing would be another way of tackling the &quot;JSON problem&quot;:<br>&gt;&gt; <br>&gt;&gt;   subscript&lt;T&gt;(key: Key, transform: (Value) throws -&gt; T) rethrows -&gt; T {<br>&gt;&gt;     guard let value = self[key] else { throw JSON.MissingKey(…) }<br>&gt;&gt;     return try transform(value)<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; …so that e.g. you can write typical parsing-code as<br>&gt;&gt; <br>&gt;&gt;   let asUserID = UserID.init(untrustedString:) // &lt;- assume this is a &quot;throwing constructor&quot;<br>&gt;&gt;   let sender = try json[“sender”,asUserID] <br>&gt;&gt;   let recipient = try json[“recipient”,asUserID]<br>&gt;&gt; <br>&gt;&gt; …(modulo any syntax errors, etc.), which would benefit from a `rethrows` declaration.<br>&gt;&gt; <br>&gt;&gt; That’s my 2c; thankfully (IMHO) there’s clearly a lot of time for this proposal to simmer.<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 20, 2016, at 1:10 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Good morning all.  Attached is the proposal Harlan Haskins and I will be submitting shortly about adding generic and `throw`ing subscript declarations to the language.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Generic and Throwing Subscripts<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>&gt;&gt;&gt; Author(s): Harlan Haskins &lt;https://github.com/harlanhaskins&gt; and Robert Widmann &lt;https://github.com/codafi&gt;<br>&gt;&gt;&gt; Status: Awaiting review &lt;https://github.com/typelift/SwiftCheck/pull/168#rationale&gt;<br>&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Currently, subscripts cannot be declared [re]throws and cannot declare new generic parameters.<br>&gt;&gt;&gt; There isn&#39;t a clear reason why they aren&#39;t as capable as full-fledged functions, so we propose<br>&gt;&gt;&gt; adding generic constraints and throwing semantics to subscripts.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On the throwing side, currently there are two ways to express a failing subscript:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Return an Optional, failing with nil.<br>&gt;&gt;&gt; Call fatalError(_:) on failure.<br>&gt;&gt;&gt; Both of these throw out useful information about the cause of the underlying error that using Swift&#39;s error handling mechanism can otherwise provide.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As for generics, to take an example, it has become a common pattern among JSON decoding DSL libraries to express a throwing generic extension on Dictionary like so<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Dictionary {<br>&gt;&gt;&gt;     public func parse&lt;T&gt;(key: Key) throws -&gt; T {<br>&gt;&gt;&gt;         guard let value = self[key] else {<br>&gt;&gt;&gt;             throw JSONError.MissingKey(&quot;\(key)&quot;)<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;         guard let ofType = value as? T else {<br>&gt;&gt;&gt;             throw JSONError.InvalidKey(key: &quot;\(key)&quot;, expectedType: T.self, foundType: value.dynamicType)<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;         return ofType<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public enum JSONError: ErrorType, CustomStringConvertible {<br>&gt;&gt;&gt;     case InvalidKey(key: String, expectedType: Any.Type, foundType: Any.Type)<br>&gt;&gt;&gt;     case MissingKey(String)<br>&gt;&gt;&gt;     public var description: String {<br>&gt;&gt;&gt;         switch self {<br>&gt;&gt;&gt;         case .InvalidKey(let key, let expected, let found):<br>&gt;&gt;&gt;             return &quot;Invalid key \&quot;\(key)\&quot;. Expected value of type \&quot;\(expected)\&quot;, found \&quot;\(found)\&quot;.&quot;<br>&gt;&gt;&gt;         case .MissingKey(let key):<br>&gt;&gt;&gt;             return &quot;Key \(key) not found.&quot;<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; Given this, one can decode JSON with the full support of native type inference and exception handling. But when working with the DSL, one would expect to be able to express this as a subscript on Dictionary, allowing the following:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; //...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Dictionary {<br>&gt;&gt;&gt;     public subscript&lt;T&gt;(key: Key) throws -&gt; T {<br>&gt;&gt;&gt;         guard let value = self[key] else {<br>&gt;&gt;&gt;             throw JSONError.MissingKey(&quot;\(key)&quot;)<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;         guard let ofType = value as? T else {<br>&gt;&gt;&gt;             throw JSONError.InvalidKey(key: &quot;\(key)&quot;, expectedType: T.self, foundType: value.dynamicType)<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;         return ofType<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; We believe this is an even more natural way to write these kinds of libraries in Swift and that bringing subscript member declarations up to par with functions is a useful addition to the language as a whole.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Add the ability to introduce new generic parameters and mark throws and rethrows on subscript members.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Detailed design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This change will modify and add the following productions in the Swift grammar<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; GRAMMAR OF A SUBSCRIPT DECLARATION<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; subscript-declaration → subscript-head subscript-result code-block<br>&gt;&gt;&gt; subscript-declaration → subscript-head subscript-result getter-setter-block<br>&gt;&gt;&gt; subscript-declaration → subscript-head subscript-result getter-setter-keyword-block<br>&gt;&gt;&gt; -subscript-head → attributes(opt) declaration-modifiers(opt) subscript parameter-clause<br>&gt;&gt;&gt; +subscript-head → attributes(opt) declaration-modifiers(opt) generic-parameter-clause(opt) subscript parameter-clause<br>&gt;&gt;&gt; +subscript-result → -&gt; attributes(opt) throws(opt) type<br>&gt;&gt;&gt; +subscript-result → -&gt; attributes(opt) rethrows(opt) type<br>&gt;&gt;&gt; Rationale<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On [Date], the core team decided to (TBD) this proposal.<br>&gt;&gt;&gt; When the core team makes a decision regarding this proposal,<br>&gt;&gt;&gt; their rationale for the decision will be written here.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160622/f34937e1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Proposal] Generic and `throw`ing subscripts</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>June 22, 2016 at 09:00:00pm</p></header><div class="content"><p>You’re right on the specifics, of course.<br></p><p>To be clear I am more concerned about accidental shadowing with such subscripts; picture starting initial development with only the generic subscript from the proposal, writing some code that uses it…and then at some later point in time importing a module that defines the `RawRepresentable` variant, which would subtly shift how your code got interpreted.<br></p><p>This isn’t anything that couldn’t happen today with plain-old functions, of course — and it can be worked around in various ways, if you know it happens — but given the IMHO much higher likelihood of &quot;name collisions” (you’re correct you can label the subscript arguments, but I doubt most subscripts will opt to do so)…it seems far likelier we’ll see resolution-modifying collisions under a proposal like this, should it be introduced.<br></p><p>But I could be very wrong, and in any case this proposal should probably wait until at least August, as per suggestion.<br></p><p>&gt; On Jun 22, 2016, at 9:29 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jun 22, 2016, at 9:11 AM, plx via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 22, 2016, at 8:28 AM, T.J. Usiyan &lt;griotspeak at gmail.com &lt;mailto:griotspeak at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; plx: wouldn&#39;t the same overload resolution strategy be appropriate here? &quot;most specific choice, otherwise diagnostic”<br>&gt;&gt; <br>&gt;&gt; I’d assume it’d be good enough for most cases, certainly; I’d love to turn out to be needlessly scaremongering here, too.<br>&gt;&gt; <br>&gt;&gt; But (hopefully unintentionally!) it seems like you could easily wind up with scenarios like this:<br>&gt;&gt; <br>&gt;&gt;   // from proposal:<br>&gt;&gt;   public subscript&lt;T&gt;(key: Key) throws -&gt; T {<br>&gt;&gt;     guard let value = self[key] else { throw ... }<br>&gt;&gt;     guard let ofType = value as? T else { throw ... }<br>&gt;&gt;     return ofType<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   // an annoying addition:<br>&gt;&gt;   public subscript&lt;T:RawRepresentable&gt;(key: Key) throws -&gt; T {<br>&gt;&gt;     guard let v = self[key] else { throw ... }<br>&gt;&gt;     guard let rawValue = v as? T.RawValue else { throw ... }<br>&gt;&gt;     guard let converted = T(rawValue: rawValue) else { throw ... }<br>&gt;&gt;     return converted<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   // assume `Foo:RawRepresentable`:<br>&gt;&gt;   let foo: Foo = json[&quot;foo&quot;]<br>&gt;&gt; <br>&gt;&gt; …and similar, where I’d assume the `T:RawRepresentable` would “win”, but I’m not sure *how* you could force use of the *other* subscript in the above.<br>&gt;&gt; <br>&gt;&gt; This isn’t really a new problem, but it seems likelier to be encountered if generic subscripts become allowed, due to all subscripts having the same “name”.<br>&gt; <br>&gt; This isn’t exactly true.  External argument labels are considered part of the “name” in Swift.  Subscripts parameters don’t get external labels automatically like other functions / methods do, but you can still add one if you *want* the ability to disambiguate.  <br>&gt; <br>&gt; Of course this won’t help if you require the ability to use both subscripts without a label but is worth noting.  It is also worth noting that this behavior is no different from that of any other function or method - if the name (including external argument labels) matches the most specific overload will always be selected.<br>&gt; <br>&gt; One way to make your example work properly when `T` is `RawRepresentable` and the dictionary actually contains an instance of `T` is to add an extra check for that case:<br>&gt; <br>&gt;   public subscript&lt;T:RawRepresentable&gt;(key: Key) throws -&gt; T {<br>&gt;     guard let v = self[key] else { throw … }<br>&gt; <br>&gt;     // extra check here in case the value is *already* T and therefore does not require conversion.<br>&gt;     if let value = v as? T { return value }<br>&gt; <br>&gt;     guard let rawValue = v as? T.RawValue else { throw ... }<br>&gt;     guard let converted = T(rawValue: rawValue) else { throw ... }<br>&gt;     return converted<br>&gt;   }<br>&gt; <br>&gt;&gt; <br>&gt;&gt; But again I’d like to be wrong about the issue (or at least the severity).<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; separately:<br>&gt;&gt;&gt; Are there any subscripts in the standard library that would be throwing/generic but can&#39;t be?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Wed, Jun 22, 2016 at 9:13 AM, plx via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; Prefacing the below with a “I am well-aware this proposal likely won’t make it into Swift 3”:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A feature like this would be nice to use, but before I could get behind any proposal along these lines it I’d want to see it include an explicit strategy for disambiguation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; EG: in your example, your generic subscript uses `self[key]`, and presumably expects that to use the “original” subscript…and not the generic subscript being defined.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think that’s reasonable in that specific case, but it doesn’t seem unreasonable to anticipate this proposal introducing ambiguities that would need explicit disambiguation…and for which explicit type annotation may not always be adequate to resolve (I could be wrong here, though). <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This would need addressing (either showing they won’t be an issue, or providing a reliable disambiguation mechanism).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Relatedly, in-re: “rethrows”: if the syntax supported it, this kind of thing would be another way of tackling the &quot;JSON problem&quot;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   subscript&lt;T&gt;(key: Key, transform: (Value) throws -&gt; T) rethrows -&gt; T {<br>&gt;&gt;&gt;     guard let value = self[key] else { throw JSON.MissingKey(…) }<br>&gt;&gt;&gt;     return try transform(value)<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; …so that e.g. you can write typical parsing-code as<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   let asUserID = UserID.init(untrustedString:) // &lt;- assume this is a &quot;throwing constructor&quot;<br>&gt;&gt;&gt;   let sender = try json[“sender”,asUserID] <br>&gt;&gt;&gt;   let recipient = try json[“recipient”,asUserID]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; …(modulo any syntax errors, etc.), which would benefit from a `rethrows` declaration.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That’s my 2c; thankfully (IMHO) there’s clearly a lot of time for this proposal to simmer.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 20, 2016, at 1:10 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Good morning all.  Attached is the proposal Harlan Haskins and I will be submitting shortly about adding generic and `throw`ing subscript declarations to the language.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Generic and Throwing Subscripts<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>&gt;&gt;&gt;&gt; Author(s): Harlan Haskins &lt;https://github.com/harlanhaskins&gt; and Robert Widmann &lt;https://github.com/codafi&gt;<br>&gt;&gt;&gt;&gt; Status: Awaiting review &lt;https://github.com/typelift/SwiftCheck/pull/168#rationale&gt;<br>&gt;&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Currently, subscripts cannot be declared [re]throws and cannot declare new generic parameters.<br>&gt;&gt;&gt;&gt; There isn&#39;t a clear reason why they aren&#39;t as capable as full-fledged functions, so we propose<br>&gt;&gt;&gt;&gt; adding generic constraints and throwing semantics to subscripts.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On the throwing side, currently there are two ways to express a failing subscript:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Return an Optional, failing with nil.<br>&gt;&gt;&gt;&gt; Call fatalError(_:) on failure.<br>&gt;&gt;&gt;&gt; Both of these throw out useful information about the cause of the underlying error that using Swift&#39;s error handling mechanism can otherwise provide.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As for generics, to take an example, it has become a common pattern among JSON decoding DSL libraries to express a throwing generic extension on Dictionary like so<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension Dictionary {<br>&gt;&gt;&gt;&gt;     public func parse&lt;T&gt;(key: Key) throws -&gt; T {<br>&gt;&gt;&gt;&gt;         guard let value = self[key] else {<br>&gt;&gt;&gt;&gt;             throw JSONError.MissingKey(&quot;\(key)&quot;)<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;         guard let ofType = value as? T else {<br>&gt;&gt;&gt;&gt;             throw JSONError.InvalidKey(key: &quot;\(key)&quot;, expectedType: T.self, foundType: value.dynamicType)<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;         return ofType<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; public enum JSONError: ErrorType, CustomStringConvertible {<br>&gt;&gt;&gt;&gt;     case InvalidKey(key: String, expectedType: Any.Type, foundType: Any.Type)<br>&gt;&gt;&gt;&gt;     case MissingKey(String)<br>&gt;&gt;&gt;&gt;     public var description: String {<br>&gt;&gt;&gt;&gt;         switch self {<br>&gt;&gt;&gt;&gt;         case .InvalidKey(let key, let expected, let found):<br>&gt;&gt;&gt;&gt;             return &quot;Invalid key \&quot;\(key)\&quot;. Expected value of type \&quot;\(expected)\&quot;, found \&quot;\(found)\&quot;.&quot;<br>&gt;&gt;&gt;&gt;         case .MissingKey(let key):<br>&gt;&gt;&gt;&gt;             return &quot;Key \(key) not found.&quot;<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; Given this, one can decode JSON with the full support of native type inference and exception handling. But when working with the DSL, one would expect to be able to express this as a subscript on Dictionary, allowing the following:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension Dictionary {<br>&gt;&gt;&gt;&gt;     public subscript&lt;T&gt;(key: Key) throws -&gt; T {<br>&gt;&gt;&gt;&gt;         guard let value = self[key] else {<br>&gt;&gt;&gt;&gt;             throw JSONError.MissingKey(&quot;\(key)&quot;)<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;         guard let ofType = value as? T else {<br>&gt;&gt;&gt;&gt;             throw JSONError.InvalidKey(key: &quot;\(key)&quot;, expectedType: T.self, foundType: value.dynamicType)<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;         return ofType<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; We believe this is an even more natural way to write these kinds of libraries in Swift and that bringing subscript member declarations up to par with functions is a useful addition to the language as a whole.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Add the ability to introduce new generic parameters and mark throws and rethrows on subscript members.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Detailed design<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This change will modify and add the following productions in the Swift grammar<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; GRAMMAR OF A SUBSCRIPT DECLARATION<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; subscript-declaration → subscript-head subscript-result code-block<br>&gt;&gt;&gt;&gt; subscript-declaration → subscript-head subscript-result getter-setter-block<br>&gt;&gt;&gt;&gt; subscript-declaration → subscript-head subscript-result getter-setter-keyword-block<br>&gt;&gt;&gt;&gt; -subscript-head → attributes(opt) declaration-modifiers(opt) subscript parameter-clause<br>&gt;&gt;&gt;&gt; +subscript-head → attributes(opt) declaration-modifiers(opt) generic-parameter-clause(opt) subscript parameter-clause<br>&gt;&gt;&gt;&gt; +subscript-result → -&gt; attributes(opt) throws(opt) type<br>&gt;&gt;&gt;&gt; +subscript-result → -&gt; attributes(opt) rethrows(opt) type<br>&gt;&gt;&gt;&gt; Rationale<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On [Date], the core team decided to (TBD) this proposal.<br>&gt;&gt;&gt;&gt; When the core team makes a decision regarding this proposal,<br>&gt;&gt;&gt;&gt; their rationale for the decision will be written here.<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160622/a02c04c0/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
