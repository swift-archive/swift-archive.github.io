<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4090ad26a70acd97d197ac8b732a520c?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>David Beck</string> &lt;david at davidbeck.co&gt;<p>September 16, 2016 at 03:00:00pm</p></header><div class="content"><p>Yeah, I figured it had probably come up before since I don’t follow evolution that closely, but it is, in my opinion and experience, Swift’s last pitfall. So many other pitfalls from ObjC and other languages have been solved with Swift, including this exact one (when it comes to subclassing). If we are going to say that it is a big enough problem to solve with a language feature for subclasses, it really seems like it would make sense to solve it for protocol conformance.<br></p><p>&gt; On Sep 16, 2016, at 4:08 PM, Xiaodi Wu via swift-evolution&lt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)&gt;wrote:<br>&gt; &gt; <br>&gt; &gt; We&#39;ve had this discussion on the list multiple times already. The gist of the difficulty here is that most proposals for a mandatory keyword don&#39;t permit retroactive modeling, so it&#39;s a no-go. On the other hand, the core team seems to take a dim view to optional syntax, since that&#39;s more in the ballpark of linters.<br>&gt; Numerous solutions to your objection have been proposed; you always simply dismiss all of them in favor of your dogmatic stance. It’s really quite tiring. You can have this and support retroactive modeling; you just might need to have a separate syntax for retroactive conformances. You keep bringing that up as a hard-and-fast objection, but you know what? Maybe retroactive conformancesshouldhave a separate syntax, because they’re not saying the same thing! One is saying &quot;here are some methods that will make this type conform to this protocol”, where the other is saying “this type already has the methods that conform to this protocol somewhere.” These are not the same thing, and it might be confusing to see a conformance declaration and assume it’s the former when it’s actually the latter, and then have trouble finding the conformances. Maybe it would actually make your code clearer if retroactive conformances were required to declare “this method exists somewhere else already.” Maybe you could even command-click on it and jump to the actual declaration. Anything would be better than the current situation, because:<br>&gt; <br>&gt; The reason this keeps coming up is because it’s a real problem. I myself have started taking up the practice of always using copy-and-paste to declare conformances to protocols, because otherwise the chances of mistyping something and having the bug not manifest itself until runtime is simply too high. This is not a “linter” problem; this affects basic functionality and makes protocols, honestly, really dangerous to use. For a language that bills itself as “protocol-oriented”, it’s really quite damning that its protocol support is this brittle and fragile compared to its support for traditional inheritance. I’ve been bitten by this enough times by now to somewhat regret the decision to go with a protocol-based design. This is a real shame because conceptually, the idea of Swift’s protocol-based design is really cool.<br>&gt; <br>&gt; Charles<br>&gt; <br>&gt; <br>&gt; <br>&gt;  <br></p><p><br>David Beck<br>http://davidbeck.co<br>http://twitter.com/davbeck<br>http://facebook.com/davbeck<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160916/698e203a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/86db9f016890afc3f0fbac377c7128d8?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>David Goodine</string> &lt;dmgoodine at gmail.com&gt;<p>September 16, 2016 at 07:00:00pm</p></header><div class="content"><p>I&#39;m not familiar with all of the discussions in other threads relating to this issue that some are here, so forgive me if I&#39;m running over old ground.<br></p><p>Looking back at the original use case that David B. posted my first instinct was that this is a case that would best be solved by adding a compiler warning/error based on any function signature that matches a protocol signature but differs in the types.<br></p><p>My opinion is that naming a function that is so similar to a protocol function but clearly has a different signature is a bad idea and at least should be a warning. If Swift wants to be opinionated about it, it could become an error.<br></p><p>But looking at Vladimir&#39;s response, one thing that caught my interest was the idea of an &#39;implements&#39; keyword. I think it might be a good addition to the language because it a) avoids this whole class of programming mistakes and, more importantly, b) strengthens the &#39;intention&#39; of the programmer implementing the protocol, similarly to the way &#39;override&#39; works for inherited functions.<br></p><p>One of the things I really like about Swift is that in many cases it requires programmers to explicitly state their intent when writing code (i.e. override). I think Vladimir&#39;s suggestion could do the same for protocols and should be considered. <br></p><p>Sent from my iPhone<br></p><p>&gt; On Sep 16, 2016, at 6:28 PM, David Beck via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Yeah, I figured it had probably come up before since I don’t follow evolution that closely, but it is, in my opinion and experience, Swift’s last pitfall. So many other pitfalls from ObjC and other languages have been solved with Swift, including this exact one (when it comes to subclassing). If we are going to say that it is a big enough problem to solve with a language feature for subclasses, it really seems like it would make sense to solve it for protocol conformance.<br>&gt; <br>&gt; &gt; On Sep 16, 2016, at 4:08 PM, Xiaodi Wu via swift-evolution&lt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)&gt;wrote:<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; We&#39;ve had this discussion on the list multiple times already. The gist of the difficulty here is that most proposals for a mandatory keyword don&#39;t permit retroactive modeling, so it&#39;s a no-go. On the other hand, the core team seems to take a dim view to optional syntax, since that&#39;s more in the ballpark of linters.<br>&gt; &gt; Numerous solutions to your objection have been proposed; you always simply dismiss all of them in favor of your dogmatic stance. It’s really quite tiring. You can have this and support retroactive modeling; you just might need to have a separate syntax for retroactive conformances. You keep bringing that up as a hard-and-fast objection, but you know what? Maybe retroactive conformancesshouldhave a separate syntax, because they’re not saying the same thing! One is saying &quot;here are some methods that will make this type conform to this protocol”, where the other is saying “this type already has the methods that conform to this protocol somewhere.” These are not the same thing, and it might be confusing to see a conformance declaration and assume it’s the former when it’s actually the latter, and then have trouble finding the conformances. Maybe it would actually make your code clearer if retroactive conformances were required to declare “this method exists somewhere else already.” Maybe you could even command-click on it and jump to the actual declaration. Anything would be better than the current situation, because:<br>&gt; &gt; <br>&gt; &gt; The reason this keeps coming up is because it’s a real problem. I myself have started taking up the practice of always using copy-and-paste to declare conformances to protocols, because otherwise the chances of mistyping something and having the bug not manifest itself until runtime is simply too high. This is not a “linter” problem; this affects basic functionality and makes protocols, honestly, really dangerous to use. For a language that bills itself as “protocol-oriented”, it’s really quite damning that its protocol support is this brittle and fragile compared to its support for traditional inheritance. I’ve been bitten by this enough times by now to somewhat regret the decision to go with a protocol-based design. This is a real shame because conceptually, the idea of Swift’s protocol-based design is really cool.<br>&gt; &gt; <br>&gt; &gt; Charles<br>&gt; &gt; <br>&gt; &gt; <br>&gt; &gt; <br>&gt; &gt;  <br>&gt; <br>&gt; <br>&gt; David Beck<br>&gt; http://davidbeck.co<br>&gt; http://twitter.com/davbeck<br>&gt; http://facebook.com/davbeck<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160916/203cd6c8/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
