<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Completing Generics] Completing protocol extension diagnostics</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March  3, 2016 at 04:00:00pm</p></header><div class="content"><p>Under the umbrella of completing generics, I think we should make room for improving our diagnostics around protocol extensions. They&#39;re a well-received feature, but they introduce a lot of surprising behavior, and introduce opportunity for subtle bugs. We didn&#39;t have time to put much diagnostic work in last year, but now that users have had time to work with the feature, we have evidence of some of the more surprising and problematic behavior. Among the most common things we&#39;ve seen reported:<br></p><p>A) When a protocol requirement has an extension implementation requirement available, we&#39;ll silently ignore when a conforming type attempts to conform to the protocol but misses, by type or spelling:<br></p><p>protocol Channel {<br>  func receive() -&gt; NSData<br>}<br>extension Channel {<br>  func receive() -&gt; NSData { return NSData() }<br>}<br></p><p>// Silently fails to replace the default implementation:<br>struct ClumsyChannel: Channel {<br>  // Wrong spelling<br>  func recieve() -&gt; NSData { return NSData(bytes: &quot;oops&quot;, length: 4) }<br>  // Wrong return type<br>  func receive() -&gt; [UInt8] { return Array(&quot;whoopsie&quot;.utf8) }<br>  // Wrong throwiness<br>  func receive() throws -&gt; NSData { throw &quot;doh&quot; }<br>}<br></p><p>B) Protocol requirements aren&#39;t real class members, and can&#39;t be overridden by subclasses unless the base class satisfies the requirement with one of its own methods rather than with a protocol extension method, but we silently allow subclasses to shadow:<br></p><p>class BaseChannel: Channel { } // gets default imp from extension<br></p><p>class SubChannel: BaseChannel {<br>  // Doesn&#39;t &#39;override&#39; protocol requirement; silently shadows it<br>  func receive() -&gt; NSData { return NSData(bytes: &quot;oof&quot;, length: 3) }<br>}<br></p><p>C) Similarly, protocol extension methods aren&#39;t protocol requirements, so extension methods that don&#39;t match a requirement can&#39;t be specialized in a way available to generic code, but we silently allow concrete type implementations to shadow:<br></p><p>extension Channel {<br>  func receiveAsString() -&gt; String {<br>    return String(data: receive(), encoding: NSUTF8Encoding)<br>  }<br>}<br></p><p>struct StringyChannel {<br>  func receive() -&gt; NSData { return NSData(bytes: &quot;data&quot;, 4) }<br>  // Does not affect generic code calling receiveAsString<br>  func receiveAsString() -&gt; String { return &quot;string&quot; }<br>}<br></p><p>func foo&lt;T: Channel&gt;(chan: T) {<br>  print(chan.receiveAsString())<br>}<br></p><p>foo(StringyChannel()) // Prints &quot;data&quot;<br></p><p>(B) and (C) could be mitigated by shadowing warnings, and we&#39;ve also floated ideas for making them behave as intended, by implicitly forwarding protocol requirements into class methods to address (B) and/or introducing dynamic dispatch for protocol extensions to address (C). (A) is a bit trickier, since with overloading it&#39;s tricky to divine whether a declaration was really intended to match another one with a different type in isolation. We&#39;ve discussed a couple approaches to this problem:<br></p><p>- Adopting an explicit &#39;implements&#39; modifier, in the spirit of &#39;override&#39;, to mark a declaration as being intended to fulfill a requirement. This adds boilerplate we&#39;d like to avoid, and also interferes with retroactive modeling.<br>- Encourage &quot;one extension per conformance&quot; style, where each protocol conformance&#39;s requirements are defined in a dedicated extension. We can then warn about any declarations in an extension that don&#39;t satisfy a requirement:<br></p><p>struct InconsistentChannel {}<br></p><p>extension InconsistentChannel: Channel {<br>  func receive() -&gt; NSData { ... } // OK<br>  func recieve() -&gt; NSData { ... } // Warning: Declaration in conformance extension doesn&#39;t satisfy any requirements from &#39;Channel&#39;<br>  func receive() -&gt; NSData? { ... } // Warning<br>}<br></p><p>There are likely others too. It&#39;d be great if we could give users better guidance about this feature.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160303/a849d2db/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Completing Generics] Completing protocol extension diagnostics</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March  3, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; (B) and (C) could be mitigated by shadowing warnings, and we&#39;ve also floated ideas for making them behave as intended, by implicitly forwarding protocol requirements into class methods to address (B) and/or introducing dynamic dispatch for protocol extensions to address (C).<br></p><p>For what it&#39;s worth, I&#39;ve posted threads several times aimed at addressing (C) through better warnings and keywording, and each time I&#39;ve gotten lost of feedback from people who just want it dynamically dispatched. I wasn&#39;t aware of (B), but my guess is that I&#39;d have heard the same thing if I&#39;d brought it up.<br></p><p>&gt; - Adopting an explicit &#39;implements&#39; modifier, in the spirit of &#39;override&#39;, to mark a declaration as being intended to fulfill a requirement. This adds boilerplate we&#39;d like to avoid, and also interferes with retroactive modeling.<br></p><p>One possible way around that second issue is to permit you to mark the conformance itself as `implements` when you&#39;re doing retroactive modeling.<br></p><p>	protocol Arithmetic {<br>		func + (lhs: Self, rhs: Self) -&gt; Self<br>		func - (lhs: Self, rhs: Self) -&gt; Self<br>		func * (lhs: Self, rhs: Self) -&gt; Self<br>		func / (lhs: Self, rhs: Self) -&gt; Self<br>	}<br>	<br>	extension Int: implements Arithmetic {}<br>	extension Double: implements Arithmetic {}<br></p><p>If we just turned off the keyword requirement when the conformance was marked, people would abuse the feature, so perhaps it merely indicates that one or more members defined *outside* the current module implement the requirements. Any members *inside* the current module would still have to be individually marked. (And if the protocol wasn&#39;t at least partially implemented by external members, the `implements` in the conformance would be illegal.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[Completing Generics] Completing protocol extension diagnostics</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>March  4, 2016 at 07:00:00am</p></header><div class="content"><p>Brent, why is dynamic dispatching for protocol extension default implementations wrong in your mind? Wouldn&#39;t you agree that when static dispatching introduces such a side effect that it should not be automatically applied and perhaps a keyword should be added if you really wanted static dispatching nonetheless?<br></p><p>I think that code execution should not be affected by type casting, it feels like a very confusing part of the language.<br></p><p>Sent from my iPhone<br></p><p>On 4 Mar 2016, at 07:06, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; (B) and (C) could be mitigated by shadowing warnings, and we&#39;ve also floated ideas for making them behave as intended, by implicitly forwarding protocol requirements into class methods to address (B) and/or introducing dynamic dispatch for protocol extensions to address (C).<br>&gt; <br>&gt; For what it&#39;s worth, I&#39;ve posted threads several times aimed at addressing (C) through better warnings and keywording, and each time I&#39;ve gotten lost of feedback from people who just want it dynamically dispatched. I wasn&#39;t aware of (B), but my guess is that I&#39;d have heard the same thing if I&#39;d brought it up.<br>&gt; <br>&gt;&gt; - Adopting an explicit &#39;implements&#39; modifier, in the spirit of &#39;override&#39;, to mark a declaration as being intended to fulfill a requirement. This adds boilerplate we&#39;d like to avoid, and also interferes with retroactive modeling.<br>&gt; <br>&gt; One possible way around that second issue is to permit you to mark the conformance itself as `implements` when you&#39;re doing retroactive modeling.<br>&gt; <br>&gt;    protocol Arithmetic {<br>&gt;        func + (lhs: Self, rhs: Self) -&gt; Self<br>&gt;        func - (lhs: Self, rhs: Self) -&gt; Self<br>&gt;        func * (lhs: Self, rhs: Self) -&gt; Self<br>&gt;        func / (lhs: Self, rhs: Self) -&gt; Self<br>&gt;    }<br>&gt;    <br>&gt;    extension Int: implements Arithmetic {}<br>&gt;    extension Double: implements Arithmetic {}<br>&gt; <br>&gt; If we just turned off the keyword requirement when the conformance was marked, people would abuse the feature, so perhaps it merely indicates that one or more members defined *outside* the current module implement the requirements. Any members *inside* the current module would still have to be individually marked. (And if the protocol wasn&#39;t at least partially implemented by external members, the `implements` in the conformance would be illegal.)<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Completing Generics] Completing protocol extension diagnostics</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March  4, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; Brent, why is dynamic dispatching for protocol extension default implementations wrong in your mind? Wouldn&#39;t you agree that when static dispatching introduces such a side effect that it should not be automatically applied and perhaps a keyword should be added if you really wanted static dispatching nonetheless?<br>&gt; <br>&gt; I think that code execution should not be affected by type casting, it feels like a very confusing part of the language.<br></p><p>I don&#39;t think dynamic dispatch is wrong; I think it&#39;s a large and technically challenging change. So in the spirit of incrementalism, I was trying to make cautious proposals which kept existing semantics intact but made them clearer, in preparation for perhaps eventually introducing dynamic dispatch. (Basically, I suggested that non-overridable protocol extension members should be marked `final` and it should be illegal to shadow them.)<br></p><p>But the feedback I got indicated that most people wanted a more aggressive proposal which introduced dynamic dispatch immediately. That&#39;s much harder to propose because it touches on all sorts of runtime implementation details I know nothing about, so I didn&#39;t try to draft a proposal.<br></p><p>(You are, perhaps inadvertently, currently demonstrating exactly what happened in those previous threads!)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[Completing Generics] Completing protocol extension diagnostics</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>March  4, 2016 at 10:00:00am</p></header><div class="content"><p>Sorry, I understand and appreciate your pragmatism. Right now it feels very much like a fight to the ideological death between POP and OOP and it may get really bad results this way.<br></p><p>Sent from my iPhone<br></p><p>On 4 Mar 2016, at 08:58, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br></p><p>&gt;&gt; Brent, why is dynamic dispatching for protocol extension default implementations wrong in your mind? Wouldn&#39;t you agree that when static dispatching introduces such a side effect that it should not be automatically applied and perhaps a keyword should be added if you really wanted static dispatching nonetheless?<br>&gt;&gt; <br>&gt;&gt; I think that code execution should not be affected by type casting, it feels like a very confusing part of the language.<br>&gt; <br>&gt; I don&#39;t think dynamic dispatch is wrong; I think it&#39;s a large and technically challenging change. So in the spirit of incrementalism, I was trying to make cautious proposals which kept existing semantics intact but made them clearer, in preparation for perhaps eventually introducing dynamic dispatch. (Basically, I suggested that non-overridable protocol extension members should be marked `final` and it should be illegal to shadow them.)<br>&gt; <br>&gt; But the feedback I got indicated that most people wanted a more aggressive proposal which introduced dynamic dispatch immediately. That&#39;s much harder to propose because it touches on all sorts of runtime implementation details I know nothing about, so I didn&#39;t try to draft a proposal.<br>&gt; <br>&gt; (You are, perhaps inadvertently, currently demonstrating exactly what happened in those previous threads!)<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Completing Generics] Completing protocol extension diagnostics</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>March 10, 2016 at 02:00:00pm</p></header><div class="content"><p>+1 to all of Goffredo&#39;s comments.<br></p><p>  -- Howard.<br></p><p>On 4 March 2016 at 18:41, Goffredo Marocchi via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Brent, why is dynamic dispatching for protocol extension default<br>&gt; implementations wrong in your mind? Wouldn&#39;t you agree that when static<br>&gt; dispatching introduces such a side effect that it should not be<br>&gt; automatically applied and perhaps a keyword should be added if you really<br>&gt; wanted static dispatching nonetheless?<br>&gt;<br>&gt; I think that code execution should not be affected by type casting, it<br>&gt; feels like a very confusing part of the language.<br>&gt;<br>&gt; Sent from my iPhone<br>&gt;<br>&gt; On 4 Mar 2016, at 07:06, Brent Royal-Gordon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; &gt;&gt; (B) and (C) could be mitigated by shadowing warnings, and we&#39;ve also<br>&gt; floated ideas for making them behave as intended, by implicitly forwarding<br>&gt; protocol requirements into class methods to address (B) and/or introducing<br>&gt; dynamic dispatch for protocol extensions to address (C).<br>&gt; &gt;<br>&gt; &gt; For what it&#39;s worth, I&#39;ve posted threads several times aimed at<br>&gt; addressing (C) through better warnings and keywording, and each time I&#39;ve<br>&gt; gotten lost of feedback from people who just want it dynamically<br>&gt; dispatched. I wasn&#39;t aware of (B), but my guess is that I&#39;d have heard the<br>&gt; same thing if I&#39;d brought it up.<br>&gt; &gt;<br>&gt; &gt;&gt; - Adopting an explicit &#39;implements&#39; modifier, in the spirit of<br>&gt; &#39;override&#39;, to mark a declaration as being intended to fulfill a<br>&gt; requirement. This adds boilerplate we&#39;d like to avoid, and also interferes<br>&gt; with retroactive modeling.<br>&gt; &gt;<br>&gt; &gt; One possible way around that second issue is to permit you to mark the<br>&gt; conformance itself as `implements` when you&#39;re doing retroactive modeling.<br>&gt; &gt;<br>&gt; &gt;    protocol Arithmetic {<br>&gt; &gt;        func + (lhs: Self, rhs: Self) -&gt; Self<br>&gt; &gt;        func - (lhs: Self, rhs: Self) -&gt; Self<br>&gt; &gt;        func * (lhs: Self, rhs: Self) -&gt; Self<br>&gt; &gt;        func / (lhs: Self, rhs: Self) -&gt; Self<br>&gt; &gt;    }<br>&gt; &gt;<br>&gt; &gt;    extension Int: implements Arithmetic {}<br>&gt; &gt;    extension Double: implements Arithmetic {}<br>&gt; &gt;<br>&gt; &gt; If we just turned off the keyword requirement when the conformance was<br>&gt; marked, people would abuse the feature, so perhaps it merely indicates that<br>&gt; one or more members defined *outside* the current module implement the<br>&gt; requirements. Any members *inside* the current module would still have to<br>&gt; be individually marked. (And if the protocol wasn&#39;t at least partially<br>&gt; implemented by external members, the `implements` in the conformance would<br>&gt; be illegal.)<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Brent Royal-Gordon<br>&gt; &gt; Architechies<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160310/55d69f5a/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Completing Generics] Completing protocol extension diagnostics</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>March  4, 2016 at 11:00:00am</p></header><div class="content"><p>I like the idea of encouraging &quot;one extension per conformance&quot;, though I’d maybe adjust it to simply “add conformance through extension”, as sometimes it makes sense for a single extension to add conformance to multiple protocols at a time, for example an extension to add conformance to CustomDebugStringConvertible and CustomStringConvertible as a single item. I’m not sure if you intended to prevent that, but I think it should still be possible to allow multiple protocols with the same basic concept that conformance must be exact.<br></p><p>Regarding keyword usage for implementations, I’d say that we should have the override keyword at least on methods that shadow default implementations provided for protocol methods, as this should make things clearer. It could also help to tidy up documentation as currently default implementations that have been shadowed still show up in many places, even though they’re no longer strictly relevant.<br></p><p>&gt; On 4 Mar 2016, at 00:08, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Under the umbrella of completing generics, I think we should make room for improving our diagnostics around protocol extensions. They&#39;re a well-received feature, but they introduce a lot of surprising behavior, and introduce opportunity for subtle bugs. We didn&#39;t have time to put much diagnostic work in last year, but now that users have had time to work with the feature, we have evidence of some of the more surprising and problematic behavior. Among the most common things we&#39;ve seen reported:<br>&gt; <br>&gt; A) When a protocol requirement has an extension implementation requirement available, we&#39;ll silently ignore when a conforming type attempts to conform to the protocol but misses, by type or spelling:<br>&gt; <br>&gt; protocol Channel {<br>&gt;   func receive() -&gt; NSData<br>&gt; }<br>&gt; extension Channel {<br>&gt;   func receive() -&gt; NSData { return NSData() }<br>&gt; }<br>&gt; <br>&gt; // Silently fails to replace the default implementation:<br>&gt; struct ClumsyChannel: Channel {<br>&gt;   // Wrong spelling<br>&gt;   func recieve() -&gt; NSData { return NSData(bytes: &quot;oops&quot;, length: 4) }<br>&gt;   // Wrong return type<br>&gt;   func receive() -&gt; [UInt8] { return Array(&quot;whoopsie&quot;.utf8) }<br>&gt;   // Wrong throwiness<br>&gt;   func receive() throws -&gt; NSData { throw &quot;doh&quot; }<br>&gt; }<br>&gt; <br>&gt; B) Protocol requirements aren&#39;t real class members, and can&#39;t be overridden by subclasses unless the base class satisfies the requirement with one of its own methods rather than with a protocol extension method, but we silently allow subclasses to shadow:<br>&gt; <br>&gt; class BaseChannel: Channel { } // gets default imp from extension<br>&gt; <br>&gt; class SubChannel: BaseChannel {<br>&gt;   // Doesn&#39;t &#39;override&#39; protocol requirement; silently shadows it<br>&gt;   func receive() -&gt; NSData { return NSData(bytes: &quot;oof&quot;, length: 3) }<br>&gt; }<br>&gt; <br>&gt; C) Similarly, protocol extension methods aren&#39;t protocol requirements, so extension methods that don&#39;t match a requirement can&#39;t be specialized in a way available to generic code, but we silently allow concrete type implementations to shadow:<br>&gt; <br>&gt; extension Channel {<br>&gt;   func receiveAsString() -&gt; String {<br>&gt;     return String(data: receive(), encoding: NSUTF8Encoding)<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; struct StringyChannel {<br>&gt;   func receive() -&gt; NSData { return NSData(bytes: &quot;data&quot;, 4) }<br>&gt;   // Does not affect generic code calling receiveAsString<br>&gt;   func receiveAsString() -&gt; String { return &quot;string&quot; }<br>&gt; }<br>&gt; <br>&gt; func foo&lt;T: Channel&gt;(chan: T) {<br>&gt;   print(chan.receiveAsString())<br>&gt; }<br>&gt; <br>&gt; foo(StringyChannel()) // Prints &quot;data&quot;<br>&gt; <br>&gt; (B) and (C) could be mitigated by shadowing warnings, and we&#39;ve also floated ideas for making them behave as intended, by implicitly forwarding protocol requirements into class methods to address (B) and/or introducing dynamic dispatch for protocol extensions to address (C). (A) is a bit trickier, since with overloading it&#39;s tricky to divine whether a declaration was really intended to match another one with a different type in isolation. We&#39;ve discussed a couple approaches to this problem:<br>&gt; <br>&gt; - Adopting an explicit &#39;implements&#39; modifier, in the spirit of &#39;override&#39;, to mark a declaration as being intended to fulfill a requirement. This adds boilerplate we&#39;d like to avoid, and also interferes with retroactive modeling.<br>&gt; - Encourage &quot;one extension per conformance&quot; style, where each protocol conformance&#39;s requirements are defined in a dedicated extension. We can then warn about any declarations in an extension that don&#39;t satisfy a requirement:<br>&gt; <br>&gt; struct InconsistentChannel {}<br>&gt; <br>&gt; extension InconsistentChannel: Channel {<br>&gt;   func receive() -&gt; NSData { ... } // OK<br>&gt;   func recieve() -&gt; NSData { ... } // Warning: Declaration in conformance extension doesn&#39;t satisfy any requirements from &#39;Channel&#39;<br>&gt;   func receive() -&gt; NSData? { ... } // Warning<br>&gt; }<br>&gt; <br>&gt; There are likely others too. It&#39;d be great if we could give users better guidance about this feature.<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160304/8c9c3f4a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9fa0dab2b53704212f29f6c5b1eeee58?s=50"></div><header><strong>[Completing Generics] Completing protocol extension diagnostics</strong> from <string>Tim Schmelter</string> &lt;tschmelter at gmail.com&gt;<p>March  8, 2016 at 08:00:00am</p></header><div class="content"><p>If we adopt the &quot;one extension per conformance&quot; model, would the compiler<br>then warn us if we include, say, helper functions that exist only to aid in<br>that conformance (and would therefore be appropriate to include in the<br>extension)? Wouldn&#39;t that lead to polluting the main type with those helper<br>methods?<br></p><p>--T<br></p><p><br>On Fri, Mar 4, 2016 at 3:38 AM, Haravikk via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I like the idea of encouraging &quot;one extension per conformance&quot;, though I’d<br>&gt; maybe adjust it to simply “add conformance through extension”, as sometimes<br>&gt; it makes sense for a single extension to add conformance to multiple<br>&gt; protocols at a time, for example an extension to add conformance to<br>&gt; CustomDebugStringConvertible and CustomStringConvertible as a single item.<br>&gt; I’m not sure if you intended to prevent that, but I think it should still<br>&gt; be possible to allow multiple protocols with the same basic concept that<br>&gt; conformance must be exact.<br>&gt;<br>&gt; Regarding keyword usage for implementations, I’d say that we should have<br>&gt; the override keyword at least on methods that shadow default<br>&gt; implementations provided for protocol methods, as this should make things<br>&gt; clearer. It could also help to tidy up documentation as currently default<br>&gt; implementations that have been shadowed still show up in many places, even<br>&gt; though they’re no longer strictly relevant.<br>&gt;<br>&gt; On 4 Mar 2016, at 00:08, Joe Groff via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Under the umbrella of completing generics, I think we should make room for<br>&gt; improving our diagnostics around protocol extensions. They&#39;re a<br>&gt; well-received feature, but they introduce a lot of surprising behavior, and<br>&gt; introduce opportunity for subtle bugs. We didn&#39;t have time to put much<br>&gt; diagnostic work in last year, but now that users have had time to work with<br>&gt; the feature, we have evidence of some of the more surprising and<br>&gt; problematic behavior. Among the most common things we&#39;ve seen reported:<br>&gt;<br>&gt; A) When a protocol requirement has an extension implementation requirement<br>&gt; available, we&#39;ll silently ignore when a conforming type attempts to conform<br>&gt; to the protocol but misses, by type or spelling:<br>&gt;<br>&gt; protocol Channel {<br>&gt;   func receive() -&gt; NSData<br>&gt; }<br>&gt; extension Channel {<br>&gt;   func receive() -&gt; NSData { return NSData() }<br>&gt; }<br>&gt;<br>&gt; // Silently fails to replace the default implementation:<br>&gt; struct ClumsyChannel: Channel {<br>&gt;   // Wrong spelling<br>&gt;   func recieve() -&gt; NSData { return NSData(bytes: &quot;oops&quot;, length: 4) }<br>&gt;   // Wrong return type<br>&gt;   func receive() -&gt; [UInt8] { return Array(&quot;whoopsie&quot;.utf8) }<br>&gt;   // Wrong throwiness<br>&gt;   func receive() throws -&gt; NSData { throw &quot;doh&quot; }<br>&gt; }<br>&gt;<br>&gt; B) Protocol requirements aren&#39;t real class members, and can&#39;t be<br>&gt; overridden by subclasses unless the base class satisfies the requirement<br>&gt; with one of its own methods rather than with a protocol extension method,<br>&gt; but we silently allow subclasses to shadow:<br>&gt;<br>&gt; class BaseChannel: Channel { } // gets default imp from extension<br>&gt;<br>&gt; class SubChannel: BaseChannel {<br>&gt;   // Doesn&#39;t &#39;override&#39; protocol requirement; silently shadows it<br>&gt;   func receive() -&gt; NSData { return NSData(bytes: &quot;oof&quot;, length: 3) }<br>&gt; }<br>&gt;<br>&gt; C) Similarly, protocol extension methods aren&#39;t protocol requirements, so<br>&gt; extension methods that don&#39;t match a requirement can&#39;t be specialized in a<br>&gt; way available to generic code, but we silently allow concrete type<br>&gt; implementations to shadow:<br>&gt;<br>&gt; extension Channel {<br>&gt;   func receiveAsString() -&gt; String {<br>&gt;     return String(data: receive(), encoding: NSUTF8Encoding)<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; struct StringyChannel {<br>&gt;   func receive() -&gt; NSData { return NSData(bytes: &quot;data&quot;, 4) }<br>&gt;   // Does not affect generic code calling receiveAsString<br>&gt;   func receiveAsString() -&gt; String { return &quot;string&quot; }<br>&gt; }<br>&gt;<br>&gt; func foo&lt;T: Channel&gt;(chan: T) {<br>&gt;   print(chan.receiveAsString())<br>&gt; }<br>&gt;<br>&gt; foo(StringyChannel()) // Prints &quot;data&quot;<br>&gt;<br>&gt; (B) and (C) could be mitigated by shadowing warnings, and we&#39;ve also<br>&gt; floated ideas for making them behave as intended, by implicitly forwarding<br>&gt; protocol requirements into class methods to address (B) and/or introducing<br>&gt; dynamic dispatch for protocol extensions to address (C). (A) is a bit<br>&gt; trickier, since with overloading it&#39;s tricky to divine whether a<br>&gt; declaration was really intended to match another one with a different type<br>&gt; in isolation. We&#39;ve discussed a couple approaches to this problem:<br>&gt;<br>&gt; - Adopting an explicit &#39;implements&#39; modifier, in the spirit of &#39;override&#39;,<br>&gt; to mark a declaration as being intended to fulfill a requirement. This adds<br>&gt; boilerplate we&#39;d like to avoid, and also interferes with retroactive<br>&gt; modeling.<br>&gt; - Encourage &quot;one extension per conformance&quot; style, where each protocol<br>&gt; conformance&#39;s requirements are defined in a dedicated extension. We can<br>&gt; then warn about any declarations in an extension that don&#39;t satisfy a<br>&gt; requirement:<br>&gt;<br>&gt; struct InconsistentChannel {}<br>&gt;<br>&gt; extension InconsistentChannel: Channel {<br>&gt;   func receive() -&gt; NSData { ... } // OK<br>&gt;   func recieve() -&gt; NSData { ... } // Warning: Declaration in conformance<br>&gt; extension doesn&#39;t satisfy any requirements from &#39;Channel&#39;<br>&gt;   func receive() -&gt; NSData? { ... } // Warning<br>&gt; }<br>&gt;<br>&gt; There are likely others too. It&#39;d be great if we could give users better<br>&gt; guidance about this feature.<br>&gt;<br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160308/86c6b778/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Completing Generics] Completing protocol extension diagnostics</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>March  8, 2016 at 12:00:00pm</p></header><div class="content"><p>```<br>struct InconsistentChannel {}<br></p><p>extension InconsistentChannel: Channel {<br>  func receive() -&gt; NSData { ... } // OK<br>  func recieve() -&gt; NSData { ... } // Warning: Declaration in conformance<br>extension doesn&#39;t satisfy any requirements from &#39;Channel&#39;<br>  func doSomething() -&gt; NSData? { ... } // Warning<br>}<br>```<br></p><p>Would/Could the warning be silenced if `doSomething()` is called by one of<br>the methods that do satisfy requirements? (I know that it is possible, is<br>it reasonable?)<br></p><p>TJ<br></p><p><br>On Tue, Mar 8, 2016 at 11:34 AM, Tim Schmelter via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; If we adopt the &quot;one extension per conformance&quot; model, would the compiler<br>&gt; then warn us if we include, say, helper functions that exist only to aid in<br>&gt; that conformance (and would therefore be appropriate to include in the<br>&gt; extension)? Wouldn&#39;t that lead to polluting the main type with those helper<br>&gt; methods?<br>&gt;<br>&gt; --T<br>&gt;<br>&gt;<br>&gt; On Fri, Mar 4, 2016 at 3:38 AM, Haravikk via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; I like the idea of encouraging &quot;one extension per conformance&quot;, though<br>&gt;&gt; I’d maybe adjust it to simply “add conformance through extension”, as<br>&gt;&gt; sometimes it makes sense for a single extension to add conformance to<br>&gt;&gt; multiple protocols at a time, for example an extension to add conformance<br>&gt;&gt; to CustomDebugStringConvertible and CustomStringConvertible as a single<br>&gt;&gt; item. I’m not sure if you intended to prevent that, but I think it should<br>&gt;&gt; still be possible to allow multiple protocols with the same basic concept<br>&gt;&gt; that conformance must be exact.<br>&gt;&gt;<br>&gt;&gt; Regarding keyword usage for implementations, I’d say that we should have<br>&gt;&gt; the override keyword at least on methods that shadow default<br>&gt;&gt; implementations provided for protocol methods, as this should make things<br>&gt;&gt; clearer. It could also help to tidy up documentation as currently default<br>&gt;&gt; implementations that have been shadowed still show up in many places, even<br>&gt;&gt; though they’re no longer strictly relevant.<br>&gt;&gt;<br>&gt;&gt; On 4 Mar 2016, at 00:08, Joe Groff via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Under the umbrella of completing generics, I think we should make room<br>&gt;&gt; for improving our diagnostics around protocol extensions. They&#39;re a<br>&gt;&gt; well-received feature, but they introduce a lot of surprising behavior, and<br>&gt;&gt; introduce opportunity for subtle bugs. We didn&#39;t have time to put much<br>&gt;&gt; diagnostic work in last year, but now that users have had time to work with<br>&gt;&gt; the feature, we have evidence of some of the more surprising and<br>&gt;&gt; problematic behavior. Among the most common things we&#39;ve seen reported:<br>&gt;&gt;<br>&gt;&gt; A) When a protocol requirement has an extension implementation<br>&gt;&gt; requirement available, we&#39;ll silently ignore when a conforming type<br>&gt;&gt; attempts to conform to the protocol but misses, by type or spelling:<br>&gt;&gt;<br>&gt;&gt; protocol Channel {<br>&gt;&gt;   func receive() -&gt; NSData<br>&gt;&gt; }<br>&gt;&gt; extension Channel {<br>&gt;&gt;   func receive() -&gt; NSData { return NSData() }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; // Silently fails to replace the default implementation:<br>&gt;&gt; struct ClumsyChannel: Channel {<br>&gt;&gt;   // Wrong spelling<br>&gt;&gt;   func recieve() -&gt; NSData { return NSData(bytes: &quot;oops&quot;, length: 4) }<br>&gt;&gt;   // Wrong return type<br>&gt;&gt;   func receive() -&gt; [UInt8] { return Array(&quot;whoopsie&quot;.utf8) }<br>&gt;&gt;   // Wrong throwiness<br>&gt;&gt;   func receive() throws -&gt; NSData { throw &quot;doh&quot; }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; B) Protocol requirements aren&#39;t real class members, and can&#39;t be<br>&gt;&gt; overridden by subclasses unless the base class satisfies the requirement<br>&gt;&gt; with one of its own methods rather than with a protocol extension method,<br>&gt;&gt; but we silently allow subclasses to shadow:<br>&gt;&gt;<br>&gt;&gt; class BaseChannel: Channel { } // gets default imp from extension<br>&gt;&gt;<br>&gt;&gt; class SubChannel: BaseChannel {<br>&gt;&gt;   // Doesn&#39;t &#39;override&#39; protocol requirement; silently shadows it<br>&gt;&gt;   func receive() -&gt; NSData { return NSData(bytes: &quot;oof&quot;, length: 3) }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; C) Similarly, protocol extension methods aren&#39;t protocol requirements, so<br>&gt;&gt; extension methods that don&#39;t match a requirement can&#39;t be specialized in a<br>&gt;&gt; way available to generic code, but we silently allow concrete type<br>&gt;&gt; implementations to shadow:<br>&gt;&gt;<br>&gt;&gt; extension Channel {<br>&gt;&gt;   func receiveAsString() -&gt; String {<br>&gt;&gt;     return String(data: receive(), encoding: NSUTF8Encoding)<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; struct StringyChannel {<br>&gt;&gt;   func receive() -&gt; NSData { return NSData(bytes: &quot;data&quot;, 4) }<br>&gt;&gt;   // Does not affect generic code calling receiveAsString<br>&gt;&gt;   func receiveAsString() -&gt; String { return &quot;string&quot; }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; func foo&lt;T: Channel&gt;(chan: T) {<br>&gt;&gt;   print(chan.receiveAsString())<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; foo(StringyChannel()) // Prints &quot;data&quot;<br>&gt;&gt;<br>&gt;&gt; (B) and (C) could be mitigated by shadowing warnings, and we&#39;ve also<br>&gt;&gt; floated ideas for making them behave as intended, by implicitly forwarding<br>&gt;&gt; protocol requirements into class methods to address (B) and/or introducing<br>&gt;&gt; dynamic dispatch for protocol extensions to address (C). (A) is a bit<br>&gt;&gt; trickier, since with overloading it&#39;s tricky to divine whether a<br>&gt;&gt; declaration was really intended to match another one with a different type<br>&gt;&gt; in isolation. We&#39;ve discussed a couple approaches to this problem:<br>&gt;&gt;<br>&gt;&gt; - Adopting an explicit &#39;implements&#39; modifier, in the spirit of<br>&gt;&gt; &#39;override&#39;, to mark a declaration as being intended to fulfill a<br>&gt;&gt; requirement. This adds boilerplate we&#39;d like to avoid, and also interferes<br>&gt;&gt; with retroactive modeling.<br>&gt;&gt; - Encourage &quot;one extension per conformance&quot; style, where each protocol<br>&gt;&gt; conformance&#39;s requirements are defined in a dedicated extension. We can<br>&gt;&gt; then warn about any declarations in an extension that don&#39;t satisfy a<br>&gt;&gt; requirement:<br>&gt;&gt;<br>&gt;&gt; struct InconsistentChannel {}<br>&gt;&gt;<br>&gt;&gt; extension InconsistentChannel: Channel {<br>&gt;&gt;   func receive() -&gt; NSData { ... } // OK<br>&gt;&gt;   func recieve() -&gt; NSData { ... } // Warning: Declaration in conformance<br>&gt;&gt; extension doesn&#39;t satisfy any requirements from &#39;Channel&#39;<br>&gt;&gt;   func receive() -&gt; NSData? { ... } // Warning<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; There are likely others too. It&#39;d be great if we could give users better<br>&gt;&gt; guidance about this feature.<br>&gt;&gt;<br>&gt;&gt; -Joe<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160308/266f59e0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Completing Generics] Completing protocol extension diagnostics</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March  8, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Mar 8, 2016, at 9:24 AM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; ```<br>&gt; struct InconsistentChannel {}<br>&gt; <br>&gt; extension InconsistentChannel: Channel {<br>&gt;   func receive() -&gt; NSData { ... } // OK<br>&gt;   func recieve() -&gt; NSData { ... } // Warning: Declaration in conformance extension doesn&#39;t satisfy any requirements from &#39;Channel&#39;<br>&gt;   func doSomething() -&gt; NSData? { ... } // Warning<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; Would/Could the warning be silenced if `doSomething()` is called by one of the methods that do satisfy requirements? (I know that it is possible, is it reasonable?)<br></p><p>That&#39;s an interesting idea. It seems reasonable to me.<br></p><p>-Joe<br></p><p>&gt; TJ<br>&gt; <br>&gt; <br>&gt; On Tue, Mar 8, 2016 at 11:34 AM, Tim Schmelter via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; If we adopt the &quot;one extension per conformance&quot; model, would the compiler then warn us if we include, say, helper functions that exist only to aid in that conformance (and would therefore be appropriate to include in the extension)? Wouldn&#39;t that lead to polluting the main type with those helper methods?<br>&gt; <br>&gt; --T<br>&gt; <br>&gt; <br>&gt; On Fri, Mar 4, 2016 at 3:38 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; I like the idea of encouraging &quot;one extension per conformance&quot;, though I’d maybe adjust it to simply “add conformance through extension”, as sometimes it makes sense for a single extension to add conformance to multiple protocols at a time, for example an extension to add conformance to CustomDebugStringConvertible and CustomStringConvertible as a single item. I’m not sure if you intended to prevent that, but I think it should still be possible to allow multiple protocols with the same basic concept that conformance must be exact.<br>&gt; <br>&gt; Regarding keyword usage for implementations, I’d say that we should have the override keyword at least on methods that shadow default implementations provided for protocol methods, as this should make things clearer. It could also help to tidy up documentation as currently default implementations that have been shadowed still show up in many places, even though they’re no longer strictly relevant.<br>&gt; <br>&gt;&gt; On 4 Mar 2016, at 00:08, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Under the umbrella of completing generics, I think we should make room for improving our diagnostics around protocol extensions. They&#39;re a well-received feature, but they introduce a lot of surprising behavior, and introduce opportunity for subtle bugs. We didn&#39;t have time to put much diagnostic work in last year, but now that users have had time to work with the feature, we have evidence of some of the more surprising and problematic behavior. Among the most common things we&#39;ve seen reported:<br>&gt;&gt; <br>&gt;&gt; A) When a protocol requirement has an extension implementation requirement available, we&#39;ll silently ignore when a conforming type attempts to conform to the protocol but misses, by type or spelling:<br>&gt;&gt; <br>&gt;&gt; protocol Channel {<br>&gt;&gt;   func receive() -&gt; NSData<br>&gt;&gt; }<br>&gt;&gt; extension Channel {<br>&gt;&gt;   func receive() -&gt; NSData { return NSData() }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // Silently fails to replace the default implementation:<br>&gt;&gt; struct ClumsyChannel: Channel {<br>&gt;&gt;   // Wrong spelling<br>&gt;&gt;   func recieve() -&gt; NSData { return NSData(bytes: &quot;oops&quot;, length: 4) }<br>&gt;&gt;   // Wrong return type<br>&gt;&gt;   func receive() -&gt; [UInt8] { return Array(&quot;whoopsie&quot;.utf8) }<br>&gt;&gt;   // Wrong throwiness<br>&gt;&gt;   func receive() throws -&gt; NSData { throw &quot;doh&quot; }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; B) Protocol requirements aren&#39;t real class members, and can&#39;t be overridden by subclasses unless the base class satisfies the requirement with one of its own methods rather than with a protocol extension method, but we silently allow subclasses to shadow:<br>&gt;&gt; <br>&gt;&gt; class BaseChannel: Channel { } // gets default imp from extension<br>&gt;&gt; <br>&gt;&gt; class SubChannel: BaseChannel {<br>&gt;&gt;   // Doesn&#39;t &#39;override&#39; protocol requirement; silently shadows it<br>&gt;&gt;   func receive() -&gt; NSData { return NSData(bytes: &quot;oof&quot;, length: 3) }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; C) Similarly, protocol extension methods aren&#39;t protocol requirements, so extension methods that don&#39;t match a requirement can&#39;t be specialized in a way available to generic code, but we silently allow concrete type implementations to shadow:<br>&gt;&gt; <br>&gt;&gt; extension Channel {<br>&gt;&gt;   func receiveAsString() -&gt; String {<br>&gt;&gt;     return String(data: receive(), encoding: NSUTF8Encoding)<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct StringyChannel {<br>&gt;&gt;   func receive() -&gt; NSData { return NSData(bytes: &quot;data&quot;, 4) }<br>&gt;&gt;   // Does not affect generic code calling receiveAsString<br>&gt;&gt;   func receiveAsString() -&gt; String { return &quot;string&quot; }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func foo&lt;T: Channel&gt;(chan: T) {<br>&gt;&gt;   print(chan.receiveAsString())<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; foo(StringyChannel()) // Prints &quot;data&quot;<br>&gt;&gt; <br>&gt;&gt; (B) and (C) could be mitigated by shadowing warnings, and we&#39;ve also floated ideas for making them behave as intended, by implicitly forwarding protocol requirements into class methods to address (B) and/or introducing dynamic dispatch for protocol extensions to address (C). (A) is a bit trickier, since with overloading it&#39;s tricky to divine whether a declaration was really intended to match another one with a different type in isolation. We&#39;ve discussed a couple approaches to this problem:<br>&gt;&gt; <br>&gt;&gt; - Adopting an explicit &#39;implements&#39; modifier, in the spirit of &#39;override&#39;, to mark a declaration as being intended to fulfill a requirement. This adds boilerplate we&#39;d like to avoid, and also interferes with retroactive modeling.<br>&gt;&gt; - Encourage &quot;one extension per conformance&quot; style, where each protocol conformance&#39;s requirements are defined in a dedicated extension. We can then warn about any declarations in an extension that don&#39;t satisfy a requirement:<br>&gt;&gt; <br>&gt;&gt; struct InconsistentChannel {}<br>&gt;&gt; <br>&gt;&gt; extension InconsistentChannel: Channel {<br>&gt;&gt;   func receive() -&gt; NSData { ... } // OK<br>&gt;&gt;   func recieve() -&gt; NSData { ... } // Warning: Declaration in conformance extension doesn&#39;t satisfy any requirements from &#39;Channel&#39;<br>&gt;&gt;   func receive() -&gt; NSData? { ... } // Warning<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; There are likely others too. It&#39;d be great if we could give users better guidance about this feature.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160308/76e84197/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Completing Generics] Completing protocol extension diagnostics</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March  8, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; Would/Could the warning be silenced if `doSomething()` is called by one of the methods that do satisfy requirements? (I know that it is possible, is it reasonable?)<br></p><p>If the `scoped` proposal passes (note: I am still -1 on that proposal), that might be another criterion for permitting a non-conforming member in an extension.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Completing Generics] Completing protocol extension diagnostics</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>March  8, 2016 at 07:00:00pm</p></header><div class="content"><p>I strongly suggest against requiring the scope keyword. This would force<br>you to move a method *out* of the scope if you also wanted to use it<br>outside of the conforming extension, which seems needlessly punitive.<br></p><p>TJ<br></p><p>On Tue, Mar 8, 2016 at 6:48 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>wrote:<br></p><p>&gt; &gt; Would/Could the warning be silenced if `doSomething()` is called by one<br>&gt; of the methods that do satisfy requirements? (I know that it is possible,<br>&gt; is it reasonable?)<br>&gt;<br>&gt; If the `scoped` proposal passes (note: I am still -1 on that proposal),<br>&gt; that might be another criterion for permitting a non-conforming member in<br>&gt; an extension.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160308/985d48a5/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Completing Generics] Completing protocol extension diagnostics</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>March 10, 2016 at 02:00:00pm</p></header><div class="content"><p>For type A problems: why not require that you annotate with overload? In<br>Java they used to be like Swift; where a method that overrode an interface<br>declaration, no override was required. But they changed, due to these<br>problems, to always require override when implementing a previously<br>declared method, whether this was the first implementation of not. IE:<br></p><p>protocol Channel {<br>  func receive() -&gt; NSData<br>}<br></p><p>extension Channel {<br>  func receive() -&gt; NSData { return NSData() } // Error - no override and<br>declaration in protocol<br></p><p>  override func receive() -&gt; NSData { return NSData() } // OK - note<br>override<br>}<br></p><p>// Silently fails to replace the default implementation:<br>struct ClumsyChannel: Channel {<br>  override func recieve() -&gt; NSData { return NSData(bytes: &quot;oops&quot;, length:<br>4) } // Error - Wrong spelling<br></p><p>  override func receive() -&gt; [UInt8] { return Array(&quot;whoopsie&quot;.utf8) } //<br>Error - Wrong return type<br></p><p>  override func receive() throws -&gt; NSData { throw &quot;doh&quot; } // Error - Wrong<br>throwiness<br></p><p>  func receive() -&gt; NSData { return NSData(bytes: &quot;Forgot&quot;, length: 6) } //<br>Error - no override and declaration in protocol<br></p><p>  override func receive() -&gt; NSData { return NSData(bytes: &quot;OK&quot;, length: 2) }<br>// OK - note override<br>}<br></p><p><br>This implies that methods implemented in extensions gain dynamic dispatch;<br>which I believe is under consideration anyway.<br></p><p>As an aside: I think that protocol extensions are only popular because you<br>can&#39;t put bodies in protocols. If bodies are allowed, I would think that<br>extensions to protocols will become the exception rather than the rule.<br></p><p>  -- Howard.<br></p><p>On 4 March 2016 at 11:08, Joe Groff via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Under the umbrella of completing generics, I think we should make room for<br>&gt; improving our diagnostics around protocol extensions. They&#39;re a<br>&gt; well-received feature, but they introduce a lot of surprising behavior, and<br>&gt; introduce opportunity for subtle bugs. We didn&#39;t have time to put much<br>&gt; diagnostic work in last year, but now that users have had time to work with<br>&gt; the feature, we have evidence of some of the more surprising and<br>&gt; problematic behavior. Among the most common things we&#39;ve seen reported:<br>&gt;<br>&gt; A) When a protocol requirement has an extension implementation requirement<br>&gt; available, we&#39;ll silently ignore when a conforming type attempts to conform<br>&gt; to the protocol but misses, by type or spelling:<br>&gt;<br>&gt; protocol Channel {<br>&gt;   func receive() -&gt; NSData<br>&gt; }<br>&gt; extension Channel {<br>&gt;   func receive() -&gt; NSData { return NSData() }<br>&gt; }<br>&gt;<br>&gt; // Silently fails to replace the default implementation:<br>&gt; struct ClumsyChannel: Channel {<br>&gt;   // Wrong spelling<br>&gt;   func recieve() -&gt; NSData { return NSData(bytes: &quot;oops&quot;, length: 4) }<br>&gt;   // Wrong return type<br>&gt;   func receive() -&gt; [UInt8] { return Array(&quot;whoopsie&quot;.utf8) }<br>&gt;   // Wrong throwiness<br>&gt;   func receive() throws -&gt; NSData { throw &quot;doh&quot; }<br>&gt; }<br>&gt;<br>&gt; B) Protocol requirements aren&#39;t real class members, and can&#39;t be<br>&gt; overridden by subclasses unless the base class satisfies the requirement<br>&gt; with one of its own methods rather than with a protocol extension method,<br>&gt; but we silently allow subclasses to shadow:<br>&gt;<br>&gt; class BaseChannel: Channel { } // gets default imp from extension<br>&gt;<br>&gt; class SubChannel: BaseChannel {<br>&gt;   // Doesn&#39;t &#39;override&#39; protocol requirement; silently shadows it<br>&gt;   func receive() -&gt; NSData { return NSData(bytes: &quot;oof&quot;, length: 3) }<br>&gt; }<br>&gt;<br>&gt; C) Similarly, protocol extension methods aren&#39;t protocol requirements, so<br>&gt; extension methods that don&#39;t match a requirement can&#39;t be specialized in a<br>&gt; way available to generic code, but we silently allow concrete type<br>&gt; implementations to shadow:<br>&gt;<br>&gt; extension Channel {<br>&gt;   func receiveAsString() -&gt; String {<br>&gt;     return String(data: receive(), encoding: NSUTF8Encoding)<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; struct StringyChannel {<br>&gt;   func receive() -&gt; NSData { return NSData(bytes: &quot;data&quot;, 4) }<br>&gt;   // Does not affect generic code calling receiveAsString<br>&gt;   func receiveAsString() -&gt; String { return &quot;string&quot; }<br>&gt; }<br>&gt;<br>&gt; func foo&lt;T: Channel&gt;(chan: T) {<br>&gt;   print(chan.receiveAsString())<br>&gt; }<br>&gt;<br>&gt; foo(StringyChannel()) // Prints &quot;data&quot;<br>&gt;<br>&gt; (B) and (C) could be mitigated by shadowing warnings, and we&#39;ve also<br>&gt; floated ideas for making them behave as intended, by implicitly forwarding<br>&gt; protocol requirements into class methods to address (B) and/or introducing<br>&gt; dynamic dispatch for protocol extensions to address (C). (A) is a bit<br>&gt; trickier, since with overloading it&#39;s tricky to divine whether a<br>&gt; declaration was really intended to match another one with a different type<br>&gt; in isolation. We&#39;ve discussed a couple approaches to this problem:<br>&gt;<br>&gt; - Adopting an explicit &#39;implements&#39; modifier, in the spirit of &#39;override&#39;,<br>&gt; to mark a declaration as being intended to fulfill a requirement. This adds<br>&gt; boilerplate we&#39;d like to avoid, and also interferes with retroactive<br>&gt; modeling.<br>&gt; - Encourage &quot;one extension per conformance&quot; style, where each protocol<br>&gt; conformance&#39;s requirements are defined in a dedicated extension. We can<br>&gt; then warn about any declarations in an extension that don&#39;t satisfy a<br>&gt; requirement:<br>&gt;<br>&gt; struct InconsistentChannel {}<br>&gt;<br>&gt; extension InconsistentChannel: Channel {<br>&gt;   func receive() -&gt; NSData { ... } // OK<br>&gt;   func recieve() -&gt; NSData { ... } // Warning: Declaration in conformance<br>&gt; extension doesn&#39;t satisfy any requirements from &#39;Channel&#39;<br>&gt;   func receive() -&gt; NSData? { ... } // Warning<br>&gt; }<br>&gt;<br>&gt; There are likely others too. It&#39;d be great if we could give users better<br>&gt; guidance about this feature.<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160310/ef1ef587/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Completing Generics] Completing protocol extension diagnostics</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March  9, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; For type A problems: why not require that you annotate with overload?<br></p><p>This is basically the same thing as the suggestion to use `implements`, except that `override` (which I assume is what you meant) is not really accurate since you only override inherited methods.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Completing Generics] Completing protocol extension diagnostics</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>March 10, 2016 at 03:00:00pm</p></header><div class="content"><p>Yes. Just really saying that in another language, Java, they went through<br>the same discussion, chose override, and that it worked out well.<br></p><p>  -- Howard.<br></p><p>On 10 March 2016 at 14:55, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>wrote:<br></p><p>&gt; &gt; For type A problems: why not require that you annotate with overload?<br>&gt;<br>&gt; This is basically the same thing as the suggestion to use `implements`,<br>&gt; except that `override` (which I assume is what you meant) is not really<br>&gt; accurate since you only override inherited methods.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160310/ddd44257/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
