<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Making the sign of NaNs unspecified to enable enum layout optimization</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>October 19, 2016 at 08:00:00pm</p></header><div class="content"><p>I had a discussion with Steve this morning about the potential for enum layout optimization with floating-point payloads. One great thing about floating-point is that it has NaNs, and lots of them. For the most part, the only significant semantic difference among these NaNs is whether they&#39;re signaling or not, so it&#39;s tempting to reclaim some of these representations for other purposes. Javascript engines are of course famous for &quot;NaN-encoding&quot; values, representing JS numbers as native Doubles and packing pointers to non-number object instances into the same representation by using NaN bit patterns. In Swift, we could do similar things for enums with floating-point payloads, making &#39;Float?&#39; and &#39;Double?&#39; take the same amount of space as non-optionals, and automatically applying Javascript-style layout optimizations when defining enums with mixed float and object payloads. IEEE 754 is ambivalent about the role of NaN payloads, and there are libraries that use payloads for interesting diagnostic purposes, but the standard declares up front that it &quot;does not interpret the sign of a NaN&quot; (section 6.3). Reserving &quot;negative&quot; NaNs with the sign bit set as extra inhabitants could let us do enum layout optimization without interfering with the ability for libraries to freely use NaN payloads.<br></p><p>However, the way we usually handle enum optimization with extra inhabitants is problematic for floats. We normally say that it is undefined behavior for a value to have an extra inhabitant representation—a class reference cannot be null, a Bool can only be 0 or 1, and so on. With floats, we need to interoperate with numerics code not written in Swift, and we want to be able to read floating-point data out of memory that may use arbitrary bit patterns. We don&#39;t want every double-returning C function or load from memory to require a check for reserved values afterward. Making it undefined behavior for floats to have &quot;extra inhabitant&quot; representations is thus probably not practical.<br></p><p>Instead of saying that extra inhabitants are undefined behavior, we could instead continue to allow Floats and Doubles to have arbitrary bit patterns, and only check for reserved values at the point we construct an enum that wants to use reserved values for layout. If we reserve negative NaNs, then for example, constructing a Float? or Double? from a nonoptional value would check whether the payload value is NaN and if so, clear the sign bit at that point. That way, we don&#39;t have any ABI problems with Floats and Doubles from foreign sources, but still get the benefits of layout optimization for Swift types. On the other hand, this would mean that supposedly-idempotent operations like &#39;.some(x)!&#39; lose the sign information for NaNs. Since we wouldn&#39;t want to prevent the optimizer from folding those kinds of operations away, we could define Swift&#39;s semantics to say that querying the sign of a NaN value produces an unspecified value. This matches the intent of IEEE 754, and shouldn&#39;t impact most numerics code in practice. If we were interested in pursuing enum layout optimization with float payloads, I think this would be the best approach.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Making the sign of NaNs unspecified to enable enum layout optimization</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>October 20, 2016 at 09:00:00am</p></header><div class="content"><p>Some disconnected thoughts:<br></p><p>- “Does not interpret” does not mean “does not preserve”. The very next sentence in the standard is &quot;Note, however, that operations on bit strings—copy, negate, abs, copySign—specify the sign bit of a NaN result, sometimes based upon the sign bit of a NaN operand.&quot;<br></p><p>- If we were to claim a class of NaNs, I would pick signalling NaNs rather than positive or negative ones. AFAIK most NaN-embedding tricks avoid signalling NaNs because they can, well, signal, even though (again AFAIK) most modern systems don’t bother.<br></p><p>- I don’t feel like we have a coherent story here. We know that APIs taking “Double” or “Float” can represent any bit pattern. The last plan I heard for floating-point comparison treats NaNs as unordered relative to one another, even in a total order comparison. (I maintain that this is unsound.) And this proposal would treat some or all NaNs as invalid. I feel like we need to pick one approach here.<br></p><p>Jordan<br></p><p><br>&gt; On Oct 19, 2016, at 20:42, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; I had a discussion with Steve this morning about the potential for enum layout optimization with floating-point payloads. One great thing about floating-point is that it has NaNs, and lots of them. For the most part, the only significant semantic difference among these NaNs is whether they&#39;re signaling or not, so it&#39;s tempting to reclaim some of these representations for other purposes. Javascript engines are of course famous for &quot;NaN-encoding&quot; values, representing JS numbers as native Doubles and packing pointers to non-number object instances into the same representation by using NaN bit patterns. In Swift, we could do similar things for enums with floating-point payloads, making &#39;Float?&#39; and &#39;Double?&#39; take the same amount of space as non-optionals, and automatically applying Javascript-style layout optimizations when defining enums with mixed float and object payloads. IEEE 754 is ambivalent about the role of NaN payloads, and there are libraries that use payloads for interesting diagnostic purposes, but the standard declares up front that it &quot;does not interpret the sign of a NaN&quot; (section 6.3). Reserving &quot;negative&quot; NaNs with the sign bit set as extra inhabitants could let us do enum layout optimization without interfering with the ability for libraries to freely use NaN payloads.<br>&gt; <br>&gt; However, the way we usually handle enum optimization with extra inhabitants is problematic for floats. We normally say that it is undefined behavior for a value to have an extra inhabitant representation—a class reference cannot be null, a Bool can only be 0 or 1, and so on. With floats, we need to interoperate with numerics code not written in Swift, and we want to be able to read floating-point data out of memory that may use arbitrary bit patterns. We don&#39;t want every double-returning C function or load from memory to require a check for reserved values afterward. Making it undefined behavior for floats to have &quot;extra inhabitant&quot; representations is thus probably not practical.<br>&gt; <br>&gt; Instead of saying that extra inhabitants are undefined behavior, we could instead continue to allow Floats and Doubles to have arbitrary bit patterns, and only check for reserved values at the point we construct an enum that wants to use reserved values for layout. If we reserve negative NaNs, then for example, constructing a Float? or Double? from a nonoptional value would check whether the payload value is NaN and if so, clear the sign bit at that point. That way, we don&#39;t have any ABI problems with Floats and Doubles from foreign sources, but still get the benefits of layout optimization for Swift types. On the other hand, this would mean that supposedly-idempotent operations like &#39;.some(x)!&#39; lose the sign information for NaNs. Since we wouldn&#39;t want to prevent the optimizer from folding those kinds of operations away, we could define Swift&#39;s semantics to say that querying the sign of a NaN value produces an unspecified value. This matches the intent of IEEE 754, and shouldn&#39;t impact most numerics code in practice. If we were interested in pursuing enum layout optimization with float payloads, I think this would be the best approach.<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Making the sign of NaNs unspecified to enable enum layout optimization</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>October 20, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Oct 20, 2016, at 9:42 AM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; Some disconnected thoughts:<br>&gt; <br>&gt; - “Does not interpret” does not mean “does not preserve”. The very next sentence in the standard is &quot;Note, however, that operations on bit strings—copy, negate, abs, copySign—specify the sign bit of a NaN result, sometimes based upon the sign bit of a NaN operand.&quot;<br>&gt; <br>&gt; - If we were to claim a class of NaNs, I would pick signalling NaNs rather than positive or negative ones. AFAIK most NaN-embedding tricks avoid signalling NaNs because they can, well, signal, even though (again AFAIK) most modern systems don’t bother.<br></p><p>Claiming sNaNs would be unfortunate since &quot;signaling&quot; is about the only semantically distinct bit NaNs normally have, and I think we should minimize interference with users who are taking advantage of signaling or NaN payloads for their own means. (OTOH, on some platforms like x87 it&#39;s already practically impossible to preserve the signaling bit, since even loads will immediately raise the exception and quiet the NaN, and there would be some nice safety benefits to getting a trap early if a Float? is bitcast to a Float without being formally checked first.)<br></p><p>&gt; <br>&gt; - I don’t feel like we have a coherent story here. We know that APIs taking “Double” or “Float” can represent any bit pattern. The last plan I heard for floating-point comparison treats NaNs as unordered relative to one another, even in a total order comparison. (I maintain that this is unsound.) And this proposal would treat some or all NaNs as invalid. I feel like we need to pick one approach here.<br></p><p>I&#39;m not saying that they&#39;d be invalid, only that the language doesn&#39;t guarantee to preserve these representations exactly. That seems orthogonal to the comparison issue—whatever rule we come up with for float ordering, all NaNs ought to be treated uniformly by that rule.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e01e37acbfad671da1b94a61cf819d82?s=50"></div><header><strong>Making the sign of NaNs</strong> from <string>Kenny Leung</string> &lt;kenny_leung at pobox.com&gt;<p>October 20, 2016 at 10:00:00am</p></header><div class="content"><p>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161020/5a0acdb9/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: nimoy-interview.png.jpeg<br>Type: image/jpeg<br>Size: 31199 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161020/5a0acdb9/attachment.jpeg&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Making the sign of NaNs unspecified to enable enum layout optimization</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>October 20, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Oct 20, 2016, at 10:04, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 20, 2016, at 9:42 AM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Some disconnected thoughts:<br>&gt;&gt; <br>&gt;&gt; - “Does not interpret” does not mean “does not preserve”. The very next sentence in the standard is &quot;Note, however, that operations on bit strings—copy, negate, abs, copySign—specify the sign bit of a NaN result, sometimes based upon the sign bit of a NaN operand.&quot;<br>&gt;&gt; <br>&gt;&gt; - If we were to claim a class of NaNs, I would pick signalling NaNs rather than positive or negative ones. AFAIK most NaN-embedding tricks avoid signalling NaNs because they can, well, signal, even though (again AFAIK) most modern systems don’t bother.<br>&gt; <br>&gt; Claiming sNaNs would be unfortunate since &quot;signaling&quot; is about the only semantically distinct bit NaNs normally have, and I think we should minimize interference with users who are taking advantage of signaling or NaN payloads for their own means. (OTOH, on some platforms like x87 it&#39;s already practically impossible to preserve the signaling bit, since even loads will immediately raise the exception and quiet the NaN, and there would be some nice safety benefits to getting a trap early if a Float? is bitcast to a Float without being formally checked first.)<br></p><p>Right, that’s sort of my point. If you’re using NaN payloads for non-float-related information, you shouldn’t be using the bit that’s part of the floating-point standard. But I could also see plenty of people saying “we’re not going to waste a whole bit” and not bothering to distinguish it from the rest.<br></p><p>At the same time, I can certainly see people saying “hey, an extra bit” about the sign bit. If you’re using NaN payloads, you probably are going to check for that before performing any operations on the NaN, rather than relying on nil-swallowing NaN-propagation doing what your program requires.<br></p><p>&gt;&gt; <br>&gt;&gt; - I don’t feel like we have a coherent story here. We know that APIs taking “Double” or “Float” can represent any bit pattern. The last plan I heard for floating-point comparison treats NaNs as unordered relative to one another, even in a total order comparison. (I maintain that this is unsound.) And this proposal would treat some or all NaNs as invalid. I feel like we need to pick one approach here.<br>&gt; <br>&gt; I&#39;m not saying that they&#39;d be invalid, only that the language doesn&#39;t guarantee to preserve these representations exactly. That seems orthogonal to the comparison issue—whatever rule we come up with for float ordering, all NaNs ought to be treated uniformly by that rule.<br></p><p>I don’t think I agree with either of those sentences. I’d really like the story to be either “we treat different NaN bit strings as distinct” or “there are no meaningful distinctions between NaNs in Swift (except maybe sNaN vs. qNaN); if you want anything more you need to use Int as your storage type”. Each of those has natural consequences for me concerning both extra inhabitants and total ordering.<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161020/ee7cb77d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Making the sign of NaNs unspecified to enable enum layout optimization</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>October 20, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Oct 20, 2016, at 10:35 AM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Oct 20, 2016, at 10:04, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 20, 2016, at 9:42 AM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Some disconnected thoughts:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - “Does not interpret” does not mean “does not preserve”. The very next sentence in the standard is &quot;Note, however, that operations on bit strings—copy, negate, abs, copySign—specify the sign bit of a NaN result, sometimes based upon the sign bit of a NaN operand.&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - If we were to claim a class of NaNs, I would pick signalling NaNs rather than positive or negative ones. AFAIK most NaN-embedding tricks avoid signalling NaNs because they can, well, signal, even though (again AFAIK) most modern systems don’t bother.<br>&gt;&gt; <br>&gt;&gt; Claiming sNaNs would be unfortunate since &quot;signaling&quot; is about the only semantically distinct bit NaNs normally have, and I think we should minimize interference with users who are taking advantage of signaling or NaN payloads for their own means. (OTOH, on some platforms like x87 it&#39;s already practically impossible to preserve the signaling bit, since even loads will immediately raise the exception and quiet the NaN, and there would be some nice safety benefits to getting a trap early if a Float? is bitcast to a Float without being formally checked first.)<br>&gt; <br>&gt; Right, that’s sort of my point. If you’re using NaN payloads for non-float-related information, you shouldn’t be using the bit that’s part of the floating-point standard. But I could also see plenty of people saying “we’re not going to waste a whole bit” and not bothering to distinguish it from the rest.<br>&gt; <br>&gt; At the same time, I can certainly see people saying “hey, an extra bit” about the sign bit. If you’re using NaN payloads, you probably are going to check for that before performing any operations on the NaN, rather than relying on nil-swallowing NaN-propagation doing what your program requires.<br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - I don’t feel like we have a coherent story here. We know that APIs taking “Double” or “Float” can represent any bit pattern. The last plan I heard for floating-point comparison treats NaNs as unordered relative to one another, even in a total order comparison. (I maintain that this is unsound.) And this proposal would treat some or all NaNs as invalid. I feel like we need to pick one approach here.<br>&gt;&gt; <br>&gt;&gt; I&#39;m not saying that they&#39;d be invalid, only that the language doesn&#39;t guarantee to preserve these representations exactly. That seems orthogonal to the comparison issue—whatever rule we come up with for float ordering, all NaNs ought to be treated uniformly by that rule.<br>&gt; <br>&gt; I don’t think I agree with either of those sentences. I’d really like the story to be either “we treat different NaN bit strings as distinct” or “there are no meaningful distinctions between NaNs in Swift (except maybe sNaN vs. qNaN); if you want anything more you need to use Int as your storage type”. Each of those has natural consequences for me concerning both extra inhabitants and total ordering.<br></p><p>JavaScript goes as far as saying that there&#39;s semantically only one NaN value. We could reasonably do the same (though I think there&#39;s value in preserving &#39;sNaN&#39; and &#39;qNaN&#39;), since hardware and libm already make basically no portable guarantees about what NaN representation you get. That might make it less morally wrong to sometimes treat all NaNs uniformly and sometimes preserve them.<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161020/8b341394/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>Making the sign of NaNs unspecified to enable enum layout optimization</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>October 20, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Oct 20, 2016, at 10:04 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 20, 2016, at 9:42 AM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Some disconnected thoughts:<br>&gt;&gt; <br>&gt;&gt; - “Does not interpret” does not mean “does not preserve”. The very next sentence in the standard is &quot;Note, however, that operations on bit strings—copy, negate, abs, copySign—specify the sign bit of a NaN result, sometimes based upon the sign bit of a NaN operand.&quot;<br>&gt;&gt; <br>&gt;&gt; - If we were to claim a class of NaNs, I would pick signalling NaNs rather than positive or negative ones. AFAIK most NaN-embedding tricks avoid signalling NaNs because they can, well, signal, even though (again AFAIK) most modern systems don’t bother.<br>&gt; <br>&gt; Claiming sNaNs would be unfortunate since &quot;signaling&quot; is about the only semantically distinct bit NaNs normally have, and I think we should minimize interference with users who are taking advantage of signaling or NaN payloads for their own means. (OTOH, on some platforms like x87 it&#39;s already practically impossible to preserve the signaling bit, since even loads will immediately raise the exception and quiet the NaN, and there would be some nice safety benefits to getting a trap early if a Float? is bitcast to a Float without being formally checked first.)<br>&gt; <br>&gt;&gt; - I don’t feel like we have a coherent story here. We know that APIs taking “Double” or “Float” can represent any bit pattern. The last plan I heard for floating-point comparison treats NaNs as unordered relative to one another, even in a total order comparison. (I maintain that this is unsound.) And this proposal would treat some or all NaNs as invalid. I feel like we need to pick one approach here.<br>&gt; <br>&gt; I&#39;m not saying that they&#39;d be invalid, only that the language doesn&#39;t guarantee to preserve these representations exactly. That seems orthogonal to the comparison issue—whatever rule we come up with for float ordering, all NaNs ought to be treated uniformly by that rule.<br></p><p>In particular, the language doesn’t guarantee to preserve the representation exactly specifically **for conversions to Float? and back**.  IEEE 754 has no notion of optionals, so the IEEE 754 rules don’t directly constrain the design space here.<br></p><p>The primary constraint is that conversion to Optional and back should preserve values.  I don’t think that it needs to preserve *encodings*, however (e.g. IEEE 754 conversions canonicalize decimal significands, and I’m OK with conversions to/from Optional doing the same; we can mod NaNs out by some reserved payload bit and call them different encodings of the same NaN value and the same rationale applies).<br></p><p>Preserving values implies preserving substitutability.  That should preserve nan-ness for sure, and should either preserve signaling-ness or actually “signal” (in the IEEE 754 sense) at the point of conversion to Optional.  One can argue that preserving the signbit of the NaN would be nice (for substitutability in copysign), but one can also argue that this is really a property of the encoding, not the value.<br></p><p>Like Joe, I don’t think that comparison really enters into this (the issue was never totally resolved to my understanding, but my recollection is that we mostly left it as &quot;&lt;=&gt; should order according to the IEEE 754 level 2 abstraction”—meaning all NaNs are equal to each other for the purposes of &lt;=&gt;).<br></p><p>I would be pretty opposed to claiming sNaNs for this purpose.  The two better options I see are:<br></p><p>	- Use the signbit of NaN.<br>	- Reserve NaNs whose significand begins with `b11` (these bit patterns are already reserved by the `Float(nan: signaling:)` constructor).<br></p><p>copysign( ) is a reason to not pick the first option.  I’m not very worried about it, but it is a reason.  I see no problem with the second option.<br></p><p>– Steve<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Making the sign of NaNs unspecified to enable enum layout optimization</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>October 20, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Oct 20, 2016, at 10:38 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Oct 20, 2016, at 10:04 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 20, 2016, at 9:42 AM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Some disconnected thoughts:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - “Does not interpret” does not mean “does not preserve”. The very next sentence in the standard is &quot;Note, however, that operations on bit strings—copy, negate, abs, copySign—specify the sign bit of a NaN result, sometimes based upon the sign bit of a NaN operand.&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - If we were to claim a class of NaNs, I would pick signalling NaNs rather than positive or negative ones. AFAIK most NaN-embedding tricks avoid signalling NaNs because they can, well, signal, even though (again AFAIK) most modern systems don’t bother.<br>&gt;&gt; <br>&gt;&gt; Claiming sNaNs would be unfortunate since &quot;signaling&quot; is about the only semantically distinct bit NaNs normally have, and I think we should minimize interference with users who are taking advantage of signaling or NaN payloads for their own means. (OTOH, on some platforms like x87 it&#39;s already practically impossible to preserve the signaling bit, since even loads will immediately raise the exception and quiet the NaN, and there would be some nice safety benefits to getting a trap early if a Float? is bitcast to a Float without being formally checked first.)<br>&gt;&gt; <br>&gt;&gt;&gt; - I don’t feel like we have a coherent story here. We know that APIs taking “Double” or “Float” can represent any bit pattern. The last plan I heard for floating-point comparison treats NaNs as unordered relative to one another, even in a total order comparison. (I maintain that this is unsound.) And this proposal would treat some or all NaNs as invalid. I feel like we need to pick one approach here.<br>&gt;&gt; <br>&gt;&gt; I&#39;m not saying that they&#39;d be invalid, only that the language doesn&#39;t guarantee to preserve these representations exactly. That seems orthogonal to the comparison issue—whatever rule we come up with for float ordering, all NaNs ought to be treated uniformly by that rule.<br>&gt; <br>&gt; In particular, the language doesn’t guarantee to preserve the representation exactly specifically **for conversions to Float? and back**.  IEEE 754 has no notion of optionals, so the IEEE 754 rules don’t directly constrain the design space here.<br>&gt; <br>&gt; The primary constraint is that conversion to Optional and back should preserve values.  I don’t think that it needs to preserve *encodings*, however (e.g. IEEE 754 conversions canonicalize decimal significands, and I’m OK with conversions to/from Optional doing the same; we can mod NaNs out by some reserved payload bit and call them different encodings of the same NaN value and the same rationale applies).<br>&gt; <br>&gt; Preserving values implies preserving substitutability.  That should preserve nan-ness for sure, and should either preserve signaling-ness or actually “signal” (in the IEEE 754 sense) at the point of conversion to Optional.  One can argue that preserving the signbit of the NaN would be nice (for substitutability in copysign), but one can also argue that this is really a property of the encoding, not the value.<br>&gt; <br>&gt; Like Joe, I don’t think that comparison really enters into this (the issue was never totally resolved to my understanding, but my recollection is that we mostly left it as &quot;&lt;=&gt; should order according to the IEEE 754 level 2 abstraction”—meaning all NaNs are equal to each other for the purposes of &lt;=&gt;).<br>&gt; <br>&gt; I would be pretty opposed to claiming sNaNs for this purpose.  The two better options I see are:<br>&gt; <br>&gt; 	- Use the signbit of NaN.<br>&gt; 	- Reserve NaNs whose significand begins with `b11` (these bit patterns are already reserved by the `Float(nan: signaling:)` constructor).<br>&gt; <br>&gt; copysign( ) is a reason to not pick the first option.  I’m not very worried about it, but it is a reason.  I see no problem with the second option.<br></p><p>As we discussed in person this morning, de-canonicalizing b11 might be a better compromise to minimize the potential impact of layout optimizations. That would leave the implementation with 2^51 NaN representations (50 significand bits, plus the sign bit) in Double to play with, which ought to be enough for anyone™. I liked the idea of using the sign bit originally since testing for NaNs and sign bits is something that can be easily done using common FPU instructions without crossing domains, but as you noted, it sounds like comparison and branching operations tend to do that anyway, so masking and branching using integer operations shouldn&#39;t be too much of a burden. Jordan&#39;s question of to what degree we consider different NaN encodings to be distinct semantic values is still an interesting one, but if we take only the b11 NaN payloads away, that should minimize the degree to which the implementation needs to be considered as a constraint in having that discussion.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161020/d4725382/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Making the sign of NaNs unspecified to enable enum layout optimization</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>October 20, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Oct 20, 2016, at 12:59, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 20, 2016, at 10:38 AM, Stephen Canon &lt;scanon at apple.com &lt;mailto:scanon at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Oct 20, 2016, at 10:04 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 20, 2016, at 9:42 AM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Some disconnected thoughts:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - “Does not interpret” does not mean “does not preserve”. The very next sentence in the standard is &quot;Note, however, that operations on bit strings—copy, negate, abs, copySign—specify the sign bit of a NaN result, sometimes based upon the sign bit of a NaN operand.&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - If we were to claim a class of NaNs, I would pick signalling NaNs rather than positive or negative ones. AFAIK most NaN-embedding tricks avoid signalling NaNs because they can, well, signal, even though (again AFAIK) most modern systems don’t bother.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Claiming sNaNs would be unfortunate since &quot;signaling&quot; is about the only semantically distinct bit NaNs normally have, and I think we should minimize interference with users who are taking advantage of signaling or NaN payloads for their own means. (OTOH, on some platforms like x87 it&#39;s already practically impossible to preserve the signaling bit, since even loads will immediately raise the exception and quiet the NaN, and there would be some nice safety benefits to getting a trap early if a Float? is bitcast to a Float without being formally checked first.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - I don’t feel like we have a coherent story here. We know that APIs taking “Double” or “Float” can represent any bit pattern. The last plan I heard for floating-point comparison treats NaNs as unordered relative to one another, even in a total order comparison. (I maintain that this is unsound.) And this proposal would treat some or all NaNs as invalid. I feel like we need to pick one approach here.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m not saying that they&#39;d be invalid, only that the language doesn&#39;t guarantee to preserve these representations exactly. That seems orthogonal to the comparison issue—whatever rule we come up with for float ordering, all NaNs ought to be treated uniformly by that rule.<br>&gt;&gt; <br>&gt;&gt; In particular, the language doesn’t guarantee to preserve the representation exactly specifically **for conversions to Float? and back**.  IEEE 754 has no notion of optionals, so the IEEE 754 rules don’t directly constrain the design space here.<br>&gt;&gt; <br>&gt;&gt; The primary constraint is that conversion to Optional and back should preserve values.  I don’t think that it needs to preserve *encodings*, however (e.g. IEEE 754 conversions canonicalize decimal significands, and I’m OK with conversions to/from Optional doing the same; we can mod NaNs out by some reserved payload bit and call them different encodings of the same NaN value and the same rationale applies).<br>&gt;&gt; <br>&gt;&gt; Preserving values implies preserving substitutability.  That should preserve nan-ness for sure, and should either preserve signaling-ness or actually “signal” (in the IEEE 754 sense) at the point of conversion to Optional.  One can argue that preserving the signbit of the NaN would be nice (for substitutability in copysign), but one can also argue that this is really a property of the encoding, not the value.<br>&gt;&gt; <br>&gt;&gt; Like Joe, I don’t think that comparison really enters into this (the issue was never totally resolved to my understanding, but my recollection is that we mostly left it as &quot;&lt;=&gt; should order according to the IEEE 754 level 2 abstraction”—meaning all NaNs are equal to each other for the purposes of &lt;=&gt;).<br>&gt;&gt; <br>&gt;&gt; I would be pretty opposed to claiming sNaNs for this purpose.  The two better options I see are:<br>&gt;&gt; <br>&gt;&gt; 	- Use the signbit of NaN.<br>&gt;&gt; 	- Reserve NaNs whose significand begins with `b11` (these bit patterns are already reserved by the `Float(nan: signaling:)` constructor).<br>&gt;&gt; <br>&gt;&gt; copysign( ) is a reason to not pick the first option.  I’m not very worried about it, but it is a reason.  I see no problem with the second option.<br>&gt; <br>&gt; As we discussed in person this morning, de-canonicalizing b11 might be a better compromise to minimize the potential impact of layout optimizations. That would leave the implementation with 2^51 NaN representations (50 significand bits, plus the sign bit) in Double to play with, which ought to be enough for anyone™. I liked the idea of using the sign bit originally since testing for NaNs and sign bits is something that can be easily done using common FPU instructions without crossing domains, but as you noted, it sounds like comparison and branching operations tend to do that anyway, so masking and branching using integer operations shouldn&#39;t be too much of a burden. Jordan&#39;s question of to what degree we consider different NaN encodings to be distinct semantic values is still an interesting one, but if we take only the b11 NaN payloads away, that should minimize the degree to which the implementation needs to be considered as a constraint in having that discussion.<br></p><p>Joe, Steve, and Dave Abrahams convinced me that this is a fairly good encoding for NaN-payloads in general, and probably one that’s still compatible with real systems in practice. If anyone really needs that last bit of qNaN payload, they can inspect the bit pattern directly, and if they need to distinguish different NaNs in a Set or Dictionary the element type shouldn’t be Float/Double.<br></p><p>Thanks for talking this all through with me.<br>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161020/2f6edd07/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Making the sign of NaNs unspecified to enable enum layout optimization</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>October 22, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Oct 20, 2016, at 2:59 PM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; copysign( ) is a reason to not pick the first option.  I’m not very worried about it, but it is a reason.  I see no problem with the second option.<br>&gt; <br>&gt; As we discussed in person this morning, de-canonicalizing b11 might be a better compromise to minimize the potential impact of layout optimizations. That would leave the implementation with 2^51 NaN representations (50 significand bits, plus the sign bit) in Double to play with, which ought to be enough for anyone™. I liked the idea of using the sign bit originally since testing for NaNs and sign bits is something that can be easily done using common FPU instructions without crossing domains, but as you noted, it sounds like comparison and branching operations tend to do that anyway, so masking and branching using integer operations shouldn&#39;t be too much of a burden. Jordan&#39;s question of to what degree we consider different NaN encodings to be distinct semantic values is still an interesting one, but if we take only the b11 NaN payloads away, that should minimize the degree to which the implementation needs to be considered as a constraint in having that discussion.<br></p><p>To your original email, I agree this is an important problem to tackle, and that we should handle the inhabitant masking when the FP value is converted to optional.<br></p><p>That said, I don’t understand the above.  With the “b11” representation, what how is a &quot;Double?&quot; tested for “.None&quot;? One advantage of using the signbit is that “is negative” comparisons are very cheap on risc systems, because you don’t have to materialize a large/weird immediate.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161022/8d8b2cf3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Making the sign of NaNs unspecified to enable enum layout optimization</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>October 24, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Oct 22, 2016, at 10:39 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Oct 20, 2016, at 2:59 PM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; copysign( ) is a reason to not pick the first option.  I’m not very worried about it, but it is a reason.  I see no problem with the second option.<br>&gt;&gt; <br>&gt;&gt; As we discussed in person this morning, de-canonicalizing b11 might be a better compromise to minimize the potential impact of layout optimizations. That would leave the implementation with 2^51 NaN representations (50 significand bits, plus the sign bit) in Double to play with, which ought to be enough for anyone™. I liked the idea of using the sign bit originally since testing for NaNs and sign bits is something that can be easily done using common FPU instructions without crossing domains, but as you noted, it sounds like comparison and branching operations tend to do that anyway, so masking and branching using integer operations shouldn&#39;t be too much of a burden. Jordan&#39;s question of to what degree we consider different NaN encodings to be distinct semantic values is still an interesting one, but if we take only the b11 NaN payloads away, that should minimize the degree to which the implementation needs to be considered as a constraint in having that discussion.<br>&gt; <br>&gt; To your original email, I agree this is an important problem to tackle, and that we should handle the inhabitant masking when the FP value is converted to optional.<br>&gt; <br>&gt; That said, I don’t understand the above.  With the “b11” representation, what how is a &quot;Double?&quot; tested for “.None&quot;? One advantage of using the signbit is that “is negative” comparisons are very cheap on risc systems, because you don’t have to materialize a large/weird immediate.<br></p><p>That&#39;s why I liked using the sign bit originally too. Steve noted that, since any operation on an Optional is probably going to involve testing and branching before revealing the underlying float value, and float comparisons and branches tend to unavoidably burn a couple cycles engaging the integer ALU, there&#39;s unlikely to be much benefit on ARM or Intel avoiding integer masking operations. (More strictly RISCy architectures like Power would be more negatively impacted, perhaps.) On ARM64 at least, the bitmask for a b11 NaN is still representable as an immediate, since it involves a single contiguous run of 1 bits.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Making the sign of NaNs unspecified to enable enum layout optimization</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>October 24, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Oct 24, 2016, at 8:49 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; On Oct 22, 2016, at 10:39 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 20, 2016, at 2:59 PM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; copysign( ) is a reason to not pick the first option.  I’m not very worried about it, but it is a reason.  I see no problem with the second option.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As we discussed in person this morning, de-canonicalizing b11 might be a better compromise to minimize the potential impact of layout optimizations. That would leave the implementation with 2^51 NaN representations (50 significand bits, plus the sign bit) in Double to play with, which ought to be enough for anyone™. I liked the idea of using the sign bit originally since testing for NaNs and sign bits is something that can be easily done using common FPU instructions without crossing domains, but as you noted, it sounds like comparison and branching operations tend to do that anyway, so masking and branching using integer operations shouldn&#39;t be too much of a burden. Jordan&#39;s question of to what degree we consider different NaN encodings to be distinct semantic values is still an interesting one, but if we take only the b11 NaN payloads away, that should minimize the degree to which the implementation needs to be considered as a constraint in having that discussion.<br>&gt;&gt; <br>&gt;&gt; To your original email, I agree this is an important problem to tackle, and that we should handle the inhabitant masking when the FP value is converted to optional.<br>&gt;&gt; <br>&gt;&gt; That said, I don’t understand the above.  With the “b11” representation, what how is a &quot;Double?&quot; tested for “.None&quot;? One advantage of using the signbit is that “is negative” comparisons are very cheap on risc systems, because you don’t have to materialize a large/weird immediate.<br>&gt; <br>&gt; That&#39;s why I liked using the sign bit originally too. Steve noted that, since any operation on an Optional is probably going to involve testing and branching before revealing the underlying float value, and float comparisons and branches tend to unavoidably burn a couple cycles engaging the integer ALU, there&#39;s unlikely to be much benefit on ARM or Intel avoiding integer masking operations. (More strictly RISCy architectures like Power would be more negatively impacted, perhaps.) On ARM64 at least, the bitmask for a b11 NaN is still representable as an immediate, since it involves a single contiguous run of 1 bits.<br></p><p>There isn&#39;t any efficient way of just testing the sign bit of a value using FP instructions that I can see.  You could maybe take advantage of the vector registers overlapping the FP registers and use integer vector operations, but it would take a lot of code and have false-dependency problems.  So in both representations, the most efficient test sequence seems to be (1) get value in integer register (2) compare against some specific integer value.  And in that case, in both representations it seems to me that the obvious extra-inhabitant sequence is 0xFFFFFFFF, 0xFFFFFFFE, ...<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>Making the sign of NaNs unspecified to enable enum layout optimization</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>October 24, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Oct 24, 2016, at 2:55 PM, John McCall via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Oct 24, 2016, at 8:49 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; On Oct 22, 2016, at 10:39 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 20, 2016, at 2:59 PM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; copysign( ) is a reason to not pick the first option.  I’m not very worried about it, but it is a reason.  I see no problem with the second option.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As we discussed in person this morning, de-canonicalizing b11 might be a better compromise to minimize the potential impact of layout optimizations. That would leave the implementation with 2^51 NaN representations (50 significand bits, plus the sign bit) in Double to play with, which ought to be enough for anyone™. I liked the idea of using the sign bit originally since testing for NaNs and sign bits is something that can be easily done using common FPU instructions without crossing domains, but as you noted, it sounds like comparison and branching operations tend to do that anyway, so masking and branching using integer operations shouldn&#39;t be too much of a burden. Jordan&#39;s question of to what degree we consider different NaN encodings to be distinct semantic values is still an interesting one, but if we take only the b11 NaN payloads away, that should minimize the degree to which the implementation needs to be considered as a constraint in having that discussion.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To your original email, I agree this is an important problem to tackle, and that we should handle the inhabitant masking when the FP value is converted to optional.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That said, I don’t understand the above.  With the “b11” representation, what how is a &quot;Double?&quot; tested for “.None&quot;? One advantage of using the signbit is that “is negative” comparisons are very cheap on risc systems, because you don’t have to materialize a large/weird immediate.<br>&gt;&gt; <br>&gt;&gt; That&#39;s why I liked using the sign bit originally too. Steve noted that, since any operation on an Optional is probably going to involve testing and branching before revealing the underlying float value, and float comparisons and branches tend to unavoidably burn a couple cycles engaging the integer ALU, there&#39;s unlikely to be much benefit on ARM or Intel avoiding integer masking operations. (More strictly RISCy architectures like Power would be more negatively impacted, perhaps.) On ARM64 at least, the bitmask for a b11 NaN is still representable as an immediate, since it involves a single contiguous run of 1 bits.<br>&gt; <br>&gt; There isn&#39;t any efficient way of just testing the sign bit of a value using FP instructions that I can see.  You could maybe take advantage of the vector registers overlapping the FP registers and use integer vector operations, but it would take a lot of code and have false-dependency problems.  So in both representations, the most efficient test sequence seems to be (1) get value in integer register (2) compare against some specific integer value.  And in that case, in both representations it seems to me that the obvious extra-inhabitant sequence is 0xFFFFFFFF, 0xFFFFFFFE, …<br></p><p>The test for detecting the reserved encoding is essentially identical either way (pseudo-assembly):<br></p><p>	detectNegativeNaN:<br>		ADD encoding, encoding, 0x0010000000000000<br>		JC nil<br></p><p>	detectLeading11NaN:<br>		ADD encoding, encoding, 0x0004000000000000<br>		JO nil<br></p><p>– Steve<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Making the sign of NaNs unspecified to enable enum layout optimization</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>October 24, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Oct 24, 2016, at 12:30 PM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;&gt; On Oct 24, 2016, at 2:55 PM, John McCall via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 24, 2016, at 8:49 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; On Oct 22, 2016, at 10:39 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Oct 20, 2016, at 2:59 PM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; copysign( ) is a reason to not pick the first option.  I’m not very worried about it, but it is a reason.  I see no problem with the second option.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; As we discussed in person this morning, de-canonicalizing b11 might be a better compromise to minimize the potential impact of layout optimizations. That would leave the implementation with 2^51 NaN representations (50 significand bits, plus the sign bit) in Double to play with, which ought to be enough for anyone™. I liked the idea of using the sign bit originally since testing for NaNs and sign bits is something that can be easily done using common FPU instructions without crossing domains, but as you noted, it sounds like comparison and branching operations tend to do that anyway, so masking and branching using integer operations shouldn&#39;t be too much of a burden. Jordan&#39;s question of to what degree we consider different NaN encodings to be distinct semantic values is still an interesting one, but if we take only the b11 NaN payloads away, that should minimize the degree to which the implementation needs to be considered as a constraint in having that discussion.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; To your original email, I agree this is an important problem to tackle, and that we should handle the inhabitant masking when the FP value is converted to optional.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That said, I don’t understand the above.  With the “b11” representation, what how is a &quot;Double?&quot; tested for “.None&quot;? One advantage of using the signbit is that “is negative” comparisons are very cheap on risc systems, because you don’t have to materialize a large/weird immediate.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That&#39;s why I liked using the sign bit originally too. Steve noted that, since any operation on an Optional is probably going to involve testing and branching before revealing the underlying float value, and float comparisons and branches tend to unavoidably burn a couple cycles engaging the integer ALU, there&#39;s unlikely to be much benefit on ARM or Intel avoiding integer masking operations. (More strictly RISCy architectures like Power would be more negatively impacted, perhaps.) On ARM64 at least, the bitmask for a b11 NaN is still representable as an immediate, since it involves a single contiguous run of 1 bits.<br>&gt;&gt; <br>&gt;&gt; There isn&#39;t any efficient way of just testing the sign bit of a value using FP instructions that I can see.  You could maybe take advantage of the vector registers overlapping the FP registers and use integer vector operations, but it would take a lot of code and have false-dependency problems.  So in both representations, the most efficient test sequence seems to be (1) get value in integer register (2) compare against some specific integer value.  And in that case, in both representations it seems to me that the obvious extra-inhabitant sequence is 0xFFFFFFFF, 0xFFFFFFFE, …<br>&gt; <br>&gt; The test for detecting the reserved encoding is essentially identical either way (pseudo-assembly):<br>&gt; <br>&gt; 	detectNegativeNaN:<br>&gt; 		ADD encoding, encoding, 0x0010000000000000<br>&gt; 		JC nil<br>&gt; <br>&gt; 	detectLeading11NaN:<br>&gt; 		ADD encoding, encoding, 0x0004000000000000<br>&gt; 		JO nil<br></p><p>Sure, that&#39;s basically just a different way of spelling the comparison.  For the most part, though, Swift will not need to perform this operation; it&#39;ll be checking for a specific value.  I don&#39;t see any reason to say that e.g. .none can be encoded by an arbitrary reserved NaN rather than a specific one.<br></p><p>Anyway, we&#39;re agreed that both representations require doing integer comparisons on the value, not FP comparisons, and so operations on Float? will generally require moving the value between register banks if we do this.  It&#39;s not as pure a win as we might hope.  Still probably worthwhile, though.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Making the sign of NaNs unspecified to enable enum layout optimization</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>October 24, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Oct 24, 2016, at 12:58, John McCall via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Oct 24, 2016, at 12:30 PM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;&gt;&gt; On Oct 24, 2016, at 2:55 PM, John McCall via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 24, 2016, at 8:49 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; On Oct 22, 2016, at 10:39 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Oct 20, 2016, at 2:59 PM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; copysign( ) is a reason to not pick the first option.  I’m not very worried about it, but it is a reason.  I see no problem with the second option.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; As we discussed in person this morning, de-canonicalizing b11 might be a better compromise to minimize the potential impact of layout optimizations. That would leave the implementation with 2^51 NaN representations (50 significand bits, plus the sign bit) in Double to play with, which ought to be enough for anyone™. I liked the idea of using the sign bit originally since testing for NaNs and sign bits is something that can be easily done using common FPU instructions without crossing domains, but as you noted, it sounds like comparison and branching operations tend to do that anyway, so masking and branching using integer operations shouldn&#39;t be too much of a burden. Jordan&#39;s question of to what degree we consider different NaN encodings to be distinct semantic values is still an interesting one, but if we take only the b11 NaN payloads away, that should minimize the degree to which the implementation needs to be considered as a constraint in having that discussion.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; To your original email, I agree this is an important problem to tackle, and that we should handle the inhabitant masking when the FP value is converted to optional.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That said, I don’t understand the above.  With the “b11” representation, what how is a &quot;Double?&quot; tested for “.None&quot;? One advantage of using the signbit is that “is negative” comparisons are very cheap on risc systems, because you don’t have to materialize a large/weird immediate.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That&#39;s why I liked using the sign bit originally too. Steve noted that, since any operation on an Optional is probably going to involve testing and branching before revealing the underlying float value, and float comparisons and branches tend to unavoidably burn a couple cycles engaging the integer ALU, there&#39;s unlikely to be much benefit on ARM or Intel avoiding integer masking operations. (More strictly RISCy architectures like Power would be more negatively impacted, perhaps.) On ARM64 at least, the bitmask for a b11 NaN is still representable as an immediate, since it involves a single contiguous run of 1 bits.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There isn&#39;t any efficient way of just testing the sign bit of a value using FP instructions that I can see.  You could maybe take advantage of the vector registers overlapping the FP registers and use integer vector operations, but it would take a lot of code and have false-dependency problems.  So in both representations, the most efficient test sequence seems to be (1) get value in integer register (2) compare against some specific integer value.  And in that case, in both representations it seems to me that the obvious extra-inhabitant sequence is 0xFFFFFFFF, 0xFFFFFFFE, …<br>&gt;&gt; <br>&gt;&gt; The test for detecting the reserved encoding is essentially identical either way (pseudo-assembly):<br>&gt;&gt; <br>&gt;&gt; 	detectNegativeNaN:<br>&gt;&gt; 		ADD encoding, encoding, 0x0010000000000000<br>&gt;&gt; 		JC nil<br>&gt;&gt; <br>&gt;&gt; 	detectLeading11NaN:<br>&gt;&gt; 		ADD encoding, encoding, 0x0004000000000000<br>&gt;&gt; 		JO nil<br>&gt; <br>&gt; Sure, that&#39;s basically just a different way of spelling the comparison.  For the most part, though, Swift will not need to perform this operation; it&#39;ll be checking for a specific value.  I don&#39;t see any reason to say that e.g. .none can be encoded by an arbitrary reserved NaN rather than a specific one.<br></p><p>That doesn&#39;t quite happen when the other case also has a payload.<br></p><p>enum SmallIntOrBigFloat {<br>  case small(Int8)<br>  case big(Double)<br>}<br></p><p>Jordan<br></p><p>&gt; Anyway, we&#39;re agreed that both representations require doing integer comparisons on the value, not FP comparisons, and so operations on Float? will generally require moving the value between register banks if we do this.  It&#39;s not as pure a win as we might hope.  Still probably worthwhile, though.<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161024/e686ed28/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Making the sign of NaNs unspecified to enable enum layout optimization</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>October 24, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Oct 24, 2016, at 1:07 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;&gt; On Oct 24, 2016, at 12:58, John McCall via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 24, 2016, at 12:30 PM, Stephen Canon &lt;scanon at apple.com &lt;mailto:scanon at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; On Oct 24, 2016, at 2:55 PM, John McCall via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Oct 24, 2016, at 8:49 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; On Oct 22, 2016, at 10:39 AM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 20, 2016, at 2:59 PM, Joe Groff via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; copysign( ) is a reason to not pick the first option.  I’m not very worried about it, but it is a reason.  I see no problem with the second option.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; As we discussed in person this morning, de-canonicalizing b11 might be a better compromise to minimize the potential impact of layout optimizations. That would leave the implementation with 2^51 NaN representations (50 significand bits, plus the sign bit) in Double to play with, which ought to be enough for anyone™. I liked the idea of using the sign bit originally since testing for NaNs and sign bits is something that can be easily done using common FPU instructions without crossing domains, but as you noted, it sounds like comparison and branching operations tend to do that anyway, so masking and branching using integer operations shouldn&#39;t be too much of a burden. Jordan&#39;s question of to what degree we consider different NaN encodings to be distinct semantic values is still an interesting one, but if we take only the b11 NaN payloads away, that should minimize the degree to which the implementation needs to be considered as a constraint in having that discussion.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; To your original email, I agree this is an important problem to tackle, and that we should handle the inhabitant masking when the FP value is converted to optional.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; That said, I don’t understand the above.  With the “b11” representation, what how is a &quot;Double?&quot; tested for “.None&quot;? One advantage of using the signbit is that “is negative” comparisons are very cheap on risc systems, because you don’t have to materialize a large/weird immediate.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That&#39;s why I liked using the sign bit originally too. Steve noted that, since any operation on an Optional is probably going to involve testing and branching before revealing the underlying float value, and float comparisons and branches tend to unavoidably burn a couple cycles engaging the integer ALU, there&#39;s unlikely to be much benefit on ARM or Intel avoiding integer masking operations. (More strictly RISCy architectures like Power would be more negatively impacted, perhaps.) On ARM64 at least, the bitmask for a b11 NaN is still representable as an immediate, since it involves a single contiguous run of 1 bits.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There isn&#39;t any efficient way of just testing the sign bit of a value using FP instructions that I can see.  You could maybe take advantage of the vector registers overlapping the FP registers and use integer vector operations, but it would take a lot of code and have false-dependency problems.  So in both representations, the most efficient test sequence seems to be (1) get value in integer register (2) compare against some specific integer value.  And in that case, in both representations it seems to me that the obvious extra-inhabitant sequence is 0xFFFFFFFF, 0xFFFFFFFE, …<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The test for detecting the reserved encoding is essentially identical either way (pseudo-assembly):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	detectNegativeNaN:<br>&gt;&gt;&gt; 		ADD encoding, encoding, 0x0010000000000000<br>&gt;&gt;&gt; 		JC nil<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	detectLeading11NaN:<br>&gt;&gt;&gt; 		ADD encoding, encoding, 0x0004000000000000<br>&gt;&gt;&gt; 		JO nil<br>&gt;&gt; <br>&gt;&gt; Sure, that&#39;s basically just a different way of spelling the comparison.  For the most part, though, Swift will not need to perform this operation; it&#39;ll be checking for a specific value.  I don&#39;t see any reason to say that e.g. .none can be encoded by an arbitrary reserved NaN rather than a specific one.<br>&gt; <br>&gt; That doesn&#39;t quite happen when the other case also has a payload.<br>&gt; <br>&gt; enum SmallIntOrBigFloat {<br>&gt;   case small(Int8)<br>&gt;   case big(Double)<br>&gt; }<br></p><p>I don&#39;t know if we actually do that particular optimization, but sure, there are situations where this comes up.  The more important one to my mind is that the value witnesses for Float will have to return an abstract index; that&#39;s the path that will be used by generic code that&#39;s working with a T?.<br></p><p>John.<br></p><p>&gt; <br>&gt; Jordan<br>&gt; <br>&gt;&gt; Anyway, we&#39;re agreed that both representations require doing integer comparisons on the value, not FP comparisons, and so operations on Float? will generally require moving the value between register banks if we do this.  It&#39;s not as pure a win as we might hope.  Still probably worthwhile, though.<br>&gt; <br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161024/65ea6f11/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Making the sign of NaNs unspecified to enable enum layout optimization</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>October 24, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Oct 24, 2016, at 12:58 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Oct 24, 2016, at 12:30 PM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;&gt;&gt; On Oct 24, 2016, at 2:55 PM, John McCall via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 24, 2016, at 8:49 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; On Oct 22, 2016, at 10:39 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Oct 20, 2016, at 2:59 PM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; copysign( ) is a reason to not pick the first option.  I’m not very worried about it, but it is a reason.  I see no problem with the second option.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; As we discussed in person this morning, de-canonicalizing b11 might be a better compromise to minimize the potential impact of layout optimizations. That would leave the implementation with 2^51 NaN representations (50 significand bits, plus the sign bit) in Double to play with, which ought to be enough for anyone™. I liked the idea of using the sign bit originally since testing for NaNs and sign bits is something that can be easily done using common FPU instructions without crossing domains, but as you noted, it sounds like comparison and branching operations tend to do that anyway, so masking and branching using integer operations shouldn&#39;t be too much of a burden. Jordan&#39;s question of to what degree we consider different NaN encodings to be distinct semantic values is still an interesting one, but if we take only the b11 NaN payloads away, that should minimize the degree to which the implementation needs to be considered as a constraint in having that discussion.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; To your original email, I agree this is an important problem to tackle, and that we should handle the inhabitant masking when the FP value is converted to optional.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That said, I don’t understand the above.  With the “b11” representation, what how is a &quot;Double?&quot; tested for “.None&quot;? One advantage of using the signbit is that “is negative” comparisons are very cheap on risc systems, because you don’t have to materialize a large/weird immediate.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That&#39;s why I liked using the sign bit originally too. Steve noted that, since any operation on an Optional is probably going to involve testing and branching before revealing the underlying float value, and float comparisons and branches tend to unavoidably burn a couple cycles engaging the integer ALU, there&#39;s unlikely to be much benefit on ARM or Intel avoiding integer masking operations. (More strictly RISCy architectures like Power would be more negatively impacted, perhaps.) On ARM64 at least, the bitmask for a b11 NaN is still representable as an immediate, since it involves a single contiguous run of 1 bits.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There isn&#39;t any efficient way of just testing the sign bit of a value using FP instructions that I can see.  You could maybe take advantage of the vector registers overlapping the FP registers and use integer vector operations, but it would take a lot of code and have false-dependency problems.  So in both representations, the most efficient test sequence seems to be (1) get value in integer register (2) compare against some specific integer value.  And in that case, in both representations it seems to me that the obvious extra-inhabitant sequence is 0xFFFFFFFF, 0xFFFFFFFE, …<br>&gt;&gt; <br>&gt;&gt; The test for detecting the reserved encoding is essentially identical either way (pseudo-assembly):<br>&gt;&gt; <br>&gt;&gt; 	detectNegativeNaN:<br>&gt;&gt; 		ADD encoding, encoding, 0x0010000000000000<br>&gt;&gt; 		JC nil<br>&gt;&gt; <br>&gt;&gt; 	detectLeading11NaN:<br>&gt;&gt; 		ADD encoding, encoding, 0x0004000000000000<br>&gt;&gt; 		JO nil<br>&gt; <br>&gt; Sure, that&#39;s basically just a different way of spelling the comparison.  For the most part, though, Swift will not need to perform this operation; it&#39;ll be checking for a specific value.  I don&#39;t see any reason to say that e.g. .none can be encoded by an arbitrary reserved NaN rather than a specific one.<br></p><p>When we know there&#39;s exactly one no-payload case, as with .none in Optional, we do have the option of testing for an arbitrary extra inhabitant if it happens to be cheaper/smaller code, since having any extra inhabitant representation other than the first would be UB anyway. In these cases, either the mask or first inhabitant should fit in an ARM64 bitmask immediate, and are a 64-bit movabs on Intel either way, so it&#39;s probably not worthwhile.<br></p><p>&gt; Anyway, we&#39;re agreed that both representations require doing integer comparisons on the value, not FP comparisons, and so operations on Float? will generally require moving the value between register banks if we do this.  It&#39;s not as pure a win as we might hope.  Still probably worthwhile, though.<br></p><p>Right. Since there&#39;s no perf benefit to using the sign bit, using b11 payloads has the least potential of interfering with users trying to use specific NaN encodings for their own purposes.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161024/4dc1f40e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Making the sign of NaNs unspecified to enable enum layout optimization</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>October 24, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Oct 24, 2016, at 1:23 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; On Oct 24, 2016, at 12:58 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 24, 2016, at 12:30 PM, Stephen Canon &lt;scanon at apple.com &lt;mailto:scanon at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; On Oct 24, 2016, at 2:55 PM, John McCall via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Oct 24, 2016, at 8:49 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; On Oct 22, 2016, at 10:39 AM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 20, 2016, at 2:59 PM, Joe Groff via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; copysign( ) is a reason to not pick the first option.  I’m not very worried about it, but it is a reason.  I see no problem with the second option.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; As we discussed in person this morning, de-canonicalizing b11 might be a better compromise to minimize the potential impact of layout optimizations. That would leave the implementation with 2^51 NaN representations (50 significand bits, plus the sign bit) in Double to play with, which ought to be enough for anyone™. I liked the idea of using the sign bit originally since testing for NaNs and sign bits is something that can be easily done using common FPU instructions without crossing domains, but as you noted, it sounds like comparison and branching operations tend to do that anyway, so masking and branching using integer operations shouldn&#39;t be too much of a burden. Jordan&#39;s question of to what degree we consider different NaN encodings to be distinct semantic values is still an interesting one, but if we take only the b11 NaN payloads away, that should minimize the degree to which the implementation needs to be considered as a constraint in having that discussion.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; To your original email, I agree this is an important problem to tackle, and that we should handle the inhabitant masking when the FP value is converted to optional.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; That said, I don’t understand the above.  With the “b11” representation, what how is a &quot;Double?&quot; tested for “.None&quot;? One advantage of using the signbit is that “is negative” comparisons are very cheap on risc systems, because you don’t have to materialize a large/weird immediate.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That&#39;s why I liked using the sign bit originally too. Steve noted that, since any operation on an Optional is probably going to involve testing and branching before revealing the underlying float value, and float comparisons and branches tend to unavoidably burn a couple cycles engaging the integer ALU, there&#39;s unlikely to be much benefit on ARM or Intel avoiding integer masking operations. (More strictly RISCy architectures like Power would be more negatively impacted, perhaps.) On ARM64 at least, the bitmask for a b11 NaN is still representable as an immediate, since it involves a single contiguous run of 1 bits.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There isn&#39;t any efficient way of just testing the sign bit of a value using FP instructions that I can see.  You could maybe take advantage of the vector registers overlapping the FP registers and use integer vector operations, but it would take a lot of code and have false-dependency problems.  So in both representations, the most efficient test sequence seems to be (1) get value in integer register (2) compare against some specific integer value.  And in that case, in both representations it seems to me that the obvious extra-inhabitant sequence is 0xFFFFFFFF, 0xFFFFFFFE, …<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The test for detecting the reserved encoding is essentially identical either way (pseudo-assembly):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	detectNegativeNaN:<br>&gt;&gt;&gt; 		ADD encoding, encoding, 0x0010000000000000<br>&gt;&gt;&gt; 		JC nil<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	detectLeading11NaN:<br>&gt;&gt;&gt; 		ADD encoding, encoding, 0x0004000000000000<br>&gt;&gt;&gt; 		JO nil<br>&gt;&gt; <br>&gt;&gt; Sure, that&#39;s basically just a different way of spelling the comparison.  For the most part, though, Swift will not need to perform this operation; it&#39;ll be checking for a specific value.  I don&#39;t see any reason to say that e.g. .none can be encoded by an arbitrary reserved NaN rather than a specific one.<br>&gt; <br>&gt; When we know there&#39;s exactly one no-payload case, as with .none in Optional, we do have the option of testing for an arbitrary extra inhabitant if it happens to be cheaper/smaller code, since having any extra inhabitant representation other than the first would be UB anyway.<br></p><p>Sure.<br></p><p>&gt; In these cases, either the mask or first inhabitant should fit in an ARM64 bitmask immediate, and are a 64-bit movabs on Intel either way, so it&#39;s probably not worthwhile.<br></p><p>Well, if we always set the sign bit on our extra inhabitants, we end up with a prefix that&#39;s amenable to extra inhabitants typically being small-magnitude negative numbers, right?  Or am I missing something important?<br></p><p>&gt;&gt; Anyway, we&#39;re agreed that both representations require doing integer comparisons on the value, not FP comparisons, and so operations on Float? will generally require moving the value between register banks if we do this.  It&#39;s not as pure a win as we might hope.  Still probably worthwhile, though.<br>&gt; <br>&gt; Right. Since there&#39;s no perf benefit to using the sign bit, using b11 payloads has the least potential of interfering with users trying to use specific NaN encodings for their own purposes.<br></p><p>I agree.<br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161024/3bfff0f0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Making the sign of NaNs unspecified to enable enum layout optimization</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>October 24, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Oct 24, 2016, at 1:36 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Oct 24, 2016, at 1:23 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; On Oct 24, 2016, at 12:58 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 24, 2016, at 12:30 PM, Stephen Canon &lt;scanon at apple.com &lt;mailto:scanon at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; On Oct 24, 2016, at 2:55 PM, John McCall via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Oct 24, 2016, at 8:49 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 22, 2016, at 10:39 AM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 20, 2016, at 2:59 PM, Joe Groff via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; copysign( ) is a reason to not pick the first option.  I’m not very worried about it, but it is a reason.  I see no problem with the second option.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; As we discussed in person this morning, de-canonicalizing b11 might be a better compromise to minimize the potential impact of layout optimizations. That would leave the implementation with 2^51 NaN representations (50 significand bits, plus the sign bit) in Double to play with, which ought to be enough for anyone™. I liked the idea of using the sign bit originally since testing for NaNs and sign bits is something that can be easily done using common FPU instructions without crossing domains, but as you noted, it sounds like comparison and branching operations tend to do that anyway, so masking and branching using integer operations shouldn&#39;t be too much of a burden. Jordan&#39;s question of to what degree we consider different NaN encodings to be distinct semantic values is still an interesting one, but if we take only the b11 NaN payloads away, that should minimize the degree to which the implementation needs to be considered as a constraint in having that discussion.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; To your original email, I agree this is an important problem to tackle, and that we should handle the inhabitant masking when the FP value is converted to optional.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; That said, I don’t understand the above.  With the “b11” representation, what how is a &quot;Double?&quot; tested for “.None&quot;? One advantage of using the signbit is that “is negative” comparisons are very cheap on risc systems, because you don’t have to materialize a large/weird immediate.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; That&#39;s why I liked using the sign bit originally too. Steve noted that, since any operation on an Optional is probably going to involve testing and branching before revealing the underlying float value, and float comparisons and branches tend to unavoidably burn a couple cycles engaging the integer ALU, there&#39;s unlikely to be much benefit on ARM or Intel avoiding integer masking operations. (More strictly RISCy architectures like Power would be more negatively impacted, perhaps.) On ARM64 at least, the bitmask for a b11 NaN is still representable as an immediate, since it involves a single contiguous run of 1 bits.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There isn&#39;t any efficient way of just testing the sign bit of a value using FP instructions that I can see.  You could maybe take advantage of the vector registers overlapping the FP registers and use integer vector operations, but it would take a lot of code and have false-dependency problems.  So in both representations, the most efficient test sequence seems to be (1) get value in integer register (2) compare against some specific integer value.  And in that case, in both representations it seems to me that the obvious extra-inhabitant sequence is 0xFFFFFFFF, 0xFFFFFFFE, …<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The test for detecting the reserved encoding is essentially identical either way (pseudo-assembly):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	detectNegativeNaN:<br>&gt;&gt;&gt;&gt; 		ADD encoding, encoding, 0x0010000000000000<br>&gt;&gt;&gt;&gt; 		JC nil<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	detectLeading11NaN:<br>&gt;&gt;&gt;&gt; 		ADD encoding, encoding, 0x0004000000000000<br>&gt;&gt;&gt;&gt; 		JO nil<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sure, that&#39;s basically just a different way of spelling the comparison.  For the most part, though, Swift will not need to perform this operation; it&#39;ll be checking for a specific value.  I don&#39;t see any reason to say that e.g. .none can be encoded by an arbitrary reserved NaN rather than a specific one.<br>&gt;&gt; <br>&gt;&gt; When we know there&#39;s exactly one no-payload case, as with .none in Optional, we do have the option of testing for an arbitrary extra inhabitant if it happens to be cheaper/smaller code, since having any extra inhabitant representation other than the first would be UB anyway.<br>&gt; <br>&gt; Sure.<br>&gt; <br>&gt;&gt; In these cases, either the mask or first inhabitant should fit in an ARM64 bitmask immediate, and are a 64-bit movabs on Intel either way, so it&#39;s probably not worthwhile.<br>&gt; <br>&gt; Well, if we always set the sign bit on our extra inhabitants, we end up with a prefix that&#39;s amenable to extra inhabitants typically being small-magnitude negative numbers, right?  Or am I missing something important?<br></p><p>Ah, I see what you&#39;re saying now. Yeah, setting the sign bit for extra inhabitants definitely makes sense, for the benefit of platforms with less clever immediate encodings.<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161024/f3561ffe/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Making the sign of NaNs unspecified to enable enum layout optimization</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>October 20, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Oct 19, 2016, at 8:42 PM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; I had a discussion with Steve this morning about the potential for enum layout optimization with floating-point payloads. One great thing about floating-point is that it has NaNs, and lots of them. For the most part, the only significant semantic difference among these NaNs is whether they&#39;re signaling or not, so it&#39;s tempting to reclaim some of these representations for other purposes. Javascript engines are of course famous for &quot;NaN-encoding&quot; values, representing JS numbers as native Doubles and packing pointers to non-number object instances into the same representation by using NaN bit patterns. In Swift, we could do similar things for enums with floating-point payloads, making &#39;Float?&#39; and &#39;Double?&#39; take the same amount of space as non-optionals, and automatically applying Javascript-style layout optimizations when defining enums with mixed float and object payloads. IEEE 754 is ambivalent about the role of NaN payloads, and there are libraries that use payloads for interesting diagnostic purposes, but the standard declares up front that it &quot;does not interpret the sign of a NaN&quot; (section 6.3). Reserving &quot;negative&quot; NaNs with the sign bit set as extra inhabitants could let us do enum layout optimization without interfering with the ability for libraries to freely use NaN payloads.<br>&gt; <br>&gt; However, the way we usually handle enum optimization with extra inhabitants is problematic for floats. We normally say that it is undefined behavior for a value to have an extra inhabitant representation—a class reference cannot be null, a Bool can only be 0 or 1, and so on. With floats, we need to interoperate with numerics code not written in Swift, and we want to be able to read floating-point data out of memory that may use arbitrary bit patterns. We don&#39;t want every double-returning C function or load from memory to require a check for reserved values afterward. Making it undefined behavior for floats to have &quot;extra inhabitant&quot; representations is thus probably not practical.<br>&gt; <br>&gt; Instead of saying that extra inhabitants are undefined behavior, we could instead continue to allow Floats and Doubles to have arbitrary bit patterns, and only check for reserved values at the point we construct an enum that wants to use reserved values for layout. If we reserve negative NaNs, then for example, constructing a Float? or Double? from a nonoptional value would check whether the payload value is NaN and if so, clear the sign bit at that point. That way, we don&#39;t have any ABI problems with Floats and Doubles from foreign sources, but still get the benefits of layout optimization for Swift types. On the other hand, this would mean that supposedly-idempotent operations like &#39;.some(x)!&#39; lose the sign information for NaNs. Since we wouldn&#39;t want to prevent the optimizer from folding those kinds of operations away, we could define Swift&#39;s semantics to say that querying the sign of a NaN value produces an unspecified value. This matches the intent of IEEE 754, and shouldn&#39;t impact most numerics code in practice. If we were interested in pursuing enum layout optimization with float payloads, I think this would be the best approach.<br></p><p>As an implementation matter, is this going to significantly complicate the &quot;make a T? from an unknown T&quot; path?  Currently, I think that logic just asks whether a type has extra inhabitants; it doesn&#39;t have any notion of having to rewrite actual values to avoid colliding with the &quot;extra&quot; inhabitants.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Making the sign of NaNs unspecified to enable enum layout optimization</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>October 20, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Oct 20, 2016, at 10:45 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Oct 19, 2016, at 8:42 PM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; I had a discussion with Steve this morning about the potential for enum layout optimization with floating-point payloads. One great thing about floating-point is that it has NaNs, and lots of them. For the most part, the only significant semantic difference among these NaNs is whether they&#39;re signaling or not, so it&#39;s tempting to reclaim some of these representations for other purposes. Javascript engines are of course famous for &quot;NaN-encoding&quot; values, representing JS numbers as native Doubles and packing pointers to non-number object instances into the same representation by using NaN bit patterns. In Swift, we could do similar things for enums with floating-point payloads, making &#39;Float?&#39; and &#39;Double?&#39; take the same amount of space as non-optionals, and automatically applying Javascript-style layout optimizations when defining enums with mixed float and object payloads. IEEE 754 is ambivalent about the role of NaN payloads, and there are libraries that use payloads for interesting diagnostic purposes, but the standard declares up front that it &quot;does not interpret the sign of a NaN&quot; (section 6.3). Reserving &quot;negative&quot; NaNs with the sign bit set as extra inhabitants could let us do enum layout optimization without interfering with the ability for libraries to freely use NaN payloads.<br>&gt;&gt; <br>&gt;&gt; However, the way we usually handle enum optimization with extra inhabitants is problematic for floats. We normally say that it is undefined behavior for a value to have an extra inhabitant representation—a class reference cannot be null, a Bool can only be 0 or 1, and so on. With floats, we need to interoperate with numerics code not written in Swift, and we want to be able to read floating-point data out of memory that may use arbitrary bit patterns. We don&#39;t want every double-returning C function or load from memory to require a check for reserved values afterward. Making it undefined behavior for floats to have &quot;extra inhabitant&quot; representations is thus probably not practical.<br>&gt;&gt; <br>&gt;&gt; Instead of saying that extra inhabitants are undefined behavior, we could instead continue to allow Floats and Doubles to have arbitrary bit patterns, and only check for reserved values at the point we construct an enum that wants to use reserved values for layout. If we reserve negative NaNs, then for example, constructing a Float? or Double? from a nonoptional value would check whether the payload value is NaN and if so, clear the sign bit at that point. That way, we don&#39;t have any ABI problems with Floats and Doubles from foreign sources, but still get the benefits of layout optimization for Swift types. On the other hand, this would mean that supposedly-idempotent operations like &#39;.some(x)!&#39; lose the sign information for NaNs. Since we wouldn&#39;t want to prevent the optimizer from folding those kinds of operations away, we could define Swift&#39;s semantics to say that querying the sign of a NaN value produces an unspecified value. This matches the intent of IEEE 754, and shouldn&#39;t impact most numerics code in practice. If we were interested in pursuing enum layout optimization with float payloads, I think this would be the best approach.<br>&gt; <br>&gt; As an implementation matter, is this going to significantly complicate the &quot;make a T? from an unknown T&quot; path?  Currently, I think that logic just asks whether a type has extra inhabitants; it doesn&#39;t have any notion of having to rewrite actual values to avoid colliding with the &quot;extra&quot; inhabitants.<br></p><p>It&#39;s true that it would no longer be a guaranteed identity operation, but we already have the notion of &quot;inject tag&quot; in the abstract access pattern for enums, which occurs after the payload has been stored, which normally sets the extra tag bits. It seems to me we could also use it to collapse NaN representations when the &quot;some&quot; tag is injected over a float (though we would need a &quot;evacuateExtraInhabitantRepresentations&quot; value witness to do this generically).<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161020/12a8e344/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Making the sign of NaNs unspecified to enable enum layout optimization</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>October 20, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Oct 20, 2016, at 10:50 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; On Oct 20, 2016, at 10:45 AM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 19, 2016, at 8:42 PM, Joe Groff via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; I had a discussion with Steve this morning about the potential for enum layout optimization with floating-point payloads. One great thing about floating-point is that it has NaNs, and lots of them. For the most part, the only significant semantic difference among these NaNs is whether they&#39;re signaling or not, so it&#39;s tempting to reclaim some of these representations for other purposes. Javascript engines are of course famous for &quot;NaN-encoding&quot; values, representing JS numbers as native Doubles and packing pointers to non-number object instances into the same representation by using NaN bit patterns. In Swift, we could do similar things for enums with floating-point payloads, making &#39;Float?&#39; and &#39;Double?&#39; take the same amount of space as non-optionals, and automatically applying Javascript-style layout optimizations when defining enums with mixed float and object payloads. IEEE 754 is ambivalent about the role of NaN payloads, and there are libraries that use payloads for interesting diagnostic purposes, but the standard declares up front that it &quot;does not interpret the sign of a NaN&quot; (section 6.3). Reserving &quot;negative&quot; NaNs with the sign bit set as extra inhabitants could let us do enum layout optimization without interfering with the ability for libraries to freely use NaN payloads.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However, the way we usually handle enum optimization with extra inhabitants is problematic for floats. We normally say that it is undefined behavior for a value to have an extra inhabitant representation—a class reference cannot be null, a Bool can only be 0 or 1, and so on. With floats, we need to interoperate with numerics code not written in Swift, and we want to be able to read floating-point data out of memory that may use arbitrary bit patterns. We don&#39;t want every double-returning C function or load from memory to require a check for reserved values afterward. Making it undefined behavior for floats to have &quot;extra inhabitant&quot; representations is thus probably not practical.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Instead of saying that extra inhabitants are undefined behavior, we could instead continue to allow Floats and Doubles to have arbitrary bit patterns, and only check for reserved values at the point we construct an enum that wants to use reserved values for layout. If we reserve negative NaNs, then for example, constructing a Float? or Double? from a nonoptional value would check whether the payload value is NaN and if so, clear the sign bit at that point. That way, we don&#39;t have any ABI problems with Floats and Doubles from foreign sources, but still get the benefits of layout optimization for Swift types. On the other hand, this would mean that supposedly-idempotent operations like &#39;.some(x)!&#39; lose the sign information for NaNs. Since we wouldn&#39;t want to prevent the optimizer from folding those kinds of operations away, we could define Swift&#39;s semantics to say that querying the sign of a NaN value produces an unspecified value. This matches the intent of IEEE 754, and shouldn&#39;t impact most numerics code in practice. If we were interested in pursuing enum layout optimization with float payloads, I think this would be the best approach.<br>&gt;&gt; <br>&gt;&gt; As an implementation matter, is this going to significantly complicate the &quot;make a T? from an unknown T&quot; path?  Currently, I think that logic just asks whether a type has extra inhabitants; it doesn&#39;t have any notion of having to rewrite actual values to avoid colliding with the &quot;extra&quot; inhabitants.<br>&gt; <br>&gt; It&#39;s true that it would no longer be a guaranteed identity operation, but we already have the notion of &quot;inject tag&quot; in the abstract access pattern for enums, which occurs after the payload has been stored, which normally sets the extra tag bits. It seems to me we could also use it to collapse NaN representations when the &quot;some&quot; tag is injected over a float (though we would need a &quot;evacuateExtraInhabitantRepresentations&quot; value witness to do this generically).<br></p><p>This seems reasonable.  We could use the same thing to take advantage of spare bits that the type doesn&#39;t promise to initialize, e.g. in a struct with internal padding.<br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161020/0d1f0366/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
