<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d972db2b6ee8b77746ce7122663eb4f8?s=50"></div><header><strong>[Proposal] Qualified Imports and Modules</strong> from <string>Robert Widmann</string> &lt;rwidmann at apple.com&gt;<p>July 18, 2016 at 02:00:00pm</p></header><div class="content"><p>Hello all,<br></p><p>TJ Usiyan, Harlan Haskins, and I have been working on a proposal to rework qualified imports and introduce an explicit module system to Swift that we’d like to publish for your viewing pleasure.<br></p><p>The initial impetus was set out in a radar (rdar://17630570) I sent fairly early on that didn’t receive a response, so I started a swift-evolution &lt;http://permalink.gmane.org/gmane.comp.lang.swift.evolution/1378&gt; thread discussing the basics of this proposal.  It has been refined and expanded a bit to include an effort to make Swift modules explicit and updated with the feedback of that first thread.  Contents of the proposal are inline and can also be had as a gist &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6&gt; or on Github. &lt;https://github.com/apple/swift-evolution/pull/440&gt;<br></p><p>Cheers,<br></p><p>~Robert Widmann<br></p><p>Qualified Imports and Modules<br></p><p>Proposal: SE-NNNN &lt;https://gist.github.com/CodaFi/NNNN-first-class-qualified-imports.md&gt;<br>Authors: Robert Widmann &lt;https://github.com/codafi&gt;, Harlan Haskins &lt;https://github.com/harlanhaskins&gt;, TJ Usiyan &lt;https://github.com/griotspeak&gt;<br>Status: Awaiting review<br>Review manager: TBD<br> &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#introduction&gt;Introduction<br></p><p>We propose a complete overhaul of the qualified imports syntax and semantics and the introduction of a module system.<br></p><p> &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#motivation&gt;Motivation<br></p><p>Swift code is modular by default. However, it is not clear how to decompose existing modules further into submodules. In addition, it is difficult to tell how importing a module affects its export to consumers of a library. This leads many to either fake namespaces with enums, attempt to structure Swift code with modulemaps, or use a large amount of version-control submodules. All of these can be rolled into one complete package in the form of a comprehensive rethink of the qualified import system and the introduction of a module system.<br></p><p> &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#proposed-solution&gt;Proposed solution<br></p><p>Modules will now become an explicit part of working with canonical Swift code. The grammar and semantics of qualified imports will change completely with the addition of import qualifiers and import directives. We also introduce three new contextual keywords: using, hiding, and renaming, to facilitate fine-grained usage of module contents.<br></p><p> &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#detailed-design&gt;Detailed design<br></p><p>Qualified import syntax will be revised to the following<br></p><p>module-decl -&gt; module &lt;module-path&gt;<br>import-decl -&gt; &lt;access-level-modifier&gt; import &lt;module-path&gt; &lt;(opt) import-directive-list&gt;<br>module-path -&gt; &lt;identifier&gt;<br>            -&gt; &lt;identifier&gt;.&lt;import-path&gt;<br>import-directive-list -&gt; &lt;import-directive&gt;<br>                      -&gt; &lt;import-directive&gt; &lt;import-directive-list&gt;<br>import-directive -&gt; using (&lt;identifier&gt;, ...)<br>                 -&gt; hiding (&lt;identifier&gt;, ...)<br>                 -&gt; renaming (&lt;identifier&gt;, to: &lt;identifier&gt;, ...)<br>This introduces the concept of an import directive. An import directive is a file-local modification of an imported identifier. A directive can be one of 3 operations:<br></p><p>1) using: The using directive is followed by a list of identifiers within the imported module that should be exposed to this file. <br></p><p>// The only visible parts of Foundation in this file are <br>// Date.init(), Date.hashValue, and Date.description.<br>import Foundation.Date using (Date.init(), Date.hashValue, Date.description)<br>2) hiding: The hiding directive is followed by a list of identifiers within the imported module that should be hidden from this file.<br></p><p>// Imports all of Foundation.Date except `Date.compare()`<br>import Foundation.Date hiding (Date.compare())<br>3) renaming: The renaming directive is followed by a list of identifiers separated by to: that should be exposed to this file but renamed. <br></p><p>// Imports all of Dispatch.DispatchQueue but renames the static member <br>// DispatchQueue.main, to DispatchQueue.mainQueue<br>import Dispatch.DispatchQueue renaming (DispatchQueue.Type.main to: DispatchQueue.Type.mainQueue)<br>// Renaming can also rename modules.  All members of UIKit have to be qualified with<br>// `UI` now.<br>import UIKit renaming (UIKit, to: UI)<br>Import directives chain to one another and can be used to create a fine-grained module import:<br></p><p>// Imports all of Foundation except `DateFormatter` and renames `Cache` to `LRUCache`<br>import Foundation hiding (DateFormatter) renaming (Cache to: LRUCache)<br>// Imports SCNNode except SCNNode.init(mdlObject:) and renames `.description` to<br>// `.nodeDescription` <br>import SceneKit using (SCNNode) <br>                renaming (SCNNode.description, to: SCNNode.nodeDescription)<br>                hiding (SCNNode.init(mdlObject:))<br>Directive chaining occurs left-to-right:<br></p><p>// This says to 1) Hide nothing 2) Use nothing 3) rename Int to INT.  It is invalid<br>// because 1) We will show everything 2) Then hide everything 3) Therefore Int is unavailable, error.<br>import Swift hiding () using () renaming (Int, to: INT)<br>// This says to 1) Use Int 2) Hide String 3) rename Double to Triple.  It is invalid<br>// because 1) Int is available 2) String is not, error. 3) Double is unavailable, error.<br>import Swift using (Int) hiding (String) renaming (Double, to: Triple)<br>// Valid.  This will be merged as `using (Int)`<br>import Swift using () using (Int)<br>// Valid.  This will be merged as `hiding (String, Double)`<br>import Swift hiding (String) hiding (Double) hiding ()<br>// Valid (if redundant). This will be merged as `using ()`<br>import Swift using (String) hiding (String)<br>Module scope is delimited by the keyword module followed by a fully qualified name and must occur as the first declaration in a file. For example:<br></p><p>// ./Math/Integers/Arithmetic.swift<br>module Math.Integers.Arithmetic<br></p><p>public protocol _IntegerArithmetic {}<br></p><p>public struct _Abs {}<br></p><p>@_versioned<br>internal func _abs&lt;Args&gt;(_ args: Args) -&gt; (_Abs, Args) {}<br></p><p>// ./Math/Integers.swift<br>module Math.Integers<br></p><p>// _abs is visible in this module and all others within the project, <br>// but is not exported along with it.<br>internal import Math.Integers.Arithmetic<br></p><p>public protocol IntegerArithmetic : _IntegerArithmetic, Comparable {}<br>public protocol SignedNumber : Comparable, ExpressibleByIntegerLiteral {}<br></p><p><br>// Math.swift<br>module Math<br></p><p>// Exports the entire public contents of Math.Integers, but nothing in <br>// Math.Integers.Arithmetic.<br>public import Math.Integers<br>Modules names are tied to a directory structure that describes their location relative to the current module and it will now be an error to violate this rule. For example:<br></p><p>module String // lives in ./String.swift<br>module String.Core // lives in ./String/Core.swift<br>module String.Core.Internals.Do.You.Even.Write // lives in ./String/Core/Internals/Do/You/Even/Write.swift<br>Existing projects that do not adopt these rules will still retain their implicit module name (usually defined as the name of the framework or application that is being built) and may continue to use whatever directory structure they wish, however they may not declare any explicit modules.<br></p><p>This proposal also solves the problem of module export. A module that is imported without an access level modifier will default to an internal import per usual. However, when it is useful to fully expose the public content of submodules to a client, a public modifier can be used. Similarly, when it is useful to access internal or [file]private APIs, but not expose them to clients, those access modifiers may be used. The rule of thumb is: Only identifiers that are at least as visible as the qualifier on the import make for valid import declarations. For example:<br></p><p>// A submodule declaring a `private` class that gets imported with <br>// an `internal` qualifier with a `using` directive is an invalid import <br>// declaration.  <br>module Foo.Bar<br></p><p>private class PrivateThing {}<br></p><p>module Foo<br></p><p>// Error: PrivateThing not visible, use `private import`<br>import Foo.Bar using (PrivateThing) <br>// However, a submodule declaring a `public` struct that gets imported with <br>// an `private` qualifier is a valid import declaration.<br>module Foo.Bar<br></p><p>public class PublicThing {}<br></p><p>module Foo<br></p><p>// All good!  Foo can see Foo.Bar.PrivateThing.<br>private import Foo.Bar using (PublicThing) <br>Because import directives are file-local, they will never be exported along with a public import and will default to exporting the entire contents of the module as though you had never declared them.<br></p><p>// In this file and this file alone, the directives apply.  To the user<br>// of this module, it is as though this declaration were simply:<br>// public import Foundation.Date<br>public import Foundation.Date hiding (Date.init()) <br>                              renaming (Date.Type.distantPast, <br>                                        to: Date.Type.letsGoLivingInThePast,<br>                                        Date.Type.timeIntervalSinceReferenceDate, <br>                                        to: Date.Type.startOfTheUniverse)<br>                              renaming (Date.Type.&lt;, to: Date.Type.&lt;&lt;&lt;&lt;&lt;)<br> &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#impact-on-existing-code&gt;Impact on existing code<br></p><p>Existing code that is using qualified module import syntax (import {func|class|typealias|class|struct|enum|protocol} &lt;qualified-name&gt;) will be deprecated. Code that is not organized into modules will remain unaffected and organized into one contiguous top-level module. However, it is strongly recommended that frameworks be decomposed and reorganized around the new module system.<br></p><p>As a case study, the public interface to the standard library appears to already be mostly broken down into submodules as described in GroupInfo.json &lt;https://github.com/apple/swift/blob/master/stdlib/public/core/GroupInfo.json&gt;.<br></p><p>Code that is defined in modulemaps already defines a module structure that can be imported directly into this scheme.<br></p><p> &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#alternatives-considered&gt;Alternatives considered<br></p><p>Module export can also be placed on the module declaration itself. The relevant parts of the grammar that have changed are below with an example:<br></p><p>module-decl -&gt; &lt;access-level-modifier&gt; module &lt;module-path&gt;<br>import-decl -&gt; import &lt;module-path&gt; &lt;(opt) import-directive-list&gt;<br>private module String.Core.Internals<br></p><p>// Shh, it&#39;s a secret.<br>While this style makes it immediately obvious to the library author which modules are public or private, it causes the consumer problems because submodule exports are no longer explicit and are entirely ad-hoc. In the interest of enabling, for one, users of IDEs to drill into public submodules, making export local to import seems more appropriate.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160718/c75638b1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Proposal] Qualified Imports and Modules</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 18, 2016 at 09:00:00pm</p></header><div class="content"><p>This is an interesting document. I think it deserves careful study. For<br>now, some questions:<br></p><p>What is the rationale behind permitting the using of specific methods? This<br>seems to be usually fine-grained in comparison to other languages. What use<br>cases do you have in mind for this?<br></p><p>I can see the use case for hiding specific symbols when they come into<br>conflict with your own, but in your example you&#39;re hiding specific methods<br>declared *in* an imported type. What is the use case here? Is it going to<br>allow me to open backdoors so that, if I don&#39;t like `Foo.frobnicate()`, I<br>can hide it and then substitute my own in an extension? This seems like a<br>bad thing at first blush.<br></p><p>I can see the obvious use case for renaming modules and types on<br>import--basically, in my mind, it&#39;s like typealiases with hiding, and it&#39;s<br>available in other languages of course. But how would renaming methods<br>work? If Foo conforms to Equatable and I rename `Foo.==` to `Foo.!=`, is<br>the type I import still Equatable? How would it behave? And even if Foo is<br>fine, what happens if I try to subclass my Frankensteinian Foo?<br></p><p>On Mon, Jul 18, 2016 at 16:10 Robert Widmann via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hello all,<br>&gt;<br>&gt; TJ Usiyan, Harlan Haskins, and I have been working on a proposal to rework<br>&gt; qualified imports and introduce an explicit module system to Swift that<br>&gt; we’d like to publish for your viewing pleasure.<br>&gt;<br>&gt; The initial impetus was set out in a radar (rdar://17630570) I sent<br>&gt; fairly early on that didn’t receive a response, so I started a<br>&gt; swift-evolution<br>&gt; &lt;http://permalink.gmane.org/gmane.comp.lang.swift.evolution/1378&gt; thread<br>&gt; discussing the basics of this proposal.  It has been refined and expanded a<br>&gt; bit to include an effort to make Swift modules explicit and updated with<br>&gt; the feedback of that first thread.  Contents of the proposal are inline and can<br>&gt; also be had as a gist<br>&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6&gt; or on<br>&gt; Github. &lt;https://github.com/apple/swift-evolution/pull/440&gt;<br>&gt;<br>&gt; Cheers,<br>&gt;<br>&gt; ~Robert Widmann<br>&gt;<br>&gt; Qualified Imports and Modules<br>&gt;<br>&gt;    - Proposal: SE-NNNN<br>&gt;    &lt;https://gist.github.com/CodaFi/NNNN-first-class-qualified-imports.md&gt;<br>&gt;    - Authors: Robert Widmann &lt;https://github.com/codafi&gt;, Harlan Haskins<br>&gt;    &lt;https://github.com/harlanhaskins&gt;, TJ Usiyan<br>&gt;    &lt;https://github.com/griotspeak&gt;<br>&gt;    - Status: Awaiting review<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; We propose a complete overhaul of the qualified imports syntax and<br>&gt; semantics and the introduction of a module system.<br>&gt;<br>&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; Swift code is modular by default. However, it is not clear how to<br>&gt; decompose existing modules further into submodules. In addition, it is<br>&gt; difficult to tell how importing a module affects its export to consumers of<br>&gt; a library. This leads many to either fake namespaces with enums, attempt to<br>&gt; structure Swift code with modulemaps, or use a large amount of<br>&gt; version-control submodules. All of these can be rolled into one complete<br>&gt; package in the form of a comprehensive rethink of the qualified import<br>&gt; system and the introduction of a module system.<br>&gt;<br>&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#proposed-solution&gt;Proposed<br>&gt; solution<br>&gt;<br>&gt; Modules will now become an explicit part of working with canonical Swift<br>&gt; code. The grammar and semantics of qualified imports will change completely<br>&gt; with the addition of *import qualifiers* and *import directives*. We also<br>&gt; introduce three new contextual keywords: using, hiding, and renaming, to<br>&gt; facilitate fine-grained usage of module contents.<br>&gt;<br>&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#detailed-design&gt;Detailed<br>&gt; design<br>&gt;<br>&gt; Qualified import syntax will be revised to the following<br>&gt;<br>&gt; module-decl -&gt; module &lt;module-path&gt;<br>&gt; import-decl -&gt; &lt;access-level-modifier&gt; import &lt;module-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt; module-path -&gt; &lt;identifier&gt;<br>&gt;             -&gt; &lt;identifier&gt;.&lt;import-path&gt;<br>&gt; import-directive-list -&gt; &lt;import-directive&gt;<br>&gt;                       -&gt; &lt;import-directive&gt; &lt;import-directive-list&gt;<br>&gt; import-directive -&gt; using (&lt;identifier&gt;, ...)<br>&gt;                  -&gt; hiding (&lt;identifier&gt;, ...)<br>&gt;                  -&gt; renaming (&lt;identifier&gt;, to: &lt;identifier&gt;, ...)<br>&gt;<br>&gt; This introduces the concept of an import *directive*. An import directive<br>&gt; is a file-local modification of an imported identifier. A directive can be<br>&gt; one of 3 operations:<br>&gt;<br>&gt; 1) *using*: The *using* directive is followed by a list of identifiers<br>&gt; within the imported module that should be exposed to this file.<br>&gt;<br>&gt; // The only visible parts of Foundation in this file are // Date.init(), Date.hashValue, and Date.description.import Foundation.Date using (Date.init(), Date.hashValue, Date.description)<br>&gt;<br>&gt; 2) *hiding*: The hiding directive is followed by a list of identifiers<br>&gt; within the imported module that should be hidden from this file.<br>&gt;<br>&gt; // Imports all of Foundation.Date except `Date.compare()`import Foundation.Date hiding (Date.compare())<br>&gt;<br>&gt; 3) *renaming*: The renaming directive is followed by a list of<br>&gt; identifiers separated by to: that should be exposed to this file but<br>&gt; renamed.<br>&gt;<br>&gt; // Imports all of Dispatch.DispatchQueue but renames the static member // DispatchQueue.main, to DispatchQueue.mainQueueimport Dispatch.DispatchQueue renaming (DispatchQueue.Type.main to: DispatchQueue.Type.mainQueue)// Renaming can also rename modules.  All members of UIKit have to be qualified with// `UI` now.import UIKit renaming (UIKit, to: UI)<br>&gt;<br>&gt; Import directives chain to one another and can be used to create a<br>&gt; fine-grained module import:<br>&gt;<br>&gt; // Imports all of Foundation except `DateFormatter` and renames `Cache` to `LRUCache`import Foundation hiding (DateFormatter) renaming (Cache to: LRUCache)// Imports SCNNode except SCNNode.init(mdlObject:) and renames `.description` to// `.nodeDescription` import SceneKit using (SCNNode)<br>&gt;                 renaming (SCNNode.description, to: SCNNode.nodeDescription)<br>&gt;                 hiding (SCNNode.init(mdlObject:))<br>&gt;<br>&gt; Directive chaining occurs left-to-right:<br>&gt;<br>&gt; // This says to 1) Hide nothing 2) Use nothing 3) rename Int to INT.  It is invalid// because 1) We will show everything 2) Then hide everything 3) Therefore Int is unavailable, error.import Swift hiding () using () renaming (Int, to: INT)// This says to 1) Use Int 2) Hide String 3) rename Double to Triple.  It is invalid// because 1) Int is available 2) String is not, error. 3) Double is unavailable, error.import Swift using (Int) hiding (String) renaming (Double, to: Triple)// Valid.  This will be merged as `using (Int)`import Swift using () using (Int)// Valid.  This will be merged as `hiding (String, Double)`import Swift hiding (String) hiding (Double) hiding ()// Valid (if redundant). This will be merged as `using ()`import Swift using (String) hiding (String)<br>&gt;<br>&gt; Module scope is delimited by the keyword module followed by a fully<br>&gt; qualified name and must occur as the first declaration in a file. For<br>&gt; example:<br>&gt;<br>&gt; // ./Math/Integers/Arithmetic.swift<br>&gt; module Math.Integers.Arithmetic<br>&gt; public protocol _IntegerArithmetic {}<br>&gt; public struct _Abs {}<br>&gt; @_versionedinternal func _abs&lt;Args&gt;(_ args: Args) -&gt; (_Abs, Args) {}<br>&gt; // ./Math/Integers.swift<br>&gt; module Math.Integers<br>&gt; // _abs is visible in this module and all others within the project, // but is not exported along with it.internal import Math.Integers.Arithmetic<br>&gt; public protocol IntegerArithmetic : _IntegerArithmetic, Comparable {}public protocol SignedNumber : Comparable, ExpressibleByIntegerLiteral {}<br>&gt;<br>&gt; // Math.swift<br>&gt; module Math<br>&gt; // Exports the entire public contents of Math.Integers, but nothing in // Math.Integers.Arithmetic.public import Math.Integers<br>&gt;<br>&gt; Modules names are tied to a directory structure that describes their<br>&gt; location relative to the current module and it will now be an error to<br>&gt; violate this rule. For example:<br>&gt;<br>&gt; module String // lives in ./String.swift<br>&gt; module String.Core // lives in ./String/Core.swift<br>&gt; module String.Core.Internals.Do.You.Even.Write // lives in ./String/Core/Internals/Do/You/Even/Write.swift<br>&gt;<br>&gt; Existing projects that do not adopt these rules will still retain their *implicit<br>&gt; module name* (usually defined as the name of the framework or application<br>&gt; that is being built) and may continue to use whatever directory structure<br>&gt; they wish, however they may not declare any explicit modules.<br>&gt;<br>&gt; This proposal also solves the problem of module *export*. A module that<br>&gt; is imported without an access level modifier will default to an internal import<br>&gt; per usual. However, when it is useful to fully expose the public content of<br>&gt; submodules to a client, a public modifier can be used. Similarly, when it<br>&gt; is useful to access internal or [file]private APIs, but not expose them<br>&gt; to clients, those access modifiers may be used. The rule of thumb is: Only<br>&gt; identifiers that are at least as visible as the qualifier on the import<br>&gt; make for valid import declarations. For example:<br>&gt;<br>&gt; // A submodule declaring a `private` class that gets imported with // an `internal` qualifier with a `using` directive is an invalid import // declaration.<br>&gt; module Foo.Bar<br>&gt; private class PrivateThing {}<br>&gt;<br>&gt; module Foo<br>&gt; // Error: PrivateThing not visible, use `private import`import Foo.Bar using (PrivateThing)<br>&gt;<br>&gt; // However, a submodule declaring a `public` struct that gets imported with // an `private` qualifier is a valid import declaration.<br>&gt; module Foo.Bar<br>&gt; public class PublicThing {}<br>&gt;<br>&gt; module Foo<br>&gt; // All good!  Foo can see Foo.Bar.PrivateThing.private import Foo.Bar using (PublicThing)<br>&gt;<br>&gt; Because import directives are file-local, they will never be exported<br>&gt; along with a public import and will default to exporting the entire<br>&gt; contents of the module as though you had never declared them.<br>&gt;<br>&gt; // In this file and this file alone, the directives apply.  To the user// of this module, it is as though this declaration were simply:// public import Foundation.Datepublic import Foundation.Date hiding (Date.init())<br>&gt;                               renaming (Date.Type.distantPast,<br>&gt;                                         to: Date.Type.letsGoLivingInThePast,<br>&gt;                                         Date.Type.timeIntervalSinceReferenceDate,<br>&gt;                                         to: Date.Type.startOfTheUniverse)<br>&gt;                               renaming (Date.Type.&lt;, to: Date.Type.&lt;&lt;&lt;&lt;&lt;)<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#impact-on-existing-code&gt;Impact<br>&gt; on existing code<br>&gt;<br>&gt; Existing code that is using qualified module import syntax (import<br>&gt; {func|class|typealias|class|struct|enum|protocol} &lt;qualified-name&gt;) will<br>&gt; be deprecated. Code that is not organized into modules will remain<br>&gt; unaffected and organized into one contiguous top-level module. However, it<br>&gt; is strongly recommended that frameworks be decomposed and reorganized<br>&gt; around the new module system.<br>&gt;<br>&gt; As a case study, the public interface to the standard library appears to<br>&gt; already be mostly broken down into submodules as described in<br>&gt; GroupInfo.json<br>&gt; &lt;https://github.com/apple/swift/blob/master/stdlib/public/core/GroupInfo.json&gt;<br>&gt; .<br>&gt;<br>&gt; Code that is defined in modulemaps already defines a module structure that<br>&gt; can be imported directly into this scheme.<br>&gt;<br>&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#alternatives-considered&gt;Alternatives<br>&gt; considered<br>&gt;<br>&gt; Module export can also be placed on the module declaration itself. The<br>&gt; relevant parts of the grammar that have changed are below with an example:<br>&gt;<br>&gt; module-decl -&gt; &lt;access-level-modifier&gt; module &lt;module-path&gt;<br>&gt; import-decl -&gt; import &lt;module-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt;<br>&gt; private module String.Core.Internals<br>&gt; // Shh, it&#39;s a secret.<br>&gt;<br>&gt; While this style makes it immediately obvious to the library author which<br>&gt; modules are public or private, it causes the consumer problems because<br>&gt; submodule exports are no longer explicit and are entirely ad-hoc. In the<br>&gt; interest of enabling, for one, users of IDEs to drill into public<br>&gt; submodules, making export local to import seems more appropriate.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160718/28b39a83/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d972db2b6ee8b77746ce7122663eb4f8?s=50"></div><header><strong>[Proposal] Qualified Imports and Modules</strong> from <string>Robert Widmann</string> &lt;rwidmann at apple.com&gt;<p>July 18, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jul 18, 2016, at 2:32 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; This is an interesting document. I think it deserves careful study. For now, some questions:<br>&gt; <br>&gt; What is the rationale behind permitting the using of specific methods? This seems to be usually fine-grained in comparison to other languages. What use cases do you have in mind for this?<br>&gt; <br></p><p>One use case: Swift libraries export not just member references as I’ve used here, but a large amount of free functions.  It has long been a problem that free functions seem to pollute a shared namespace and there didn’t seem to be a clear way to hide them.<br></p><p>&gt; I can see the use case for hiding specific symbols when they come into conflict with your own, but in your example you&#39;re hiding specific methods declared *in* an imported type. What is the use case here? Is it going to allow me to open backdoors so that, if I don&#39;t like `Foo.frobnicate()`, I can hide it and then substitute my own in an extension? This seems like a bad thing at first blush.<br></p><p>For members that would be an acceptable use-case.  The worst-case scenario that comes to mind is this being used as a way to “virtually override” a method in a subclass.  Then again, the scope of the damage is limited to the file in which you’ve declared this monstrosity so clients and even you will not be able to see it outside of there unless you explicitly redeclare the hiding import (in which case, you probably know what you’re doing).<br></p><p>A use care here might be hiding the KVO-ish parts of an object from yourself, or more generally subsetting out the part of an API you know you shouldn’t interact with in a particular submodule.<br></p><p>&gt; <br>&gt; I can see the obvious use case for renaming modules and types on import--basically, in my mind, it&#39;s like typealiases with hiding, and it&#39;s available in other languages of course. But how would renaming methods work? If Foo conforms to Equatable and I rename `Foo.==` to `Foo.!=`, is the type I import still Equatable? How would it behave? And even if Foo is fine, what happens if I try to subclass my Frankensteinian Foo?<br></p><p>Of course you still conform to Equatable.  The renaming defines a mapping from your names to “proper&quot; names.  For example, if you use a renaming import to change the requirements of a protocol in a file, then your conformance will simply look at the mapping and see that everything resolves into its proper place.  Bear in mind that your renamings will not survive outside of the file in which you declare them.  Frankenteinian Foo exists where you say it does and nowhere else.  Everybody else just sees Foo conform to Equatable (unless they rename things themselves).<br></p><p>&gt; <br>&gt; On Mon, Jul 18, 2016 at 16:10 Robert Widmann via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Hello all,<br>&gt; <br>&gt; TJ Usiyan, Harlan Haskins, and I have been working on a proposal to rework qualified imports and introduce an explicit module system to Swift that we’d like to publish for your viewing pleasure.<br>&gt; <br>&gt; The initial impetus was set out in a radar (rdar://17630570 &lt;&gt;) I sent fairly early on that didn’t receive a response, so I started a swift-evolution &lt;http://permalink.gmane.org/gmane.comp.lang.swift.evolution/1378&gt; thread discussing the basics of this proposal.  It has been refined and expanded a bit to include an effort to make Swift modules explicit and updated with the feedback of that first thread.  Contents of the proposal are inline and can also be had as a gist &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6&gt; or on Github. &lt;https://github.com/apple/swift-evolution/pull/440&gt;<br>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt; Qualified Imports and Modules<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;https://gist.github.com/CodaFi/NNNN-first-class-qualified-imports.md&gt;<br>&gt; Authors: Robert Widmann &lt;https://github.com/codafi&gt;, Harlan Haskins &lt;https://github.com/harlanhaskins&gt;, TJ Usiyan &lt;https://github.com/griotspeak&gt;<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#introduction&gt;Introduction<br>&gt; <br>&gt; We propose a complete overhaul of the qualified imports syntax and semantics and the introduction of a module system.<br>&gt; <br>&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#motivation&gt;Motivation<br>&gt; <br>&gt; Swift code is modular by default. However, it is not clear how to decompose existing modules further into submodules. In addition, it is difficult to tell how importing a module affects its export to consumers of a library. This leads many to either fake namespaces with enums, attempt to structure Swift code with modulemaps, or use a large amount of version-control submodules. All of these can be rolled into one complete package in the form of a comprehensive rethink of the qualified import system and the introduction of a module system.<br>&gt; <br>&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; Modules will now become an explicit part of working with canonical Swift code. The grammar and semantics of qualified imports will change completely with the addition of import qualifiers and import directives. We also introduce three new contextual keywords: using, hiding, and renaming, to facilitate fine-grained usage of module contents.<br>&gt; <br>&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#detailed-design&gt;Detailed design<br>&gt; <br>&gt; Qualified import syntax will be revised to the following<br>&gt; <br>&gt; module-decl -&gt; module &lt;module-path&gt;<br>&gt; import-decl -&gt; &lt;access-level-modifier&gt; import &lt;module-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt; module-path -&gt; &lt;identifier&gt;<br>&gt;             -&gt; &lt;identifier&gt;.&lt;import-path&gt;<br>&gt; import-directive-list -&gt; &lt;import-directive&gt;<br>&gt;                       -&gt; &lt;import-directive&gt; &lt;import-directive-list&gt;<br>&gt; import-directive -&gt; using (&lt;identifier&gt;, ...)<br>&gt;                  -&gt; hiding (&lt;identifier&gt;, ...)<br>&gt;                  -&gt; renaming (&lt;identifier&gt;, to: &lt;identifier&gt;, ...)<br>&gt; This introduces the concept of an import directive. An import directive is a file-local modification of an imported identifier. A directive can be one of 3 operations:<br>&gt; <br>&gt; 1) using: The using directive is followed by a list of identifiers within the imported module that should be exposed to this file. <br>&gt; <br>&gt; // The only visible parts of Foundation in this file are <br>&gt; // Date.init(), Date.hashValue, and Date.description.<br>&gt; import Foundation.Date using (Date.init(), Date.hashValue, Date.description)<br>&gt; 2) hiding: The hiding directive is followed by a list of identifiers within the imported module that should be hidden from this file.<br>&gt; <br>&gt; // Imports all of Foundation.Date except `Date.compare()`<br>&gt; import Foundation.Date hiding (Date.compare())<br>&gt; 3) renaming: The renaming directive is followed by a list of identifiers separated by to: that should be exposed to this file but renamed. <br>&gt; <br>&gt; // Imports all of Dispatch.DispatchQueue but renames the static member <br>&gt; // DispatchQueue.main, to DispatchQueue.mainQueue<br>&gt; import Dispatch.DispatchQueue renaming (DispatchQueue.Type.main to: DispatchQueue.Type.mainQueue)<br>&gt; // Renaming can also rename modules.  All members of UIKit have to be qualified with<br>&gt; // `UI` now.<br>&gt; import UIKit renaming (UIKit, to: UI)<br>&gt; Import directives chain to one another and can be used to create a fine-grained module import:<br>&gt; <br>&gt; // Imports all of Foundation except `DateFormatter` and renames `Cache` to `LRUCache`<br>&gt; import Foundation hiding (DateFormatter) renaming (Cache to: LRUCache)<br>&gt; // Imports SCNNode except SCNNode.init(mdlObject:) and renames `.description` to<br>&gt; // `.nodeDescription` <br>&gt; import SceneKit using (SCNNode) <br>&gt;                 renaming (SCNNode.description, to: SCNNode.nodeDescription)<br>&gt;                 hiding (SCNNode.init(mdlObject:))<br>&gt; Directive chaining occurs left-to-right:<br>&gt; <br>&gt; // This says to 1) Hide nothing 2) Use nothing 3) rename Int to INT.  It is invalid<br>&gt; // because 1) We will show everything 2) Then hide everything 3) Therefore Int is unavailable, error.<br>&gt; import Swift hiding () using () renaming (Int, to: INT)<br>&gt; // This says to 1) Use Int 2) Hide String 3) rename Double to Triple.  It is invalid<br>&gt; // because 1) Int is available 2) String is not, error. 3) Double is unavailable, error.<br>&gt; import Swift using (Int) hiding (String) renaming (Double, to: Triple)<br>&gt; // Valid.  This will be merged as `using (Int)`<br>&gt; import Swift using () using (Int)<br>&gt; // Valid.  This will be merged as `hiding (String, Double)`<br>&gt; import Swift hiding (String) hiding (Double) hiding ()<br>&gt; // Valid (if redundant). This will be merged as `using ()`<br>&gt; import Swift using (String) hiding (String)<br>&gt; Module scope is delimited by the keyword module followed by a fully qualified name and must occur as the first declaration in a file. For example:<br>&gt; <br>&gt; // ./Math/Integers/Arithmetic.swift<br>&gt; module Math.Integers.Arithmetic<br>&gt; <br>&gt; public protocol _IntegerArithmetic {}<br>&gt; <br>&gt; public struct _Abs {}<br>&gt; <br>&gt; @_versioned<br>&gt; internal func _abs&lt;Args&gt;(_ args: Args) -&gt; (_Abs, Args) {}<br>&gt; <br>&gt; // ./Math/Integers.swift<br>&gt; module Math.Integers<br>&gt; <br>&gt; // _abs is visible in this module and all others within the project, <br>&gt; // but is not exported along with it.<br>&gt; internal import Math.Integers.Arithmetic<br>&gt; <br>&gt; public protocol IntegerArithmetic : _IntegerArithmetic, Comparable {}<br>&gt; public protocol SignedNumber : Comparable, ExpressibleByIntegerLiteral {}<br>&gt; <br>&gt; <br>&gt; // Math.swift<br>&gt; module Math<br>&gt; <br>&gt; // Exports the entire public contents of Math.Integers, but nothing in <br>&gt; // Math.Integers.Arithmetic.<br>&gt; public import Math.Integers<br>&gt; Modules names are tied to a directory structure that describes their location relative to the current module and it will now be an error to violate this rule. For example:<br>&gt; <br>&gt; module String // lives in ./String.swift<br>&gt; module String.Core // lives in ./String/Core.swift<br>&gt; module String.Core.Internals.Do.You.Even.Write // lives in ./String/Core/Internals/Do/You/Even/Write.swift<br>&gt; Existing projects that do not adopt these rules will still retain their implicit module name (usually defined as the name of the framework or application that is being built) and may continue to use whatever directory structure they wish, however they may not declare any explicit modules.<br>&gt; <br>&gt; This proposal also solves the problem of module export. A module that is imported without an access level modifier will default to an internal import per usual. However, when it is useful to fully expose the public content of submodules to a client, a public modifier can be used. Similarly, when it is useful to access internal or [file]private APIs, but not expose them to clients, those access modifiers may be used. The rule of thumb is: Only identifiers that are at least as visible as the qualifier on the import make for valid import declarations. For example:<br>&gt; <br>&gt; // A submodule declaring a `private` class that gets imported with <br>&gt; // an `internal` qualifier with a `using` directive is an invalid import <br>&gt; // declaration.  <br>&gt; module Foo.Bar<br>&gt; <br>&gt; private class PrivateThing {}<br>&gt; <br>&gt; module Foo<br>&gt; <br>&gt; // Error: PrivateThing not visible, use `private import`<br>&gt; import Foo.Bar using (PrivateThing) <br>&gt; // However, a submodule declaring a `public` struct that gets imported with <br>&gt; // an `private` qualifier is a valid import declaration.<br>&gt; module Foo.Bar<br>&gt; <br>&gt; public class PublicThing {}<br>&gt; <br>&gt; module Foo<br>&gt; <br>&gt; // All good!  Foo can see Foo.Bar.PrivateThing.<br>&gt; private import Foo.Bar using (PublicThing) <br>&gt; Because import directives are file-local, they will never be exported along with a public import and will default to exporting the entire contents of the module as though you had never declared them.<br>&gt; <br>&gt; // In this file and this file alone, the directives apply.  To the user<br>&gt; // of this module, it is as though this declaration were simply:<br>&gt; // public import Foundation.Date<br>&gt; public import Foundation.Date hiding (Date.init()) <br>&gt;                               renaming (Date.Type.distantPast, <br>&gt;                                         to: Date.Type.letsGoLivingInThePast,<br>&gt;                                         Date.Type.timeIntervalSinceReferenceDate, <br>&gt;                                         to: Date.Type.startOfTheUniverse)<br>&gt;                               renaming (Date.Type.&lt;, to: Date.Type.&lt;&lt;&lt;&lt;&lt;)<br>&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; Existing code that is using qualified module import syntax (import {func|class|typealias|class|struct|enum|protocol} &lt;qualified-name&gt;) will be deprecated. Code that is not organized into modules will remain unaffected and organized into one contiguous top-level module. However, it is strongly recommended that frameworks be decomposed and reorganized around the new module system.<br>&gt; <br>&gt; As a case study, the public interface to the standard library appears to already be mostly broken down into submodules as described in GroupInfo.json &lt;https://github.com/apple/swift/blob/master/stdlib/public/core/GroupInfo.json&gt;.<br>&gt; <br>&gt; Code that is defined in modulemaps already defines a module structure that can be imported directly into this scheme.<br>&gt; <br>&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt; Module export can also be placed on the module declaration itself. The relevant parts of the grammar that have changed are below with an example:<br>&gt; <br>&gt; module-decl -&gt; &lt;access-level-modifier&gt; module &lt;module-path&gt;<br>&gt; import-decl -&gt; import &lt;module-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt; private module String.Core.Internals<br>&gt; <br>&gt; // Shh, it&#39;s a secret.<br>&gt; While this style makes it immediately obvious to the library author which modules are public or private, it causes the consumer problems because submodule exports are no longer explicit and are entirely ad-hoc. In the interest of enabling, for one, users of IDEs to drill into public submodules, making export local to import seems more appropriate.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160718/3ecd3861/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/36f3ec204630839e54fb68c6979e5f78?s=50"></div><header><strong>[Proposal] Qualified Imports and Modules</strong> from <string>Daniel Resnick</string> &lt;danielzresnick at gmail.com&gt;<p>July 18, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt;<br>&gt; Modules names are tied to a directory structure that describes their<br>&gt; location relative to the current module and it will now be an error to<br>&gt; violate this rule<br></p><p>What is the rationale for this rule? I realize this is a common convention<br>but what is gained from strictly enforcing it?<br></p><p>On Mon, Jul 18, 2016 at 2:49 PM, Robert Widmann via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Jul 18, 2016, at 2:32 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; This is an interesting document. I think it deserves careful study. For<br>&gt; now, some questions:<br>&gt;<br>&gt; What is the rationale behind permitting the using of specific methods?<br>&gt; This seems to be usually fine-grained in comparison to other languages.<br>&gt; What use cases do you have in mind for this?<br>&gt;<br>&gt;<br>&gt; One use case: Swift libraries export not just member references as I’ve<br>&gt; used here, but a large amount of free functions.  It has long been a<br>&gt; problem that free functions seem to pollute a shared namespace and there<br>&gt; didn’t seem to be a clear way to hide them.<br>&gt;<br>&gt; I can see the use case for hiding specific symbols when they come into<br>&gt; conflict with your own, but in your example you&#39;re hiding specific methods<br>&gt; declared *in* an imported type. What is the use case here? Is it going to<br>&gt; allow me to open backdoors so that, if I don&#39;t like `Foo.frobnicate()`, I<br>&gt; can hide it and then substitute my own in an extension? This seems like a<br>&gt; bad thing at first blush.<br>&gt;<br>&gt;<br>&gt; For members that would be an acceptable use-case.  The worst-case scenario<br>&gt; that comes to mind is this being used as a way to “virtually override” a<br>&gt; method in a subclass.  Then again, the scope of the damage is limited to<br>&gt; the file in which you’ve declared this monstrosity so clients and even you<br>&gt; will not be able to see it outside of there unless you explicitly redeclare<br>&gt; the hiding import (in which case, you probably know what you’re doing).<br>&gt;<br>&gt; A use care here might be hiding the KVO-ish parts of an object from<br>&gt; yourself, or more generally subsetting out the part of an API you know you<br>&gt; shouldn’t interact with in a particular submodule.<br>&gt;<br>&gt;<br>&gt; I can see the obvious use case for renaming modules and types on<br>&gt; import--basically, in my mind, it&#39;s like typealiases with hiding, and it&#39;s<br>&gt; available in other languages of course. But how would renaming methods<br>&gt; work? If Foo conforms to Equatable and I rename `Foo.==` to `Foo.!=`, is<br>&gt; the type I import still Equatable? How would it behave? And even if Foo is<br>&gt; fine, what happens if I try to subclass my Frankensteinian Foo?<br>&gt;<br>&gt;<br>&gt; Of course you still conform to Equatable.  The renaming defines a mapping<br>&gt; from your names to “proper&quot; names.  For example, if you use a renaming<br>&gt; import to change the requirements of a protocol in a file, then your<br>&gt; conformance will simply look at the mapping and see that everything<br>&gt; resolves into its proper place.  Bear in mind that your renamings will not<br>&gt; survive outside of the file in which you declare them.  Frankenteinian Foo<br>&gt; exists where you say it does and nowhere else.  Everybody else just sees<br>&gt; Foo conform to Equatable (unless they rename things themselves).<br>&gt;<br>&gt;<br>&gt; On Mon, Jul 18, 2016 at 16:10 Robert Widmann via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Hello all,<br>&gt;&gt;<br>&gt;&gt; TJ Usiyan, Harlan Haskins, and I have been working on a proposal to<br>&gt;&gt; rework qualified imports and introduce an explicit module system to Swift<br>&gt;&gt; that we’d like to publish for your viewing pleasure.<br>&gt;&gt;<br>&gt;&gt; The initial impetus was set out in a radar (rdar://17630570) I sent<br>&gt;&gt; fairly early on that didn’t receive a response, so I started a<br>&gt;&gt; swift-evolution<br>&gt;&gt; &lt;http://permalink.gmane.org/gmane.comp.lang.swift.evolution/1378&gt; thread<br>&gt;&gt; discussing the basics of this proposal.  It has been refined and expanded a<br>&gt;&gt; bit to include an effort to make Swift modules explicit and updated with<br>&gt;&gt; the feedback of that first thread.  Contents of the proposal are inline and can<br>&gt;&gt; also be had as a gist<br>&gt;&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6&gt; or on<br>&gt;&gt; Github. &lt;https://github.com/apple/swift-evolution/pull/440&gt;<br>&gt;&gt;<br>&gt;&gt; Cheers,<br>&gt;&gt;<br>&gt;&gt; ~Robert Widmann<br>&gt;&gt;<br>&gt;&gt; Qualified Imports and Modules<br>&gt;&gt;<br>&gt;&gt;    - Proposal: SE-NNNN<br>&gt;&gt;    &lt;https://gist.github.com/CodaFi/NNNN-first-class-qualified-imports.md&gt;<br>&gt;&gt;    - Authors: Robert Widmann &lt;https://github.com/codafi&gt;, Harlan Haskins<br>&gt;&gt;    &lt;https://github.com/harlanhaskins&gt;, TJ Usiyan<br>&gt;&gt;    &lt;https://github.com/griotspeak&gt;<br>&gt;&gt;    - Status: Awaiting review<br>&gt;&gt;    - Review manager: TBD<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#introduction&gt;<br>&gt;&gt; Introduction<br>&gt;&gt;<br>&gt;&gt; We propose a complete overhaul of the qualified imports syntax and<br>&gt;&gt; semantics and the introduction of a module system.<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#motivation&gt;<br>&gt;&gt; Motivation<br>&gt;&gt;<br>&gt;&gt; Swift code is modular by default. However, it is not clear how to<br>&gt;&gt; decompose existing modules further into submodules. In addition, it is<br>&gt;&gt; difficult to tell how importing a module affects its export to consumers of<br>&gt;&gt; a library. This leads many to either fake namespaces with enums, attempt to<br>&gt;&gt; structure Swift code with modulemaps, or use a large amount of<br>&gt;&gt; version-control submodules. All of these can be rolled into one complete<br>&gt;&gt; package in the form of a comprehensive rethink of the qualified import<br>&gt;&gt; system and the introduction of a module system.<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#proposed-solution&gt;Proposed<br>&gt;&gt; solution<br>&gt;&gt;<br>&gt;&gt; Modules will now become an explicit part of working with canonical Swift<br>&gt;&gt; code. The grammar and semantics of qualified imports will change completely<br>&gt;&gt; with the addition of *import qualifiers* and *import directives*. We<br>&gt;&gt; also introduce three new contextual keywords: using, hiding, and renaming,<br>&gt;&gt; to facilitate fine-grained usage of module contents.<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#detailed-design&gt;Detailed<br>&gt;&gt; design<br>&gt;&gt;<br>&gt;&gt; Qualified import syntax will be revised to the following<br>&gt;&gt;<br>&gt;&gt; module-decl -&gt; module &lt;module-path&gt;<br>&gt;&gt; import-decl -&gt; &lt;access-level-modifier&gt; import &lt;module-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt;&gt; module-path -&gt; &lt;identifier&gt;<br>&gt;&gt;             -&gt; &lt;identifier&gt;.&lt;import-path&gt;<br>&gt;&gt; import-directive-list -&gt; &lt;import-directive&gt;<br>&gt;&gt;                       -&gt; &lt;import-directive&gt; &lt;import-directive-list&gt;<br>&gt;&gt; import-directive -&gt; using (&lt;identifier&gt;, ...)<br>&gt;&gt;                  -&gt; hiding (&lt;identifier&gt;, ...)<br>&gt;&gt;                  -&gt; renaming (&lt;identifier&gt;, to: &lt;identifier&gt;, ...)<br>&gt;&gt;<br>&gt;&gt; This introduces the concept of an import *directive*. An import<br>&gt;&gt; directive is a file-local modification of an imported identifier. A<br>&gt;&gt; directive can be one of 3 operations:<br>&gt;&gt;<br>&gt;&gt; 1) *using*: The *using* directive is followed by a list of identifiers<br>&gt;&gt; within the imported module that should be exposed to this file.<br>&gt;&gt;<br>&gt;&gt; // The only visible parts of Foundation in this file are // Date.init(), Date.hashValue, and Date.description.import Foundation.Date using (Date.init(), Date.hashValue, Date.description)<br>&gt;&gt;<br>&gt;&gt; 2) *hiding*: The hiding directive is followed by a list of identifiers<br>&gt;&gt; within the imported module that should be hidden from this file.<br>&gt;&gt;<br>&gt;&gt; // Imports all of Foundation.Date except `Date.compare()`import Foundation.Date hiding (Date.compare())<br>&gt;&gt;<br>&gt;&gt; 3) *renaming*: The renaming directive is followed by a list of<br>&gt;&gt; identifiers separated by to: that should be exposed to this file but<br>&gt;&gt; renamed.<br>&gt;&gt;<br>&gt;&gt; // Imports all of Dispatch.DispatchQueue but renames the static member // DispatchQueue.main, to DispatchQueue.mainQueueimport Dispatch.DispatchQueue renaming (DispatchQueue.Type.main to: DispatchQueue.Type.mainQueue)// Renaming can also rename modules.  All members of UIKit have to be qualified with// `UI` now.import UIKit renaming (UIKit, to: UI)<br>&gt;&gt;<br>&gt;&gt; Import directives chain to one another and can be used to create a<br>&gt;&gt; fine-grained module import:<br>&gt;&gt;<br>&gt;&gt; // Imports all of Foundation except `DateFormatter` and renames `Cache` to `LRUCache`import Foundation hiding (DateFormatter) renaming (Cache to: LRUCache)// Imports SCNNode except SCNNode.init(mdlObject:) and renames `.description` to// `.nodeDescription` import SceneKit using (SCNNode)<br>&gt;&gt;                 renaming (SCNNode.description, to: SCNNode.nodeDescription)<br>&gt;&gt;                 hiding (SCNNode.init(mdlObject:))<br>&gt;&gt;<br>&gt;&gt; Directive chaining occurs left-to-right:<br>&gt;&gt;<br>&gt;&gt; // This says to 1) Hide nothing 2) Use nothing 3) rename Int to INT.  It is invalid// because 1) We will show everything 2) Then hide everything 3) Therefore Int is unavailable, error.import Swift hiding () using () renaming (Int, to: INT)// This says to 1) Use Int 2) Hide String 3) rename Double to Triple.  It is invalid// because 1) Int is available 2) String is not, error. 3) Double is unavailable, error.import Swift using (Int) hiding (String) renaming (Double, to: Triple)// Valid.  This will be merged as `using (Int)`import Swift using () using (Int)// Valid.  This will be merged as `hiding (String, Double)`import Swift hiding (String) hiding (Double) hiding ()// Valid (if redundant). This will be merged as `using ()`import Swift using (String) hiding (String)<br>&gt;&gt;<br>&gt;&gt; Module scope is delimited by the keyword module followed by a fully<br>&gt;&gt; qualified name and must occur as the first declaration in a file. For<br>&gt;&gt; example:<br>&gt;&gt;<br>&gt;&gt; // ./Math/Integers/Arithmetic.swift<br>&gt;&gt; module Math.Integers.Arithmetic<br>&gt;&gt; public protocol _IntegerArithmetic {}<br>&gt;&gt; public struct _Abs {}<br>&gt;&gt; @_versionedinternal func _abs&lt;Args&gt;(_ args: Args) -&gt; (_Abs, Args) {}<br>&gt;&gt; // ./Math/Integers.swift<br>&gt;&gt; module Math.Integers<br>&gt;&gt; // _abs is visible in this module and all others within the project, // but is not exported along with it.internal import Math.Integers.Arithmetic<br>&gt;&gt; public protocol IntegerArithmetic : _IntegerArithmetic, Comparable {}public protocol SignedNumber : Comparable, ExpressibleByIntegerLiteral {}<br>&gt;&gt;<br>&gt;&gt; // Math.swift<br>&gt;&gt; module Math<br>&gt;&gt; // Exports the entire public contents of Math.Integers, but nothing in // Math.Integers.Arithmetic.public import Math.Integers<br>&gt;&gt;<br>&gt;&gt; Modules names are tied to a directory structure that describes their<br>&gt;&gt; location relative to the current module and it will now be an error to<br>&gt;&gt; violate this rule. For example:<br>&gt;&gt;<br>&gt;&gt; module String // lives in ./String.swift<br>&gt;&gt; module String.Core // lives in ./String/Core.swift<br>&gt;&gt; module String.Core.Internals.Do.You.Even.Write // lives in ./String/Core/Internals/Do/You/Even/Write.swift<br>&gt;&gt;<br>&gt;&gt; Existing projects that do not adopt these rules will still retain their *implicit<br>&gt;&gt; module name* (usually defined as the name of the framework or<br>&gt;&gt; application that is being built) and may continue to use whatever directory<br>&gt;&gt; structure they wish, however they may not declare any explicit modules.<br>&gt;&gt;<br>&gt;&gt; This proposal also solves the problem of module *export*. A module that<br>&gt;&gt; is imported without an access level modifier will default to an internal import<br>&gt;&gt; per usual. However, when it is useful to fully expose the public content of<br>&gt;&gt; submodules to a client, a public modifier can be used. Similarly, when<br>&gt;&gt; it is useful to access internal or [file]private APIs, but not expose<br>&gt;&gt; them to clients, those access modifiers may be used. The rule of thumb is:<br>&gt;&gt; Only identifiers that are at least as visible as the qualifier on the<br>&gt;&gt; import make for valid import declarations. For example:<br>&gt;&gt;<br>&gt;&gt; // A submodule declaring a `private` class that gets imported with // an `internal` qualifier with a `using` directive is an invalid import // declaration.<br>&gt;&gt; module Foo.Bar<br>&gt;&gt; private class PrivateThing {}<br>&gt;&gt;<br>&gt;&gt; module Foo<br>&gt;&gt; // Error: PrivateThing not visible, use `private import`import Foo.Bar using (PrivateThing)<br>&gt;&gt;<br>&gt;&gt; // However, a submodule declaring a `public` struct that gets imported with // an `private` qualifier is a valid import declaration.<br>&gt;&gt; module Foo.Bar<br>&gt;&gt; public class PublicThing {}<br>&gt;&gt;<br>&gt;&gt; module Foo<br>&gt;&gt; // All good!  Foo can see Foo.Bar.PrivateThing.private import Foo.Bar using (PublicThing)<br>&gt;&gt;<br>&gt;&gt; Because import directives are file-local, they will never be exported<br>&gt;&gt; along with a public import and will default to exporting the entire<br>&gt;&gt; contents of the module as though you had never declared them.<br>&gt;&gt;<br>&gt;&gt; // In this file and this file alone, the directives apply.  To the user// of this module, it is as though this declaration were simply:// public import Foundation.Datepublic import Foundation.Date hiding (Date.init())<br>&gt;&gt;                               renaming (Date.Type.distantPast,<br>&gt;&gt;                                         to: Date.Type.letsGoLivingInThePast,<br>&gt;&gt;                                         Date.Type.timeIntervalSinceReferenceDate,<br>&gt;&gt;                                         to: Date.Type.startOfTheUniverse)<br>&gt;&gt;                               renaming (Date.Type.&lt;, to: Date.Type.&lt;&lt;&lt;&lt;&lt;)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#impact-on-existing-code&gt;Impact<br>&gt;&gt; on existing code<br>&gt;&gt;<br>&gt;&gt; Existing code that is using qualified module import syntax (import<br>&gt;&gt; {func|class|typealias|class|struct|enum|protocol} &lt;qualified-name&gt;) will<br>&gt;&gt; be deprecated. Code that is not organized into modules will remain<br>&gt;&gt; unaffected and organized into one contiguous top-level module. However, it<br>&gt;&gt; is strongly recommended that frameworks be decomposed and reorganized<br>&gt;&gt; around the new module system.<br>&gt;&gt;<br>&gt;&gt; As a case study, the public interface to the standard library appears to<br>&gt;&gt; already be mostly broken down into submodules as described in<br>&gt;&gt; GroupInfo.json<br>&gt;&gt; &lt;https://github.com/apple/swift/blob/master/stdlib/public/core/GroupInfo.json&gt;<br>&gt;&gt; .<br>&gt;&gt;<br>&gt;&gt; Code that is defined in modulemaps already defines a module structure<br>&gt;&gt; that can be imported directly into this scheme.<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#alternatives-considered&gt;Alternatives<br>&gt;&gt; considered<br>&gt;&gt;<br>&gt;&gt; Module export can also be placed on the module declaration itself. The<br>&gt;&gt; relevant parts of the grammar that have changed are below with an example:<br>&gt;&gt;<br>&gt;&gt; module-decl -&gt; &lt;access-level-modifier&gt; module &lt;module-path&gt;<br>&gt;&gt; import-decl -&gt; import &lt;module-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt;&gt;<br>&gt;&gt; private module String.Core.Internals<br>&gt;&gt; // Shh, it&#39;s a secret.<br>&gt;&gt;<br>&gt;&gt; While this style makes it immediately obvious to the library author which<br>&gt;&gt; modules are public or private, it causes the consumer problems because<br>&gt;&gt; submodule exports are no longer explicit and are entirely ad-hoc. In the<br>&gt;&gt; interest of enabling, for one, users of IDEs to drill into public<br>&gt;&gt; submodules, making export local to import seems more appropriate.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160718/b07fa4cf/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d972db2b6ee8b77746ce7122663eb4f8?s=50"></div><header><strong>[Proposal] Qualified Imports and Modules</strong> from <string>Robert Widmann</string> &lt;rwidmann at apple.com&gt;<p>July 18, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jul 18, 2016, at 2:57 PM, Daniel Resnick &lt;danielzresnick at gmail.com&gt; wrote:<br>&gt; <br>&gt; Modules names are tied to a directory structure that describes their location relative to the current module and it will now be an error to violate this rule<br>&gt; What is the rationale for this rule? I realize this is a common convention but what is gained from strictly enforcing it? <br></p><p>Outside of general organizational cleanliness?  A big reason to favor this over a free-for-all is that a module becomes tied to something physical.  These are not C++-style namespaces that admit the kind of behavior you might be thinking of sans restriction.  And with it on, there is nothing stopping you from declaring whatever you wish in any particular module space and re-exporting it the proper way.  For example<br></p><p>module String // publicly imports <br>module String.Core // which publicly imports<br>module String.Core.Algorithms // which internally imports<br>module String.Core.Algorithms.ExperimentsAndOtherNonsense  <br></p><p>You can have your cake and eat it too, you just can’t put it wherever you’d like without being consistent both within and without.  We also allow you to opt out of this behavior entirely if you have a particular organizational structure you would like to use other than modules.<br></p><p>&gt; Existing projects that do not adopt these rules will still retain their implicit module name <br>&gt; (usually defined as the name of the framework or application that is being built) and may continue to use<br>&gt; whatever directory structure they wish, however they may not declare any explicit modules.<br></p><p>&gt; <br>&gt; On Mon, Jul 18, 2016 at 2:49 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Jul 18, 2016, at 2:32 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This is an interesting document. I think it deserves careful study. For now, some questions:<br>&gt;&gt; <br>&gt;&gt; What is the rationale behind permitting the using of specific methods? This seems to be usually fine-grained in comparison to other languages. What use cases do you have in mind for this?<br>&gt;&gt; <br>&gt; <br>&gt; One use case: Swift libraries export not just member references as I’ve used here, but a large amount of free functions.  It has long been a problem that free functions seem to pollute a shared namespace and there didn’t seem to be a clear way to hide them.<br>&gt; <br>&gt;&gt; I can see the use case for hiding specific symbols when they come into conflict with your own, but in your example you&#39;re hiding specific methods declared *in* an imported type. What is the use case here? Is it going to allow me to open backdoors so that, if I don&#39;t like `Foo.frobnicate()`, I can hide it and then substitute my own in an extension? This seems like a bad thing at first blush.<br>&gt; <br>&gt; For members that would be an acceptable use-case.  The worst-case scenario that comes to mind is this being used as a way to “virtually override” a method in a subclass.  Then again, the scope of the damage is limited to the file in which you’ve declared this monstrosity so clients and even you will not be able to see it outside of there unless you explicitly redeclare the hiding import (in which case, you probably know what you’re doing).<br>&gt; <br>&gt; A use care here might be hiding the KVO-ish parts of an object from yourself, or more generally subsetting out the part of an API you know you shouldn’t interact with in a particular submodule.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; I can see the obvious use case for renaming modules and types on import--basically, in my mind, it&#39;s like typealiases with hiding, and it&#39;s available in other languages of course. But how would renaming methods work? If Foo conforms to Equatable and I rename `Foo.==` to `Foo.!=`, is the type I import still Equatable? How would it behave? And even if Foo is fine, what happens if I try to subclass my Frankensteinian Foo?<br>&gt; <br>&gt; Of course you still conform to Equatable.  The renaming defines a mapping from your names to “proper&quot; names.  For example, if you use a renaming import to change the requirements of a protocol in a file, then your conformance will simply look at the mapping and see that everything resolves into its proper place.  Bear in mind that your renamings will not survive outside of the file in which you declare them.  Frankenteinian Foo exists where you say it does and nowhere else.  Everybody else just sees Foo conform to Equatable (unless they rename things themselves).<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Mon, Jul 18, 2016 at 16:10 Robert Widmann via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Hello all,<br>&gt;&gt; <br>&gt;&gt; TJ Usiyan, Harlan Haskins, and I have been working on a proposal to rework qualified imports and introduce an explicit module system to Swift that we’d like to publish for your viewing pleasure.<br>&gt;&gt; <br>&gt;&gt; The initial impetus was set out in a radar (rdar://17630570 &lt;&gt;) I sent fairly early on that didn’t receive a response, so I started a swift-evolution &lt;http://permalink.gmane.org/gmane.comp.lang.swift.evolution/1378&gt; thread discussing the basics of this proposal.  It has been refined and expanded a bit to include an effort to make Swift modules explicit and updated with the feedback of that first thread.  Contents of the proposal are inline and can also be had as a gist &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6&gt; or on Github. &lt;https://github.com/apple/swift-evolution/pull/440&gt;<br>&gt;&gt; <br>&gt;&gt; Cheers,<br>&gt;&gt; <br>&gt;&gt; ~Robert Widmann<br>&gt;&gt; <br>&gt;&gt; Qualified Imports and Modules<br>&gt;&gt; <br>&gt;&gt; Proposal: SE-NNNN &lt;https://gist.github.com/CodaFi/NNNN-first-class-qualified-imports.md&gt;<br>&gt;&gt; Authors: Robert Widmann &lt;https://github.com/codafi&gt;, Harlan Haskins &lt;https://github.com/harlanhaskins&gt;, TJ Usiyan &lt;https://github.com/griotspeak&gt;<br>&gt;&gt; Status: Awaiting review<br>&gt;&gt; Review manager: TBD<br>&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#introduction&gt;Introduction<br>&gt;&gt; <br>&gt;&gt; We propose a complete overhaul of the qualified imports syntax and semantics and the introduction of a module system.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#motivation&gt;Motivation<br>&gt;&gt; <br>&gt;&gt; Swift code is modular by default. However, it is not clear how to decompose existing modules further into submodules. In addition, it is difficult to tell how importing a module affects its export to consumers of a library. This leads many to either fake namespaces with enums, attempt to structure Swift code with modulemaps, or use a large amount of version-control submodules. All of these can be rolled into one complete package in the form of a comprehensive rethink of the qualified import system and the introduction of a module system.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#proposed-solution&gt;Proposed solution<br>&gt;&gt; <br>&gt;&gt; Modules will now become an explicit part of working with canonical Swift code. The grammar and semantics of qualified imports will change completely with the addition of import qualifiers and import directives. We also introduce three new contextual keywords: using, hiding, and renaming, to facilitate fine-grained usage of module contents.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#detailed-design&gt;Detailed design<br>&gt;&gt; <br>&gt;&gt; Qualified import syntax will be revised to the following<br>&gt;&gt; <br>&gt;&gt; module-decl -&gt; module &lt;module-path&gt;<br>&gt;&gt; import-decl -&gt; &lt;access-level-modifier&gt; import &lt;module-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt;&gt; module-path -&gt; &lt;identifier&gt;<br>&gt;&gt;             -&gt; &lt;identifier&gt;.&lt;import-path&gt;<br>&gt;&gt; import-directive-list -&gt; &lt;import-directive&gt;<br>&gt;&gt;                       -&gt; &lt;import-directive&gt; &lt;import-directive-list&gt;<br>&gt;&gt; import-directive -&gt; using (&lt;identifier&gt;, ...)<br>&gt;&gt;                  -&gt; hiding (&lt;identifier&gt;, ...)<br>&gt;&gt;                  -&gt; renaming (&lt;identifier&gt;, to: &lt;identifier&gt;, ...)<br>&gt;&gt; This introduces the concept of an import directive. An import directive is a file-local modification of an imported identifier. A directive can be one of 3 operations:<br>&gt;&gt; <br>&gt;&gt; 1) using: The using directive is followed by a list of identifiers within the imported module that should be exposed to this file. <br>&gt;&gt; <br>&gt;&gt; // The only visible parts of Foundation in this file are <br>&gt;&gt; // Date.init(), Date.hashValue, and Date.description.<br>&gt;&gt; import Foundation.Date using (Date.init(), Date.hashValue, Date.description)<br>&gt;&gt; 2) hiding: The hiding directive is followed by a list of identifiers within the imported module that should be hidden from this file.<br>&gt;&gt; <br>&gt;&gt; // Imports all of Foundation.Date except `Date.compare()`<br>&gt;&gt; import Foundation.Date hiding (Date.compare())<br>&gt;&gt; 3) renaming: The renaming directive is followed by a list of identifiers separated by to: that should be exposed to this file but renamed. <br>&gt;&gt; <br>&gt;&gt; // Imports all of Dispatch.DispatchQueue but renames the static member <br>&gt;&gt; // DispatchQueue.main, to DispatchQueue.mainQueue<br>&gt;&gt; import Dispatch.DispatchQueue renaming (DispatchQueue.Type.main to: DispatchQueue.Type.mainQueue)<br>&gt;&gt; // Renaming can also rename modules.  All members of UIKit have to be qualified with<br>&gt;&gt; // `UI` now.<br>&gt;&gt; import UIKit renaming (UIKit, to: UI)<br>&gt;&gt; Import directives chain to one another and can be used to create a fine-grained module import:<br>&gt;&gt; <br>&gt;&gt; // Imports all of Foundation except `DateFormatter` and renames `Cache` to `LRUCache`<br>&gt;&gt; import Foundation hiding (DateFormatter) renaming (Cache to: LRUCache)<br>&gt;&gt; // Imports SCNNode except SCNNode.init(mdlObject:) and renames `.description` to<br>&gt;&gt; // `.nodeDescription` <br>&gt;&gt; import SceneKit using (SCNNode) <br>&gt;&gt;                 renaming (SCNNode.description, to: SCNNode.nodeDescription)<br>&gt;&gt;                 hiding (SCNNode.init(mdlObject:))<br>&gt;&gt; Directive chaining occurs left-to-right:<br>&gt;&gt; <br>&gt;&gt; // This says to 1) Hide nothing 2) Use nothing 3) rename Int to INT.  It is invalid<br>&gt;&gt; // because 1) We will show everything 2) Then hide everything 3) Therefore Int is unavailable, error.<br>&gt;&gt; import Swift hiding () using () renaming (Int, to: INT)<br>&gt;&gt; // This says to 1) Use Int 2) Hide String 3) rename Double to Triple.  It is invalid<br>&gt;&gt; // because 1) Int is available 2) String is not, error. 3) Double is unavailable, error.<br>&gt;&gt; import Swift using (Int) hiding (String) renaming (Double, to: Triple)<br>&gt;&gt; // Valid.  This will be merged as `using (Int)`<br>&gt;&gt; import Swift using () using (Int)<br>&gt;&gt; // Valid.  This will be merged as `hiding (String, Double)`<br>&gt;&gt; import Swift hiding (String) hiding (Double) hiding ()<br>&gt;&gt; // Valid (if redundant). This will be merged as `using ()`<br>&gt;&gt; import Swift using (String) hiding (String)<br>&gt;&gt; Module scope is delimited by the keyword module followed by a fully qualified name and must occur as the first declaration in a file. For example:<br>&gt;&gt; <br>&gt;&gt; // ./Math/Integers/Arithmetic.swift<br>&gt;&gt; module Math.Integers.Arithmetic<br>&gt;&gt; <br>&gt;&gt; public protocol _IntegerArithmetic {}<br>&gt;&gt; <br>&gt;&gt; public struct _Abs {}<br>&gt;&gt; <br>&gt;&gt; @_versioned<br>&gt;&gt; internal func _abs&lt;Args&gt;(_ args: Args) -&gt; (_Abs, Args) {}<br>&gt;&gt; <br>&gt;&gt; // ./Math/Integers.swift<br>&gt;&gt; module Math.Integers<br>&gt;&gt; <br>&gt;&gt; // _abs is visible in this module and all others within the project, <br>&gt;&gt; // but is not exported along with it.<br>&gt;&gt; internal import Math.Integers.Arithmetic<br>&gt;&gt; <br>&gt;&gt; public protocol IntegerArithmetic : _IntegerArithmetic, Comparable {}<br>&gt;&gt; public protocol SignedNumber : Comparable, ExpressibleByIntegerLiteral {}<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; // Math.swift<br>&gt;&gt; module Math<br>&gt;&gt; <br>&gt;&gt; // Exports the entire public contents of Math.Integers, but nothing in <br>&gt;&gt; // Math.Integers.Arithmetic.<br>&gt;&gt; public import Math.Integers<br>&gt;&gt; Modules names are tied to a directory structure that describes their location relative to the current module and it will now be an error to violate this rule. For example:<br>&gt;&gt; <br>&gt;&gt; module String // lives in ./String.swift<br>&gt;&gt; module String.Core // lives in ./String/Core.swift<br>&gt;&gt; module String.Core.Internals.Do.You.Even.Write // lives in ./String/Core/Internals/Do/You/Even/Write.swift<br>&gt;&gt; Existing projects that do not adopt these rules will still retain their implicit module name (usually defined as the name of the framework or application that is being built) and may continue to use whatever directory structure they wish, however they may not declare any explicit modules.<br>&gt;&gt; <br>&gt;&gt; This proposal also solves the problem of module export. A module that is imported without an access level modifier will default to an internal import per usual. However, when it is useful to fully expose the public content of submodules to a client, a public modifier can be used. Similarly, when it is useful to access internal or [file]private APIs, but not expose them to clients, those access modifiers may be used. The rule of thumb is: Only identifiers that are at least as visible as the qualifier on the import make for valid import declarations. For example:<br>&gt;&gt; <br>&gt;&gt; // A submodule declaring a `private` class that gets imported with <br>&gt;&gt; // an `internal` qualifier with a `using` directive is an invalid import <br>&gt;&gt; // declaration.  <br>&gt;&gt; module Foo.Bar<br>&gt;&gt; <br>&gt;&gt; private class PrivateThing {}<br>&gt;&gt; <br>&gt;&gt; module Foo<br>&gt;&gt; <br>&gt;&gt; // Error: PrivateThing not visible, use `private import`<br>&gt;&gt; import Foo.Bar using (PrivateThing) <br>&gt;&gt; // However, a submodule declaring a `public` struct that gets imported with <br>&gt;&gt; // an `private` qualifier is a valid import declaration.<br>&gt;&gt; module Foo.Bar<br>&gt;&gt; <br>&gt;&gt; public class PublicThing {}<br>&gt;&gt; <br>&gt;&gt; module Foo<br>&gt;&gt; <br>&gt;&gt; // All good!  Foo can see Foo.Bar.PrivateThing.<br>&gt;&gt; private import Foo.Bar using (PublicThing) <br>&gt;&gt; Because import directives are file-local, they will never be exported along with a public import and will default to exporting the entire contents of the module as though you had never declared them.<br>&gt;&gt; <br>&gt;&gt; // In this file and this file alone, the directives apply.  To the user<br>&gt;&gt; // of this module, it is as though this declaration were simply:<br>&gt;&gt; // public import Foundation.Date<br>&gt;&gt; public import Foundation.Date hiding (Date.init()) <br>&gt;&gt;                               renaming (Date.Type.distantPast, <br>&gt;&gt;                                         to: Date.Type.letsGoLivingInThePast,<br>&gt;&gt;                                         Date.Type.timeIntervalSinceReferenceDate, <br>&gt;&gt;                                         to: Date.Type.startOfTheUniverse)<br>&gt;&gt;                               renaming (Date.Type.&lt;, to: Date.Type.&lt;&lt;&lt;&lt;&lt;)<br>&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt; <br>&gt;&gt; Existing code that is using qualified module import syntax (import {func|class|typealias|class|struct|enum|protocol} &lt;qualified-name&gt;) will be deprecated. Code that is not organized into modules will remain unaffected and organized into one contiguous top-level module. However, it is strongly recommended that frameworks be decomposed and reorganized around the new module system.<br>&gt;&gt; <br>&gt;&gt; As a case study, the public interface to the standard library appears to already be mostly broken down into submodules as described in GroupInfo.json &lt;https://github.com/apple/swift/blob/master/stdlib/public/core/GroupInfo.json&gt;.<br>&gt;&gt; <br>&gt;&gt; Code that is defined in modulemaps already defines a module structure that can be imported directly into this scheme.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#alternatives-considered&gt;Alternatives considered<br>&gt;&gt; <br>&gt;&gt; Module export can also be placed on the module declaration itself. The relevant parts of the grammar that have changed are below with an example:<br>&gt;&gt; <br>&gt;&gt; module-decl -&gt; &lt;access-level-modifier&gt; module &lt;module-path&gt;<br>&gt;&gt; import-decl -&gt; import &lt;module-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt;&gt; private module String.Core.Internals<br>&gt;&gt; <br>&gt;&gt; // Shh, it&#39;s a secret.<br>&gt;&gt; While this style makes it immediately obvious to the library author which modules are public or private, it causes the consumer problems because submodule exports are no longer explicit and are entirely ad-hoc. In the interest of enabling, for one, users of IDEs to drill into public submodules, making export local to import seems more appropriate.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160718/31473cd4/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Proposal] Qualified Imports and Modules</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 18, 2016 at 05:00:00pm</p></header><div class="content"><p>On Mon, Jul 18, 2016 at 4:49 PM, Robert Widmann &lt;rwidmann at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Jul 18, 2016, at 2:32 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; This is an interesting document. I think it deserves careful study. For<br>&gt; now, some questions:<br>&gt;<br>&gt; What is the rationale behind permitting the using of specific methods?<br>&gt; This seems to be usually fine-grained in comparison to other languages.<br>&gt; What use cases do you have in mind for this?<br>&gt;<br>&gt;<br>&gt; One use case: Swift libraries export not just member references as I’ve<br>&gt; used here, but a large amount of free functions.  It has long been a<br>&gt; problem that free functions seem to pollute a shared namespace and there<br>&gt; didn’t seem to be a clear way to hide them.<br>&gt;<br></p><p>Would a plausible simplification of the proposal be to have it fine-grained<br>enough to address free functions but not methods inside types?<br>Incidentally, although I do not see it in the proposal, I assume that * in<br>some form will be permitted (as in, `import Foundation using *`).<br></p><p><br>&gt; I can see the use case for hiding specific symbols when they come into<br>&gt; conflict with your own, but in your example you&#39;re hiding specific methods<br>&gt; declared *in* an imported type. What is the use case here? Is it going to<br>&gt; allow me to open backdoors so that, if I don&#39;t like `Foo.frobnicate()`, I<br>&gt; can hide it and then substitute my own in an extension? This seems like a<br>&gt; bad thing at first blush.<br>&gt;<br>&gt;<br>&gt; For members that would be an acceptable use-case.  The worst-case scenario<br>&gt; that comes to mind is this being used as a way to “virtually override” a<br>&gt; method in a subclass.  Then again, the scope of the damage is limited to<br>&gt; the file in which you’ve declared this monstrosity so clients and even you<br>&gt; will not be able to see it outside of there unless you explicitly redeclare<br>&gt; the hiding import (in which case, you probably know what you’re doing).<br>&gt;<br>&gt; A use care here might be hiding the KVO-ish parts of an object from<br>&gt; yourself, or more generally subsetting out the part of an API you know you<br>&gt; shouldn’t interact with in a particular submodule.<br>&gt;<br>&gt;<br>&gt; I can see the obvious use case for renaming modules and types on<br>&gt; import--basically, in my mind, it&#39;s like typealiases with hiding, and it&#39;s<br>&gt; available in other languages of course. But how would renaming methods<br>&gt; work? If Foo conforms to Equatable and I rename `Foo.==` to `Foo.!=`, is<br>&gt; the type I import still Equatable? How would it behave? And even if Foo is<br>&gt; fine, what happens if I try to subclass my Frankensteinian Foo?<br>&gt;<br>&gt;<br>&gt; Of course you still conform to Equatable.  The renaming defines a mapping<br>&gt; from your names to “proper&quot; names.  For example, if you use a renaming<br>&gt; import to change the requirements of a protocol in a file, then your<br>&gt; conformance will simply look at the mapping and see that everything<br>&gt; resolves into its proper place.  Bear in mind that your renamings will not<br>&gt; survive outside of the file in which you declare them.  Frankenteinian Foo<br>&gt; exists where you say it does and nowhere else.  Everybody else just sees<br>&gt; Foo conform to Equatable (unless they rename things themselves).<br>&gt;<br></p><p>Maybe let&#39;s work through an example:<br></p><p>Suppose we have in stdlib:<br></p><p>```<br>public protocol FooProtocol {<br>  func frobnicate()<br>}<br>```<br></p><p>Now, I write a library:<br></p><p>```<br>import Swift.FooProtocol renaming (FooProtocol.frobnicate(), to:<br>FooProtocol.bobnicate())<br></p><p>public open class MyFoo : Swift.FooProtocol {<br>  public open func bobnicate() {<br>    print(&quot;Does your head hurt yet?&quot;)<br>  }<br>}<br>```<br></p><p>Now, you are an end user of my sinister library.<br></p><p>What is the public API of `MyFoo`?<br>For you, does `MyFoo` conform to `Swift.FooProtocol`?<br>Can you call `MyFoo.frobnicate()`? How about `MyFoo.bobnicate()`?<br></p><p>What if you try to subclass `MyFoo`?<br>Does your subclass still conform to `Swift.FooProtocol`?<br>Do you override `bobnicate()` or `frobnicate()`?<br>My head hurts...<br></p><p><br>&gt;<br>&gt;<br>&gt; On Mon, Jul 18, 2016 at 16:10 Robert Widmann via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Hello all,<br>&gt;&gt;<br>&gt;&gt; TJ Usiyan, Harlan Haskins, and I have been working on a proposal to<br>&gt;&gt; rework qualified imports and introduce an explicit module system to Swift<br>&gt;&gt; that we’d like to publish for your viewing pleasure.<br>&gt;&gt;<br>&gt;&gt; The initial impetus was set out in a radar (rdar://17630570) I sent<br>&gt;&gt; fairly early on that didn’t receive a response, so I started a<br>&gt;&gt; swift-evolution<br>&gt;&gt; &lt;http://permalink.gmane.org/gmane.comp.lang.swift.evolution/1378&gt; thread<br>&gt;&gt; discussing the basics of this proposal.  It has been refined and expanded a<br>&gt;&gt; bit to include an effort to make Swift modules explicit and updated with<br>&gt;&gt; the feedback of that first thread.  Contents of the proposal are inline and can<br>&gt;&gt; also be had as a gist<br>&gt;&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6&gt; or on<br>&gt;&gt; Github. &lt;https://github.com/apple/swift-evolution/pull/440&gt;<br>&gt;&gt;<br>&gt;&gt; Cheers,<br>&gt;&gt;<br>&gt;&gt; ~Robert Widmann<br>&gt;&gt;<br>&gt;&gt; Qualified Imports and Modules<br>&gt;&gt;<br>&gt;&gt;    - Proposal: SE-NNNN<br>&gt;&gt;    &lt;https://gist.github.com/CodaFi/NNNN-first-class-qualified-imports.md&gt;<br>&gt;&gt;    - Authors: Robert Widmann &lt;https://github.com/codafi&gt;, Harlan Haskins<br>&gt;&gt;    &lt;https://github.com/harlanhaskins&gt;, TJ Usiyan<br>&gt;&gt;    &lt;https://github.com/griotspeak&gt;<br>&gt;&gt;    - Status: Awaiting review<br>&gt;&gt;    - Review manager: TBD<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#introduction&gt;<br>&gt;&gt; Introduction<br>&gt;&gt;<br>&gt;&gt; We propose a complete overhaul of the qualified imports syntax and<br>&gt;&gt; semantics and the introduction of a module system.<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#motivation&gt;<br>&gt;&gt; Motivation<br>&gt;&gt;<br>&gt;&gt; Swift code is modular by default. However, it is not clear how to<br>&gt;&gt; decompose existing modules further into submodules. In addition, it is<br>&gt;&gt; difficult to tell how importing a module affects its export to consumers of<br>&gt;&gt; a library. This leads many to either fake namespaces with enums, attempt to<br>&gt;&gt; structure Swift code with modulemaps, or use a large amount of<br>&gt;&gt; version-control submodules. All of these can be rolled into one complete<br>&gt;&gt; package in the form of a comprehensive rethink of the qualified import<br>&gt;&gt; system and the introduction of a module system.<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#proposed-solution&gt;Proposed<br>&gt;&gt; solution<br>&gt;&gt;<br>&gt;&gt; Modules will now become an explicit part of working with canonical Swift<br>&gt;&gt; code. The grammar and semantics of qualified imports will change completely<br>&gt;&gt; with the addition of *import qualifiers* and *import directives*. We<br>&gt;&gt; also introduce three new contextual keywords: using, hiding, and renaming,<br>&gt;&gt; to facilitate fine-grained usage of module contents.<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#detailed-design&gt;Detailed<br>&gt;&gt; design<br>&gt;&gt;<br>&gt;&gt; Qualified import syntax will be revised to the following<br>&gt;&gt;<br>&gt;&gt; module-decl -&gt; module &lt;module-path&gt;<br>&gt;&gt; import-decl -&gt; &lt;access-level-modifier&gt; import &lt;module-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt;&gt; module-path -&gt; &lt;identifier&gt;<br>&gt;&gt;             -&gt; &lt;identifier&gt;.&lt;import-path&gt;<br>&gt;&gt; import-directive-list -&gt; &lt;import-directive&gt;<br>&gt;&gt;                       -&gt; &lt;import-directive&gt; &lt;import-directive-list&gt;<br>&gt;&gt; import-directive -&gt; using (&lt;identifier&gt;, ...)<br>&gt;&gt;                  -&gt; hiding (&lt;identifier&gt;, ...)<br>&gt;&gt;                  -&gt; renaming (&lt;identifier&gt;, to: &lt;identifier&gt;, ...)<br>&gt;&gt;<br>&gt;&gt; This introduces the concept of an import *directive*. An import<br>&gt;&gt; directive is a file-local modification of an imported identifier. A<br>&gt;&gt; directive can be one of 3 operations:<br>&gt;&gt;<br>&gt;&gt; 1) *using*: The *using* directive is followed by a list of identifiers<br>&gt;&gt; within the imported module that should be exposed to this file.<br>&gt;&gt;<br>&gt;&gt; // The only visible parts of Foundation in this file are // Date.init(), Date.hashValue, and Date.description.import Foundation.Date using (Date.init(), Date.hashValue, Date.description)<br>&gt;&gt;<br>&gt;&gt; 2) *hiding*: The hiding directive is followed by a list of identifiers<br>&gt;&gt; within the imported module that should be hidden from this file.<br>&gt;&gt;<br>&gt;&gt; // Imports all of Foundation.Date except `Date.compare()`import Foundation.Date hiding (Date.compare())<br>&gt;&gt;<br>&gt;&gt; 3) *renaming*: The renaming directive is followed by a list of<br>&gt;&gt; identifiers separated by to: that should be exposed to this file but<br>&gt;&gt; renamed.<br>&gt;&gt;<br>&gt;&gt; // Imports all of Dispatch.DispatchQueue but renames the static member // DispatchQueue.main, to DispatchQueue.mainQueueimport Dispatch.DispatchQueue renaming (DispatchQueue.Type.main to: DispatchQueue.Type.mainQueue)// Renaming can also rename modules.  All members of UIKit have to be qualified with// `UI` now.import UIKit renaming (UIKit, to: UI)<br>&gt;&gt;<br>&gt;&gt; Import directives chain to one another and can be used to create a<br>&gt;&gt; fine-grained module import:<br>&gt;&gt;<br>&gt;&gt; // Imports all of Foundation except `DateFormatter` and renames `Cache` to `LRUCache`import Foundation hiding (DateFormatter) renaming (Cache to: LRUCache)// Imports SCNNode except SCNNode.init(mdlObject:) and renames `.description` to// `.nodeDescription` import SceneKit using (SCNNode)<br>&gt;&gt;                 renaming (SCNNode.description, to: SCNNode.nodeDescription)<br>&gt;&gt;                 hiding (SCNNode.init(mdlObject:))<br>&gt;&gt;<br>&gt;&gt; Directive chaining occurs left-to-right:<br>&gt;&gt;<br>&gt;&gt; // This says to 1) Hide nothing 2) Use nothing 3) rename Int to INT.  It is invalid// because 1) We will show everything 2) Then hide everything 3) Therefore Int is unavailable, error.import Swift hiding () using () renaming (Int, to: INT)// This says to 1) Use Int 2) Hide String 3) rename Double to Triple.  It is invalid// because 1) Int is available 2) String is not, error. 3) Double is unavailable, error.import Swift using (Int) hiding (String) renaming (Double, to: Triple)// Valid.  This will be merged as `using (Int)`import Swift using () using (Int)// Valid.  This will be merged as `hiding (String, Double)`import Swift hiding (String) hiding (Double) hiding ()// Valid (if redundant). This will be merged as `using ()`import Swift using (String) hiding (String)<br>&gt;&gt;<br>&gt;&gt; Module scope is delimited by the keyword module followed by a fully<br>&gt;&gt; qualified name and must occur as the first declaration in a file. For<br>&gt;&gt; example:<br>&gt;&gt;<br>&gt;&gt; // ./Math/Integers/Arithmetic.swift<br>&gt;&gt; module Math.Integers.Arithmetic<br>&gt;&gt; public protocol _IntegerArithmetic {}<br>&gt;&gt; public struct _Abs {}<br>&gt;&gt; @_versionedinternal func _abs&lt;Args&gt;(_ args: Args) -&gt; (_Abs, Args) {}<br>&gt;&gt; // ./Math/Integers.swift<br>&gt;&gt; module Math.Integers<br>&gt;&gt; // _abs is visible in this module and all others within the project, // but is not exported along with it.internal import Math.Integers.Arithmetic<br>&gt;&gt; public protocol IntegerArithmetic : _IntegerArithmetic, Comparable {}public protocol SignedNumber : Comparable, ExpressibleByIntegerLiteral {}<br>&gt;&gt;<br>&gt;&gt; // Math.swift<br>&gt;&gt; module Math<br>&gt;&gt; // Exports the entire public contents of Math.Integers, but nothing in // Math.Integers.Arithmetic.public import Math.Integers<br>&gt;&gt;<br>&gt;&gt; Modules names are tied to a directory structure that describes their<br>&gt;&gt; location relative to the current module and it will now be an error to<br>&gt;&gt; violate this rule. For example:<br>&gt;&gt;<br>&gt;&gt; module String // lives in ./String.swift<br>&gt;&gt; module String.Core // lives in ./String/Core.swift<br>&gt;&gt; module String.Core.Internals.Do.You.Even.Write // lives in ./String/Core/Internals/Do/You/Even/Write.swift<br>&gt;&gt;<br>&gt;&gt; Existing projects that do not adopt these rules will still retain their *implicit<br>&gt;&gt; module name* (usually defined as the name of the framework or<br>&gt;&gt; application that is being built) and may continue to use whatever directory<br>&gt;&gt; structure they wish, however they may not declare any explicit modules.<br>&gt;&gt;<br>&gt;&gt; This proposal also solves the problem of module *export*. A module that<br>&gt;&gt; is imported without an access level modifier will default to an internal import<br>&gt;&gt; per usual. However, when it is useful to fully expose the public content of<br>&gt;&gt; submodules to a client, a public modifier can be used. Similarly, when<br>&gt;&gt; it is useful to access internal or [file]private APIs, but not expose<br>&gt;&gt; them to clients, those access modifiers may be used. The rule of thumb is:<br>&gt;&gt; Only identifiers that are at least as visible as the qualifier on the<br>&gt;&gt; import make for valid import declarations. For example:<br>&gt;&gt;<br>&gt;&gt; // A submodule declaring a `private` class that gets imported with // an `internal` qualifier with a `using` directive is an invalid import // declaration.<br>&gt;&gt; module Foo.Bar<br>&gt;&gt; private class PrivateThing {}<br>&gt;&gt;<br>&gt;&gt; module Foo<br>&gt;&gt; // Error: PrivateThing not visible, use `private import`import Foo.Bar using (PrivateThing)<br>&gt;&gt;<br>&gt;&gt; // However, a submodule declaring a `public` struct that gets imported with // an `private` qualifier is a valid import declaration.<br>&gt;&gt; module Foo.Bar<br>&gt;&gt; public class PublicThing {}<br>&gt;&gt;<br>&gt;&gt; module Foo<br>&gt;&gt; // All good!  Foo can see Foo.Bar.PrivateThing.private import Foo.Bar using (PublicThing)<br>&gt;&gt;<br>&gt;&gt; Because import directives are file-local, they will never be exported<br>&gt;&gt; along with a public import and will default to exporting the entire<br>&gt;&gt; contents of the module as though you had never declared them.<br>&gt;&gt;<br>&gt;&gt; // In this file and this file alone, the directives apply.  To the user// of this module, it is as though this declaration were simply:// public import Foundation.Datepublic import Foundation.Date hiding (Date.init())<br>&gt;&gt;                               renaming (Date.Type.distantPast,<br>&gt;&gt;                                         to: Date.Type.letsGoLivingInThePast,<br>&gt;&gt;                                         Date.Type.timeIntervalSinceReferenceDate,<br>&gt;&gt;                                         to: Date.Type.startOfTheUniverse)<br>&gt;&gt;                               renaming (Date.Type.&lt;, to: Date.Type.&lt;&lt;&lt;&lt;&lt;)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#impact-on-existing-code&gt;Impact<br>&gt;&gt; on existing code<br>&gt;&gt;<br>&gt;&gt; Existing code that is using qualified module import syntax (import<br>&gt;&gt; {func|class|typealias|class|struct|enum|protocol} &lt;qualified-name&gt;) will<br>&gt;&gt; be deprecated. Code that is not organized into modules will remain<br>&gt;&gt; unaffected and organized into one contiguous top-level module. However, it<br>&gt;&gt; is strongly recommended that frameworks be decomposed and reorganized<br>&gt;&gt; around the new module system.<br>&gt;&gt;<br>&gt;&gt; As a case study, the public interface to the standard library appears to<br>&gt;&gt; already be mostly broken down into submodules as described in<br>&gt;&gt; GroupInfo.json<br>&gt;&gt; &lt;https://github.com/apple/swift/blob/master/stdlib/public/core/GroupInfo.json&gt;<br>&gt;&gt; .<br>&gt;&gt;<br>&gt;&gt; Code that is defined in modulemaps already defines a module structure<br>&gt;&gt; that can be imported directly into this scheme.<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#alternatives-considered&gt;Alternatives<br>&gt;&gt; considered<br>&gt;&gt;<br>&gt;&gt; Module export can also be placed on the module declaration itself. The<br>&gt;&gt; relevant parts of the grammar that have changed are below with an example:<br>&gt;&gt;<br>&gt;&gt; module-decl -&gt; &lt;access-level-modifier&gt; module &lt;module-path&gt;<br>&gt;&gt; import-decl -&gt; import &lt;module-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt;&gt;<br>&gt;&gt; private module String.Core.Internals<br>&gt;&gt; // Shh, it&#39;s a secret.<br>&gt;&gt;<br>&gt;&gt; While this style makes it immediately obvious to the library author which<br>&gt;&gt; modules are public or private, it causes the consumer problems because<br>&gt;&gt; submodule exports are no longer explicit and are entirely ad-hoc. In the<br>&gt;&gt; interest of enabling, for one, users of IDEs to drill into public<br>&gt;&gt; submodules, making export local to import seems more appropriate.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160718/d996af43/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d972db2b6ee8b77746ce7122663eb4f8?s=50"></div><header><strong>[Proposal] Qualified Imports and Modules</strong> from <string>Robert Widmann</string> &lt;rwidmann at apple.com&gt;<p>July 18, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jul 18, 2016, at 3:00 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Mon, Jul 18, 2016 at 4:49 PM, Robert Widmann &lt;rwidmann at apple.com &lt;mailto:rwidmann at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Jul 18, 2016, at 2:32 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This is an interesting document. I think it deserves careful study. For now, some questions:<br>&gt;&gt; <br>&gt;&gt; What is the rationale behind permitting the using of specific methods? This seems to be usually fine-grained in comparison to other languages. What use cases do you have in mind for this?<br>&gt;&gt; <br>&gt; <br>&gt; One use case: Swift libraries export not just member references as I’ve used here, but a large amount of free functions.  It has long been a problem that free functions seem to pollute a shared namespace and there didn’t seem to be a clear way to hide them.<br>&gt; <br>&gt; Would a plausible simplification of the proposal be to have it fine-grained enough to address free functions but not methods inside types?<br>&gt; Incidentally, although I do not see it in the proposal, I assume that * in some form will be permitted (as in, `import Foundation using *`).<br>&gt; <br>&gt; <br>&gt;&gt; I can see the use case for hiding specific symbols when they come into conflict with your own, but in your example you&#39;re hiding specific methods declared *in* an imported type. What is the use case here? Is it going to allow me to open backdoors so that, if I don&#39;t like `Foo.frobnicate()`, I can hide it and then substitute my own in an extension? This seems like a bad thing at first blush.<br>&gt; <br>&gt; For members that would be an acceptable use-case.  The worst-case scenario that comes to mind is this being used as a way to “virtually override” a method in a subclass.  Then again, the scope of the damage is limited to the file in which you’ve declared this monstrosity so clients and even you will not be able to see it outside of there unless you explicitly redeclare the hiding import (in which case, you probably know what you’re doing).<br>&gt; <br>&gt; A use care here might be hiding the KVO-ish parts of an object from yourself, or more generally subsetting out the part of an API you know you shouldn’t interact with in a particular submodule.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; I can see the obvious use case for renaming modules and types on import--basically, in my mind, it&#39;s like typealiases with hiding, and it&#39;s available in other languages of course. But how would renaming methods work? If Foo conforms to Equatable and I rename `Foo.==` to `Foo.!=`, is the type I import still Equatable? How would it behave? And even if Foo is fine, what happens if I try to subclass my Frankensteinian Foo?<br>&gt; <br>&gt; Of course you still conform to Equatable.  The renaming defines a mapping from your names to “proper&quot; names.  For example, if you use a renaming import to change the requirements of a protocol in a file, then your conformance will simply look at the mapping and see that everything resolves into its proper place.  Bear in mind that your renamings will not survive outside of the file in which you declare them.  Frankenteinian Foo exists where you say it does and nowhere else.  Everybody else just sees Foo conform to Equatable (unless they rename things themselves).<br>&gt; <br>&gt; Maybe let&#39;s work through an example:<br>&gt; <br>&gt; Suppose we have in stdlib:<br>&gt; <br>&gt; ```<br>&gt; public protocol FooProtocol {<br>&gt;   func frobnicate()<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; Now, I write a library:<br>&gt; <br>&gt; ```<br>&gt; import Swift.FooProtocol renaming (FooProtocol.frobnicate(), to: FooProtocol.bobnicate())<br>&gt; <br>&gt; public open class MyFoo : Swift.FooProtocol {<br>&gt;   public open func bobnicate() {<br>&gt;     print(&quot;Does your head hurt yet?&quot;)<br>&gt;   }<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; Now, you are an end user of my sinister library.<br>&gt; <br>&gt; What is the public API of `MyFoo`?<br></p><p>The proposal addresses this<br></p><p>&gt; Because import directives are file-local, they will never be exported along with a `public` import and will<br>&gt; default to exporting the entire contents of the module as though you had never declared them.<br></p><p>The user (and even you in other files that import this module) will see a protocol conformance exactly as laid out in the Swift.FooProtocol module.<br></p><p>&gt; For you, does `MyFoo` conform to `Swift.FooProtocol`?<br></p><p>It conforms because the renaming you wrote describes a way of resolving FooProtocol.bobnicate() (your API) to FooProtocol.frobnicate() (everybody else’s API).<br></p><p>&gt; Can you call `MyFoo.frobnicate()`? How about `MyFoo.bobnicate()`?<br>&gt; <br>&gt; What if you try to subclass `MyFoo`?<br></p><p>If you are inside the module you wrote the renaming, you will use it.  If you are outside of it, you will see the protocol requirement sans renaming.<br></p><p>&gt; Does your subclass still conform to `Swift.FooProtocol`?<br>&gt; Do you override `bobnicate()` or `frobnicate()`?<br>&gt; My head hurts…<br></p><p>Because you have explicitly renamed the protocol requirement, you will override the same protocol requirement both inside and outside this module but your renaming will not propagate to other files unless they themselves opt in the way you have here.  It would be particularly sinister if you could arbitrarily edit the user-facing API of members simply by importing a library.<br></p><p>&gt;  <br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Mon, Jul 18, 2016 at 16:10 Robert Widmann via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Hello all,<br>&gt;&gt; <br>&gt;&gt; TJ Usiyan, Harlan Haskins, and I have been working on a proposal to rework qualified imports and introduce an explicit module system to Swift that we’d like to publish for your viewing pleasure.<br>&gt;&gt; <br>&gt;&gt; The initial impetus was set out in a radar (rdar://17630570 &lt;&gt;) I sent fairly early on that didn’t receive a response, so I started a swift-evolution &lt;http://permalink.gmane.org/gmane.comp.lang.swift.evolution/1378&gt; thread discussing the basics of this proposal.  It has been refined and expanded a bit to include an effort to make Swift modules explicit and updated with the feedback of that first thread.  Contents of the proposal are inline and can also be had as a gist &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6&gt; or on Github. &lt;https://github.com/apple/swift-evolution/pull/440&gt;<br>&gt;&gt; <br>&gt;&gt; Cheers,<br>&gt;&gt; <br>&gt;&gt; ~Robert Widmann<br>&gt;&gt; <br>&gt;&gt; Qualified Imports and Modules<br>&gt;&gt; <br>&gt;&gt; Proposal: SE-NNNN &lt;https://gist.github.com/CodaFi/NNNN-first-class-qualified-imports.md&gt;<br>&gt;&gt; Authors: Robert Widmann &lt;https://github.com/codafi&gt;, Harlan Haskins &lt;https://github.com/harlanhaskins&gt;, TJ Usiyan &lt;https://github.com/griotspeak&gt;<br>&gt;&gt; Status: Awaiting review<br>&gt;&gt; Review manager: TBD<br>&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#introduction&gt;Introduction<br>&gt;&gt; <br>&gt;&gt; We propose a complete overhaul of the qualified imports syntax and semantics and the introduction of a module system.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#motivation&gt;Motivation<br>&gt;&gt; <br>&gt;&gt; Swift code is modular by default. However, it is not clear how to decompose existing modules further into submodules. In addition, it is difficult to tell how importing a module affects its export to consumers of a library. This leads many to either fake namespaces with enums, attempt to structure Swift code with modulemaps, or use a large amount of version-control submodules. All of these can be rolled into one complete package in the form of a comprehensive rethink of the qualified import system and the introduction of a module system.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#proposed-solution&gt;Proposed solution<br>&gt;&gt; <br>&gt;&gt; Modules will now become an explicit part of working with canonical Swift code. The grammar and semantics of qualified imports will change completely with the addition of import qualifiers and import directives. We also introduce three new contextual keywords: using, hiding, and renaming, to facilitate fine-grained usage of module contents.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#detailed-design&gt;Detailed design<br>&gt;&gt; <br>&gt;&gt; Qualified import syntax will be revised to the following<br>&gt;&gt; <br>&gt;&gt; module-decl -&gt; module &lt;module-path&gt;<br>&gt;&gt; import-decl -&gt; &lt;access-level-modifier&gt; import &lt;module-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt;&gt; module-path -&gt; &lt;identifier&gt;<br>&gt;&gt;             -&gt; &lt;identifier&gt;.&lt;import-path&gt;<br>&gt;&gt; import-directive-list -&gt; &lt;import-directive&gt;<br>&gt;&gt;                       -&gt; &lt;import-directive&gt; &lt;import-directive-list&gt;<br>&gt;&gt; import-directive -&gt; using (&lt;identifier&gt;, ...)<br>&gt;&gt;                  -&gt; hiding (&lt;identifier&gt;, ...)<br>&gt;&gt;                  -&gt; renaming (&lt;identifier&gt;, to: &lt;identifier&gt;, ...)<br>&gt;&gt; This introduces the concept of an import directive. An import directive is a file-local modification of an imported identifier. A directive can be one of 3 operations:<br>&gt;&gt; <br>&gt;&gt; 1) using: The using directive is followed by a list of identifiers within the imported module that should be exposed to this file. <br>&gt;&gt; <br>&gt;&gt; // The only visible parts of Foundation in this file are <br>&gt;&gt; // Date.init(), Date.hashValue, and Date.description.<br>&gt;&gt; import Foundation.Date using (Date.init(), Date.hashValue, Date.description)<br>&gt;&gt; 2) hiding: The hiding directive is followed by a list of identifiers within the imported module that should be hidden from this file.<br>&gt;&gt; <br>&gt;&gt; // Imports all of Foundation.Date except `Date.compare()`<br>&gt;&gt; import Foundation.Date hiding (Date.compare())<br>&gt;&gt; 3) renaming: The renaming directive is followed by a list of identifiers separated by to: that should be exposed to this file but renamed. <br>&gt;&gt; <br>&gt;&gt; // Imports all of Dispatch.DispatchQueue but renames the static member <br>&gt;&gt; // DispatchQueue.main, to DispatchQueue.mainQueue<br>&gt;&gt; import Dispatch.DispatchQueue renaming (DispatchQueue.Type.main to: DispatchQueue.Type.mainQueue)<br>&gt;&gt; // Renaming can also rename modules.  All members of UIKit have to be qualified with<br>&gt;&gt; // `UI` now.<br>&gt;&gt; import UIKit renaming (UIKit, to: UI)<br>&gt;&gt; Import directives chain to one another and can be used to create a fine-grained module import:<br>&gt;&gt; <br>&gt;&gt; // Imports all of Foundation except `DateFormatter` and renames `Cache` to `LRUCache`<br>&gt;&gt; import Foundation hiding (DateFormatter) renaming (Cache to: LRUCache)<br>&gt;&gt; // Imports SCNNode except SCNNode.init(mdlObject:) and renames `.description` to<br>&gt;&gt; // `.nodeDescription` <br>&gt;&gt; import SceneKit using (SCNNode) <br>&gt;&gt;                 renaming (SCNNode.description, to: SCNNode.nodeDescription)<br>&gt;&gt;                 hiding (SCNNode.init(mdlObject:))<br>&gt;&gt; Directive chaining occurs left-to-right:<br>&gt;&gt; <br>&gt;&gt; // This says to 1) Hide nothing 2) Use nothing 3) rename Int to INT.  It is invalid<br>&gt;&gt; // because 1) We will show everything 2) Then hide everything 3) Therefore Int is unavailable, error.<br>&gt;&gt; import Swift hiding () using () renaming (Int, to: INT)<br>&gt;&gt; // This says to 1) Use Int 2) Hide String 3) rename Double to Triple.  It is invalid<br>&gt;&gt; // because 1) Int is available 2) String is not, error. 3) Double is unavailable, error.<br>&gt;&gt; import Swift using (Int) hiding (String) renaming (Double, to: Triple)<br>&gt;&gt; // Valid.  This will be merged as `using (Int)`<br>&gt;&gt; import Swift using () using (Int)<br>&gt;&gt; // Valid.  This will be merged as `hiding (String, Double)`<br>&gt;&gt; import Swift hiding (String) hiding (Double) hiding ()<br>&gt;&gt; // Valid (if redundant). This will be merged as `using ()`<br>&gt;&gt; import Swift using (String) hiding (String)<br>&gt;&gt; Module scope is delimited by the keyword module followed by a fully qualified name and must occur as the first declaration in a file. For example:<br>&gt;&gt; <br>&gt;&gt; // ./Math/Integers/Arithmetic.swift<br>&gt;&gt; module Math.Integers.Arithmetic<br>&gt;&gt; <br>&gt;&gt; public protocol _IntegerArithmetic {}<br>&gt;&gt; <br>&gt;&gt; public struct _Abs {}<br>&gt;&gt; <br>&gt;&gt; @_versioned<br>&gt;&gt; internal func _abs&lt;Args&gt;(_ args: Args) -&gt; (_Abs, Args) {}<br>&gt;&gt; <br>&gt;&gt; // ./Math/Integers.swift<br>&gt;&gt; module Math.Integers<br>&gt;&gt; <br>&gt;&gt; // _abs is visible in this module and all others within the project, <br>&gt;&gt; // but is not exported along with it.<br>&gt;&gt; internal import Math.Integers.Arithmetic<br>&gt;&gt; <br>&gt;&gt; public protocol IntegerArithmetic : _IntegerArithmetic, Comparable {}<br>&gt;&gt; public protocol SignedNumber : Comparable, ExpressibleByIntegerLiteral {}<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; // Math.swift<br>&gt;&gt; module Math<br>&gt;&gt; <br>&gt;&gt; // Exports the entire public contents of Math.Integers, but nothing in <br>&gt;&gt; // Math.Integers.Arithmetic.<br>&gt;&gt; public import Math.Integers<br>&gt;&gt; Modules names are tied to a directory structure that describes their location relative to the current module and it will now be an error to violate this rule. For example:<br>&gt;&gt; <br>&gt;&gt; module String // lives in ./String.swift<br>&gt;&gt; module String.Core // lives in ./String/Core.swift<br>&gt;&gt; module String.Core.Internals.Do.You.Even.Write // lives in ./String/Core/Internals/Do/You/Even/Write.swift<br>&gt;&gt; Existing projects that do not adopt these rules will still retain their implicit module name (usually defined as the name of the framework or application that is being built) and may continue to use whatever directory structure they wish, however they may not declare any explicit modules.<br>&gt;&gt; <br>&gt;&gt; This proposal also solves the problem of module export. A module that is imported without an access level modifier will default to an internal import per usual. However, when it is useful to fully expose the public content of submodules to a client, a public modifier can be used. Similarly, when it is useful to access internal or [file]private APIs, but not expose them to clients, those access modifiers may be used. The rule of thumb is: Only identifiers that are at least as visible as the qualifier on the import make for valid import declarations. For example:<br>&gt;&gt; <br>&gt;&gt; // A submodule declaring a `private` class that gets imported with <br>&gt;&gt; // an `internal` qualifier with a `using` directive is an invalid import <br>&gt;&gt; // declaration.  <br>&gt;&gt; module Foo.Bar<br>&gt;&gt; <br>&gt;&gt; private class PrivateThing {}<br>&gt;&gt; <br>&gt;&gt; module Foo<br>&gt;&gt; <br>&gt;&gt; // Error: PrivateThing not visible, use `private import`<br>&gt;&gt; import Foo.Bar using (PrivateThing) <br>&gt;&gt; // However, a submodule declaring a `public` struct that gets imported with <br>&gt;&gt; // an `private` qualifier is a valid import declaration.<br>&gt;&gt; module Foo.Bar<br>&gt;&gt; <br>&gt;&gt; public class PublicThing {}<br>&gt;&gt; <br>&gt;&gt; module Foo<br>&gt;&gt; <br>&gt;&gt; // All good!  Foo can see Foo.Bar.PrivateThing.<br>&gt;&gt; private import Foo.Bar using (PublicThing) <br>&gt;&gt; Because import directives are file-local, they will never be exported along with a public import and will default to exporting the entire contents of the module as though you had never declared them.<br>&gt;&gt; <br>&gt;&gt; // In this file and this file alone, the directives apply.  To the user<br>&gt;&gt; // of this module, it is as though this declaration were simply:<br>&gt;&gt; // public import Foundation.Date<br>&gt;&gt; public import Foundation.Date hiding (Date.init()) <br>&gt;&gt;                               renaming (Date.Type.distantPast, <br>&gt;&gt;                                         to: Date.Type.letsGoLivingInThePast,<br>&gt;&gt;                                         Date.Type.timeIntervalSinceReferenceDate, <br>&gt;&gt;                                         to: Date.Type.startOfTheUniverse)<br>&gt;&gt;                               renaming (Date.Type.&lt;, to: Date.Type.&lt;&lt;&lt;&lt;&lt;)<br>&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt; <br>&gt;&gt; Existing code that is using qualified module import syntax (import {func|class|typealias|class|struct|enum|protocol} &lt;qualified-name&gt;) will be deprecated. Code that is not organized into modules will remain unaffected and organized into one contiguous top-level module. However, it is strongly recommended that frameworks be decomposed and reorganized around the new module system.<br>&gt;&gt; <br>&gt;&gt; As a case study, the public interface to the standard library appears to already be mostly broken down into submodules as described in GroupInfo.json &lt;https://github.com/apple/swift/blob/master/stdlib/public/core/GroupInfo.json&gt;.<br>&gt;&gt; <br>&gt;&gt; Code that is defined in modulemaps already defines a module structure that can be imported directly into this scheme.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#alternatives-considered&gt;Alternatives considered<br>&gt;&gt; <br>&gt;&gt; Module export can also be placed on the module declaration itself. The relevant parts of the grammar that have changed are below with an example:<br>&gt;&gt; <br>&gt;&gt; module-decl -&gt; &lt;access-level-modifier&gt; module &lt;module-path&gt;<br>&gt;&gt; import-decl -&gt; import &lt;module-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt;&gt; private module String.Core.Internals<br>&gt;&gt; <br>&gt;&gt; // Shh, it&#39;s a secret.<br>&gt;&gt; While this style makes it immediately obvious to the library author which modules are public or private, it causes the consumer problems because submodule exports are no longer explicit and are entirely ad-hoc. In the interest of enabling, for one, users of IDEs to drill into public submodules, making export local to import seems more appropriate.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160718/2f0c4170/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Proposal] Qualified Imports and Modules</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 18, 2016 at 05:00:00pm</p></header><div class="content"><p>On Mon, Jul 18, 2016 at 5:09 PM, Robert Widmann &lt;rwidmann at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Jul 18, 2016, at 3:00 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Mon, Jul 18, 2016 at 4:49 PM, Robert Widmann &lt;rwidmann at apple.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Jul 18, 2016, at 2:32 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; This is an interesting document. I think it deserves careful study. For<br>&gt;&gt; now, some questions:<br>&gt;&gt;<br>&gt;&gt; What is the rationale behind permitting the using of specific methods?<br>&gt;&gt; This seems to be usually fine-grained in comparison to other languages.<br>&gt;&gt; What use cases do you have in mind for this?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; One use case: Swift libraries export not just member references as I’ve<br>&gt;&gt; used here, but a large amount of free functions.  It has long been a<br>&gt;&gt; problem that free functions seem to pollute a shared namespace and there<br>&gt;&gt; didn’t seem to be a clear way to hide them.<br>&gt;&gt;<br>&gt;<br>&gt; Would a plausible simplification of the proposal be to have it<br>&gt; fine-grained enough to address free functions but not methods inside types?<br>&gt; Incidentally, although I do not see it in the proposal, I assume that * in<br>&gt; some form will be permitted (as in, `import Foundation using *`).<br>&gt;<br>&gt;<br>&gt;&gt; I can see the use case for hiding specific symbols when they come into<br>&gt;&gt; conflict with your own, but in your example you&#39;re hiding specific methods<br>&gt;&gt; declared *in* an imported type. What is the use case here? Is it going to<br>&gt;&gt; allow me to open backdoors so that, if I don&#39;t like `Foo.frobnicate()`, I<br>&gt;&gt; can hide it and then substitute my own in an extension? This seems like a<br>&gt;&gt; bad thing at first blush.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; For members that would be an acceptable use-case.  The worst-case<br>&gt;&gt; scenario that comes to mind is this being used as a way to “virtually<br>&gt;&gt; override” a method in a subclass.  Then again, the scope of the damage is<br>&gt;&gt; limited to the file in which you’ve declared this monstrosity so clients<br>&gt;&gt; and even you will not be able to see it outside of there unless you<br>&gt;&gt; explicitly redeclare the hiding import (in which case, you probably know<br>&gt;&gt; what you’re doing).<br>&gt;&gt;<br>&gt;&gt; A use care here might be hiding the KVO-ish parts of an object from<br>&gt;&gt; yourself, or more generally subsetting out the part of an API you know you<br>&gt;&gt; shouldn’t interact with in a particular submodule.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I can see the obvious use case for renaming modules and types on<br>&gt;&gt; import--basically, in my mind, it&#39;s like typealiases with hiding, and it&#39;s<br>&gt;&gt; available in other languages of course. But how would renaming methods<br>&gt;&gt; work? If Foo conforms to Equatable and I rename `Foo.==` to `Foo.!=`, is<br>&gt;&gt; the type I import still Equatable? How would it behave? And even if Foo is<br>&gt;&gt; fine, what happens if I try to subclass my Frankensteinian Foo?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Of course you still conform to Equatable.  The renaming defines a mapping<br>&gt;&gt; from your names to “proper&quot; names.  For example, if you use a renaming<br>&gt;&gt; import to change the requirements of a protocol in a file, then your<br>&gt;&gt; conformance will simply look at the mapping and see that everything<br>&gt;&gt; resolves into its proper place.  Bear in mind that your renamings will not<br>&gt;&gt; survive outside of the file in which you declare them.  Frankenteinian Foo<br>&gt;&gt; exists where you say it does and nowhere else.  Everybody else just sees<br>&gt;&gt; Foo conform to Equatable (unless they rename things themselves).<br>&gt;&gt;<br>&gt;<br>&gt; Maybe let&#39;s work through an example:<br>&gt;<br>&gt; Suppose we have in stdlib:<br>&gt;<br>&gt; ```<br>&gt; public protocol FooProtocol {<br>&gt;   func frobnicate()<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; Now, I write a library:<br>&gt;<br>&gt; ```<br>&gt; import Swift.FooProtocol renaming (FooProtocol.frobnicate(), to:<br>&gt; FooProtocol.bobnicate())<br>&gt;<br>&gt; public open class MyFoo : Swift.FooProtocol {<br>&gt;   public open func bobnicate() {<br>&gt;     print(&quot;Does your head hurt yet?&quot;)<br>&gt;   }<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; Now, you are an end user of my sinister library.<br>&gt;<br>&gt; What is the public API of `MyFoo`?<br>&gt;<br>&gt;<br>&gt; The proposal addresses this<br>&gt;<br>&gt; &gt; Because import directives are file-local, they will never be exported<br>&gt; along with a `public` import and will<br>&gt; &gt; default to exporting the entire contents of the module as though you had<br>&gt; never declared them.<br>&gt;<br>&gt; The user (and even you in other files that import this module) will see a<br>&gt; protocol conformance exactly as laid out in the Swift.FooProtocol module.<br>&gt;<br>&gt; For you, does `MyFoo` conform to `Swift.FooProtocol`?<br>&gt;<br>&gt;<br>&gt; It conforms because the renaming you wrote describes a way of resolving<br>&gt; FooProtocol.bobnicate() (your API) to FooProtocol.frobnicate() (everybody<br>&gt; else’s API).<br>&gt;<br>&gt; Can you call `MyFoo.frobnicate()`? How about `MyFoo.bobnicate()`?<br>&gt;<br>&gt;<br>&gt; What if you try to subclass `MyFoo`?<br>&gt;<br>&gt;<br>&gt; If you are inside the module you wrote the renaming, you will use it.  If<br>&gt; you are outside of it, you will see the protocol requirement sans renaming.<br>&gt;<br>&gt; Does your subclass still conform to `Swift.FooProtocol`?<br>&gt; Do you override `bobnicate()` or `frobnicate()`?<br>&gt; My head hurts…<br>&gt;<br>&gt;<br>&gt; Because you have explicitly renamed the protocol requirement, you will<br>&gt; override the same protocol requirement both inside and outside this module<br>&gt; but your renaming will not propagate to other files unless they themselves<br>&gt; opt in the way you have here.  It would be particularly sinister if you<br>&gt; could arbitrarily edit the user-facing API of members simply by importing a<br>&gt; library.<br>&gt;<br></p><p>Sounds good. If I understand you correctly, by conforming `MyFoo` to an<br>internally renamed `Swift.FooProtocol`, the renaming of the user-facing API<br>for `FooProtocol` means that the public API of `MyFoo` is changed so that,<br>outside the module, it has a member `frobnicate()` and no longer has a<br>member `bobnicate()`?<br></p><p><br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Mon, Jul 18, 2016 at 16:10 Robert Widmann via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; TJ Usiyan, Harlan Haskins, and I have been working on a proposal to<br>&gt;&gt;&gt; rework qualified imports and introduce an explicit module system to Swift<br>&gt;&gt;&gt; that we’d like to publish for your viewing pleasure.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The initial impetus was set out in a radar (rdar://17630570) I sent<br>&gt;&gt;&gt; fairly early on that didn’t receive a response, so I started a<br>&gt;&gt;&gt; swift-evolution<br>&gt;&gt;&gt; &lt;http://permalink.gmane.org/gmane.comp.lang.swift.evolution/1378&gt; thread<br>&gt;&gt;&gt; discussing the basics of this proposal.  It has been refined and expanded a<br>&gt;&gt;&gt; bit to include an effort to make Swift modules explicit and updated with<br>&gt;&gt;&gt; the feedback of that first thread.  Contents of the proposal are inline and can<br>&gt;&gt;&gt; also be had as a gist<br>&gt;&gt;&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6&gt; or on<br>&gt;&gt;&gt; Github. &lt;https://github.com/apple/swift-evolution/pull/440&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Qualified Imports and Modules<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    - Proposal: SE-NNNN<br>&gt;&gt;&gt;    &lt;https://gist.github.com/CodaFi/NNNN-first-class-qualified-imports.md&gt;<br>&gt;&gt;&gt;    - Authors: Robert Widmann &lt;https://github.com/codafi&gt;, Harlan Haskins<br>&gt;&gt;&gt;    &lt;https://github.com/harlanhaskins&gt;, TJ Usiyan<br>&gt;&gt;&gt;    &lt;https://github.com/griotspeak&gt;<br>&gt;&gt;&gt;    - Status: Awaiting review<br>&gt;&gt;&gt;    - Review manager: TBD<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#introduction&gt;<br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; We propose a complete overhaul of the qualified imports syntax and<br>&gt;&gt;&gt; semantics and the introduction of a module system.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#motivation&gt;<br>&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Swift code is modular by default. However, it is not clear how to<br>&gt;&gt;&gt; decompose existing modules further into submodules. In addition, it is<br>&gt;&gt;&gt; difficult to tell how importing a module affects its export to consumers of<br>&gt;&gt;&gt; a library. This leads many to either fake namespaces with enums, attempt to<br>&gt;&gt;&gt; structure Swift code with modulemaps, or use a large amount of<br>&gt;&gt;&gt; version-control submodules. All of these can be rolled into one complete<br>&gt;&gt;&gt; package in the form of a comprehensive rethink of the qualified import<br>&gt;&gt;&gt; system and the introduction of a module system.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#proposed-solution&gt;Proposed<br>&gt;&gt;&gt; solution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Modules will now become an explicit part of working with canonical Swift<br>&gt;&gt;&gt; code. The grammar and semantics of qualified imports will change completely<br>&gt;&gt;&gt; with the addition of *import qualifiers* and *import directives*. We<br>&gt;&gt;&gt; also introduce three new contextual keywords: using, hiding, and<br>&gt;&gt;&gt; renaming, to facilitate fine-grained usage of module contents.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#detailed-design&gt;Detailed<br>&gt;&gt;&gt; design<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Qualified import syntax will be revised to the following<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; module-decl -&gt; module &lt;module-path&gt;<br>&gt;&gt;&gt; import-decl -&gt; &lt;access-level-modifier&gt; import &lt;module-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt;&gt;&gt; module-path -&gt; &lt;identifier&gt;<br>&gt;&gt;&gt;             -&gt; &lt;identifier&gt;.&lt;import-path&gt;<br>&gt;&gt;&gt; import-directive-list -&gt; &lt;import-directive&gt;<br>&gt;&gt;&gt;                       -&gt; &lt;import-directive&gt; &lt;import-directive-list&gt;<br>&gt;&gt;&gt; import-directive -&gt; using (&lt;identifier&gt;, ...)<br>&gt;&gt;&gt;                  -&gt; hiding (&lt;identifier&gt;, ...)<br>&gt;&gt;&gt;                  -&gt; renaming (&lt;identifier&gt;, to: &lt;identifier&gt;, ...)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This introduces the concept of an import *directive*. An import<br>&gt;&gt;&gt; directive is a file-local modification of an imported identifier. A<br>&gt;&gt;&gt; directive can be one of 3 operations:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 1) *using*: The *using* directive is followed by a list of identifiers<br>&gt;&gt;&gt; within the imported module that should be exposed to this file.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // The only visible parts of Foundation in this file are // Date.init(), Date.hashValue, and Date.description.import Foundation.Date using (Date.init(), Date.hashValue, Date.description)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 2) *hiding*: The hiding directive is followed by a list of identifiers<br>&gt;&gt;&gt; within the imported module that should be hidden from this file.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // Imports all of Foundation.Date except `Date.compare()`import Foundation.Date hiding (Date.compare())<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 3) *renaming*: The renaming directive is followed by a list of<br>&gt;&gt;&gt; identifiers separated by to: that should be exposed to this file but<br>&gt;&gt;&gt; renamed.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // Imports all of Dispatch.DispatchQueue but renames the static member // DispatchQueue.main, to DispatchQueue.mainQueueimport Dispatch.DispatchQueue renaming (DispatchQueue.Type.main to: DispatchQueue.Type.mainQueue)// Renaming can also rename modules.  All members of UIKit have to be qualified with// `UI` now.import UIKit renaming (UIKit, to: UI)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Import directives chain to one another and can be used to create a<br>&gt;&gt;&gt; fine-grained module import:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // Imports all of Foundation except `DateFormatter` and renames `Cache` to `LRUCache`import Foundation hiding (DateFormatter) renaming (Cache to: LRUCache)// Imports SCNNode except SCNNode.init(mdlObject:) and renames `.description` to// `.nodeDescription` import SceneKit using (SCNNode)<br>&gt;&gt;&gt;                 renaming (SCNNode.description, to: SCNNode.nodeDescription)<br>&gt;&gt;&gt;                 hiding (SCNNode.init(mdlObject:))<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Directive chaining occurs left-to-right:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // This says to 1) Hide nothing 2) Use nothing 3) rename Int to INT.  It is invalid// because 1) We will show everything 2) Then hide everything 3) Therefore Int is unavailable, error.import Swift hiding () using () renaming (Int, to: INT)// This says to 1) Use Int 2) Hide String 3) rename Double to Triple.  It is invalid// because 1) Int is available 2) String is not, error. 3) Double is unavailable, error.import Swift using (Int) hiding (String) renaming (Double, to: Triple)// Valid.  This will be merged as `using (Int)`import Swift using () using (Int)// Valid.  This will be merged as `hiding (String, Double)`import Swift hiding (String) hiding (Double) hiding ()// Valid (if redundant). This will be merged as `using ()`import Swift using (String) hiding (String)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Module scope is delimited by the keyword module followed by a fully<br>&gt;&gt;&gt; qualified name and must occur as the first declaration in a file. For<br>&gt;&gt;&gt; example:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // ./Math/Integers/Arithmetic.swift<br>&gt;&gt;&gt; module Math.Integers.Arithmetic<br>&gt;&gt;&gt; public protocol _IntegerArithmetic {}<br>&gt;&gt;&gt; public struct _Abs {}<br>&gt;&gt;&gt; @_versionedinternal func _abs&lt;Args&gt;(_ args: Args) -&gt; (_Abs, Args) {}<br>&gt;&gt;&gt; // ./Math/Integers.swift<br>&gt;&gt;&gt; module Math.Integers<br>&gt;&gt;&gt; // _abs is visible in this module and all others within the project, // but is not exported along with it.internal import Math.Integers.Arithmetic<br>&gt;&gt;&gt; public protocol IntegerArithmetic : _IntegerArithmetic, Comparable {}public protocol SignedNumber : Comparable, ExpressibleByIntegerLiteral {}<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // Math.swift<br>&gt;&gt;&gt; module Math<br>&gt;&gt;&gt; // Exports the entire public contents of Math.Integers, but nothing in // Math.Integers.Arithmetic.public import Math.Integers<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Modules names are tied to a directory structure that describes their<br>&gt;&gt;&gt; location relative to the current module and it will now be an error to<br>&gt;&gt;&gt; violate this rule. For example:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; module String // lives in ./String.swift<br>&gt;&gt;&gt; module String.Core // lives in ./String/Core.swift<br>&gt;&gt;&gt; module String.Core.Internals.Do.You.Even.Write // lives in ./String/Core/Internals/Do/You/Even/Write.swift<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Existing projects that do not adopt these rules will still retain their *implicit<br>&gt;&gt;&gt; module name* (usually defined as the name of the framework or<br>&gt;&gt;&gt; application that is being built) and may continue to use whatever directory<br>&gt;&gt;&gt; structure they wish, however they may not declare any explicit modules.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This proposal also solves the problem of module *export*. A module that<br>&gt;&gt;&gt; is imported without an access level modifier will default to an internal import<br>&gt;&gt;&gt; per usual. However, when it is useful to fully expose the public content of<br>&gt;&gt;&gt; submodules to a client, a public modifier can be used. Similarly, when<br>&gt;&gt;&gt; it is useful to access internal or [file]private APIs, but not expose<br>&gt;&gt;&gt; them to clients, those access modifiers may be used. The rule of thumb is:<br>&gt;&gt;&gt; Only identifiers that are at least as visible as the qualifier on the<br>&gt;&gt;&gt; import make for valid import declarations. For example:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // A submodule declaring a `private` class that gets imported with // an `internal` qualifier with a `using` directive is an invalid import // declaration.<br>&gt;&gt;&gt; module Foo.Bar<br>&gt;&gt;&gt; private class PrivateThing {}<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; module Foo<br>&gt;&gt;&gt; // Error: PrivateThing not visible, use `private import`import Foo.Bar using (PrivateThing)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // However, a submodule declaring a `public` struct that gets imported with // an `private` qualifier is a valid import declaration.<br>&gt;&gt;&gt; module Foo.Bar<br>&gt;&gt;&gt; public class PublicThing {}<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; module Foo<br>&gt;&gt;&gt; // All good!  Foo can see Foo.Bar.PrivateThing.private import Foo.Bar using (PublicThing)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Because import directives are file-local, they will never be exported<br>&gt;&gt;&gt; along with a public import and will default to exporting the entire<br>&gt;&gt;&gt; contents of the module as though you had never declared them.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // In this file and this file alone, the directives apply.  To the user// of this module, it is as though this declaration were simply:// public import Foundation.Datepublic import Foundation.Date hiding (Date.init())<br>&gt;&gt;&gt;                               renaming (Date.Type.distantPast,<br>&gt;&gt;&gt;                                         to: Date.Type.letsGoLivingInThePast,<br>&gt;&gt;&gt;                                         Date.Type.timeIntervalSinceReferenceDate,<br>&gt;&gt;&gt;                                         to: Date.Type.startOfTheUniverse)<br>&gt;&gt;&gt;                               renaming (Date.Type.&lt;, to: Date.Type.&lt;&lt;&lt;&lt;&lt;)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#impact-on-existing-code&gt;Impact<br>&gt;&gt;&gt; on existing code<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Existing code that is using qualified module import syntax (import<br>&gt;&gt;&gt; {func|class|typealias|class|struct|enum|protocol} &lt;qualified-name&gt;)<br>&gt;&gt;&gt; will be deprecated. Code that is not organized into modules will remain<br>&gt;&gt;&gt; unaffected and organized into one contiguous top-level module. However, it<br>&gt;&gt;&gt; is strongly recommended that frameworks be decomposed and reorganized<br>&gt;&gt;&gt; around the new module system.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; As a case study, the public interface to the standard library appears to<br>&gt;&gt;&gt; already be mostly broken down into submodules as described in<br>&gt;&gt;&gt; GroupInfo.json<br>&gt;&gt;&gt; &lt;https://github.com/apple/swift/blob/master/stdlib/public/core/GroupInfo.json&gt;<br>&gt;&gt;&gt; .<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Code that is defined in modulemaps already defines a module structure<br>&gt;&gt;&gt; that can be imported directly into this scheme.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#alternatives-considered&gt;Alternatives<br>&gt;&gt;&gt; considered<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Module export can also be placed on the module declaration itself. The<br>&gt;&gt;&gt; relevant parts of the grammar that have changed are below with an example:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; module-decl -&gt; &lt;access-level-modifier&gt; module &lt;module-path&gt;<br>&gt;&gt;&gt; import-decl -&gt; import &lt;module-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; private module String.Core.Internals<br>&gt;&gt;&gt; // Shh, it&#39;s a secret.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; While this style makes it immediately obvious to the library author<br>&gt;&gt;&gt; which modules are public or private, it causes the consumer problems<br>&gt;&gt;&gt; because submodule exports are no longer explicit and are entirely ad-hoc.<br>&gt;&gt;&gt; In the interest of enabling, for one, users of IDEs to drill into public<br>&gt;&gt;&gt; submodules, making export local to import seems more appropriate.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160718/53c7eea1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d972db2b6ee8b77746ce7122663eb4f8?s=50"></div><header><strong>[Proposal] Qualified Imports and Modules</strong> from <string>Robert Widmann</string> &lt;rwidmann at apple.com&gt;<p>July 18, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt;  is changed so that, outside the module, it has a member `frobnicate()` and no longer has a member `bobnicate()`?<br></p><p>*Unchanged.  Other than that, you’ve got it!  I wanted to make *very* sure that whatever APIs come in are the same ones that go out regardless of local changes.<br></p><p>&gt; On Jul 18, 2016, at 3:17 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Mon, Jul 18, 2016 at 5:09 PM, Robert Widmann &lt;rwidmann at apple.com &lt;mailto:rwidmann at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Jul 18, 2016, at 3:00 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Mon, Jul 18, 2016 at 4:49 PM, Robert Widmann &lt;rwidmann at apple.com &lt;mailto:rwidmann at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 18, 2016, at 2:32 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is an interesting document. I think it deserves careful study. For now, some questions:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What is the rationale behind permitting the using of specific methods? This seems to be usually fine-grained in comparison to other languages. What use cases do you have in mind for this?<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; One use case: Swift libraries export not just member references as I’ve used here, but a large amount of free functions.  It has long been a problem that free functions seem to pollute a shared namespace and there didn’t seem to be a clear way to hide them.<br>&gt;&gt; <br>&gt;&gt; Would a plausible simplification of the proposal be to have it fine-grained enough to address free functions but not methods inside types?<br>&gt;&gt; Incidentally, although I do not see it in the proposal, I assume that * in some form will be permitted (as in, `import Foundation using *`).<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; I can see the use case for hiding specific symbols when they come into conflict with your own, but in your example you&#39;re hiding specific methods declared *in* an imported type. What is the use case here? Is it going to allow me to open backdoors so that, if I don&#39;t like `Foo.frobnicate()`, I can hide it and then substitute my own in an extension? This seems like a bad thing at first blush.<br>&gt;&gt; <br>&gt;&gt; For members that would be an acceptable use-case.  The worst-case scenario that comes to mind is this being used as a way to “virtually override” a method in a subclass.  Then again, the scope of the damage is limited to the file in which you’ve declared this monstrosity so clients and even you will not be able to see it outside of there unless you explicitly redeclare the hiding import (in which case, you probably know what you’re doing).<br>&gt;&gt; <br>&gt;&gt; A use care here might be hiding the KVO-ish parts of an object from yourself, or more generally subsetting out the part of an API you know you shouldn’t interact with in a particular submodule.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I can see the obvious use case for renaming modules and types on import--basically, in my mind, it&#39;s like typealiases with hiding, and it&#39;s available in other languages of course. But how would renaming methods work? If Foo conforms to Equatable and I rename `Foo.==` to `Foo.!=`, is the type I import still Equatable? How would it behave? And even if Foo is fine, what happens if I try to subclass my Frankensteinian Foo?<br>&gt;&gt; <br>&gt;&gt; Of course you still conform to Equatable.  The renaming defines a mapping from your names to “proper&quot; names.  For example, if you use a renaming import to change the requirements of a protocol in a file, then your conformance will simply look at the mapping and see that everything resolves into its proper place.  Bear in mind that your renamings will not survive outside of the file in which you declare them.  Frankenteinian Foo exists where you say it does and nowhere else.  Everybody else just sees Foo conform to Equatable (unless they rename things themselves).<br>&gt;&gt; <br>&gt;&gt; Maybe let&#39;s work through an example:<br>&gt;&gt; <br>&gt;&gt; Suppose we have in stdlib:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; public protocol FooProtocol {<br>&gt;&gt;   func frobnicate()<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; Now, I write a library:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; import Swift.FooProtocol renaming (FooProtocol.frobnicate(), to: FooProtocol.bobnicate())<br>&gt;&gt; <br>&gt;&gt; public open class MyFoo : Swift.FooProtocol {<br>&gt;&gt;   public open func bobnicate() {<br>&gt;&gt;     print(&quot;Does your head hurt yet?&quot;)<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; Now, you are an end user of my sinister library.<br>&gt;&gt; <br>&gt;&gt; What is the public API of `MyFoo`?<br>&gt; <br>&gt; The proposal addresses this<br>&gt; <br>&gt; &gt; Because import directives are file-local, they will never be exported along with a `public` import and will<br>&gt; &gt; default to exporting the entire contents of the module as though you had never declared them.<br>&gt; <br>&gt; The user (and even you in other files that import this module) will see a protocol conformance exactly as laid out in the Swift.FooProtocol module.<br>&gt; <br>&gt;&gt; For you, does `MyFoo` conform to `Swift.FooProtocol`?<br>&gt; <br>&gt; It conforms because the renaming you wrote describes a way of resolving FooProtocol.bobnicate() (your API) to FooProtocol.frobnicate() (everybody else’s API).<br>&gt; <br>&gt;&gt; Can you call `MyFoo.frobnicate()`? How about `MyFoo.bobnicate()`?<br>&gt;&gt; <br>&gt;&gt; What if you try to subclass `MyFoo`?<br>&gt; <br>&gt; If you are inside the module you wrote the renaming, you will use it.  If you are outside of it, you will see the protocol requirement sans renaming.<br>&gt; <br>&gt;&gt; Does your subclass still conform to `Swift.FooProtocol`?<br>&gt;&gt; Do you override `bobnicate()` or `frobnicate()`?<br>&gt;&gt; My head hurts…<br>&gt; <br>&gt; Because you have explicitly renamed the protocol requirement, you will override the same protocol requirement both inside and outside this module but your renaming will not propagate to other files unless they themselves opt in the way you have here.  It would be particularly sinister if you could arbitrarily edit the user-facing API of members simply by importing a library.<br>&gt; <br>&gt; Sounds good. If I understand you correctly, by conforming `MyFoo` to an internally renamed `Swift.FooProtocol`, the renaming of the user-facing API for `FooProtocol` means that the public API of `MyFoo` is changed so that, outside the module, it has a member `frobnicate()` and no longer has a member `bobnicate()`?<br>&gt; <br>&gt; <br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Mon, Jul 18, 2016 at 16:10 Robert Widmann via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; TJ Usiyan, Harlan Haskins, and I have been working on a proposal to rework qualified imports and introduce an explicit module system to Swift that we’d like to publish for your viewing pleasure.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The initial impetus was set out in a radar (rdar://17630570 &lt;&gt;) I sent fairly early on that didn’t receive a response, so I started a swift-evolution &lt;http://permalink.gmane.org/gmane.comp.lang.swift.evolution/1378&gt; thread discussing the basics of this proposal.  It has been refined and expanded a bit to include an effort to make Swift modules explicit and updated with the feedback of that first thread.  Contents of the proposal are inline and can also be had as a gist &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6&gt; or on Github. &lt;https://github.com/apple/swift-evolution/pull/440&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Qualified Imports and Modules<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposal: SE-NNNN &lt;https://gist.github.com/CodaFi/NNNN-first-class-qualified-imports.md&gt;<br>&gt;&gt;&gt; Authors: Robert Widmann &lt;https://github.com/codafi&gt;, Harlan Haskins &lt;https://github.com/harlanhaskins&gt;, TJ Usiyan &lt;https://github.com/griotspeak&gt;<br>&gt;&gt;&gt; Status: Awaiting review<br>&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#introduction&gt;Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We propose a complete overhaul of the qualified imports syntax and semantics and the introduction of a module system.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#motivation&gt;Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift code is modular by default. However, it is not clear how to decompose existing modules further into submodules. In addition, it is difficult to tell how importing a module affects its export to consumers of a library. This leads many to either fake namespaces with enums, attempt to structure Swift code with modulemaps, or use a large amount of version-control submodules. All of these can be rolled into one complete package in the form of a comprehensive rethink of the qualified import system and the introduction of a module system.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#proposed-solution&gt;Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Modules will now become an explicit part of working with canonical Swift code. The grammar and semantics of qualified imports will change completely with the addition of import qualifiers and import directives. We also introduce three new contextual keywords: using, hiding, and renaming, to facilitate fine-grained usage of module contents.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#detailed-design&gt;Detailed design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Qualified import syntax will be revised to the following<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; module-decl -&gt; module &lt;module-path&gt;<br>&gt;&gt;&gt; import-decl -&gt; &lt;access-level-modifier&gt; import &lt;module-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt;&gt;&gt; module-path -&gt; &lt;identifier&gt;<br>&gt;&gt;&gt;             -&gt; &lt;identifier&gt;.&lt;import-path&gt;<br>&gt;&gt;&gt; import-directive-list -&gt; &lt;import-directive&gt;<br>&gt;&gt;&gt;                       -&gt; &lt;import-directive&gt; &lt;import-directive-list&gt;<br>&gt;&gt;&gt; import-directive -&gt; using (&lt;identifier&gt;, ...)<br>&gt;&gt;&gt;                  -&gt; hiding (&lt;identifier&gt;, ...)<br>&gt;&gt;&gt;                  -&gt; renaming (&lt;identifier&gt;, to: &lt;identifier&gt;, ...)<br>&gt;&gt;&gt; This introduces the concept of an import directive. An import directive is a file-local modification of an imported identifier. A directive can be one of 3 operations:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1) using: The using directive is followed by a list of identifiers within the imported module that should be exposed to this file. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // The only visible parts of Foundation in this file are <br>&gt;&gt;&gt; // Date.init(), Date.hashValue, and Date.description.<br>&gt;&gt;&gt; import Foundation.Date using (Date.init(), Date.hashValue, Date.description)<br>&gt;&gt;&gt; 2) hiding: The hiding directive is followed by a list of identifiers within the imported module that should be hidden from this file.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Imports all of Foundation.Date except `Date.compare()`<br>&gt;&gt;&gt; import Foundation.Date hiding (Date.compare())<br>&gt;&gt;&gt; 3) renaming: The renaming directive is followed by a list of identifiers separated by to: that should be exposed to this file but renamed. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Imports all of Dispatch.DispatchQueue but renames the static member <br>&gt;&gt;&gt; // DispatchQueue.main, to DispatchQueue.mainQueue<br>&gt;&gt;&gt; import Dispatch.DispatchQueue renaming (DispatchQueue.Type.main to: DispatchQueue.Type.mainQueue)<br>&gt;&gt;&gt; // Renaming can also rename modules.  All members of UIKit have to be qualified with<br>&gt;&gt;&gt; // `UI` now.<br>&gt;&gt;&gt; import UIKit renaming (UIKit, to: UI)<br>&gt;&gt;&gt; Import directives chain to one another and can be used to create a fine-grained module import:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Imports all of Foundation except `DateFormatter` and renames `Cache` to `LRUCache`<br>&gt;&gt;&gt; import Foundation hiding (DateFormatter) renaming (Cache to: LRUCache)<br>&gt;&gt;&gt; // Imports SCNNode except SCNNode.init(mdlObject:) and renames `.description` to<br>&gt;&gt;&gt; // `.nodeDescription` <br>&gt;&gt;&gt; import SceneKit using (SCNNode) <br>&gt;&gt;&gt;                 renaming (SCNNode.description, to: SCNNode.nodeDescription)<br>&gt;&gt;&gt;                 hiding (SCNNode.init(mdlObject:))<br>&gt;&gt;&gt; Directive chaining occurs left-to-right:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // This says to 1) Hide nothing 2) Use nothing 3) rename Int to INT.  It is invalid<br>&gt;&gt;&gt; // because 1) We will show everything 2) Then hide everything 3) Therefore Int is unavailable, error.<br>&gt;&gt;&gt; import Swift hiding () using () renaming (Int, to: INT)<br>&gt;&gt;&gt; // This says to 1) Use Int 2) Hide String 3) rename Double to Triple.  It is invalid<br>&gt;&gt;&gt; // because 1) Int is available 2) String is not, error. 3) Double is unavailable, error.<br>&gt;&gt;&gt; import Swift using (Int) hiding (String) renaming (Double, to: Triple)<br>&gt;&gt;&gt; // Valid.  This will be merged as `using (Int)`<br>&gt;&gt;&gt; import Swift using () using (Int)<br>&gt;&gt;&gt; // Valid.  This will be merged as `hiding (String, Double)`<br>&gt;&gt;&gt; import Swift hiding (String) hiding (Double) hiding ()<br>&gt;&gt;&gt; // Valid (if redundant). This will be merged as `using ()`<br>&gt;&gt;&gt; import Swift using (String) hiding (String)<br>&gt;&gt;&gt; Module scope is delimited by the keyword module followed by a fully qualified name and must occur as the first declaration in a file. For example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // ./Math/Integers/Arithmetic.swift<br>&gt;&gt;&gt; module Math.Integers.Arithmetic<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public protocol _IntegerArithmetic {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public struct _Abs {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; @_versioned<br>&gt;&gt;&gt; internal func _abs&lt;Args&gt;(_ args: Args) -&gt; (_Abs, Args) {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // ./Math/Integers.swift<br>&gt;&gt;&gt; module Math.Integers<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // _abs is visible in this module and all others within the project, <br>&gt;&gt;&gt; // but is not exported along with it.<br>&gt;&gt;&gt; internal import Math.Integers.Arithmetic<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public protocol IntegerArithmetic : _IntegerArithmetic, Comparable {}<br>&gt;&gt;&gt; public protocol SignedNumber : Comparable, ExpressibleByIntegerLiteral {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Math.swift<br>&gt;&gt;&gt; module Math<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Exports the entire public contents of Math.Integers, but nothing in <br>&gt;&gt;&gt; // Math.Integers.Arithmetic.<br>&gt;&gt;&gt; public import Math.Integers<br>&gt;&gt;&gt; Modules names are tied to a directory structure that describes their location relative to the current module and it will now be an error to violate this rule. For example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; module String // lives in ./String.swift<br>&gt;&gt;&gt; module String.Core // lives in ./String/Core.swift<br>&gt;&gt;&gt; module String.Core.Internals.Do.You.Even.Write // lives in ./String/Core/Internals/Do/You/Even/Write.swift<br>&gt;&gt;&gt; Existing projects that do not adopt these rules will still retain their implicit module name (usually defined as the name of the framework or application that is being built) and may continue to use whatever directory structure they wish, however they may not declare any explicit modules.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This proposal also solves the problem of module export. A module that is imported without an access level modifier will default to an internal import per usual. However, when it is useful to fully expose the public content of submodules to a client, a public modifier can be used. Similarly, when it is useful to access internal or [file]private APIs, but not expose them to clients, those access modifiers may be used. The rule of thumb is: Only identifiers that are at least as visible as the qualifier on the import make for valid import declarations. For example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // A submodule declaring a `private` class that gets imported with <br>&gt;&gt;&gt; // an `internal` qualifier with a `using` directive is an invalid import <br>&gt;&gt;&gt; // declaration.  <br>&gt;&gt;&gt; module Foo.Bar<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; private class PrivateThing {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; module Foo<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Error: PrivateThing not visible, use `private import`<br>&gt;&gt;&gt; import Foo.Bar using (PrivateThing) <br>&gt;&gt;&gt; // However, a submodule declaring a `public` struct that gets imported with <br>&gt;&gt;&gt; // an `private` qualifier is a valid import declaration.<br>&gt;&gt;&gt; module Foo.Bar<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public class PublicThing {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; module Foo<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // All good!  Foo can see Foo.Bar.PrivateThing.<br>&gt;&gt;&gt; private import Foo.Bar using (PublicThing) <br>&gt;&gt;&gt; Because import directives are file-local, they will never be exported along with a public import and will default to exporting the entire contents of the module as though you had never declared them.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // In this file and this file alone, the directives apply.  To the user<br>&gt;&gt;&gt; // of this module, it is as though this declaration were simply:<br>&gt;&gt;&gt; // public import Foundation.Date<br>&gt;&gt;&gt; public import Foundation.Date hiding (Date.init()) <br>&gt;&gt;&gt;                               renaming (Date.Type.distantPast, <br>&gt;&gt;&gt;                                         to: Date.Type.letsGoLivingInThePast,<br>&gt;&gt;&gt;                                         Date.Type.timeIntervalSinceReferenceDate, <br>&gt;&gt;&gt;                                         to: Date.Type.startOfTheUniverse)<br>&gt;&gt;&gt;                               renaming (Date.Type.&lt;, to: Date.Type.&lt;&lt;&lt;&lt;&lt;)<br>&gt;&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Existing code that is using qualified module import syntax (import {func|class|typealias|class|struct|enum|protocol} &lt;qualified-name&gt;) will be deprecated. Code that is not organized into modules will remain unaffected and organized into one contiguous top-level module. However, it is strongly recommended that frameworks be decomposed and reorganized around the new module system.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As a case study, the public interface to the standard library appears to already be mostly broken down into submodules as described in GroupInfo.json &lt;https://github.com/apple/swift/blob/master/stdlib/public/core/GroupInfo.json&gt;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Code that is defined in modulemaps already defines a module structure that can be imported directly into this scheme.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#alternatives-considered&gt;Alternatives considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Module export can also be placed on the module declaration itself. The relevant parts of the grammar that have changed are below with an example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; module-decl -&gt; &lt;access-level-modifier&gt; module &lt;module-path&gt;<br>&gt;&gt;&gt; import-decl -&gt; import &lt;module-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt;&gt;&gt; private module String.Core.Internals<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Shh, it&#39;s a secret.<br>&gt;&gt;&gt; While this style makes it immediately obvious to the library author which modules are public or private, it causes the consumer problems because submodule exports are no longer explicit and are entirely ad-hoc. In the interest of enabling, for one, users of IDEs to drill into public submodules, making export local to import seems more appropriate.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160718/c17e2397/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Proposal] Qualified Imports and Modules</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>July 19, 2016 at 12:00:00am</p></header><div class="content"><p>Interesting... mix of c# and swift and others<br></p><p>I am not sure it has many chances to see the light: unless they internally manage to cheat and reuse the natural scoping provided by empty enums, the implications on the binary structure of the dylibs are kolossal... and as if this was not enough, there will be a similar impact on the linux runtime. If memory serves, the last issues standing in the way for a windows port were just recently overcome (same business of how to store the runtime data into the structure of a dll), and this would send them back a few steps back.<br>Considering this is v3.0, the last of the breakers, and this is the very end of the cycle, with features still not designed as well as designs without coders, I think that a deep change like this one is rather unlikely for 3, and unless there is a clever way to make it additive in 4, then ever. Had swiftc been written in swift 4 years ago, this is likely one of the first things the core team would have missed, to deal with a 150,000+ loc codebase (i think in wwdc someone threw 500k as the total size today - the typescript type checker is ~20kloc).<br>But i still hope some variations on the theme will show up (preferably as somthing like the less verbose &quot;using xxxx as vvvvv&quot;  &quot;using xxxxx omitting bbbbbb&quot; &quot;using (bbbbb) from xxxxx&quot;)<br></p><p>Regards<br>(From mobile)<br></p><p>&gt; On Jul 18, 2016, at 11:09 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello all,<br>&gt; <br>&gt; TJ Usiyan, Harlan Haskins, and I have been working on a proposal to rework qualified imports and introduce an explicit module system to Swift that we’d like to publish for your viewing pleasure.<br>&gt; <br>&gt; The initial impetus was set out in a radar (rdar://17630570) I sent fairly early on that didn’t receive a response, so I started a swift-evolution thread discussing the basics of this proposal.  It has been refined and expanded a bit to include an effort to make Swift modules explicit and updated with the feedback of that first thread.  Contents of the proposal are inline and can also be had as a gist or on Github.<br>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt; Qualified Imports and Modules<br>&gt; <br>&gt; Proposal: SE-NNNN<br>&gt; Authors: Robert Widmann, Harlan Haskins, TJ Usiyan<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; We propose a complete overhaul of the qualified imports syntax and semantics and the introduction of a module system.<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; Swift code is modular by default. However, it is not clear how to decompose existing modules further into submodules. In addition, it is difficult to tell how importing a module affects its export to consumers of a library. This leads many to either fake namespaces with enums, attempt to structure Swift code with modulemaps, or use a large amount of version-control submodules. All of these can be rolled into one complete package in the form of a comprehensive rethink of the qualified import system and the introduction of a module system.<br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; Modules will now become an explicit part of working with canonical Swift code. The grammar and semantics of qualified imports will change completely with the addition of import qualifiers and import directives. We also introduce three new contextual keywords: using, hiding, and renaming, to facilitate fine-grained usage of module contents.<br>&gt; <br>&gt; Detailed design<br>&gt; <br>&gt; Qualified import syntax will be revised to the following<br>&gt; <br>&gt; module-decl -&gt; module &lt;module-path&gt;<br>&gt; import-decl -&gt; &lt;access-level-modifier&gt; import &lt;module-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt; module-path -&gt; &lt;identifier&gt;<br>&gt;             -&gt; &lt;identifier&gt;.&lt;import-path&gt;<br>&gt; import-directive-list -&gt; &lt;import-directive&gt;<br>&gt;                       -&gt; &lt;import-directive&gt; &lt;import-directive-list&gt;<br>&gt; import-directive -&gt; using (&lt;identifier&gt;, ...)<br>&gt;                  -&gt; hiding (&lt;identifier&gt;, ...)<br>&gt;                  -&gt; renaming (&lt;identifier&gt;, to: &lt;identifier&gt;, ...)<br>&gt; This introduces the concept of an import directive. An import directive is a file-local modification of an imported identifier. A directive can be one of 3 operations:<br>&gt; <br>&gt; 1) using: The using directive is followed by a list of identifiers within the imported module that should be exposed to this file. <br>&gt; <br>&gt; // The only visible parts of Foundation in this file are <br>&gt; // Date.init(), Date.hashValue, and Date.description.<br>&gt; import Foundation.Date using (Date.init(), Date.hashValue, Date.description)<br>&gt; 2) hiding: The hiding directive is followed by a list of identifiers within the imported module that should be hidden from this file.<br>&gt; <br>&gt; // Imports all of Foundation.Date except `Date.compare()`<br>&gt; import Foundation.Date hiding (Date.compare())<br>&gt; 3) renaming: The renaming directive is followed by a list of identifiers separated by to: that should be exposed to this file but renamed. <br>&gt; <br>&gt; // Imports all of Dispatch.DispatchQueue but renames the static member <br>&gt; // DispatchQueue.main, to DispatchQueue.mainQueue<br>&gt; import Dispatch.DispatchQueue renaming (DispatchQueue.Type.main to: DispatchQueue.Type.mainQueue)<br>&gt; // Renaming can also rename modules.  All members of UIKit have to be qualified with<br>&gt; // `UI` now.<br>&gt; import UIKit renaming (UIKit, to: UI)<br>&gt; Import directives chain to one another and can be used to create a fine-grained module import:<br>&gt; <br>&gt; // Imports all of Foundation except `DateFormatter` and renames `Cache` to `LRUCache`<br>&gt; import Foundation hiding (DateFormatter) renaming (Cache to: LRUCache)<br>&gt; // Imports SCNNode except SCNNode.init(mdlObject:) and renames `.description` to<br>&gt; // `.nodeDescription` <br>&gt; import SceneKit using (SCNNode) <br>&gt;                 renaming (SCNNode.description, to: SCNNode.nodeDescription)<br>&gt;                 hiding (SCNNode.init(mdlObject:))<br>&gt; Directive chaining occurs left-to-right:<br>&gt; <br>&gt; // This says to 1) Hide nothing 2) Use nothing 3) rename Int to INT.  It is invalid<br>&gt; // because 1) We will show everything 2) Then hide everything 3) Therefore Int is unavailable, error.<br>&gt; import Swift hiding () using () renaming (Int, to: INT)<br>&gt; // This says to 1) Use Int 2) Hide String 3) rename Double to Triple.  It is invalid<br>&gt; // because 1) Int is available 2) String is not, error. 3) Double is unavailable, error.<br>&gt; import Swift using (Int) hiding (String) renaming (Double, to: Triple)<br>&gt; // Valid.  This will be merged as `using (Int)`<br>&gt; import Swift using () using (Int)<br>&gt; // Valid.  This will be merged as `hiding (String, Double)`<br>&gt; import Swift hiding (String) hiding (Double) hiding ()<br>&gt; // Valid (if redundant). This will be merged as `using ()`<br>&gt; import Swift using (String) hiding (String)<br>&gt; Module scope is delimited by the keyword module followed by a fully qualified name and must occur as the first declaration in a file. For example:<br>&gt; <br>&gt; // ./Math/Integers/Arithmetic.swift<br>&gt; module Math.Integers.Arithmetic<br>&gt; <br>&gt; public protocol _IntegerArithmetic {}<br>&gt; <br>&gt; public struct _Abs {}<br>&gt; <br>&gt; @_versioned<br>&gt; internal func _abs&lt;Args&gt;(_ args: Args) -&gt; (_Abs, Args) {}<br>&gt; <br>&gt; // ./Math/Integers.swift<br>&gt; module Math.Integers<br>&gt; <br>&gt; // _abs is visible in this module and all others within the project, <br>&gt; // but is not exported along with it.<br>&gt; internal import Math.Integers.Arithmetic<br>&gt; <br>&gt; public protocol IntegerArithmetic : _IntegerArithmetic, Comparable {}<br>&gt; public protocol SignedNumber : Comparable, ExpressibleByIntegerLiteral {}<br>&gt; <br>&gt; <br>&gt; // Math.swift<br>&gt; module Math<br>&gt; <br>&gt; // Exports the entire public contents of Math.Integers, but nothing in <br>&gt; // Math.Integers.Arithmetic.<br>&gt; public import Math.Integers<br>&gt; Modules names are tied to a directory structure that describes their location relative to the current module and it will now be an error to violate this rule. For example:<br>&gt; <br>&gt; module String // lives in ./String.swift<br>&gt; module String.Core // lives in ./String/Core.swift<br>&gt; module String.Core.Internals.Do.You.Even.Write // lives in ./String/Core/Internals/Do/You/Even/Write.swift<br>&gt; Existing projects that do not adopt these rules will still retain their implicit module name (usually defined as the name of the framework or application that is being built) and may continue to use whatever directory structure they wish, however they may not declare any explicit modules.<br>&gt; <br>&gt; This proposal also solves the problem of module export. A module that is imported without an access level modifier will default to an internal import per usual. However, when it is useful to fully expose the public content of submodules to a client, a public modifier can be used. Similarly, when it is useful to access internal or [file]private APIs, but not expose them to clients, those access modifiers may be used. The rule of thumb is: Only identifiers that are at least as visible as the qualifier on the import make for valid import declarations. For example:<br>&gt; <br>&gt; // A submodule declaring a `private` class that gets imported with <br>&gt; // an `internal` qualifier with a `using` directive is an invalid import <br>&gt; // declaration.  <br>&gt; module Foo.Bar<br>&gt; <br>&gt; private class PrivateThing {}<br>&gt; <br>&gt; module Foo<br>&gt; <br>&gt; // Error: PrivateThing not visible, use `private import`<br>&gt; import Foo.Bar using (PrivateThing) <br>&gt; // However, a submodule declaring a `public` struct that gets imported with <br>&gt; // an `private` qualifier is a valid import declaration.<br>&gt; module Foo.Bar<br>&gt; <br>&gt; public class PublicThing {}<br>&gt; <br>&gt; module Foo<br>&gt; <br>&gt; // All good!  Foo can see Foo.Bar.PrivateThing.<br>&gt; private import Foo.Bar using (PublicThing) <br>&gt; Because import directives are file-local, they will never be exported along with a public import and will default to exporting the entire contents of the module as though you had never declared them.<br>&gt; <br>&gt; // In this file and this file alone, the directives apply.  To the user<br>&gt; // of this module, it is as though this declaration were simply:<br>&gt; // public import Foundation.Date<br>&gt; public import Foundation.Date hiding (Date.init()) <br>&gt;                               renaming (Date.Type.distantPast, <br>&gt;                                         to: Date.Type.letsGoLivingInThePast,<br>&gt;                                         Date.Type.timeIntervalSinceReferenceDate, <br>&gt;                                         to: Date.Type.startOfTheUniverse)<br>&gt;                               renaming (Date.Type.&lt;, to: Date.Type.&lt;&lt;&lt;&lt;&lt;)<br>&gt; Impact on existing code<br>&gt; <br>&gt; Existing code that is using qualified module import syntax (import {func|class|typealias|class|struct|enum|protocol} &lt;qualified-name&gt;) will be deprecated. Code that is not organized into modules will remain unaffected and organized into one contiguous top-level module. However, it is strongly recommended that frameworks be decomposed and reorganized around the new module system.<br>&gt; <br>&gt; As a case study, the public interface to the standard library appears to already be mostly broken down into submodules as described in GroupInfo.json.<br>&gt; <br>&gt; Code that is defined in modulemaps already defines a module structure that can be imported directly into this scheme.<br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; Module export can also be placed on the module declaration itself. The relevant parts of the grammar that have changed are below with an example:<br>&gt; <br>&gt; module-decl -&gt; &lt;access-level-modifier&gt; module &lt;module-path&gt;<br>&gt; import-decl -&gt; import &lt;module-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt; private module String.Core.Internals<br>&gt; <br>&gt; // Shh, it&#39;s a secret.<br>&gt; While this style makes it immediately obvious to the library author which modules are public or private, it causes the consumer problems because submodule exports are no longer explicit and are entirely ad-hoc. In the interest of enabling, for one, users of IDEs to drill into public submodules, making export local to import seems more appropriate.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160719/f8f44236/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Proposal] Qualified Imports and Modules</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>July 18, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jul 18, 2016, at 2:09 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello all,<br>&gt; <br>&gt; TJ Usiyan, Harlan Haskins, and I have been working on a proposal to rework qualified imports and introduce an explicit module system to Swift that we’d like to publish for your viewing pleasure.<br>&gt; <br>&gt; The initial impetus was set out in a radar (rdar://17630570 &lt;rdar://17630570&gt;) I sent fairly early on that didn’t receive a response, so I started a swift-evolution &lt;http://permalink.gmane.org/gmane.comp.lang.swift.evolution/1378&gt; thread discussing the basics of this proposal.  It has been refined and expanded a bit to include an effort to make Swift modules explicit and updated with the feedback of that first thread.  Contents of the proposal are inline and can also be had as a gist &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6&gt; or on Github. &lt;https://github.com/apple/swift-evolution/pull/440&gt;<br>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt; Qualified Imports and Modules<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;https://gist.github.com/CodaFi/NNNN-first-class-qualified-imports.md&gt;<br>&gt; Authors: Robert Widmann &lt;https://github.com/codafi&gt;, Harlan Haskins &lt;https://github.com/harlanhaskins&gt;, TJ Usiyan &lt;https://github.com/griotspeak&gt;<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#introduction&gt;Introduction<br>&gt; <br>&gt; We propose a complete overhaul of the qualified imports syntax and semantics and the introduction of a module system.<br>&gt; <br>&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#motivation&gt;Motivation<br>&gt; <br>&gt; Swift code is modular by default. However, it is not clear how to decompose existing modules further into submodules. In addition, it is difficult to tell how importing a module affects its export to consumers of a library. This leads many to either fake namespaces with enums, attempt to structure Swift code with modulemaps, or use a large amount of version-control submodules. All of these can be rolled into one complete package in the form of a comprehensive rethink of the qualified import system and the introduction of a module system.<br>&gt; <br>&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; Modules will now become an explicit part of working with canonical Swift code. The grammar and semantics of qualified imports will change completely with the addition of import qualifiers and import directives. We also introduce three new contextual keywords: using, hiding, and renaming, to facilitate fine-grained usage of module contents.<br>&gt; <br>&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#detailed-design&gt;Detailed design<br>&gt; <br>&gt; Qualified import syntax will be revised to the following<br>&gt; <br>&gt; module-decl -&gt; module &lt;module-path&gt;<br>&gt; import-decl -&gt; &lt;access-level-modifier&gt; import &lt;module-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt; module-path -&gt; &lt;identifier&gt;<br>&gt;             -&gt; &lt;identifier&gt;.&lt;import-path&gt;<br>&gt; import-directive-list -&gt; &lt;import-directive&gt;<br>&gt;                       -&gt; &lt;import-directive&gt; &lt;import-directive-list&gt;<br>&gt; import-directive -&gt; using (&lt;identifier&gt;, ...)<br>&gt;                  -&gt; hiding (&lt;identifier&gt;, ...)<br>&gt;                  -&gt; renaming (&lt;identifier&gt;, to: &lt;identifier&gt;, ...)<br>&gt; This introduces the concept of an import directive. An import directive is a file-local modification of an imported identifier. A directive can be one of 3 operations:<br>&gt; <br>&gt; 1) using: The using directive is followed by a list of identifiers within the imported module that should be exposed to this file. <br>&gt; <br>&gt; // The only visible parts of Foundation in this file are <br>&gt; // Date.init(), Date.hashValue, and Date.description.<br>&gt; import Foundation.Date using (Date.init(), Date.hashValue, Date.description)<br>&gt; 2) hiding: The hiding directive is followed by a list of identifiers within the imported module that should be hidden from this file.<br>&gt; <br>&gt; // Imports all of Foundation.Date except `Date.compare()`<br>&gt; import Foundation.Date hiding (Date.compare())<br>It&#39;s unfortunate that this proposal requires the identifiers to be re-qualified when the imported module is actually the name of a type.  It seems to me that whether e.g. a type is defined in its own sub-module is a detail that users won&#39;t really appreciate and which probably shouldn&#39;t be surfaced to them.  In fact, in general I&#39;m concerned about this turning the file and directory organization of a project into API.<br></p><p>&gt; This proposal also solves the problem of module export. A module that is imported without an access level modifier will default to an internal import per usual. However, when it is useful to fully expose the public content of submodules to a client, a public modifier can be used. Similarly, when it is useful to access internal or [file]private APIs, but not expose them to clients, those access modifiers may be used.<br>&gt; <br>These uses of access modifiers feel inconsistent to me.  &quot;public import Foo&quot; exports the contents of Foo as if they were members of my module, but &quot;private import Foo&quot; imports the private APIs (?) of Foo?  That is not the same interpretive rule.<br></p><p>I think the more consistent analogy for &quot;private import&quot; would be to say that the public members of Foo are visible in this file only (i.e. the default behavior of &quot;import&quot; today, which I think we would want to keep), whereas you could do an &quot;internal import&quot; to make the members of Foo visible throughout the current module (potentially useful if you have an interesting set of common modifications you want to make).<br></p><p>I don&#39;t know why you think it should be possible to import the private declarations of a module.  That seems completely contrary to the access-control design.  I agree that it&#39;s useful to have sub-modules expose APIs that are only usable by other parts of the larger module, but I think the Swiftier design would be for that to be opt-in on the declaration somehow, or at least to specify how it interacts with &quot;internal&quot;.<br></p><p>Also, it is completely unclear to me why modifiers like &quot;renaming&quot; don&#39;t change how the imported module&#39;s declarations are re-exported.<br></p><p>John.<br></p><p>&gt; The rule of thumb is: Only identifiers that are at least as visible as the qualifier on the import make for valid import declarations. For example:<br>&gt; <br>&gt; // A submodule declaring a `private` class that gets imported with <br>&gt; // an `internal` qualifier with a `using` directive is an invalid import <br>&gt; // declaration.  <br>&gt; module Foo.Bar<br>&gt; <br>&gt; private class PrivateThing {}<br>&gt; <br>&gt; module Foo<br>&gt; <br>&gt; // Error: PrivateThing not visible, use `private import`<br>&gt; import Foo.Bar using (PrivateThing) <br>&gt; // However, a submodule declaring a `public` struct that gets imported with <br>&gt; // an `private` qualifier is a valid import declaration.<br>&gt; module Foo.Bar<br>&gt; <br>&gt; public class PublicThing {}<br>&gt; <br>&gt; module Foo<br>&gt; <br>&gt; // All good!  Foo can see Foo.Bar.PrivateThing.<br>&gt; private import Foo.Bar using (PublicThing) <br>&gt; Because import directives are file-local, they will never be exported along with a public import and will default to exporting the entire contents of the module as though you had never declared them.<br>&gt; <br>&gt; // In this file and this file alone, the directives apply.  To the user<br>&gt; // of this module, it is as though this declaration were simply:<br>&gt; // public import Foundation.Date<br>&gt; public import Foundation.Date hiding (Date.init()) <br>&gt;                               renaming (Date.Type.distantPast, <br>&gt;                                         to: Date.Type.letsGoLivingInThePast,<br>&gt;                                         Date.Type.timeIntervalSinceReferenceDate, <br>&gt;                                         to: Date.Type.startOfTheUniverse)<br>&gt;                               renaming (Date.Type.&lt;, to: Date.Type.&lt;&lt;&lt;&lt;&lt;)<br>&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; Existing code that is using qualified module import syntax (import {func|class|typealias|class|struct|enum|protocol} &lt;qualified-name&gt;) will be deprecated. Code that is not organized into modules will remain unaffected and organized into one contiguous top-level module. However, it is strongly recommended that frameworks be decomposed and reorganized around the new module system.<br>&gt; <br>&gt; As a case study, the public interface to the standard library appears to already be mostly broken down into submodules as described in GroupInfo.json &lt;https://github.com/apple/swift/blob/master/stdlib/public/core/GroupInfo.json&gt;.<br>&gt; <br>&gt; Code that is defined in modulemaps already defines a module structure that can be imported directly into this scheme.<br>&gt; <br>&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt; Module export can also be placed on the module declaration itself. The relevant parts of the grammar that have changed are below with an example:<br>&gt; <br>&gt; module-decl -&gt; &lt;access-level-modifier&gt; module &lt;module-path&gt;<br>&gt; import-decl -&gt; import &lt;module-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt; private module String.Core.Internals<br>&gt; <br>&gt; // Shh, it&#39;s a secret.<br>&gt; While this style makes it immediately obvious to the library author which modules are public or private, it causes the consumer problems because submodule exports are no longer explicit and are entirely ad-hoc. In the interest of enabling, for one, users of IDEs to drill into public submodules, making export local to import seems more appropriate.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160718/c8ca9c66/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d972db2b6ee8b77746ce7122663eb4f8?s=50"></div><header><strong>[Proposal] Qualified Imports and Modules</strong> from <string>Robert Widmann</string> &lt;rwidmann at apple.com&gt;<p>July 18, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jul 18, 2016, at 3:21 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jul 18, 2016, at 2:09 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello all,<br>&gt;&gt; <br>&gt;&gt; TJ Usiyan, Harlan Haskins, and I have been working on a proposal to rework qualified imports and introduce an explicit module system to Swift that we’d like to publish for your viewing pleasure.<br>&gt;&gt; <br>&gt;&gt; The initial impetus was set out in a radar (rdar://17630570 &lt;rdar://17630570&gt;) I sent fairly early on that didn’t receive a response, so I started a swift-evolution &lt;http://permalink.gmane.org/gmane.comp.lang.swift.evolution/1378&gt; thread discussing the basics of this proposal.  It has been refined and expanded a bit to include an effort to make Swift modules explicit and updated with the feedback of that first thread.  Contents of the proposal are inline and can also be had as a gist &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6&gt; or on Github. &lt;https://github.com/apple/swift-evolution/pull/440&gt;<br>&gt;&gt; <br>&gt;&gt; Cheers,<br>&gt;&gt; <br>&gt;&gt; ~Robert Widmann<br>&gt;&gt; <br>&gt;&gt; Qualified Imports and Modules<br>&gt;&gt; <br>&gt;&gt; Proposal: SE-NNNN &lt;https://gist.github.com/CodaFi/NNNN-first-class-qualified-imports.md&gt;<br>&gt;&gt; Authors: Robert Widmann &lt;https://github.com/codafi&gt;, Harlan Haskins &lt;https://github.com/harlanhaskins&gt;, TJ Usiyan &lt;https://github.com/griotspeak&gt;<br>&gt;&gt; Status: Awaiting review<br>&gt;&gt; Review manager: TBD<br>&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#introduction&gt;Introduction<br>&gt;&gt; <br>&gt;&gt; We propose a complete overhaul of the qualified imports syntax and semantics and the introduction of a module system.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#motivation&gt;Motivation<br>&gt;&gt; <br>&gt;&gt; Swift code is modular by default. However, it is not clear how to decompose existing modules further into submodules. In addition, it is difficult to tell how importing a module affects its export to consumers of a library. This leads many to either fake namespaces with enums, attempt to structure Swift code with modulemaps, or use a large amount of version-control submodules. All of these can be rolled into one complete package in the form of a comprehensive rethink of the qualified import system and the introduction of a module system.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#proposed-solution&gt;Proposed solution<br>&gt;&gt; <br>&gt;&gt; Modules will now become an explicit part of working with canonical Swift code. The grammar and semantics of qualified imports will change completely with the addition of import qualifiers and import directives. We also introduce three new contextual keywords: using, hiding, and renaming, to facilitate fine-grained usage of module contents.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#detailed-design&gt;Detailed design<br>&gt;&gt; <br>&gt;&gt; Qualified import syntax will be revised to the following<br>&gt;&gt; <br>&gt;&gt; module-decl -&gt; module &lt;module-path&gt;<br>&gt;&gt; import-decl -&gt; &lt;access-level-modifier&gt; import &lt;module-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt;&gt; module-path -&gt; &lt;identifier&gt;<br>&gt;&gt;             -&gt; &lt;identifier&gt;.&lt;import-path&gt;<br>&gt;&gt; import-directive-list -&gt; &lt;import-directive&gt;<br>&gt;&gt;                       -&gt; &lt;import-directive&gt; &lt;import-directive-list&gt;<br>&gt;&gt; import-directive -&gt; using (&lt;identifier&gt;, ...)<br>&gt;&gt;                  -&gt; hiding (&lt;identifier&gt;, ...)<br>&gt;&gt;                  -&gt; renaming (&lt;identifier&gt;, to: &lt;identifier&gt;, ...)<br>&gt;&gt; This introduces the concept of an import directive. An import directive is a file-local modification of an imported identifier. A directive can be one of 3 operations:<br>&gt;&gt; <br>&gt;&gt; 1) using: The using directive is followed by a list of identifiers within the imported module that should be exposed to this file. <br>&gt;&gt; <br>&gt;&gt; // The only visible parts of Foundation in this file are <br>&gt;&gt; // Date.init(), Date.hashValue, and Date.description.<br>&gt;&gt; import Foundation.Date using (Date.init(), Date.hashValue, Date.description)<br>&gt;&gt; 2) hiding: The hiding directive is followed by a list of identifiers within the imported module that should be hidden from this file.<br>&gt;&gt; <br>&gt;&gt; // Imports all of Foundation.Date except `Date.compare()`<br>&gt;&gt; import Foundation.Date hiding (Date.compare())<br>&gt; It&#39;s unfortunate that this proposal requires the identifiers to be re-qualified when the imported module is actually the name of a type.<br></p><p>I considered making that a feature of this proposal but I had a tough time reconciling removing the decl specifier from qualified imports and having an unambiguous notation for Swift declarations. <br></p><p>&gt;  It seems to me that whether e.g. a type is defined in its own sub-module is a detail that users won&#39;t really appreciate and which probably shouldn&#39;t be surfaced to them.  In fact, in general I&#39;m concerned about this turning the file and directory organization of a project into API.<br></p><p>It’s a detail that they’ve already had to have surfaced if they use the existing syntax.<br></p><p>&gt;  In fact, in general I&#39;m concerned about this turning the file and directory organization of a project into API.<br></p><p>It’s a legitimate concern and one that I share considering there is a way to abuse this restriction (*cough* Java), or try to rally around a limited set of namespaces for common controls.<br></p><p>&gt; <br>&gt;&gt; This proposal also solves the problem of module export. A module that is imported without an access level modifier will default to an internal import per usual. However, when it is useful to fully expose the public content of submodules to a client, a public modifier can be used. Similarly, when it is useful to access internal or [file]private APIs, but not expose them to clients, those access modifiers may be used.<br>&gt;&gt; <br>&gt; These uses of access modifiers feel inconsistent to me.  &quot;public import Foo&quot; exports the contents of Foo as if they were members of my module, but &quot;private import Foo&quot; imports the private APIs (?) of Foo?  That is not the same interpretive rule.<br>&gt; <br></p><p>It’s not, and it’s that way intentionally.  Non-public imports do not re-export.  The wording around this is shabby, I’ll work to improve it.<br></p><p>&gt; I think the more consistent analogy for &quot;private import&quot; would be to say that the public members of Foo are visible in this file only (i.e. the default behavior of &quot;import&quot; today, which I think we would want to keep), whereas you could do an &quot;internal import&quot; to make the members of Foo visible throughout the current module (potentially useful if you have an interesting set of common modifications you want to make).<br>&gt; <br></p><p>&gt; I don&#39;t know why you think it should be possible to import the private declarations of a module.  That seems completely contrary to the access-control design.  I agree that it&#39;s useful to have sub-modules expose APIs that are only usable by other parts of the larger module, but I think the Swiftier design would be for that to be opt-in on the declaration somehow, or at least to specify how it interacts with &quot;internal&quot;.<br>&gt; <br></p><p>I was approached by users at WWDC that did wish to have some way of grouping a bunch of private Swift files that should “know about each other’s internal stuff”.  At the time this was the semantics that seemed to match that and stayed in-line with what a `private import` could possibly do.  Perhaps this kind of import can be banned-by-diagnostic in that case.<br></p><p>&gt; Also, it is completely unclear to me why modifiers like &quot;renaming&quot; don&#39;t change how the imported module&#39;s declarations are re-exported.<br>&gt; <br></p><p>Because importing a library shouldn’t be able to change whatever it likes and break client code on re-export.  I don’t have a particularly compelling use-case for allowing user-specified mappings to escape file scope and neither do many other languages I can find that permit this feature.  If you have one I’d like to know about it.<br></p><p>&gt; John.<br>&gt; <br>&gt;&gt; The rule of thumb is: Only identifiers that are at least as visible as the qualifier on the import make for valid import declarations. For example:<br>&gt;&gt; <br>&gt;&gt; // A submodule declaring a `private` class that gets imported with <br>&gt;&gt; // an `internal` qualifier with a `using` directive is an invalid import <br>&gt;&gt; // declaration.  <br>&gt;&gt; module Foo.Bar<br>&gt;&gt; <br>&gt;&gt; private class PrivateThing {}<br>&gt;&gt; <br>&gt;&gt; module Foo<br>&gt;&gt; <br>&gt;&gt; // Error: PrivateThing not visible, use `private import`<br>&gt;&gt; import Foo.Bar using (PrivateThing) <br>&gt;&gt; // However, a submodule declaring a `public` struct that gets imported with <br>&gt;&gt; // an `private` qualifier is a valid import declaration.<br>&gt;&gt; module Foo.Bar<br>&gt;&gt; <br>&gt;&gt; public class PublicThing {}<br>&gt;&gt; <br>&gt;&gt; module Foo<br>&gt;&gt; <br>&gt;&gt; // All good!  Foo can see Foo.Bar.PrivateThing.<br>&gt;&gt; private import Foo.Bar using (PublicThing) <br>&gt;&gt; Because import directives are file-local, they will never be exported along with a public import and will default to exporting the entire contents of the module as though you had never declared them.<br>&gt;&gt; <br>&gt;&gt; // In this file and this file alone, the directives apply.  To the user<br>&gt;&gt; // of this module, it is as though this declaration were simply:<br>&gt;&gt; // public import Foundation.Date<br>&gt;&gt; public import Foundation.Date hiding (Date.init()) <br>&gt;&gt;                               renaming (Date.Type.distantPast, <br>&gt;&gt;                                         to: Date.Type.letsGoLivingInThePast,<br>&gt;&gt;                                         Date.Type.timeIntervalSinceReferenceDate, <br>&gt;&gt;                                         to: Date.Type.startOfTheUniverse)<br>&gt;&gt;                               renaming (Date.Type.&lt;, to: Date.Type.&lt;&lt;&lt;&lt;&lt;)<br>&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt; <br>&gt;&gt; Existing code that is using qualified module import syntax (import {func|class|typealias|class|struct|enum|protocol} &lt;qualified-name&gt;) will be deprecated. Code that is not organized into modules will remain unaffected and organized into one contiguous top-level module. However, it is strongly recommended that frameworks be decomposed and reorganized around the new module system.<br>&gt;&gt; <br>&gt;&gt; As a case study, the public interface to the standard library appears to already be mostly broken down into submodules as described in GroupInfo.json &lt;https://github.com/apple/swift/blob/master/stdlib/public/core/GroupInfo.json&gt;.<br>&gt;&gt; <br>&gt;&gt; Code that is defined in modulemaps already defines a module structure that can be imported directly into this scheme.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#alternatives-considered&gt;Alternatives considered<br>&gt;&gt; <br>&gt;&gt; Module export can also be placed on the module declaration itself. The relevant parts of the grammar that have changed are below with an example:<br>&gt;&gt; <br>&gt;&gt; module-decl -&gt; &lt;access-level-modifier&gt; module &lt;module-path&gt;<br>&gt;&gt; import-decl -&gt; import &lt;module-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt;&gt; private module String.Core.Internals<br>&gt;&gt; <br>&gt;&gt; // Shh, it&#39;s a secret.<br>&gt;&gt; While this style makes it immediately obvious to the library author which modules are public or private, it causes the consumer problems because submodule exports are no longer explicit and are entirely ad-hoc. In the interest of enabling, for one, users of IDEs to drill into public submodules, making export local to import seems more appropriate.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160718/571a7bed/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Proposal] Qualified Imports and Modules</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>July 18, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jul 18, 2016, at 3:53 PM, Robert Widmann &lt;rwidmann at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 18, 2016, at 3:21 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jul 18, 2016, at 2:09 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; TJ Usiyan, Harlan Haskins, and I have been working on a proposal to rework qualified imports and introduce an explicit module system to Swift that we’d like to publish for your viewing pleasure.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The initial impetus was set out in a radar (rdar://17630570 &lt;rdar://17630570&gt;) I sent fairly early on that didn’t receive a response, so I started a swift-evolution &lt;http://permalink.gmane.org/gmane.comp.lang.swift.evolution/1378&gt; thread discussing the basics of this proposal.  It has been refined and expanded a bit to include an effort to make Swift modules explicit and updated with the feedback of that first thread.  Contents of the proposal are inline and can also be had as a gist &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6&gt; or on Github. &lt;https://github.com/apple/swift-evolution/pull/440&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Qualified Imports and Modules<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposal: SE-NNNN &lt;https://gist.github.com/CodaFi/NNNN-first-class-qualified-imports.md&gt;<br>&gt;&gt;&gt; Authors: Robert Widmann &lt;https://github.com/codafi&gt;, Harlan Haskins &lt;https://github.com/harlanhaskins&gt;, TJ Usiyan &lt;https://github.com/griotspeak&gt;<br>&gt;&gt;&gt; Status: Awaiting review<br>&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#introduction&gt;Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We propose a complete overhaul of the qualified imports syntax and semantics and the introduction of a module system.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#motivation&gt;Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift code is modular by default. However, it is not clear how to decompose existing modules further into submodules. In addition, it is difficult to tell how importing a module affects its export to consumers of a library. This leads many to either fake namespaces with enums, attempt to structure Swift code with modulemaps, or use a large amount of version-control submodules. All of these can be rolled into one complete package in the form of a comprehensive rethink of the qualified import system and the introduction of a module system.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#proposed-solution&gt;Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Modules will now become an explicit part of working with canonical Swift code. The grammar and semantics of qualified imports will change completely with the addition of import qualifiers and import directives. We also introduce three new contextual keywords: using, hiding, and renaming, to facilitate fine-grained usage of module contents.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#detailed-design&gt;Detailed design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Qualified import syntax will be revised to the following<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; module-decl -&gt; module &lt;module-path&gt;<br>&gt;&gt;&gt; import-decl -&gt; &lt;access-level-modifier&gt; import &lt;module-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt;&gt;&gt; module-path -&gt; &lt;identifier&gt;<br>&gt;&gt;&gt;             -&gt; &lt;identifier&gt;.&lt;import-path&gt;<br>&gt;&gt;&gt; import-directive-list -&gt; &lt;import-directive&gt;<br>&gt;&gt;&gt;                       -&gt; &lt;import-directive&gt; &lt;import-directive-list&gt;<br>&gt;&gt;&gt; import-directive -&gt; using (&lt;identifier&gt;, ...)<br>&gt;&gt;&gt;                  -&gt; hiding (&lt;identifier&gt;, ...)<br>&gt;&gt;&gt;                  -&gt; renaming (&lt;identifier&gt;, to: &lt;identifier&gt;, ...)<br>&gt;&gt;&gt; This introduces the concept of an import directive. An import directive is a file-local modification of an imported identifier. A directive can be one of 3 operations:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1) using: The using directive is followed by a list of identifiers within the imported module that should be exposed to this file. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // The only visible parts of Foundation in this file are <br>&gt;&gt;&gt; // Date.init(), Date.hashValue, and Date.description.<br>&gt;&gt;&gt; import Foundation.Date using (Date.init(), Date.hashValue, Date.description)<br>&gt;&gt;&gt; 2) hiding: The hiding directive is followed by a list of identifiers within the imported module that should be hidden from this file.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Imports all of Foundation.Date except `Date.compare()`<br>&gt;&gt;&gt; import Foundation.Date hiding (Date.compare())<br>&gt;&gt; It&#39;s unfortunate that this proposal requires the identifiers to be re-qualified when the imported module is actually the name of a type.<br>&gt; <br>&gt; I considered making that a feature of this proposal but I had a tough time reconciling removing the decl specifier from qualified imports and having an unambiguous notation for Swift declarations. <br></p><p>Yes, I can see that there are difficulties here.  I&#39;m just worried that an abruptly-designed solution is going to carve those difficulties into stone.<br></p><p>&gt;&gt;  It seems to me that whether e.g. a type is defined in its own sub-module is a detail that users won&#39;t really appreciate and which probably shouldn&#39;t be surfaced to them.  In fact, in general I&#39;m concerned about this turning the file and directory organization of a project into API.<br>&gt; <br>&gt; It’s a detail that they’ve already had to have surfaced if they use the existing syntax.<br></p><p>Hmm?  We don&#39;t have sub-modules today.  &quot;import Foundation.NSObject&quot; just brings that specific declaration in; there&#39;s no semantic differentiation between that and importing a module.<br></p><p>Relatedly, your proposal side-steps any discussion about what happens if you try to name a sub-module the same as a type.  You must have done that very carefully, because one of your examples clearly envisages String being in its own sub-module. :)<br></p><p>&gt;&gt;  In fact, in general I&#39;m concerned about this turning the file and directory organization of a project into API.<br>&gt; <br>&gt; It’s a legitimate concern and one that I share considering there is a way to abuse this restriction (*cough* Java), or try to rally around a limited set of namespaces for common controls.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; This proposal also solves the problem of module export. A module that is imported without an access level modifier will default to an internal import per usual. However, when it is useful to fully expose the public content of submodules to a client, a public modifier can be used. Similarly, when it is useful to access internal or [file]private APIs, but not expose them to clients, those access modifiers may be used.<br>&gt;&gt;&gt; <br>&gt;&gt; These uses of access modifiers feel inconsistent to me.  &quot;public import Foo&quot; exports the contents of Foo as if they were members of my module, but &quot;private import Foo&quot; imports the private APIs (?) of Foo?  That is not the same interpretive rule.<br>&gt;&gt; <br>&gt; <br>&gt; It’s not, and it’s that way intentionally.  Non-public imports do not re-export.  The wording around this is shabby, I’ll work to improve it.<br></p><p>Yeah, I don&#39;t think this is good.  I think my suggestion makes more sense, where a non-private import exports to whatever the named scope is.  This draws the current behavior consistently into your model (the default import rule is private), and the &quot;internal import&quot; concept actually seems like a pretty useful feature in a world where you anticipate people doing significant renames on import.<br></p><p>&gt;&gt; I think the more consistent analogy for &quot;private import&quot; would be to say that the public members of Foo are visible in this file only (i.e. the default behavior of &quot;import&quot; today, which I think we would want to keep), whereas you could do an &quot;internal import&quot; to make the members of Foo visible throughout the current module (potentially useful if you have an interesting set of common modifications you want to make).<br>&gt;&gt; <br>&gt; <br>&gt;&gt; I don&#39;t know why you think it should be possible to import the private declarations of a module.  That seems completely contrary to the access-control design.  I agree that it&#39;s useful to have sub-modules expose APIs that are only usable by other parts of the larger module, but I think the Swiftier design would be for that to be opt-in on the declaration somehow, or at least to specify how it interacts with &quot;internal&quot;.<br>&gt;&gt; <br>&gt; <br>&gt; I was approached by users at WWDC that did wish to have some way of grouping a bunch of private Swift files that should “know about each other’s internal stuff”.  At the time this was the semantics that seemed to match that and stayed in-line with what a `private import` could possibly do.  Perhaps this kind of import can be banned-by-diagnostic in that case.<br></p><p>This sounds more like it&#39;s calling for better definition of the access interactions between sub-modules.<br></p><p>&gt;&gt; Also, it is completely unclear to me why modifiers like &quot;renaming&quot; don&#39;t change how the imported module&#39;s declarations are re-exported.<br>&gt;&gt; <br>&gt; <br>&gt; Because importing a library shouldn’t be able to change whatever it likes and break client code on re-export.  I don’t have a particularly compelling use-case for allowing user-specified mappings to escape file scope and neither do many other languages I can find that permit this feature.  If you have one I’d like to know about it.<br></p><p>Sharing user-specified mappings between files seems better than forcing them to be copy-and-pasted.  You could lock down on public exports that rename mappings if you&#39;re worried about that.<br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160718/26b703b3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d972db2b6ee8b77746ce7122663eb4f8?s=50"></div><header><strong>[Proposal] Qualified Imports and Modules</strong> from <string>Robert Widmann</string> &lt;rwidmann at apple.com&gt;<p>July 18, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jul 18, 2016, at 4:30 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jul 18, 2016, at 3:53 PM, Robert Widmann &lt;rwidmann at apple.com &lt;mailto:rwidmann at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 18, 2016, at 3:21 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jul 18, 2016, at 2:09 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; TJ Usiyan, Harlan Haskins, and I have been working on a proposal to rework qualified imports and introduce an explicit module system to Swift that we’d like to publish for your viewing pleasure.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The initial impetus was set out in a radar (rdar://17630570 &lt;rdar://17630570&gt;) I sent fairly early on that didn’t receive a response, so I started a swift-evolution &lt;http://permalink.gmane.org/gmane.comp.lang.swift.evolution/1378&gt; thread discussing the basics of this proposal.  It has been refined and expanded a bit to include an effort to make Swift modules explicit and updated with the feedback of that first thread.  Contents of the proposal are inline and can also be had as a gist &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6&gt; or on Github. &lt;https://github.com/apple/swift-evolution/pull/440&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Qualified Imports and Modules<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Proposal: SE-NNNN &lt;https://gist.github.com/CodaFi/NNNN-first-class-qualified-imports.md&gt;<br>&gt;&gt;&gt;&gt; Authors: Robert Widmann &lt;https://github.com/codafi&gt;, Harlan Haskins &lt;https://github.com/harlanhaskins&gt;, TJ Usiyan &lt;https://github.com/griotspeak&gt;<br>&gt;&gt;&gt;&gt; Status: Awaiting review<br>&gt;&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#introduction&gt;Introduction<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We propose a complete overhaul of the qualified imports syntax and semantics and the introduction of a module system.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#motivation&gt;Motivation<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Swift code is modular by default. However, it is not clear how to decompose existing modules further into submodules. In addition, it is difficult to tell how importing a module affects its export to consumers of a library. This leads many to either fake namespaces with enums, attempt to structure Swift code with modulemaps, or use a large amount of version-control submodules. All of these can be rolled into one complete package in the form of a comprehensive rethink of the qualified import system and the introduction of a module system.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#proposed-solution&gt;Proposed solution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Modules will now become an explicit part of working with canonical Swift code. The grammar and semantics of qualified imports will change completely with the addition of import qualifiers and import directives. We also introduce three new contextual keywords: using, hiding, and renaming, to facilitate fine-grained usage of module contents.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#detailed-design&gt;Detailed design<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Qualified import syntax will be revised to the following<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; module-decl -&gt; module &lt;module-path&gt;<br>&gt;&gt;&gt;&gt; import-decl -&gt; &lt;access-level-modifier&gt; import &lt;module-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt;&gt;&gt;&gt; module-path -&gt; &lt;identifier&gt;<br>&gt;&gt;&gt;&gt;             -&gt; &lt;identifier&gt;.&lt;import-path&gt;<br>&gt;&gt;&gt;&gt; import-directive-list -&gt; &lt;import-directive&gt;<br>&gt;&gt;&gt;&gt;                       -&gt; &lt;import-directive&gt; &lt;import-directive-list&gt;<br>&gt;&gt;&gt;&gt; import-directive -&gt; using (&lt;identifier&gt;, ...)<br>&gt;&gt;&gt;&gt;                  -&gt; hiding (&lt;identifier&gt;, ...)<br>&gt;&gt;&gt;&gt;                  -&gt; renaming (&lt;identifier&gt;, to: &lt;identifier&gt;, ...)<br>&gt;&gt;&gt;&gt; This introduces the concept of an import directive. An import directive is a file-local modification of an imported identifier. A directive can be one of 3 operations:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1) using: The using directive is followed by a list of identifiers within the imported module that should be exposed to this file. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // The only visible parts of Foundation in this file are <br>&gt;&gt;&gt;&gt; // Date.init(), Date.hashValue, and Date.description.<br>&gt;&gt;&gt;&gt; import Foundation.Date using (Date.init(), Date.hashValue, Date.description)<br>&gt;&gt;&gt;&gt; 2) hiding: The hiding directive is followed by a list of identifiers within the imported module that should be hidden from this file.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // Imports all of Foundation.Date except `Date.compare()`<br>&gt;&gt;&gt;&gt; import Foundation.Date hiding (Date.compare())<br>&gt;&gt;&gt; It&#39;s unfortunate that this proposal requires the identifiers to be re-qualified when the imported module is actually the name of a type. <br>&gt;&gt; <br>&gt;&gt; I considered making that a feature of this proposal but I had a tough time reconciling removing the decl specifier from qualified imports and having an unambiguous notation for Swift declarations. <br>&gt; <br>&gt; Yes, I can see that there are difficulties here.  I&#39;m just worried that an abruptly-designed solution is going to carve those difficulties into stone.<br>&gt; <br>&gt;&gt;&gt;  It seems to me that whether e.g. a type is defined in its own sub-module is a detail that users won&#39;t really appreciate and which probably shouldn&#39;t be surfaced to them.  In fact, in general I&#39;m concerned about this turning the file and directory organization of a project into API.<br>&gt;&gt; <br>&gt;&gt; It’s a detail that they’ve already had to have surfaced if they use the existing syntax.<br>&gt; <br>&gt; Hmm?  We don&#39;t have sub-modules today.  &quot;import Foundation.NSObject&quot; just brings that specific declaration in; there&#39;s no semantic differentiation between that and importing a module.<br>&gt; <br></p><p>We do!<br></p><p>import class Foundation.NSObject<br></p><p>^That’s the syntax we’re trying to replace.<br></p><p>&gt; Relatedly, your proposal side-steps any discussion about what happens if you try to name a sub-module the same as a type.  You must have done that very carefully, because one of your examples clearly envisages String being in its own sub-module. :)<br>&gt; <br>&gt;&gt;&gt;  In fact, in general I&#39;m concerned about this turning the file and directory organization of a project into API.<br>&gt;&gt; <br>&gt;&gt; It’s a legitimate concern and one that I share considering there is a way to abuse this restriction (*cough* Java), or try to rally around a limited set of namespaces for common controls.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This proposal also solves the problem of module export. A module that is imported without an access level modifier will default to an internal import per usual. However, when it is useful to fully expose the public content of submodules to a client, a public modifier can be used. Similarly, when it is useful to access internal or [file]private APIs, but not expose them to clients, those access modifiers may be used.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; These uses of access modifiers feel inconsistent to me.  &quot;public import Foo&quot; exports the contents of Foo as if they were members of my module, but &quot;private import Foo&quot; imports the private APIs (?) of Foo?  That is not the same interpretive rule.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; It’s not, and it’s that way intentionally.  Non-public imports do not re-export.  The wording around this is shabby, I’ll work to improve it.<br>&gt; <br>&gt; Yeah, I don&#39;t think this is good.  I think my suggestion makes more sense, where a non-private import exports to whatever the named scope is.  This draws the current behavior consistently into your model (the default import rule is private), and the &quot;internal import&quot; concept actually seems like a pretty useful feature in a world where you anticipate people doing significant renames on import.<br></p><p>I honestly don’t anticipate this being as much of a thing.  There should be minor cosmetic updates to local functions and possibly more descriptive renamings of common functions, but if you want to export a renaming today you can always find a way to alias existing definitions to other definitions (nominal types with typealiases, functions with top-level let-bound closures, members are tricky but that’s what extensions are for) rather than go through lookup.  Regardless, that is a more consistent rule.<br></p><p>&gt; <br>&gt;&gt;&gt; I think the more consistent analogy for &quot;private import&quot; would be to say that the public members of Foo are visible in this file only (i.e. the default behavior of &quot;import&quot; today, which I think we would want to keep), whereas you could do an &quot;internal import&quot; to make the members of Foo visible throughout the current module (potentially useful if you have an interesting set of common modifications you want to make).<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t know why you think it should be possible to import the private declarations of a module.  That seems completely contrary to the access-control design.  I agree that it&#39;s useful to have sub-modules expose APIs that are only usable by other parts of the larger module, but I think the Swiftier design would be for that to be opt-in on the declaration somehow, or at least to specify how it interacts with &quot;internal&quot;.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I was approached by users at WWDC that did wish to have some way of grouping a bunch of private Swift files that should “know about each other’s internal stuff”.  At the time this was the semantics that seemed to match that and stayed in-line with what a `private import` could possibly do.  Perhaps this kind of import can be banned-by-diagnostic in that case.<br>&gt; <br>&gt; This sounds more like it&#39;s calling for better definition of the access interactions between sub-modules.<br></p><p>Breaking true private scope on decls is something we’re already doing with the fileprivate updates.  If we wanted to draw inspiration from that we could introduce a rule where a private import is only allowed to reference a submodule “one-level-deeper” than itself (to match the “private decl’s members can be seen effectively &#39;one scope level up’ rule).  <br></p><p>&gt; <br>&gt;&gt;&gt; Also, it is completely unclear to me why modifiers like &quot;renaming&quot; don&#39;t change how the imported module&#39;s declarations are re-exported.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Because importing a library shouldn’t be able to change whatever it likes and break client code on re-export.  I don’t have a particularly compelling use-case for allowing user-specified mappings to escape file scope and neither do many other languages I can find that permit this feature.  If you have one I’d like to know about it.<br>&gt; <br>&gt; Sharing user-specified mappings between files seems better than forcing them to be copy-and-pasted.  You could lock down on public exports that rename mappings if you&#39;re worried about that.<br>&gt; <br></p><p>Now it seems like we’re defining a macro system.  Renamings of identifiers are probably going to be the least common of the three and it’s not clear what happens if a user internally is using multiple renamings for the same identifier if they’re exported around the project.  Plus, because declarations would be decentralized, it’s entirely possible that a multi-person project will wind up with people trampling over each other’s renamings than a consistent organized mapping.  It seems like we want to encourage the definition of new symbols and aliases for significant API changes and renamings for local fixes and nitpicks where it wouldn’t otherwise be possible to use an API because of a conflict.<br></p><p>&gt; John.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160718/426e3810/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal] Qualified Imports and Modules</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>July 18, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jul 18, 2016, at 2:09 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello all,<br>&gt; <br>&gt; TJ Usiyan, Harlan Haskins, and I have been working on a proposal to rework qualified imports and introduce an explicit module system to Swift that we’d like to publish for your viewing pleasure.<br></p><p>This is really interesting. A few incomplete comments:<br></p><p>&gt; 2) hiding: The hiding directive is followed by a list of identifiers within the imported module that should be hidden from this file.<br>&gt; <br>&gt; // Imports all of Foundation.Date except `Date.compare()`<br>&gt; import Foundation.Date hiding (Date.compare())<br>[snip]<br>&gt; // Exports the entire public contents of Math.Integers, but nothing in <br>&gt; // Math.Integers.Arithmetic.<br>&gt; public import Math.Integers<br></p><p>Would this work?<br></p><p>	module UIKit<br>	<br>	public import UIKit.UIGestureRecognizerSubclass.UIGestureRecognizer<br>		hiding (UIGestureRecognizer.touchesBegan(_:with:), UIGestureRecognizer.touchesMoved(_:with:), …)<br></p><p>(If so, we&#39;d need a way to hide only the setter of a property, not the getter.)<br></p><p>&gt; Modules names are tied to a directory structure that describes their location relative to the current module and it will now be an error to violate this rule. For example:<br>&gt; <br>&gt; module String // lives in ./String.swift<br>&gt; <br>&gt; module String.Core // lives in ./String/Core.swift<br>&gt; <br>&gt; module String.Core.Internals.Do.You.Even.Write // lives in ./String/Core/Internals/Do/You/Even/Write.swift<br></p><p>I think this is a mistake for several reasons:<br></p><p>* You may need to split a single submodule across multiple files, but this rule doesn&#39;t allow that.<br></p><p>* The module declaration and filename contain redundant information, and one of them could get out of sync with the other.<br></p><p>* Xcode doesn&#39;t like to organize things into folders on disk and will fight you tooth and nail.<br></p><p>* Deeply nested folders are a usability issue. Never forget the jury in Oracle v. Google: https://www.geek.com/wp-content/uploads/2016/05/courtroomhijinks.png<br></p><p>At the very least, I would like to see allowances for multi-file submodules—String/Core/Internals/Do/You/Even/Write**.swift. Better would be to use long filenames—String.Core.Internals.Do.You.Even.Write*.swift. Even better would be to just allow freeform naming and trust programmers to organize their projects sanely.<br></p><p>&gt; Existing projects that do not adopt these rules will still retain their implicit module name (usually defined as the name of the framework or application that is being built) and may continue to use whatever directory structure they wish, however they may not declare any explicit modules.<br>&gt; <br>&gt; This proposal also solves the problem of module export. A module that is imported without an access level modifier will default to an internal import per usual. However, when it is useful to fully expose the public content of submodules to a client, a public modifier can be used. Similarly, when it is useful to access internal or [file]private APIs, but not expose them to clients, those access modifiers may be used. The rule of thumb is: Only identifiers that are at least as visible as the qualifier on the import make for valid import declarations.<br></p><p>It appears the semantics here are &quot;grab all declarations at level X and above, and expose them in this module as level X&quot;. This is bizarre for a number of reasons:<br></p><p>* Currently, `import` can only access `internal` declarations using `@testable`. This would change that.<br></p><p>* Currently, `import` can&#39;t access `private` and `fileprivate` declarations at all, and it&#39;s not clear what it would mean to add that. What happens if two different parts of the module have different `private` members with the same name? Which do you get?<br></p><p>* Currently, `import` only affects the current file—it&#39;s effectively &quot;import `public` members as `fileprivate`&quot;. If your default is `internal import`, that would imply that an import statement in one file would, by default, expose the APIs it imported to all files. That&#39;s an important change in behavior.<br></p><p>I think you&#39;re mixing two things together that ought not to be. `import` should always import only public APIs (unless you use `@testable`—which might need a bit of renaming to support the additional use case of SPIs between submodules and supermodules—in which case you also get `internal` APIs). An access modifier on the `import` statement controls how they&#39;re exposed to the rest of the file/project/world, and `private` is the default. It&#39;s a little weird to have `private` be the default on `import` when `internal` is the default on everything else, but the alternative is to change `import`&#39;s behavior in a way that is neither backwards-compatible, nor likely to be correct.<br></p><p>&gt; Because import directives are file-local, they will never be exported along with a public import and will default to exporting the entire contents of the module as though you had never declared them.<br></p><p>Whoa, wait, what? Why? I think hiding parts of the implementation is a good use case for re-exporting a module. And I think the clear implication of attaching these clauses directly to the import statement is that it controls how the module is imported everywhere that statement makes it visible, not just within the one file. If we&#39;re not going to do that, I think these clauses ought to be separated from the `import` statement and turned into something separate.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Proposal] Qualified Imports and Modules</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>July 18, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt;<br>&gt; &gt; Modules names are tied to a directory structure that describes their<br>&gt; location relative to the current module and it will now be an error to<br>&gt; violate this rule. For example:<br>&gt; &gt;<br>&gt; &gt; module String // lives in ./String.swift<br>&gt; &gt;<br>&gt; &gt; module String.Core // lives in ./String/Core.swift<br>&gt; &gt;<br>&gt; &gt; module String.Core.Internals.Do.You.Even.Write // lives in<br>&gt; ./String/Core/Internals/Do/You/Even/Write.swift<br>&gt; I think this is a mistake for several reasons:<br>&gt; * You may need to split a single submodule across multiple files, but this<br>&gt; rule doesn&#39;t allow that.<br></p><p>You can, internally, have several modules and then create one that imports<br>those smaller ones publicly with the name that you desire.<br></p><p>&gt;<br>&gt; * The module declaration and filename contain redundant information, and<br>&gt; one of them could get out of sync with the other.<br></p><p><br>I agree with this point though I am not sure that it is so much of an<br>issue. Diagnostics can handle much of the issue.<br></p><p>&gt;<br>&gt; * Xcode doesn&#39;t like to organize things into folders on disk and will<br>&gt; fight you tooth and nail.<br></p><p><br>&gt; * Deeply nested folders are a usability issue. Never forget the jury in<br>&gt; Oracle v. Google:<br>&gt; https://www.geek.com/wp-content/uploads/2016/05/courtroomhijinks.png<br></p><p><br></p><p><br></p><p><br></p><p><br>On Mon, Jul 18, 2016 at 7:34 PM, Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; On Jul 18, 2016, at 2:09 PM, Robert Widmann via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Hello all,<br>&gt; &gt;<br>&gt; &gt; TJ Usiyan, Harlan Haskins, and I have been working on a proposal to<br>&gt; rework qualified imports and introduce an explicit module system to Swift<br>&gt; that we’d like to publish for your viewing pleasure.<br>&gt;<br>&gt; This is really interesting. A few incomplete comments:<br>&gt;<br>&gt; &gt; 2) hiding: The hiding directive is followed by a list of identifiers<br>&gt; within the imported module that should be hidden from this file.<br>&gt; &gt;<br>&gt; &gt; // Imports all of Foundation.Date except `Date.compare()`<br>&gt; &gt; import Foundation.Date hiding (Date.compare())<br>&gt; [snip]<br>&gt; &gt; // Exports the entire public contents of Math.Integers, but nothing in<br>&gt; &gt; // Math.Integers.Arithmetic.<br>&gt; &gt; public import Math.Integers<br>&gt;<br>&gt; Would this work?<br>&gt;<br>&gt;         module UIKit<br>&gt;<br>&gt;         public import UIKit.UIGestureRecognizerSubclass.UIGestureRecognizer<br>&gt;                 hiding (UIGestureRecognizer.touchesBegan(_:with:),<br>&gt; UIGestureRecognizer.touchesMoved(_:with:), …)<br>&gt;<br>&gt; (If so, we&#39;d need a way to hide only the setter of a property, not the<br>&gt; getter.)<br>&gt;<br>&gt; &gt; Modules names are tied to a directory structure that describes their<br>&gt; location relative to the current module and it will now be an error to<br>&gt; violate this rule. For example:<br>&gt; &gt;<br>&gt; &gt; module String // lives in ./String.swift<br>&gt; &gt;<br>&gt; &gt; module String.Core // lives in ./String/Core.swift<br>&gt; &gt;<br>&gt; &gt; module String.Core.Internals.Do.You.Even.Write // lives in<br>&gt; ./String/Core/Internals/Do/You/Even/Write.swift<br>&gt;<br>&gt; I think this is a mistake for several reasons:<br>&gt;<br>&gt; * You may need to split a single submodule across multiple files, but this<br>&gt; rule doesn&#39;t allow that.<br>&gt;<br>&gt; * The module declaration and filename contain redundant information, and<br>&gt; one of them could get out of sync with the other.<br>&gt;<br>&gt; * Xcode doesn&#39;t like to organize things into folders on disk and will<br>&gt; fight you tooth and nail.<br>&gt;<br>&gt; * Deeply nested folders are a usability issue. Never forget the jury in<br>&gt; Oracle v. Google:<br>&gt; https://www.geek.com/wp-content/uploads/2016/05/courtroomhijinks.png<br>&gt;<br>&gt; At the very least, I would like to see allowances for multi-file<br>&gt; submodules—String/Core/Internals/Do/You/Even/Write**.swift. Better would be<br>&gt; to use long filenames—String.Core.Internals.Do.You.Even.Write*.swift. Even<br>&gt; better would be to just allow freeform naming and trust programmers to<br>&gt; organize their projects sanely.<br>&gt;<br>&gt; &gt; Existing projects that do not adopt these rules will still retain their<br>&gt; implicit module name (usually defined as the name of the framework or<br>&gt; application that is being built) and may continue to use whatever directory<br>&gt; structure they wish, however they may not declare any explicit modules.<br>&gt; &gt;<br>&gt; &gt; This proposal also solves the problem of module export. A module that is<br>&gt; imported without an access level modifier will default to an internal<br>&gt; import per usual. However, when it is useful to fully expose the public<br>&gt; content of submodules to a client, a public modifier can be used.<br>&gt; Similarly, when it is useful to access internal or [file]private APIs, but<br>&gt; not expose them to clients, those access modifiers may be used. The rule of<br>&gt; thumb is: Only identifiers that are at least as visible as the qualifier on<br>&gt; the import make for valid import declarations.<br>&gt;<br>&gt; It appears the semantics here are &quot;grab all declarations at level X and<br>&gt; above, and expose them in this module as level X&quot;. This is bizarre for a<br>&gt; number of reasons:<br>&gt;<br>&gt; * Currently, `import` can only access `internal` declarations using<br>&gt; `@testable`. This would change that.<br>&gt;<br>&gt; * Currently, `import` can&#39;t access `private` and `fileprivate`<br>&gt; declarations at all, and it&#39;s not clear what it would mean to add that.<br>&gt; What happens if two different parts of the module have different `private`<br>&gt; members with the same name? Which do you get?<br>&gt;<br>&gt; * Currently, `import` only affects the current file—it&#39;s effectively<br>&gt; &quot;import `public` members as `fileprivate`&quot;. If your default is `internal<br>&gt; import`, that would imply that an import statement in one file would, by<br>&gt; default, expose the APIs it imported to all files. That&#39;s an important<br>&gt; change in behavior.<br>&gt;<br>&gt; I think you&#39;re mixing two things together that ought not to be. `import`<br>&gt; should always import only public APIs (unless you use `@testable`—which<br>&gt; might need a bit of renaming to support the additional use case of SPIs<br>&gt; between submodules and supermodules—in which case you also get `internal`<br>&gt; APIs). An access modifier on the `import` statement controls how they&#39;re<br>&gt; exposed to the rest of the file/project/world, and `private` is the<br>&gt; default. It&#39;s a little weird to have `private` be the default on `import`<br>&gt; when `internal` is the default on everything else, but the alternative is<br>&gt; to change `import`&#39;s behavior in a way that is neither<br>&gt; backwards-compatible, nor likely to be correct.<br>&gt;<br>&gt; &gt; Because import directives are file-local, they will never be exported<br>&gt; along with a public import and will default to exporting the entire<br>&gt; contents of the module as though you had never declared them.<br>&gt;<br>&gt; Whoa, wait, what? Why? I think hiding parts of the implementation is a<br>&gt; good use case for re-exporting a module. And I think the clear implication<br>&gt; of attaching these clauses directly to the import statement is that it<br>&gt; controls how the module is imported everywhere that statement makes it<br>&gt; visible, not just within the one file. If we&#39;re not going to do that, I<br>&gt; think these clauses ought to be separated from the `import` statement and<br>&gt; turned into something separate.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160718/c2628db8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal] Qualified Imports and Modules</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>July 18, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jul 18, 2016, at 4:50 PM, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt; <br>&gt; * You may need to split a single submodule across multiple files, but this rule doesn&#39;t allow that.<br>&gt; <br>&gt; You can, internally, have several modules and then create one that imports those smaller ones publicly with the name that you desire. <br></p><p>They wouldn&#39;t have access to each others&#39; internal scopes by default, would they?<br></p><p>In general, I get the sense that this proposal is hostile to the current idea that a module (or submodule) consists of multiple files, each of which has both intra-file privacy and inter-file sharing with other parts of the module. I think this is a natural and extremely useful way to design software. Moreover, I think throwing this concept out goes explicitly against the grain of current Swift access control mechanisms. In a world where every file is its own module, what&#39;s the difference between `internal` and `fileprivate`? Are we going to end up in an Objective-C-style situation of giant import lists at the top of every file, listing stuff that&#39;s in the same module? Doesn&#39;t that go against the goal of reducing boilerplate?<br></p><p>I would prefer to see:<br></p><p>1. Each file is allowed one `submodule` declaration as the first non-comment line of code in the file. It does not include the main module name, only the submodule name (so `UIKit.UIGestureRecognizerSubclass` would simply have `submodule UIGestureRecognizerSubclass` at the top). If there is none, the file is part of the main module. (It *might* make sense to have both public submodules, which anyone can import, and internal submodules, which can only be imported within the top-level module, but I&#39;ll need to think about that.)<br></p><p>2. Filenames are freeform; any file can declare itself to belong to any submodule. Obviously, best practice would be to give your files sensible names that have some kind of link to the submodule name, but this would be a linter concern.<br></p><p>3. Each submodule has its own `internal` scope. Submodules can import the `internal` scopes of specific peer modules with an annotation like `@testable` (but probably renamed). Tests are treated as a submodule of the main module, so they can participate in this mechanism just like everyone else.<br></p><p>4. `import` only ever imports the `public` (or `internal`, with the `@testable` equivalent) symbols in the specified submodule. It re-exposes them with the access modifier on the `import` statement, or `private` by default. It does not re-expose `internal` symbols as `public`. `using`, `hiding`, and `renaming` apply to all comers, not just the current file.<br></p><p>I think this approach would harmonize much better with current Swift features and code organization practices, while offering several new features (umbrella modules, exposing certain symbols only when a submodule is explicitly imported, multiple `internal` scopes within a top-level module) which would be very useful.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d972db2b6ee8b77746ce7122663eb4f8?s=50"></div><header><strong>[Proposal] Qualified Imports and Modules</strong> from <string>Robert Widmann</string> &lt;rwidmann at apple.com&gt;<p>July 18, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jul 18, 2016, at 5:26 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jul 18, 2016, at 4:50 PM, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; * You may need to split a single submodule across multiple files, but this rule doesn&#39;t allow that.<br>&gt;&gt; <br>&gt;&gt; You can, internally, have several modules and then create one that imports those smaller ones publicly with the name that you desire. <br>&gt; <br>&gt; They wouldn&#39;t have access to each others&#39; internal scopes by default, would they?<br>&gt; <br>&gt; In general, I get the sense that this proposal is hostile to the current idea that a module (or submodule) consists of multiple files, each of which has both intra-file privacy and inter-file sharing with other parts of the module. I think this is a natural and extremely useful way to design software. Moreover, I think throwing this concept out goes explicitly against the grain of current Swift access control mechanisms. In a world where every file is its own module, what&#39;s the difference between `internal` and `fileprivate`? Are we going to end up in an Objective-C-style situation of giant import lists at the top of every file, listing stuff that&#39;s in the same module? Doesn&#39;t that go against the goal of reducing boilerplate?<br>&gt; <br>&gt; I would prefer to see:<br>&gt; <br>&gt; 1. Each file is allowed one `submodule` declaration as the first non-comment line of code in the file. It does not include the main module name, only the submodule name (so `UIKit.UIGestureRecognizerSubclass` would simply have `submodule UIGestureRecognizerSubclass` at the top). If there is none, the file is part of the main module. (It *might* make sense to have both public submodules, which anyone can import, and internal submodules, which can only be imported within the top-level module, but I&#39;ll need to think about that.)<br></p><p>That is one of the alternatives considered.  It may be possible through annotation of the module itself to express this kind of thing.<br></p><p>&gt; 2. Filenames are freeform; any file can declare itself to belong to any submodule. Obviously, best practice would be to give your files sensible names that have some kind of link to the submodule name, but this would be a linter concern.<br></p><p>How does this interact with duplicate declarations?<br></p><p>&gt; <br>&gt; 3. Each submodule has its own `internal` scope. Submodules can import the `internal` scopes of specific peer modules with an annotation like `@testable` (but probably renamed). <br></p><p>&quot;Peer modules” is something we can lock down without having to introduce even more scopes and fits well within this proposal.  A restriction like “a module may only import private members from submodules 1-level deeper than themselves” for example.<br></p><p>&gt; Tests are treated as a submodule of the main module, so they can participate in this mechanism just like everyone else.<br></p><p>Or we could keep the existing @testable import syntax.  It will still work exactly the way it always has under this proposal.<br></p><p>&gt; 4. `import` only ever imports the `public` (or `internal`, with the `@testable` equivalent) symbols in the specified submodule. It re-exposes them with the access modifier on the `import` statement, or `private` by default. It does not re-expose `internal` symbols as `public`. `using`, `hiding`, and `renaming` apply to all comers, not just the current file.<br></p><p>We do not allow you to re-export any API that is not public.  The wording around the section you keep bringing up is vague and needs to be fixed.<br></p><p>&gt; <br>&gt; I think this approach would harmonize much better with current Swift features and code organization practices, while offering several new features (umbrella modules, exposing certain symbols only when a submodule is explicitly imported, multiple `internal` scopes within a top-level module) which would be very useful.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Proposal] Qualified Imports and Modules</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>July 18, 2016 at 08:00:00pm</p></header><div class="content"><p>What about using duplicate declarations to indicate that two files are part<br>of the same module?<br></p><p>On Mon, Jul 18, 2016 at 8:33 PM, Robert Widmann &lt;rwidmann at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Jul 18, 2016, at 5:26 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; On Jul 18, 2016, at 4:50 PM, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; * You may need to split a single submodule across multiple files, but<br>&gt; this rule doesn&#39;t allow that.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; You can, internally, have several modules and then create one that<br>&gt; imports those smaller ones publicly with the name that you desire.<br>&gt; &gt;<br>&gt; &gt; They wouldn&#39;t have access to each others&#39; internal scopes by default,<br>&gt; would they?<br>&gt; &gt;<br>&gt; &gt; In general, I get the sense that this proposal is hostile to the current<br>&gt; idea that a module (or submodule) consists of multiple files, each of which<br>&gt; has both intra-file privacy and inter-file sharing with other parts of the<br>&gt; module. I think this is a natural and extremely useful way to design<br>&gt; software. Moreover, I think throwing this concept out goes explicitly<br>&gt; against the grain of current Swift access control mechanisms. In a world<br>&gt; where every file is its own module, what&#39;s the difference between<br>&gt; `internal` and `fileprivate`? Are we going to end up in an<br>&gt; Objective-C-style situation of giant import lists at the top of every file,<br>&gt; listing stuff that&#39;s in the same module? Doesn&#39;t that go against the goal<br>&gt; of reducing boilerplate?<br>&gt; &gt;<br>&gt; &gt; I would prefer to see:<br>&gt; &gt;<br>&gt; &gt; 1. Each file is allowed one `submodule` declaration as the first<br>&gt; non-comment line of code in the file. It does not include the main module<br>&gt; name, only the submodule name (so `UIKit.UIGestureRecognizerSubclass` would<br>&gt; simply have `submodule UIGestureRecognizerSubclass` at the top). If there<br>&gt; is none, the file is part of the main module. (It *might* make sense to<br>&gt; have both public submodules, which anyone can import, and internal<br>&gt; submodules, which can only be imported within the top-level module, but<br>&gt; I&#39;ll need to think about that.)<br>&gt;<br>&gt; That is one of the alternatives considered.  It may be possible through<br>&gt; annotation of the module itself to express this kind of thing.<br>&gt;<br>&gt; &gt; 2. Filenames are freeform; any file can declare itself to belong to any<br>&gt; submodule. Obviously, best practice would be to give your files sensible<br>&gt; names that have some kind of link to the submodule name, but this would be<br>&gt; a linter concern.<br>&gt;<br>&gt; How does this interact with duplicate declarations?<br>&gt;<br>&gt; &gt;<br>&gt; &gt; 3. Each submodule has its own `internal` scope. Submodules can import<br>&gt; the `internal` scopes of specific peer modules with an annotation like<br>&gt; `@testable` (but probably renamed).<br>&gt;<br>&gt; &quot;Peer modules” is something we can lock down without having to introduce<br>&gt; even more scopes and fits well within this proposal.  A restriction like “a<br>&gt; module may only import private members from submodules 1-level deeper than<br>&gt; themselves” for example.<br>&gt;<br>&gt; &gt; Tests are treated as a submodule of the main module, so they can<br>&gt; participate in this mechanism just like everyone else.<br>&gt;<br>&gt; Or we could keep the existing @testable import syntax.  It will still work<br>&gt; exactly the way it always has under this proposal.<br>&gt;<br>&gt; &gt; 4. `import` only ever imports the `public` (or `internal`, with the<br>&gt; `@testable` equivalent) symbols in the specified submodule. It re-exposes<br>&gt; them with the access modifier on the `import` statement, or `private` by<br>&gt; default. It does not re-expose `internal` symbols as `public`. `using`,<br>&gt; `hiding`, and `renaming` apply to all comers, not just the current file.<br>&gt;<br>&gt; We do not allow you to re-export any API that is not public.  The wording<br>&gt; around the section you keep bringing up is vague and needs to be fixed.<br>&gt;<br>&gt; &gt;<br>&gt; &gt; I think this approach would harmonize much better with current Swift<br>&gt; features and code organization practices, while offering several new<br>&gt; features (umbrella modules, exposing certain symbols only when a submodule<br>&gt; is explicitly imported, multiple `internal` scopes within a top-level<br>&gt; module) which would be very useful.<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Brent Royal-Gordon<br>&gt; &gt; Architechies<br>&gt; &gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160718/d176ee8a/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal] Qualified Imports and Modules</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>July 18, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jul 18, 2016, at 5:33 PM, Robert Widmann &lt;rwidmann at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; 2. Filenames are freeform; any file can declare itself to belong to any submodule. Obviously, best practice would be to give your files sensible names that have some kind of link to the submodule name, but this would be a linter concern.<br>&gt; <br>&gt; How does this interact with duplicate declarations?<br></p><p>Then they are part of the same submodule.<br></p><p>For instance, take a look at the GroupInfo.json file cited in the proposal: &lt;https://github.com/apple/swift/blob/master/stdlib/public/core/GroupInfo.json&gt; The Swift.String submodule consists of 18 separate files. Each of these would have `submodule String` at the top, and they would all share a single `internal` scope separate from the internal scope of the Swift module as a whole.<br></p><p>&gt;&gt; 3. Each submodule has its own `internal` scope. Submodules can import the `internal` scopes of specific peer modules with an annotation like `@testable` (but probably renamed). <br>&gt; <br>&gt; &quot;Peer modules” is something we can lock down without having to introduce even more scopes and fits well within this proposal.  A restriction like “a module may only import private members from submodules 1-level deeper than themselves” for example.<br></p><p>I assume you mean `internal` members; exposing `private` members outside the scope they&#39;re declared in, or `fileprivate` members outside the file they&#39;re declared in, is problematic.<br></p><p>What I&#39;m suggesting is that, for instance, StringCharacterView.swift can write:<br></p><p>	submodule String<br>	@testable /* or whatever */ import Swift.Collection<br>	<br>	extension String {<br>		struct CharacterView: Collection {<br>			// And we can use internal-only Collection calls here<br>		}<br>	}<br></p><p>We could certainly make rules restricting you to only importing (say) immediate siblings or immediate children, but I think that might end up being overly bureaucratic. The combination of a module and its submodules form a single whole, released together and controlled by the same organization. I see little need for elaborate tying of hands.<br></p><p>&gt;&gt; Tests are treated as a submodule of the main module, so they can participate in this mechanism just like everyone else.<br>&gt; <br>&gt; Or we could keep the existing @testable import syntax.  It will still work exactly the way it always has under this proposal.<br></p><p>I&#39;m trying to merge two similar mechanisms into one. We need some way to have SPIs between submodules within a module; it seems sensible to rework `@testable`, which creates SPIs between a module and its tests, into this mechanism.<br></p><p>&gt;&gt; 4. `import` only ever imports the `public` (or `internal`, with the `@testable` equivalent) symbols in the specified submodule. It re-exposes them with the access modifier on the `import` statement, or `private` by default. It does not re-expose `internal` symbols as `public`. `using`, `hiding`, and `renaming` apply to all comers, not just the current file.<br>&gt; <br>&gt; We do not allow you to re-export any API that is not public.  The wording around the section you keep bringing up is vague and needs to be fixed.<br></p><p>Yes—I&#39;m merely restating that to emphasize that it&#39;s part of my approach.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d972db2b6ee8b77746ce7122663eb4f8?s=50"></div><header><strong>[Proposal] Qualified Imports and Modules</strong> from <string>Robert Widmann</string> &lt;rwidmann at apple.com&gt;<p>July 18, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jul 18, 2016, at 6:01 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jul 18, 2016, at 5:33 PM, Robert Widmann &lt;rwidmann at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; 2. Filenames are freeform; any file can declare itself to belong to any submodule. Obviously, best practice would be to give your files sensible names that have some kind of link to the submodule name, but this would be a linter concern.<br>&gt;&gt; <br>&gt;&gt; How does this interact with duplicate declarations?<br>&gt; <br>&gt; Then they are part of the same submodule.<br>&gt; <br>&gt; For instance, take a look at the GroupInfo.json file cited in the proposal: &lt;https://github.com/apple/swift/blob/master/stdlib/public/core/GroupInfo.json&gt; The Swift.String submodule consists of 18 separate files. Each of these would have `submodule String` at the top, and they would all share a single `internal` scope separate from the internal scope of the Swift module as a whole.<br></p><p>It seems like that kind of scoping can just fall under “whatever my submodules are, I’d like to be able to see into them”.  If you think of a module and its submodules as a tree, an internal module scope is a branch and its children and a set of private declarations are the leaves.<br></p><p>&gt;&gt;&gt; 3. Each submodule has its own `internal` scope. Submodules can import the `internal` scopes of specific peer modules with an annotation like `@testable` (but probably renamed). <br>&gt;&gt; <br>&gt;&gt; &quot;Peer modules” is something we can lock down without having to introduce even more scopes and fits well within this proposal.  A restriction like “a module may only import private members from submodules 1-level deeper than themselves” for example.<br>&gt; <br>&gt; I assume you mean `internal` members; exposing `private` members outside the scope they&#39;re declared in, or `fileprivate` members outside the file they&#39;re declared in, is problematic.<br>&gt; <br>&gt; What I&#39;m suggesting is that, for instance, StringCharacterView.swift can write:<br>&gt; <br>&gt; 	submodule String<br>&gt; 	@testable /* or whatever */ import Swift.Collection<br>&gt; 	<br>&gt; 	extension String {<br>&gt; 		struct CharacterView: Collection {<br>&gt; 			// And we can use internal-only Collection calls here<br>&gt; 		}<br>&gt; 	}<br>&gt; <br>&gt; We could certainly make rules restricting you to only importing (say) immediate siblings or immediate children, but I think that might end up being overly bureaucratic. The combination of a module and its submodules form a single whole, released together and controlled by the same organization. I see little need for elaborate tying of hands.<br>&gt; <br></p><p>Which is why the proposal originally allowed you to say something like internal import Swift.Collection rather than express a group of “friends” that can import from each other.  If you want to ask for the contents of a non-exported module from another within the same project, at least you have to be explicit about what kind of access you want.  I think we have similar goals for private access here, it’s just a matter of expression.<br></p><p>&gt;&gt;&gt; Tests are treated as a submodule of the main module, so they can participate in this mechanism just like everyone else.<br>&gt;&gt; <br>&gt;&gt; Or we could keep the existing @testable import syntax.  It will still work exactly the way it always has under this proposal.<br>&gt; <br>&gt; I&#39;m trying to merge two similar mechanisms into one. We need some way to have SPIs between submodules within a module; it seems sensible to rework `@testable`, which creates SPIs between a module and its tests, into this mechanism.<br>&gt; <br>&gt;&gt;&gt; 4. `import` only ever imports the `public` (or `internal`, with the `@testable` equivalent) symbols in the specified submodule. It re-exposes them with the access modifier on the `import` statement, or `private` by default. It does not re-expose `internal` symbols as `public`. `using`, `hiding`, and `renaming` apply to all comers, not just the current file.<br>&gt;&gt; <br>&gt;&gt; We do not allow you to re-export any API that is not public.  The wording around the section you keep bringing up is vague and needs to be fixed.<br>&gt; <br>&gt; Yes—I&#39;m merely restating that to emphasize that it&#39;s part of my approach.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d972db2b6ee8b77746ce7122663eb4f8?s=50"></div><header><strong>[Proposal] Qualified Imports and Modules</strong> from <string>Robert Widmann</string> &lt;rwidmann at apple.com&gt;<p>July 18, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jul 18, 2016, at 4:34 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jul 18, 2016, at 2:09 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello all,<br>&gt;&gt; <br>&gt;&gt; TJ Usiyan, Harlan Haskins, and I have been working on a proposal to rework qualified imports and introduce an explicit module system to Swift that we’d like to publish for your viewing pleasure.<br>&gt; <br>&gt; This is really interesting. A few incomplete comments:<br>&gt; <br>&gt;&gt; 2) hiding: The hiding directive is followed by a list of identifiers within the imported module that should be hidden from this file.<br>&gt;&gt; <br>&gt;&gt; // Imports all of Foundation.Date except `Date.compare()`<br>&gt;&gt; import Foundation.Date hiding (Date.compare())<br>&gt; [snip]<br>&gt;&gt; // Exports the entire public contents of Math.Integers, but nothing in <br>&gt;&gt; // Math.Integers.Arithmetic.<br>&gt;&gt; public import Math.Integers<br>&gt; <br>&gt; Would this work?<br>&gt; <br>&gt; 	module UIKit<br>&gt; 	<br>&gt; 	public import UIKit.UIGestureRecognizerSubclass.UIGestureRecognizer<br>&gt; 		hiding (UIGestureRecognizer.touchesBegan(_:with:), UIGestureRecognizer.touchesMoved(_:with:), …)<br>&gt; <br>&gt; (If so, we&#39;d need a way to hide only the setter of a property, not the getter.)<br></p><p>Yes, that would work.  Notation for hiding setters and getters through the import system (probably best to do it internally, but I see what you mean) can ideally be another dot qualifier<br></p><p>public import Foo hiding (Foo.bar) // Hide the whole thing<br>public import Foo hiding (Foo.bar.set) // Hide the setter.<br>public import Foo hiding (Foo.bar.get) // Hide the getter [Not sure why you’d want this].<br></p><p>&gt;&gt; Modules names are tied to a directory structure that describes their location relative to the current module and it will now be an error to violate this rule. For example:<br>&gt;&gt; <br>&gt;&gt; module String // lives in ./String.swift<br>&gt;&gt; <br>&gt;&gt; module String.Core // lives in ./String/Core.swift<br>&gt;&gt; <br>&gt;&gt; module String.Core.Internals.Do.You.Even.Write // lives in ./String/Core/Internals/Do/You/Even/Write.swift<br>&gt; <br>&gt; I think this is a mistake for several reasons:<br>&gt; <br>&gt; * You may need to split a single submodule across multiple files, but this rule doesn&#39;t allow that.<br>&gt; <br>&gt; * The module declaration and filename contain redundant information, and one of them could get out of sync with the other.<br>&gt; <br>&gt; * Xcode doesn&#39;t like to organize things into folders on disk and will fight you tooth and nail.<br>&gt; <br>&gt; * Deeply nested folders are a usability issue. Never forget the jury in Oracle v. Google: https://www.geek.com/wp-content/uploads/2016/05/courtroomhijinks.png<br>&gt; <br>&gt; At the very least, I would like to see allowances for multi-file submodules—String/Core/Internals/Do/You/Even/Write**.swift. Better would be to use long filenames—String.Core.Internals.Do.You.Even.Write*.swift. Even better would be to just allow freeform naming and trust programmers to organize their projects sanely.<br></p><p>We are not proposing a Java-style module system so much as an extension of the existing one to submodules the way they are used today for frameworks like Darwin.  Projects no longer require reverse-DNS-style directory structures and nesting of submodules to great depth can grow unwieldy, but that may be a sign that a project is growing too decentralized.  Large frameworks will decompose themselves into submodules in roughly the same way that projects written in Objective-C, C, C++ have always decomposed themselves.  The directory structure for that style of framework rarely grows to the extend you’re concerned with here.  <br></p><p><br>&gt;&gt; Existing projects that do not adopt these rules will still retain their implicit module name (usually defined as the name of the framework or application that is being built) and may continue to use whatever directory structure they wish, however they may not declare any explicit modules.<br>&gt;&gt; <br>&gt;&gt; This proposal also solves the problem of module export. A module that is imported without an access level modifier will default to an internal import per usual. However, when it is useful to fully expose the public content of submodules to a client, a public modifier can be used. Similarly, when it is useful to access internal or [file]private APIs, but not expose them to clients, those access modifiers may be used. The rule of thumb is: Only identifiers that are at least as visible as the qualifier on the import make for valid import declarations.<br>&gt; <br>&gt; It appears the semantics here are &quot;grab all declarations at level X and above, and expose them in this module as level X&quot;. This is bizarre for a number of reasons:<br>&gt; <br>&gt; * Currently, `import` can only access `internal` declarations using `@testable`. This would change that.<br>&gt; <br></p><p>It would not.  Re-export can only re-export public APIs.<br></p><p>&gt; * Currently, `import` can&#39;t access `private` and `fileprivate` declarations at all, and it&#39;s not clear what it would mean to add that. What happens if two different parts of the module have different `private` members with the same name? Which do you get?<br></p><p>If we decide to allow this you will get an ambiguity which you can resolve with a renaming.  John has made me reconsider the semantics of a private import.<br></p><p>&gt; * Currently, `import` only affects the current file—it&#39;s effectively &quot;import `public` members as `fileprivate`&quot;. If your default is `internal import`, that would imply that an import statement in one file would, by default, expose the APIs it imported to all files. That&#39;s an important change in behavior.<br>&gt; <br></p><p>It changes existing behavior in the sense that internal imports are now module-scoped rather than project-scoped but you still cannot re-export non-public APIs.  I specifically want to *remove* the behavior where an imported API winds up recursively importing submodules until your qualified import is just garbage anyway.  Your submodules will not see an `internal import` in the same way that a project can currently see an internal import unless they themselves declare an `internal import` of that module.  And if they’re re-exporting public APIs then you probably wanted to see that when you imported them anyway.<br></p><p>&gt; I think you&#39;re mixing two things together that ought not to be. `import` should always import only public APIs (unless you use `@testable`—which might need a bit of renaming to support the additional use case of SPIs between submodules and supermodules—in which case you also get `internal` APIs).<br></p><p>And it does.<br></p><p>&gt; An access modifier on the `import` statement controls how they&#39;re exposed to the rest of the file/project/world, and `private` is the default. It&#39;s a little weird to have `private` be the default on `import` when `internal` is the default on everything else, but the alternative is to change `import`&#39;s behavior in a way that is neither backwards-compatible, nor likely to be correct.<br></p><p>Internal is the default.<br></p><p>&gt; This proposal also solves the problem of module export.  <br>&gt; A module that is imported without an access level modifier will default to an internal import per usual.<br></p><p>Doesn’t mean you can import internal APIs from modules you don’t own (that’s still banned).  You can still only export public API.<br></p><p>&gt; <br>&gt;&gt; Because import directives are file-local, they will never be exported along with a public import and will default to exporting the entire contents of the module as though you had never declared them.<br>&gt; <br>&gt; Whoa, wait, what? Why? I think hiding parts of the implementation is a good use case for re-exporting a module. And I think the clear implication of attaching these clauses directly to the import statement is that it controls how the module is imported everywhere that statement makes it visible, not just within the one file. If we&#39;re not going to do that, I think these clauses ought to be separated from the `import` statement and turned into something separate.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160718/fc5d5233/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Proposal] Qualified Imports and Modules</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 18, 2016 at 08:00:00pm</p></header><div class="content"><p>On Mon, Jul 18, 2016 at 4:09 PM, Robert Widmann via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hello all,<br>&gt;<br>&gt; TJ Usiyan, Harlan Haskins, and I have been working on a proposal to rework<br>&gt; qualified imports and introduce an explicit module system to Swift that<br>&gt; we’d like to publish for your viewing pleasure.<br>&gt;<br>&gt; The initial impetus was set out in a radar (rdar://17630570) I sent<br>&gt; fairly early on that didn’t receive a response, so I started a<br>&gt; swift-evolution<br>&gt; &lt;http://permalink.gmane.org/gmane.comp.lang.swift.evolution/1378&gt; thread<br>&gt; discussing the basics of this proposal.  It has been refined and expanded a<br>&gt; bit to include an effort to make Swift modules explicit and updated with<br>&gt; the feedback of that first thread.  Contents of the proposal are inline and can<br>&gt; also be had as a gist<br>&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6&gt; or on<br>&gt; Github. &lt;https://github.com/apple/swift-evolution/pull/440&gt;<br>&gt;<br>&gt; Cheers,<br>&gt;<br>&gt; ~Robert Widmann<br>&gt;<br>&gt; Qualified Imports and Modules<br>&gt;<br>&gt;    - Proposal: SE-NNNN<br>&gt;    &lt;https://gist.github.com/CodaFi/NNNN-first-class-qualified-imports.md&gt;<br>&gt;    - Authors: Robert Widmann &lt;https://github.com/codafi&gt;, Harlan Haskins<br>&gt;    &lt;https://github.com/harlanhaskins&gt;, TJ Usiyan<br>&gt;    &lt;https://github.com/griotspeak&gt;<br>&gt;    - Status: Awaiting review<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; We propose a complete overhaul of the qualified imports syntax and<br>&gt; semantics and the introduction of a module system.<br>&gt;<br>&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; Swift code is modular by default. However, it is not clear how to<br>&gt; decompose existing modules further into submodules. In addition, it is<br>&gt; difficult to tell how importing a module affects its export to consumers of<br>&gt; a library. This leads many to either fake namespaces with enums, attempt to<br>&gt; structure Swift code with modulemaps, or use a large amount of<br>&gt; version-control submodules. All of these can be rolled into one complete<br>&gt; package in the form of a comprehensive rethink of the qualified import<br>&gt; system and the introduction of a module system.<br>&gt;<br>&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#proposed-solution&gt;Proposed<br>&gt; solution<br>&gt;<br>&gt; Modules will now become an explicit part of working with canonical Swift<br>&gt; code. The grammar and semantics of qualified imports will change completely<br>&gt; with the addition of *import qualifiers* and *import directives*. We also<br>&gt; introduce three new contextual keywords: using, hiding, and renaming, to<br>&gt; facilitate fine-grained usage of module contents.<br>&gt;<br>&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#detailed-design&gt;Detailed<br>&gt; design<br>&gt;<br>&gt; Qualified import syntax will be revised to the following<br>&gt;<br>&gt; module-decl -&gt; module &lt;module-path&gt;<br>&gt; import-decl -&gt; &lt;access-level-modifier&gt; import &lt;module-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt; module-path -&gt; &lt;identifier&gt;<br>&gt;             -&gt; &lt;identifier&gt;.&lt;import-path&gt;<br>&gt; import-directive-list -&gt; &lt;import-directive&gt;<br>&gt;                       -&gt; &lt;import-directive&gt; &lt;import-directive-list&gt;<br>&gt; import-directive -&gt; using (&lt;identifier&gt;, ...)<br>&gt;                  -&gt; hiding (&lt;identifier&gt;, ...)<br>&gt;                  -&gt; renaming (&lt;identifier&gt;, to: &lt;identifier&gt;, ...)<br>&gt;<br>&gt; This introduces the concept of an import *directive*. An import directive<br>&gt; is a file-local modification of an imported identifier. A directive can be<br>&gt; one of 3 operations:<br>&gt;<br>&gt; 1) *using*: The *using* directive is followed by a list of identifiers<br>&gt; within the imported module that should be exposed to this file.<br>&gt;<br>&gt; // The only visible parts of Foundation in this file are // Date.init(), Date.hashValue, and Date.description.import Foundation.Date using (Date.init(), Date.hashValue, Date.description)<br>&gt;<br>&gt; 2) *hiding*: The hiding directive is followed by a list of identifiers<br>&gt; within the imported module that should be hidden from this file.<br>&gt;<br>&gt; // Imports all of Foundation.Date except `Date.compare()`import Foundation.Date hiding (Date.compare())<br>&gt;<br>&gt; 3) *renaming*: The renaming directive is followed by a list of<br>&gt; identifiers separated by to: that should be exposed to this file but<br>&gt; renamed.<br>&gt;<br>&gt; // Imports all of Dispatch.DispatchQueue but renames the static member // DispatchQueue.main, to DispatchQueue.mainQueueimport Dispatch.DispatchQueue renaming (DispatchQueue.Type.main to: DispatchQueue.Type.mainQueue)// Renaming can also rename modules.  All members of UIKit have to be qualified with// `UI` now.import UIKit renaming (UIKit, to: UI)<br>&gt;<br>&gt; Import directives chain to one another and can be used to create a<br>&gt; fine-grained module import:<br>&gt;<br>&gt; // Imports all of Foundation except `DateFormatter` and renames `Cache` to `LRUCache`import Foundation hiding (DateFormatter) renaming (Cache to: LRUCache)// Imports SCNNode except SCNNode.init(mdlObject:) and renames `.description` to// `.nodeDescription` import SceneKit using (SCNNode)<br>&gt;                 renaming (SCNNode.description, to: SCNNode.nodeDescription)<br>&gt;                 hiding (SCNNode.init(mdlObject:))<br>&gt;<br>&gt; Directive chaining occurs left-to-right:<br>&gt;<br>&gt; // This says to 1) Hide nothing 2) Use nothing 3) rename Int to INT.  It is invalid// because 1) We will show everything 2) Then hide everything 3) Therefore Int is unavailable, error.import Swift hiding () using () renaming (Int, to: INT)// This says to 1) Use Int 2) Hide String 3) rename Double to Triple.  It is invalid// because 1) Int is available 2) String is not, error. 3) Double is unavailable, error.import Swift using (Int) hiding (String) renaming (Double, to: Triple)// Valid.  This will be merged as `using (Int)`import Swift using () using (Int)// Valid.  This will be merged as `hiding (String, Double)`import Swift hiding (String) hiding (Double) hiding ()// Valid (if redundant). This will be merged as `using ()`import Swift using (String) hiding (String)<br>&gt;<br>&gt;<br>I don&#39;t mean to detract from the conversation on the deeper design aspects<br>of this proposal, but in terms of the proposed syntax I think there&#39;s<br>opportunity for simplification. I understand the desire to use parentheses,<br>especially to avoid taking up `to` even as a contextual keyword, but I<br>think it is possible to improve clarity by way of some tweaks:<br></p><p>```<br>import Swift using Int<br></p><p>import Swift using Int as INT, Double as Triple<br>// there is no possible confusion with casting here,<br>// and the use of `as` in this context would be familiar<br>// for those coming from some other languages<br></p><p>import Swift using Int, Double as Triple, String as _<br>// poof, no more String<br>```<br></p><p><br>&gt; Module scope is delimited by the keyword module followed by a fully<br>&gt; qualified name and must occur as the first declaration in a file. For<br>&gt; example:<br>&gt;<br>&gt; // ./Math/Integers/Arithmetic.swift<br>&gt; module Math.Integers.Arithmetic<br>&gt; public protocol _IntegerArithmetic {}<br>&gt; public struct _Abs {}<br>&gt; @_versionedinternal func _abs&lt;Args&gt;(_ args: Args) -&gt; (_Abs, Args) {}<br>&gt; // ./Math/Integers.swift<br>&gt; module Math.Integers<br>&gt; // _abs is visible in this module and all others within the project, // but is not exported along with it.internal import Math.Integers.Arithmetic<br>&gt; public protocol IntegerArithmetic : _IntegerArithmetic, Comparable {}public protocol SignedNumber : Comparable, ExpressibleByIntegerLiteral {}<br>&gt;<br>&gt; // Math.swift<br>&gt; module Math<br>&gt; // Exports the entire public contents of Math.Integers, but nothing in // Math.Integers.Arithmetic.public import Math.Integers<br>&gt;<br>&gt; Modules names are tied to a directory structure that describes their<br>&gt; location relative to the current module and it will now be an error to<br>&gt; violate this rule. For example:<br>&gt;<br>&gt; module String // lives in ./String.swift<br>&gt; module String.Core // lives in ./String/Core.swift<br>&gt; module String.Core.Internals.Do.You.Even.Write // lives in ./String/Core/Internals/Do/You/Even/Write.swift<br>&gt;<br>&gt; Existing projects that do not adopt these rules will still retain their *implicit<br>&gt; module name* (usually defined as the name of the framework or application<br>&gt; that is being built) and may continue to use whatever directory structure<br>&gt; they wish, however they may not declare any explicit modules.<br>&gt;<br>&gt; This proposal also solves the problem of module *export*. A module that<br>&gt; is imported without an access level modifier will default to an internal import<br>&gt; per usual. However, when it is useful to fully expose the public content of<br>&gt; submodules to a client, a public modifier can be used. Similarly, when it<br>&gt; is useful to access internal or [file]private APIs, but not expose them<br>&gt; to clients, those access modifiers may be used. The rule of thumb is: Only<br>&gt; identifiers that are at least as visible as the qualifier on the import<br>&gt; make for valid import declarations. For example:<br>&gt;<br>&gt; // A submodule declaring a `private` class that gets imported with // an `internal` qualifier with a `using` directive is an invalid import // declaration.<br>&gt; module Foo.Bar<br>&gt; private class PrivateThing {}<br>&gt;<br>&gt; module Foo<br>&gt; // Error: PrivateThing not visible, use `private import`import Foo.Bar using (PrivateThing)<br>&gt;<br>&gt; // However, a submodule declaring a `public` struct that gets imported with // an `private` qualifier is a valid import declaration.<br>&gt; module Foo.Bar<br>&gt; public class PublicThing {}<br>&gt;<br>&gt; module Foo<br>&gt; // All good!  Foo can see Foo.Bar.PrivateThing.private import Foo.Bar using (PublicThing)<br>&gt;<br>&gt; Because import directives are file-local, they will never be exported<br>&gt; along with a public import and will default to exporting the entire<br>&gt; contents of the module as though you had never declared them.<br>&gt;<br>&gt; // In this file and this file alone, the directives apply.  To the user// of this module, it is as though this declaration were simply:// public import Foundation.Datepublic import Foundation.Date hiding (Date.init())<br>&gt;                               renaming (Date.Type.distantPast,<br>&gt;                                         to: Date.Type.letsGoLivingInThePast,<br>&gt;                                         Date.Type.timeIntervalSinceReferenceDate,<br>&gt;                                         to: Date.Type.startOfTheUniverse)<br>&gt;                               renaming (Date.Type.&lt;, to: Date.Type.&lt;&lt;&lt;&lt;&lt;)<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#impact-on-existing-code&gt;Impact<br>&gt; on existing code<br>&gt;<br>&gt; Existing code that is using qualified module import syntax (import<br>&gt; {func|class|typealias|class|struct|enum|protocol} &lt;qualified-name&gt;) will<br>&gt; be deprecated. Code that is not organized into modules will remain<br>&gt; unaffected and organized into one contiguous top-level module. However, it<br>&gt; is strongly recommended that frameworks be decomposed and reorganized<br>&gt; around the new module system.<br>&gt;<br>&gt; As a case study, the public interface to the standard library appears to<br>&gt; already be mostly broken down into submodules as described in<br>&gt; GroupInfo.json<br>&gt; &lt;https://github.com/apple/swift/blob/master/stdlib/public/core/GroupInfo.json&gt;<br>&gt; .<br>&gt;<br>&gt; Code that is defined in modulemaps already defines a module structure that<br>&gt; can be imported directly into this scheme.<br>&gt;<br>&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#alternatives-considered&gt;Alternatives<br>&gt; considered<br>&gt;<br>&gt; Module export can also be placed on the module declaration itself. The<br>&gt; relevant parts of the grammar that have changed are below with an example:<br>&gt;<br>&gt; module-decl -&gt; &lt;access-level-modifier&gt; module &lt;module-path&gt;<br>&gt; import-decl -&gt; import &lt;module-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt;<br>&gt; private module String.Core.Internals<br>&gt; // Shh, it&#39;s a secret.<br>&gt;<br>&gt; While this style makes it immediately obvious to the library author which<br>&gt; modules are public or private, it causes the consumer problems because<br>&gt; submodule exports are no longer explicit and are entirely ad-hoc. In the<br>&gt; interest of enabling, for one, users of IDEs to drill into public<br>&gt; submodules, making export local to import seems more appropriate.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160718/120e3a8c/attachment-0001.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Qualified Imports and Modules</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>July 18, 2016 at 06:00:00pm</p></header><div class="content"><p>Our import story definitely needs work, and this is a step in the right direction. Thanks for working on this! Some comments:<br></p><p>- The import changes can be separated from the submodule issues. Enhancing imports is IMO more important, and is source-breaking today, whereas &#39;module &#39; declarations and submodules can be added later. I&#39;d suggest breaking this into two proposals.<br>- I think the `import` design you propose is a bit more complicated than it needs to be. Python and Haskell get by just having &quot;import everything&quot; and &quot;import itemized (with aliases)&quot;. I don&#39;t see the need for &#39;hiding&#39;; if you have a rule that itemized imports get priority over import-everything, then that covers the most important use case of selectively shadowing one module&#39;s imports with another. Bikeshed-wise, I don&#39;t see much reason to veer from the Java/Haskell-ish template of:<br></p><p>import Foo.* // import everything from module Foo<br>import Foo.(x, y, z as zed) // import x, y, and z from foo, renaming Foo.z to zed<br></p><p>-Joe<br></p><p>&gt; On Jul 18, 2016, at 2:09 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello all,<br>&gt; <br>&gt; TJ Usiyan, Harlan Haskins, and I have been working on a proposal to rework qualified imports and introduce an explicit module system to Swift that we’d like to publish for your viewing pleasure.<br>&gt; <br>&gt; The initial impetus was set out in a radar (rdar://17630570) I sent fairly early on that didn’t receive a response, so I started a swift-evolution thread discussing the basics of this proposal.  It has been refined and expanded a bit to include an effort to make Swift modules explicit and updated with the feedback of that first thread.  Contents of the proposal are inline and can also be had as a gist or on Github.<br>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt; Qualified Imports and Modules<br>&gt; <br>&gt; 	• Proposal: SE-NNNN<br>&gt; 	• Authors: Robert Widmann, Harlan Haskins, TJ Usiyan<br>&gt; 	• Status: Awaiting review<br>&gt; 	• Review manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; We propose a complete overhaul of the qualified imports syntax and semantics and the introduction of a module system.<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; Swift code is modular by default. However, it is not clear how to decompose existing modules further into submodules. In addition, it is difficult to tell how importing a module affects its export to consumers of a library. This leads many to either fake namespaces with enums, attempt to structure Swift code with modulemaps, or use a large amount of version-control submodules. All of these can be rolled into one complete package in the form of a comprehensive rethink of the qualified import system and the introduction of a module system.<br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; Modules will now become an explicit part of working with canonical Swift code. The grammar and semantics of qualified imports will change completely with the addition of import qualifiers and import directives. We also introduce three new contextual keywords: using, hiding, and renaming, to facilitate fine-grained usage of module contents.<br>&gt; <br>&gt; Detailed design<br>&gt; <br>&gt; Qualified import syntax will be revised to the following<br>&gt; <br>&gt; module-decl -&gt; module &lt;module-path&gt;<br>&gt; import-decl -&gt; &lt;access-level-modifier&gt; import &lt;module-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt; module-path -&gt; &lt;identifier&gt;<br>&gt;             -&gt; &lt;identifier&gt;.&lt;import-path&gt;<br>&gt; import-directive-list -&gt; &lt;import-directive&gt;<br>&gt;                       -&gt; &lt;import-directive&gt; &lt;import-directive-list&gt;<br>&gt; import-directive -&gt; using (&lt;identifier&gt;, ...)<br>&gt;                  -&gt; hiding (&lt;identifier&gt;, ...)<br>&gt;                  -&gt; renaming (&lt;identifier&gt;, to: &lt;identifier&gt;, ...)<br>&gt; <br>&gt; This introduces the concept of an import directive. An import directive is a file-local modification of an imported identifier. A directive can be one of 3 operations:<br>&gt; <br>&gt; 1) using: The using directive is followed by a list of identifiers within the imported module that should be exposed to this file. <br>&gt; <br>&gt; // The only visible parts of Foundation in this file are <br>&gt; // Date.init(), Date.hashValue, and Date.description.<br>&gt; import Foundation.Date using (Date.init(), Date.hashValue, Date.description)<br>&gt; 2) hiding: The hiding directive is followed by a list of identifiers within the imported module that should be hidden from this file.<br>&gt; <br>&gt; // Imports all of Foundation.Date except `Date.compare()`<br>&gt; import Foundation.Date hiding (Date.compare())<br>&gt; 3) renaming: The renaming directive is followed by a list of identifiers separated by to: that should be exposed to this file but renamed. <br>&gt; <br>&gt; // Imports all of Dispatch.DispatchQueue but renames the static member <br>&gt; // DispatchQueue.main, to DispatchQueue.mainQueue<br>&gt; import Dispatch.DispatchQueue renaming (DispatchQueue.Type.main to: DispatchQueue.Type.<br>&gt; mainQueue)<br>&gt; <br>&gt; // Renaming can also rename modules.  All members of UIKit have to be qualified with<br>&gt; // `UI` now.<br>&gt; import UIKit renaming (UIKit, to: UI)<br>&gt; Import directives chain to one another and can be used to create a fine-grained module import:<br>&gt; <br>&gt; // Imports all of Foundation except `DateFormatter` and renames `Cache` to `LRUCache`<br>&gt; import Foundation<br>&gt;  hiding (DateFormatter) renaming (Cache to: LRUCache)<br>&gt; <br>&gt; // Imports SCNNode except SCNNode.init(mdlObject:) and renames `.description` to<br>&gt; // `.nodeDescription` <br>&gt; import SceneKit<br>&gt;  using (SCNNode) <br>&gt;                 renaming (SCNNode<br>&gt; .description, to: SCNNode.<br>&gt; nodeDescription)<br>&gt;                 hiding (SCNNode<br>&gt; .init(mdlObject:))<br>&gt; Directive chaining occurs left-to-right:<br>&gt; <br>&gt; // This says to 1) Hide nothing 2) Use nothing 3) rename Int to INT.  It is invalid<br>&gt; // because 1) We will show everything 2) Then hide everything 3) Therefore Int is unavailable, error.<br>&gt; import Swift hiding () using () renaming (Int<br>&gt; , to: INT)<br>&gt; <br>&gt; // This says to 1) Use Int 2) Hide String 3) rename Double to Triple.  It is invalid<br>&gt; // because 1) Int is available 2) String is not, error. 3) Double is unavailable, error.<br>&gt; import Swift using (Int) hiding (String) renaming (Double<br>&gt; , to: Triple)<br>&gt; <br>&gt; // Valid.  This will be merged as `using (Int)`<br>&gt; import Swift using () using (Int<br>&gt; )<br>&gt; <br>&gt; // Valid.  This will be merged as `hiding (String, Double)`<br>&gt; import Swift hiding (String) hiding (Double<br>&gt; ) hiding ()<br>&gt; <br>&gt; // Valid (if redundant). This will be merged as `using ()`<br>&gt; import Swift using (String) hiding (String)<br>&gt; Module scope is delimited by the keyword module followed by a fully qualified name and must occur as the first declaration in a file. For example:<br>&gt; <br>&gt; // ./Math/Integers/Arithmetic.swift<br>&gt; <br>&gt; module Math<br>&gt; .Integers.<br>&gt; Arithmetic<br>&gt; <br>&gt; <br>&gt; public protocol<br>&gt;  _IntegerArithmetic {}<br>&gt; <br>&gt; <br>&gt; public struct<br>&gt;  _Abs {}<br>&gt; <br>&gt; <br>&gt; @_versioned<br>&gt; internal func _abs&lt;Args&gt;(_ args: Args) -&gt;<br>&gt;  (_Abs, Args) {}<br>&gt; <br>&gt; <br>&gt; // ./Math/Integers.swift<br>&gt; <br>&gt; module Math<br>&gt; .<br>&gt; Integers<br>&gt; <br>&gt; <br>&gt; // _abs is visible in this module and all others within the project, <br>&gt; // but is not exported along with it.<br>&gt; internal import Math.Integers.Arithmetic<br>&gt; <br>&gt; <br>&gt; <br>&gt; public protocol IntegerArithmetic : _IntegerArithmetic, Comparable<br>&gt;  {}<br>&gt; <br>&gt; public protocol SignedNumber : Comparable<br>&gt; , ExpressibleByIntegerLiteral {}<br>&gt; <br>&gt; <br>&gt; <br>&gt; // Math.swift<br>&gt; <br>&gt; module Math<br>&gt; <br>&gt; <br>&gt; // Exports the entire public contents of Math.Integers, but nothing in <br>&gt; // Math.Integers.Arithmetic.<br>&gt; public import Math.Integers<br>&gt; Modules names are tied to a directory structure that describes their location relative to the current module and it will now be an error to violate this rule. For example:<br>&gt; <br>&gt; module String // lives in ./String.swift<br>&gt; <br>&gt; module <br>&gt; String.Core // lives in ./String/Core.swift<br>&gt; <br>&gt; module <br>&gt; String.Core.Internals.Do.You.Even.Write // lives in ./String/Core/Internals/Do/You/Even/Write.swift<br>&gt; Existing projects that do not adopt these rules will still retain their implicit module name (usually defined as the name of the framework or application that is being built) and may continue to use whatever directory structure they wish, however they may not declare any explicit modules.<br>&gt; <br>&gt; This proposal also solves the problem of module export. A module that is imported without an access level modifier will default to an internal import per usual. However, when it is useful to fully expose the public content of submodules to a client, a public modifier can be used. Similarly, when it is useful to access internal or [file]private APIs, but not expose them to clients, those access modifiers may be used. The rule of thumb is: Only identifiers that are at least as visible as the qualifier on the import make for valid import declarations. For example:<br>&gt; <br>&gt; // A submodule declaring a `private` class that gets imported with <br>&gt; // an `internal` qualifier with a `using` directive is an invalid import <br>&gt; // declaration.  <br>&gt; <br>&gt; module Foo<br>&gt; .<br>&gt; Bar<br>&gt; <br>&gt; <br>&gt; private class<br>&gt;  PrivateThing {}<br>&gt; <br>&gt; module Foo<br>&gt; <br>&gt; <br>&gt; // Error: PrivateThing not visible, use `private import`<br>&gt; import Foo.Bar using (PrivateThing) <br>&gt; // However, a submodule declaring a `public` struct that gets imported with <br>&gt; // an `private` qualifier is a valid import declaration.<br>&gt; <br>&gt; module Foo<br>&gt; .<br>&gt; Bar<br>&gt; <br>&gt; <br>&gt; public class<br>&gt;  PublicThing {}<br>&gt; <br>&gt; module Foo<br>&gt; <br>&gt; <br>&gt; // All good!  Foo can see Foo.Bar.PrivateThing.<br>&gt; private import Foo.Bar using (PublicThing) <br>&gt; Because import directives are file-local, they will never be exported along with a public import and will default to exporting the entire contents of the module as though you had never declared them.<br>&gt; <br>&gt; // In this file and this file alone, the directives apply.  To the user<br>&gt; // of this module, it is as though this declaration were simply:<br>&gt; // public import Foundation.Date<br>&gt; public import Foundation.Date hiding (Date.init<br>&gt; ()) <br>&gt;                               renaming (Date<br>&gt; .Type.<br>&gt; distantPast, <br>&gt;                                         to: Date<br>&gt; .Type.<br>&gt; letsGoLivingInThePast,<br>&gt;                                         Date<br>&gt; .Type.<br>&gt; timeIntervalSinceReferenceDate, <br>&gt;                                         to: Date<br>&gt; .Type.<br>&gt; startOfTheUniverse)<br>&gt;                               renaming (Date<br>&gt; .Type.&lt;, to: Date.Type.&lt;&lt;&lt;&lt;&lt;)<br>&gt; Impact on existing code<br>&gt; <br>&gt; Existing code that is using qualified module import syntax (import {func|class|typealias|class|struct|enum|protocol} &lt;qualified-name&gt;) will be deprecated. Code that is not organized into modules will remain unaffected and organized into one contiguous top-level module. However, it is strongly recommended that frameworks be decomposed and reorganized around the new module system.<br>&gt; <br>&gt; As a case study, the public interface to the standard library appears to already be mostly broken down into submodules as described in GroupInfo.json.<br>&gt; <br>&gt; Code that is defined in modulemaps already defines a module structure that can be imported directly into this scheme.<br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; Module export can also be placed on the module declaration itself. The relevant parts of the grammar that have changed are below with an example:<br>&gt; <br>&gt; module-decl -&gt; &lt;access-level-modifier&gt; module &lt;module-path&gt;<br>&gt; import-decl -&gt; import &lt;module-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt; <br>&gt; private module String.Core.<br>&gt; Internals<br>&gt; <br>&gt; <br>&gt; // Shh, it&#39;s a secret.<br>&gt; While this style makes it immediately obvious to the library author which modules are public or private, it causes the consumer problems because submodule exports are no longer explicit and are entirely ad-hoc. In the interest of enabling, for one, users of IDEs to drill into public submodules, making export local to import seems more appropriate.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Proposal] Qualified Imports and Modules</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>July 18, 2016 at 09:00:00pm</p></header><div class="content"><p>My gut feeling is also that this is more complex than it needs to be. If we want to keep all of these features around, I&#39;d be in favor of looking for a syntax that &quot;flows better&quot; than three separate clauses.<br></p><p>Also, under the current model (or a somewhat recent model, because I ran into that last month), everything included in a bridging header is implicitly imported into every Swift file. If it #includes Foundation, you won&#39;t get to refine that from Swift. The proposal would probably benefit from taking that into account, somehow. (Allow re-imports? Separate module imports from using-like statements?)<br></p><p>Finally, should selecting extension methods with the same name or conformances to the same protocol from different modules be considered a problem that this proposal intends to solve?<br></p><p>Félix<br></p><p>&gt; Le 18 juil. 2016 à 18:19:59, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Our import story definitely needs work, and this is a step in the right direction. Thanks for working on this! Some comments:<br>&gt; <br>&gt; - The import changes can be separated from the submodule issues. Enhancing imports is IMO more important, and is source-breaking today, whereas &#39;module &#39; declarations and submodules can be added later. I&#39;d suggest breaking this into two proposals.<br>&gt; - I think the `import` design you propose is a bit more complicated than it needs to be. Python and Haskell get by just having &quot;import everything&quot; and &quot;import itemized (with aliases)&quot;. I don&#39;t see the need for &#39;hiding&#39;; if you have a rule that itemized imports get priority over import-everything, then that covers the most important use case of selectively shadowing one module&#39;s imports with another. Bikeshed-wise, I don&#39;t see much reason to veer from the Java/Haskell-ish template of:<br>&gt; <br>&gt; import Foo.* // import everything from module Foo<br>&gt; import Foo.(x, y, z as zed) // import x, y, and z from foo, renaming Foo.z to zed<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; On Jul 18, 2016, at 2:09 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello all,<br>&gt;&gt; <br>&gt;&gt; TJ Usiyan, Harlan Haskins, and I have been working on a proposal to rework qualified imports and introduce an explicit module system to Swift that we’d like to publish for your viewing pleasure.<br>&gt;&gt; <br>&gt;&gt; The initial impetus was set out in a radar (rdar://17630570) I sent fairly early on that didn’t receive a response, so I started a swift-evolution thread discussing the basics of this proposal.  It has been refined and expanded a bit to include an effort to make Swift modules explicit and updated with the feedback of that first thread.  Contents of the proposal are inline and can also be had as a gist or on Github.<br>&gt;&gt; <br>&gt;&gt; Cheers,<br>&gt;&gt; <br>&gt;&gt; ~Robert Widmann<br>&gt;&gt; <br>&gt;&gt; Qualified Imports and Modules<br>&gt;&gt; <br>&gt;&gt; 	• Proposal: SE-NNNN<br>&gt;&gt; 	• Authors: Robert Widmann, Harlan Haskins, TJ Usiyan<br>&gt;&gt; 	• Status: Awaiting review<br>&gt;&gt; 	• Review manager: TBD<br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; We propose a complete overhaul of the qualified imports syntax and semantics and the introduction of a module system.<br>&gt;&gt; <br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; Swift code is modular by default. However, it is not clear how to decompose existing modules further into submodules. In addition, it is difficult to tell how importing a module affects its export to consumers of a library. This leads many to either fake namespaces with enums, attempt to structure Swift code with modulemaps, or use a large amount of version-control submodules. All of these can be rolled into one complete package in the form of a comprehensive rethink of the qualified import system and the introduction of a module system.<br>&gt;&gt; <br>&gt;&gt; Proposed solution<br>&gt;&gt; <br>&gt;&gt; Modules will now become an explicit part of working with canonical Swift code. The grammar and semantics of qualified imports will change completely with the addition of import qualifiers and import directives. We also introduce three new contextual keywords: using, hiding, and renaming, to facilitate fine-grained usage of module contents.<br>&gt;&gt; <br>&gt;&gt; Detailed design<br>&gt;&gt; <br>&gt;&gt; Qualified import syntax will be revised to the following<br>&gt;&gt; <br>&gt;&gt; module-decl -&gt; module &lt;module-path&gt;<br>&gt;&gt; import-decl -&gt; &lt;access-level-modifier&gt; import &lt;module-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt;&gt; module-path -&gt; &lt;identifier&gt;<br>&gt;&gt;            -&gt; &lt;identifier&gt;.&lt;import-path&gt;<br>&gt;&gt; import-directive-list -&gt; &lt;import-directive&gt;<br>&gt;&gt;                      -&gt; &lt;import-directive&gt; &lt;import-directive-list&gt;<br>&gt;&gt; import-directive -&gt; using (&lt;identifier&gt;, ...)<br>&gt;&gt;                 -&gt; hiding (&lt;identifier&gt;, ...)<br>&gt;&gt;                 -&gt; renaming (&lt;identifier&gt;, to: &lt;identifier&gt;, ...)<br>&gt;&gt; <br>&gt;&gt; This introduces the concept of an import directive. An import directive is a file-local modification of an imported identifier. A directive can be one of 3 operations:<br>&gt;&gt; <br>&gt;&gt; 1) using: The using directive is followed by a list of identifiers within the imported module that should be exposed to this file. <br>&gt;&gt; <br>&gt;&gt; // The only visible parts of Foundation in this file are <br>&gt;&gt; // Date.init(), Date.hashValue, and Date.description.<br>&gt;&gt; import Foundation.Date using (Date.init(), Date.hashValue, Date.description)<br>&gt;&gt; 2) hiding: The hiding directive is followed by a list of identifiers within the imported module that should be hidden from this file.<br>&gt;&gt; <br>&gt;&gt; // Imports all of Foundation.Date except `Date.compare()`<br>&gt;&gt; import Foundation.Date hiding (Date.compare())<br>&gt;&gt; 3) renaming: The renaming directive is followed by a list of identifiers separated by to: that should be exposed to this file but renamed. <br>&gt;&gt; <br>&gt;&gt; // Imports all of Dispatch.DispatchQueue but renames the static member <br>&gt;&gt; // DispatchQueue.main, to DispatchQueue.mainQueue<br>&gt;&gt; import Dispatch.DispatchQueue renaming (DispatchQueue.Type.main to: DispatchQueue.Type.<br>&gt;&gt; mainQueue)<br>&gt;&gt; <br>&gt;&gt; // Renaming can also rename modules.  All members of UIKit have to be qualified with<br>&gt;&gt; // `UI` now.<br>&gt;&gt; import UIKit renaming (UIKit, to: UI)<br>&gt;&gt; Import directives chain to one another and can be used to create a fine-grained module import:<br>&gt;&gt; <br>&gt;&gt; // Imports all of Foundation except `DateFormatter` and renames `Cache` to `LRUCache`<br>&gt;&gt; import Foundation<br>&gt;&gt; hiding (DateFormatter) renaming (Cache to: LRUCache)<br>&gt;&gt; <br>&gt;&gt; // Imports SCNNode except SCNNode.init(mdlObject:) and renames `.description` to<br>&gt;&gt; // `.nodeDescription` <br>&gt;&gt; import SceneKit<br>&gt;&gt; using (SCNNode) <br>&gt;&gt;                renaming (SCNNode<br>&gt;&gt; .description, to: SCNNode.<br>&gt;&gt; nodeDescription)<br>&gt;&gt;                hiding (SCNNode<br>&gt;&gt; .init(mdlObject:))<br>&gt;&gt; Directive chaining occurs left-to-right:<br>&gt;&gt; <br>&gt;&gt; // This says to 1) Hide nothing 2) Use nothing 3) rename Int to INT.  It is invalid<br>&gt;&gt; // because 1) We will show everything 2) Then hide everything 3) Therefore Int is unavailable, error.<br>&gt;&gt; import Swift hiding () using () renaming (Int<br>&gt;&gt; , to: INT)<br>&gt;&gt; <br>&gt;&gt; // This says to 1) Use Int 2) Hide String 3) rename Double to Triple.  It is invalid<br>&gt;&gt; // because 1) Int is available 2) String is not, error. 3) Double is unavailable, error.<br>&gt;&gt; import Swift using (Int) hiding (String) renaming (Double<br>&gt;&gt; , to: Triple)<br>&gt;&gt; <br>&gt;&gt; // Valid.  This will be merged as `using (Int)`<br>&gt;&gt; import Swift using () using (Int<br>&gt;&gt; )<br>&gt;&gt; <br>&gt;&gt; // Valid.  This will be merged as `hiding (String, Double)`<br>&gt;&gt; import Swift hiding (String) hiding (Double<br>&gt;&gt; ) hiding ()<br>&gt;&gt; <br>&gt;&gt; // Valid (if redundant). This will be merged as `using ()`<br>&gt;&gt; import Swift using (String) hiding (String)<br>&gt;&gt; Module scope is delimited by the keyword module followed by a fully qualified name and must occur as the first declaration in a file. For example:<br>&gt;&gt; <br>&gt;&gt; // ./Math/Integers/Arithmetic.swift<br>&gt;&gt; <br>&gt;&gt; module Math<br>&gt;&gt; .Integers.<br>&gt;&gt; Arithmetic<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; public protocol<br>&gt;&gt; _IntegerArithmetic {}<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; public struct<br>&gt;&gt; _Abs {}<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; @_versioned<br>&gt;&gt; internal func _abs&lt;Args&gt;(_ args: Args) -&gt;<br>&gt;&gt; (_Abs, Args) {}<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; // ./Math/Integers.swift<br>&gt;&gt; <br>&gt;&gt; module Math<br>&gt;&gt; .<br>&gt;&gt; Integers<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; // _abs is visible in this module and all others within the project, <br>&gt;&gt; // but is not exported along with it.<br>&gt;&gt; internal import Math.Integers.Arithmetic<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; public protocol IntegerArithmetic : _IntegerArithmetic, Comparable<br>&gt;&gt; {}<br>&gt;&gt; <br>&gt;&gt; public protocol SignedNumber : Comparable<br>&gt;&gt; , ExpressibleByIntegerLiteral {}<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; // Math.swift<br>&gt;&gt; <br>&gt;&gt; module Math<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; // Exports the entire public contents of Math.Integers, but nothing in <br>&gt;&gt; // Math.Integers.Arithmetic.<br>&gt;&gt; public import Math.Integers<br>&gt;&gt; Modules names are tied to a directory structure that describes their location relative to the current module and it will now be an error to violate this rule. For example:<br>&gt;&gt; <br>&gt;&gt; module String // lives in ./String.swift<br>&gt;&gt; <br>&gt;&gt; module <br>&gt;&gt; String.Core // lives in ./String/Core.swift<br>&gt;&gt; <br>&gt;&gt; module <br>&gt;&gt; String.Core.Internals.Do.You.Even.Write // lives in ./String/Core/Internals/Do/You/Even/Write.swift<br>&gt;&gt; Existing projects that do not adopt these rules will still retain their implicit module name (usually defined as the name of the framework or application that is being built) and may continue to use whatever directory structure they wish, however they may not declare any explicit modules.<br>&gt;&gt; <br>&gt;&gt; This proposal also solves the problem of module export. A module that is imported without an access level modifier will default to an internal import per usual. However, when it is useful to fully expose the public content of submodules to a client, a public modifier can be used. Similarly, when it is useful to access internal or [file]private APIs, but not expose them to clients, those access modifiers may be used. The rule of thumb is: Only identifiers that are at least as visible as the qualifier on the import make for valid import declarations. For example:<br>&gt;&gt; <br>&gt;&gt; // A submodule declaring a `private` class that gets imported with <br>&gt;&gt; // an `internal` qualifier with a `using` directive is an invalid import <br>&gt;&gt; // declaration.  <br>&gt;&gt; <br>&gt;&gt; module Foo<br>&gt;&gt; .<br>&gt;&gt; Bar<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; private class<br>&gt;&gt; PrivateThing {}<br>&gt;&gt; <br>&gt;&gt; module Foo<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; // Error: PrivateThing not visible, use `private import`<br>&gt;&gt; import Foo.Bar using (PrivateThing) <br>&gt;&gt; // However, a submodule declaring a `public` struct that gets imported with <br>&gt;&gt; // an `private` qualifier is a valid import declaration.<br>&gt;&gt; <br>&gt;&gt; module Foo<br>&gt;&gt; .<br>&gt;&gt; Bar<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; public class<br>&gt;&gt; PublicThing {}<br>&gt;&gt; <br>&gt;&gt; module Foo<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; // All good!  Foo can see Foo.Bar.PrivateThing.<br>&gt;&gt; private import Foo.Bar using (PublicThing) <br>&gt;&gt; Because import directives are file-local, they will never be exported along with a public import and will default to exporting the entire contents of the module as though you had never declared them.<br>&gt;&gt; <br>&gt;&gt; // In this file and this file alone, the directives apply.  To the user<br>&gt;&gt; // of this module, it is as though this declaration were simply:<br>&gt;&gt; // public import Foundation.Date<br>&gt;&gt; public import Foundation.Date hiding (Date.init<br>&gt;&gt; ()) <br>&gt;&gt;                              renaming (Date<br>&gt;&gt; .Type.<br>&gt;&gt; distantPast, <br>&gt;&gt;                                        to: Date<br>&gt;&gt; .Type.<br>&gt;&gt; letsGoLivingInThePast,<br>&gt;&gt;                                        Date<br>&gt;&gt; .Type.<br>&gt;&gt; timeIntervalSinceReferenceDate, <br>&gt;&gt;                                        to: Date<br>&gt;&gt; .Type.<br>&gt;&gt; startOfTheUniverse)<br>&gt;&gt;                              renaming (Date<br>&gt;&gt; .Type.&lt;, to: Date.Type.&lt;&lt;&lt;&lt;&lt;)<br>&gt;&gt; Impact on existing code<br>&gt;&gt; <br>&gt;&gt; Existing code that is using qualified module import syntax (import {func|class|typealias|class|struct|enum|protocol} &lt;qualified-name&gt;) will be deprecated. Code that is not organized into modules will remain unaffected and organized into one contiguous top-level module. However, it is strongly recommended that frameworks be decomposed and reorganized around the new module system.<br>&gt;&gt; <br>&gt;&gt; As a case study, the public interface to the standard library appears to already be mostly broken down into submodules as described in GroupInfo.json.<br>&gt;&gt; <br>&gt;&gt; Code that is defined in modulemaps already defines a module structure that can be imported directly into this scheme.<br>&gt;&gt; <br>&gt;&gt; Alternatives considered<br>&gt;&gt; <br>&gt;&gt; Module export can also be placed on the module declaration itself. The relevant parts of the grammar that have changed are below with an example:<br>&gt;&gt; <br>&gt;&gt; module-decl -&gt; &lt;access-level-modifier&gt; module &lt;module-path&gt;<br>&gt;&gt; import-decl -&gt; import &lt;module-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt;&gt; <br>&gt;&gt; private module String.Core.<br>&gt;&gt; Internals<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; // Shh, it&#39;s a secret.<br>&gt;&gt; While this style makes it immediately obvious to the library author which modules are public or private, it causes the consumer problems because submodule exports are no longer explicit and are entirely ad-hoc. In the interest of enabling, for one, users of IDEs to drill into public submodules, making export local to import seems more appropriate.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160718/cdaff9a5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Proposal] Qualified Imports and Modules</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>July 19, 2016 at 07:00:00am</p></header><div class="content"><p>Import Foo.* as bar.    // has public methodX() and type TypeA<br>Import Foo2.* as baz. // also has public methodX() and type TypeA<br></p><p>would be interesting because it entirely avoids collisions when using both together. It also provides some documentation at the point of use, as well as allow the IDE to keep its indexing of Foo completely distinct fromthe indexing of the current module. The last point is that it also leads to less cluttered code completion proposal lists<br></p><p>Y = bar.methodX() + baz.methodX()<br>var v1 = new bar.TypeA()<br>var v2 = new baz.TypeA()<br></p><p><br>Regards<br>(From mobile)<br></p><p>&gt; On Jul 19, 2016, at 6:50 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; My gut feeling is also that this is more complex than it needs to be. If we want to keep all of these features around, I&#39;d be in favor of looking for a syntax that &quot;flows better&quot; than three separate clauses.<br>&gt; <br>&gt; Also, under the current model (or a somewhat recent model, because I ran into that last month), everything included in a bridging header is implicitly imported into every Swift file. If it #includes Foundation, you won&#39;t get to refine that from Swift. The proposal would probably benefit from taking that into account, somehow. (Allow re-imports? Separate module imports from using-like statements?)<br>&gt; <br>&gt; Finally, should selecting extension methods with the same name or conformances to the same protocol from different modules be considered a problem that this proposal intends to solve?<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 18 juil. 2016 à 18:19:59, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; Our import story definitely needs work, and this is a step in the right direction. Thanks for working on this! Some comments:<br>&gt;&gt; <br>&gt;&gt; - The import changes can be separated from the submodule issues. Enhancing imports is IMO more important, and is source-breaking today, whereas &#39;module &#39; declarations and submodules can be added later. I&#39;d suggest breaking this into two proposals.<br>&gt;&gt; - I think the `import` design you propose is a bit more complicated than it needs to be. Python and Haskell get by just having &quot;import everything&quot; and &quot;import itemized (with aliases)&quot;. I don&#39;t see the need for &#39;hiding&#39;; if you have a rule that itemized imports get priority over import-everything, then that covers the most important use case of selectively shadowing one module&#39;s imports with another. Bikeshed-wise, I don&#39;t see much reason to veer from the Java/Haskell-ish template of:<br>&gt;&gt; <br>&gt;&gt; import Foo.* // import everything from module Foo<br>&gt;&gt; import Foo.(x, y, z as zed) // import x, y, and z from foo, renaming Foo.z to zed<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 18, 2016, at 2:09 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; TJ Usiyan, Harlan Haskins, and I have been working on a proposal to rework qualified imports and introduce an explicit module system to Swift that we’d like to publish for your viewing pleasure.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The initial impetus was set out in a radar (rdar://17630570) I sent fairly early on that didn’t receive a response, so I started a swift-evolution thread discussing the basics of this proposal.  It has been refined and expanded a bit to include an effort to make Swift modules explicit and updated with the feedback of that first thread.  Contents of the proposal are inline and can also be had as a gist or on Github.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Qualified Imports and Modules<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	• Proposal: SE-NNNN<br>&gt;&gt;&gt; 	• Authors: Robert Widmann, Harlan Haskins, TJ Usiyan<br>&gt;&gt;&gt; 	• Status: Awaiting review<br>&gt;&gt;&gt; 	• Review manager: TBD<br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We propose a complete overhaul of the qualified imports syntax and semantics and the introduction of a module system.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift code is modular by default. However, it is not clear how to decompose existing modules further into submodules. In addition, it is difficult to tell how importing a module affects its export to consumers of a library. This leads many to either fake namespaces with enums, attempt to structure Swift code with modulemaps, or use a large amount of version-control submodules. All of these can be rolled into one complete package in the form of a comprehensive rethink of the qualified import system and the introduction of a module system.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Modules will now become an explicit part of working with canonical Swift code. The grammar and semantics of qualified imports will change completely with the addition of import qualifiers and import directives. We also introduce three new contextual keywords: using, hiding, and renaming, to facilitate fine-grained usage of module contents.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Detailed design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Qualified import syntax will be revised to the following<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; module-decl -&gt; module &lt;module-path&gt;<br>&gt;&gt;&gt; import-decl -&gt; &lt;access-level-modifier&gt; import &lt;module-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt;&gt;&gt; module-path -&gt; &lt;identifier&gt;<br>&gt;&gt;&gt;            -&gt; &lt;identifier&gt;.&lt;import-path&gt;<br>&gt;&gt;&gt; import-directive-list -&gt; &lt;import-directive&gt;<br>&gt;&gt;&gt;                      -&gt; &lt;import-directive&gt; &lt;import-directive-list&gt;<br>&gt;&gt;&gt; import-directive -&gt; using (&lt;identifier&gt;, ...)<br>&gt;&gt;&gt;                 -&gt; hiding (&lt;identifier&gt;, ...)<br>&gt;&gt;&gt;                 -&gt; renaming (&lt;identifier&gt;, to: &lt;identifier&gt;, ...)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This introduces the concept of an import directive. An import directive is a file-local modification of an imported identifier. A directive can be one of 3 operations:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1) using: The using directive is followed by a list of identifiers within the imported module that should be exposed to this file. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // The only visible parts of Foundation in this file are <br>&gt;&gt;&gt; // Date.init(), Date.hashValue, and Date.description.<br>&gt;&gt;&gt; import Foundation.Date using (Date.init(), Date.hashValue, Date.description)<br>&gt;&gt;&gt; 2) hiding: The hiding directive is followed by a list of identifiers within the imported module that should be hidden from this file.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Imports all of Foundation.Date except `Date.compare()`<br>&gt;&gt;&gt; import Foundation.Date hiding (Date.compare())<br>&gt;&gt;&gt; 3) renaming: The renaming directive is followed by a list of identifiers separated by to: that should be exposed to this file but renamed. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Imports all of Dispatch.DispatchQueue but renames the static member <br>&gt;&gt;&gt; // DispatchQueue.main, to DispatchQueue.mainQueue<br>&gt;&gt;&gt; import Dispatch.DispatchQueue renaming (DispatchQueue.Type.main to: DispatchQueue.Type.<br>&gt;&gt;&gt; mainQueue)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Renaming can also rename modules.  All members of UIKit have to be qualified with<br>&gt;&gt;&gt; // `UI` now.<br>&gt;&gt;&gt; import UIKit renaming (UIKit, to: UI)<br>&gt;&gt;&gt; Import directives chain to one another and can be used to create a fine-grained module import:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Imports all of Foundation except `DateFormatter` and renames `Cache` to `LRUCache`<br>&gt;&gt;&gt; import Foundation<br>&gt;&gt;&gt; hiding (DateFormatter) renaming (Cache to: LRUCache)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Imports SCNNode except SCNNode.init(mdlObject:) and renames `.description` to<br>&gt;&gt;&gt; // `.nodeDescription` <br>&gt;&gt;&gt; import SceneKit<br>&gt;&gt;&gt; using (SCNNode) <br>&gt;&gt;&gt;                renaming (SCNNode<br>&gt;&gt;&gt; .description, to: SCNNode.<br>&gt;&gt;&gt; nodeDescription)<br>&gt;&gt;&gt;                hiding (SCNNode<br>&gt;&gt;&gt; .init(mdlObject:))<br>&gt;&gt;&gt; Directive chaining occurs left-to-right:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // This says to 1) Hide nothing 2) Use nothing 3) rename Int to INT.  It is invalid<br>&gt;&gt;&gt; // because 1) We will show everything 2) Then hide everything 3) Therefore Int is unavailable, error.<br>&gt;&gt;&gt; import Swift hiding () using () renaming (Int<br>&gt;&gt;&gt; , to: INT)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // This says to 1) Use Int 2) Hide String 3) rename Double to Triple.  It is invalid<br>&gt;&gt;&gt; // because 1) Int is available 2) String is not, error. 3) Double is unavailable, error.<br>&gt;&gt;&gt; import Swift using (Int) hiding (String) renaming (Double<br>&gt;&gt;&gt; , to: Triple)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Valid.  This will be merged as `using (Int)`<br>&gt;&gt;&gt; import Swift using () using (Int<br>&gt;&gt;&gt; )<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Valid.  This will be merged as `hiding (String, Double)`<br>&gt;&gt;&gt; import Swift hiding (String) hiding (Double<br>&gt;&gt;&gt; ) hiding ()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Valid (if redundant). This will be merged as `using ()`<br>&gt;&gt;&gt; import Swift using (String) hiding (String)<br>&gt;&gt;&gt; Module scope is delimited by the keyword module followed by a fully qualified name and must occur as the first declaration in a file. For example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // ./Math/Integers/Arithmetic.swift<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; module Math<br>&gt;&gt;&gt; .Integers.<br>&gt;&gt;&gt; Arithmetic<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public protocol<br>&gt;&gt;&gt; _IntegerArithmetic {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public struct<br>&gt;&gt;&gt; _Abs {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; @_versioned<br>&gt;&gt;&gt; internal func _abs&lt;Args&gt;(_ args: Args) -&gt;<br>&gt;&gt;&gt; (_Abs, Args) {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // ./Math/Integers.swift<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; module Math<br>&gt;&gt;&gt; .<br>&gt;&gt;&gt; Integers<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // _abs is visible in this module and all others within the project, <br>&gt;&gt;&gt; // but is not exported along with it.<br>&gt;&gt;&gt; internal import Math.Integers.Arithmetic<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public protocol IntegerArithmetic : _IntegerArithmetic, Comparable<br>&gt;&gt;&gt; {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public protocol SignedNumber : Comparable<br>&gt;&gt;&gt; , ExpressibleByIntegerLiteral {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Math.swift<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; module Math<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Exports the entire public contents of Math.Integers, but nothing in <br>&gt;&gt;&gt; // Math.Integers.Arithmetic.<br>&gt;&gt;&gt; public import Math.Integers<br>&gt;&gt;&gt; Modules names are tied to a directory structure that describes their location relative to the current module and it will now be an error to violate this rule. For example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; module String // lives in ./String.swift<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; module <br>&gt;&gt;&gt; String.Core // lives in ./String/Core.swift<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; module <br>&gt;&gt;&gt; String.Core.Internals.Do.You.Even.Write // lives in ./String/Core/Internals/Do/You/Even/Write.swift<br>&gt;&gt;&gt; Existing projects that do not adopt these rules will still retain their implicit module name (usually defined as the name of the framework or application that is being built) and may continue to use whatever directory structure they wish, however they may not declare any explicit modules.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This proposal also solves the problem of module export. A module that is imported without an access level modifier will default to an internal import per usual. However, when it is useful to fully expose the public content of submodules to a client, a public modifier can be used. Similarly, when it is useful to access internal or [file]private APIs, but not expose them to clients, those access modifiers may be used. The rule of thumb is: Only identifiers that are at least as visible as the qualifier on the import make for valid import declarations. For example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // A submodule declaring a `private` class that gets imported with <br>&gt;&gt;&gt; // an `internal` qualifier with a `using` directive is an invalid import <br>&gt;&gt;&gt; // declaration.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; module Foo<br>&gt;&gt;&gt; .<br>&gt;&gt;&gt; Bar<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; private class<br>&gt;&gt;&gt; PrivateThing {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; module Foo<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Error: PrivateThing not visible, use `private import`<br>&gt;&gt;&gt; import Foo.Bar using (PrivateThing) <br>&gt;&gt;&gt; // However, a submodule declaring a `public` struct that gets imported with <br>&gt;&gt;&gt; // an `private` qualifier is a valid import declaration.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; module Foo<br>&gt;&gt;&gt; .<br>&gt;&gt;&gt; Bar<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public class<br>&gt;&gt;&gt; PublicThing {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; module Foo<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // All good!  Foo can see Foo.Bar.PrivateThing.<br>&gt;&gt;&gt; private import Foo.Bar using (PublicThing) <br>&gt;&gt;&gt; Because import directives are file-local, they will never be exported along with a public import and will default to exporting the entire contents of the module as though you had never declared them.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // In this file and this file alone, the directives apply.  To the user<br>&gt;&gt;&gt; // of this module, it is as though this declaration were simply:<br>&gt;&gt;&gt; // public import Foundation.Date<br>&gt;&gt;&gt; public import Foundation.Date hiding (Date.init<br>&gt;&gt;&gt; ()) <br>&gt;&gt;&gt;                              renaming (Date<br>&gt;&gt;&gt; .Type.<br>&gt;&gt;&gt; distantPast, <br>&gt;&gt;&gt;                                        to: Date<br>&gt;&gt;&gt; .Type.<br>&gt;&gt;&gt; letsGoLivingInThePast,<br>&gt;&gt;&gt;                                        Date<br>&gt;&gt;&gt; .Type.<br>&gt;&gt;&gt; timeIntervalSinceReferenceDate, <br>&gt;&gt;&gt;                                        to: Date<br>&gt;&gt;&gt; .Type.<br>&gt;&gt;&gt; startOfTheUniverse)<br>&gt;&gt;&gt;                              renaming (Date<br>&gt;&gt;&gt; .Type.&lt;, to: Date.Type.&lt;&lt;&lt;&lt;&lt;)<br>&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Existing code that is using qualified module import syntax (import {func|class|typealias|class|struct|enum|protocol} &lt;qualified-name&gt;) will be deprecated. Code that is not organized into modules will remain unaffected and organized into one contiguous top-level module. However, it is strongly recommended that frameworks be decomposed and reorganized around the new module system.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As a case study, the public interface to the standard library appears to already be mostly broken down into submodules as described in GroupInfo.json.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Code that is defined in modulemaps already defines a module structure that can be imported directly into this scheme.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Module export can also be placed on the module declaration itself. The relevant parts of the grammar that have changed are below with an example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; module-decl -&gt; &lt;access-level-modifier&gt; module &lt;module-path&gt;<br>&gt;&gt;&gt; import-decl -&gt; import &lt;module-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; private module String.Core.<br>&gt;&gt;&gt; Internals<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Shh, it&#39;s a secret.<br>&gt;&gt;&gt; While this style makes it immediately obvious to the library author which modules are public or private, it causes the consumer problems because submodule exports are no longer explicit and are entirely ad-hoc. In the interest of enabling, for one, users of IDEs to drill into public submodules, making export local to import seems more appropriate.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160719/a0d79c00/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Proposal] Qualified Imports and Modules</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>July 19, 2016 at 01:00:00am</p></header><div class="content"><p>Haskell has much more than import everything and import itemized.<br>https://wiki.haskell.org/Import<br></p><p>Hiding is important for avoiding collisions of name and/or function.<br></p><p>On Mon, Jul 18, 2016 at 9:19 PM, Joe Groff via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Our import story definitely needs work, and this is a step in the right<br>&gt; direction. Thanks for working on this! Some comments:<br>&gt;<br>&gt; - The import changes can be separated from the submodule issues. Enhancing<br>&gt; imports is IMO more important, and is source-breaking today, whereas<br>&gt; &#39;module &#39; declarations and submodules can be added later. I&#39;d suggest<br>&gt; breaking this into two proposals.<br>&gt; - I think the `import` design you propose is a bit more complicated than<br>&gt; it needs to be. Python and Haskell get by just having &quot;import everything&quot;<br>&gt; and &quot;import itemized (with aliases)&quot;. I don&#39;t see the need for &#39;hiding&#39;; if<br>&gt; you have a rule that itemized imports get priority over import-everything,<br>&gt; then that covers the most important use case of selectively shadowing one<br>&gt; module&#39;s imports with another. Bikeshed-wise, I don&#39;t see much reason to<br>&gt; veer from the Java/Haskell-ish template of:<br>&gt;<br>&gt; import Foo.* // import everything from module Foo<br>&gt; import Foo.(x, y, z as zed) // import x, y, and z from foo, renaming Foo.z<br>&gt; to zed<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt; &gt; On Jul 18, 2016, at 2:09 PM, Robert Widmann via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Hello all,<br>&gt; &gt;<br>&gt; &gt; TJ Usiyan, Harlan Haskins, and I have been working on a proposal to<br>&gt; rework qualified imports and introduce an explicit module system to Swift<br>&gt; that we’d like to publish for your viewing pleasure.<br>&gt; &gt;<br>&gt; &gt; The initial impetus was set out in a radar (rdar://17630570) I sent<br>&gt; fairly early on that didn’t receive a response, so I started a<br>&gt; swift-evolution thread discussing the basics of this proposal.  It has been<br>&gt; refined and expanded a bit to include an effort to make Swift modules<br>&gt; explicit and updated with the feedback of that first thread.  Contents of<br>&gt; the proposal are inline and can also be had as a gist or on Github.<br>&gt; &gt;<br>&gt; &gt; Cheers,<br>&gt; &gt;<br>&gt; &gt; ~Robert Widmann<br>&gt; &gt;<br>&gt; &gt; Qualified Imports and Modules<br>&gt; &gt;<br>&gt; &gt;       • Proposal: SE-NNNN<br>&gt; &gt;       • Authors: Robert Widmann, Harlan Haskins, TJ Usiyan<br>&gt; &gt;       • Status: Awaiting review<br>&gt; &gt;       • Review manager: TBD<br>&gt; &gt; Introduction<br>&gt; &gt;<br>&gt; &gt; We propose a complete overhaul of the qualified imports syntax and<br>&gt; semantics and the introduction of a module system.<br>&gt; &gt;<br>&gt; &gt; Motivation<br>&gt; &gt;<br>&gt; &gt; Swift code is modular by default. However, it is not clear how to<br>&gt; decompose existing modules further into submodules. In addition, it is<br>&gt; difficult to tell how importing a module affects its export to consumers of<br>&gt; a library. This leads many to either fake namespaces with enums, attempt to<br>&gt; structure Swift code with modulemaps, or use a large amount of<br>&gt; version-control submodules. All of these can be rolled into one complete<br>&gt; package in the form of a comprehensive rethink of the qualified import<br>&gt; system and the introduction of a module system.<br>&gt; &gt;<br>&gt; &gt; Proposed solution<br>&gt; &gt;<br>&gt; &gt; Modules will now become an explicit part of working with canonical Swift<br>&gt; code. The grammar and semantics of qualified imports will change completely<br>&gt; with the addition of import qualifiers and import directives. We also<br>&gt; introduce three new contextual keywords: using, hiding, and renaming, to<br>&gt; facilitate fine-grained usage of module contents.<br>&gt; &gt;<br>&gt; &gt; Detailed design<br>&gt; &gt;<br>&gt; &gt; Qualified import syntax will be revised to the following<br>&gt; &gt;<br>&gt; &gt; module-decl -&gt; module &lt;module-path&gt;<br>&gt; &gt; import-decl -&gt; &lt;access-level-modifier&gt; import &lt;module-path&gt; &lt;(opt)<br>&gt; import-directive-list&gt;<br>&gt; &gt; module-path -&gt; &lt;identifier&gt;<br>&gt; &gt;             -&gt; &lt;identifier&gt;.&lt;import-path&gt;<br>&gt; &gt; import-directive-list -&gt; &lt;import-directive&gt;<br>&gt; &gt;                       -&gt; &lt;import-directive&gt; &lt;import-directive-list&gt;<br>&gt; &gt; import-directive -&gt; using (&lt;identifier&gt;, ...)<br>&gt; &gt;                  -&gt; hiding (&lt;identifier&gt;, ...)<br>&gt; &gt;                  -&gt; renaming (&lt;identifier&gt;, to: &lt;identifier&gt;, ...)<br>&gt; &gt;<br>&gt; &gt; This introduces the concept of an import directive. An import directive<br>&gt; is a file-local modification of an imported identifier. A directive can be<br>&gt; one of 3 operations:<br>&gt; &gt;<br>&gt; &gt; 1) using: The using directive is followed by a list of identifiers<br>&gt; within the imported module that should be exposed to this file.<br>&gt; &gt;<br>&gt; &gt; // The only visible parts of Foundation in this file are<br>&gt; &gt; // Date.init(), Date.hashValue, and Date.description.<br>&gt; &gt; import Foundation.Date using (Date.init(), Date.hashValue,<br>&gt; Date.description)<br>&gt; &gt; 2) hiding: The hiding directive is followed by a list of identifiers<br>&gt; within the imported module that should be hidden from this file.<br>&gt; &gt;<br>&gt; &gt; // Imports all of Foundation.Date except `Date.compare()`<br>&gt; &gt; import Foundation.Date hiding (Date.compare())<br>&gt; &gt; 3) renaming: The renaming directive is followed by a list of identifiers<br>&gt; separated by to: that should be exposed to this file but renamed.<br>&gt; &gt;<br>&gt; &gt; // Imports all of Dispatch.DispatchQueue but renames the static member<br>&gt; &gt; // DispatchQueue.main, to DispatchQueue.mainQueue<br>&gt; &gt; import Dispatch.DispatchQueue renaming (DispatchQueue.Type.main to:<br>&gt; DispatchQueue.Type.<br>&gt; &gt; mainQueue)<br>&gt; &gt;<br>&gt; &gt; // Renaming can also rename modules.  All members of UIKit have to be<br>&gt; qualified with<br>&gt; &gt; // `UI` now.<br>&gt; &gt; import UIKit renaming (UIKit, to: UI)<br>&gt; &gt; Import directives chain to one another and can be used to create a<br>&gt; fine-grained module import:<br>&gt; &gt;<br>&gt; &gt; // Imports all of Foundation except `DateFormatter` and renames `Cache`<br>&gt; to `LRUCache`<br>&gt; &gt; import Foundation<br>&gt; &gt;  hiding (DateFormatter) renaming (Cache to: LRUCache)<br>&gt; &gt;<br>&gt; &gt; // Imports SCNNode except SCNNode.init(mdlObject:) and renames<br>&gt; `.description` to<br>&gt; &gt; // `.nodeDescription`<br>&gt; &gt; import SceneKit<br>&gt; &gt;  using (SCNNode)<br>&gt; &gt;                 renaming (SCNNode<br>&gt; &gt; .description, to: SCNNode.<br>&gt; &gt; nodeDescription)<br>&gt; &gt;                 hiding (SCNNode<br>&gt; &gt; .init(mdlObject:))<br>&gt; &gt; Directive chaining occurs left-to-right:<br>&gt; &gt;<br>&gt; &gt; // This says to 1) Hide nothing 2) Use nothing 3) rename Int to INT.  It<br>&gt; is invalid<br>&gt; &gt; // because 1) We will show everything 2) Then hide everything 3)<br>&gt; Therefore Int is unavailable, error.<br>&gt; &gt; import Swift hiding () using () renaming (Int<br>&gt; &gt; , to: INT)<br>&gt; &gt;<br>&gt; &gt; // This says to 1) Use Int 2) Hide String 3) rename Double to Triple.<br>&gt; It is invalid<br>&gt; &gt; // because 1) Int is available 2) String is not, error. 3) Double is<br>&gt; unavailable, error.<br>&gt; &gt; import Swift using (Int) hiding (String) renaming (Double<br>&gt; &gt; , to: Triple)<br>&gt; &gt;<br>&gt; &gt; // Valid.  This will be merged as `using (Int)`<br>&gt; &gt; import Swift using () using (Int<br>&gt; &gt; )<br>&gt; &gt;<br>&gt; &gt; // Valid.  This will be merged as `hiding (String, Double)`<br>&gt; &gt; import Swift hiding (String) hiding (Double<br>&gt; &gt; ) hiding ()<br>&gt; &gt;<br>&gt; &gt; // Valid (if redundant). This will be merged as `using ()`<br>&gt; &gt; import Swift using (String) hiding (String)<br>&gt; &gt; Module scope is delimited by the keyword module followed by a fully<br>&gt; qualified name and must occur as the first declaration in a file. For<br>&gt; example:<br>&gt; &gt;<br>&gt; &gt; // ./Math/Integers/Arithmetic.swift<br>&gt; &gt;<br>&gt; &gt; module Math<br>&gt; &gt; .Integers.<br>&gt; &gt; Arithmetic<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; public protocol<br>&gt; &gt;  _IntegerArithmetic {}<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; public struct<br>&gt; &gt;  _Abs {}<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; @_versioned<br>&gt; &gt; internal func _abs&lt;Args&gt;(_ args: Args) -&gt;<br>&gt; &gt;  (_Abs, Args) {}<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; // ./Math/Integers.swift<br>&gt; &gt;<br>&gt; &gt; module Math<br>&gt; &gt; .<br>&gt; &gt; Integers<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; // _abs is visible in this module and all others within the project,<br>&gt; &gt; // but is not exported along with it.<br>&gt; &gt; internal import Math.Integers.Arithmetic<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; public protocol IntegerArithmetic : _IntegerArithmetic, Comparable<br>&gt; &gt;  {}<br>&gt; &gt;<br>&gt; &gt; public protocol SignedNumber : Comparable<br>&gt; &gt; , ExpressibleByIntegerLiteral {}<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; // Math.swift<br>&gt; &gt;<br>&gt; &gt; module Math<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; // Exports the entire public contents of Math.Integers, but nothing in<br>&gt; &gt; // Math.Integers.Arithmetic.<br>&gt; &gt; public import Math.Integers<br>&gt; &gt; Modules names are tied to a directory structure that describes their<br>&gt; location relative to the current module and it will now be an error to<br>&gt; violate this rule. For example:<br>&gt; &gt;<br>&gt; &gt; module String // lives in ./String.swift<br>&gt; &gt;<br>&gt; &gt; module<br>&gt; &gt; String.Core // lives in ./String/Core.swift<br>&gt; &gt;<br>&gt; &gt; module<br>&gt; &gt; String.Core.Internals.Do.You.Even.Write // lives in<br>&gt; ./String/Core/Internals/Do/You/Even/Write.swift<br>&gt; &gt; Existing projects that do not adopt these rules will still retain their<br>&gt; implicit module name (usually defined as the name of the framework or<br>&gt; application that is being built) and may continue to use whatever directory<br>&gt; structure they wish, however they may not declare any explicit modules.<br>&gt; &gt;<br>&gt; &gt; This proposal also solves the problem of module export. A module that is<br>&gt; imported without an access level modifier will default to an internal<br>&gt; import per usual. However, when it is useful to fully expose the public<br>&gt; content of submodules to a client, a public modifier can be used.<br>&gt; Similarly, when it is useful to access internal or [file]private APIs, but<br>&gt; not expose them to clients, those access modifiers may be used. The rule of<br>&gt; thumb is: Only identifiers that are at least as visible as the qualifier on<br>&gt; the import make for valid import declarations. For example:<br>&gt; &gt;<br>&gt; &gt; // A submodule declaring a `private` class that gets imported with<br>&gt; &gt; // an `internal` qualifier with a `using` directive is an invalid import<br>&gt; &gt; // declaration.<br>&gt; &gt;<br>&gt; &gt; module Foo<br>&gt; &gt; .<br>&gt; &gt; Bar<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; private class<br>&gt; &gt;  PrivateThing {}<br>&gt; &gt;<br>&gt; &gt; module Foo<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; // Error: PrivateThing not visible, use `private import`<br>&gt; &gt; import Foo.Bar using (PrivateThing)<br>&gt; &gt; // However, a submodule declaring a `public` struct that gets imported<br>&gt; with<br>&gt; &gt; // an `private` qualifier is a valid import declaration.<br>&gt; &gt;<br>&gt; &gt; module Foo<br>&gt; &gt; .<br>&gt; &gt; Bar<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; public class<br>&gt; &gt;  PublicThing {}<br>&gt; &gt;<br>&gt; &gt; module Foo<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; // All good!  Foo can see Foo.Bar.PrivateThing.<br>&gt; &gt; private import Foo.Bar using (PublicThing)<br>&gt; &gt; Because import directives are file-local, they will never be exported<br>&gt; along with a public import and will default to exporting the entire<br>&gt; contents of the module as though you had never declared them.<br>&gt; &gt;<br>&gt; &gt; // In this file and this file alone, the directives apply.  To the user<br>&gt; &gt; // of this module, it is as though this declaration were simply:<br>&gt; &gt; // public import Foundation.Date<br>&gt; &gt; public import Foundation.Date hiding (Date.init<br>&gt; &gt; ())<br>&gt; &gt;                               renaming (Date<br>&gt; &gt; .Type.<br>&gt; &gt; distantPast,<br>&gt; &gt;                                         to: Date<br>&gt; &gt; .Type.<br>&gt; &gt; letsGoLivingInThePast,<br>&gt; &gt;                                         Date<br>&gt; &gt; .Type.<br>&gt; &gt; timeIntervalSinceReferenceDate,<br>&gt; &gt;                                         to: Date<br>&gt; &gt; .Type.<br>&gt; &gt; startOfTheUniverse)<br>&gt; &gt;                               renaming (Date<br>&gt; &gt; .Type.&lt;, to: Date.Type.&lt;&lt;&lt;&lt;&lt;)<br>&gt; &gt; Impact on existing code<br>&gt; &gt;<br>&gt; &gt; Existing code that is using qualified module import syntax (import<br>&gt; {func|class|typealias|class|struct|enum|protocol} &lt;qualified-name&gt;) will be<br>&gt; deprecated. Code that is not organized into modules will remain unaffected<br>&gt; and organized into one contiguous top-level module. However, it is strongly<br>&gt; recommended that frameworks be decomposed and reorganized around the new<br>&gt; module system.<br>&gt; &gt;<br>&gt; &gt; As a case study, the public interface to the standard library appears to<br>&gt; already be mostly broken down into submodules as described in<br>&gt; GroupInfo.json.<br>&gt; &gt;<br>&gt; &gt; Code that is defined in modulemaps already defines a module structure<br>&gt; that can be imported directly into this scheme.<br>&gt; &gt;<br>&gt; &gt; Alternatives considered<br>&gt; &gt;<br>&gt; &gt; Module export can also be placed on the module declaration itself. The<br>&gt; relevant parts of the grammar that have changed are below with an example:<br>&gt; &gt;<br>&gt; &gt; module-decl -&gt; &lt;access-level-modifier&gt; module &lt;module-path&gt;<br>&gt; &gt; import-decl -&gt; import &lt;module-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt; &gt;<br>&gt; &gt; private module String.Core.<br>&gt; &gt; Internals<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; // Shh, it&#39;s a secret.<br>&gt; &gt; While this style makes it immediately obvious to the library author<br>&gt; which modules are public or private, it causes the consumer problems<br>&gt; because submodule exports are no longer explicit and are entirely ad-hoc.<br>&gt; In the interest of enabling, for one, users of IDEs to drill into public<br>&gt; submodules, making export local to import seems more appropriate.<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160719/1791e99a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Proposal] Qualified Imports and Modules</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>July 18, 2016 at 10:00:00pm</p></header><div class="content"><p>There is no effective difference between renaming to a dummy name and hiding. In fact, renaming (Int, to: _) could do that.<br></p><p>Félix<br></p><p>&gt; Le 18 juil. 2016 à 22:04:44, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Haskell has much more than import everything and import itemized. https://wiki.haskell.org/Import &lt;https://wiki.haskell.org/Import&gt; <br>&gt; <br>&gt; Hiding is important for avoiding collisions of name and/or function.<br>&gt; <br>&gt; On Mon, Jul 18, 2016 at 9:19 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Our import story definitely needs work, and this is a step in the right direction. Thanks for working on this! Some comments:<br>&gt; <br>&gt; - The import changes can be separated from the submodule issues. Enhancing imports is IMO more important, and is source-breaking today, whereas &#39;module &#39; declarations and submodules can be added later. I&#39;d suggest breaking this into two proposals.<br>&gt; - I think the `import` design you propose is a bit more complicated than it needs to be. Python and Haskell get by just having &quot;import everything&quot; and &quot;import itemized (with aliases)&quot;. I don&#39;t see the need for &#39;hiding&#39;; if you have a rule that itemized imports get priority over import-everything, then that covers the most important use case of selectively shadowing one module&#39;s imports with another. Bikeshed-wise, I don&#39;t see much reason to veer from the Java/Haskell-ish template of:<br>&gt; <br>&gt; import Foo.* // import everything from module Foo<br>&gt; import Foo.(x, y, z as zed) // import x, y, and z from foo, renaming Foo.z to zed<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; &gt; On Jul 18, 2016, at 2:09 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Hello all,<br>&gt; &gt;<br>&gt; &gt; TJ Usiyan, Harlan Haskins, and I have been working on a proposal to rework qualified imports and introduce an explicit module system to Swift that we’d like to publish for your viewing pleasure.<br>&gt; &gt;<br>&gt; &gt; The initial impetus was set out in a radar (rdar://17630570) I sent fairly early on that didn’t receive a response, so I started a swift-evolution thread discussing the basics of this proposal.  It has been refined and expanded a bit to include an effort to make Swift modules explicit and updated with the feedback of that first thread.  Contents of the proposal are inline and can also be had as a gist or on Github.<br>&gt; &gt;<br>&gt; &gt; Cheers,<br>&gt; &gt;<br>&gt; &gt; ~Robert Widmann<br>&gt; &gt;<br>&gt; &gt; Qualified Imports and Modules<br>&gt; &gt;<br>&gt; &gt;       • Proposal: SE-NNNN<br>&gt; &gt;       • Authors: Robert Widmann, Harlan Haskins, TJ Usiyan<br>&gt; &gt;       • Status: Awaiting review<br>&gt; &gt;       • Review manager: TBD<br>&gt; &gt; Introduction<br>&gt; &gt;<br>&gt; &gt; We propose a complete overhaul of the qualified imports syntax and semantics and the introduction of a module system.<br>&gt; &gt;<br>&gt; &gt; Motivation<br>&gt; &gt;<br>&gt; &gt; Swift code is modular by default. However, it is not clear how to decompose existing modules further into submodules. In addition, it is difficult to tell how importing a module affects its export to consumers of a library. This leads many to either fake namespaces with enums, attempt to structure Swift code with modulemaps, or use a large amount of version-control submodules. All of these can be rolled into one complete package in the form of a comprehensive rethink of the qualified import system and the introduction of a module system.<br>&gt; &gt;<br>&gt; &gt; Proposed solution<br>&gt; &gt;<br>&gt; &gt; Modules will now become an explicit part of working with canonical Swift code. The grammar and semantics of qualified imports will change completely with the addition of import qualifiers and import directives. We also introduce three new contextual keywords: using, hiding, and renaming, to facilitate fine-grained usage of module contents.<br>&gt; &gt;<br>&gt; &gt; Detailed design<br>&gt; &gt;<br>&gt; &gt; Qualified import syntax will be revised to the following<br>&gt; &gt;<br>&gt; &gt; module-decl -&gt; module &lt;module-path&gt;<br>&gt; &gt; import-decl -&gt; &lt;access-level-modifier&gt; import &lt;module-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt; &gt; module-path -&gt; &lt;identifier&gt;<br>&gt; &gt;             -&gt; &lt;identifier&gt;.&lt;import-path&gt;<br>&gt; &gt; import-directive-list -&gt; &lt;import-directive&gt;<br>&gt; &gt;                       -&gt; &lt;import-directive&gt; &lt;import-directive-list&gt;<br>&gt; &gt; import-directive -&gt; using (&lt;identifier&gt;, ...)<br>&gt; &gt;                  -&gt; hiding (&lt;identifier&gt;, ...)<br>&gt; &gt;                  -&gt; renaming (&lt;identifier&gt;, to: &lt;identifier&gt;, ...)<br>&gt; &gt;<br>&gt; &gt; This introduces the concept of an import directive. An import directive is a file-local modification of an imported identifier. A directive can be one of 3 operations:<br>&gt; &gt;<br>&gt; &gt; 1) using: The using directive is followed by a list of identifiers within the imported module that should be exposed to this file.<br>&gt; &gt;<br>&gt; &gt; // The only visible parts of Foundation in this file are<br>&gt; &gt; // Date.init(), Date.hashValue, and Date.description.<br>&gt; &gt; import Foundation.Date using (Date.init(), Date.hashValue, Date.description)<br>&gt; &gt; 2) hiding: The hiding directive is followed by a list of identifiers within the imported module that should be hidden from this file.<br>&gt; &gt;<br>&gt; &gt; // Imports all of Foundation.Date except `Date.compare()`<br>&gt; &gt; import Foundation.Date hiding (Date.compare())<br>&gt; &gt; 3) renaming: The renaming directive is followed by a list of identifiers separated by to: that should be exposed to this file but renamed.<br>&gt; &gt;<br>&gt; &gt; // Imports all of Dispatch.DispatchQueue but renames the static member<br>&gt; &gt; // DispatchQueue.main, to DispatchQueue.mainQueue<br>&gt; &gt; import Dispatch.DispatchQueue renaming (DispatchQueue.Type.main to: DispatchQueue.Type.<br>&gt; &gt; mainQueue)<br>&gt; &gt;<br>&gt; &gt; // Renaming can also rename modules.  All members of UIKit have to be qualified with<br>&gt; &gt; // `UI` now.<br>&gt; &gt; import UIKit renaming (UIKit, to: UI)<br>&gt; &gt; Import directives chain to one another and can be used to create a fine-grained module import:<br>&gt; &gt;<br>&gt; &gt; // Imports all of Foundation except `DateFormatter` and renames `Cache` to `LRUCache`<br>&gt; &gt; import Foundation<br>&gt; &gt;  hiding (DateFormatter) renaming (Cache to: LRUCache)<br>&gt; &gt;<br>&gt; &gt; // Imports SCNNode except SCNNode.init(mdlObject:) and renames `.description` to<br>&gt; &gt; // `.nodeDescription`<br>&gt; &gt; import SceneKit<br>&gt; &gt;  using (SCNNode)<br>&gt; &gt;                 renaming (SCNNode<br>&gt; &gt; .description, to: SCNNode.<br>&gt; &gt; nodeDescription)<br>&gt; &gt;                 hiding (SCNNode<br>&gt; &gt; .init(mdlObject:))<br>&gt; &gt; Directive chaining occurs left-to-right:<br>&gt; &gt;<br>&gt; &gt; // This says to 1) Hide nothing 2) Use nothing 3) rename Int to INT.  It is invalid<br>&gt; &gt; // because 1) We will show everything 2) Then hide everything 3) Therefore Int is unavailable, error.<br>&gt; &gt; import Swift hiding () using () renaming (Int<br>&gt; &gt; , to: INT)<br>&gt; &gt;<br>&gt; &gt; // This says to 1) Use Int 2) Hide String 3) rename Double to Triple.  It is invalid<br>&gt; &gt; // because 1) Int is available 2) String is not, error. 3) Double is unavailable, error.<br>&gt; &gt; import Swift using (Int) hiding (String) renaming (Double<br>&gt; &gt; , to: Triple)<br>&gt; &gt;<br>&gt; &gt; // Valid.  This will be merged as `using (Int)`<br>&gt; &gt; import Swift using () using (Int<br>&gt; &gt; )<br>&gt; &gt;<br>&gt; &gt; // Valid.  This will be merged as `hiding (String, Double)`<br>&gt; &gt; import Swift hiding (String) hiding (Double<br>&gt; &gt; ) hiding ()<br>&gt; &gt;<br>&gt; &gt; // Valid (if redundant). This will be merged as `using ()`<br>&gt; &gt; import Swift using (String) hiding (String)<br>&gt; &gt; Module scope is delimited by the keyword module followed by a fully qualified name and must occur as the first declaration in a file. For example:<br>&gt; &gt;<br>&gt; &gt; // ./Math/Integers/Arithmetic.swift<br>&gt; &gt;<br>&gt; &gt; module Math<br>&gt; &gt; .Integers.<br>&gt; &gt; Arithmetic<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; public protocol<br>&gt; &gt;  _IntegerArithmetic {}<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; public struct<br>&gt; &gt;  _Abs {}<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; @_versioned<br>&gt; &gt; internal func _abs&lt;Args&gt;(_ args: Args) -&gt;<br>&gt; &gt;  (_Abs, Args) {}<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; // ./Math/Integers.swift<br>&gt; &gt;<br>&gt; &gt; module Math<br>&gt; &gt; .<br>&gt; &gt; Integers<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; // _abs is visible in this module and all others within the project,<br>&gt; &gt; // but is not exported along with it.<br>&gt; &gt; internal import Math.Integers.Arithmetic<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; public protocol IntegerArithmetic : _IntegerArithmetic, Comparable<br>&gt; &gt;  {}<br>&gt; &gt;<br>&gt; &gt; public protocol SignedNumber : Comparable<br>&gt; &gt; , ExpressibleByIntegerLiteral {}<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; // Math.swift<br>&gt; &gt;<br>&gt; &gt; module Math<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; // Exports the entire public contents of Math.Integers, but nothing in<br>&gt; &gt; // Math.Integers.Arithmetic.<br>&gt; &gt; public import Math.Integers<br>&gt; &gt; Modules names are tied to a directory structure that describes their location relative to the current module and it will now be an error to violate this rule. For example:<br>&gt; &gt;<br>&gt; &gt; module String // lives in ./String.swift<br>&gt; &gt;<br>&gt; &gt; module<br>&gt; &gt; String.Core // lives in ./String/Core.swift<br>&gt; &gt;<br>&gt; &gt; module<br>&gt; &gt; String.Core.Internals.Do.You.Even.Write // lives in ./String/Core/Internals/Do/You/Even/Write.swift<br>&gt; &gt; Existing projects that do not adopt these rules will still retain their implicit module name (usually defined as the name of the framework or application that is being built) and may continue to use whatever directory structure they wish, however they may not declare any explicit modules.<br>&gt; &gt;<br>&gt; &gt; This proposal also solves the problem of module export. A module that is imported without an access level modifier will default to an internal import per usual. However, when it is useful to fully expose the public content of submodules to a client, a public modifier can be used. Similarly, when it is useful to access internal or [file]private APIs, but not expose them to clients, those access modifiers may be used. The rule of thumb is: Only identifiers that are at least as visible as the qualifier on the import make for valid import declarations. For example:<br>&gt; &gt;<br>&gt; &gt; // A submodule declaring a `private` class that gets imported with<br>&gt; &gt; // an `internal` qualifier with a `using` directive is an invalid import<br>&gt; &gt; // declaration.<br>&gt; &gt;<br>&gt; &gt; module Foo<br>&gt; &gt; .<br>&gt; &gt; Bar<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; private class<br>&gt; &gt;  PrivateThing {}<br>&gt; &gt;<br>&gt; &gt; module Foo<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; // Error: PrivateThing not visible, use `private import`<br>&gt; &gt; import Foo.Bar using (PrivateThing)<br>&gt; &gt; // However, a submodule declaring a `public` struct that gets imported with<br>&gt; &gt; // an `private` qualifier is a valid import declaration.<br>&gt; &gt;<br>&gt; &gt; module Foo<br>&gt; &gt; .<br>&gt; &gt; Bar<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; public class<br>&gt; &gt;  PublicThing {}<br>&gt; &gt;<br>&gt; &gt; module Foo<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; // All good!  Foo can see Foo.Bar.PrivateThing.<br>&gt; &gt; private import Foo.Bar using (PublicThing)<br>&gt; &gt; Because import directives are file-local, they will never be exported along with a public import and will default to exporting the entire contents of the module as though you had never declared them.<br>&gt; &gt;<br>&gt; &gt; // In this file and this file alone, the directives apply.  To the user<br>&gt; &gt; // of this module, it is as though this declaration were simply:<br>&gt; &gt; // public import Foundation.Date<br>&gt; &gt; public import Foundation.Date hiding (Date.init<br>&gt; &gt; ())<br>&gt; &gt;                               renaming (Date<br>&gt; &gt; .Type.<br>&gt; &gt; distantPast,<br>&gt; &gt;                                         to: Date<br>&gt; &gt; .Type.<br>&gt; &gt; letsGoLivingInThePast,<br>&gt; &gt;                                         Date<br>&gt; &gt; .Type.<br>&gt; &gt; timeIntervalSinceReferenceDate,<br>&gt; &gt;                                         to: Date<br>&gt; &gt; .Type.<br>&gt; &gt; startOfTheUniverse)<br>&gt; &gt;                               renaming (Date<br>&gt; &gt; .Type.&lt;, to: Date.Type.&lt;&lt;&lt;&lt;&lt;)<br>&gt; &gt; Impact on existing code<br>&gt; &gt;<br>&gt; &gt; Existing code that is using qualified module import syntax (import {func|class|typealias|class|struct|enum|protocol} &lt;qualified-name&gt;) will be deprecated. Code that is not organized into modules will remain unaffected and organized into one contiguous top-level module. However, it is strongly recommended that frameworks be decomposed and reorganized around the new module system.<br>&gt; &gt;<br>&gt; &gt; As a case study, the public interface to the standard library appears to already be mostly broken down into submodules as described in GroupInfo.json.<br>&gt; &gt;<br>&gt; &gt; Code that is defined in modulemaps already defines a module structure that can be imported directly into this scheme.<br>&gt; &gt;<br>&gt; &gt; Alternatives considered<br>&gt; &gt;<br>&gt; &gt; Module export can also be placed on the module declaration itself. The relevant parts of the grammar that have changed are below with an example:<br>&gt; &gt;<br>&gt; &gt; module-decl -&gt; &lt;access-level-modifier&gt; module &lt;module-path&gt;<br>&gt; &gt; import-decl -&gt; import &lt;module-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt; &gt;<br>&gt; &gt; private module String.Core.<br>&gt; &gt; Internals<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; // Shh, it&#39;s a secret.<br>&gt; &gt; While this style makes it immediately obvious to the library author which modules are public or private, it causes the consumer problems because submodule exports are no longer explicit and are entirely ad-hoc. In the interest of enabling, for one, users of IDEs to drill into public submodules, making export local to import seems more appropriate.<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160718/91af3ebd/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Proposal] Qualified Imports and Modules</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>July 20, 2016 at 08:00:00am</p></header><div class="content"><p>Totally agree with Joe here. I’d like to see a simplified version of the import design through ASAP. Mot people will quickly agree with it. The rest of the proposal is much more up for discussion IMHO.<br></p><p>&gt; On 19 Jul 2016, at 03:19, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Our import story definitely needs work, and this is a step in the right direction. Thanks for working on this! Some comments:<br>&gt; <br>&gt; - The import changes can be separated from the submodule issues. Enhancing imports is IMO more important, and is source-breaking today, whereas &#39;module &#39; declarations and submodules can be added later. I&#39;d suggest breaking this into two proposals.<br>&gt; - I think the `import` design you propose is a bit more complicated than it needs to be. Python and Haskell get by just having &quot;import everything&quot; and &quot;import itemized (with aliases)&quot;. I don&#39;t see the need for &#39;hiding&#39;; if you have a rule that itemized imports get priority over import-everything, then that covers the most important use case of selectively shadowing one module&#39;s imports with another. Bikeshed-wise, I don&#39;t see much reason to veer from the Java/Haskell-ish template of:<br>&gt; <br>&gt; import Foo.* // import everything from module Foo<br>&gt; import Foo.(x, y, z as zed) // import x, y, and z from foo, renaming Foo.z to zed<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; On Jul 18, 2016, at 2:09 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello all,<br>&gt;&gt; <br>&gt;&gt; TJ Usiyan, Harlan Haskins, and I have been working on a proposal to rework qualified imports and introduce an explicit module system to Swift that we’d like to publish for your viewing pleasure.<br>&gt;&gt; <br>&gt;&gt; The initial impetus was set out in a radar (rdar://17630570) I sent fairly early on that didn’t receive a response, so I started a swift-evolution thread discussing the basics of this proposal.  It has been refined and expanded a bit to include an effort to make Swift modules explicit and updated with the feedback of that first thread.  Contents of the proposal are inline and can also be had as a gist or on Github.<br>&gt;&gt; <br>&gt;&gt; Cheers,<br>&gt;&gt; <br>&gt;&gt; ~Robert Widmann<br>&gt;&gt; <br>&gt;&gt; Qualified Imports and Modules<br>&gt;&gt; <br>&gt;&gt; 	• Proposal: SE-NNNN<br>&gt;&gt; 	• Authors: Robert Widmann, Harlan Haskins, TJ Usiyan<br>&gt;&gt; 	• Status: Awaiting review<br>&gt;&gt; 	• Review manager: TBD<br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; We propose a complete overhaul of the qualified imports syntax and semantics and the introduction of a module system.<br>&gt;&gt; <br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; Swift code is modular by default. However, it is not clear how to decompose existing modules further into submodules. In addition, it is difficult to tell how importing a module affects its export to consumers of a library. This leads many to either fake namespaces with enums, attempt to structure Swift code with modulemaps, or use a large amount of version-control submodules. All of these can be rolled into one complete package in the form of a comprehensive rethink of the qualified import system and the introduction of a module system.<br>&gt;&gt; <br>&gt;&gt; Proposed solution<br>&gt;&gt; <br>&gt;&gt; Modules will now become an explicit part of working with canonical Swift code. The grammar and semantics of qualified imports will change completely with the addition of import qualifiers and import directives. We also introduce three new contextual keywords: using, hiding, and renaming, to facilitate fine-grained usage of module contents.<br>&gt;&gt; <br>&gt;&gt; Detailed design<br>&gt;&gt; <br>&gt;&gt; Qualified import syntax will be revised to the following<br>&gt;&gt; <br>&gt;&gt; module-decl -&gt; module &lt;module-path&gt;<br>&gt;&gt; import-decl -&gt; &lt;access-level-modifier&gt; import &lt;module-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt;&gt; module-path -&gt; &lt;identifier&gt;<br>&gt;&gt;            -&gt; &lt;identifier&gt;.&lt;import-path&gt;<br>&gt;&gt; import-directive-list -&gt; &lt;import-directive&gt;<br>&gt;&gt;                      -&gt; &lt;import-directive&gt; &lt;import-directive-list&gt;<br>&gt;&gt; import-directive -&gt; using (&lt;identifier&gt;, ...)<br>&gt;&gt;                 -&gt; hiding (&lt;identifier&gt;, ...)<br>&gt;&gt;                 -&gt; renaming (&lt;identifier&gt;, to: &lt;identifier&gt;, ...)<br>&gt;&gt; <br>&gt;&gt; This introduces the concept of an import directive. An import directive is a file-local modification of an imported identifier. A directive can be one of 3 operations:<br>&gt;&gt; <br>&gt;&gt; 1) using: The using directive is followed by a list of identifiers within the imported module that should be exposed to this file. <br>&gt;&gt; <br>&gt;&gt; // The only visible parts of Foundation in this file are <br>&gt;&gt; // Date.init(), Date.hashValue, and Date.description.<br>&gt;&gt; import Foundation.Date using (Date.init(), Date.hashValue, Date.description)<br>&gt;&gt; 2) hiding: The hiding directive is followed by a list of identifiers within the imported module that should be hidden from this file.<br>&gt;&gt; <br>&gt;&gt; // Imports all of Foundation.Date except `Date.compare()`<br>&gt;&gt; import Foundation.Date hiding (Date.compare())<br>&gt;&gt; 3) renaming: The renaming directive is followed by a list of identifiers separated by to: that should be exposed to this file but renamed. <br>&gt;&gt; <br>&gt;&gt; // Imports all of Dispatch.DispatchQueue but renames the static member <br>&gt;&gt; // DispatchQueue.main, to DispatchQueue.mainQueue<br>&gt;&gt; import Dispatch.DispatchQueue renaming (DispatchQueue.Type.main to: DispatchQueue.Type.<br>&gt;&gt; mainQueue)<br>&gt;&gt; <br>&gt;&gt; // Renaming can also rename modules.  All members of UIKit have to be qualified with<br>&gt;&gt; // `UI` now.<br>&gt;&gt; import UIKit renaming (UIKit, to: UI)<br>&gt;&gt; Import directives chain to one another and can be used to create a fine-grained module import:<br>&gt;&gt; <br>&gt;&gt; // Imports all of Foundation except `DateFormatter` and renames `Cache` to `LRUCache`<br>&gt;&gt; import Foundation<br>&gt;&gt; hiding (DateFormatter) renaming (Cache to: LRUCache)<br>&gt;&gt; <br>&gt;&gt; // Imports SCNNode except SCNNode.init(mdlObject:) and renames `.description` to<br>&gt;&gt; // `.nodeDescription` <br>&gt;&gt; import SceneKit<br>&gt;&gt; using (SCNNode) <br>&gt;&gt;                renaming (SCNNode<br>&gt;&gt; .description, to: SCNNode.<br>&gt;&gt; nodeDescription)<br>&gt;&gt;                hiding (SCNNode<br>&gt;&gt; .init(mdlObject:))<br>&gt;&gt; Directive chaining occurs left-to-right:<br>&gt;&gt; <br>&gt;&gt; // This says to 1) Hide nothing 2) Use nothing 3) rename Int to INT.  It is invalid<br>&gt;&gt; // because 1) We will show everything 2) Then hide everything 3) Therefore Int is unavailable, error.<br>&gt;&gt; import Swift hiding () using () renaming (Int<br>&gt;&gt; , to: INT)<br>&gt;&gt; <br>&gt;&gt; // This says to 1) Use Int 2) Hide String 3) rename Double to Triple.  It is invalid<br>&gt;&gt; // because 1) Int is available 2) String is not, error. 3) Double is unavailable, error.<br>&gt;&gt; import Swift using (Int) hiding (String) renaming (Double<br>&gt;&gt; , to: Triple)<br>&gt;&gt; <br>&gt;&gt; // Valid.  This will be merged as `using (Int)`<br>&gt;&gt; import Swift using () using (Int<br>&gt;&gt; )<br>&gt;&gt; <br>&gt;&gt; // Valid.  This will be merged as `hiding (String, Double)`<br>&gt;&gt; import Swift hiding (String) hiding (Double<br>&gt;&gt; ) hiding ()<br>&gt;&gt; <br>&gt;&gt; // Valid (if redundant). This will be merged as `using ()`<br>&gt;&gt; import Swift using (String) hiding (String)<br>&gt;&gt; Module scope is delimited by the keyword module followed by a fully qualified name and must occur as the first declaration in a file. For example:<br>&gt;&gt; <br>&gt;&gt; // ./Math/Integers/Arithmetic.swift<br>&gt;&gt; <br>&gt;&gt; module Math<br>&gt;&gt; .Integers.<br>&gt;&gt; Arithmetic<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; public protocol<br>&gt;&gt; _IntegerArithmetic {}<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; public struct<br>&gt;&gt; _Abs {}<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; @_versioned<br>&gt;&gt; internal func _abs&lt;Args&gt;(_ args: Args) -&gt;<br>&gt;&gt; (_Abs, Args) {}<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; // ./Math/Integers.swift<br>&gt;&gt; <br>&gt;&gt; module Math<br>&gt;&gt; .<br>&gt;&gt; Integers<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; // _abs is visible in this module and all others within the project, <br>&gt;&gt; // but is not exported along with it.<br>&gt;&gt; internal import Math.Integers.Arithmetic<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; public protocol IntegerArithmetic : _IntegerArithmetic, Comparable<br>&gt;&gt; {}<br>&gt;&gt; <br>&gt;&gt; public protocol SignedNumber : Comparable<br>&gt;&gt; , ExpressibleByIntegerLiteral {}<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; // Math.swift<br>&gt;&gt; <br>&gt;&gt; module Math<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; // Exports the entire public contents of Math.Integers, but nothing in <br>&gt;&gt; // Math.Integers.Arithmetic.<br>&gt;&gt; public import Math.Integers<br>&gt;&gt; Modules names are tied to a directory structure that describes their location relative to the current module and it will now be an error to violate this rule. For example:<br>&gt;&gt; <br>&gt;&gt; module String // lives in ./String.swift<br>&gt;&gt; <br>&gt;&gt; module <br>&gt;&gt; String.Core // lives in ./String/Core.swift<br>&gt;&gt; <br>&gt;&gt; module <br>&gt;&gt; String.Core.Internals.Do.You.Even.Write // lives in ./String/Core/Internals/Do/You/Even/Write.swift<br>&gt;&gt; Existing projects that do not adopt these rules will still retain their implicit module name (usually defined as the name of the framework or application that is being built) and may continue to use whatever directory structure they wish, however they may not declare any explicit modules.<br>&gt;&gt; <br>&gt;&gt; This proposal also solves the problem of module export. A module that is imported without an access level modifier will default to an internal import per usual. However, when it is useful to fully expose the public content of submodules to a client, a public modifier can be used. Similarly, when it is useful to access internal or [file]private APIs, but not expose them to clients, those access modifiers may be used. The rule of thumb is: Only identifiers that are at least as visible as the qualifier on the import make for valid import declarations. For example:<br>&gt;&gt; <br>&gt;&gt; // A submodule declaring a `private` class that gets imported with <br>&gt;&gt; // an `internal` qualifier with a `using` directive is an invalid import <br>&gt;&gt; // declaration.  <br>&gt;&gt; <br>&gt;&gt; module Foo<br>&gt;&gt; .<br>&gt;&gt; Bar<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; private class<br>&gt;&gt; PrivateThing {}<br>&gt;&gt; <br>&gt;&gt; module Foo<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; // Error: PrivateThing not visible, use `private import`<br>&gt;&gt; import Foo.Bar using (PrivateThing) <br>&gt;&gt; // However, a submodule declaring a `public` struct that gets imported with <br>&gt;&gt; // an `private` qualifier is a valid import declaration.<br>&gt;&gt; <br>&gt;&gt; module Foo<br>&gt;&gt; .<br>&gt;&gt; Bar<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; public class<br>&gt;&gt; PublicThing {}<br>&gt;&gt; <br>&gt;&gt; module Foo<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; // All good!  Foo can see Foo.Bar.PrivateThing.<br>&gt;&gt; private import Foo.Bar using (PublicThing) <br>&gt;&gt; Because import directives are file-local, they will never be exported along with a public import and will default to exporting the entire contents of the module as though you had never declared them.<br>&gt;&gt; <br>&gt;&gt; // In this file and this file alone, the directives apply.  To the user<br>&gt;&gt; // of this module, it is as though this declaration were simply:<br>&gt;&gt; // public import Foundation.Date<br>&gt;&gt; public import Foundation.Date hiding (Date.init<br>&gt;&gt; ()) <br>&gt;&gt;                              renaming (Date<br>&gt;&gt; .Type.<br>&gt;&gt; distantPast, <br>&gt;&gt;                                        to: Date<br>&gt;&gt; .Type.<br>&gt;&gt; letsGoLivingInThePast,<br>&gt;&gt;                                        Date<br>&gt;&gt; .Type.<br>&gt;&gt; timeIntervalSinceReferenceDate, <br>&gt;&gt;                                        to: Date<br>&gt;&gt; .Type.<br>&gt;&gt; startOfTheUniverse)<br>&gt;&gt;                              renaming (Date<br>&gt;&gt; .Type.&lt;, to: Date.Type.&lt;&lt;&lt;&lt;&lt;)<br>&gt;&gt; Impact on existing code<br>&gt;&gt; <br>&gt;&gt; Existing code that is using qualified module import syntax (import {func|class|typealias|class|struct|enum|protocol} &lt;qualified-name&gt;) will be deprecated. Code that is not organized into modules will remain unaffected and organized into one contiguous top-level module. However, it is strongly recommended that frameworks be decomposed and reorganized around the new module system.<br>&gt;&gt; <br>&gt;&gt; As a case study, the public interface to the standard library appears to already be mostly broken down into submodules as described in GroupInfo.json.<br>&gt;&gt; <br>&gt;&gt; Code that is defined in modulemaps already defines a module structure that can be imported directly into this scheme.<br>&gt;&gt; <br>&gt;&gt; Alternatives considered<br>&gt;&gt; <br>&gt;&gt; Module export can also be placed on the module declaration itself. The relevant parts of the grammar that have changed are below with an example:<br>&gt;&gt; <br>&gt;&gt; module-decl -&gt; &lt;access-level-modifier&gt; module &lt;module-path&gt;<br>&gt;&gt; import-decl -&gt; import &lt;module-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt;&gt; <br>&gt;&gt; private module String.Core.<br>&gt;&gt; Internals<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; // Shh, it&#39;s a secret.<br>&gt;&gt; While this style makes it immediately obvious to the library author which modules are public or private, it causes the consumer problems because submodule exports are no longer explicit and are entirely ad-hoc. In the interest of enabling, for one, users of IDEs to drill into public submodules, making export local to import seems more appropriate.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Proposal] Qualified Imports and Modules</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>July 20, 2016 at 10:00:00am</p></header><div class="content"><p>I’m not a fan of renaming. Along with ‘dialects’ of the Swift language itself, allowing people to rename APIs (because they don’t like Apple’s long names) makes it harder for everybody else to understand.<br></p><p>I know people who do this at the moment with typedefs/typealiases. Drives me nuts. Especially if it’s per-file; oh God, can you imagine? Having to re-learn a new set of SDK mappings when you open a new file?<br></p><p>I also don’t understand the argument about free-functions “polluting the global namespace” (I’ve heard it a couple of times). You can still get qualified access to free functions (e.g. Swift.repeatElement(…)), so if there is a conflict you can resolve it like you do any other conflict - by qualifying it with the module name.<br></p><p>Karl<br></p><p>&gt; On 18 Jul 2016, at 23:09, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello all,<br>&gt; <br>&gt; TJ Usiyan, Harlan Haskins, and I have been working on a proposal to rework qualified imports and introduce an explicit module system to Swift that we’d like to publish for your viewing pleasure.<br>&gt; <br>&gt; The initial impetus was set out in a radar (rdar://17630570 &lt;rdar://17630570&gt;) I sent fairly early on that didn’t receive a response, so I started a swift-evolution &lt;http://permalink.gmane.org/gmane.comp.lang.swift.evolution/1378&gt; thread discussing the basics of this proposal.  It has been refined and expanded a bit to include an effort to make Swift modules explicit and updated with the feedback of that first thread.  Contents of the proposal are inline and can also be had as a gist &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6&gt; or on Github. &lt;https://github.com/apple/swift-evolution/pull/440&gt;<br>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt; Qualified Imports and Modules<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;https://gist.github.com/CodaFi/NNNN-first-class-qualified-imports.md&gt;<br>&gt; Authors: Robert Widmann &lt;https://github.com/codafi&gt;, Harlan Haskins &lt;https://github.com/harlanhaskins&gt;, TJ Usiyan &lt;https://github.com/griotspeak&gt;<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#introduction&gt;Introduction<br>&gt; <br>&gt; We propose a complete overhaul of the qualified imports syntax and semantics and the introduction of a module system.<br>&gt; <br>&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#motivation&gt;Motivation<br>&gt; <br>&gt; Swift code is modular by default. However, it is not clear how to decompose existing modules further into submodules. In addition, it is difficult to tell how importing a module affects its export to consumers of a library. This leads many to either fake namespaces with enums, attempt to structure Swift code with modulemaps, or use a large amount of version-control submodules. All of these can be rolled into one complete package in the form of a comprehensive rethink of the qualified import system and the introduction of a module system.<br>&gt; <br>&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; Modules will now become an explicit part of working with canonical Swift code. The grammar and semantics of qualified imports will change completely with the addition of import qualifiers and import directives. We also introduce three new contextual keywords: using, hiding, and renaming, to facilitate fine-grained usage of module contents.<br>&gt; <br>&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#detailed-design&gt;Detailed design<br>&gt; <br>&gt; Qualified import syntax will be revised to the following<br>&gt; <br>&gt; module-decl -&gt; module &lt;module-path&gt;<br>&gt; import-decl -&gt; &lt;access-level-modifier&gt; import &lt;module-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt; module-path -&gt; &lt;identifier&gt;<br>&gt;             -&gt; &lt;identifier&gt;.&lt;import-path&gt;<br>&gt; import-directive-list -&gt; &lt;import-directive&gt;<br>&gt;                       -&gt; &lt;import-directive&gt; &lt;import-directive-list&gt;<br>&gt; import-directive -&gt; using (&lt;identifier&gt;, ...)<br>&gt;                  -&gt; hiding (&lt;identifier&gt;, ...)<br>&gt;                  -&gt; renaming (&lt;identifier&gt;, to: &lt;identifier&gt;, ...)<br>&gt; This introduces the concept of an import directive. An import directive is a file-local modification of an imported identifier. A directive can be one of 3 operations:<br>&gt; <br>&gt; 1) using: The using directive is followed by a list of identifiers within the imported module that should be exposed to this file. <br>&gt; <br>&gt; // The only visible parts of Foundation in this file are <br>&gt; // Date.init(), Date.hashValue, and Date.description.<br>&gt; import Foundation.Date using (Date.init(), Date.hashValue, Date.description)<br>&gt; 2) hiding: The hiding directive is followed by a list of identifiers within the imported module that should be hidden from this file.<br>&gt; <br>&gt; // Imports all of Foundation.Date except `Date.compare()`<br>&gt; import Foundation.Date hiding (Date.compare())<br>&gt; 3) renaming: The renaming directive is followed by a list of identifiers separated by to: that should be exposed to this file but renamed. <br>&gt; <br>&gt; // Imports all of Dispatch.DispatchQueue but renames the static member <br>&gt; // DispatchQueue.main, to DispatchQueue.mainQueue<br>&gt; import Dispatch.DispatchQueue renaming (DispatchQueue.Type.main to: DispatchQueue.Type.mainQueue)<br>&gt; // Renaming can also rename modules.  All members of UIKit have to be qualified with<br>&gt; // `UI` now.<br>&gt; import UIKit renaming (UIKit, to: UI)<br>&gt; Import directives chain to one another and can be used to create a fine-grained module import:<br>&gt; <br>&gt; // Imports all of Foundation except `DateFormatter` and renames `Cache` to `LRUCache`<br>&gt; import Foundation hiding (DateFormatter) renaming (Cache to: LRUCache)<br>&gt; // Imports SCNNode except SCNNode.init(mdlObject:) and renames `.description` to<br>&gt; // `.nodeDescription` <br>&gt; import SceneKit using (SCNNode) <br>&gt;                 renaming (SCNNode.description, to: SCNNode.nodeDescription)<br>&gt;                 hiding (SCNNode.init(mdlObject:))<br>&gt; Directive chaining occurs left-to-right:<br>&gt; <br>&gt; // This says to 1) Hide nothing 2) Use nothing 3) rename Int to INT.  It is invalid<br>&gt; // because 1) We will show everything 2) Then hide everything 3) Therefore Int is unavailable, error.<br>&gt; import Swift hiding () using () renaming (Int, to: INT)<br>&gt; // This says to 1) Use Int 2) Hide String 3) rename Double to Triple.  It is invalid<br>&gt; // because 1) Int is available 2) String is not, error. 3) Double is unavailable, error.<br>&gt; import Swift using (Int) hiding (String) renaming (Double, to: Triple)<br>&gt; // Valid.  This will be merged as `using (Int)`<br>&gt; import Swift using () using (Int)<br>&gt; // Valid.  This will be merged as `hiding (String, Double)`<br>&gt; import Swift hiding (String) hiding (Double) hiding ()<br>&gt; // Valid (if redundant). This will be merged as `using ()`<br>&gt; import Swift using (String) hiding (String)<br>&gt; Module scope is delimited by the keyword module followed by a fully qualified name and must occur as the first declaration in a file. For example:<br>&gt; <br>&gt; // ./Math/Integers/Arithmetic.swift<br>&gt; module Math.Integers.Arithmetic<br>&gt; <br>&gt; public protocol _IntegerArithmetic {}<br>&gt; <br>&gt; public struct _Abs {}<br>&gt; <br>&gt; @_versioned<br>&gt; internal func _abs&lt;Args&gt;(_ args: Args) -&gt; (_Abs, Args) {}<br>&gt; <br>&gt; // ./Math/Integers.swift<br>&gt; module Math.Integers<br>&gt; <br>&gt; // _abs is visible in this module and all others within the project, <br>&gt; // but is not exported along with it.<br>&gt; internal import Math.Integers.Arithmetic<br>&gt; <br>&gt; public protocol IntegerArithmetic : _IntegerArithmetic, Comparable {}<br>&gt; public protocol SignedNumber : Comparable, ExpressibleByIntegerLiteral {}<br>&gt; <br>&gt; <br>&gt; // Math.swift<br>&gt; module Math<br>&gt; <br>&gt; // Exports the entire public contents of Math.Integers, but nothing in <br>&gt; // Math.Integers.Arithmetic.<br>&gt; public import Math.Integers<br>&gt; Modules names are tied to a directory structure that describes their location relative to the current module and it will now be an error to violate this rule. For example:<br>&gt; <br>&gt; module String // lives in ./String.swift<br>&gt; module String.Core // lives in ./String/Core.swift<br>&gt; module String.Core.Internals.Do.You.Even.Write // lives in ./String/Core/Internals/Do/You/Even/Write.swift<br>&gt; Existing projects that do not adopt these rules will still retain their implicit module name (usually defined as the name of the framework or application that is being built) and may continue to use whatever directory structure they wish, however they may not declare any explicit modules.<br>&gt; <br>&gt; This proposal also solves the problem of module export. A module that is imported without an access level modifier will default to an internal import per usual. However, when it is useful to fully expose the public content of submodules to a client, a public modifier can be used. Similarly, when it is useful to access internal or [file]private APIs, but not expose them to clients, those access modifiers may be used. The rule of thumb is: Only identifiers that are at least as visible as the qualifier on the import make for valid import declarations. For example:<br>&gt; <br>&gt; // A submodule declaring a `private` class that gets imported with <br>&gt; // an `internal` qualifier with a `using` directive is an invalid import <br>&gt; // declaration.  <br>&gt; module Foo.Bar<br>&gt; <br>&gt; private class PrivateThing {}<br>&gt; <br>&gt; module Foo<br>&gt; <br>&gt; // Error: PrivateThing not visible, use `private import`<br>&gt; import Foo.Bar using (PrivateThing) <br>&gt; // However, a submodule declaring a `public` struct that gets imported with <br>&gt; // an `private` qualifier is a valid import declaration.<br>&gt; module Foo.Bar<br>&gt; <br>&gt; public class PublicThing {}<br>&gt; <br>&gt; module Foo<br>&gt; <br>&gt; // All good!  Foo can see Foo.Bar.PrivateThing.<br>&gt; private import Foo.Bar using (PublicThing) <br>&gt; Because import directives are file-local, they will never be exported along with a public import and will default to exporting the entire contents of the module as though you had never declared them.<br>&gt; <br>&gt; // In this file and this file alone, the directives apply.  To the user<br>&gt; // of this module, it is as though this declaration were simply:<br>&gt; // public import Foundation.Date<br>&gt; public import Foundation.Date hiding (Date.init()) <br>&gt;                               renaming (Date.Type.distantPast, <br>&gt;                                         to: Date.Type.letsGoLivingInThePast,<br>&gt;                                         Date.Type.timeIntervalSinceReferenceDate, <br>&gt;                                         to: Date.Type.startOfTheUniverse)<br>&gt;                               renaming (Date.Type.&lt;, to: Date.Type.&lt;&lt;&lt;&lt;&lt;)<br>&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; Existing code that is using qualified module import syntax (import {func|class|typealias|class|struct|enum|protocol} &lt;qualified-name&gt;) will be deprecated. Code that is not organized into modules will remain unaffected and organized into one contiguous top-level module. However, it is strongly recommended that frameworks be decomposed and reorganized around the new module system.<br>&gt; <br>&gt; As a case study, the public interface to the standard library appears to already be mostly broken down into submodules as described in GroupInfo.json &lt;https://github.com/apple/swift/blob/master/stdlib/public/core/GroupInfo.json&gt;.<br>&gt; <br>&gt; Code that is defined in modulemaps already defines a module structure that can be imported directly into this scheme.<br>&gt; <br>&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt; Module export can also be placed on the module declaration itself. The relevant parts of the grammar that have changed are below with an example:<br>&gt; <br>&gt; module-decl -&gt; &lt;access-level-modifier&gt; module &lt;module-path&gt;<br>&gt; import-decl -&gt; import &lt;module-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt; private module String.Core.Internals<br>&gt; <br>&gt; // Shh, it&#39;s a secret.<br>&gt; While this style makes it immediately obvious to the library author which modules are public or private, it causes the consumer problems because submodule exports are no longer explicit and are entirely ad-hoc. In the interest of enabling, for one, users of IDEs to drill into public submodules, making export local to import seems more appropriate.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160720/80081ccb/attachment-0001.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Proposal] Qualified Imports and Modules</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>July 20, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On 19 Jul 2016, at 00:09, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; TJ Usiyan, Harlan Haskins, and I have been working on a proposal to rework qualified imports and introduce an explicit module system to Swift that we’d like to publish for your viewing pleasure.<br>&gt; <br>&gt; The initial impetus was set out in a radar (rdar://17630570 &lt;rdar://17630570&gt;) I sent fairly early on that didn’t receive a response, so I started a swift-evolution &lt;http://permalink.gmane.org/gmane.comp.lang.swift.evolution/1378&gt; thread discussing the basics of this proposal.  It has been refined and expanded a bit to include an effort to make Swift modules explicit and updated with the feedback of that first thread.  Contents of the proposal are inline and can also be had as a gist &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6&gt; or on Github. &lt;https://github.com/apple/swift-evolution/pull/440&gt;<br></p><p>Firstly, thank you Robert, TJ, and Harlan for the proposal and especially for considering the introduction of submodules too! Those would be very useful when Swift libraries start growing. But maybe we can delay that discussion past Swift 3.<br></p><p>* * *<br></p><p>Secondly, I used to be in the selective import camp before, but I think it&#39;s somewhat counter to Swift&#39;s feel and direction where most of the API is wrapped inside types, and function names consist of not just the base name but argument labels too (even if we now have the &quot;Gregorian&quot; naming SE-0021 available). So while I don&#39;t see a big problem introducing something like<br></p><p>    import Foo.(fooConstant, bar(a:b) as bar1(a:b:), IrrelevantType as _)<br></p><p>to pick identifiers à la carte, I don&#39;t think it would be useful very often. And the alternative of accessing `bar` through the module name as `Foo.bar` does work just as well already.<br></p><p>…Well, that is except for the problem when the module name `Foo` happens to be shadowed by a non-module name `Foo`. I&#39;d rather tackle that problem, and I do so as follows:<br></p><p>* * *<br></p><p>My usual pain points with imported (micro-)frameworks have been:<br></p><p>A) …when two modules (e.g. `Foo` and `Bar`) export the same identifier (`baz`) for different meanings.<br>B) …when a local or imported identifier (e.g. `class Tree`) has the same name as a module `Tree`.<br></p><p>In case A, I can just disambiguate by prefixing with the module name: `Foo.baz` vs. `Bar.baz`.<br></p><p>In case B, there is really no way around that I&#39;m aware of. Anyway you write `Tree.foo` Swift will try to look up under the type `Tree` and never the module `Tree`.<br></p><p>Those two issues could be addressed by simply introducing qualified imports as follows:<br></p><p>    import Darwin as Darwin // qualified import (there could be a shorthand but what?)<br>    import UIKit as UI      // qualified import with renaming<br>    import Tree             // unqualified import brings in struct Tree.Tree, among others.<br>    import Tree as T        // qualified import<br>    <br>    let out = Darwin.stdout      // ok<br>    var vc: UI.UIViewController? // ok<br>    let tree: Tree = T.emptyTree // ok; `struct Tree.Tree` was imported unqualified<br>    <br>    let err = stderr<br>    // error: Use of unresolved identifier &#39;stderr&#39;<br>    // note: did you mean &#39;Darwin.stderr&#39;?<br>    <br>    var view: UIView?<br>    // error: Use of unresolved type &#39;UIView&#39;<br>    // note: did you mean &#39;UI.UIView&#39;?<br>    <br>    enum UI {}<br>    // error: invalid redeclaration of &#39;UI&#39;<br>    // note: &#39;UI&#39; previously declared (line 2)<br></p><p>The qualified import syntax, `import MODULE as NAME`, imports the module MODULE such that its contents can be accessed through the prefix of `NAME.` – but not without it, unless also imported without qualification.<br></p><p>The given NAME uses up that identifier in the current scope (as if it was a private type) such that there can be no locally visible type or value with the same name in that scope. For example, if the current module defined NAME publicly or internally in another file, then that identifier would be shadowed in this file by the qualified module name NAME.<br></p><p>Side note: It is still possible to chain multiple module imports, qualified or not, on the same line (albeit not a particularly good coding style if they&#39;re unrelated). The order of imports does not matter. So the above example could&#39;ve been written as:<br></p><p>    import Darwin as Darwin, UIKit as UI, Tree as T, Tree<br></p><p>* * *<br></p><p>I think that&#39;s the small change we need most urgently. The rest can wait.<br></p><p>— Pyry<br></p><p>PS: Another thing I&#39;d see useful, especially when migrating code from the `MyPlayground_Sources` module to a real project would be a syntax something like `_.foo` to access the `foo` that is visible in the current file top-level, so to escape any local shadowing.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160720/4924a32d/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
