<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>Proposal: Remove % operator for floating-point types</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>December 18, 2015 at 04:00:00pm</p></header><div class="content"><p>Hi everybody —<br></p><p>I’d like to propose removing the “%” operator for floating-point types.<br></p><p>Rationale:<br>While C and C++ do not provide the “%” operator for floating-point types, many newer languages do (Java, C#, and Python, to name just a few).  Superficially this seems reasonable, but there are severe gotchas when % is applied to floating-point data, and the results are often extremely surprising to unwary users.  C and C++ omitted this operator for good reason.  Even if you think you want this operator, it is probably doing the wrong thing in subtle ways that will cause trouble for you in the future.<br></p><p>The % operator on integer types satisfies the division algorithm axiom: If b is non-zero and q = a/b, r = a%b, then a = q*b + r.  This property does not hold for floating-point types, because a/b does not produce an integral value.  If it did produce an integral value, it would need to be a bignum type of some sort (the integral part of DBL_MAX / DBL_MIN, for example, has over 2000 bits or 600 decimal digits).<br></p><p>Even if a bignum type were returned, or if we ignore the loss of the division algorithm axiom, % would still be deeply flawed.  Whereas people are generally used to modest rounding errors in floating-point arithmetic, because % is not continuous small errors are frequently enormously magnified with catastrophic results:<br></p><p>	(swift) 10.0 % 0.1<br>    // r0 : Double = 0.0999999999999995 // What?!<br></p><p>[Explanation: 0.1 cannot be exactly represented in binary floating point; the actual value of “0.1” is 0.1000000000000000055511151231257827021181583404541015625.  Other than that rounding, the entire computation is exact.]<br></p><p>Proposed Approach:<br>Remove the “%” operator for floating-point types.  The operation is still be available via the C standard library fmod( ) function (which should be mapped to a Swiftier name, but that’s a separate proposal).<br></p><p>Alternative Considered:<br>Instead of binding “%” to fmod( ), it could be bound to remainder( ), which implements the IEEE 754 remainder operation; this is just like fmod( ), except instead of returning the remainder under truncating division, it returns the remainder of round-to-nearest division, meaning that if a and b are positive, remainder(a,b) is in the range [-b/2, b/2] rather than [0, b).  This still has a large discontinuity, but the discontinuity is moved away from zero, which makes it much less troublesome (that’s why IEEE 754 standardized this operation):<br></p><p>	(swift) remainder(1, 0.1)<br>    // r1 : Double = -0.000000000000000055511151231257827 // Looks like normal floating-point rounding<br></p><p>The downside to this alternative is that now % behaves totally differently for integer and floating-point data, and of course the division algorithm still doesn’t hold.<br></p><p>Proposal:<br>Remove the % operator for floating-point types in Swift 3.  Add a warning in Swift 2.2 that points out the replacement fmod(a, b).<br></p><p>Thanks for your feedback,<br>– Steve<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/c2130a2d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>Proposal: Remove % operator for floating-point types</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>December 19, 2015 at 04:00:00am</p></header><div class="content"><p>Floating point numbers by their very nature are approximation represented in binary.  Many numbers in Decimal cannot be represented exactly in decimal floating point format.  <br>So after math calculations decimal number -&gt; floating point binary -&gt; repeating decimal numbers.<br></p><p>If decimal accuracy such as accounting, you should avoid using floats altogether and stick to Decimal type numbers (in java it is called BigDecimal, in Swift they have NSDecimalNumber I think which has it’s own issues.<br></p><p><br>&gt; On 2015-12-19, at 4:12:58, Stephen Canon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi everybody —<br>&gt; <br>&gt; I’d like to propose removing the “%” operator for floating-point types.<br>&gt; <br>&gt; Rationale:<br>&gt; While C and C++ do not provide the “%” operator for floating-point types, many newer languages do (Java, C#, and Python, to name just a few).  Superficially this seems reasonable, but there are severe gotchas when % is applied to floating-point data, and the results are often extremely surprising to unwary users.  C and C++ omitted this operator for good reason.  Even if you think you want this operator, it is probably doing the wrong thing in subtle ways that will cause trouble for you in the future.<br>&gt; <br>&gt; The % operator on integer types satisfies the division algorithm axiom: If b is non-zero and q = a/b, r = a%b, then a = q*b + r.  This property does not hold for floating-point types, because a/b does not produce an integral value.  If it did produce an integral value, it would need to be a bignum type of some sort (the integral part of DBL_MAX / DBL_MIN, for example, has over 2000 bits or 600 decimal digits).<br>&gt; <br>&gt; Even if a bignum type were returned, or if we ignore the loss of the division algorithm axiom, % would still be deeply flawed.  Whereas people are generally used to modest rounding errors in floating-point arithmetic, because % is not continuous small errors are frequently enormously magnified with catastrophic results:<br>&gt; <br>&gt; 	(swift) 10.0 % 0.1<br>&gt;     // r0 : Double = 0.0999999999999995 // What?!<br>&gt; <br>&gt; [Explanation: 0.1 cannot be exactly represented in binary floating point; the actual value of “0.1” is 0.1000000000000000055511151231257827021181583404541015625.  Other than that rounding, the entire computation is exact.]<br>&gt; <br>&gt; Proposed Approach:<br>&gt; Remove the “%” operator for floating-point types.  The operation is still be available via the C standard library fmod( ) function (which should be mapped to a Swiftier name, but that’s a separate proposal).<br>&gt; <br>&gt; Alternative Considered:<br>&gt; Instead of binding “%” to fmod( ), it could be bound to remainder( ), which implements the IEEE 754 remainder operation; this is just like fmod( ), except instead of returning the remainder under truncating division, it returns the remainder of round-to-nearest division, meaning that if a and b are positive, remainder(a,b) is in the range [-b/2, b/2] rather than [0, b).  This still has a large discontinuity, but the discontinuity is moved away from zero, which makes it much less troublesome (that’s why IEEE 754 standardized this operation):<br>&gt; <br>&gt; 	(swift) remainder(1, 0.1)<br>&gt;     // r1 : Double = -0.000000000000000055511151231257827 // Looks like normal floating-point rounding<br>&gt; <br>&gt; The downside to this alternative is that now % behaves totally differently for integer and floating-point data, and of course the division algorithm still doesn’t hold.<br>&gt; <br>&gt; Proposal:<br>&gt; Remove the % operator for floating-point types in Swift 3.  Add a warning in Swift 2.2 that points out the replacement fmod(a, b).<br>&gt; <br>&gt; Thanks for your feedback,<br>&gt; – Steve<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151219/a59617d6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>Proposal: Remove % operator for floating-point types</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>December 19, 2015 at 04:00:00am</p></header><div class="content"><p>http://www.exploringbinary.com/why-0-point-1-does-not-exist-in-floating-point/ &lt;http://www.exploringbinary.com/why-0-point-1-does-not-exist-in-floating-point/&gt;<br></p><p><br>&gt; On 2015-12-19, at 4:17:45, Craig Cruden &lt;ccruden at novafore.com&gt; wrote:<br>&gt; <br>&gt; Floating point numbers by their very nature are approximation represented in binary.  Many numbers in Decimal cannot be represented exactly in decimal floating point format.  <br>&gt; So after math calculations decimal number -&gt; floating point binary -&gt; repeating decimal numbers.<br>&gt; <br>&gt; If decimal accuracy such as accounting, you should avoid using floats altogether and stick to Decimal type numbers (in java it is called BigDecimal, in Swift they have NSDecimalNumber I think which has it’s own issues.<br>&gt; <br>&gt; <br>&gt;&gt; On 2015-12-19, at 4:12:58, Stephen Canon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi everybody —<br>&gt;&gt; <br>&gt;&gt; I’d like to propose removing the “%” operator for floating-point types.<br>&gt;&gt; <br>&gt;&gt; Rationale:<br>&gt;&gt; While C and C++ do not provide the “%” operator for floating-point types, many newer languages do (Java, C#, and Python, to name just a few).  Superficially this seems reasonable, but there are severe gotchas when % is applied to floating-point data, and the results are often extremely surprising to unwary users.  C and C++ omitted this operator for good reason.  Even if you think you want this operator, it is probably doing the wrong thing in subtle ways that will cause trouble for you in the future.<br>&gt;&gt; <br>&gt;&gt; The % operator on integer types satisfies the division algorithm axiom: If b is non-zero and q = a/b, r = a%b, then a = q*b + r.  This property does not hold for floating-point types, because a/b does not produce an integral value.  If it did produce an integral value, it would need to be a bignum type of some sort (the integral part of DBL_MAX / DBL_MIN, for example, has over 2000 bits or 600 decimal digits).<br>&gt;&gt; <br>&gt;&gt; Even if a bignum type were returned, or if we ignore the loss of the division algorithm axiom, % would still be deeply flawed.  Whereas people are generally used to modest rounding errors in floating-point arithmetic, because % is not continuous small errors are frequently enormously magnified with catastrophic results:<br>&gt;&gt; <br>&gt;&gt; 	(swift) 10.0 % 0.1<br>&gt;&gt;     // r0 : Double = 0.0999999999999995 // What?!<br>&gt;&gt; <br>&gt;&gt; [Explanation: 0.1 cannot be exactly represented in binary floating point; the actual value of “0.1” is 0.1000000000000000055511151231257827021181583404541015625.  Other than that rounding, the entire computation is exact.]<br>&gt;&gt; <br>&gt;&gt; Proposed Approach:<br>&gt;&gt; Remove the “%” operator for floating-point types.  The operation is still be available via the C standard library fmod( ) function (which should be mapped to a Swiftier name, but that’s a separate proposal).<br>&gt;&gt; <br>&gt;&gt; Alternative Considered:<br>&gt;&gt; Instead of binding “%” to fmod( ), it could be bound to remainder( ), which implements the IEEE 754 remainder operation; this is just like fmod( ), except instead of returning the remainder under truncating division, it returns the remainder of round-to-nearest division, meaning that if a and b are positive, remainder(a,b) is in the range [-b/2, b/2] rather than [0, b).  This still has a large discontinuity, but the discontinuity is moved away from zero, which makes it much less troublesome (that’s why IEEE 754 standardized this operation):<br>&gt;&gt; <br>&gt;&gt; 	(swift) remainder(1, 0.1)<br>&gt;&gt;     // r1 : Double = -0.000000000000000055511151231257827 // Looks like normal floating-point rounding<br>&gt;&gt; <br>&gt;&gt; The downside to this alternative is that now % behaves totally differently for integer and floating-point data, and of course the division algorithm still doesn’t hold.<br>&gt;&gt; <br>&gt;&gt; Proposal:<br>&gt;&gt; Remove the % operator for floating-point types in Swift 3.  Add a warning in Swift 2.2 that points out the replacement fmod(a, b).<br>&gt;&gt; <br>&gt;&gt; Thanks for your feedback,<br>&gt;&gt; – Steve<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151219/bed32682/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Proposal: Remove % operator for floating-point types</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 18, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 18, 2015, at 1:19 PM, Craig Cruden via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; http://www.exploringbinary.com/why-0-point-1-does-not-exist-in-floating-point/ &lt;http://www.exploringbinary.com/why-0-point-1-does-not-exist-in-floating-point/&gt;<br>&gt; <br>&gt; <br>&gt;&gt; On 2015-12-19, at 4:17:45, Craig Cruden &lt;ccruden at novafore.com &lt;mailto:ccruden at novafore.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Floating point numbers by their very nature are approximation represented in binary.  Many numbers in Decimal cannot be represented exactly in decimal floating point format.  <br>&gt;&gt; So after math calculations decimal number -&gt; floating point binary -&gt; repeating decimal numbers.<br>&gt;&gt; <br>&gt;&gt; If decimal accuracy such as accounting, you should avoid using floats altogether and stick to Decimal type numbers (in java it is called BigDecimal, in Swift they have NSDecimalNumber I think which has it’s own issues.<br></p><p>Just for background and to save time, I’ll note out that Steve is one of Apple’s most respected numerics experts, and he’s more familiar with the details of how floating point, decimal, and other numeric representations work than just about anyone I’ve ever met.<br></p><p>FWIW-ly y’rs,<br></p><p>-Dave<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/10cb13af/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>Proposal: Remove % operator for floating-point types</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>December 19, 2015 at 05:00:00am</p></header><div class="content"><p>I am not a numerics expert…… just have run into people using floats in banking and brokerage systems to do calculation with decimal numbers too many times in my life….  I even spent a whole night in a bank vault with the system on conversion trying to figure out why it was out by a single penny :o<br></p><p>If I were not mentally unstable beforehand I would have gone insane over the misuse of floats, and the lack of languages having good decimal numeric types :p<br></p><p><br>&gt; On 2015-12-19, at 5:47:58, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 18, 2015, at 1:19 PM, Craig Cruden via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; http://www.exploringbinary.com/why-0-point-1-does-not-exist-in-floating-point/ &lt;http://www.exploringbinary.com/why-0-point-1-does-not-exist-in-floating-point/&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 2015-12-19, at 4:17:45, Craig Cruden &lt;ccruden at novafore.com &lt;mailto:ccruden at novafore.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Floating point numbers by their very nature are approximation represented in binary.  Many numbers in Decimal cannot be represented exactly in decimal floating point format.  <br>&gt;&gt;&gt; So after math calculations decimal number -&gt; floating point binary -&gt; repeating decimal numbers.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If decimal accuracy such as accounting, you should avoid using floats altogether and stick to Decimal type numbers (in java it is called BigDecimal, in Swift they have NSDecimalNumber I think which has it’s own issues.<br>&gt; <br>&gt; Just for background and to save time, I’ll note out that Steve is one of Apple’s most respected numerics experts, and he’s more familiar with the details of how floating point, decimal, and other numeric representations work than just about anyone I’ve ever met.<br>&gt; <br>&gt; FWIW-ly y’rs,<br>&gt; <br>&gt; -Dave<br>&gt; <br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151219/06df9e30/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Proposal: Remove % operator for floating-point types</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>December 18, 2015 at 01:00:00pm</p></header><div class="content"><p>Hi Steve,<br>I like this idea because it removes a potential &quot;gotcha&quot; / unexpected<br>behavior, and it will encourage people not to do stuff like this with<br>floating-point numbers. (Somewhat like the clang analyzer&#39;s<br>security.FloatLoopCounter<br>&lt;http://clang-analyzer.llvm.org/available_checks.html#security_checkers&gt;<br>tries to do.) The remainder() behavior makes sense to me.<br></p><p>However, I think it&#39;d be nice for the standard library to continue exposing<br>this behavior, if possible, rather than requiring the user to &quot;import<br>Darwin&quot; or &quot;import Glibc&quot;. Can these remain as methods on the built-in<br>floating-point types, perhaps like .mod() and .remainder(), so they can be<br>used if truly desired?<br></p><p>Jacob<br></p><p>On Fri, Dec 18, 2015 at 1:12 PM, Stephen Canon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi everybody —<br>&gt;<br>&gt; I’d like to propose removing the “%” operator for floating-point types.<br>&gt;<br>&gt; *Rationale:*<br>&gt; While C and C++ do not provide the “%” operator for floating-point types,<br>&gt; many newer languages do (Java, C#, and Python, to name just a few).<br>&gt; Superficially this seems reasonable, but there are severe gotchas when % is<br>&gt; applied to floating-point data, and the results are often extremely<br>&gt; surprising to unwary users.  C and C++ omitted this operator for good<br>&gt; reason.  Even if you think you want this operator, it is probably doing the<br>&gt; wrong thing in subtle ways that will cause trouble for you in the future.<br>&gt;<br>&gt; The % operator on integer types satisfies the division algorithm axiom: If<br>&gt; b is non-zero and q = a/b, r = a%b, then a = q*b + r.  This property does<br>&gt; not hold for floating-point types, because a/b does not produce an integral<br>&gt; value.  If it did produce an integral value, it would need to be a bignum<br>&gt; type of some sort (the integral part of DBL_MAX / DBL_MIN, for example, has<br>&gt; over 2000 bits or 600 decimal digits).<br>&gt;<br>&gt; Even if a bignum type were returned, or if we ignore the loss of the<br>&gt; division algorithm axiom, % would still be deeply flawed.  Whereas people<br>&gt; are generally used to modest rounding errors in floating-point arithmetic,<br>&gt; because % is not continuous small errors are frequently enormously<br>&gt; magnified with catastrophic results:<br>&gt;<br>&gt; (swift) 10.0 % 0.1<br>&gt;     // r0 : Double = 0.0999999999999995 // What?!<br>&gt;<br>&gt; [Explanation: 0.1 cannot be exactly represented in binary floating point;<br>&gt; the actual value of “0.1”<br>&gt; is 0.1000000000000000055511151231257827021181583404541015625.  Other than<br>&gt; that rounding, the entire computation is exact.]<br>&gt;<br>&gt; *Proposed Approach:*<br>&gt; Remove the “%” operator for floating-point types.  The operation is still<br>&gt; be available via the C standard library fmod( ) function (which should be<br>&gt; mapped to a Swiftier name, but that’s a separate proposal).<br>&gt;<br>&gt; *Alternative Considered:*<br>&gt; Instead of binding “%” to fmod( ), it could be bound to remainder( ),<br>&gt; which implements the IEEE 754 remainder operation; this is just like fmod(<br>&gt; ), except instead of returning the remainder under truncating division, it<br>&gt; returns the remainder of round-to-nearest division, meaning that if a and b<br>&gt; are positive, remainder(a,b) is in the range [-b/2, b/2] rather than [0,<br>&gt; b).  This still has a large discontinuity, but the discontinuity is moved<br>&gt; away from zero, which makes it much less troublesome (that’s why IEEE 754<br>&gt; standardized this operation):<br>&gt;<br>&gt; (swift) remainder(1, 0.1)<br>&gt;     // r1 : Double = -0.000000000000000055511151231257827 // Looks like<br>&gt; normal floating-point rounding<br>&gt;<br>&gt; The downside to this alternative is that now % behaves totally differently<br>&gt; for integer and floating-point data, and of course the division algorithm<br>&gt; still doesn’t hold.<br>&gt;<br>&gt; *Proposal:*<br>&gt; Remove the % operator for floating-point types in Swift 3.  Add a warning<br>&gt; in Swift 2.2 that points out the replacement fmod(a, b).<br>&gt;<br>&gt; Thanks for your feedback,<br>&gt; – Steve<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/26ff057b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>Proposal: Remove % operator for floating-point types</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>December 18, 2015 at 04:00:00pm</p></header><div class="content"><p>One of my long-term goals is for the standard library to provide (nearly) full support for all IEEE 754 required operations, which would include something similar to what you suggest.  I’d like to address those bindings under a separate proposal, however, in order to keep this one simple.<br></p><p>– Steve<br></p><p>&gt; On Dec 18, 2015, at 4:19 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt; Hi Steve,<br>&gt; I like this idea because it removes a potential &quot;gotcha&quot; / unexpected behavior, and it will encourage people not to do stuff like this with floating-point numbers. (Somewhat like the clang analyzer&#39;s security.FloatLoopCounter &lt;http://clang-analyzer.llvm.org/available_checks.html#security_checkers&gt; tries to do.) The remainder() behavior makes sense to me.<br>&gt; <br>&gt; However, I think it&#39;d be nice for the standard library to continue exposing this behavior, if possible, rather than requiring the user to &quot;import Darwin&quot; or &quot;import Glibc&quot;. Can these remain as methods on the built-in floating-point types, perhaps like .mod() and .remainder(), so they can be used if truly desired?<br>&gt; <br>&gt; Jacob<br>&gt; <br>&gt; On Fri, Dec 18, 2015 at 1:12 PM, Stephen Canon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Hi everybody —<br>&gt; <br>&gt; I’d like to propose removing the “%” operator for floating-point types.<br>&gt; <br>&gt; Rationale:<br>&gt; While C and C++ do not provide the “%” operator for floating-point types, many newer languages do (Java, C#, and Python, to name just a few).  Superficially this seems reasonable, but there are severe gotchas when % is applied to floating-point data, and the results are often extremely surprising to unwary users.  C and C++ omitted this operator for good reason.  Even if you think you want this operator, it is probably doing the wrong thing in subtle ways that will cause trouble for you in the future.<br>&gt; <br>&gt; The % operator on integer types satisfies the division algorithm axiom: If b is non-zero and q = a/b, r = a%b, then a = q*b + r.  This property does not hold for floating-point types, because a/b does not produce an integral value.  If it did produce an integral value, it would need to be a bignum type of some sort (the integral part of DBL_MAX / DBL_MIN, for example, has over 2000 bits or 600 decimal digits).<br>&gt; <br>&gt; Even if a bignum type were returned, or if we ignore the loss of the division algorithm axiom, % would still be deeply flawed.  Whereas people are generally used to modest rounding errors in floating-point arithmetic, because % is not continuous small errors are frequently enormously magnified with catastrophic results:<br>&gt; <br>&gt; 	(swift) 10.0 % 0.1<br>&gt;     // r0 : Double = 0.0999999999999995 // What?!<br>&gt; <br>&gt; [Explanation: 0.1 cannot be exactly represented in binary floating point; the actual value of “0.1” is 0.1000000000000000055511151231257827021181583404541015625.  Other than that rounding, the entire computation is exact.]<br>&gt; <br>&gt; Proposed Approach:<br>&gt; Remove the “%” operator for floating-point types.  The operation is still be available via the C standard library fmod( ) function (which should be mapped to a Swiftier name, but that’s a separate proposal).<br>&gt; <br>&gt; Alternative Considered:<br>&gt; Instead of binding “%” to fmod( ), it could be bound to remainder( ), which implements the IEEE 754 remainder operation; this is just like fmod( ), except instead of returning the remainder under truncating division, it returns the remainder of round-to-nearest division, meaning that if a and b are positive, remainder(a,b) is in the range [-b/2, b/2] rather than [0, b).  This still has a large discontinuity, but the discontinuity is moved away from zero, which makes it much less troublesome (that’s why IEEE 754 standardized this operation):<br>&gt; <br>&gt; 	(swift) remainder(1, 0.1)<br>&gt;     // r1 : Double = -0.000000000000000055511151231257827 // Looks like normal floating-point rounding<br>&gt; <br>&gt; The downside to this alternative is that now % behaves totally differently for integer and floating-point data, and of course the division algorithm still doesn’t hold.<br>&gt; <br>&gt; Proposal:<br>&gt; Remove the % operator for floating-point types in Swift 3.  Add a warning in Swift 2.2 that points out the replacement fmod(a, b).<br>&gt; <br>&gt; Thanks for your feedback,<br>&gt; – Steve<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/ecfadf1e/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: Remove % operator for floating-point types</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 18, 2015 at 02:00:00pm</p></header><div class="content"><p>On Dec 18, 2015, at 1:12 PM, Stephen Canon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Hi everybody —<br>&gt; <br>&gt; I’d like to propose removing the “%” operator for floating-point types.<br></p><p>I support removing this - it is actively harmful for a surprising operation like this to have such short and inviting syntax.  As asked downthread, have you given any thought into whether a Decimal type would support this operation?  <br></p><p>-Chris<br></p><p><br>&gt; <br>&gt; Rationale:<br>&gt; While C and C++ do not provide the “%” operator for floating-point types, many newer languages do (Java, C#, and Python, to name just a few).  Superficially this seems reasonable, but there are severe gotchas when % is applied to floating-point data, and the results are often extremely surprising to unwary users.  C and C++ omitted this operator for good reason.  Even if you think you want this operator, it is probably doing the wrong thing in subtle ways that will cause trouble for you in the future.<br>&gt; <br>&gt; The % operator on integer types satisfies the division algorithm axiom: If b is non-zero and q = a/b, r = a%b, then a = q*b + r.  This property does not hold for floating-point types, because a/b does not produce an integral value.  If it did produce an integral value, it would need to be a bignum type of some sort (the integral part of DBL_MAX / DBL_MIN, for example, has over 2000 bits or 600 decimal digits).<br>&gt; <br>&gt; Even if a bignum type were returned, or if we ignore the loss of the division algorithm axiom, % would still be deeply flawed.  Whereas people are generally used to modest rounding errors in floating-point arithmetic, because % is not continuous small errors are frequently enormously magnified with catastrophic results:<br>&gt; <br>&gt; 	(swift) 10.0 % 0.1<br>&gt;     // r0 : Double = 0.0999999999999995 // What?!<br>&gt; <br>&gt; [Explanation: 0.1 cannot be exactly represented in binary floating point; the actual value of “0.1” is 0.1000000000000000055511151231257827021181583404541015625.  Other than that rounding, the entire computation is exact.]<br>&gt; <br>&gt; Proposed Approach:<br>&gt; Remove the “%” operator for floating-point types.  The operation is still be available via the C standard library fmod( ) function (which should be mapped to a Swiftier name, but that’s a separate proposal).<br>&gt; <br>&gt; Alternative Considered:<br>&gt; Instead of binding “%” to fmod( ), it could be bound to remainder( ), which implements the IEEE 754 remainder operation; this is just like fmod( ), except instead of returning the remainder under truncating division, it returns the remainder of round-to-nearest division, meaning that if a and b are positive, remainder(a,b) is in the range [-b/2, b/2] rather than [0, b).  This still has a large discontinuity, but the discontinuity is moved away from zero, which makes it much less troublesome (that’s why IEEE 754 standardized this operation):<br>&gt; <br>&gt; 	(swift) remainder(1, 0.1)<br>&gt;     // r1 : Double = -0.000000000000000055511151231257827 // Looks like normal floating-point rounding<br>&gt; <br>&gt; The downside to this alternative is that now % behaves totally differently for integer and floating-point data, and of course the division algorithm still doesn’t hold.<br>&gt; <br>&gt; Proposal:<br>&gt; Remove the % operator for floating-point types in Swift 3.  Add a warning in Swift 2.2 that points out the replacement fmod(a, b).<br>&gt; <br>&gt; Thanks for your feedback,<br>&gt; – Steve<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/c89d5fb0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>Proposal: Remove % operator for floating-point types</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>December 18, 2015 at 06:00:00pm</p></header><div class="content"><p>&gt; On Dec 18, 2015, at 5:57 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; On Dec 18, 2015, at 1:12 PM, Stephen Canon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Hi everybody —<br>&gt;&gt; <br>&gt;&gt; I’d like to propose removing the “%” operator for floating-point types.<br>&gt; <br>&gt; I support removing this - it is actively harmful for a surprising operation like this to have such short and inviting syntax.  As asked downthread, have you given any thought into whether a Decimal type would support this operation?<br></p><p>The same concerns apply to decimal.  It makes sense to have the operation (for both binary and decimal floating-point) as “Type.remainder(a,b)” or a free function like &quot;remainder(a, b)”, but I would prefer not to use the operator “%” for it because it behaves very differently from integer %, and in ways that are not at all obvious to most users.<br></p><p>– Steve<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/940ebeab/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: Remove % operator for floating-point types</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 18, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 18, 2015, at 3:03 PM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 18, 2015, at 5:57 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Dec 18, 2015, at 1:12 PM, Stephen Canon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; Hi everybody —<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’d like to propose removing the “%” operator for floating-point types.<br>&gt;&gt; <br>&gt;&gt; I support removing this - it is actively harmful for a surprising operation like this to have such short and inviting syntax.  As asked downthread, have you given any thought into whether a Decimal type would support this operation?<br>&gt; <br>&gt; The same concerns apply to decimal.  It makes sense to have the operation (for both binary and decimal floating-point) as “Type.remainder(a,b)” or a free function like &quot;remainder(a, b)”, but I would prefer not to use the operator “%” for it because it behaves very differently from integer %, and in ways that are not at all obvious to most users.<br></p><p>Great, I’d prefer decimal and the float types to have a consistent interface where possible.  +1 from me on the proposal.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/c2bebd6c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Remove % operator for floating-point types</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 18, 2015 at 03:00:00pm</p></header><div class="content"><p>On Fri, Dec 18, 2015, at 03:04 PM, Chris Lattner via swift-evolution wrote:<br>&gt;<br>&gt;&gt; On Dec 18, 2015, at 3:03 PM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; On Dec 18, 2015, at 5:57 PM, Chris Lattner &lt;clattner at apple.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Dec 18, 2015, at 1:12 PM, Stephen Canon via swift-evolution &lt;swift-<br>&gt;&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; Hi everybody —<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I’d like to propose removing the “%” operator for floating-point<br>&gt;&gt;&gt;&gt; types.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I support removing this - it is actively harmful for a surprising<br>&gt;&gt;&gt; operation like this to have such short and inviting syntax.  As<br>&gt;&gt;&gt; asked downthread, have you given any thought into whether a Decimal<br>&gt;&gt;&gt; type would support this operation?<br>&gt;&gt;<br>&gt;&gt; The same concerns apply to decimal.  It makes sense to have the<br>&gt;&gt; operation (for both binary and decimal floating-point) as<br>&gt;&gt; “Type.remainder(a,b)” or a free function like &quot;remainder(a, b)”, but<br>&gt;&gt; I would prefer not to use the operator “%” for it because it behaves<br>&gt;&gt; very differently from integer %, and in ways that are not at all<br>&gt;&gt; obvious to most users.<br>&gt;<br>&gt; Great, I’d prefer decimal and the float types to have a consistent<br>&gt; interface where possible.  +1 from me on the proposal.<br></p><p>Agreed. +1 from me too. The `10.0 % 0.1` behavior is sufficiently<br>surprising that I think that justifies removal by itself.<br></p><p>I&#39;m also in favor of adding mod and remainder as instance methods of the<br>floating point types, e.g. `10.0.mod(0.1)` (as opposed to static methods<br>or free functions).<br></p><p>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/9db66d7e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8353e5613dab0dc3647987ffd996d974?s=50"></div><header><strong>Proposal: Remove % operator for floating-point types</strong> from <string>August Joki</string> &lt;august at apple.com&gt;<p>December 18, 2015 at 03:00:00pm</p></header><div class="content"><p>-August<br></p><p>&gt; On 18 Dec, 2015, at 15:31, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Fri, Dec 18, 2015, at 03:04 PM, Chris Lattner via swift-evolution wrote:<br>&gt;&gt;  <br>&gt;&gt;&gt; On Dec 18, 2015, at 3:03 PM, Stephen Canon &lt;scanon at apple.com &lt;mailto:scanon at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; On Dec 18, 2015, at 5:57 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; On Dec 18, 2015, at 1:12 PM, Stephen Canon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; Hi everybody —<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; I’d like to propose removing the “%” operator for floating-point types.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; I support removing this - it is actively harmful for a surprising operation like this to have such short and inviting syntax.  As asked downthread, have you given any thought into whether a Decimal type would support this operation?<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; The same concerns apply to decimal.  It makes sense to have the operation (for both binary and decimal floating-point) as “Type.remainder(a,b)” or a free function like &quot;remainder(a, b)”, but I would prefer not to use the operator “%” for it because it behaves very differently from integer %, and in ways that are not at all obvious to most users.<br>&gt;&gt;  <br>&gt;&gt; Great, I’d prefer decimal and the float types to have a consistent interface where possible.  +1 from me on the proposal.<br>&gt;  <br>&gt; Agreed. +1 from me too. The `10.0 % 0.1` behavior is sufficiently surprising that I think that justifies removal by itself.<br>&gt;  <br>&gt; I&#39;m also in favor of adding mod and remainder as instance methods of the floating point types, e.g. `10.0.mod(0.1)` (as opposed to static methods or free functions).<br>Shouldn’t that be added to any Arithmetic type?<br>&gt;  <br>&gt; -Kevin Ballard<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/c94322d9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Remove % operator for floating-point types</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 18, 2015 at 03:00:00pm</p></header><div class="content"><p>On Fri, Dec 18, 2015, at 03:40 PM, August Joki wrote:<br>&gt;<br>&gt;&gt; On 18 Dec, 2015, at 15:31, Kevin Ballard via swift-evolution &lt;swift-<br>&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Fri, Dec 18, 2015, at 03:04 PM, Chris Lattner via swift-<br>&gt;&gt; evolution wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Dec 18, 2015, at 3:03 PM, Stephen Canon &lt;scanon at apple.com&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Dec 18, 2015, at 5:57 PM, Chris Lattner &lt;clattner at apple.com&gt;<br>&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Dec 18, 2015, at 1:12 PM, Stephen Canon via swift-evolution &lt;swift-<br>&gt;&gt;&gt;&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; Hi everybody —<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; I’d like to propose removing the “%” operator for floating-point<br>&gt;&gt;&gt;&gt;&gt;&gt; types.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I support removing this - it is actively harmful for a surprising<br>&gt;&gt;&gt;&gt;&gt; operation like this to have such short and inviting syntax.  As<br>&gt;&gt;&gt;&gt;&gt; asked downthread, have you given any thought into whether a<br>&gt;&gt;&gt;&gt;&gt; Decimal type would support this operation?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The same concerns apply to decimal.  It makes sense to have the<br>&gt;&gt;&gt;&gt; operation (for both binary and decimal floating-point) as<br>&gt;&gt;&gt;&gt; “Type.remainder(a,b)” or a free function like &quot;remainder(a, b)”,<br>&gt;&gt;&gt;&gt; but I would prefer not to use the operator “%” for it because it<br>&gt;&gt;&gt;&gt; behaves very differently from integer %, and in ways that are not<br>&gt;&gt;&gt;&gt; at all obvious to most users.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Great, I’d prefer decimal and the float types to have a consistent<br>&gt;&gt;&gt; interface where possible.  +1 from me on the proposal.<br>&gt;&gt;<br>&gt;&gt; Agreed. +1 from me too. The `10.0 % 0.1` behavior is sufficiently<br>&gt;&gt; surprising that I think that justifies removal by itself.<br>&gt;&gt;<br>&gt;&gt; I&#39;m also in favor of adding mod and remainder as instance methods of<br>&gt;&gt; the floating point types, e.g. `10.0.mod(0.1)` (as opposed to static<br>&gt;&gt; methods or free functions).<br>&gt; Shouldn’t that be added to any Arithmetic type?<br></p><p>IntegerArithmeticType already defines the % operator, adding a mod()<br>method would just be duplication. If we have Float.remainder() then<br>arguably we might want an integral remainder too, although remainder<br>turns out to be rarely what people want (at least, for integral<br>calculations), which is why the % operator is mod.<br></p><p>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/8fcb7cae/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: Remove % operator for floating-point types</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 18, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; On Dec 18, 2015, at 3:40 PM, August Joki via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; -August<br>&gt; <br>&gt;&gt; On 18 Dec, 2015, at 15:31, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Fri, Dec 18, 2015, at 03:04 PM, Chris Lattner via swift-evolution wrote:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; On Dec 18, 2015, at 3:03 PM, Stephen Canon &lt;scanon at apple.com &lt;mailto:scanon at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; On Dec 18, 2015, at 5:57 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; On Dec 18, 2015, at 1:12 PM, Stephen Canon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; Hi everybody —<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; I’d like to propose removing the “%” operator for floating-point types.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; I support removing this - it is actively harmful for a surprising operation like this to have such short and inviting syntax.  As asked downthread, have you given any thought into whether a Decimal type would support this operation?<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; The same concerns apply to decimal.  It makes sense to have the operation (for both binary and decimal floating-point) as “Type.remainder(a,b)” or a free function like &quot;remainder(a, b)”, but I would prefer not to use the operator “%” for it because it behaves very differently from integer %, and in ways that are not at all obvious to most users.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Great, I’d prefer decimal and the float types to have a consistent interface where possible.  +1 from me on the proposal.<br>&gt;&gt;  <br>&gt;&gt; Agreed. +1 from me too. The `10.0 % 0.1` behavior is sufficiently surprising that I think that justifies removal by itself.<br>&gt;&gt;  <br>&gt;&gt; I&#39;m also in favor of adding mod and remainder as instance methods of the floating point types, e.g. `10.0.mod(0.1)` (as opposed to static methods or free functions).<br>&gt; Shouldn’t that be added to any Arithmetic type?<br></p><p>We don&#39;t offer protocols that abstract over both integer and float arithmetic. They behave differently, and require different algorithms and interfaces. Floating-point types gaining a `mod` member does not necessarily mean integer types should get the same.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/8fec0191/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Proposal: Remove % operator for floating-point types</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>December 19, 2015 at 01:00:00pm</p></header><div class="content"><p>First of all great proposal, and thank you for trying to make it easier to<br>write safe code with Swift.<br></p><p>I feel like this proposal is more about human error than floating point<br>error.<br></p><p>I don&#39;t think this solves the precision issue. It makes it harder to use<br>fmod, but doesn&#39;t stop people wanting to, life finds a way. I completely<br>agree with your rationale, but if someone wants mod they&#39;ll use mod. The<br>question probably comes down to whether stackoverflow will tell them to use<br>fmod or remainder.<br></p><p>Regarding binding % to remainder, I think this is way too unexpected (a<br>much bigger gotcha):<br></p><p>3.0 % 4.0 == -1.0<br>3 % 4 == 3<br></p><p>I don&#39;t think we should change the binding to remainder.<br></p><p>If X.remainder(Y) is added to FloatingPointType I&#39;m fairly neutral about<br>the proposal to remove % on floating point types.<br></p><p>I feel like the deprecation warning is basically teaching people that<br>instead of using % you now have to use fmod, you haven&#39;t gained anything<br>except making their code less readable. Perhaps an automatic migration is<br>better, or perhaps the warning should make it clear there are potential<br>precision issues.<br></p><p>The deprecation warning could be something like this:<br></p><p>Deprecated due to precision issues, renamed to &#39;fmod&#39;, consider rewriting<br>to use &#39;remainder&#39; instead.<br></p><p>The issue with this I guess is that it is non-obvious how to change between<br>them, and I suspect attempts could just introduce similar or worse<br>precision issues.<br></p><p>It&#39;s almost a cliché on swift-evolution proposals, but I feel like my main<br>concerns here could almost be solved by a linter.  Has Apple considered<br>adding built-in support for an easily customisable linter? There&#39;s probably<br>an overlap with clang&#39;s static analyser.<br></p><p>On Sat, Dec 19, 2015 at 12:10 PM, Joe Groff via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Dec 18, 2015, at 3:40 PM, August Joki via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt;<br>&gt; -August<br>&gt;<br>&gt; On 18 Dec, 2015, at 15:31, Kevin Ballard via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Fri, Dec 18, 2015, at 03:04 PM, Chris Lattner via swift-evolution wrote:<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Dec 18, 2015, at 3:03 PM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Dec 18, 2015, at 5:57 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;<br>&gt; On Dec 18, 2015, at 1:12 PM, Stephen Canon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Hi everybody —<br>&gt;<br>&gt; I’d like to propose removing the “%” operator for floating-point types.<br>&gt;<br>&gt;<br>&gt; I support removing this - it is actively harmful for a surprising<br>&gt; operation like this to have such short and inviting syntax.  As asked<br>&gt; downthread, have you given any thought into whether a Decimal type would<br>&gt; support this operation?<br>&gt;<br>&gt;<br>&gt; The same concerns apply to decimal.  It makes sense to have the operation<br>&gt; (for both binary and decimal floating-point) as “Type.remainder(a,b)” or a<br>&gt; free function like &quot;remainder(a, b)”, but I would prefer not to use the<br>&gt; operator “%” for it because it behaves very differently from integer %, and<br>&gt; in ways that are not at all obvious to most users.<br>&gt;<br>&gt;<br>&gt; Great, I’d prefer decimal and the float types to have a consistent<br>&gt; interface where possible.  +1 from me on the proposal.<br>&gt;<br>&gt;<br>&gt; Agreed. +1 from me too. The `10.0 % 0.1` behavior is sufficiently<br>&gt; surprising that I think that justifies removal by itself.<br>&gt;<br>&gt; I&#39;m also in favor of adding mod and remainder as instance methods of the<br>&gt; floating point types, e.g. `10.0.mod(0.1)` (as opposed to static methods or<br>&gt; free functions).<br>&gt;<br>&gt; Shouldn’t that be added to any Arithmetic type?<br>&gt;<br>&gt;<br>&gt; We don&#39;t offer protocols that abstract over both integer and float<br>&gt; arithmetic. They behave differently, and require different algorithms and<br>&gt; interfaces. Floating-point types gaining a `mod` member does not<br>&gt; necessarily mean integer types should get the same.<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151219/f75bf6ba/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
