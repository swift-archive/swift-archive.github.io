<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Improvement proposal: change overflow behavior in successor()/predecessor() methods for Int types</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>April  7, 2016 at 10:00:00am</p></header><div class="content"><p>Hi All!<br>(Please let me know if that was already discussed. Searched, found nothing <br>related to such proposal.)<br></p><p>(TLDR: Suggest to change successor() method for Int values to follow <br>default Swift rules for integer overflow. Probably some kind of <br>successorWithOverflow could be introduced to use when needed)<br></p><p>Swift protects(trying to protect) us from Integer overflow problem, i.e. <br>when we want to do this:<br>let i : Int8 = Int8.max<br>let k : Int8 = i + 1<br>, we will have run-time error on second line. Swift protects us from using <br>(most likely) unexpected negative value (-128) for &lt;k&gt; variable in this case.<br></p><p>I believe this is really great and prevents our code from undefined <br>behavior and some security problems.<br>When we adds something to our Int variable in most cases we presume(and <br>create next code with that presumption) that in result we have a bigger <br>value in our variable. Not smaller and not negative(in case of signed Int).<br></p><p>If we really needs Integer overflow in our code(for example for some math), <br>we use special operator explicitly:<br>let k = i &amp;+ 1<br>and in this case we&#39;ll have -128 in &lt;k&gt; with no errors.<br></p><p>But. .successor() .predecessor() methods for Int values do not follow these <br>rules for overflow situations. I.e. :<br>let i : Int8 = Int8.max<br>let k : Int8 = i.successor()<br>- is OK for current Swift compiler. We have i==127 and k==-128, no run-time <br>error.<br></p><p>I&#39;m totally confused in this case. No explicit &#39;marker&#39; to allow integer <br>overflow. I don&#39;t expect to have (-128) in k, I&#39;m calling successor() to <br>get next mathematical value for &lt;i&gt; and (-128) is not next value for (127).<br></p><p>Even worse. In Swift 3.0 we have no ++ operator. You can find that often <br>.successor/.predecessor are recommended as replacement for ++ operator.<br>I.e. i++  =&gt;  i.successor(), I believe that many will choose this form over <br>i += 1 or i + 1. And in this case we lose our integer overflow protection <br>from Swift.<br></p><p>Suggestion is: change .successor/.predecessor for Int values to follow <br>overflow rules and probable introduce some <br>.successorWithOverflow/.predecessorWithOverflow if one need them in code.<br></p><p>Please let me know what do you think about this suggestion. Thank you.<br></p><p>P.S. Sorry for my English.<br></p><p>(Btw, I personally totally disagree with the chosen solution regarding <br>removing ++/--, I believe that we should leave ++ and -- as form of i += 1 <br>code. I.e. only as assignment for variable, drop all other variants of <br>using ++ and --.<br>And i += 1 is not just 1 char longer than i++ : in first case you have to <br>press 4 different keys/combinations and just one(the same twice) in second <br>case.<br>Just personal opinion :-) )<br></p><p>Vladimir.S<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Improvement proposal: change overflow behavior in successor()/predecessor() methods for Int types</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>April  7, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On 7 Apr 2016, at 08:20, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; (TLDR: Suggest to change successor() method for Int values to follow default Swift rules for integer overflow. Probably some kind of successorWithOverflow could be introduced to use when needed)<br></p><p>I’m a +1 for this; in fact, this is just how I assumed they worked, as the postcondition requirement for .successor() is that n.successor() &gt; n if I remember right, which clearly can’t be the case if the limit of the integer is reached, so a runtime error seems reasonable.<br></p><p>&gt; (Btw, I personally totally disagree with the chosen solution regarding removing ++/--, I believe that we should leave ++ and -- as form of i += 1 code. I.e. only as assignment for variable, drop all other variants of using ++ and --.<br>&gt; And i += 1 is not just 1 char longer than i++ : in first case you have to press 4 different keys/combinations and just one(the same twice) in second case.<br>&gt; Just personal opinion :-) )<br></p><p>These were removed for a bunch of reasons:<br>Requiring the use of += 1 or -=1 is more consistent (assignment always includes an equals sign)<br>It can easily lead to confusing cases when used in function parameters or complex statements, making it unclear at a glance what a value will actually be. Some people argued that the operator should just have no return type to counter this.<br>If the operator had no return type to address #2 then it basically becomes redundant when i += 1 is identical, but also more flexible.<br>They were most commonly used within C-style for loops, which Swift no longer has.<br>So I’m a -1 to anyone wanting those back ;)<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160407/2afea812/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Improvement proposal: change overflow behavior in successor()/predecessor() methods for Int types</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>April  7, 2016 at 08:00:00pm</p></header><div class="content"><p>This is exactly why I think successor()/predecessor() must raise runtime <br>error on integer overflow - because we(I believe) expect this behavior from <br>these funcs.<br>For example, someone, who don&#39;t know about current behavior of these <br>methods, can use them to increment/decrement index for some <br>collection/array and so produce hard-to-find errors or vulnerable code.<br></p><p>Any other opinion on this proposal please?<br></p><p><br>On 07.04.2016 14:31, Haravikk wrote:<br>&gt;<br>&gt;&gt; On 7 Apr 2016, at 08:20, Vladimir.S via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; (TLDR: Suggest to change successor() method for Int values to follow<br>&gt;&gt; default Swift rules for integer overflow. Probably some kind of<br>&gt;&gt; successorWithOverflow could be introduced to use when needed)<br>&gt;<br>&gt; I’m a +1 for this; in fact, this is just how I assumed they worked, as the<br>&gt; postcondition requirement for .successor() is that n.successor() &gt; n if I<br>&gt; remember right, which clearly can’t be the case if the limit of the integer<br>&gt; is reached, so a runtime error seems reasonable.<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Improvement proposal: change overflow behavior in successor()/predecessor() methods for Int types</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>April  7, 2016 at 10:00:00am</p></header><div class="content"><p>On Thu, Apr 7, 2016 at 12:20 AM, Vladimir.S via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; But. .successor() .predecessor() methods for Int values do not follow these<br>&gt; rules for overflow situations. I.e. :<br>&gt; let i : Int8 = Int8.max<br>&gt; let k : Int8 = i.successor()<br>&gt; - is OK for current Swift compiler. We have i==127 and k==-128, no run-time<br>&gt; error.<br></p><p>This was done for performance reasons.  Array&#39;s indices are Ints, and<br>adding an overflow check here was causing significant performance<br>issues when iterating over arrays.  These methods were not designed to<br>be used in contexts other than indices.  When ints are used as<br>indices, doing an overflow check in successor() does not prevent any<br>mistakes, since Array&#39;s bounds are always tighter than<br>Int.min...Int.max.<br></p><p>These methods are going away in the new indexing model.<br>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160229/011552.html<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Improvement proposal: change overflow behavior in successor()/predecessor() methods for Int types</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>April  7, 2016 at 09:00:00pm</p></header><div class="content"><p>OK, thank you for the clarification Dmitri.<br>If these methods are going away - no possible problems :-)<br>Will we have some kind of .next() method for integers in new indexing model <br>and in Swift 3.0 in general?<br></p><p><br>(But actually I don&#39;t agree that there is all OK with these functions in <br>current version of Swift. &quot;Not designed&quot; - understand, but they can be <br>used(so they will! be used) &quot;out of the box&quot;, even Int8 has these methods,<br>Int32.max is just 2GB for [Int8] etc..<br>Yes, in case of using successor() only with Int64 only for indices of Array <br>- all looks like OK.)<br></p><p><br>On 07.04.2016 20:54, Dmitri Gribenko wrote:<br>&gt; This was done for performance reasons.  Array&#39;s indices are Ints, and<br>&gt; adding an overflow check here was causing significant performance<br>&gt; issues when iterating over arrays.  These methods were not designed to<br>&gt; be used in contexts other than indices.  When ints are used as<br>&gt; indices, doing an overflow check in successor() does not prevent any<br>&gt; mistakes, since Array&#39;s bounds are always tighter than<br>&gt; Int.min...Int.max.<br>&gt;<br>&gt; These methods are going away in the new indexing model.<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160229/011552.html<br>&gt;<br>&gt; Dmitri<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Improvement proposal: change overflow behavior in successor()/predecessor() methods for Int types</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>April  7, 2016 at 11:00:00am</p></header><div class="content"><p>On Thu, Apr 7, 2016 at 11:27 AM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt; OK, thank you for the clarification Dmitri.<br>&gt; If these methods are going away - no possible problems :-)<br>&gt; Will we have some kind of .next() method for integers in new indexing model<br>&gt; and in Swift 3.0 in general?<br></p><p>There would be no need to.  Collection will have a .successor(of:)<br>method that returns the next index after the given one.<br></p><p>&gt; (But actually I don&#39;t agree that there is all OK with these functions in<br>&gt; current version of Swift. &quot;Not designed&quot; - understand, but they can be<br>&gt; used(so they will! be used) &quot;out of the box&quot;, even Int8 has these methods,<br>&gt; Int32.max is just 2GB for [Int8] etc..<br>&gt; Yes, in case of using successor() only with Int64 only for indices of Array<br>&gt; - all looks like OK.)<br></p><p>I can see that, but when you know that you are dealing with an<br>integer, isn&#39;t &quot;+ 1&quot; a more common and readable notation?<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Improvement proposal: change overflow behavior in successor()/predecessor() methods for Int types</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>April  8, 2016 at 01:00:00pm</p></header><div class="content"><p>On 07.04.2016 21:43, Dmitri Gribenko wrote:<br>&gt; There would be no need to.  Collection will have a .successor(of:)<br>&gt; method that returns the next index after the given one.<br>&gt;<br></p><p>I see. Thank you for letting know about this.<br></p><p>&gt; I can see that, but when you know that you are dealing with an<br>&gt; integer, isn&#39;t &quot;+ 1&quot; a more common and readable notation?<br></p><p>Hmm.. I believe that i++ is muuuch common used than i += 1 ;-)<br></p><p>Personally I totally agree with almost all reasons why we should drop these <br>++/--, but until this moment I was not agree that operator(not expression) <br>i++ (i.e. operator to increase i to 1 that do not return any value) <br>produces any problem in code. And it is so common in programming word, in <br>c/c++ which we will(!) use with our Swift code often, so it can&#39;t produce <br>any misunderstanding like &quot;what does this &quot;i++&quot; line do??&quot;<br>(again, just operator, like: if something { someInt++ } )<br></p><p>But now, I was pointed that someInt += 1 is better because of this &quot;=&quot; char <br>in operator i.e. we clearly say that we will assign the value to variable, <br>mutate it.<br>And I think this makes the language better, so right now I fully support <br>the decision to remove ++/--<br></p><p>So.. Thank you for your time and your replies :-)<br></p><p>Vladimir.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Improvement proposal: change overflow behavior in successor()/predecessor() methods for Int types</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>April  8, 2016 at 09:00:00am</p></header><div class="content"><p>On Fri, Apr 8, 2016 at 3:49 AM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On 07.04.2016 21:43, Dmitri Gribenko wrote:<br>&gt;&gt;<br>&gt;&gt; There would be no need to.  Collection will have a .successor(of:)<br>&gt;&gt; method that returns the next index after the given one.<br>&gt;&gt;<br>&gt;<br>&gt; I see. Thank you for letting know about this.<br>&gt;<br>&gt;&gt; I can see that, but when you know that you are dealing with an<br>&gt;&gt; integer, isn&#39;t &quot;+ 1&quot; a more common and readable notation?<br>&gt;<br>&gt;<br>&gt; Hmm.. I believe that i++ is muuuch common used than i += 1 ;-)<br></p><p>The reason why I said &quot;+ 1&quot; is because this discussion is about<br>Int.successor(), which returns a new Int rather than mutating it in<br>place.  So i++ and i += 1 are not direct replacements for<br>Int.successor().<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Improvement proposal: change overflow behavior in successor()/predecessor() methods for Int types</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>April 23, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On 7 Apr 2016, at 18:54, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Thu, Apr 7, 2016 at 12:20 AM, Vladimir.S via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; But. .successor() .predecessor() methods for Int values do not follow these<br>&gt;&gt; rules for overflow situations. I.e. :<br>&gt;&gt; let i : Int8 = Int8.max<br>&gt;&gt; let k : Int8 = i.successor()<br>&gt;&gt; - is OK for current Swift compiler. We have i==127 and k==-128, no run-time<br>&gt;&gt; error.<br>&gt; <br>&gt; This was done for performance reasons.  Array&#39;s indices are Ints, and<br>&gt; adding an overflow check here was causing significant performance<br>&gt; issues when iterating over arrays.<br></p><p>Sorry to bump this after it’s been idle for a little while, but I was thinking about this again recently and I can’t come up with a test that verifies a meaningful performance difference. I just threw the following into a playground:<br></p><p>import Foundation<br></p><p>do {<br>    let startTime = NSDate().timeIntervalSince1970<br>    var i = 0<br>    while i &lt; 1000000 { i = i &amp;+ 1 }<br>    let elapsed = NSDate().timeIntervalSince1970 - startTime<br>}<br></p><p>do {<br>    let startTime = NSDate().timeIntervalSince1970<br>    var i = 0<br>    while i &lt; 1000000 { i = i + 1 }<br>    let elapsed = NSDate().timeIntervalSince1970 - startTime<br>}<br></p><p>My results come out with no discernible performance difference; I suspect that this a side-effect of the iteration and storing overhead, but it seems to me that this is the kind of minimum boilerplate you are going to have anyway if you’re using .successor(). I know the issue is specifically with array iteration, but I don’t believe I actually need an array involved to demonstrate this, in fact the extra overhead would make the difference even less noticeable.<br></p><p>Is there a test that can demonstrate a more extreme difference? Even so, if the issue is with array iteration then it seems that the best place to fix that is in the array’s generator, rather than using the more generic IndexingGenerator that has no awareness of the underlying index type.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160423/52b38679/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
