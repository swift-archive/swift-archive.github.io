<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8016afa037fa775c19d05b495a24413f?s=50"></div><header><strong>UnsafeMutablePointer Swift 3 conversion</strong> from <string>Patrice Kouame</string> &lt;pkouame at me.com&gt;<p>September  2, 2016 at 02:00:00pm</p></header><div class="content"><p>Hi all - <br></p><p>I’m converting Apple’s Swift Sample &quot;Adopting Metal II: Designing and Implementing a Real-World Metal Renderer” in Xcode 8 beta6 to the latest UnsafeMutablePointer API for untyped memory access.  <br>Changes are necessary in MetalView.swift (Apple hasn’t updated their sample code for the latest beta yet…) <br>The Swift Compiler crashes (Segmentation Fault: 11) on the attempt:<br></p><p>        // Grab a pointer to the constant buffer&#39;s data store<br>        // Since we are using Swift, it is easier to cast the pointer to the ShadowPass type to fill the constant buffer<br>        // We need to make a copy of these so the block captures the correct data<br></p><p>//      let shadowPtr = UnsafeMutablePointer&lt;ShadowPass&gt;(constantBufferForFrame.contents())<br>        let shadowPtr = constantBufferForFrame.contents().bindMemory(to: ShadowPass.self, capacity: MemoryLayout&lt;ShadowPass&gt;.size)<br>        shadowPtr.pointee = shadowPassData[0]<br></p><p>        //More Swift specific stuff - advance pointer and cast to MainPass<br></p><p>//      let mainPtr = UnsafeMutablePointer&lt;MainPass&gt;(shadowPtr.advanced(by: 1))<br>//      mainPtr.pointee = mainPassFrameData<br>        let mainPtr : UnsafeMutablePointer&lt;MainPass&gt;  = shadowPtr.advanced(by: 1).withMemoryRebound(to: MainPass.self, capacity: MemoryLayout&lt;MainPass&gt;.size) {<br>            $0.pointee = mainPassFrameData<br>        }<br>        <br>        //Advance and cast to ObjectData<br>        <br>//      var ptr = UnsafeMutablePointer&lt;ObjectData&gt;(mainPtr.advanced(by: 1))<br>        var ptr : UnsafeMutablePointer&lt;ObjectData&gt; = mainPtr.advanced(by: 1).withMemoryRebound(to: ObjectData.self, capacity: MemoryLayout&lt;ObjectData&gt;.size) {_ in<br>        }<br></p><p>        let shadowOffset = 0<br>        let mainPassOffset = MemoryLayout&lt;ShadowPass&gt;.size + shadowOffset<br>        let objectDataOffset = MemoryLayout&lt;MainPass&gt;.size + mainPassOffset<br></p><p>        // Update position of all the objects<br>        if multithreadedUpdate {<br>            DispatchQueue.concurrentPerform(iterations: objectsToRender) { i in<br>                let thisPtr = ptr.advanced(by: i)<br>                _ = self.renderables[i].UpdateData(ptr, deltaTime: 1.0/60.0)<br>            }<br>        }<br>        else {<br>            for index in 0..&lt;objectsToRender {<br>                ptr = renderables[index].UpdateData(ptr, deltaTime: 1.0/60.0)<br>            }<br>        }<br>        <br>        ptr = ptr.advanced(by: objectsToRender)<br>        <br>        _ = groundPlane!.UpdateData(ptr, deltaTime: 1.0/60.0)<br></p><p>Any help is appreciated.  I have the latest Xcode log handy if necessary.  Here’s a clip of the stack trace.<br></p><p>0  swift                    0x000000010714a99d PrintStackTraceSignalHandler(void*) + 45<br>1  swift                    0x000000010714a3e6 SignalHandler(int) + 470<br>2  libsystem_platform.dylib 0x00007fff91461bba _sigtramp + 26<br>3  libsystem_platform.dylib 000000000000000000 _sigtramp + 1857676384<br>4  swift                    0x00000001047207b3 (anonymous namespace)::SILGenApply::visitExpr(swift::Expr*) + 51<br>5  swift                    0x0000000104723ace (anonymous namespace)::SILGenApply::visitApplyExpr(swift::ApplyExpr*) + 5182<br>6  swift                    0x0000000104711cc1 prepareApplyExpr(swift::Lowering::SILGenFunction&amp;, swift::Expr*) + 273<br>7  swift                    0x00000001047624e7 swift::ASTVisitor&lt;(anonymous namespace)::RValueEmitter, swift::Lowering::RValue, void, void, void, void, void, swift::Lowering::SGFContext&gt;::visit(swift::Expr*, swift::Lowering::SGFContext) + 103<br>8  swift                    0x0000000104762313 swift::Lowering::SILGenFunction::emitExprInto(swift::Expr*, swift::Lowering::Initialization*) + 195<br>9  swift                    0x000000010474fbc3 swift::Lowering::SILGenFunction::emitPatternBinding(swift::PatternBindingDecl*, unsigned int) + 195<br>10 swift                    0x00000001047077bd swift::ASTVisitor&lt;swift::Lowering::SILGenFunction, void, void, void, void, void, void&gt;::visit(swift::Decl*) + 125<br>11 swift                    0x00000001047c0019 swift::ASTVisitor&lt;(anonymous namespace)::StmtEmitter, void, void, void, void, void, void&gt;::visit(swift::Stmt*) + 4169<br>12 swift                    0x00000001047809ba swift::Lowering::SILGenFunction::emitFunction(swift::FuncDecl*) + 314<br>13 swift                    0x00000001046fd775 swift::Lowering::SILGenModule::emitFunction(swift::FuncDecl*)::$_1::operator()(swift::SILFunction*) const + 1877<br>14 swift                    0x00000001046fc322 swift::Lowering::SILGenModule::emitFunction(swift::FuncDecl*) + 626<br>15 swift                    0x00000001047c7007 (anonymous namespace)::SILGenType::emitType() + 1271<br>16 swift                    0x00000001047c6a9e swift::Lowering::SILGenModule::visitNominalTypeDecl(swift::NominalTypeDecl*) + 30<br>17 swift                    0x0000000104709093 swift::Lowering::SILGenModule::emitSourceFile(swift::SourceFile*, unsigned int) + 1795<br>18 swift                    0x000000010470ad4d swift::SILModule::constructSIL(swift::ModuleDecl*, swift::SILOptions&amp;, swift::FileUnit*, llvm::Optional&lt;unsigned int&gt;, bool, bool) + 1629<br>19 swift                    0x00000001045621bf performCompile(swift::CompilerInstance&amp;, swift::CompilerInvocation&amp;, llvm::ArrayRef&lt;char const*&gt;, int&amp;, swift::FrontendObserver*) + 19487<br>20 swift                    0x000000010455b2c5 swift::performFrontend(llvm::ArrayRef&lt;char const*&gt;, char const*, void*, swift::FrontendObserver*) + 17029<br>21 swift                    0x000000010451888d main + 8685<br>22 libdyld.dylib            0x00007fff91255255 start + 1<br></p><p><br>Patrice<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160902/da168a9b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>UnsafeMutablePointer Swift 3 conversion</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>September  2, 2016 at 11:00:00pm</p></header><div class="content"><p>Hi Patrice,<br>I don&#39;t have a solution for you, but I just wanted to point out what I<br>think may be an error with your use of the new UnsafeRawPointer APIs:<br></p><p>constantBufferForFrame.contents().bindMemory(to: ShadowPass.self, capacity:<br>MemoryLayout&lt;ShadowPass&gt;.size)<br></p><p>I believe the `capacity` should actually be the number of ShadowPass<br>elements in the buffer, not the size of each element. Using `bindMemory(to:<br>ShadowPass.self` already implies that MemoryLayout&lt;ShadowPass&gt;.size is the<br>size of each element.<br></p><p>More info at<br>https://developer.apple.com/reference/swift/unsaferawpointer/2428875-bindmemory<br></p><p>I just updated a small Metal project of mine to Swift 3. I ran into some<br>compiler (playground) crashes, but it does seem to work most of the time.<br>Although I only have 1 buffer :-)<br>https://github.com/jtbandes/Metalbrot.playground<br></p><p>Jacob<br></p><p>On Fri, Sep 2, 2016 at 11:00 AM, Patrice Kouame via swift-users &lt;<br>swift-users at swift.org&gt; wrote:<br></p><p>&gt; Hi all -<br>&gt;<br>&gt; I’m converting Apple’s Swift Sample &quot;Adopting Metal II: Designing and<br>&gt; Implementing a Real-World Metal Renderer” in Xcode 8 beta6 to the latest<br>&gt; UnsafeMutablePointer API for untyped memory access.<br>&gt; Changes are necessary in MetalView.swift (Apple hasn’t updated their<br>&gt; sample code for the latest beta yet…)<br>&gt; The Swift Compiler crashes (Segmentation Fault: 11) on the attempt:<br>&gt;<br>&gt;         // Grab a pointer to the constant buffer&#39;s data store<br>&gt;         // Since we are using Swift, it is easier to cast the pointer to<br>&gt; the ShadowPass type to fill the constant buffer<br>&gt;         // We need to make a copy of these so the block captures the<br>&gt; correct data<br>&gt;<br>&gt; //      let shadowPtr = UnsafeMutablePointer&lt;ShadowPass&gt;(<br>&gt; constantBufferForFrame.contents())<br>&gt;         let shadowPtr = constantBufferForFrame.contents().bindMemory(to:<br>&gt; ShadowPass.self, capacity: MemoryLayout&lt;ShadowPass&gt;.size)<br>&gt;         shadowPtr.pointee = shadowPassData[0]<br>&gt;<br>&gt;         //More Swift specific stuff - advance pointer and cast to MainPass<br>&gt;<br>&gt; //      let mainPtr = UnsafeMutablePointer&lt;MainPass&gt;(shadowPtr.advanced(by:<br>&gt; 1))<br>&gt; //      mainPtr.pointee = mainPassFrameData<br>&gt;         let mainPtr : UnsafeMutablePointer&lt;MainPass&gt;  =<br>&gt; shadowPtr.advanced(by: 1).withMemoryRebound(to: MainPass.self, capacity:<br>&gt; MemoryLayout&lt;MainPass&gt;.size) {<br>&gt;             $0.pointee = mainPassFrameData<br>&gt;         }<br>&gt;<br>&gt;<br>&gt;         //Advance and cast to ObjectData<br>&gt;<br>&gt;<br>&gt; //      var ptr = UnsafeMutablePointer&lt;ObjectData&gt;(mainPtr.advanced(by:<br>&gt; 1))<br>&gt;         var ptr : UnsafeMutablePointer&lt;ObjectData&gt; = mainPtr.advanced(by:<br>&gt; 1).withMemoryRebound(to: ObjectData.self, capacity: MemoryLayout&lt;<br>&gt; ObjectData&gt;.size) {_ in<br>&gt;         }<br>&gt;<br>&gt;         let shadowOffset = 0<br>&gt;         let mainPassOffset = MemoryLayout&lt;ShadowPass&gt;.size + shadowOffset<br>&gt;         let objectDataOffset = MemoryLayout&lt;MainPass&gt;.size +<br>&gt; mainPassOffset<br>&gt;<br>&gt;         // Update position of all the objects<br>&gt;         if multithreadedUpdate {<br>&gt;             DispatchQueue.concurrentPerform(iterations: objectsToRender)<br>&gt; { i in<br>&gt;                 let thisPtr = ptr.advanced(by: i)<br>&gt;                 _ = self.renderables[i].UpdateData(ptr, deltaTime: 1.0/<br>&gt; 60.0)<br>&gt;             }<br>&gt;         }<br>&gt;         else {<br>&gt;             for index in 0..&lt;objectsToRender {<br>&gt;                 ptr = renderables[index].UpdateData(ptr, deltaTime: 1.0/<br>&gt; 60.0)<br>&gt;             }<br>&gt;         }<br>&gt;<br>&gt;<br>&gt;         ptr = ptr.advanced(by: objectsToRender)<br>&gt;<br>&gt;<br>&gt;         _ = groundPlane!.UpdateData(ptr, deltaTime: 1.0/60.0)<br>&gt;<br>&gt; Any help is appreciated.  I have the latest Xcode log handy if necessary.<br>&gt; Here’s a clip of the stack trace.<br>&gt;<br>&gt; 0  swift                    0x000000010714a99d<br>&gt; PrintStackTraceSignalHandler(void*) + 45<br>&gt; 1  swift                    0x000000010714a3e6 SignalHandler(int) + 470<br>&gt; 2  libsystem_platform.dylib 0x00007fff91461bba _sigtramp + 26<br>&gt; 3  libsystem_platform.dylib 000000000000000000 _sigtramp + 1857676384<br>&gt; 4  swift                    0x00000001047207b3 (anonymous<br>&gt; namespace)::SILGenApply::visitExpr(swift::Expr*) + 51<br>&gt; 5  swift                    0x0000000104723ace (anonymous<br>&gt; namespace)::SILGenApply::visitApplyExpr(swift::ApplyExpr*) + 5182<br>&gt; 6  swift                    0x0000000104711cc1 prepareApplyExpr(swift::Lowering::SILGenFunction&amp;,<br>&gt; swift::Expr*) + 273<br>&gt; 7  swift                    0x00000001047624e7<br>&gt; swift::ASTVisitor&lt;(anonymous namespace)::RValueEmitter,<br>&gt; swift::Lowering::RValue, void, void, void, void, void,<br>&gt; swift::Lowering::SGFContext&gt;::visit(swift::Expr*,<br>&gt; swift::Lowering::SGFContext) + 103<br>&gt; 8  swift                    0x0000000104762313 swift::Lowering::<br>&gt; SILGenFunction::emitExprInto(swift::Expr*, swift::Lowering::Initialization*)<br>&gt; + 195<br>&gt; 9  swift                    0x000000010474fbc3 swift::Lowering::<br>&gt; SILGenFunction::emitPatternBinding(swift::PatternBindingDecl*, unsigned<br>&gt; int) + 195<br>&gt; 10 swift                    0x00000001047077bd swift::ASTVisitor&lt;swift::Lowering::SILGenFunction,<br>&gt; void, void, void, void, void, void&gt;::visit(swift::Decl*) + 125<br>&gt; 11 swift                    0x00000001047c0019<br>&gt; swift::ASTVisitor&lt;(anonymous namespace)::StmtEmitter, void, void, void,<br>&gt; void, void, void&gt;::visit(swift::Stmt*) + 4169<br>&gt; 12 swift                    0x00000001047809ba swift::Lowering::<br>&gt; SILGenFunction::emitFunction(swift::FuncDecl*) + 314<br>&gt; 13 swift                    0x00000001046fd775<br>&gt; swift::Lowering::SILGenModule::emitFunction(swift::FuncDecl*<br>&gt; )::$_1::operator()(swift::SILFunction*) const + 1877<br>&gt; 14 swift                    0x00000001046fc322<br>&gt; swift::Lowering::SILGenModule::emitFunction(swift::FuncDecl*) + 626<br>&gt; 15 swift                    0x00000001047c7007 (anonymous<br>&gt; namespace)::SILGenType::emitType() + 1271<br>&gt; 16 swift                    0x00000001047c6a9e<br>&gt; swift::Lowering::SILGenModule::visitNominalTypeDecl(swift::NominalTypeDecl*)<br>&gt; + 30<br>&gt; 17 swift                    0x0000000104709093<br>&gt; swift::Lowering::SILGenModule::emitSourceFile(swift::SourceFile*,<br>&gt; unsigned int) + 1795<br>&gt; 18 swift                    0x000000010470ad4d swift::SILModule::<br>&gt; constructSIL(swift::ModuleDecl*, swift::SILOptions&amp;, swift::FileUnit*,<br>&gt; llvm::Optional&lt;unsigned int&gt;, bool, bool) + 1629<br>&gt; 19 swift                    0x00000001045621bf performCompile(swift::CompilerInstance&amp;,<br>&gt; swift::CompilerInvocation&amp;, llvm::ArrayRef&lt;char const*&gt;, int&amp;,<br>&gt; swift::FrontendObserver*) + 19487<br>&gt; 20 swift                    0x000000010455b2c5<br>&gt; swift::performFrontend(llvm::ArrayRef&lt;char const*&gt;, char const*, void*,<br>&gt; swift::FrontendObserver*) + 17029<br>&gt; 21 swift                    0x000000010451888d main + 8685<br>&gt; 22 libdyld.dylib            0x00007fff91255255 start + 1<br>&gt;<br>&gt;<br>&gt; Patrice<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160902/0faa39ed/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8016afa037fa775c19d05b495a24413f?s=50"></div><header><strong>UnsafeMutablePointer Swift 3 conversion</strong> from <string>Patrice Kouame</string> &lt;pkouame at me.com&gt;<p>September  3, 2016 at 04:00:00am</p></header><div class="content"><p>Hi Jacob - <br></p><p>I think you’re right. “capacity” should be the count of type T elements in my buffer.  So in my case that line should read<br></p><p>        let shadowPtr = constantBufferForFrame.contents().bindMemory(to: ShadowPass.self, capacity: shadowPassData.count)<br></p><p>The withMemoryRebound calls need similar adjustments. The pointer to MainPass is actually a single structure to it should be safe to do this<br></p><p>        let mainPtr : UnsafeMutablePointer&lt;MainPass&gt; = shadowPtr.advanced(by: 1).withMemoryRebound(to: MainPass.self, capacity: 1) {<br>            $0.pointee = mainPassFrameData<br>        }<br></p><p>Whereas the unsafe pointer to &lt;ObjectData&gt; is actually a buffer of renderable objects, so this should work:<br></p><p>        var ptr : UnsafeMutablePointer&lt;ObjectData&gt; = mainPtr.advanced(by: 1).withMemoryRebound(to: ObjectData.self, capacity: objectsToRender) {_ in<br>	}<br></p><p>There are surely ways to refactor and simplify this, but I’m trying to retain as much of the original sample code approach as possible.<br></p><p>However, the compiler still segs badly. <br>Xcode also borks an internal error often. Only cleaning or restarting the project can clear up that state.<br>Compilers (or Playgrounds for that matter) should never crash, and I’m not sure where to file this bug : Swift or Apple radar against Xcode or both? I now Xcode 8 is beta but…it’s been doing this for quite a while now...<br></p><p>In both our “close to the metal” (no pun intended) cases, it seems like a lot of churning for very little gain. Don’t you think? The easier, but “unsafe” casting afforded previously did the trick with the normal caveats.<br>Don’t get me wrong, I love Swift and “get&quot; all the neat type safety features. Guess we can’t have our cake and eat it too, especially when interfacing with “unsafe” C APIs.<br></p><p>Anyway, back to rtfm … maybe some of the Swift Gods can chime in?  ;-) <br></p><p>I must be doing something stupid...Patrice<br></p><p>&gt; On Sep 3, 2016, at 2:32 AM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt; Hi Patrice,<br>&gt; I don&#39;t have a solution for you, but I just wanted to point out what I think may be an error with your use of the new UnsafeRawPointer APIs:<br>&gt; <br>&gt; constantBufferForFrame.contents().bindMemory(to: ShadowPass.self, capacity: MemoryLayout&lt;ShadowPass&gt;.size)<br>&gt; <br>&gt; I believe the `capacity` should actually be the number of ShadowPass elements in the buffer, not the size of each element. Using `bindMemory(to: ShadowPass.self` already implies that MemoryLayout&lt;ShadowPass&gt;.size is the size of each element.<br>&gt; <br>&gt; More info at https://developer.apple.com/reference/swift/unsaferawpointer/2428875-bindmemory &lt;https://developer.apple.com/reference/swift/unsaferawpointer/2428875-bindmemory&gt;<br>&gt; <br>&gt; I just updated a small Metal project of mine to Swift 3. I ran into some compiler (playground) crashes, but it does seem to work most of the time. Although I only have 1 buffer :-) https://github.com/jtbandes/Metalbrot.playground &lt;https://github.com/jtbandes/Metalbrot.playground&gt;<br>&gt; <br>&gt; Jacob<br>&gt; <br>&gt; On Fri, Sep 2, 2016 at 11:00 AM, Patrice Kouame via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt; Hi all - <br>&gt; <br>&gt; I’m converting Apple’s Swift Sample &quot;Adopting Metal II: Designing and Implementing a Real-World Metal Renderer” in Xcode 8 beta6 to the latest UnsafeMutablePointer API for untyped memory access.  <br>&gt; Changes are necessary in MetalView.swift (Apple hasn’t updated their sample code for the latest beta yet…) <br>&gt; The Swift Compiler crashes (Segmentation Fault: 11) on the attempt:<br>&gt; <br>&gt;         // Grab a pointer to the constant buffer&#39;s data store<br>&gt;         // Since we are using Swift, it is easier to cast the pointer to the ShadowPass type to fill the constant buffer<br>&gt;         // We need to make a copy of these so the block captures the correct data<br>&gt; <br>&gt; //      let shadowPtr = UnsafeMutablePointer&lt;ShadowPass&gt;(constantBufferForFrame.contents())<br>&gt;         let shadowPtr = constantBufferForFrame.contents().bindMemory(to: ShadowPass.self, capacity: MemoryLayout&lt;ShadowPass&gt;.size)<br>&gt;         shadowPtr.pointee = shadowPassData[0]<br>&gt; <br>&gt;         //More Swift specific stuff - advance pointer and cast to MainPass<br>&gt; <br>&gt; //      let mainPtr = UnsafeMutablePointer&lt;MainPass&gt;(shadowPtr.advanced(by: 1))<br>&gt; //      mainPtr.pointee = mainPassFrameData<br>&gt;         let mainPtr : UnsafeMutablePointer&lt;MainPass&gt;  = shadowPtr.advanced(by: 1).withMemoryRebound(to: MainPass.self, capacity: MemoryLayout&lt;MainPass&gt;.size) {<br>&gt;             $0.pointee = mainPassFrameData<br>&gt;         }<br>&gt;         <br>&gt;         //Advance and cast to ObjectData<br>&gt;         <br>&gt; //      var ptr = UnsafeMutablePointer&lt;ObjectData&gt;(mainPtr.advanced(by: 1))<br>&gt;         var ptr : UnsafeMutablePointer&lt;ObjectData&gt; = mainPtr.advanced(by: 1).withMemoryRebound(to: ObjectData.self, capacity: MemoryLayout&lt;ObjectData&gt;.size) {_ in<br>&gt;         }<br>&gt; <br>&gt;         let shadowOffset = 0<br>&gt;         let mainPassOffset = MemoryLayout&lt;ShadowPass&gt;.size + shadowOffset<br>&gt;         let objectDataOffset = MemoryLayout&lt;MainPass&gt;.size + mainPassOffset<br>&gt; <br>&gt;         // Update position of all the objects<br>&gt;         if multithreadedUpdate {<br>&gt;             DispatchQueue.concurrentPerform(iterations: objectsToRender) { i in<br>&gt;                 let thisPtr = ptr.advanced(by: i)<br>&gt;                 _ = self.renderables[i].UpdateData(ptr, deltaTime: 1.0/60.0)<br>&gt;             }<br>&gt;         }<br>&gt;         else {<br>&gt;             for index in 0..&lt;objectsToRender {<br>&gt;                 ptr = renderables[index].UpdateData(ptr, deltaTime: 1.0/60.0)<br>&gt;             }<br>&gt;         }<br>&gt;         <br>&gt;         ptr = ptr.advanced(by: objectsToRender)<br>&gt;         <br>&gt;         _ = groundPlane!.UpdateData(ptr, deltaTime: 1.0/60.0)<br>&gt; <br>&gt; Any help is appreciated.  I have the latest Xcode log handy if necessary.  Here’s a clip of the stack trace.<br>&gt; <br>&gt; 0  swift                    0x000000010714a99d PrintStackTraceSignalHandler(void*) + 45<br>&gt; 1  swift                    0x000000010714a3e6 SignalHandler(int) + 470<br>&gt; 2  libsystem_platform.dylib 0x00007fff91461bba _sigtramp + 26<br>&gt; 3  libsystem_platform.dylib 000000000000000000 _sigtramp + 1857676384<br>&gt; 4  swift                    0x00000001047207b3 (anonymous namespace)::SILGenApply::visitExpr(swift::Expr*) + 51<br>&gt; 5  swift                    0x0000000104723ace (anonymous namespace)::SILGenApply::visitApplyExpr(swift::ApplyExpr*) + 5182<br>&gt; 6  swift                    0x0000000104711cc1 prepareApplyExpr(swift::Lowering::SILGenFunction&amp;, swift::Expr*) + 273<br>&gt; 7  swift                    0x00000001047624e7 swift::ASTVisitor&lt;(anonymous namespace)::RValueEmitter, swift::Lowering::RValue, void, void, void, void, void, swift::Lowering::SGFContext&gt;::visit(swift::Expr*, swift::Lowering::SGFContext) + 103<br>&gt; 8  swift                    0x0000000104762313 swift::Lowering::SILGenFunction::emitExprInto(swift::Expr*, swift::Lowering::Initialization*) + 195<br>&gt; 9  swift                    0x000000010474fbc3 swift::Lowering::SILGenFunction::emitPatternBinding(swift::PatternBindingDecl*, unsigned int) + 195<br>&gt; 10 swift                    0x00000001047077bd swift::ASTVisitor&lt;swift::Lowering::SILGenFunction, void, void, void, void, void, void&gt;::visit(swift::Decl*) + 125<br>&gt; 11 swift                    0x00000001047c0019 swift::ASTVisitor&lt;(anonymous namespace)::StmtEmitter, void, void, void, void, void, void&gt;::visit(swift::Stmt*) + 4169<br>&gt; 12 swift                    0x00000001047809ba swift::Lowering::SILGenFunction::emitFunction(swift::FuncDecl*) + 314<br>&gt; 13 swift                    0x00000001046fd775 swift::Lowering::SILGenModule::emitFunction(swift::FuncDecl*)::$_1::operator()(swift::SILFunction*) const + 1877<br>&gt; 14 swift                    0x00000001046fc322 swift::Lowering::SILGenModule::emitFunction(swift::FuncDecl*) + 626<br>&gt; 15 swift                    0x00000001047c7007 (anonymous namespace)::SILGenType::emitType() + 1271<br>&gt; 16 swift                    0x00000001047c6a9e swift::Lowering::SILGenModule::visitNominalTypeDecl(swift::NominalTypeDecl*) + 30<br>&gt; 17 swift                    0x0000000104709093 swift::Lowering::SILGenModule::emitSourceFile(swift::SourceFile*, unsigned int) + 1795<br>&gt; 18 swift                    0x000000010470ad4d swift::SILModule::constructSIL(swift::ModuleDecl*, swift::SILOptions&amp;, swift::FileUnit*, llvm::Optional&lt;unsigned int&gt;, bool, bool) + 1629<br>&gt; 19 swift                    0x00000001045621bf performCompile(swift::CompilerInstance&amp;, swift::CompilerInvocation&amp;, llvm::ArrayRef&lt;char const*&gt;, int&amp;, swift::FrontendObserver*) + 19487<br>&gt; 20 swift                    0x000000010455b2c5 swift::performFrontend(llvm::ArrayRef&lt;char const*&gt;, char const*, void*, swift::FrontendObserver*) + 17029<br>&gt; 21 swift                    0x000000010451888d main + 8685<br>&gt; 22 libdyld.dylib            0x00007fff91255255 start + 1<br>&gt; <br>&gt; <br>&gt; Patrice<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160903/e9e42ef4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f0c42759e3b302ee8b0665d8b59c1197?s=50"></div><header><strong>UnsafeMutablePointer Swift 3 conversion</strong> from <string>Gerard Iglesias</string> &lt;gerard_iglesias at me.com&gt;<p>September  3, 2016 at 05:00:00pm</p></header><div class="content"><p>Hello,<br></p><p>I think that it is more secure to use stride in place of size, sometimes it is not the same value.<br></p><p>I use it in my own use of raw bindings <br></p><p>Regards<br></p><p>Gérard <br></p><p>&gt; Le 3 sept. 2016 à 10:03, Patrice Kouame via swift-users &lt;swift-users at swift.org&gt; a écrit :<br>&gt; <br>&gt; Hi Jacob - <br>&gt; <br>&gt; I think you’re right. “capacity” should be the count of type T elements in my buffer.  So in my case that line should read<br>&gt; <br>&gt;         let shadowPtr = constantBufferForFrame.contents().bindMemory(to: ShadowPass.self, capacity: shadowPassData.count)<br>&gt; <br>&gt; The withMemoryRebound calls need similar adjustments. The pointer to MainPass is actually a single structure to it should be safe to do this<br>&gt; <br>&gt;         let mainPtr : UnsafeMutablePointer&lt;MainPass&gt; = shadowPtr.advanced(by: 1).withMemoryRebound(to: MainPass.self, capacity: 1) {<br>&gt;             $0.pointee = mainPassFrameData<br>&gt;         }<br>&gt; <br>&gt; Whereas the unsafe pointer to &lt;ObjectData&gt; is actually a buffer of renderable objects, so this should work:<br>&gt; <br>&gt;         var ptr : UnsafeMutablePointer&lt;ObjectData&gt; = mainPtr.advanced(by: 1).withMemoryRebound(to: ObjectData.self, capacity: objectsToRender) {_ in<br>&gt; 	}<br>&gt; <br>&gt; There are surely ways to refactor and simplify this, but I’m trying to retain as much of the original sample code approach as possible.<br>&gt; <br>&gt; However, the compiler still segs badly. <br>&gt; Xcode also borks an internal error often. Only cleaning or restarting the project can clear up that state.<br>&gt; Compilers (or Playgrounds for that matter) should never crash, and I’m not sure where to file this bug : Swift or Apple radar against Xcode or both? I now Xcode 8 is beta but…it’s been doing this for quite a while now...<br>&gt; <br>&gt; In both our “close to the metal” (no pun intended) cases, it seems like a lot of churning for very little gain. Don’t you think? The easier, but “unsafe” casting afforded previously did the trick with the normal caveats.<br>&gt; Don’t get me wrong, I love Swift and “get&quot; all the neat type safety features. Guess we can’t have our cake and eat it too, especially when interfacing with “unsafe” C APIs.<br>&gt; <br>&gt; Anyway, back to rtfm … maybe some of the Swift Gods can chime in?  ;-) <br>&gt; <br>&gt; I must be doing something stupid...Patrice<br>&gt; <br>&gt;&gt; On Sep 3, 2016, at 2:32 AM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi Patrice,<br>&gt;&gt; I don&#39;t have a solution for you, but I just wanted to point out what I think may be an error with your use of the new UnsafeRawPointer APIs:<br>&gt;&gt; <br>&gt;&gt; constantBufferForFrame.contents().bindMemory(to: ShadowPass.self, capacity: MemoryLayout&lt;ShadowPass&gt;.size)<br>&gt;&gt; <br>&gt;&gt; I believe the `capacity` should actually be the number of ShadowPass elements in the buffer, not the size of each element. Using `bindMemory(to: ShadowPass.self` already implies that MemoryLayout&lt;ShadowPass&gt;.size is the size of each element.<br>&gt;&gt; <br>&gt;&gt; More info at https://developer.apple.com/reference/swift/unsaferawpointer/2428875-bindmemory<br>&gt;&gt; <br>&gt;&gt; I just updated a small Metal project of mine to Swift 3. I ran into some compiler (playground) crashes, but it does seem to work most of the time. Although I only have 1 buffer :-) https://github.com/jtbandes/Metalbrot.playground<br>&gt;&gt; <br>&gt;&gt; Jacob<br>&gt;&gt; <br>&gt;&gt;&gt; On Fri, Sep 2, 2016 at 11:00 AM, Patrice Kouame via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt; Hi all - <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m converting Apple’s Swift Sample &quot;Adopting Metal II: Designing and Implementing a Real-World Metal Renderer” in Xcode 8 beta6 to the latest UnsafeMutablePointer API for untyped memory access.  <br>&gt;&gt;&gt; Changes are necessary in MetalView.swift (Apple hasn’t updated their sample code for the latest beta yet…) <br>&gt;&gt;&gt; The Swift Compiler crashes (Segmentation Fault: 11) on the attempt:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         // Grab a pointer to the constant buffer&#39;s data store<br>&gt;&gt;&gt;         // Since we are using Swift, it is easier to cast the pointer to the ShadowPass type to fill the constant buffer<br>&gt;&gt;&gt;         // We need to make a copy of these so the block captures the correct data<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; //      let shadowPtr = UnsafeMutablePointer&lt;ShadowPass&gt;(constantBufferForFrame.contents())<br>&gt;&gt;&gt;         let shadowPtr = constantBufferForFrame.contents().bindMemory(to: ShadowPass.self, capacity: MemoryLayout&lt;ShadowPass&gt;.size)<br>&gt;&gt;&gt;         shadowPtr.pointee = shadowPassData[0]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         //More Swift specific stuff - advance pointer and cast to MainPass<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; //      let mainPtr = UnsafeMutablePointer&lt;MainPass&gt;(shadowPtr.advanced(by: 1))<br>&gt;&gt;&gt; //      mainPtr.pointee = mainPassFrameData<br>&gt;&gt;&gt;         let mainPtr : UnsafeMutablePointer&lt;MainPass&gt;  = shadowPtr.advanced(by: 1).withMemoryRebound(to: MainPass.self, capacity: MemoryLayout&lt;MainPass&gt;.size) {<br>&gt;&gt;&gt;             $0.pointee = mainPassFrameData<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;         <br>&gt;&gt;&gt;         //Advance and cast to ObjectData<br>&gt;&gt;&gt;         <br>&gt;&gt;&gt; //      var ptr = UnsafeMutablePointer&lt;ObjectData&gt;(mainPtr.advanced(by: 1))<br>&gt;&gt;&gt;         var ptr : UnsafeMutablePointer&lt;ObjectData&gt; = mainPtr.advanced(by: 1).withMemoryRebound(to: ObjectData.self, capacity: MemoryLayout&lt;ObjectData&gt;.size) {_ in<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         let shadowOffset = 0<br>&gt;&gt;&gt;         let mainPassOffset = MemoryLayout&lt;ShadowPass&gt;.size + shadowOffset<br>&gt;&gt;&gt;         let objectDataOffset = MemoryLayout&lt;MainPass&gt;.size + mainPassOffset<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         // Update position of all the objects<br>&gt;&gt;&gt;         if multithreadedUpdate {<br>&gt;&gt;&gt;             DispatchQueue.concurrentPerform(iterations: objectsToRender) { i in<br>&gt;&gt;&gt;                 let thisPtr = ptr.advanced(by: i)<br>&gt;&gt;&gt;                 _ = self.renderables[i].UpdateData(ptr, deltaTime: 1.0/60.0)<br>&gt;&gt;&gt;             }<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;         else {<br>&gt;&gt;&gt;             for index in 0..&lt;objectsToRender {<br>&gt;&gt;&gt;                 ptr = renderables[index].UpdateData(ptr, deltaTime: 1.0/60.0)<br>&gt;&gt;&gt;             }<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;         <br>&gt;&gt;&gt;         ptr = ptr.advanced(by: objectsToRender)<br>&gt;&gt;&gt;         <br>&gt;&gt;&gt;         _ = groundPlane!.UpdateData(ptr, deltaTime: 1.0/60.0)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Any help is appreciated.  I have the latest Xcode log handy if necessary.  Here’s a clip of the stack trace.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 0  swift                    0x000000010714a99d PrintStackTraceSignalHandler(void*) + 45<br>&gt;&gt;&gt; 1  swift                    0x000000010714a3e6 SignalHandler(int) + 470<br>&gt;&gt;&gt; 2  libsystem_platform.dylib 0x00007fff91461bba _sigtramp + 26<br>&gt;&gt;&gt; 3  libsystem_platform.dylib 000000000000000000 _sigtramp + 1857676384<br>&gt;&gt;&gt; 4  swift                    0x00000001047207b3 (anonymous namespace)::SILGenApply::visitExpr(swift::Expr*) + 51<br>&gt;&gt;&gt; 5  swift                    0x0000000104723ace (anonymous namespace)::SILGenApply::visitApplyExpr(swift::ApplyExpr*) + 5182<br>&gt;&gt;&gt; 6  swift                    0x0000000104711cc1 prepareApplyExpr(swift::Lowering::SILGenFunction&amp;, swift::Expr*) + 273<br>&gt;&gt;&gt; 7  swift                    0x00000001047624e7 swift::ASTVisitor&lt;(anonymous namespace)::RValueEmitter, swift::Lowering::RValue, void, void, void, void, void, swift::Lowering::SGFContext&gt;::visit(swift::Expr*, swift::Lowering::SGFContext) + 103<br>&gt;&gt;&gt; 8  swift                    0x0000000104762313 swift::Lowering::SILGenFunction::emitExprInto(swift::Expr*, swift::Lowering::Initialization*) + 195<br>&gt;&gt;&gt; 9  swift                    0x000000010474fbc3 swift::Lowering::SILGenFunction::emitPatternBinding(swift::PatternBindingDecl*, unsigned int) + 195<br>&gt;&gt;&gt; 10 swift                    0x00000001047077bd swift::ASTVisitor&lt;swift::Lowering::SILGenFunction, void, void, void, void, void, void&gt;::visit(swift::Decl*) + 125<br>&gt;&gt;&gt; 11 swift                    0x00000001047c0019 swift::ASTVisitor&lt;(anonymous namespace)::StmtEmitter, void, void, void, void, void, void&gt;::visit(swift::Stmt*) + 4169<br>&gt;&gt;&gt; 12 swift                    0x00000001047809ba swift::Lowering::SILGenFunction::emitFunction(swift::FuncDecl*) + 314<br>&gt;&gt;&gt; 13 swift                    0x00000001046fd775 swift::Lowering::SILGenModule::emitFunction(swift::FuncDecl*)::$_1::operator()(swift::SILFunction*) const + 1877<br>&gt;&gt;&gt; 14 swift                    0x00000001046fc322 swift::Lowering::SILGenModule::emitFunction(swift::FuncDecl*) + 626<br>&gt;&gt;&gt; 15 swift                    0x00000001047c7007 (anonymous namespace)::SILGenType::emitType() + 1271<br>&gt;&gt;&gt; 16 swift                    0x00000001047c6a9e swift::Lowering::SILGenModule::visitNominalTypeDecl(swift::NominalTypeDecl*) + 30<br>&gt;&gt;&gt; 17 swift                    0x0000000104709093 swift::Lowering::SILGenModule::emitSourceFile(swift::SourceFile*, unsigned int) + 1795<br>&gt;&gt;&gt; 18 swift                    0x000000010470ad4d swift::SILModule::constructSIL(swift::ModuleDecl*, swift::SILOptions&amp;, swift::FileUnit*, llvm::Optional&lt;unsigned int&gt;, bool, bool) + 1629<br>&gt;&gt;&gt; 19 swift                    0x00000001045621bf performCompile(swift::CompilerInstance&amp;, swift::CompilerInvocation&amp;, llvm::ArrayRef&lt;char const*&gt;, int&amp;, swift::FrontendObserver*) + 19487<br>&gt;&gt;&gt; 20 swift                    0x000000010455b2c5 swift::performFrontend(llvm::ArrayRef&lt;char const*&gt;, char const*, void*, swift::FrontendObserver*) + 17029<br>&gt;&gt;&gt; 21 swift                    0x000000010451888d main + 8685<br>&gt;&gt;&gt; 22 libdyld.dylib            0x00007fff91255255 start + 1<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Patrice<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt; swift-users at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160903/4b5f371c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8016afa037fa775c19d05b495a24413f?s=50"></div><header><strong>UnsafeMutablePointer Swift 3 conversion</strong> from <string>Patrice Kouame</string> &lt;pkouame at me.com&gt;<p>September  3, 2016 at 12:00:00pm</p></header><div class="content"><p>Indeed. There is a difference between stride and size, but I interpreted capacity incorrectly for my purposes.  It should indicate the number of &lt;T&gt; elements (not their size - right?) and the snippets below should work.<br></p><p>Still, compiler crashes and Xcode IDE is left in inconsistent state.  So I filed this Apple radar against Developer Tools.<br></p><p>	28150447 - Swift 3 UnsafeMutablePointer conversion crashes the compiler and IDE<br>Should I file a Swift bug too? Would that be helpful?<br></p><p>Regards, Patrice<br></p><p>&gt; On Sep 3, 2016, at 11:39 AM, Gerard Iglesias via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello,<br>&gt; <br>&gt; I think that it is more secure to use stride in place of size, sometimes it is not the same value.<br>&gt; <br>&gt; I use it in my own use of raw bindings <br>&gt; <br>&gt; Regards<br>&gt; <br>&gt; Gérard <br>&gt; <br>&gt; Le 3 sept. 2016 à 10:03, Patrice Kouame via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; a écrit :<br>&gt; <br>&gt;&gt; Hi Jacob - <br>&gt;&gt; <br>&gt;&gt; I think you’re right. “capacity” should be the count of type T elements in my buffer.  So in my case that line should read<br>&gt;&gt; <br>&gt;&gt;         let shadowPtr = constantBufferForFrame.contents().bindMemory(to: ShadowPass.self, capacity: shadowPassData.count)<br>&gt;&gt; <br>&gt;&gt; The withMemoryRebound calls need similar adjustments. The pointer to MainPass is actually a single structure to it should be safe to do this<br>&gt;&gt; <br>&gt;&gt;         let mainPtr : UnsafeMutablePointer&lt;MainPass&gt; = shadowPtr.advanced(by: 1).withMemoryRebound(to: MainPass.self, capacity: 1) {<br>&gt;&gt;             $0.pointee = mainPassFrameData<br>&gt;&gt;         }<br>&gt;&gt; <br>&gt;&gt; Whereas the unsafe pointer to &lt;ObjectData&gt; is actually a buffer of renderable objects, so this should work:<br>&gt;&gt; <br>&gt;&gt;         var ptr : UnsafeMutablePointer&lt;ObjectData&gt; = mainPtr.advanced(by: 1).withMemoryRebound(to: ObjectData.self, capacity: objectsToRender) {_ in<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; There are surely ways to refactor and simplify this, but I’m trying to retain as much of the original sample code approach as possible.<br>&gt;&gt; <br>&gt;&gt; However, the compiler still segs badly. <br>&gt;&gt; Xcode also borks an internal error often. Only cleaning or restarting the project can clear up that state.<br>&gt;&gt; Compilers (or Playgrounds for that matter) should never crash, and I’m not sure where to file this bug : Swift or Apple radar against Xcode or both? I now Xcode 8 is beta but…it’s been doing this for quite a while now...<br>&gt;&gt; <br>&gt;&gt; In both our “close to the metal” (no pun intended) cases, it seems like a lot of churning for very little gain. Don’t you think? The easier, but “unsafe” casting afforded previously did the trick with the normal caveats.<br>&gt;&gt; Don’t get me wrong, I love Swift and “get&quot; all the neat type safety features. Guess we can’t have our cake and eat it too, especially when interfacing with “unsafe” C APIs.<br>&gt;&gt; <br>&gt;&gt; Anyway, back to rtfm … maybe some of the Swift Gods can chime in?  ;-) <br>&gt;&gt; <br>&gt;&gt; I must be doing something stupid...Patrice<br>&gt;&gt; <br>&gt;&gt;&gt; On Sep 3, 2016, at 2:32 AM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi Patrice,<br>&gt;&gt;&gt; I don&#39;t have a solution for you, but I just wanted to point out what I think may be an error with your use of the new UnsafeRawPointer APIs:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; constantBufferForFrame.contents().bindMemory(to: ShadowPass.self, capacity: MemoryLayout&lt;ShadowPass&gt;.size)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I believe the `capacity` should actually be the number of ShadowPass elements in the buffer, not the size of each element. Using `bindMemory(to: ShadowPass.self` already implies that MemoryLayout&lt;ShadowPass&gt;.size is the size of each element.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; More info at https://developer.apple.com/reference/swift/unsaferawpointer/2428875-bindmemory &lt;https://developer.apple.com/reference/swift/unsaferawpointer/2428875-bindmemory&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I just updated a small Metal project of mine to Swift 3. I ran into some compiler (playground) crashes, but it does seem to work most of the time. Although I only have 1 buffer :-) https://github.com/jtbandes/Metalbrot.playground &lt;https://github.com/jtbandes/Metalbrot.playground&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jacob<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Fri, Sep 2, 2016 at 11:00 AM, Patrice Kouame via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; Hi all - <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m converting Apple’s Swift Sample &quot;Adopting Metal II: Designing and Implementing a Real-World Metal Renderer” in Xcode 8 beta6 to the latest UnsafeMutablePointer API for untyped memory access.  <br>&gt;&gt;&gt; Changes are necessary in MetalView.swift (Apple hasn’t updated their sample code for the latest beta yet…) <br>&gt;&gt;&gt; The Swift Compiler crashes (Segmentation Fault: 11) on the attempt:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         // Grab a pointer to the constant buffer&#39;s data store<br>&gt;&gt;&gt;         // Since we are using Swift, it is easier to cast the pointer to the ShadowPass type to fill the constant buffer<br>&gt;&gt;&gt;         // We need to make a copy of these so the block captures the correct data<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; //      let shadowPtr = UnsafeMutablePointer&lt;ShadowPass&gt;(constantBufferForFrame.contents())<br>&gt;&gt;&gt;         let shadowPtr = constantBufferForFrame.contents().bindMemory(to: ShadowPass.self, capacity: MemoryLayout&lt;ShadowPass&gt;.size)<br>&gt;&gt;&gt;         shadowPtr.pointee = shadowPassData[0]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         //More Swift specific stuff - advance pointer and cast to MainPass<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; //      let mainPtr = UnsafeMutablePointer&lt;MainPass&gt;(shadowPtr.advanced(by: 1))<br>&gt;&gt;&gt; //      mainPtr.pointee = mainPassFrameData<br>&gt;&gt;&gt;         let mainPtr : UnsafeMutablePointer&lt;MainPass&gt;  = shadowPtr.advanced(by: 1).withMemoryRebound(to: MainPass.self, capacity: MemoryLayout&lt;MainPass&gt;.size) {<br>&gt;&gt;&gt;             $0.pointee = mainPassFrameData<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;         <br>&gt;&gt;&gt;         //Advance and cast to ObjectData<br>&gt;&gt;&gt;         <br>&gt;&gt;&gt; //      var ptr = UnsafeMutablePointer&lt;ObjectData&gt;(mainPtr.advanced(by: 1))<br>&gt;&gt;&gt;         var ptr : UnsafeMutablePointer&lt;ObjectData&gt; = mainPtr.advanced(by: 1).withMemoryRebound(to: ObjectData.self, capacity: MemoryLayout&lt;ObjectData&gt;.size) {_ in<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         let shadowOffset = 0<br>&gt;&gt;&gt;         let mainPassOffset = MemoryLayout&lt;ShadowPass&gt;.size + shadowOffset<br>&gt;&gt;&gt;         let objectDataOffset = MemoryLayout&lt;MainPass&gt;.size + mainPassOffset<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         // Update position of all the objects<br>&gt;&gt;&gt;         if multithreadedUpdate {<br>&gt;&gt;&gt;             DispatchQueue.concurrentPerform(iterations: objectsToRender) { i in<br>&gt;&gt;&gt;                 let thisPtr = ptr.advanced(by: i)<br>&gt;&gt;&gt;                 _ = self.renderables[i].UpdateData(ptr, deltaTime: 1.0/60.0)<br>&gt;&gt;&gt;             }<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;         else {<br>&gt;&gt;&gt;             for index in 0..&lt;objectsToRender {<br>&gt;&gt;&gt;                 ptr = renderables[index].UpdateData(ptr, deltaTime: 1.0/60.0)<br>&gt;&gt;&gt;             }<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;         <br>&gt;&gt;&gt;         ptr = ptr.advanced(by: objectsToRender)<br>&gt;&gt;&gt;         <br>&gt;&gt;&gt;         _ = groundPlane!.UpdateData(ptr, deltaTime: 1.0/60.0)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Any help is appreciated.  I have the latest Xcode log handy if necessary.  Here’s a clip of the stack trace.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 0  swift                    0x000000010714a99d PrintStackTraceSignalHandler(void*) + 45<br>&gt;&gt;&gt; 1  swift                    0x000000010714a3e6 SignalHandler(int) + 470<br>&gt;&gt;&gt; 2  libsystem_platform.dylib 0x00007fff91461bba _sigtramp + 26<br>&gt;&gt;&gt; 3  libsystem_platform.dylib 000000000000000000 _sigtramp + 1857676384<br>&gt;&gt;&gt; 4  swift                    0x00000001047207b3 (anonymous namespace)::SILGenApply::visitExpr(swift::Expr*) + 51<br>&gt;&gt;&gt; 5  swift                    0x0000000104723ace (anonymous namespace)::SILGenApply::visitApplyExpr(swift::ApplyExpr*) + 5182<br>&gt;&gt;&gt; 6  swift                    0x0000000104711cc1 prepareApplyExpr(swift::Lowering::SILGenFunction&amp;, swift::Expr*) + 273<br>&gt;&gt;&gt; 7  swift                    0x00000001047624e7 swift::ASTVisitor&lt;(anonymous namespace)::RValueEmitter, swift::Lowering::RValue, void, void, void, void, void, swift::Lowering::SGFContext&gt;::visit(swift::Expr*, swift::Lowering::SGFContext) + 103<br>&gt;&gt;&gt; 8  swift                    0x0000000104762313 swift::Lowering::SILGenFunction::emitExprInto(swift::Expr*, swift::Lowering::Initialization*) + 195<br>&gt;&gt;&gt; 9  swift                    0x000000010474fbc3 swift::Lowering::SILGenFunction::emitPatternBinding(swift::PatternBindingDecl*, unsigned int) + 195<br>&gt;&gt;&gt; 10 swift                    0x00000001047077bd swift::ASTVisitor&lt;swift::Lowering::SILGenFunction, void, void, void, void, void, void&gt;::visit(swift::Decl*) + 125<br>&gt;&gt;&gt; 11 swift                    0x00000001047c0019 swift::ASTVisitor&lt;(anonymous namespace)::StmtEmitter, void, void, void, void, void, void&gt;::visit(swift::Stmt*) + 4169<br>&gt;&gt;&gt; 12 swift                    0x00000001047809ba swift::Lowering::SILGenFunction::emitFunction(swift::FuncDecl*) + 314<br>&gt;&gt;&gt; 13 swift                    0x00000001046fd775 swift::Lowering::SILGenModule::emitFunction(swift::FuncDecl*)::$_1::operator()(swift::SILFunction*) const + 1877<br>&gt;&gt;&gt; 14 swift                    0x00000001046fc322 swift::Lowering::SILGenModule::emitFunction(swift::FuncDecl*) + 626<br>&gt;&gt;&gt; 15 swift                    0x00000001047c7007 (anonymous namespace)::SILGenType::emitType() + 1271<br>&gt;&gt;&gt; 16 swift                    0x00000001047c6a9e swift::Lowering::SILGenModule::visitNominalTypeDecl(swift::NominalTypeDecl*) + 30<br>&gt;&gt;&gt; 17 swift                    0x0000000104709093 swift::Lowering::SILGenModule::emitSourceFile(swift::SourceFile*, unsigned int) + 1795<br>&gt;&gt;&gt; 18 swift                    0x000000010470ad4d swift::SILModule::constructSIL(swift::ModuleDecl*, swift::SILOptions&amp;, swift::FileUnit*, llvm::Optional&lt;unsigned int&gt;, bool, bool) + 1629<br>&gt;&gt;&gt; 19 swift                    0x00000001045621bf performCompile(swift::CompilerInstance&amp;, swift::CompilerInvocation&amp;, llvm::ArrayRef&lt;char const*&gt;, int&amp;, swift::FrontendObserver*) + 19487<br>&gt;&gt;&gt; 20 swift                    0x000000010455b2c5 swift::performFrontend(llvm::ArrayRef&lt;char const*&gt;, char const*, void*, swift::FrontendObserver*) + 17029<br>&gt;&gt;&gt; 21 swift                    0x000000010451888d main + 8685<br>&gt;&gt;&gt; 22 libdyld.dylib            0x00007fff91255255 start + 1<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Patrice<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160903/65f28921/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f0c42759e3b302ee8b0665d8b59c1197?s=50"></div><header><strong>UnsafeMutablePointer Swift 3 conversion</strong> from <string>Gerard Iglesias</string> &lt;gerard_iglesias at me.com&gt;<p>September  3, 2016 at 07:00:00pm</p></header><div class="content"><p>Ok<br></p><p>For the record I succeeded this transformation phase last week<br></p><p>I remember the tedious stuff to advance pointer from one struct to the other kind of struct... it worked<br></p><p>But I don&#39;t have my MacBook with me, only the phone, the six :)<br></p><p>Gérard <br></p><p>&gt; Le 3 sept. 2016 à 18:22, Patrice Kouame &lt;pkouame at me.com&gt; a écrit :<br>&gt; <br>&gt; Indeed. There is a difference between stride and size, but I interpreted capacity incorrectly for my purposes.  It should indicate the number of &lt;T&gt; elements (not their size - right?) and the snippets below should work.<br>&gt; <br>&gt; Still, compiler crashes and Xcode IDE is left in inconsistent state.  So I filed this Apple radar against Developer Tools.<br>&gt; <br>&gt; 	28150447 - Swift 3 UnsafeMutablePointer conversion crashes the compiler and IDE<br>&gt; Should I file a Swift bug too? Would that be helpful?<br>&gt; <br>&gt; Regards, Patrice<br>&gt; <br>&gt;&gt; On Sep 3, 2016, at 11:39 AM, Gerard Iglesias via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello,<br>&gt;&gt; <br>&gt;&gt; I think that it is more secure to use stride in place of size, sometimes it is not the same value.<br>&gt;&gt; <br>&gt;&gt; I use it in my own use of raw bindings <br>&gt;&gt; <br>&gt;&gt; Regards<br>&gt;&gt; <br>&gt;&gt; Gérard <br>&gt;&gt; <br>&gt;&gt;&gt; Le 3 sept. 2016 à 10:03, Patrice Kouame via swift-users &lt;swift-users at swift.org&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi Jacob - <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think you’re right. “capacity” should be the count of type T elements in my buffer.  So in my case that line should read<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         let shadowPtr = constantBufferForFrame.contents().bindMemory(to: ShadowPass.self, capacity: shadowPassData.count)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The withMemoryRebound calls need similar adjustments. The pointer to MainPass is actually a single structure to it should be safe to do this<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         let mainPtr : UnsafeMutablePointer&lt;MainPass&gt; = shadowPtr.advanced(by: 1).withMemoryRebound(to: MainPass.self, capacity: 1) {<br>&gt;&gt;&gt;             $0.pointee = mainPassFrameData<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Whereas the unsafe pointer to &lt;ObjectData&gt; is actually a buffer of renderable objects, so this should work:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         var ptr : UnsafeMutablePointer&lt;ObjectData&gt; = mainPtr.advanced(by: 1).withMemoryRebound(to: ObjectData.self, capacity: objectsToRender) {_ in<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are surely ways to refactor and simplify this, but I’m trying to retain as much of the original sample code approach as possible.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However, the compiler still segs badly. <br>&gt;&gt;&gt; Xcode also borks an internal error often. Only cleaning or restarting the project can clear up that state.<br>&gt;&gt;&gt; Compilers (or Playgrounds for that matter) should never crash, and I’m not sure where to file this bug : Swift or Apple radar against Xcode or both? I now Xcode 8 is beta but…it’s been doing this for quite a while now...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In both our “close to the metal” (no pun intended) cases, it seems like a lot of churning for very little gain. Don’t you think? The easier, but “unsafe” casting afforded previously did the trick with the normal caveats.<br>&gt;&gt;&gt; Don’t get me wrong, I love Swift and “get&quot; all the neat type safety features. Guess we can’t have our cake and eat it too, especially when interfacing with “unsafe” C APIs.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Anyway, back to rtfm … maybe some of the Swift Gods can chime in?  ;-) <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I must be doing something stupid...Patrice<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Sep 3, 2016, at 2:32 AM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi Patrice,<br>&gt;&gt;&gt;&gt; I don&#39;t have a solution for you, but I just wanted to point out what I think may be an error with your use of the new UnsafeRawPointer APIs:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; constantBufferForFrame.contents().bindMemory(to: ShadowPass.self, capacity: MemoryLayout&lt;ShadowPass&gt;.size)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I believe the `capacity` should actually be the number of ShadowPass elements in the buffer, not the size of each element. Using `bindMemory(to: ShadowPass.self` already implies that MemoryLayout&lt;ShadowPass&gt;.size is the size of each element.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; More info at https://developer.apple.com/reference/swift/unsaferawpointer/2428875-bindmemory<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I just updated a small Metal project of mine to Swift 3. I ran into some compiler (playground) crashes, but it does seem to work most of the time. Although I only have 1 buffer :-) https://github.com/jtbandes/Metalbrot.playground<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Jacob<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Fri, Sep 2, 2016 at 11:00 AM, Patrice Kouame via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; Hi all - <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’m converting Apple’s Swift Sample &quot;Adopting Metal II: Designing and Implementing a Real-World Metal Renderer” in Xcode 8 beta6 to the latest UnsafeMutablePointer API for untyped memory access.  <br>&gt;&gt;&gt;&gt;&gt; Changes are necessary in MetalView.swift (Apple hasn’t updated their sample code for the latest beta yet…) <br>&gt;&gt;&gt;&gt;&gt; The Swift Compiler crashes (Segmentation Fault: 11) on the attempt:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;         // Grab a pointer to the constant buffer&#39;s data store<br>&gt;&gt;&gt;&gt;&gt;         // Since we are using Swift, it is easier to cast the pointer to the ShadowPass type to fill the constant buffer<br>&gt;&gt;&gt;&gt;&gt;         // We need to make a copy of these so the block captures the correct data<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; //      let shadowPtr = UnsafeMutablePointer&lt;ShadowPass&gt;(constantBufferForFrame.contents())<br>&gt;&gt;&gt;&gt;&gt;         let shadowPtr = constantBufferForFrame.contents().bindMemory(to: ShadowPass.self, capacity: MemoryLayout&lt;ShadowPass&gt;.size)<br>&gt;&gt;&gt;&gt;&gt;         shadowPtr.pointee = shadowPassData[0]<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;         //More Swift specific stuff - advance pointer and cast to MainPass<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; //      let mainPtr = UnsafeMutablePointer&lt;MainPass&gt;(shadowPtr.advanced(by: 1))<br>&gt;&gt;&gt;&gt;&gt; //      mainPtr.pointee = mainPassFrameData<br>&gt;&gt;&gt;&gt;&gt;         let mainPtr : UnsafeMutablePointer&lt;MainPass&gt;  = shadowPtr.advanced(by: 1).withMemoryRebound(to: MainPass.self, capacity: MemoryLayout&lt;MainPass&gt;.size) {<br>&gt;&gt;&gt;&gt;&gt;             $0.pointee = mainPassFrameData<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;&gt;         //Advance and cast to ObjectData<br>&gt;&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;&gt; //      var ptr = UnsafeMutablePointer&lt;ObjectData&gt;(mainPtr.advanced(by: 1))<br>&gt;&gt;&gt;&gt;&gt;         var ptr : UnsafeMutablePointer&lt;ObjectData&gt; = mainPtr.advanced(by: 1).withMemoryRebound(to: ObjectData.self, capacity: MemoryLayout&lt;ObjectData&gt;.size) {_ in<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;         let shadowOffset = 0<br>&gt;&gt;&gt;&gt;&gt;         let mainPassOffset = MemoryLayout&lt;ShadowPass&gt;.size + shadowOffset<br>&gt;&gt;&gt;&gt;&gt;         let objectDataOffset = MemoryLayout&lt;MainPass&gt;.size + mainPassOffset<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;         // Update position of all the objects<br>&gt;&gt;&gt;&gt;&gt;         if multithreadedUpdate {<br>&gt;&gt;&gt;&gt;&gt;             DispatchQueue.concurrentPerform(iterations: objectsToRender) { i in<br>&gt;&gt;&gt;&gt;&gt;                 let thisPtr = ptr.advanced(by: i)<br>&gt;&gt;&gt;&gt;&gt;                 _ = self.renderables[i].UpdateData(ptr, deltaTime: 1.0/60.0)<br>&gt;&gt;&gt;&gt;&gt;             }<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;         else {<br>&gt;&gt;&gt;&gt;&gt;             for index in 0..&lt;objectsToRender {<br>&gt;&gt;&gt;&gt;&gt;                 ptr = renderables[index].UpdateData(ptr, deltaTime: 1.0/60.0)<br>&gt;&gt;&gt;&gt;&gt;             }<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;&gt;         ptr = ptr.advanced(by: objectsToRender)<br>&gt;&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;&gt;         _ = groundPlane!.UpdateData(ptr, deltaTime: 1.0/60.0)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Any help is appreciated.  I have the latest Xcode log handy if necessary.  Here’s a clip of the stack trace.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 0  swift                    0x000000010714a99d PrintStackTraceSignalHandler(void*) + 45<br>&gt;&gt;&gt;&gt;&gt; 1  swift                    0x000000010714a3e6 SignalHandler(int) + 470<br>&gt;&gt;&gt;&gt;&gt; 2  libsystem_platform.dylib 0x00007fff91461bba _sigtramp + 26<br>&gt;&gt;&gt;&gt;&gt; 3  libsystem_platform.dylib 000000000000000000 _sigtramp + 1857676384<br>&gt;&gt;&gt;&gt;&gt; 4  swift                    0x00000001047207b3 (anonymous namespace)::SILGenApply::visitExpr(swift::Expr*) + 51<br>&gt;&gt;&gt;&gt;&gt; 5  swift                    0x0000000104723ace (anonymous namespace)::SILGenApply::visitApplyExpr(swift::ApplyExpr*) + 5182<br>&gt;&gt;&gt;&gt;&gt; 6  swift                    0x0000000104711cc1 prepareApplyExpr(swift::Lowering::SILGenFunction&amp;, swift::Expr*) + 273<br>&gt;&gt;&gt;&gt;&gt; 7  swift                    0x00000001047624e7 swift::ASTVisitor&lt;(anonymous namespace)::RValueEmitter, swift::Lowering::RValue, void, void, void, void, void, swift::Lowering::SGFContext&gt;::visit(swift::Expr*, swift::Lowering::SGFContext) + 103<br>&gt;&gt;&gt;&gt;&gt; 8  swift                    0x0000000104762313 swift::Lowering::SILGenFunction::emitExprInto(swift::Expr*, swift::Lowering::Initialization*) + 195<br>&gt;&gt;&gt;&gt;&gt; 9  swift                    0x000000010474fbc3 swift::Lowering::SILGenFunction::emitPatternBinding(swift::PatternBindingDecl*, unsigned int) + 195<br>&gt;&gt;&gt;&gt;&gt; 10 swift                    0x00000001047077bd swift::ASTVisitor&lt;swift::Lowering::SILGenFunction, void, void, void, void, void, void&gt;::visit(swift::Decl*) + 125<br>&gt;&gt;&gt;&gt;&gt; 11 swift                    0x00000001047c0019 swift::ASTVisitor&lt;(anonymous namespace)::StmtEmitter, void, void, void, void, void, void&gt;::visit(swift::Stmt*) + 4169<br>&gt;&gt;&gt;&gt;&gt; 12 swift                    0x00000001047809ba swift::Lowering::SILGenFunction::emitFunction(swift::FuncDecl*) + 314<br>&gt;&gt;&gt;&gt;&gt; 13 swift                    0x00000001046fd775 swift::Lowering::SILGenModule::emitFunction(swift::FuncDecl*)::$_1::operator()(swift::SILFunction*) const + 1877<br>&gt;&gt;&gt;&gt;&gt; 14 swift                    0x00000001046fc322 swift::Lowering::SILGenModule::emitFunction(swift::FuncDecl*) + 626<br>&gt;&gt;&gt;&gt;&gt; 15 swift                    0x00000001047c7007 (anonymous namespace)::SILGenType::emitType() + 1271<br>&gt;&gt;&gt;&gt;&gt; 16 swift                    0x00000001047c6a9e swift::Lowering::SILGenModule::visitNominalTypeDecl(swift::NominalTypeDecl*) + 30<br>&gt;&gt;&gt;&gt;&gt; 17 swift                    0x0000000104709093 swift::Lowering::SILGenModule::emitSourceFile(swift::SourceFile*, unsigned int) + 1795<br>&gt;&gt;&gt;&gt;&gt; 18 swift                    0x000000010470ad4d swift::SILModule::constructSIL(swift::ModuleDecl*, swift::SILOptions&amp;, swift::FileUnit*, llvm::Optional&lt;unsigned int&gt;, bool, bool) + 1629<br>&gt;&gt;&gt;&gt;&gt; 19 swift                    0x00000001045621bf performCompile(swift::CompilerInstance&amp;, swift::CompilerInvocation&amp;, llvm::ArrayRef&lt;char const*&gt;, int&amp;, swift::FrontendObserver*) + 19487<br>&gt;&gt;&gt;&gt;&gt; 20 swift                    0x000000010455b2c5 swift::performFrontend(llvm::ArrayRef&lt;char const*&gt;, char const*, void*, swift::FrontendObserver*) + 17029<br>&gt;&gt;&gt;&gt;&gt; 21 swift                    0x000000010451888d main + 8685<br>&gt;&gt;&gt;&gt;&gt; 22 libdyld.dylib            0x00007fff91255255 start + 1<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Patrice<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-users at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt; swift-users at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160903/557a9e30/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8016afa037fa775c19d05b495a24413f?s=50"></div><header><strong>UnsafeMutablePointer Swift 3 conversion</strong> from <string>Patrice Kouame</string> &lt;pkouame at me.com&gt;<p>September  3, 2016 at 01:00:00pm</p></header><div class="content"><p>Gerard- <br></p><p>Excellent!  Looking forward to seeing your fix (hoping you get your book back soon ;-) )<br></p><p>I think Xcode/Swift gags on the last ptr advance to objectData.  I recently tried another variant using withUnsafeMutablePointer like this:<br></p><p>        var ptr : UnsafeMutablePointer&lt;ObjectData&gt;  = withUnsafeMutablePointer(to: &amp;mainPtr) {<br>            $0.withMemoryRebound(to: ObjectData.self, capacity: objectsToRender) {<br>                $0.pointee = renderables[0].objectData<br>            }<br>        }<br></p><p>..but still crashes with no hints.<br></p><p>My bug report also mentions that the Xcode migration/conversion tool is incomplete.  <br>It handles the “simpler&quot; UnsafeMutableRawPointer&lt;X&gt; to UnsafeMutablePonter&lt;Y&gt; with bindMemory cases correctly (one still has to mind the capacity value though)<br>In all fairness, migrating/converting automagically in these cases is always a little bit tricky - the proposed Xcode fixes should always be reviewed by a human...<br></p><p>Patrice<br></p><p>&gt; On Sep 3, 2016, at 1:05 PM, Gerard Iglesias via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Ok<br>&gt; <br>&gt; For the record I succeeded this transformation phase last week<br>&gt; <br>&gt; I remember the tedious stuff to advance pointer from one struct to the other kind of struct... it worked<br>&gt; <br>&gt; But I don&#39;t have my MacBook with me, only the phone, the six :)<br>&gt; <br>&gt; Gérard <br>&gt; <br>&gt; Le 3 sept. 2016 à 18:22, Patrice Kouame &lt;pkouame at me.com &lt;mailto:pkouame at me.com&gt;&gt; a écrit :<br>&gt; <br>&gt;&gt; Indeed. There is a difference between stride and size, but I interpreted capacity incorrectly for my purposes.  It should indicate the number of &lt;T&gt; elements (not their size - right?) and the snippets below should work.<br>&gt;&gt; <br>&gt;&gt; Still, compiler crashes and Xcode IDE is left in inconsistent state.  So I filed this Apple radar against Developer Tools.<br>&gt;&gt; <br>&gt;&gt; 	28150447 - Swift 3 UnsafeMutablePointer conversion crashes the compiler and IDE<br>&gt;&gt; Should I file a Swift bug too? Would that be helpful?<br>&gt;&gt; <br>&gt;&gt; Regards, Patrice<br>&gt;&gt; <br>&gt;&gt;&gt; On Sep 3, 2016, at 11:39 AM, Gerard Iglesias via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think that it is more secure to use stride in place of size, sometimes it is not the same value.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I use it in my own use of raw bindings <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Regards<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Gérard <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Le 3 sept. 2016 à 10:03, Patrice Kouame via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi Jacob - <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think you’re right. “capacity” should be the count of type T elements in my buffer.  So in my case that line should read<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;         let shadowPtr = constantBufferForFrame.contents().bindMemory(to: ShadowPass.self, capacity: shadowPassData.count)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The withMemoryRebound calls need similar adjustments. The pointer to MainPass is actually a single structure to it should be safe to do this<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;         let mainPtr : UnsafeMutablePointer&lt;MainPass&gt; = shadowPtr.advanced(by: 1).withMemoryRebound(to: MainPass.self, capacity: 1) {<br>&gt;&gt;&gt;&gt;             $0.pointee = mainPassFrameData<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Whereas the unsafe pointer to &lt;ObjectData&gt; is actually a buffer of renderable objects, so this should work:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;         var ptr : UnsafeMutablePointer&lt;ObjectData&gt; = mainPtr.advanced(by: 1).withMemoryRebound(to: ObjectData.self, capacity: objectsToRender) {_ in<br>&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are surely ways to refactor and simplify this, but I’m trying to retain as much of the original sample code approach as possible.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; However, the compiler still segs badly. <br>&gt;&gt;&gt;&gt; Xcode also borks an internal error often. Only cleaning or restarting the project can clear up that state.<br>&gt;&gt;&gt;&gt; Compilers (or Playgrounds for that matter) should never crash, and I’m not sure where to file this bug : Swift or Apple radar against Xcode or both? I now Xcode 8 is beta but…it’s been doing this for quite a while now...<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In both our “close to the metal” (no pun intended) cases, it seems like a lot of churning for very little gain. Don’t you think? The easier, but “unsafe” casting afforded previously did the trick with the normal caveats.<br>&gt;&gt;&gt;&gt; Don’t get me wrong, I love Swift and “get&quot; all the neat type safety features. Guess we can’t have our cake and eat it too, especially when interfacing with “unsafe” C APIs.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Anyway, back to rtfm … maybe some of the Swift Gods can chime in?  ;-) <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I must be doing something stupid...Patrice<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Sep 3, 2016, at 2:32 AM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hi Patrice,<br>&gt;&gt;&gt;&gt;&gt; I don&#39;t have a solution for you, but I just wanted to point out what I think may be an error with your use of the new UnsafeRawPointer APIs:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; constantBufferForFrame.contents().bindMemory(to: ShadowPass.self, capacity: MemoryLayout&lt;ShadowPass&gt;.size)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I believe the `capacity` should actually be the number of ShadowPass elements in the buffer, not the size of each element. Using `bindMemory(to: ShadowPass.self` already implies that MemoryLayout&lt;ShadowPass&gt;.size is the size of each element.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; More info at https://developer.apple.com/reference/swift/unsaferawpointer/2428875-bindmemory &lt;https://developer.apple.com/reference/swift/unsaferawpointer/2428875-bindmemory&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I just updated a small Metal project of mine to Swift 3. I ran into some compiler (playground) crashes, but it does seem to work most of the time. Although I only have 1 buffer :-) https://github.com/jtbandes/Metalbrot.playground &lt;https://github.com/jtbandes/Metalbrot.playground&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Jacob<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Fri, Sep 2, 2016 at 11:00 AM, Patrice Kouame via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; Hi all - <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’m converting Apple’s Swift Sample &quot;Adopting Metal II: Designing and Implementing a Real-World Metal Renderer” in Xcode 8 beta6 to the latest UnsafeMutablePointer API for untyped memory access.  <br>&gt;&gt;&gt;&gt;&gt; Changes are necessary in MetalView.swift (Apple hasn’t updated their sample code for the latest beta yet…) <br>&gt;&gt;&gt;&gt;&gt; The Swift Compiler crashes (Segmentation Fault: 11) on the attempt:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;         // Grab a pointer to the constant buffer&#39;s data store<br>&gt;&gt;&gt;&gt;&gt;         // Since we are using Swift, it is easier to cast the pointer to the ShadowPass type to fill the constant buffer<br>&gt;&gt;&gt;&gt;&gt;         // We need to make a copy of these so the block captures the correct data<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; //      let shadowPtr = UnsafeMutablePointer&lt;ShadowPass&gt;(constantBufferForFrame.contents())<br>&gt;&gt;&gt;&gt;&gt;         let shadowPtr = constantBufferForFrame.contents().bindMemory(to: ShadowPass.self, capacity: MemoryLayout&lt;ShadowPass&gt;.size)<br>&gt;&gt;&gt;&gt;&gt;         shadowPtr.pointee = shadowPassData[0]<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;         //More Swift specific stuff - advance pointer and cast to MainPass<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; //      let mainPtr = UnsafeMutablePointer&lt;MainPass&gt;(shadowPtr.advanced(by: 1))<br>&gt;&gt;&gt;&gt;&gt; //      mainPtr.pointee = mainPassFrameData<br>&gt;&gt;&gt;&gt;&gt;         let mainPtr : UnsafeMutablePointer&lt;MainPass&gt;  = shadowPtr.advanced(by: 1).withMemoryRebound(to: MainPass.self, capacity: MemoryLayout&lt;MainPass&gt;.size) {<br>&gt;&gt;&gt;&gt;&gt;             $0.pointee = mainPassFrameData<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;&gt;         //Advance and cast to ObjectData<br>&gt;&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;&gt; //      var ptr = UnsafeMutablePointer&lt;ObjectData&gt;(mainPtr.advanced(by: 1))<br>&gt;&gt;&gt;&gt;&gt;         var ptr : UnsafeMutablePointer&lt;ObjectData&gt; = mainPtr.advanced(by: 1).withMemoryRebound(to: ObjectData.self, capacity: MemoryLayout&lt;ObjectData&gt;.size) {_ in<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;         let shadowOffset = 0<br>&gt;&gt;&gt;&gt;&gt;         let mainPassOffset = MemoryLayout&lt;ShadowPass&gt;.size + shadowOffset<br>&gt;&gt;&gt;&gt;&gt;         let objectDataOffset = MemoryLayout&lt;MainPass&gt;.size + mainPassOffset<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;         // Update position of all the objects<br>&gt;&gt;&gt;&gt;&gt;         if multithreadedUpdate {<br>&gt;&gt;&gt;&gt;&gt;             DispatchQueue.concurrentPerform(iterations: objectsToRender) { i in<br>&gt;&gt;&gt;&gt;&gt;                 let thisPtr = ptr.advanced(by: i)<br>&gt;&gt;&gt;&gt;&gt;                 _ = self.renderables[i].UpdateData(ptr, deltaTime: 1.0/60.0)<br>&gt;&gt;&gt;&gt;&gt;             }<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;         else {<br>&gt;&gt;&gt;&gt;&gt;             for index in 0..&lt;objectsToRender {<br>&gt;&gt;&gt;&gt;&gt;                 ptr = renderables[index].UpdateData(ptr, deltaTime: 1.0/60.0)<br>&gt;&gt;&gt;&gt;&gt;             }<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;&gt;         ptr = ptr.advanced(by: objectsToRender)<br>&gt;&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;&gt;         _ = groundPlane!.UpdateData(ptr, deltaTime: 1.0/60.0)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Any help is appreciated.  I have the latest Xcode log handy if necessary.  Here’s a clip of the stack trace.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 0  swift                    0x000000010714a99d PrintStackTraceSignalHandler(void*) + 45<br>&gt;&gt;&gt;&gt;&gt; 1  swift                    0x000000010714a3e6 SignalHandler(int) + 470<br>&gt;&gt;&gt;&gt;&gt; 2  libsystem_platform.dylib 0x00007fff91461bba _sigtramp + 26<br>&gt;&gt;&gt;&gt;&gt; 3  libsystem_platform.dylib 000000000000000000 _sigtramp + 1857676384<br>&gt;&gt;&gt;&gt;&gt; 4  swift                    0x00000001047207b3 (anonymous namespace)::SILGenApply::visitExpr(swift::Expr*) + 51<br>&gt;&gt;&gt;&gt;&gt; 5  swift                    0x0000000104723ace (anonymous namespace)::SILGenApply::visitApplyExpr(swift::ApplyExpr*) + 5182<br>&gt;&gt;&gt;&gt;&gt; 6  swift                    0x0000000104711cc1 prepareApplyExpr(swift::Lowering::SILGenFunction&amp;, swift::Expr*) + 273<br>&gt;&gt;&gt;&gt;&gt; 7  swift                    0x00000001047624e7 swift::ASTVisitor&lt;(anonymous namespace)::RValueEmitter, swift::Lowering::RValue, void, void, void, void, void, swift::Lowering::SGFContext&gt;::visit(swift::Expr*, swift::Lowering::SGFContext) + 103<br>&gt;&gt;&gt;&gt;&gt; 8  swift                    0x0000000104762313 swift::Lowering::SILGenFunction::emitExprInto(swift::Expr*, swift::Lowering::Initialization*) + 195<br>&gt;&gt;&gt;&gt;&gt; 9  swift                    0x000000010474fbc3 swift::Lowering::SILGenFunction::emitPatternBinding(swift::PatternBindingDecl*, unsigned int) + 195<br>&gt;&gt;&gt;&gt;&gt; 10 swift                    0x00000001047077bd swift::ASTVisitor&lt;swift::Lowering::SILGenFunction, void, void, void, void, void, void&gt;::visit(swift::Decl*) + 125<br>&gt;&gt;&gt;&gt;&gt; 11 swift                    0x00000001047c0019 swift::ASTVisitor&lt;(anonymous namespace)::StmtEmitter, void, void, void, void, void, void&gt;::visit(swift::Stmt*) + 4169<br>&gt;&gt;&gt;&gt;&gt; 12 swift                    0x00000001047809ba swift::Lowering::SILGenFunction::emitFunction(swift::FuncDecl*) + 314<br>&gt;&gt;&gt;&gt;&gt; 13 swift                    0x00000001046fd775 swift::Lowering::SILGenModule::emitFunction(swift::FuncDecl*)::$_1::operator()(swift::SILFunction*) const + 1877<br>&gt;&gt;&gt;&gt;&gt; 14 swift                    0x00000001046fc322 swift::Lowering::SILGenModule::emitFunction(swift::FuncDecl*) + 626<br>&gt;&gt;&gt;&gt;&gt; 15 swift                    0x00000001047c7007 (anonymous namespace)::SILGenType::emitType() + 1271<br>&gt;&gt;&gt;&gt;&gt; 16 swift                    0x00000001047c6a9e swift::Lowering::SILGenModule::visitNominalTypeDecl(swift::NominalTypeDecl*) + 30<br>&gt;&gt;&gt;&gt;&gt; 17 swift                    0x0000000104709093 swift::Lowering::SILGenModule::emitSourceFile(swift::SourceFile*, unsigned int) + 1795<br>&gt;&gt;&gt;&gt;&gt; 18 swift                    0x000000010470ad4d swift::SILModule::constructSIL(swift::ModuleDecl*, swift::SILOptions&amp;, swift::FileUnit*, llvm::Optional&lt;unsigned int&gt;, bool, bool) + 1629<br>&gt;&gt;&gt;&gt;&gt; 19 swift                    0x00000001045621bf performCompile(swift::CompilerInstance&amp;, swift::CompilerInvocation&amp;, llvm::ArrayRef&lt;char const*&gt;, int&amp;, swift::FrontendObserver*) + 19487<br>&gt;&gt;&gt;&gt;&gt; 20 swift                    0x000000010455b2c5 swift::performFrontend(llvm::ArrayRef&lt;char const*&gt;, char const*, void*, swift::FrontendObserver*) + 17029<br>&gt;&gt;&gt;&gt;&gt; 21 swift                    0x000000010451888d main + 8685<br>&gt;&gt;&gt;&gt;&gt; 22 libdyld.dylib            0x00007fff91255255 start + 1<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Patrice<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt;&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160903/beab56db/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8016afa037fa775c19d05b495a24413f?s=50"></div><header><strong>UnsafeMutablePointer Swift 3 conversion</strong> from <string>Patrice Kouame</string> &lt;pkouame at me.com&gt;<p>September  3, 2016 at 04:00:00pm</p></header><div class="content"><p>Finally Success!  I’m seeing my pretty little 3D twirling Metal Renderer cubes again… Here’s how<br></p><p>Snippet of old  sample code which no longer compiles in Xcode 8 beta 6 with stricter Swift3 unsafe type casting restrictions <br>(in MetalView.swift from # Adopting Metal II: Designing and Implementing a Real-World Metal Renderer)<br></p><p>	let shadowPtr = UnsafeMutablePointer&lt;ShadowPass&gt;(constantBufferForFrame.contents())<br>	let mainPtr = UnsafeMutablePointer&lt;MainPass&gt;(shadowPtr.advanced(by: 1))<br>	mainPtr.pointee = mainPassFrameData<br>	var ptr = UnsafeMutablePointer&lt;ObjectData&gt;(mainPtr.advanced(by: 1))<br></p><p>My conversion attempt that crashes Swift 3 Xcode 8 beta 6 (see  RADAR 28150447 - Swift 3 UnsafeMutablePointer conversion crashes the compiler and IDE)<br></p><p>        let shadowPtr = constantBufferForFrame.contents().bindMemory(to: ShadowPass.self, capacity: MemoryLayout&lt;shadowPassData&gt;.size)<br>        let mainPtr : UnsafeMutablePointer&lt;MainPass&gt; = shadowPtr.advanced(by: 1).withMemoryRebound(to: MainPass.self, capacity: 1) {<br>		$0.pointee = mainPassFrameData<br>	}<br>        var ptr : UnsafeMutablePointer&lt;ObjectData&gt; = mainPtr.advanced(by: 1).withMemoryRebound(to: ObjectData.self, capacity: MemoryLayout&lt; ObjectData &gt;.size) {$0}<br></p><p>Latest conversion that make Xcode and Swift 3 smile again...<br></p><p>        let shadowPtr = constantBufferForFrame.contents().bindMemory(to: ShadowPass.self, capacity: shadowPassData.count)<br>        let mainPtr : UnsafeMutablePointer&lt;MainPass&gt; = shadowPtr.advanced(by: 1).withMemoryRebound(to: MainPass.self, capacity: 1) {$0}<br>        mainPtr.pointee = mainPassFrameData<br>        var ptr : UnsafeMutablePointer&lt;ObjectData&gt; = mainPtr.advanced(by: 1).withMemoryRebound(to: ObjectData.self, capacity: objectsToRender) {$0}<br></p><p>Yes… Xcode/Swift3 SIL generation definitely did NOT like my &quot;$0.pointee = mainPassFrameData&quot; statement. <br>Apparently, reassigning the pointee within the closure makes Swift gag out of disgust. Sorry ;-(<br>That’s what I get for trying to be fancy…<br>And fixed my “capacity” issues thanks to some previous posters.<br></p><p>Hope this helps anyone trying to get the Metal projects to compile again.<br></p><p>At least I got a Radar out of this ;-) Compilers should never burn and crash out like this...<br></p><p>Regards to all, Patrice<br></p><p><br>&gt; On Sep 3, 2016, at 1:22 PM, Patrice Kouame via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Gerard- <br>&gt; <br>&gt; Excellent!  Looking forward to seeing your fix (hoping you get your book back soon ;-) )<br>&gt; <br>&gt; I think Xcode/Swift gags on the last ptr advance to objectData.  I recently tried another variant using withUnsafeMutablePointer like this:<br>&gt; <br>&gt;         var ptr : UnsafeMutablePointer&lt;ObjectData&gt;  = withUnsafeMutablePointer(to: &amp;mainPtr) {<br>&gt;             $0.withMemoryRebound(to: ObjectData.self, capacity: objectsToRender) {<br>&gt;                 $0.pointee = renderables[0].objectData<br>&gt;             }<br>&gt;         }<br>&gt; <br>&gt; ..but still crashes with no hints.<br>&gt; <br>&gt; My bug report also mentions that the Xcode migration/conversion tool is incomplete.  <br>&gt; It handles the “simpler&quot; UnsafeMutableRawPointer&lt;X&gt; to UnsafeMutablePonter&lt;Y&gt; with bindMemory cases correctly (one still has to mind the capacity value though)<br>&gt; In all fairness, migrating/converting automagically in these cases is always a little bit tricky - the proposed Xcode fixes should always be reviewed by a human...<br>&gt; <br>&gt; Patrice<br>&gt; <br>&gt;&gt; On Sep 3, 2016, at 1:05 PM, Gerard Iglesias via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Ok<br>&gt;&gt; <br>&gt;&gt; For the record I succeeded this transformation phase last week<br>&gt;&gt; <br>&gt;&gt; I remember the tedious stuff to advance pointer from one struct to the other kind of struct... it worked<br>&gt;&gt; <br>&gt;&gt; But I don&#39;t have my MacBook with me, only the phone, the six :)<br>&gt;&gt; <br>&gt;&gt; Gérard <br>&gt;&gt; <br>&gt;&gt; Le 3 sept. 2016 à 18:22, Patrice Kouame &lt;pkouame at me.com &lt;mailto:pkouame at me.com&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt;&gt; Indeed. There is a difference between stride and size, but I interpreted capacity incorrectly for my purposes.  It should indicate the number of &lt;T&gt; elements (not their size - right?) and the snippets below should work.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Still, compiler crashes and Xcode IDE is left in inconsistent state.  So I filed this Apple radar against Developer Tools.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	28150447 - Swift 3 UnsafeMutablePointer conversion crashes the compiler and IDE<br>&gt;&gt;&gt; Should I file a Swift bug too? Would that be helpful?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Regards, Patrice<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Sep 3, 2016, at 11:39 AM, Gerard Iglesias via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hello,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think that it is more secure to use stride in place of size, sometimes it is not the same value.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I use it in my own use of raw bindings <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Regards<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Gérard <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Le 3 sept. 2016 à 10:03, Patrice Kouame via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hi Jacob - <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think you’re right. “capacity” should be the count of type T elements in my buffer.  So in my case that line should read<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;         let shadowPtr = constantBufferForFrame.contents().bindMemory(to: ShadowPass.self, capacity: shadowPassData.count)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The withMemoryRebound calls need similar adjustments. The pointer to MainPass is actually a single structure to it should be safe to do this<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;         let mainPtr : UnsafeMutablePointer&lt;MainPass&gt; = shadowPtr.advanced(by: 1).withMemoryRebound(to: MainPass.self, capacity: 1) {<br>&gt;&gt;&gt;&gt;&gt;             $0.pointee = mainPassFrameData<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Whereas the unsafe pointer to &lt;ObjectData&gt; is actually a buffer of renderable objects, so this should work:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;         var ptr : UnsafeMutablePointer&lt;ObjectData&gt; = mainPtr.advanced(by: 1).withMemoryRebound(to: ObjectData.self, capacity: objectsToRender) {_ in<br>&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There are surely ways to refactor and simplify this, but I’m trying to retain as much of the original sample code approach as possible.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; However, the compiler still segs badly. <br>&gt;&gt;&gt;&gt;&gt; Xcode also borks an internal error often. Only cleaning or restarting the project can clear up that state.<br>&gt;&gt;&gt;&gt;&gt; Compilers (or Playgrounds for that matter) should never crash, and I’m not sure where to file this bug : Swift or Apple radar against Xcode or both? I now Xcode 8 is beta but…it’s been doing this for quite a while now...<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In both our “close to the metal” (no pun intended) cases, it seems like a lot of churning for very little gain. Don’t you think? The easier, but “unsafe” casting afforded previously did the trick with the normal caveats.<br>&gt;&gt;&gt;&gt;&gt; Don’t get me wrong, I love Swift and “get&quot; all the neat type safety features. Guess we can’t have our cake and eat it too, especially when interfacing with “unsafe” C APIs.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Anyway, back to rtfm … maybe some of the Swift Gods can chime in?  ;-) <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I must be doing something stupid...Patrice<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Sep 3, 2016, at 2:32 AM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Hi Patrice,<br>&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t have a solution for you, but I just wanted to point out what I think may be an error with your use of the new UnsafeRawPointer APIs:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; constantBufferForFrame.contents().bindMemory(to: ShadowPass.self, capacity: MemoryLayout&lt;ShadowPass&gt;.size)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I believe the `capacity` should actually be the number of ShadowPass elements in the buffer, not the size of each element. Using `bindMemory(to: ShadowPass.self` already implies that MemoryLayout&lt;ShadowPass&gt;.size is the size of each element.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; More info at https://developer.apple.com/reference/swift/unsaferawpointer/2428875-bindmemory &lt;https://developer.apple.com/reference/swift/unsaferawpointer/2428875-bindmemory&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I just updated a small Metal project of mine to Swift 3. I ran into some compiler (playground) crashes, but it does seem to work most of the time. Although I only have 1 buffer :-) https://github.com/jtbandes/Metalbrot.playground &lt;https://github.com/jtbandes/Metalbrot.playground&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Jacob<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Fri, Sep 2, 2016 at 11:00 AM, Patrice Kouame via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; Hi all - <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I’m converting Apple’s Swift Sample &quot;Adopting Metal II: Designing and Implementing a Real-World Metal Renderer” in Xcode 8 beta6 to the latest UnsafeMutablePointer API for untyped memory access.  <br>&gt;&gt;&gt;&gt;&gt;&gt; Changes are necessary in MetalView.swift (Apple hasn’t updated their sample code for the latest beta yet…) <br>&gt;&gt;&gt;&gt;&gt;&gt; The Swift Compiler crashes (Segmentation Fault: 11) on the attempt:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;         // Grab a pointer to the constant buffer&#39;s data store<br>&gt;&gt;&gt;&gt;&gt;&gt;         // Since we are using Swift, it is easier to cast the pointer to the ShadowPass type to fill the constant buffer<br>&gt;&gt;&gt;&gt;&gt;&gt;         // We need to make a copy of these so the block captures the correct data<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; //      let shadowPtr = UnsafeMutablePointer&lt;ShadowPass&gt;(constantBufferForFrame.contents())<br>&gt;&gt;&gt;&gt;&gt;&gt;         let shadowPtr = constantBufferForFrame.contents().bindMemory(to: ShadowPass.self, capacity: MemoryLayout&lt;ShadowPass&gt;.size)<br>&gt;&gt;&gt;&gt;&gt;&gt;         shadowPtr.pointee = shadowPassData[0]<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;         //More Swift specific stuff - advance pointer and cast to MainPass<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; //      let mainPtr = UnsafeMutablePointer&lt;MainPass&gt;(shadowPtr.advanced(by: 1))<br>&gt;&gt;&gt;&gt;&gt;&gt; //      mainPtr.pointee = mainPassFrameData<br>&gt;&gt;&gt;&gt;&gt;&gt;         let mainPtr : UnsafeMutablePointer&lt;MainPass&gt;  = shadowPtr.advanced(by: 1).withMemoryRebound(to: MainPass.self, capacity: MemoryLayout&lt;MainPass&gt;.size) {<br>&gt;&gt;&gt;&gt;&gt;&gt;             $0.pointee = mainPassFrameData<br>&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;&gt;&gt;         //Advance and cast to ObjectData<br>&gt;&gt;&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;&gt;&gt; //      var ptr = UnsafeMutablePointer&lt;ObjectData&gt;(mainPtr.advanced(by: 1))<br>&gt;&gt;&gt;&gt;&gt;&gt;         var ptr : UnsafeMutablePointer&lt;ObjectData&gt; = mainPtr.advanced(by: 1).withMemoryRebound(to: ObjectData.self, capacity: MemoryLayout&lt;ObjectData&gt;.size) {_ in<br>&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;         let shadowOffset = 0<br>&gt;&gt;&gt;&gt;&gt;&gt;         let mainPassOffset = MemoryLayout&lt;ShadowPass&gt;.size + shadowOffset<br>&gt;&gt;&gt;&gt;&gt;&gt;         let objectDataOffset = MemoryLayout&lt;MainPass&gt;.size + mainPassOffset<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;         // Update position of all the objects<br>&gt;&gt;&gt;&gt;&gt;&gt;         if multithreadedUpdate {<br>&gt;&gt;&gt;&gt;&gt;&gt;             DispatchQueue.concurrentPerform(iterations: objectsToRender) { i in<br>&gt;&gt;&gt;&gt;&gt;&gt;                 let thisPtr = ptr.advanced(by: i)<br>&gt;&gt;&gt;&gt;&gt;&gt;                 _ = self.renderables[i].UpdateData(ptr, deltaTime: 1.0/60.0)<br>&gt;&gt;&gt;&gt;&gt;&gt;             }<br>&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;         else {<br>&gt;&gt;&gt;&gt;&gt;&gt;             for index in 0..&lt;objectsToRender {<br>&gt;&gt;&gt;&gt;&gt;&gt;                 ptr = renderables[index].UpdateData(ptr, deltaTime: 1.0/60.0)<br>&gt;&gt;&gt;&gt;&gt;&gt;             }<br>&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;&gt;&gt;         ptr = ptr.advanced(by: objectsToRender)<br>&gt;&gt;&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;&gt;&gt;         _ = groundPlane!.UpdateData(ptr, deltaTime: 1.0/60.0)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Any help is appreciated.  I have the latest Xcode log handy if necessary.  Here’s a clip of the stack trace.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 0  swift                    0x000000010714a99d PrintStackTraceSignalHandler(void*) + 45<br>&gt;&gt;&gt;&gt;&gt;&gt; 1  swift                    0x000000010714a3e6 SignalHandler(int) + 470<br>&gt;&gt;&gt;&gt;&gt;&gt; 2  libsystem_platform.dylib 0x00007fff91461bba _sigtramp + 26<br>&gt;&gt;&gt;&gt;&gt;&gt; 3  libsystem_platform.dylib 000000000000000000 _sigtramp + 1857676384<br>&gt;&gt;&gt;&gt;&gt;&gt; 4  swift                    0x00000001047207b3 (anonymous namespace)::SILGenApply::visitExpr(swift::Expr*) + 51<br>&gt;&gt;&gt;&gt;&gt;&gt; 5  swift                    0x0000000104723ace (anonymous namespace)::SILGenApply::visitApplyExpr(swift::ApplyExpr*) + 5182<br>&gt;&gt;&gt;&gt;&gt;&gt; 6  swift                    0x0000000104711cc1 prepareApplyExpr(swift::Lowering::SILGenFunction&amp;, swift::Expr*) + 273<br>&gt;&gt;&gt;&gt;&gt;&gt; 7  swift                    0x00000001047624e7 swift::ASTVisitor&lt;(anonymous namespace)::RValueEmitter, swift::Lowering::RValue, void, void, void, void, void, swift::Lowering::SGFContext&gt;::visit(swift::Expr*, swift::Lowering::SGFContext) + 103<br>&gt;&gt;&gt;&gt;&gt;&gt; 8  swift                    0x0000000104762313 swift::Lowering::SILGenFunction::emitExprInto(swift::Expr*, swift::Lowering::Initialization*) + 195<br>&gt;&gt;&gt;&gt;&gt;&gt; 9  swift                    0x000000010474fbc3 swift::Lowering::SILGenFunction::emitPatternBinding(swift::PatternBindingDecl*, unsigned int) + 195<br>&gt;&gt;&gt;&gt;&gt;&gt; 10 swift                    0x00000001047077bd swift::ASTVisitor&lt;swift::Lowering::SILGenFunction, void, void, void, void, void, void&gt;::visit(swift::Decl*) + 125<br>&gt;&gt;&gt;&gt;&gt;&gt; 11 swift                    0x00000001047c0019 swift::ASTVisitor&lt;(anonymous namespace)::StmtEmitter, void, void, void, void, void, void&gt;::visit(swift::Stmt*) + 4169<br>&gt;&gt;&gt;&gt;&gt;&gt; 12 swift                    0x00000001047809ba swift::Lowering::SILGenFunction::emitFunction(swift::FuncDecl*) + 314<br>&gt;&gt;&gt;&gt;&gt;&gt; 13 swift                    0x00000001046fd775 swift::Lowering::SILGenModule::emitFunction(swift::FuncDecl*)::$_1::operator()(swift::SILFunction*) const + 1877<br>&gt;&gt;&gt;&gt;&gt;&gt; 14 swift                    0x00000001046fc322 swift::Lowering::SILGenModule::emitFunction(swift::FuncDecl*) + 626<br>&gt;&gt;&gt;&gt;&gt;&gt; 15 swift                    0x00000001047c7007 (anonymous namespace)::SILGenType::emitType() + 1271<br>&gt;&gt;&gt;&gt;&gt;&gt; 16 swift                    0x00000001047c6a9e swift::Lowering::SILGenModule::visitNominalTypeDecl(swift::NominalTypeDecl*) + 30<br>&gt;&gt;&gt;&gt;&gt;&gt; 17 swift                    0x0000000104709093 swift::Lowering::SILGenModule::emitSourceFile(swift::SourceFile*, unsigned int) + 1795<br>&gt;&gt;&gt;&gt;&gt;&gt; 18 swift                    0x000000010470ad4d swift::SILModule::constructSIL(swift::ModuleDecl*, swift::SILOptions&amp;, swift::FileUnit*, llvm::Optional&lt;unsigned int&gt;, bool, bool) + 1629<br>&gt;&gt;&gt;&gt;&gt;&gt; 19 swift                    0x00000001045621bf performCompile(swift::CompilerInstance&amp;, swift::CompilerInvocation&amp;, llvm::ArrayRef&lt;char const*&gt;, int&amp;, swift::FrontendObserver*) + 19487<br>&gt;&gt;&gt;&gt;&gt;&gt; 20 swift                    0x000000010455b2c5 swift::performFrontend(llvm::ArrayRef&lt;char const*&gt;, char const*, void*, swift::FrontendObserver*) + 17029<br>&gt;&gt;&gt;&gt;&gt;&gt; 21 swift                    0x000000010451888d main + 8685<br>&gt;&gt;&gt;&gt;&gt;&gt; 22 libdyld.dylib            0x00007fff91255255 start + 1<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Patrice<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt;&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160903/af66ece6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>UnsafeMutablePointer Swift 3 conversion</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>September  3, 2016 at 01:00:00pm</p></header><div class="content"><p>Yikes! That&#39;s unsafe! When using withMemoryRebound, I think you&#39;re only<br>supposed to use the argument $0 inside the block. Saving it and using it<br>after withMemoryRebound is probably undefined behavior. But maybe you can<br>move your &quot;.pointee = x&quot; into a separate function rather than using a<br>closure?<br></p><p>On Sat, Sep 3, 2016 at 1:12 PM, Patrice Kouame via swift-users &lt;<br>swift-users at swift.org&gt; wrote:<br></p><p>&gt; Finally Success!  I’m seeing my pretty little 3D twirling Metal Renderer<br>&gt; cubes again… Here’s how<br>&gt;<br>&gt; Snippet of old  sample code which no longer compiles in Xcode 8 beta 6<br>&gt; with stricter Swift3 unsafe type casting restrictions<br>&gt; (in MetalView.swift from # Adopting Metal II: Designing and Implementing<br>&gt; a Real-World Metal Renderer)<br>&gt;<br>&gt; let shadowPtr = UnsafeMutablePointer&lt;ShadowPass&gt;(constantBufferForFrame.<br>&gt; contents())<br>&gt; let mainPtr = UnsafeMutablePointer&lt;MainPass&gt;(shadowPtr.advanced(by: 1))<br>&gt; mainPtr.pointee = mainPassFrameData<br>&gt; var ptr = UnsafeMutablePointer&lt;ObjectData&gt;(mainPtr.advanced(by: 1))<br>&gt;<br>&gt; My conversion attempt that crashes Swift 3 Xcode 8 beta 6 (see  RADAR 28150447<br>&gt; - Swift 3 UnsafeMutablePointer conversion crashes the compiler and IDE)<br>&gt;<br>&gt;         let shadowPtr = constantBufferForFrame.contents().bindMemory(to:<br>&gt; ShadowPass.self, capacity: MemoryLayout&lt;shadowPassData&gt;.size)<br>&gt;         let mainPtr : UnsafeMutablePointer&lt;MainPass&gt; = shadowPtr.advanced(by:<br>&gt; 1).withMemoryRebound(to: MainPass.self, capacity: 1) {<br>&gt; $0.pointee = mainPassFrameData<br>&gt; }<br>&gt;         var ptr : UnsafeMutablePointer&lt;ObjectData&gt; = mainPtr.advanced(by:<br>&gt; 1).withMemoryRebound(to: ObjectData.self, capacity: MemoryLayout&lt;<br>&gt; ObjectData &gt;.size) {$0}<br>&gt;<br>&gt; Latest conversion that make Xcode and Swift 3 smile again...<br>&gt;<br>&gt;         let shadowPtr = constantBufferForFrame.contents().bindMemory(to:<br>&gt; ShadowPass.self, capacity: shadowPassData.count)<br>&gt;         let mainPtr : UnsafeMutablePointer&lt;MainPass&gt; = shadowPtr.advanced(by:<br>&gt; 1).withMemoryRebound(to: MainPass.self, capacity: 1) {$0}<br>&gt;         mainPtr.pointee = mainPassFrameData<br>&gt;         var ptr : UnsafeMutablePointer&lt;ObjectData&gt; = mainPtr.advanced(by:<br>&gt; 1).withMemoryRebound(to: ObjectData.self, capacity: objectsToRender) {$0}<br>&gt;<br>&gt; Yes… Xcode/Swift3 SIL generation definitely did NOT like my &quot;$0.pointee =<br>&gt; mainPassFrameData&quot; statement.<br>&gt; Apparently, reassigning the pointee within the closure makes Swift gag out<br>&gt; of disgust. Sorry ;-(<br>&gt; That’s what I get for trying to be fancy…<br>&gt; And fixed my “capacity” issues thanks to some previous posters.<br>&gt;<br>&gt; Hope this helps anyone trying to get the Metal projects to compile again.<br>&gt;<br>&gt; At least I got a Radar out of this ;-) Compilers should never burn and<br>&gt; crash out like this...<br>&gt;<br>&gt; Regards to all, Patrice<br>&gt;<br>&gt;<br>&gt; On Sep 3, 2016, at 1:22 PM, Patrice Kouame via swift-users &lt;<br>&gt; swift-users at swift.org&gt; wrote:<br>&gt;<br>&gt; Gerard-<br>&gt;<br>&gt; Excellent!  Looking forward to seeing your fix (hoping you get your book<br>&gt; back soon ;-) )<br>&gt;<br>&gt; I think Xcode/Swift gags on the last ptr advance to objectData.  I<br>&gt; recently tried another variant using withUnsafeMutablePointer like this:<br>&gt;<br>&gt;         var ptr : UnsafeMutablePointer&lt;ObjectData&gt;  =<br>&gt; withUnsafeMutablePointer(to: &amp;mainPtr) {<br>&gt;             $0.withMemoryRebound(to: ObjectData.self, capacity:<br>&gt; objectsToRender) {<br>&gt;                 $0.pointee = renderables[0].objectData<br>&gt;             }<br>&gt;         }<br>&gt;<br>&gt; ..but still crashes with no hints.<br>&gt;<br>&gt; My bug report also mentions that the Xcode migration/conversion tool is<br>&gt; incomplete.<br>&gt; It handles the “simpler&quot; UnsafeMutableRawPointer&lt;X&gt; to<br>&gt; UnsafeMutablePonter&lt;Y&gt; with bindMemory cases correctly (one still has to<br>&gt; mind the capacity value though)<br>&gt; In all fairness, migrating/converting automagically in these cases is<br>&gt; always a little bit tricky - the proposed Xcode fixes should always be<br>&gt; reviewed by a human...<br>&gt;<br>&gt; Patrice<br>&gt;<br>&gt; On Sep 3, 2016, at 1:05 PM, Gerard Iglesias via swift-users &lt;<br>&gt; swift-users at swift.org&gt; wrote:<br>&gt;<br>&gt; Ok<br>&gt;<br>&gt; For the record I succeeded this transformation phase last week<br>&gt;<br>&gt; I remember the tedious stuff to advance pointer from one struct to the<br>&gt; other kind of struct... it worked<br>&gt;<br>&gt; But I don&#39;t have my MacBook with me, only the phone, the six :)<br>&gt;<br>&gt; Gérard<br>&gt;<br>&gt; Le 3 sept. 2016 à 18:22, Patrice Kouame &lt;pkouame at me.com&gt; a écrit :<br>&gt;<br>&gt; Indeed. There is a difference between stride and size, but I interpreted<br>&gt; capacity incorrectly for my purposes.  It should indicate the number of &lt;T&gt;<br>&gt; elements (not their size - right?) and the snippets below should work.<br>&gt;<br>&gt; Still, compiler crashes and Xcode IDE is left in inconsistent state.  So I<br>&gt; filed this Apple radar against Developer Tools.<br>&gt;<br>&gt; 28150447 - Swift 3 UnsafeMutablePointer conversion crashes the compiler<br>&gt; and IDE<br>&gt; Should I file a Swift bug too? Would that be helpful?<br>&gt;<br>&gt; Regards, Patrice<br>&gt;<br>&gt; On Sep 3, 2016, at 11:39 AM, Gerard Iglesias via swift-users &lt;<br>&gt; swift-users at swift.org&gt; wrote:<br>&gt;<br>&gt; Hello,<br>&gt;<br>&gt; I think that it is more secure to use stride in place of size, sometimes<br>&gt; it is not the same value.<br>&gt;<br>&gt; I use it in my own use of raw bindings<br>&gt;<br>&gt; Regards<br>&gt;<br>&gt; Gérard<br>&gt;<br>&gt; Le 3 sept. 2016 à 10:03, Patrice Kouame via swift-users &lt;<br>&gt; swift-users at swift.org&gt; a écrit :<br>&gt;<br>&gt; Hi Jacob -<br>&gt;<br>&gt; I think you’re right. “capacity” should be the count of type T elements in<br>&gt; my buffer.  So in my case that line should read<br>&gt;<br>&gt;         let shadowPtr = constantBufferForFrame.contents().bindMemory(to:<br>&gt; ShadowPass.self, capacity: shadowPassData.count)<br>&gt;<br>&gt; The withMemoryRebound calls need similar adjustments. The pointer to<br>&gt; MainPass is actually a single structure to it should be safe to do this<br>&gt;<br>&gt;         let mainPtr : UnsafeMutablePointer&lt;MainPass&gt; =<br>&gt; shadowPtr.advanced(by: 1).withMemoryRebound(to: MainPass.self, capacity: 1)<br>&gt; {<br>&gt;             $0.pointee = mainPassFrameData<br>&gt;         }<br>&gt;<br>&gt; Whereas the unsafe pointer to &lt;ObjectData&gt; is actually a buffer of<br>&gt; renderable objects, so this should work:<br>&gt;<br>&gt;         var ptr : UnsafeMutablePointer&lt;ObjectData&gt; = mainPtr.advanced(by:<br>&gt; 1).withMemoryRebound(to: ObjectData.self, capacity: objectsToRender) {_ in<br>&gt; }<br>&gt;<br>&gt; There are surely ways to refactor and simplify this, but I’m trying to<br>&gt; retain as much of the original sample code approach as possible.<br>&gt;<br>&gt; However, the compiler still segs badly.<br>&gt; Xcode also borks an internal error often. Only cleaning or restarting the<br>&gt; project can clear up that state.<br>&gt; Compilers (or Playgrounds for that matter) should never crash, and I’m not<br>&gt; sure where to file this bug : Swift or Apple radar against Xcode or both? I<br>&gt; now Xcode 8 is beta but…it’s been doing this for quite a while now...<br>&gt;<br>&gt; In both our “close to the metal” (no pun intended) cases, it seems like a<br>&gt; lot of churning for very little gain. Don’t you think? The easier, but<br>&gt; “unsafe” casting afforded previously did the trick with the normal caveats.<br>&gt; Don’t get me wrong, I love Swift and “get&quot; all the neat type safety<br>&gt; features. Guess we can’t have our cake and eat it too, especially when<br>&gt; interfacing with “unsafe” C APIs.<br>&gt;<br>&gt; Anyway, back to rtfm … maybe some of the Swift Gods can chime in?  ;-)<br>&gt;<br>&gt; I must be doing something stupid...Patrice<br>&gt;<br>&gt; On Sep 3, 2016, at 2:32 AM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; Hi Patrice,<br>&gt; I don&#39;t have a solution for you, but I just wanted to point out what I<br>&gt; think may be an error with your use of the new UnsafeRawPointer APIs:<br>&gt;<br>&gt; constantBufferForFrame.contents().bindMemory(to: ShadowPass.self,<br>&gt; capacity: MemoryLayout&lt;ShadowPass&gt;.size)<br>&gt;<br>&gt; I believe the `capacity` should actually be the number of ShadowPass<br>&gt; elements in the buffer, not the size of each element. Using `bindMemory(to:<br>&gt; ShadowPass.self` already implies that MemoryLayout&lt;ShadowPass&gt;.size is the<br>&gt; size of each element.<br>&gt;<br>&gt; More info at https://developer.apple.com/reference/swift/<br>&gt; unsaferawpointer/2428875-bindmemory<br>&gt;<br>&gt; I just updated a small Metal project of mine to Swift 3. I ran into some<br>&gt; compiler (playground) crashes, but it does seem to work most of the time.<br>&gt; Although I only have 1 buffer :-) https://github.com/jtbandes/<br>&gt; Metalbrot.playground<br>&gt;<br>&gt; Jacob<br>&gt;<br>&gt; On Fri, Sep 2, 2016 at 11:00 AM, Patrice Kouame via swift-users &lt;<br>&gt; swift-users at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Hi all -<br>&gt;&gt;<br>&gt;&gt; I’m converting Apple’s Swift Sample &quot;Adopting Metal II: Designing and<br>&gt;&gt; Implementing a Real-World Metal Renderer” in Xcode 8 beta6 to the latest<br>&gt;&gt; UnsafeMutablePointer API for untyped memory access.<br>&gt;&gt; Changes are necessary in MetalView.swift (Apple hasn’t updated their<br>&gt;&gt; sample code for the latest beta yet…)<br>&gt;&gt; The Swift Compiler crashes (Segmentation Fault: 11) on the attempt:<br>&gt;&gt;<br>&gt;&gt;         // Grab a pointer to the constant buffer&#39;s data store<br>&gt;&gt;         // Since we are using Swift, it is easier to cast the pointer to<br>&gt;&gt; the ShadowPass type to fill the constant buffer<br>&gt;&gt;         // We need to make a copy of these so the block captures the<br>&gt;&gt; correct data<br>&gt;&gt;<br>&gt;&gt; //      let shadowPtr = UnsafeMutablePointer&lt;ShadowPas<br>&gt;&gt; s&gt;(constantBufferForFrame.contents())<br>&gt;&gt;         let shadowPtr = constantBufferForFrame.contents().bindMemory(to:<br>&gt;&gt; ShadowPass.self, capacity: MemoryLayout&lt;ShadowPass&gt;.size)<br>&gt;&gt;         shadowPtr.pointee = shadowPassData[0]<br>&gt;&gt;<br>&gt;&gt;         //More Swift specific stuff - advance pointer and cast to<br>&gt;&gt; MainPass<br>&gt;&gt;<br>&gt;&gt; //      let mainPtr = UnsafeMutablePointer&lt;MainPass&gt;(shadowPtr.advanced(by:<br>&gt;&gt; 1))<br>&gt;&gt; //      mainPtr.pointee = mainPassFrameData<br>&gt;&gt;         let mainPtr : UnsafeMutablePointer&lt;MainPass&gt;  =<br>&gt;&gt; shadowPtr.advanced(by: 1).withMemoryRebound(to: MainPass.self, capacity:<br>&gt;&gt; MemoryLayout&lt;MainPass&gt;.size) {<br>&gt;&gt;             $0.pointee = mainPassFrameData<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;         //Advance and cast to ObjectData<br>&gt;&gt;<br>&gt;&gt; //      var ptr = UnsafeMutablePointer&lt;ObjectData&gt;(mainPtr.advanced(by:<br>&gt;&gt; 1))<br>&gt;&gt;         var ptr : UnsafeMutablePointer&lt;ObjectData&gt; =<br>&gt;&gt; mainPtr.advanced(by: 1).withMemoryRebound(to: ObjectData.self, capacity:<br>&gt;&gt; MemoryLayout&lt;ObjectData&gt;.size) {_ in<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;         let shadowOffset = 0<br>&gt;&gt;         let mainPassOffset = MemoryLayout&lt;ShadowPass&gt;.size + shadowOffset<br>&gt;&gt;         let objectDataOffset = MemoryLayout&lt;MainPass&gt;.size +<br>&gt;&gt; mainPassOffset<br>&gt;&gt;<br>&gt;&gt;         // Update position of all the objects<br>&gt;&gt;         if multithreadedUpdate {<br>&gt;&gt;             DispatchQueue.concurrentPerform(iterations: objectsToRender)<br>&gt;&gt; { i in<br>&gt;&gt;                 let thisPtr = ptr.advanced(by: i)<br>&gt;&gt;                 _ = self.renderables[i].UpdateData(ptr, deltaTime: 1.0/<br>&gt;&gt; 60.0)<br>&gt;&gt;             }<br>&gt;&gt;         }<br>&gt;&gt;         else {<br>&gt;&gt;             for index in 0..&lt;objectsToRender {<br>&gt;&gt;                 ptr = renderables[index].UpdateData(ptr, deltaTime: 1.0/<br>&gt;&gt; 60.0)<br>&gt;&gt;             }<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;         ptr = ptr.advanced(by: objectsToRender)<br>&gt;&gt;<br>&gt;&gt;         _ = groundPlane!.UpdateData(ptr, deltaTime: 1.0/60.0)<br>&gt;&gt;<br>&gt;&gt; Any help is appreciated.  I have the latest Xcode log handy if<br>&gt;&gt; necessary.  Here’s a clip of the stack trace.<br>&gt;&gt;<br>&gt;&gt; 0  swift                    0x000000010714a99d<br>&gt;&gt; PrintStackTraceSignalHandler(void*) + 45<br>&gt;&gt; 1  swift                    0x000000010714a3e6 SignalHandler(int) + 470<br>&gt;&gt; 2  libsystem_platform.dylib 0x00007fff91461bba _sigtramp + 26<br>&gt;&gt; 3  libsystem_platform.dylib 000000000000000000 _sigtramp + 1857676384<br>&gt;&gt; 4  swift                    0x00000001047207b3 (anonymous<br>&gt;&gt; namespace)::SILGenApply::visitExpr(swift::Expr*) + 51<br>&gt;&gt; 5  swift                    0x0000000104723ace (anonymous<br>&gt;&gt; namespace)::SILGenApply::visitApplyExpr(swift::ApplyExpr*) + 5182<br>&gt;&gt; 6  swift                    0x0000000104711cc1<br>&gt;&gt; prepareApplyExpr(swift::Lowering::SILGenFunction&amp;, swift::Expr*) + 273<br>&gt;&gt; 7  swift                    0x00000001047624e7<br>&gt;&gt; swift::ASTVisitor&lt;(anonymous namespace)::RValueEmitter,<br>&gt;&gt; swift::Lowering::RValue, void, void, void, void, void,<br>&gt;&gt; swift::Lowering::SGFContext&gt;::visit(swift::Expr*,<br>&gt;&gt; swift::Lowering::SGFContext) + 103<br>&gt;&gt; 8  swift                    0x0000000104762313<br>&gt;&gt; swift::Lowering::SILGenFunction::emitExprInto(swift::Expr*,<br>&gt;&gt; swift::Lowering::Initialization*) + 195<br>&gt;&gt; 9  swift                    0x000000010474fbc3<br>&gt;&gt; swift::Lowering::SILGenFunction::emitPatternBinding(swift::PatternBindingDecl*,<br>&gt;&gt; unsigned int) + 195<br>&gt;&gt; 10 swift                    0x00000001047077bd<br>&gt;&gt; swift::ASTVisitor&lt;swift::Lowering::SILGenFunction, void, void, void,<br>&gt;&gt; void, void, void&gt;::visit(swift::Decl*) + 125<br>&gt;&gt; 11 swift                    0x00000001047c0019<br>&gt;&gt; swift::ASTVisitor&lt;(anonymous namespace)::StmtEmitter, void, void, void,<br>&gt;&gt; void, void, void&gt;::visit(swift::Stmt*) + 4169<br>&gt;&gt; 12 swift                    0x00000001047809ba<br>&gt;&gt; swift::Lowering::SILGenFunction::emitFunction(swift::FuncDecl*) + 314<br>&gt;&gt; 13 swift                    0x00000001046fd775<br>&gt;&gt; swift::Lowering::SILGenModule::emitFunction(swift::FuncDecl*<br>&gt;&gt; )::$_1::operator()(swift::SILFunction*) const + 1877<br>&gt;&gt; 14 swift                    0x00000001046fc322<br>&gt;&gt; swift::Lowering::SILGenModule::emitFunction(swift::FuncDecl*) + 626<br>&gt;&gt; 15 swift                    0x00000001047c7007 (anonymous<br>&gt;&gt; namespace)::SILGenType::emitType() + 1271<br>&gt;&gt; 16 swift                    0x00000001047c6a9e<br>&gt;&gt; swift::Lowering::SILGenModule::visitNominalTypeDecl(swift::NominalTypeDecl*)<br>&gt;&gt; + 30<br>&gt;&gt; 17 swift                    0x0000000104709093<br>&gt;&gt; swift::Lowering::SILGenModule::emitSourceFile(swift::SourceFile*,<br>&gt;&gt; unsigned int) + 1795<br>&gt;&gt; 18 swift                    0x000000010470ad4d<br>&gt;&gt; swift::SILModule::constructSIL(swift::ModuleDecl*, swift::SILOptions&amp;,<br>&gt;&gt; swift::FileUnit*, llvm::Optional&lt;unsigned int&gt;, bool, bool) + 1629<br>&gt;&gt; 19 swift                    0x00000001045621bf<br>&gt;&gt; performCompile(swift::CompilerInstance&amp;, swift::CompilerInvocation&amp;,<br>&gt;&gt; llvm::ArrayRef&lt;char const*&gt;, int&amp;, swift::FrontendObserver*) + 19487<br>&gt;&gt; 20 swift                    0x000000010455b2c5<br>&gt;&gt; swift::performFrontend(llvm::ArrayRef&lt;char const*&gt;, char const*, void*,<br>&gt;&gt; swift::FrontendObserver*) + 17029<br>&gt;&gt; 21 swift                    0x000000010451888d main + 8685<br>&gt;&gt; 22 libdyld.dylib            0x00007fff91255255 start + 1<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Patrice<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160903/d700d33e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8016afa037fa775c19d05b495a24413f?s=50"></div><header><strong>UnsafeMutablePointer Swift 3 conversion</strong> from <string>Patrice Kouame</string> &lt;pkouame at me.com&gt;<p>September  3, 2016 at 05:00:00pm</p></header><div class="content"><p>Not sure what you mean? <br>The positional arg $0 is never used outside the closure whatever the version...<br>No attempt is ever made to save and reuse after withMemoryRebound?<br>Why would I use a separate function?<br></p><p>Are we looking at the same code? 🤓<br></p><p>rédigé sur mon iPhone.<br></p><p>&gt; On Sep 3, 2016, at 4:16 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt; Yikes! That&#39;s unsafe! When using withMemoryRebound, I think you&#39;re only supposed to use the argument $0 inside the block. Saving it and using it after withMemoryRebound is probably undefined behavior. But maybe you can move your &quot;.pointee = x&quot; into a separate function rather than using a closure?<br>&gt; <br>&gt;&gt; On Sat, Sep 3, 2016 at 1:12 PM, Patrice Kouame via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; Finally Success!  I’m seeing my pretty little 3D twirling Metal Renderer cubes again… Here’s how<br>&gt;&gt; <br>&gt;&gt; Snippet of old  sample code which no longer compiles in Xcode 8 beta 6 with stricter Swift3 unsafe type casting restrictions <br>&gt;&gt; (in MetalView.swift from # Adopting Metal II: Designing and Implementing a Real-World Metal Renderer)<br>&gt;&gt; <br>&gt;&gt; 	let shadowPtr = UnsafeMutablePointer&lt;ShadowPass&gt;(constantBufferForFrame.contents())<br>&gt;&gt; 	let mainPtr = UnsafeMutablePointer&lt;MainPass&gt;(shadowPtr.advanced(by: 1))<br>&gt;&gt; 	mainPtr.pointee = mainPassFrameData<br>&gt;&gt; 	var ptr = UnsafeMutablePointer&lt;ObjectData&gt;(mainPtr.advanced(by: 1))<br>&gt;&gt; <br>&gt;&gt; My conversion attempt that crashes Swift 3 Xcode 8 beta 6 (see  RADAR 28150447 - Swift 3 UnsafeMutablePointer conversion crashes the compiler and IDE)<br>&gt;&gt; <br>&gt;&gt;         let shadowPtr = constantBufferForFrame.contents().bindMemory(to: ShadowPass.self, capacity: MemoryLayout&lt;shadowPassData&gt;.size)<br>&gt;&gt;         let mainPtr : UnsafeMutablePointer&lt;MainPass&gt; = shadowPtr.advanced(by: 1).withMemoryRebound(to: MainPass.self, capacity: 1) {<br>&gt;&gt; 		$0.pointee = mainPassFrameData<br>&gt;&gt; 	}<br>&gt;&gt;         var ptr : UnsafeMutablePointer&lt;ObjectData&gt; = mainPtr.advanced(by: 1).withMemoryRebound(to: ObjectData.self, capacity: MemoryLayout&lt; ObjectData &gt;.size) {$0}<br>&gt;&gt; <br>&gt;&gt; Latest conversion that make Xcode and Swift 3 smile again...<br>&gt;&gt; <br>&gt;&gt;         let shadowPtr = constantBufferForFrame.contents().bindMemory(to: ShadowPass.self, capacity: shadowPassData.count)<br>&gt;&gt;         let mainPtr : UnsafeMutablePointer&lt;MainPass&gt; = shadowPtr.advanced(by: 1).withMemoryRebound(to: MainPass.self, capacity: 1) {$0}<br>&gt;&gt;         mainPtr.pointee = mainPassFrameData<br>&gt;&gt;         var ptr : UnsafeMutablePointer&lt;ObjectData&gt; = mainPtr.advanced(by: 1).withMemoryRebound(to: ObjectData.self, capacity: objectsToRender) {$0}<br>&gt;&gt; <br>&gt;&gt; Yes… Xcode/Swift3 SIL generation definitely did NOT like my &quot;$0.pointee = mainPassFrameData&quot; statement. <br>&gt;&gt; Apparently, reassigning the pointee within the closure makes Swift gag out of disgust. Sorry ;-(<br>&gt;&gt; That’s what I get for trying to be fancy…<br>&gt;&gt; And fixed my “capacity” issues thanks to some previous posters.<br>&gt;&gt; <br>&gt;&gt; Hope this helps anyone trying to get the Metal projects to compile again.<br>&gt;&gt; <br>&gt;&gt; At least I got a Radar out of this ;-) Compilers should never burn and crash out like this...<br>&gt;&gt; <br>&gt;&gt; Regards to all, Patrice<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Sep 3, 2016, at 1:22 PM, Patrice Kouame via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Gerard- <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Excellent!  Looking forward to seeing your fix (hoping you get your book back soon ;-) )<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think Xcode/Swift gags on the last ptr advance to objectData.  I recently tried another variant using withUnsafeMutablePointer like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         var ptr : UnsafeMutablePointer&lt;ObjectData&gt;  = withUnsafeMutablePointer(to: &amp;mainPtr) {<br>&gt;&gt;&gt;             $0.withMemoryRebound(to: ObjectData.self, capacity: objectsToRender) {<br>&gt;&gt;&gt;                 $0.pointee = renderables[0].objectData<br>&gt;&gt;&gt;             }<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ..but still crashes with no hints.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My bug report also mentions that the Xcode migration/conversion tool is incomplete.  <br>&gt;&gt;&gt; It handles the “simpler&quot; UnsafeMutableRawPointer&lt;X&gt; to UnsafeMutablePonter&lt;Y&gt; with bindMemory cases correctly (one still has to mind the capacity value though)<br>&gt;&gt;&gt; In all fairness, migrating/converting automagically in these cases is always a little bit tricky - the proposed Xcode fixes should always be reviewed by a human...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Patrice<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Sep 3, 2016, at 1:05 PM, Gerard Iglesias via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Ok<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For the record I succeeded this transformation phase last week<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I remember the tedious stuff to advance pointer from one struct to the other kind of struct... it worked<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But I don&#39;t have my MacBook with me, only the phone, the six :)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Gérard <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Le 3 sept. 2016 à 18:22, Patrice Kouame &lt;pkouame at me.com&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Indeed. There is a difference between stride and size, but I interpreted capacity incorrectly for my purposes.  It should indicate the number of &lt;T&gt; elements (not their size - right?) and the snippets below should work.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Still, compiler crashes and Xcode IDE is left in inconsistent state.  So I filed this Apple radar against Developer Tools.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	28150447 - Swift 3 UnsafeMutablePointer conversion crashes the compiler and IDE<br>&gt;&gt;&gt;&gt;&gt; Should I file a Swift bug too? Would that be helpful?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Regards, Patrice<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Sep 3, 2016, at 11:39 AM, Gerard Iglesias via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Hello,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I think that it is more secure to use stride in place of size, sometimes it is not the same value.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I use it in my own use of raw bindings <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Regards<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Gérard <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Le 3 sept. 2016 à 10:03, Patrice Kouame via swift-users &lt;swift-users at swift.org&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi Jacob - <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think you’re right. “capacity” should be the count of type T elements in my buffer.  So in my case that line should read<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         let shadowPtr = constantBufferForFrame.contents().bindMemory(to: ShadowPass.self, capacity: shadowPassData.count)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The withMemoryRebound calls need similar adjustments. The pointer to MainPass is actually a single structure to it should be safe to do this<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         let mainPtr : UnsafeMutablePointer&lt;MainPass&gt; = shadowPtr.advanced(by: 1).withMemoryRebound(to: MainPass.self, capacity: 1) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;             $0.pointee = mainPassFrameData<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Whereas the unsafe pointer to &lt;ObjectData&gt; is actually a buffer of renderable objects, so this should work:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         var ptr : UnsafeMutablePointer&lt;ObjectData&gt; = mainPtr.advanced(by: 1).withMemoryRebound(to: ObjectData.self, capacity: objectsToRender) {_ in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; There are surely ways to refactor and simplify this, but I’m trying to retain as much of the original sample code approach as possible.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; However, the compiler still segs badly. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Xcode also borks an internal error often. Only cleaning or restarting the project can clear up that state.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Compilers (or Playgrounds for that matter) should never crash, and I’m not sure where to file this bug : Swift or Apple radar against Xcode or both? I now Xcode 8 is beta but…it’s been doing this for quite a while now...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; In both our “close to the metal” (no pun intended) cases, it seems like a lot of churning for very little gain. Don’t you think? The easier, but “unsafe” casting afforded previously did the trick with the normal caveats.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Don’t get me wrong, I love Swift and “get&quot; all the neat type safety features. Guess we can’t have our cake and eat it too, especially when interfacing with “unsafe” C APIs.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Anyway, back to rtfm … maybe some of the Swift Gods can chime in?  ;-) <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I must be doing something stupid...Patrice<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Sep 3, 2016, at 2:32 AM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi Patrice,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t have a solution for you, but I just wanted to point out what I think may be an error with your use of the new UnsafeRawPointer APIs:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; constantBufferForFrame.contents().bindMemory(to: ShadowPass.self, capacity: MemoryLayout&lt;ShadowPass&gt;.size)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I believe the `capacity` should actually be the number of ShadowPass elements in the buffer, not the size of each element. Using `bindMemory(to: ShadowPass.self` already implies that MemoryLayout&lt;ShadowPass&gt;.size is the size of each element.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; More info at https://developer.apple.com/reference/swift/unsaferawpointer/2428875-bindmemory<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I just updated a small Metal project of mine to Swift 3. I ran into some compiler (playground) crashes, but it does seem to work most of the time. Although I only have 1 buffer :-) https://github.com/jtbandes/Metalbrot.playground<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jacob<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Fri, Sep 2, 2016 at 11:00 AM, Patrice Kouame via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi all - <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I’m converting Apple’s Swift Sample &quot;Adopting Metal II: Designing and Implementing a Real-World Metal Renderer” in Xcode 8 beta6 to the latest UnsafeMutablePointer API for untyped memory access.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Changes are necessary in MetalView.swift (Apple hasn’t updated their sample code for the latest beta yet…) <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The Swift Compiler crashes (Segmentation Fault: 11) on the attempt:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         // Grab a pointer to the constant buffer&#39;s data store<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         // Since we are using Swift, it is easier to cast the pointer to the ShadowPass type to fill the constant buffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         // We need to make a copy of these so the block captures the correct data<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; //      let shadowPtr = UnsafeMutablePointer&lt;ShadowPass&gt;(constantBufferForFrame.contents())<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         let shadowPtr = constantBufferForFrame.contents().bindMemory(to: ShadowPass.self, capacity: MemoryLayout&lt;ShadowPass&gt;.size)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         shadowPtr.pointee = shadowPassData[0]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         //More Swift specific stuff - advance pointer and cast to MainPass<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; //      let mainPtr = UnsafeMutablePointer&lt;MainPass&gt;(shadowPtr.advanced(by: 1))<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; //      mainPtr.pointee = mainPassFrameData<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         let mainPtr : UnsafeMutablePointer&lt;MainPass&gt;  = shadowPtr.advanced(by: 1).withMemoryRebound(to: MainPass.self, capacity: MemoryLayout&lt;MainPass&gt;.size) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;             $0.pointee = mainPassFrameData<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         //Advance and cast to ObjectData<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; //      var ptr = UnsafeMutablePointer&lt;ObjectData&gt;(mainPtr.advanced(by: 1))<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         var ptr : UnsafeMutablePointer&lt;ObjectData&gt; = mainPtr.advanced(by: 1).withMemoryRebound(to: ObjectData.self, capacity: MemoryLayout&lt;ObjectData&gt;.size) {_ in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         let shadowOffset = 0<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         let mainPassOffset = MemoryLayout&lt;ShadowPass&gt;.size + shadowOffset<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         let objectDataOffset = MemoryLayout&lt;MainPass&gt;.size + mainPassOffset<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         // Update position of all the objects<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         if multithreadedUpdate {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;             DispatchQueue.concurrentPerform(iterations: objectsToRender) { i in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                 let thisPtr = ptr.advanced(by: i)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                 _ = self.renderables[i].UpdateData(ptr, deltaTime: 1.0/60.0)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;             }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         else {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;             for index in 0..&lt;objectsToRender {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                 ptr = renderables[index].UpdateData(ptr, deltaTime: 1.0/60.0)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;             }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         ptr = ptr.advanced(by: objectsToRender)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         _ = groundPlane!.UpdateData(ptr, deltaTime: 1.0/60.0)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Any help is appreciated.  I have the latest Xcode log handy if necessary.  Here’s a clip of the stack trace.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 0  swift                    0x000000010714a99d PrintStackTraceSignalHandler(void*) + 45<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1  swift                    0x000000010714a3e6 SignalHandler(int) + 470<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2  libsystem_platform.dylib 0x00007fff91461bba _sigtramp + 26<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3  libsystem_platform.dylib 000000000000000000 _sigtramp + 1857676384<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 4  swift                    0x00000001047207b3 (anonymous namespace)::SILGenApply::visitExpr(swift::Expr*) + 51<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 5  swift                    0x0000000104723ace (anonymous namespace)::SILGenApply::visitApplyExpr(swift::ApplyExpr*) + 5182<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 6  swift                    0x0000000104711cc1 prepareApplyExpr(swift::Lowering::SILGenFunction&amp;, swift::Expr*) + 273<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 7  swift                    0x00000001047624e7 swift::ASTVisitor&lt;(anonymous namespace)::RValueEmitter, swift::Lowering::RValue, void, void, void, void, void, swift::Lowering::SGFContext&gt;::visit(swift::Expr*, swift::Lowering::SGFContext) + 103<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 8  swift                    0x0000000104762313 swift::Lowering::SILGenFunction::emitExprInto(swift::Expr*, swift::Lowering::Initialization*) + 195<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 9  swift                    0x000000010474fbc3 swift::Lowering::SILGenFunction::emitPatternBinding(swift::PatternBindingDecl*, unsigned int) + 195<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 10 swift                    0x00000001047077bd swift::ASTVisitor&lt;swift::Lowering::SILGenFunction, void, void, void, void, void, void&gt;::visit(swift::Decl*) + 125<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 11 swift                    0x00000001047c0019 swift::ASTVisitor&lt;(anonymous namespace)::StmtEmitter, void, void, void, void, void, void&gt;::visit(swift::Stmt*) + 4169<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 12 swift                    0x00000001047809ba swift::Lowering::SILGenFunction::emitFunction(swift::FuncDecl*) + 314<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 13 swift                    0x00000001046fd775 swift::Lowering::SILGenModule::emitFunction(swift::FuncDecl*)::$_1::operator()(swift::SILFunction*) const + 1877<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 14 swift                    0x00000001046fc322 swift::Lowering::SILGenModule::emitFunction(swift::FuncDecl*) + 626<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 15 swift                    0x00000001047c7007 (anonymous namespace)::SILGenType::emitType() + 1271<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 16 swift                    0x00000001047c6a9e swift::Lowering::SILGenModule::visitNominalTypeDecl(swift::NominalTypeDecl*) + 30<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 17 swift                    0x0000000104709093 swift::Lowering::SILGenModule::emitSourceFile(swift::SourceFile*, unsigned int) + 1795<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 18 swift                    0x000000010470ad4d swift::SILModule::constructSIL(swift::ModuleDecl*, swift::SILOptions&amp;, swift::FileUnit*, llvm::Optional&lt;unsigned int&gt;, bool, bool) + 1629<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 19 swift                    0x00000001045621bf performCompile(swift::CompilerInstance&amp;, swift::CompilerInvocation&amp;, llvm::ArrayRef&lt;char const*&gt;, int&amp;, swift::FrontendObserver*) + 19487<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 20 swift                    0x000000010455b2c5 swift::performFrontend(llvm::ArrayRef&lt;char const*&gt;, char const*, void*, swift::FrontendObserver*) + 17029<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 21 swift                    0x000000010451888d main + 8685<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 22 libdyld.dylib            0x00007fff91255255 start + 1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Patrice<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-users at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-users at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-users at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt;&gt; swift-users at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt; swift-users at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160903/1e66c8c9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>UnsafeMutablePointer Swift 3 conversion</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>September  3, 2016 at 06:00:00pm</p></header><div class="content"><p>I was referring to this:<br></p><p>        let mainPtr : UnsafeMutablePointer&lt;MainPass&gt; = shadowPtr.advanced<br>(by: 1).withMemoryRebound(to: MainPass.self, capacity: 1) {$0}<br>        mainPtr.pointee = mainPassFrameData<br></p><p>The result of $0 is being returned from the block and used later.<br></p><p>cc&#39;ing Andrew Trick on this conversation because his input would be quite<br>useful :-)<br></p><p>Jacob<br></p><p>On Sat, Sep 3, 2016 at 2:03 PM, Patrice Kouame &lt;pkouame at me.com&gt; wrote:<br></p><p>&gt;<br>&gt; Not sure what you mean?<br>&gt; The positional arg $0 is never used outside the closure whatever the<br>&gt; version...<br>&gt; No attempt is ever made to save and reuse after withMemoryRebound?<br>&gt; Why would I use a separate function?<br>&gt;<br>&gt; Are we looking at the same code? 🤓<br>&gt;<br>&gt; rédigé sur mon iPhone.<br>&gt;<br>&gt; On Sep 3, 2016, at 4:16 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; Yikes! That&#39;s unsafe! When using withMemoryRebound, I think you&#39;re only<br>&gt; supposed to use the argument $0 inside the block. Saving it and using it<br>&gt; after withMemoryRebound is probably undefined behavior. But maybe you can<br>&gt; move your &quot;.pointee = x&quot; into a separate function rather than using a<br>&gt; closure?<br>&gt;<br>&gt; On Sat, Sep 3, 2016 at 1:12 PM, Patrice Kouame via swift-users &lt;<br>&gt; swift-users at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Finally Success!  I’m seeing my pretty little 3D twirling Metal Renderer<br>&gt;&gt; cubes again… Here’s how<br>&gt;&gt;<br>&gt;&gt; Snippet of old  sample code which no longer compiles in Xcode 8 beta 6<br>&gt;&gt; with stricter Swift3 unsafe type casting restrictions<br>&gt;&gt; (in MetalView.swift from # Adopting Metal II: Designing and Implementing<br>&gt;&gt; a Real-World Metal Renderer)<br>&gt;&gt;<br>&gt;&gt; let shadowPtr = UnsafeMutablePointer&lt;ShadowPas<br>&gt;&gt; s&gt;(constantBufferForFrame.contents())<br>&gt;&gt; let mainPtr = UnsafeMutablePointer&lt;MainPass&gt;(shadowPtr.advanced(by: 1))<br>&gt;&gt; mainPtr.pointee = mainPassFrameData<br>&gt;&gt; var ptr = UnsafeMutablePointer&lt;ObjectData&gt;(mainPtr.advanced(by: 1))<br>&gt;&gt;<br>&gt;&gt; My conversion attempt that crashes Swift 3 Xcode 8 beta 6 (see  RADAR 28150447<br>&gt;&gt; - Swift 3 UnsafeMutablePointer conversion crashes the compiler and IDE)<br>&gt;&gt;<br>&gt;&gt;         let shadowPtr = constantBufferForFrame.contents().bindMemory(to:<br>&gt;&gt; ShadowPass.self, capacity: MemoryLayout&lt;shadowPassData&gt;.size)<br>&gt;&gt;         let mainPtr : UnsafeMutablePointer&lt;MainPass&gt; = shadowPtr.advanced(by:<br>&gt;&gt; 1).withMemoryRebound(to: MainPass.self, capacity: 1) {<br>&gt;&gt; $0.pointee = mainPassFrameData<br>&gt;&gt; }<br>&gt;&gt;         var ptr : UnsafeMutablePointer&lt;ObjectData&gt; = mainPtr.advanced(by:<br>&gt;&gt; 1).withMemoryRebound(to: ObjectData.self, capacity: MemoryLayout&lt; Object<br>&gt;&gt; Data &gt;.size) {$0}<br>&gt;&gt;<br>&gt;&gt; Latest conversion that make Xcode and Swift 3 smile again...<br>&gt;&gt;<br>&gt;&gt;         let shadowPtr = constantBufferForFrame.contents().bindMemory(to:<br>&gt;&gt; ShadowPass.self, capacity: shadowPassData.count)<br>&gt;&gt;         let mainPtr : UnsafeMutablePointer&lt;MainPass&gt; = shadowPtr.advanced(by:<br>&gt;&gt; 1).withMemoryRebound(to: MainPass.self, capacity: 1) {$0}<br>&gt;&gt;         mainPtr.pointee = mainPassFrameData<br>&gt;&gt;         var ptr : UnsafeMutablePointer&lt;ObjectData&gt; = mainPtr.advanced(by:<br>&gt;&gt; 1).withMemoryRebound(to: ObjectData.self, capacity: objectsToRender) {$0}<br>&gt;&gt;<br>&gt;&gt; Yes… Xcode/Swift3 SIL generation definitely did NOT like my &quot;$0.pointee =<br>&gt;&gt; mainPassFrameData&quot; statement.<br>&gt;&gt; Apparently, reassigning the pointee within the closure makes Swift gag<br>&gt;&gt; out of disgust. Sorry ;-(<br>&gt;&gt; That’s what I get for trying to be fancy…<br>&gt;&gt; And fixed my “capacity” issues thanks to some previous posters.<br>&gt;&gt;<br>&gt;&gt; Hope this helps anyone trying to get the Metal projects to compile again.<br>&gt;&gt;<br>&gt;&gt; At least I got a Radar out of this ;-) Compilers should never burn and<br>&gt;&gt; crash out like this...<br>&gt;&gt;<br>&gt;&gt; Regards to all, Patrice<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Sep 3, 2016, at 1:22 PM, Patrice Kouame via swift-users &lt;<br>&gt;&gt; swift-users at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Gerard-<br>&gt;&gt;<br>&gt;&gt; Excellent!  Looking forward to seeing your fix (hoping you get your book<br>&gt;&gt; back soon ;-) )<br>&gt;&gt;<br>&gt;&gt; I think Xcode/Swift gags on the last ptr advance to objectData.  I<br>&gt;&gt; recently tried another variant using withUnsafeMutablePointer like this:<br>&gt;&gt;<br>&gt;&gt;         var ptr : UnsafeMutablePointer&lt;ObjectData&gt;  =<br>&gt;&gt; withUnsafeMutablePointer(to: &amp;mainPtr) {<br>&gt;&gt;             $0.withMemoryRebound(to: ObjectData.self, capacity:<br>&gt;&gt; objectsToRender) {<br>&gt;&gt;                 $0.pointee = renderables[0].objectData<br>&gt;&gt;             }<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt; ..but still crashes with no hints.<br>&gt;&gt;<br>&gt;&gt; My bug report also mentions that the Xcode migration/conversion tool is<br>&gt;&gt; incomplete.<br>&gt;&gt; It handles the “simpler&quot; UnsafeMutableRawPointer&lt;X&gt; to<br>&gt;&gt; UnsafeMutablePonter&lt;Y&gt; with bindMemory cases correctly (one still has to<br>&gt;&gt; mind the capacity value though)<br>&gt;&gt; In all fairness, migrating/converting automagically in these cases is<br>&gt;&gt; always a little bit tricky - the proposed Xcode fixes should always be<br>&gt;&gt; reviewed by a human...<br>&gt;&gt;<br>&gt;&gt; Patrice<br>&gt;&gt;<br>&gt;&gt; On Sep 3, 2016, at 1:05 PM, Gerard Iglesias via swift-users &lt;<br>&gt;&gt; swift-users at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Ok<br>&gt;&gt;<br>&gt;&gt; For the record I succeeded this transformation phase last week<br>&gt;&gt;<br>&gt;&gt; I remember the tedious stuff to advance pointer from one struct to the<br>&gt;&gt; other kind of struct... it worked<br>&gt;&gt;<br>&gt;&gt; But I don&#39;t have my MacBook with me, only the phone, the six :)<br>&gt;&gt;<br>&gt;&gt; Gérard<br>&gt;&gt;<br>&gt;&gt; Le 3 sept. 2016 à 18:22, Patrice Kouame &lt;pkouame at me.com&gt; a écrit :<br>&gt;&gt;<br>&gt;&gt; Indeed. There is a difference between stride and size, but I interpreted<br>&gt;&gt; capacity incorrectly for my purposes.  It should indicate the number of &lt;T&gt;<br>&gt;&gt; elements (not their size - right?) and the snippets below should work.<br>&gt;&gt;<br>&gt;&gt; Still, compiler crashes and Xcode IDE is left in inconsistent state.  So<br>&gt;&gt; I filed this Apple radar against Developer Tools.<br>&gt;&gt;<br>&gt;&gt; 28150447 - Swift 3 UnsafeMutablePointer conversion crashes the compiler<br>&gt;&gt; and IDE<br>&gt;&gt; Should I file a Swift bug too? Would that be helpful?<br>&gt;&gt;<br>&gt;&gt; Regards, Patrice<br>&gt;&gt;<br>&gt;&gt; On Sep 3, 2016, at 11:39 AM, Gerard Iglesias via swift-users &lt;<br>&gt;&gt; swift-users at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Hello,<br>&gt;&gt;<br>&gt;&gt; I think that it is more secure to use stride in place of size, sometimes<br>&gt;&gt; it is not the same value.<br>&gt;&gt;<br>&gt;&gt; I use it in my own use of raw bindings<br>&gt;&gt;<br>&gt;&gt; Regards<br>&gt;&gt;<br>&gt;&gt; Gérard<br>&gt;&gt;<br>&gt;&gt; Le 3 sept. 2016 à 10:03, Patrice Kouame via swift-users &lt;<br>&gt;&gt; swift-users at swift.org&gt; a écrit :<br>&gt;&gt;<br>&gt;&gt; Hi Jacob -<br>&gt;&gt;<br>&gt;&gt; I think you’re right. “capacity” should be the count of type T elements<br>&gt;&gt; in my buffer.  So in my case that line should read<br>&gt;&gt;<br>&gt;&gt;         let shadowPtr = constantBufferForFrame.contents().bindMemory(to:<br>&gt;&gt; ShadowPass.self, capacity: shadowPassData.count)<br>&gt;&gt;<br>&gt;&gt; The withMemoryRebound calls need similar adjustments. The pointer to<br>&gt;&gt; MainPass is actually a single structure to it should be safe to do this<br>&gt;&gt;<br>&gt;&gt;         let mainPtr : UnsafeMutablePointer&lt;MainPass&gt; =<br>&gt;&gt; shadowPtr.advanced(by: 1).withMemoryRebound(to: MainPass.self, capacity:<br>&gt;&gt; 1) {<br>&gt;&gt;             $0.pointee = mainPassFrameData<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt; Whereas the unsafe pointer to &lt;ObjectData&gt; is actually a buffer of<br>&gt;&gt; renderable objects, so this should work:<br>&gt;&gt;<br>&gt;&gt;         var ptr : UnsafeMutablePointer&lt;ObjectData&gt; =<br>&gt;&gt; mainPtr.advanced(by: 1).withMemoryRebound(to: ObjectData.self, capacity:<br>&gt;&gt; objectsToRender) {_ in<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; There are surely ways to refactor and simplify this, but I’m trying to<br>&gt;&gt; retain as much of the original sample code approach as possible.<br>&gt;&gt;<br>&gt;&gt; However, the compiler still segs badly.<br>&gt;&gt; Xcode also borks an internal error often. Only cleaning or restarting<br>&gt;&gt; the project can clear up that state.<br>&gt;&gt; Compilers (or Playgrounds for that matter) should never crash, and I’m<br>&gt;&gt; not sure where to file this bug : Swift or Apple radar against Xcode or<br>&gt;&gt; both? I now Xcode 8 is beta but…it’s been doing this for quite a while<br>&gt;&gt; now...<br>&gt;&gt;<br>&gt;&gt; In both our “close to the metal” (no pun intended) cases, it seems like a<br>&gt;&gt; lot of churning for very little gain. Don’t you think? The easier, but<br>&gt;&gt; “unsafe” casting afforded previously did the trick with the normal caveats.<br>&gt;&gt; Don’t get me wrong, I love Swift and “get&quot; all the neat type safety<br>&gt;&gt; features. Guess we can’t have our cake and eat it too, especially when<br>&gt;&gt; interfacing with “unsafe” C APIs.<br>&gt;&gt;<br>&gt;&gt; Anyway, back to rtfm … maybe some of the Swift Gods can chime in?  ;-)<br>&gt;&gt;<br>&gt;&gt; I must be doing something stupid...Patrice<br>&gt;&gt;<br>&gt;&gt; On Sep 3, 2016, at 2:32 AM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Hi Patrice,<br>&gt;&gt; I don&#39;t have a solution for you, but I just wanted to point out what I<br>&gt;&gt; think may be an error with your use of the new UnsafeRawPointer APIs:<br>&gt;&gt;<br>&gt;&gt; constantBufferForFrame.contents().bindMemory(to: ShadowPass.self,<br>&gt;&gt; capacity: MemoryLayout&lt;ShadowPass&gt;.size)<br>&gt;&gt;<br>&gt;&gt; I believe the `capacity` should actually be the number of ShadowPass<br>&gt;&gt; elements in the buffer, not the size of each element. Using `bindMemory(to:<br>&gt;&gt; ShadowPass.self` already implies that MemoryLayout&lt;ShadowPass&gt;.size is the<br>&gt;&gt; size of each element.<br>&gt;&gt;<br>&gt;&gt; More info at https://developer.apple.com/reference/swift/unsaferawpointer<br>&gt;&gt; /2428875-bindmemory<br>&gt;&gt;<br>&gt;&gt; I just updated a small Metal project of mine to Swift 3. I ran into some<br>&gt;&gt; compiler (playground) crashes, but it does seem to work most of the time.<br>&gt;&gt; Although I only have 1 buffer :-) https://github.com/jtbandes/Me<br>&gt;&gt; talbrot.playground<br>&gt;&gt;<br>&gt;&gt; Jacob<br>&gt;&gt;<br>&gt;&gt; On Fri, Sep 2, 2016 at 11:00 AM, Patrice Kouame via swift-users &lt;<br>&gt;&gt; swift-users at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Hi all -<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I’m converting Apple’s Swift Sample &quot;Adopting Metal II: Designing and<br>&gt;&gt;&gt; Implementing a Real-World Metal Renderer” in Xcode 8 beta6 to the latest<br>&gt;&gt;&gt; UnsafeMutablePointer API for untyped memory access.<br>&gt;&gt;&gt; Changes are necessary in MetalView.swift (Apple hasn’t updated their<br>&gt;&gt;&gt; sample code for the latest beta yet…)<br>&gt;&gt;&gt; The Swift Compiler crashes (Segmentation Fault: 11) on the attempt:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         // Grab a pointer to the constant buffer&#39;s data store<br>&gt;&gt;&gt;         // Since we are using Swift, it is easier to cast the pointer<br>&gt;&gt;&gt; to the ShadowPass type to fill the constant buffer<br>&gt;&gt;&gt;         // We need to make a copy of these so the block captures the<br>&gt;&gt;&gt; correct data<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; //      let shadowPtr = UnsafeMutablePointer&lt;ShadowPas<br>&gt;&gt;&gt; s&gt;(constantBufferForFrame.contents())<br>&gt;&gt;&gt;         let shadowPtr = constantBufferForFrame.contents().bindMemory(to:<br>&gt;&gt;&gt; ShadowPass.self, capacity: MemoryLayout&lt;ShadowPass&gt;.size)<br>&gt;&gt;&gt;         shadowPtr.pointee = shadowPassData[0]<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         //More Swift specific stuff - advance pointer and cast to<br>&gt;&gt;&gt; MainPass<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; //      let mainPtr = UnsafeMutablePointer&lt;MainPass&gt;(shadowPtr.advanced(by:<br>&gt;&gt;&gt; 1))<br>&gt;&gt;&gt; //      mainPtr.pointee = mainPassFrameData<br>&gt;&gt;&gt;         let mainPtr : UnsafeMutablePointer&lt;MainPass&gt;  =<br>&gt;&gt;&gt; shadowPtr.advanced(by: 1).withMemoryRebound(to: MainPass.self,<br>&gt;&gt;&gt; capacity: MemoryLayout&lt;MainPass&gt;.size) {<br>&gt;&gt;&gt;             $0.pointee = mainPassFrameData<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         //Advance and cast to ObjectData<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; //      var ptr = UnsafeMutablePointer&lt;ObjectData&gt;(mainPtr.advanced(by:<br>&gt;&gt;&gt; 1))<br>&gt;&gt;&gt;         var ptr : UnsafeMutablePointer&lt;ObjectData&gt; =<br>&gt;&gt;&gt; mainPtr.advanced(by: 1).withMemoryRebound(to: ObjectData.self,<br>&gt;&gt;&gt; capacity: MemoryLayout&lt;ObjectData&gt;.size) {_ in<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         let shadowOffset = 0<br>&gt;&gt;&gt;         let mainPassOffset = MemoryLayout&lt;ShadowPass&gt;.size +<br>&gt;&gt;&gt; shadowOffset<br>&gt;&gt;&gt;         let objectDataOffset = MemoryLayout&lt;MainPass&gt;.size +<br>&gt;&gt;&gt; mainPassOffset<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         // Update position of all the objects<br>&gt;&gt;&gt;         if multithreadedUpdate {<br>&gt;&gt;&gt;             DispatchQueue.concurrentPerform(iterations:<br>&gt;&gt;&gt; objectsToRender) { i in<br>&gt;&gt;&gt;                 let thisPtr = ptr.advanced(by: i)<br>&gt;&gt;&gt;                 _ = self.renderables[i].UpdateData(ptr, deltaTime: 1.0/<br>&gt;&gt;&gt; 60.0)<br>&gt;&gt;&gt;             }<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;         else {<br>&gt;&gt;&gt;             for index in 0..&lt;objectsToRender {<br>&gt;&gt;&gt;                 ptr = renderables[index].UpdateData(ptr, deltaTime: 1.0/<br>&gt;&gt;&gt; 60.0)<br>&gt;&gt;&gt;             }<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         ptr = ptr.advanced(by: objectsToRender)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         _ = groundPlane!.UpdateData(ptr, deltaTime: 1.0/60.0)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Any help is appreciated.  I have the latest Xcode log handy if<br>&gt;&gt;&gt; necessary.  Here’s a clip of the stack trace.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 0  swift                    0x000000010714a99d<br>&gt;&gt;&gt; PrintStackTraceSignalHandler(void*) + 45<br>&gt;&gt;&gt; 1  swift                    0x000000010714a3e6 SignalHandler(int) + 470<br>&gt;&gt;&gt; 2  libsystem_platform.dylib 0x00007fff91461bba _sigtramp + 26<br>&gt;&gt;&gt; 3  libsystem_platform.dylib 000000000000000000 _sigtramp + 1857676384<br>&gt;&gt;&gt; 4  swift                    0x00000001047207b3 (anonymous<br>&gt;&gt;&gt; namespace)::SILGenApply::visitExpr(swift::Expr*) + 51<br>&gt;&gt;&gt; 5  swift                    0x0000000104723ace (anonymous<br>&gt;&gt;&gt; namespace)::SILGenApply::visitApplyExpr(swift::ApplyExpr*) + 5182<br>&gt;&gt;&gt; 6  swift                    0x0000000104711cc1<br>&gt;&gt;&gt; prepareApplyExpr(swift::Lowering::SILGenFunction&amp;, swift::Expr*) + 273<br>&gt;&gt;&gt; 7  swift                    0x00000001047624e7<br>&gt;&gt;&gt; swift::ASTVisitor&lt;(anonymous namespace)::RValueEmitter,<br>&gt;&gt;&gt; swift::Lowering::RValue, void, void, void, void, void,<br>&gt;&gt;&gt; swift::Lowering::SGFContext&gt;::visit(swift::Expr*,<br>&gt;&gt;&gt; swift::Lowering::SGFContext) + 103<br>&gt;&gt;&gt; 8  swift                    0x0000000104762313<br>&gt;&gt;&gt; swift::Lowering::SILGenFunction::emitExprInto(swift::Expr*,<br>&gt;&gt;&gt; swift::Lowering::Initialization*) + 195<br>&gt;&gt;&gt; 9  swift                    0x000000010474fbc3<br>&gt;&gt;&gt; swift::Lowering::SILGenFunction::emitPatternBinding(swift::PatternBindingDecl*,<br>&gt;&gt;&gt; unsigned int) + 195<br>&gt;&gt;&gt; 10 swift                    0x00000001047077bd<br>&gt;&gt;&gt; swift::ASTVisitor&lt;swift::Lowering::SILGenFunction, void, void, void,<br>&gt;&gt;&gt; void, void, void&gt;::visit(swift::Decl*) + 125<br>&gt;&gt;&gt; 11 swift                    0x00000001047c0019<br>&gt;&gt;&gt; swift::ASTVisitor&lt;(anonymous namespace)::StmtEmitter, void, void, void,<br>&gt;&gt;&gt; void, void, void&gt;::visit(swift::Stmt*) + 4169<br>&gt;&gt;&gt; 12 swift                    0x00000001047809ba<br>&gt;&gt;&gt; swift::Lowering::SILGenFunction::emitFunction(swift::FuncDecl*) + 314<br>&gt;&gt;&gt; 13 swift                    0x00000001046fd775<br>&gt;&gt;&gt; swift::Lowering::SILGenModule::emitFunction(swift::FuncDecl*<br>&gt;&gt;&gt; )::$_1::operator()(swift::SILFunction*) const + 1877<br>&gt;&gt;&gt; 14 swift                    0x00000001046fc322<br>&gt;&gt;&gt; swift::Lowering::SILGenModule::emitFunction(swift::FuncDecl*) + 626<br>&gt;&gt;&gt; 15 swift                    0x00000001047c7007 (anonymous<br>&gt;&gt;&gt; namespace)::SILGenType::emitType() + 1271<br>&gt;&gt;&gt; 16 swift                    0x00000001047c6a9e<br>&gt;&gt;&gt; swift::Lowering::SILGenModule::visitNominalTypeDecl(swift::NominalTypeDecl*)<br>&gt;&gt;&gt; + 30<br>&gt;&gt;&gt; 17 swift                    0x0000000104709093<br>&gt;&gt;&gt; swift::Lowering::SILGenModule::emitSourceFile(swift::SourceFile*,<br>&gt;&gt;&gt; unsigned int) + 1795<br>&gt;&gt;&gt; 18 swift                    0x000000010470ad4d<br>&gt;&gt;&gt; swift::SILModule::constructSIL(swift::ModuleDecl*, swift::SILOptions&amp;,<br>&gt;&gt;&gt; swift::FileUnit*, llvm::Optional&lt;unsigned int&gt;, bool, bool) + 1629<br>&gt;&gt;&gt; 19 swift                    0x00000001045621bf<br>&gt;&gt;&gt; performCompile(swift::CompilerInstance&amp;, swift::CompilerInvocation&amp;,<br>&gt;&gt;&gt; llvm::ArrayRef&lt;char const*&gt;, int&amp;, swift::FrontendObserver*) + 19487<br>&gt;&gt;&gt; 20 swift                    0x000000010455b2c5<br>&gt;&gt;&gt; swift::performFrontend(llvm::ArrayRef&lt;char const*&gt;, char const*, void*,<br>&gt;&gt;&gt; swift::FrontendObserver*) + 17029<br>&gt;&gt;&gt; 21 swift                    0x000000010451888d main + 8685<br>&gt;&gt;&gt; 22 libdyld.dylib            0x00007fff91255255 start + 1<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Patrice<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt; swift-users at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160903/b3f3ba33/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8016afa037fa775c19d05b495a24413f?s=50"></div><header><strong>UnsafeMutablePointer Swift 3 conversion</strong> from <string>Patrice Kouame</string> &lt;pkouame at me.com&gt;<p>September  4, 2016 at 01:00:00am</p></header><div class="content"><p>Ok, I see. <br></p><p>But withMemoryRebound requires a return value. Don’t think there’s any way around that…compiler error<br>And mainPtr (now typed correctly/safely) needs to access the appropriate data structure mainPassFrameData.<br>Hence the external mainPtr.pointee assignment (since I can’t do so safely within the closure -&gt; Swift compiler crashes)<br></p><p>Gerard Iglesias crafted another version of this snippet of code using assumingMemoryBound but also assigns pointee externally.<br>So did the original sample code.<br></p><p>Haven’t we achieved the goal of “safely&quot; re-typing raw memory on the fly? To &quot;help the compiler help us&quot; so to speak…<br>What do you believe is so “unsafe&quot; about the external pointee assignment? Since the compiler won’t let us do so anymore <br>If the types aren’t all correctly aligned.<br></p><p>Curious to see what Andrew Trick has to say about all of this. Good idea to cc: him<br></p><p>In the meantime, both versions seem to work. Plus am learning a lot about typed versus untyped memory access in Swift...<br></p><p>Best - Patrice<br></p><p>On Sep 3, 2016, at 9:27 PM, Jacob Bandes-Storch via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; I was referring to this:<br>&gt; <br>&gt;         let mainPtr : UnsafeMutablePointer&lt;MainPass&gt; = shadowPtr.advanced(by: 1).withMemoryRebound(to: MainPass.self, capacity: 1) {$0}<br>&gt;         mainPtr.pointee = mainPassFrameData<br>&gt; <br>&gt; The result of $0 is being returned from the block and used later.<br>&gt; <br>&gt; cc&#39;ing Andrew Trick on this conversation because his input would be quite useful :-)<br>&gt; <br>&gt; Jacob<br>&gt; <br>&gt; On Sat, Sep 3, 2016 at 2:03 PM, Patrice Kouame &lt;pkouame at me.com&gt; wrote:<br>&gt; <br>&gt; Not sure what you mean? <br>&gt; The positional arg $0 is never used outside the closure whatever the version...<br>&gt; No attempt is ever made to save and reuse after withMemoryRebound?<br>&gt; Why would I use a separate function?<br>&gt; <br>&gt; Are we looking at the same code? 🤓<br>&gt; <br>&gt; rédigé sur mon iPhone.<br>&gt; <br>&gt; On Sep 3, 2016, at 4:16 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; Yikes! That&#39;s unsafe! When using withMemoryRebound, I think you&#39;re only supposed to use the argument $0 inside the block. Saving it and using it after withMemoryRebound is probably undefined behavior. But maybe you can move your &quot;.pointee = x&quot; into a separate function rather than using a closure?<br>&gt;&gt; <br>&gt;&gt; On Sat, Sep 3, 2016 at 1:12 PM, Patrice Kouame via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; Finally Success!  I’m seeing my pretty little 3D twirling Metal Renderer cubes again… Here’s how<br>&gt;&gt; <br>&gt;&gt; Snippet of old  sample code which no longer compiles in Xcode 8 beta 6 with stricter Swift3 unsafe type casting restrictions <br>&gt;&gt; (in MetalView.swift from # Adopting Metal II: Designing and Implementing a Real-World Metal Renderer)<br>&gt;&gt; <br>&gt;&gt; 	let shadowPtr = UnsafeMutablePointer&lt;ShadowPass&gt;(constantBufferForFrame.contents())<br>&gt;&gt; 	let mainPtr = UnsafeMutablePointer&lt;MainPass&gt;(shadowPtr.advanced(by: 1))<br>&gt;&gt; 	mainPtr.pointee = mainPassFrameData<br>&gt;&gt; 	var ptr = UnsafeMutablePointer&lt;ObjectData&gt;(mainPtr.advanced(by: 1))<br>&gt;&gt; <br>&gt;&gt; My conversion attempt that crashes Swift 3 Xcode 8 beta 6 (see  RADAR 28150447 - Swift 3 UnsafeMutablePointer conversion crashes the compiler and IDE)<br>&gt;&gt; <br>&gt;&gt;         let shadowPtr = constantBufferForFrame.contents().bindMemory(to: ShadowPass.self, capacity: MemoryLayout&lt;shadowPassData&gt;.size)<br>&gt;&gt;         let mainPtr : UnsafeMutablePointer&lt;MainPass&gt; = shadowPtr.advanced(by: 1).withMemoryRebound(to: MainPass.self, capacity: 1) {<br>&gt;&gt; 		$0.pointee = mainPassFrameData<br>&gt;&gt; 	}<br>&gt;&gt;         var ptr : UnsafeMutablePointer&lt;ObjectData&gt; = mainPtr.advanced(by: 1).withMemoryRebound(to: ObjectData.self, capacity: MemoryLayout&lt; ObjectData &gt;.size) {$0}<br>&gt;&gt; <br>&gt;&gt; Latest conversion that make Xcode and Swift 3 smile again...<br>&gt;&gt; <br>&gt;&gt;         let shadowPtr = constantBufferForFrame.contents().bindMemory(to: ShadowPass.self, capacity: shadowPassData.count)<br>&gt;&gt;         let mainPtr : UnsafeMutablePointer&lt;MainPass&gt; = shadowPtr.advanced(by: 1).withMemoryRebound(to: MainPass.self, capacity: 1) {$0}<br>&gt;&gt;         mainPtr.pointee = mainPassFrameData<br>&gt;&gt;         var ptr : UnsafeMutablePointer&lt;ObjectData&gt; = mainPtr.advanced(by: 1).withMemoryRebound(to: ObjectData.self, capacity: objectsToRender) {$0}<br>&gt;&gt; <br>&gt;&gt; Yes… Xcode/Swift3 SIL generation definitely did NOT like my &quot;$0.pointee = mainPassFrameData&quot; statement. <br>&gt;&gt; Apparently, reassigning the pointee within the closure makes Swift gag out of disgust. Sorry ;-(<br>&gt;&gt; That’s what I get for trying to be fancy…<br>&gt;&gt; And fixed my “capacity” issues thanks to some previous posters.<br>&gt;&gt; <br>&gt;&gt; Hope this helps anyone trying to get the Metal projects to compile again.<br>&gt;&gt; <br>&gt;&gt; At least I got a Radar out of this ;-) Compilers should never burn and crash out like this...<br>&gt;&gt; <br>&gt;&gt; Regards to all, Patrice<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Sep 3, 2016, at 1:22 PM, Patrice Kouame via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Gerard- <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Excellent!  Looking forward to seeing your fix (hoping you get your book back soon ;-) )<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think Xcode/Swift gags on the last ptr advance to objectData.  I recently tried another variant using withUnsafeMutablePointer like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         var ptr : UnsafeMutablePointer&lt;ObjectData&gt;  = withUnsafeMutablePointer(to: &amp;mainPtr) {<br>&gt;&gt;&gt;             $0.withMemoryRebound(to: ObjectData.self, capacity: objectsToRender) {<br>&gt;&gt;&gt;                 $0.pointee = renderables[0].objectData<br>&gt;&gt;&gt;             }<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ..but still crashes with no hints.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My bug report also mentions that the Xcode migration/conversion tool is incomplete.  <br>&gt;&gt;&gt; It handles the “simpler&quot; UnsafeMutableRawPointer&lt;X&gt; to UnsafeMutablePonter&lt;Y&gt; with bindMemory cases correctly (one still has to mind the capacity value though)<br>&gt;&gt;&gt; In all fairness, migrating/converting automagically in these cases is always a little bit tricky - the proposed Xcode fixes should always be reviewed by a human...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Patrice<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Sep 3, 2016, at 1:05 PM, Gerard Iglesias via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Ok<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For the record I succeeded this transformation phase last week<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I remember the tedious stuff to advance pointer from one struct to the other kind of struct... it worked<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But I don&#39;t have my MacBook with me, only the phone, the six :)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Gérard <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Le 3 sept. 2016 à 18:22, Patrice Kouame &lt;pkouame at me.com&gt; a écrit :<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Indeed. There is a difference between stride and size, but I interpreted capacity incorrectly for my purposes.  It should indicate the number of &lt;T&gt; elements (not their size - right?) and the snippets below should work.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Still, compiler crashes and Xcode IDE is left in inconsistent state.  So I filed this Apple radar against Developer Tools.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	28150447 - Swift 3 UnsafeMutablePointer conversion crashes the compiler and IDE<br>&gt;&gt;&gt;&gt;&gt; Should I file a Swift bug too? Would that be helpful?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Regards, Patrice<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Sep 3, 2016, at 11:39 AM, Gerard Iglesias via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Hello,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I think that it is more secure to use stride in place of size, sometimes it is not the same value.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I use it in my own use of raw bindings <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Regards<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Gérard <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Le 3 sept. 2016 à 10:03, Patrice Kouame via swift-users &lt;swift-users at swift.org&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi Jacob - <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think you’re right. “capacity” should be the count of type T elements in my buffer.  So in my case that line should read<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         let shadowPtr = constantBufferForFrame.contents().bindMemory(to: ShadowPass.self, capacity: shadowPassData.count)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The withMemoryRebound calls need similar adjustments. The pointer to MainPass is actually a single structure to it should be safe to do this<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         let mainPtr : UnsafeMutablePointer&lt;MainPass&gt; = shadowPtr.advanced(by: 1).withMemoryRebound(to: MainPass.self, capacity: 1) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;             $0.pointee = mainPassFrameData<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Whereas the unsafe pointer to &lt;ObjectData&gt; is actually a buffer of renderable objects, so this should work:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         var ptr : UnsafeMutablePointer&lt;ObjectData&gt; = mainPtr.advanced(by: 1).withMemoryRebound(to: ObjectData.self, capacity: objectsToRender) {_ in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; There are surely ways to refactor and simplify this, but I’m trying to retain as much of the original sample code approach as possible.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; However, the compiler still segs badly. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Xcode also borks an internal error often. Only cleaning or restarting the project can clear up that state.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Compilers (or Playgrounds for that matter) should never crash, and I’m not sure where to file this bug : Swift or Apple radar against Xcode or both? I now Xcode 8 is beta but…it’s been doing this for quite a while now...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; In both our “close to the metal” (no pun intended) cases, it seems like a lot of churning for very little gain. Don’t you think? The easier, but “unsafe” casting afforded previously did the trick with the normal caveats.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Don’t get me wrong, I love Swift and “get&quot; all the neat type safety features. Guess we can’t have our cake and eat it too, especially when interfacing with “unsafe” C APIs.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Anyway, back to rtfm … maybe some of the Swift Gods can chime in?  ;-) <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I must be doing something stupid...Patrice<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Sep 3, 2016, at 2:32 AM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi Patrice,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t have a solution for you, but I just wanted to point out what I think may be an error with your use of the new UnsafeRawPointer APIs:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; constantBufferForFrame.contents().bindMemory(to: ShadowPass.self, capacity: MemoryLayout&lt;ShadowPass&gt;.size)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I believe the `capacity` should actually be the number of ShadowPass elements in the buffer, not the size of each element. Using `bindMemory(to: ShadowPass.self` already implies that MemoryLayout&lt;ShadowPass&gt;.size is the size of each element.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; More info at https://developer.apple.com/reference/swift/unsaferawpointer/2428875-bindmemory<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I just updated a small Metal project of mine to Swift 3. I ran into some compiler (playground) crashes, but it does seem to work most of the time. Although I only have 1 buffer :-) https://github.com/jtbandes/Metalbrot.playground<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jacob<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Fri, Sep 2, 2016 at 11:00 AM, Patrice Kouame via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi all - <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I’m converting Apple’s Swift Sample &quot;Adopting Metal II: Designing and Implementing a Real-World Metal Renderer” in Xcode 8 beta6 to the latest UnsafeMutablePointer API for untyped memory access.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Changes are necessary in MetalView.swift (Apple hasn’t updated their sample code for the latest beta yet…) <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The Swift Compiler crashes (Segmentation Fault: 11) on the attempt:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         // Grab a pointer to the constant buffer&#39;s data store<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         // Since we are using Swift, it is easier to cast the pointer to the ShadowPass type to fill the constant buffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         // We need to make a copy of these so the block captures the correct data<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; //      let shadowPtr = UnsafeMutablePointer&lt;ShadowPass&gt;(constantBufferForFrame.contents())<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         let shadowPtr = constantBufferForFrame.contents().bindMemory(to: ShadowPass.self, capacity: MemoryLayout&lt;ShadowPass&gt;.size)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         shadowPtr.pointee = shadowPassData[0]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         //More Swift specific stuff - advance pointer and cast to MainPass<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; //      let mainPtr = UnsafeMutablePointer&lt;MainPass&gt;(shadowPtr.advanced(by: 1))<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; //      mainPtr.pointee = mainPassFrameData<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         let mainPtr : UnsafeMutablePointer&lt;MainPass&gt;  = shadowPtr.advanced(by: 1).withMemoryRebound(to: MainPass.self, capacity: MemoryLayout&lt;MainPass&gt;.size) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;             $0.pointee = mainPassFrameData<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         //Advance and cast to ObjectData<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; //      var ptr = UnsafeMutablePointer&lt;ObjectData&gt;(mainPtr.advanced(by: 1))<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         var ptr : UnsafeMutablePointer&lt;ObjectData&gt; = mainPtr.advanced(by: 1).withMemoryRebound(to: ObjectData.self, capacity: MemoryLayout&lt;ObjectData&gt;.size) {_ in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         let shadowOffset = 0<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         let mainPassOffset = MemoryLayout&lt;ShadowPass&gt;.size + shadowOffset<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         let objectDataOffset = MemoryLayout&lt;MainPass&gt;.size + mainPassOffset<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         // Update position of all the objects<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         if multithreadedUpdate {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;             DispatchQueue.concurrentPerform(iterations: objectsToRender) { i in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                 let thisPtr = ptr.advanced(by: i)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                 _ = self.renderables[i].UpdateData(ptr, deltaTime: 1.0/60.0)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;             }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         else {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;             for index in 0..&lt;objectsToRender {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                 ptr = renderables[index].UpdateData(ptr, deltaTime: 1.0/60.0)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;             }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         ptr = ptr.advanced(by: objectsToRender)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         _ = groundPlane!.UpdateData(ptr, deltaTime: 1.0/60.0)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Any help is appreciated.  I have the latest Xcode log handy if necessary.  Here’s a clip of the stack trace.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 0  swift                    0x000000010714a99d PrintStackTraceSignalHandler(void*) + 45<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1  swift                    0x000000010714a3e6 SignalHandler(int) + 470<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2  libsystem_platform.dylib 0x00007fff91461bba _sigtramp + 26<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3  libsystem_platform.dylib 000000000000000000 _sigtramp + 1857676384<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 4  swift                    0x00000001047207b3 (anonymous namespace)::SILGenApply::visitExpr(swift::Expr*) + 51<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 5  swift                    0x0000000104723ace (anonymous namespace)::SILGenApply::visitApplyExpr(swift::ApplyExpr*) + 5182<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 6  swift                    0x0000000104711cc1 prepareApplyExpr(swift::Lowering::SILGenFunction&amp;, swift::Expr*) + 273<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 7  swift                    0x00000001047624e7 swift::ASTVisitor&lt;(anonymous namespace)::RValueEmitter, swift::Lowering::RValue, void, void, void, void, void, swift::Lowering::SGFContext&gt;::visit(swift::Expr*, swift::Lowering::SGFContext) + 103<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 8  swift                    0x0000000104762313 swift::Lowering::SILGenFunction::emitExprInto(swift::Expr*, swift::Lowering::Initialization*) + 195<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 9  swift                    0x000000010474fbc3 swift::Lowering::SILGenFunction::emitPatternBinding(swift::PatternBindingDecl*, unsigned int) + 195<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 10 swift                    0x00000001047077bd swift::ASTVisitor&lt;swift::Lowering::SILGenFunction, void, void, void, void, void, void&gt;::visit(swift::Decl*) + 125<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 11 swift                    0x00000001047c0019 swift::ASTVisitor&lt;(anonymous namespace)::StmtEmitter, void, void, void, void, void, void&gt;::visit(swift::Stmt*) + 4169<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 12 swift                    0x00000001047809ba swift::Lowering::SILGenFunction::emitFunction(swift::FuncDecl*) + 314<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 13 swift                    0x00000001046fd775 swift::Lowering::SILGenModule::emitFunction(swift::FuncDecl*)::$_1::operator()(swift::SILFunction*) const + 1877<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 14 swift                    0x00000001046fc322 swift::Lowering::SILGenModule::emitFunction(swift::FuncDecl*) + 626<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 15 swift                    0x00000001047c7007 (anonymous namespace)::SILGenType::emitType() + 1271<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 16 swift                    0x00000001047c6a9e swift::Lowering::SILGenModule::visitNominalTypeDecl(swift::NominalTypeDecl*) + 30<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 17 swift                    0x0000000104709093 swift::Lowering::SILGenModule::emitSourceFile(swift::SourceFile*, unsigned int) + 1795<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 18 swift                    0x000000010470ad4d swift::SILModule::constructSIL(swift::ModuleDecl*, swift::SILOptions&amp;, swift::FileUnit*, llvm::Optional&lt;unsigned int&gt;, bool, bool) + 1629<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 19 swift                    0x00000001045621bf performCompile(swift::CompilerInstance&amp;, swift::CompilerInvocation&amp;, llvm::ArrayRef&lt;char const*&gt;, int&amp;, swift::FrontendObserver*) + 19487<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 20 swift                    0x000000010455b2c5 swift::performFrontend(llvm::ArrayRef&lt;char const*&gt;, char const*, void*, swift::FrontendObserver*) + 17029<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 21 swift                    0x000000010451888d main + 8685<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 22 libdyld.dylib            0x00007fff91255255 start + 1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Patrice<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-users at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-users at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-users at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt;&gt; swift-users at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt; swift-users at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160904/da03c5bf/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f0c42759e3b302ee8b0665d8b59c1197?s=50"></div><header><strong>UnsafeMutablePointer Swift 3 conversion</strong> from <string>Gerard Iglesias</string> &lt;gerard_iglesias at me.com&gt;<p>September  4, 2016 at 03:00:00am</p></header><div class="content"><p>This is my funny version… I succeeded and I didn’t come back to find an other way…<br></p><p>// Grab a pointer to the constant buffer&#39;s data store<br>// Since we are using Swift, it is easier to cast the pointer to the ShadowPass type to fill the constant buffer<br>// We need to make a copy of these so the block captures the correct data<br>    <br>//let shadowPtr = UnsafeMutablePointer&lt;ShadowPass&gt;(constantBufferForFrame.contents())<br>let shadowPtr = constantBufferForFrame.contents().assumingMemoryBound(to: ShadowPass.self)<br>shadowPtr.pointee = shadowPassData[0]<br>		<br>//More Swift specific stuff - advance pointer and cast to MainPass<br>    <br>//let mainPtr = UnsafeMutablePointer&lt;MainPass&gt;(shadowPtr.advanced(by: 1))<br>let mainPtr = constantBufferForFrame.contents().advanced(by: MemoryLayout&lt;ShadowPass&gt;.size).assumingMemoryBound(to: MainPass.self)<br>mainPtr.pointee = mainPassFrameData<br>		<br>//Advance and cast to ObjectData<br></p><p>//var ptr = UnsafeMutablePointer&lt;ObjectData&gt;(mainPtr.advanced(by: 1))<br>var ptr = constantBufferForFrame.contents().advanced(by: MemoryLayout&lt;ShadowPass&gt;.size + MemoryLayout&lt;MainPass&gt;.size).assumingMemoryBound(to: ObjectData.self)<br></p><p><br>&gt; On 3 Sep 2016, at 19:22, Patrice Kouame &lt;pkouame at me.com&gt; wrote:<br>&gt; <br>&gt; Gerard- <br>&gt; <br>&gt; Excellent!  Looking forward to seeing your fix (hoping you get your book back soon ;-) )<br>&gt; <br>&gt; I think Xcode/Swift gags on the last ptr advance to objectData.  I recently tried another variant using withUnsafeMutablePointer like this:<br>&gt; <br>&gt;         var ptr : UnsafeMutablePointer&lt;ObjectData&gt;  = withUnsafeMutablePointer(to: &amp;mainPtr) {<br>&gt;             $0.withMemoryRebound(to: ObjectData.self, capacity: objectsToRender) {<br>&gt;                 $0.pointee = renderables[0].objectData<br>&gt;             }<br>&gt;         }<br>&gt; <br>&gt; ..but still crashes with no hints.<br>&gt; <br>&gt; My bug report also mentions that the Xcode migration/conversion tool is incomplete.  <br>&gt; It handles the “simpler&quot; UnsafeMutableRawPointer&lt;X&gt; to UnsafeMutablePonter&lt;Y&gt; with bindMemory cases correctly (one still has to mind the capacity value though)<br>&gt; In all fairness, migrating/converting automagically in these cases is always a little bit tricky - the proposed Xcode fixes should always be reviewed by a human...<br>&gt; <br>&gt; Patrice<br>&gt; <br>&gt;&gt; On Sep 3, 2016, at 1:05 PM, Gerard Iglesias via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Ok<br>&gt;&gt; <br>&gt;&gt; For the record I succeeded this transformation phase last week<br>&gt;&gt; <br>&gt;&gt; I remember the tedious stuff to advance pointer from one struct to the other kind of struct... it worked<br>&gt;&gt; <br>&gt;&gt; But I don&#39;t have my MacBook with me, only the phone, the six :)<br>&gt;&gt; <br>&gt;&gt; Gérard <br>&gt;&gt; <br>&gt;&gt; Le 3 sept. 2016 à 18:22, Patrice Kouame &lt;pkouame at me.com &lt;mailto:pkouame at me.com&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt;&gt; Indeed. There is a difference between stride and size, but I interpreted capacity incorrectly for my purposes.  It should indicate the number of &lt;T&gt; elements (not their size - right?) and the snippets below should work.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Still, compiler crashes and Xcode IDE is left in inconsistent state.  So I filed this Apple radar against Developer Tools.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	28150447 - Swift 3 UnsafeMutablePointer conversion crashes the compiler and IDE<br>&gt;&gt;&gt; Should I file a Swift bug too? Would that be helpful?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Regards, Patrice<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Sep 3, 2016, at 11:39 AM, Gerard Iglesias via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hello,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think that it is more secure to use stride in place of size, sometimes it is not the same value.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I use it in my own use of raw bindings <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Regards<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Gérard <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Le 3 sept. 2016 à 10:03, Patrice Kouame via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hi Jacob - <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think you’re right. “capacity” should be the count of type T elements in my buffer.  So in my case that line should read<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;         let shadowPtr = constantBufferForFrame.contents().bindMemory(to: ShadowPass.self, capacity: shadowPassData.count)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The withMemoryRebound calls need similar adjustments. The pointer to MainPass is actually a single structure to it should be safe to do this<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;         let mainPtr : UnsafeMutablePointer&lt;MainPass&gt; = shadowPtr.advanced(by: 1).withMemoryRebound(to: MainPass.self, capacity: 1) {<br>&gt;&gt;&gt;&gt;&gt;             $0.pointee = mainPassFrameData<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Whereas the unsafe pointer to &lt;ObjectData&gt; is actually a buffer of renderable objects, so this should work:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;         var ptr : UnsafeMutablePointer&lt;ObjectData&gt; = mainPtr.advanced(by: 1).withMemoryRebound(to: ObjectData.self, capacity: objectsToRender) {_ in<br>&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There are surely ways to refactor and simplify this, but I’m trying to retain as much of the original sample code approach as possible.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; However, the compiler still segs badly. <br>&gt;&gt;&gt;&gt;&gt; Xcode also borks an internal error often. Only cleaning or restarting the project can clear up that state.<br>&gt;&gt;&gt;&gt;&gt; Compilers (or Playgrounds for that matter) should never crash, and I’m not sure where to file this bug : Swift or Apple radar against Xcode or both? I now Xcode 8 is beta but…it’s been doing this for quite a while now...<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In both our “close to the metal” (no pun intended) cases, it seems like a lot of churning for very little gain. Don’t you think? The easier, but “unsafe” casting afforded previously did the trick with the normal caveats.<br>&gt;&gt;&gt;&gt;&gt; Don’t get me wrong, I love Swift and “get&quot; all the neat type safety features. Guess we can’t have our cake and eat it too, especially when interfacing with “unsafe” C APIs.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Anyway, back to rtfm … maybe some of the Swift Gods can chime in?  ;-) <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I must be doing something stupid...Patrice<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Sep 3, 2016, at 2:32 AM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Hi Patrice,<br>&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t have a solution for you, but I just wanted to point out what I think may be an error with your use of the new UnsafeRawPointer APIs:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; constantBufferForFrame.contents().bindMemory(to: ShadowPass.self, capacity: MemoryLayout&lt;ShadowPass&gt;.size)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I believe the `capacity` should actually be the number of ShadowPass elements in the buffer, not the size of each element. Using `bindMemory(to: ShadowPass.self` already implies that MemoryLayout&lt;ShadowPass&gt;.size is the size of each element.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; More info at https://developer.apple.com/reference/swift/unsaferawpointer/2428875-bindmemory &lt;https://developer.apple.com/reference/swift/unsaferawpointer/2428875-bindmemory&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I just updated a small Metal project of mine to Swift 3. I ran into some compiler (playground) crashes, but it does seem to work most of the time. Although I only have 1 buffer :-) https://github.com/jtbandes/Metalbrot.playground &lt;https://github.com/jtbandes/Metalbrot.playground&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Jacob<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Fri, Sep 2, 2016 at 11:00 AM, Patrice Kouame via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; Hi all - <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I’m converting Apple’s Swift Sample &quot;Adopting Metal II: Designing and Implementing a Real-World Metal Renderer” in Xcode 8 beta6 to the latest UnsafeMutablePointer API for untyped memory access.  <br>&gt;&gt;&gt;&gt;&gt;&gt; Changes are necessary in MetalView.swift (Apple hasn’t updated their sample code for the latest beta yet…) <br>&gt;&gt;&gt;&gt;&gt;&gt; The Swift Compiler crashes (Segmentation Fault: 11) on the attempt:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;         // Grab a pointer to the constant buffer&#39;s data store<br>&gt;&gt;&gt;&gt;&gt;&gt;         // Since we are using Swift, it is easier to cast the pointer to the ShadowPass type to fill the constant buffer<br>&gt;&gt;&gt;&gt;&gt;&gt;         // We need to make a copy of these so the block captures the correct data<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; //      let shadowPtr = UnsafeMutablePointer&lt;ShadowPass&gt;(constantBufferForFrame.contents())<br>&gt;&gt;&gt;&gt;&gt;&gt;         let shadowPtr = constantBufferForFrame.contents().bindMemory(to: ShadowPass.self, capacity: MemoryLayout&lt;ShadowPass&gt;.size)<br>&gt;&gt;&gt;&gt;&gt;&gt;         shadowPtr.pointee = shadowPassData[0]<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;         //More Swift specific stuff - advance pointer and cast to MainPass<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; //      let mainPtr = UnsafeMutablePointer&lt;MainPass&gt;(shadowPtr.advanced(by: 1))<br>&gt;&gt;&gt;&gt;&gt;&gt; //      mainPtr.pointee = mainPassFrameData<br>&gt;&gt;&gt;&gt;&gt;&gt;         let mainPtr : UnsafeMutablePointer&lt;MainPass&gt;  = shadowPtr.advanced(by: 1).withMemoryRebound(to: MainPass.self, capacity: MemoryLayout&lt;MainPass&gt;.size) {<br>&gt;&gt;&gt;&gt;&gt;&gt;             $0.pointee = mainPassFrameData<br>&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;&gt;&gt;         //Advance and cast to ObjectData<br>&gt;&gt;&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;&gt;&gt; //      var ptr = UnsafeMutablePointer&lt;ObjectData&gt;(mainPtr.advanced(by: 1))<br>&gt;&gt;&gt;&gt;&gt;&gt;         var ptr : UnsafeMutablePointer&lt;ObjectData&gt; = mainPtr.advanced(by: 1).withMemoryRebound(to: ObjectData.self, capacity: MemoryLayout&lt;ObjectData&gt;.size) {_ in<br>&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;         let shadowOffset = 0<br>&gt;&gt;&gt;&gt;&gt;&gt;         let mainPassOffset = MemoryLayout&lt;ShadowPass&gt;.size + shadowOffset<br>&gt;&gt;&gt;&gt;&gt;&gt;         let objectDataOffset = MemoryLayout&lt;MainPass&gt;.size + mainPassOffset<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;         // Update position of all the objects<br>&gt;&gt;&gt;&gt;&gt;&gt;         if multithreadedUpdate {<br>&gt;&gt;&gt;&gt;&gt;&gt;             DispatchQueue.concurrentPerform(iterations: objectsToRender) { i in<br>&gt;&gt;&gt;&gt;&gt;&gt;                 let thisPtr = ptr.advanced(by: i)<br>&gt;&gt;&gt;&gt;&gt;&gt;                 _ = self.renderables[i].UpdateData(ptr, deltaTime: 1.0/60.0)<br>&gt;&gt;&gt;&gt;&gt;&gt;             }<br>&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;         else {<br>&gt;&gt;&gt;&gt;&gt;&gt;             for index in 0..&lt;objectsToRender {<br>&gt;&gt;&gt;&gt;&gt;&gt;                 ptr = renderables[index].UpdateData(ptr, deltaTime: 1.0/60.0)<br>&gt;&gt;&gt;&gt;&gt;&gt;             }<br>&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;&gt;&gt;         ptr = ptr.advanced(by: objectsToRender)<br>&gt;&gt;&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;&gt;&gt;         _ = groundPlane!.UpdateData(ptr, deltaTime: 1.0/60.0)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Any help is appreciated.  I have the latest Xcode log handy if necessary.  Here’s a clip of the stack trace.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 0  swift                    0x000000010714a99d PrintStackTraceSignalHandler(void*) + 45<br>&gt;&gt;&gt;&gt;&gt;&gt; 1  swift                    0x000000010714a3e6 SignalHandler(int) + 470<br>&gt;&gt;&gt;&gt;&gt;&gt; 2  libsystem_platform.dylib 0x00007fff91461bba _sigtramp + 26<br>&gt;&gt;&gt;&gt;&gt;&gt; 3  libsystem_platform.dylib 000000000000000000 _sigtramp + 1857676384<br>&gt;&gt;&gt;&gt;&gt;&gt; 4  swift                    0x00000001047207b3 (anonymous namespace)::SILGenApply::visitExpr(swift::Expr*) + 51<br>&gt;&gt;&gt;&gt;&gt;&gt; 5  swift                    0x0000000104723ace (anonymous namespace)::SILGenApply::visitApplyExpr(swift::ApplyExpr*) + 5182<br>&gt;&gt;&gt;&gt;&gt;&gt; 6  swift                    0x0000000104711cc1 prepareApplyExpr(swift::Lowering::SILGenFunction&amp;, swift::Expr*) + 273<br>&gt;&gt;&gt;&gt;&gt;&gt; 7  swift                    0x00000001047624e7 swift::ASTVisitor&lt;(anonymous namespace)::RValueEmitter, swift::Lowering::RValue, void, void, void, void, void, swift::Lowering::SGFContext&gt;::visit(swift::Expr*, swift::Lowering::SGFContext) + 103<br>&gt;&gt;&gt;&gt;&gt;&gt; 8  swift                    0x0000000104762313 swift::Lowering::SILGenFunction::emitExprInto(swift::Expr*, swift::Lowering::Initialization*) + 195<br>&gt;&gt;&gt;&gt;&gt;&gt; 9  swift                    0x000000010474fbc3 swift::Lowering::SILGenFunction::emitPatternBinding(swift::PatternBindingDecl*, unsigned int) + 195<br>&gt;&gt;&gt;&gt;&gt;&gt; 10 swift                    0x00000001047077bd swift::ASTVisitor&lt;swift::Lowering::SILGenFunction, void, void, void, void, void, void&gt;::visit(swift::Decl*) + 125<br>&gt;&gt;&gt;&gt;&gt;&gt; 11 swift                    0x00000001047c0019 swift::ASTVisitor&lt;(anonymous namespace)::StmtEmitter, void, void, void, void, void, void&gt;::visit(swift::Stmt*) + 4169<br>&gt;&gt;&gt;&gt;&gt;&gt; 12 swift                    0x00000001047809ba swift::Lowering::SILGenFunction::emitFunction(swift::FuncDecl*) + 314<br>&gt;&gt;&gt;&gt;&gt;&gt; 13 swift                    0x00000001046fd775 swift::Lowering::SILGenModule::emitFunction(swift::FuncDecl*)::$_1::operator()(swift::SILFunction*) const + 1877<br>&gt;&gt;&gt;&gt;&gt;&gt; 14 swift                    0x00000001046fc322 swift::Lowering::SILGenModule::emitFunction(swift::FuncDecl*) + 626<br>&gt;&gt;&gt;&gt;&gt;&gt; 15 swift                    0x00000001047c7007 (anonymous namespace)::SILGenType::emitType() + 1271<br>&gt;&gt;&gt;&gt;&gt;&gt; 16 swift                    0x00000001047c6a9e swift::Lowering::SILGenModule::visitNominalTypeDecl(swift::NominalTypeDecl*) + 30<br>&gt;&gt;&gt;&gt;&gt;&gt; 17 swift                    0x0000000104709093 swift::Lowering::SILGenModule::emitSourceFile(swift::SourceFile*, unsigned int) + 1795<br>&gt;&gt;&gt;&gt;&gt;&gt; 18 swift                    0x000000010470ad4d swift::SILModule::constructSIL(swift::ModuleDecl*, swift::SILOptions&amp;, swift::FileUnit*, llvm::Optional&lt;unsigned int&gt;, bool, bool) + 1629<br>&gt;&gt;&gt;&gt;&gt;&gt; 19 swift                    0x00000001045621bf performCompile(swift::CompilerInstance&amp;, swift::CompilerInvocation&amp;, llvm::ArrayRef&lt;char const*&gt;, int&amp;, swift::FrontendObserver*) + 19487<br>&gt;&gt;&gt;&gt;&gt;&gt; 20 swift                    0x000000010455b2c5 swift::performFrontend(llvm::ArrayRef&lt;char const*&gt;, char const*, void*, swift::FrontendObserver*) + 17029<br>&gt;&gt;&gt;&gt;&gt;&gt; 21 swift                    0x000000010451888d main + 8685<br>&gt;&gt;&gt;&gt;&gt;&gt; 22 libdyld.dylib            0x00007fff91255255 start + 1<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Patrice<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt;&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160904/87123c28/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8016afa037fa775c19d05b495a24413f?s=50"></div><header><strong>UnsafeMutablePointer Swift 3 conversion</strong> from <string>Patrice Kouame</string> &lt;pkouame at me.com&gt;<p>September  4, 2016 at 01:00:00am</p></header><div class="content"><p>Cool. Another approach. Never thought of using assumingMemoryBound. <br>Need to read up on that.  I wonder how both versions compare from a safety/security/performance stand point.<br></p><p>Behold the spinning cubes… ;-)<br></p><p>P<br></p><p>&gt; <br>&gt; On Sep 3, 2016, at 9:03 PM, Gerard Iglesias via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; This is my funny version… I succeeded and I didn’t come back to find an other way…<br>&gt; <br>&gt; // Grab a pointer to the constant buffer&#39;s data store<br>&gt; // Since we are using Swift, it is easier to cast the pointer to the ShadowPass type to fill the constant buffer<br>&gt; // We need to make a copy of these so the block captures the correct data<br>&gt;     <br>&gt; //let shadowPtr = UnsafeMutablePointer&lt;ShadowPass&gt;(constantBufferForFrame.contents())<br>&gt; let shadowPtr = constantBufferForFrame.contents().assumingMemoryBound(to: ShadowPass.self)<br>&gt; shadowPtr.pointee = shadowPassData[0]<br>&gt; 		<br>&gt; //More Swift specific stuff - advance pointer and cast to MainPass<br>&gt;     <br>&gt; //let mainPtr = UnsafeMutablePointer&lt;MainPass&gt;(shadowPtr.advanced(by: 1))<br>&gt; let mainPtr = constantBufferForFrame.contents().advanced(by: MemoryLayout&lt;ShadowPass&gt;.size).assumingMemoryBound(to: MainPass.self)<br>&gt; mainPtr.pointee = mainPassFrameData<br>&gt; 		<br>&gt; //Advance and cast to ObjectData<br>&gt; <br>&gt; //var ptr = UnsafeMutablePointer&lt;ObjectData&gt;(mainPtr.advanced(by: 1))<br>&gt; var ptr = constantBufferForFrame.contents().advanced(by: MemoryLayout&lt;ShadowPass&gt;.size + MemoryLayout&lt;MainPass&gt;.size).assumingMemoryBound(to: ObjectData.self)<br>&gt; <br>&gt; <br>&gt;&gt; On 3 Sep 2016, at 19:22, Patrice Kouame &lt;pkouame at me.com &lt;mailto:pkouame at me.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Gerard- <br>&gt;&gt; <br>&gt;&gt; Excellent!  Looking forward to seeing your fix (hoping you get your book back soon ;-) )<br>&gt;&gt; <br>&gt;&gt; I think Xcode/Swift gags on the last ptr advance to objectData.  I recently tried another variant using withUnsafeMutablePointer like this:<br>&gt;&gt; <br>&gt;&gt;         var ptr : UnsafeMutablePointer&lt;ObjectData&gt;  = withUnsafeMutablePointer(to: &amp;mainPtr) {<br>&gt;&gt;             $0.withMemoryRebound(to: ObjectData.self, capacity: objectsToRender) {<br>&gt;&gt;                 $0.pointee = renderables[0].objectData<br>&gt;&gt;             }<br>&gt;&gt;         }<br>&gt;&gt; <br>&gt;&gt; ..but still crashes with no hints.<br>&gt;&gt; <br>&gt;&gt; My bug report also mentions that the Xcode migration/conversion tool is incomplete.  <br>&gt;&gt; It handles the “simpler&quot; UnsafeMutableRawPointer&lt;X&gt; to UnsafeMutablePonter&lt;Y&gt; with bindMemory cases correctly (one still has to mind the capacity value though)<br>&gt;&gt; In all fairness, migrating/converting automagically in these cases is always a little bit tricky - the proposed Xcode fixes should always be reviewed by a human...<br>&gt;&gt; <br>&gt;&gt; Patrice<br>&gt;&gt; <br>&gt;&gt;&gt; On Sep 3, 2016, at 1:05 PM, Gerard Iglesias via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Ok<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For the record I succeeded this transformation phase last week<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I remember the tedious stuff to advance pointer from one struct to the other kind of struct... it worked<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But I don&#39;t have my MacBook with me, only the phone, the six :)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Gérard <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Le 3 sept. 2016 à 18:22, Patrice Kouame &lt;pkouame at me.com &lt;mailto:pkouame at me.com&gt;&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Indeed. There is a difference between stride and size, but I interpreted capacity incorrectly for my purposes.  It should indicate the number of &lt;T&gt; elements (not their size - right?) and the snippets below should work.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Still, compiler crashes and Xcode IDE is left in inconsistent state.  So I filed this Apple radar against Developer Tools.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	28150447 - Swift 3 UnsafeMutablePointer conversion crashes the compiler and IDE<br>&gt;&gt;&gt;&gt; Should I file a Swift bug too? Would that be helpful?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Regards, Patrice<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Sep 3, 2016, at 11:39 AM, Gerard Iglesias via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hello,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think that it is more secure to use stride in place of size, sometimes it is not the same value.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I use it in my own use of raw bindings <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Regards<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Gérard <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Le 3 sept. 2016 à 10:03, Patrice Kouame via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Hi Jacob - <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I think you’re right. “capacity” should be the count of type T elements in my buffer.  So in my case that line should read<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;         let shadowPtr = constantBufferForFrame.contents().bindMemory(to: ShadowPass.self, capacity: shadowPassData.count)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The withMemoryRebound calls need similar adjustments. The pointer to MainPass is actually a single structure to it should be safe to do this<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;         let mainPtr : UnsafeMutablePointer&lt;MainPass&gt; = shadowPtr.advanced(by: 1).withMemoryRebound(to: MainPass.self, capacity: 1) {<br>&gt;&gt;&gt;&gt;&gt;&gt;             $0.pointee = mainPassFrameData<br>&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Whereas the unsafe pointer to &lt;ObjectData&gt; is actually a buffer of renderable objects, so this should work:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;         var ptr : UnsafeMutablePointer&lt;ObjectData&gt; = mainPtr.advanced(by: 1).withMemoryRebound(to: ObjectData.self, capacity: objectsToRender) {_ in<br>&gt;&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; There are surely ways to refactor and simplify this, but I’m trying to retain as much of the original sample code approach as possible.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; However, the compiler still segs badly. <br>&gt;&gt;&gt;&gt;&gt;&gt; Xcode also borks an internal error often. Only cleaning or restarting the project can clear up that state.<br>&gt;&gt;&gt;&gt;&gt;&gt; Compilers (or Playgrounds for that matter) should never crash, and I’m not sure where to file this bug : Swift or Apple radar against Xcode or both? I now Xcode 8 is beta but…it’s been doing this for quite a while now...<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In both our “close to the metal” (no pun intended) cases, it seems like a lot of churning for very little gain. Don’t you think? The easier, but “unsafe” casting afforded previously did the trick with the normal caveats.<br>&gt;&gt;&gt;&gt;&gt;&gt; Don’t get me wrong, I love Swift and “get&quot; all the neat type safety features. Guess we can’t have our cake and eat it too, especially when interfacing with “unsafe” C APIs.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Anyway, back to rtfm … maybe some of the Swift Gods can chime in?  ;-) <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I must be doing something stupid...Patrice<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Sep 3, 2016, at 2:32 AM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi Patrice,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t have a solution for you, but I just wanted to point out what I think may be an error with your use of the new UnsafeRawPointer APIs:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; constantBufferForFrame.contents().bindMemory(to: ShadowPass.self, capacity: MemoryLayout&lt;ShadowPass&gt;.size)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I believe the `capacity` should actually be the number of ShadowPass elements in the buffer, not the size of each element. Using `bindMemory(to: ShadowPass.self` already implies that MemoryLayout&lt;ShadowPass&gt;.size is the size of each element.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; More info at https://developer.apple.com/reference/swift/unsaferawpointer/2428875-bindmemory &lt;https://developer.apple.com/reference/swift/unsaferawpointer/2428875-bindmemory&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I just updated a small Metal project of mine to Swift 3. I ran into some compiler (playground) crashes, but it does seem to work most of the time. Although I only have 1 buffer :-) https://github.com/jtbandes/Metalbrot.playground &lt;https://github.com/jtbandes/Metalbrot.playground&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jacob<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Fri, Sep 2, 2016 at 11:00 AM, Patrice Kouame via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi all - <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I’m converting Apple’s Swift Sample &quot;Adopting Metal II: Designing and Implementing a Real-World Metal Renderer” in Xcode 8 beta6 to the latest UnsafeMutablePointer API for untyped memory access.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Changes are necessary in MetalView.swift (Apple hasn’t updated their sample code for the latest beta yet…) <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The Swift Compiler crashes (Segmentation Fault: 11) on the attempt:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         // Grab a pointer to the constant buffer&#39;s data store<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         // Since we are using Swift, it is easier to cast the pointer to the ShadowPass type to fill the constant buffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         // We need to make a copy of these so the block captures the correct data<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; //      let shadowPtr = UnsafeMutablePointer&lt;ShadowPass&gt;(constantBufferForFrame.contents())<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         let shadowPtr = constantBufferForFrame.contents().bindMemory(to: ShadowPass.self, capacity: MemoryLayout&lt;ShadowPass&gt;.size)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         shadowPtr.pointee = shadowPassData[0]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         //More Swift specific stuff - advance pointer and cast to MainPass<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; //      let mainPtr = UnsafeMutablePointer&lt;MainPass&gt;(shadowPtr.advanced(by: 1))<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; //      mainPtr.pointee = mainPassFrameData<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         let mainPtr : UnsafeMutablePointer&lt;MainPass&gt;  = shadowPtr.advanced(by: 1).withMemoryRebound(to: MainPass.self, capacity: MemoryLayout&lt;MainPass&gt;.size) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;             $0.pointee = mainPassFrameData<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         //Advance and cast to ObjectData<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; //      var ptr = UnsafeMutablePointer&lt;ObjectData&gt;(mainPtr.advanced(by: 1))<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         var ptr : UnsafeMutablePointer&lt;ObjectData&gt; = mainPtr.advanced(by: 1).withMemoryRebound(to: ObjectData.self, capacity: MemoryLayout&lt;ObjectData&gt;.size) {_ in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         let shadowOffset = 0<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         let mainPassOffset = MemoryLayout&lt;ShadowPass&gt;.size + shadowOffset<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         let objectDataOffset = MemoryLayout&lt;MainPass&gt;.size + mainPassOffset<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         // Update position of all the objects<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         if multithreadedUpdate {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;             DispatchQueue.concurrentPerform(iterations: objectsToRender) { i in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;                 let thisPtr = ptr.advanced(by: i)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;                 _ = self.renderables[i].UpdateData(ptr, deltaTime: 1.0/60.0)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;             }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         else {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;             for index in 0..&lt;objectsToRender {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;                 ptr = renderables[index].UpdateData(ptr, deltaTime: 1.0/60.0)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;             }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         ptr = ptr.advanced(by: objectsToRender)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         _ = groundPlane!.UpdateData(ptr, deltaTime: 1.0/60.0)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Any help is appreciated.  I have the latest Xcode log handy if necessary.  Here’s a clip of the stack trace.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 0  swift                    0x000000010714a99d PrintStackTraceSignalHandler(void*) + 45<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1  swift                    0x000000010714a3e6 SignalHandler(int) + 470<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2  libsystem_platform.dylib 0x00007fff91461bba _sigtramp + 26<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3  libsystem_platform.dylib 000000000000000000 _sigtramp + 1857676384<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 4  swift                    0x00000001047207b3 (anonymous namespace)::SILGenApply::visitExpr(swift::Expr*) + 51<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 5  swift                    0x0000000104723ace (anonymous namespace)::SILGenApply::visitApplyExpr(swift::ApplyExpr*) + 5182<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 6  swift                    0x0000000104711cc1 prepareApplyExpr(swift::Lowering::SILGenFunction&amp;, swift::Expr*) + 273<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 7  swift                    0x00000001047624e7 swift::ASTVisitor&lt;(anonymous namespace)::RValueEmitter, swift::Lowering::RValue, void, void, void, void, void, swift::Lowering::SGFContext&gt;::visit(swift::Expr*, swift::Lowering::SGFContext) + 103<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 8  swift                    0x0000000104762313 swift::Lowering::SILGenFunction::emitExprInto(swift::Expr*, swift::Lowering::Initialization*) + 195<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 9  swift                    0x000000010474fbc3 swift::Lowering::SILGenFunction::emitPatternBinding(swift::PatternBindingDecl*, unsigned int) + 195<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 10 swift                    0x00000001047077bd swift::ASTVisitor&lt;swift::Lowering::SILGenFunction, void, void, void, void, void, void&gt;::visit(swift::Decl*) + 125<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 11 swift                    0x00000001047c0019 swift::ASTVisitor&lt;(anonymous namespace)::StmtEmitter, void, void, void, void, void, void&gt;::visit(swift::Stmt*) + 4169<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 12 swift                    0x00000001047809ba swift::Lowering::SILGenFunction::emitFunction(swift::FuncDecl*) + 314<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 13 swift                    0x00000001046fd775 swift::Lowering::SILGenModule::emitFunction(swift::FuncDecl*)::$_1::operator()(swift::SILFunction*) const + 1877<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 14 swift                    0x00000001046fc322 swift::Lowering::SILGenModule::emitFunction(swift::FuncDecl*) + 626<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 15 swift                    0x00000001047c7007 (anonymous namespace)::SILGenType::emitType() + 1271<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 16 swift                    0x00000001047c6a9e swift::Lowering::SILGenModule::visitNominalTypeDecl(swift::NominalTypeDecl*) + 30<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 17 swift                    0x0000000104709093 swift::Lowering::SILGenModule::emitSourceFile(swift::SourceFile*, unsigned int) + 1795<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 18 swift                    0x000000010470ad4d swift::SILModule::constructSIL(swift::ModuleDecl*, swift::SILOptions&amp;, swift::FileUnit*, llvm::Optional&lt;unsigned int&gt;, bool, bool) + 1629<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 19 swift                    0x00000001045621bf performCompile(swift::CompilerInstance&amp;, swift::CompilerInvocation&amp;, llvm::ArrayRef&lt;char const*&gt;, int&amp;, swift::FrontendObserver*) + 19487<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 20 swift                    0x000000010455b2c5 swift::performFrontend(llvm::ArrayRef&lt;char const*&gt;, char const*, void*, swift::FrontendObserver*) + 17029<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 21 swift                    0x000000010451888d main + 8685<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 22 libdyld.dylib            0x00007fff91255255 start + 1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Patrice<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160904/19dcbcea/attachment-0001.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>UnsafeMutablePointer Swift 3 conversion</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>September  7, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Sep 3, 2016, at 6:03 PM, Gerard Iglesias via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; This is my funny version… I succeeded and I didn’t come back to find an other way…<br>&gt; <br>&gt; // Grab a pointer to the constant buffer&#39;s data store<br>&gt; // Since we are using Swift, it is easier to cast the pointer to the ShadowPass type to fill the constant buffer<br>&gt; // We need to make a copy of these so the block captures the correct data<br>&gt;     <br>&gt; //let shadowPtr = UnsafeMutablePointer&lt;ShadowPass&gt;(constantBufferForFrame.contents())<br>&gt; let shadowPtr = constantBufferForFrame.contents().assumingMemoryBound(to: ShadowPass.self)<br>&gt; shadowPtr.pointee = shadowPassData[0]<br>&gt; 		<br>&gt; //More Swift specific stuff - advance pointer and cast to MainPass<br>&gt;     <br>&gt; //let mainPtr = UnsafeMutablePointer&lt;MainPass&gt;(shadowPtr.advanced(by: 1))<br>&gt; let mainPtr = constantBufferForFrame.contents().advanced(by: MemoryLayout&lt;ShadowPass&gt;.size).assumingMemoryBound(to: MainPass.self)<br>&gt; mainPtr.pointee = mainPassFrameData<br>&gt; 		<br>&gt; //Advance and cast to ObjectData<br>&gt; <br>&gt; //var ptr = UnsafeMutablePointer&lt;ObjectData&gt;(mainPtr.advanced(by: 1))<br>&gt; var ptr = constantBufferForFrame.contents().advanced(by: MemoryLayout&lt;ShadowPass&gt;.size + MemoryLayout&lt;MainPass&gt;.size).assumingMemoryBound(to: ObjectData.self)<br></p><p>Gerard,<br></p><p>I like your code. A couple of things to consider:<br></p><p>1. If the memory has never been bound to a type (i.e. it&#39;s straight from MTLBuffer.newBuffer), then rather than “assuming” memory is bound to these types, you should just bind it here (substitute all your assumingMemoryBound(to: _) with bindMemory(to: _, capacity: 1). Think of it as two-phase initialization of the memory. First declare the memory&#39;s type (e.g. some structure that holds a bunch of floats), then write individual float values into the memory.<br></p><p>2. If you want the compiler to compute byte offsets for you like the original code, then can be done as follows:<br></p><p>  let mainPtr = UnsafeMutableRawPointer(shadowPtr + 1).bindMemory(<br>    to: MainPass.self, capacity: 1)<br>  mainPtr.pointee = mainPassFrameData<br>  ...<br></p><p>However, your approach of computing byte offsets is more explicit.<br></p><p>My migration guide landed on swift.org today! I think it will be a big help.<br>https://swift.org/migration-guide/se-0107-migrate.html<br></p><p>-Andy<br></p><p>&gt;&gt; On 3 Sep 2016, at 19:22, Patrice Kouame &lt;pkouame at me.com &lt;mailto:pkouame at me.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Gerard- <br>&gt;&gt; <br>&gt;&gt; Excellent!  Looking forward to seeing your fix (hoping you get your book back soon ;-) )<br>&gt;&gt; <br>&gt;&gt; I think Xcode/Swift gags on the last ptr advance to objectData.  I recently tried another variant using withUnsafeMutablePointer like this:<br>&gt;&gt; <br>&gt;&gt;         var ptr : UnsafeMutablePointer&lt;ObjectData&gt;  = withUnsafeMutablePointer(to: &amp;mainPtr) {<br>&gt;&gt;             $0.withMemoryRebound(to: ObjectData.self, capacity: objectsToRender) {<br>&gt;&gt;                 $0.pointee = renderables[0].objectData<br>&gt;&gt;             }<br>&gt;&gt;         }<br>&gt;&gt; <br>&gt;&gt; ..but still crashes with no hints.<br>&gt;&gt; <br>&gt;&gt; My bug report also mentions that the Xcode migration/conversion tool is incomplete.  <br>&gt;&gt; It handles the “simpler&quot; UnsafeMutableRawPointer&lt;X&gt; to UnsafeMutablePonter&lt;Y&gt; with bindMemory cases correctly (one still has to mind the capacity value though)<br>&gt;&gt; In all fairness, migrating/converting automagically in these cases is always a little bit tricky - the proposed Xcode fixes should always be reviewed by a human...<br>&gt;&gt; <br>&gt;&gt; Patrice<br>&gt;&gt; <br>&gt;&gt;&gt; On Sep 3, 2016, at 1:05 PM, Gerard Iglesias via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Ok<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For the record I succeeded this transformation phase last week<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I remember the tedious stuff to advance pointer from one struct to the other kind of struct... it worked<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But I don&#39;t have my MacBook with me, only the phone, the six :)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Gérard <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Le 3 sept. 2016 à 18:22, Patrice Kouame &lt;pkouame at me.com &lt;mailto:pkouame at me.com&gt;&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Indeed. There is a difference between stride and size, but I interpreted capacity incorrectly for my purposes.  It should indicate the number of &lt;T&gt; elements (not their size - right?) and the snippets below should work.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Still, compiler crashes and Xcode IDE is left in inconsistent state.  So I filed this Apple radar against Developer Tools.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	28150447 - Swift 3 UnsafeMutablePointer conversion crashes the compiler and IDE<br>&gt;&gt;&gt;&gt; Should I file a Swift bug too? Would that be helpful?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Regards, Patrice<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Sep 3, 2016, at 11:39 AM, Gerard Iglesias via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hello,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think that it is more secure to use stride in place of size, sometimes it is not the same value.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I use it in my own use of raw bindings <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Regards<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Gérard <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Le 3 sept. 2016 à 10:03, Patrice Kouame via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Hi Jacob - <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I think you’re right. “capacity” should be the count of type T elements in my buffer.  So in my case that line should read<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;         let shadowPtr = constantBufferForFrame.contents().bindMemory(to: ShadowPass.self, capacity: shadowPassData.count)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The withMemoryRebound calls need similar adjustments. The pointer to MainPass is actually a single structure to it should be safe to do this<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;         let mainPtr : UnsafeMutablePointer&lt;MainPass&gt; = shadowPtr.advanced(by: 1).withMemoryRebound(to: MainPass.self, capacity: 1) {<br>&gt;&gt;&gt;&gt;&gt;&gt;             $0.pointee = mainPassFrameData<br>&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Whereas the unsafe pointer to &lt;ObjectData&gt; is actually a buffer of renderable objects, so this should work:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;         var ptr : UnsafeMutablePointer&lt;ObjectData&gt; = mainPtr.advanced(by: 1).withMemoryRebound(to: ObjectData.self, capacity: objectsToRender) {_ in<br>&gt;&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; There are surely ways to refactor and simplify this, but I’m trying to retain as much of the original sample code approach as possible.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; However, the compiler still segs badly. <br>&gt;&gt;&gt;&gt;&gt;&gt; Xcode also borks an internal error often. Only cleaning or restarting the project can clear up that state.<br>&gt;&gt;&gt;&gt;&gt;&gt; Compilers (or Playgrounds for that matter) should never crash, and I’m not sure where to file this bug : Swift or Apple radar against Xcode or both? I now Xcode 8 is beta but…it’s been doing this for quite a while now...<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In both our “close to the metal” (no pun intended) cases, it seems like a lot of churning for very little gain. Don’t you think? The easier, but “unsafe” casting afforded previously did the trick with the normal caveats.<br>&gt;&gt;&gt;&gt;&gt;&gt; Don’t get me wrong, I love Swift and “get&quot; all the neat type safety features. Guess we can’t have our cake and eat it too, especially when interfacing with “unsafe” C APIs.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Anyway, back to rtfm … maybe some of the Swift Gods can chime in?  ;-) <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I must be doing something stupid...Patrice<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Sep 3, 2016, at 2:32 AM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi Patrice,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t have a solution for you, but I just wanted to point out what I think may be an error with your use of the new UnsafeRawPointer APIs:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; constantBufferForFrame.contents().bindMemory(to: ShadowPass.self, capacity: MemoryLayout&lt;ShadowPass&gt;.size)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I believe the `capacity` should actually be the number of ShadowPass elements in the buffer, not the size of each element. Using `bindMemory(to: ShadowPass.self` already implies that MemoryLayout&lt;ShadowPass&gt;.size is the size of each element.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; More info at https://developer.apple.com/reference/swift/unsaferawpointer/2428875-bindmemory &lt;https://developer.apple.com/reference/swift/unsaferawpointer/2428875-bindmemory&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I just updated a small Metal project of mine to Swift 3. I ran into some compiler (playground) crashes, but it does seem to work most of the time. Although I only have 1 buffer :-) https://github.com/jtbandes/Metalbrot.playground &lt;https://github.com/jtbandes/Metalbrot.playground&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jacob<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Fri, Sep 2, 2016 at 11:00 AM, Patrice Kouame via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi all - <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I’m converting Apple’s Swift Sample &quot;Adopting Metal II: Designing and Implementing a Real-World Metal Renderer” in Xcode 8 beta6 to the latest UnsafeMutablePointer API for untyped memory access.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Changes are necessary in MetalView.swift (Apple hasn’t updated their sample code for the latest beta yet…) <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The Swift Compiler crashes (Segmentation Fault: 11) on the attempt:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         // Grab a pointer to the constant buffer&#39;s data store<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         // Since we are using Swift, it is easier to cast the pointer to the ShadowPass type to fill the constant buffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         // We need to make a copy of these so the block captures the correct data<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; //      let shadowPtr = UnsafeMutablePointer&lt;ShadowPass&gt;(constantBufferForFrame.contents())<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         let shadowPtr = constantBufferForFrame.contents().bindMemory(to: ShadowPass.self, capacity: MemoryLayout&lt;ShadowPass&gt;.size)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         shadowPtr.pointee = shadowPassData[0]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         //More Swift specific stuff - advance pointer and cast to MainPass<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; //      let mainPtr = UnsafeMutablePointer&lt;MainPass&gt;(shadowPtr.advanced(by: 1))<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; //      mainPtr.pointee = mainPassFrameData<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         let mainPtr : UnsafeMutablePointer&lt;MainPass&gt;  = shadowPtr.advanced(by: 1).withMemoryRebound(to: MainPass.self, capacity: MemoryLayout&lt;MainPass&gt;.size) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;             $0.pointee = mainPassFrameData<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         //Advance and cast to ObjectData<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; //      var ptr = UnsafeMutablePointer&lt;ObjectData&gt;(mainPtr.advanced(by: 1))<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         var ptr : UnsafeMutablePointer&lt;ObjectData&gt; = mainPtr.advanced(by: 1).withMemoryRebound(to: ObjectData.self, capacity: MemoryLayout&lt;ObjectData&gt;.size) {_ in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         let shadowOffset = 0<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         let mainPassOffset = MemoryLayout&lt;ShadowPass&gt;.size + shadowOffset<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         let objectDataOffset = MemoryLayout&lt;MainPass&gt;.size + mainPassOffset<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         // Update position of all the objects<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         if multithreadedUpdate {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;             DispatchQueue.concurrentPerform(iterations: objectsToRender) { i in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;                 let thisPtr = ptr.advanced(by: i)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;                 _ = self.renderables[i].UpdateData(ptr, deltaTime: 1.0/60.0)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;             }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         else {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;             for index in 0..&lt;objectsToRender {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;                 ptr = renderables[index].UpdateData(ptr, deltaTime: 1.0/60.0)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;             }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         ptr = ptr.advanced(by: objectsToRender)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         _ = groundPlane!.UpdateData(ptr, deltaTime: 1.0/60.0)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Any help is appreciated.  I have the latest Xcode log handy if necessary.  Here’s a clip of the stack trace.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 0  swift                    0x000000010714a99d PrintStackTraceSignalHandler(void*) + 45<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1  swift                    0x000000010714a3e6 SignalHandler(int) + 470<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2  libsystem_platform.dylib 0x00007fff91461bba _sigtramp + 26<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3  libsystem_platform.dylib 000000000000000000 _sigtramp + 1857676384<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 4  swift                    0x00000001047207b3 (anonymous namespace)::SILGenApply::visitExpr(swift::Expr*) + 51<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 5  swift                    0x0000000104723ace (anonymous namespace)::SILGenApply::visitApplyExpr(swift::ApplyExpr*) + 5182<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 6  swift                    0x0000000104711cc1 prepareApplyExpr(swift::Lowering::SILGenFunction&amp;, swift::Expr*) + 273<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 7  swift                    0x00000001047624e7 swift::ASTVisitor&lt;(anonymous namespace)::RValueEmitter, swift::Lowering::RValue, void, void, void, void, void, swift::Lowering::SGFContext&gt;::visit(swift::Expr*, swift::Lowering::SGFContext) + 103<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 8  swift                    0x0000000104762313 swift::Lowering::SILGenFunction::emitExprInto(swift::Expr*, swift::Lowering::Initialization*) + 195<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 9  swift                    0x000000010474fbc3 swift::Lowering::SILGenFunction::emitPatternBinding(swift::PatternBindingDecl*, unsigned int) + 195<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 10 swift                    0x00000001047077bd swift::ASTVisitor&lt;swift::Lowering::SILGenFunction, void, void, void, void, void, void&gt;::visit(swift::Decl*) + 125<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 11 swift                    0x00000001047c0019 swift::ASTVisitor&lt;(anonymous namespace)::StmtEmitter, void, void, void, void, void, void&gt;::visit(swift::Stmt*) + 4169<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 12 swift                    0x00000001047809ba swift::Lowering::SILGenFunction::emitFunction(swift::FuncDecl*) + 314<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 13 swift                    0x00000001046fd775 swift::Lowering::SILGenModule::emitFunction(swift::FuncDecl*)::$_1::operator()(swift::SILFunction*) const + 1877<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 14 swift                    0x00000001046fc322 swift::Lowering::SILGenModule::emitFunction(swift::FuncDecl*) + 626<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 15 swift                    0x00000001047c7007 (anonymous namespace)::SILGenType::emitType() + 1271<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 16 swift                    0x00000001047c6a9e swift::Lowering::SILGenModule::visitNominalTypeDecl(swift::NominalTypeDecl*) + 30<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 17 swift                    0x0000000104709093 swift::Lowering::SILGenModule::emitSourceFile(swift::SourceFile*, unsigned int) + 1795<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 18 swift                    0x000000010470ad4d swift::SILModule::constructSIL(swift::ModuleDecl*, swift::SILOptions&amp;, swift::FileUnit*, llvm::Optional&lt;unsigned int&gt;, bool, bool) + 1629<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 19 swift                    0x00000001045621bf performCompile(swift::CompilerInstance&amp;, swift::CompilerInvocation&amp;, llvm::ArrayRef&lt;char const*&gt;, int&amp;, swift::FrontendObserver*) + 19487<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 20 swift                    0x000000010455b2c5 swift::performFrontend(llvm::ArrayRef&lt;char const*&gt;, char const*, void*, swift::FrontendObserver*) + 17029<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 21 swift                    0x000000010451888d main + 8685<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 22 libdyld.dylib            0x00007fff91255255 start + 1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Patrice<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160907/d0973d8c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>UnsafeMutablePointer Swift 3 conversion</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>September  7, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt;<br>&gt; My migration guide landed on swift.org today! I think it will be a big<br>&gt; help.<br>&gt; https://swift.org/migration-guide/se-0107-migrate.html<br>&gt;<br>&gt; -Andy<br>&gt;<br></p><p>Thanks Andy, this is great!<br></p><p>I hope that over time, even more accessible material is added for<br>newcomers. I still feel I would have a hard time answering the question of<br>what bindMemory &quot;does&quot;, if someone asked me. My impression is that all<br>these methods are really just hints to the compiler about which kinds of<br>transformations/optimizations are allowed and which are not — making it<br>aware of aliasing.<br></p><p>The example below (from your proposal) is a good, practical showcase of<br>what might go wrong with aliasing. But what *should* this look like when<br>using the new API / how do the changes help prevent these problems? The<br>example shows only the &quot;old version&quot;.<br></p><p>// --- old version ---func testUndefinedExecution() {<br>  let pA = UnsafeMutablePointer&lt;A&gt;.allocate(capacity: 1)<br>  pA[0] = A(value:42)<br>  if pA[0].value != 42 {<br>    // Code path should never execute...<br>    releaseDemons()<br>  }<br>  // This compiler may inline this, and hoist the store above the<br>  // previous check.<br>  unforeseenCode(pA)<br>}<br>func releaseDemons() {<br>  // Something that should never be executed...<br>}<br>func assignB(_ pB: UnsafeMutablePointer&lt;B&gt;) {<br>  pB[0] = B(value:13)<br>}<br>func unforeseenCode(_ pA: UnsafeMutablePointer&lt;A&gt;) {<br>  // At some arbitrary point in the future, the same memory is<br>  // innocuously assigned to B.<br>  assignB(UnsafeMutablePointer(pA))<br>}<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160907/4f3310d8/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f0c42759e3b302ee8b0665d8b59c1197?s=50"></div><header><strong>UnsafeMutablePointer Swift 3 conversion</strong> from <string>Gerard Iglesias</string> &lt;gerard_iglesias at me.com&gt;<p>September  8, 2016 at 01:00:00pm</p></header><div class="content"><p>Andrew,<br></p><p>Thank you for the compliment ;)<br></p><p>And thank you for the 2 advices<br></p><p>And the question about use of size or stride ? I understand that the underlaying float data are aligned in this specific case, but I wonder in fact if the shader compiler align memory the same way the swift compiler do, I suppose yes unless it would be a nightmare, but murphy’s principle says me … take care ;)<br></p><p>Thanks in advance<br></p><p>Gerard<br></p><p>&gt; On 8 Sep 2016, at 07:21, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Sep 3, 2016, at 6:03 PM, Gerard Iglesias via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This is my funny version… I succeeded and I didn’t come back to find an other way…<br>&gt;&gt; <br>&gt;&gt; // Grab a pointer to the constant buffer&#39;s data store<br>&gt;&gt; // Since we are using Swift, it is easier to cast the pointer to the ShadowPass type to fill the constant buffer<br>&gt;&gt; // We need to make a copy of these so the block captures the correct data<br>&gt;&gt;     <br>&gt;&gt; //let shadowPtr = UnsafeMutablePointer&lt;ShadowPass&gt;(constantBufferForFrame.contents())<br>&gt;&gt; let shadowPtr = constantBufferForFrame.contents().assumingMemoryBound(to: ShadowPass.self)<br>&gt;&gt; shadowPtr.pointee = shadowPassData[0]<br>&gt;&gt; 		<br>&gt;&gt; //More Swift specific stuff - advance pointer and cast to MainPass<br>&gt;&gt;     <br>&gt;&gt; //let mainPtr = UnsafeMutablePointer&lt;MainPass&gt;(shadowPtr.advanced(by: 1))<br>&gt;&gt; let mainPtr = constantBufferForFrame.contents().advanced(by: MemoryLayout&lt;ShadowPass&gt;.size).assumingMemoryBound(to: MainPass.self)<br>&gt;&gt; mainPtr.pointee = mainPassFrameData<br>&gt;&gt; 		<br>&gt;&gt; //Advance and cast to ObjectData<br>&gt;&gt; <br>&gt;&gt; //var ptr = UnsafeMutablePointer&lt;ObjectData&gt;(mainPtr.advanced(by: 1))<br>&gt;&gt; var ptr = constantBufferForFrame.contents().advanced(by: MemoryLayout&lt;ShadowPass&gt;.size + MemoryLayout&lt;MainPass&gt;.size).assumingMemoryBound(to: ObjectData.self)<br>&gt; <br>&gt; Gerard,<br>&gt; <br>&gt; I like your code. A couple of things to consider:<br>&gt; <br>&gt; 1. If the memory has never been bound to a type (i.e. it&#39;s straight from MTLBuffer.newBuffer), then rather than “assuming” memory is bound to these types, you should just bind it here (substitute all your assumingMemoryBound(to: _) with bindMemory(to: _, capacity: 1). Think of it as two-phase initialization of the memory. First declare the memory&#39;s type (e.g. some structure that holds a bunch of floats), then write individual float values into the memory.<br>&gt; <br>&gt; 2. If you want the compiler to compute byte offsets for you like the original code, then can be done as follows:<br>&gt; <br>&gt;   let mainPtr = UnsafeMutableRawPointer(shadowPtr + 1).bindMemory(<br>&gt;     to: MainPass.self, capacity: 1)<br>&gt;   mainPtr.pointee = mainPassFrameData<br>&gt;   ...<br>&gt; <br>&gt; However, your approach of computing byte offsets is more explicit.<br>&gt; <br>&gt; My migration guide landed on swift.org &lt;http://swift.org/&gt; today! I think it will be a big help.<br>&gt; https://swift.org/migration-guide/se-0107-migrate.html &lt;https://swift.org/migration-guide/se-0107-migrate.html&gt;<br>&gt; <br>&gt; -Andy<br>&gt; <br>&gt;&gt;&gt; On 3 Sep 2016, at 19:22, Patrice Kouame &lt;pkouame at me.com &lt;mailto:pkouame at me.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Gerard- <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Excellent!  Looking forward to seeing your fix (hoping you get your book back soon ;-) )<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think Xcode/Swift gags on the last ptr advance to objectData.  I recently tried another variant using withUnsafeMutablePointer like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         var ptr : UnsafeMutablePointer&lt;ObjectData&gt;  = withUnsafeMutablePointer(to: &amp;mainPtr) {<br>&gt;&gt;&gt;             $0.withMemoryRebound(to: ObjectData.self, capacity: objectsToRender) {<br>&gt;&gt;&gt;                 $0.pointee = renderables[0].objectData<br>&gt;&gt;&gt;             }<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ..but still crashes with no hints.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My bug report also mentions that the Xcode migration/conversion tool is incomplete.  <br>&gt;&gt;&gt; It handles the “simpler&quot; UnsafeMutableRawPointer&lt;X&gt; to UnsafeMutablePonter&lt;Y&gt; with bindMemory cases correctly (one still has to mind the capacity value though)<br>&gt;&gt;&gt; In all fairness, migrating/converting automagically in these cases is always a little bit tricky - the proposed Xcode fixes should always be reviewed by a human...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Patrice<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Sep 3, 2016, at 1:05 PM, Gerard Iglesias via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Ok<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For the record I succeeded this transformation phase last week<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I remember the tedious stuff to advance pointer from one struct to the other kind of struct... it worked<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But I don&#39;t have my MacBook with me, only the phone, the six :)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Gérard <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Le 3 sept. 2016 à 18:22, Patrice Kouame &lt;pkouame at me.com &lt;mailto:pkouame at me.com&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Indeed. There is a difference between stride and size, but I interpreted capacity incorrectly for my purposes.  It should indicate the number of &lt;T&gt; elements (not their size - right?) and the snippets below should work.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Still, compiler crashes and Xcode IDE is left in inconsistent state.  So I filed this Apple radar against Developer Tools.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	28150447 - Swift 3 UnsafeMutablePointer conversion crashes the compiler and IDE<br>&gt;&gt;&gt;&gt;&gt; Should I file a Swift bug too? Would that be helpful?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Regards, Patrice<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Sep 3, 2016, at 11:39 AM, Gerard Iglesias via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Hello,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I think that it is more secure to use stride in place of size, sometimes it is not the same value.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I use it in my own use of raw bindings <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Regards<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Gérard <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Le 3 sept. 2016 à 10:03, Patrice Kouame via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi Jacob - <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think you’re right. “capacity” should be the count of type T elements in my buffer.  So in my case that line should read<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         let shadowPtr = constantBufferForFrame.contents().bindMemory(to: ShadowPass.self, capacity: shadowPassData.count)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The withMemoryRebound calls need similar adjustments. The pointer to MainPass is actually a single structure to it should be safe to do this<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         let mainPtr : UnsafeMutablePointer&lt;MainPass&gt; = shadowPtr.advanced(by: 1).withMemoryRebound(to: MainPass.self, capacity: 1) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;             $0.pointee = mainPassFrameData<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Whereas the unsafe pointer to &lt;ObjectData&gt; is actually a buffer of renderable objects, so this should work:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         var ptr : UnsafeMutablePointer&lt;ObjectData&gt; = mainPtr.advanced(by: 1).withMemoryRebound(to: ObjectData.self, capacity: objectsToRender) {_ in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; There are surely ways to refactor and simplify this, but I’m trying to retain as much of the original sample code approach as possible.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; However, the compiler still segs badly. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Xcode also borks an internal error often. Only cleaning or restarting the project can clear up that state.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Compilers (or Playgrounds for that matter) should never crash, and I’m not sure where to file this bug : Swift or Apple radar against Xcode or both? I now Xcode 8 is beta but…it’s been doing this for quite a while now...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; In both our “close to the metal” (no pun intended) cases, it seems like a lot of churning for very little gain. Don’t you think? The easier, but “unsafe” casting afforded previously did the trick with the normal caveats.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Don’t get me wrong, I love Swift and “get&quot; all the neat type safety features. Guess we can’t have our cake and eat it too, especially when interfacing with “unsafe” C APIs.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Anyway, back to rtfm … maybe some of the Swift Gods can chime in?  ;-) <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I must be doing something stupid...Patrice<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Sep 3, 2016, at 2:32 AM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi Patrice,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t have a solution for you, but I just wanted to point out what I think may be an error with your use of the new UnsafeRawPointer APIs:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; constantBufferForFrame.contents().bindMemory(to: ShadowPass.self, capacity: MemoryLayout&lt;ShadowPass&gt;.size)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I believe the `capacity` should actually be the number of ShadowPass elements in the buffer, not the size of each element. Using `bindMemory(to: ShadowPass.self` already implies that MemoryLayout&lt;ShadowPass&gt;.size is the size of each element.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; More info at https://developer.apple.com/reference/swift/unsaferawpointer/2428875-bindmemory &lt;https://developer.apple.com/reference/swift/unsaferawpointer/2428875-bindmemory&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I just updated a small Metal project of mine to Swift 3. I ran into some compiler (playground) crashes, but it does seem to work most of the time. Although I only have 1 buffer :-) https://github.com/jtbandes/Metalbrot.playground &lt;https://github.com/jtbandes/Metalbrot.playground&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jacob<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Fri, Sep 2, 2016 at 11:00 AM, Patrice Kouame via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi all - <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I’m converting Apple’s Swift Sample &quot;Adopting Metal II: Designing and Implementing a Real-World Metal Renderer” in Xcode 8 beta6 to the latest UnsafeMutablePointer API for untyped memory access.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Changes are necessary in MetalView.swift (Apple hasn’t updated their sample code for the latest beta yet…) <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The Swift Compiler crashes (Segmentation Fault: 11) on the attempt:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         // Grab a pointer to the constant buffer&#39;s data store<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         // Since we are using Swift, it is easier to cast the pointer to the ShadowPass type to fill the constant buffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         // We need to make a copy of these so the block captures the correct data<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; //      let shadowPtr = UnsafeMutablePointer&lt;ShadowPass&gt;(constantBufferForFrame.contents())<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         let shadowPtr = constantBufferForFrame.contents().bindMemory(to: ShadowPass.self, capacity: MemoryLayout&lt;ShadowPass&gt;.size)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         shadowPtr.pointee = shadowPassData[0]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         //More Swift specific stuff - advance pointer and cast to MainPass<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; //      let mainPtr = UnsafeMutablePointer&lt;MainPass&gt;(shadowPtr.advanced(by: 1))<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; //      mainPtr.pointee = mainPassFrameData<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         let mainPtr : UnsafeMutablePointer&lt;MainPass&gt;  = shadowPtr.advanced(by: 1).withMemoryRebound(to: MainPass.self, capacity: MemoryLayout&lt;MainPass&gt;.size) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;             $0.pointee = mainPassFrameData<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         //Advance and cast to ObjectData<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; //      var ptr = UnsafeMutablePointer&lt;ObjectData&gt;(mainPtr.advanced(by: 1))<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         var ptr : UnsafeMutablePointer&lt;ObjectData&gt; = mainPtr.advanced(by: 1).withMemoryRebound(to: ObjectData.self, capacity: MemoryLayout&lt;ObjectData&gt;.size) {_ in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         let shadowOffset = 0<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         let mainPassOffset = MemoryLayout&lt;ShadowPass&gt;.size + shadowOffset<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         let objectDataOffset = MemoryLayout&lt;MainPass&gt;.size + mainPassOffset<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         // Update position of all the objects<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         if multithreadedUpdate {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;             DispatchQueue.concurrentPerform(iterations: objectsToRender) { i in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                 let thisPtr = ptr.advanced(by: i)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                 _ = self.renderables[i].UpdateData(ptr, deltaTime: 1.0/60.0)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;             }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         else {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;             for index in 0..&lt;objectsToRender {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                 ptr = renderables[index].UpdateData(ptr, deltaTime: 1.0/60.0)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;             }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         ptr = ptr.advanced(by: objectsToRender)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         _ = groundPlane!.UpdateData(ptr, deltaTime: 1.0/60.0)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Any help is appreciated.  I have the latest Xcode log handy if necessary.  Here’s a clip of the stack trace.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 0  swift                    0x000000010714a99d PrintStackTraceSignalHandler(void*) + 45<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1  swift                    0x000000010714a3e6 SignalHandler(int) + 470<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2  libsystem_platform.dylib 0x00007fff91461bba _sigtramp + 26<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3  libsystem_platform.dylib 000000000000000000 _sigtramp + 1857676384<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 4  swift                    0x00000001047207b3 (anonymous namespace)::SILGenApply::visitExpr(swift::Expr*) + 51<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 5  swift                    0x0000000104723ace (anonymous namespace)::SILGenApply::visitApplyExpr(swift::ApplyExpr*) + 5182<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 6  swift                    0x0000000104711cc1 prepareApplyExpr(swift::Lowering::SILGenFunction&amp;, swift::Expr*) + 273<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 7  swift                    0x00000001047624e7 swift::ASTVisitor&lt;(anonymous namespace)::RValueEmitter, swift::Lowering::RValue, void, void, void, void, void, swift::Lowering::SGFContext&gt;::visit(swift::Expr*, swift::Lowering::SGFContext) + 103<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 8  swift                    0x0000000104762313 swift::Lowering::SILGenFunction::emitExprInto(swift::Expr*, swift::Lowering::Initialization*) + 195<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 9  swift                    0x000000010474fbc3 swift::Lowering::SILGenFunction::emitPatternBinding(swift::PatternBindingDecl*, unsigned int) + 195<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 10 swift                    0x00000001047077bd swift::ASTVisitor&lt;swift::Lowering::SILGenFunction, void, void, void, void, void, void&gt;::visit(swift::Decl*) + 125<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 11 swift                    0x00000001047c0019 swift::ASTVisitor&lt;(anonymous namespace)::StmtEmitter, void, void, void, void, void, void&gt;::visit(swift::Stmt*) + 4169<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 12 swift                    0x00000001047809ba swift::Lowering::SILGenFunction::emitFunction(swift::FuncDecl*) + 314<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 13 swift                    0x00000001046fd775 swift::Lowering::SILGenModule::emitFunction(swift::FuncDecl*)::$_1::operator()(swift::SILFunction*) const + 1877<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 14 swift                    0x00000001046fc322 swift::Lowering::SILGenModule::emitFunction(swift::FuncDecl*) + 626<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 15 swift                    0x00000001047c7007 (anonymous namespace)::SILGenType::emitType() + 1271<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 16 swift                    0x00000001047c6a9e swift::Lowering::SILGenModule::visitNominalTypeDecl(swift::NominalTypeDecl*) + 30<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 17 swift                    0x0000000104709093 swift::Lowering::SILGenModule::emitSourceFile(swift::SourceFile*, unsigned int) + 1795<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 18 swift                    0x000000010470ad4d swift::SILModule::constructSIL(swift::ModuleDecl*, swift::SILOptions&amp;, swift::FileUnit*, llvm::Optional&lt;unsigned int&gt;, bool, bool) + 1629<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 19 swift                    0x00000001045621bf performCompile(swift::CompilerInstance&amp;, swift::CompilerInvocation&amp;, llvm::ArrayRef&lt;char const*&gt;, int&amp;, swift::FrontendObserver*) + 19487<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 20 swift                    0x000000010455b2c5 swift::performFrontend(llvm::ArrayRef&lt;char const*&gt;, char const*, void*, swift::FrontendObserver*) + 17029<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 21 swift                    0x000000010451888d main + 8685<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 22 libdyld.dylib            0x00007fff91255255 start + 1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Patrice<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt;&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160908/8bccaf37/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>UnsafeMutablePointer Swift 3 conversion</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>September  8, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Sep 8, 2016, at 4:04 AM, Gerard Iglesias &lt;gerard_iglesias at me.com&gt; wrote:<br>&gt; <br>&gt; Andrew,<br>&gt; <br>&gt; Thank you for the compliment ;)<br>&gt; <br>&gt; And thank you for the 2 advices<br>&gt; <br>&gt; And the question about use of size or stride ? I understand that the underlaying float data are aligned in this specific case, but I wonder in fact if the shader compiler align memory the same way the swift compiler do, I suppose yes unless it would be a nightmare, but murphy’s principle says me … take care ;)<br></p><p>Always use stride for contiguous in-memory values.<br></p><p>-Andy<br></p><p>&gt; <br>&gt; Thanks in advance<br>&gt; <br>&gt; Gerard<br>&gt; <br>&gt;&gt; On 8 Sep 2016, at 07:21, Andrew Trick &lt;atrick at apple.com &lt;mailto:atrick at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Sep 3, 2016, at 6:03 PM, Gerard Iglesias via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is my funny version… I succeeded and I didn’t come back to find an other way…<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Grab a pointer to the constant buffer&#39;s data store<br>&gt;&gt;&gt; // Since we are using Swift, it is easier to cast the pointer to the ShadowPass type to fill the constant buffer<br>&gt;&gt;&gt; // We need to make a copy of these so the block captures the correct data<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt; //let shadowPtr = UnsafeMutablePointer&lt;ShadowPass&gt;(constantBufferForFrame.contents())<br>&gt;&gt;&gt; let shadowPtr = constantBufferForFrame.contents().assumingMemoryBound(to: ShadowPass.self)<br>&gt;&gt;&gt; shadowPtr.pointee = shadowPassData[0]<br>&gt;&gt;&gt; 		<br>&gt;&gt;&gt; //More Swift specific stuff - advance pointer and cast to MainPass<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt; //let mainPtr = UnsafeMutablePointer&lt;MainPass&gt;(shadowPtr.advanced(by: 1))<br>&gt;&gt;&gt; let mainPtr = constantBufferForFrame.contents().advanced(by: MemoryLayout&lt;ShadowPass&gt;.size).assumingMemoryBound(to: MainPass.self)<br>&gt;&gt;&gt; mainPtr.pointee = mainPassFrameData<br>&gt;&gt;&gt; 		<br>&gt;&gt;&gt; //Advance and cast to ObjectData<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; //var ptr = UnsafeMutablePointer&lt;ObjectData&gt;(mainPtr.advanced(by: 1))<br>&gt;&gt;&gt; var ptr = constantBufferForFrame.contents().advanced(by: MemoryLayout&lt;ShadowPass&gt;.size + MemoryLayout&lt;MainPass&gt;.size).assumingMemoryBound(to: ObjectData.self)<br>&gt;&gt; <br>&gt;&gt; Gerard,<br>&gt;&gt; <br>&gt;&gt; I like your code. A couple of things to consider:<br>&gt;&gt; <br>&gt;&gt; 1. If the memory has never been bound to a type (i.e. it&#39;s straight from MTLBuffer.newBuffer), then rather than “assuming” memory is bound to these types, you should just bind it here (substitute all your assumingMemoryBound(to: _) with bindMemory(to: _, capacity: 1). Think of it as two-phase initialization of the memory. First declare the memory&#39;s type (e.g. some structure that holds a bunch of floats), then write individual float values into the memory.<br>&gt;&gt; <br>&gt;&gt; 2. If you want the compiler to compute byte offsets for you like the original code, then can be done as follows:<br>&gt;&gt; <br>&gt;&gt;   let mainPtr = UnsafeMutableRawPointer(shadowPtr + 1).bindMemory(<br>&gt;&gt;     to: MainPass.self, capacity: 1)<br>&gt;&gt;   mainPtr.pointee = mainPassFrameData<br>&gt;&gt;   ...<br>&gt;&gt; <br>&gt;&gt; However, your approach of computing byte offsets is more explicit.<br>&gt;&gt; <br>&gt;&gt; My migration guide landed on swift.org &lt;http://swift.org/&gt; today! I think it will be a big help.<br>&gt;&gt; https://swift.org/migration-guide/se-0107-migrate.html &lt;https://swift.org/migration-guide/se-0107-migrate.html&gt;<br>&gt;&gt; <br>&gt;&gt; -Andy<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On 3 Sep 2016, at 19:22, Patrice Kouame &lt;pkouame at me.com &lt;mailto:pkouame at me.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Gerard- <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Excellent!  Looking forward to seeing your fix (hoping you get your book back soon ;-) )<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think Xcode/Swift gags on the last ptr advance to objectData.  I recently tried another variant using withUnsafeMutablePointer like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;         var ptr : UnsafeMutablePointer&lt;ObjectData&gt;  = withUnsafeMutablePointer(to: &amp;mainPtr) {<br>&gt;&gt;&gt;&gt;             $0.withMemoryRebound(to: ObjectData.self, capacity: objectsToRender) {<br>&gt;&gt;&gt;&gt;                 $0.pointee = renderables[0].objectData<br>&gt;&gt;&gt;&gt;             }<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ..but still crashes with no hints.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; My bug report also mentions that the Xcode migration/conversion tool is incomplete.  <br>&gt;&gt;&gt;&gt; It handles the “simpler&quot; UnsafeMutableRawPointer&lt;X&gt; to UnsafeMutablePonter&lt;Y&gt; with bindMemory cases correctly (one still has to mind the capacity value though)<br>&gt;&gt;&gt;&gt; In all fairness, migrating/converting automagically in these cases is always a little bit tricky - the proposed Xcode fixes should always be reviewed by a human...<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Patrice<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Sep 3, 2016, at 1:05 PM, Gerard Iglesias via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Ok<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; For the record I succeeded this transformation phase last week<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I remember the tedious stuff to advance pointer from one struct to the other kind of struct... it worked<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; But I don&#39;t have my MacBook with me, only the phone, the six :)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Gérard <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Le 3 sept. 2016 à 18:22, Patrice Kouame &lt;pkouame at me.com &lt;mailto:pkouame at me.com&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Indeed. There is a difference between stride and size, but I interpreted capacity incorrectly for my purposes.  It should indicate the number of &lt;T&gt; elements (not their size - right?) and the snippets below should work.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Still, compiler crashes and Xcode IDE is left in inconsistent state.  So I filed this Apple radar against Developer Tools.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	28150447 - Swift 3 UnsafeMutablePointer conversion crashes the compiler and IDE<br>&gt;&gt;&gt;&gt;&gt;&gt; Should I file a Swift bug too? Would that be helpful?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Regards, Patrice<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Sep 3, 2016, at 11:39 AM, Gerard Iglesias via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think that it is more secure to use stride in place of size, sometimes it is not the same value.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I use it in my own use of raw bindings <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Regards<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Gérard <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Le 3 sept. 2016 à 10:03, Patrice Kouame via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi Jacob - <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think you’re right. “capacity” should be the count of type T elements in my buffer.  So in my case that line should read<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         let shadowPtr = constantBufferForFrame.contents().bindMemory(to: ShadowPass.self, capacity: shadowPassData.count)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The withMemoryRebound calls need similar adjustments. The pointer to MainPass is actually a single structure to it should be safe to do this<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         let mainPtr : UnsafeMutablePointer&lt;MainPass&gt; = shadowPtr.advanced(by: 1).withMemoryRebound(to: MainPass.self, capacity: 1) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;             $0.pointee = mainPassFrameData<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Whereas the unsafe pointer to &lt;ObjectData&gt; is actually a buffer of renderable objects, so this should work:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         var ptr : UnsafeMutablePointer&lt;ObjectData&gt; = mainPtr.advanced(by: 1).withMemoryRebound(to: ObjectData.self, capacity: objectsToRender) {_ in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There are surely ways to refactor and simplify this, but I’m trying to retain as much of the original sample code approach as possible.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; However, the compiler still segs badly. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Xcode also borks an internal error often. Only cleaning or restarting the project can clear up that state.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Compilers (or Playgrounds for that matter) should never crash, and I’m not sure where to file this bug : Swift or Apple radar against Xcode or both? I now Xcode 8 is beta but…it’s been doing this for quite a while now...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In both our “close to the metal” (no pun intended) cases, it seems like a lot of churning for very little gain. Don’t you think? The easier, but “unsafe” casting afforded previously did the trick with the normal caveats.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Don’t get me wrong, I love Swift and “get&quot; all the neat type safety features. Guess we can’t have our cake and eat it too, especially when interfacing with “unsafe” C APIs.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Anyway, back to rtfm … maybe some of the Swift Gods can chime in?  ;-) <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I must be doing something stupid...Patrice<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Sep 3, 2016, at 2:32 AM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi Patrice,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t have a solution for you, but I just wanted to point out what I think may be an error with your use of the new UnsafeRawPointer APIs:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; constantBufferForFrame.contents().bindMemory(to: ShadowPass.self, capacity: MemoryLayout&lt;ShadowPass&gt;.size)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I believe the `capacity` should actually be the number of ShadowPass elements in the buffer, not the size of each element. Using `bindMemory(to: ShadowPass.self` already implies that MemoryLayout&lt;ShadowPass&gt;.size is the size of each element.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; More info at https://developer.apple.com/reference/swift/unsaferawpointer/2428875-bindmemory &lt;https://developer.apple.com/reference/swift/unsaferawpointer/2428875-bindmemory&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I just updated a small Metal project of mine to Swift 3. I ran into some compiler (playground) crashes, but it does seem to work most of the time. Although I only have 1 buffer :-) https://github.com/jtbandes/Metalbrot.playground &lt;https://github.com/jtbandes/Metalbrot.playground&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jacob<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Fri, Sep 2, 2016 at 11:00 AM, Patrice Kouame via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi all - <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I’m converting Apple’s Swift Sample &quot;Adopting Metal II: Designing and Implementing a Real-World Metal Renderer” in Xcode 8 beta6 to the latest UnsafeMutablePointer API for untyped memory access.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Changes are necessary in MetalView.swift (Apple hasn’t updated their sample code for the latest beta yet…) <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The Swift Compiler crashes (Segmentation Fault: 11) on the attempt:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         // Grab a pointer to the constant buffer&#39;s data store<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         // Since we are using Swift, it is easier to cast the pointer to the ShadowPass type to fill the constant buffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         // We need to make a copy of these so the block captures the correct data<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; //      let shadowPtr = UnsafeMutablePointer&lt;ShadowPass&gt;(constantBufferForFrame.contents())<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         let shadowPtr = constantBufferForFrame.contents().bindMemory(to: ShadowPass.self, capacity: MemoryLayout&lt;ShadowPass&gt;.size)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         shadowPtr.pointee = shadowPassData[0]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         //More Swift specific stuff - advance pointer and cast to MainPass<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; //      let mainPtr = UnsafeMutablePointer&lt;MainPass&gt;(shadowPtr.advanced(by: 1))<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; //      mainPtr.pointee = mainPassFrameData<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         let mainPtr : UnsafeMutablePointer&lt;MainPass&gt;  = shadowPtr.advanced(by: 1).withMemoryRebound(to: MainPass.self, capacity: MemoryLayout&lt;MainPass&gt;.size) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;             $0.pointee = mainPassFrameData<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         //Advance and cast to ObjectData<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; //      var ptr = UnsafeMutablePointer&lt;ObjectData&gt;(mainPtr.advanced(by: 1))<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         var ptr : UnsafeMutablePointer&lt;ObjectData&gt; = mainPtr.advanced(by: 1).withMemoryRebound(to: ObjectData.self, capacity: MemoryLayout&lt;ObjectData&gt;.size) {_ in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         let shadowOffset = 0<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         let mainPassOffset = MemoryLayout&lt;ShadowPass&gt;.size + shadowOffset<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         let objectDataOffset = MemoryLayout&lt;MainPass&gt;.size + mainPassOffset<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         // Update position of all the objects<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         if multithreadedUpdate {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;             DispatchQueue.concurrentPerform(iterations: objectsToRender) { i in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                 let thisPtr = ptr.advanced(by: i)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                 _ = self.renderables[i].UpdateData(ptr, deltaTime: 1.0/60.0)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;             }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         else {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;             for index in 0..&lt;objectsToRender {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                 ptr = renderables[index].UpdateData(ptr, deltaTime: 1.0/60.0)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;             }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         ptr = ptr.advanced(by: objectsToRender)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         _ = groundPlane!.UpdateData(ptr, deltaTime: 1.0/60.0)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Any help is appreciated.  I have the latest Xcode log handy if necessary.  Here’s a clip of the stack trace.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 0  swift                    0x000000010714a99d PrintStackTraceSignalHandler(void*) + 45<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1  swift                    0x000000010714a3e6 SignalHandler(int) + 470<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2  libsystem_platform.dylib 0x00007fff91461bba _sigtramp + 26<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3  libsystem_platform.dylib 000000000000000000 _sigtramp + 1857676384<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 4  swift                    0x00000001047207b3 (anonymous namespace)::SILGenApply::visitExpr(swift::Expr*) + 51<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 5  swift                    0x0000000104723ace (anonymous namespace)::SILGenApply::visitApplyExpr(swift::ApplyExpr*) + 5182<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 6  swift                    0x0000000104711cc1 prepareApplyExpr(swift::Lowering::SILGenFunction&amp;, swift::Expr*) + 273<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 7  swift                    0x00000001047624e7 swift::ASTVisitor&lt;(anonymous namespace)::RValueEmitter, swift::Lowering::RValue, void, void, void, void, void, swift::Lowering::SGFContext&gt;::visit(swift::Expr*, swift::Lowering::SGFContext) + 103<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 8  swift                    0x0000000104762313 swift::Lowering::SILGenFunction::emitExprInto(swift::Expr*, swift::Lowering::Initialization*) + 195<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 9  swift                    0x000000010474fbc3 swift::Lowering::SILGenFunction::emitPatternBinding(swift::PatternBindingDecl*, unsigned int) + 195<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 10 swift                    0x00000001047077bd swift::ASTVisitor&lt;swift::Lowering::SILGenFunction, void, void, void, void, void, void&gt;::visit(swift::Decl*) + 125<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 11 swift                    0x00000001047c0019 swift::ASTVisitor&lt;(anonymous namespace)::StmtEmitter, void, void, void, void, void, void&gt;::visit(swift::Stmt*) + 4169<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 12 swift                    0x00000001047809ba swift::Lowering::SILGenFunction::emitFunction(swift::FuncDecl*) + 314<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 13 swift                    0x00000001046fd775 swift::Lowering::SILGenModule::emitFunction(swift::FuncDecl*)::$_1::operator()(swift::SILFunction*) const + 1877<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 14 swift                    0x00000001046fc322 swift::Lowering::SILGenModule::emitFunction(swift::FuncDecl*) + 626<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 15 swift                    0x00000001047c7007 (anonymous namespace)::SILGenType::emitType() + 1271<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 16 swift                    0x00000001047c6a9e swift::Lowering::SILGenModule::visitNominalTypeDecl(swift::NominalTypeDecl*) + 30<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 17 swift                    0x0000000104709093 swift::Lowering::SILGenModule::emitSourceFile(swift::SourceFile*, unsigned int) + 1795<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 18 swift                    0x000000010470ad4d swift::SILModule::constructSIL(swift::ModuleDecl*, swift::SILOptions&amp;, swift::FileUnit*, llvm::Optional&lt;unsigned int&gt;, bool, bool) + 1629<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 19 swift                    0x00000001045621bf performCompile(swift::CompilerInstance&amp;, swift::CompilerInvocation&amp;, llvm::ArrayRef&lt;char const*&gt;, int&amp;, swift::FrontendObserver*) + 19487<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 20 swift                    0x000000010455b2c5 swift::performFrontend(llvm::ArrayRef&lt;char const*&gt;, char const*, void*, swift::FrontendObserver*) + 17029<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 21 swift                    0x000000010451888d main + 8685<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 22 libdyld.dylib            0x00007fff91255255 start + 1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Patrice<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160908/0fe075d4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8016afa037fa775c19d05b495a24413f?s=50"></div><header><strong>UnsafeMutablePointer Swift 3 conversion</strong> from <string>Patrice Kouame</string> &lt;pkouame at me.com&gt;<p>September 12, 2016 at 10:00:00am</p></header><div class="content"><p>Andy - yes thanks for the guidance and great job on your guide. <br>There&#39;s a lot to absorb there. I think the metal samples are another great use case for your new apis. I have a small side project in mind to<br>analyze its impact on performance, comparing the swift 3 compliant &quot;safe&quot; implementation versus straight objective-c.<br></p><p>P.<br></p><p><br>&gt; On Sep 8, 2016, at 1:35 PM, Andrew Trick via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Sep 8, 2016, at 4:04 AM, Gerard Iglesias &lt;gerard_iglesias at me.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Andrew,<br>&gt;&gt; <br>&gt;&gt; Thank you for the compliment ;)<br>&gt;&gt; <br>&gt;&gt; And thank you for the 2 advices<br>&gt;&gt; <br>&gt;&gt; And the question about use of size or stride ? I understand that the underlaying float data are aligned in this specific case, but I wonder in fact if the shader compiler align memory the same way the swift compiler do, I suppose yes unless it would be a nightmare, but murphy’s principle says me … take care ;)<br>&gt; <br>&gt; Always use stride for contiguous in-memory values.<br>&gt; <br>&gt; -Andy<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Thanks in advance<br>&gt;&gt; <br>&gt;&gt; Gerard<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On 8 Sep 2016, at 07:21, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Sep 3, 2016, at 6:03 PM, Gerard Iglesias via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is my funny version… I succeeded and I didn’t come back to find an other way…<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // Grab a pointer to the constant buffer&#39;s data store<br>&gt;&gt;&gt;&gt; // Since we are using Swift, it is easier to cast the pointer to the ShadowPass type to fill the constant buffer<br>&gt;&gt;&gt;&gt; // We need to make a copy of these so the block captures the correct data<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt; //let shadowPtr = UnsafeMutablePointer&lt;ShadowPass&gt;(constantBufferForFrame.contents())<br>&gt;&gt;&gt;&gt; let shadowPtr = constantBufferForFrame.contents().assumingMemoryBound(to: ShadowPass.self)<br>&gt;&gt;&gt;&gt; shadowPtr.pointee = shadowPassData[0]<br>&gt;&gt;&gt;&gt; 		<br>&gt;&gt;&gt;&gt; //More Swift specific stuff - advance pointer and cast to MainPass<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt; //let mainPtr = UnsafeMutablePointer&lt;MainPass&gt;(shadowPtr.advanced(by: 1))<br>&gt;&gt;&gt;&gt; let mainPtr = constantBufferForFrame.contents().advanced(by: MemoryLayout&lt;ShadowPass&gt;.size).assumingMemoryBound(to: MainPass.self)<br>&gt;&gt;&gt;&gt; mainPtr.pointee = mainPassFrameData<br>&gt;&gt;&gt;&gt; 		<br>&gt;&gt;&gt;&gt; //Advance and cast to ObjectData<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; //var ptr = UnsafeMutablePointer&lt;ObjectData&gt;(mainPtr.advanced(by: 1))<br>&gt;&gt;&gt;&gt; var ptr = constantBufferForFrame.contents().advanced(by: MemoryLayout&lt;ShadowPass&gt;.size + MemoryLayout&lt;MainPass&gt;.size).assumingMemoryBound(to: ObjectData.self)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Gerard,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I like your code. A couple of things to consider:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. If the memory has never been bound to a type (i.e. it&#39;s straight from MTLBuffer.newBuffer), then rather than “assuming” memory is bound to these types, you should just bind it here (substitute all your assumingMemoryBound(to: _) with bindMemory(to: _, capacity: 1). Think of it as two-phase initialization of the memory. First declare the memory&#39;s type (e.g. some structure that holds a bunch of floats), then write individual float values into the memory.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2. If you want the compiler to compute byte offsets for you like the original code, then can be done as follows:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   let mainPtr = UnsafeMutableRawPointer(shadowPtr + 1).bindMemory(<br>&gt;&gt;&gt;     to: MainPass.self, capacity: 1)<br>&gt;&gt;&gt;   mainPtr.pointee = mainPassFrameData<br>&gt;&gt;&gt;   ...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However, your approach of computing byte offsets is more explicit.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My migration guide landed on swift.org today! I think it will be a big help.<br>&gt;&gt;&gt; https://swift.org/migration-guide/se-0107-migrate.html<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Andy<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 3 Sep 2016, at 19:22, Patrice Kouame &lt;pkouame at me.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Gerard- <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Excellent!  Looking forward to seeing your fix (hoping you get your book back soon ;-) )<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think Xcode/Swift gags on the last ptr advance to objectData.  I recently tried another variant using withUnsafeMutablePointer like this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;         var ptr : UnsafeMutablePointer&lt;ObjectData&gt;  = withUnsafeMutablePointer(to: &amp;mainPtr) {<br>&gt;&gt;&gt;&gt;&gt;             $0.withMemoryRebound(to: ObjectData.self, capacity: objectsToRender) {<br>&gt;&gt;&gt;&gt;&gt;                 $0.pointee = renderables[0].objectData<br>&gt;&gt;&gt;&gt;&gt;             }<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ..but still crashes with no hints.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; My bug report also mentions that the Xcode migration/conversion tool is incomplete.  <br>&gt;&gt;&gt;&gt;&gt; It handles the “simpler&quot; UnsafeMutableRawPointer&lt;X&gt; to UnsafeMutablePonter&lt;Y&gt; with bindMemory cases correctly (one still has to mind the capacity value though)<br>&gt;&gt;&gt;&gt;&gt; In all fairness, migrating/converting automagically in these cases is always a little bit tricky - the proposed Xcode fixes should always be reviewed by a human...<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Patrice<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Sep 3, 2016, at 1:05 PM, Gerard Iglesias via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Ok<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; For the record I succeeded this transformation phase last week<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I remember the tedious stuff to advance pointer from one struct to the other kind of struct... it worked<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; But I don&#39;t have my MacBook with me, only the phone, the six :)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Gérard <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Le 3 sept. 2016 à 18:22, Patrice Kouame &lt;pkouame at me.com&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Indeed. There is a difference between stride and size, but I interpreted capacity incorrectly for my purposes.  It should indicate the number of &lt;T&gt; elements (not their size - right?) and the snippets below should work.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Still, compiler crashes and Xcode IDE is left in inconsistent state.  So I filed this Apple radar against Developer Tools.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	28150447 - Swift 3 UnsafeMutablePointer conversion crashes the compiler and IDE<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Should I file a Swift bug too? Would that be helpful?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Regards, Patrice<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Sep 3, 2016, at 11:39 AM, Gerard Iglesias via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think that it is more secure to use stride in place of size, sometimes it is not the same value.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I use it in my own use of raw bindings <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Regards<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Gérard <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Le 3 sept. 2016 à 10:03, Patrice Kouame via swift-users &lt;swift-users at swift.org&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi Jacob - <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think you’re right. “capacity” should be the count of type T elements in my buffer.  So in my case that line should read<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         let shadowPtr = constantBufferForFrame.contents().bindMemory(to: ShadowPass.self, capacity: shadowPassData.count)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The withMemoryRebound calls need similar adjustments. The pointer to MainPass is actually a single structure to it should be safe to do this<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         let mainPtr : UnsafeMutablePointer&lt;MainPass&gt; = shadowPtr.advanced(by: 1).withMemoryRebound(to: MainPass.self, capacity: 1) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;             $0.pointee = mainPassFrameData<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Whereas the unsafe pointer to &lt;ObjectData&gt; is actually a buffer of renderable objects, so this should work:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         var ptr : UnsafeMutablePointer&lt;ObjectData&gt; = mainPtr.advanced(by: 1).withMemoryRebound(to: ObjectData.self, capacity: objectsToRender) {_ in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There are surely ways to refactor and simplify this, but I’m trying to retain as much of the original sample code approach as possible.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; However, the compiler still segs badly. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Xcode also borks an internal error often. Only cleaning or restarting the project can clear up that state.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Compilers (or Playgrounds for that matter) should never crash, and I’m not sure where to file this bug : Swift or Apple radar against Xcode or both? I now Xcode 8 is beta but…it’s been doing this for quite a while now...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In both our “close to the metal” (no pun intended) cases, it seems like a lot of churning for very little gain. Don’t you think? The easier, but “unsafe” casting afforded previously did the trick with the normal caveats.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Don’t get me wrong, I love Swift and “get&quot; all the neat type safety features. Guess we can’t have our cake and eat it too, especially when interfacing with “unsafe” C APIs.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Anyway, back to rtfm … maybe some of the Swift Gods can chime in?  ;-) <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I must be doing something stupid...Patrice<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Sep 3, 2016, at 2:32 AM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi Patrice,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t have a solution for you, but I just wanted to point out what I think may be an error with your use of the new UnsafeRawPointer APIs:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; constantBufferForFrame.contents().bindMemory(to: ShadowPass.self, capacity: MemoryLayout&lt;ShadowPass&gt;.size)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I believe the `capacity` should actually be the number of ShadowPass elements in the buffer, not the size of each element. Using `bindMemory(to: ShadowPass.self` already implies that MemoryLayout&lt;ShadowPass&gt;.size is the size of each element.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; More info at https://developer.apple.com/reference/swift/unsaferawpointer/2428875-bindmemory<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I just updated a small Metal project of mine to Swift 3. I ran into some compiler (playground) crashes, but it does seem to work most of the time. Although I only have 1 buffer :-) https://github.com/jtbandes/Metalbrot.playground<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jacob<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Fri, Sep 2, 2016 at 11:00 AM, Patrice Kouame via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi all - <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I’m converting Apple’s Swift Sample &quot;Adopting Metal II: Designing and Implementing a Real-World Metal Renderer” in Xcode 8 beta6 to the latest UnsafeMutablePointer API for untyped memory access.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Changes are necessary in MetalView.swift (Apple hasn’t updated their sample code for the latest beta yet…) <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The Swift Compiler crashes (Segmentation Fault: 11) on the attempt:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         // Grab a pointer to the constant buffer&#39;s data store<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         // Since we are using Swift, it is easier to cast the pointer to the ShadowPass type to fill the constant buffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         // We need to make a copy of these so the block captures the correct data<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; //      let shadowPtr = UnsafeMutablePointer&lt;ShadowPass&gt;(constantBufferForFrame.contents())<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         let shadowPtr = constantBufferForFrame.contents().bindMemory(to: ShadowPass.self, capacity: MemoryLayout&lt;ShadowPass&gt;.size)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         shadowPtr.pointee = shadowPassData[0]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         //More Swift specific stuff - advance pointer and cast to MainPass<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; //      let mainPtr = UnsafeMutablePointer&lt;MainPass&gt;(shadowPtr.advanced(by: 1))<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; //      mainPtr.pointee = mainPassFrameData<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         let mainPtr : UnsafeMutablePointer&lt;MainPass&gt;  = shadowPtr.advanced(by: 1).withMemoryRebound(to: MainPass.self, capacity: MemoryLayout&lt;MainPass&gt;.size) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;             $0.pointee = mainPassFrameData<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         //Advance and cast to ObjectData<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; //      var ptr = UnsafeMutablePointer&lt;ObjectData&gt;(mainPtr.advanced(by: 1))<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         var ptr : UnsafeMutablePointer&lt;ObjectData&gt; = mainPtr.advanced(by: 1).withMemoryRebound(to: ObjectData.self, capacity: MemoryLayout&lt;ObjectData&gt;.size) {_ in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         let shadowOffset = 0<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         let mainPassOffset = MemoryLayout&lt;ShadowPass&gt;.size + shadowOffset<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         let objectDataOffset = MemoryLayout&lt;MainPass&gt;.size + mainPassOffset<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         // Update position of all the objects<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         if multithreadedUpdate {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;             DispatchQueue.concurrentPerform(iterations: objectsToRender) { i in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                 let thisPtr = ptr.advanced(by: i)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                 _ = self.renderables[i].UpdateData(ptr, deltaTime: 1.0/60.0)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;             }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         else {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;             for index in 0..&lt;objectsToRender {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                 ptr = renderables[index].UpdateData(ptr, deltaTime: 1.0/60.0)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;             }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         ptr = ptr.advanced(by: objectsToRender)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         _ = groundPlane!.UpdateData(ptr, deltaTime: 1.0/60.0)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Any help is appreciated.  I have the latest Xcode log handy if necessary.  Here’s a clip of the stack trace.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 0  swift                    0x000000010714a99d PrintStackTraceSignalHandler(void*) + 45<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1  swift                    0x000000010714a3e6 SignalHandler(int) + 470<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2  libsystem_platform.dylib 0x00007fff91461bba _sigtramp + 26<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3  libsystem_platform.dylib 000000000000000000 _sigtramp + 1857676384<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 4  swift                    0x00000001047207b3 (anonymous namespace)::SILGenApply::visitExpr(swift::Expr*) + 51<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 5  swift                    0x0000000104723ace (anonymous namespace)::SILGenApply::visitApplyExpr(swift::ApplyExpr*) + 5182<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 6  swift                    0x0000000104711cc1 prepareApplyExpr(swift::Lowering::SILGenFunction&amp;, swift::Expr*) + 273<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 7  swift                    0x00000001047624e7 swift::ASTVisitor&lt;(anonymous namespace)::RValueEmitter, swift::Lowering::RValue, void, void, void, void, void, swift::Lowering::SGFContext&gt;::visit(swift::Expr*, swift::Lowering::SGFContext) + 103<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 8  swift                    0x0000000104762313 swift::Lowering::SILGenFunction::emitExprInto(swift::Expr*, swift::Lowering::Initialization*) + 195<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 9  swift                    0x000000010474fbc3 swift::Lowering::SILGenFunction::emitPatternBinding(swift::PatternBindingDecl*, unsigned int) + 195<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 10 swift                    0x00000001047077bd swift::ASTVisitor&lt;swift::Lowering::SILGenFunction, void, void, void, void, void, void&gt;::visit(swift::Decl*) + 125<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 11 swift                    0x00000001047c0019 swift::ASTVisitor&lt;(anonymous namespace)::StmtEmitter, void, void, void, void, void, void&gt;::visit(swift::Stmt*) + 4169<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 12 swift                    0x00000001047809ba swift::Lowering::SILGenFunction::emitFunction(swift::FuncDecl*) + 314<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 13 swift                    0x00000001046fd775 swift::Lowering::SILGenModule::emitFunction(swift::FuncDecl*)::$_1::operator()(swift::SILFunction*) const + 1877<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 14 swift                    0x00000001046fc322 swift::Lowering::SILGenModule::emitFunction(swift::FuncDecl*) + 626<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 15 swift                    0x00000001047c7007 (anonymous namespace)::SILGenType::emitType() + 1271<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 16 swift                    0x00000001047c6a9e swift::Lowering::SILGenModule::visitNominalTypeDecl(swift::NominalTypeDecl*) + 30<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 17 swift                    0x0000000104709093 swift::Lowering::SILGenModule::emitSourceFile(swift::SourceFile*, unsigned int) + 1795<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 18 swift                    0x000000010470ad4d swift::SILModule::constructSIL(swift::ModuleDecl*, swift::SILOptions&amp;, swift::FileUnit*, llvm::Optional&lt;unsigned int&gt;, bool, bool) + 1629<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 19 swift                    0x00000001045621bf performCompile(swift::CompilerInstance&amp;, swift::CompilerInvocation&amp;, llvm::ArrayRef&lt;char const*&gt;, int&amp;, swift::FrontendObserver*) + 19487<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 20 swift                    0x000000010455b2c5 swift::performFrontend(llvm::ArrayRef&lt;char const*&gt;, char const*, void*, swift::FrontendObserver*) + 17029<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 21 swift                    0x000000010451888d main + 8685<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 22 libdyld.dylib            0x00007fff91255255 start + 1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Patrice<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-users at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-users at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-users at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-users at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt;&gt; swift-users at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160912/aa95148a/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
