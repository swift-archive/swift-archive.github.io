<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>[Pitch] Nested types in protocols (and nesting protocols in types)</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>October 24, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; FWIW, in almost all the situations where I’ve wanted to nest types inside protocols and generic types, it’s only as a namespacing convenience. Most often, it’s an enum type that’s used only by a single method, and having it at the top of the module namespace adds clutter.<br>&gt; Alternatively, what if (1) outer types aren’t capture unless they’re referenced, and (2) nesting is only illegal if there’s a capture?<br>I was just about to write something similar, but Paul said it better.<br></p><p>Why don’t we allow everything to be nested in everything for namespacing purposes (which is most of why I want it), but forbid references to generic or associated types from the nested type?  Then, as the generics manifesto gets implemented, we can start allowing certain generics to be referenced over time as they start to become possible and make sense (but we wouldn’t worry about that yet for this proposal)<br></p><p>Is there another issue which would keep that simpler version from working?<br></p><p>Thanks,<br>Jon<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161024/ffd47724/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Pitch] Nested types in protocols (and nesting protocols in types)</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>October 25, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On 24 Oct 2016, at 20:23, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; FWIW, in almost all the situations where I’ve wanted to nest types inside protocols and generic types, it’s only as a namespacing convenience. Most often, it’s an enum type that’s used only by a single method, and having it at the top of the module namespace adds clutter.<br>&gt;&gt; Alternatively, what if (1) outer types aren’t capture unless they’re referenced, and (2) nesting is only illegal if there’s a capture?<br>&gt; I was just about to write something similar, but Paul said it better.<br>&gt; <br>&gt; Why don’t we allow everything to be nested in everything for namespacing purposes (which is most of why I want it), but forbid references to generic or associated types from the nested type?  Then, as the generics manifesto gets implemented, we can start allowing certain generics to be referenced over time as they start to become possible and make sense (but we wouldn’t worry about that yet for this proposal)<br>&gt; <br>&gt; Is there another issue which would keep that simpler version from working?<br>&gt; <br>&gt; Thanks,<br>&gt; Jon<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>Yeah, that’s why I structured it like that. We can’t represent most of the stuff with captured associated types in the type system right now.<br></p><p>I’ll split it up to include just the simple cases, with some rules:<br></p><p>- Protocols cannot capture generic type parameters<br>- No nested types can capture associated types<br></p><p>@Slava: Yes, I thought about a system where protocols which capture associated types could only be referred to from a concrete conforming type:<br></p><p>protocol Editor {<br>    associatedtype Content<br></p><p>    protocol Delegate : class { func contentDidChange(oldContent: Content) }<br>    var delegate : Delegate? { get, set }<br>}<br></p><p>class ImageEditor : Editor {<br>    associatedtype Content = Image<br>    weak var delegate : Delegate? // type is ImageEditor.Delegate, not Editor.Delegate<br>}<br></p><p>class ImageEditorController : ImageEditor.Delegate {<br>    func contentDidChange(oldContent: Image) {<br>    }<br>}<br></p><p>class TextEditorController : TextEditor.Delegate {<br>    func contentDidChange(oldContent: String) {<br>    }<br>}<br></p><p>And even though that seems pretty cool and like it adds some value, but it seemed like people would want to be able to express “This is a Delegate for any Editor whose Content is Image” rather than only “This is a Delegate for an ImageEditor”. Perhaps that&#39;s something which could live alongside a fully existential-based model (i.e. conforming to Editor.Delegate with an inherited associatedtype “Content”, as in the proposal) until we can do that.<br></p><p>Conversion to generic types is also interesting. I thought about perhaps requiring a shorthand for captured types:<br></p><p>protocol MyProtocol {<br>    associatedtype ErrorType : Error<br></p><p>    enum NestedType&lt;associatedtype ErrorType&gt; { // binds generic parameter ErrorType to associated type ErrorType<br>        case success<br>        case failed(ErrorType)<br>    }<br></p><p>    func getProgress() -&gt; NestedType  // behind-the-scenes when implemented: func getProgress() -&gt; NestedType&lt;Self.ErrorType&gt;<br>    func setProgress(_: NestedType)   // behind-the-scenes when implemented: func setProgress&lt;E&gt;(_: NestedType&lt;E&gt;) where E == Self.ErrorType<br>}<br></p><p>On the one hand, it’s a bit of an awkward cludge to work-around gaps in existential support; on the other hand, automatic bridging between existentials and bound generics might be a good feature anyway, because you know more about the generic type and can optimise more.<br></p><p>- Karl<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161025/5b2292a6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Pitch] Nested types in protocols (and nesting protocols in types)</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>October 25, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On 25 Oct 2016, at 00:06, Karl &lt;raziel.im+swift-users at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 24 Oct 2016, at 20:23, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; FWIW, in almost all the situations where I’ve wanted to nest types inside protocols and generic types, it’s only as a namespacing convenience. Most often, it’s an enum type that’s used only by a single method, and having it at the top of the module namespace adds clutter.<br>&gt;&gt;&gt; Alternatively, what if (1) outer types aren’t capture unless they’re referenced, and (2) nesting is only illegal if there’s a capture?<br>&gt;&gt; I was just about to write something similar, but Paul said it better.<br>&gt;&gt; <br>&gt;&gt; Why don’t we allow everything to be nested in everything for namespacing purposes (which is most of why I want it), but forbid references to generic or associated types from the nested type?  Then, as the generics manifesto gets implemented, we can start allowing certain generics to be referenced over time as they start to become possible and make sense (but we wouldn’t worry about that yet for this proposal)<br>&gt;&gt; <br>&gt;&gt; Is there another issue which would keep that simpler version from working?<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; Jon<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; Yeah, that’s why I structured it like that. We can’t represent most of the stuff with captured associated types in the type system right now.<br>&gt; <br>&gt; I’ll split it up to include just the simple cases, with some rules:<br>&gt; <br>&gt; - Protocols cannot capture generic type parameters<br>&gt; - No nested types can capture associated types<br>&gt; <br>&gt; @Slava: Yes, I thought about a system where protocols which capture associated types could only be referred to from a concrete conforming type:<br>&gt; <br>&gt; protocol Editor {<br>&gt;     associatedtype Content<br>&gt; <br>&gt;     protocol Delegate : class { func contentDidChange(oldContent: Content) }<br>&gt;     var delegate : Delegate? { get, set }<br>&gt; }<br>&gt; <br>&gt; class ImageEditor : Editor {<br>&gt;     associatedtype Content = Image<br>&gt;     weak var delegate : Delegate? // type is ImageEditor.Delegate, not Editor.Delegate<br>&gt; }<br>&gt; <br>&gt; class ImageEditorController : ImageEditor.Delegate {<br>&gt;     func contentDidChange(oldContent: Image) {<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; class TextEditorController : TextEditor.Delegate {<br>&gt;     func contentDidChange(oldContent: String) {<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; And even though that seems pretty cool and like it adds some value, but it seemed like people would want to be able to express “This is a Delegate for any Editor whose Content is Image” rather than only “This is a Delegate for an ImageEditor”. Perhaps that&#39;s something which could live alongside a fully existential-based model (i.e. conforming to Editor.Delegate with an inherited associatedtype “Content”, as in the proposal) until we can do that.<br>&gt; <br>&gt; Conversion to generic types is also interesting. I thought about perhaps requiring a shorthand for captured types:<br>&gt; <br>&gt; protocol MyProtocol {<br>&gt;     associatedtype ErrorType : Error<br>&gt; <br>&gt;     enum NestedType&lt;associatedtype ErrorType&gt; { // binds generic parameter ErrorType to associated type ErrorType<br>&gt;         case success<br>&gt;         case failed(ErrorType)<br>&gt;     }<br>&gt; <br>&gt;     func getProgress() -&gt; NestedType  // behind-the-scenes when implemented: func getProgress() -&gt; NestedType&lt;Self.ErrorType&gt;<br>&gt;     func setProgress(_: NestedType)   // behind-the-scenes when implemented: func setProgress&lt;E&gt;(_: NestedType&lt;E&gt;) where E == Self.ErrorType<br>&gt; }<br>&gt; <br>&gt; On the one hand, it’s a bit of an awkward cludge to work-around gaps in existential support; on the other hand, automatic bridging between existentials and bound generics might be a good feature anyway, because you know more about the generic type and can optimise more.<br>&gt; <br>&gt; - Karl<br></p><p>Sorry, I don’t mean “automatic bridging” — I mean a syntax that makes using generic types as simple as it would be to use an existential. <br></p><p>For example, it might be really tempting to just capture “ErrorType” directly instead of indirectly through the generic constraint (especially with people always looking for code which is &quot;more dynamic”), but it would be more awkward to use in lots of cases and less optimisable. OTOH, generics need lots of boilerplate. If you can bind a generic parameter for a supporting type with one of your own associated types though, the compiler can generate the boilerplate for you.<br></p><p>- Karl<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161025/4072c2c9/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
