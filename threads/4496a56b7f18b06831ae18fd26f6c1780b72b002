<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0a88a27755600d9f1c1ce00e3c209a38?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Brad Hilton</string> &lt;brad.hilton.nw at gmail.com&gt;<p>July  6, 2016 at 10:00:00pm</p></header><div class="content"><p>I completely agree with rparada and give a strong, strong, strong -1 to this proposal. To make classes non-subclassable by default is only going to lead to unanticipated pain and frustration. Also agree with other comments that subclassable and overridable conflate access control with class behavior. If we want to make it possible to define a class as non-subclassable to external users, Iâ€™d agree to something more consistent with existing swift access control like public(final) as has been proposed by other commenters. However, I agree that making classes final by default is a bad idea that will create a larger problem that it solves.<br></p><p>Also, just a more general complaint, I sometimes feel that the evolution list is being dominated by safety enthusiasts at the expense of usability advocates. Safety is a premier feature of Swift, but so is usability. We should be trying to find solutions that advance both objectives, as well as performance and power.<br></p><p>&gt; On Jul 5, 2016, at 7:11 PM, Chris Lattner&lt;clattner at apple.com(mailto:clattner at apple.com)&gt;wrote:<br>&gt; <br>&gt; &gt; Hello Swift community,<br>&gt; &gt; <br>&gt; &gt; The review of &quot;SE-0117: Default classes to be non-subclassable publicly&quot; begins now and runs through July 11. The proposal is available here:<br>&gt; &gt; <br>&gt; &gt; https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt; &gt; <br>&gt; &gt; * What is your evaluation of the proposal?<br>&gt; -1<br>&gt; <br>&gt; Perhaps because this is so different from what I have seen in other languages and used for so many years. I have not worked with a language that uses non-subclassable/ non-overridable as the default.<br>&gt; <br>&gt; I think that by default classes should be subclassable, not the other way around. I am afraid that developers will not take the time to specify which methods are overridable resulting in libraries that are difficult to patch, extend.<br>&gt; <br>&gt; In my 26+ years of object-oriented design and programming (other languages, Objective-C since 1990 and Java since 2001) I have worked with object oriented libraries and subclassed methods that the authors probably never anticipated. I have been able to fix problems, enhance classes by creating subclasses with fixes and enhanced behavior.<br>&gt; <br>&gt; In java for example I have seen that sometimes I would have been able to fix bugs or enhance the existing classes had the author not chosen a method to be protected or private. Sometimes they had a good reason but sometimes they didn&#39;t.Is have been able to survive using an awesome library that was discontinued and end-of-lifed thanks to subclassing that has allowed me to fix problems and enhance over the years as the Java language kept evolving.<br>&gt; <br>&gt; In general I like to design classes with methods that have a very well defined purpose / logic. Such methods are potentially overridable. I find that making a method private or final can be selfish / restrictive at times and I choose it carefully for implementation details that are better served by going through the public methods.<br>&gt; <br>&gt; I think that making a class not subclassable by default is restrictive / limiting / selfish.<br>&gt; <br>&gt; Sometimes the extension points are clear.<br>&gt; I also think that every other method with a well defined purpose / logic is also potentially an extension point.<br>&gt; <br>&gt; In my experience we should allow the developer to override by default.That is how I design my classes and every method / property.<br>&gt; <br>&gt; I use private for the stuff that is obvious that should not be exposed.<br>&gt; <br>&gt; In the motivation sectionperformanceis also mentioned as driving this proposal. However I don&#39;t see any study that supports that. I would like to see that. This should not be taken lightly.<br>&gt; <br>&gt; Let&#39;s imagine that performance is important for a library that is heavily used and that the classes are not the type that you usually override. Wouldn&#39;t we be better servedby being able to seal the class, i.e. &quot;public sealed class Foo&quot;and then for the methods / properties that are clear extension points should be flaggedoverridable.I would prefer something like that. And I think it would be more intuitive.<br>&gt; <br>&gt; <br>&gt; &gt; * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; No.<br>&gt; <br>&gt; &gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt; I think it is counter-intuitive.I don&#39;t think that reading &quot;public class Foo&quot; would make anyone think that Foo is non-subclassable.<br>&gt; <br>&gt; On the other hand, reading &quot;public class sealed Foo&quot; would suggest to the reader that the class can be overridden but only the methods that are flagged asoverridable.<br>&gt; <br>&gt; If we wanted to prohibit overriding then we could use &quot;public final class Foo&quot; without any extension points. Then nobody would be able to subclass and it would be an error to try to flag a method / property as overridable.<br>&gt; <br>&gt; <br>&gt; &gt; * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; I don&#39;t recall having seen this behavior in the languages that I have worked with.<br>&gt; <br>&gt; &gt; * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; I read the whole proposal and have been thinking about the implications for a few hours.<br>&gt; <br>&gt; &gt; More information about the Swift evolution process is available at<br>&gt; &gt; <br>&gt; &gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; &gt; <br>&gt; &gt; Thank you,<br>&gt; &gt; <br>&gt; &gt; -Chris Lattner<br>&gt; &gt; Review Manager<br>&gt; &gt; <br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution-announce mailing list<br>&gt; &gt; swift-evolution-announce at swift.org(mailto:swift-evolution-announce at swift.org)<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution-announce<br>&gt; <br>&gt; <br>&gt;<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
