<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d0659d0725d0f35fa2b7d2cd23631502?s=50"></div><header><strong>[Proposal] Instance Operators</strong> from <string>Vanderlei Martinelli</string> &lt;vmartinelli at alecrim.com&gt;<p>February 25, 2016 at 04:00:00pm</p></header><div class="content"><p>Hello.<br></p><p>The proposal can be also read at<br>https://gist.github.com/vmartinelli/67d6ad234c7a4e14f8d5<br></p><p>Original thread:<br>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160125/008508.html<br></p><p>Opinions, comments and corrections (including on English grammar) are all<br>welcome. :-)<br></p><p>-Van<br></p><p>---------<br></p><p>Instance Operators<br></p><p>   - Proposal: SE-NNNN<br>   &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-instance-operators.md&gt;<br>   - Author: Vanderlei Martinelli &lt;https://github.com/vmartinelli&gt;<br>   - Status: *Awaiting review*<br>   - Review manager: TBD<br></p><p>Introduction<br></p><p>The proposal aims to move operator implementation from the global and<br>static scope into extension/struct/class instance scope.<br></p><p>Swift-evolution thread: link to the discussion thread for that proposal<br>&lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160125/008508.html&gt;<br>Motivation<br></p><p>When writing the protocol interface the operator is declarated inside the<br>scope of that protocol, but its implementation has to be static and global.<br>This, besides being inconsistent, might not the behaviour expected by<br>programmers coming from other languages that have some kind of support for<br>interface/protocol and operator implementation.<br></p><p>Example:<br></p><p>// MARK: - protocol<br>public protocol MyDoubleType {<br>    public func someUsefulFunction()<br></p><p>    public func *(lhs: Self, rhs: Self) -&gt; Self<br>    public postfix func ++(inout x: Self) -&gt; Self<br>}<br>// MARK: - implementation<br>extension Double: MyDoubleType {<br></p><p>    public func someUsefulFunction() {<br>        // ...<br>    }<br></p><p>    // we cannot implement the operators here...<br></p><p>}<br>// ... but have to implement them here<br>public func *(lhs: Double, rhs: Double) -&gt; Double {<br>    return lhs.multipliedBy(rhs)<br>}<br>public postfix func ++(inout x: Double) -&gt; Double {<br>    x += 1.0<br>    return x<br>}<br></p><p>Also the current implementation does not leave much room for future<br>expansion in the use of operators (such as conversion between values, for<br>example).<br>Proposed solution<br></p><p>Move the operator implementation into the extension/struct/class scope and<br>turn operator funcs into instance funcs, using the operator keyword.<br>Detailed designProtocol conformance<br></p><p>After the change the above code can be written like the example bellow.<br></p><p>// MARK: - protocol<br>public protocol MyDoubleType {<br>    public func someUsefulFunction()<br></p><p>    public operator *(rhs: Self) -&gt; Self<br>    public mutating postfix operator ++() -&gt; Self<br>}<br>// MARK: - implementation<br>extension Double: MyDoubleType {<br></p><p>    public func someUsefulFunction() {<br>        // ...<br>    }<br></p><p>    public operator *(rhs: Double) -&gt; Double {<br>        return self.multipliedBy(rhs)<br>    }<br></p><p>    public mutating postfix operator ++() -&gt; Double {<br>       self += 1.0<br>       return self<br>    }<br></p><p>}<br></p><p>Operator funcs everywhere<br></p><p>An operator does not have to be implemented only to conform to a protocol,<br>however. It can be also be implemented in any other place where a common<br>func is. This means that even the current form can be supported.<br>Operator internal names<br></p><p>Perhaps because of the internal implementation of Swift, operators have to<br>have names to be handled. The suggestion is to adopt<br>__operator__GreaterThanOrEqual for a &gt;= operator, as example. The operator<br>introduction would be:<br></p><p>infix operator &gt;= {<br>    associativity none<br>    precedence 130<br>    name &quot;GreaterThanOrEqual&quot;<br>}<br></p><p>So the code will be written like this...<br></p><p>struct MyStruct {<br>    operator &gt;=(other: MyStruct) -&gt; Bool {<br>        return ...<br>    }<br>}<br></p><p>... but translated internally to this:<br></p><p>struct MyStruct {<br>    func __operator__GreaterThanOrEqual(other: MyStruct) -&gt; Bool {<br>        return ...<br>    }<br>}<br></p><p>Impact on existing code<br></p><p>Since after this change an operator can be implemented in any other place<br>where a common func can be, the current implementation may continue to<br>exist, but marked as deprecated with a compiler/analyser warning.<br></p><p>Also the func keyword would be deprecated for operators as well, using the<br>operator to declare/implement an operator func.<br>Alternatives consideredStatus quo<br></p><p>Leave things as they are. Even being inconsistent or not allowing new<br>possibilities that instance operators will bring.<br>Static implementation inside extension/struct/class scope<br></p><p>This is the way operators are implemented in C#, for example. The change<br>would be only aesthetic. The functionality would remain the same as today.<br></p><p>As the types may differ from protocol/structure/class, this would allow<br>state within the scope of operators that have nothing to do with that type.<br>Not a good thing. In this case it might be better to keep things as they<br>are.<br></p><p>Example:<br></p><p>// MARK: - protocol<br>public protocol MyDoubleType {<br>    public func someUsefulFunction()<br></p><p>    public static operator *(lhs: Self, rhs: Self) -&gt; Self<br>    public static operator /(lhs: Int64, rhs: Int64) -&gt; Int64 // what?<br>    public static postfix operator ++(inout x: Self) -&gt; Self<br>}<br>// MARK: - implementation<br>extension Double: MyDoubleType {<br></p><p>    public func someUsefulFunction() {<br>        // ...<br>    }<br></p><p>    public static operator *(lhs: Double, rhs: Double) -&gt; Double {<br>        return lhs.multipliedBy(rhs)<br>    }<br></p><p>    // this should be implemented inside a Int64 type, not here...<br>    public static operator /(lhs: Int64, rhs: Int64) -&gt; Int64 {<br>        // ...<br>    }<br></p><p>    public static postfix operator ++(inout x: Double) -&gt; Double {<br>        x += 1.0<br>        return x<br>    }<br></p><p>}<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160225/37cd3271/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[Proposal] Instance Operators</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>February 25, 2016 at 01:00:00pm</p></header><div class="content"><p>If operators are not effectively final or static, then the semantics change - operators do not perform dynamic dispatch today, same as functions but different from methods.<br></p><p>see today:<br></p><p>class A :Equatable { }<br>class B : A { }<br>func == (lhs:A, rhs:A) -&gt; Bool { return true }<br>func == (lhs:B, rhs:B) -&gt; Bool { return false }<br></p><p>let b = B()<br>let a:A = b<br></p><p>a == a // true<br>b == b // false<br></p><p>-DW<br></p><p><br>&gt; On Feb 25, 2016, at 12:59 PM, Vanderlei Martinelli via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello.<br>&gt; <br>&gt; The proposal can be also read at https://gist.github.com/vmartinelli/67d6ad234c7a4e14f8d5 &lt;https://gist.github.com/vmartinelli/67d6ad234c7a4e14f8d5&gt;<br>&gt; <br>&gt; Original thread: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160125/008508.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160125/008508.html&gt;<br>&gt; <br>&gt; Opinions, comments and corrections (including on English grammar) are all welcome. :-)<br>&gt; <br>&gt; -Van<br>&gt; <br>&gt; ---------<br>&gt; <br>&gt; Instance Operators<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-instance-operators.md&gt;<br>&gt; Author: Vanderlei Martinelli &lt;https://github.com/vmartinelli&gt;<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; The proposal aims to move operator implementation from the global and static scope into extension/struct/class instance scope.<br>&gt; <br>&gt; Swift-evolution thread: link to the discussion thread for that proposal &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160125/008508.html&gt;<br>&gt; Motivation<br>&gt; <br>&gt; When writing the protocol interface the operator is declarated inside the scope of that protocol, but its implementation has to be static and global. This, besides being inconsistent, might not the behaviour expected by programmers coming from other languages that have some kind of support for interface/protocol and operator implementation.<br>&gt; <br>&gt; Example:<br>&gt; <br>&gt; // MARK: - protocol<br>&gt; <br>&gt; public protocol MyDoubleType {<br>&gt;     public func someUsefulFunction()<br>&gt; <br>&gt;     public func *(lhs: Self, rhs: Self) -&gt; Self<br>&gt;     public postfix func ++(inout x: Self) -&gt; Self<br>&gt; }<br>&gt; <br>&gt; // MARK: - implementation<br>&gt; <br>&gt; extension Double: MyDoubleType {<br>&gt; <br>&gt;     public func someUsefulFunction() {<br>&gt;         // ...<br>&gt;     }<br>&gt; <br>&gt;     // we cannot implement the operators here...<br>&gt; <br>&gt; }<br>&gt; <br>&gt; // ... but have to implement them here<br>&gt; <br>&gt; public func *(lhs: Double, rhs: Double) -&gt; Double {<br>&gt;     return lhs.multipliedBy(rhs)<br>&gt; }<br>&gt; <br>&gt; public postfix func ++(inout x: Double) -&gt; Double {<br>&gt;     x += 1.0<br>&gt;     return x<br>&gt; }<br>&gt; Also the current implementation does not leave much room for future expansion in the use of operators (such as conversion between values, for example).<br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; Move the operator implementation into the extension/struct/class scope and turn operator funcs into instance funcs, using the operator keyword.<br>&gt; <br>&gt; Detailed design<br>&gt; <br>&gt; Protocol conformance<br>&gt; <br>&gt; After the change the above code can be written like the example bellow.<br>&gt; <br>&gt; // MARK: - protocol<br>&gt; <br>&gt; public protocol MyDoubleType {<br>&gt;     public func someUsefulFunction()<br>&gt; <br>&gt;     public operator *(rhs: Self) -&gt; Self<br>&gt;     public mutating postfix operator ++() -&gt; Self<br>&gt; }<br>&gt; <br>&gt; // MARK: - implementation<br>&gt; <br>&gt; extension Double: MyDoubleType {<br>&gt; <br>&gt;     public func someUsefulFunction() {<br>&gt;         // ...<br>&gt;     }<br>&gt; <br>&gt;     public operator *(rhs: Double) -&gt; Double {<br>&gt;         return self.multipliedBy(rhs)<br>&gt;     }<br>&gt; <br>&gt;     public mutating postfix operator ++() -&gt; Double {<br>&gt;        self += 1.0<br>&gt;        return self<br>&gt;     }<br>&gt; <br>&gt; }<br>&gt; Operator funcs everywhere<br>&gt; <br>&gt; An operator does not have to be implemented only to conform to a protocol, however. It can be also be implemented in any other place where a common func is. This means that even the current form can be supported.<br>&gt; <br>&gt; Operator internal names<br>&gt; <br>&gt; Perhaps because of the internal implementation of Swift, operators have to have names to be handled. The suggestion is to adopt __operator__GreaterThanOrEqual for a &gt;= operator, as example. The operator introduction would be:<br>&gt; <br>&gt; infix operator &gt;= {<br>&gt;     associativity none<br>&gt;     precedence 130<br>&gt;     name &quot;GreaterThanOrEqual&quot;<br>&gt; }<br>&gt; So the code will be written like this...<br>&gt; <br>&gt; struct MyStruct {<br>&gt;     operator &gt;=(other: MyStruct) -&gt; Bool {<br>&gt;         return ...<br>&gt;     }<br>&gt; }<br>&gt; ... but translated internally to this:<br>&gt; <br>&gt; struct MyStruct {<br>&gt;     func __operator__GreaterThanOrEqual(other: MyStruct) -&gt; Bool {<br>&gt;         return ...<br>&gt;     }<br>&gt; }<br>&gt; Impact on existing code<br>&gt; <br>&gt; Since after this change an operator can be implemented in any other place where a common func can be, the current implementation may continue to exist, but marked as deprecated with a compiler/analyser warning.<br>&gt; <br>&gt; Also the func keyword would be deprecated for operators as well, using the operator to declare/implement an operator func.<br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; Status quo<br>&gt; <br>&gt; Leave things as they are. Even being inconsistent or not allowing new possibilities that instance operators will bring.<br>&gt; <br>&gt; Static implementation inside extension/struct/class scope<br>&gt; <br>&gt; This is the way operators are implemented in C#, for example. The change would be only aesthetic. The functionality would remain the same as today.<br>&gt; <br>&gt; As the types may differ from protocol/structure/class, this would allow state within the scope of operators that have nothing to do with that type. Not a good thing. In this case it might be better to keep things as they are.<br>&gt; <br>&gt; Example:<br>&gt; <br>&gt; // MARK: - protocol<br>&gt; <br>&gt; public protocol MyDoubleType {<br>&gt;     public func someUsefulFunction()<br>&gt; <br>&gt;     public static operator *(lhs: Self, rhs: Self) -&gt; Self<br>&gt;     public static operator /(lhs: Int64, rhs: Int64) -&gt; Int64 // what?<br>&gt;     public static postfix operator ++(inout x: Self) -&gt; Self<br>&gt; }<br>&gt; <br>&gt; // MARK: - implementation<br>&gt; <br>&gt; extension Double: MyDoubleType {<br>&gt; <br>&gt;     public func someUsefulFunction() {<br>&gt;         // ...<br>&gt;     }<br>&gt; <br>&gt;     public static operator *(lhs: Double, rhs: Double) -&gt; Double {<br>&gt;         return lhs.multipliedBy(rhs)<br>&gt;     }<br>&gt; <br>&gt;     // this should be implemented inside a Int64 type, not here...<br>&gt;     public static operator /(lhs: Int64, rhs: Int64) -&gt; Int64 {<br>&gt;         // ...<br>&gt;     }<br>&gt; <br>&gt;     public static postfix operator ++(inout x: Double) -&gt; Double {<br>&gt;         x += 1.0<br>&gt;         return x<br>&gt;     }<br>&gt; <br>&gt; }<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160225/f354f6b7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Proposal] Instance Operators</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>February 25, 2016 at 10:00:00pm</p></header><div class="content"><p>I’m a big +1 for the proposal, I hate managing operators the way they are now. In fact I tend to implement Equatable and Comparable with .equals() and .compareTo() methods in my types so that I only have to call those in the operator implementations (which coincidentally can avoid the problem you mention):<br></p><p>&gt; On 25 Feb 2016, at 20:11, David Waite via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; If operators are not effectively final or static, then the semantics change - operators do not perform dynamic dispatch today, same as functions but different from methods.<br></p><p>An important point, but this proposal does suggest keeping the current method as well for the time being, so we can have the instance form use dynamic dispatch like any other method. Personally though I think that making the transition is important as the lack of dynamic dispatch is something that can be confusing and lead to hard to find bugs; in your example the bug is pretty obvious to track down, but in more detailed implementations it may not be obvious that the type of your value is changing the behaviour for operators when it doesn’t for methods.<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Proposal] Instance Operators</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>February 25, 2016 at 03:00:00pm</p></header><div class="content"><p>I think this is a direction we want to go in, but how does this work for unary operators with a non-object type, and binary operators with a non-object LHS?<br></p><p>As DavidW said, it&#39;s important to figure out what this means for classes. (Don&#39;t forget asymmetrical operations within a class hierarchy, i.e. `A() == B()` vs. `B() == A()`.)<br></p><p>I also think you should subset out the change from &quot;func&quot; to &quot;operator&quot;. Currently &quot;func&quot; and &quot;operator&quot; mean very different things, and discussing that here is just going to muddy your intent.<br></p><p>Jordan<br></p><p><br>&gt; On Feb 25, 2016, at 11:59, Vanderlei Martinelli via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello.<br>&gt; <br>&gt; The proposal can be also read at https://gist.github.com/vmartinelli/67d6ad234c7a4e14f8d5 &lt;https://gist.github.com/vmartinelli/67d6ad234c7a4e14f8d5&gt;<br>&gt; <br>&gt; Original thread: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160125/008508.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160125/008508.html&gt;<br>&gt; <br>&gt; Opinions, comments and corrections (including on English grammar) are all welcome. :-)<br>&gt; <br>&gt; -Van<br>&gt; <br>&gt; ---------<br>&gt; <br>&gt; Instance Operators<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-instance-operators.md&gt;<br>&gt; Author: Vanderlei Martinelli &lt;https://github.com/vmartinelli&gt;<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; The proposal aims to move operator implementation from the global and static scope into extension/struct/class instance scope.<br>&gt; <br>&gt; Swift-evolution thread: link to the discussion thread for that proposal &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160125/008508.html&gt;<br>&gt; Motivation<br>&gt; <br>&gt; When writing the protocol interface the operator is declarated inside the scope of that protocol, but its implementation has to be static and global. This, besides being inconsistent, might not the behaviour expected by programmers coming from other languages that have some kind of support for interface/protocol and operator implementation.<br>&gt; <br>&gt; Example:<br>&gt; <br>&gt; // MARK: - protocol<br>&gt; <br>&gt; public protocol MyDoubleType {<br>&gt;     public func someUsefulFunction()<br>&gt; <br>&gt;     public func *(lhs: Self, rhs: Self) -&gt; Self<br>&gt;     public postfix func ++(inout x: Self) -&gt; Self<br>&gt; }<br>&gt; <br>&gt; // MARK: - implementation<br>&gt; <br>&gt; extension Double: MyDoubleType {<br>&gt; <br>&gt;     public func someUsefulFunction() {<br>&gt;         // ...<br>&gt;     }<br>&gt; <br>&gt;     // we cannot implement the operators here...<br>&gt; <br>&gt; }<br>&gt; <br>&gt; // ... but have to implement them here<br>&gt; <br>&gt; public func *(lhs: Double, rhs: Double) -&gt; Double {<br>&gt;     return lhs.multipliedBy(rhs)<br>&gt; }<br>&gt; <br>&gt; public postfix func ++(inout x: Double) -&gt; Double {<br>&gt;     x += 1.0<br>&gt;     return x<br>&gt; }<br>&gt; Also the current implementation does not leave much room for future expansion in the use of operators (such as conversion between values, for example).<br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; Move the operator implementation into the extension/struct/class scope and turn operator funcs into instance funcs, using the operator keyword.<br>&gt; <br>&gt; Detailed design<br>&gt; <br>&gt; Protocol conformance<br>&gt; <br>&gt; After the change the above code can be written like the example bellow.<br>&gt; <br>&gt; // MARK: - protocol<br>&gt; <br>&gt; public protocol MyDoubleType {<br>&gt;     public func someUsefulFunction()<br>&gt; <br>&gt;     public operator *(rhs: Self) -&gt; Self<br>&gt;     public mutating postfix operator ++() -&gt; Self<br>&gt; }<br>&gt; <br>&gt; // MARK: - implementation<br>&gt; <br>&gt; extension Double: MyDoubleType {<br>&gt; <br>&gt;     public func someUsefulFunction() {<br>&gt;         // ...<br>&gt;     }<br>&gt; <br>&gt;     public operator *(rhs: Double) -&gt; Double {<br>&gt;         return self.multipliedBy(rhs)<br>&gt;     }<br>&gt; <br>&gt;     public mutating postfix operator ++() -&gt; Double {<br>&gt;        self += 1.0<br>&gt;        return self<br>&gt;     }<br>&gt; <br>&gt; }<br>&gt; Operator funcs everywhere<br>&gt; <br>&gt; An operator does not have to be implemented only to conform to a protocol, however. It can be also be implemented in any other place where a common func is. This means that even the current form can be supported.<br>&gt; <br>&gt; Operator internal names<br>&gt; <br>&gt; Perhaps because of the internal implementation of Swift, operators have to have names to be handled. The suggestion is to adopt __operator__GreaterThanOrEqual for a &gt;= operator, as example. The operator introduction would be:<br>&gt; <br>&gt; infix operator &gt;= {<br>&gt;     associativity none<br>&gt;     precedence 130<br>&gt;     name &quot;GreaterThanOrEqual&quot;<br>&gt; }<br>&gt; So the code will be written like this...<br>&gt; <br>&gt; struct MyStruct {<br>&gt;     operator &gt;=(other: MyStruct) -&gt; Bool {<br>&gt;         return ...<br>&gt;     }<br>&gt; }<br>&gt; ... but translated internally to this:<br>&gt; <br>&gt; struct MyStruct {<br>&gt;     func __operator__GreaterThanOrEqual(other: MyStruct) -&gt; Bool {<br>&gt;         return ...<br>&gt;     }<br>&gt; }<br>&gt; Impact on existing code<br>&gt; <br>&gt; Since after this change an operator can be implemented in any other place where a common func can be, the current implementation may continue to exist, but marked as deprecated with a compiler/analyser warning.<br>&gt; <br>&gt; Also the func keyword would be deprecated for operators as well, using the operator to declare/implement an operator func.<br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; Status quo<br>&gt; <br>&gt; Leave things as they are. Even being inconsistent or not allowing new possibilities that instance operators will bring.<br>&gt; <br>&gt; Static implementation inside extension/struct/class scope<br>&gt; <br>&gt; This is the way operators are implemented in C#, for example. The change would be only aesthetic. The functionality would remain the same as today.<br>&gt; <br>&gt; As the types may differ from protocol/structure/class, this would allow state within the scope of operators that have nothing to do with that type. Not a good thing. In this case it might be better to keep things as they are.<br>&gt; <br>&gt; Example:<br>&gt; <br>&gt; // MARK: - protocol<br>&gt; <br>&gt; public protocol MyDoubleType {<br>&gt;     public func someUsefulFunction()<br>&gt; <br>&gt;     public static operator *(lhs: Self, rhs: Self) -&gt; Self<br>&gt;     public static operator /(lhs: Int64, rhs: Int64) -&gt; Int64 // what?<br>&gt;     public static postfix operator ++(inout x: Self) -&gt; Self<br>&gt; }<br>&gt; <br>&gt; // MARK: - implementation<br>&gt; <br>&gt; extension Double: MyDoubleType {<br>&gt; <br>&gt;     public func someUsefulFunction() {<br>&gt;         // ...<br>&gt;     }<br>&gt; <br>&gt;     public static operator *(lhs: Double, rhs: Double) -&gt; Double {<br>&gt;         return lhs.multipliedBy(rhs)<br>&gt;     }<br>&gt; <br>&gt;     // this should be implemented inside a Int64 type, not here...<br>&gt;     public static operator /(lhs: Int64, rhs: Int64) -&gt; Int64 {<br>&gt;         // ...<br>&gt;     }<br>&gt; <br>&gt;     public static postfix operator ++(inout x: Double) -&gt; Double {<br>&gt;         x += 1.0<br>&gt;         return x<br>&gt;     }<br>&gt; <br>&gt; }<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160225/ca662e33/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Proposal] Instance Operators</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>February 25, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On 25 Feb 2016, at 23:11, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think this is a direction we want to go in, but how does this work for unary operators with a non-object type, and binary operators with a non-object LHS?<br></p><p>These could still use the global form of the operator; actually that does raise the point though that perhaps it shouldn’t be deprecated as suggested in the proposal, but instead we should just encourage the instance form for structs and classes?<br></p><p>&gt; As DavidW said, it&#39;s important to figure out what this means for classes. (Don&#39;t forget asymmetrical operations within a class hierarchy, i.e. `A() == B()` vs. `B() == A()`.)<br></p><p>How big a problem is this in practice? Java for example just requires you to provide an equals() method, and actually that method takes an argument of Java’s Object type which is even more vacuous, but I never really found it to be problematic. In fact, thinking back on it I’m surprised that I didn’t.<br></p><p>Could we possibly provide some means of making an operator flippable? i.e- if in your example B extends A, the compiler would ensure that B, the more specific type, is always on the left hand side? Otherwise, while we can use is to test inheritance from a particular type, is there a way to test whether something is a sub-class? For example, we could implement operators such as:<br></p><p>	class Foo {<br>		func == (rhs: Foo) -&gt; Bool {<br>			if rhs isSubClassOf Foo { return rhs == self }<br>			...<br>		}<br>	}<br></p><p>Is that currently possible or would it require a new feature? Thought that would be better if the comparison could be made against Self (as sub-classes that don’t override the operator could produce horrible loops).<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160225/f3cc307b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d0659d0725d0f35fa2b7d2cd23631502?s=50"></div><header><strong>[Proposal] Instance Operators</strong> from <string>Vanderlei Martinelli</string> &lt;vmartinelli at alecrim.com&gt;<p>February 26, 2016 at 12:00:00pm</p></header><div class="content"><p>Thank you for your feedback. My comments are below:<br></p><p>On Thu, Feb 25, 2016 at 8:11 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br></p><p>&gt; I think this is a direction we want to go in, but how does this work for<br>&gt; unary operators with a non-object type, and binary operators with a<br>&gt; non-object LHS?<br>&gt;<br></p><p>I&#39;d like to see some examples regarding this.<br></p><p><br>&gt;<br>&gt; As DavidW said, it&#39;s important to figure out what this means for classes.<br>&gt; (Don&#39;t forget asymmetrical operations within a class hierarchy, i.e. `A()<br>&gt; == B()` vs. `B() == A()`.)<br>&gt;<br></p><p>I think that currently the same problem can happen or am I mistaken?<br></p><p><br>&gt;<br>&gt; I also think you should subset out the change from &quot;func&quot; to &quot;operator&quot;.<br>&gt; Currently &quot;func&quot; and &quot;operator&quot; mean very different things, and discussing<br>&gt; that here is just going to muddy your intent.<br>&gt;<br></p><p>I updated the proposal draft (<br>https://gist.github.com/vmartinelli/67d6ad234c7a4e14f8d5) to remove the<br>change from `func` to `operator` keyword. Also removed the deprecation of<br>the current pattern.<br></p><p><br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt;<br></p><p>-Van<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160226/4389f4d0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d0659d0725d0f35fa2b7d2cd23631502?s=50"></div><header><strong>[Proposal] Instance Operators</strong> from <string>Vanderlei Martinelli</string> &lt;vmartinelli at alecrim.com&gt;<p>February 26, 2016 at 12:00:00pm</p></header><div class="content"><p>Thanks for the comments and suggestions.<br></p><p>A new text for the proposal is available at<br>https://gist.github.com/vmartinelli/67d6ad234c7a4e14f8d5<br></p><p>We can continue the discussion from there.<br></p><p>-Van<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160226/ea01cb37/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d0659d0725d0f35fa2b7d2cd23631502?s=50"></div><header><strong>[Proposal] Instance Operators</strong> from <string>Vanderlei Martinelli</string> &lt;vmartinelli at alecrim.com&gt;<p>February 26, 2016 at 01:00:00pm</p></header><div class="content"><p>I mean with &quot;from there&quot;: &quot;from the current proposal text&quot;.<br></p><p>-Van<br></p><p>On Fri, Feb 26, 2016 at 12:45 PM, Vanderlei Martinelli &lt;<br>vmartinelli at alecrim.com&gt; wrote:<br></p><p>&gt; Thanks for the comments and suggestions.<br>&gt;<br>&gt; A new text for the proposal is available at<br>&gt; https://gist.github.com/vmartinelli/67d6ad234c7a4e14f8d5<br>&gt;<br>&gt; We can continue the discussion from there.<br>&gt;<br>&gt; -Van<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160226/1ce80ecb/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Proposal] Instance Operators</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>February 26, 2016 at 10:00:00am</p></header><div class="content"><p>After careful consideration, I am not sure this sort of thing is actually a change that would *actually* be an obvious improvement.<br></p><p># First Concern: Code-Organization/Ownership Issues<br></p><p>Although it is easy to see how to handle operators that have *homogenous* types — e.g. anything like `func +(lhs: T, rhs: T) -&gt; T` — it’s really unclear how a proposal like this *should* work for operators that have *heterogeneous* types — e.g. anything like `func *(lhs: T, rhs: U) -&gt; U ` (etc.).<br></p><p>Since we’re talking about operators, this isn’t really a hypothetical concern, either:<br></p><p>## Example: Vector/Matrix Operations<br></p><p>func *(lhs: Matrix4x4, rhs: Vector4) -&gt; Vector4 <br>func *(lhs: Vector4, rhs: Matrix4x4) -&gt; Vector4<br></p><p>Both operations are reasonable to define, but defining the operator as instance methods seems to leave you in a rather awkward spot:<br></p><p>- perhaps one is implemented by `Matrix4x4` and the other by `Vector4` (really odd code organization imho…)<br>- perhaps both are implemented by, say, `Matrix4x4`, but one of them is using nonstandard syntax (defeating the point of custom operators, imho)<br>- perhaps the proposal lets an operator-function declaration indicate *which* argument is `self` (new syntax/new semantics)<br></p><p>…whereas the “operators are static functions” approach makes it reasonable to have both versions defined at the same scope (and e.g. &quot;near each other”).<br></p><p>I know the specific proposal here wouldn’t eliminate the ability to define the operators as currently, but it’d be a shame to be unable to include things like the above method in protocols.<br></p><p>## Example: Scalar/Vector Operations<br></p><p>Similarly, at a more-basic level, you might *want* this:<br></p><p>protocol VectorType : Equatable {<br>  typealias Component : NumericType // if it existed<br></p><p>  // to match convention, scalars go *in front* of vectors<br>  operator *(lhs: Int, rhs: Self) -&gt; Self <br>  operator *(lhs: Self.Component, rhs: Self) -&gt; Self <br></p><p>  // but why should we not be flexible on this point?<br>  operator *(lhs: Self, rhs: Int) -&gt; Self <br>  operator *(lhs: Self, rhs: Self.Component) -&gt; Self <br>}<br></p><p>…and are we going to make `struct Vector4`’s conformance to `VectorType` contingent on the presence of extension methods on `Int` (etc.)?<br></p><p>That just seems really unintuitive and counterproductive.<br></p><p># Second Concern: Dynamic Operator Dispatch Not Really Necessary<br></p><p>What I mean is, in the use cases that come to mind for dynamic operator-dispatch. making operators dynamically-dispatched wouldnt’ actually provide any benefit over what you can achieve today with protocols.<br></p><p>EG, for `==`, consider a protocol and operators like below:<br></p><p>protocol DynamicEquatable : class {<br>  func isEqual(other: Self) -&gt; Bool<br>}<br></p><p>func ==&lt;T:DynamicEquatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>  return (lhs === rhs) || lhs.isEqual(rhs)<br>}<br></p><p>func !=&lt;T:DynamicEquatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>  return (lhs !== rhs) &amp;&amp; !lhs.isEqual(rhs)<br>}<br></p><p>…which as far as I can tell gets you back to the same place you’d be if you had a dynamically-dispatched `==` (both in terms of *what it would do* and also *what issues it would still have*).<br></p><p>Is there some (beneficial?) aspect of making `==` dynamically-dispatched that isn’t also present in the above design?<br></p><p>Are there operators for which there would be a material difference between the operator being dynamically-dispatched and the operator being defined over a protocol that has a dynamically-dispatched method providing the implementation?<br></p><p># Remark<br></p><p>For `==` in particular, you could *maybe* improve the above slightly if Swift had a way to write a where clause like `U:&gt;T` — meaning “U is a subclass of T, but not T itself” — as then you could add variants like:<br></p><p>func ==&lt;T:DynamicEquatable,U:DynamicEquatable where T:&gt;U&gt;(lhs: T, rhs: U) -&gt; Bool {<br>  return (lhs === rhs) || lhs.isEqual(rhs)<br>}<br></p><p>func ==&lt;T:DynamicEquatable,U:DynamicEquatable where U:&gt;T&gt;(lhs: T, rhs: U) -&gt; Bool {<br>  return (lhs === rhs) || rhs.isEqual(lhs)<br>}<br></p><p>…which would hopefully make a direct call into the more-derived type’s implementation of `isEqual`, which would be more-likely to contain a fast path, but even so it’s not obvious that there’s all that much of an actual win to be had here, in practice.<br></p><p>&gt; On Feb 25, 2016, at 1:59 PM, Vanderlei Martinelli via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello.<br>&gt; <br>&gt; The proposal can be also read at https://gist.github.com/vmartinelli/67d6ad234c7a4e14f8d5 &lt;https://gist.github.com/vmartinelli/67d6ad234c7a4e14f8d5&gt;<br>&gt; <br>&gt; Original thread: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160125/008508.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160125/008508.html&gt;<br>&gt; <br>&gt; Opinions, comments and corrections (including on English grammar) are all welcome. :-)<br>&gt; <br>&gt; -Van<br>&gt; <br>&gt; ---------<br>&gt; <br>&gt; Instance Operators<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-instance-operators.md&gt;<br>&gt; Author: Vanderlei Martinelli &lt;https://github.com/vmartinelli&gt;<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; The proposal aims to move operator implementation from the global and static scope into extension/struct/class instance scope.<br>&gt; <br>&gt; Swift-evolution thread: link to the discussion thread for that proposal &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160125/008508.html&gt;<br>&gt; Motivation<br>&gt; <br>&gt; When writing the protocol interface the operator is declarated inside the scope of that protocol, but its implementation has to be static and global. This, besides being inconsistent, might not the behaviour expected by programmers coming from other languages that have some kind of support for interface/protocol and operator implementation.<br>&gt; <br>&gt; Example:<br>&gt; <br>&gt; // MARK: - protocol<br>&gt; <br>&gt; public protocol MyDoubleType {<br>&gt;     public func someUsefulFunction()<br>&gt; <br>&gt;     public func *(lhs: Self, rhs: Self) -&gt; Self<br>&gt;     public postfix func ++(inout x: Self) -&gt; Self<br>&gt; }<br>&gt; <br>&gt; // MARK: - implementation<br>&gt; <br>&gt; extension Double: MyDoubleType {<br>&gt; <br>&gt;     public func someUsefulFunction() {<br>&gt;         // ...<br>&gt;     }<br>&gt; <br>&gt;     // we cannot implement the operators here...<br>&gt; <br>&gt; }<br>&gt; <br>&gt; // ... but have to implement them here<br>&gt; <br>&gt; public func *(lhs: Double, rhs: Double) -&gt; Double {<br>&gt;     return lhs.multipliedBy(rhs)<br>&gt; }<br>&gt; <br>&gt; public postfix func ++(inout x: Double) -&gt; Double {<br>&gt;     x += 1.0<br>&gt;     return x<br>&gt; }<br>&gt; Also the current implementation does not leave much room for future expansion in the use of operators (such as conversion between values, for example).<br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; Move the operator implementation into the extension/struct/class scope and turn operator funcs into instance funcs, using the operator keyword.<br>&gt; <br>&gt; Detailed design<br>&gt; <br>&gt; Protocol conformance<br>&gt; <br>&gt; After the change the above code can be written like the example bellow.<br>&gt; <br>&gt; // MARK: - protocol<br>&gt; <br>&gt; public protocol MyDoubleType {<br>&gt;     public func someUsefulFunction()<br>&gt; <br>&gt;     public operator *(rhs: Self) -&gt; Self<br>&gt;     public mutating postfix operator ++() -&gt; Self<br>&gt; }<br>&gt; <br>&gt; // MARK: - implementation<br>&gt; <br>&gt; extension Double: MyDoubleType {<br>&gt; <br>&gt;     public func someUsefulFunction() {<br>&gt;         // ...<br>&gt;     }<br>&gt; <br>&gt;     public operator *(rhs: Double) -&gt; Double {<br>&gt;         return self.multipliedBy(rhs)<br>&gt;     }<br>&gt; <br>&gt;     public mutating postfix operator ++() -&gt; Double {<br>&gt;        self += 1.0<br>&gt;        return self<br>&gt;     }<br>&gt; <br>&gt; }<br>&gt; Operator funcs everywhere<br>&gt; <br>&gt; An operator does not have to be implemented only to conform to a protocol, however. It can be also be implemented in any other place where a common func is. This means that even the current form can be supported.<br>&gt; <br>&gt; Operator internal names<br>&gt; <br>&gt; Perhaps because of the internal implementation of Swift, operators have to have names to be handled. The suggestion is to adopt __operator__GreaterThanOrEqual for a &gt;= operator, as example. The operator introduction would be:<br>&gt; <br>&gt; infix operator &gt;= {<br>&gt;     associativity none<br>&gt;     precedence 130<br>&gt;     name &quot;GreaterThanOrEqual&quot;<br>&gt; }<br>&gt; So the code will be written like this...<br>&gt; <br>&gt; struct MyStruct {<br>&gt;     operator &gt;=(other: MyStruct) -&gt; Bool {<br>&gt;         return ...<br>&gt;     }<br>&gt; }<br>&gt; ... but translated internally to this:<br>&gt; <br>&gt; struct MyStruct {<br>&gt;     func __operator__GreaterThanOrEqual(other: MyStruct) -&gt; Bool {<br>&gt;         return ...<br>&gt;     }<br>&gt; }<br>&gt; Impact on existing code<br>&gt; <br>&gt; Since after this change an operator can be implemented in any other place where a common func can be, the current implementation may continue to exist, but marked as deprecated with a compiler/analyser warning.<br>&gt; <br>&gt; Also the func keyword would be deprecated for operators as well, using the operator to declare/implement an operator func.<br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; Status quo<br>&gt; <br>&gt; Leave things as they are. Even being inconsistent or not allowing new possibilities that instance operators will bring.<br>&gt; <br>&gt; Static implementation inside extension/struct/class scope<br>&gt; <br>&gt; This is the way operators are implemented in C#, for example. The change would be only aesthetic. The functionality would remain the same as today.<br>&gt; <br>&gt; As the types may differ from protocol/structure/class, this would allow state within the scope of operators that have nothing to do with that type. Not a good thing. In this case it might be better to keep things as they are.<br>&gt; <br>&gt; Example:<br>&gt; <br>&gt; // MARK: - protocol<br>&gt; <br>&gt; public protocol MyDoubleType {<br>&gt;     public func someUsefulFunction()<br>&gt; <br>&gt;     public static operator *(lhs: Self, rhs: Self) -&gt; Self<br>&gt;     public static operator /(lhs: Int64, rhs: Int64) -&gt; Int64 // what?<br>&gt;     public static postfix operator ++(inout x: Self) -&gt; Self<br>&gt; }<br>&gt; <br>&gt; // MARK: - implementation<br>&gt; <br>&gt; extension Double: MyDoubleType {<br>&gt; <br>&gt;     public func someUsefulFunction() {<br>&gt;         // ...<br>&gt;     }<br>&gt; <br>&gt;     public static operator *(lhs: Double, rhs: Double) -&gt; Double {<br>&gt;         return lhs.multipliedBy(rhs)<br>&gt;     }<br>&gt; <br>&gt;     // this should be implemented inside a Int64 type, not here...<br>&gt;     public static operator /(lhs: Int64, rhs: Int64) -&gt; Int64 {<br>&gt;         // ...<br>&gt;     }<br>&gt; <br>&gt;     public static postfix operator ++(inout x: Double) -&gt; Double {<br>&gt;         x += 1.0<br>&gt;         return x<br>&gt;     }<br>&gt; <br>&gt; }<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160226/34797acf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>[Proposal] Instance Operators</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>February 26, 2016 at 10:00:00am</p></header><div class="content"><p>I agree with all of this. I’m not sure operators really belong *inside* of the type. IMO, attempting to include them within the type is only desirable because of the way they are declared inside of the protocol. I think the asymmetry should be addressed on that side instead (if at all).<br></p><p>l8r<br>Sean<br></p><p><br></p><p>&gt; On Feb 26, 2016, at 10:43 AM, plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; After careful consideration, I am not sure this sort of thing is actually a change that would *actually* be an obvious improvement.<br>&gt; <br>&gt; # First Concern: Code-Organization/Ownership Issues<br>&gt; <br>&gt; Although it is easy to see how to handle operators that have *homogenous* types — e.g. anything like `func +(lhs: T, rhs: T) -&gt; T` — it’s really unclear how a proposal like this *should* work for operators that have *heterogeneous* types — e.g. anything like `func *(lhs: T, rhs: U) -&gt; U ` (etc.).<br>&gt; <br>&gt; Since we’re talking about operators, this isn’t really a hypothetical concern, either:<br>&gt; <br>&gt; ## Example: Vector/Matrix Operations<br>&gt; <br>&gt; func *(lhs: Matrix4x4, rhs: Vector4) -&gt; Vector4 <br>&gt; func *(lhs: Vector4, rhs: Matrix4x4) -&gt; Vector4<br>&gt; <br>&gt; Both operations are reasonable to define, but defining the operator as instance methods seems to leave you in a rather awkward spot:<br>&gt; <br>&gt; - perhaps one is implemented by `Matrix4x4` and the other by `Vector4` (really odd code organization imho…)<br>&gt; - perhaps both are implemented by, say, `Matrix4x4`, but one of them is using nonstandard syntax (defeating the point of custom operators, imho)<br>&gt; - perhaps the proposal lets an operator-function declaration indicate *which* argument is `self` (new syntax/new semantics)<br>&gt; <br>&gt; …whereas the “operators are static functions” approach makes it reasonable to have both versions defined at the same scope (and e.g. &quot;near each other”).<br>&gt; <br>&gt; I know the specific proposal here wouldn’t eliminate the ability to define the operators as currently, but it’d be a shame to be unable to include things like the above method in protocols.<br>&gt; <br>&gt; ## Example: Scalar/Vector Operations<br>&gt; <br>&gt; Similarly, at a more-basic level, you might *want* this:<br>&gt; <br>&gt; protocol VectorType : Equatable {<br>&gt;   typealias Component : NumericType // if it existed<br>&gt; <br>&gt;   // to match convention, scalars go *in front* of vectors<br>&gt;   operator *(lhs: Int, rhs: Self) -&gt; Self <br>&gt;   operator *(lhs: Self.Component, rhs: Self) -&gt; Self <br>&gt; <br>&gt;   // but why should we not be flexible on this point?<br>&gt;   operator *(lhs: Self, rhs: Int) -&gt; Self <br>&gt;   operator *(lhs: Self, rhs: Self.Component) -&gt; Self <br>&gt; }<br>&gt; <br>&gt; …and are we going to make `struct Vector4`’s conformance to `VectorType` contingent on the presence of extension methods on `Int` (etc.)?<br>&gt; <br>&gt; That just seems really unintuitive and counterproductive.<br>&gt; <br>&gt; # Second Concern: Dynamic Operator Dispatch Not Really Necessary<br>&gt; <br>&gt; What I mean is, in the use cases that come to mind for dynamic operator-dispatch. making operators dynamically-dispatched wouldnt’ actually provide any benefit over what you can achieve today with protocols.<br>&gt; <br>&gt; EG, for `==`, consider a protocol and operators like below:<br>&gt; <br>&gt; protocol DynamicEquatable : class {<br>&gt;   func isEqual(other: Self) -&gt; Bool<br>&gt; }<br>&gt; <br>&gt; func ==&lt;T:DynamicEquatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;   return (lhs === rhs) || lhs.isEqual(rhs)<br>&gt; }<br>&gt; <br>&gt; func !=&lt;T:DynamicEquatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;   return (lhs !== rhs) &amp;&amp; !lhs.isEqual(rhs)<br>&gt; }<br>&gt; <br>&gt; …which as far as I can tell gets you back to the same place you’d be if you had a dynamically-dispatched `==` (both in terms of *what it would do* and also *what issues it would still have*).<br>&gt; <br>&gt; Is there some (beneficial?) aspect of making `==` dynamically-dispatched that isn’t also present in the above design?<br>&gt; <br>&gt; Are there operators for which there would be a material difference between the operator being dynamically-dispatched and the operator being defined over a protocol that has a dynamically-dispatched method providing the implementation?<br>&gt; <br>&gt; # Remark<br>&gt; <br>&gt; For `==` in particular, you could *maybe* improve the above slightly if Swift had a way to write a where clause like `U:&gt;T` — meaning “U is a subclass of T, but not T itself” — as then you could add variants like:<br>&gt; <br>&gt; func ==&lt;T:DynamicEquatable,U:DynamicEquatable where T:&gt;U&gt;(lhs: T, rhs: U) -&gt; Bool {<br>&gt;   return (lhs === rhs) || lhs.isEqual(rhs)<br>&gt; }<br>&gt; <br>&gt; func ==&lt;T:DynamicEquatable,U:DynamicEquatable where U:&gt;T&gt;(lhs: T, rhs: U) -&gt; Bool {<br>&gt;   return (lhs === rhs) || rhs.isEqual(lhs)<br>&gt; }<br>&gt; <br>&gt; …which would hopefully make a direct call into the more-derived type’s implementation of `isEqual`, which would be more-likely to contain a fast path, but even so it’s not obvious that there’s all that much of an actual win to be had here, in practice.<br>&gt; <br>&gt;&gt; On Feb 25, 2016, at 1:59 PM, Vanderlei Martinelli via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello.<br>&gt;&gt; <br>&gt;&gt; The proposal can be also read at https://gist.github.com/vmartinelli/67d6ad234c7a4e14f8d5<br>&gt;&gt; <br>&gt;&gt; Original thread: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160125/008508.html<br>&gt;&gt; <br>&gt;&gt; Opinions, comments and corrections (including on English grammar) are all welcome. :-)<br>&gt;&gt; <br>&gt;&gt; -Van<br>&gt;&gt; <br>&gt;&gt; ---------<br>&gt;&gt; <br>&gt;&gt; Instance Operators<br>&gt;&gt; <br>&gt;&gt; 	• Proposal: SE-NNNN<br>&gt;&gt; 	• Author: Vanderlei Martinelli<br>&gt;&gt; 	• Status: Awaiting review<br>&gt;&gt; 	• Review manager: TBD<br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; The proposal aims to move operator implementation from the global and static scope into extension/struct/class instance scope.<br>&gt;&gt; <br>&gt;&gt; Swift-evolution thread: link to the discussion thread for that proposal<br>&gt;&gt; <br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; When writing the protocol interface the operator is declarated inside the scope of that protocol, but its implementation has to be static and global. This, besides being inconsistent, might not the behaviour expected by programmers coming from other languages that have some kind of support for interface/protocol and operator implementation.<br>&gt;&gt; <br>&gt;&gt; Example:<br>&gt;&gt; <br>&gt;&gt; // MARK: - protocol<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; public protocol<br>&gt;&gt;  MyDoubleType {<br>&gt;&gt;     <br>&gt;&gt; public func someUsefulFunction<br>&gt;&gt; ()<br>&gt;&gt; <br>&gt;&gt;     <br>&gt;&gt; public func *(lhs: Self, rhs: Self) -&gt;<br>&gt;&gt;  Self<br>&gt;&gt;     <br>&gt;&gt; public postfix func ++(inout x: Self) -&gt;<br>&gt;&gt;  Self<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; // MARK: - implementation<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; extension Double<br>&gt;&gt; : MyDoubleType {<br>&gt;&gt; <br>&gt;&gt;     <br>&gt;&gt; public func someUsefulFunction<br>&gt;&gt; () {<br>&gt;&gt;         <br>&gt;&gt; // ...<br>&gt;&gt; <br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     <br>&gt;&gt; // we cannot implement the operators here...<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; // ... but have to implement them here<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; public func *(lhs: Double, rhs: Double) -&gt; Double<br>&gt;&gt;  {<br>&gt;&gt;     <br>&gt;&gt; return lhs.<br>&gt;&gt; multipliedBy(rhs)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; public postfix func ++(inout x: Double) -&gt; Double<br>&gt;&gt;  {<br>&gt;&gt;     x <br>&gt;&gt; += 1.0<br>&gt;&gt; <br>&gt;&gt;     <br>&gt;&gt; return<br>&gt;&gt;  x<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Also the current implementation does not leave much room for future expansion in the use of operators (such as conversion between values, for example).<br>&gt;&gt; <br>&gt;&gt; Proposed solution<br>&gt;&gt; <br>&gt;&gt; Move the operator implementation into the extension/struct/class scope and turn operator funcs into instance funcs, using the operator keyword.<br>&gt;&gt; <br>&gt;&gt; Detailed design<br>&gt;&gt; <br>&gt;&gt; Protocol conformance<br>&gt;&gt; <br>&gt;&gt; After the change the above code can be written like the example bellow.<br>&gt;&gt; <br>&gt;&gt; // MARK: - protocol<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; public protocol<br>&gt;&gt;  MyDoubleType {<br>&gt;&gt;     <br>&gt;&gt; public func someUsefulFunction<br>&gt;&gt; ()<br>&gt;&gt; <br>&gt;&gt;     <br>&gt;&gt; public operator *(rhs: Self) -&gt; Self<br>&gt;&gt; <br>&gt;&gt;     <br>&gt;&gt; public mutating postfix operator ++() -&gt; Self<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; // MARK: - implementation<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; extension Double<br>&gt;&gt; : MyDoubleType {<br>&gt;&gt; <br>&gt;&gt;     <br>&gt;&gt; public func someUsefulFunction<br>&gt;&gt; () {<br>&gt;&gt;         <br>&gt;&gt; // ...<br>&gt;&gt; <br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     <br>&gt;&gt; public operator *(rhs: Double) -&gt; Double<br>&gt;&gt;  {<br>&gt;&gt;         <br>&gt;&gt; return self.<br>&gt;&gt; multipliedBy(rhs)<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     <br>&gt;&gt; public mutating postfix operator ++() -&gt; Double<br>&gt;&gt;  {<br>&gt;&gt;        <br>&gt;&gt; self += 1.0<br>&gt;&gt; <br>&gt;&gt;        <br>&gt;&gt; return self<br>&gt;&gt; <br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Operator funcs everywhere<br>&gt;&gt; <br>&gt;&gt; An operator does not have to be implemented only to conform to a protocol, however. It can be also be implemented in any other place where a common func is. This means that even the current form can be supported.<br>&gt;&gt; <br>&gt;&gt; Operator internal names<br>&gt;&gt; <br>&gt;&gt; Perhaps because of the internal implementation of Swift, operators have to have names to be handled. The suggestion is to adopt __operator__GreaterThanOrEqual for a &gt;= operator, as example. The operator introduction would be:<br>&gt;&gt; <br>&gt;&gt; infix operator &gt;=<br>&gt;&gt;  {<br>&gt;&gt;     <br>&gt;&gt; associativity none<br>&gt;&gt; <br>&gt;&gt;     <br>&gt;&gt; precedence 130<br>&gt;&gt; <br>&gt;&gt;     name <br>&gt;&gt; &quot;GreaterThanOrEqual&quot;<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; So the code will be written like this...<br>&gt;&gt; <br>&gt;&gt; struct<br>&gt;&gt;  MyStruct {<br>&gt;&gt;     <br>&gt;&gt; operator &gt;=(other: MyStruct) -&gt; Bool<br>&gt;&gt;  {<br>&gt;&gt;         <br>&gt;&gt; return ...<br>&gt;&gt; <br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; ... but translated internally to this:<br>&gt;&gt; <br>&gt;&gt; struct<br>&gt;&gt;  MyStruct {<br>&gt;&gt;     <br>&gt;&gt; func __operator__GreaterThanOrEqual(other: MyStruct) -&gt; Bool<br>&gt;&gt;  {<br>&gt;&gt;         <br>&gt;&gt; return ...<br>&gt;&gt; <br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Impact on existing code<br>&gt;&gt; <br>&gt;&gt; Since after this change an operator can be implemented in any other place where a common func can be, the current implementation may continue to exist, but marked as deprecated with a compiler/analyser warning.<br>&gt;&gt; <br>&gt;&gt; Also the func keyword would be deprecated for operators as well, using the operator to declare/implement an operator func.<br>&gt;&gt; <br>&gt;&gt; Alternatives considered<br>&gt;&gt; <br>&gt;&gt; Status quo<br>&gt;&gt; <br>&gt;&gt; Leave things as they are. Even being inconsistent or not allowing new possibilities that instance operators will bring.<br>&gt;&gt; <br>&gt;&gt; Static implementation inside extension/struct/class scope<br>&gt;&gt; <br>&gt;&gt; This is the way operators are implemented in C#, for example. The change would be only aesthetic. The functionality would remain the same as today.<br>&gt;&gt; <br>&gt;&gt; As the types may differ from protocol/structure/class, this would allow state within the scope of operators that have nothing to do with that type. Not a good thing. In this case it might be better to keep things as they are.<br>&gt;&gt; <br>&gt;&gt; Example:<br>&gt;&gt; <br>&gt;&gt; // MARK: - protocol<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; public protocol<br>&gt;&gt;  MyDoubleType {<br>&gt;&gt;     <br>&gt;&gt; public func someUsefulFunction<br>&gt;&gt; ()<br>&gt;&gt; <br>&gt;&gt;     <br>&gt;&gt; public static operator *(lhs: Self, rhs: Self) -&gt; Self<br>&gt;&gt; <br>&gt;&gt;     <br>&gt;&gt; public static operator /(lhs: Int64, rhs: Int64) -&gt; Int64 // what?<br>&gt;&gt; <br>&gt;&gt;     <br>&gt;&gt; public static postfix operator ++(inout x: Self) -&gt; Self<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; // MARK: - implementation<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; extension Double<br>&gt;&gt; : MyDoubleType {<br>&gt;&gt; <br>&gt;&gt;     <br>&gt;&gt; public func someUsefulFunction<br>&gt;&gt; () {<br>&gt;&gt;         <br>&gt;&gt; // ...<br>&gt;&gt; <br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     <br>&gt;&gt; public static operator *(lhs: Double, rhs: Double) -&gt; Double<br>&gt;&gt;  {<br>&gt;&gt;         <br>&gt;&gt; return lhs.<br>&gt;&gt; multipliedBy(rhs)<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     <br>&gt;&gt; // this should be implemented inside a Int64 type, not here...<br>&gt;&gt; <br>&gt;&gt;     <br>&gt;&gt; public static operator /(lhs: Int64, rhs: Int64) -&gt; Int64<br>&gt;&gt;  {<br>&gt;&gt;         <br>&gt;&gt; // ...<br>&gt;&gt; <br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     <br>&gt;&gt; public static postfix operator ++(inout x: Double) -&gt; Double<br>&gt;&gt;  {<br>&gt;&gt;         x <br>&gt;&gt; += 1.0<br>&gt;&gt; <br>&gt;&gt;         <br>&gt;&gt; return<br>&gt;&gt;  x<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Proposal] Instance Operators</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>February 29, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; Am 26.02.2016 um 17:55 schrieb Sean Heber via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; I agree with all of this. I’m not sure operators really belong *inside* of the type. IMO, attempting to include them within the type is only desirable because of the way they are declared inside of the protocol. I think the asymmetry should be addressed on that side instead (if at all).<br></p><p>Good point! Maybe we should think about turning operators into multi-methods which are dynamically dispatched on all arguments like Dylan had. Or at least just move their declaration out of protocols.<br></p><p>-Thorsten <br></p><p>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Feb 26, 2016, at 10:43 AM, plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; After careful consideration, I am not sure this sort of thing is actually a change that would *actually* be an obvious improvement.<br>&gt;&gt; <br>&gt;&gt; # First Concern: Code-Organization/Ownership Issues<br>&gt;&gt; <br>&gt;&gt; Although it is easy to see how to handle operators that have *homogenous* types — e.g. anything like `func +(lhs: T, rhs: T) -&gt; T` — it’s really unclear how a proposal like this *should* work for operators that have *heterogeneous* types — e.g. anything like `func *(lhs: T, rhs: U) -&gt; U ` (etc.).<br>&gt;&gt; <br>&gt;&gt; Since we’re talking about operators, this isn’t really a hypothetical concern, either:<br>&gt;&gt; <br>&gt;&gt; ## Example: Vector/Matrix Operations<br>&gt;&gt; <br>&gt;&gt; func *(lhs: Matrix4x4, rhs: Vector4) -&gt; Vector4 <br>&gt;&gt; func *(lhs: Vector4, rhs: Matrix4x4) -&gt; Vector4<br>&gt;&gt; <br>&gt;&gt; Both operations are reasonable to define, but defining the operator as instance methods seems to leave you in a rather awkward spot:<br>&gt;&gt; <br>&gt;&gt; - perhaps one is implemented by `Matrix4x4` and the other by `Vector4` (really odd code organization imho…)<br>&gt;&gt; - perhaps both are implemented by, say, `Matrix4x4`, but one of them is using nonstandard syntax (defeating the point of custom operators, imho)<br>&gt;&gt; - perhaps the proposal lets an operator-function declaration indicate *which* argument is `self` (new syntax/new semantics)<br>&gt;&gt; <br>&gt;&gt; …whereas the “operators are static functions” approach makes it reasonable to have both versions defined at the same scope (and e.g. &quot;near each other”).<br>&gt;&gt; <br>&gt;&gt; I know the specific proposal here wouldn’t eliminate the ability to define the operators as currently, but it’d be a shame to be unable to include things like the above method in protocols.<br>&gt;&gt; <br>&gt;&gt; ## Example: Scalar/Vector Operations<br>&gt;&gt; <br>&gt;&gt; Similarly, at a more-basic level, you might *want* this:<br>&gt;&gt; <br>&gt;&gt; protocol VectorType : Equatable {<br>&gt;&gt;  typealias Component : NumericType // if it existed<br>&gt;&gt; <br>&gt;&gt;  // to match convention, scalars go *in front* of vectors<br>&gt;&gt;  operator *(lhs: Int, rhs: Self) -&gt; Self <br>&gt;&gt;  operator *(lhs: Self.Component, rhs: Self) -&gt; Self <br>&gt;&gt; <br>&gt;&gt;  // but why should we not be flexible on this point?<br>&gt;&gt;  operator *(lhs: Self, rhs: Int) -&gt; Self <br>&gt;&gt;  operator *(lhs: Self, rhs: Self.Component) -&gt; Self <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; …and are we going to make `struct Vector4`’s conformance to `VectorType` contingent on the presence of extension methods on `Int` (etc.)?<br>&gt;&gt; <br>&gt;&gt; That just seems really unintuitive and counterproductive.<br>&gt;&gt; <br>&gt;&gt; # Second Concern: Dynamic Operator Dispatch Not Really Necessary<br>&gt;&gt; <br>&gt;&gt; What I mean is, in the use cases that come to mind for dynamic operator-dispatch. making operators dynamically-dispatched wouldnt’ actually provide any benefit over what you can achieve today with protocols.<br>&gt;&gt; <br>&gt;&gt; EG, for `==`, consider a protocol and operators like below:<br>&gt;&gt; <br>&gt;&gt; protocol DynamicEquatable : class {<br>&gt;&gt;  func isEqual(other: Self) -&gt; Bool<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func ==&lt;T:DynamicEquatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;&gt;  return (lhs === rhs) || lhs.isEqual(rhs)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func !=&lt;T:DynamicEquatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;&gt;  return (lhs !== rhs) &amp;&amp; !lhs.isEqual(rhs)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; …which as far as I can tell gets you back to the same place you’d be if you had a dynamically-dispatched `==` (both in terms of *what it would do* and also *what issues it would still have*).<br>&gt;&gt; <br>&gt;&gt; Is there some (beneficial?) aspect of making `==` dynamically-dispatched that isn’t also present in the above design?<br>&gt;&gt; <br>&gt;&gt; Are there operators for which there would be a material difference between the operator being dynamically-dispatched and the operator being defined over a protocol that has a dynamically-dispatched method providing the implementation?<br>&gt;&gt; <br>&gt;&gt; # Remark<br>&gt;&gt; <br>&gt;&gt; For `==` in particular, you could *maybe* improve the above slightly if Swift had a way to write a where clause like `U:&gt;T` — meaning “U is a subclass of T, but not T itself” — as then you could add variants like:<br>&gt;&gt; <br>&gt;&gt; func ==&lt;T:DynamicEquatable,U:DynamicEquatable where T:&gt;U&gt;(lhs: T, rhs: U) -&gt; Bool {<br>&gt;&gt;  return (lhs === rhs) || lhs.isEqual(rhs)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func ==&lt;T:DynamicEquatable,U:DynamicEquatable where U:&gt;T&gt;(lhs: T, rhs: U) -&gt; Bool {<br>&gt;&gt;  return (lhs === rhs) || rhs.isEqual(lhs)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; …which would hopefully make a direct call into the more-derived type’s implementation of `isEqual`, which would be more-likely to contain a fast path, but even so it’s not obvious that there’s all that much of an actual win to be had here, in practice.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>[Proposal] Instance Operators</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>March  4, 2016 at 11:00:00pm</p></header><div class="content"><p>I&#39;m +1 on Nicola&#39;s suggestions.<br></p><p>Basically, remove operators from protocols, simplifying the language. This<br>doesn&#39;t prevent operators from using protocols (through generics).<br></p><p>Operators with protocols can still be defined as Nicola suggested, through<br>a regular protocol method and a generic. Symmetrical operators can use a<br>static method on the protocol if that&#39;s desirable. Swift has all the<br>functionality for this already.<br></p><p>It also doesn&#39;t have the downside of preventing operators from working on<br>things like types, tuples, etc.<br></p><p><br>On Mon, Feb 29, 2016 at 5:24 PM, Thorsten Seitz via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; Am 26.02.2016 um 17:55 schrieb Sean Heber via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt; &gt;<br>&gt; &gt; I agree with all of this. I’m not sure operators really belong *inside*<br>&gt; of the type. IMO, attempting to include them within the type is only<br>&gt; desirable because of the way they are declared inside of the protocol. I<br>&gt; think the asymmetry should be addressed on that side instead (if at all).<br>&gt;<br>&gt; Good point! Maybe we should think about turning operators into<br>&gt; multi-methods which are dynamically dispatched on all arguments like Dylan<br>&gt; had. Or at least just move their declaration out of protocols.<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt; &gt;<br>&gt; &gt; l8r<br>&gt; &gt; Sean<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On Feb 26, 2016, at 10:43 AM, plx via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; After careful consideration, I am not sure this sort of thing is<br>&gt; actually a change that would *actually* be an obvious improvement.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; # First Concern: Code-Organization/Ownership Issues<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Although it is easy to see how to handle operators that have<br>&gt; *homogenous* types — e.g. anything like `func +(lhs: T, rhs: T) -&gt; T` —<br>&gt; it’s really unclear how a proposal like this *should* work for operators<br>&gt; that have *heterogeneous* types — e.g. anything like `func *(lhs: T, rhs:<br>&gt; U) -&gt; U ` (etc.).<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Since we’re talking about operators, this isn’t really a hypothetical<br>&gt; concern, either:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; ## Example: Vector/Matrix Operations<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; func *(lhs: Matrix4x4, rhs: Vector4) -&gt; Vector4<br>&gt; &gt;&gt; func *(lhs: Vector4, rhs: Matrix4x4) -&gt; Vector4<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Both operations are reasonable to define, but defining the operator as<br>&gt; instance methods seems to leave you in a rather awkward spot:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; - perhaps one is implemented by `Matrix4x4` and the other by `Vector4`<br>&gt; (really odd code organization imho…)<br>&gt; &gt;&gt; - perhaps both are implemented by, say, `Matrix4x4`, but one of them is<br>&gt; using nonstandard syntax (defeating the point of custom operators, imho)<br>&gt; &gt;&gt; - perhaps the proposal lets an operator-function declaration indicate<br>&gt; *which* argument is `self` (new syntax/new semantics)<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; …whereas the “operators are static functions” approach makes it<br>&gt; reasonable to have both versions defined at the same scope (and e.g. &quot;near<br>&gt; each other”).<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I know the specific proposal here wouldn’t eliminate the ability to<br>&gt; define the operators as currently, but it’d be a shame to be unable to<br>&gt; include things like the above method in protocols.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; ## Example: Scalar/Vector Operations<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Similarly, at a more-basic level, you might *want* this:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; protocol VectorType : Equatable {<br>&gt; &gt;&gt;  typealias Component : NumericType // if it existed<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;  // to match convention, scalars go *in front* of vectors<br>&gt; &gt;&gt;  operator *(lhs: Int, rhs: Self) -&gt; Self<br>&gt; &gt;&gt;  operator *(lhs: Self.Component, rhs: Self) -&gt; Self<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;  // but why should we not be flexible on this point?<br>&gt; &gt;&gt;  operator *(lhs: Self, rhs: Int) -&gt; Self<br>&gt; &gt;&gt;  operator *(lhs: Self, rhs: Self.Component) -&gt; Self<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; …and are we going to make `struct Vector4`’s conformance to<br>&gt; `VectorType` contingent on the presence of extension methods on `Int`<br>&gt; (etc.)?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; That just seems really unintuitive and counterproductive.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; # Second Concern: Dynamic Operator Dispatch Not Really Necessary<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; What I mean is, in the use cases that come to mind for dynamic<br>&gt; operator-dispatch. making operators dynamically-dispatched wouldnt’<br>&gt; actually provide any benefit over what you can achieve today with protocols.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; EG, for `==`, consider a protocol and operators like below:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; protocol DynamicEquatable : class {<br>&gt; &gt;&gt;  func isEqual(other: Self) -&gt; Bool<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; func ==&lt;T:DynamicEquatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt; &gt;&gt;  return (lhs === rhs) || lhs.isEqual(rhs)<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; func !=&lt;T:DynamicEquatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt; &gt;&gt;  return (lhs !== rhs) &amp;&amp; !lhs.isEqual(rhs)<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; …which as far as I can tell gets you back to the same place you’d be if<br>&gt; you had a dynamically-dispatched `==` (both in terms of *what it would do*<br>&gt; and also *what issues it would still have*).<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Is there some (beneficial?) aspect of making `==`<br>&gt; dynamically-dispatched that isn’t also present in the above design?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Are there operators for which there would be a material difference<br>&gt; between the operator being dynamically-dispatched and the operator being<br>&gt; defined over a protocol that has a dynamically-dispatched method providing<br>&gt; the implementation?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; # Remark<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; For `==` in particular, you could *maybe* improve the above slightly if<br>&gt; Swift had a way to write a where clause like `U:&gt;T` — meaning “U is a<br>&gt; subclass of T, but not T itself” — as then you could add variants like:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; func ==&lt;T:DynamicEquatable,U:DynamicEquatable where T:&gt;U&gt;(lhs: T, rhs:<br>&gt; U) -&gt; Bool {<br>&gt; &gt;&gt;  return (lhs === rhs) || lhs.isEqual(rhs)<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; func ==&lt;T:DynamicEquatable,U:DynamicEquatable where U:&gt;T&gt;(lhs: T, rhs:<br>&gt; U) -&gt; Bool {<br>&gt; &gt;&gt;  return (lhs === rhs) || rhs.isEqual(lhs)<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; …which would hopefully make a direct call into the more-derived type’s<br>&gt; implementation of `isEqual`, which would be more-likely to contain a fast<br>&gt; path, but even so it’s not obvious that there’s all that much of an actual<br>&gt; win to be had here, in practice.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160304/e8f21c0f/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Proposal] Instance Operators</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>March  4, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On 4 Mar 2016, at 12:54, Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;m +1 on Nicola&#39;s suggestions.<br>&gt; <br>&gt; Basically, remove operators from protocols, simplifying the language. This doesn&#39;t prevent operators from using protocols (through generics).<br>&gt; <br>&gt; Operators with protocols can still be defined as Nicola suggested, through a regular protocol method and a generic. Symmetrical operators can use a static method on the protocol if that&#39;s desirable. Swift has all the functionality for this already.<br>&gt; <br>&gt; It also doesn&#39;t have the downside of preventing operators from working on things like types, tuples, etc.<br></p><p>Having thought about it I think that this a good summary of my thoughts now too; by having protocols like Equatable specify method requirements instead of operators we can get the best of both worlds without having to introduce a new syntax for specifying operators as instance-specific constructs.<br></p><p>This should be relatively simple to implement since in many ways we’re actually just getting rid of a feature, though of course the impact on code is more complex and probably not an easy one to convert automatically (as it would mean somehow pulling global == declarations into a local .equals() method and similar on affected types).<br></p><p>But I think in the long run it’s a cleaner system, and offers all the flexibility we need.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Proposal] Instance Operators</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>March  4, 2016 at 03:00:00pm</p></header><div class="content"><p>Why not do it the other way around, like this?<br>func == &lt;T: Equatable&gt; (lhs: T, rhs: T) -&gt; Bool {<br>	return T.equals(lhs, rhs)<br>}<br>&gt; On Mar 4, 2016, at 3:40 PM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; ...<br>&gt; This should be relatively simple to implement since in many ways we’re actually just getting rid of a feature, though of course the impact on code is more complex and probably not an easy one to convert automatically (as it would mean somehow pulling global == declarations into a local .equals() method and similar on affected types).<br>&gt; <br>&gt; But I think in the long run it’s a cleaner system, and offers all the flexibility we need.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Proposal] Instance Operators</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>March  4, 2016 at 10:00:00pm</p></header><div class="content"><p>Actually that’s what I was referring to; the difficulty is how to convert existing implementations of an equals operator into the new format, which means we’d probably have to just remove it from Equatable, require an equals() method then force developers to update their code.<br></p><p>i.e- if someone already has:<br></p><p>	func == (lhs:MyType, rhs:MyType) -&gt; Bool { /* Do some stuff */ }<br></p><p>It’s not clear whether it would be safe just covert that into an equals() method, removing the lhs parameter and replacing it with references to self instead. It might just be one of those changes that has to break code, but will be better in the long-run.<br></p><p>&gt; On 4 Mar 2016, at 21:53, davesweeris at mac.com wrote:<br>&gt; <br>&gt; Why not do it the other way around, like this?<br>&gt; func == &lt;T: Equatable&gt; (lhs: T, rhs: T) -&gt; Bool {<br>&gt; 	return T.equals(lhs, rhs)<br>&gt; }<br>&gt;&gt; On Mar 4, 2016, at 3:40 PM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; ...<br>&gt;&gt; This should be relatively simple to implement since in many ways we’re actually just getting rid of a feature, though of course the impact on code is more complex and probably not an easy one to convert automatically (as it would mean somehow pulling global == declarations into a local .equals() method and similar on affected types).<br>&gt;&gt; <br>&gt;&gt; But I think in the long run it’s a cleaner system, and offers all the flexibility we need.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d30e546d655d1c7ece0464791a9a90d5?s=50"></div><header><strong>[Proposal] Instance Operators</strong> from <string>Adrian Kashivskyy</string> &lt;adrian.kashivskyy at me.com&gt;<p>March  9, 2016 at 11:00:00am</p></header><div class="content"><p>I like the idea of moving operator implementations to the inner scope of a type, but I think this proposal doesn&#39;t cover all that is needed.<br></p><p>My main concern are infix operators – your proposal assumes that infix operators will always be implemented with the source on the left-hand-side:<br></p><p>&gt; public operator * (rhs: Self) -&gt; Self<br></p><p>My second concern is the internal operator symbol names:<br></p><p>&gt; __operator__GreaterThanOrEqual<br></p><p>How should the compiler generate the name for below operator if it translates `&gt;=` to `greater than or equal`?<br></p><p>&gt; infix operator &lt;**$$**&gt;&gt;<br></p><p><br></p><p>Pozdrawiam – Regards,<br>Adrian Kashivskyy<br></p><p>&gt; Wiadomość napisana przez Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; w dniu 04.03.2016, o godz. 23:49:<br>&gt; <br>&gt; Actually that’s what I was referring to; the difficulty is how to convert existing implementations of an equals operator into the new format, which means we’d probably have to just remove it from Equatable, require an equals() method then force developers to update their code.<br>&gt; <br>&gt; i.e- if someone already has:<br>&gt; <br>&gt; 	func == (lhs:MyType, rhs:MyType) -&gt; Bool { /* Do some stuff */ }<br>&gt; <br>&gt; It’s not clear whether it would be safe just covert that into an equals() method, removing the lhs parameter and replacing it with references to self instead. It might just be one of those changes that has to break code, but will be better in the long-run.<br>&gt; <br>&gt;&gt; On 4 Mar 2016, at 21:53, davesweeris at mac.com wrote:<br>&gt;&gt; <br>&gt;&gt; Why not do it the other way around, like this?<br>&gt;&gt; func == &lt;T: Equatable&gt; (lhs: T, rhs: T) -&gt; Bool {<br>&gt;&gt; 	return T.equals(lhs, rhs)<br>&gt;&gt; }<br>&gt;&gt;&gt; On Mar 4, 2016, at 3:40 PM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ...<br>&gt;&gt;&gt; This should be relatively simple to implement since in many ways we’re actually just getting rid of a feature, though of course the impact on code is more complex and probably not an easy one to convert automatically (as it would mean somehow pulling global == declarations into a local .equals() method and similar on affected types).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But I think in the long run it’s a cleaner system, and offers all the flexibility we need.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160309/fe475cac/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
