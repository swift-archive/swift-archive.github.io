<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Reconsidering SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January 28, 2016 at 10:00:00am</p></header><div class="content"><p>on Thu Jan 28 2016, Jordan Rose &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I still don&#39;t understand how value types and reference types are<br>&gt; different here. Here&#39;s a contrived &quot;confusion&quot; example (but we have<br>&gt; seen similar real-world code):<br>&gt;<br>&gt; for var element in array {<br>&gt;   if element.isNotUpToMyStandards {<br>&gt;     element = makeANewElement()<br>&gt;     // &#39;element&#39; is not stored back into &#39;array&#39;, but was meant to be.<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; This code, or rather the behavior the developer intended, is perfectly<br>&gt; reasonable. But it&#39;s exactly the same code whether there&#39;s a value<br>&gt; type or a reference type involved. I get that there are other examples<br>&gt; where this is not the case, but I can&#39;t see how those would be any<br>&gt; less confusing by adding this rule.<br></p><p>The difference between value types and reference types here is that in<br>many examples (but not this one), a reference type will hide the fact<br>that &quot;var&quot; doesn&#39;t produce writeback semantics, and the user who expects<br>writeback will only discover it much later.<br></p><p>[IMO this mis-expectation is better treated through education than<br>through language surface changes, FWIW]<br></p><p>&gt;<br>&gt; But maybe I&#39;m just too familiar with Swift, and so have trouble<br>&gt; putting myself in the shoes of a new learner.<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt;&gt; On Jan 27, 2016, at 20:45 , J. Cheyo Jimenez<br>&gt;&gt; &lt;cheyo at masters3d.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Reassigning of class objects probably occurs less than mutations of<br>&gt;&gt; structs inside `if var` or `guard var`.<br>&gt;&gt; The main reason for the removal of `if var` or `guard var`, AFAIK,<br>&gt;&gt; is that people get confuse about references.  Perhaps just limiting<br>&gt;&gt; their use for value types could then clear up the confusion.<br>&gt;&gt; example of warning. <br>&gt;&gt; &quot;&#39;if var&#39; is restricted to value types, did you mean &#39;if let&#39;?&quot;<br>&gt;&gt; <br>&gt;&gt; One of the issues is that now all comma separated optionals need to<br>&gt;&gt; be value types or offer alternative syntax.<br>&gt;&gt; <br>&gt;&gt; if var value1 = value1, ref1 = ref1 {} /// This would not work<br>&gt;&gt; <br>&gt;&gt; if var value1 = value1, let ref1 = ref1 {} /// Possible solution, notice the `let`<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Wed, Jan 27, 2016 at 8:05 PM, Jordan Rose<br>&gt;&gt; &lt;jordan_rose at apple.com<br>&gt;&gt; &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt; That doesn&#39;t make sense to me. If it&#39;s sometimes necessary to<br>&gt;&gt; reassign a struct containing a single reference, then surely it may<br>&gt;&gt; be necessary to reassign a single reference not contained in a<br>&gt;&gt; struct.<br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 26, 2016, at 20:37 , Nate Birkholz via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Seems in line with other compiler warnings.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPhone, please excuse brevity and errors<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 26, 2016, at 8:30 PM, J. Cheyo Jimenez via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Would it be confusing if `guard var ` or  `if var ` was only allowed for value types? <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Tuesday, January 26, 2016, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Tue Jan 26 2016, Tian Zhang<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;&gt;&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt; I’m also curious how most people fix “guard var” or “if var”?<br>&gt;&gt;&gt;&gt; &gt; Especially for checking a class object for protocol conformation and<br>&gt;&gt;&gt;&gt; &gt; set variable on the object?<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; like in this case,<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; if var vc = vc as? ControlPanelConfigurationProtocol {<br>&gt;&gt;&gt;&gt; &gt;&gt;         vc.servicePresentationObject = service<br>&gt;&gt;&gt;&gt; &gt;&gt;         vc.presentAsPanel = true<br>&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; become<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; if let vc = vc as? ControlPanelConfigurationProtocol {<br>&gt;&gt;&gt;&gt; &gt;&gt;         var vc = vc<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;         vc.servicePresentationObject = service<br>&gt;&gt;&gt;&gt; &gt;&gt;         vc.presentAsPanel = true<br>&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If vc has class type, you don&#39;t need the var at all.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt; I saw a few people suggest to create a method on the protocol like<br>&gt;&gt;&gt;&gt; &gt; “configureObject(...)” with all potential args and have the object to<br>&gt;&gt;&gt;&gt; &gt; figure it out but doing so I feel we’re losing the benefits offered by<br>&gt;&gt;&gt;&gt; &gt; property observation for the underlying object. Using pattern “if let”<br>&gt;&gt;&gt;&gt; &gt; with a “var” in the block just to make the property mutable again<br>&gt;&gt;&gt;&gt; &gt; feels really strange.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; Best Wishes,<br>&gt;&gt;&gt;&gt; &gt; Tian<br>&gt;&gt;&gt;&gt; &gt;&gt; An alternative would certainly be interesting but I would prefer to<br>&gt;&gt;&gt;&gt; &gt;&gt; take it one step at a time and avoid being hasty so we can come up<br>&gt;&gt;&gt;&gt; &gt;&gt; with something really great. What did most of your var fixes look<br>&gt;&gt;&gt;&gt; &gt;&gt; like, by the way? Did you end up changing the layout of your value<br>&gt;&gt;&gt;&gt; &gt;&gt; types or did you decide to add more vars?<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; David<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt; On Jan 24, 2016, at 7:19 PM, Zach Waldowski via swift-evolution<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt; &lt;swift-evolution at swift.org &lt;http://swift.org/&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt; -1<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt; Having already adopted the syntax in my projects in anticipation of 2.2,<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt; the increase in clarity at the expense of terseness is appreciated. A<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt; proposal should not be discussing an alternative, not a rollback.<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt; Cheers!<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt; Zachary Waldowski<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt; zach at waldowski.me &lt;http://waldowski.me/&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt; On Fri, Jan 22, 2016, at 12:26 PM, David Farler via swift-evolution<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; Hello everyone,<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; I&#39;d like to reconsider SE-0003 for Swift 3 and propose cancelling the<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; change in its entirety. After collecting feedback since Swift&#39;s open<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; source launch, I no longer feel this is a good move and there are a few<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; reasons why.<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; There are two main patterns that the removal penalizes:<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; - Get-Modify-Reassign<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; - Get-Modify-Return<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; I&#39;ve found that many of the problems with this proposal stem from the<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; uses before and after the &quot;Modify&quot; part, before returning or reassigning<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; with the new value.<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; I&#39;ve seen a few common responses to the var removal. Consider a<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; `Rectangle` struct:<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; struct Rectangle {<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; var origin: (x: Double, y: Double)<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; var size: (width: Double, height: Double)<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; Even with mutable variables `origin` and `size`, this pattern would be<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; impossible:<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; var selection = getRectangularSelection()<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; if var rect = selection?.rect {<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; // Mutate `rect` ...<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; selection.rect = rect<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; So, one might shadow the variable, which is not ideal:<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; var selection = getRectangularSelection()<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; if let rect = selection?.rect {<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; var rect = rect // Not so great<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; // Mutate `rect` ...<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; selection.rect = rect<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; Or, you might make a transformation function on `Rect`:<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; struct Rectangle {<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; var origin: (x: Double, y: Double)<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; var size: (width: Double, height: Double)<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; func withOrigin(x: Double, y: Double) -&gt; Rect {<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt;   var r = self<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt;   r.origin = (x, y)<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt;   return r<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; This is a much better solution than shadowing but you would need one of<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; these for any property that you want to mutate and I think you&#39;ll agree<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; that it doesn&#39;t scale with the language we have today. This response begs<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; for a kind of initializer that takes all of the fields of the original<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; struct except any that you want to override:<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; if let rect = selection?.rect.with(origin: newOrigin) {<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; // ...<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; Straw syntax, but maybe you&#39;ll see something along these lines on<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; swift-evolution in the future, which would provide a clear alternative to<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; direct mutation patterns. Even then, I think having complementary<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; patterns in the language isn&#39;t a bad thing.<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; These problems come up with the other variable bindings but the one that<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; ended up bothering me the most was `guard var`:<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; func transform(selection: Rect?) {<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; guard let rect = selection else { return }<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; var _rect = rect<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; // Mutate `_rect` ...<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; One of the guard statement&#39;s main purposes is to conditionally bind a<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; value as a peer in its own scope, not an inner scope like if statements.<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; Not having var makes the guard statement much weaker.<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; There is certainly a bit of confusion about the nuances between value and<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; reference semantics, who owns a value and when, how effects are<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; propagated back to values, but I think we can attack the problem with<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; more finesse.<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; Value types are one of the attractive features of Swift – because of<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; their semantics, mutating algorithms are written in a familiar style but<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; keeping effects limited to your unique reference. I don&#39;t think we should<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; give that up now to address confusion about semantics, out of principle,<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; or in anticipation of new language features. I propose cancelling this<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; change for Swift 3 and continue to allow `var` in the grammar everywhere<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; it occurs in Swift 2.2.<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; Regards,<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; David<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;http://swift.org/&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt; swift-evolution at swift.org &lt;http://swift.org/&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; &gt;&gt; &gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;&gt;<br>&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; &gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>-Dave<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
