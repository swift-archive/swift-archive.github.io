<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/91c88f3ed8bc9a8164f281098c03059b?s=50"></div><header><strong>Add stableSort() to the standard library.</strong> from <string>Davide Italiano</string> &lt;dccitaliano at gmail.com&gt;<p>January 10, 2016 at 06:00:00pm</p></header><div class="content"><p>Feedback very appreciated.<br></p><p>Add stableSort() to the standard library.<br></p><p>####<br>Introduction<br>####<br>At the time of writing the Swift standard library provides two way two<br>different versions of sort.<br>The first one is sort(), which provides a regular unstable[1] sorting algorithm.<br>The second one, sortInPlace(), which also provides unstable sorting with the<br>additional guarantee that the algorithm will operate in-place, i.e., it will<br>use only a constant amount of extra space (independent from the input size).<br>The aim of this proposal is to implement a third variant, stableSort(), in order<br>to provide a stable version of sorting.<br></p><p>####<br>Motivation<br>####<br>Stable sorting is useful when sorting lists by multiple keys<br>(primary/secondary). A classical example is provided in [2].<br>Other programming languages, e.g. C++ or Go provide interfaces for stable<br>sorting in their standard libraries (respective std::stable_sort and Stable()).<br></p><p>#####<br>Proposed solution<br>#####<br>The API proposed just mirrors the one of regular sort().<br></p><p>@warn_unused_result func stableSort() -&gt; [Self.Generator.Element]<br>Return an Array containing the sorted elements of source.<br></p><p>Discussion<br>The sorting algorithm is stable (does not change the relative order of elements<br>that compare equal).<br></p><p>Requires: The less-than operator (func &lt;) defined in the Comparable conformance<br>is a strict weak ordering over the elements in self.<br></p><p>Constraints<br>Self.Generator.Element : Comparable<br></p><p>#####<br>Impact on existing code<br>#####<br>None.<br></p><p>####<br>Alternatives considered<br>####<br>An alternative would be that of augmenting sort() to get a Bool as argument<br>(stable: True). I&#39;d rather like better to mirror what almost every<br>other programming<br>language does (providing a separate API).<br>It&#39;s an API breaking change (I think, but I&#39;m not entirely sure).<br></p><p>####<br>Open questions<br>####<br>Should we also provide a stableSortInPlace() implementation?<br></p><p><br>Notes:<br></p><p>[1] A sorting algorithm is said to be &quot;stable&quot; if it maintains in the output<br>the relative order of entries with equal keys, and &quot;unstable&quot; otherwise.<br>[2] http://stackoverflow.com/questions/808617/what-is-the-benefit-for-a-sort-algorithm-to-be-stable/808658#808658<br></p><p>Thanks,<br></p><p>--<br>Davide<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9f3e3f9871fd088e42df4509aa724367?s=50"></div><header><strong>Add stableSort() to the standard library.</strong> from <string>Adriano Ferreira</string> &lt;adriano.ferreira at me.com&gt;<p>January 10, 2016 at 09:00:00pm</p></header><div class="content"><p>Perhaps instead of declaring new functions, just pass the `stability option` as a parameter to `sort` and `sortInPlace`. Makes sense?<br></p><p>Best,<br></p><p>— A<br></p><p>&gt; On Jan 10, 2016, at 6:11 PM, Davide Italiano via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Feedback very appreciated.<br>&gt; <br>&gt; Add stableSort() to the standard library.<br>&gt; <br>&gt; ####<br>&gt; Introduction<br>&gt; ####<br>&gt; At the time of writing the Swift standard library provides two way two<br>&gt; different versions of sort.<br>&gt; The first one is sort(), which provides a regular unstable[1] sorting algorithm.<br>&gt; The second one, sortInPlace(), which also provides unstable sorting with the<br>&gt; additional guarantee that the algorithm will operate in-place, i.e., it will<br>&gt; use only a constant amount of extra space (independent from the input size).<br>&gt; The aim of this proposal is to implement a third variant, stableSort(), in order<br>&gt; to provide a stable version of sorting.<br>&gt; <br>&gt; ####<br>&gt; Motivation<br>&gt; ####<br>&gt; Stable sorting is useful when sorting lists by multiple keys<br>&gt; (primary/secondary). A classical example is provided in [2].<br>&gt; Other programming languages, e.g. C++ or Go provide interfaces for stable<br>&gt; sorting in their standard libraries (respective std::stable_sort and Stable()).<br>&gt; <br>&gt; #####<br>&gt; Proposed solution<br>&gt; #####<br>&gt; The API proposed just mirrors the one of regular sort().<br>&gt; <br>&gt; @warn_unused_result func stableSort() -&gt; [Self.Generator.Element]<br>&gt; Return an Array containing the sorted elements of source.<br>&gt; <br>&gt; Discussion<br>&gt; The sorting algorithm is stable (does not change the relative order of elements<br>&gt; that compare equal).<br>&gt; <br>&gt; Requires: The less-than operator (func &lt;) defined in the Comparable conformance<br>&gt; is a strict weak ordering over the elements in self.<br>&gt; <br>&gt; Constraints<br>&gt; Self.Generator.Element : Comparable<br>&gt; <br>&gt; #####<br>&gt; Impact on existing code<br>&gt; #####<br>&gt; None.<br>&gt; <br>&gt; ####<br>&gt; Alternatives considered<br>&gt; ####<br>&gt; An alternative would be that of augmenting sort() to get a Bool as argument<br>&gt; (stable: True). I&#39;d rather like better to mirror what almost every<br>&gt; other programming<br>&gt; language does (providing a separate API).<br>&gt; It&#39;s an API breaking change (I think, but I&#39;m not entirely sure).<br>&gt; <br>&gt; ####<br>&gt; Open questions<br>&gt; ####<br>&gt; Should we also provide a stableSortInPlace() implementation?<br>&gt; <br>&gt; <br>&gt; Notes:<br>&gt; <br>&gt; [1] A sorting algorithm is said to be &quot;stable&quot; if it maintains in the output<br>&gt; the relative order of entries with equal keys, and &quot;unstable&quot; otherwise.<br>&gt; [2] http://stackoverflow.com/questions/808617/what-is-the-benefit-for-a-sort-algorithm-to-be-stable/808658#808658<br>&gt; <br>&gt; Thanks,<br>&gt; <br>&gt; --<br>&gt; Davide<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/91c88f3ed8bc9a8164f281098c03059b?s=50"></div><header><strong>Add stableSort() to the standard library.</strong> from <string>Davide Italiano</string> &lt;dccitaliano at gmail.com&gt;<p>January 10, 2016 at 09:00:00pm</p></header><div class="content"><p>On Sun, Jan 10, 2016 at 9:39 PM, Adriano Ferreira<br>&lt;adriano.ferreira at me.com&gt; wrote:<br>&gt; Perhaps instead of declaring new functions, just pass the `stability option` as a parameter to `sort` and `sortInPlace`. Makes sense?<br>&gt;<br></p><p>It does. In fact, as you may see, I proposed that as &#39;alternative<br>considered&#39;. I&#39;m not completely sure about API/ABI stability<br>consequences, so I left that as an option.<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0089229ece6e648767cff4dc6c6d38ab?s=50"></div><header><strong>Add stableSort() to the standard library.</strong> from <string>Charles Kissinger</string> &lt;crk at akkyra.com&gt;<p>January 10, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Jan 10, 2016, at 3:11 PM, Davide Italiano via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Add stableSort() to the standard library.<br>I am in favor of this. I have a use for it.<br></p><p>&gt; An alternative would be that of augmenting sort() to get a Bool as argument<br>&gt; (stable: True).<br>This approach, probably with a default of stable: Bool = false, might be more in line with the latest API guidelines. I kind of prefer separate functions myself.<br></p><p>&gt; Should we also provide a stableSortInPlace() implementation?<br></p><p>Definitely! It doesn’t make sense to have a mutating version of the unstable sort but not a corresponding mutating stable sort.<br></p><p>-CK<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Add stableSort() to the standard library.</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>January 10, 2016 at 07:00:00pm</p></header><div class="content"><p>On Sun, Jan 10, 2016 at 3:11 PM, Davide Italiano &lt;dccitaliano at gmail.com&gt; wrote:<br>&gt; Feedback very appreciated.<br>&gt;<br>&gt; Add stableSort() to the standard library.<br></p><p>Thank you for the proposal!  It is much appreciated!<br></p><p>&gt; ####<br>&gt; Introduction<br>&gt; ####<br>&gt; At the time of writing the Swift standard library provides two way two<br>&gt; different versions of sort.<br>&gt; The first one is sort(), which provides a regular unstable[1] sorting algorithm.<br>&gt; The second one, sortInPlace(), which also provides unstable sorting with the<br>&gt; additional guarantee that the algorithm will operate in-place, i.e., it will<br>&gt; use only a constant amount of extra space (independent from the input size).<br>&gt; The aim of this proposal is to implement a third variant, stableSort(), in order<br>&gt; to provide a stable version of sorting.<br>&gt;<br>&gt; ####<br>&gt; Motivation<br>&gt; ####<br>&gt; Stable sorting is useful when sorting lists by multiple keys<br>&gt; (primary/secondary). A classical example is provided in [2].<br>&gt; Other programming languages, e.g. C++ or Go provide interfaces for stable<br>&gt; sorting in their standard libraries (respective std::stable_sort and Stable()).<br>&gt;<br>&gt; #####<br>&gt; Proposed solution<br>&gt; #####<br>&gt; The API proposed just mirrors the one of regular sort().<br>&gt;<br>&gt; @warn_unused_result func stableSort() -&gt; [Self.Generator.Element]<br>&gt; Return an Array containing the sorted elements of source.<br>&gt;<br>&gt; Discussion<br>&gt; The sorting algorithm is stable (does not change the relative order of elements<br>&gt; that compare equal).<br>&gt;<br>&gt; Requires: The less-than operator (func &lt;) defined in the Comparable conformance<br>&gt; is a strict weak ordering over the elements in self.<br>&gt;<br>&gt; Constraints<br>&gt; Self.Generator.Element : Comparable<br></p><p>We should also add an overload that takes a comparator closure.<br></p><p>&gt; #####<br>&gt; Impact on existing code<br>&gt; #####<br>&gt; None.<br>&gt;<br>&gt; ####<br>&gt; Alternatives considered<br>&gt; ####<br>&gt; An alternative would be that of augmenting sort() to get a Bool as argument<br>&gt; (stable: True). I&#39;d rather like better to mirror what almost every<br>&gt; other programming<br>&gt; language does (providing a separate API).<br>&gt; It&#39;s an API breaking change (I think, but I&#39;m not entirely sure).<br></p><p>I have been thinking about this, and even though other languages it is<br>a separate function, since the fundamental operation of sort() and<br>stableSort() seems sufficiently similar to me, the defaulted parameter<br>seems like the right thing to do.  What other parameters could sort()<br>conceivably get in future?  Should the parameter be a boolean flag or<br>a resilient option set?  Foundation has NSSortOptions, which has just<br>&quot;Stable&quot; and &quot;Concurrent&quot;.  The &quot;concurrent&quot; part, in my opinion,<br>needs to be handled somehow for all algorithms in a consistent manner,<br>rather than adding flags for each API separately.<br></p><p>&gt; ####<br>&gt; Open questions<br>&gt; ####<br>&gt; Should we also provide a stableSortInPlace() implementation?<br></p><p>Absolutely!<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/91c88f3ed8bc9a8164f281098c03059b?s=50"></div><header><strong>Add stableSort() to the standard library.</strong> from <string>Davide Italiano</string> &lt;dccitaliano at gmail.com&gt;<p>January 10, 2016 at 10:00:00pm</p></header><div class="content"><p>On Sun, Jan 10, 2016 at 10:39 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; On Sun, Jan 10, 2016 at 3:11 PM, Davide Italiano &lt;dccitaliano at gmail.com&gt; wrote:<br>&gt;&gt; Feedback very appreciated.<br>&gt;&gt;<br>&gt;&gt; Add stableSort() to the standard library.<br>&gt;<br>&gt; Thank you for the proposal!  It is much appreciated!<br>&gt;<br>&gt;&gt; ####<br>&gt;&gt; Introduction<br>&gt;&gt; ####<br>&gt;&gt; At the time of writing the Swift standard library provides two way two<br>&gt;&gt; different versions of sort.<br>&gt;&gt; The first one is sort(), which provides a regular unstable[1] sorting algorithm.<br>&gt;&gt; The second one, sortInPlace(), which also provides unstable sorting with the<br>&gt;&gt; additional guarantee that the algorithm will operate in-place, i.e., it will<br>&gt;&gt; use only a constant amount of extra space (independent from the input size).<br>&gt;&gt; The aim of this proposal is to implement a third variant, stableSort(), in order<br>&gt;&gt; to provide a stable version of sorting.<br>&gt;&gt;<br>&gt;&gt; ####<br>&gt;&gt; Motivation<br>&gt;&gt; ####<br>&gt;&gt; Stable sorting is useful when sorting lists by multiple keys<br>&gt;&gt; (primary/secondary). A classical example is provided in [2].<br>&gt;&gt; Other programming languages, e.g. C++ or Go provide interfaces for stable<br>&gt;&gt; sorting in their standard libraries (respective std::stable_sort and Stable()).<br>&gt;&gt;<br>&gt;&gt; #####<br>&gt;&gt; Proposed solution<br>&gt;&gt; #####<br>&gt;&gt; The API proposed just mirrors the one of regular sort().<br>&gt;&gt;<br>&gt;&gt; @warn_unused_result func stableSort() -&gt; [Self.Generator.Element]<br>&gt;&gt; Return an Array containing the sorted elements of source.<br>&gt;&gt;<br>&gt;&gt; Discussion<br>&gt;&gt; The sorting algorithm is stable (does not change the relative order of elements<br>&gt;&gt; that compare equal).<br>&gt;&gt;<br>&gt;&gt; Requires: The less-than operator (func &lt;) defined in the Comparable conformance<br>&gt;&gt; is a strict weak ordering over the elements in self.<br>&gt;&gt;<br>&gt;&gt; Constraints<br>&gt;&gt; Self.Generator.Element : Comparable<br>&gt;<br>&gt; We should also add an overload that takes a comparator closure.<br>&gt;<br>&gt;&gt; #####<br>&gt;&gt; Impact on existing code<br>&gt;&gt; #####<br>&gt;&gt; None.<br>&gt;&gt;<br>&gt;&gt; ####<br>&gt;&gt; Alternatives considered<br>&gt;&gt; ####<br>&gt;&gt; An alternative would be that of augmenting sort() to get a Bool as argument<br>&gt;&gt; (stable: True). I&#39;d rather like better to mirror what almost every<br>&gt;&gt; other programming<br>&gt;&gt; language does (providing a separate API).<br>&gt;&gt; It&#39;s an API breaking change (I think, but I&#39;m not entirely sure).<br>&gt;<br>&gt; I have been thinking about this, and even though other languages it is<br>&gt; a separate function, since the fundamental operation of sort() and<br>&gt; stableSort() seems sufficiently similar to me, the defaulted parameter<br>&gt; seems like the right thing to do.  What other parameters could sort()<br>&gt; conceivably get in future?  Should the parameter be a boolean flag or<br>&gt; a resilient option set?  Foundation has NSSortOptions, which has just<br>&gt; &quot;Stable&quot; and &quot;Concurrent&quot;.  The &quot;concurrent&quot; part, in my opinion,<br>&gt; needs to be handled somehow for all algorithms in a consistent manner,<br>&gt; rather than adding flags for each API separately.<br>&gt;<br>&gt;&gt; ####<br>&gt;&gt; Open questions<br>&gt;&gt; ####<br>&gt;&gt; Should we also provide a stableSortInPlace() implementation?<br>&gt;<br>&gt; Absolutely!<br>&gt;<br>&gt; Dmitri<br>&gt;<br>&gt; --<br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p><p>So, thank you all for the feedback.<br>I&#39;ll refine this proposal further, but I have a question.<br>Should we continue here (and I should paste a new version of the<br>proposal) -- or should I submit a new pull request to<br>apple/swift-evolution on github so that interested parties can comment<br>there?<br></p><p>Thanks,<br></p><p>--<br>Davide<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Add stableSort() to the standard library.</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>January 10, 2016 at 07:00:00pm</p></header><div class="content"><p>On Sun, Jan 10, 2016 at 7:45 PM, Davide Italiano &lt;dccitaliano at gmail.com&gt; wrote:<br>&gt; So, thank you all for the feedback.<br>&gt; I&#39;ll refine this proposal further, but I have a question.<br>&gt; Should we continue here (and I should paste a new version of the<br>&gt; proposal) -- or should I submit a new pull request to<br>&gt; apple/swift-evolution on github so that interested parties can comment<br>&gt; there?<br></p><p>The general rule is that discussions should happen on the mailing<br>list, so we should continue here.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a6a2eebe83a60a4b42395145484cda15?s=50"></div><header><strong>Add stableSort() to the standard library.</strong> from <string>Daniel Vollmer</string> &lt;lists at maven.de&gt;<p>January 11, 2016 at 04:00:00pm</p></header><div class="content"><p>Hello,<br></p><p>&gt; On 11 Jan 2016, at 04:39, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>[snip]<br></p><p>&gt; I have been thinking about this, and even though other languages it is<br>&gt; a separate function, since the fundamental operation of sort() and<br>&gt; stableSort() seems sufficiently similar to me, the defaulted parameter<br>&gt; seems like the right thing to do.  What other parameters could sort()<br>&gt; conceivably get in future?  Should the parameter be a boolean flag or<br>&gt; a resilient option set?<br></p><p>Whether a sort should be stable or not doesn’t really strike me as a (variable) parameter (i.e. context of the sort() call determines whether a stable sort is needed). I would also assume that the algorithms implemented would be different for stable vs. unstable (unless of course unstable sort is implemented in terms of stable sort). Both of these would make me (very slightly) prefer separate methods.<br></p><p>That being said, once additional variations / flags come into play, it seems like a bad idea to have distinct methods for all compile-time fixed “parameter”-combinations.<br></p><p>*shrug*<br></p><p>	Daniel.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Add stableSort() to the standard library.</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>January 11, 2016 at 08:00:00am</p></header><div class="content"><p>On Mon, Jan 11, 2016 at 7:40 AM, Daniel Vollmer via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Hello,<br>&gt;<br>&gt;&gt; On 11 Jan 2016, at 04:39, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; [snip]<br>&gt;<br>&gt;&gt; I have been thinking about this, and even though other languages it is<br>&gt;&gt; a separate function, since the fundamental operation of sort() and<br>&gt;&gt; stableSort() seems sufficiently similar to me, the defaulted parameter<br>&gt;&gt; seems like the right thing to do.  What other parameters could sort()<br>&gt;&gt; conceivably get in future?  Should the parameter be a boolean flag or<br>&gt;&gt; a resilient option set?<br>&gt;<br>&gt; Whether a sort should be stable or not doesn’t really strike me as a (variable) parameter (i.e. context of the sort() call determines whether a stable sort is needed).<br></p><p>Yes, I understand this.  However, consider other cases when you would<br>typically pass a constant at the call site --<br>Array.removeAll(keepCapacity:), for example.  The &#39;keepCapacity&#39;<br>argument is typically a constant.  Do you feel like this API would be<br>better expressed as two methods?<br></p><p>&gt; I would also assume that the algorithms implemented would be different for stable vs. unstable (unless of course unstable sort is implemented in terms of stable sort).<br></p><p>Also true, but even the unstable sort will check the array length and<br>use different implementations based on that.  So while a naive<br>implementation of `sort(stable:)` will only check the flag and switch<br>algorithms based on that, the implementation used in practice will be<br>more complex.<br></p><p>But, one thing that we need to ensure is that the generic specializer<br>and inliner are good enough to not produce extra code bloat for the<br>case when `sort(stable:)` is passed a constant.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/91c88f3ed8bc9a8164f281098c03059b?s=50"></div><header><strong>Add stableSort() to the standard library.</strong> from <string>Davide Italiano</string> &lt;dccitaliano at gmail.com&gt;<p>January 11, 2016 at 10:00:00am</p></header><div class="content"><p>On Sun, Jan 10, 2016 at 7:39 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; On Sun, Jan 10, 2016 at 3:11 PM, Davide Italiano &lt;dccitaliano at gmail.com&gt; wrote:<br>&gt;&gt; Feedback very appreciated.<br>&gt;&gt;<br>&gt;&gt; Add stableSort() to the standard library.<br>&gt;<br>&gt; Thank you for the proposal!  It is much appreciated!<br>&gt;<br>&gt;&gt; ####<br>&gt;&gt; Introduction<br>&gt;&gt; ####<br>&gt;&gt; At the time of writing the Swift standard library provides two way two<br>&gt;&gt; different versions of sort.<br>&gt;&gt; The first one is sort(), which provides a regular unstable[1] sorting algorithm.<br>&gt;&gt; The second one, sortInPlace(), which also provides unstable sorting with the<br>&gt;&gt; additional guarantee that the algorithm will operate in-place, i.e., it will<br>&gt;&gt; use only a constant amount of extra space (independent from the input size).<br>&gt;&gt; The aim of this proposal is to implement a third variant, stableSort(), in order<br>&gt;&gt; to provide a stable version of sorting.<br>&gt;&gt;<br>&gt;&gt; ####<br>&gt;&gt; Motivation<br>&gt;&gt; ####<br>&gt;&gt; Stable sorting is useful when sorting lists by multiple keys<br>&gt;&gt; (primary/secondary). A classical example is provided in [2].<br>&gt;&gt; Other programming languages, e.g. C++ or Go provide interfaces for stable<br>&gt;&gt; sorting in their standard libraries (respective std::stable_sort and Stable()).<br>&gt;&gt;<br>&gt;&gt; #####<br>&gt;&gt; Proposed solution<br>&gt;&gt; #####<br>&gt;&gt; The API proposed just mirrors the one of regular sort().<br>&gt;&gt;<br>&gt;&gt; @warn_unused_result func stableSort() -&gt; [Self.Generator.Element]<br>&gt;&gt; Return an Array containing the sorted elements of source.<br>&gt;&gt;<br>&gt;&gt; Discussion<br>&gt;&gt; The sorting algorithm is stable (does not change the relative order of elements<br>&gt;&gt; that compare equal).<br>&gt;&gt;<br>&gt;&gt; Requires: The less-than operator (func &lt;) defined in the Comparable conformance<br>&gt;&gt; is a strict weak ordering over the elements in self.<br>&gt;&gt;<br>&gt;&gt; Constraints<br>&gt;&gt; Self.Generator.Element : Comparable<br>&gt;<br>&gt; We should also add an overload that takes a comparator closure.<br>&gt;<br>&gt;&gt; #####<br>&gt;&gt; Impact on existing code<br>&gt;&gt; #####<br>&gt;&gt; None.<br>&gt;&gt;<br>&gt;&gt; ####<br>&gt;&gt; Alternatives considered<br>&gt;&gt; ####<br>&gt;&gt; An alternative would be that of augmenting sort() to get a Bool as argument<br>&gt;&gt; (stable: True). I&#39;d rather like better to mirror what almost every<br>&gt;&gt; other programming<br>&gt;&gt; language does (providing a separate API).<br>&gt;&gt; It&#39;s an API breaking change (I think, but I&#39;m not entirely sure).<br>&gt;<br>&gt; I have been thinking about this, and even though other languages it is<br>&gt; a separate function, since the fundamental operation of sort() and<br>&gt; stableSort() seems sufficiently similar to me, the defaulted parameter<br>&gt; seems like the right thing to do.  What other parameters could sort()<br>&gt; conceivably get in future?  Should the parameter be a boolean flag or<br>&gt; a resilient option set?  Foundation has NSSortOptions, which has just<br>&gt; &quot;Stable&quot; and &quot;Concurrent&quot;.  The &quot;concurrent&quot; part, in my opinion,<br>&gt; needs to be handled somehow for all algorithms in a consistent manner,<br>&gt; rather than adding flags for each API separately.<br>&gt;<br></p><p>I think you convinced me that passing a parameter to sort() is the<br>right way to go. About NSortOptions -- I&#39;m not completely sure<br>(still).<br>I think it largely depends on the number of options we want to<br>provide, and I see pro/cons in both the approaches.<br></p><p>* If we change sort to take a Bool as argument, and then suddenly<br>realize we need another option (as you noted, Concurrent), then we<br>need to break the API again and make that more verbose. If the number<br>of options grows under a certain number the verboseness of the API<br>might start becoming a problem (although I don&#39;t think this is the<br>case for sort()).<br></p><p>* If we change sort to take NSOptions -- and then the number of<br>options to pass doesn&#39;t grow (in the worst, somewhat terrible case, we<br>don&#39;t introduce any other options other than `stable`), then we lose<br>in usability. It&#39;s sort of goofy providing an API with Options which<br>take a single option.<br></p><p>So, my preference is for passing a Bool to sort(), and *eventually*<br>re-evaluate if needed. I think my guiding principle is trying to not<br>violate the YAGNI/KISS principles. But I&#39;m open to comments if<br>somebody disagrees =)<br></p><p>Thanks!<br></p><p>--<br>Davide<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Add stableSort() to the standard library.</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>January 11, 2016 at 11:00:00am</p></header><div class="content"><p>On Mon, Jan 11, 2016 at 10:26 AM, Davide Italiano &lt;dccitaliano at gmail.com&gt; wrote:<br>&gt; So, my preference is for passing a Bool to sort(), and *eventually*<br>&gt; re-evaluate if needed.<br></p><p>I agree.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b660eecceda60138f137d353b8289925?s=50"></div><header><strong>Add stableSort() to the standard library.</strong> from <string>Janosch Hildebrand</string> &lt;jnosh at jnosh.com&gt;<p>January 11, 2016 at 03:00:00pm</p></header><div class="content"><p>Strong +1 for adding a stable sort to the stdlib.<br></p><p>&gt; Should we also provide a stableSortInPlace() implementation?<br></p><p>Yes!<br></p><p>&gt; On 11 Jan 2016, at 04:39, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; ####<br>&gt;&gt; Alternatives considered<br>&gt;&gt; ####<br>&gt;&gt; An alternative would be that of augmenting sort() to get a Bool as argument<br>&gt;&gt; (stable: True). I&#39;d rather like better to mirror what almost every<br>&gt;&gt; other programming<br>&gt;&gt; language does (providing a separate API).<br>&gt;&gt; It&#39;s an API breaking change (I think, but I&#39;m not entirely sure).<br>&gt; <br>&gt; I have been thinking about this, and even though other languages it is<br>&gt; a separate function, since the fundamental operation of sort() and<br>&gt; stableSort() seems sufficiently similar to me, the defaulted parameter<br>&gt; seems like the right thing to do.  What other parameters could sort()<br>&gt; conceivably get in future?  Should the parameter be a boolean flag or<br>&gt; a resilient option set?  Foundation has NSSortOptions, which has just<br>&gt; &quot;Stable&quot; and &quot;Concurrent&quot;.  The &quot;concurrent&quot; part, in my opinion,<br>&gt; needs to be handled somehow for all algorithms in a consistent manner,<br>&gt; rather than adding flags for each API separately.<br></p><p><br>This seems like the right direction to me.<br></p><p>Are there other compelling options for &#39;sort&#39; though?<br>More input towards the sort strategy/algorithm(s) employed is what I can think of but that has relatively limited applicability.<br>Then again this is going to exist anyway whether it is in the stdlib or not...<br></p><p>Personally I wouldn&#39;t mind `foo.sort(.stable)` so I&#39;m pro option set if there is a reasonable case for keeping our options open, so to speak.<br></p><p>- Janosch<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e01e37acbfad671da1b94a61cf819d82?s=50"></div><header><strong>Add stableSort() to the standard library.</strong> from <string>Kenny Leung</string> &lt;kenny_leung at pobox.com&gt;<p>January 11, 2016 at 09:00:00am</p></header><div class="content"><p>I can’t imagine a case where one wouldn’t want this, so why not just replace the existing sort with the stable sort?<br></p><p>-Kenny<br></p><p><br>&gt; On Jan 10, 2016, at 3:11 PM, Davide Italiano via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Feedback very appreciated.<br>&gt; <br>&gt; Add stableSort() to the standard library.<br>&gt; <br>&gt; ####<br>&gt; Introduction<br>&gt; ####<br>&gt; At the time of writing the Swift standard library provides two way two<br>&gt; different versions of sort.<br>&gt; The first one is sort(), which provides a regular unstable[1] sorting algorithm.<br>&gt; The second one, sortInPlace(), which also provides unstable sorting with the<br>&gt; additional guarantee that the algorithm will operate in-place, i.e., it will<br>&gt; use only a constant amount of extra space (independent from the input size).<br>&gt; The aim of this proposal is to implement a third variant, stableSort(), in order<br>&gt; to provide a stable version of sorting.<br>&gt; <br>&gt; ####<br>&gt; Motivation<br>&gt; ####<br>&gt; Stable sorting is useful when sorting lists by multiple keys<br>&gt; (primary/secondary). A classical example is provided in [2].<br>&gt; Other programming languages, e.g. C++ or Go provide interfaces for stable<br>&gt; sorting in their standard libraries (respective std::stable_sort and Stable()).<br>&gt; <br>&gt; #####<br>&gt; Proposed solution<br>&gt; #####<br>&gt; The API proposed just mirrors the one of regular sort().<br>&gt; <br>&gt; @warn_unused_result func stableSort() -&gt; [Self.Generator.Element]<br>&gt; Return an Array containing the sorted elements of source.<br>&gt; <br>&gt; Discussion<br>&gt; The sorting algorithm is stable (does not change the relative order of elements<br>&gt; that compare equal).<br>&gt; <br>&gt; Requires: The less-than operator (func &lt;) defined in the Comparable conformance<br>&gt; is a strict weak ordering over the elements in self.<br>&gt; <br>&gt; Constraints<br>&gt; Self.Generator.Element : Comparable<br>&gt; <br>&gt; #####<br>&gt; Impact on existing code<br>&gt; #####<br>&gt; None.<br>&gt; <br>&gt; ####<br>&gt; Alternatives considered<br>&gt; ####<br>&gt; An alternative would be that of augmenting sort() to get a Bool as argument<br>&gt; (stable: True). I&#39;d rather like better to mirror what almost every<br>&gt; other programming<br>&gt; language does (providing a separate API).<br>&gt; It&#39;s an API breaking change (I think, but I&#39;m not entirely sure).<br>&gt; <br>&gt; ####<br>&gt; Open questions<br>&gt; ####<br>&gt; Should we also provide a stableSortInPlace() implementation?<br>&gt; <br>&gt; <br>&gt; Notes:<br>&gt; <br>&gt; [1] A sorting algorithm is said to be &quot;stable&quot; if it maintains in the output<br>&gt; the relative order of entries with equal keys, and &quot;unstable&quot; otherwise.<br>&gt; [2] http://stackoverflow.com/questions/808617/what-is-the-benefit-for-a-sort-algorithm-to-be-stable/808658#808658<br>&gt; <br>&gt; Thanks,<br>&gt; <br>&gt; --<br>&gt; Davide<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0089229ece6e648767cff4dc6c6d38ab?s=50"></div><header><strong>Add stableSort() to the standard library.</strong> from <string>Charles Kissinger</string> &lt;crk at akkyra.com&gt;<p>January 11, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 11, 2016, at 9:51 AM, Kenny Leung via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I can’t imagine a case where one wouldn’t want this, so why not just replace the existing sort with the stable sort?<br>&gt; <br>&gt; -Kenny<br>&gt; <br></p><p>It’s primarily a performance issue, I think. The best unstable sort algorithms are faster and/or use less memory, as I understand it. Are they enough faster to make a difference to most people? I don’t know.<br></p><p>-CK<br></p><p>&gt; <br>&gt;&gt; On Jan 10, 2016, at 3:11 PM, Davide Italiano via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Feedback very appreciated.<br>&gt;&gt; <br>&gt;&gt; Add stableSort() to the standard library.<br>&gt;&gt; <br>&gt;&gt; ####<br>&gt;&gt; Introduction<br>&gt;&gt; ####<br>&gt;&gt; At the time of writing the Swift standard library provides two way two<br>&gt;&gt; different versions of sort.<br>&gt;&gt; The first one is sort(), which provides a regular unstable[1] sorting algorithm.<br>&gt;&gt; The second one, sortInPlace(), which also provides unstable sorting with the<br>&gt;&gt; additional guarantee that the algorithm will operate in-place, i.e., it will<br>&gt;&gt; use only a constant amount of extra space (independent from the input size).<br>&gt;&gt; The aim of this proposal is to implement a third variant, stableSort(), in order<br>&gt;&gt; to provide a stable version of sorting.<br>&gt;&gt; <br>&gt;&gt; ####<br>&gt;&gt; Motivation<br>&gt;&gt; ####<br>&gt;&gt; Stable sorting is useful when sorting lists by multiple keys<br>&gt;&gt; (primary/secondary). A classical example is provided in [2].<br>&gt;&gt; Other programming languages, e.g. C++ or Go provide interfaces for stable<br>&gt;&gt; sorting in their standard libraries (respective std::stable_sort and Stable()).<br>&gt;&gt; <br>&gt;&gt; #####<br>&gt;&gt; Proposed solution<br>&gt;&gt; #####<br>&gt;&gt; The API proposed just mirrors the one of regular sort().<br>&gt;&gt; <br>&gt;&gt; @warn_unused_result func stableSort() -&gt; [Self.Generator.Element]<br>&gt;&gt; Return an Array containing the sorted elements of source.<br>&gt;&gt; <br>&gt;&gt; Discussion<br>&gt;&gt; The sorting algorithm is stable (does not change the relative order of elements<br>&gt;&gt; that compare equal).<br>&gt;&gt; <br>&gt;&gt; Requires: The less-than operator (func &lt;) defined in the Comparable conformance<br>&gt;&gt; is a strict weak ordering over the elements in self.<br>&gt;&gt; <br>&gt;&gt; Constraints<br>&gt;&gt; Self.Generator.Element : Comparable<br>&gt;&gt; <br>&gt;&gt; #####<br>&gt;&gt; Impact on existing code<br>&gt;&gt; #####<br>&gt;&gt; None.<br>&gt;&gt; <br>&gt;&gt; ####<br>&gt;&gt; Alternatives considered<br>&gt;&gt; ####<br>&gt;&gt; An alternative would be that of augmenting sort() to get a Bool as argument<br>&gt;&gt; (stable: True). I&#39;d rather like better to mirror what almost every<br>&gt;&gt; other programming<br>&gt;&gt; language does (providing a separate API).<br>&gt;&gt; It&#39;s an API breaking change (I think, but I&#39;m not entirely sure).<br>&gt;&gt; <br>&gt;&gt; ####<br>&gt;&gt; Open questions<br>&gt;&gt; ####<br>&gt;&gt; Should we also provide a stableSortInPlace() implementation?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Notes:<br>&gt;&gt; <br>&gt;&gt; [1] A sorting algorithm is said to be &quot;stable&quot; if it maintains in the output<br>&gt;&gt; the relative order of entries with equal keys, and &quot;unstable&quot; otherwise.<br>&gt;&gt; [2] http://stackoverflow.com/questions/808617/what-is-the-benefit-for-a-sort-algorithm-to-be-stable/808658#808658<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; Davide<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/91c88f3ed8bc9a8164f281098c03059b?s=50"></div><header><strong>Add stableSort() to the standard library.</strong> from <string>Davide Italiano</string> &lt;dccitaliano at gmail.com&gt;<p>January 11, 2016 at 10:00:00am</p></header><div class="content"><p>On Mon, Jan 11, 2016 at 9:51 AM, Kenny Leung via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; I can’t imagine a case where one wouldn’t want this, so why not just replace the existing sort with the stable sort?<br>&gt;<br></p><p>Unstable sort and stable sort come with different time/space<br>computational complexity tradeoffs. In general you might be faster if<br>you don&#39;t care about relative order of elements with the same keys and<br>some (most?) consumers don&#39;t. So, I don&#39;t think it&#39;s an option<br>providing only stable sort.<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
