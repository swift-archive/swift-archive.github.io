<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] SE-0074: Implementation of Binary Search functions</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May  6, 2016 at 03:00:00pm</p></header><div class="content"><p>I am posting this review on behalf of Dmitri Gribenko, Max Moiseev, and<br>myself.<br></p><p>on Tue May 03 2016, Chris Lattner &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hello Swift community,<br>&gt;<br>&gt; The review of &quot;SE-0074: Implementation of Binary Search functions&quot;<br>&gt; begins now and runs through May 9. The proposal is available here:<br>&gt;<br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0074-binary-search.md<br>&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;<br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt;<br>&gt; What goes into a review?<br>&gt;<br>&gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and contribute to the direction of<br>&gt; Swift. When writing your review, here are some questions you might<br>&gt; want to answer in your review:<br>&gt;<br>&gt; 	* What is your evaluation of the proposal?<br></p><p>We think binary searches are fundamental and important, and want to see<br>them added.  However, we don&#39;t agree with the form of the current<br>proposal.  In particular, we think:<br></p><p>* Operations that depend on sorted-ness and use binary predicates should<br>  not be available on all Collections; they&#39;re too easy to misuse,<br>  they&#39;re hard to name well, and as Nicola Salmoria has noted, they<br>  would not make any sense at all for a Set&lt;T&gt;.<br></p><p>* They should be scoped to a kind of collection that bundles<br>  the predicate with the elements, e.g.<br></p><p>    let x = Sorted([3, 4, 1, 5, 2], &gt;)          // stores a sorted copy of the array<br>    let y = Sorted(preSorted: 0..&lt;100, &lt;)  // stores a copy of the range<br></p><p>  Maybe there should also be protocols for this; CountableRange&lt;T&gt; would<br>  already already conform to the immutable version.  We might want a<br>  mutable form of the protocol for sorted collections with<br>  insertion/removal methods.  This whole area needs more design.<br></p><p>* The polarity of the predicates is wrong: a method with a “where:<br>  predicate” should always return you the index of an element that<br>  *does* satisfy the predicate.<br></p><p>* Any code in the proposal should be updated to:<br></p><p>  - conform to the new<br>    indexing model; it still shows indices being moved without<br>    participation of the collection instance.<br>  <br>  - attach the @noescape attribute to a parameter&#39;s type, rather than <br>    its name.<br></p><p>* The existing partition algorithms in the stdlib are indeed hobbled.<br>  The more-general partition function is a great idea, but it belongs in<br>  a separate proposal.<br></p><p>* Something like the method the proposal calls `partitionedIndex`<br>  *should* be included in the standard library for Swift 3, with the<br>  following differences:<br></p><p>  - it should be called partitionPoint(where:)<br></p><p>  - the meaning of the predicate result should be inverted so that the<br>    result of calling the function points to an element actually<br>    satisfying the predicate<br></p><p>  This would give people the primitive they need to build higher-level<br>  functionality without broadening the interface too far, or committing<br>  us to a design that will be hard to use correctly.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a<br>&gt; change to Swift?  <br></p><p>Yes.<br></p><p>&gt; * Does this proposal fit well with the feel and direction of Swift?  <br></p><p>Not as written, we think.<br></p><p>&gt; * If you have used other languages or libraries with a similar<br>&gt; feature, how do you feel that this proposal compares to those?<br></p><p>We have used the C++ standard library and Python&#39;s `bisect` function.<br>This proposal is obviously inspired by much of the work in C++, but we<br>think we can do much better for Swift.<br></p><p>&gt; * How much effort did you put into your review? A glance, a<br>&gt; quick reading, or an in-depth study?<br></p><p>An in-depth study.  <br></p><p>&gt; More information about the Swift evolution process is available at<br>&gt;<br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;<br>&gt; Thank you,<br>&gt;<br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>Thanks,<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review] SE-0074: Implementation of Binary Search functions</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May  9, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; * Operations that depend on sorted-ness and use binary predicates should<br>&gt;  not be available on all Collections; they&#39;re too easy to misuse,<br>&gt;  they&#39;re hard to name well, and as Nicola Salmoria has noted, they<br>&gt;  would not make any sense at all for a Set&lt;T&gt;.<br>&gt; <br>&gt; * They should be scoped to a kind of collection that bundles<br>&gt;  the predicate with the elements, e.g.<br>&gt; <br>&gt;    let x = Sorted([3, 4, 1, 5, 2], &gt;)          // stores a sorted copy of the array<br>&gt;    let y = Sorted(preSorted: 0..&lt;100, &lt;)  // stores a copy of the range<br>&gt; <br>&gt;  Maybe there should also be protocols for this; CountableRange&lt;T&gt; would<br>&gt;  already already conform to the immutable version.  We might want a<br>&gt;  mutable form of the protocol for sorted collections with<br>&gt;  insertion/removal methods.  This whole area needs more design.<br></p><p>I agree with both of these statements, but not with your conclusion.<br></p><p>There are three classes of collections:<br></p><p>1) Those which are always sorted, like a SortedSet.<br>2) Those which may or may not be sorted, like an Array.<br>3) Those which are never sorted, like a Set.<br></p><p>These APIs are useless on a #3, but #2 is still a valuable use case to support. In particular, it&#39;s quite common to use sorted `Array`s, and these APIs would help you do that.<br></p><p>What I might consider doing is tying this to `RangeReplaceableCollection`. That protocol is applied only to types which allow insertion at arbitrary indices, which is a good, though not perfect, proxy for types which might allow you to manually maintain a sort order. `Array`, `ArraySlice`, `ContiguousArray`, and the mutable `String` views would get these methods, while `Set` and `Dictionary` would not.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Review] SE-0074: Implementation of Binary Search functions</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>May  9, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On May 9, 2016, at 6:23 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; * Operations that depend on sorted-ness and use binary predicates should<br>&gt;&gt; not be available on all Collections; they&#39;re too easy to misuse,<br>&gt;&gt; they&#39;re hard to name well, and as Nicola Salmoria has noted, they<br>&gt;&gt; would not make any sense at all for a Set&lt;T&gt;.<br>&gt;&gt; <br>&gt;&gt; * They should be scoped to a kind of collection that bundles<br>&gt;&gt; the predicate with the elements, e.g.<br>&gt;&gt; <br>&gt;&gt;   let x = Sorted([3, 4, 1, 5, 2], &gt;)          // stores a sorted copy of the array<br>&gt;&gt;   let y = Sorted(preSorted: 0..&lt;100, &lt;)  // stores a copy of the range<br>&gt;&gt; <br>&gt;&gt; Maybe there should also be protocols for this; CountableRange&lt;T&gt; would<br>&gt;&gt; already already conform to the immutable version.  We might want a<br>&gt;&gt; mutable form of the protocol for sorted collections with<br>&gt;&gt; insertion/removal methods.  This whole area needs more design.<br>&gt; <br>&gt; I agree with both of these statements, but not with your conclusion.<br>&gt; <br>&gt; There are three classes of collections:<br>&gt; <br>&gt; 1) Those which are always sorted, like a SortedSet.<br>&gt; 2) Those which may or may not be sorted, like an Array.<br>&gt; 3) Those which are never sorted, like a Set.<br>&gt; <br>&gt; These APIs are useless on a #3, but #2 is still a valuable use case to support. In particular, it&#39;s quite common to use sorted `Array`s, and these APIs would help you do that.<br>&gt; <br>&gt; What I might consider doing is tying this to `RangeReplaceableCollection`. That protocol is applied only to types which allow insertion at arbitrary indices, which is a good, though not perfect, proxy for types which might allow you to manually maintain a sort order. `Array`, `ArraySlice`, `ContiguousArray`, and the mutable `String` views would get these methods, while `Set` and `Dictionary` would not.<br></p><p>We could also introduce a new OrderedCollection protocol. (This would also be useful in the future for supporting `case` pattern matching on collections. It makes sense to pattern-match arrays and other ordered collections in order by element, but you&#39;d expect very different semantics pattern-matching an unordered Set.)<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5f463dd4e7af28b64ad8f0e032ee82dc?s=50"></div><header><strong>[Review] SE-0074: Implementation of Binary Search functions</strong> from <string>Nate Cook</string> &lt;natecook at gmail.com&gt;<p>May  9, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On May 9, 2016, at 9:48 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On May 9, 2016, at 6:23 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; * Operations that depend on sorted-ness and use binary predicates should<br>&gt;&gt;&gt; not be available on all Collections; they&#39;re too easy to misuse,<br>&gt;&gt;&gt; they&#39;re hard to name well, and as Nicola Salmoria has noted, they<br>&gt;&gt;&gt; would not make any sense at all for a Set&lt;T&gt;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * They should be scoped to a kind of collection that bundles<br>&gt;&gt;&gt; the predicate with the elements, e.g.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  let x = Sorted([3, 4, 1, 5, 2], &gt;)          // stores a sorted copy of the array<br>&gt;&gt;&gt;  let y = Sorted(preSorted: 0..&lt;100, &lt;)  // stores a copy of the range<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Maybe there should also be protocols for this; CountableRange&lt;T&gt; would<br>&gt;&gt;&gt; already already conform to the immutable version.  We might want a<br>&gt;&gt;&gt; mutable form of the protocol for sorted collections with<br>&gt;&gt;&gt; insertion/removal methods.  This whole area needs more design.<br>&gt;&gt; <br>&gt;&gt; I agree with both of these statements, but not with your conclusion.<br>&gt;&gt; <br>&gt;&gt; There are three classes of collections:<br>&gt;&gt; <br>&gt;&gt; 1) Those which are always sorted, like a SortedSet.<br>&gt;&gt; 2) Those which may or may not be sorted, like an Array.<br>&gt;&gt; 3) Those which are never sorted, like a Set.<br>&gt;&gt; <br>&gt;&gt; These APIs are useless on a #3, but #2 is still a valuable use case to support. In particular, it&#39;s quite common to use sorted `Array`s, and these APIs would help you do that.<br>&gt;&gt; <br>&gt;&gt; What I might consider doing is tying this to `RangeReplaceableCollection`. That protocol is applied only to types which allow insertion at arbitrary indices, which is a good, though not perfect, proxy for types which might allow you to manually maintain a sort order. `Array`, `ArraySlice`, `ContiguousArray`, and the mutable `String` views would get these methods, while `Set` and `Dictionary` would not.<br>&gt; <br>&gt; We could also introduce a new OrderedCollection protocol. (This would also be useful in the future for supporting `case` pattern matching on collections. It makes sense to pattern-match arrays and other ordered collections in order by element, but you&#39;d expect very different semantics pattern-matching an unordered Set.)<br>&gt; <br></p><p>&gt; -Joe<br></p><p>Yet another alternative would be to drop Set and Dictionary down a level to a FiniteSequence protocol in between Sequence and Collection. Basically none of the index-based collection APIs (i.e. everything except `count` and `isEmpty`) make sense on sets and dictionaries. index(where:) was marginally useful with dictionaries, but now that Sequence is getting first(where:), née find(...), even that isn&#39;t necessary.<br></p><p>Nate<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160509/b23c4420/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Review] SE-0074: Implementation of Binary Search functions</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>May 10, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On May 9, 2016, at 10:28 PM, Nate Cook via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On May 9, 2016, at 9:48 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 9, 2016, at 6:23 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * Operations that depend on sorted-ness and use binary predicates should<br>&gt;&gt;&gt;&gt; not be available on all Collections; they&#39;re too easy to misuse,<br>&gt;&gt;&gt;&gt; they&#39;re hard to name well, and as Nicola Salmoria has noted, they<br>&gt;&gt;&gt;&gt; would not make any sense at all for a Set&lt;T&gt;.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * They should be scoped to a kind of collection that bundles<br>&gt;&gt;&gt;&gt; the predicate with the elements, e.g.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  let x = Sorted([3, 4, 1, 5, 2], &gt;)          // stores a sorted copy of the array<br>&gt;&gt;&gt;&gt;  let y = Sorted(preSorted: 0..&lt;100, &lt;)  // stores a copy of the range<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Maybe there should also be protocols for this; CountableRange&lt;T&gt; would<br>&gt;&gt;&gt;&gt; already already conform to the immutable version.  We might want a<br>&gt;&gt;&gt;&gt; mutable form of the protocol for sorted collections with<br>&gt;&gt;&gt;&gt; insertion/removal methods.  This whole area needs more design.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree with both of these statements, but not with your conclusion.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are three classes of collections:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1) Those which are always sorted, like a SortedSet.<br>&gt;&gt;&gt; 2) Those which may or may not be sorted, like an Array.<br>&gt;&gt;&gt; 3) Those which are never sorted, like a Set.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; These APIs are useless on a #3, but #2 is still a valuable use case to support. In particular, it&#39;s quite common to use sorted `Array`s, and these APIs would help you do that.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What I might consider doing is tying this to `RangeReplaceableCollection`. That protocol is applied only to types which allow insertion at arbitrary indices, which is a good, though not perfect, proxy for types which might allow you to manually maintain a sort order. `Array`, `ArraySlice`, `ContiguousArray`, and the mutable `String` views would get these methods, while `Set` and `Dictionary` would not.<br>&gt;&gt; <br>&gt;&gt; We could also introduce a new OrderedCollection protocol. (This would also be useful in the future for supporting `case` pattern matching on collections. It makes sense to pattern-match arrays and other ordered collections in order by element, but you&#39;d expect very different semantics pattern-matching an unordered Set.)<br></p><p>I have some high-level comments about this proposal: it feels rather muddled and as if it&#39;s mixing different concerns.<br></p><p>Taking a step back, at a *minimum* I think the right way to add this functionality is to:<br></p><p>A) add generic functions like `binarySearch` (etc.) to `Collection` (taking the GIGO risk, of course)<br>B) add overridable methods like `sortedIndex(of:)` to `Collection` (taking the GIGO risk again, of course)<br>C) provide default implementations of e.g. `sortedIndex(of:)` that use `binarySearch` (etc.)<br></p><p>…and *ideally* I think both (A) and probably (B) wind up introducing some methods like `_customBinarySearchForComparableElement` (etc.), but that is a level of detail that can be skipped for this discussion.<br></p><p>I understand the motivation to try and add only “intent-focused” methods like `sortedIndex(of:)`, but a binary search should be expressible generically and is a very useful building block to have when building such higher-level methods; it would also prove useful to *implement* the `Sorted(…)` concept mentioned above, one would think.<br></p><p>I also think it will be a mistake to restrict the availability of any of these APIs to “sorted” collections; there are several reasons here. <br></p><p>One reason is simply b/c such sorted collections aren’t part of the standard library yet. <br></p><p>Also, it seems like for *some* of these methods (binarySearch) it’s a category error to restrict them to sorted collections: such sorted collections should instead simply exploit their own ordering/structure where appropriate! <br></p><p>Finally, things like binary searches are often basic building blocks (etc.) for *constructing* such ordered collections, and thus being unable to use them in that context would be limiting (e.g. if you wanted to implement `Sorted(…)` as suggested above, you’d probably benefit from being able to use these methods…).<br></p><p>Thus although I understand the desire for jumping immediately to the higher-level, &quot;intent-focused” API, and although I understand the GIGO risk for having some of these methods defined too broadly, I am not sure the cures aren&#39;t worse than the disease here, so to speak.<br></p><p>&gt;&gt; <br>&gt; <br>&gt;&gt; -Joe<br>&gt; <br>&gt; Yet another alternative would be to drop Set and Dictionary down a level to a FiniteSequence protocol in between Sequence and Collection. Basically none of the index-based collection APIs (i.e. everything except `count` and `isEmpty`) make sense on sets and dictionaries. index(where:) was marginally useful with dictionaries, but now that Sequence is getting first(where:), née find(...), even that isn&#39;t necessary.<br></p><p>I’ve argued this (unsuccessfully) here in the past, but with 2 such distinctions:<br></p><p>- Sequence -&gt; FiniteSequence <br>- Sequence -&gt; StableSequence (“stable” meaning identical on each iteration)<br>- Collection: FiniteSequence, StableSequence<br></p><p>…but it didn’t go well; I can certainly dredge up my design notes if there’s someone else interested in taking up this case.<br></p><p>&gt; <br>&gt; Nate<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160510/aa82c6f9/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] SE-0074: Implementation of Binary Search functions</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May 13, 2016 at 08:00:00am</p></header><div class="content"><p>on Mon May 09 2016, Nate Cook &lt;natecook-AT-gmail.com&gt; wrote:<br></p><p>&gt; Yet another alternative would be to drop Set and Dictionary down a<br>&gt; level to a FiniteSequence protocol in between Sequence and<br>&gt; Collection. Basically none of the index-based collection APIs<br>&gt; (i.e. everything except `count` and `isEmpty`) make sense on sets and<br>&gt; dictionaries. <br></p><p>Strongly disagreed.  Any read-only operation that makes sense on a<br>bidirectional collection makes sense on these data structures.<br></p><p>&gt; index(where:) was marginally useful with dictionaries, but now that<br>&gt; Sequence is getting first(where:), née find(...), even that isn&#39;t<br>&gt; necessary.<br></p><p>   s.remove(at: s.index(where: { $0 &lt; 1 }))<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/67a361b77f5c6cba256d06ba641f2af8?s=50"></div><header><strong>[Review] SE-0074: Implementation of Binary Search functions</strong> from <string>Nate Cook</string> &lt;nate at natecook.com&gt;<p>May 13, 2016 at 11:00:00am</p></header><div class="content"><p>&gt;&gt; On May 13, 2016, at 9:36 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; on Mon May 09 2016, Nate Cook &lt;natecook-AT-gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Yet another alternative would be to drop Set and Dictionary down a<br>&gt;&gt; level to a FiniteSequence protocol in between Sequence and<br>&gt;&gt; Collection. Basically none of the index-based collection APIs<br>&gt;&gt; (i.e. everything except `count` and `isEmpty`) make sense on sets and<br>&gt;&gt; dictionaries.<br>&gt; <br>&gt; Strongly disagreed.  Any read-only operation that makes sense on a<br>&gt; bidirectional collection makes sense on these data structures.<br></p><p>I don&#39;t see how the methods that impose meaning on the order of a set are useful. What does mySet.prefix(upTo: i) mean when I have no control or dependable way of knowing which elements lie between startIndex and i? mySet.first is useful, but it&#39;s meaning is more like NSSet&#39;s anyObject.<br></p><p>&gt;&gt; index(where:) was marginally useful with dictionaries, but now that<br>&gt;&gt; Sequence is getting first(where:), née find(...), even that isn&#39;t<br>&gt;&gt; necessary.<br>&gt; <br>&gt;   s.remove(at: s.index(where: { $0 &lt; 1 }))<br></p><p>Since Set&#39;s remove(at:) method is type-specific, it would need to be rewritten as remove(where:). <br></p><p>This example is kind of my point, though - it removes the first element less than 1, but only one such element, and there&#39;s no telling which. That&#39;s not an operation I&#39;ve ever needed to perform on a set.<br></p><p>To clarify, I don&#39;t think the current system is hurting Set and Dictionary in any way. It&#39;s simply providing them with methods that aren&#39;t very useful for that particular data structure.<br></p><p>Nate<br></p><p>&gt; -- <br>&gt; -Dave<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] SE-0074: Implementation of Binary Search functions</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May 15, 2016 at 10:00:00am</p></header><div class="content"><p>on Fri May 13 2016, Nate Cook &lt;nate-AT-natecook.com&gt; wrote:<br></p><p>&gt;&gt;&gt; On May 13, 2016, at 9:36 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Mon May 09 2016, Nate Cook &lt;natecook-AT-gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yet another alternative would be to drop Set and Dictionary down a<br>&gt;&gt;&gt; level to a FiniteSequence protocol in between Sequence and<br>&gt;&gt;&gt; Collection. Basically none of the index-based collection APIs<br>&gt;&gt;&gt; (i.e. everything except `count` and `isEmpty`) make sense on sets and<br>&gt;&gt;&gt; dictionaries.<br>&gt;&gt; <br>&gt;&gt; Strongly disagreed.  Any read-only operation that makes sense on a<br>&gt;&gt; bidirectional collection makes sense on these data structures.<br>&gt;<br>&gt; I don&#39;t see how the methods that impose meaning on the order of a set<br>&gt; are useful. What does mySet.prefix(upTo: i) mean when I have no<br>&gt; control or dependable way of knowing which elements lie between<br>&gt; startIndex and i? mySet.first is useful, but it&#39;s meaning is more like<br>&gt; NSSet&#39;s anyObject.<br></p><p>If you give me a random collection of Ts, I may want to find the index<br>of the first element that satisfies some predicate.  Then I may want to<br>process the prefix of elements that don&#39;t satisfy that predicate, and<br>repeat.<br></p><p>In general, many algorithms that operate on a collection place no<br>requirements on the semantic relationship and/or ordering of the<br>elements, and such algorithms can still be useful on Sets.  Use your<br>imagination and you&#39;ll see more of them, e.g. find the index of the<br>maximum element in the set (so that you can remove it).<br></p><p>&gt;&gt;&gt; index(where:) was marginally useful with dictionaries, but now that<br>&gt;&gt;&gt; Sequence is getting first(where:), née find(...), even that isn&#39;t<br>&gt;&gt;&gt; necessary.<br>&gt;&gt; <br>&gt;&gt;   s.remove(at: s.index(where: { $0 &lt; 1 }))<br>&gt;<br>&gt; Since Set&#39;s remove(at:) method is type-specific, it would need to be<br>&gt; rewritten as remove(where:). <br></p><p>? What does “type-specific” mean and why do you say so?<br></p><p>If we don&#39;t have a remove(at:) method for Set, that&#39;s a bug.  Whether we<br>need a RangeRemovableCollection that is refined by<br>RangeReplaceableCollection is an interesting question.<br></p><p>&gt; This example is kind of my point, though - it removes the first<br>&gt; element less than 1, but only one such element, and there&#39;s no telling<br>&gt; which. That&#39;s not an operation I&#39;ve ever needed to perform on a set.<br>&gt;<br>&gt; To clarify, I don&#39;t think the current system is hurting Set and<br>&gt; Dictionary in any way. It&#39;s simply providing them with methods that<br>&gt; aren&#39;t very useful for that particular data structure.<br></p><p>It&#39;s true that it&#39;s harder to find algorithms that are *very likely* to<br>be useful on collections whose ordering is not controlled, but that<br>doesn&#39;t mean those collections shouldn&#39;t satisfy the Collection<br>protocol.  Even parallelization of trivial operations such as “find the<br>minimum element” requires the the fundamental properties of Collection.<br></p><p>-- <br>-Dave<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Review] SE-0074: Implementation of Binary Search functions</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 10, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; Am 10.05.2016 um 04:48 schrieb Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On May 9, 2016, at 6:23 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; * Operations that depend on sorted-ness and use binary predicates should<br>&gt;&gt;&gt; not be available on all Collections; they&#39;re too easy to misuse,<br>&gt;&gt;&gt; they&#39;re hard to name well, and as Nicola Salmoria has noted, they<br>&gt;&gt;&gt; would not make any sense at all for a Set&lt;T&gt;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * They should be scoped to a kind of collection that bundles<br>&gt;&gt;&gt; the predicate with the elements, e.g.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  let x = Sorted([3, 4, 1, 5, 2], &gt;)          // stores a sorted copy of the array<br>&gt;&gt;&gt;  let y = Sorted(preSorted: 0..&lt;100, &lt;)  // stores a copy of the range<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Maybe there should also be protocols for this; CountableRange&lt;T&gt; would<br>&gt;&gt;&gt; already already conform to the immutable version.  We might want a<br>&gt;&gt;&gt; mutable form of the protocol for sorted collections with<br>&gt;&gt;&gt; insertion/removal methods.  This whole area needs more design.<br>&gt;&gt; <br>&gt;&gt; I agree with both of these statements, but not with your conclusion.<br>&gt;&gt; <br>&gt;&gt; There are three classes of collections:<br>&gt;&gt; <br>&gt;&gt; 1) Those which are always sorted, like a SortedSet.<br>&gt;&gt; 2) Those which may or may not be sorted, like an Array.<br>&gt;&gt; 3) Those which are never sorted, like a Set.<br>&gt;&gt; <br>&gt;&gt; These APIs are useless on a #3, but #2 is still a valuable use case to support. In particular, it&#39;s quite common to use sorted `Array`s, and these APIs would help you do that.<br>&gt;&gt; <br>&gt;&gt; What I might consider doing is tying this to `RangeReplaceableCollection`. That protocol is applied only to types which allow insertion at arbitrary indices, which is a good, though not perfect, proxy for types which might allow you to manually maintain a sort order. `Array`, `ArraySlice`, `ContiguousArray`, and the mutable `String` views would get these methods, while `Set` and `Dictionary` would not.<br>&gt; <br>&gt; We could also introduce a new OrderedCollection protocol. (This would also be useful in the future for supporting `case` pattern matching on collections. It makes sense to pattern-match arrays and other ordered collections in order by element, but you&#39;d expect very different semantics pattern-matching an unordered Set.)<br></p><p>big +1<br></p><p>Smalltalk has an OrderedCollection which implies that the elements are ordered (though not automatically sorted) and a SortedCollection which maintains a given sort order like the `Sorted` from Dave’s comment. Smalltalk’s Set and Dictionary are just Collections. I always found these useful distinctions.<br></p><p>-Thorsten<br></p><p><br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160510/87d93f09/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] SE-0074: Implementation of Binary Search functions</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May 13, 2016 at 08:00:00am</p></header><div class="content"><p>on Mon May 09 2016, Joe Groff &lt;jgroff-AT-apple.com&gt; wrote:<br></p><p>&gt;&gt; On May 9, 2016, at 6:23 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; * Operations that depend on sorted-ness and use binary predicates should<br>&gt;&gt;&gt; not be available on all Collections; they&#39;re too easy to misuse,<br>&gt;&gt;&gt; they&#39;re hard to name well, and as Nicola Salmoria has noted, they<br>&gt;<br>&gt;&gt;&gt; would not make any sense at all for a Set&lt;T&gt;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * They should be scoped to a kind of collection that bundles<br>&gt;&gt;&gt; the predicate with the elements, e.g.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   let x = Sorted([3, 4, 1, 5, 2], &gt;)          // stores a sorted copy of the array<br>&gt;&gt;&gt;   let y = Sorted(preSorted: 0..&lt;100, &lt;)  // stores a copy of the range<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Maybe there should also be protocols for this; CountableRange&lt;T&gt; would<br>&gt;&gt;&gt; already already conform to the immutable version.  We might want a<br>&gt;&gt;&gt; mutable form of the protocol for sorted collections with<br>&gt;&gt;&gt; insertion/removal methods.  This whole area needs more design.<br>&gt;&gt; <br>&gt;&gt; I agree with both of these statements, but not with your conclusion.<br>&gt;&gt; <br>&gt;&gt; There are three classes of collections:<br>&gt;&gt; <br>&gt;&gt; 1) Those which are always sorted, like a SortedSet.<br>&gt;&gt; 2) Those which may or may not be sorted, like an Array.<br>&gt;&gt; 3) Those which are never sorted, like a Set.<br>&gt;&gt; <br>&gt;&gt; These APIs are useless on a #3, but #2 is still a valuable use case<br>&gt;&gt; to support. In particular, it&#39;s quite common to use sorted `Array`s,<br>&gt;&gt; and these APIs would help you do that.<br>&gt;&gt; <br>&gt;&gt; What I might consider doing is tying this to<br>&gt;&gt; `RangeReplaceableCollection`. That protocol is applied only to types<br>&gt;&gt; which allow insertion at arbitrary indices, which is a good, though<br>&gt;&gt; not perfect, proxy for types which might allow you to manually<br>&gt;&gt; maintain a sort order. `Array`, `ArraySlice`, `ContiguousArray`, and<br>&gt;&gt; the mutable `String` views would get these methods, while `Set` and<br>&gt;&gt; `Dictionary` would not.<br>&gt;<br>&gt; We could also introduce a new OrderedCollection protocol. (This would<br>&gt; also be useful in the future for supporting `case` pattern matching on<br>&gt; collections. It makes sense to pattern-match arrays and other ordered<br>&gt; collections in order by element, but you&#39;d expect very different<br>&gt; semantics pattern-matching an unordered Set.)<br></p><p>What do you mean by “Ordered” here?  Please note that when Cocoa uses<br>“Ordered” it means something very different from “Sorted.”  I don&#39;t find<br>the Cocoa usage intuitive myself, but it might be best to avoid that<br>term to avoid confusion.<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Review] SE-0074: Implementation of Binary Search functions</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>May 13, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On May 13, 2016, at 7:30 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Mon May 09 2016, Joe Groff &lt;jgroff-AT-apple.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On May 9, 2016, at 6:23 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * Operations that depend on sorted-ness and use binary predicates should<br>&gt;&gt;&gt;&gt; not be available on all Collections; they&#39;re too easy to misuse,<br>&gt;&gt;&gt;&gt; they&#39;re hard to name well, and as Nicola Salmoria has noted, they<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; would not make any sense at all for a Set&lt;T&gt;.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * They should be scoped to a kind of collection that bundles<br>&gt;&gt;&gt;&gt; the predicate with the elements, e.g.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  let x = Sorted([3, 4, 1, 5, 2], &gt;)          // stores a sorted copy of the array<br>&gt;&gt;&gt;&gt;  let y = Sorted(preSorted: 0..&lt;100, &lt;)  // stores a copy of the range<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Maybe there should also be protocols for this; CountableRange&lt;T&gt; would<br>&gt;&gt;&gt;&gt; already already conform to the immutable version.  We might want a<br>&gt;&gt;&gt;&gt; mutable form of the protocol for sorted collections with<br>&gt;&gt;&gt;&gt; insertion/removal methods.  This whole area needs more design.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree with both of these statements, but not with your conclusion.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are three classes of collections:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1) Those which are always sorted, like a SortedSet.<br>&gt;&gt;&gt; 2) Those which may or may not be sorted, like an Array.<br>&gt;&gt;&gt; 3) Those which are never sorted, like a Set.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; These APIs are useless on a #3, but #2 is still a valuable use case<br>&gt;&gt;&gt; to support. In particular, it&#39;s quite common to use sorted `Array`s,<br>&gt;&gt;&gt; and these APIs would help you do that.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What I might consider doing is tying this to<br>&gt;&gt;&gt; `RangeReplaceableCollection`. That protocol is applied only to types<br>&gt;&gt;&gt; which allow insertion at arbitrary indices, which is a good, though<br>&gt;&gt;&gt; not perfect, proxy for types which might allow you to manually<br>&gt;&gt;&gt; maintain a sort order. `Array`, `ArraySlice`, `ContiguousArray`, and<br>&gt;&gt;&gt; the mutable `String` views would get these methods, while `Set` and<br>&gt;&gt;&gt; `Dictionary` would not.<br>&gt;&gt; <br>&gt;&gt; We could also introduce a new OrderedCollection protocol. (This would<br>&gt;&gt; also be useful in the future for supporting `case` pattern matching on<br>&gt;&gt; collections. It makes sense to pattern-match arrays and other ordered<br>&gt;&gt; collections in order by element, but you&#39;d expect very different<br>&gt;&gt; semantics pattern-matching an unordered Set.)<br>&gt; <br>&gt; What do you mean by “Ordered” here?  Please note that when Cocoa uses<br>&gt; “Ordered” it means something very different from “Sorted.”  I don&#39;t find<br>&gt; the Cocoa usage intuitive myself, but it might be best to avoid that<br>&gt; term to avoid confusion.<br></p><p>By &quot;ordered&quot;, I only mean &quot;ordering is significant to the value of the collection&quot;, so Array is ordered but Set is not.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] SE-0074: Implementation of Binary Search functions</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May 15, 2016 at 10:00:00am</p></header><div class="content"><p>on Fri May 13 2016, Joe Groff &lt;jgroff-AT-apple.com&gt; wrote:<br></p><p>&gt;&gt; On May 13, 2016, at 7:30 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Mon May 09 2016, Joe Groff &lt;jgroff-AT-apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;&gt;&gt; On May 9, 2016, at 6:23 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; * Operations that depend on sorted-ness and use binary predicates should<br>&gt;&gt;&gt;&gt;&gt; not be available on all Collections; they&#39;re too easy to misuse,<br>&gt;&gt;&gt;&gt;&gt; they&#39;re hard to name well, and as Nicola Salmoria has noted, they<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; would not make any sense at all for a Set&lt;T&gt;.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; * They should be scoped to a kind of collection that bundles<br>&gt;&gt;&gt;&gt;&gt; the predicate with the elements, e.g.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  let x = Sorted([3, 4, 1, 5, 2], &gt;)          // stores a sorted copy of the array<br>&gt;&gt;&gt;&gt;&gt;  let y = Sorted(preSorted: 0..&lt;100, &lt;)  // stores a copy of the range<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Maybe there should also be protocols for this; CountableRange&lt;T&gt; would<br>&gt;&gt;&gt;&gt;&gt; already already conform to the immutable version.  We might want a<br>&gt;&gt;&gt;&gt;&gt; mutable form of the protocol for sorted collections with<br>&gt;&gt;&gt;&gt;&gt; insertion/removal methods.  This whole area needs more design.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I agree with both of these statements, but not with your conclusion.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are three classes of collections:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1) Those which are always sorted, like a SortedSet.<br>&gt;&gt;&gt;&gt; 2) Those which may or may not be sorted, like an Array.<br>&gt;&gt;&gt;&gt; 3) Those which are never sorted, like a Set.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; These APIs are useless on a #3, but #2 is still a valuable use case<br>&gt;&gt;&gt;&gt; to support. In particular, it&#39;s quite common to use sorted `Array`s,<br>&gt;&gt;&gt;&gt; and these APIs would help you do that.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What I might consider doing is tying this to<br>&gt;&gt;&gt;&gt; `RangeReplaceableCollection`. That protocol is applied only to types<br>&gt;&gt;&gt;&gt; which allow insertion at arbitrary indices, which is a good, though<br>&gt;&gt;&gt;&gt; not perfect, proxy for types which might allow you to manually<br>&gt;&gt;&gt;&gt; maintain a sort order. `Array`, `ArraySlice`, `ContiguousArray`, and<br>&gt;&gt;&gt;&gt; the mutable `String` views would get these methods, while `Set` and<br>&gt;&gt;&gt;&gt; `Dictionary` would not.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We could also introduce a new OrderedCollection protocol. (This would<br>&gt;&gt;&gt; also be useful in the future for supporting `case` pattern matching on<br>&gt;&gt;&gt; collections. It makes sense to pattern-match arrays and other ordered<br>&gt;&gt;&gt; collections in order by element, but you&#39;d expect very different<br>&gt;&gt;&gt; semantics pattern-matching an unordered Set.)<br>&gt;&gt; <br>&gt;&gt; What do you mean by “Ordered” here?  Please note that when Cocoa uses<br>&gt;&gt; “Ordered” it means something very different from “Sorted.”  I don&#39;t find<br>&gt;&gt; the Cocoa usage intuitive myself, but it might be best to avoid that<br>&gt;&gt; term to avoid confusion.<br>&gt;<br>&gt; By &quot;ordered&quot;, I only mean &quot;ordering is significant to the value of the<br>&gt; collection&quot;, so Array is ordered but Set is not.<br></p><p>Thanks for clarifying.<br></p><p>-- <br>-Dave<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] SE-0074: Implementation of Binary Search functions</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May 13, 2016 at 08:00:00am</p></header><div class="content"><p>on Mon May 09 2016, Brent Royal-Gordon &lt;brent-AT-architechies.com&gt; wrote:<br></p><p>&gt;&gt; * Operations that depend on sorted-ness and use binary predicates should<br>&gt;&gt;  not be available on all Collections; they&#39;re too easy to misuse,<br>&gt;&gt;  they&#39;re hard to name well, and as Nicola Salmoria has noted, they<br>&gt;&gt;  would not make any sense at all for a Set&lt;T&gt;.<br>&gt;&gt; <br>&gt;&gt; * They should be scoped to a kind of collection that bundles<br>&gt;&gt;  the predicate with the elements, e.g.<br>&gt;&gt; <br>&gt;&gt;    let x = Sorted([3, 4, 1, 5, 2], &gt;)          // stores a sorted copy of the array<br>&gt;&gt;    let y = Sorted(preSorted: 0..&lt;100, &lt;)  // stores a copy of the range<br>&gt;&gt; <br>&gt;&gt;  Maybe there should also be protocols for this; CountableRange&lt;T&gt; would<br>&gt;&gt;  already already conform to the immutable version.  We might want a<br>&gt;&gt;  mutable form of the protocol for sorted collections with<br>&gt;&gt;  insertion/removal methods.  This whole area needs more design.<br>&gt;<br>&gt; I agree with both of these statements, but not with your conclusion.<br>&gt;<br>&gt; There are three classes of collections:<br>&gt;<br>&gt; 1) Those which are always sorted, like a SortedSet.<br>&gt; 2) Those which may or may not be sorted, like an Array.<br>&gt; 3) Those which are never sorted, like a Set.<br>&gt;<br>&gt; These APIs are useless on a #3, but #2 is still a valuable use case to<br>&gt; support. In particular, it&#39;s quite common to use sorted `Array`s, and<br>&gt; these APIs would help you do that.<br></p><p>Sorted&lt;Array&lt;T&gt;&gt; would help you do that even more :-)<br></p><p>&gt; What I might consider doing is tying this to<br>&gt; `RangeReplaceableCollection`. That protocol is applied only to types<br>&gt; which allow insertion at arbitrary indices, which is a good, though<br>&gt; not perfect, proxy for types which might allow you to manually<br>&gt; maintain a sort order.  `Array`, `ArraySlice`, `ContiguousArray`, and<br>&gt; the mutable `String` views would get these methods, while `Set` and<br>&gt; `Dictionary` would not.<br></p><p>That&#39;s interesting, but I don&#39;t understand why it&#39;s better than having<br>Sorted.<br></p><p>IME it&#39;s very rare to have a collection that&#39;s transiently sorted and<br>thus appropriate for a binary search.  You may start out un-sorted, but<br>after a bit you&#39;re maintaining sorted order.  It makes sense to reflect<br>that in the type system.<br></p><p>-- <br>-Dave<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5f463dd4e7af28b64ad8f0e032ee82dc?s=50"></div><header><strong>[Review] SE-0074: Implementation of Binary Search functions</strong> from <string>Nate Cook</string> &lt;natecook at gmail.com&gt;<p>May  9, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt;&gt; Proposal:<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0074-binary-search.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0074-binary-search.md&gt;<br>&gt; On May 6, 2016, at 5:16 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I am posting this review on behalf of Dmitri Gribenko, Max Moiseev, and<br>&gt; myself.<br></p><p>Thanks for the feedback! This reply is only from me—I haven&#39;t had a chance to consult with the other authors and they may disagree with me or have better arguments on everything below. <br></p><p>&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt; <br>&gt; We think binary searches are fundamental and important, and want to see<br>&gt; them added.  However, we don&#39;t agree with the form of the current<br>&gt; proposal.  In particular, we think:<br>&gt; <br>&gt; * Operations that depend on sorted-ness and use binary predicates should<br>&gt;  not be available on all Collections; they&#39;re too easy to misuse,<br>&gt;  they&#39;re hard to name well, and as Nicola Salmoria has noted, they<br>&gt;  would not make any sense at all for a Set&lt;T&gt;.<br>&gt; <br>&gt; * They should be scoped to a kind of collection that bundles<br>&gt;  the predicate with the elements, e.g.<br>&gt; <br>&gt;    let x = Sorted([3, 4, 1, 5, 2], &gt;)          // stores a sorted copy of the array<br>&gt;    let y = Sorted(preSorted: 0..&lt;100, &lt;)  // stores a copy of the range<br>&gt; <br>&gt;  Maybe there should also be protocols for this; CountableRange&lt;T&gt; would<br>&gt;  already already conform to the immutable version.  We might want a<br>&gt;  mutable form of the protocol for sorted collections with<br>&gt;  insertion/removal methods.  This whole area needs more design.<br></p><p>I can certainly see this as an alternate approach. I would still prefer to have access to APIs that require but don&#39;t enforce sorting as a precondition, since, as Brent mentioned, sorted arrays are fairly common. That said, if there&#39;s a thoughtfully designed collection protocol and a &quot;sorted collection&quot; wrapper that doe smart things without duplicating storage, I&#39;d be on board with that as well.<br></p><p>&gt; * The polarity of the predicates is wrong: a method with a “where:<br>&gt;  predicate” should always return you the index of an element that<br>&gt;  *does* satisfy the predicate.<br></p><p>Wow, yeah, this is totally backwards. So these should really be: <br></p><p>let a = [10, 20, 30, 30, 30, 40, 60]<br>a.partitionedIndex(where: { $0 &gt;= 20 })     // 1<br></p><p>let lowerBound30 = a.partitionedIndex(where: { $0 &gt;= 30 })<br>let upperBound30 = a.partitionedIndex(where: { $0 &gt; 30 })<br></p><p>&gt; * Any code in the proposal should be updated to:<br>&gt; <br>&gt;  - conform to the new<br>&gt;    indexing model; it still shows indices being moved without<br>&gt;    participation of the collection instance.<br>&gt; <br>&gt;  - attach the @noescape attribute to a parameter&#39;s type, rather than <br>&gt;    its name.<br>&gt; <br>&gt; * The existing partition algorithms in the stdlib are indeed hobbled.<br>&gt;  The more-general partition function is a great idea, but it belongs in<br>&gt;  a separate proposal.<br>&gt; <br>&gt; * Something like the method the proposal calls `partitionedIndex`<br>&gt;  *should* be included in the standard library for Swift 3, with the<br>&gt;  following differences:<br>&gt; <br>&gt;  - it should be called partitionPoint(where:)<br>&gt; <br>&gt;  - the meaning of the predicate result should be inverted so that the<br>&gt;    result of calling the function points to an element actually<br>&gt;    satisfying the predicate<br>&gt; <br>&gt;  This would give people the primitive they need to build higher-level<br>&gt;  functionality without broadening the interface too far, or committing<br>&gt;  us to a design that will be hard to use correctly.<br></p><p>This would definitely be a more limited and focused proposal. Thanks again for the feedback!<br></p><p>Nate<br></p><p>&gt;&gt; 	* Is the problem being addressed significant enough to warrant a<br>&gt;&gt; change to Swift?  <br>&gt; <br>&gt; Yes.<br>&gt; <br>&gt;&gt; * Does this proposal fit well with the feel and direction of Swift?  <br>&gt; <br>&gt; Not as written, we think.<br>&gt; <br>&gt;&gt; * If you have used other languages or libraries with a similar<br>&gt;&gt; feature, how do you feel that this proposal compares to those?<br>&gt; <br>&gt; We have used the C++ standard library and Python&#39;s `bisect` function.<br>&gt; This proposal is obviously inspired by much of the work in C++, but we<br>&gt; think we can do much better for Swift.<br>&gt; <br>&gt;&gt; * How much effort did you put into your review? A glance, a<br>&gt;&gt; quick reading, or an in-depth study?<br>&gt; <br>&gt; An in-depth study.  <br>&gt; <br>&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt; <br>&gt;&gt; Thank you,<br>&gt;&gt; <br>&gt;&gt; -Chris Lattner<br>&gt;&gt; Review Manager<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; Thanks,<br>&gt; <br>&gt; -- <br>&gt; Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160509/9dc00ef4/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Review] SE-0074: Implementation of Binary Search functions</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>May 10, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On May 6, 2016, at 3:16 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; I am posting this review on behalf of Dmitri Gribenko, Max Moiseev, and<br>&gt; myself.<br>&gt; <br>&gt; on Tue May 03 2016, Chris Lattner &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of &quot;SE-0074: Implementation of Binary Search functions&quot;<br>&gt;&gt; begins now and runs through May 9. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0074-binary-search.md<br>&gt;&gt; <br>&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt; <br>&gt;&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt;&gt; <br>&gt;&gt; What goes into a review?<br>&gt;&gt; <br>&gt;&gt; The goal of the review process is to improve the proposal under review<br>&gt;&gt; through constructive criticism and contribute to the direction of<br>&gt;&gt; Swift. When writing your review, here are some questions you might<br>&gt;&gt; want to answer in your review:<br>&gt;&gt; <br>&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt; <br>&gt; We think binary searches are fundamental and important, and want to see<br>&gt; them added.  However, we don&#39;t agree with the form of the current<br>&gt; proposal.  In particular, we think:<br>&gt; <br>&gt; * Operations that depend on sorted-ness and use binary predicates should<br>&gt;  not be available on all Collections; they&#39;re too easy to misuse,<br>&gt;  they&#39;re hard to name well, and as Nicola Salmoria has noted, they<br>&gt;  would not make any sense at all for a Set&lt;T&gt;.<br>&gt; <br>&gt; * They should be scoped to a kind of collection that bundles<br>&gt;  the predicate with the elements, e.g.<br>&gt; <br>&gt;    let x = Sorted([3, 4, 1, 5, 2], &gt;)          // stores a sorted copy of the array<br>&gt;    let y = Sorted(preSorted: 0..&lt;100, &lt;)  // stores a copy of the range<br>&gt; <br>&gt;  Maybe there should also be protocols for this; CountableRange&lt;T&gt; would<br>&gt;  already already conform to the immutable version.  We might want a<br>&gt;  mutable form of the protocol for sorted collections with<br>&gt;  insertion/removal methods.  This whole area needs more design.<br></p><p>I worry that attaching these methods to a strongly-typed `Sorted` wrapper limits their appeal. It&#39;s useful to be able to binary-search through data in a standard container that&#39;s known to be sorted, or over a subregion of the data that&#39;s sorted. While you can of course cobble together a Sorted(Slice(container[sortedRange])), that&#39;s pretty inconvenient. Is misapplying binary search algorithms to unsorted data a big problem in practice in C++?<br></p><p>-Joe<br></p><p>&gt; <br>&gt; * The polarity of the predicates is wrong: a method with a “where:<br>&gt;  predicate” should always return you the index of an element that<br>&gt;  *does* satisfy the predicate.<br>&gt; <br>&gt; * Any code in the proposal should be updated to:<br>&gt; <br>&gt;  - conform to the new<br>&gt;    indexing model; it still shows indices being moved without<br>&gt;    participation of the collection instance.<br>&gt; <br>&gt;  - attach the @noescape attribute to a parameter&#39;s type, rather than <br>&gt;    its name.<br>&gt; <br>&gt; * The existing partition algorithms in the stdlib are indeed hobbled.<br>&gt;  The more-general partition function is a great idea, but it belongs in<br>&gt;  a separate proposal.<br>&gt; <br>&gt; * Something like the method the proposal calls `partitionedIndex`<br>&gt;  *should* be included in the standard library for Swift 3, with the<br>&gt;  following differences:<br>&gt; <br>&gt;  - it should be called partitionPoint(where:)<br>&gt; <br>&gt;  - the meaning of the predicate result should be inverted so that the<br>&gt;    result of calling the function points to an element actually<br>&gt;    satisfying the predicate<br>&gt; <br>&gt;  This would give people the primitive they need to build higher-level<br>&gt;  functionality without broadening the interface too far, or committing<br>&gt;  us to a design that will be hard to use correctly.<br>&gt; <br>&gt;&gt; 	* Is the problem being addressed significant enough to warrant a<br>&gt;&gt; change to Swift?  <br>&gt; <br>&gt; Yes.<br>&gt; <br>&gt;&gt; * Does this proposal fit well with the feel and direction of Swift?  <br>&gt; <br>&gt; Not as written, we think.<br>&gt; <br>&gt;&gt; * If you have used other languages or libraries with a similar<br>&gt;&gt; feature, how do you feel that this proposal compares to those?<br>&gt; <br>&gt; We have used the C++ standard library and Python&#39;s `bisect` function.<br>&gt; This proposal is obviously inspired by much of the work in C++, but we<br>&gt; think we can do much better for Swift.<br>&gt; <br>&gt;&gt; * How much effort did you put into your review? A glance, a<br>&gt;&gt; quick reading, or an in-depth study?<br>&gt; <br>&gt; An in-depth study.  <br>&gt; <br>&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt; <br>&gt;&gt; Thank you,<br>&gt;&gt; <br>&gt;&gt; -Chris Lattner<br>&gt;&gt; Review Manager<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; Thanks,<br>&gt; <br>&gt; -- <br>&gt; Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a6a2eebe83a60a4b42395145484cda15?s=50"></div><header><strong>[Review] SE-0074: Implementation of Binary Search functions</strong> from <string>Daniel Vollmer</string> &lt;lists at maven.de&gt;<p>May 11, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On 10 May 2016, at 19:36, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I worry that attaching these methods to a strongly-typed `Sorted` wrapper limits their appeal. It&#39;s useful to be able to binary-search through data in a standard container that&#39;s known to be sorted, or over a subregion of the data that&#39;s sorted. While you can of course cobble together a Sorted(Slice(container[sortedRange])), that&#39;s pretty inconvenient. Is misapplying binary search algorithms to unsorted data a big problem in practice in C++?<br></p><p>I agree with Joe here, just look at the recursive construction of a kd-tree where you recursively sort (and then search for a partitioning point) in smaller and smaller slices sorted along different dimensions.<br></p><p>I don’t think misapplying is a big problem in C++.<br></p><p>	Daniel.<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
