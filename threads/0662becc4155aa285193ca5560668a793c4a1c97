<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a39ef1491768b90e7de8e0ec4d0b0091?s=50"></div><header><strong>Auto-generate op==?</strong> from <string>Daniel Tartaglia</string> &lt;danielt1263 at gmail.com&gt;<p>February 12, 2016 at 03:00:00pm</p></header><div class="content"><p>In Haskell, we can mark a data block as deriving from Eq and it will auto-generate the == operator.<br></p><p>I would like to see Swift auto-generate the == operator if a struct implements Equatable. Obviously, it would only be able to do this if all the structs members implemented Equatable themselves.<br></p><p>Has this idea already been proposed? I didn’t see it at the github repo…<br></p><p>Thanks,<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Auto-generate op==?</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>February 12, 2016 at 03:00:00pm</p></header><div class="content"><p>+1, but...<br></p><p>I don&#39;t know what the actual reason this isn&#39;t in the language is, but the main issue I see is that there isn&#39;t a generic way to iterate over the properties of a struct or class. This *might* change if the proposal for iterating over a tuple goes through... An object could, I think, store all its non-computed properties in a tuple, and if *that* is equatable, then a generic == could probably be written.<br></p><p>The obvious reply is, &quot;Well then why not use compiler magic&quot;, to which I say, &quot;Because it&#39;s better to extend the language than to rely on compiler magic.&quot;<br></p><p>IMHO, this sounds like is one of several suggestions that most people will probably want, but that simply can&#39;t be done until Swift gains either a mechanism for generically processing tuples, and/or a macro system, both of which have been declared out of scope until it&#39;s time to start talking about Swift 3.<br></p><p>- Dave Sweeris<br></p><p>&gt; On Feb 12, 2016, at 14:47, Daniel Tartaglia via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; In Haskell, we can mark a data block as deriving from Eq and it will auto-generate the == operator.<br>&gt; <br>&gt; I would like to see Swift auto-generate the == operator if a struct implements Equatable. Obviously, it would only be able to do this if all the structs members implemented Equatable themselves.<br>&gt; <br>&gt; Has this idea already been proposed? I didn’t see it at the github repo…<br>&gt; <br>&gt; Thanks,<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05e222e6ef4d84013bb3baeb0e25c90b?s=50"></div><header><strong>Auto-generate op==?</strong> from <string>Patrick Gili</string> &lt;gili.patrick.r at gili-labs.com&gt;<p>February 13, 2016 at 12:00:00pm</p></header><div class="content"><p>Not having a lot of experience with Haskell, can you provide an example, so that we can better understand what you&#39;re proposing?<br></p><p>Cheers,<br>-Patrick<br></p><p>&gt; On Feb 12, 2016, at 3:47 PM, Daniel Tartaglia via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; In Haskell, we can mark a data block as deriving from Eq and it will auto-generate the == operator.<br>&gt; <br>&gt; I would like to see Swift auto-generate the == operator if a struct implements Equatable. Obviously, it would only be able to do this if all the structs members implemented Equatable themselves.<br>&gt; <br>&gt; Has this idea already been proposed? I didn’t see it at the github repo…<br>&gt; <br>&gt; Thanks,<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f5228ad4a1fad94f1a7d3d05b0c0ff6a?s=50"></div><header><strong>Auto-generate op==?</strong> from <string>Donnacha Oisín Kidney</string> &lt;oisin.kidney at gmail.com&gt;<p>February 13, 2016 at 05:00:00pm</p></header><div class="content"><p>In Haskell, when you declare a datatype, you can follow it with a “deriving” clause, and it will derive several typeclasses (which are Haskell’s equivalent to protocols):<br></p><p>data Person = Person { name :: String, age :: Int } deriving Eq<br></p><p>In Swift, I’d imaging the equivalent would be something like:<br></p><p>struct Person {<br>  let name: String<br>  let age: Int<br>} deriving Equatable<br></p><p>&gt; On 13 Feb 2016, at 17:04, Patrick Gili via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Not having a lot of experience with Haskell, can you provide an example, so that we can better understand what you&#39;re proposing?<br>&gt; <br>&gt; Cheers,<br>&gt; -Patrick<br>&gt; <br>&gt;&gt; On Feb 12, 2016, at 3:47 PM, Daniel Tartaglia via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; In Haskell, we can mark a data block as deriving from Eq and it will auto-generate the == operator.<br>&gt;&gt; <br>&gt;&gt; I would like to see Swift auto-generate the == operator if a struct implements Equatable. Obviously, it would only be able to do this if all the structs members implemented Equatable themselves.<br>&gt;&gt; <br>&gt;&gt; Has this idea already been proposed? I didn’t see it at the github repo…<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160213/508b2cb6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0f163c0be9c7f32231614d28b2ceccab?s=50"></div><header><strong>Auto-generate op==?</strong> from <string>Donald Pinckney</string> &lt;djpinckney at ucdavis.edu&gt;<p>February 13, 2016 at 09:00:00am</p></header><div class="content"><p>To make sure I understand correctly, what you are discussing is having == be auto generated in some way for types. The automatic implementation of == would be a member wise logical and operation:<br></p><p>struct Person {<br>   let age: Int<br>   let name: String<br>} deriving Equatable<br></p><p>Would also generate:<br>func ==(left: Person, right: Person) -&gt; Bool {<br>   return left.age == right.age &amp;&amp; left.name == right.name;<br>}<br></p><p>The compiler would only do this if all data members implement (or derive) the Equatable protocol, and probably error otherwise.<br></p><p>That&#39;s my interpretation.  If I misunderstood, please correct me.  <br></p><p>As it stands, I think something like this is a fabulous idea, as I have recently found myself writing lots of member wise equality checks.<br></p><p>Donald Pinckney<br></p><p>Sent from my iPhone<br></p><p>&gt; On Feb 13, 2016, at 9:12 AM, Donnacha Oisín Kidney via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; In Haskell, when you declare a datatype, you can follow it with a “deriving” clause, and it will derive several typeclasses (which are Haskell’s equivalent to protocols):<br>&gt; <br>&gt; data Person = Person { name :: String, age :: Int } deriving Eq<br>&gt; <br>&gt; In Swift, I’d imaging the equivalent would be something like:<br>&gt; <br>&gt; struct Person {<br>&gt;   let name: String<br>&gt;   let age: Int<br>&gt; } deriving Equatable<br>&gt; <br>&gt;&gt; On 13 Feb 2016, at 17:04, Patrick Gili via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Not having a lot of experience with Haskell, can you provide an example, so that we can better understand what you&#39;re proposing?<br>&gt;&gt; <br>&gt;&gt; Cheers,<br>&gt;&gt; -Patrick<br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 12, 2016, at 3:47 PM, Daniel Tartaglia via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In Haskell, we can mark a data block as deriving from Eq and it will auto-generate the == operator.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would like to see Swift auto-generate the == operator if a struct implements Equatable. Obviously, it would only be able to do this if all the structs members implemented Equatable themselves.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Has this idea already been proposed? I didn’t see it at the github repo…<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160213/bf3e4c17/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a39ef1491768b90e7de8e0ec4d0b0091?s=50"></div><header><strong>Auto-generate op==?</strong> from <string>Daniel Tartaglia</string> &lt;danielt1263 at gmail.com&gt;<p>February 13, 2016 at 03:00:00pm</p></header><div class="content"><p>Yes, that&#39;s exactly what I am suggesting. Maybe even do the same for Hashable. (And any other protocol where there is an obvious implementation...)<br></p><p>As for syntax, I don&#39;t much care. A &quot;deriving&quot; keyword could be added, or maybe if you mark the type as Equatable and don&#39;t provide an implantation, it would auto-generate one for you, or error out.<br></p><p>I personally feel that most value types should be equatable, but I tend not to do it purely because of all the boilerplate required. This sort of mechanism would help tremendously. <br></p><p>I don&#39;t see any reason to limit such an idea to just value types, but that is where it&#39;s most  needed IMHO.<br></p><p>Based on an earlier comment, this type of feature would probably have to wait until 3.0, but I wanted to put the idea out there.<br></p><p><br>Sent from my iPad<br></p><p>&gt; On Feb 13, 2016, at 12:38 PM, Donald Pinckney &lt;djpinckney at ucdavis.edu&gt; wrote:<br>&gt; <br>&gt; To make sure I understand correctly, what you are discussing is having == be auto generated in some way for types. The automatic implementation of == would be a member wise logical and operation:<br>&gt; <br>&gt; struct Person {<br>&gt;    let age: Int<br>&gt;    let name: String<br>&gt; } deriving Equatable<br>&gt; <br>&gt; Would also generate:<br>&gt; func ==(left: Person, right: Person) -&gt; Bool {<br>&gt;    return left.age == right.age &amp;&amp; left.name == right.name;<br>&gt; }<br>&gt; <br>&gt; The compiler would only do this if all data members implement (or derive) the Equatable protocol, and probably error otherwise.<br>&gt; <br>&gt; That&#39;s my interpretation.  If I misunderstood, please correct me.  <br>&gt; <br>&gt; As it stands, I think something like this is a fabulous idea, as I have recently found myself writing lots of member wise equality checks.<br>&gt; <br>&gt; Donald Pinckney<br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt;&gt; On Feb 13, 2016, at 9:12 AM, Donnacha Oisín Kidney via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; In Haskell, when you declare a datatype, you can follow it with a “deriving” clause, and it will derive several typeclasses (which are Haskell’s equivalent to protocols):<br>&gt;&gt; <br>&gt;&gt; data Person = Person { name :: String, age :: Int } deriving Eq<br>&gt;&gt; <br>&gt;&gt; In Swift, I’d imaging the equivalent would be something like:<br>&gt;&gt; <br>&gt;&gt; struct Person {<br>&gt;&gt;   let name: String<br>&gt;&gt;   let age: Int<br>&gt;&gt; } deriving Equatable<br>&gt;&gt; <br>&gt;&gt;&gt; On 13 Feb 2016, at 17:04, Patrick Gili via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Not having a lot of experience with Haskell, can you provide an example, so that we can better understand what you&#39;re proposing?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt; -Patrick<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 12, 2016, at 3:47 PM, Daniel Tartaglia via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In Haskell, we can mark a data block as deriving from Eq and it will auto-generate the == operator.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I would like to see Swift auto-generate the == operator if a struct implements Equatable. Obviously, it would only be able to do this if all the structs members implemented Equatable themselves.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Has this idea already been proposed? I didn’t see it at the github repo…<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160213/001ea5f1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ab486d7597af4cfe0be33a762150848?s=50"></div><header><strong>Auto-generate op==?</strong> from <string>Dany St-Amant</string> &lt;dsa.mls at icloud.com&gt;<p>February 13, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; Le 13 févr. 2016 à 15:54, Daniel T. via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Yes, that&#39;s exactly what I am suggesting. Maybe even do the same for Hashable. (And any other protocol where there is an obvious implementation...)<br>&gt; <br>&gt; As for syntax, I don&#39;t much care. A &quot;deriving&quot; keyword could be added, or maybe if you mark the type as Equatable and don&#39;t provide an implantation, it would auto-generate one for you, or error out.<br></p><p>For safety the programmer must opt-in via a keyword like this ‘deriving’, as an implicit auto-generated implementation may not give the proper result.<br></p><p>struct fraction {<br>    var numerator: Int<br>    var denominator: Int<br>}<br></p><p>An auto-generared implementation will say that 1/2 and 3/6 are different, while a properly implemented Equatable function will report equality.<br></p><p>Dany<br></p><p>&gt; I personally feel that most value types should be equatable, but I tend not to do it purely because of all the boilerplate required. This sort of mechanism would help tremendously. <br>&gt; <br>&gt; I don&#39;t see any reason to limit such an idea to just value types, but that is where it&#39;s most  needed IMHO.<br>&gt; <br>&gt; Based on an earlier comment, this type of feature would probably have to wait until 3.0, but I wanted to put the idea out there.<br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On Feb 13, 2016, at 12:38 PM, Donald Pinckney &lt;djpinckney at ucdavis.edu &lt;mailto:djpinckney at ucdavis.edu&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; To make sure I understand correctly, what you are discussing is having == be auto generated in some way for types. The automatic implementation of == would be a member wise logical and operation:<br>&gt;&gt; <br>&gt;&gt; struct Person {<br>&gt;&gt;    let age: Int<br>&gt;&gt;    let name: String<br>&gt;&gt; } deriving Equatable<br>&gt;&gt; <br>&gt;&gt; Would also generate:<br>&gt;&gt; func ==(left: Person, right: Person) -&gt; Bool {<br>&gt;&gt;    return left.age == right.age &amp;&amp; left.name == right.name;<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The compiler would only do this if all data members implement (or derive) the Equatable protocol, and probably error otherwise.<br>&gt;&gt; <br>&gt;&gt; That&#39;s my interpretation.  If I misunderstood, please correct me.  <br>&gt;&gt; <br>&gt;&gt; As it stands, I think something like this is a fabulous idea, as I have recently found myself writing lots of member wise equality checks.<br>&gt;&gt; <br>&gt;&gt; Donald Pinckney<br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt; On Feb 13, 2016, at 9:12 AM, Donnacha Oisín Kidney via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; In Haskell, when you declare a datatype, you can follow it with a “deriving” clause, and it will derive several typeclasses (which are Haskell’s equivalent to protocols):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; data Person = Person { name :: String, age :: Int } deriving Eq<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In Swift, I’d imaging the equivalent would be something like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Person {<br>&gt;&gt;&gt;   let name: String<br>&gt;&gt;&gt;   let age: Int<br>&gt;&gt;&gt; } deriving Equatable<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 13 Feb 2016, at 17:04, Patrick Gili via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Not having a lot of experience with Haskell, can you provide an example, so that we can better understand what you&#39;re proposing?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt; -Patrick<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Feb 12, 2016, at 3:47 PM, Daniel Tartaglia via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In Haskell, we can mark a data block as deriving from Eq and it will auto-generate the == operator.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I would like to see Swift auto-generate the == operator if a struct implements Equatable. Obviously, it would only be able to do this if all the structs members implemented Equatable themselves.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Has this idea already been proposed? I didn’t see it at the github repo…<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160213/7b510c3f/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05e222e6ef4d84013bb3baeb0e25c90b?s=50"></div><header><strong>Auto-generate op==?</strong> from <string>Patrick Gili</string> &lt;gili.patrick.r at gili-labs.com&gt;<p>February 13, 2016 at 04:00:00pm</p></header><div class="content"><p>I&#39;ve been playing with the concept in Haskell, and I like the concept. However, I don&#39;t like the proposed syntax, as it is not consistent the rest of the language. Maybe something like<br></p><p>struct Person : deriving Equatable {<br>    let age: Int<br>    let name: String<br>}<br></p><p>or <br></p><p>struct Person : @deriving Equatable {<br>    let age: Int<br>    let name: String<br>}<br></p><p>-Patrick<br></p><p>&gt; On Feb 13, 2016, at 12:38 PM, Donald Pinckney &lt;djpinckney at ucdavis.edu&gt; wrote:<br>&gt; <br>&gt; To make sure I understand correctly, what you are discussing is having == be auto generated in some way for types. The automatic implementation of == would be a member wise logical and operation:<br>&gt; <br>&gt; struct Person {<br>&gt;    let age: Int<br>&gt;    let name: String<br>&gt; } deriving Equatable<br>&gt; <br>&gt; Would also generate:<br>&gt; func ==(left: Person, right: Person) -&gt; Bool {<br>&gt;    return left.age == right.age &amp;&amp; left.name == right.name;<br>&gt; }<br>&gt; <br>&gt; The compiler would only do this if all data members implement (or derive) the Equatable protocol, and probably error otherwise.<br>&gt; <br>&gt; That&#39;s my interpretation.  If I misunderstood, please correct me.  <br>&gt; <br>&gt; As it stands, I think something like this is a fabulous idea, as I have recently found myself writing lots of member wise equality checks.<br>&gt; <br>&gt; Donald Pinckney<br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt; On Feb 13, 2016, at 9:12 AM, Donnacha Oisín Kidney via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; In Haskell, when you declare a datatype, you can follow it with a “deriving” clause, and it will derive several typeclasses (which are Haskell’s equivalent to protocols):<br>&gt;&gt; <br>&gt;&gt; data Person = Person { name :: String, age :: Int } deriving Eq<br>&gt;&gt; <br>&gt;&gt; In Swift, I’d imaging the equivalent would be something like:<br>&gt;&gt; <br>&gt;&gt; struct Person {<br>&gt;&gt;   let name: String<br>&gt;&gt;   let age: Int<br>&gt;&gt; } deriving Equatable<br>&gt;&gt; <br>&gt;&gt;&gt; On 13 Feb 2016, at 17:04, Patrick Gili via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Not having a lot of experience with Haskell, can you provide an example, so that we can better understand what you&#39;re proposing?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt; -Patrick<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 12, 2016, at 3:47 PM, Daniel Tartaglia via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In Haskell, we can mark a data block as deriving from Eq and it will auto-generate the == operator.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I would like to see Swift auto-generate the == operator if a struct implements Equatable. Obviously, it would only be able to do this if all the structs members implemented Equatable themselves.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Has this idea already been proposed? I didn’t see it at the github repo…<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160213/6c8a21b4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>Auto-generate op==?</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>February 13, 2016 at 04:00:00pm</p></header><div class="content"><p>I&#39;d be in favor of forgoing the keyword addition and just prefixing compiler-derivable protocols with a # or @.  Save `deriving` for later extensions to a future generalized deriving mechanism.<br></p><p>~Robert Widmann<br></p><p>2016/02/13 16:29、Patrick Gili via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br></p><p>&gt; I&#39;ve been playing with the concept in Haskell, and I like the concept. However, I don&#39;t like the proposed syntax, as it is not consistent the rest of the language. Maybe something like<br>&gt; <br>&gt; struct Person : deriving Equatable {<br>&gt;     let age: Int<br>&gt;     let name: String<br>&gt; }<br>&gt; <br>&gt; or <br>&gt; <br>&gt; struct Person : @deriving Equatable {<br>&gt;     let age: Int<br>&gt;     let name: String<br>&gt; }<br>&gt; <br>&gt; -Patrick<br>&gt; <br>&gt;&gt; On Feb 13, 2016, at 12:38 PM, Donald Pinckney &lt;djpinckney at ucdavis.edu&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; To make sure I understand correctly, what you are discussing is having == be auto generated in some way for types. The automatic implementation of == would be a member wise logical and operation:<br>&gt;&gt; <br>&gt;&gt; struct Person {<br>&gt;&gt;    let age: Int<br>&gt;&gt;    let name: String<br>&gt;&gt; } deriving Equatable<br>&gt;&gt; <br>&gt;&gt; Would also generate:<br>&gt;&gt; func ==(left: Person, right: Person) -&gt; Bool {<br>&gt;&gt;    return left.age == right.age &amp;&amp; left.name == right.name;<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The compiler would only do this if all data members implement (or derive) the Equatable protocol, and probably error otherwise.<br>&gt;&gt; <br>&gt;&gt; That&#39;s my interpretation.  If I misunderstood, please correct me.  <br>&gt;&gt; <br>&gt;&gt; As it stands, I think something like this is a fabulous idea, as I have recently found myself writing lots of member wise equality checks.<br>&gt;&gt; <br>&gt;&gt; Donald Pinckney<br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 13, 2016, at 9:12 AM, Donnacha Oisín Kidney via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In Haskell, when you declare a datatype, you can follow it with a “deriving” clause, and it will derive several typeclasses (which are Haskell’s equivalent to protocols):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; data Person = Person { name :: String, age :: Int } deriving Eq<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In Swift, I’d imaging the equivalent would be something like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Person {<br>&gt;&gt;&gt;   let name: String<br>&gt;&gt;&gt;   let age: Int<br>&gt;&gt;&gt; } deriving Equatable<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 13 Feb 2016, at 17:04, Patrick Gili via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Not having a lot of experience with Haskell, can you provide an example, so that we can better understand what you&#39;re proposing?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt; -Patrick<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Feb 12, 2016, at 3:47 PM, Daniel Tartaglia via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In Haskell, we can mark a data block as deriving from Eq and it will auto-generate the == operator.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I would like to see Swift auto-generate the == operator if a struct implements Equatable. Obviously, it would only be able to do this if all the structs members implemented Equatable themselves.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Has this idea already been proposed? I didn’t see it at the github repo…<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160213/4a649253/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05e222e6ef4d84013bb3baeb0e25c90b?s=50"></div><header><strong>Auto-generate op==?</strong> from <string>Patrick Gili</string> &lt;gili.patrick.r at gili-labs.com&gt;<p>February 13, 2016 at 05:00:00pm</p></header><div class="content"><p>Agreed.<br></p><p>In the property behaviors review, Chris Lattner mentioned that there is a trend to use # to denote compiler synthesis. Thus, this is probably a good alternative.<br></p><p>Cheers,<br>-Patrick<br></p><p>&gt; On Feb 13, 2016, at 4:37 PM, Developer &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt; <br>&gt; I&#39;d be in favor of forgoing the keyword addition and just prefixing compiler-derivable protocols with a # or @.  Save `deriving` for later extensions to a future generalized deriving mechanism.<br>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt; 2016/02/13 16:29、Patrick Gili via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; のメッセージ:<br>&gt; <br>&gt;&gt; I&#39;ve been playing with the concept in Haskell, and I like the concept. However, I don&#39;t like the proposed syntax, as it is not consistent the rest of the language. Maybe something like<br>&gt;&gt; <br>&gt;&gt; struct Person : deriving Equatable {<br>&gt;&gt;     let age: Int<br>&gt;&gt;     let name: String<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; or <br>&gt;&gt; <br>&gt;&gt; struct Person : @deriving Equatable {<br>&gt;&gt;     let age: Int<br>&gt;&gt;     let name: String<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; -Patrick<br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 13, 2016, at 12:38 PM, Donald Pinckney &lt;djpinckney at ucdavis.edu &lt;mailto:djpinckney at ucdavis.edu&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To make sure I understand correctly, what you are discussing is having == be auto generated in some way for types. The automatic implementation of == would be a member wise logical and operation:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Person {<br>&gt;&gt;&gt;    let age: Int<br>&gt;&gt;&gt;    let name: String<br>&gt;&gt;&gt; } deriving Equatable<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Would also generate:<br>&gt;&gt;&gt; func ==(left: Person, right: Person) -&gt; Bool {<br>&gt;&gt;&gt;    return left.age == right.age &amp;&amp; left.name == right.name;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The compiler would only do this if all data members implement (or derive) the Equatable protocol, and probably error otherwise.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That&#39;s my interpretation.  If I misunderstood, please correct me.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As it stands, I think something like this is a fabulous idea, as I have recently found myself writing lots of member wise equality checks.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Donald Pinckney<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Feb 13, 2016, at 9:12 AM, Donnacha Oisín Kidney via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In Haskell, when you declare a datatype, you can follow it with a “deriving” clause, and it will derive several typeclasses (which are Haskell’s equivalent to protocols):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; data Person = Person { name :: String, age :: Int } deriving Eq<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In Swift, I’d imaging the equivalent would be something like:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct Person {<br>&gt;&gt;&gt;&gt;   let name: String<br>&gt;&gt;&gt;&gt;   let age: Int<br>&gt;&gt;&gt;&gt; } deriving Equatable<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 13 Feb 2016, at 17:04, Patrick Gili via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Not having a lot of experience with Haskell, can you provide an example, so that we can better understand what you&#39;re proposing?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt;&gt; -Patrick<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Feb 12, 2016, at 3:47 PM, Daniel Tartaglia via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In Haskell, we can mark a data block as deriving from Eq and it will auto-generate the == operator.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I would like to see Swift auto-generate the == operator if a struct implements Equatable. Obviously, it would only be able to do this if all the structs members implemented Equatable themselves.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Has this idea already been proposed? I didn’t see it at the github repo…<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160213/b6ef9c1a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Auto-generate op==?</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>February 13, 2016 at 11:00:00pm</p></header><div class="content"><p>I discussed this recently,  there are two things that might be worth considering at the same time:<br></p><p>There should probably be an attribute so that we can indicate properties that should not be compared. This would also be a useful way to tell the compiler to ignore non-equatable values if we don’t actually care about them in the comparison.<br>It might be nice now or in future if we could also build upon the auto-generated implementation. For example, by marking properties as ignored like I say, we could then add custom code for these while still letting the compiler auto-generate the simpler cases for us.<br></p><p>&gt; On 13 Feb 2016, at 22:32, Patrick Gili via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Agreed.<br>&gt; <br>&gt; In the property behaviors review, Chris Lattner mentioned that there is a trend to use # to denote compiler synthesis. Thus, this is probably a good alternative.<br>&gt; <br>&gt; Cheers,<br>&gt; -Patrick<br>&gt; <br>&gt;&gt; On Feb 13, 2016, at 4:37 PM, Developer &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;d be in favor of forgoing the keyword addition and just prefixing compiler-derivable protocols with a # or @.  Save `deriving` for later extensions to a future generalized deriving mechanism.<br>&gt;&gt; <br>&gt;&gt; ~Robert Widmann<br>&gt;&gt; <br>&gt;&gt; 2016/02/13 16:29、Patrick Gili via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; のメッセージ:<br>&gt;&gt; <br>&gt;&gt;&gt; I&#39;ve been playing with the concept in Haskell, and I like the concept. However, I don&#39;t like the proposed syntax, as it is not consistent the rest of the language. Maybe something like<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Person : deriving Equatable {<br>&gt;&gt;&gt;     let age: Int<br>&gt;&gt;&gt;     let name: String<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; or <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Person : @deriving Equatable {<br>&gt;&gt;&gt;     let age: Int<br>&gt;&gt;&gt;     let name: String<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Patrick<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 13, 2016, at 12:38 PM, Donald Pinckney &lt;djpinckney at ucdavis.edu &lt;mailto:djpinckney at ucdavis.edu&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; To make sure I understand correctly, what you are discussing is having == be auto generated in some way for types. The automatic implementation of == would be a member wise logical and operation:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct Person {<br>&gt;&gt;&gt;&gt;    let age: Int<br>&gt;&gt;&gt;&gt;    let name: String<br>&gt;&gt;&gt;&gt; } deriving Equatable<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Would also generate:<br>&gt;&gt;&gt;&gt; func ==(left: Person, right: Person) -&gt; Bool {<br>&gt;&gt;&gt;&gt;    return left.age == right.age &amp;&amp; left.name == right.name;<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The compiler would only do this if all data members implement (or derive) the Equatable protocol, and probably error otherwise.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That&#39;s my interpretation.  If I misunderstood, please correct me.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As it stands, I think something like this is a fabulous idea, as I have recently found myself writing lots of member wise equality checks.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Donald Pinckney<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 13, 2016, at 9:12 AM, Donnacha Oisín Kidney via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In Haskell, when you declare a datatype, you can follow it with a “deriving” clause, and it will derive several typeclasses (which are Haskell’s equivalent to protocols):<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; data Person = Person { name :: String, age :: Int } deriving Eq<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In Swift, I’d imaging the equivalent would be something like:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; struct Person {<br>&gt;&gt;&gt;&gt;&gt;   let name: String<br>&gt;&gt;&gt;&gt;&gt;   let age: Int<br>&gt;&gt;&gt;&gt;&gt; } deriving Equatable<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 13 Feb 2016, at 17:04, Patrick Gili via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Not having a lot of experience with Haskell, can you provide an example, so that we can better understand what you&#39;re proposing?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt;&gt;&gt; -Patrick<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Feb 12, 2016, at 3:47 PM, Daniel Tartaglia via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; In Haskell, we can mark a data block as deriving from Eq and it will auto-generate the == operator.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I would like to see Swift auto-generate the == operator if a struct implements Equatable. Obviously, it would only be able to do this if all the structs members implemented Equatable themselves.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Has this idea already been proposed? I didn’t see it at the github repo…<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160213/dd4578b6/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Auto-generate op==?</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 13, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; I discussed this recently,  there are two things that might be worth considering at the same time:<br>&gt; <br>&gt; 	• There should probably be an attribute so that we can indicate properties that should not be compared. This would also be a useful way to tell the compiler to ignore non-equatable values if we don’t actually care about them in the comparison.<br>&gt; 	• It might be nice now or in future if we could also build upon the auto-generated implementation. For example, by marking properties as ignored like I say, we could then add custom code for these while still letting the compiler auto-generate the simpler cases for us.<br></p><p>I&#39;d worry that this might lead us into the same territory that got memberwise init into trouble.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a39ef1491768b90e7de8e0ec4d0b0091?s=50"></div><header><strong>Auto-generate op==?</strong> from <string>Daniel Tartaglia</string> &lt;danielt1263 at gmail.com&gt;<p>February 13, 2016 at 10:00:00pm</p></header><div class="content"><p>I don&#39;t think all that is necessary. If you don&#39;t like the default implementation for some reason, just implement it yourself. The point of this idea is to make the common case easy.<br></p><p>If the system you are talking about was in place, readers couldn&#39;t trust the derived implementation without first examining the entire definition. Your additions would also discourage adding other derived methods in the future. One set of annotations for Equatable, another set for Hashable, another set for DebugPrintable... Such a system would be unwieldy to say the least.<br></p><p>Sent from my iPad<br></p><p>&gt; On Feb 13, 2016, at 6:43 PM, Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br>&gt; <br>&gt; I discussed this recently,  there are two things that might be worth considering at the same time:<br>&gt; <br>&gt; There should probably be an attribute so that we can indicate properties that should not be compared. This would also be a useful way to tell the compiler to ignore non-equatable values if we don’t actually care about them in the comparison.<br>&gt; It might be nice now or in future if we could also build upon the auto-generated implementation. For example, by marking properties as ignored like I say, we could then add custom code for these while still letting the compiler auto-generate the simpler cases for us.<br>&gt; <br>&gt;&gt; On 13 Feb 2016, at 22:32, Patrick Gili via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Agreed.<br>&gt;&gt; <br>&gt;&gt; In the property behaviors review, Chris Lattner mentioned that there is a trend to use # to denote compiler synthesis. Thus, this is probably a good alternative.<br>&gt;&gt; <br>&gt;&gt; Cheers,<br>&gt;&gt; -Patrick<br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 13, 2016, at 4:37 PM, Developer &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;d be in favor of forgoing the keyword addition and just prefixing compiler-derivable protocols with a # or @.  Save `deriving` for later extensions to a future generalized deriving mechanism.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2016/02/13 16:29、Patrick Gili via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;ve been playing with the concept in Haskell, and I like the concept. However, I don&#39;t like the proposed syntax, as it is not consistent the rest of the language. Maybe something like<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct Person : deriving Equatable {<br>&gt;&gt;&gt;&gt;     let age: Int<br>&gt;&gt;&gt;&gt;     let name: String<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; or <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct Person : @deriving Equatable {<br>&gt;&gt;&gt;&gt;     let age: Int<br>&gt;&gt;&gt;&gt;     let name: String<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Patrick<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Feb 13, 2016, at 12:38 PM, Donald Pinckney &lt;djpinckney at ucdavis.edu&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; To make sure I understand correctly, what you are discussing is having == be auto generated in some way for types. The automatic implementation of == would be a member wise logical and operation:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; struct Person {<br>&gt;&gt;&gt;&gt;&gt;    let age: Int<br>&gt;&gt;&gt;&gt;&gt;    let name: String<br>&gt;&gt;&gt;&gt;&gt; } deriving Equatable<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Would also generate:<br>&gt;&gt;&gt;&gt;&gt; func ==(left: Person, right: Person) -&gt; Bool {<br>&gt;&gt;&gt;&gt;&gt;    return left.age == right.age &amp;&amp; left.name == right.name;<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The compiler would only do this if all data members implement (or derive) the Equatable protocol, and probably error otherwise.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That&#39;s my interpretation.  If I misunderstood, please correct me.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; As it stands, I think something like this is a fabulous idea, as I have recently found myself writing lots of member wise equality checks.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Donald Pinckney<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Feb 13, 2016, at 9:12 AM, Donnacha Oisín Kidney via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In Haskell, when you declare a datatype, you can follow it with a “deriving” clause, and it will derive several typeclasses (which are Haskell’s equivalent to protocols):<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; data Person = Person { name :: String, age :: Int } deriving Eq<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In Swift, I’d imaging the equivalent would be something like:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; struct Person {<br>&gt;&gt;&gt;&gt;&gt;&gt;   let name: String<br>&gt;&gt;&gt;&gt;&gt;&gt;   let age: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; } deriving Equatable<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 13 Feb 2016, at 17:04, Patrick Gili via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Not having a lot of experience with Haskell, can you provide an example, so that we can better understand what you&#39;re proposing?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Patrick<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Feb 12, 2016, at 3:47 PM, Daniel Tartaglia via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In Haskell, we can mark a data block as deriving from Eq and it will auto-generate the == operator.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I would like to see Swift auto-generate the == operator if a struct implements Equatable. Obviously, it would only be able to do this if all the structs members implemented Equatable themselves.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Has this idea already been proposed? I didn’t see it at the github repo…<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160213/998a89d7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Auto-generate op==?</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>February 14, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On 14 Feb 2016, at 03:44, danielt1263 at gmail.com wrote:<br>&gt; <br>&gt; I don&#39;t think all that is necessary. If you don&#39;t like the default implementation for some reason, just implement it yourself. The point of this idea is to make the common case easy.<br>&gt; <br>&gt; If the system you are talking about was in place, readers couldn&#39;t trust the derived implementation without first examining the entire definition. Your additions would also discourage adding other derived methods in the future. One set of annotations for Equatable, another set for Hashable, another set for DebugPrintable... Such a system would be unwieldy to say the least.<br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On Feb 13, 2016, at 6:43 PM, Haravikk &lt;swift-evolution at haravikk.me &lt;mailto:swift-evolution at haravikk.me&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; I discussed this recently,  there are two things that might be worth considering at the same time:<br>&gt;&gt; <br>&gt;&gt; There should probably be an attribute so that we can indicate properties that should not be compared. This would also be a useful way to tell the compiler to ignore non-equatable values if we don’t actually care about them in the comparison.<br>&gt;&gt; It might be nice now or in future if we could also build upon the auto-generated implementation. For example, by marking properties as ignored like I say, we could then add custom code for these while still letting the compiler auto-generate the simpler cases for us.<br></p><p>I could say the same about any derived implementation, as you may not to check to be 100% sure that ever property is valid for the comparison. I get that extending the derived function has other complexities, but I’ve had complex types in the past (not in Swift) that would have been a lot cleaner if I could just use the derived result for most values, then tweak a few somehow. I just think it’s worth considering, even if that’s just “yeah we could do that later maybe”, but it’s a possible reason for preferring an actual keyword as it that same keyword could then be used in the extended operator.<br></p><p>Either way I think we still need an attribute so that properties can be opted out of the auto-generation, as it lets the feature be used on types with cache properties and other values that don’t need to be compared, which extends its usefulness to more cases; I can think of a dozen or so of my own types which essentially just have boiler-plate equality operators, but which also have properties that need to be ignored, so couldn’t make the switch to auto-generation.<br></p><p>Also, I just wanted to add as well that my vote’s for a derived/deriving keyword; the # prefix for compiler directives suggests to me that something may be compiled away, however if we’re using it to mark Equatable then this isn’t the case as the result is still always going to be Equatable. One other alternative is to just use some kind of decorative “magic” protocol, e.g- AutoEquatable (extending Equatable) that is handled with some compiler magic in the short term, and perhaps some other mechanism in future once we get reflection and other goodies.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160214/1799abfd/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>Auto-generate op==?</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>February 14, 2016 at 12:00:00am</p></header><div class="content"><p>That is Haskel’s Algebraic Data Type is it not?  I would think the Swift equivalent would be an `enum` (enumeration).  (just one case) — unless of course you had something like <br></p><p>enum InvolvedParty {<br>    case Person(name: String, age: Int)<br>    case Organization(name: String)<br>}<br></p><p>The only problem with Swift is that it becomes cumbersome to use if you only had one case… having to refer to it as InvolvedParty.Person when initializing the value.<br></p><p>And yes as far as I know it has no auto definition of equatable. <br></p><p><br>&gt; On 2016-02-14, at 0:12:48, Donnacha Oisín Kidney via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; In Haskell, when you declare a datatype, you can follow it with a “deriving” clause, and it will derive several typeclasses (which are Haskell’s equivalent to protocols):<br>&gt; <br>&gt; data Person = Person { name :: String, age :: Int } deriving Eq<br>&gt; <br>&gt; In Swift, I’d imaging the equivalent would be something like:<br>&gt; <br>&gt; struct Person {<br>&gt;   let name: String<br>&gt;   let age: Int<br>&gt; } deriving Equatable<br>&gt; <br>&gt;&gt; On 13 Feb 2016, at 17:04, Patrick Gili via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Not having a lot of experience with Haskell, can you provide an example, so that we can better understand what you&#39;re proposing?<br>&gt;&gt; <br>&gt;&gt; Cheers,<br>&gt;&gt; -Patrick<br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 12, 2016, at 3:47 PM, Daniel Tartaglia via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In Haskell, we can mark a data block as deriving from Eq and it will auto-generate the == operator.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would like to see Swift auto-generate the == operator if a struct implements Equatable. Obviously, it would only be able to do this if all the structs members implemented Equatable themselves.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Has this idea already been proposed? I didn’t see it at the github repo…<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160214/7dc835a9/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
