<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Returned for revision] SE-0050: Decoupling Floating Point Strides from Generic Implementations</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 29, 2016 at 01:00:00pm</p></header><div class="content"><p>Proposal link: https://github.com/apple/swift-evolution/blob/master/proposals/0050-floating-point-stride.md<br></p><p>Hello Swift Community,<br></p><p>The review of SE-0050: &quot;Decoupling Floating Point Strides from Generic Implementations&quot; ran from May 17...23, 2016. The proposal is returned for revision:<br></p><p>There was very little feedback from the community - the feedback was positive about solving the floating point error accumulation problem indicated by the proposal, but wasn’t strongly positive about the solution.  The core team also agrees that the problem needs to be solved, however they don&#39;t think this API change is the right approach.  <br></p><p>The core team believes that the existing strideable API cannot efficiently and correctly handle all the real-world use cases one would want.  However, a multiplication-based implementation similar to the one proposed in SE-0050 (but potentially extended) seems sufficiently general to solve the existing use cases as well as solve the floating point error accumulation issue.  Once the design of this iterates on swift-evolution, it would be great to see a revised version of this proposal.<br></p><p>Many thanks to Erica Sadun and Xiaodi Wu for driving this discussion and writing a great proposal!<br></p><p>-Chris Lattner<br>Review Manager<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0050: Decoupling Floating Point Strides from Generic Implementations</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 30, 2016 at 03:00:00am</p></header><div class="content"><p>&gt; The core team believes that the existing strideable API cannot efficiently and correctly handle all the real-world use cases one would want.  However, a multiplication-based implementation similar to the one proposed in SE-0050 (but potentially extended) seems sufficiently general to solve the existing use cases as well as solve the floating point error accumulation issue.  Once the design of this iterates on swift-evolution, it would be great to see a revised version of this proposal.<br></p><p>Can you give any indication of what&#39;s wrong with the proposed API?<br></p><p>Personally, what bothered me about it is that it seems too float-specific. The way I would design it is to add multiplication to Strideable:<br></p><p>	public protocol Strideable: Comparable {<br>		typealias Stride: SignedNumber<br>		<br>		func distance(to other: Self) -&gt; Stride<br>		func advanced(by stride: Stride) -&gt; Self<br>		<br>		static func scale(_ stride: Stride, by multiplier: Stride) -&gt; Stride<br>	}<br></p><p>And then have a refined protocol for types like Int which are safe to repeatedly advance:<br></p><p>	/// An AccumulatingStrideable is a Strideable which guarantees that:<br>	///<br>	///	(0..&lt;10).reduce(value) { val, _ in val.advanced(by: stride) } == value.advanced(by: T.scale(stride, by: 10))<br>	/// <br>	/// In other words, the result of repeatedly advancing any value by any stride *n* times is exactly equal to the <br>	/// result of advancing it once by that stride scaled up *n* times.<br>	public protocol AccumulatingStrideable: Strideable {}<br></p><p>Then you have two forms of `stride(from:to:by:)`:<br></p><p>	public func stride&lt;T: Strideable&gt;(from start: T, to end: T, by stride: T.Stride) -&gt; StrideTo&lt;T&gt;<br>	public func stride&lt;T: AccumulatingStrideable&gt;(from start: T, to end: T, by stride: T.Stride) -&gt; AccumulatingStrideTo&lt;T&gt;<br></p><p>Obviously there are many designs we could consider along these lines, and I don&#39;t want to get bogged down in the details of choosing one at this point. What I&#39;m asking is, is this the general *kind* of design you&#39;re looking for compared to SE-0050, one which is not specific to FloatingPoint types? Or are you looking for a redesign which addresses different issues from these?<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0050: Decoupling Floating Point Strides from Generic Implementations</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 30, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On May 30, 2016, at 4:10 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; The core team believes that the existing strideable API cannot efficiently and correctly handle all the real-world use cases one would want.  However, a multiplication-based implementation similar to the one proposed in SE-0050 (but potentially extended) seems sufficiently general to solve the existing use cases as well as solve the floating point error accumulation issue.  Once the design of this iterates on swift-evolution, it would be great to see a revised version of this proposal.<br>&gt; <br>&gt; Can you give any indication of what&#39;s wrong with the proposed API?<br></p><p>Piling on because it would really help to get a sense of what direction the core team is looking for. Unless we can figure out in advance what the core team is actually looking for, it&#39;s hard to respond with the request for revision. The feedback says: &quot;they don&#39;t think this API change is the right approach&quot; and &quot;The core team believes that the existing strideable API cannot efficiently and correctly handle all the real-world use cases one would want.&quot; <br></p><p>I&#39;d like to iterate the design as requested, but it&#39;s hard to know where to start. So let me discuss things that can be strode along:<br></p><p>There are four types of bounded intervals (open and closed on each end) that can be traversed in either direction, four types of unbounded interval (open and closed starting points, heading positively and negatively), and both integer and floating point applications of strides along these:<br></p><p>Bounded Intervals: [A, B), (A, B], (A, B), [A, B]<br>Unbounded Intervals: (A, ∞), [A,  ∞), ( -∞, A), (-∞, A]<br></p><p>(Technically, there&#39;s also the empty interval (), and the full number line (-∞, ∞), which really don&#39;t come into play for sequences but might play a role in pattern matching.)<br></p><p>The simplest API to handle all these cases would be:<br></p><p>`stride(from/off:, by:, towards/to/through:)` for sequences along bounded intervals and <br>`stride(from/off:, by:)` for sequences along unbounded intervals. <br></p><p>In these calls, `from` is inclusive and `off` is exclusive of the first value.<br></p><p>SE-0051 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0051-stride-semantics.md&gt; covers the details of what the semantics of `towards`/`to`/`through` mean: <br></p><p>towards meaning a..&lt;b, a&lt;..b, for example: 1 towards 5 by 1 is [1, 2, 3, 4]<br>to a...b, for example: 1 to 5 by 1 is [1, 2, 3, 4, 5], and 1 to 10 by 8 is [1, 9]<br>through a..&gt;=b, a&gt;=..b, for example: 1 through 5 by 1 is [1, 2, 3, 4, 5] and 1 through 10 by 8 is [1, 9, 17]<br></p><p>The acceptance of SE-0045 and SE-0099 and makes implementing each of these sequence types much easier.  The state version can use the error-reducing iteration multiplier. The non-state version is perfect for integer math.<br></p><p>-- E<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160530/e8c3ab77/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0050: Decoupling Floating Point Strides from Generic Implementations</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 31, 2016 at 05:00:00pm</p></header><div class="content"><p>Like it!<br></p><p>-Thorsten <br></p><p>Am 30.05.2016 um 12:10 schrieb Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt;:<br></p><p>&gt;&gt; The core team believes that the existing strideable API cannot efficiently and correctly handle all the real-world use cases one would want.  However, a multiplication-based implementation similar to the one proposed in SE-0050 (but potentially extended) seems sufficiently general to solve the existing use cases as well as solve the floating point error accumulation issue.  Once the design of this iterates on swift-evolution, it would be great to see a revised version of this proposal.<br>&gt; <br>&gt; Can you give any indication of what&#39;s wrong with the proposed API?<br>&gt; <br>&gt; Personally, what bothered me about it is that it seems too float-specific. The way I would design it is to add multiplication to Strideable:<br>&gt; <br>&gt;    public protocol Strideable: Comparable {<br>&gt;        typealias Stride: SignedNumber<br>&gt;        <br>&gt;        func distance(to other: Self) -&gt; Stride<br>&gt;        func advanced(by stride: Stride) -&gt; Self<br>&gt;        <br>&gt;        static func scale(_ stride: Stride, by multiplier: Stride) -&gt; Stride<br>&gt;    }<br>&gt; <br>&gt; And then have a refined protocol for types like Int which are safe to repeatedly advance:<br>&gt; <br>&gt;    /// An AccumulatingStrideable is a Strideable which guarantees that:<br>&gt;    ///<br>&gt;    ///    (0..&lt;10).reduce(value) { val, _ in val.advanced(by: stride) } == value.advanced(by: T.scale(stride, by: 10))<br>&gt;    /// <br>&gt;    /// In other words, the result of repeatedly advancing any value by any stride *n* times is exactly equal to the <br>&gt;    /// result of advancing it once by that stride scaled up *n* times.<br>&gt;    public protocol AccumulatingStrideable: Strideable {}<br>&gt; <br>&gt; Then you have two forms of `stride(from:to:by:)`:<br>&gt; <br>&gt;    public func stride&lt;T: Strideable&gt;(from start: T, to end: T, by stride: T.Stride) -&gt; StrideTo&lt;T&gt;<br>&gt;    public func stride&lt;T: AccumulatingStrideable&gt;(from start: T, to end: T, by stride: T.Stride) -&gt; AccumulatingStrideTo&lt;T&gt;<br>&gt; <br>&gt; Obviously there are many designs we could consider along these lines, and I don&#39;t want to get bogged down in the details of choosing one at this point. What I&#39;m asking is, is this the general *kind* of design you&#39;re looking for compared to SE-0050, one which is not specific to FloatingPoint types? Or are you looking for a redesign which addresses different issues from these?<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
