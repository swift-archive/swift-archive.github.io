<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9245f9f7df459c19a735740e281aeae2?s=50"></div><header><strong>Thread safety of weak properties</strong> from <string>Mike Ash</string> &lt;mike at mikeash.com&gt;<p>December 10, 2015 at 09:00:00pm</p></header><div class="content"><p>Hello, world!<br></p><p>First, congratulations on the whole open source thing. I&#39;m really pleased to see how the team set it up and how well it&#39;s going. Blew away my expectations.<br></p><p>Anyway, on to the thing.<br></p><p>I was looking through the standard library&#39;s implementation of weak references, as one does, and noticed that loading a weak reference is not thread safe. I&#39;m not sure if this is by intent or by omission. On one hand, loading a weak reference *looks like* just reading a stored property, which should be thread safe if not done concurrently with any writes. On the other hand, loading a weak reference is *actually* a potential mutation of that stored property, from its original content to nil, which one would not expect to be thread safe. It&#39;s clear that weak references are supposed to be thread safe with respect to the target object being destroyed, but less clear whether they&#39;re supposed to be thread safe for concurrent accesses of the same weak reference.<br></p><p>Is there an explicit intent as to whether loading a weak reference should be thread safe or not?<br></p><p>The root of the problem (or not-problem, if it&#39;s supposed to be this way) is in the swift_weakLoadStrong function in HeapObject.cpp. If two threads simultaneously enter this function with the same weak reference and object-&gt;refCount.isDeallocating() is true, the threads will race. This can result in calling swift_unownedRelease() twice resulting in a double-free or worse, or it could result in one thread calling swift_tryRetain() on a deallocated object.<br></p><p>If making this thread safe is desired, there are a couple of potential fixes.<br></p><p>One fix would be to just remove these two lines:<br></p><p>    swift_unownedRelease(object);<br>    ref-&gt;Value = nullptr;<br></p><p>This would cause the weak reference to never become nil in memory, and the target object&#39;s memory to stay allocated until the weak reference is destroyed or reassigned, but it would eliminate the potential for a race.<br></p><p>Another potential fix would be to add a lock to make this function thread safe. This could be done with low overhead by stealing a bit in ref-&gt;Value and using that bit as a spinlock. It pains me to think of adding a lock to this lovely lock-free code, but at least it would be specific to the individual reference.<br></p><p>I haven&#39;t filed a bug yet, since I didn&#39;t know if it&#39;s supposed to be like this or not. If a fix is desired, I&#39;d be happy to file, and maybe make the fix too.<br></p><p>In case it&#39;s helpful, here is my test code which demonstrates the crash:<br></p><p>import Foundation<br></p><p>class Target {}<br></p><p>class WeakHolder {<br>    weak var weak: Target?<br>}<br></p><p>for i in 0..&lt;1000000 {<br>    print(i)<br>    let holder = WeakHolder()<br>    holder.weak = Target()<br>    dispatch_async(dispatch_get_global_queue(0, 0), {<br>        let _ = holder.weak<br>    })<br>    dispatch_async(dispatch_get_global_queue(0, 0), {<br>        let _ = holder.weak<br>    })<br>}<br></p><p>Mike<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Thread safety of weak properties</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December 10, 2015 at 07:00:00pm</p></header><div class="content"><p>&gt; On Dec 10, 2015, at 6:50 PM, Mike Ash via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; Hello, world!<br>&gt; <br>&gt; First, congratulations on the whole open source thing. I&#39;m really pleased to see how the team set it up and how well it&#39;s going. Blew away my expectations.<br>&gt; <br>&gt; Anyway, on to the thing.<br>&gt; <br>&gt; I was looking through the standard library&#39;s implementation of weak references, as one does, and noticed that loading a weak reference is not thread safe. I&#39;m not sure if this is by intent or by omission. On one hand, loading a weak reference *looks like* just reading a stored property, which should be thread safe if not done concurrently with any writes. On the other hand, loading a weak reference is *actually* a potential mutation of that stored property, from its original content to nil, which one would not expect to be thread safe. It&#39;s clear that weak references are supposed to be thread safe with respect to the target object being destroyed, but less clear whether they&#39;re supposed to be thread safe for concurrent accesses of the same weak reference.<br>&gt; <br>&gt; Is there an explicit intent as to whether loading a weak reference should be thread safe or not?<br></p><p>The intent is that weak references do not need to be safe against read/write and write/write races.  They do need to be safe against read/destroy and write/destroy races (by “destroy”, I mean destruction of the object, not the weak reference).  I agree that they should also be safe against read/read races.<br></p><p>&gt; The root of the problem (or not-problem, if it&#39;s supposed to be this way) is in the swift_weakLoadStrong function in HeapObject.cpp. If two threads simultaneously enter this function with the same weak reference and object-&gt;refCount.isDeallocating() is true, the threads will race. This can result in calling swift_unownedRelease() twice resulting in a double-free or worse, or it could result in one thread calling swift_tryRetain() on a deallocated object.<br></p><p>Yes, you’re absolutely right, this is a bug in the current implementation; good catch!<br></p><p>&gt; If making this thread safe is desired, there are a couple of potential fixes.<br>&gt; <br>&gt; One fix would be to just remove these two lines:<br>&gt; <br>&gt;    swift_unownedRelease(object);<br>&gt;    ref-&gt;Value = nullptr;<br>&gt; <br>&gt; This would cause the weak reference to never become nil in memory, and the target object&#39;s memory to stay allocated until the weak reference is destroyed or reassigned, but it would eliminate the potential for a race.<br>&gt; <br>&gt; Another potential fix would be to add a lock to make this function thread safe. This could be done with low overhead by stealing a bit in ref-&gt;Value and using that bit as a spinlock. It pains me to think of adding a lock to this lovely lock-free code, but at least it would be specific to the individual reference.<br>&gt; <br>&gt; I haven&#39;t filed a bug yet, since I didn&#39;t know if it&#39;s supposed to be like this or not. If a fix is desired, I&#39;d be happy to file, and maybe make the fix too.<br></p><p>That would be great.<br></p><p>There’s actually a higher-level semantic bug in this code, which is that we really do want weak references to make the same deallocation guarantees as Objective-C if possible.  That is, while we’re comfortable with the idea of an unowned reference pinning some memory until the unowned reference is destroyed, weak references should really allow the object’s memory to be more-or-less immediately returned to the general pool.  It was always our intention to revisit the implementation and do this.<br></p><p>It would be acceptable to increase the inline size of weak references if that makes this more performant.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9245f9f7df459c19a735740e281aeae2?s=50"></div><header><strong>Thread safety of weak properties</strong> from <string>Mike Ash</string> &lt;mike at mikeash.com&gt;<p>December 11, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 10, 2015, at 10:55 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt; The intent is that weak references do not need to be safe against read/write and write/write races.  They do need to be safe against read/destroy and write/destroy races (by “destroy”, I mean destruction of the object, not the weak reference).  I agree that they should also be safe against read/read races.<br>&gt; <br>&gt;&gt; The root of the problem (or not-problem, if it&#39;s supposed to be this way) is in the swift_weakLoadStrong function in HeapObject.cpp. If two threads simultaneously enter this function with the same weak reference and object-&gt;refCount.isDeallocating() is true, the threads will race. This can result in calling swift_unownedRelease() twice resulting in a double-free or worse, or it could result in one thread calling swift_tryRetain() on a deallocated object.<br>&gt; <br>&gt; Yes, you’re absolutely right, this is a bug in the current implementation; good catch!<br></p><p>OK! I filed the bug:<br></p><p>https://bugs.swift.org/browse/SR-192<br></p><p>&gt; There’s actually a higher-level semantic bug in this code, which is that we really do want weak references to make the same deallocation guarantees as Objective-C if possible.  That is, while we’re comfortable with the idea of an unowned reference pinning some memory until the unowned reference is destroyed, weak references should really allow the object’s memory to be more-or-less immediately returned to the general pool.  It was always our intention to revisit the implementation and do this.<br>&gt; <br>&gt; It would be acceptable to increase the inline size of weak references if that makes this more performant.<br></p><p>It&#39;s interesting that you say that. I discovered this bug while writing up the weak reference implementation for a blog article. (Which I just posted here: https://mikeash.com/pyblog/friday-qa-2015-12-11-swift-weak-references.html) My conclusion is that the Swift Way of leaving an object husk lying around in memory for a while is superior to the Objective-C approach of eagerly deallocating objects and zeroing out references. The memory impact is small, and the performance improvement is nice. Zeroing weak references are always good to have but the cost of accessing them in Objective-C always bugged me a bit. (And I say this having written my own implementation that works exactly the same way.)<br></p><p>My own thinking is that object instances are not usually very big. As long as you can destroy the external resources it holds such as arrays and dictionaries and trees of other objects, the cost is small, just one allocation of some dozens of bytes. You have at most one such allocation per weak reference to a dead object, and less than that if there are multiple weak references to the same dead object. (I hope I am understanding the implementation correctly that it does in fact tear down the object completely when the last strong reference is released, and just keeps the instance&#39;s own memory around for the weak references.)<br></p><p>Increasing the inline size of weak references opens up the possibilities a bit. I can think of at least four fixes:<br></p><p>1. Delete the zeroing, and otherwise leave things as-is. This extends the life of the object husk (by the way, is there an official term?) possibly indefinitely. This seems fine to me but it sounds like you may disagree. I will, of course, defer to your judgment on that.<br></p><p>2. Add an activity count to the weak reference. WeakReference would become something like struct WeakReference { HeapObject *Value; unsigned long count; }. swift_weakLoadStrong would increment the count when loading the pointer, and decrement the count when done. Zeroing would only happen when decrementing the count to zero. This would require a 16-byte compare-and-swap operation.<br></p><p>3. Borrow a bit from the weak pointer to implement a spinlock. This is really a special case of (2), with the activity count being capped at 1 and additional activity blocking. In fact, you could even do a hybrid approach by borrowing more bits. (I think it could safely steal up to 20 bits with current 64-bit architectures. This may not be wise. As long as targets are pointer-aligned you can safely steal 2/3 bits.)<br></p><p>4. Add additional bookkeeping and synchronization to allow eager zeroing and deallocation of object husks more like the Objective-C weak pointer implementation. This would require a list of weak references to a given object to be maintained somewhere.<br></p><p>I personally would rank my preference as 1, 3, 2, 4. You guys have *slightly* more experience with this code than I do, though, so I put little weight on my own preference here. What do you think?<br></p><p>Mike<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Thread safety of weak properties</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 12, 2015 at 12:00:00am</p></header><div class="content"><p>On Fri, Dec 11, 2015, at 07:00 AM, Mike Ash via swift-dev wrote:<br>&gt; <br>&gt; Increasing the inline size of weak references opens up the possibilities a bit. I can think of at least four fixes:<br>&gt; <br>&gt; 1. Delete the zeroing, and otherwise leave things as-is. This extends the life of the object husk (by the way, is there an official term?) possibly indefinitely. This seems fine to me but it sounds like you may disagree. I will, of course, defer to your judgment on that.<br></p><p>I don&#39;t mind un-zeroed weak references keeping an object husk around, but if I read a weak reference and get nil back, I expect the reference to now be zeroed and to not prolong the lifetime of the husk. It&#39;s probably not that big a deal, but it would be surprising if it behaved differently.<br></p><p>I think swift_weakCopyInit() and swift_weakTakeInit() have to also be updated for whatever change is done to swift_weakLoadStrong() as those two functions are conceptually just reads of the src pointer, but like swift_weakLoadStrong() they zero out and release the object if it&#39;s deallocating.<br></p><p>Another possible fix is to just atomically load/store the Value pointer itself (assuming all platforms Swift runs on supports lock-free atomic pointers). This way if the object is deallocating, it would attempt an atomic CAS on the pointer to null it out, and only release the object if it wasn&#39;t already null. This means all writes to weak pointers now require an atomic write, but the benefit over the activity count / spinlock is reads don&#39;t have to perform an atomic write while the object is still alive, only an atomic read (although I&#39;m not sure offhand if there&#39;s any practical performance difference there). And with this approach, it now becomes easy to make read/write and write/write safe. Whether this approach is worth doing depends on how many weak writes there are compared to weak reads (and offhand I don&#39;t have any idea there, except I do know I see an awful lot of code that looks like `weakRef?.foo(); weakRef?.bar(); weakRef?.baz()`).<br></p><p>-Kevin Ballard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Thread safety of weak properties</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 12, 2015 at 12:00:00am</p></header><div class="content"><p>On Sat, Dec 12, 2015, at 12:01 AM, Kevin Ballard wrote:<br>&gt; Another possible fix is to just atomically load/store the Value pointer itself (assuming all platforms Swift runs on supports lock-free atomic pointers). This way if the object is deallocating, it would attempt an atomic CAS on the pointer to null it out, and only release the object if it wasn&#39;t already null. This means all writes to weak pointers now require an atomic write, but the benefit over the activity count / spinlock is reads don&#39;t have to perform an atomic write while the object is still alive, only an atomic read (although I&#39;m not sure offhand if there&#39;s any practical performance difference there). And with this approach, it now becomes easy to make read/write and write/write safe. Whether this approach is worth doing depends on how many weak writes there are compared to weak reads (and offhand I don&#39;t have any idea there, except I do know I see an awful lot of code that looks like `weakRef?.foo(); weakRef?.bar(); weakRef?.baz()`).<br></p><p>I take it back, this is still unsafe because the object can get free&#39;d while another thread is in the process of checking its refcount.<br></p><p>At the moment I&#39;m leaning towards the activity count idea, though I&#39;m not sure why you need a 16-byte CAS for that.<br></p><p>-Kevin<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9245f9f7df459c19a735740e281aeae2?s=50"></div><header><strong>Thread safety of weak properties</strong> from <string>Mike Ash</string> &lt;mike at mikeash.com&gt;<p>December 12, 2015 at 12:00:00pm</p></header><div class="content"><p>On Dec 12, 2015, at 3:29 AM, Kevin Ballard via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; On Sat, Dec 12, 2015, at 12:01 AM, Kevin Ballard wrote:<br>&gt;&gt; Another possible fix is to just atomically load/store the Value pointer itself (assuming all platforms Swift runs on supports lock-free atomic pointers). This way if the object is deallocating, it would attempt an atomic CAS on the pointer to null it out, and only release the object if it wasn&#39;t already null. This means all writes to weak pointers now require an atomic write, but the benefit over the activity count / spinlock is reads don&#39;t have to perform an atomic write while the object is still alive, only an atomic read (although I&#39;m not sure offhand if there&#39;s any practical performance difference there). And with this approach, it now becomes easy to make read/write and write/write safe. Whether this approach is worth doing depends on how many weak writes there are compared to weak reads (and offhand I don&#39;t have any idea there, except I do know I see an awful lot of code that looks like `weakRef?.foo(); weakRef?.bar(); weakRef?.baz()`).<br>&gt; <br>&gt; I take it back, this is still unsafe because the object can get free&#39;d while another thread is in the process of checking its refcount.<br>&gt; <br>&gt; At the moment I&#39;m leaning towards the activity count idea, though I&#39;m not sure why you need a 16-byte CAS for that.<br></p><p>Yes, I initially thought of the CAS idea as well, but it doesn&#39;t work, like you say.<br></p><p>For the activity count, I was thinking that you&#39;d need to update it atomically along with the weak pointer. But thinking more, I believe that&#39;s unnecessary. In fact, the weak pointer doesn&#39;t even need to be updated at all.<br></p><p>Here&#39;s how I envision this one working. Let&#39;s say the weak pointer itself looks like `(ptr, count)`. Define a special value for `count` that means &quot;the weak pointer has been zeroed out.&quot; 0xFFFFFFFFFFFFFFFF would be a good candidate. Then reading looks like:<br></p><p>read(ref):<br>	(obj, count) = *ref<br>	if count == 0xFFFFFFFFFFFFFFFF: return null<br>	CAS(ref-&gt;count, count, count + 1)<br>	if failed: restart from the top<br>	<br>	if obj.isDeallocating():<br>		CAS(ref-&gt;count, 1, 0xFFFFFFFFFFFFFFFF)<br>		if success: weakRelease(obj)<br>		return null<br>	else:<br>		result = tryRetain(obj)<br>		atomic_decrement(ref-&gt;count)<br>		return result<br></p><p>If an atomic increment is faster than a compare-and-swap loop (probably the case on x86-64?) then you could modify this to say that the top bit of count means &quot;reference is null,&quot; then read can safely do an atomic increment and check the top bit of the result to know how to proceed.<br></p><p>For what it&#39;s worth, I implemented stealing the bottom bit for a spinlock yesterday and it&#39;s pretty nice and easy. I&#39;m a bit conflicted on cutting down on concurrency but preserving weak references as a single pointer, versus improving concurrency but taking up more memory to store them. Concurrency is probably more important.<br></p><p>Mike<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Thread safety of weak properties</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 12, 2015 at 07:00:00pm</p></header><div class="content"><p>#3 sounds like a great approach to me.  I agree with Kevin that if we keep the object husk approach that any use of a weak pointer that returns nil should drop any reference to a husk.<br></p><p>-Chris<br></p><p>&gt; On Dec 11, 2015, at 7:00 AM, Mike Ash via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; 3. Borrow a bit from the weak pointer to implement a spinlock. This is really a special case of (2), with the activity count being capped at 1 and additional activity blocking. In fact, you could even do a hybrid approach by borrowing more bits. (I think it could safely steal up to 20 bits with current 64-bit architectures. This may not be wise. As long as targets are pointer-aligned you can safely steal 2/3 bits.)<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Thread safety of weak properties</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December 14, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 12, 2015, at 7:04 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; #3 sounds like a great approach to me.  I agree with Kevin that if we keep the object husk approach that any use of a weak pointer that returns nil should drop any reference to a husk.<br></p><p>Spin locks are, unfortunately, illegal on iOS, which does not guarantee progress in the face of priority inversion.<br></p><p>John.<br></p><p>&gt; <br>&gt; -Chris<br>&gt; <br>&gt;&gt; On Dec 11, 2015, at 7:00 AM, Mike Ash via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; 3. Borrow a bit from the weak pointer to implement a spinlock. This is really a special case of (2), with the activity count being capped at 1 and additional activity blocking. In fact, you could even do a hybrid approach by borrowing more bits. (I think it could safely steal up to 20 bits with current 64-bit architectures. This may not be wise. As long as targets are pointer-aligned you can safely steal 2/3 bits.)<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>Thread safety of weak properties</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>December 14, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; On Dec 14, 2015, at 9:47 AM, John McCall via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 12, 2015, at 7:04 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt; #3 sounds like a great approach to me.  I agree with Kevin that if we keep the object husk approach that any use of a weak pointer that returns nil should drop any reference to a husk.<br>&gt; <br>&gt; Spin locks are, unfortunately, illegal on iOS, which does not guarantee progress in the face of priority inversion.<br></p><p>There is a spinlock algorithm that does work (in practice if not in theory), but it requires a full word of storage instead of a single bit.<br></p><p><br>-- <br>Greg Parker     gparker at apple.com     Runtime Wrangler<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Thread safety of weak properties</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 14, 2015 at 07:00:00pm</p></header><div class="content"><p>On Mon, Dec 14, 2015, at 12:19 PM, Greg Parker via swift-dev wrote:<br>&gt; <br>&gt; &gt; On Dec 14, 2015, at 9:47 AM, John McCall via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; &gt; <br>&gt; &gt;&gt; On Dec 12, 2015, at 7:04 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; &gt;&gt; #3 sounds like a great approach to me.  I agree with Kevin that if we keep the object husk approach that any use of a weak pointer that returns nil should drop any reference to a husk.<br>&gt; &gt; <br>&gt; &gt; Spin locks are, unfortunately, illegal on iOS, which does not guarantee progress in the face of priority inversion.<br>&gt; <br>&gt; There is a spinlock algorithm that does work (in practice if not in theory), but it requires a full word of storage instead of a single bit.<br></p><p>Is that what OSSpinLock uses?<br></p><p>-Kevin Ballard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>Thread safety of weak properties</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>December 14, 2015 at 07:00:00pm</p></header><div class="content"><p>&gt; On Dec 14, 2015, at 7:26 PM, Kevin Ballard via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Mon, Dec 14, 2015, at 12:19 PM, Greg Parker via swift-dev wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 14, 2015, at 9:47 AM, John McCall via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 12, 2015, at 7:04 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; #3 sounds like a great approach to me.  I agree with Kevin that if we keep the object husk approach that any use of a weak pointer that returns nil should drop any reference to a husk.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Spin locks are, unfortunately, illegal on iOS, which does not guarantee progress in the face of priority inversion.<br>&gt;&gt; <br>&gt;&gt; There is a spinlock algorithm that does work (in practice if not in theory), but it requires a full word of storage instead of a single bit.<br>&gt; <br>&gt; Is that what OSSpinLock uses?<br></p><p>It does not. OSSpinLock is unsafe unless you can guarantee that all users have the same priority.<br></p><p><br>-- <br>Greg Parker     gparker at apple.com     Runtime Wrangler<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Thread safety of weak properties</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 14, 2015 at 07:00:00pm</p></header><div class="content"><p>On Mon, Dec 14, 2015, at 07:34 PM, Greg Parker wrote:<br>&gt; <br>&gt; &gt; On Dec 14, 2015, at 7:26 PM, Kevin Ballard via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; &gt; <br>&gt; &gt;&gt; On Mon, Dec 14, 2015, at 12:19 PM, Greg Parker via swift-dev wrote:<br>&gt; &gt;&gt; <br>&gt; &gt;&gt;&gt; On Dec 14, 2015, at 9:47 AM, John McCall via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt; On Dec 12, 2015, at 7:04 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt; #3 sounds like a great approach to me.  I agree with Kevin that if we keep the object husk approach that any use of a weak pointer that returns nil should drop any reference to a husk.<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; Spin locks are, unfortunately, illegal on iOS, which does not guarantee progress in the face of priority inversion.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; There is a spinlock algorithm that does work (in practice if not in theory), but it requires a full word of storage instead of a single bit.<br>&gt; &gt; <br>&gt; &gt; Is that what OSSpinLock uses?<br>&gt; <br>&gt; It does not. OSSpinLock is unsafe unless you can guarantee that all users have the same priority.<br></p><p>Hmm, that&#39;s pretty unfortunate to hear. I&#39;ve written code with spinlocks on iOS, and I imagine I&#39;m not the only one. Does the system provide an implementation of this &quot;safe in practice&quot; spinlock that&#39;s visible to third-party devs?<br></p><p>-Kevin Ballard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>Thread safety of weak properties</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>December 14, 2015 at 07:00:00pm</p></header><div class="content"><p>&gt; On Dec 14, 2015, at 7:39 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Mon, Dec 14, 2015, at 07:34 PM, Greg Parker wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 14, 2015, at 7:26 PM, Kevin Ballard via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mon, Dec 14, 2015, at 12:19 PM, Greg Parker via swift-dev wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 14, 2015, at 9:47 AM, John McCall via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 12, 2015, at 7:04 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; #3 sounds like a great approach to me.  I agree with Kevin that if we keep the object husk approach that any use of a weak pointer that returns nil should drop any reference to a husk.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Spin locks are, unfortunately, illegal on iOS, which does not guarantee progress in the face of priority inversion.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There is a spinlock algorithm that does work (in practice if not in theory), but it requires a full word of storage instead of a single bit.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is that what OSSpinLock uses?<br>&gt;&gt; <br>&gt;&gt; It does not. OSSpinLock is unsafe unless you can guarantee that all users have the same priority.<br>&gt; <br>&gt; Hmm, that&#39;s pretty unfortunate to hear. I&#39;ve written code with spinlocks on iOS, and I imagine I&#39;m not the only one. Does the system provide an implementation of this &quot;safe in practice&quot; spinlock that&#39;s visible to third-party devs?<br></p><p>Not that I know of. You should file a bug report.<br></p><p><br>-- <br>Greg Parker     gparker at apple.com     Runtime Wrangler<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Thread safety of weak properties</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 14, 2015 at 10:00:00pm</p></header><div class="content"><p>On Mon, Dec 14, 2015, at 07:48 PM, Greg Parker wrote:<br>&gt; <br>&gt; &gt; On Dec 14, 2015, at 7:39 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; &gt; <br>&gt; &gt;&gt; On Mon, Dec 14, 2015, at 07:34 PM, Greg Parker wrote:<br>&gt; &gt;&gt; <br>&gt; &gt;&gt;&gt; On Dec 14, 2015, at 7:26 PM, Kevin Ballard via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt; On Mon, Dec 14, 2015, at 12:19 PM, Greg Parker via swift-dev wrote:<br>&gt; &gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt; On Dec 14, 2015, at 9:47 AM, John McCall via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; On Dec 12, 2015, at 7:04 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; #3 sounds like a great approach to me.  I agree with Kevin that if we keep the object husk approach that any use of a weak pointer that returns nil should drop any reference to a husk.<br>&gt; &gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt; Spin locks are, unfortunately, illegal on iOS, which does not guarantee progress in the face of priority inversion.<br>&gt; &gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt; There is a spinlock algorithm that does work (in practice if not in theory), but it requires a full word of storage instead of a single bit.<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; Is that what OSSpinLock uses?<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; It does not. OSSpinLock is unsafe unless you can guarantee that all users have the same priority.<br>&gt; &gt; <br>&gt; &gt; Hmm, that&#39;s pretty unfortunate to hear. I&#39;ve written code with spinlocks on iOS, and I imagine I&#39;m not the only one. Does the system provide an implementation of this &quot;safe in practice&quot; spinlock that&#39;s visible to third-party devs?<br>&gt; <br>&gt; Not that I know of. You should file a bug report.<br></p><p>Filed as rdar://problem/23896366.<br></p><p>-Kevin Ballard<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9245f9f7df459c19a735740e281aeae2?s=50"></div><header><strong>Thread safety of weak properties</strong> from <string>Mike Ash</string> &lt;mike at mikeash.com&gt;<p>December 14, 2015 at 10:00:00pm</p></header><div class="content"><p>&gt; On Dec 14, 2015, at 3:19 PM, Greg Parker via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 14, 2015, at 9:47 AM, John McCall via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 12, 2015, at 7:04 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt;&gt; #3 sounds like a great approach to me.  I agree with Kevin that if we keep the object husk approach that any use of a weak pointer that returns nil should drop any reference to a husk.<br>&gt;&gt; <br>&gt;&gt; Spin locks are, unfortunately, illegal on iOS, which does not guarantee progress in the face of priority inversion.<br>&gt; <br>&gt; There is a spinlock algorithm that does work (in practice if not in theory), but it requires a full word of storage instead of a single bit.<br></p><p>Do you have a pointer (unintentional pun, oops) to this algorithm?<br></p><p>In this case, if we&#39;re going to dedicate a whole word to it, then we might as well go with the activity count implementation, but I&#39;d be curious to read more just the same.<br></p><p>Mike<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>Thread safety of weak properties</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>December 15, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 14, 2015, at 7:51 PM, Mike Ash &lt;mike at mikeash.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 14, 2015, at 3:19 PM, Greg Parker via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 14, 2015, at 9:47 AM, John McCall via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 12, 2015, at 7:04 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; #3 sounds like a great approach to me.  I agree with Kevin that if we keep the object husk approach that any use of a weak pointer that returns nil should drop any reference to a husk.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Spin locks are, unfortunately, illegal on iOS, which does not guarantee progress in the face of priority inversion.<br>&gt;&gt; <br>&gt;&gt; There is a spinlock algorithm that does work (in practice if not in theory), but it requires a full word of storage instead of a single bit.<br>&gt; <br>&gt; Do you have a pointer (unintentional pun, oops) to this algorithm?<br>&gt; <br>&gt; In this case, if we&#39;re going to dedicate a whole word to it, then we might as well go with the activity count implementation, but I&#39;d be curious to read more just the same.<br></p><p>The iOS scheduler maintains several different priority levels / QoS classes: background, utility, default, user-initiated, user-interactive. If any thread in a higher class is runnable then it will always run before every thread in lower classes. A thread&#39;s priority will never decay down into a lower class. (I am told that I/O throttling has similar effects, but I don&#39;t know the details there.)<br></p><p>This breaks naïve spinlocks like OSSpinLock. If a lower priority thread acquires the lock and is scheduled out, and then enough high-priority threads spin on the lock, then the low-priority thread will be starved and will never run again.<br></p><p>This is not a theoretical problem. libobjc saw dozens of livelocks against its internal spinlocks until we stopped using OSSpinLock.<br></p><p>One solution is to use truly unbounded backoff. This prevents permanent livelock (assuming the rest of the system ever goes quiescent), but can still block a high-priority thread for tens of seconds depending on system load.<br></p><p>Another solution is to use a handoff lock algorithm. This is what libobjc does now. The lock owner stores its thread ID in the lock. Each lock waiter yields to the owner thread specifically, donating its priority and resolving the inversion. This scheme has theoretical holes when multiple locks are involved, but in practice we haven&#39;t seen any problems.<br></p><p>As far as I know the spinlock that libobjc now uses is not API. We can&#39;t change OSSpinLock for binary compatibility reasons (the locked state is no longer 1 but some existing code assumes that).<br></p><p><br>-- <br>Greg Parker     gparker at apple.com     Runtime Wrangler<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Thread safety of weak properties</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 15, 2015 at 05:00:00pm</p></header><div class="content"><p>On Tue, Dec 15, 2015, at 01:38 PM, Greg Parker via swift-dev wrote:<br>&gt; <br>&gt; Another solution is to use a handoff lock algorithm. This is what libobjc does now. The lock owner stores its thread ID in the lock. Each lock waiter yields to the owner thread specifically, donating its priority and resolving the inversion. This scheme has theoretical holes when multiple locks are involved, but in practice we haven&#39;t seen any problems.<br>&gt; <br>&gt; As far as I know the spinlock that libobjc now uses is not API.<br></p><p>It&#39;s not. I checked earlier today against the copy of the objc runtime I have (from opensource.apple.com; my copy is slightly out of date, at version 647, but it&#39;s new enough). The runtime defines a type spinlock_t that&#39;s backed by something called os_lock_handoff_s. It also imports a header &lt;os/lock_private.h&gt;, which is presumably where this type is defined. I already updated my radar to suggest that perhaps this type would be a good candidate to expose.<br></p><p>Incidentally, if I wanted to implement my own spinlock like this, how can you yield to a specific thread? I&#39;m only aware of pthread_yield_np(), which doesn&#39;t take a target thread.<br></p><p>-Kevin Ballard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>Thread safety of weak properties</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>December 15, 2015 at 06:00:00pm</p></header><div class="content"><p>&gt; On Dec 15, 2015, at 5:32 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Tue, Dec 15, 2015, at 01:38 PM, Greg Parker via swift-dev wrote:<br>&gt;&gt; <br>&gt;&gt; Another solution is to use a handoff lock algorithm. This is what libobjc does now. The lock owner stores its thread ID in the lock. Each lock waiter yields to the owner thread specifically, donating its priority and resolving the inversion. This scheme has theoretical holes when multiple locks are involved, but in practice we haven&#39;t seen any problems.<br>&gt;&gt; <br>&gt;&gt; As far as I know the spinlock that libobjc now uses is not API.<br>&gt; <br>&gt; It&#39;s not. I checked earlier today against the copy of the objc runtime I have (from opensource.apple.com; my copy is slightly out of date, at version 647, but it&#39;s new enough). The runtime defines a type spinlock_t that&#39;s backed by something called os_lock_handoff_s. It also imports a header &lt;os/lock_private.h&gt;, which is presumably where this type is defined. I already updated my radar to suggest that perhaps this type would be a good candidate to expose.<br>&gt; <br>&gt; Incidentally, if I wanted to implement my own spinlock like this, how can you yield to a specific thread? I&#39;m only aware of pthread_yield_np(), which doesn&#39;t take a target thread.<br></p><p>It uses Mach&#39;s thread_switch() and passes a Mach thread port. It also uses a private option flag; I don&#39;t know if any of the public ones are good enough to solve the problem.<br></p><p><br>-- <br>Greg Parker     gparker at apple.com     Runtime Wrangler<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Thread safety of weak properties</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December 15, 2015 at 06:00:00pm</p></header><div class="content"><p>&gt; On Dec 15, 2015, at 6:01 PM, Greg Parker via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; On Dec 15, 2015, at 5:32 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Tue, Dec 15, 2015, at 01:38 PM, Greg Parker via swift-dev wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another solution is to use a handoff lock algorithm. This is what libobjc does now. The lock owner stores its thread ID in the lock. Each lock waiter yields to the owner thread specifically, donating its priority and resolving the inversion. This scheme has theoretical holes when multiple locks are involved, but in practice we haven&#39;t seen any problems.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As far as I know the spinlock that libobjc now uses is not API.<br>&gt;&gt; <br>&gt;&gt; It&#39;s not. I checked earlier today against the copy of the objc runtime I have (from opensource.apple.com; my copy is slightly out of date, at version 647, but it&#39;s new enough). The runtime defines a type spinlock_t that&#39;s backed by something called os_lock_handoff_s. It also imports a header &lt;os/lock_private.h&gt;, which is presumably where this type is defined. I already updated my radar to suggest that perhaps this type would be a good candidate to expose.<br>&gt;&gt; <br>&gt;&gt; Incidentally, if I wanted to implement my own spinlock like this, how can you yield to a specific thread? I&#39;m only aware of pthread_yield_np(), which doesn&#39;t take a target thread.<br>&gt; <br>&gt; It uses Mach&#39;s thread_switch() and passes a Mach thread port. It also uses a private option flag; I don&#39;t know if any of the public ones are good enough to solve the problem.<br></p><p>So, just to complete the loop here: absent Darwin granting public and backwards-compatible access to an internal API, we need to write this in a way that falls back on using a heavyweight lock in the presence of contention.  I’m fine with that being a global lock.<br></p><p>I’m also fine with using a spin lock on other platforms.<br></p><p>Note that Darwin platforms need this to interoperate with the unknownWeak entrypoints.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Thread safety of weak properties</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 15, 2015 at 06:00:00pm</p></header><div class="content"><p>On Tue, Dec 15, 2015, at 06:12 PM, John McCall wrote:<br>&gt; So, just to complete the loop here: absent Darwin granting public and backwards-compatible access to an internal API, we need to write this in a way that falls back on using a heavyweight lock in the presence of contention.  I’m fine with that being a global lock.<br></p><p>Well, no, the activity count idea isn&#39;t a spinlock and is perfectly safe. It&#39;s actually basically a retain count, but it&#39;s protecting write access to the field rather than protecting an object.<br></p><p>&gt; Note that Darwin platforms need this to interoperate with the unknownWeak entrypoints.<br></p><p>What does that interoperation look like?<br></p><p>-Kevin Ballard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Thread safety of weak properties</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December 15, 2015 at 06:00:00pm</p></header><div class="content"><p>&gt; On Dec 15, 2015, at 6:27 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; On Tue, Dec 15, 2015, at 06:12 PM, John McCall wrote:<br>&gt;&gt; So, just to complete the loop here: absent Darwin granting public and backwards-compatible access to an internal API, we need to write this in a way that falls back on using a heavyweight lock in the presence of contention.  I’m fine with that being a global lock.<br>&gt; <br>&gt; Well, no, the activity count idea isn&#39;t a spinlock and is perfectly safe. It&#39;s actually basically a retain count, but it&#39;s protecting write access to the field rather than protecting an object.<br></p><p>I keep forgetting about that option; that would be better.  And we can assert that the activity count of the target is zero in weakAssign / weakCopyAssign / weakTakeAssign because anything else would be a read/write race.  weakCopyAssign and weakCopyInit will have to bump the activity count of the source during the unownedRetain.<br></p><p>&gt;&gt; Note that Darwin platforms need this to interoperate with the unknownWeak entrypoints.<br>&gt; <br>&gt; What does that interoperation look like?<br></p><p>The current implementation is in SwiftObject.mm, but it has nasty races with deallocation..  If we add an extra word to WeakReference, we can just use a specific bit pattern to indicate that the reference was last set to an ObjC pointer.  The native implementation can assert that it never sees that pattern.<br></p><p>The compiler does have intrinsic knowledge of the size of a weak reference, but it is simple to update that when we have a runtime implementation we’re happy with.<br></p><p>John.<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
