<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Issues with 0005-Better Translation of Objective-C APIs Into Swift</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>February  2, 2016 at 01:00:00pm</p></header><div class="content"><p>on Tue Feb 02 2016, Kevin Schlei &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Sorry for the premature send! Continuing:<br></p><p>Ah, thank you...<br></p><p>&gt; let content = listItemView.text.trimming(.whitespaceAndNewlines)<br>&gt;<br>&gt; For a beginning programmer, there is no indication of what .trimming<br>&gt; does.<br></p><p>It trims.  In this case, it trims whitespace and newlines.  I think<br>that&#39;s actually pretty clear.<br></p><p>&gt; In this case, it returns a new string instance. <br></p><p>That isn&#39;t what it *does*; that&#39;s the type it returns.<br></p><p>&gt; Where is that explained? In the documentation. Nowhere near the method<br>&gt; call.<br></p><p>Exactly.  You get this information from context.  If you take some text<br>and you trim off the whitespace and newlines, you get some other text.<br></p><p>I don&#39;t believe that teaching students that the name of a method is<br>going to supply all the relevant type information is doing them a<br>service.  This is *not* what they&#39;ll encounter in the real world,<br>not even if they&#39;re programming in Objective-C and using Cocoa.<br></p><p>&gt; So are we reduced now to looking up documentation just to read code? What<br>&gt; does this line do:<br>&gt;<br>&gt; let next = current.updating(p)<br>&gt;<br>&gt; It&#39;s 100% unclear because you&#39;re relying on parameter names to contain all<br>&gt; the hints. <br></p><p>It&#39;s 75% unclear because there&#39;s no context.  I have no idea what<br>current or p are.  But I *can* tell (assuming this is following the<br>guidelines), that the method returns a modified version of current that<br>is obtained by updating p (whatever that means).<br></p><p>&gt; But this line:<br>&gt;<br>&gt; let next = current.locationByUpdatingProximity(p)<br>&gt;<br>&gt; Lets you know that:<br>&gt;<br>&gt; 1. we&#39;re returning a *&#39;location&#39;*<br>&gt; 2. &#39;*by* *updating&#39; *current with a new *&#39;proximity&#39;*<br></p><p>Under the proposed guidelines, that would be:<br></p><p>  let next = current.updatingProximityWith(p)<br></p><p>or<br></p><p>  let next = current.replacingProximityWith(p)<br></p><p>or<br></p><p>  let next = current.settingProximityTo(p)<br></p><p>&gt; When is the last time you saw a gerund (-ing) as a method name? <br></p><p>FWIW, these are not gerunds, they&#39;re present participles.<br></p><p>&gt; I wouldn&#39;t let my students write that. Gerunds make good boolean<br>&gt; properties. How would you even read the first line above out loud?<br>&gt; Probably by filling in the words in the second line, magically.<br></p><p>You&#39;re presuming that the guidelines as written would endorse that line,<br>but they don&#39;t.  Clarity at the point of use is the prime directive.<br></p><p>&gt; My second major issue is that autocomplete grouping is totally lost when<br>&gt; dropping the type returned at the beginning of the call. How many of us<br>&gt; learned a *ton* when we just autocompleted .stringBy? Look at all the<br>&gt; things you can do! But by removing the &#39;useless word&#39; (really don&#39;t like<br>&gt; that flag name) we have no grouping of constructor methods.<br></p><p>These things can be handled in other ways, e.g. by improving the tools,<br>without punishing readability at the use-site by adding needless words.<br></p><p>&gt; I see a lot of discussion on how to deal with &#39;with&#39; and &#39;by&#39; and other<br>&gt; words, but I want to strongly suggest that the current naming practices<br>&gt; provide context and clarity. It makes code readable and accessible. Don&#39;t<br>&gt; forget about when you didn&#39;t know how to code! These method names are<br>&gt; teaching tools!<br>&gt;<br>&gt; Finally, I just want to ask: why? What is the great benefit? Shouldn&#39;t<br>&gt; clarity be prioritized over brevity (where have I seen that...)<br></p><p>It is.  You just have a different idea about what creates clarity in<br>source code.  IMO, clarity is provided by communicating semantics, *not*<br>by repeating non-semantic details such as which specific types are in<br>use.  By eliminating words that don&#39;t communicate semantics, you make<br>the semantics clearer.  If we didn&#39;t believe in this approach, Swift<br>wouldn&#39;t have type inference.<br></p><p>HTH,<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/08045ad84066382b7a4d173e89302627?s=50"></div><header><strong>Issues with 0005-Better Translation of Objective-C APIs Into Swift</strong> from <string>Kevin Schlei</string> &lt;kevinschlei at gmail.com&gt;<p>February  3, 2016 at 09:00:00am</p></header><div class="content"><p>On Tue, Feb 2, 2016 at 3:21 PM, Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; It trims.  In this case, it trims whitespace and newlines.  I think<br>&gt; that&#39;s actually pretty clear.<br>&gt;<br></p><p>I wouldn&#39;t explain what trimming: does to a new student by just saying &#39;it<br>trims&#39;, because by that explanation it sounds like it mutates its caller.<br>The clarity provided by the verbosity of the old method name will be missed.<br></p><p>I do appreciate your clarification of how my updating: example would not<br>meet the new standards, but I find all of the new standards difficult to<br>get right. If &#39;Proximity&#39; is a type, wouldn&#39;t that be truncated because it<br>doesn&#39;t communicate semantics? It feels like half of the methods will have<br>clarifying qualifiers, and half won&#39;t. I think that will make the language<br>less consistent.<br></p><p>It is.  You just have a different idea about what creates clarity in<br>&gt; source code.  IMO, clarity is provided by communicating semantics, *not*<br>&gt; by repeating non-semantic details such as which specific types are in<br>&gt; use.  By eliminating words that don&#39;t communicate semantics, you make<br>&gt; the semantics clearer.  If we didn&#39;t believe in this approach, Swift<br>&gt; wouldn&#39;t have type inference.<br>&gt;<br></p><p>You&#39;ve solved the repetition of type detail be removing all type detail.<br>That line is clear to you because you already know that .<br>whitespaceAndNewlines is an NSCharacterSet, and that string trims<br>characters instead of something else, like length. There is nothing written<br>on that line of code that tells me what .whitespaceAndNewlines is. It looks<br>like a poorly capitalized enum.<br></p><p>We don&#39;t always read code from within our tools. I can&#39;t command-click<br>variables on Stackoverflow, WWDC slides, GitHub. I could read 100 lines of<br>trimming: and still not know that NSCharacterSet exists.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/f1ad0fe4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Issues with 0005-Better Translation of Objective-C APIs Into Swift</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>February  3, 2016 at 09:00:00am</p></header><div class="content"><p>on Wed Feb 03 2016, Kevin Schlei &lt;kevinschlei-AT-gmail.com&gt; wrote:<br></p><p>&gt; On Tue, Feb 2, 2016 at 3:21 PM, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; It trims.  In this case, it trims whitespace and newlines.  I think<br>&gt;&gt; that&#39;s actually pretty clear.<br>&gt;&gt;<br>&gt;<br>&gt; I wouldn&#39;t explain what trimming: does to a new student by just saying &#39;it<br>&gt; trims&#39;, because by that explanation it sounds like it mutates its<br>&gt; caller.<br></p><p>Uh, fine, for new students: it makes a copy, trims that, and returns it.<br></p><p>&gt; The clarity provided by the verbosity of the old method name will be missed.<br>&gt;<br>&gt; I do appreciate your clarification of how my updating: example would not<br>&gt; meet the new standards, but I find all of the new standards difficult to<br>&gt; get right. If &#39;Proximity&#39; is a type, wouldn&#39;t that be truncated because it<br>&gt; doesn&#39;t communicate semantics? <br></p><p>It would be omitted if it were a strong type.  If it was just a<br>typealias for Float, you&#39;d add it to clarify the role of the argument.<br></p><p>&gt; It feels like half of the methods will have clarifying qualifiers, and<br>&gt; half won&#39;t. I think that will make the language less consistent.<br></p><p>Yes, it is less uniform than code written to the existing conventions.<br>On balance, it leads to clearer code.  <br></p><p>If this makes you work a little harder to choose good API names, that&#39;s<br>a net plus. In reviewing existing APIs written against the existing<br>standards, I can&#39;t tell you how many times I&#39;ve found names that are<br>ambiguous—or worse, strongly imply something unintented—but fit the<br>usual linguistic patterns. As long as you spell it &quot;noun1ByVerbingNoun2&quot;<br>or &quot;verbWithNoun&quot; people who are used to reading this kind of<br>declaration but aren&#39;t paying *really close* attention to detail nod<br>their head and says &quot;yep, sounds about right,&quot; and fail to even look at<br>the resulting code, much less read it the way a new maintainer will.<br>The familiar patterns lead us into complacency.<br></p><p>&gt; It is.  You just have a different idea about what creates clarity in<br>&gt;&gt; source code.  IMO, clarity is provided by communicating semantics, *not*<br>&gt;&gt; by repeating non-semantic details such as which specific types are in<br>&gt;&gt; use.  By eliminating words that don&#39;t communicate semantics, you make<br>&gt;&gt; the semantics clearer.  If we didn&#39;t believe in this approach, Swift<br>&gt;&gt; wouldn&#39;t have type inference.<br>&gt;&gt;<br>&gt;<br>&gt; You&#39;ve solved the repetition of type detail be removing all type detail.<br>&gt; That line is clear to you because you already know that .<br>&gt; whitespaceAndNewlines is an NSCharacterSet, and that string trims<br>&gt; characters instead of something else, like length. <br></p><p>Not really.  I do know is that &quot;trim&quot; is a term of art for string<br>manipulation, and I happen to know what it means.  Even if you put the<br>type information back in, nothing in the name is going to tell you that<br>this call removes stuff on the ends of the string but not in the<br>middle.  That&#39;s a much more essential piece of information than the type<br>of the argument.<br></p><p>&gt; There is nothing written on that line of code that tells me what<br>&gt; .whitespaceAndNewlines is. It looks like a poorly capitalized enum.<br></p><p>You can&#39;t read one line of code by itself anyway just like you can&#39;t<br>generally take a sentence out of context and understand it.<br></p><p>&gt; We don&#39;t always read code from within our tools. I can&#39;t command-click<br>&gt; variables on Stackoverflow, WWDC slides, GitHub. I could read 100 lines of<br>&gt; trimming: and still not know that NSCharacterSet exists.<br></p><p>Fortunately if someone wrote 100 lines of trimming with no other<br>context, it would be pretty easy to infer that by the end there would be<br>nothing left ;-)<br></p><p>P.S. FWIW, as a standard library developer, I mostly can&#39;t use Xcode for<br>     development, so command-click is not something I get to rely on.<br></p><p>-- <br>-Dave<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/de7ad0a98b5a246d7825f220b0174f4a?s=50"></div><header><strong>Issues with 0005-Better Translation of Objective-C APIs Into Swift</strong> from <string>Preston Sumner</string> &lt;preston.sumner at gmail.com&gt;<p>February  3, 2016 at 12:00:00pm</p></header><div class="content"><p>Where context fails, tools can go the rest of the way (option-clicking a symbol in Xcode displays a documentation popover). Failing that, referring to external documentation isn’t necessarily a failure of the API. No API can self-document everything. Cocoa methods already can’t be relied on for type documentation.<br></p><p>What are the types of s2, options, and result?<br>let result = s1.compare(s2, options: [])<br></p><p>Is copy a noun or a verb?<br>foo.copy()<br></p><p>What type is p?<br>string.hasPrefix(p)<br></p><p>What is foo?<br>obj.isDescendantOf(foo)<br></p><p>Preston<br></p><p>&gt; On Feb 3, 2016, at 8:46 AM, Kevin Schlei via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Tue, Feb 2, 2016 at 3:21 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; It trims.  In this case, it trims whitespace and newlines.  I think<br>&gt; that&#39;s actually pretty clear.<br>&gt; <br>&gt; I wouldn&#39;t explain what trimming: does to a new student by just saying &#39;it trims&#39;, because by that explanation it sounds like it mutates its caller. The clarity provided by the verbosity of the old method name will be missed.<br>&gt; <br>&gt; I do appreciate your clarification of how my updating: example would not meet the new standards, but I find all of the new standards difficult to get right. If &#39;Proximity&#39; is a type, wouldn&#39;t that be truncated because it doesn&#39;t communicate semantics? It feels like half of the methods will have clarifying qualifiers, and half won&#39;t. I think that will make the language less consistent.<br>&gt; <br>&gt; It is.  You just have a different idea about what creates clarity in<br>&gt; source code.  IMO, clarity is provided by communicating semantics, *not*<br>&gt; by repeating non-semantic details such as which specific types are in<br>&gt; use.  By eliminating words that don&#39;t communicate semantics, you make<br>&gt; the semantics clearer.  If we didn&#39;t believe in this approach, Swift<br>&gt; wouldn&#39;t have type inference.<br>&gt; <br>&gt; You&#39;ve solved the repetition of type detail be removing all type detail. That line is clear to you because you already know that .whitespaceAndNewlines is an NSCharacterSet, and that string trims characters instead of something else, like length. There is nothing written on that line of code that tells me what .whitespaceAndNewlines is. It looks like a poorly capitalized enum.<br>&gt; <br>&gt; We don&#39;t always read code from within our tools. I can&#39;t command-click variables on Stackoverflow, WWDC slides, GitHub. I could read 100 lines of trimming: and still not know that NSCharacterSet exists.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/b262a2c2/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
