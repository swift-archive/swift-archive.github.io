<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Bridging the gap between protocols and protocol extensions</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January  9, 2016 at 02:00:00pm</p></header><div class="content"><p>From my previous thread, &quot;[Draft Proposal] Require `final` on protocol extension members&quot;, I&#39;m getting the sense that many people want straight-up dynamic dispatch from protocol extension methods. That is, protocol extension methods should be treated as if they were included as requirements of the protocol; the implementations provided should be treated as overridable defaults.<br></p><p>A few questions about that:<br></p><p>1. Do people really want this?<br></p><p>2. People familiar with the implementation of protocol witnesses: is this feasible?<br></p><p>3. Do people want the current non-overridable, statically-dispatched protocol extension members available as an option?<br></p><p>4. Should this be proposed alongside other changes that would reduce the difference between a protocol and a protocol extension, like allowing default implementations in the protocol declaration?<br></p><p>5. Especially with #3 or #4, this sounds like a very large change which could be broken up into several smaller ones. Core team members: what is the best way to propose this? One big proposal with all the details, several small proposals, or a big vague proposal for the overall direction, followed by several smaller proposals with a detailed design for each part?<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>Bridging the gap between protocols and protocol extensions</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>January 10, 2016 at 09:00:00am</p></header><div class="content"><p>Please see my response inline.<br></p><p>-Rod<br></p><p><br>&gt; On 10 Jan 2016, at 9:05 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; From my previous thread, &quot;[Draft Proposal] Require `final` on protocol extension members&quot;, I&#39;m getting the sense that many people want straight-up dynamic dispatch from protocol extension methods. That is, protocol extension methods should be treated as if they were included as requirements of the protocol; the implementations provided should be treated as overridable defaults.<br>&gt; <br>&gt; A few questions about that:<br>&gt; <br>&gt; 1. Do people really want this?<br>Yes. I think it makes the most sense. While I appreciate the optimisation, I think the idea of protocols forcing an implementation on the type is backwards, and potentially dangerous when the protocol has no understanding of the potential repercussions on how the implementing type is implemented.<br></p><p>&gt; <br>&gt; 2. People familiar with the implementation of protocol witnesses: is this feasible?<br>Unfortunately I have no experience here.<br></p><p>&gt; <br>&gt; 3. Do people want the current non-overridable, statically-dispatched protocol extension members available as an option?<br>I think there might be a use case, but I debate the safety and usability of a protocol as such. When you’re implementing the protocol, as has been discussed above, you cannot be aware of all the ramifications of your code on another potential type. Whilst a “non-overridable, final” implementation would be be better for inlining, I question whether the benefit is worth the risks.<br></p><p>&gt; <br>&gt; 4. Should this be proposed alongside other changes that would reduce the difference between a protocol and a protocol extension, like allowing default implementations in the protocol declaration?<br>It appears like it should go through at a similar time frame, if not together. They are all consistent with a streamlining of the protocol/protocol extension design. How that is implemented in proposals, would be best left to the Core Swift Team’s guidance.<br></p><p>&gt; <br>&gt; 5. Especially with #3 or #4, this sounds like a very large change which could be broken up into several smaller ones. Core team members: what is the best way to propose this? One big proposal with all the details, several small proposals, or a big vague proposal for the overall direction, followed by several smaller proposals with a detailed design for each part?<br>N/A as I am not a core team member.<br></p><p>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/662ae7fc3710f235bb3f6fd55a295760?s=50"></div><header><strong>Bridging the gap between protocols and protocol extensions</strong> from <string>Andy Molloy</string> &lt;amolloy at gmail.com&gt;<p>January  9, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; 1. Do people really want this?<br>&gt;<br></p><p>Yes, if for no other reason than that the current behavior (imho) violates<br>the principle of least surprise - the surprising part being that the<br>behavior is different than other method calls. Further, there is no way to<br>know at the call site what the behavior is going to be, hindering<br>readability.<br></p><p><br>&gt; 2. People familiar with the implementation of protocol witnesses: is this<br>&gt; feasible?<br>&gt;<br></p><p>I am not familiar with this so I can&#39;t comment specifically, but I would<br>just like to mention that (with apologies to whoever might eventually have<br>to implement this) the compiler is meant to serve the programmer, not the<br>other way around.<br></p><p><br>&gt; 3. Do people want the current non-overridable, statically-dispatched<br>&gt; protocol extension members available as an option?<br>&gt;<br></p><p>Sure, why not? I would prefer it not be the default behavior, though. It<br>should be triggered by some keyword (final, default, etc) in the protocol<br>extension.<br></p><p><br>&gt; 4. Should this be proposed alongside other changes that would reduce the<br>&gt; difference between a protocol and a protocol extension, like allowing<br>&gt; default implementations in the protocol declaration?<br>&gt;<br></p><p>I don&#39;t feel strongly one way or the other about this.<br></p><p>Thanks!<br>Andy<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160109/8cd4e9f8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Bridging the gap between protocols and protocol extensions</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January  9, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; I am not familiar with this so I can&#39;t comment specifically, but I would just like to mention that (with apologies to whoever might eventually have to implement this) the compiler is meant to serve the programmer, not the other way around.<br></p><p>Certainly, but the programmer will be ill-served if the compiler can only implement this with a very slow dispatch, or an expensive mandatory translation of protocol instances accessed across module lines, or with gaping semantic defects, or by dropping a dozen more-desirable features to implement it. And if it just can&#39;t be done, then it doesn&#39;t matter how well the compiler would serve the programmer by offering it.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>Bridging the gap between protocols and protocol extensions</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>January 10, 2016 at 12:00:00pm</p></header><div class="content"><p>Forgive my ignorance if I am wrong, but without the objective-C runtime, we’re looking at dynamism from the perspective of vtables rather than from dynamic dispatch. I would assume the vtable approach would far closer approach vtable lookup than Dynamic dispatch. This appears to have no more overhead than standard protocols, and I would be very hazardous to call that “very slow dispatch”.<br></p><p>Protocol extensions that are final and not “default only&quot; create 4 issues that I can see:<br></p><p>1. They lock a programmer into an implementation rather than an interface. This means if the implementations don’t perfectly match how you would perform the function (due to some internal state) then you must simply suffer and deal with it.<br></p><p>2. They create headaches for adhering to multiple protocols with the same method. This is currently being discussed on Swift Evolution as well.<br></p><p>3. They start to confuse what a protocol is - is it an implementation, or is it a guaranteed interface?<br></p><p>4. They seem to more closely model multiple inheritance, a model that was dismissed by the Swift team since Swift 1.0<br></p><p><br></p><p>&gt; On 10 Jan 2016, at 12:17 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; I am not familiar with this so I can&#39;t comment specifically, but I would just like to mention that (with apologies to whoever might eventually have to implement this) the compiler is meant to serve the programmer, not the other way around.<br>&gt; <br>&gt; Certainly, but the programmer will be ill-served if the compiler can only implement this with a very slow dispatch, or an expensive mandatory translation of protocol instances accessed across module lines, or with gaping semantic defects, or by dropping a dozen more-desirable features to implement it. And if it just can&#39;t be done, then it doesn&#39;t matter how well the compiler would serve the programmer by offering it.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Bridging the gap between protocols and protocol extensions</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January  9, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; Forgive my ignorance if I am wrong, but without the objective-C runtime, we’re looking at dynamism from the perspective of vtables rather than from dynamic dispatch. I would assume the vtable approach would far closer approach vtable lookup than Dynamic dispatch. This appears to have no more overhead than standard protocols, and I would be very hazardous to call that “very slow dispatch”.<br></p><p>That&#39;s a large part of what I mean when I ask if it&#39;s feasible. Can the protocol witness vtables be made extensible in some way? If they can, and a dynamic protocol extension call is no slower than any other protocol member call, that&#39;s great. If they can&#39;t, and protocol extension methods need a slower form of dispatch or some kind of translation when crossing module boundaries, that&#39;s probably not acceptable.<br></p><p>Class vtables can be extended in this way (and early in Swift&#39;s evolution, they even had overridability problems like protocol extensions now do), so I&#39;m guessing it can be done. But protocols are in many ways more complicated than classes—particularly in their need to support multiple conformances rather than single inheritance—so I&#39;m not willing to assume that it can be done without soliciting expert opinions.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Bridging the gap between protocols and protocol extensions</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>January 10, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jan 9, 2016, at 7:37 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Forgive my ignorance if I am wrong, but without the objective-C runtime, we’re looking at dynamism from the perspective of vtables rather than from dynamic dispatch. I would assume the vtable approach would far closer approach vtable lookup than Dynamic dispatch. This appears to have no more overhead than standard protocols, and I would be very hazardous to call that “very slow dispatch”.<br>&gt; <br>&gt; That&#39;s a large part of what I mean when I ask if it&#39;s feasible. Can the protocol witness vtables be made extensible in some way? If they can, and a dynamic protocol extension call is no slower than any other protocol member call, that&#39;s great. If they can&#39;t, and protocol extension methods need a slower form of dispatch or some kind of translation when crossing module boundaries, that&#39;s probably not acceptable.<br></p><p>If we make protocol extension methods dynamically dispatched (even as just an opt-in thing), we’d probably use a caching technique akin to objc_msgSend, keyed by the address of some global structure unique to the extension method.  This has the huge advantage of not requiring eager resolution of every extension method on every conformance, and it can still be made very fast — on the order of a few dozen cycles, i.e. maybe 50-75% slower than a v-table dispatch.  So it will not be as fast as a core requirement, but it’s likely to be close enough that all but the most performance-conscious programmers will be unaware of the difference, in the same way that most Java programmers have no need to be aware that dispatch through an interface type is usually slower than dispatch through a class type.<br></p><p>We would use a very similar approach for making out-of-module class extension methods dynamically dispatched.<br></p><p>John.<br></p><p>&gt; <br>&gt; Class vtables can be extended in this way (and early in Swift&#39;s evolution, they even had overridability problems like protocol extensions now do), so I&#39;m guessing it can be done. But protocols are in many ways more complicated than classes—particularly in their need to support multiple conformances rather than single inheritance—so I&#39;m not willing to assume that it can be done without soliciting expert opinions.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Bridging the gap between protocols and protocol extensions</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January 10, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; If we make protocol extension methods dynamically dispatched (even as just an opt-in thing), we’d probably use a caching technique akin to objc_msgSend, keyed by the address of some global structure unique to the extension method.  This has the huge advantage of not requiring eager resolution of every extension method on every conformance, and it can still be made very fast — on the order of a few dozen cycles, i.e. maybe 50-75% slower than a v-table dispatch.  So it will not be as fast as a core requirement, but it’s likely to be close enough that all but the most performance-conscious programmers will be unaware of the difference, in the same way that most Java programmers have no need to be aware that dispatch through an interface type is usually slower than dispatch through a class type.<br></p><p>Thanks, John. So if I&#39;m reading this right:<br></p><p>1. It is a significant engineering effort (you can&#39;t just rearrange things in the existing vtables), but definitely doable.<br></p><p>2. It would have reasonably good performance, but performance-sensitive code might want a statically-dispatched alternative.<br></p><p>Is that an accurate reading? Is it reasonable to propose for Swift 3, or would it require too much work for that timeframe?<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Bridging the gap between protocols and protocol extensions</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>January 10, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jan 10, 2016, at 5:21 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt; If we make protocol extension methods dynamically dispatched (even as just an opt-in thing), we’d probably use a caching technique akin to objc_msgSend, keyed by the address of some global structure unique to the extension method.  This has the huge advantage of not requiring eager resolution of every extension method on every conformance, and it can still be made very fast — on the order of a few dozen cycles, i.e. maybe 50-75% slower than a v-table dispatch.  So it will not be as fast as a core requirement, but it’s likely to be close enough that all but the most performance-conscious programmers will be unaware of the difference, in the same way that most Java programmers have no need to be aware that dispatch through an interface type is usually slower than dispatch through a class type.<br>&gt; <br>&gt; Thanks, John. So if I&#39;m reading this right:<br>&gt; <br>&gt; 1. It is a significant engineering effort (you can&#39;t just rearrange things in the existing vtables), but definitely doable.<br>&gt; <br>&gt; 2. It would have reasonably good performance, but performance-sensitive code might want a statically-dispatched alternative.<br>&gt; <br>&gt; Is that an accurate reading? Is it reasonable to propose for Swift 3, or would it require too much work for that timeframe?<br></p><p>It’s something we need to figure out before committing permanently to an ABI, and that makes it a logical part of the Swift 3 effort to at least leave room for this.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Bridging the gap between protocols and protocol extensions</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January 12, 2016 at 09:00:00pm</p></header><div class="content"><p>I have put a proposal in for generic protocols and covariant generics:<br></p><p>	[swift-evolution] Make generics covariant and add generics to	protocols  &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160111/006367.html&gt;  &lt;&gt;<br></p><p>This proposal requires that protocol functions are dynamically dispatched, i.e. it would require this change.<br></p><p><br>&gt; On 11 Jan 2016, at 12:34 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 10, 2016, at 5:21 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt; If we make protocol extension methods dynamically dispatched (even as just an opt-in thing), we’d probably use a caching technique akin to objc_msgSend, keyed by the address of some global structure unique to the extension method.  This has the huge advantage of not requiring eager resolution of every extension method on every conformance, and it can still be made very fast — on the order of a few dozen cycles, i.e. maybe 50-75% slower than a v-table dispatch.  So it will not be as fast as a core requirement, but it’s likely to be close enough that all but the most performance-conscious programmers will be unaware of the difference, in the same way that most Java programmers have no need to be aware that dispatch through an interface type is usually slower than dispatch through a class type.<br>&gt;&gt; <br>&gt;&gt; Thanks, John. So if I&#39;m reading this right:<br>&gt;&gt; <br>&gt;&gt; 1. It is a significant engineering effort (you can&#39;t just rearrange things in the existing vtables), but definitely doable.<br>&gt;&gt; <br>&gt;&gt; 2. It would have reasonably good performance, but performance-sensitive code might want a statically-dispatched alternative.<br>&gt;&gt; <br>&gt;&gt; Is that an accurate reading? Is it reasonable to propose for Swift 3, or would it require too much work for that timeframe?<br>&gt; <br>&gt; It’s something we need to figure out before committing permanently to an ABI, and that makes it a logical part of the Swift 3 effort to at least leave room for this.<br>&gt; <br>&gt; John.<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160112/6f2168f8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Bridging the gap between protocols and protocol extensions</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January 12, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; I have put a proposal in for generic protocols and covariant generics:<br>&gt; <br>&gt; 	[swift-evolution] Make generics covariant and add generics to	protocols  <br>&gt; <br>&gt; This proposal requires that protocol functions are dynamically dispatched, i.e. it would require this change.<br></p><p>What you propose is a fairly serious redesign of how protocols handle related types; I&#39;m trying to focus on changes that hopefully are relatively uncontroversial and mostly straightforwardly extend what currently exists.<br></p><p>(Frankly, I&#39;m also not in favor of replacing associated types, because I think they&#39;re a far better fit for the task than generics. But I don&#39;t want to derail this thread into a critique of your proposal.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Bridging the gap between protocols and protocol extensions</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January 13, 2016 at 06:00:00pm</p></header><div class="content"><p>@Brent,<br></p><p>I don&#39;t want to derail this thread either.<br></p><p>If you want to post on the other thread your concerns I am happy to take a<br>look.<br></p><p>Cheers,<br></p><p> -- Howard.<br></p><p>On 13 January 2016 at 17:42, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>wrote:<br></p><p>&gt; &gt; I have put a proposal in for generic protocols and covariant generics:<br>&gt; &gt;<br>&gt; &gt;       [swift-evolution] Make generics covariant and add generics to<br>&gt;  protocols<br>&gt; &gt;<br>&gt; &gt; This proposal requires that protocol functions are dynamically<br>&gt; dispatched, i.e. it would require this change.<br>&gt;<br>&gt; What you propose is a fairly serious redesign of how protocols handle<br>&gt; related types; I&#39;m trying to focus on changes that hopefully are relatively<br>&gt; uncontroversial and mostly straightforwardly extend what currently exists.<br>&gt;<br>&gt; (Frankly, I&#39;m also not in favor of replacing associated types, because I<br>&gt; think they&#39;re a far better fit for the task than generics. But I don&#39;t want<br>&gt; to derail this thread into a critique of your proposal.)<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt;<br></p><p><br>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/f1f63591/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Bridging the gap between protocols and protocol extensions</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>January  9, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jan 9, 2016, at 3:05 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; From my previous thread, &quot;[Draft Proposal] Require `final` on protocol extension members&quot;, I&#39;m getting the sense that many people want straight-up dynamic dispatch from protocol extension methods. That is, protocol extension methods should be treated as if they were included as requirements of the protocol; the implementations provided should be treated as overridable defaults.<br>&gt; <br>&gt; A few questions about that:<br>&gt; <br>&gt; 1. Do people really want this?<br></p><p>I can’t speak for all people, but I don’t. <br></p><p>Protocol extensions which are not part of the protocol are not part of any explicit contract, and are not ‘opted into’ by the implementing types. Code in protocol extensions will break if they have interdependent methods which change behavior because I implemented a method with the same name but different behavior.<br></p><p>&gt; 2. People familiar with the implementation of protocol witnesses: is this feasible?<br>&gt; <br>&gt; 3. Do people want the current non-overridable, statically-dispatched protocol extension members available as an option?<br></p><p>Yes.<br></p><p>&gt; 4. Should this be proposed alongside other changes that would reduce the difference between a protocol and a protocol extension, like allowing default implementations in the protocol declaration?<br>Having default implementations inside the protocol would help illustrate a default implementation is available. Currently, it can be confusing what you do or do not need to implement in order to conform to a protocol.<br></p><p>-DW<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Bridging the gap between protocols and protocol extensions</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>January  9, 2016 at 05:00:00pm</p></header><div class="content"><p>On Jan 9, 2016, at 4:05 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; From my previous thread, &quot;[Draft Proposal] Require `final` on protocol extension members&quot;, I&#39;m getting the sense that many people want straight-up dynamic dispatch from protocol extension methods. That is, protocol extension methods should be treated as if they were included as requirements of the protocol; the implementations provided should be treated as overridable defaults.<br>&gt; <br>&gt; A few questions about that:<br>&gt; <br>&gt; 1. Do people really want this?<br></p><p>I do. There are lots of useful things you could do with dynamically dispatched protocol extension methods that you cannot easily do elegantly. As an example, I could declare this extension on ErrorType:<br></p><p>extension ErrorType {<br>	var isFileNotFoundError: Bool {<br>		// Check for all of the possible “File not found” errors in POSIXError, NSCocoaError, NSURLError, NSOSStatusErrorDomain, etc.<br>		// Then check for NSUnderlyingErrorKey and if it exists, rinse and repeat with that.<br>	}<br></p><p>	func toNSError() -&gt; NSError {<br>		return self as NSError<br>	}<br>}<br></p><p>A method like this allows one to do things like this:<br></p><p>do {<br>	try NSFileManager.defaultManager().removeItemAtURL(someURL)<br>} catch {<br>	if error.isFileNotFoundError {<br>		// The file we were trying to delete didn’t exist. Ignore the error<br>	} else {<br>		// Okay, something actually went wrong<br>		NSApp.presentError(error.toNSError())<br>	}<br>}<br></p><p>Then, perhaps you define your own error type that has a FileNotFound error condition in it, and would like to override these methods:<br></p><p>enum MyErrorType: ErrorType {<br>	case FileNotFound(url: NSURL)<br>	// more cases<br></p><p>	var isFileNotFoundError: Bool {<br>		// Unfortunately, this will never get called.<br>		return case .FileNotFound(_) = self<br>	}<br></p><p>	func toNSError() -&gt; NSError {<br>		// This won’t get called either. The user will see a lovely “MyErrorType error (Int)” instead of our localized error message.<br></p><p>		switch self {<br>			case let .FileNotFound(url: url):<br>				let userInfo = [NSLocalizedFailureReasonErrorKey : String(format: NSLocalizedString(“FNF %@“, comment: “String format: File Not Found error”), url.lastPathComponent)]<br>				return NSError(domain: “MyErrorType”, code: 1, userInfo: userInfo)<br>			// other cases<br>		}<br>	}<br>}<br></p><p>For any of the above to work as is, each and every error handler has to do an as? check against every custom error type in your project.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160109/6ad17275/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
