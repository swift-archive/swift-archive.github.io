<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Review] SE-0058: Allow Swift types to provide custom Objective-C representations</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>April  4, 2016 at 10:00:00am</p></header><div class="content"><p>Hello Swift community,<br></p><p>The review of “Allow Swift types to provide custom Objective-C representations” begins now and runs through April 11, 2016. The proposal is available here:<br></p><p>	https://github.com/apple/swift-evolution/blob/master/proposals/0058-objectivecbridgeable.md<br></p><p>Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br></p><p>	https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br></p><p>	Proposal link:<br></p><p>		https://github.com/apple/swift-evolution/blob/master/proposals/0058-objectivecbridgeable.md<br></p><p>	Reply text<br></p><p>		Other replies<br></p><p>What goes into a review?<br></p><p>The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br></p><p>	• What is your evaluation of the proposal?<br>	• Is the problem being addressed significant enough to warrant a change to Swift?<br>	• Does this proposal fit well with the feel and direction of Swift?<br>	• If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>	• How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>More information about the Swift evolution process is available at<br></p><p>https://github.com/apple/swift-evolution/blob/master/process.md<br></p><p>Thank you,<br></p><p>-Joe<br>Review Manager<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution-announce/attachments/20160404/0d46c23e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Review] SE-0058: Allow Swift types to provide custom Objective-C representations</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>April  5, 2016 at 06:00:00am</p></header><div class="content"><p>• What is your evaluation of the proposal?<br></p><p>Good idea, it gets rid of compiler magic<br></p><p>• Is the problem being addressed significant enough to warrant a change to<br>Swift?<br></p><p>Yes, plenty of mixed projects. Plenty of Cocoa libraries that could be<br>improved with a Swift API.<br></p><p>• Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes, obj-c is still important<br></p><p>• If you have used other languages or libraries with a similar feature, how<br>do you feel that this proposal compares to those?<br></p><p>No, but have wanted this in Swift<br></p><p>• How much effort did you put into your review? A glance, a quick reading,<br>or an in-depth study?<br></p><p>Followed discussions on swift-evolution<br></p><p><br>On Tuesday, 5 April 2016, Joe Groff via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hello Swift community,<br>&gt;<br>&gt; The review of “Allow Swift types to provide custom Objective-C<br>&gt; representations” begins now and runs through April 11, 2016. The proposal<br>&gt; is available here:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0058-objectivecbridgeable.md<br>&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt; should be sent to the swift-evolution mailing list at<br>&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the<br>&gt; review manager. When replying, please try to keep the proposal link at<br>&gt; the top of the message:<br>&gt;<br>&gt; Proposal link:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0058-objectivecbridgeable.md<br>&gt;<br>&gt; Reply text<br>&gt;<br>&gt; Other replies<br>&gt;<br>&gt; *What goes into a review?*<br>&gt;<br>&gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and, eventually, determine the direction of<br>&gt; Swift. When writing your review, here are some questions you might want to<br>&gt; answer in your review:<br>&gt;<br>&gt; • What is your evaluation of the proposal?<br>&gt; • Is the problem being addressed significant enough to warrant a change to<br>&gt; Swift?<br>&gt; • Does this proposal fit well with the feel and direction of Swift?<br>&gt; • If you have used other languages or libraries with a similar feature,<br>&gt; how do you feel that this proposal compares to those?<br>&gt; • How much effort did you put into your review? A glance, a quick reading,<br>&gt; or an in-depth study?<br>&gt;<br>&gt; More information about the Swift evolution process is available at<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;<br>&gt; Thank you,<br>&gt;<br>&gt; -Joe<br>&gt; Review Manager<br>&gt;<br></p><p><br>-- <br>-- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160405/d70fe063/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review] SE-0058: Allow Swift types to provide custom Objective-C representations</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April  4, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0058-objectivecbridgeable.md<br></p><p>There are a number of things I&#39;m not really clear on.<br></p><p>* * *<br></p><p>Consider this Objective-C API:<br></p><p>	ObjCFizzer* myFizzer;<br></p><p>Which of these represents how it is imported?<br></p><p>	var myFizzer: ObjCFizzer<br>	var myFizzer: Fizzer<br></p><p>Suppose there is also a subclass (say, ObjCMutableFizzer), and we have this Objective-C API:<br></p><p>	ObjCMutableFizzer* mutableFizzer;<br></p><p>Which of these represents how it is imported?<br></p><p>	var myMutableFizzer: ObjCMutableFizzer<br>	var myMutableFizzer: Fizzer<br></p><p>On the basis of NSArray and friends, I assume they come across like this:<br></p><p>	var myFizzer: Fizzer<br>	var myMutableFizzer: ObjCMutableFizzer<br></p><p>Is that correct?<br></p><p>* * *<br></p><p>I assume that you can use casts to implicitly cross the bridge in both directions, even when Objective-C is not involved. That is, you could write something like this:<br></p><p>	ObjCFizzer() as Fizzer<br></p><p>Is that correct?<br></p><p>If you can cross the bridge purely in Swift, does the object type actually have to be @objc? Why?<br></p><p>If it does not have to be @objc, is this perhaps better thought of as an `ObjectBridgeable` protocol which allows cast-based conversion of any type to an equivalent class, and which also does Objective-C bridging if the class happens to be @objc? (This looser definition might help us if we ever interoperate with other object systems on different platforms.)<br></p><p>* * *<br></p><p>Suppose you have a value of type `ObjCMutableFizzer`:<br></p><p>	let mutableFizzer: ObjCMutableFizzer = ...<br></p><p>Can you write `mutableFizzer as! Fizzer`? In other words, if a type is bridged to a particular class, is it also bridged to its subclasses?<br></p><p>Based on the examples from Foundation, I suspect the answer is &quot;yes&quot;.<br></p><p>* * *<br></p><p>Foundation classes can sometimes be bridged using an upcast (a plain `as`), which cannot crash. Is this possible with ObjectiveCBridgeable? If so, how? If not, will Foundation classes lose that ability?<br></p><p>If this feature can&#39;t be expressed with ObjectiveCBridgeable, is this seen as a shortcoming we should try to overcome, or the proper design? I worry about the unnecessary proliferation of exclamation points, especially since many style guides strongly discourage them, which will turn this into an unnecessary proliferation of unnecessary `if let`s.<br></p><p>* * *<br></p><p>I&#39;m confused by a statement in the &quot;Ambiguity and Casting&quot; section:<br></p><p>	2. A Swift type may bridge to an Objective-C base class then provide different subclass instances at runtime, but no other Swift type may bridge to that base class or any of its subclasses.<br>		i. The compiler should emit a diagnostic when it detects two Swift types attempting to bridge to the same ObjectiveCType.<br></p><p>Does this mean that each bridged class must have exactly one corresponding Swift type? Or does it mean that if a bridged type has more than one corresponding Swift class, an explicit cast is always needed? Or merely that it may sometimes be needed?<br></p><p>There are examples in the frameworks of many types bridging to a single class. For instance, a whole hoard of numeric types bridge to NSNumber; Swift handles this by exposing Swift types like `[Int]` as `NSArray&lt;NSNumber*&gt;*`, but doesn&#39;t do any converting when going in the opposite direction. Is that how this new protocol works, or does it do something else? <br></p><p>* * *<br></p><p>I&#39;m confused by the SWIFT_BRIDGED() macro. Why does it exist? Doesn&#39;t the ObjectiveCBridgeable conformance provide all the information needed? What happens if you don&#39;t include it? (Perhaps you get the one-way bridging behavior seen with `NSNumber`?)<br></p><p>* * *<br></p><p>The &quot;Resilience&quot; section says:<br></p><p>	Adding or removing conformance to ObjectiveCBridgeable, or changing the ObjectiveCType is a fragile (breaking) change.<br></p><p>Why is this? In particular, why is adding a conformance a breaking change? That isn&#39;t the normal rule for protocols.<br></p><p>* * *<br></p><p>Probably a stupid question, but I want to be certain since the example does something else: There would not be some kind of circularity problem with defining `ObjCFizzer` in terms of `Fizzer`, would there? For instance:<br></p><p>	class ObjCFizzer: NSObject {<br>		fileprivate var fizzer: Fizzer<br></p><p>		fileprivate init(_ fizzer: Fizzer) {<br>			self.fizzer = fizzer<br>		}<br>				<br>		var fizzyString: String? {<br>			guard case .case1(let string) = fizzer else { return nil }<br></p><p>			return string<br>		}<br>		<br>		var fizzyX: Int? {<br>			guard case .case2(let x, _) = fizzer else { return nil }<br>			return x<br>		}<br>		<br>		var fizzyY: Int? {<br>			guard case .case2(_, let y) = fizzer else { return nil }<br>			return y<br>		}<br>	}<br>	extension ObjCFizzer {<br>		convenience init(string: String) {<br>			self.init(.case1(string))<br>		}<br>		<br>		convenience init(x: Int, y: Int) {<br>			fizzer = .case2(x, y)<br>		}<br>	}<br></p><p>I have a place in my code where I would like to use ObjectiveCBridgeable, but it uses a pattern like this, so I&#39;d like to make sure I&#39;ll be able to adopt the feature.<br></p><p>* * *<br></p><p>In general, I feel like this proposal is written in a way which is accessible to the people who participated in the original discussion, but not to others.<br></p><p>This is a proposal which contains seven uses of the word &quot;thunk&quot; and zero uses (as opposed to conformances) of the proposed protocol in examples. It seems to imply that existing bridging of Foundation types might change, but does not explain what those changes will mean for user code. It is fundamentally an Objective-C bridging feature, but it contains no examples of Objective-C.<br></p><p>In theory I think this proposal is a great idea, but in practice I understand the specifics of it so poorly that I can&#39;t really endorse it without some clarifications. Hopefully someone can explain things a little more clearly so that I can lend my support, or at least give a more specific and helpful critique.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>[Review] SE-0058: Allow Swift types to provide custom Objective-C representations</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>April  4, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Apr 4, 2016, at 9:22 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0058-objectivecbridgeable.md<br>&gt; <br>&gt; There are a number of things I&#39;m not really clear on.<br>&gt; <br>&gt; * * *<br>&gt; <br>&gt; Consider this Objective-C API:<br>&gt; <br>&gt; 	ObjCFizzer* myFizzer;<br>&gt; <br>&gt; Which of these represents how it is imported?<br>&gt; <br>&gt; 	var myFizzer: ObjCFizzer<br>&gt; 	var myFizzer: Fizzer<br></p><p>The latter. The idea is that the importer sees the bridged type is available and substitutes it on all imported signatures. The actual mechanics of that will involve some generated code (thunk) to call the protocol. I could update the proposal to include what the body of that thunk might look like but it didn’t seem terribly interesting.<br></p><p>&gt; <br>&gt; Suppose there is also a subclass (say, ObjCMutableFizzer), and we have this Objective-C API:<br>&gt; <br>&gt; 	ObjCMutableFizzer* mutableFizzer;<br>&gt; <br>&gt; Which of these represents how it is imported?<br>&gt; <br>&gt; 	var myMutableFizzer: ObjCMutableFizzer<br>&gt; 	var myMutableFizzer: Fizzer<br></p><p>The intention there is that it imports as the bridged type so the latter.<br></p><p><br>&gt; <br>&gt; On the basis of NSArray and friends, I assume they come across like this:<br>&gt; <br>&gt; 	var myFizzer: Fizzer<br>&gt; 	var myMutableFizzer: ObjCMutableFizzer<br>&gt; <br>&gt; Is that correct?<br></p><p>No<br></p><p><br>&gt; <br>&gt; * * *<br>&gt; <br>&gt; I assume that you can use casts to implicitly cross the bridge in both directions, even when Objective-C is not involved. That is, you could write something like this:<br>&gt; <br>&gt; 	ObjCFizzer() as Fizzer<br>&gt; <br>&gt; Is that correct?<br>&gt; <br>&gt; If you can cross the bridge purely in Swift, does the object type actually have to be @objc? Why?<br>&gt; <br>&gt; If it does not have to be @objc, is this perhaps better thought of as an `ObjectBridgeable` protocol which allows cast-based conversion of any type to an equivalent class, and which also does Objective-C bridging if the class happens to be @objc? (This looser definition might help us if we ever interoperate with other object systems on different platforms.)<br></p><p>In theory you could do this, though it would be a useless waste of CPU cycles :)<br></p><p>My thinking was that we may need similar bridging protocols in some hypothetical world where we can import C++ objects but the shape of the protocol (and certainly the constraints on the associated type) would be quite different.<br></p><p><br>&gt; <br>&gt; * * *<br>&gt; <br>&gt; Suppose you have a value of type `ObjCMutableFizzer`:<br>&gt; <br>&gt; 	let mutableFizzer: ObjCMutableFizzer = ...<br>&gt; <br>&gt; Can you write `mutableFizzer as! Fizzer`? In other words, if a type is bridged to a particular class, is it also bridged to its subclasses?<br>&gt; <br>&gt; Based on the examples from Foundation, I suspect the answer is &quot;yes”.<br></p><p>Yes, you can invoke as? or as! casts which will call the respective initializers, though the default implementation of unconditional bridging (as!) will call the conditional initializer.<br></p><p><br>&gt; <br>&gt; * * *<br>&gt; <br>&gt; Foundation classes can sometimes be bridged using an upcast (a plain `as`), which cannot crash. Is this possible with ObjectiveCBridgeable? If so, how? If not, will Foundation classes lose that ability?<br>&gt; <br>&gt; If this feature can&#39;t be expressed with ObjectiveCBridgeable, is this seen as a shortcoming we should try to overcome, or the proper design? I worry about the unnecessary proliferation of exclamation points, especially since many style guides strongly discourage them, which will turn this into an unnecessary proliferation of unnecessary `if let`s.<br></p><p>This would not be possible. This sort of bridging only works with special magic types because they are known to always succeed. There is no condition under which Swift will fail to convert String to NSString. The compiler/runtime can’t prove that about any arbitrary type.<br></p><p>For bridging an Objective-C library into Swift, ideally all the APIs will be annotated with SWIFT_BRIDGED so on import the Swift code won’t even be aware the Objective-C type exists. All you’ll see in Swift is the appropriate Swift types. This gives a library (say Photos.framework or UIKit) the chance to provide truly native Swift types by shipping a module with combined Swift and Objective-C code.<br></p><p>Similarly, going the other direction (an app with Objective-C and Swift code) this proposal eliminates the need to deal with the Objective-C types in Swift.<br></p><p>The only situation where casting might be required is interop with things like performSelector, context objects, or when SWIFT_BRIDGED annotations are missing.<br></p><p><br>&gt; <br>&gt; * * *<br>&gt; <br>&gt; I&#39;m confused by a statement in the &quot;Ambiguity and Casting&quot; section:<br>&gt; <br>&gt; 	2. A Swift type may bridge to an Objective-C base class then provide different subclass instances at runtime, but no other Swift type may bridge to that base class or any of its subclasses.<br>&gt; 		i. The compiler should emit a diagnostic when it detects two Swift types attempting to bridge to the same ObjectiveCType.<br>&gt; <br>&gt; Does this mean that each bridged class must have exactly one corresponding Swift type? Or does it mean that if a bridged type has more than one corresponding Swift class, an explicit cast is always needed? Or merely that it may sometimes be needed?<br></p><p>As of right now, the proposal says that is an error to define in Swift code and the compiler will generate an error.<br></p><p><br></p><p>&gt; <br>&gt; There are examples in the frameworks of many types bridging to a single class. For instance, a whole hoard of numeric types bridge to NSNumber; Swift handles this by exposing Swift types like `[Int]` as `NSArray&lt;NSNumber*&gt;*`, but doesn&#39;t do any converting when going in the opposite direction. Is that how this new protocol works, or does it do something else? <br></p><p>I’ve gone back and forth on the ambiguity section (In one version of the proposal, ambiguity just disabled automatic thunk generation and required you to perform manual casting). NSNumber brings up an interesting case. Several Swift types should adopt NSNumber as their bridging target, but wouldn’t be able to under the proposed rule. However allowing this for the general case may be problematic. There is already special compiler magic for importing things like NSInteger and Int bridges to NSInteger or NSNumber depending on whether it is inside a collection. I’m curious what other people’s thoughts are on this.<br></p><p><br></p><p>&gt; <br>&gt; * * *<br>&gt; <br>&gt; I&#39;m confused by the SWIFT_BRIDGED() macro. Why does it exist? Doesn&#39;t the ObjectiveCBridgeable conformance provide all the information needed? What happens if you don&#39;t include it? (Perhaps you get the one-way bridging behavior seen with `NSNumber`?)<br></p><p>For an Objective-C framework, the definitions of the @objc types will be in Objective-C headers, not an auto-generated Swift bridging header. The macro is both for the auto-generated header but also for library writers to use in their Objective-C headers.<br></p><p><br>&gt; <br>&gt; * * *<br>&gt; <br>&gt; The &quot;Resilience&quot; section says:<br>&gt; <br>&gt; 	Adding or removing conformance to ObjectiveCBridgeable, or changing the ObjectiveCType is a fragile (breaking) change.<br>&gt; <br>&gt; Why is this? In particular, why is adding a conformance a breaking change? That isn&#39;t the normal rule for protocols.<br></p><p>Because it changes the shape of the API of a client importing it. <br></p><p>For similar reasons requiring the bridging to be in same-named modules is to prevent the shape of an imported API changing because you imported a separate module that added some bridging conformance.<br></p><p><br>&gt; <br>&gt; * * *<br>&gt; <br>&gt; Probably a stupid question, but I want to be certain since the example does something else: There would not be some kind of circularity problem with defining `ObjCFizzer` in terms of `Fizzer`, would there? For instance:<br>&gt; <br>&gt; 	class ObjCFizzer: NSObject {<br>&gt; 		fileprivate var fizzer: Fizzer<br>&gt; <br>&gt; 		fileprivate init(_ fizzer: Fizzer) {<br>&gt; 			self.fizzer = fizzer<br>&gt; 		}<br>&gt; 				<br>&gt; 		var fizzyString: String? {<br>&gt; 			guard case .case1(let string) = fizzer else { return nil }<br>&gt; <br>&gt; 			return string<br>&gt; 		}<br>&gt; 		<br>&gt; 		var fizzyX: Int? {<br>&gt; 			guard case .case2(let x, _) = fizzer else { return nil }<br>&gt; 			return x<br>&gt; 		}<br>&gt; 		<br>&gt; 		var fizzyY: Int? {<br>&gt; 			guard case .case2(_, let y) = fizzer else { return nil }<br>&gt; 			return y<br>&gt; 		}<br>&gt; 	}<br>&gt; 	extension ObjCFizzer {<br>&gt; 		convenience init(string: String) {<br>&gt; 			self.init(.case1(string))<br>&gt; 		}<br>&gt; 		<br>&gt; 		convenience init(x: Int, y: Int) {<br>&gt; 			fizzer = .case2(x, y)<br>&gt; 		}<br>&gt; 	}<br>&gt; <br>&gt; I have a place in my code where I would like to use ObjectiveCBridgeable, but it uses a pattern like this, so I&#39;d like to make sure I&#39;ll be able to adopt the feature.<br>&gt; <br></p><p>You can certainly “wrap” the underlying Swift type and expose accessors for it as you’ve done here. There are no issues with circularity at all. <br></p><p>I realize that the proposal doesn’t explicitly state it but generally a type that is @objc can’t conform to ObjectiveCBridgeable. (Even if it did, the conformance would be useless.)<br></p><p><br></p><p>&gt; * * *<br>&gt; <br>&gt; In general, I feel like this proposal is written in a way which is accessible to the people who participated in the original discussion, but not to others.<br>&gt; <br>&gt; This is a proposal which contains seven uses of the word &quot;thunk&quot; and zero uses (as opposed to conformances) of the proposed protocol in examples. It seems to imply that existing bridging of Foundation types might change, but does not explain what those changes will mean for user code. It is fundamentally an Objective-C bridging feature, but it contains no examples of Objective-C.<br></p><p>The intent is for existing foundation types to continue bridging just as they do today with no changes. <br></p><p><br></p><p>Russ<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Review] SE-0058: Allow Swift types to provide custom Objective-C representations</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>April  5, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Apr 4, 2016, at 9:54 PM, Russ Bishop via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Apr 4, 2016, at 9:22 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0058-objectivecbridgeable.md<br>&gt;&gt; <br>&gt;&gt; There are a number of things I&#39;m not really clear on.<br>&gt;&gt; <br>&gt;&gt; * * *<br>&gt;&gt; <br>&gt;&gt; Consider this Objective-C API:<br>&gt;&gt; <br>&gt;&gt; 	ObjCFizzer* myFizzer;<br>&gt;&gt; <br>&gt;&gt; Which of these represents how it is imported?<br>&gt;&gt; <br>&gt;&gt; 	var myFizzer: ObjCFizzer<br>&gt;&gt; 	var myFizzer: Fizzer<br>&gt; <br>&gt; The latter. The idea is that the importer sees the bridged type is available and substitutes it on all imported signatures. The actual mechanics of that will involve some generated code (thunk) to call the protocol. I could update the proposal to include what the body of that thunk might look like but it didn’t seem terribly interesting.<br></p><p>Right. There will be some thunking the compiler does.<br></p><p>&gt;&gt; Suppose there is also a subclass (say, ObjCMutableFizzer), and we have this Objective-C API:<br>&gt;&gt; <br>&gt;&gt; 	ObjCMutableFizzer* mutableFizzer;<br>&gt;&gt; <br>&gt;&gt; Which of these represents how it is imported?<br>&gt;&gt; <br>&gt;&gt; 	var myMutableFizzer: ObjCMutableFizzer<br>&gt;&gt; 	var myMutableFizzer: Fizzer<br>&gt; <br>&gt; The intention there is that it imports as the bridged type so the latter.<br></p><p>I disagree here: ObjCFizzer is bridged, not ObjCMutableFizzer, so it would be the former.<br></p><p>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; On the basis of NSArray and friends, I assume they come across like this:<br>&gt;&gt; <br>&gt;&gt; 	var myFizzer: Fizzer<br>&gt;&gt; 	var myMutableFizzer: ObjCMutableFizzer<br>&gt;&gt; <br>&gt;&gt; Is that correct?<br>&gt; <br>&gt; No<br></p><p>I would have said “yes&quot; ;)<br></p><p>&gt;&gt; <br>&gt;&gt; * * *<br>&gt;&gt; <br>&gt;&gt; Foundation classes can sometimes be bridged using an upcast (a plain `as`), which cannot crash. Is this possible with ObjectiveCBridgeable? If so, how? If not, will Foundation classes lose that ability?<br>&gt;&gt; <br>&gt;&gt; If this feature can&#39;t be expressed with ObjectiveCBridgeable, is this seen as a shortcoming we should try to overcome, or the proper design? I worry about the unnecessary proliferation of exclamation points, especially since many style guides strongly discourage them, which will turn this into an unnecessary proliferation of unnecessary `if let`s.<br>&gt; <br>&gt; This would not be possible. This sort of bridging only works with special magic types because they are known to always succeed. There is no condition under which Swift will fail to convert String to NSString. The compiler/runtime can’t prove that about any arbitrary type.<br></p><p>We can bridge from, e.g., Fizzer to ObjCFizzer via “as Fizzer” using the entry-point<br></p><p>	func bridgeToObjectiveC() -&gt; ObjectiveCType<br></p><p><br>&gt; For bridging an Objective-C library into Swift, ideally all the APIs will be annotated with SWIFT_BRIDGED so on import the Swift code won’t even be aware the Objective-C type exists. All you’ll see in Swift is the appropriate Swift types. This gives a library (say Photos.framework or UIKit) the chance to provide truly native Swift types by shipping a module with combined Swift and Objective-C code.<br>&gt; <br>&gt; Similarly, going the other direction (an app with Objective-C and Swift code) this proposal eliminates the need to deal with the Objective-C types in Swift.<br></p><p>The ObjC types will still exist (unless explicitly banned via NS_UNAVAILABLE_IN_SWIFT or similar), and can leak through in some cases (e.g., UnsafeMutablePointer&lt;ObjCFuzzer&gt;).<br></p><p>	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160405/2843af97/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>[Review] SE-0058: Allow Swift types to provide custom Objective-C representations</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>April  5, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Apr 5, 2016, at 10:14 AM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Suppose there is also a subclass (say, ObjCMutableFizzer), and we have this Objective-C API:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	ObjCMutableFizzer* mutableFizzer;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Which of these represents how it is imported?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	var myMutableFizzer: ObjCMutableFizzer<br>&gt;&gt;&gt; 	var myMutableFizzer: Fizzer<br>&gt;&gt; <br>&gt;&gt; The intention there is that it imports as the bridged type so the latter.<br>&gt; <br>&gt; I disagree here: ObjCFizzer is bridged, not ObjCMutableFizzer, so it would be the former.<br>&gt; <br></p><p>Hmmm… So all subclasses are hidden as far as the interface is concerned (and the ambiguity rules)? I’m fine with that, it seems like it suites the class cluster approach just fine.<br></p><p><br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * * *<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Foundation classes can sometimes be bridged using an upcast (a plain `as`), which cannot crash. Is this possible with ObjectiveCBridgeable? If so, how? If not, will Foundation classes lose that ability?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If this feature can&#39;t be expressed with ObjectiveCBridgeable, is this seen as a shortcoming we should try to overcome, or the proper design? I worry about the unnecessary proliferation of exclamation points, especially since many style guides strongly discourage them, which will turn this into an unnecessary proliferation of unnecessary `if let`s.<br>&gt;&gt; <br>&gt;&gt; This would not be possible. This sort of bridging only works with special magic types because they are known to always succeed. There is no condition under which Swift will fail to convert String to NSString. The compiler/runtime can’t prove that about any arbitrary type.<br>&gt; <br>&gt; We can bridge from, e.g., Fizzer to ObjCFizzer via “as Fizzer” using the entry-point<br>&gt; <br>&gt; 	func bridgeToObjectiveC() -&gt; ObjectiveCType<br>&gt; <br></p><p>It does seem strange that this is asymmetrical but I don’t know that it is worth the complexity to introduce an extended protocol to declare a type has a bi-directional always-succeeds bridging conversion.<br></p><p><br>&gt; <br>&gt;&gt; For bridging an Objective-C library into Swift, ideally all the APIs will be annotated with SWIFT_BRIDGED so on import the Swift code won’t even be aware the Objective-C type exists. All you’ll see in Swift is the appropriate Swift types. This gives a library (say Photos.framework or UIKit) the chance to provide truly native Swift types by shipping a module with combined Swift and Objective-C code.<br>&gt;&gt; <br>&gt;&gt; Similarly, going the other direction (an app with Objective-C and Swift code) this proposal eliminates the need to deal with the Objective-C types in Swift.<br>&gt; <br>&gt; The ObjC types will still exist (unless explicitly banned via NS_UNAVAILABLE_IN_SWIFT or similar), and can leak through in some cases (e.g., UnsafeMutablePointer&lt;ObjCFuzzer&gt;).<br>&gt; <br>&gt; 	- Doug<br></p><p>Agreed, that’s what I meant by &quot;things like performSelector, context objects, …” :)<br></p><p><br>Russ<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160405/f9170ae6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Review] SE-0058: Allow Swift types to provide custom Objective-C representations</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>April  5, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Apr 5, 2016, at 11:36 AM, Russ Bishop &lt;xenadu at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 5, 2016, at 10:14 AM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Suppose there is also a subclass (say, ObjCMutableFizzer), and we have this Objective-C API:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	ObjCMutableFizzer* mutableFizzer;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Which of these represents how it is imported?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	var myMutableFizzer: ObjCMutableFizzer<br>&gt;&gt;&gt;&gt; 	var myMutableFizzer: Fizzer<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The intention there is that it imports as the bridged type so the latter.<br>&gt;&gt; <br>&gt;&gt; I disagree here: ObjCFizzer is bridged, not ObjCMutableFizzer, so it would be the former.<br>&gt;&gt; <br>&gt; <br>&gt; Hmmm… So all subclasses are hidden as far as the interface is concerned (and the ambiguity rules)? I’m fine with that, it seems like it suites the class cluster approach just fine.<br></p><p>Not “hidden”; they’re accessible and not bridged.<br></p><p>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * * *<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Foundation classes can sometimes be bridged using an upcast (a plain `as`), which cannot crash. Is this possible with ObjectiveCBridgeable? If so, how? If not, will Foundation classes lose that ability?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If this feature can&#39;t be expressed with ObjectiveCBridgeable, is this seen as a shortcoming we should try to overcome, or the proper design? I worry about the unnecessary proliferation of exclamation points, especially since many style guides strongly discourage them, which will turn this into an unnecessary proliferation of unnecessary `if let`s.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This would not be possible. This sort of bridging only works with special magic types because they are known to always succeed. There is no condition under which Swift will fail to convert String to NSString. The compiler/runtime can’t prove that about any arbitrary type.<br>&gt;&gt; <br>&gt;&gt; We can bridge from, e.g., Fizzer to ObjCFizzer via “as Fizzer” using the entry-point<br>&gt;&gt; <br>&gt;&gt; 	func bridgeToObjectiveC() -&gt; ObjectiveCType<br>&gt;&gt; <br>&gt; <br>&gt; It does seem strange that this is asymmetrical but I don’t know that it is worth the complexity to introduce an extended protocol to declare a type has a bi-directional always-succeeds bridging conversion.<br></p><p>It is a little odd; we have isBridgedToObjectiveC and bridgeToObjectiveC, where we could possibly have the latter produce an ObjectiveCType? and remove the former.<br></p><p>	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160405/fbf558fe/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bab03b11d4cd60804cf4a6ba68589430?s=50"></div><header><strong>[Review] SE-0058: Allow Swift types to provide custom Objective-C representations</strong> from <string>Kevin Lundberg</string> &lt;kevin at klundberg.com&gt;<p>April  5, 2016 at 08:00:00pm</p></header><div class="content"><p>Generally I&#39;m +1 on this, but I do have a concern. It&#39;s not made<br>explicit in the proposal, but I presume that this is meant to only be<br>available on Darwin, and not Linux or other platforms that don&#39;t have<br>swift using the Objective-C runtime? (Please correct me if I am mistaken.)<br></p><p>I ask because of the swift-corelibs-foundation project; Presumably once<br>that is complete for Swift 3, code that makes use of this type bridging<br>should be able to be run cross-platform. For example:<br></p><p>var a = [AnyObject]()<br>(a as NSArray).addObject(NSObject()) // should this work on all platforms?<br></p><p>swift-corelibs-foundation uses its own protocol named<br>_ObjectTypeBridgeable (defined here:<br>https://github.com/apple/swift-corelibs-foundation/blob/338f4bf3a89c75a0420b49f5701466e106af02b5/Foundation/NSSwiftRuntime.swift#L205)<br>to simulate what happens today on Darwin platforms, but there is no<br>language support for it so API consumers must explicitly call its<br>bridging methods. It would be great if corelibs-foundation (and any code<br>designed to work on Linux) could take advantage of this proposal to<br>provide the language support, and if the proposal as written is not<br>intended to have an effect on Linux at all, then I would suggest we<br>modify it so that the resulting implementation is not tied to<br>Objective-C and Darwin only.<br></p><p>-Kevin<br></p><p>On 4/4/2016 1:44 PM, Joe Groff via swift-evolution wrote:<br>&gt; Hello Swift community,<br>&gt;<br>&gt; The review of “Allow Swift types to provide custom Objective-C<br>&gt; representations” begins now and runs through April 11, 2016. The<br>&gt; proposal is available here:<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0058-objectivecbridgeable.md<br>&gt;<br>&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All<br>&gt; reviews should be sent to the swift-evolution mailing list at<br>&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the<br>&gt; review manager. When replying, please try to keep the proposal link at<br>&gt; the top of the message:<br>&gt;<br>&gt; Proposal link:<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0058-objectivecbridgeable.md<br>&gt;<br>&gt; Reply text<br>&gt;<br>&gt; Other replies<br>&gt;<br>&gt; *What goes into a review?*<br>&gt;<br>&gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and, eventually, determine the<br>&gt; direction of Swift. When writing your review, here are some questions<br>&gt; you might want to answer in your review:<br>&gt;<br>&gt; • What is your evaluation of the proposal?<br>&gt; • Is the problem being addressed significant enough to warrant a<br>&gt; change to Swift?<br>&gt; • Does this proposal fit well with the feel and direction of Swift?<br>&gt; • If you have used other languages or libraries with a similar<br>&gt; feature, how do you feel that this proposal compares to those?<br>&gt; • How much effort did you put into your review? A glance, a quick<br>&gt; reading, or an in-depth study?<br>&gt;<br>&gt; More information about the Swift evolution process is available at<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;<br>&gt; Thank you,<br>&gt;<br>&gt; -Joe<br>&gt; Review Manager<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160405/d80e0a81/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>[Review] SE-0058: Allow Swift types to provide custom Objective-C representations</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>April  6, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Apr 5, 2016, at 5:57 PM, Kevin Lundberg via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Generally I&#39;m +1 on this, but I do have a concern. It&#39;s not made explicit in the proposal, but I presume that this is meant to only be available on Darwin, and not Linux or other platforms that don&#39;t have swift using the Objective-C runtime? (Please correct me if I am mistaken.)<br>&gt; <br>&gt; I ask because of the swift-corelibs-foundation project; Presumably once that is complete for Swift 3, code that makes use of this type bridging should be able to be run cross-platform. For example:<br>&gt; <br>&gt; var a = [AnyObject]()<br>&gt; (a as NSArray).addObject(NSObject()) // should this work on all platforms?<br>&gt; <br>&gt; swift-corelibs-foundation uses its own protocol named _ObjectTypeBridgeable (defined here: https://github.com/apple/swift-corelibs-foundation/blob/338f4bf3a89c75a0420b49f5701466e106af02b5/Foundation/NSSwiftRuntime.swift#L205 &lt;https://github.com/apple/swift-corelibs-foundation/blob/338f4bf3a89c75a0420b49f5701466e106af02b5/Foundation/NSSwiftRuntime.swift#L205&gt;) to simulate what happens today on Darwin platforms, but there is no language support for it so API consumers must explicitly call its bridging methods. It would be great if corelibs-foundation (and any code designed to work on Linux) could take advantage of this proposal to provide the language support, and if the proposal as written is not intended to have an effect on Linux at all, then I would suggest we modify it so that the resulting implementation is not tied to Objective-C and Darwin only.<br>&gt; <br>&gt; -Kevin<br>&gt; <br></p><p><br>The original intent was to be available on platforms that have an Objective-C runtime (Darwin only at the moment, I guess in theory Windows if someone were determined enough).<br></p><p><br>You bring up a good point; there is nothing in the protocol that absolutely requires Objective-C, only that it requires AnyObject be the root object type. <br></p><p>However in some hypothetical world where we support importing C++ types, Rust types, or JavaScript (only half trolling) types it would be nice for this protocol to have something tying it to the idea that we are bridging to the Objective-C/corelibs-foundation runtime specifically.<br></p><p><br>Russ<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/147bc226/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bab03b11d4cd60804cf4a6ba68589430?s=50"></div><header><strong>[Review] SE-0058: Allow Swift types to provide custom Objective-C representations</strong> from <string>Kevin Lundberg</string> &lt;kevin at klundberg.com&gt;<p>April  6, 2016 at 09:00:00pm</p></header><div class="content"><p>On 4/6/2016 1:22 PM, Russ Bishop wrote:<br>&gt; The original intent was to be available on platforms that have an<br>&gt; Objective-C runtime (Darwin only at the moment, I guess in theory<br>&gt; Windows if someone were determined enough).<br>&gt;<br>&gt;<br>&gt; You bring up a good point; there is nothing in the protocol that<br>&gt; absolutely requires Objective-C, only that it requires AnyObject be<br>&gt; the root object type. <br>&gt;<br>&gt; However in some hypothetical world where we support importing C++<br>&gt; types, Rust types, or JavaScript (only half trolling) types it would<br>&gt; be nice for this protocol to have something tying it to the idea that<br>&gt; we are bridging to the Objective-C/corelibs-foundation runtime<br>&gt; specifically.<br>&gt;<br>&gt;<br>&gt; Russ<br></p><p>Good point. I was going to suggest breaking out the protocol into a<br>general swift version and have an objective-c specific one refine it,<br>but in the case where bridging to other languages happens, those other<br>language specific bridging protocols wouldn&#39;t be able to refine the<br>generic base protocol for types that want to bridge more than one<br>language. I formally retract my concern :)<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/e18f7f2a/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
