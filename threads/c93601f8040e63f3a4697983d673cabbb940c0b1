<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8809800aec2460f291384b794d7e6f8f?s=50"></div><header><strong>Are value semantics really appropriate in a diagramming app?</strong> from <string>Rick Mann</string> &lt;rmann at latencyzero.com&gt;<p>August  1, 2016 at 01:00:00am</p></header><div class="content"><p>I watched the WWDC 2015 video about protocol-oriented programming and value semantics. Both of them use the example of a diagramming app, where the user can make a diagram of circles and polygons. They make a protocol for Drawable (makes sense), and then make Circle and Polygon structs.<br></p><p>I&#39;m working on rewriting a long-term project of mine in Swift. It&#39;s a schematic capture CAD app, and it draws schematic diagrams built up from instances of parts from a library, and wires between them. Currently, my model is entirely made of classes, with reference semantics. I&#39;m trying to see if it wouldn&#39;t make sense to make them structs with value semantics, but I don&#39;t think it does, and I&#39;m looking for advice.<br></p><p>My model consists of the following objects: PartDefinition and PartInstance, as well as some geometric primitives. A PartDefinition has a set of properties (e.g. UUID, name, value), and a set of geometric primitives. The geometry defines the appearance on screen, and the properties give the part identity in the schematic. A PartInstance references a PartDefinition, and adds a position property (to define that instance&#39;s location in the canvas), as well as overriding zero or more of the PartDefinition&#39;s properties, or adding its own (for example, a PartInstance gets a Reference Designator, just a label for the instance, like &quot;R1&quot; or &quot;U23&quot;). A PartInstance rarely, if ever, overrides or adds geometry found in the corresponding PartDefinition.<br></p><p>The reason I don&#39;t think these work so well with value semantics is that they can be edited by the user: they can be repositioned, properties can be changed, etc. Even the geometry of a PartDefinition can be changed, and the intended result is that all instances displayed in the canvas reflect the new geometry.<br></p><p>Similarly, in the diagramming example from the WWDC videos, how would that app handle the user editing existing Drawables in the Diagram? Let&#39;s say you allow the user to click on a Drawable and drag it to another location in the canvas. Is this reasonable:<br></p><p>- User clicks with the mouse<br>- Find the item hit by that click by iterating through the array of Drawable<br>- var currentItem = self.items[hitIndex] (makes a copy)<br>- update currentItem with whatever changes have occurred<br>- self.items[hitIndex] = currentItem (copy the new values back into the array<br>- set window needs update<br></p><p>It seems like reference semantics are more appropriate here.<br></p><p>Thoughts? Thanks.<br></p><p>-- <br>Rick Mann<br>rmann at latencyzero.com<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ec5a599777854c540fd102ef4691fe10?s=50"></div><header><strong>Are value semantics really appropriate in a diagramming app?</strong> from <string>Rimantas Liubertas</string> &lt;rimantas at gmail.com&gt;<p>August  1, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; Similarly, in the diagramming example from the WWDC videos, how would that<br>&gt; app handle the user editing existing Drawables in the Diagram? Let&#39;s say<br>&gt; you allow the user to click on a Drawable and drag it to another location<br>&gt; in the canvas. Is this reasonable:<br>&gt;<br></p><p>See this talk too: https://developer.apple.com/videos/play/wwdc2015/414/<br>It should answer a lot of your question and give some new ideas.<br></p><p>Best regards,<br>Rimantas<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160801/0e0a9f58/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8809800aec2460f291384b794d7e6f8f?s=50"></div><header><strong>Are value semantics really appropriate in a diagramming app?</strong> from <string>Rick Mann</string> &lt;rmann at latencyzero.com&gt;<p>August  1, 2016 at 02:00:00am</p></header><div class="content"><p>&gt; On Aug 1, 2016, at 02:14 , Rimantas Liubertas &lt;rimantas at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Similarly, in the diagramming example from the WWDC videos, how would that app handle the user editing existing Drawables in the Diagram? Let&#39;s say you allow the user to click on a Drawable and drag it to another location in the canvas. Is this reasonable:<br>&gt; <br>&gt; See this talk too: https://developer.apple.com/videos/play/wwdc2015/414/<br>&gt; It should answer a lot of your question and give some new ideas.<br></p><p>I did. That&#39;s one of the two talks I mentioned.<br></p><p><br>-- <br>Rick Mann<br>rmann at latencyzero.com<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>Are value semantics really appropriate in a diagramming app?</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>August  1, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Aug 1, 2016, at 1:19 AM, Rick Mann via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; It seems like reference semantics are more appropriate here.<br></p><p>Yes, they are. (Just because structs exist doesn’t mean you have to use them everywhere.)<br></p><p>—Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160801/c4e0a0fd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8809800aec2460f291384b794d7e6f8f?s=50"></div><header><strong>Are value semantics really appropriate in a diagramming app?</strong> from <string>Rick Mann</string> &lt;rmann at latencyzero.com&gt;<p>August  1, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Aug 1, 2016, at 16:32 , Jens Alfke &lt;jens at mooseyard.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Aug 1, 2016, at 1:19 AM, Rick Mann via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; It seems like reference semantics are more appropriate here.<br>&gt; <br>&gt; Yes, they are. (Just because structs exist doesn’t mean you have to use them everywhere.)<br></p><p>Of course. I&#39;m just trying to expand on the Diagramming app example in the talks to a more real-world example. They make a compelling case for a value-based model, but I&#39;m currently stuck trying to figure out how to do this in my complex app without duplicating a lot of code.<br></p><p><br>-- <br>Rick Mann<br>rmann at latencyzero.com<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ec21faaf010581d3b9d6ef507644e622?s=50"></div><header><strong>Are value semantics really appropriate in a diagramming app?</strong> from <string>Jack Lawrence</string> &lt;jackl at apple.com&gt;<p>August  1, 2016 at 07:00:00pm</p></header><div class="content"><p>Jens: Why? There are significant benefits to value semantics for this type of problem, for the reasons laid out in the WWDC videos. It would be helpful to know why you disagree in this case—maybe there are solutions to the issues you’re thinking of.<br></p><p>Rick: I’d think that value semantics would be the right choice here. When you do a mutation, you would copy the state of the entire diagram. It should be efficient via COW, but if not you can implement you own more fine-grained COW types with isUniquelyReferenced(). This would allow you to easily support things like undo.<br></p><p>Jack<br>&gt; On Aug 1, 2016, at 4:32 PM, Jens Alfke via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Aug 1, 2016, at 1:19 AM, Rick Mann via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; It seems like reference semantics are more appropriate here.<br>&gt; <br>&gt; Yes, they are. (Just because structs exist doesn’t mean you have to use them everywhere.)<br>&gt; <br>&gt; —Jens<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160801/55119126/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8809800aec2460f291384b794d7e6f8f?s=50"></div><header><strong>Are value semantics really appropriate in a diagramming app?</strong> from <string>Rick Mann</string> &lt;rmann at latencyzero.com&gt;<p>August  1, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Aug 1, 2016, at 19:18 , Jack Lawrence &lt;jackl at apple.com&gt; wrote:<br>&gt; <br>&gt; Jens: Why? There are significant benefits to value semantics for this type of problem, for the reasons laid out in the WWDC videos. It would be helpful to know why you disagree in this case—maybe there are solutions to the issues you’re thinking of.<br>&gt; <br>&gt; Rick: I’d think that value semantics would be the right choice here. When you do a mutation, you would copy the state of the entire diagram. It should be efficient via COW, but if not you can implement you own more fine-grained COW types with isUniquelyReferenced(). This would allow you to easily support things like undo.<br></p><p>The more I consider this, the more I think value semantics won&#39;t work for me. I think, to take advantage of the easy undo feature, my entire model *must* be implemented with value semantics.<br></p><p>But my model has implicit reference semantics: multiple instances of a part can share a PartDefinition; it is intended that if the PartDefinition changes, all the referencing instances get the change. There are additional situations in which reference semantics are at play, as well: a PartDefinition can have one or more labels, but each instance can specify the relative location of the label for that instance. So, there is struct that contains a position and a reference to the label in the PartDefinition. But if the contents of the label changes, all the instances need to see that change.<br></p><p>I don&#39;t think I get to take advantage of value semantics, and it makes me wonder if any typical, non-trivial model&#39;s object graph really has no reference semantics.<br></p><p>&gt; <br>&gt; Jack<br>&gt;&gt; On Aug 1, 2016, at 4:32 PM, Jens Alfke via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Aug 1, 2016, at 1:19 AM, Rick Mann via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It seems like reference semantics are more appropriate here.<br>&gt;&gt; <br>&gt;&gt; Yes, they are. (Just because structs exist doesn’t mean you have to use them everywhere.)<br>&gt;&gt; <br>&gt;&gt; —Jens<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt; <br></p><p><br>-- <br>Rick Mann<br>rmann at latencyzero.com<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>Are value semantics really appropriate in a diagramming app?</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>August  1, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Aug 1, 2016, at 7:24 PM, Rick Mann &lt;rmann at latencyzero.com&gt; wrote:<br>&gt; <br>&gt; But my model has implicit reference semantics: multiple instances of a part can share a PartDefinition; it is intended that if the PartDefinition changes, all the referencing instances get the change.<br></p><p>Bingo. That’s the very definition of a reference.<br></p><p><br></p><p>&gt; On Aug 1, 2016, at 7:18 PM, Jack Lawrence &lt;jackl at apple.com&gt; wrote:<br>&gt; <br>&gt; I’d think that value semantics would be the right choice here. When you do a mutation, you would copy the state of the entire diagram. It should be efficient via COW<br></p><p><br>It sounds like you’re talking about a persistent data structure &lt;https://en.wikipedia.org/wiki/Persistent_data_structure&gt;, which to me is not the same thing as a value type.<br></p><p>—Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160801/9e28e4a9/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Are value semantics really appropriate in a diagramming app?</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>August  1, 2016 at 07:00:00pm</p></header><div class="content"><p>I happen to agree with Jens, though Dave Abrahams (and Crusty) might disagree with me. The number one consideration for choosing between a value type and a reference type is “do I want value semantics or reference semantics?” If I want to talk about a particular shape, talk about “that one”, I can only do that if there’s some notion of identity. So yes, if that’s part of my app, I would start with reference types.<br></p><p>Now, that doesn’t have to apply to rendering. As shown in the presentation, if you’re generating the shapes, there’s no need to refer to a particular shape afterwards…especially if the shapes are immutable. Any individual shape is just data to be rendered. But if I want a command like “change the color of that square”, then I need a way to know what “that square” refers to, and an object with persistent identity—a class instance—is one way to do it.<br></p><p>You can get a notion of “identity” in ways other than reference semantics—say, by generating unique IDs that go with a particular shape, and then looking them up later. But it’s a perfectly fine choice to make your model use reference semantics.<br></p><p>All of that said, reference semantics do have traps: mutation makes things harder to test in isolation, and mutation with shared state makes things not thread-safe. So you have to decide what trade-off you want to make in your app.<br></p><p>Jordan<br></p><p><br>&gt; On Aug 1, 2016, at 19:18, Jack Lawrence via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Jens: Why? There are significant benefits to value semantics for this type of problem, for the reasons laid out in the WWDC videos. It would be helpful to know why you disagree in this case—maybe there are solutions to the issues you’re thinking of.<br>&gt; <br>&gt; Rick: I’d think that value semantics would be the right choice here. When you do a mutation, you would copy the state of the entire diagram. It should be efficient via COW, but if not you can implement you own more fine-grained COW types with isUniquelyReferenced(). This would allow you to easily support things like undo.<br>&gt; <br>&gt; Jack<br>&gt;&gt; On Aug 1, 2016, at 4:32 PM, Jens Alfke via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Aug 1, 2016, at 1:19 AM, Rick Mann via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It seems like reference semantics are more appropriate here.<br>&gt;&gt; <br>&gt;&gt; Yes, they are. (Just because structs exist doesn’t mean you have to use them everywhere.)<br>&gt;&gt; <br>&gt;&gt; —Jens<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160801/74eee36a/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
