<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0ab9e40f73106b42eaa9724c02b6ad8?s=50"></div><header><strong>Covariance and Contravariance</strong> from <string>Simon Pilkington</string> &lt;simonmpilkington at icloud.com&gt;<p>December  8, 2015 at 11:00:00pm</p></header><div class="content"><p>Hi,<br></p><p>Is providing Covariance and Contravariance[1] of generics going to be part of the work on generics for Swift 3? I am sure this topic has come up within the core team and I was wondering what their opinion on the topic was.<br></p><p>I can see this as beneficial as it would allow the compiler - in conjunction with type inference - to retain more type information and hence allow code be more type safe. For example -<br></p><p>class ConcreteClass&lt;GenType : GenericType&gt; {<br>    ...<br>    <br>    func getFunction() -&gt; GenType {<br>        ...<br>    }<br>    <br>    func putFunction(input: GenType) -&gt; Bool {<br>        return ...<br>    }<br>    <br>}<br></p><p>protocol GenericType {<br>    ...<br>}<br></p><p>class GenericType1 : GenericType {<br>    ...<br>}<br></p><p>class GenericType2 : GenericType {<br>    ...<br>}<br></p><p>let array = [ConcreteClass&lt;GenericType2&gt;(...), ConcreteClass&lt;GenericType1&gt;(...)]<br></p><p>let x : GenericType = array[0].getFunction() // this would compile as array would be of type ConcreteClass&lt;types that extend GenericType&gt;<br>                      // currently array is of type AnyObject so this line doesn’t compile<br>array[0].putFunction(…) // this would still not compile as it would break type guarantees<br></p><p>As a downside I can see it as making generics more complex and difficult to understand. On balance I think probably the benefit in improved type safety is worth it but I was interested in what others thought.<br></p><p>Cheers,<br>Simon<br></p><p>[1] https://dzone.com/articles/covariance-and-contravariance<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/13b77300/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Covariance and Contravariance</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December  9, 2015 at 12:00:00am</p></header><div class="content"><p>&gt; On Dec 8, 2015, at 11:47 PM, Simon Pilkington via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; Is providing Covariance and Contravariance[1] of generics going to be part of the work on generics for Swift 3? I am sure this topic has come up within the core team and I was wondering what their opinion on the topic was.<br>&gt; <br>&gt; I can see this as beneficial as it would allow the compiler - in conjunction with type inference - to retain more type information and hence allow code be more type safe. For example -<br>&gt; <br>&gt; class ConcreteClass&lt;GenType : GenericType&gt; {<br>&gt;     ...<br>&gt;     <br>&gt;     func getFunction() -&gt; GenType {<br>&gt;         ...<br>&gt;     }<br>&gt;     <br>&gt;     func putFunction(input: GenType) -&gt; Bool {<br>&gt;         return ...<br>&gt;     }<br>&gt;     <br>&gt; }<br>&gt; <br>&gt; protocol GenericType {<br>&gt;     ...<br>&gt; }<br>&gt; <br>&gt; class GenericType1 : GenericType {<br>&gt;     ...<br>&gt; }<br>&gt; <br>&gt; class GenericType2 : GenericType {<br>&gt;     ...<br>&gt; }<br>&gt; <br>&gt; let array = [ConcreteClass&lt;GenericType2&gt;(...), ConcreteClass&lt;GenericType1&gt;(...)]<br>&gt; <br>&gt; let x : GenericType = array[0].getFunction() // this would compile as array would be of type ConcreteClass&lt;types that extend GenericType&gt;<br>&gt;                       // currently array is of type AnyObject so this line doesn’t compile<br>&gt; array[0].putFunction(…) // this would still not compile as it would break type guarantees<br>&gt; <br>&gt; As a downside I can see it as making generics more complex and difficult to understand. On balance I think probably the benefit in improved type safety is worth it but I was interested in what others thought.<br></p><p>One challenge here is that subtyping in Swift doesn’t mean equivalence of representation.  For example, Int is a subtype of Int?, but the later requires extra space to store in memory.  So while it would make sense to allow, say, [Int] to be a subtype of [Int?], the actual conversion at runtime wouldn’t be trivial — we’d either need to eagerly apply the element-wise transform, or Array would need some ability to apply it lazily.  Both come with fairly serious performance costs.<br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/745767e1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/998d3d631acb87e0aa687abc0085f990?s=50"></div><header><strong>Covariance and Contravariance</strong> from <string>André Videla</string> &lt;zephyz at me.com&gt;<p>December  9, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On 09 Dec 2015, at 09:04, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; One challenge here is that subtyping in Swift doesn’t mean equivalence of representation.<br></p><p>I’m curious, what does that mean?<br>In my experience,&quot; Int &lt;: Int?&quot; means Int can be used when &quot;Int?&quot; is expected.<br>Imagine this scenario:<br></p><p>class A {}<br>class B {}<br>class C : A {}<br>class D : B {}<br></p><p>func processDict(d: [C : B]) {}<br></p><p>let dict1 = [C: B]()<br>let dict2 = [A: D]()  //dict 2 &lt;: dict1<br>processDict(dict1)<br>processDict(dict2)<br></p><p>I get a type error when it should type check. Because it is safe to output D wherever I expect a B and It is safe to use A whenever I need to input a C.<br></p><p>About your example on covariant arrays: Variance on arrays depends on if they are read only or read and write.<br>Read and write arrays need to be invariant to be safe. But read-only arrays can be covariant. If the compiler can make this distinction, it seem reasonable to assume it can eagerly do the transformation at no runtime cost.<br></p><p>- André<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/f7d8a602/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Covariance and Contravariance</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December  9, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 9, 2015, at 12:04 AM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 8, 2015, at 11:47 PM, Simon Pilkington via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi,<br>&gt;&gt; <br>&gt;&gt; Is providing Covariance and Contravariance[1] of generics going to be part of the work on generics for Swift 3? I am sure this topic has come up within the core team and I was wondering what their opinion on the topic was.<br>&gt;&gt; <br>&gt;&gt; I can see this as beneficial as it would allow the compiler - in conjunction with type inference - to retain more type information and hence allow code be more type safe. For example -<br>&gt;&gt; <br>&gt;&gt; class ConcreteClass&lt;GenType : GenericType&gt; {<br>&gt;&gt;     ...<br>&gt;&gt;     <br>&gt;&gt;     func getFunction() -&gt; GenType {<br>&gt;&gt;         ...<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     func putFunction(input: GenType) -&gt; Bool {<br>&gt;&gt;         return ...<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; protocol GenericType {<br>&gt;&gt;     ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class GenericType1 : GenericType {<br>&gt;&gt;     ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class GenericType2 : GenericType {<br>&gt;&gt;     ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let array = [ConcreteClass&lt;GenericType2&gt;(...), ConcreteClass&lt;GenericType1&gt;(...)]<br>&gt;&gt; <br>&gt;&gt; let x : GenericType = array[0].getFunction() // this would compile as array would be of type ConcreteClass&lt;types that extend GenericType&gt;<br>&gt;&gt;                       // currently array is of type AnyObject so this line doesn’t compile<br>&gt;&gt; array[0].putFunction(…) // this would still not compile as it would break type guarantees<br>&gt;&gt; <br>&gt;&gt; As a downside I can see it as making generics more complex and difficult to understand. On balance I think probably the benefit in improved type safety is worth it but I was interested in what others thought.<br>&gt; <br>&gt; One challenge here is that subtyping in Swift doesn’t mean equivalence of representation.  For example, Int is a subtype of Int?, but the later requires extra space to store in memory.  So while it would make sense to allow, say, [Int] to be a subtype of [Int?], the actual conversion at runtime wouldn’t be trivial — we’d either need to eagerly apply the element-wise transform, or Array would need some ability to apply it lazily.  Both come with fairly serious performance costs.<br></p><p>Another thing that makes covariance in Swift interesting compared to other OO languages is value semantics. Mutation operations on value types like Array and Dictionary can be safely covariant, whereas this is unsafe in Java or C#. This is great for expressivity, but it means that a generalized covariance proposal needs to do some legwork to decide what operations exactly can be safely covariant, and how far the compiler can verify that. I haven&#39;t thought extensively about this, but it seems potentially complex.<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/fe041f04/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>Covariance and Contravariance</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>December  9, 2015 at 02:00:00pm</p></header><div class="content"><p>Le 9 déc. 2015 à 3:04, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br></p><p>&gt; One challenge here is that subtyping in Swift doesn’t mean equivalence of representation.  For example, Int is a subtype of Int?, but the later requires extra space to store in memory.  So while it would make sense to allow, say, [Int] to be a subtype of [Int?], the actual conversion at runtime wouldn’t be trivial — we’d either need to eagerly apply the element-wise transform, or Array would need some ability to apply it lazily.  Both come with fairly serious performance costs.<br></p><p>But the compiler already lets you use a [Derived] as a [Base?], as long as the representation is the same. It&#39;d be nice if that could apply with generics too, even if the limitation was that it would work only as long as there is no difference in representation.<br></p><p>If you want the restriction to depend a little less on low-level representation details, allow it only for class pointers. You won&#39;t have any representation problem there. This is also where people will expect it the most.<br></p><p>-- <br>Michel Fortin<br>michel.fortin at michelf.ca<br>https://michelf.ca<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Covariance and Contravariance</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December  9, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 9, 2015, at 11:50 AM, Michel Fortin &lt;michel.fortin at michelf.ca&gt; wrote:<br>&gt; Le 9 déc. 2015 à 3:04, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt;&gt; One challenge here is that subtyping in Swift doesn’t mean equivalence of representation.  For example, Int is a subtype of Int?, but the later requires extra space to store in memory.  So while it would make sense to allow, say, [Int] to be a subtype of [Int?], the actual conversion at runtime wouldn’t be trivial — we’d either need to eagerly apply the element-wise transform, or Array would need some ability to apply it lazily.  Both come with fairly serious performance costs.<br>&gt; <br>&gt; But the compiler already lets you use a [Derived] as a [Base?], as long as the representation is the same. It&#39;d be nice if that could apply with generics too, even if the limitation was that it would work only as long as there is no difference in representation.<br></p><p>I was using Array as an example of a generic type, but I’d forgotten that we already had the subtyping rule in place as a special case there.<br></p><p>&gt; If you want the restriction to depend a little less on low-level representation details, allow it only for class pointers. You won&#39;t have any representation problem there. This is also where people will expect it the most.<br></p><p>I’d rather we not design a general-purpose language mechanism that’s only actually useful for class pointers, especially given the importance of value types in the language.<br></p><p>John.<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
