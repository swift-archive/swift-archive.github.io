<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[RFC] &quot;Library Evolution Support in Swift (&#39;Resilience&#39;)&quot;</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>February  8, 2016 at 06:00:00pm</p></header><div class="content"><p>Hi, swift-evolution. We&#39;ve been making references for a while to &quot;resilience&quot; as a cornerstone of the Swift 3.0 work, the collection of features that allows a library to evolve over time while maintaining binary compatibility. Among other things, this is necessary if we want to stop bundling the Swift standard library with any app that uses Swift, a noted complaint from iOS developers. :-)<br></p><p>If you&#39;re wondering what this is all about, take a look at the prologue for the design document:<br></p><p>&gt; One of Swift’s primary design goals is to allow efficient execution of code without sacrificing load-time abstraction of implementation.<br>&gt; <br>&gt; Abstraction of implementation means that code correctly written against a published interface will correctly function when the underlying implementation changes to anything which still satisfies the original interface. There are many potential reasons to provide this sort of abstraction. Apple’s primary interest is in making it easy and painless for our internal and external developers to improve the ecosystem of Apple products by creating good and secure programs and libraries; subtle deployment problems and/or unnecessary dependencies on the behavior of our implementations would work against these goals.<br>&gt; <br>&gt; Our current design in Swift is to provide opt-out load-time abstraction of implementation for all language features. Alone, this would either incur unacceptable cost or force widespread opting-out of abstraction. We intend to mitigate this primarily by designing the language and its implementation to minimize unnecessary and unintended abstraction:<br>&gt; <br>&gt; 	• Avoiding unnecessary language guarantees and taking advantage of that flexibility to limit load-time costs.<br>&gt; 	• Within the domain that defines an entity, all the details of its implementation are available.<br>&gt; 	• When entities are not exposed outside their defining module, their implementation is not constrained.<br>&gt; 	• By default, entities are not exposed outside their defining modules. This is independently desirable to reduce accidental API surface area, but happens to also interact well with the performance design.<br>&gt; <br>&gt; This last point is a specific case of a general tenet of Swift: the default behavior is safe. Where possible, choices made when an entity is first published should not limit its evolution in the future.<br></p><p><br>RFC stands for &quot;request for comments&quot;, and that&#39;s what this is: I&#39;d appreciate the eager and discriminating eyes of swift-evolution on this model. It is quite long—nearly ten thousand words—and attempts to be fairly precise in describing what is and isn&#39;t allowed, so feel free to focus on the parts that interest you most. This isn&#39;t a proposal and won&#39;t be going through the Swift Evolution Process, but many existing or planned proposals will affect or support the model described here. (There&#39;s a list of them at the end of the document.)<br></p><p>The document is written in ReStructuredText to match the rest of the compiler documentation, but it&#39;s using some features from the Sphinx system that GitHub&#39;s ReST renderer doesn&#39;t support. Consequently, I&#39;ve put up a rendered form &lt;http://jrose-apple.github.io/swift-library-evolution/&gt;, which I&#39;ll update every few days when there are changes. (This is pretty much the same rendering you get from running &quot;make&quot; in the docs/ directory in the Swift repo.) The canonical document is still the one in the Swift repository &lt;https://github.com/apple/swift/blob/master/docs/LibraryEvolution.rst&gt;.<br></p><p>Looking forward to your feedback!<br>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160208/13bc41e5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[RFC] &quot;Library Evolution Support in Swift (&#39;Resilience&#39;)&quot;</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>February  8, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Feb 8, 2016, at 8:24 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi, swift-evolution. We&#39;ve been making references for a while to &quot;resilience&quot; as a cornerstone of the Swift 3.0 work, the collection of features that allows a library to evolve over time while maintaining binary compatibility. Among other things, this is necessary if we want to stop bundling the Swift standard library with any app that uses Swift, a noted complaint from iOS developers. :-)<br>&gt; <br>&gt; If you&#39;re wondering what this is all about, take a look at the prologue for the design document:<br>&gt; <br>&gt;&gt; One of Swift’s primary design goals is to allow efficient execution of code without sacrificing load-time abstraction of implementation.<br>&gt;&gt; <br>&gt;&gt; Abstraction of implementation means that code correctly written against a published interface will correctly function when the underlying implementation changes to anything which still satisfies the original interface. There are many potential reasons to provide this sort of abstraction. Apple’s primary interest is in making it easy and painless for our internal and external developers to improve the ecosystem of Apple products by creating good and secure programs and libraries; subtle deployment problems and/or unnecessary dependencies on the behavior of our implementations would work against these goals.<br>&gt;&gt; <br>&gt;&gt; Our current design in Swift is to provide opt-out load-time abstraction of implementation for all language features. Alone, this would either incur unacceptable cost or force widespread opting-out of abstraction. We intend to mitigate this primarily by designing the language and its implementation to minimize unnecessary and unintended abstraction:<br>&gt;&gt; <br>&gt;&gt; 	• Avoiding unnecessary language guarantees and taking advantage of that flexibility to limit load-time costs.<br>&gt;&gt; 	• Within the domain that defines an entity, all the details of its implementation are available.<br>&gt;&gt; 	• When entities are not exposed outside their defining module, their implementation is not constrained.<br>&gt;&gt; 	• By default, entities are not exposed outside their defining modules. This is independently desirable to reduce accidental API surface area, but happens to also interact well with the performance design.<br>&gt;&gt; <br>&gt;&gt; This last point is a specific case of a general tenet of Swift: the default behavior is safe. Where possible, choices made when an entity is first published should not limit its evolution in the future.<br>&gt; <br>&gt; RFC stands for &quot;request for comments&quot;, and that&#39;s what this is: I&#39;d appreciate the eager and discriminating eyes of swift-evolution on this model. It is quite long—nearly ten thousand words—and attempts to be fairly precise in describing what is and isn&#39;t allowed, so feel free to focus on the parts that interest you most. This isn&#39;t a proposal and won&#39;t be going through the Swift Evolution Process, but many existing or planned proposals will affect or support the model described here. (There&#39;s a list of them at the end of the document.)<br>&gt; <br>&gt; The document is written in ReStructuredText to match the rest of the compiler documentation, but it&#39;s using some features from the Sphinx system that GitHub&#39;s ReST renderer doesn&#39;t support. Consequently, I&#39;ve put up a rendered form, which I&#39;ll update every few days when there are changes. (This is pretty much the same rendering you get from running &quot;make&quot; in the docs/ directory in the Swift repo.) The canonical document is still the one in the Swift repository.<br>&gt; <br>&gt; Looking forward to your feedback!<br>&gt; Jordan<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>I noticed this note in the document:<br></p><p>&gt; Note<br>&gt; Swift 2’s implementation of default values puts the evaluation of the default value expression in the library, rather than in the client like C++ or C#. We plan to change this.<br></p><p>What is the reasoning behind this? Keeping the default value in the library seems more resilient; if the default value changes, clients will get the new behavior without requiring a recompile, thus matching the behavior that you’d get if you implemented the same thing via a method with fewer arguments (as you’d have done in Objective-C). This seems far preferable to hard-coding all the default values in the client, IMO.<br></p><p>Charles<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[RFC] &quot;Library Evolution Support in Swift (&#39;Resilience&#39;)&quot;</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February  8, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Feb 8, 2016, at 6:47 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Feb 8, 2016, at 8:24 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi, swift-evolution. We&#39;ve been making references for a while to &quot;resilience&quot; as a cornerstone of the Swift 3.0 work, the collection of features that allows a library to evolve over time while maintaining binary compatibility. Among other things, this is necessary if we want to stop bundling the Swift standard library with any app that uses Swift, a noted complaint from iOS developers. :-)<br>&gt;&gt; <br>&gt;&gt; If you&#39;re wondering what this is all about, take a look at the prologue for the design document:<br>&gt;&gt; <br>&gt;&gt;&gt; One of Swift’s primary design goals is to allow efficient execution of code without sacrificing load-time abstraction of implementation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Abstraction of implementation means that code correctly written against a published interface will correctly function when the underlying implementation changes to anything which still satisfies the original interface. There are many potential reasons to provide this sort of abstraction. Apple’s primary interest is in making it easy and painless for our internal and external developers to improve the ecosystem of Apple products by creating good and secure programs and libraries; subtle deployment problems and/or unnecessary dependencies on the behavior of our implementations would work against these goals.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Our current design in Swift is to provide opt-out load-time abstraction of implementation for all language features. Alone, this would either incur unacceptable cost or force widespread opting-out of abstraction. We intend to mitigate this primarily by designing the language and its implementation to minimize unnecessary and unintended abstraction:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	• Avoiding unnecessary language guarantees and taking advantage of that flexibility to limit load-time costs.<br>&gt;&gt;&gt; 	• Within the domain that defines an entity, all the details of its implementation are available.<br>&gt;&gt;&gt; 	• When entities are not exposed outside their defining module, their implementation is not constrained.<br>&gt;&gt;&gt; 	• By default, entities are not exposed outside their defining modules. This is independently desirable to reduce accidental API surface area, but happens to also interact well with the performance design.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This last point is a specific case of a general tenet of Swift: the default behavior is safe. Where possible, choices made when an entity is first published should not limit its evolution in the future.<br>&gt;&gt; <br>&gt;&gt; RFC stands for &quot;request for comments&quot;, and that&#39;s what this is: I&#39;d appreciate the eager and discriminating eyes of swift-evolution on this model. It is quite long—nearly ten thousand words—and attempts to be fairly precise in describing what is and isn&#39;t allowed, so feel free to focus on the parts that interest you most. This isn&#39;t a proposal and won&#39;t be going through the Swift Evolution Process, but many existing or planned proposals will affect or support the model described here. (There&#39;s a list of them at the end of the document.)<br>&gt;&gt; <br>&gt;&gt; The document is written in ReStructuredText to match the rest of the compiler documentation, but it&#39;s using some features from the Sphinx system that GitHub&#39;s ReST renderer doesn&#39;t support. Consequently, I&#39;ve put up a rendered form, which I&#39;ll update every few days when there are changes. (This is pretty much the same rendering you get from running &quot;make&quot; in the docs/ directory in the Swift repo.) The canonical document is still the one in the Swift repository.<br>&gt;&gt; <br>&gt;&gt; Looking forward to your feedback!<br>&gt;&gt; Jordan<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; I noticed this note in the document:<br>&gt; <br>&gt;&gt; Note<br>&gt;&gt; Swift 2’s implementation of default values puts the evaluation of the default value expression in the library, rather than in the client like C++ or C#. We plan to change this.<br>&gt; <br>&gt; What is the reasoning behind this? Keeping the default value in the library seems more resilient; if the default value changes, clients will get the new behavior without requiring a recompile, thus matching the behavior that you’d get if you implemented the same thing via a method with fewer arguments (as you’d have done in Objective-C). This seems far preferable to hard-coding all the default values in the client, IMO.<br></p><p>Abstracting default values from the client limits resilience in other, more obnoxious ways. In particular, it means you can&#39;t *introduce* new defaulted parameters on published APIs without a deployment target limitation, since the entry point for the default argument evaluator will be missing in older versions. We figured that instantiating the default argument on the client side is more in line with users&#39; expectations in what resilience constraints it imposes. In many cases, you&#39;ll have the resilinece you want at a different level; for example, in the common case of an option set where the default is &#39;all options&#39;, evaluating &#39;func foo(options: Options = .all)&#39; is still resilient if &#39;Options.all&#39; is.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[RFC] &quot;Library Evolution Support in Swift (&#39;Resilience&#39;)&quot;</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>February  8, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Feb 8, 2016, at 19:17 , Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 8, 2016, at 6:47 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 8, 2016, at 8:24 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi, swift-evolution. We&#39;ve been making references for a while to &quot;resilience&quot; as a cornerstone of the Swift 3.0 work, the collection of features that allows a library to evolve over time while maintaining binary compatibility. Among other things, this is necessary if we want to stop bundling the Swift standard library with any app that uses Swift, a noted complaint from iOS developers. :-)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you&#39;re wondering what this is all about, take a look at the prologue for the design document:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One of Swift’s primary design goals is to allow efficient execution of code without sacrificing load-time abstraction of implementation.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Abstraction of implementation means that code correctly written against a published interface will correctly function when the underlying implementation changes to anything which still satisfies the original interface. There are many potential reasons to provide this sort of abstraction. Apple’s primary interest is in making it easy and painless for our internal and external developers to improve the ecosystem of Apple products by creating good and secure programs and libraries; subtle deployment problems and/or unnecessary dependencies on the behavior of our implementations would work against these goals.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Our current design in Swift is to provide opt-out load-time abstraction of implementation for all language features. Alone, this would either incur unacceptable cost or force widespread opting-out of abstraction. We intend to mitigate this primarily by designing the language and its implementation to minimize unnecessary and unintended abstraction:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	• Avoiding unnecessary language guarantees and taking advantage of that flexibility to limit load-time costs.<br>&gt;&gt;&gt;&gt; 	• Within the domain that defines an entity, all the details of its implementation are available.<br>&gt;&gt;&gt;&gt; 	• When entities are not exposed outside their defining module, their implementation is not constrained.<br>&gt;&gt;&gt;&gt; 	• By default, entities are not exposed outside their defining modules. This is independently desirable to reduce accidental API surface area, but happens to also interact well with the performance design.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This last point is a specific case of a general tenet of Swift: the default behavior is safe. Where possible, choices made when an entity is first published should not limit its evolution in the future.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; RFC stands for &quot;request for comments&quot;, and that&#39;s what this is: I&#39;d appreciate the eager and discriminating eyes of swift-evolution on this model. It is quite long—nearly ten thousand words—and attempts to be fairly precise in describing what is and isn&#39;t allowed, so feel free to focus on the parts that interest you most. This isn&#39;t a proposal and won&#39;t be going through the Swift Evolution Process, but many existing or planned proposals will affect or support the model described here. (There&#39;s a list of them at the end of the document.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The document is written in ReStructuredText to match the rest of the compiler documentation, but it&#39;s using some features from the Sphinx system that GitHub&#39;s ReST renderer doesn&#39;t support. Consequently, I&#39;ve put up a rendered form, which I&#39;ll update every few days when there are changes. (This is pretty much the same rendering you get from running &quot;make&quot; in the docs/ directory in the Swift repo.) The canonical document is still the one in the Swift repository.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Looking forward to your feedback!<br>&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; I noticed this note in the document:<br>&gt;&gt; <br>&gt;&gt;&gt; Note<br>&gt;&gt;&gt; Swift 2’s implementation of default values puts the evaluation of the default value expression in the library, rather than in the client like C++ or C#. We plan to change this.<br>&gt;&gt; <br>&gt;&gt; What is the reasoning behind this? Keeping the default value in the library seems more resilient; if the default value changes, clients will get the new behavior without requiring a recompile, thus matching the behavior that you’d get if you implemented the same thing via a method with fewer arguments (as you’d have done in Objective-C). This seems far preferable to hard-coding all the default values in the client, IMO.<br>&gt; <br>&gt; Abstracting default values from the client limits resilience in other, more obnoxious ways. In particular, it means you can&#39;t *introduce* new defaulted parameters on published APIs without a deployment target limitation, since the entry point for the default argument evaluator will be missing in older versions. We figured that instantiating the default argument on the client side is more in line with users&#39; expectations in what resilience constraints it imposes. In many cases, you&#39;ll have the resilinece you want at a different level; for example, in the common case of an option set where the default is &#39;all options&#39;, evaluating &#39;func foo(options: Options = .all)&#39; is still resilient if &#39;Options.all&#39; is.<br></p><p>In addition, it&#39;s less resilient than you think it is (and than we thought it would be when we introduced it). The library author still needs to document what the default behavior is anyway, so that users know if they want it, and they need to be very careful in changing existing programs, so that they don&#39;t break anyone who was depending on the old behavior, and they need to make sure that anybody who supplied the same value explicitly really does not want the new behavior.<br></p><p>After all that, it turns out there aren&#39;t really any places where you can safely change the value of a default parameter anyway.<br></p><p>Jordan<br></p><p>P.S. Credit to DaveA for convincing the rest of us. Or me, at least.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160208/0a2e1c43/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[RFC] &quot;Library Evolution Support in Swift (&#39;Resilience&#39;)&quot;</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>February  8, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Feb 8, 2016, at 9:24 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; The library author still needs to document what the default behavior is anyway, so that users know if they want it, and they need to be very careful in changing existing programs, so that they don&#39;t break anyone who was depending on the old behavior<br></p><p>It seems to me that using a default parameter means you don’t care about its value. If you explicitly want a certain value, and especially if you’re *depending* on a certain value, it would be best to supply that value explicitly. Using the default is saying “eh, do whatever you think is best.&quot;<br></p><p>&gt; and they need to make sure that anybody who supplied the same value explicitly really does not want the new behavior.<br></p><p><br>It seems to me that if you explicitly provide a value to a parameter which has a default, it would appear that you want that value. Else, why go to the trouble of explicitly providing it?<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160208/c97b3bf3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[RFC] &quot;Library Evolution Support in Swift (&#39;Resilience&#39;)&quot;</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February  8, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; It seems to me that using a default parameter means you don’t care about its value. If you explicitly want a certain value, and especially if you’re *depending* on a certain value, it would be best to supply that value explicitly. Using the default is saying “eh, do whatever you think is best.&quot;<br></p><p>Sometimes it means you don&#39;t care about the value; sometimes it means that the parameters are rarely used and the defaults are fine for you. For instance, if you&#39;re using the variant of `NSString.compare` with no options, you probably care very much that you&#39;re getting the default &quot;minimal frills&quot; behavior and your search covers the entire string. You would be very surprised and probably rather annoyed if a future OS version made your code compare only the first ten characters case-insensitively.<br></p><p>If a library wants to support &quot;just do what you think is best&quot;, it should explicitly model that, either by having a value like `.Automatic` or `nil` as the default, or by providing a separate method. `NSString`, for example, takes the latter option in `localizedStandardCompare`.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[RFC] &quot;Library Evolution Support in Swift (&#39;Resilience&#39;)&quot;</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>February  9, 2016 at 07:00:00am</p></header><div class="content"><p>Sent from my iPhone<br></p><p>On 9 Feb 2016, at 05:32, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; It seems to me that using a default parameter means you don’t care about its value. If you explicitly want a certain value, and especially if you’re *depending* on a certain value, it would be best to supply that value explicitly. Using the default is saying “eh, do whatever you think is best.&quot;<br>&gt; <br>&gt; Sometimes it means you don&#39;t care about the value; sometimes it means that the parameters are rarely used and the defaults are fine for you. For instance, if you&#39;re using the variant of `NSString.compare` with no options, you probably care very much that you&#39;re getting the default &quot;minimal frills&quot; behavior and your search covers the entire string. You would be very surprised and probably rather annoyed if a future OS version made your code compare only the first ten characters case-insensitively.<br></p><p>Conscious of infuriating lots of non unit testing fanatics, this does make a good case for writing your own unit tests against the API&#39;s you commonly use too ;).<br></p><p>&gt; <br>&gt; If a library wants to support &quot;just do what you think is best&quot;, it should explicitly model that, either by having a value like `.Automatic` or `nil` as the default, or by providing a separate method. `NSString`, for example, takes the latter option in `localizedStandardCompare`.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[RFC] &quot;Library Evolution Support in Swift (&#39;Resilience&#39;)&quot;</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>February 10, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Feb 8, 2016, at 6:24 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; This last point is a specific case of a general tenet of Swift: the default behavior is safe. Where possible, choices made when an entity is first published should not limit its evolution in the future.<br></p><p><br>Regarding this:<br></p><p>&gt; Changing or removing a default value is permitted but discouraged; it may break or change the meaning of existing source code.<br></p><p><br>Maybe I&#39;m being dense, but how is something with a caveat of &quot;discouraged&quot; and &quot;it may break or change&quot; in-line with &quot;the default behavior is safe&quot;? I&#39;ve got no qualms with putting the default value in the client code; I actually think that is fine.<br></p><p>However, my concern is that you will have different behavior depending on if you simply drop in the updated binary vs recompile against the binary. Even worse if you have multiple components within your app that link against the library. If only one of those components is recompiled on release, you now have a problem of conflicting behavior within your own app because of the client-side calling the API will be using different values.<br></p><p>It would seem that removing the default value could be permitted (though maybe still discouraged) because this will result in a compiler error in the scenario above. It&#39;s still possible to have different behavior in your components, but now it&#39;s no longer implicitly happening. However, changing the default parameter seems highly problematic.<br></p><p>-David<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160210/780346c4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[RFC] &quot;Library Evolution Support in Swift (&#39;Resilience&#39;)&quot;</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>February 10, 2016 at 01:00:00pm</p></header><div class="content"><p>Actually, there are quite a few places that allow for the same type of behavior: @inlineable, accessors, enums, structs, etc...<br></p><p>As soon as I see these words: &quot;existing clients may use the new implementations, or they may use the implementations from the time they were compiled, or a mix of both&quot; or similar, we&#39;ve ventured right back into undefined territory. <br></p><p>That concerns me.<br></p><p>-David<br></p><p>&gt; On Feb 10, 2016, at 12:45 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 8, 2016, at 6:24 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; This last point is a specific case of a general tenet of Swift: the default behavior is safe. Where possible, choices made when an entity is first published should not limit its evolution in the future.<br>&gt; <br>&gt; <br>&gt; Regarding this:<br>&gt; <br>&gt;&gt; Changing or removing a default value is permitted but discouraged; it may break or change the meaning of existing source code.<br>&gt; <br>&gt; <br>&gt; Maybe I&#39;m being dense, but how is something with a caveat of &quot;discouraged&quot; and &quot;it may break or change&quot; in-line with &quot;the default behavior is safe&quot;? I&#39;ve got no qualms with putting the default value in the client code; I actually think that is fine.<br>&gt; <br>&gt; However, my concern is that you will have different behavior depending on if you simply drop in the updated binary vs recompile against the binary. Even worse if you have multiple components within your app that link against the library. If only one of those components is recompiled on release, you now have a problem of conflicting behavior within your own app because of the client-side calling the API will be using different values.<br>&gt; <br>&gt; It would seem that removing the default value could be permitted (though maybe still discouraged) because this will result in a compiler error in the scenario above. It&#39;s still possible to have different behavior in your components, but now it&#39;s no longer implicitly happening. However, changing the default parameter seems highly problematic.<br>&gt; <br>&gt; -David<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160210/3b626f00/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[RFC] &quot;Library Evolution Support in Swift (&#39;Resilience&#39;)&quot;</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 10, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Feb 10, 2016, at 1:00 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Actually, there are quite a few places that allow for the same type of behavior: @inlineable, accessors, enums, structs, etc...<br></p><p>Of these, inlineable functions definitely have the same problem, but I&#39;m not sure what you&#39;re referring to with regard to accessors, enums, or structs. These will all be accessed by opaque interfaces (unless declared fixed-contents), so clients are guaranteed to use the framework implementation.<br></p><p>-Joe<br></p><p>&gt; <br>&gt; As soon as I see these words: &quot;existing clients may use the new implementations, or they may use the implementations from the time they were compiled, or a mix of both&quot; or similar, we&#39;ve ventured right back into undefined territory. <br>&gt; <br>&gt; That concerns me.<br>&gt; <br>&gt; -David<br>&gt; <br>&gt;&gt; On Feb 10, 2016, at 12:45 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 8, 2016, at 6:24 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This last point is a specific case of a general tenet of Swift: the default behavior is safe. Where possible, choices made when an entity is first published should not limit its evolution in the future.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Regarding this:<br>&gt;&gt; <br>&gt;&gt;&gt; Changing or removing a default value is permitted but discouraged; it may break or change the meaning of existing source code.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Maybe I&#39;m being dense, but how is something with a caveat of &quot;discouraged&quot; and &quot;it may break or change&quot; in-line with &quot;the default behavior is safe&quot;? I&#39;ve got no qualms with putting the default value in the client code; I actually think that is fine.<br>&gt;&gt; <br>&gt;&gt; However, my concern is that you will have different behavior depending on if you simply drop in the updated binary vs recompile against the binary. Even worse if you have multiple components within your app that link against the library. If only one of those components is recompiled on release, you now have a problem of conflicting behavior within your own app because of the client-side calling the API will be using different values.<br>&gt;&gt; <br>&gt;&gt; It would seem that removing the default value could be permitted (though maybe still discouraged) because this will result in a compiler error in the scenario above. It&#39;s still possible to have different behavior in your components, but now it&#39;s no longer implicitly happening. However, changing the default parameter seems highly problematic.<br>&gt;&gt; <br>&gt;&gt; -David<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160210/4c050d50/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[RFC] &quot;Library Evolution Support in Swift (&#39;Resilience&#39;)&quot;</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>February 10, 2016 at 01:00:00pm</p></header><div class="content"><p>I do object to the word &quot;undefined&quot;, which in the C family of languages means &quot;the compiler can do anything it wants&quot;. In this case you will definitely get behavior equivalent to the old code, or equivalent to the new code, and the section on optimizing inlineable functions makes it clear that the inlineable code must not make assumptions about what library it&#39;s deployed against. Again, memory and type safety are preserved, while under &quot;undefined behavior&quot; in a C language they definitely would not be.<br></p><p>Jordan<br></p><p>&gt; On Feb 10, 2016, at 13:00, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt; <br>&gt; Actually, there are quite a few places that allow for the same type of behavior: @inlineable, accessors, enums, structs, etc...<br>&gt; <br>&gt; As soon as I see these words: &quot;existing clients may use the new implementations, or they may use the implementations from the time they were compiled, or a mix of both&quot; or similar, we&#39;ve ventured right back into undefined territory. <br>&gt; <br>&gt; That concerns me.<br>&gt; <br>&gt; -David<br>&gt; <br>&gt;&gt; On Feb 10, 2016, at 12:45 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 8, 2016, at 6:24 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This last point is a specific case of a general tenet of Swift: the default behavior is safe. Where possible, choices made when an entity is first published should not limit its evolution in the future.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Regarding this:<br>&gt;&gt; <br>&gt;&gt;&gt; Changing or removing a default value is permitted but discouraged; it may break or change the meaning of existing source code.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Maybe I&#39;m being dense, but how is something with a caveat of &quot;discouraged&quot; and &quot;it may break or change&quot; in-line with &quot;the default behavior is safe&quot;? I&#39;ve got no qualms with putting the default value in the client code; I actually think that is fine.<br>&gt;&gt; <br>&gt;&gt; However, my concern is that you will have different behavior depending on if you simply drop in the updated binary vs recompile against the binary. Even worse if you have multiple components within your app that link against the library. If only one of those components is recompiled on release, you now have a problem of conflicting behavior within your own app because of the client-side calling the API will be using different values.<br>&gt;&gt; <br>&gt;&gt; It would seem that removing the default value could be permitted (though maybe still discouraged) because this will result in a compiler error in the scenario above. It&#39;s still possible to have different behavior in your components, but now it&#39;s no longer implicitly happening. However, changing the default parameter seems highly problematic.<br>&gt;&gt; <br>&gt;&gt; -David<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160210/9b706af0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[RFC] &quot;Library Evolution Support in Swift (&#39;Resilience&#39;)&quot;</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>February 10, 2016 at 01:00:00pm</p></header><div class="content"><p>OK, I can be more correct: nondeterministic behavior. At least it will be consistent in the path that happens. =)<br></p><p><br>&gt; On Feb 10, 2016, at 1:07 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; I do object to the word &quot;undefined&quot;, which in the C family of languages means &quot;the compiler can do anything it wants&quot;. In this case you will definitely get behavior equivalent to the old code, or equivalent to the new code, and the section on optimizing inlineable functions makes it clear that the inlineable code must not make assumptions about what library it&#39;s deployed against. Again, memory and type safety are preserved, while under &quot;undefined behavior&quot; in a C language they definitely would not be.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt;&gt; On Feb 10, 2016, at 13:00, David Owens II &lt;david at owensd.io &lt;mailto:david at owensd.io&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Actually, there are quite a few places that allow for the same type of behavior: @inlineable, accessors, enums, structs, etc...<br>&gt;&gt; <br>&gt;&gt; As soon as I see these words: &quot;existing clients may use the new implementations, or they may use the implementations from the time they were compiled, or a mix of both&quot; or similar, we&#39;ve ventured right back into undefined territory. <br>&gt;&gt; <br>&gt;&gt; That concerns me.<br>&gt;&gt; <br>&gt;&gt; -David<br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 10, 2016, at 12:45 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 8, 2016, at 6:24 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This last point is a specific case of a general tenet of Swift: the default behavior is safe. Where possible, choices made when an entity is first published should not limit its evolution in the future.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Regarding this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Changing or removing a default value is permitted but discouraged; it may break or change the meaning of existing source code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Maybe I&#39;m being dense, but how is something with a caveat of &quot;discouraged&quot; and &quot;it may break or change&quot; in-line with &quot;the default behavior is safe&quot;? I&#39;ve got no qualms with putting the default value in the client code; I actually think that is fine.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However, my concern is that you will have different behavior depending on if you simply drop in the updated binary vs recompile against the binary. Even worse if you have multiple components within your app that link against the library. If only one of those components is recompiled on release, you now have a problem of conflicting behavior within your own app because of the client-side calling the API will be using different values.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It would seem that removing the default value could be permitted (though maybe still discouraged) because this will result in a compiler error in the scenario above. It&#39;s still possible to have different behavior in your components, but now it&#39;s no longer implicitly happening. However, changing the default parameter seems highly problematic.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -David<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160210/96e7e465/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[RFC] &quot;Library Evolution Support in Swift (&#39;Resilience&#39;)&quot;</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>February 10, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Feb 10, 2016, at 12:45, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 8, 2016, at 6:24 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; This last point is a specific case of a general tenet of Swift: the default behavior is safe. Where possible, choices made when an entity is first published should not limit its evolution in the future.<br>&gt; <br>&gt; <br>&gt; Regarding this:<br>&gt; <br>&gt;&gt; Changing or removing a default value is permitted but discouraged; it may break or change the meaning of existing source code.<br>&gt; <br>&gt; <br>&gt; Maybe I&#39;m being dense, but how is something with a caveat of &quot;discouraged&quot; and &quot;it may break or change&quot; in-line with &quot;the default behavior is safe&quot;? I&#39;ve got no qualms with putting the default value in the client code; I actually think that is fine.<br>&gt; <br>&gt; However, my concern is that you will have different behavior depending on if you simply drop in the updated binary vs recompile against the binary. Even worse if you have multiple components within your app that link against the library. If only one of those components is recompiled on release, you now have a problem of conflicting behavior within your own app because of the client-side calling the API will be using different values.<br>&gt; <br>&gt; It would seem that removing the default value could be permitted (though maybe still discouraged) because this will result in a compiler error in the scenario above. It&#39;s still possible to have different behavior in your components, but now it&#39;s no longer implicitly happening. However, changing the default parameter seems highly problematic.<br></p><p>This is a good point, and I think the &quot;checker&quot; tool described at the end of the document should warn about these kinds of changes as well. I was trying to distinguish between &quot;changing this affects the ABI of your library and therefore breaks memory and type safety&quot; and &quot;changing this merely affects the behavior of your library but will not break memory and type safety&quot;, but maybe that&#39;s not such an important distinction.<br></p><p>It&#39;s important to note that &quot;it may break or change the meaning of existing source code&quot; is something that applies to any behavior change you make in a library; if version 2.0 of an opaque function &#39;foo&#39; accesses global memory where it didn&#39;t before, existing clients may run into concurrency issues if they assumed the function was concurrency-safe. The specific twist for inlineable code (including default argument expressions) is that the change is triggered by recompiling the client, which is why any changes to inlineable code (including default argument expressions) should really preserve the existing contract of the API.<br></p><p>I actually considered leaving out the section about changing a default parameter, but that&#39;s no different from removing a default parameter and then immediately doing a second release with a new parameter added back. Calling it out explicitly is intended to serve as a warning more than an endorsement.<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160210/55abf324/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[RFC] &quot;Library Evolution Support in Swift (&#39;Resilience&#39;)&quot;</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>February 10, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Feb 10, 2016, at 1:03 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 10, 2016, at 12:45, David Owens II &lt;david at owensd.io &lt;mailto:david at owensd.io&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 8, 2016, at 6:24 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This last point is a specific case of a general tenet of Swift: the default behavior is safe. Where possible, choices made when an entity is first published should not limit its evolution in the future.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Regarding this:<br>&gt;&gt; <br>&gt;&gt;&gt; Changing or removing a default value is permitted but discouraged; it may break or change the meaning of existing source code.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Maybe I&#39;m being dense, but how is something with a caveat of &quot;discouraged&quot; and &quot;it may break or change&quot; in-line with &quot;the default behavior is safe&quot;? I&#39;ve got no qualms with putting the default value in the client code; I actually think that is fine.<br>&gt;&gt; <br>&gt;&gt; However, my concern is that you will have different behavior depending on if you simply drop in the updated binary vs recompile against the binary. Even worse if you have multiple components within your app that link against the library. If only one of those components is recompiled on release, you now have a problem of conflicting behavior within your own app because of the client-side calling the API will be using different values.<br>&gt;&gt; <br>&gt;&gt; It would seem that removing the default value could be permitted (though maybe still discouraged) because this will result in a compiler error in the scenario above. It&#39;s still possible to have different behavior in your components, but now it&#39;s no longer implicitly happening. However, changing the default parameter seems highly problematic.<br>&gt; <br>&gt; This is a good point, and I think the &quot;checker&quot; tool described at the end of the document should warn about these kinds of changes as well. I was trying to distinguish between &quot;changing this affects the ABI of your library and therefore breaks memory and type safety&quot; and &quot;changing this merely affects the behavior of your library but will not break memory and type safety&quot;, but maybe that&#39;s not such an important distinction.<br></p><p>I think the stated desire to use semantic versioning moves the conversation from strictly ABI and satisfying the compiler to the realm of attempting to create behavioral contracts. So when I see things that will have an impact on behavior too, I get a little concerned.<br></p><p>&gt; It&#39;s important to note that &quot;it may break or change the meaning of existing source code&quot; is something that applies to any behavior change you make in a library; if version 2.0 of an opaque function &#39;foo&#39; accesses global memory where it didn&#39;t before, existing clients may run into concurrency issues if they assumed the function was concurrency-safe. The specific twist for inlineable code (including default argument expressions) is that the change is triggered by recompiling the client, which is why any changes to inlineable code (including default argument expressions) should really preserve the existing contract of the API.<br></p><p>I agree. Any change to source is a potential breaking change even if the ABI is kept in-tact. This is one of the primary arguments against semantic versioning in the first place in that it&#39;s a contract that cannot actually be adhered to.<br></p><p>I think the document would be stronger if it simply stated up-front that you are *only* addressing the ABI compatibility (maybe it does but the semantic version carries a ton of baggage that counters that position). This allows you to have potential behavior breaking changes while not confusing the fact.<br></p><p>It would still be nice to be at least warned on changes that could have a compile-time vs. link-time difference.<br></p><p>-David<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160210/aec39f60/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>[RFC] &quot;Library Evolution Support in Swift (&#39;Resilience&#39;)&quot;</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>February 10, 2016 at 06:00:00pm</p></header><div class="content"><p>This is an amazing document.  I do not understand half of it, but the half I do understand will set software engineering forward ten years.<br></p><p>It will take me a long time to digest all of it, but 2 quick things:<br></p><p>&gt; It is legal to change the implementation of an inlineable function in the next release of the library. However, any such change must be made with the understanding that it may or may not affect existing clients.<br></p><p>I think this is wrong.  Specifically, let&#39;s say I have a security bug in my inlineable function.  *Currently*, the industry practice for responding to security issues is &quot;download the new version of the library&quot;.  But for inlined functions, this is not good enough to correctly apply the patch.<br></p><p>In my view, &quot;somebody&quot; (the linker, the loader, the runtime... it&#39;s all greek to me) should say &quot;hold on a minute, you cannot use the new library version, recompile your code&quot;.  Because as long as it appears the new library version installs/works fine, the security fix is falsely assumed to be applied.<br></p><p>Another thing I think we are missing here is versioning the function bodies themselves.  For example (ignore syntax) suppose we have<br></p><p>            <br>public (1.0) func removeTheCacheFiles() {<br>      os.rmdir(&quot;/path/to/cache&quot;)<br>}<br></p><p>We may evolve this function in two orthogonal ways:<br></p><p>We may develop other cache files as our program grows<br>We may discover that we forgot to check if the user is allowed by the security policy to remove the cache files.<br></p><p>Therefore we may evolve this function as follows (again, I use pretend syntax):<br></p><p>public (1.0) func removeTheCacheFiles() {<br>      precondition(userIsAuthorized()) //this change is backported to 1.0<br>      os.rmdir(&quot;/path/to/cache&quot;)<br>      #if 1.1 { //this code only for 1.1-era callers<br>        os.rmdir(&quot;/path/to/cache2&quot;)<br>      }<br>}<br></p><p>It is important to support this case because very often in server land, certain clients only want to pick up the security fixes (and not, say, new features).  See e.g. this Debian Security FAQ &lt;https://www.debian.org/security/faq#oldversion&gt;, where people spend a huge amount of time backporting security fixes to old versions.<br></p><p>I realize this is not at all the practice in &quot;consumer-grade&quot; applications like iOS/OSX/etc., but it is very entrenched in serverland, and I really think there is value in supporting this at the language level for those people who work in that world.<br></p><p>I think the implementation of this is just to compile all possibilities and just let the client pick the implementation based on the API version.  I realize this may result in larger binaries, but only when the feature is used, so it&#39;s opt-in.<br></p><p>Apologies for not using fancy compiler words, I am still trying to grasp the full implications of this amazing paper.<br></p><p>&gt; On Feb 8, 2016, at 8:24 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi, swift-evolution. We&#39;ve been making references for a while to &quot;resilience&quot; as a cornerstone of the Swift 3.0 work, the collection of features that allows a library to evolve over time while maintaining binary compatibility. Among other things, this is necessary if we want to stop bundling the Swift standard library with any app that uses Swift, a noted complaint from iOS developers. :-)<br>&gt; <br>&gt; If you&#39;re wondering what this is all about, take a look at the prologue for the design document:<br>&gt; <br>&gt;&gt; One of Swift’s primary design goals is to allow efficient execution of code without sacrificing load-time abstraction of implementation.<br>&gt;&gt; <br>&gt;&gt; Abstraction of implementation means that code correctly written against a published interface will correctly function when the underlying implementation changes to anything which still satisfies the original interface. There are many potential reasons to provide this sort of abstraction. Apple’s primary interest is in making it easy and painless for our internal and external developers to improve the ecosystem of Apple products by creating good and secure programs and libraries; subtle deployment problems and/or unnecessary dependencies on the behavior of our implementations would work against these goals.<br>&gt;&gt; <br>&gt;&gt; Our current design in Swift is to provide opt-out load-time abstraction of implementation for all language features. Alone, this would either incur unacceptable cost or force widespread opting-out of abstraction. We intend to mitigate this primarily by designing the language and its implementation to minimize unnecessary and unintended abstraction:<br>&gt;&gt; <br>&gt;&gt; 	• Avoiding unnecessary language guarantees and taking advantage of that flexibility to limit load-time costs.<br>&gt;&gt; 	• Within the domain that defines an entity, all the details of its implementation are available.<br>&gt;&gt; 	• When entities are not exposed outside their defining module, their implementation is not constrained.<br>&gt;&gt; 	• By default, entities are not exposed outside their defining modules. This is independently desirable to reduce accidental API surface area, but happens to also interact well with the performance design.<br>&gt;&gt; <br>&gt;&gt; This last point is a specific case of a general tenet of Swift: the default behavior is safe. Where possible, choices made when an entity is first published should not limit its evolution in the future.<br>&gt; <br>&gt; <br>&gt; RFC stands for &quot;request for comments&quot;, and that&#39;s what this is: I&#39;d appreciate the eager and discriminating eyes of swift-evolution on this model. It is quite long—nearly ten thousand words—and attempts to be fairly precise in describing what is and isn&#39;t allowed, so feel free to focus on the parts that interest you most. This isn&#39;t a proposal and won&#39;t be going through the Swift Evolution Process, but many existing or planned proposals will affect or support the model described here. (There&#39;s a list of them at the end of the document.)<br>&gt; <br>&gt; The document is written in ReStructuredText to match the rest of the compiler documentation, but it&#39;s using some features from the Sphinx system that GitHub&#39;s ReST renderer doesn&#39;t support. Consequently, I&#39;ve put up a rendered form &lt;http://jrose-apple.github.io/swift-library-evolution/&gt;, which I&#39;ll update every few days when there are changes. (This is pretty much the same rendering you get from running &quot;make&quot; in the docs/ directory in the Swift repo.) The canonical document is still the one in the Swift repository &lt;https://github.com/apple/swift/blob/master/docs/LibraryEvolution.rst&gt;.<br>&gt; <br>&gt; Looking forward to your feedback!<br>&gt; Jordan<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160210/298d5cda/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[RFC] &quot;Library Evolution Support in Swift (&#39;Resilience&#39;)&quot;</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 10, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt;&gt; It is legal to change the implementation of an inlineable function in the next release of the library. However, any such change must be made with the understanding that it may or may not affect existing clients.<br>&gt; <br>&gt; I think this is wrong.<br></p><p>I don&#39;t think there&#39;s a reasonable alternative. Breaking someone&#39;s entire app because a library changed is not acceptable unless you *know* there&#39;s a problem, and checking if some specific piece of inlined code has been replaced so you can fall back to a non-inlined call is likely to be more costly than just emitting a non-inlined call would be.<br></p><p>I think the solution is that you shouldn&#39;t mark security-critical code as being eligible for inlining. Anything else is just not going to be workable.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>[RFC] &quot;Library Evolution Support in Swift (&#39;Resilience&#39;)&quot;</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>February 10, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; I think the solution is that you shouldn&#39;t mark security-critical code as being eligible for inlining. Anything else is just not going to be workable.<br></p><p>There is no such thing as &quot;I solemnly swear this function doesn&#39;t have a security bug, and if it does, we&#39;ll never patch it.&quot;<br></p><p>If we have to choose between security and inlining, let&#39;s not allow inlining across versioned APIs.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[RFC] &quot;Library Evolution Support in Swift (&#39;Resilience&#39;)&quot;</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 10, 2016 at 07:00:00pm</p></header><div class="content"><p>I don&#39;t think there&#39;s a silver bullet here. Even if the implementation is inside the binary, you&#39;ll still have clients with vendored or statically linked copies of old versions of your library embedded in their distributions. Clients always have to share in the responsibility for maintaining their security.<br></p><p>-Joe<br></p><p>&gt; On Feb 10, 2016, at 6:08 PM, Drew Crawford via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; I think the solution is that you shouldn&#39;t mark security-critical code as being eligible for inlining. Anything else is just not going to be workable.<br>&gt; <br>&gt; There is no such thing as &quot;I solemnly swear this function doesn&#39;t have a security bug, and if it does, we&#39;ll never patch it.&quot;<br>&gt; <br>&gt; If we have to choose between security and inlining, let&#39;s not allow inlining across versioned APIs.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>[RFC] &quot;Library Evolution Support in Swift (&#39;Resilience&#39;)&quot;</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>February 11, 2016 at 12:00:00am</p></header><div class="content"><p>When someone vendors or statically links a library, they know what they are getting into.  I mean, sometimes people do silly things, but they should know.<br></p><p>Whereas &quot;inlining across dynamically linked libraries&quot; is a novel Swiftism (Or it may be a Rustism as well but in any case) nobody expects it. They will assume that replacing the dynamic library actually replaces the dynamic library&#39;s code, because that is the social contract for dynamic linkage.<br></p><p>More broadly, I see inlining dynamic libraries as a &quot;nice to have&quot;, but dynamic linkage that actually works as &quot;critical&quot;.  This proposal inverts that value system, telling me that I will get inlined performance, and I might get a correctly linked program.  That seems backwards.<br></p><p>Or stated another way: if I can&#39;t relink my program afterwards, why am I using dynamic linkage?  I should statically link everything.<br></p><p>Let me advance an independent argument why I think this is the wrong behavior: LGPL compliance.  Eliding LGPLv3 §4)d)1:<br></p><p>&gt; You may convey a Combined Work... if you... Use a suitable shared library mechanism for linking with the Library. A suitable mechanism is one that (a) uses at run time a copy of the Library already present on the user&#39;s computer system, and (b) will operate properly with a modified version of the Library that is interface-compatible with the Linked Version.<br></p><p><br>and §4)e:<br></p><p>&gt; Provide Installation Information... to the extent that such information is necessary to install and execute a modified version of the Combined Work produced by recombining or relinking the Application with a modified version of the Linked Version. <br></p><p><br>I suspect that linking an LGPLed library under this proposals&#39; semantics may be a lawsuit foot-gun.<br></p><p>...inb4 &quot;don&#39;t use the LGPL&quot;, but I think this (and the security problem) generalize to a very broad class of issues.  Dynamic linkage has a certain &quot;social contract&quot; since time immemorial.  Breaking this contract has consequences that I am not sure we have thought through entirely.<br></p><p><br>&gt; On Feb 10, 2016, at 9:46 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; I don&#39;t think there&#39;s a silver bullet here. Even if the implementation is inside the binary, you&#39;ll still have clients with vendored or statically linked copies of old versions of your library embedded in their distributions. Clients always have to share in the responsibility for maintaining their security.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; On Feb 10, 2016, at 6:08 PM, Drew Crawford via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; I think the solution is that you shouldn&#39;t mark security-critical code as being eligible for inlining. Anything else is just not going to be workable.<br>&gt;&gt; <br>&gt;&gt; There is no such thing as &quot;I solemnly swear this function doesn&#39;t have a security bug, and if it does, we&#39;ll never patch it.&quot;<br>&gt;&gt; <br>&gt;&gt; If we have to choose between security and inlining, let&#39;s not allow inlining across versioned APIs.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/1ee55c10/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>[RFC] &quot;Library Evolution Support in Swift (&#39;Resilience&#39;)&quot;</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>February 10, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Feb 10, 2016, at 10:49 PM, Drew Crawford via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; When someone vendors or statically links a library, they know what they are getting into.  I mean, sometimes people do silly things, but they should know.<br>&gt; <br>&gt; Whereas &quot;inlining across dynamically linked libraries&quot; is a novel Swiftism (Or it may be a Rustism as well but in any case) nobody expects it. They will assume that replacing the dynamic library actually replaces the dynamic library&#39;s code, because that is the social contract for dynamic linkage.<br></p><p>C and C++ do it too, of course: pretty much anything you put in a C or C++ header file is fair game for inlining. The implementations of dispatch_once() and NSMakeRect() are two examples off the top of my head. Nothing you do to libdispatch.dylib or Foundation.framework will affect a previously-compiled caller of those functions. <br></p><p>Yes, @inlineable must be applied with care. The capability is too useful - especially for systems-level programming - to go without it.<br></p><p><br>-- <br>Greg Parker     gparker at apple.com     Runtime Wrangler<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160210/fa53eefa/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[RFC] &quot;Library Evolution Support in Swift (&#39;Resilience&#39;)&quot;</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>February 11, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Feb 10, 2016, at 11:04 PM, Greg Parker via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 10, 2016, at 10:49 PM, Drew Crawford via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; When someone vendors or statically links a library, they know what they are getting into.  I mean, sometimes people do silly things, but they should know.<br>&gt;&gt; <br>&gt;&gt; Whereas &quot;inlining across dynamically linked libraries&quot; is a novel Swiftism (Or it may be a Rustism as well but in any case) nobody expects it. They will assume that replacing the dynamic library actually replaces the dynamic library&#39;s code, because that is the social contract for dynamic linkage.<br>&gt; <br>&gt; C and C++ do it too, of course: pretty much anything you put in a C or C++ header file is fair game for inlining. The implementations of dispatch_once() and NSMakeRect() are two examples off the top of my head. Nothing you do to libdispatch.dylib or Foundation.framework will affect a previously-compiled caller of those functions. <br>&gt; <br>&gt; Yes, @inlineable must be applied with care. The capability is too useful - especially for systems-level programming - to go without it.<br></p><p>I don&#39;t think anyone is arguing that @inlineable shouldn&#39;t be available, but we are already heading down the path of &quot;some features&quot; are more important than resilience, so we&#39;ll allow it. That seems to be defeat purpose of resiliency in the first place.<br></p><p>I personally think it&#39;s a very fair trade-off to disallow @inlineable code to be inlined from a dynamic dll by default. Now, that doesn&#39;t mean that the developer couldn&#39;t add a link flag `--super-nonresilient-i-know-what-im-doing` when pulling in certain DLLs. That&#39;s an explicit statement that the developer is choosing to break resilience. The important part is that it&#39;s the developer consuming the DLL making the choice vs. the developer of the DLL making that choice for everyone.<br></p><p>Further, this can now be a runtime warning/error when loading a version of the DLL that is not the same one that was linked against originally. Another option is to hash the inlined function and if those hashes don&#39;t match error.<br></p><p>-David<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/e9ea3ac0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>[RFC] &quot;Library Evolution Support in Swift (&#39;Resilience&#39;)&quot;</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>February 11, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Feb 11, 2016, at 11:53 AM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt; <br>&gt; I personally think it&#39;s a very fair trade-off to disallow @inlineable code to be inlined from a dynamic dll by default. Now, that doesn&#39;t mean that the developer couldn&#39;t add a link flag `--super-nonresilient-i-know-what-im-doing` when pulling in certain DLLs. That&#39;s an explicit statement that the developer is choosing to break resilience. The important part is that it&#39;s the developer consuming the DLL making the choice vs. the developer of the DLL making that choice for everyone.<br></p><p>+2<br></p><p>IMO disabling inlining of DLLs should clearly be the default, and there should be some &quot;I know what I&#39;m doing&quot; flag for folks who are willing to take on the burden of vendoring their library as if it were static.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/809dc100/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[RFC] &quot;Library Evolution Support in Swift (&#39;Resilience&#39;)&quot;</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>February 11, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Feb 11, 2016, at 13:54, Drew Crawford via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 11, 2016, at 11:53 AM, David Owens II &lt;david at owensd.io &lt;mailto:david at owensd.io&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I personally think it&#39;s a very fair trade-off to disallow @inlineable code to be inlined from a dynamic dll by default. Now, that doesn&#39;t mean that the developer couldn&#39;t add a link flag `--super-nonresilient-i-know-what-im-doing` when pulling in certain DLLs. That&#39;s an explicit statement that the developer is choosing to break resilience. The important part is that it&#39;s the developer consuming the DLL making the choice vs. the developer of the DLL making that choice for everyone.<br>&gt; <br>&gt; +2<br>&gt; <br>&gt; IMO disabling inlining of DLLs should clearly be the default, and there should be some &quot;I know what I&#39;m doing&quot; flag for folks who are willing to take on the burden of vendoring their library as if it were static.<br></p><p><br>You&#39;re using inlineable code today in Cocoa: dispatch_once&#39;s fast-path, the geometry functions from CoreGraphics to SceneKit, and every NS_OPTIONS enum that has an &quot;all&quot; case. It is a performance vs. flexibility tradeoff, but an incredibly important one. In Swift we definitely don&#39;t want to sacrifice flexibility by default, but it has to be an option if we want Swift to be a viable replacement for things traditionally done with C or C++. &quot;Inlining across dynamic libraries&quot; has been around for decades with C, C++, and C#.<br></p><p>I&#39;m skeptical that anyone will actually use your hypothetical &quot;use this library without treating anything as fragile, even if I could&quot; setting; most clients just want as much performance as they can get. But it would be implementable.<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/c81a2b35/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>[RFC] &quot;Library Evolution Support in Swift (&#39;Resilience&#39;)&quot;</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>February 11, 2016 at 04:00:00pm</p></header><div class="content"><p>When I generate a Swift interface, does the @inlineable attribute appear for the function?<br></p><p>If so, I think you&#39;ve all made good arguments here.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[RFC] &quot;Library Evolution Support in Swift (&#39;Resilience&#39;)&quot;</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>February 11, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Feb 11, 2016, at 14:54, Drew Crawford &lt;drew at sealedabstract.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; When I generate a Swift interface, does the @inlineable attribute appear for the function?<br></p><p>If it does, what are you going to do about it? Are you going to try to make a distinction on a per-function basis whether or not it&#39;s safe to inline it?<br></p><p>I can understand a client wanting to say wholesale not to use any inlineable code from library X, but if you care about being able to update inlineable parts of the library I don&#39;t think I trust any client to decide which parts of the library are &quot;safe, probably&quot;.<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/f2e240d2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>[RFC] &quot;Library Evolution Support in Swift (&#39;Resilience&#39;)&quot;</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>February 11, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Feb 11, 2016, at 6:26 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; If it does, what are you going to do about it? Are you going to try to make a distinction on a per-function basis whether or not it&#39;s safe to inline it?<br></p><p><br>Backing up, the argument was advanced that inlining is fine because it&#39;s equivalent to C/C++.  C/C++ has a way to determine with certainty if a function will be inlined (e.g. appears in the header) so either we are equivalent to C/C++ and we can also determine with certainty or we are not.  If we are not, then arguments of the form &quot;C/C++ does it&quot; when actually it has a similar but subtly different feature begin to lose ground.<br></p><p>But to answer the question about &quot;what I would do about it&quot;, I might not call the function, if I knew it to be inlined.  Another thing I have done in C/C++ is vendor the inline function, and implement it slightly more optimally based on things I know at the callsite, so that is a special case of not calling it.<br></p><p>&gt; I don&#39;t think I trust any client to decide which parts of the library are &quot;safe, probably&quot;<br></p><p><br>Similarly, I don&#39;t trust library authors to decide which parts of their libraries are safe for me to inline in my client.<br></p><p>I think this may be a difference in perspective, e.g. if one works at Apple then one may receive many bug reports of the form &quot;silly app developer, don&#39;t use UIKit this way&quot; leading to a general mistrust of clients.  Meanwhile, if one has hundreds of filed radars still open (ಠ_ಠ) one might develop a general mistrust of library authors.<br></p><p>To me it seems that this trust problem could be resolved were inlining to be an opt-in feature for each party.  The library author should opt-in at the function level, and the client should opt in at least at the library level, and I would prefer at the callsite.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/d6736d2b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[RFC] &quot;Library Evolution Support in Swift (&#39;Resilience&#39;)&quot;</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>February 11, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Feb 11, 2016, at 16:56, Drew Crawford &lt;drew at sealedabstract.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 11, 2016, at 6:26 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; If it does, what are you going to do about it? Are you going to try to make a distinction on a per-function basis whether or not it&#39;s safe to inline it?<br>&gt; <br>&gt; <br>&gt; Backing up, the argument was advanced that inlining is fine because it&#39;s equivalent to C/C++.  C/C++ has a way to determine with certainty if a function will be inlined (e.g. appears in the header) so either we are equivalent to C/C++ and we can also determine with certainty or we are not.  If we are not, then arguments of the form &quot;C/C++ does it&quot; when actually it has a similar but subtly different feature begin to lose ground.<br></p><p>That&#39;s true, but it still doesn&#39;t mean all clients will use the same implementation. If different client libraries are compiled against different versions of a base library, they will each inline the version they were compiled with, and of course the base library itself will use the version it was compiled with. Knowing for sure that your client is inlining isn&#39;t extra information over knowing it may inline.<br></p><p>(Technically, a C function marked &#39;inline&#39; and not &#39;static&#39; isn&#39;t guaranteed to be inlined either, but in practice nobody does that because the rules are awful.)<br></p><p><br>&gt; <br>&gt; But to answer the question about &quot;what I would do about it&quot;, I might not call the function, if I knew it to be inlined.  Another thing I have done in C/C++ is vendor the inline function, and implement it slightly more optimally based on things I know at the callsite, so that is a special case of not calling it.<br></p><p>There may not be another way to accomplish what you want. For instance, inlineable functions are permitted to access non-public properties of a struct; like in C++, there is no way to get at those properties otherwise. You&#39;re right that you could introduce another intermediate library, though.<br></p><p><br>&gt; <br>&gt;&gt; I don&#39;t think I trust any client to decide which parts of the library are &quot;safe, probably&quot;<br>&gt; <br>&gt; <br>&gt; Similarly, I don&#39;t trust library authors to decide which parts of their libraries are safe for me to inline in my client.<br>&gt; <br>&gt; I think this may be a difference in perspective, e.g. if one works at Apple then one may receive many bug reports of the form &quot;silly app developer, don&#39;t use UIKit this way&quot; leading to a general mistrust of clients.  Meanwhile, if one has hundreds of filed radars still open (ಠ_ಠ) one might develop a general mistrust of library authors.<br>&gt; <br>&gt; To me it seems that this trust problem could be resolved were inlining to be an opt-in feature for each party.  The library author should opt-in at the function level, and the client should opt in at least at the library level, and I would prefer at the callsite.<br></p><p>Sorry, my point wasn&#39;t &quot;library authors know better than client developers&quot;; it&#39;s that trying to make decisions about specific functions isn&#39;t sound. It&#39;s possible the body of one function makes assumptions based on other (guaranteed, version-independent) knowledge about the library, the simplest form being that that function calls other inlineable functions.<br></p><p>I really don&#39;t think we want average app developers to be accessing types like NSRect indirectly, though, and if you have to opt in to accessing NSRect directly, well, everyone will do it all the time, and it&#39;ll cease to be meaningful.<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/2303a74f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>[RFC] &quot;Library Evolution Support in Swift (&#39;Resilience&#39;)&quot;</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>February 11, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Feb 11, 2016, at 7:32 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; Knowing for sure that your client is inlining isn&#39;t extra information over knowing it may inline.<br>&gt; <br>&gt; (Technically, a C function marked &#39;inline&#39; and not &#39;static&#39; isn&#39;t guaranteed to be inlined either, but in practice nobody does that because the rules are awful.)<br></p><p>I&#39;m referring specifically to the C/C++ case, where &quot;inlining a dynamic library&quot; means &quot;calling a function (or macro) with a body that appears in a .h file&quot;.<br></p><p>In that case I am 100% sure that the function was inlined.  I look at the header file and there it is.<br></p><p>An argument was advanced that &quot;we do this already in C/C++&quot; We do *something*, but not *this*.<br></p><p>&gt; I really don&#39;t think we want average app developers to be accessing types like NSRect indirectly, though, and if you have to opt in to accessing NSRect directly, well, everyone will do it all the time, and it&#39;ll cease to be meaningful.<br></p><p>It seems to me that this can be solved at the xcodeproj level.  Xcode projects have &quot;default settings&quot; and somebody can ship in that template &quot;--inline=UIKit&quot;.<br></p><p>The argument that &quot;we want average app developers to be accessing types like NSRect indirectly&quot; sounds vendor-specific to me, there is a good way here to ship that intuition in a vendor-specific location.<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/53830130/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7ba3c93f9350613c243eeb87c602935e?s=50"></div><header><strong>[RFC] &quot;Library Evolution Support in Swift (&#39;Resilience&#39;)&quot;</strong> from <string>David Smith</string> &lt;david_smith at apple.com&gt;<p>February 11, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Feb 11, 2016, at 5:57 PM, Drew Crawford via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 11, 2016, at 7:32 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Knowing for sure that your client is inlining isn&#39;t extra information over knowing it may inline.<br>&gt;&gt; <br>&gt;&gt; (Technically, a C function marked &#39;inline&#39; and not &#39;static&#39; isn&#39;t guaranteed to be inlined either, but in practice nobody does that because the rules are awful.)<br>&gt; <br>&gt; I&#39;m referring specifically to the C/C++ case, where &quot;inlining a dynamic library&quot; means &quot;calling a function (or macro) with a body that appears in a .h file&quot;.<br>&gt; <br>&gt; In that case I am 100% sure that the function was inlined.  I look at the header file and there it is.<br>&gt; <br>&gt; An argument was advanced that &quot;we do this already in C/C++&quot; We do *something*, but not *this*.<br>&gt; <br>&gt;&gt; I really don&#39;t think we want average app developers to be accessing types like NSRect indirectly, though, and if you have to opt in to accessing NSRect directly, well, everyone will do it all the time, and it&#39;ll cease to be meaningful.<br>&gt; <br>&gt; It seems to me that this can be solved at the xcodeproj level.  Xcode projects have &quot;default settings&quot; and somebody can ship in that template &quot;--inline=UIKit&quot;.<br>&gt; <br>&gt; The argument that &quot;we want average app developers to be accessing types like NSRect indirectly&quot; sounds vendor-specific to me, there is a good way here to ship that intuition in a vendor-specific location.<br>&gt; <br>&gt; <br></p><p>A less vendor-specific example would be the Int struct in the standard library.<br></p><p>	David<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/73f9d63d/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[RFC] &quot;Library Evolution Support in Swift (&#39;Resilience&#39;)&quot;</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>February 12, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Feb 11, 2016, at 17:57, Drew Crawford &lt;drew at sealedabstract.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 11, 2016, at 7:32 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Knowing for sure that your client is inlining isn&#39;t extra information over knowing it may inline.<br>&gt;&gt; <br>&gt;&gt; (Technically, a C function marked &#39;inline&#39; and not &#39;static&#39; isn&#39;t guaranteed to be inlined either, but in practice nobody does that because the rules are awful.)<br>&gt; <br>&gt; I&#39;m referring specifically to the C/C++ case, where &quot;inlining a dynamic library&quot; means &quot;calling a function (or macro) with a body that appears in a .h file&quot;.<br>&gt; <br>&gt; In that case I am 100% sure that the function was inlined.  I look at the header file and there it is.<br>&gt; <br>&gt; An argument was advanced that &quot;we do this already in C/C++&quot; We do *something*, but not *this*.<br></p><p>My point is that it&#39;s not substantially different. Knowing whether or not the function is definitely inlined doesn&#39;t change any action you want to take in response to that. (As you noted, this does require knowing whether the library has any inlineable code.)<br></p><p><br>&gt; <br>&gt;&gt; I really don&#39;t think we want average app developers to be accessing types like NSRect indirectly, though, and if you have to opt in to accessing NSRect directly, well, everyone will do it all the time, and it&#39;ll cease to be meaningful.<br>&gt; <br>&gt; It seems to me that this can be solved at the xcodeproj level.  Xcode projects have &quot;default settings&quot; and somebody can ship in that template &quot;--inline=UIKit&quot;.<br>&gt; <br>&gt; The argument that &quot;we want average app developers to be accessing types like NSRect indirectly&quot; sounds vendor-specific to me, there is a good way here to ship that intuition in a vendor-specific location.<br></p><p>There&#39;s no practical difference to a client between &quot;settings in a library&quot; and &quot;vendor settings shipped with a library&quot;, so I guess you&#39;re asking for a way to disable inlining code from a particular library? I still think this is something better done on the client side.<br></p><p>You&#39;ve brought up a good point, though: marking code inlineable needs to be taken very seriously. &#39;@inlineable&#39; and &#39;@fixed_contents&#39; are both placeholder names; they were intended for bikeshedding in the individual proposals to introduce them. Can you come up with something scarier that makes people less likely to use them on a whim? (This is by analogy with things like &quot;UnsafePointer&quot;; &quot;@unsafe_inlineable&quot; isn&#39;t quite right but gets at what I mean.)<br></p><p>(&#39;@closed&#39; is also a fragility attribute, but not one someone is likely to misuse, and also one that&#39;s much less likely to cause a security-level must-update-everything issue. The only case where that would come up is where you can fix the bug with a new value entirely on the library side—as in, existing clients don&#39;t need to do anything when they see that new value—which seems unlikely.)<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160212/816c068b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[RFC] &quot;Library Evolution Support in Swift (&#39;Resilience&#39;)&quot;</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>February 12, 2016 at 03:00:00pm</p></header><div class="content"><p>I just re-read your initial objection, which had a slightly different idea: allow inlining, but if the library has changed when I go to run it, refuse to launch. I wanted to respond to that explicitly: this is no different from treating the library as part of your own distribution (what the document calls a &quot;resilience domain&quot;), and then not shipping it with your app. That means I see two options:<br></p><p>- Mark a dependency as version-locked; if the library changes in any way, refuse to launch.<br>- Mark a dependency as non-inlineable.<br></p><p>I think these are both client-side controls, perhaps things you put in your Manifest.swift file. I&#39;m not sure that we actually need or want both of them, but does this formulation seem reasonable to you?<br></p><p>Jordan<br></p><p>P.S. I hope I&#39;m not coming off as antagonistic in these emails, particularly with the repeated responses. I think you&#39;ve brought up a very important issue and it&#39;s critical that the ramifications of the model, whatever we decide on, are well-understood and can be meaningfully acted upon.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160212/13c61c25/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>[RFC] &quot;Library Evolution Support in Swift (&#39;Resilience&#39;)&quot;</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>February 12, 2016 at 07:00:00pm</p></header><div class="content"><p>I appreciate your responses.<br></p><p>&gt; P.S. I hope I&#39;m not coming off as antagonistic in these emails, particularly with the repeated responses. I think you&#39;ve brought up a very important issue and it&#39;s critical that the ramifications of the model, whatever we decide on, are well-understood and can be meaningfully acted upon.<br></p><p>I hope I am equally not coming off as antagonistic.  I think this is a really important problem (security!  lawsuits!) and so we have to get it right.  I have a confrontational style at times, but I try to focus on ideas and not people.  And this proposal is, on balance, an amazing idea, we just have to iron out some details, and the necessary consequence of that is we have to focus on the more negative aspects.<br></p><p>&gt;  I still think this is something better done on the client side.<br></p><p>Maybe we&#39;re not communicating?  I understand this proposal to say &quot;if a library author says @inlineable in a dynamic library, the function may be inlined without any more warning on the client developer&#39;s part.&quot;  So I understand the current proposal to require consent only on the library side, and that will be sufficient for inlining to occur.<br></p><p>Let me give a developed example of the problem I forsee.  Let&#39;s say that there is a very popular third-party library for a very popular problem (JSON parsing, networking, app updating, pick your poison), and this library has been linked into hundreds or thousands of applications.<br></p><p>Through a circumstance of honest mistake, incompetence, or malice, the library has a security vulnerability.  Through a separate or coincident circumstance of honest mistake, incompetence, or malice, the function with the security vulnerability was declared inlineable.  As a matter of economics, none of the software developers depending on the library audited the library before using it, and as a matter of tooling, there was no practical way for developers like me, who forsaw this situation, to get a basic listing of what functions in the library were inlineable before deciding to avoid it.<br></p><p>This is a bad situation, although the part disregarding the inlineable aspect happens often enough that it is barely news these days (e.g. OpenSSL, Sparkle, AFNetworking, goto fail, to name recent examples).  Meanwhile application/client developers may not even be aware of security issues in their dependencies, or they may have gone out of business, they may consider the product to be at its end of life, or may take a long time to patch their software, etc.<br></p><p>There is little we can do about this in the iOS situation, but on OSX and particularly Linux, motivated end users can and do go around application/client developers, update their dynamic libraries, and resolve just such a situation as this.<br></p><p>I am worried about not so much the named examples of &quot;good&quot; inlining proffered in this thread (e.g. NSRect, UIKit, GCD, Swift standard library, etc.) but the &quot;everything else&quot; part of the ecosystem.  I assume Apple can afford to pay somebody to watch their inlineable functions, and I assume someone interested enough in performance to opt into &quot;inlining&quot; into their application understands the value of promptly patching their software.  (These may be bad assumptions for certain sensitive cases, but in the typical consumer-software case they are probably not a disaster.)  But if we consider a motivated attacker interested in developing &quot;capabilities&quot; against a large and vague unwashed mass of software, inlining-by-default significantly improves their opportunity.  And if we assume incompetence or honest mistake, inlining by default significantly raises the impact of a situation that is too common in our industry right now.<br></p><p>I believe that if inlining was &quot;consented&quot; on both sides (with some handwaving for a default policy for UIKit, standard library, and friends) the existing proposal that &quot;clients may use the new implementation, or they may use the implementation from the time they were compiled, or they may use both inconsistently&quot; might be fine, since anyone who ends up in that situation took steps to get there, and presumably they understood the risks of what they were doing.  IMO this is not so dangerous it should not be allowed, but it is so dangerous that someone should think carefully before they do it.  This feels like &quot;-Ounchecked.&quot;  It is a power feature.<br></p><p>If we don&#39;t implement some dual consent like this (on library and client), then I think the &quot;may use both inconsistently&quot; language is too sharp an edge for a default behavior.  We need to implement some other safeguard against undefined behavior, because undefined behavior is a bad default for Swift.  Ideally the application could re-link itself (e.g. perhaps it contains a non-inlined payload that it dusts off and uses in this case), but in the interests of MVP I think a fail-to-start with a diagnostic would be a place to start.  Unfortunately fail-to-start might discourage upgrading an inlined library with a security bug (say you link with OpenSSL for example) but I prefer knowing I am insecure to not knowing.<br></p><p>I think either of those directions would separately address this issue.  I don&#39;t have a strong opinion about which path we should go.<br></p><p>&gt; - Mark a dependency as version-locked; if the library changes in any way, refuse to launch.<br>&gt; - Mark a dependency as non-inlineable.<br></p><p><br>Control is better than no control, but if the default is still &quot;allow arbitrary libraries to inline with arbitrary applications&quot; we are still in the case where an end user has hundreds of vulnerable applications with no mitigation, and that is very scary to me.<br></p><p>&gt; Can you come up with something scarier that makes people less likely to use them on a whim? (This is by analogy with things like &quot;UnsafePointer&quot;; &quot;@unsafe_inlineable&quot; isn&#39;t quite right but gets at what I mean.)<br></p><p><br>The problem with &quot;inlineable&quot; is that it describes the benefit (high-performance!) but leaves the cost as an exercise to the reader.  Perhaps we should pick a word that describes the cost and leaves the benefit as an exercise to the reader.<br></p><p>I think the &quot;cost&quot; of &quot;inlineable&quot; is really that one cannot make changes to the functions later (as that will be undefined).  So we could say e.g. &quot;@fixed&quot;, &quot;@permanent&quot;, &quot;@settled&quot;, &quot;@unalterable&quot;, &quot;@promised&quot; &quot;@immutable&quot;, &quot;@irreversible&quot;, or similar.  I think that is better than &quot;unsafe&quot;, since &quot;unsafe&quot; is a general danger, but inlining is not always dangerous, it is dangerous in the context of changes.  Something like &quot;@immutable struct NSRect&quot; sounds practically benign, while &quot;@settled func verifyDigitalSignature&quot; sounds terrifying, so this intuition maps well onto the actual level of danger.<br></p><p>Meanwhile I think most people who know enough to use this feature responsibly would be able to work out that making something &quot;immutable&quot; etc. would unlock more compiler optimizations, so I think such a word is adequate to describe the benefit.<br></p><p><br></p><p>&gt; On Feb 12, 2016, at 5:06 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; I just re-read your initial objection, which had a slightly different idea: allow inlining, but if the library has changed when I go to run it, refuse to launch. I wanted to respond to that explicitly: this is no different from treating the library as part of your own distribution (what the document calls a &quot;resilience domain&quot;), and then not shipping it with your app. That means I see two options:<br>&gt; <br>&gt; - Mark a dependency as version-locked; if the library changes in any way, refuse to launch.<br>&gt; - Mark a dependency as non-inlineable.<br>&gt; <br>&gt; I think these are both client-side controls, perhaps things you put in your Manifest.swift file. I&#39;m not sure that we actually need or want both of them, but does this formulation seem reasonable to you?<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; P.S. I hope I&#39;m not coming off as antagonistic in these emails, particularly with the repeated responses. I think you&#39;ve brought up a very important issue and it&#39;s critical that the ramifications of the model, whatever we decide on, are well-understood and can be meaningfully acted upon.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160212/b222373b/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[RFC] &quot;Library Evolution Support in Swift (&#39;Resilience&#39;)&quot;</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>February 11, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Feb 11, 2016, at 2:39 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 11, 2016, at 13:54, Drew Crawford via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 11, 2016, at 11:53 AM, David Owens II &lt;david at owensd.io &lt;mailto:david at owensd.io&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I personally think it&#39;s a very fair trade-off to disallow @inlineable code to be inlined from a dynamic dll by default. Now, that doesn&#39;t mean that the developer couldn&#39;t add a link flag `--super-nonresilient-i-know-what-im-doing` when pulling in certain DLLs. That&#39;s an explicit statement that the developer is choosing to break resilience. The important part is that it&#39;s the developer consuming the DLL making the choice vs. the developer of the DLL making that choice for everyone.<br>&gt;&gt; <br>&gt;&gt; +2<br>&gt;&gt; <br>&gt;&gt; IMO disabling inlining of DLLs should clearly be the default, and there should be some &quot;I know what I&#39;m doing&quot; flag for folks who are willing to take on the burden of vendoring their library as if it were static.<br>&gt; <br>&gt; <br>&gt; You&#39;re using inlineable code today in Cocoa: dispatch_once&#39;s fast-path, the geometry functions from CoreGraphics to SceneKit, and every NS_OPTIONS enum that has an &quot;all&quot; case. It is a performance vs. flexibility tradeoff, but an incredibly important one. In Swift we definitely don&#39;t want to sacrifice flexibility by default, but it has to be an option if we want Swift to be a viable replacement for things traditionally done with C or C++. &quot;Inlining across dynamic libraries&quot; has been around for decades with C, C++, and C#.<br>&gt; <br>&gt; I&#39;m skeptical that anyone will actually use your hypothetical &quot;use this library without treating anything as fragile, even if I could&quot; setting; most clients just want as much performance as they can get. But it would be implementable.<br></p><p>Do you have any metrics on how often the disable safety metrics are used when compiling swift code?<br></p><p>C++ isn&#39;t know for being the bastion of doing versioning correctly. I agree it has the speed target that hopefully Swift can get to.<br></p><p>As for C#, unless you are talking about something I don&#39;t know about, ngen and JIT (runtime) are the only ways that the code will be inlined. However, when the assembly changes, that should invalidate the ngen&#39;d image forcing it to be regenerated. Hence the entire feature for the TargetedPatchingOptOut on system framework dlls (selective replacement of the ngen&#39;d images).<br></p><p>In any case, for apps, the scenario is largely irrelevant. To ship and update to that, I must do a recompile. This is mostly true for all ship mechanism on Apple platforms now any because.<br></p><p>Maybe it&#39;s a narrow enough surface area where this would actually be a practical issue such that it&#39;s largely irrelevant...<br></p><p>-David<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/1e263808/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>[RFC] &quot;Library Evolution Support in Swift (&#39;Resilience&#39;)&quot;</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>February 11, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Feb 11, 2016, at 5:56 PM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt; <br>&gt; Maybe it&#39;s a narrow enough surface area where this would actually be a practical issue such that it&#39;s largely irrelevant...<br></p><p>I&#39;m trying to ship security code in Swift on Linux.<br></p><p>I agree that on iOS it doesn&#39;t matter, but in terms of the broader computing ecosystem that distribution model is the exception and not the rule.<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/9c66872a/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[RFC] &quot;Library Evolution Support in Swift (&#39;Resilience&#39;)&quot;</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>February 11, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Feb 11, 2016, at 15:56, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 11, 2016, at 2:39 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 11, 2016, at 13:54, Drew Crawford via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 11, 2016, at 11:53 AM, David Owens II &lt;david at owensd.io &lt;mailto:david at owensd.io&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I personally think it&#39;s a very fair trade-off to disallow @inlineable code to be inlined from a dynamic dll by default. Now, that doesn&#39;t mean that the developer couldn&#39;t add a link flag `--super-nonresilient-i-know-what-im-doing` when pulling in certain DLLs. That&#39;s an explicit statement that the developer is choosing to break resilience. The important part is that it&#39;s the developer consuming the DLL making the choice vs. the developer of the DLL making that choice for everyone.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +2<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; IMO disabling inlining of DLLs should clearly be the default, and there should be some &quot;I know what I&#39;m doing&quot; flag for folks who are willing to take on the burden of vendoring their library as if it were static.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; You&#39;re using inlineable code today in Cocoa: dispatch_once&#39;s fast-path, the geometry functions from CoreGraphics to SceneKit, and every NS_OPTIONS enum that has an &quot;all&quot; case. It is a performance vs. flexibility tradeoff, but an incredibly important one. In Swift we definitely don&#39;t want to sacrifice flexibility by default, but it has to be an option if we want Swift to be a viable replacement for things traditionally done with C or C++. &quot;Inlining across dynamic libraries&quot; has been around for decades with C, C++, and C#.<br>&gt;&gt; <br>&gt;&gt; I&#39;m skeptical that anyone will actually use your hypothetical &quot;use this library without treating anything as fragile, even if I could&quot; setting; most clients just want as much performance as they can get. But it would be implementable.<br>&gt; <br>&gt; Do you have any metrics on how often the disable safety metrics are used when compiling swift code?<br>&gt; <br>&gt; C++ isn&#39;t know for being the bastion of doing versioning correctly. I agree it has the speed target that hopefully Swift can get to.<br>&gt; <br>&gt; As for C#, unless you are talking about something I don&#39;t know about, ngen and JIT (runtime) are the only ways that the code will be inlined. However, when the assembly changes, that should invalidate the ngen&#39;d image forcing it to be regenerated. Hence the entire feature for the TargetedPatchingOptOut on system framework dlls (selective replacement of the ngen&#39;d images).<br>&gt; <br>&gt; In any case, for apps, the scenario is largely irrelevant. To ship and update to that, I must do a recompile. This is mostly true for all ship mechanism on Apple platforms now any because.<br>&gt; <br>&gt; Maybe it&#39;s a narrow enough surface area where this would actually be a practical issue such that it&#39;s largely irrelevant...<br></p><p>Well, Apple itself will be using this model, so if there&#39;s a bug in an inlineable function in Cocoa, this could make a difference.<br></p><p>Unfortunately, I can&#39;t share any metrics about -O vs. -Ounchecked.<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/62438be4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>[RFC] &quot;Library Evolution Support in Swift (&#39;Resilience&#39;)&quot;</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>February 11, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Feb 11, 2016, at 6:19 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; Well, Apple itself will be using this model, so if there&#39;s a bug in an inlineable function in Cocoa, this could make a difference.<br></p><p>Do we know if this has happened?  This seems like a question that could be resolved by diffing publicly-available headers.<br></p><p>Granted, Cocoa is not an ideal dataset to draw conclusions for my problem domain, but it is better than nothing.  If it hasn&#39;t occurred in Cocoa, that might pacify me.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/3c1fa51c/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[RFC] &quot;Library Evolution Support in Swift (&#39;Resilience&#39;)&quot;</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>February 11, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Feb 11, 2016, at 4:19 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Feb 11, 2016, at 15:56, David Owens II &lt;david at owensd.io &lt;mailto:david at owensd.io&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Do you have any metrics on how often the disable safety metrics are used when compiling swift code?<br>&gt;&gt; <br>&gt;&gt; C++ isn&#39;t know for being the bastion of doing versioning correctly. I agree it has the speed target that hopefully Swift can get to.<br>&gt;&gt; <br>&gt;&gt; As for C#, unless you are talking about something I don&#39;t know about, ngen and JIT (runtime) are the only ways that the code will be inlined. However, when the assembly changes, that should invalidate the ngen&#39;d image forcing it to be regenerated. Hence the entire feature for the TargetedPatchingOptOut on system framework dlls (selective replacement of the ngen&#39;d images).<br>&gt;&gt; <br>&gt;&gt; In any case, for apps, the scenario is largely irrelevant. To ship and update to that, I must do a recompile. This is mostly true for all ship mechanism on Apple platforms now any because.<br>&gt;&gt; <br>&gt;&gt; Maybe it&#39;s a narrow enough surface area where this would actually be a practical issue such that it&#39;s largely irrelevant...<br>&gt; <br>&gt; Well, Apple itself will be using this model, so if there&#39;s a bug in an inlineable function in Cocoa, this could make a difference.<br>&gt; <br>&gt; Unfortunately, I can&#39;t share any metrics about -O vs. -Ounchecked.<br></p><p>Sounds like you&#39;ll already need to plan for a `TargetedPatchingOptOut` feature then... it&#39;s a good question on how apps that consume inlineable framework code get updates without a recompile, especially for critical security fixes.<br></p><p>-David<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/4529c093/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[RFC] &quot;Library Evolution Support in Swift (&#39;Resilience&#39;)&quot;</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>February 10, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; Another thing I think we are missing here is versioning the function bodies themselves.  For example (ignore syntax) suppose we have<br>&gt; <br>&gt;             <br>&gt; public (1.0) func removeTheCacheFiles() {<br>&gt;       os.rmdir(&quot;/path/to/cache&quot;)<br>&gt; }<br>&gt; <br>&gt; We may evolve this function in two orthogonal ways:<br>&gt; <br>&gt; We may develop other cache files as our program grows<br>&gt; We may discover that we forgot to check if the user is allowed by the security policy to remove the cache files.<br>&gt; <br>&gt; Therefore we may evolve this function as follows (again, I use pretend syntax):<br>&gt; <br>&gt; public (1.0) func removeTheCacheFiles() {<br>&gt;       precondition(userIsAuthorized()) //this change is backported to 1.0<br>&gt;       os.rmdir(&quot;/path/to/cache&quot;)<br>&gt;       #if 1.1 { //this code only for 1.1-era callers<br>&gt;         os.rmdir(&quot;/path/to/cache2&quot;)<br>&gt;       }<br>&gt; }<br>&gt; <br>&gt; It is important to support this case because very often in server land, certain clients only want to pick up the security fixes (and not, say, new features).  See e.g. this Debian Security FAQ &lt;https://www.debian.org/security/faq#oldversion&gt;, where people spend a huge amount of time backporting security fixes to old versions.<br>&gt; <br>&gt; I realize this is not at all the practice in &quot;consumer-grade&quot; applications like iOS/OSX/etc., but it is very entrenched in serverland, and I really think there is value in supporting this at the language level for those people who work in that world.<br>&gt; <br>&gt; I think the implementation of this is just to compile all possibilities and just let the client pick the implementation based on the API version.  I realize this may result in larger binaries, but only when the feature is used, so it&#39;s opt-in.<br></p><p>Hm, this is interesting. Apple does use a form of this, called &quot;linked-on-or-after&quot; checks; if you compile your code against the latest version of the OS, you&#39;re opting into new behavior. That said, it&#39;s problematic if two of your dependencies disagree on which version of the library they want. (There are a few different possible answers there, all with trade-offs.)<br></p><p>I think we should treat this as an additive feature; the worst that happens is you can&#39;t do this kind of multi-compilation right away.<br></p><p>Jordan<br></p><p>P.S. I want to note that most of the &quot;innovative&quot; ideas here are already in the Swift 2 OS availability model; main credit for this goes to Devin Coughlin.<br></p><p>P.P.S. I&#39;ll respond to the inlineable thread tomorrow.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160210/b1a5c39c/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[RFC] &quot;Library Evolution Support in Swift (&#39;Resilience&#39;)&quot;</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 12, 2016 at 03:00:00pm</p></header><div class="content"><p>Regarding @inlineable, I think having the equivalent of __attribute__((always_inline)) is important. As proposed, an inlineable function may factor out helpers into internal-with-availability helpers, but then those helpers are still required to exist for old clients even if a new implementation of the inlineable function is factored differently. Such deep refactorings of inlineable code are not ideal, of course, but it&#39;s happened in the past in C++ standard libraries, and seems like freedom we&#39;d want to reserve for the inlineable layer of Swift&#39;s own standard library.<br></p><p>-Joe<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
