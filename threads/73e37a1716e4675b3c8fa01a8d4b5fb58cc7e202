<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May  4, 2016 at 03:00:00pm</p></header><div class="content"><p>on Wed May 04 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On May 4, 2016, at 1:29 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Wed May 04 2016, Adrian Zubarev &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;&gt; Not sure what to think about the enum cases inside a protocol (if AnyEnum would<br>&gt;&gt;&gt; even exist), it could be a nice addition to the language, but this is an own<br>&gt;&gt;&gt; proposal I guess.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We should start by adding AnyValue protocol to which all value types<br>&gt;&gt;&gt; conforms.<br>&gt;&gt; <br>&gt;&gt; Having a way to constrain conformance to things with value semantics is<br>&gt;&gt; something I&#39;ve long wanted.  *However*, the approach described is too<br>&gt;&gt; simplistic.  It&#39;s possible to build classes whose instances have value<br>&gt;&gt; semantics (just make them immutable) and it&#39;s possible to build structs<br>&gt;&gt; whose instances have reference semantics (just put the struct&#39;s storage<br>&gt;&gt; in a mutable class instance that it holds as a property, and don&#39;t do<br>&gt;&gt; copy-on-write).  <br>&gt;&gt; <br>&gt;&gt; In order for something like AnyValue to have meaning, we need to impose<br>&gt;&gt; greater order.  After thinking through many approaches over the years, I<br>&gt;&gt; have arrived at the (admittedly rather drastic) opinion that the<br>&gt;&gt; language should effectively outlaw the creation of structs and enums<br>&gt;&gt; that don&#39;t have value semantics.  (I have no problem with the idea that<br>&gt;&gt; immutable classes that want to act as values should be wrapped in a<br>&gt;&gt; struct).  The language could then do lots of things much more<br>&gt;&gt; intelligently, such as correctly generating implementations of equality.<br>&gt;<br>&gt; That is a drastic solution indeed!  How would this impact things like<br>&gt; Array&lt;UIView&gt;?  While Array itself has value semantics, the aggregate<br>&gt; obviously does not as it contains references which usually be mutated<br>&gt; underneath us.  <br></p><p>Value semantics and mutation can only be measured with respect to<br>equality.  The definition of == for all class types would be equivalent<br>to ===.  Problem solved.<br></p><p>&gt; Similar considerations apply to simpler wrapper structs such as Weak.<br></p><p>Same answer.<br></p><p>&gt; My expectation is a generic aggregate such as Array would have to<br>&gt; conditionally conform to AnyValue only when Element also conforms to<br>&gt; AnyValue.<br>&gt;<br>&gt; I’m also wondering how such a rule would be implemented while still<br>&gt; allowing for CoW structs that *do* implement value semantics, but do<br>&gt; so while using references internally.<br></p><p>I am not talking about any kind of statically-enforceable rule, although<br>we could probably make warnings sophisticated enough to help with this.<br>&gt;<br>&gt; If the compiler can be sophisticated enough to verify value semantics<br>&gt; statically maybe it would be better to have that mechanism be<br>&gt; triggered by conformance to AnyValue rather than for all structs and<br>&gt; enums.  Types that conform to AnyValue would receive the benefits of<br>&gt; the compiler knowing they have value semantics, while other uses of<br>&gt; structs and enums would remain valid.  Best practice would be to<br>&gt; conform structs and enums to AnyValue whenever possible.<br>&gt;<br>&gt; Another possible advantage of this approach would be allowing<br>&gt; immutable reference types to conform to AnyValue and receive the<br>&gt; associated benefits such as the generated implementation of equality,<br>&gt; etc.<br>&gt;<br>&gt; -Matthew<br>&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May  4, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On May 4, 2016, at 5:50 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Wed May 04 2016, Matthew Johnson &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On May 4, 2016, at 1:29 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Wed May 04 2016, Adrian Zubarev &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; Not sure what to think about the enum cases inside a protocol (if AnyEnum would<br>&gt;&gt;&gt;&gt; even exist), it could be a nice addition to the language, but this is an own<br>&gt;&gt;&gt;&gt; proposal I guess.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We should start by adding AnyValue protocol to which all value types<br>&gt;&gt;&gt;&gt; conforms.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Having a way to constrain conformance to things with value semantics is<br>&gt;&gt;&gt; something I&#39;ve long wanted.  *However*, the approach described is too<br>&gt;&gt;&gt; simplistic.  It&#39;s possible to build classes whose instances have value<br>&gt;&gt;&gt; semantics (just make them immutable) and it&#39;s possible to build structs<br>&gt;&gt;&gt; whose instances have reference semantics (just put the struct&#39;s storage<br>&gt;&gt;&gt; in a mutable class instance that it holds as a property, and don&#39;t do<br>&gt;&gt;&gt; copy-on-write).  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In order for something like AnyValue to have meaning, we need to impose<br>&gt;&gt;&gt; greater order.  After thinking through many approaches over the years, I<br>&gt;&gt;&gt; have arrived at the (admittedly rather drastic) opinion that the<br>&gt;&gt;&gt; language should effectively outlaw the creation of structs and enums<br>&gt;&gt;&gt; that don&#39;t have value semantics.  (I have no problem with the idea that<br>&gt;&gt;&gt; immutable classes that want to act as values should be wrapped in a<br>&gt;&gt;&gt; struct).  The language could then do lots of things much more<br>&gt;&gt;&gt; intelligently, such as correctly generating implementations of equality.<br>&gt;&gt; <br>&gt;&gt; That is a drastic solution indeed!  How would this impact things like<br>&gt;&gt; Array&lt;UIView&gt;?  While Array itself has value semantics, the aggregate<br>&gt;&gt; obviously does not as it contains references which usually be mutated<br>&gt;&gt; underneath us.  <br>&gt; <br>&gt; Value semantics and mutation can only be measured with respect to<br>&gt; equality.  The definition of == for all class types would be equivalent<br>&gt; to ===.  Problem solved.<br>&gt; <br>&gt;&gt; Similar considerations apply to simpler wrapper structs such as Weak.<br>&gt; <br>&gt; Same answer.<br></p><p>Hmm.  If those qualify as “value semantic” then what kind of structs and enums would not?  A struct wrapping a mutable reference type certainly doesn’t “feel” value semantic to me and certainly doesn’t have the guarantees usually associated with value semantics (won’t mutate behind your back, thread safe, etc).<br></p><p>&gt; <br>&gt;&gt; My expectation is a generic aggregate such as Array would have to<br>&gt;&gt; conditionally conform to AnyValue only when Element also conforms to<br>&gt;&gt; AnyValue.<br>&gt;&gt; <br>&gt;&gt; I’m also wondering how such a rule would be implemented while still<br>&gt;&gt; allowing for CoW structs that *do* implement value semantics, but do<br>&gt;&gt; so while using references internally.<br>&gt; <br>&gt; I am not talking about any kind of statically-enforceable rule, although<br>&gt; we could probably make warnings sophisticated enough to help with this.<br></p><p>You said the you have arrived at the opinion that the language should “effectively outlaw” structs and enums that do not have value semantics.  That sounded like static enforcement to me.  Maybe you meant we should allow the compiler to assume value semantics for structs and enums despite the fact that it doesn’t statically enforce this?<br></p><p>&gt;&gt; <br>&gt;&gt; If the compiler can be sophisticated enough to verify value semantics<br>&gt;&gt; statically maybe it would be better to have that mechanism be<br>&gt;&gt; triggered by conformance to AnyValue rather than for all structs and<br>&gt;&gt; enums.  Types that conform to AnyValue would receive the benefits of<br>&gt;&gt; the compiler knowing they have value semantics, while other uses of<br>&gt;&gt; structs and enums would remain valid.  Best practice would be to<br>&gt;&gt; conform structs and enums to AnyValue whenever possible.<br>&gt;&gt; <br>&gt;&gt; Another possible advantage of this approach would be allowing<br>&gt;&gt; immutable reference types to conform to AnyValue and receive the<br>&gt;&gt; associated benefits such as the generated implementation of equality,<br>&gt;&gt; etc.<br>&gt;&gt; <br>&gt;&gt; -Matthew<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; -- <br>&gt; Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160504/80c28e69/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May  5, 2016 at 02:00:00pm</p></header><div class="content"><p>on Wed May 04 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br></p><p>&gt;     On May 4, 2016, at 5:50 PM, Dave Abrahams via swift-evolution<br>&gt;     &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;     on Wed May 04 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;                 On May 4, 2016, at 1:29 PM, Dave Abrahams via swift-evolution<br>&gt;             &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;             on Wed May 04 2016, Adrian Zubarev &lt;swift-evolution at swift.org&gt;<br>&gt;             wrote:<br>&gt;<br>&gt;                     Not sure what to think about the enum cases inside a<br>&gt;                 protocol (if AnyEnum would<br>&gt;                 even exist), it could be a nice addition to the language, but<br>&gt;                 this is an own<br>&gt;                 proposal I guess.<br>&gt;<br>&gt;                 We should start by adding AnyValue protocol to which all value<br>&gt;                 types<br>&gt;                 conforms.<br>&gt;<br>&gt;             Having a way to constrain conformance to things with value semantics<br>&gt;             is<br>&gt;             something I&#39;ve long wanted. *However*, the approach described is too<br>&gt;             simplistic. It&#39;s possible to build classes whose instances have<br>&gt;             value<br>&gt;             semantics (just make them immutable) and it&#39;s possible to build<br>&gt;             structs<br>&gt;             whose instances have reference semantics (just put the struct&#39;s<br>&gt;             storage<br>&gt;             in a mutable class instance that it holds as a property, and don&#39;t<br>&gt;             do<br>&gt;             copy-on-write). <br>&gt;<br>&gt;             In order for something like AnyValue to have meaning, we need to<br>&gt;             impose<br>&gt;             greater order. After thinking through many approaches over the<br>&gt;             years, I<br>&gt;             have arrived at the (admittedly rather drastic) opinion that the<br>&gt;             language should effectively outlaw the creation of structs and enums<br>&gt;             that don&#39;t have value semantics. (I have no problem with the idea<br>&gt;             that<br>&gt;             immutable classes that want to act as values should be wrapped in a<br>&gt;             struct). The language could then do lots of things much more<br>&gt;             intelligently, such as correctly generating implementations of<br>&gt;             equality.<br>&gt;<br>&gt;         That is a drastic solution indeed! How would this impact things like<br>&gt;         Array&lt;UIView&gt;? While Array itself has value semantics, the aggregate<br>&gt;         obviously does not as it contains references which usually be mutated<br>&gt;         underneath us. <br>&gt;<br>&gt;     Value semantics and mutation can only be measured with respect to<br>&gt;     equality. The definition of == for all class types would be equivalent<br>&gt;     to ===. Problem solved.<br>&gt;<br>&gt;         Similar considerations apply to simpler wrapper structs such as Weak.<br>&gt;<br>&gt;     Same answer.<br>&gt;<br>&gt; Hmm. If those qualify as “value semantic” then what kind of structs and enums<br>&gt; would not? A struct wrapping a mutable reference type certainly doesn’t “feel”<br>&gt; value semantic to me and certainly doesn’t have the guarantees usually<br>&gt; associated with value semantics (won’t mutate behind your back, thread safe,<br>&gt; etc).<br></p><p>Sure it does.<br></p><p>     public struct Wrap&lt;T: AnyObject&gt; : Equatable {<br>       init(_ x: T) { self.x = x }<br>       private x: T<br>     }<br></p><p>     func == &lt;T&gt;(lhs: Wrap&lt;T&gt;, rhs: Wrap&lt;T&gt;) -&gt; Bool {<br>       return lhs.x === rhs.x<br>     }<br></p><p>I defy you to find any scenario where Wrap&lt;T&gt; doesn&#39;t have value<br>semantics, whether T is mutable or not.<br></p><p>Alternately, you can look at the Array implementation.  Array is a<br>struct wrapping a mutable class.  It has value semantics by virtue of<br>CoW.<br></p><p>&gt;         My expectation is a generic aggregate such as Array would have to<br>&gt;         conditionally conform to AnyValue only when Element also conforms to<br>&gt;         AnyValue.<br>&gt;<br>&gt;         I’m also wondering how such a rule would be implemented while still<br>&gt;         allowing for CoW structs that *do* implement value semantics, but do<br>&gt;         so while using references internally.<br>&gt;<br>&gt;     I am not talking about any kind of statically-enforceable rule, although<br>&gt;     we could probably make warnings sophisticated enough to help with this.<br>&gt;<br>&gt; You said the you have arrived at the opinion that the language should<br>&gt; “effectively outlaw” structs and enums that do not have value semantics. That<br>&gt; sounded like static enforcement to me. <br></p><p>The language outlaws certain kinds of inout aliasing without providing static<br>enforcement.  This is like that.<br></p><p>&gt; Maybe you meant we should allow the compiler to assume value semantics<br>&gt; for structs and enums despite the fact that it doesn’t statically<br>&gt; enforce this?<br></p><p>That would be one *consequence* of effectively outlawing it.  The library<br>could make similar assumptions.<br></p><p>&gt;         If the compiler can be sophisticated enough to verify value semantics<br>&gt;         statically maybe it would be better to have that mechanism be<br>&gt;         triggered by conformance to AnyValue rather than for all structs and<br>&gt;         enums. Types that conform to AnyValue would receive the benefits of<br>&gt;         the compiler knowing they have value semantics, while other uses of<br>&gt;         structs and enums would remain valid. Best practice would be to<br>&gt;         conform structs and enums to AnyValue whenever possible.<br>&gt;<br>&gt;         Another possible advantage of this approach would be allowing<br>&gt;         immutable reference types to conform to AnyValue and receive the<br>&gt;         associated benefits such as the generated implementation of equality,<br>&gt;         etc.<br>&gt;<br>&gt;         -Matthew<br>&gt;<br>&gt;             -- <br>&gt;             Dave<br>&gt;<br>&gt;             _______________________________________________<br>&gt;             swift-evolution mailing list<br>&gt;             swift-evolution at swift.org<br>&gt;             https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;         _______________________________________________<br>&gt;         swift-evolution mailing list<br>&gt;         swift-evolution at swift.org<br>&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;     -- <br>&gt;     Dave<br>&gt;<br>&gt;     _______________________________________________<br>&gt;     swift-evolution mailing list<br>&gt;     swift-evolution at swift.org<br>&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May  5, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On May 5, 2016, at 4:59 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Wed May 04 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;    On May 4, 2016, at 5:50 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;    &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;    on Wed May 04 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;                On May 4, 2016, at 1:29 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;            &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;            on Wed May 04 2016, Adrian Zubarev &lt;swift-evolution at swift.org&gt;<br>&gt;&gt;            wrote:<br>&gt;&gt; <br>&gt;&gt;                    Not sure what to think about the enum cases inside a<br>&gt;&gt;                protocol (if AnyEnum would<br>&gt;&gt;                even exist), it could be a nice addition to the language, but<br>&gt;&gt;                this is an own<br>&gt;&gt;                proposal I guess.<br>&gt;&gt; <br>&gt;&gt;                We should start by adding AnyValue protocol to which all value<br>&gt;&gt;                types<br>&gt;&gt;                conforms.<br>&gt;&gt; <br>&gt;&gt;            Having a way to constrain conformance to things with value semantics<br>&gt;&gt;            is<br>&gt;&gt;            something I&#39;ve long wanted. *However*, the approach described is too<br>&gt;&gt;            simplistic. It&#39;s possible to build classes whose instances have<br>&gt;&gt;            value<br>&gt;&gt;            semantics (just make them immutable) and it&#39;s possible to build<br>&gt;&gt;            structs<br>&gt;&gt;            whose instances have reference semantics (just put the struct&#39;s<br>&gt;&gt;            storage<br>&gt;&gt;            in a mutable class instance that it holds as a property, and don&#39;t<br>&gt;&gt;            do<br>&gt;&gt;            copy-on-write). <br>&gt;&gt; <br>&gt;&gt;            In order for something like AnyValue to have meaning, we need to<br>&gt;&gt;            impose<br>&gt;&gt;            greater order. After thinking through many approaches over the<br>&gt;&gt;            years, I<br>&gt;&gt;            have arrived at the (admittedly rather drastic) opinion that the<br>&gt;&gt;            language should effectively outlaw the creation of structs and enums<br>&gt;&gt;            that don&#39;t have value semantics. (I have no problem with the idea<br>&gt;&gt;            that<br>&gt;&gt;            immutable classes that want to act as values should be wrapped in a<br>&gt;&gt;            struct). The language could then do lots of things much more<br>&gt;&gt;            intelligently, such as correctly generating implementations of<br>&gt;&gt;            equality.<br>&gt;&gt; <br>&gt;&gt;        That is a drastic solution indeed! How would this impact things like<br>&gt;&gt;        Array&lt;UIView&gt;? While Array itself has value semantics, the aggregate<br>&gt;&gt;        obviously does not as it contains references which usually be mutated<br>&gt;&gt;        underneath us. <br>&gt;&gt; <br>&gt;&gt;    Value semantics and mutation can only be measured with respect to<br>&gt;&gt;    equality. The definition of == for all class types would be equivalent<br>&gt;&gt;    to ===. Problem solved.<br>&gt;&gt; <br>&gt;&gt;        Similar considerations apply to simpler wrapper structs such as Weak.<br>&gt;&gt; <br>&gt;&gt;    Same answer.<br>&gt;&gt; <br>&gt;&gt; Hmm. If those qualify as “value semantic” then what kind of structs and enums<br>&gt;&gt; would not? A struct wrapping a mutable reference type certainly doesn’t “feel”<br>&gt;&gt; value semantic to me and certainly doesn’t have the guarantees usually<br>&gt;&gt; associated with value semantics (won’t mutate behind your back, thread safe,<br>&gt;&gt; etc).<br>&gt; <br>&gt; Sure it does.<br>&gt; <br>&gt;     public struct Wrap&lt;T: AnyObject&gt; : Equatable {<br>&gt;       init(_ x: T) { self.x = x }<br>&gt;       private x: T<br>&gt;     }<br>&gt; <br>&gt;     func == &lt;T&gt;(lhs: Wrap&lt;T&gt;, rhs: Wrap&lt;T&gt;) -&gt; Bool {<br>&gt;       return lhs.x === rhs.x<br>&gt;     }<br>&gt; <br>&gt; I defy you to find any scenario where Wrap&lt;T&gt; doesn&#39;t have value<br>&gt; semantics, whether T is mutable or not.<br>&gt; <br>&gt; Alternately, you can look at the Array implementation.  Array is a<br>&gt; struct wrapping a mutable class.  It has value semantics by virtue of<br>&gt; CoW.<br></p><p>This goes back to where you draw the line as to the “boundary of the value”.  Wrap and Array are “value semantic” in a shallow sense and are capable of deep value semantics when T is deeply value semantic.  Both have their place, but the maximum benefit of value semantics (purity) is derived from deep value semantics.  This is when there is no possibility of shared mutable state.  This is an extremely important property.<br></p><p><br>let t = MyClass()<br>foo.acceptWrapped(Wrap(t))<br>t.mutate()<br></p><p>In this example, foo had better not depend on the wrapped instance not getting mutated.<br></p><p>&gt; <br>&gt;&gt;        My expectation is a generic aggregate such as Array would have to<br>&gt;&gt;        conditionally conform to AnyValue only when Element also conforms to<br>&gt;&gt;        AnyValue.<br>&gt;&gt; <br>&gt;&gt;        I’m also wondering how such a rule would be implemented while still<br>&gt;&gt;        allowing for CoW structs that *do* implement value semantics, but do<br>&gt;&gt;        so while using references internally.<br>&gt;&gt; <br>&gt;&gt;    I am not talking about any kind of statically-enforceable rule, although<br>&gt;&gt;    we could probably make warnings sophisticated enough to help with this.<br>&gt;&gt; <br>&gt;&gt; You said the you have arrived at the opinion that the language should<br>&gt;&gt; “effectively outlaw” structs and enums that do not have value semantics. That<br>&gt;&gt; sounded like static enforcement to me. <br>&gt; <br>&gt; The language outlaws certain kinds of inout aliasing without providing static<br>&gt; enforcement.  This is like that.<br></p><p>I did not know this.  Now you have me curious.  Can you give an example of where we are able to violate law?  I ask mostly because it sounds like there is a possibility of stumbling into dangerous territory, possibly without being aware that you have done so.<br></p><p>&gt; <br>&gt;&gt; Maybe you meant we should allow the compiler to assume value semantics<br>&gt;&gt; for structs and enums despite the fact that it doesn’t statically<br>&gt;&gt; enforce this?<br>&gt; <br>&gt; That would be one *consequence* of effectively outlawing it.  The library<br>&gt; could make similar assumptions.<br>&gt; <br>&gt;&gt;        If the compiler can be sophisticated enough to verify value semantics<br>&gt;&gt;        statically maybe it would be better to have that mechanism be<br>&gt;&gt;        triggered by conformance to AnyValue rather than for all structs and<br>&gt;&gt;        enums. Types that conform to AnyValue would receive the benefits of<br>&gt;&gt;        the compiler knowing they have value semantics, while other uses of<br>&gt;&gt;        structs and enums would remain valid. Best practice would be to<br>&gt;&gt;        conform structs and enums to AnyValue whenever possible.<br>&gt;&gt; <br>&gt;&gt;        Another possible advantage of this approach would be allowing<br>&gt;&gt;        immutable reference types to conform to AnyValue and receive the<br>&gt;&gt;        associated benefits such as the generated implementation of equality,<br>&gt;&gt;        etc.<br>&gt;&gt; <br>&gt;&gt;        -Matthew<br>&gt;&gt; <br>&gt;&gt;            -- <br>&gt;&gt;            Dave<br>&gt;&gt; <br>&gt;&gt;            _______________________________________________<br>&gt;&gt;            swift-evolution mailing list<br>&gt;&gt;            swift-evolution at swift.org<br>&gt;&gt;            https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt;        _______________________________________________<br>&gt;&gt;        swift-evolution mailing list<br>&gt;&gt;        swift-evolution at swift.org<br>&gt;&gt;        https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt;    -- <br>&gt;&gt;    Dave<br>&gt;&gt; <br>&gt;&gt;    _______________________________________________<br>&gt;&gt;    swift-evolution mailing list<br>&gt;&gt;    swift-evolution at swift.org<br>&gt;&gt;    https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; <br>&gt; -- <br>&gt; Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160505/444dc7ba/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May  5, 2016 at 08:00:00pm</p></header><div class="content"><p>on Thu May 05 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br></p><p>&gt;     On May 5, 2016, at 4:59 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;<br>&gt;     on Wed May 04 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;<br>&gt;         On May 4, 2016, at 5:50 PM, Dave Abrahams via swift-evolution<br>&gt;         &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;         on Wed May 04 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;         On May 4, 2016, at 1:29 PM, Dave Abrahams via swift-evolution<br>&gt;         &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;         on Wed May 04 2016, Adrian Zubarev &lt;swift-evolution at swift.org&gt;<br>&gt;         wrote:<br>&gt;<br>&gt;         Not sure what to think about the enum cases inside a<br>&gt;         protocol (if AnyEnum would<br>&gt;         even exist), it could be a nice addition to the language, but<br>&gt;         this is an own<br>&gt;         proposal I guess.<br>&gt;<br>&gt;         We should start by adding AnyValue protocol to which all value<br>&gt;         types<br>&gt;         conforms.<br>&gt;<br>&gt;         Having a way to constrain conformance to things with value semantics<br>&gt;         is<br>&gt;         something I&#39;ve long wanted. *However*, the approach described is too<br>&gt;         simplistic. It&#39;s possible to build classes whose instances have<br>&gt;         value<br>&gt;         semantics (just make them immutable) and it&#39;s possible to build<br>&gt;         structs<br>&gt;         whose instances have reference semantics (just put the struct&#39;s<br>&gt;         storage<br>&gt;         in a mutable class instance that it holds as a property, and don&#39;t<br>&gt;         do<br>&gt;         copy-on-write). <br>&gt;<br>&gt;         In order for something like AnyValue to have meaning, we need to<br>&gt;         impose<br>&gt;         greater order. After thinking through many approaches over the<br>&gt;         years, I<br>&gt;         have arrived at the (admittedly rather drastic) opinion that the<br>&gt;         language should effectively outlaw the creation of structs and enums<br>&gt;         that don&#39;t have value semantics. (I have no problem with the idea<br>&gt;         that<br>&gt;         immutable classes that want to act as values should be wrapped in a<br>&gt;         struct). The language could then do lots of things much more<br>&gt;         intelligently, such as correctly generating implementations of<br>&gt;         equality.<br>&gt;<br>&gt;         That is a drastic solution indeed! How would this impact things like<br>&gt;         Array&lt;UIView&gt;? While Array itself has value semantics, the aggregate<br>&gt;         obviously does not as it contains references which usually be mutated<br>&gt;         underneath us. <br>&gt;<br>&gt;         Value semantics and mutation can only be measured with respect to<br>&gt;         equality. The definition of == for all class types would be equivalent<br>&gt;         to ===. Problem solved.<br>&gt;<br>&gt;         Similar considerations apply to simpler wrapper structs such as Weak.<br>&gt;<br>&gt;         Same answer.<br>&gt;<br>&gt;         Hmm. If those qualify as “value semantic” then what kind of structs and<br>&gt;         enums<br>&gt;         would not? A struct wrapping a mutable reference type certainly doesn’t<br>&gt;         “feel”<br>&gt;         value semantic to me and certainly doesn’t have the guarantees usually<br>&gt;         associated with value semantics (won’t mutate behind your back, thread<br>&gt;         safe,<br>&gt;         etc).<br>&gt;<br>&gt;     Sure it does.<br>&gt;<br>&gt;     public struct Wrap&lt;T: AnyObject&gt; : Equatable {<br>&gt;     init(_ x: T) { self.x = x }<br>&gt;     private x: T<br>&gt;     }<br>&gt;<br>&gt;     func == &lt;T&gt;(lhs: Wrap&lt;T&gt;, rhs: Wrap&lt;T&gt;) -&gt; Bool {<br>&gt;     return lhs.x === rhs.x<br>&gt;     }<br>&gt;<br>&gt;     I defy you to find any scenario where Wrap&lt;T&gt; doesn&#39;t have value<br>&gt;     semantics, whether T is mutable or not.<br>&gt;<br>&gt;     Alternately, you can look at the Array implementation. Array is a<br>&gt;     struct wrapping a mutable class. It has value semantics by virtue of<br>&gt;     CoW.<br>&gt;<br>&gt; This goes back to where you draw the line as to the “boundary of the value”.<br>&gt; Wrap and Array are “value semantic” in a shallow sense and are capable of deep<br>&gt; value semantics when T is deeply value semantic. <br></p><p>No, I&#39;m sorry; this “deep-vs-shallow” thing is a fallacy that comes from<br>not understanding the boundaries of your value.  Or, put more<br>solicitously: sure, you can look at the world that way, but it just<br>makes everything prohibitively complicated, so why would you want to?<br></p><p>In my world, there&#39;s no such thing as a “deep copy” or a “shallow copy;”<br>there&#39;s just “copy,” which logically creates an independent version of<br>everything up to the boundaries of the value.  Likewise, there&#39;s no<br>“deep value semantics” or “shallow value semantics.”  Equality defines<br>value semantics, and the boundaries of an Array value always includes<br>the values of its elements.  The *only* problem here is that we have no<br>way to do equality comparison on some arrays because some types aren&#39;t<br>Equatable.  IMO the costs of not having everything be equatable, in<br>complexity-of-programming-model terms, are too high.<br></p><p>&gt; Both have their place, but the maximum benefit of value semantics<br>&gt; (purity) <br></p><p>I don&#39;t know what definition of purity you&#39;re using.  The only one I<br>know of applies to functions and implies no side effects.  In that<br>world, there is no mutation and value semantics is equivalent to<br>reference semantics.<br></p><p>&gt; is derived from deep value semantics. This is when there is no<br>&gt; possibility of shared mutable state. This is an extremely important<br>&gt; property.<br></p><p>It&#39;s the wrong property, IMO.<br></p><p>&gt;<br>&gt; let t = MyClass()<br>&gt; foo.acceptWrapped(Wrap(t))<br>&gt; t.mutate()<br>&gt;<br>&gt; In this example, foo had better not depend on the wrapped instance not getting<br>&gt; mutated.<br></p><p>foo has no way to get at the wrapped instance, so it can&#39;t depend on<br>anything about it.<br></p><p>&gt;         My expectation is a generic aggregate such as Array would have to<br>&gt;         conditionally conform to AnyValue only when Element also conforms to<br>&gt;         AnyValue.<br>&gt;<br>&gt;         I’m also wondering how such a rule would be implemented while still<br>&gt;         allowing for CoW structs that *do* implement value semantics, but do<br>&gt;         so while using references internally.<br>&gt;<br>&gt;         I am not talking about any kind of statically-enforceable rule, although<br>&gt;         we could probably make warnings sophisticated enough to help with this.<br>&gt;<br>&gt;         You said the you have arrived at the opinion that the language should<br>&gt;         “effectively outlaw” structs and enums that do not have value semantics.<br>&gt;         That<br>&gt;         sounded like static enforcement to me. <br>&gt;<br>&gt;     The language outlaws certain kinds of inout aliasing without<br>&gt;     providing static enforcement. This is like that.<br>&gt;<br>&gt; I did not know this. Now you have me curious. Can you give an example of where<br>&gt; we are able to violate law? I ask mostly because it sounds like there is a<br>&gt; possibility of stumbling into dangerous territory, possibly without being aware<br>&gt; that you have done so.<br></p><p>See “In-out Parameters” in<br>https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/doc/uid/TP40014097-CH34-ID362<br></p><p>&gt;         Maybe you meant we should allow the compiler to assume value semantics<br>&gt;         for structs and enums despite the fact that it doesn’t statically<br>&gt;         enforce this?<br>&gt;<br>&gt;     That would be one *consequence* of effectively outlawing it. The library<br>&gt;     could make similar assumptions.<br>&gt;<br>&gt;         If the compiler can be sophisticated enough to verify value semantics<br>&gt;         statically maybe it would be better to have that mechanism be<br>&gt;         triggered by conformance to AnyValue rather than for all structs and<br>&gt;         enums. Types that conform to AnyValue would receive the benefits of<br>&gt;         the compiler knowing they have value semantics, while other uses of<br>&gt;         structs and enums would remain valid. Best practice would be to<br>&gt;         conform structs and enums to AnyValue whenever possible.<br>&gt;<br>&gt;         Another possible advantage of this approach would be allowing<br>&gt;         immutable reference types to conform to AnyValue and receive the<br>&gt;         associated benefits such as the generated implementation of equality,<br>&gt;         etc.<br>&gt;<br>&gt;         -Matthew<br>&gt;<br>&gt;         -- <br>&gt;         Dave<br>&gt;<br>&gt;         _______________________________________________<br>&gt;         swift-evolution mailing list<br>&gt;         swift-evolution at swift.org<br>&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;         _______________________________________________<br>&gt;         swift-evolution mailing list<br>&gt;         swift-evolution at swift.org<br>&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;         -- <br>&gt;         Dave<br>&gt;<br>&gt;         _______________________________________________<br>&gt;         swift-evolution mailing list<br>&gt;         swift-evolution at swift.org<br>&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;     -- <br>&gt;     Dave<br>&gt;<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May  5, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On May 5, 2016, at 10:02 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Thu May 05 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;    On May 5, 2016, at 4:59 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;    on Wed May 04 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;        On May 4, 2016, at 5:50 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;        &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;        on Wed May 04 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;        On May 4, 2016, at 1:29 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;        &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;        on Wed May 04 2016, Adrian Zubarev &lt;swift-evolution at swift.org&gt;<br>&gt;&gt;        wrote:<br>&gt;&gt; <br>&gt;&gt;        Not sure what to think about the enum cases inside a<br>&gt;&gt;        protocol (if AnyEnum would<br>&gt;&gt;        even exist), it could be a nice addition to the language, but<br>&gt;&gt;        this is an own<br>&gt;&gt;        proposal I guess.<br>&gt;&gt; <br>&gt;&gt;        We should start by adding AnyValue protocol to which all value<br>&gt;&gt;        types<br>&gt;&gt;        conforms.<br>&gt;&gt; <br>&gt;&gt;        Having a way to constrain conformance to things with value semantics<br>&gt;&gt;        is<br>&gt;&gt;        something I&#39;ve long wanted. *However*, the approach described is too<br>&gt;&gt;        simplistic. It&#39;s possible to build classes whose instances have<br>&gt;&gt;        value<br>&gt;&gt;        semantics (just make them immutable) and it&#39;s possible to build<br>&gt;&gt;        structs<br>&gt;&gt;        whose instances have reference semantics (just put the struct&#39;s<br>&gt;&gt;        storage<br>&gt;&gt;        in a mutable class instance that it holds as a property, and don&#39;t<br>&gt;&gt;        do<br>&gt;&gt;        copy-on-write). <br>&gt;&gt; <br>&gt;&gt;        In order for something like AnyValue to have meaning, we need to<br>&gt;&gt;        impose<br>&gt;&gt;        greater order. After thinking through many approaches over the<br>&gt;&gt;        years, I<br>&gt;&gt;        have arrived at the (admittedly rather drastic) opinion that the<br>&gt;&gt;        language should effectively outlaw the creation of structs and enums<br>&gt;&gt;        that don&#39;t have value semantics. (I have no problem with the idea<br>&gt;&gt;        that<br>&gt;&gt;        immutable classes that want to act as values should be wrapped in a<br>&gt;&gt;        struct). The language could then do lots of things much more<br>&gt;&gt;        intelligently, such as correctly generating implementations of<br>&gt;&gt;        equality.<br>&gt;&gt; <br>&gt;&gt;        That is a drastic solution indeed! How would this impact things like<br>&gt;&gt;        Array&lt;UIView&gt;? While Array itself has value semantics, the aggregate<br>&gt;&gt;        obviously does not as it contains references which usually be mutated<br>&gt;&gt;        underneath us. <br>&gt;&gt; <br>&gt;&gt;        Value semantics and mutation can only be measured with respect to<br>&gt;&gt;        equality. The definition of == for all class types would be equivalent<br>&gt;&gt;        to ===. Problem solved.<br>&gt;&gt; <br>&gt;&gt;        Similar considerations apply to simpler wrapper structs such as Weak.<br>&gt;&gt; <br>&gt;&gt;        Same answer.<br>&gt;&gt; <br>&gt;&gt;        Hmm. If those qualify as “value semantic” then what kind of structs and<br>&gt;&gt;        enums<br>&gt;&gt;        would not? A struct wrapping a mutable reference type certainly doesn’t<br>&gt;&gt;        “feel”<br>&gt;&gt;        value semantic to me and certainly doesn’t have the guarantees usually<br>&gt;&gt;        associated with value semantics (won’t mutate behind your back, thread<br>&gt;&gt;        safe,<br>&gt;&gt;        etc).<br>&gt;&gt; <br>&gt;&gt;    Sure it does.<br>&gt;&gt; <br>&gt;&gt;    public struct Wrap&lt;T: AnyObject&gt; : Equatable {<br>&gt;&gt;    init(_ x: T) { self.x = x }<br>&gt;&gt;    private x: T<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    func == &lt;T&gt;(lhs: Wrap&lt;T&gt;, rhs: Wrap&lt;T&gt;) -&gt; Bool {<br>&gt;&gt;    return lhs.x === rhs.x<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    I defy you to find any scenario where Wrap&lt;T&gt; doesn&#39;t have value<br>&gt;&gt;    semantics, whether T is mutable or not.<br>&gt;&gt; <br>&gt;&gt;    Alternately, you can look at the Array implementation. Array is a<br>&gt;&gt;    struct wrapping a mutable class. It has value semantics by virtue of<br>&gt;&gt;    CoW.<br>&gt;&gt; <br>&gt;&gt; This goes back to where you draw the line as to the “boundary of the value”.<br>&gt;&gt; Wrap and Array are “value semantic” in a shallow sense and are capable of deep<br>&gt;&gt; value semantics when T is deeply value semantic. <br>&gt; <br>&gt; No, I&#39;m sorry; this “deep-vs-shallow” thing is a fallacy that comes from<br>&gt; not understanding the boundaries of your value.  Or, put more<br>&gt; solicitously: sure, you can look at the world that way, but it just<br>&gt; makes everything prohibitively complicated, so why would you want to?<br>&gt; <br>&gt; In my world, there&#39;s no such thing as a “deep copy” or a “shallow copy;”<br>&gt; there&#39;s just “copy,” which logically creates an independent version of<br>&gt; everything up to the boundaries of the value.  Likewise, there&#39;s no<br>&gt; “deep value semantics” or “shallow value semantics.”  <br>&gt; Equality defines<br>&gt; value semantics, and the boundaries of an Array value always includes<br>&gt; the values of its elements.  The *only* problem here is that we have no<br>&gt; way to do equality comparison on some arrays because some types aren&#39;t<br>&gt; Equatable.  IMO the costs of not having everything be equatable, in<br>&gt; complexity-of-programming-model terms, are too high.<br></p><p>Thank you for clarifying the terminology for me.  This is helpful.  <br></p><p>I think I may have misunderstood what you meant by “boundary of the value”.  Do you mean that the boundary of an Array value stops at the reference identity for elements with reference semantics?  If you have an Array whose elements are of an immutable reference type that has value semantics would you say the boundary extends past the reference identity of an element and includes a definition of equality defined by that type?<br></p><p>Are you arguing that reference types should be equatable by default, using equality of the reference if the type does not provide a custom definition of equality?<br></p><p>&gt; <br>&gt;&gt; Both have their place, but the maximum benefit of value semantics<br>&gt;&gt; (purity) <br>&gt; <br>&gt; I don&#39;t know what definition of purity you&#39;re using.  The only one I<br>&gt; know of applies to functions and implies no side effects.  In that<br>&gt; world, there is no mutation and value semantics is equivalent to<br>&gt; reference semantics.<br></p><p>I was using it in the sense of “PureValue” as discussed in this thread.  I was using it to mean values for which no *observable* mutation is possible (allowing for CoW, etc).  Is there a better term for this than purity?<br></p><p>&gt; <br>&gt;&gt; is derived from deep value semantics. This is when there is no<br>&gt;&gt; possibility of shared mutable state. This is an extremely important<br>&gt;&gt; property.<br>&gt; <br>&gt; It&#39;s the wrong property, IMO.<br></p><p>Wrong in what sense?  I don’t mean to imply that it is the *only* valuable property.  However, it I (and many others) do believe it is an extremely valuable property in many cases.  Do you disagree?<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; let t = MyClass()<br>&gt;&gt; foo.acceptWrapped(Wrap(t))<br>&gt;&gt; t.mutate()<br>&gt;&gt; <br>&gt;&gt; In this example, foo had better not depend on the wrapped instance not getting<br>&gt;&gt; mutated.<br>&gt; <br>&gt; foo has no way to get at the wrapped instance, so it can&#39;t depend on<br>&gt; anything about it.<br></p><p>Ok, but this is a toy example.  What is the purpose of Wrap?  Maybe foo passes the wrapped instance back to code that *does* have visibility to the instance.  My point was that shared mutable state is still possible here.  <br></p><p>&gt; <br>&gt;&gt;        My expectation is a generic aggregate such as Array would have to<br>&gt;&gt;        conditionally conform to AnyValue only when Element also conforms to<br>&gt;&gt;        AnyValue.<br>&gt;&gt; <br>&gt;&gt;        I’m also wondering how such a rule would be implemented while still<br>&gt;&gt;        allowing for CoW structs that *do* implement value semantics, but do<br>&gt;&gt;        so while using references internally.<br>&gt;&gt; <br>&gt;&gt;        I am not talking about any kind of statically-enforceable rule, although<br>&gt;&gt;        we could probably make warnings sophisticated enough to help with this.<br>&gt;&gt; <br>&gt;&gt;        You said the you have arrived at the opinion that the language should<br>&gt;&gt;        “effectively outlaw” structs and enums that do not have value semantics.<br>&gt;&gt;        That<br>&gt;&gt;        sounded like static enforcement to me. <br>&gt;&gt; <br>&gt;&gt;    The language outlaws certain kinds of inout aliasing without<br>&gt;&gt;    providing static enforcement. This is like that.<br>&gt;&gt; <br>&gt;&gt; I did not know this. Now you have me curious. Can you give an example of where<br>&gt;&gt; we are able to violate law? I ask mostly because it sounds like there is a<br>&gt;&gt; possibility of stumbling into dangerous territory, possibly without being aware<br>&gt;&gt; that you have done so.<br>&gt; <br>&gt; See “In-out Parameters” in<br>&gt; https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/doc/uid/TP40014097-CH34-ID362 &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/doc/uid/TP40014097-CH34-ID362&gt;<br>&gt; <br>&gt;&gt;        Maybe you meant we should allow the compiler to assume value semantics<br>&gt;&gt;        for structs and enums despite the fact that it doesn’t statically<br>&gt;&gt;        enforce this?<br>&gt;&gt; <br>&gt;&gt;    That would be one *consequence* of effectively outlawing it. The library<br>&gt;&gt;    could make similar assumptions.<br>&gt;&gt; <br>&gt;&gt;        If the compiler can be sophisticated enough to verify value semantics<br>&gt;&gt;        statically maybe it would be better to have that mechanism be<br>&gt;&gt;        triggered by conformance to AnyValue rather than for all structs and<br>&gt;&gt;        enums. Types that conform to AnyValue would receive the benefits of<br>&gt;&gt;        the compiler knowing they have value semantics, while other uses of<br>&gt;&gt;        structs and enums would remain valid. Best practice would be to<br>&gt;&gt;        conform structs and enums to AnyValue whenever possible.<br>&gt;&gt; <br>&gt;&gt;        Another possible advantage of this approach would be allowing<br>&gt;&gt;        immutable reference types to conform to AnyValue and receive the<br>&gt;&gt;        associated benefits such as the generated implementation of equality,<br>&gt;&gt;        etc.<br>&gt;&gt; <br>&gt;&gt;        -Matthew<br>&gt;&gt; <br>&gt;&gt;        -- <br>&gt;&gt;        Dave<br>&gt;&gt; <br>&gt;&gt;        _______________________________________________<br>&gt;&gt;        swift-evolution mailing list<br>&gt;&gt;        swift-evolution at swift.org<br>&gt;&gt;        https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt;        _______________________________________________<br>&gt;&gt;        swift-evolution mailing list<br>&gt;&gt;        swift-evolution at swift.org<br>&gt;&gt;        https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt;        -- <br>&gt;&gt;        Dave<br>&gt;&gt; <br>&gt;&gt;        _______________________________________________<br>&gt;&gt;        swift-evolution mailing list<br>&gt;&gt;        swift-evolution at swift.org<br>&gt;&gt;        https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt;    -- <br>&gt;&gt;    Dave<br>&gt;&gt; <br>&gt; <br>&gt; -- <br>&gt; Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160505/a8137eac/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>May  7, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On May 5, 2016, at 8:02 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Thu May 05 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;    On May 5, 2016, at 4:59 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;    on Wed May 04 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;        On May 4, 2016, at 5:50 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;        &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;        on Wed May 04 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;        On May 4, 2016, at 1:29 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;        &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;        on Wed May 04 2016, Adrian Zubarev &lt;swift-evolution at swift.org&gt;<br>&gt;&gt;        wrote:<br>&gt;&gt; <br>&gt;&gt;        Not sure what to think about the enum cases inside a<br>&gt;&gt;        protocol (if AnyEnum would<br>&gt;&gt;        even exist), it could be a nice addition to the language, but<br>&gt;&gt;        this is an own<br>&gt;&gt;        proposal I guess.<br>&gt;&gt; <br>&gt;&gt;        We should start by adding AnyValue protocol to which all value<br>&gt;&gt;        types<br>&gt;&gt;        conforms.<br>&gt;&gt; <br>&gt;&gt;        Having a way to constrain conformance to things with value semantics<br>&gt;&gt;        is<br>&gt;&gt;        something I&#39;ve long wanted. *However*, the approach described is too<br>&gt;&gt;        simplistic. It&#39;s possible to build classes whose instances have<br>&gt;&gt;        value<br>&gt;&gt;        semantics (just make them immutable) and it&#39;s possible to build<br>&gt;&gt;        structs<br>&gt;&gt;        whose instances have reference semantics (just put the struct&#39;s<br>&gt;&gt;        storage<br>&gt;&gt;        in a mutable class instance that it holds as a property, and don&#39;t<br>&gt;&gt;        do<br>&gt;&gt;        copy-on-write). <br>&gt;&gt; <br>&gt;&gt;        In order for something like AnyValue to have meaning, we need to<br>&gt;&gt;        impose<br>&gt;&gt;        greater order. After thinking through many approaches over the<br>&gt;&gt;        years, I<br>&gt;&gt;        have arrived at the (admittedly rather drastic) opinion that the<br>&gt;&gt;        language should effectively outlaw the creation of structs and enums<br>&gt;&gt;        that don&#39;t have value semantics. (I have no problem with the idea<br>&gt;&gt;        that<br>&gt;&gt;        immutable classes that want to act as values should be wrapped in a<br>&gt;&gt;        struct). The language could then do lots of things much more<br>&gt;&gt;        intelligently, such as correctly generating implementations of<br>&gt;&gt;        equality.<br>&gt;&gt; <br>&gt;&gt;        That is a drastic solution indeed! How would this impact things like<br>&gt;&gt;        Array&lt;UIView&gt;? While Array itself has value semantics, the aggregate<br>&gt;&gt;        obviously does not as it contains references which usually be mutated<br>&gt;&gt;        underneath us. <br>&gt;&gt; <br>&gt;&gt;        Value semantics and mutation can only be measured with respect to<br>&gt;&gt;        equality. The definition of == for all class types would be equivalent<br>&gt;&gt;        to ===. Problem solved.<br>&gt;&gt; <br>&gt;&gt;        Similar considerations apply to simpler wrapper structs such as Weak.<br>&gt;&gt; <br>&gt;&gt;        Same answer.<br>&gt;&gt; <br>&gt;&gt;        Hmm. If those qualify as “value semantic” then what kind of structs and<br>&gt;&gt;        enums<br>&gt;&gt;        would not? A struct wrapping a mutable reference type certainly doesn’t<br>&gt;&gt;        “feel”<br>&gt;&gt;        value semantic to me and certainly doesn’t have the guarantees usually<br>&gt;&gt;        associated with value semantics (won’t mutate behind your back, thread<br>&gt;&gt;        safe,<br>&gt;&gt;        etc).<br>&gt;&gt; <br>&gt;&gt;    Sure it does.<br>&gt;&gt; <br>&gt;&gt;    public struct Wrap&lt;T: AnyObject&gt; : Equatable {<br>&gt;&gt;    init(_ x: T) { self.x = x }<br>&gt;&gt;    private x: T<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    func == &lt;T&gt;(lhs: Wrap&lt;T&gt;, rhs: Wrap&lt;T&gt;) -&gt; Bool {<br>&gt;&gt;    return lhs.x === rhs.x<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    I defy you to find any scenario where Wrap&lt;T&gt; doesn&#39;t have value<br>&gt;&gt;    semantics, whether T is mutable or not.<br>&gt;&gt; <br>&gt;&gt;    Alternately, you can look at the Array implementation. Array is a<br>&gt;&gt;    struct wrapping a mutable class. It has value semantics by virtue of<br>&gt;&gt;    CoW.<br>&gt;&gt; <br>&gt;&gt; This goes back to where you draw the line as to the “boundary of the value”.<br>&gt;&gt; Wrap and Array are “value semantic” in a shallow sense and are capable of deep<br>&gt;&gt; value semantics when T is deeply value semantic. <br>&gt; <br>&gt; No, I&#39;m sorry; this “deep-vs-shallow” thing is a fallacy that comes from<br>&gt; not understanding the boundaries of your value.  Or, put more<br>&gt; solicitously: sure, you can look at the world that way, but it just<br>&gt; makes everything prohibitively complicated, so why would you want to?<br>&gt; <br>&gt; In my world, there&#39;s no such thing as a “deep copy” or a “shallow copy;”<br>&gt; there&#39;s just “copy,” which logically creates an independent version of<br>&gt; everything up to the boundaries of the value.  Likewise, there&#39;s no<br>&gt; “deep value semantics” or “shallow value semantics.”  Equality defines<br>&gt; value semantics, and the boundaries of an Array value always includes<br>&gt; the values of its elements.  The *only* problem here is that we have no<br>&gt; way to do equality comparison on some arrays because some types aren&#39;t<br>&gt; Equatable.  IMO the costs of not having everything be equatable, in<br>&gt; complexity-of-programming-model terms, are too high.<br></p><p>My point with this is, in case I was a bit rambling, if you’re going to draw boundaries around a value, for the purpose of copying or immutability, then equality should always match with those boundaries. As you say, “Equality defines value semantics, and the boundaries of an Array value always includes the values of its elements.”<br></p><p>Under this reasoning, custom equality violates these boundaries. And without custom equality, equality checks on reference types are essentially useless. But maybe value types in Swift are powerful enough where this doesn’t matter.<br></p><p><br>&gt; <br>&gt;&gt; Both have their place, but the maximum benefit of value semantics<br>&gt;&gt; (purity) <br>&gt; <br>&gt; I don&#39;t know what definition of purity you&#39;re using.  The only one I<br>&gt; know of applies to functions and implies no side effects.  In that<br>&gt; world, there is no mutation and value semantics is equivalent to<br>&gt; reference semantics.<br>&gt; <br>&gt;&gt; is derived from deep value semantics. This is when there is no<br>&gt;&gt; possibility of shared mutable state. This is an extremely important<br>&gt;&gt; property.<br>&gt; <br>&gt; It&#39;s the wrong property, IMO.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; let t = MyClass()<br>&gt;&gt; foo.acceptWrapped(Wrap(t))<br>&gt;&gt; t.mutate()<br>&gt;&gt; <br>&gt;&gt; In this example, foo had better not depend on the wrapped instance not getting<br>&gt;&gt; mutated.<br>&gt; <br>&gt; foo has no way to get at the wrapped instance, so it can&#39;t depend on<br>&gt; anything about it.<br>&gt; <br>&gt;&gt;        My expectation is a generic aggregate such as Array would have to<br>&gt;&gt;        conditionally conform to AnyValue only when Element also conforms to<br>&gt;&gt;        AnyValue.<br>&gt;&gt; <br>&gt;&gt;        I’m also wondering how such a rule would be implemented while still<br>&gt;&gt;        allowing for CoW structs that *do* implement value semantics, but do<br>&gt;&gt;        so while using references internally.<br>&gt;&gt; <br>&gt;&gt;        I am not talking about any kind of statically-enforceable rule, although<br>&gt;&gt;        we could probably make warnings sophisticated enough to help with this.<br>&gt;&gt; <br>&gt;&gt;        You said the you have arrived at the opinion that the language should<br>&gt;&gt;        “effectively outlaw” structs and enums that do not have value semantics.<br>&gt;&gt;        That<br>&gt;&gt;        sounded like static enforcement to me. <br>&gt;&gt; <br>&gt;&gt;    The language outlaws certain kinds of inout aliasing without<br>&gt;&gt;    providing static enforcement. This is like that.<br>&gt;&gt; <br>&gt;&gt; I did not know this. Now you have me curious. Can you give an example of where<br>&gt;&gt; we are able to violate law? I ask mostly because it sounds like there is a<br>&gt;&gt; possibility of stumbling into dangerous territory, possibly without being aware<br>&gt;&gt; that you have done so.<br>&gt; <br>&gt; See “In-out Parameters” in<br>&gt; https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/doc/uid/TP40014097-CH34-ID362 &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/doc/uid/TP40014097-CH34-ID362&gt;<br>&gt; <br>&gt;&gt;        Maybe you meant we should allow the compiler to assume value semantics<br>&gt;&gt;        for structs and enums despite the fact that it doesn’t statically<br>&gt;&gt;        enforce this?<br>&gt;&gt; <br>&gt;&gt;    That would be one *consequence* of effectively outlawing it. The library<br>&gt;&gt;    could make similar assumptions.<br>&gt;&gt; <br>&gt;&gt;        If the compiler can be sophisticated enough to verify value semantics<br>&gt;&gt;        statically maybe it would be better to have that mechanism be<br>&gt;&gt;        triggered by conformance to AnyValue rather than for all structs and<br>&gt;&gt;        enums. Types that conform to AnyValue would receive the benefits of<br>&gt;&gt;        the compiler knowing they have value semantics, while other uses of<br>&gt;&gt;        structs and enums would remain valid. Best practice would be to<br>&gt;&gt;        conform structs and enums to AnyValue whenever possible.<br>&gt;&gt; <br>&gt;&gt;        Another possible advantage of this approach would be allowing<br>&gt;&gt;        immutable reference types to conform to AnyValue and receive the<br>&gt;&gt;        associated benefits such as the generated implementation of equality,<br>&gt;&gt;        etc.<br>&gt;&gt; <br>&gt;&gt;        -Matthew<br>&gt;&gt; <br>&gt;&gt;        -- <br>&gt;&gt;        Dave<br>&gt;&gt; <br>&gt;&gt;        _______________________________________________<br>&gt;&gt;        swift-evolution mailing list<br>&gt;&gt;        swift-evolution at swift.org<br>&gt;&gt;        https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt;        _______________________________________________<br>&gt;&gt;        swift-evolution mailing list<br>&gt;&gt;        swift-evolution at swift.org<br>&gt;&gt;        https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt;        -- <br>&gt;&gt;        Dave<br>&gt;&gt; <br>&gt;&gt;        _______________________________________________<br>&gt;&gt;        swift-evolution mailing list<br>&gt;&gt;        swift-evolution at swift.org<br>&gt;&gt;        https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt;    -- <br>&gt;&gt;    Dave<br>&gt;&gt; <br>&gt; <br>&gt; -- <br>&gt; Dave<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160507/9694d02f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May  7, 2016 at 10:00:00am</p></header><div class="content"><p>For me and my English its become hard to follow where this is going right now.<br></p><p>Let’s stick with my `AnyReference` and `AnyValue` protocols just for the example.<br></p><p>Do I get your intention right that we discuss here about value types that are constructed from their deepest only from other value types (same for `PureReferences`)? That’s what my understanding is for `PureValue`.<br></p><p>                   +-----+<br>                   | Any |<br>                   +--+--+<br>                      |<br>        +-------------+-------------+<br>        |                           |<br> +------+-------+             +-----+----+<br> | AnyReference |             | AnyValue |<br> +--+---+-------+             +-----+----+<br>    |   |                           |<br>+-------+-------+             +-----+-----+ <br>| PureReference |             | PureValue | <br>+---------------+             +-----+-----+ <br>    |<br>+---+--------------+ <br>| AnyObject (ObjC) | <br>+------------------+<br></p><p>Side note: If SE-0083 will be accepted it might be possible that @objc will be dropped from `AnyObject`, correct me if I&#39;m wrong.<br></p><p>I&#39;m fine with that if that’s the case, but I&#39;m not if one-day Swift won&#39;t allow anymore to mix value types with reference types.<br></p><p>I also don&#39;t think that `PureReference` and `PureValue` protocols could be implicit, but their base protocols can.<br></p><p>Explicit usage of these protocols on actual types:<br></p><p>class A: PureValue {} // won&#39;t work<br></p><p>class B: PureReference {<br>	var value: OtherClass<br>} // can only contain only reference types (if that’s what we&#39;ve been talking about here)<br></p><p>struct C: PureReference {} // won&#39;t work<br></p><p>struct D: PureValue {<br>	var value: Int<br>} // can only contain value types, and all value types inside follow the same rule<br></p><p>Explicit usage on protocols:<br></p><p>protocol E: SomeOtherProtocol, PureReference {} // shouldn&#39;t work, because if we want to replace the `class` keyword we should at least the rule that out constraint protocols should sit right behind `: ` or behind Any(Reference/Value) which will take the first place instead.<br></p><p>protocol F: PureReference {<br>	var value: SomeClass { get }<br>} // can only be applied to types that follow the pure reference constraint + SomeClass should follow the pure reference rule<br></p><p>protocol G: F {} // same as F<br></p><p>protocol H: SomeOtherProtocol, PureValue {} // same problem as with E<br></p><p>protocol I: PureValue {<br>	var value: Int<br>	func foo() -&gt; Int<br>} // same rule as with class D<br></p><p>protocol J: PureValue {<br>	var value: SomeClass<br>} // should not work<br></p><p>protocol K: PureValue {<br>	func foo() -&gt; SomeClass<br>} // I guess this should not work!?<br></p><p>protocol L: PureReference {<br>	func foo() -&gt; Int<br>} // should this work?<br></p><p>protocol M: PureReference {<br>	func foo() -&gt; SomeClass<br>} // like F<br></p><p>Implicit usage of the Any protocols:<br></p><p>class N {<br>	var value: SomeValue<br>	var anotherValue: SomeClass<br>	func foo() -&gt; Int<br>	func boo() -&gt; AClass<br>} // implicitly AnyReference; SomeClass can follow PureReference rule but still can be nested into a AnyClass or AnyValue type (same goes for SomeValue)<br></p><p>struct O {<br>	var value: SomeValue<br>	var anotherValue: SomeClass<br>	func foo() -&gt; Int<br>	func boo() -&gt; AClass<br>} // implicitly AnyValue; same rules as for N<br></p><p>Explicit protocol constrains:<br></p><p>protocol P: AnyValue, PureValue {} // or just PureValue<br></p><p>protocol Q: AnyReference, PureReference {} or just PureReference<br></p><p>protocol R: AnyValue {} // This protocol is problematic now, because logically we could apply it to a PureValue type but this shouldn’t work, just because we said that PureProtocols are more constrained<br></p><p>Now we have two options:<br></p><p>1. Split the Any and Pure concepts<br></p><p>                  +------+<br>                  | Pure |<br>                  +--+---+<br>                     |<br>       +-------------+-------------+<br>       |                           |<br>+------+--------+            +-----+-----+<br>| PureReference |            | PureValue |<br>+---------------+            +-----+-----+<br></p><p>                  +-----+<br>                  | Any |<br>                  +--+--+<br>                     |<br>       +-------------+------------+<br>       |                          |<br>+------+-------+            +-----+----+<br>| AnyReference |            | AnyValue |<br>+--------------+            +-----+----+<br></p><p>This solution feels strange. `Pure` is something like `AnyPure`.<br></p><p>2. Reorder Pure and Any protocols:<br></p><p>                  +-----+<br>                  | Any |<br>                  +--+--+<br>                     |<br>       +-------------+-------------+<br>       |                           |<br>+------+--------+            +-----+-----+<br>| PureReference |            | PureValue |<br>+------+--------+            +-----+-----+<br>       |                           |<br>+------+-------+             +-----+----+ <br>| AnyReference |             | AnyValue | <br>+--------------+             +-----+----+ <br></p><p>protocol R: AnyValue {} // is fine now because we can&#39;t apply it to a PureValue anymore.<br></p><p>With this reorder I suggest that `PureValue` and `PureReference` also becomes implicit protocols, BUT all existing types should be implicitly `AnyReference` or `AnyValue` where the strict rule from `PureProtocols` is ignored/disabled. To use the constraints of pure protocols should require its explicit usage.<br></p><p>Does this make any sense to you or am I totally wrong here?<br></p><p>What I’d prefer could look like this:<br></p><p>                  +-----+<br>                  | Any |<br>                  +--+--+<br>                     |<br>       +-------------+------------+<br>       |                          |<br>+------+-------+            +-----+----+<br>| AnyReference |            | AnyValue |<br>+--------------+            +-----+----+<br></p><p>pure protocol A: AnyReference {}<br>pure class B: A {}<br></p><p>I&#39;m not sure why this topic become so complicated where we only discussed about dropping the `class` keyword from protocols and I suggested to use implicit protocols instead, where we need at least one more for value types (I&#39;m fine with `AnyObject` as long it won&#39;t bridge to ObjC types anymore, but I&#39;d rename it for possible new reference type in the future of Swift).<br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 7. Mai 2016 bei 09:56:24, Tyler Fleming Cloutier via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p><br>On May 5, 2016, at 8:02 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p><br>on Thu May 05 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br></p><p>   On May 5, 2016, at 4:59 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br></p><p>   on Wed May 04 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br></p><p>       On May 4, 2016, at 5:50 PM, Dave Abrahams via swift-evolution<br>       &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>       on Wed May 04 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>       On May 4, 2016, at 1:29 PM, Dave Abrahams via swift-evolution<br>       &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>       on Wed May 04 2016, Adrian Zubarev &lt;swift-evolution at swift.org&gt;<br>       wrote:<br></p><p>       Not sure what to think about the enum cases inside a<br>       protocol (if AnyEnum would<br>       even exist), it could be a nice addition to the language, but<br>       this is an own<br>       proposal I guess.<br></p><p>       We should start by adding AnyValue protocol to which all value<br>       types<br>       conforms.<br></p><p>       Having a way to constrain conformance to things with value semantics<br>       is<br>       something I&#39;ve long wanted. *However*, the approach described is too<br>       simplistic. It&#39;s possible to build classes whose instances have<br>       value<br>       semantics (just make them immutable) and it&#39;s possible to build<br>       structs<br>       whose instances have reference semantics (just put the struct&#39;s<br>       storage<br>       in a mutable class instance that it holds as a property, and don&#39;t<br>       do<br>       copy-on-write). <br></p><p>       In order for something like AnyValue to have meaning, we need to<br>       impose<br>       greater order. After thinking through many approaches over the<br>       years, I<br>       have arrived at the (admittedly rather drastic) opinion that the<br>       language should effectively outlaw the creation of structs and enums<br>       that don&#39;t have value semantics. (I have no problem with the idea<br>       that<br>       immutable classes that want to act as values should be wrapped in a<br>       struct). The language could then do lots of things much more<br>       intelligently, such as correctly generating implementations of<br>       equality.<br></p><p>       That is a drastic solution indeed! How would this impact things like<br>       Array&lt;UIView&gt;? While Array itself has value semantics, the aggregate<br>       obviously does not as it contains references which usually be mutated<br>       underneath us. <br></p><p>       Value semantics and mutation can only be measured with respect to<br>       equality. The definition of == for all class types would be equivalent<br>       to ===. Problem solved.<br></p><p>       Similar considerations apply to simpler wrapper structs such as Weak.<br></p><p>       Same answer.<br></p><p>       Hmm. If those qualify as “value semantic” then what kind of structs and<br>       enums<br>       would not? A struct wrapping a mutable reference type certainly doesn’t<br>       “feel”<br>       value semantic to me and certainly doesn’t have the guarantees usually<br>       associated with value semantics (won’t mutate behind your back, thread<br>       safe,<br>       etc).<br></p><p>   Sure it does.<br></p><p>   public struct Wrap&lt;T: AnyObject&gt; : Equatable {<br>   init(_ x: T) { self.x = x }<br>   private x: T<br>   }<br></p><p>   func == &lt;T&gt;(lhs: Wrap&lt;T&gt;, rhs: Wrap&lt;T&gt;) -&gt; Bool {<br>   return lhs.x === rhs.x<br>   }<br></p><p>   I defy you to find any scenario where Wrap&lt;T&gt; doesn&#39;t have value<br>   semantics, whether T is mutable or not.<br></p><p>   Alternately, you can look at the Array implementation. Array is a<br>   struct wrapping a mutable class. It has value semantics by virtue of<br>   CoW.<br></p><p>This goes back to where you draw the line as to the “boundary of the value”.<br>Wrap and Array are “value semantic” in a shallow sense and are capable of deep<br>value semantics when T is deeply value semantic. <br></p><p>No, I&#39;m sorry; this “deep-vs-shallow” thing is a fallacy that comes from<br>not understanding the boundaries of your value.  Or, put more<br>solicitously: sure, you can look at the world that way, but it just<br>makes everything prohibitively complicated, so why would you want to?<br></p><p>In my world, there&#39;s no such thing as a “deep copy” or a “shallow copy;”<br>there&#39;s just “copy,” which logically creates an independent version of<br>everything up to the boundaries of the value.  Likewise, there&#39;s no<br>“deep value semantics” or “shallow value semantics.”  Equality defines<br>value semantics, and the boundaries of an Array value always includes<br>the values of its elements.  The *only* problem here is that we have no<br>way to do equality comparison on some arrays because some types aren&#39;t<br>Equatable.  IMO the costs of not having everything be equatable, in<br>complexity-of-programming-model terms, are too high.<br></p><p>My point with this is, in case I was a bit rambling, if you’re going to draw boundaries around a value, for the purpose of copying or immutability, then equality should always match with those boundaries. As you say, “Equality defines value semantics, and the boundaries of an Array value always includes the values of its elements.”<br></p><p>Under this reasoning, custom equality violates these boundaries. And without custom equality, equality checks on reference types are essentially useless. But maybe value types in Swift are powerful enough where this doesn’t matter.<br></p><p><br></p><p>Both have their place, but the maximum benefit of value semantics<br>(purity) <br></p><p>I don&#39;t know what definition of purity you&#39;re using.  The only one I<br>know of applies to functions and implies no side effects.  In that<br>world, there is no mutation and value semantics is equivalent to<br>reference semantics.<br></p><p>is derived from deep value semantics. This is when there is no<br>possibility of shared mutable state. This is an extremely important<br>property.<br></p><p>It&#39;s the wrong property, IMO.<br></p><p><br>let t = MyClass()<br>foo.acceptWrapped(Wrap(t))<br>t.mutate()<br></p><p>In this example, foo had better not depend on the wrapped instance not getting<br>mutated.<br></p><p>foo has no way to get at the wrapped instance, so it can&#39;t depend on<br>anything about it.<br></p><p>       My expectation is a generic aggregate such as Array would have to<br>       conditionally conform to AnyValue only when Element also conforms to<br>       AnyValue.<br></p><p>       I’m also wondering how such a rule would be implemented while still<br>       allowing for CoW structs that *do* implement value semantics, but do<br>       so while using references internally.<br></p><p>       I am not talking about any kind of statically-enforceable rule, although<br>       we could probably make warnings sophisticated enough to help with this.<br></p><p>       You said the you have arrived at the opinion that the language should<br>       “effectively outlaw” structs and enums that do not have value semantics.<br>       That<br>       sounded like static enforcement to me. <br></p><p>   The language outlaws certain kinds of inout aliasing without<br>   providing static enforcement. This is like that.<br></p><p>I did not know this. Now you have me curious. Can you give an example of where<br>we are able to violate law? I ask mostly because it sounds like there is a<br>possibility of stumbling into dangerous territory, possibly without being aware<br>that you have done so.<br></p><p>See “In-out Parameters” in<br>https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/doc/uid/TP40014097-CH34-ID362<br></p><p>       Maybe you meant we should allow the compiler to assume value semantics<br>       for structs and enums despite the fact that it doesn’t statically<br>       enforce this?<br></p><p>   That would be one *consequence* of effectively outlawing it. The library<br>   could make similar assumptions.<br></p><p>       If the compiler can be sophisticated enough to verify value semantics<br>       statically maybe it would be better to have that mechanism be<br>       triggered by conformance to AnyValue rather than for all structs and<br>       enums. Types that conform to AnyValue would receive the benefits of<br>       the compiler knowing they have value semantics, while other uses of<br>       structs and enums would remain valid. Best practice would be to<br>       conform structs and enums to AnyValue whenever possible.<br></p><p>       Another possible advantage of this approach would be allowing<br>       immutable reference types to conform to AnyValue and receive the<br>       associated benefits such as the generated implementation of equality,<br>       etc.<br></p><p>       -Matthew<br></p><p>       -- <br>       Dave<br></p><p>       _______________________________________________<br>       swift-evolution mailing list<br>       swift-evolution at swift.org<br>       https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>       _______________________________________________<br>       swift-evolution mailing list<br>       swift-evolution at swift.org<br>       https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>       -- <br>       Dave<br></p><p>       _______________________________________________<br>       swift-evolution mailing list<br>       swift-evolution at swift.org<br>       https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>   -- <br>   Dave<br></p><p><br>-- <br>Dave<br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160507/48df98a5/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May  7, 2016 at 02:00:00pm</p></header><div class="content"><p>on Sat May 07 2016, Tyler Fleming Cloutier &lt;cloutiertyler-AT-aol.com&gt; wrote:<br></p><p>&gt;     No, I&#39;m sorry; this “deep-vs-shallow” thing is a fallacy that comes from<br>&gt;     not understanding the boundaries of your value. Or, put more<br>&gt;     solicitously: sure, you can look at the world that way, but it just<br>&gt;     makes everything prohibitively complicated, so why would you want to?<br>&gt;<br>&gt;     In my world, there&#39;s no such thing as a “deep copy” or a “shallow copy;”<br>&gt;     there&#39;s just “copy,” which logically creates an independent version of<br>&gt;     everything up to the boundaries of the value. Likewise, there&#39;s no<br>&gt;     “deep value semantics” or “shallow value semantics.” Equality defines<br>&gt;     value semantics, and the boundaries of an Array value always includes<br>&gt;     the values of its elements. The *only* problem here is that we have no<br>&gt;     way to do equality comparison on some arrays because some types aren&#39;t<br>&gt;     Equatable. IMO the costs of not having everything be equatable, in<br>&gt;     complexity-of-programming-model terms, are too high.<br>&gt;<br>&gt; My point with this is, in case I was a bit rambling, if you’re going to draw<br>&gt; boundaries around a value, for the purpose of copying or immutability, then<br>&gt; equality should always match with those boundaries. <br></p><p>Quite.<br></p><p>&gt; As you say, “Equality defines value semantics, and the boundaries of<br>&gt; an Array value always includes the values of its elements.”<br>&gt;<br>&gt; Under this reasoning, custom equality violates these boundaries. <br></p><p>No, it defines those boundaries.<br></p><p>&gt; And without custom equality, equality checks on reference types are<br>&gt; essentially useless. <br></p><p>No, comparing reference identity is completely useful.  That&#39;s why “===”<br>exists.  We just spelled it wrong :-)<br></p><p><br></p><p>-- <br>-Dave<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>May  7, 2016 at 02:00:00am</p></header><div class="content"><p>&gt; On May 4, 2016, at 3:50 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Wed May 04 2016, Matthew Johnson &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On May 4, 2016, at 1:29 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Wed May 04 2016, Adrian Zubarev &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; Not sure what to think about the enum cases inside a protocol (if AnyEnum would<br>&gt;&gt;&gt;&gt; even exist), it could be a nice addition to the language, but this is an own<br>&gt;&gt;&gt;&gt; proposal I guess.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We should start by adding AnyValue protocol to which all value types<br>&gt;&gt;&gt;&gt; conforms.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Having a way to constrain conformance to things with value semantics is<br>&gt;&gt;&gt; something I&#39;ve long wanted.  *However*, the approach described is too<br>&gt;&gt;&gt; simplistic.  It&#39;s possible to build classes whose instances have value<br>&gt;&gt;&gt; semantics (just make them immutable) and it&#39;s possible to build structs<br>&gt;&gt;&gt; whose instances have reference semantics (just put the struct&#39;s storage<br>&gt;&gt;&gt; in a mutable class instance that it holds as a property, and don&#39;t do<br>&gt;&gt;&gt; copy-on-write).  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In order for something like AnyValue to have meaning, we need to impose<br>&gt;&gt;&gt; greater order.  After thinking through many approaches over the years, I<br>&gt;&gt;&gt; have arrived at the (admittedly rather drastic) opinion that the<br>&gt;&gt;&gt; language should effectively outlaw the creation of structs and enums<br>&gt;&gt;&gt; that don&#39;t have value semantics.  (I have no problem with the idea that<br>&gt;&gt;&gt; immutable classes that want to act as values should be wrapped in a<br>&gt;&gt;&gt; struct).  The language could then do lots of things much more<br>&gt;&gt;&gt; intelligently, such as correctly generating implementations of equality.<br>&gt;&gt; <br>&gt;&gt; That is a drastic solution indeed!  How would this impact things like<br>&gt;&gt; Array&lt;UIView&gt;?  While Array itself has value semantics, the aggregate<br>&gt;&gt; obviously does not as it contains references which usually be mutated<br>&gt;&gt; underneath us.  <br>&gt; <br>&gt; Value semantics and mutation can only be measured with respect to<br>&gt; equality.  The definition of == for all class types would be equivalent<br>&gt; to ===.  Problem solved.<br></p><p>Hmm, I get the feeling that I was arguing your own point back at you. Sorry, Dave, I’m a little slow. :)<br></p><p>Still, how would you generate an equality operator for a data structure that requires wrapper classes currently, like a LinkedList?<br></p><p>&gt; <br>&gt;&gt; Similar considerations apply to simpler wrapper structs such as Weak.<br>&gt; <br>&gt; Same answer.<br>&gt; <br>&gt;&gt; My expectation is a generic aggregate such as Array would have to<br>&gt;&gt; conditionally conform to AnyValue only when Element also conforms to<br>&gt;&gt; AnyValue.<br>&gt;&gt; <br>&gt;&gt; I’m also wondering how such a rule would be implemented while still<br>&gt;&gt; allowing for CoW structs that *do* implement value semantics, but do<br>&gt;&gt; so while using references internally.<br>&gt; <br>&gt; I am not talking about any kind of statically-enforceable rule, although<br>&gt; we could probably make warnings sophisticated enough to help with this.<br>&gt;&gt; <br>&gt;&gt; If the compiler can be sophisticated enough to verify value semantics<br>&gt;&gt; statically maybe it would be better to have that mechanism be<br>&gt;&gt; triggered by conformance to AnyValue rather than for all structs and<br>&gt;&gt; enums.  Types that conform to AnyValue would receive the benefits of<br>&gt;&gt; the compiler knowing they have value semantics, while other uses of<br>&gt;&gt; structs and enums would remain valid.  Best practice would be to<br>&gt;&gt; conform structs and enums to AnyValue whenever possible.<br>&gt;&gt; <br>&gt;&gt; Another possible advantage of this approach would be allowing<br>&gt;&gt; immutable reference types to conform to AnyValue and receive the<br>&gt;&gt; associated benefits such as the generated implementation of equality,<br>&gt;&gt; etc.<br>&gt;&gt; <br>&gt;&gt; -Matthew<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; -- <br>&gt; Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160507/e0d02604/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May  7, 2016 at 02:00:00pm</p></header><div class="content"><p>on Sat May 07 2016, Tyler Fleming Cloutier &lt;cloutiertyler-AT-aol.com&gt; wrote:<br></p><p>&gt;         That is a drastic solution indeed! How would this impact things like<br>&gt;         Array&lt;UIView&gt;? While Array itself has value semantics, the aggregate<br>&gt;         obviously does not as it contains references which usually be mutated<br>&gt;         underneath us. <br>&gt;<br>&gt;     Value semantics and mutation can only be measured with respect to<br>&gt;     equality. The definition of == for all class types would be equivalent<br>&gt;     to ===. Problem solved.<br>&gt;<br>&gt; Hmm, I get the feeling that I was arguing your own point back at you. Sorry,<br>&gt; Dave, I’m a little slow. :)<br>&gt;<br>&gt; Still, how would you generate an equality operator for a data structure that<br>&gt; requires wrapper classes currently, like a LinkedList?<br></p><p>I don&#39;t think I understand the question.  Maybe you should show me the<br>specific LinkedList you&#39;re interested in.  When you say “generate,” do<br>you mean automatically?<br></p><p>FWIWs:<br></p><p>1. I don&#39;t intend to make every == operator automatically-generated<br></p><p>2. A LinkedList can be defined using enums and no classes<br></p><p>3. Though it can be done, I am of the opinion that linked lists usually<br>   make poor value types.<br></p><p>-- <br>-Dave<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
