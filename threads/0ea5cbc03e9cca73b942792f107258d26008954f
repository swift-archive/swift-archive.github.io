<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>Proposal: Namespaces</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>December 11, 2015 at 04:00:00pm</p></header><div class="content"><p>Namespaces<br>Author(s): TJ Usiyan<br></p><p>Introduction<br></p><p>A `namespace` keyword for swift hold related global variables.<br></p><p>Motivation<br></p><p>We often want to collect related variables which do not, for whatever<br>reason, fit neatly into a type provided by Swift. Importing Objective C<br>&#39;magic strings&#39; as Joshua Sullivan does [here] is one such example. The<br>solution he arrives at is a `struct` type with many type variables and no<br>fields.<br>struct NotificationNames {<br> static let userDataChanged = &quot;UserDataChangedNotificationName&quot;<br> static let receivedAlert = &quot;ReceivedAlertNotificationName&quot;<br> static let peanutButterJellyTime =<br>&quot;ItsPeanutButterJellyTimeNotificationName&quot;<br>}<br></p><p>Users of this API are not meant to create instances of this type, yet it is<br>still possible. A solution to this is to use an `enum` without cases.<br></p><p>enum NotificationNames {<br> static let userDataChanged = &quot;UserDataChangedNotificationName&quot;<br> static let receivedAlert = &quot;ReceivedAlertNotificationName&quot;<br> static let peanutButterJellyTime =<br>&quot;ItsPeanutButterJellyTimeNotificationName&quot;<br>}<br></p><p>No instances of the `enum` can be made. That this inability to create an<br>instance is intentional is only conveyed via the type system.<br></p><p>Proposed solution<br></p><p>Clarity would be greatly improved if we could use `namespace` as a synonym<br>for an enum with no cases. This would allow us to avoid repetition of<br>`static` as well.<br></p><p>namespace NotificationNames {<br> let userDataChanged = &quot;UserDataChangedNotificationName&quot;<br> let receivedAlert = &quot;ReceivedAlertNotificationName&quot;<br> let peanutButterJellyTime = &quot;ItsPeanutButterJellyTimeNotificationName&quot;<br>}<br></p><p>Detailed design<br></p><p>Namespaces can be represented in the type system as enums. All variables<br>declared in a namespace&#39;s scope would be type variables.<br></p><p>Impact on existing code<br></p><p>This is an additive change and, as such, should not break any existing<br>code. Though it doesn&#39;t matter, this addition could possibly attain ABI<br>compatibility if namespaces are represented as enums without cases.<br></p><p>Alternatives considered<br></p><p>Don&#39;t implement namespaces. Developers could continue(begin?) using an<br>empty enum to hold type variables.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/0ea5954f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Proposal: Namespaces</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>December 11, 2015 at 10:00:00am</p></header><div class="content"><p>Some of this currently is being hacked into the language via the use of<br>structs.<br></p><p>On Fri, Dec 11, 2015 at 10:39 AM, T.J. Usiyan via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Namespaces<br>&gt; Author(s): TJ Usiyan<br>&gt;<br>&gt; Introduction<br>&gt;<br>&gt; A `namespace` keyword for swift hold related global variables.<br>&gt;<br>&gt; Motivation<br>&gt;<br>&gt; We often want to collect related variables which do not, for whatever<br>&gt; reason, fit neatly into a type provided by Swift. Importing Objective C<br>&gt; &#39;magic strings&#39; as Joshua Sullivan does [here] is one such example. The<br>&gt; solution he arrives at is a `struct` type with many type variables and no<br>&gt; fields.<br>&gt; struct NotificationNames {<br>&gt;  static let userDataChanged = &quot;UserDataChangedNotificationName&quot;<br>&gt;  static let receivedAlert = &quot;ReceivedAlertNotificationName&quot;<br>&gt;  static let peanutButterJellyTime =<br>&gt; &quot;ItsPeanutButterJellyTimeNotificationName&quot;<br>&gt; }<br>&gt;<br>&gt; Users of this API are not meant to create instances of this type, yet it<br>&gt; is still possible. A solution to this is to use an `enum` without cases.<br>&gt;<br>&gt; enum NotificationNames {<br>&gt;  static let userDataChanged = &quot;UserDataChangedNotificationName&quot;<br>&gt;  static let receivedAlert = &quot;ReceivedAlertNotificationName&quot;<br>&gt;  static let peanutButterJellyTime =<br>&gt; &quot;ItsPeanutButterJellyTimeNotificationName&quot;<br>&gt; }<br>&gt;<br>&gt; No instances of the `enum` can be made. That this inability to create an<br>&gt; instance is intentional is only conveyed via the type system.<br>&gt;<br>&gt; Proposed solution<br>&gt;<br>&gt; Clarity would be greatly improved if we could use `namespace` as a synonym<br>&gt; for an enum with no cases. This would allow us to avoid repetition of<br>&gt; `static` as well.<br>&gt;<br>&gt; namespace NotificationNames {<br>&gt;  let userDataChanged = &quot;UserDataChangedNotificationName&quot;<br>&gt;  let receivedAlert = &quot;ReceivedAlertNotificationName&quot;<br>&gt;  let peanutButterJellyTime = &quot;ItsPeanutButterJellyTimeNotificationName&quot;<br>&gt; }<br>&gt;<br>&gt; Detailed design<br>&gt;<br>&gt; Namespaces can be represented in the type system as enums. All variables<br>&gt; declared in a namespace&#39;s scope would be type variables.<br>&gt;<br>&gt; Impact on existing code<br>&gt;<br>&gt; This is an additive change and, as such, should not break any existing<br>&gt; code. Though it doesn&#39;t matter, this addition could possibly attain ABI<br>&gt; compatibility if namespaces are represented as enums without cases.<br>&gt;<br>&gt; Alternatives considered<br>&gt;<br>&gt; Don&#39;t implement namespaces. Developers could continue(begin?) using an<br>&gt; empty enum to hold type variables.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p><p><br>-- <br> Wizard<br>james at supmenow.com<br>+44 7523 279 698<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/ea2995b0/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c638dc69b46afe03e3491dea47620cf4?s=50"></div><header><strong>Proposal: Namespaces</strong> from <string>crk at fastmail.com</string> &lt;crk at fastmail.com&gt;<p>December 13, 2015 at 05:00:00pm</p></header><div class="content"><p>IMO using  an enum is non-intuitive. A struct is a &quot;bucket of values&quot; and so makes fits with the usage here. If the ability to instantiate the NotificationNames struct is a problem, adding a <br></p><p>private init() <br>{<br></p><p>}<br></p><p>seems more intuitive than co-opting an enum, which has a fairly established use case. <br></p><p>Your proposal would essentially be adding a keyword that is transformed back into &quot;enum&quot; during compilation. I don&#39;t think that a relatively minor improvement in clarity for a fairly small use case is worth adding a language feature.<br></p><p>Allowing structs to be declared as static would be another way of simplifying this kind of declaration, i.e.<br></p><p>static struct NotificationNames {<br>     let userDataChanged = ...<br>     let recievedAlert = ...<br>}<br></p><p>This would allow dropping the private init declaration and dropping the static from each property. I&#39;m not sure I think this shortcut is necessary or even if it&#39;s a good idea, but I do think it fits with the language a little better than your current proposal. <br></p><p>&gt; On Dec 11, 2015, at 04:39, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Namespaces<br>&gt; Author(s): TJ Usiyan<br>&gt; <br>&gt; Introduction<br>&gt; <br>&gt; A `namespace` keyword for swift hold related global variables.<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; We often want to collect related variables which do not, for whatever reason, fit neatly into a type provided by Swift. Importing Objective C &#39;magic strings&#39; as Joshua Sullivan does [here] is one such example. The solution he arrives at is a `struct` type with many type variables and no fields.<br>&gt; 	<br>&gt; 	struct NotificationNames {<br>&gt; 	  static let userDataChanged = &quot;UserDataChangedNotificationName&quot;<br>&gt; 	  static let receivedAlert = &quot;ReceivedAlertNotificationName&quot;<br>&gt; 	  static let peanutButterJellyTime = &quot;ItsPeanutButterJellyTimeNotificationName&quot;<br>&gt; 	}<br>&gt; <br>&gt; Users of this API are not meant to create instances of this type, yet it is still possible. A solution to this is to use an `enum` without cases. <br>&gt; <br>&gt; 	enum NotificationNames {<br>&gt; 	  static let userDataChanged = &quot;UserDataChangedNotificationName&quot;<br>&gt; 	  static let receivedAlert = &quot;ReceivedAlertNotificationName&quot;<br>&gt; 	  static let peanutButterJellyTime = &quot;ItsPeanutButterJellyTimeNotificationName&quot;<br>&gt; 	}<br>&gt; <br>&gt; No instances of the `enum` can be made. That this inability to create an instance is intentional is only conveyed via the type system. <br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; Clarity would be greatly improved if we could use `namespace` as a synonym for an enum with no cases. This would allow us to avoid repetition of `static` as well.<br>&gt; <br>&gt; 	namespace NotificationNames {<br>&gt; 	  let userDataChanged = &quot;UserDataChangedNotificationName&quot;<br>&gt; 	  let receivedAlert = &quot;ReceivedAlertNotificationName&quot;<br>&gt; 	  let peanutButterJellyTime = &quot;ItsPeanutButterJellyTimeNotificationName&quot;<br>&gt; 	}<br>&gt; <br>&gt; Detailed design<br>&gt; <br>&gt; Namespaces can be represented in the type system as enums. All variables declared in a namespace&#39;s scope would be type variables.<br>&gt; <br>&gt; Impact on existing code<br>&gt; <br>&gt; This is an additive change and, as such, should not break any existing code. Though it doesn&#39;t matter, this addition could possibly attain ABI compatibility if namespaces are represented as enums without cases.<br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; Don&#39;t implement namespaces. Developers could continue(begin?) using an empty enum to hold type variables.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/7e87203d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>Proposal: Namespaces</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 14, 2015 at 12:00:00am</p></header><div class="content"><p>Sounds like a potential use case for object declarations:<br>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001837.html<br></p><p>Same feature-set as structs but users cannot instantiate it since<br>namespaces are basically singletons anyway.<br>Bonus is that you can pass them around and make them conform to protocols.<br></p><p><br>On Mon, Dec 14, 2015 at 12:44 AM, Cole Kurkowski via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; IMO using  an enum is non-intuitive. A struct is a &quot;bucket of values&quot; and<br>&gt; so makes fits with the usage here. If the ability to instantiate the<br>&gt; NotificationNames struct is a problem, adding a<br>&gt;<br>&gt; private init()<br>&gt; {<br>&gt;<br>&gt; }<br>&gt;<br>&gt; seems more intuitive than co-opting an enum, which has a fairly<br>&gt; established use case.<br>&gt;<br>&gt; Your proposal would essentially be adding a keyword that is transformed<br>&gt; back into &quot;enum&quot; during compilation. I don&#39;t think that a relatively minor<br>&gt; improvement in clarity for a fairly small use case is worth adding a<br>&gt; language feature.<br>&gt;<br>&gt; Allowing structs to be declared as static would be another way of<br>&gt; simplifying this kind of declaration, i.e.<br>&gt;<br>&gt; static struct NotificationNames {<br>&gt;      let userDataChanged = ...<br>&gt;      let recievedAlert = ...<br>&gt; }<br>&gt;<br>&gt; This would allow dropping the private init declaration and dropping the<br>&gt; static from each property. I&#39;m not sure I think this shortcut is necessary<br>&gt; or even if it&#39;s a good idea, but I do think it fits with the language a<br>&gt; little better than your current proposal.<br>&gt;<br>&gt; On Dec 11, 2015, at 04:39, T.J. Usiyan via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Namespaces<br>&gt; Author(s): TJ Usiyan<br>&gt;<br>&gt; Introduction<br>&gt;<br>&gt; A `namespace` keyword for swift hold related global variables.<br>&gt;<br>&gt; Motivation<br>&gt;<br>&gt; We often want to collect related variables which do not, for whatever<br>&gt; reason, fit neatly into a type provided by Swift. Importing Objective C<br>&gt; &#39;magic strings&#39; as Joshua Sullivan does [here] is one such example. The<br>&gt; solution he arrives at is a `struct` type with many type variables and no<br>&gt; fields.<br>&gt; struct NotificationNames {<br>&gt;  static let userDataChanged = &quot;UserDataChangedNotificationName&quot;<br>&gt;  static let receivedAlert = &quot;ReceivedAlertNotificationName&quot;<br>&gt;  static let peanutButterJellyTime =<br>&gt; &quot;ItsPeanutButterJellyTimeNotificationName&quot;<br>&gt; }<br>&gt;<br>&gt; Users of this API are not meant to create instances of this type, yet it<br>&gt; is still possible. A solution to this is to use an `enum` without cases.<br>&gt;<br>&gt; enum NotificationNames {<br>&gt;  static let userDataChanged = &quot;UserDataChangedNotificationName&quot;<br>&gt;  static let receivedAlert = &quot;ReceivedAlertNotificationName&quot;<br>&gt;  static let peanutButterJellyTime =<br>&gt; &quot;ItsPeanutButterJellyTimeNotificationName&quot;<br>&gt; }<br>&gt;<br>&gt; No instances of the `enum` can be made. That this inability to create an<br>&gt; instance is intentional is only conveyed via the type system.<br>&gt;<br>&gt; Proposed solution<br>&gt;<br>&gt; Clarity would be greatly improved if we could use `namespace` as a synonym<br>&gt; for an enum with no cases. This would allow us to avoid repetition of<br>&gt; `static` as well.<br>&gt;<br>&gt; namespace NotificationNames {<br>&gt;  let userDataChanged = &quot;UserDataChangedNotificationName&quot;<br>&gt;  let receivedAlert = &quot;ReceivedAlertNotificationName&quot;<br>&gt;  let peanutButterJellyTime = &quot;ItsPeanutButterJellyTimeNotificationName&quot;<br>&gt; }<br>&gt;<br>&gt; Detailed design<br>&gt;<br>&gt; Namespaces can be represented in the type system as enums. All variables<br>&gt; declared in a namespace&#39;s scope would be type variables.<br>&gt;<br>&gt; Impact on existing code<br>&gt;<br>&gt; This is an additive change and, as such, should not break any existing<br>&gt; code. Though it doesn&#39;t matter, this addition could possibly attain ABI<br>&gt; compatibility if namespaces are represented as enums without cases.<br>&gt;<br>&gt; Alternatives considered<br>&gt;<br>&gt; Don&#39;t implement namespaces. Developers could continue(begin?) using an<br>&gt; empty enum to hold type variables.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/5bd7ec06/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c638dc69b46afe03e3491dea47620cf4?s=50"></div><header><strong>Proposal: Namespaces</strong> from <string>crk at fastmail.com</string> &lt;crk at fastmail.com&gt;<p>December 13, 2015 at 07:00:00pm</p></header><div class="content"><p>Wouldn&#39;t that require a global variable to retain the object? I&#39;m not sure that sounds ideal, since the whole point here is to stay away from having global variables flying around. (Though obviously one instead of N isn&#39;t too bad)<br></p><p>I must admit I like your ideal better than namespace as a keyword, though I&#39;m still not completely sold on bringing in anonymous objects to Swift. <br></p><p>&gt; On Dec 13, 2015, at 17:49, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt; <br>&gt; Sounds like a potential use case for object declarations:<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001837.html<br>&gt; <br>&gt; Same feature-set as structs but users cannot instantiate it since namespaces are basically singletons anyway.<br>&gt; Bonus is that you can pass them around and make them conform to protocols.<br>&gt; <br>&gt; <br>&gt;&gt; On Mon, Dec 14, 2015 at 12:44 AM, Cole Kurkowski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; IMO using  an enum is non-intuitive. A struct is a &quot;bucket of values&quot; and so makes fits with the usage here. If the ability to instantiate the NotificationNames struct is a problem, adding a <br>&gt;&gt; <br>&gt;&gt; private init() <br>&gt;&gt; {<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; seems more intuitive than co-opting an enum, which has a fairly established use case. <br>&gt;&gt; <br>&gt;&gt; Your proposal would essentially be adding a keyword that is transformed back into &quot;enum&quot; during compilation. I don&#39;t think that a relatively minor improvement in clarity for a fairly small use case is worth adding a language feature.<br>&gt;&gt; <br>&gt;&gt; Allowing structs to be declared as static would be another way of simplifying this kind of declaration, i.e.<br>&gt;&gt; <br>&gt;&gt; static struct NotificationNames {<br>&gt;&gt;      let userDataChanged = ...<br>&gt;&gt;      let recievedAlert = ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This would allow dropping the private init declaration and dropping the static from each property. I&#39;m not sure I think this shortcut is necessary or even if it&#39;s a good idea, but I do think it fits with the language a little better than your current proposal. <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 11, 2015, at 04:39, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Namespaces<br>&gt;&gt;&gt; Author(s): TJ Usiyan<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A `namespace` keyword for swift hold related global variables.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We often want to collect related variables which do not, for whatever reason, fit neatly into a type provided by Swift. Importing Objective C &#39;magic strings&#39; as Joshua Sullivan does [here] is one such example. The solution he arrives at is a `struct` type with many type variables and no fields.<br>&gt;&gt;&gt; 	<br>&gt;&gt;&gt; 	struct NotificationNames {<br>&gt;&gt;&gt; 	  static let userDataChanged = &quot;UserDataChangedNotificationName&quot;<br>&gt;&gt;&gt; 	  static let receivedAlert = &quot;ReceivedAlertNotificationName&quot;<br>&gt;&gt;&gt; 	  static let peanutButterJellyTime = &quot;ItsPeanutButterJellyTimeNotificationName&quot;<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Users of this API are not meant to create instances of this type, yet it is still possible. A solution to this is to use an `enum` without cases. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	enum NotificationNames {<br>&gt;&gt;&gt; 	  static let userDataChanged = &quot;UserDataChangedNotificationName&quot;<br>&gt;&gt;&gt; 	  static let receivedAlert = &quot;ReceivedAlertNotificationName&quot;<br>&gt;&gt;&gt; 	  static let peanutButterJellyTime = &quot;ItsPeanutButterJellyTimeNotificationName&quot;<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No instances of the `enum` can be made. That this inability to create an instance is intentional is only conveyed via the type system. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Clarity would be greatly improved if we could use `namespace` as a synonym for an enum with no cases. This would allow us to avoid repetition of `static` as well.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	namespace NotificationNames {<br>&gt;&gt;&gt; 	  let userDataChanged = &quot;UserDataChangedNotificationName&quot;<br>&gt;&gt;&gt; 	  let receivedAlert = &quot;ReceivedAlertNotificationName&quot;<br>&gt;&gt;&gt; 	  let peanutButterJellyTime = &quot;ItsPeanutButterJellyTimeNotificationName&quot;<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Detailed design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Namespaces can be represented in the type system as enums. All variables declared in a namespace&#39;s scope would be type variables.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is an additive change and, as such, should not break any existing code. Though it doesn&#39;t matter, this addition could possibly attain ABI compatibility if namespaces are represented as enums without cases.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Don&#39;t implement namespaces. Developers could continue(begin?) using an empty enum to hold type variables.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/016f5efd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>Proposal: Namespaces</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 14, 2015 at 02:00:00am</p></header><div class="content"><p>No, an object declaration is a type and an instance at the same time.<br></p><p>Whatever the syntax is, something like `object NotificationNames {}` can be<br>referred to as type and as instance. It&#39;s initialized on first access.<br>So it&#39;s just `NotificationNames.userDataChanged` to access a property and<br>you can even omit the `static` for all variables.<br></p><p>On Mon, Dec 14, 2015 at 2:19 AM, Cole Kurkowski &lt;crk at fastmail.com&gt; wrote:<br></p><p>&gt; Wouldn&#39;t that require a global variable to retain the object? I&#39;m not sure<br>&gt; that sounds ideal, since the whole point here is to stay away from having<br>&gt; global variables flying around. (Though obviously one instead of N isn&#39;t<br>&gt; too bad)<br>&gt;<br>&gt; I must admit I like your ideal better than namespace as a keyword, though<br>&gt; I&#39;m still not completely sold on bringing in anonymous objects to Swift.<br>&gt;<br>&gt; On Dec 13, 2015, at 17:49, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt;<br>&gt; Sounds like a potential use case for object declarations:<br>&gt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001837.html<br>&gt;<br>&gt; Same feature-set as structs but users cannot instantiate it since<br>&gt; namespaces are basically singletons anyway.<br>&gt; Bonus is that you can pass them around and make them conform to protocols.<br>&gt;<br>&gt;<br>&gt; On Mon, Dec 14, 2015 at 12:44 AM, Cole Kurkowski via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; IMO using  an enum is non-intuitive. A struct is a &quot;bucket of values&quot;<br>&gt;&gt; and so makes fits with the usage here. If the ability to instantiate the<br>&gt;&gt; NotificationNames struct is a problem, adding a<br>&gt;&gt;<br>&gt;&gt; private init()<br>&gt;&gt; {<br>&gt;&gt;<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; seems more intuitive than co-opting an enum, which has a fairly<br>&gt;&gt; established use case.<br>&gt;&gt;<br>&gt;&gt; Your proposal would essentially be adding a keyword that is transformed<br>&gt;&gt; back into &quot;enum&quot; during compilation. I don&#39;t think that a relatively minor<br>&gt;&gt; improvement in clarity for a fairly small use case is worth adding a<br>&gt;&gt; language feature.<br>&gt;&gt;<br>&gt;&gt; Allowing structs to be declared as static would be another way of<br>&gt;&gt; simplifying this kind of declaration, i.e.<br>&gt;&gt;<br>&gt;&gt; static struct NotificationNames {<br>&gt;&gt;      let userDataChanged = ...<br>&gt;&gt;      let recievedAlert = ...<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; This would allow dropping the private init declaration and dropping the<br>&gt;&gt; static from each property. I&#39;m not sure I think this shortcut is necessary<br>&gt;&gt; or even if it&#39;s a good idea, but I do think it fits with the language a<br>&gt;&gt; little better than your current proposal.<br>&gt;&gt;<br>&gt;&gt; On Dec 11, 2015, at 04:39, T.J. Usiyan via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Namespaces<br>&gt;&gt; Author(s): TJ Usiyan<br>&gt;&gt;<br>&gt;&gt; Introduction<br>&gt;&gt;<br>&gt;&gt; A `namespace` keyword for swift hold related global variables.<br>&gt;&gt;<br>&gt;&gt; Motivation<br>&gt;&gt;<br>&gt;&gt; We often want to collect related variables which do not, for whatever<br>&gt;&gt; reason, fit neatly into a type provided by Swift. Importing Objective C<br>&gt;&gt; &#39;magic strings&#39; as Joshua Sullivan does [here] is one such example. The<br>&gt;&gt; solution he arrives at is a `struct` type with many type variables and no<br>&gt;&gt; fields.<br>&gt;&gt; struct NotificationNames {<br>&gt;&gt;  static let userDataChanged = &quot;UserDataChangedNotificationName&quot;<br>&gt;&gt;  static let receivedAlert = &quot;ReceivedAlertNotificationName&quot;<br>&gt;&gt;  static let peanutButterJellyTime =<br>&gt;&gt; &quot;ItsPeanutButterJellyTimeNotificationName&quot;<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Users of this API are not meant to create instances of this type, yet it<br>&gt;&gt; is still possible. A solution to this is to use an `enum` without cases.<br>&gt;&gt;<br>&gt;&gt; enum NotificationNames {<br>&gt;&gt;  static let userDataChanged = &quot;UserDataChangedNotificationName&quot;<br>&gt;&gt;  static let receivedAlert = &quot;ReceivedAlertNotificationName&quot;<br>&gt;&gt;  static let peanutButterJellyTime =<br>&gt;&gt; &quot;ItsPeanutButterJellyTimeNotificationName&quot;<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; No instances of the `enum` can be made. That this inability to create an<br>&gt;&gt; instance is intentional is only conveyed via the type system.<br>&gt;&gt;<br>&gt;&gt; Proposed solution<br>&gt;&gt;<br>&gt;&gt; Clarity would be greatly improved if we could use `namespace` as a<br>&gt;&gt; synonym for an enum with no cases. This would allow us to avoid repetition<br>&gt;&gt; of `static` as well.<br>&gt;&gt;<br>&gt;&gt; namespace NotificationNames {<br>&gt;&gt;  let userDataChanged = &quot;UserDataChangedNotificationName&quot;<br>&gt;&gt;  let receivedAlert = &quot;ReceivedAlertNotificationName&quot;<br>&gt;&gt;  let peanutButterJellyTime = &quot;ItsPeanutButterJellyTimeNotificationName&quot;<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Detailed design<br>&gt;&gt;<br>&gt;&gt; Namespaces can be represented in the type system as enums. All variables<br>&gt;&gt; declared in a namespace&#39;s scope would be type variables.<br>&gt;&gt;<br>&gt;&gt; Impact on existing code<br>&gt;&gt;<br>&gt;&gt; This is an additive change and, as such, should not break any existing<br>&gt;&gt; code. Though it doesn&#39;t matter, this addition could possibly attain ABI<br>&gt;&gt; compatibility if namespaces are represented as enums without cases.<br>&gt;&gt;<br>&gt;&gt; Alternatives considered<br>&gt;&gt;<br>&gt;&gt; Don&#39;t implement namespaces. Developers could continue(begin?) using an<br>&gt;&gt; empty enum to hold type variables.<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/dbf0a25f/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>Proposal: Namespaces</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>December 13, 2015 at 07:00:00pm</p></header><div class="content"><p>The use case described in the proposal and your response doesn&#39;t use<br>structs as a &quot;bucket of values&quot;. I uses *the type* as a bucket of values.<br>The point of using an empty enum is to emphasize this point. The overal<br>point of this proposal is to introduce semantics that obviate the need to<br>&#39;decide&#39; between enum and struct since neither are the type actually<br>desired. I suggest using an enum as the implementation with the hope that<br>it will simplify implementation.<br></p><p>Your suggestion of `static struct` emphasizes the utility of a namespace<br>keyword. Is `static struct …` a declaration of a type or an instance and of<br>what?<br></p><p>TJ<br></p><p>On Sun, Dec 13, 2015 at 6:44 PM, Cole Kurkowski &lt;crk at fastmail.com&gt; wrote:<br></p><p>&gt; IMO using  an enum is non-intuitive. A struct is a &quot;bucket of values&quot; and<br>&gt; so makes fits with the usage here. If the ability to instantiate the<br>&gt; NotificationNames struct is a problem, adding a<br>&gt;<br>&gt; private init()<br>&gt; {<br>&gt;<br>&gt; }<br>&gt;<br>&gt; seems more intuitive than co-opting an enum, which has a fairly<br>&gt; established use case.<br>&gt;<br>&gt; Your proposal would essentially be adding a keyword that is transformed<br>&gt; back into &quot;enum&quot; during compilation. I don&#39;t think that a relatively minor<br>&gt; improvement in clarity for a fairly small use case is worth adding a<br>&gt; language feature.<br>&gt;<br>&gt; Allowing structs to be declared as static would be another way of<br>&gt; simplifying this kind of declaration, i.e.<br>&gt;<br>&gt; static struct NotificationNames {<br>&gt;      let userDataChanged = ...<br>&gt;      let recievedAlert = ...<br>&gt; }<br>&gt;<br>&gt; This would allow dropping the private init declaration and dropping the<br>&gt; static from each property. I&#39;m not sure I think this shortcut is necessary<br>&gt; or even if it&#39;s a good idea, but I do think it fits with the language a<br>&gt; little better than your current proposal.<br>&gt;<br>&gt; On Dec 11, 2015, at 04:39, T.J. Usiyan via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Namespaces<br>&gt; Author(s): TJ Usiyan<br>&gt;<br>&gt; Introduction<br>&gt;<br>&gt; A `namespace` keyword for swift hold related global variables.<br>&gt;<br>&gt; Motivation<br>&gt;<br>&gt; We often want to collect related variables which do not, for whatever<br>&gt; reason, fit neatly into a type provided by Swift. Importing Objective C<br>&gt; &#39;magic strings&#39; as Joshua Sullivan does [here] is one such example. The<br>&gt; solution he arrives at is a `struct` type with many type variables and no<br>&gt; fields.<br>&gt; struct NotificationNames {<br>&gt;  static let userDataChanged = &quot;UserDataChangedNotificationName&quot;<br>&gt;  static let receivedAlert = &quot;ReceivedAlertNotificationName&quot;<br>&gt;  static let peanutButterJellyTime =<br>&gt; &quot;ItsPeanutButterJellyTimeNotificationName&quot;<br>&gt; }<br>&gt;<br>&gt; Users of this API are not meant to create instances of this type, yet it<br>&gt; is still possible. A solution to this is to use an `enum` without cases.<br>&gt;<br>&gt; enum NotificationNames {<br>&gt;  static let userDataChanged = &quot;UserDataChangedNotificationName&quot;<br>&gt;  static let receivedAlert = &quot;ReceivedAlertNotificationName&quot;<br>&gt;  static let peanutButterJellyTime =<br>&gt; &quot;ItsPeanutButterJellyTimeNotificationName&quot;<br>&gt; }<br>&gt;<br>&gt; No instances of the `enum` can be made. That this inability to create an<br>&gt; instance is intentional is only conveyed via the type system.<br>&gt;<br>&gt; Proposed solution<br>&gt;<br>&gt; Clarity would be greatly improved if we could use `namespace` as a synonym<br>&gt; for an enum with no cases. This would allow us to avoid repetition of<br>&gt; `static` as well.<br>&gt;<br>&gt; namespace NotificationNames {<br>&gt;  let userDataChanged = &quot;UserDataChangedNotificationName&quot;<br>&gt;  let receivedAlert = &quot;ReceivedAlertNotificationName&quot;<br>&gt;  let peanutButterJellyTime = &quot;ItsPeanutButterJellyTimeNotificationName&quot;<br>&gt; }<br>&gt;<br>&gt; Detailed design<br>&gt;<br>&gt; Namespaces can be represented in the type system as enums. All variables<br>&gt; declared in a namespace&#39;s scope would be type variables.<br>&gt;<br>&gt; Impact on existing code<br>&gt;<br>&gt; This is an additive change and, as such, should not break any existing<br>&gt; code. Though it doesn&#39;t matter, this addition could possibly attain ABI<br>&gt; compatibility if namespaces are represented as enums without cases.<br>&gt;<br>&gt; Alternatives considered<br>&gt;<br>&gt; Don&#39;t implement namespaces. Developers could continue(begin?) using an<br>&gt; empty enum to hold type variables.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/f1e79db0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c638dc69b46afe03e3491dea47620cf4?s=50"></div><header><strong>Proposal: Namespaces</strong> from <string>crk at fastmail.com</string> &lt;crk at fastmail.com&gt;<p>December 13, 2015 at 07:00:00pm</p></header><div class="content"><p>100% agree that using a struct this way is far from ideal. I just don&#39;t think the problem here is realistically that big of a deal. <br></p><p>If there were major performance gains to be had from the compiler knowing a data structure was essentially a set of grouped constants, then I would completely support adding a keyword to indicate such. I don&#39;t believe that&#39;s the case though, as it stands I believe both your proposal and my alternative are just syntactic sugar with the potential for confusion.<br></p><p>&gt; On Dec 13, 2015, at 18:16, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt; <br>&gt; The use case described in the proposal and your response doesn&#39;t use structs as a &quot;bucket of values&quot;. I uses *the type* as a bucket of values. The point of using an empty enum is to emphasize this point. The overal point of this proposal is to introduce semantics that obviate the need to &#39;decide&#39; between enum and struct since neither are the type actually desired. I suggest using an enum as the implementation with the hope that it will simplify implementation.<br>&gt; <br>&gt; Your suggestion of `static struct` emphasizes the utility of a namespace keyword. Is `static struct …` a declaration of a type or an instance and of what? <br>&gt; <br>&gt; TJ<br>&gt; <br>&gt;&gt; On Sun, Dec 13, 2015 at 6:44 PM, Cole Kurkowski &lt;crk at fastmail.com&gt; wrote:<br>&gt;&gt; IMO using  an enum is non-intuitive. A struct is a &quot;bucket of values&quot; and so makes fits with the usage here. If the ability to instantiate the NotificationNames struct is a problem, adding a <br>&gt;&gt; <br>&gt;&gt; private init() <br>&gt;&gt; {<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; seems more intuitive than co-opting an enum, which has a fairly established use case. <br>&gt;&gt; <br>&gt;&gt; Your proposal would essentially be adding a keyword that is transformed back into &quot;enum&quot; during compilation. I don&#39;t think that a relatively minor improvement in clarity for a fairly small use case is worth adding a language feature.<br>&gt;&gt; <br>&gt;&gt; Allowing structs to be declared as static would be another way of simplifying this kind of declaration, i.e.<br>&gt;&gt; <br>&gt;&gt; static struct NotificationNames {<br>&gt;&gt;      let userDataChanged = ...<br>&gt;&gt;      let recievedAlert = ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This would allow dropping the private init declaration and dropping the static from each property. I&#39;m not sure I think this shortcut is necessary or even if it&#39;s a good idea, but I do think it fits with the language a little better than your current proposal. <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 11, 2015, at 04:39, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Namespaces<br>&gt;&gt;&gt; Author(s): TJ Usiyan<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A `namespace` keyword for swift hold related global variables.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We often want to collect related variables which do not, for whatever reason, fit neatly into a type provided by Swift. Importing Objective C &#39;magic strings&#39; as Joshua Sullivan does [here] is one such example. The solution he arrives at is a `struct` type with many type variables and no fields.<br>&gt;&gt;&gt; 	<br>&gt;&gt;&gt; 	struct NotificationNames {<br>&gt;&gt;&gt; 	  static let userDataChanged = &quot;UserDataChangedNotificationName&quot;<br>&gt;&gt;&gt; 	  static let receivedAlert = &quot;ReceivedAlertNotificationName&quot;<br>&gt;&gt;&gt; 	  static let peanutButterJellyTime = &quot;ItsPeanutButterJellyTimeNotificationName&quot;<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Users of this API are not meant to create instances of this type, yet it is still possible. A solution to this is to use an `enum` without cases. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	enum NotificationNames {<br>&gt;&gt;&gt; 	  static let userDataChanged = &quot;UserDataChangedNotificationName&quot;<br>&gt;&gt;&gt; 	  static let receivedAlert = &quot;ReceivedAlertNotificationName&quot;<br>&gt;&gt;&gt; 	  static let peanutButterJellyTime = &quot;ItsPeanutButterJellyTimeNotificationName&quot;<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No instances of the `enum` can be made. That this inability to create an instance is intentional is only conveyed via the type system. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Clarity would be greatly improved if we could use `namespace` as a synonym for an enum with no cases. This would allow us to avoid repetition of `static` as well.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	namespace NotificationNames {<br>&gt;&gt;&gt; 	  let userDataChanged = &quot;UserDataChangedNotificationName&quot;<br>&gt;&gt;&gt; 	  let receivedAlert = &quot;ReceivedAlertNotificationName&quot;<br>&gt;&gt;&gt; 	  let peanutButterJellyTime = &quot;ItsPeanutButterJellyTimeNotificationName&quot;<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Detailed design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Namespaces can be represented in the type system as enums. All variables declared in a namespace&#39;s scope would be type variables.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is an additive change and, as such, should not break any existing code. Though it doesn&#39;t matter, this addition could possibly attain ABI compatibility if namespaces are represented as enums without cases.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Don&#39;t implement namespaces. Developers could continue(begin?) using an empty enum to hold type variables.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/0eea9804/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>Proposal: Namespaces</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>January 14, 2016 at 11:00:00am</p></header><div class="content"><p>What’s the status on this? Is someone willing to write a proper proposal for this?<br></p><p>I just ran into to this yesterday. I have a project has multiple parsers and naturally, there is a need for multiple `Tokenizer` classes. It’s getting a big obnoxious to continue abuse struct/enum for this.<br></p><p>-David<br></p><p><br>&gt; On Dec 13, 2015, at 5:31 PM, Cole Kurkowski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; 100% agree that using a struct this way is far from ideal. I just don&#39;t think the problem here is realistically that big of a deal. <br>&gt; <br>&gt; If there were major performance gains to be had from the compiler knowing a data structure was essentially a set of grouped constants, then I would completely support adding a keyword to indicate such. I don&#39;t believe that&#39;s the case though, as it stands I believe both your proposal and my alternative are just syntactic sugar with the potential for confusion.<br>&gt; <br>&gt; On Dec 13, 2015, at 18:16, T.J. Usiyan &lt;griotspeak at gmail.com &lt;mailto:griotspeak at gmail.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; The use case described in the proposal and your response doesn&#39;t use structs as a &quot;bucket of values&quot;. I uses *the type* as a bucket of values. The point of using an empty enum is to emphasize this point. The overal point of this proposal is to introduce semantics that obviate the need to &#39;decide&#39; between enum and struct since neither are the type actually desired. I suggest using an enum as the implementation with the hope that it will simplify implementation.<br>&gt;&gt; <br>&gt;&gt; Your suggestion of `static struct` emphasizes the utility of a namespace keyword. Is `static struct …` a declaration of a type or an instance and of what? <br>&gt;&gt; <br>&gt;&gt; TJ<br>&gt;&gt; <br>&gt;&gt; On Sun, Dec 13, 2015 at 6:44 PM, Cole Kurkowski &lt;crk at fastmail.com &lt;mailto:crk at fastmail.com&gt;&gt; wrote:<br>&gt;&gt; IMO using  an enum is non-intuitive. A struct is a &quot;bucket of values&quot; and so makes fits with the usage here. If the ability to instantiate the NotificationNames struct is a problem, adding a <br>&gt;&gt; <br>&gt;&gt; private init() <br>&gt;&gt; {<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; seems more intuitive than co-opting an enum, which has a fairly established use case. <br>&gt;&gt; <br>&gt;&gt; Your proposal would essentially be adding a keyword that is transformed back into &quot;enum&quot; during compilation. I don&#39;t think that a relatively minor improvement in clarity for a fairly small use case is worth adding a language feature.<br>&gt;&gt; <br>&gt;&gt; Allowing structs to be declared as static would be another way of simplifying this kind of declaration, i.e.<br>&gt;&gt; <br>&gt;&gt; static struct NotificationNames {<br>&gt;&gt;      let userDataChanged = ...<br>&gt;&gt;      let recievedAlert = ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This would allow dropping the private init declaration and dropping the static from each property. I&#39;m not sure I think this shortcut is necessary or even if it&#39;s a good idea, but I do think it fits with the language a little better than your current proposal. <br>&gt;&gt; <br>&gt;&gt; On Dec 11, 2015, at 04:39, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Namespaces<br>&gt;&gt;&gt; Author(s): TJ Usiyan<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A `namespace` keyword for swift hold related global variables.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We often want to collect related variables which do not, for whatever reason, fit neatly into a type provided by Swift. Importing Objective C &#39;magic strings&#39; as Joshua Sullivan does [here] is one such example. The solution he arrives at is a `struct` type with many type variables and no fields.<br>&gt;&gt;&gt; 	<br>&gt;&gt;&gt; 	struct NotificationNames {<br>&gt;&gt;&gt; 	  static let userDataChanged = &quot;UserDataChangedNotificationName&quot;<br>&gt;&gt;&gt; 	  static let receivedAlert = &quot;ReceivedAlertNotificationName&quot;<br>&gt;&gt;&gt; 	  static let peanutButterJellyTime = &quot;ItsPeanutButterJellyTimeNotificationName&quot;<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Users of this API are not meant to create instances of this type, yet it is still possible. A solution to this is to use an `enum` without cases. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	enum NotificationNames {<br>&gt;&gt;&gt; 	  static let userDataChanged = &quot;UserDataChangedNotificationName&quot;<br>&gt;&gt;&gt; 	  static let receivedAlert = &quot;ReceivedAlertNotificationName&quot;<br>&gt;&gt;&gt; 	  static let peanutButterJellyTime = &quot;ItsPeanutButterJellyTimeNotificationName&quot;<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No instances of the `enum` can be made. That this inability to create an instance is intentional is only conveyed via the type system. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Clarity would be greatly improved if we could use `namespace` as a synonym for an enum with no cases. This would allow us to avoid repetition of `static` as well.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	namespace NotificationNames {<br>&gt;&gt;&gt; 	  let userDataChanged = &quot;UserDataChangedNotificationName&quot;<br>&gt;&gt;&gt; 	  let receivedAlert = &quot;ReceivedAlertNotificationName&quot;<br>&gt;&gt;&gt; 	  let peanutButterJellyTime = &quot;ItsPeanutButterJellyTimeNotificationName&quot;<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Detailed design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Namespaces can be represented in the type system as enums. All variables declared in a namespace&#39;s scope would be type variables.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is an additive change and, as such, should not break any existing code. Though it doesn&#39;t matter, this addition could possibly attain ABI compatibility if namespaces are represented as enums without cases.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Don&#39;t implement namespaces. Developers could continue(begin?) using an empty enum to hold type variables.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160114/5ed90434/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Proposal: Namespaces</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January 14, 2016 at 03:00:00pm</p></header><div class="content"><p>I would love it if enums could be backed by any struct type, which I think would solve this specific problem, but it won&#39;t be possible before Swift has a model for compile-time-constant expressions.<br></p><p>Félix<br></p><p>&gt; Le 14 janv. 2016 à 14:34:11, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; What’s the status on this? Is someone willing to write a proper proposal for this?<br>&gt; <br>&gt; I just ran into to this yesterday. I have a project has multiple parsers and naturally, there is a need for multiple `Tokenizer` classes. It’s getting a big obnoxious to continue abuse struct/enum for this.<br>&gt; <br>&gt; -David<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 13, 2015, at 5:31 PM, Cole Kurkowski via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; 100% agree that using a struct this way is far from ideal. I just don&#39;t think the problem here is realistically that big of a deal. <br>&gt;&gt; <br>&gt;&gt; If there were major performance gains to be had from the compiler knowing a data structure was essentially a set of grouped constants, then I would completely support adding a keyword to indicate such. I don&#39;t believe that&#39;s the case though, as it stands I believe both your proposal and my alternative are just syntactic sugar with the potential for confusion.<br>&gt;&gt; <br>&gt;&gt; On Dec 13, 2015, at 18:16, T.J. Usiyan &lt;griotspeak at gmail.com &lt;mailto:griotspeak at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; The use case described in the proposal and your response doesn&#39;t use structs as a &quot;bucket of values&quot;. I uses *the type* as a bucket of values. The point of using an empty enum is to emphasize this point. The overal point of this proposal is to introduce semantics that obviate the need to &#39;decide&#39; between enum and struct since neither are the type actually desired. I suggest using an enum as the implementation with the hope that it will simplify implementation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Your suggestion of `static struct` emphasizes the utility of a namespace keyword. Is `static struct …` a declaration of a type or an instance and of what? <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; TJ<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Sun, Dec 13, 2015 at 6:44 PM, Cole Kurkowski &lt;crk at fastmail.com &lt;mailto:crk at fastmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; IMO using  an enum is non-intuitive. A struct is a &quot;bucket of values&quot; and so makes fits with the usage here. If the ability to instantiate the NotificationNames struct is a problem, adding a <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; private init() <br>&gt;&gt;&gt; {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; seems more intuitive than co-opting an enum, which has a fairly established use case. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Your proposal would essentially be adding a keyword that is transformed back into &quot;enum&quot; during compilation. I don&#39;t think that a relatively minor improvement in clarity for a fairly small use case is worth adding a language feature.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Allowing structs to be declared as static would be another way of simplifying this kind of declaration, i.e.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; static struct NotificationNames {<br>&gt;&gt;&gt;      let userDataChanged = ...<br>&gt;&gt;&gt;      let recievedAlert = ...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This would allow dropping the private init declaration and dropping the static from each property. I&#39;m not sure I think this shortcut is necessary or even if it&#39;s a good idea, but I do think it fits with the language a little better than your current proposal. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 11, 2015, at 04:39, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Namespaces<br>&gt;&gt;&gt;&gt; Author(s): TJ Usiyan<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A `namespace` keyword for swift hold related global variables.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We often want to collect related variables which do not, for whatever reason, fit neatly into a type provided by Swift. Importing Objective C &#39;magic strings&#39; as Joshua Sullivan does [here] is one such example. The solution he arrives at is a `struct` type with many type variables and no fields.<br>&gt;&gt;&gt;&gt; 	<br>&gt;&gt;&gt;&gt; 	struct NotificationNames {<br>&gt;&gt;&gt;&gt; 	  static let userDataChanged = &quot;UserDataChangedNotificationName&quot;<br>&gt;&gt;&gt;&gt; 	  static let receivedAlert = &quot;ReceivedAlertNotificationName&quot;<br>&gt;&gt;&gt;&gt; 	  static let peanutButterJellyTime = &quot;ItsPeanutButterJellyTimeNotificationName&quot;<br>&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Users of this API are not meant to create instances of this type, yet it is still possible. A solution to this is to use an `enum` without cases. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	enum NotificationNames {<br>&gt;&gt;&gt;&gt; 	  static let userDataChanged = &quot;UserDataChangedNotificationName&quot;<br>&gt;&gt;&gt;&gt; 	  static let receivedAlert = &quot;ReceivedAlertNotificationName&quot;<br>&gt;&gt;&gt;&gt; 	  static let peanutButterJellyTime = &quot;ItsPeanutButterJellyTimeNotificationName&quot;<br>&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; No instances of the `enum` can be made. That this inability to create an instance is intentional is only conveyed via the type system. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Clarity would be greatly improved if we could use `namespace` as a synonym for an enum with no cases. This would allow us to avoid repetition of `static` as well.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	namespace NotificationNames {<br>&gt;&gt;&gt;&gt; 	  let userDataChanged = &quot;UserDataChangedNotificationName&quot;<br>&gt;&gt;&gt;&gt; 	  let receivedAlert = &quot;ReceivedAlertNotificationName&quot;<br>&gt;&gt;&gt;&gt; 	  let peanutButterJellyTime = &quot;ItsPeanutButterJellyTimeNotificationName&quot;<br>&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Detailed design<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Namespaces can be represented in the type system as enums. All variables declared in a namespace&#39;s scope would be type variables.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is an additive change and, as such, should not break any existing code. Though it doesn&#39;t matter, this addition could possibly attain ABI compatibility if namespaces are represented as enums without cases.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Don&#39;t implement namespaces. Developers could continue(begin?) using an empty enum to hold type variables.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160114/86ab9e97/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
