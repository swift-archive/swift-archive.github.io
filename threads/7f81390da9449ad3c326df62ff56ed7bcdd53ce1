<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/009173d589176cfd9c8146cc49849ff6?s=50"></div><header><strong>Proposal: Allow class cluster pattern via dynamic initializer return type</strong> from <string>Riley Testut</string> &lt;rileytestut at gmail.com&gt;<p>December  7, 2015 at 12:00:00pm</p></header><div class="content"><p>Happy Monday everyone!<br></p><p>I wrote up a prototype proposal, which is probably best viewed on GitHub (<br>https://github.com/rileytestut/swift-proposals/blob/master/class-cluster.md).<br>But for convenience, I’ve included it in this email body as well. Hopefully<br>someone else thinks this would be an idea worth considering :-)<br></p><p>*## Introduction*<br></p><p>Throughout its frameworks, Apple makes use of the “class cluster” pattern<br>as a means to separate the public API out from the (potentially complex)<br>internal representations of the data. Clients of the API simply use the<br>public API, while under the hood a different implementation is chosen to<br>most efficiently represent the provided initialization parameter values.<br></p><p>Unfortunately, because initializers in Swift are not methods like in<br>Objective-C, there is no way to specify what the actual return value should<br>be (short of returning nil for failable initializers). This makes it<br>*impossible* to actually implement the class cluster pattern in Swift.<br></p><p>*## Motivation*<br></p><p>While developing my own Swift framework, I found myself wanting to provide<br>a similar functionality. For the client of said framework, I wanted them to<br>be able to create an instance of an essentially abstract class, and be<br>returned a private subclass instance suited best for handling whatever<br>input initialization parameters they provided. It didn’t make sense given<br>the circumstances to ask the user to decide which class would be the best<br>representation of the data; it should “just work”.<br></p><p>Additionally, the class cluster pattern can make backwards compatibility<br>significantly easier; instead of littering your code with branches for<br>different versions of an OS, you could instead have one if/switch statement<br>to determine the appropriate subclass for the current OS you’re running on.<br>This allows the developer to trivially keep legacy code for older platforms<br>while taking advantage of new APIs/designs, and also without changing *any*<br>client code. An example of the class cluster pattern being used for this<br>reason can be seen here:<br>http://www.xs-labs.com/en/blog/2013/06/18/ios7-new-ui-strategies/<br></p><p>*## Proposed solution*<br></p><p>I propose that we allow for implementation of the class cluster pattern by<br>providing a way to (at run time) specify the actual type that should be<br>initialized depending on the provided initialization parameters.<br></p><p>*## Detailed design*<br></p><p>*Introduce a new class method that can return an appropriate type that<br>should be used for initialization, depending on the provided initialization<br>parameters.*<br></p><p>This is what I believe to be the most clean solution, and with (assumedly)<br>minimal impact on the existing nature of Swift’s initialization process. To<br>ensure this remains safe, the only types allowed to be returned should be<br>subclasses of the parent class (such as returning a __NSArrayI for<br>NSArray). Notably, beyond this method, everything else remains the same;<br>all this does is change what class the initializer is called on initially.<br></p><p>Here is an ideal implementation gist:<br>https://gist.github.com/rileytestut/0e6e80d3f22b845502e7<br></p><p>*## Impact on existing code*<br></p><p>There will be zero impact on existing code; if the proposed class method is<br>not implemented, then it will default to simply initializing the “base”<br>class, as it always has.<br></p><p>*## Alternatives considered*<br></p><p>*Allow for return values in initializers*<br></p><p>This is essentially how most class cluster patterns are implemented in<br>Objective-C. Inside the init method, the class inspects the provided<br>parameters, then assigns self to an instance of the appropriate subclass.<br>Unfortunately, this is wasteful; memory is allocated for the base class,<br>and then subsequently replaced with new memory allocated for the<br>appropriate base class. More importantly though, the whole process can be<br>complicated; it can be very easy to make an infinite recursive loop by<br>calling [super init] in the subclass, which then assigns self to a new<br>instance of the subclass, which then calls [super init]…etc.<br></p><p>tl;dr; this method would work, but would be somewhat inconvenient to<br>implement.<br></p><p>*Class function to return appropriate instance*<br></p><p>This is probably the simplest approach: simply make a class function that<br>returns an instance of the appropriate class given a few input parameters.<br>This totally works, but it means consumers of the API have to remember to<br>use the class method instead of the initializer. Even if all initializers<br>for the class were marked private, it would be strange to have the<br>dissonance between using initializers and class methods to instantiate<br>types in code. The consumer should not have to know about *any* of the<br>implementation details; everything should “just work”. Forcing them to use<br>alternative means to instantiate objects breaks this philosophy, IMO.<br></p><p>*Derive from Objective-C base class*<br></p><p>Another option is to simply derive from an Objective-C base class, and this<br>is actually what I am doing right now in my framework. Unfortunately, there<br>is one significant drawback: because the initialization is happening in<br>Objective-C, you can only provide Objective-C compatible types for the<br>initialization parameters (so no Swift structs for you!). Additionally,<br>this (obviously) means whatever code is using it is limited to systems with<br>Objective-C support, so it is not as portable as a pure-Swift solution.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/7f813ce1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a726de03bed3104ddaecca3fdcf59e19?s=50"></div><header><strong>Proposal: Allow class cluster pattern via dynamic initializer return type</strong> from <string>Ling Wang</string> &lt;an00na at gmail.com&gt;<p>December  7, 2015 at 08:00:00pm</p></header><div class="content"><p>Why not use factory methods?<br>On Mon, Dec 7, 2015 at 2:19 PM Riley Testut via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Happy Monday everyone!<br>&gt;<br>&gt; I wrote up a prototype proposal, which is probably best viewed on GitHub (<br>&gt; https://github.com/rileytestut/swift-proposals/blob/master/class-cluster.md).<br>&gt; But for convenience, I’ve included it in this email body as well. Hopefully<br>&gt; someone else thinks this would be an idea worth considering :-)<br>&gt;<br>&gt; *## Introduction*<br>&gt;<br>&gt; Throughout its frameworks, Apple makes use of the “class cluster” pattern<br>&gt; as a means to separate the public API out from the (potentially complex)<br>&gt; internal representations of the data. Clients of the API simply use the<br>&gt; public API, while under the hood a different implementation is chosen to<br>&gt; most efficiently represent the provided initialization parameter values.<br>&gt;<br>&gt; Unfortunately, because initializers in Swift are not methods like in<br>&gt; Objective-C, there is no way to specify what the actual return value should<br>&gt; be (short of returning nil for failable initializers). This makes it<br>&gt; *impossible* to actually implement the class cluster pattern in Swift.<br>&gt;<br>&gt; *## Motivation*<br>&gt;<br>&gt; While developing my own Swift framework, I found myself wanting to provide<br>&gt; a similar functionality. For the client of said framework, I wanted them to<br>&gt; be able to create an instance of an essentially abstract class, and be<br>&gt; returned a private subclass instance suited best for handling whatever<br>&gt; input initialization parameters they provided. It didn’t make sense given<br>&gt; the circumstances to ask the user to decide which class would be the best<br>&gt; representation of the data; it should “just work”.<br>&gt;<br>&gt; Additionally, the class cluster pattern can make backwards compatibility<br>&gt; significantly easier; instead of littering your code with branches for<br>&gt; different versions of an OS, you could instead have one if/switch statement<br>&gt; to determine the appropriate subclass for the current OS you’re running on.<br>&gt; This allows the developer to trivially keep legacy code for older platforms<br>&gt; while taking advantage of new APIs/designs, and also without changing *any*<br>&gt; client code. An example of the class cluster pattern being used for this<br>&gt; reason can be seen here:<br>&gt; http://www.xs-labs.com/en/blog/2013/06/18/ios7-new-ui-strategies/<br>&gt;<br>&gt; *## Proposed solution*<br>&gt;<br>&gt; I propose that we allow for implementation of the class cluster pattern by<br>&gt; providing a way to (at run time) specify the actual type that should be<br>&gt; initialized depending on the provided initialization parameters.<br>&gt;<br>&gt; *## Detailed design*<br>&gt;<br>&gt; *Introduce a new class method that can return an appropriate type that<br>&gt; should be used for initialization, depending on the provided initialization<br>&gt; parameters.*<br>&gt;<br>&gt; This is what I believe to be the most clean solution, and with (assumedly)<br>&gt; minimal impact on the existing nature of Swift’s initialization process. To<br>&gt; ensure this remains safe, the only types allowed to be returned should be<br>&gt; subclasses of the parent class (such as returning a __NSArrayI for<br>&gt; NSArray). Notably, beyond this method, everything else remains the same;<br>&gt; all this does is change what class the initializer is called on initially.<br>&gt;<br>&gt; Here is an ideal implementation gist:<br>&gt; https://gist.github.com/rileytestut/0e6e80d3f22b845502e7<br>&gt;<br>&gt; *## Impact on existing code*<br>&gt;<br>&gt; There will be zero impact on existing code; if the proposed class method<br>&gt; is not implemented, then it will default to simply initializing the “base”<br>&gt; class, as it always has.<br>&gt;<br>&gt; *## Alternatives considered*<br>&gt;<br>&gt; *Allow for return values in initializers*<br>&gt;<br>&gt; This is essentially how most class cluster patterns are implemented in<br>&gt; Objective-C. Inside the init method, the class inspects the provided<br>&gt; parameters, then assigns self to an instance of the appropriate subclass.<br>&gt; Unfortunately, this is wasteful; memory is allocated for the base class,<br>&gt; and then subsequently replaced with new memory allocated for the<br>&gt; appropriate base class. More importantly though, the whole process can be<br>&gt; complicated; it can be very easy to make an infinite recursive loop by<br>&gt; calling [super init] in the subclass, which then assigns self to a new<br>&gt; instance of the subclass, which then calls [super init]…etc.<br>&gt;<br>&gt; tl;dr; this method would work, but would be somewhat inconvenient to<br>&gt; implement.<br>&gt;<br>&gt; *Class function to return appropriate instance*<br>&gt;<br>&gt; This is probably the simplest approach: simply make a class function that<br>&gt; returns an instance of the appropriate class given a few input parameters.<br>&gt; This totally works, but it means consumers of the API have to remember to<br>&gt; use the class method instead of the initializer. Even if all initializers<br>&gt; for the class were marked private, it would be strange to have the<br>&gt; dissonance between using initializers and class methods to instantiate<br>&gt; types in code. The consumer should not have to know about *any* of the<br>&gt; implementation details; everything should “just work”. Forcing them to use<br>&gt; alternative means to instantiate objects breaks this philosophy, IMO.<br>&gt;<br>&gt; *Derive from Objective-C base class*<br>&gt;<br>&gt; Another option is to simply derive from an Objective-C base class, and<br>&gt; this is actually what I am doing right now in my framework. Unfortunately,<br>&gt; there is one significant drawback: because the initialization is happening<br>&gt; in Objective-C, you can only provide Objective-C compatible types for the<br>&gt; initialization parameters (so no Swift structs for you!). Additionally,<br>&gt; this (obviously) means whatever code is using it is limited to systems with<br>&gt; Objective-C support, so it is not as portable as a pure-Swift solution.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/c5d1a7d6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/009173d589176cfd9c8146cc49849ff6?s=50"></div><header><strong>Proposal: Allow class cluster pattern via dynamic initializer return type</strong> from <string>Riley Testut</string> &lt;rileytestut at gmail.com&gt;<p>December  7, 2015 at 12:00:00pm</p></header><div class="content"><p>Personally, I think enforcing factory methods is a way of leaking implementation details; there is no reason why the consumer of the API should have to question whether they should use an initializer or a factory method, because they shouldn&#39;t need to think about it at all. Especially in my case, this is used quite frequently, so having to remember to use a factory method for all necessary types is just annoying.<br></p><p>Imagine if NSString used factory methods instead of initializers. It&#39;d be far less convenient, because you&#39;d have to mentally note that you *can&#39;t* initialize that class directly. Blech.<br></p><p>&gt; On Dec 7, 2015, at 12:30 PM, an0 &lt;an00na at gmail.com&gt; wrote:<br>&gt; <br>&gt; Why not use factory methods?<br>&gt;&gt; On Mon, Dec 7, 2015 at 2:19 PM Riley Testut via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Happy Monday everyone!<br>&gt;&gt; <br>&gt;&gt; I wrote up a prototype proposal, which is probably best viewed on GitHub (https://github.com/rileytestut/swift-proposals/blob/master/class-cluster.md). But for convenience, I’ve included it in this email body as well. Hopefully someone else thinks this would be an idea worth considering :-) <br>&gt;&gt; <br>&gt;&gt; ## Introduction<br>&gt;&gt; <br>&gt;&gt; Throughout its frameworks, Apple makes use of the “class cluster” pattern as a means to separate the public API out from the (potentially complex) internal representations of the data. Clients of the API simply use the public API, while under the hood a different implementation is chosen to most efficiently represent the provided initialization parameter values.<br>&gt;&gt; <br>&gt;&gt; Unfortunately, because initializers in Swift are not methods like in Objective-C, there is no way to specify what the actual return value should be (short of returning nil for failable initializers). This makes it *impossible* to actually implement the class cluster pattern in Swift.<br>&gt;&gt; <br>&gt;&gt; ## Motivation<br>&gt;&gt; <br>&gt;&gt; While developing my own Swift framework, I found myself wanting to provide a similar functionality. For the client of said framework, I wanted them to be able to create an instance of an essentially abstract class, and be returned a private subclass instance suited best for handling whatever input initialization parameters they provided. It didn’t make sense given the circumstances to ask the user to decide which class would be the best representation of the data; it should “just work”.<br>&gt;&gt; <br>&gt;&gt; Additionally, the class cluster pattern can make backwards compatibility significantly easier; instead of littering your code with branches for different versions of an OS, you could instead have one if/switch statement to determine the appropriate subclass for the current OS you’re running on. This allows the developer to trivially keep legacy code for older platforms while taking advantage of new APIs/designs, and also without changing *any* client code. An example of the class cluster pattern being used for this reason can be seen here: http://www.xs-labs.com/en/blog/2013/06/18/ios7-new-ui-strategies/<br>&gt;&gt; <br>&gt;&gt; ## Proposed solution<br>&gt;&gt; <br>&gt;&gt; I propose that we allow for implementation of the class cluster pattern by providing a way to (at run time) specify the actual type that should be initialized depending on the provided initialization parameters.<br>&gt;&gt; <br>&gt;&gt; ## Detailed design<br>&gt;&gt; <br>&gt;&gt; Introduce a new class method that can return an appropriate type that should be used for initialization, depending on the provided initialization parameters.<br>&gt;&gt; <br>&gt;&gt; This is what I believe to be the most clean solution, and with (assumedly) minimal impact on the existing nature of Swift’s initialization process. To ensure this remains safe, the only types allowed to be returned should be subclasses of the parent class (such as returning a __NSArrayI for NSArray). Notably, beyond this method, everything else remains the same; all this does is change what class the initializer is called on initially.<br>&gt;&gt; <br>&gt;&gt; Here is an ideal implementation gist:<br>&gt;&gt; https://gist.github.com/rileytestut/0e6e80d3f22b845502e7<br>&gt;&gt; <br>&gt;&gt; ## Impact on existing code<br>&gt;&gt; <br>&gt;&gt; There will be zero impact on existing code; if the proposed class method is not implemented, then it will default to simply initializing the “base” class, as it always has.<br>&gt;&gt; <br>&gt;&gt; ## Alternatives considered<br>&gt;&gt; <br>&gt;&gt; Allow for return values in initializers<br>&gt;&gt; <br>&gt;&gt; This is essentially how most class cluster patterns are implemented in Objective-C. Inside the init method, the class inspects the provided parameters, then assigns self to an instance of the appropriate subclass. Unfortunately, this is wasteful; memory is allocated for the base class, and then subsequently replaced with new memory allocated for the appropriate base class. More importantly though, the whole process can be complicated; it can be very easy to make an infinite recursive loop by calling [super init] in the subclass, which then assigns self to a new instance of the subclass, which then calls [super init]…etc. <br>&gt;&gt; <br>&gt;&gt; tl;dr; this method would work, but would be somewhat inconvenient to implement.<br>&gt;&gt; <br>&gt;&gt; Class function to return appropriate instance<br>&gt;&gt; <br>&gt;&gt; This is probably the simplest approach: simply make a class function that returns an instance of the appropriate class given a few input parameters. This totally works, but it means consumers of the API have to remember to use the class method instead of the initializer. Even if all initializers for the class were marked private, it would be strange to have the dissonance between using initializers and class methods to instantiate types in code. The consumer should not have to know about *any* of the implementation details; everything should “just work”. Forcing them to use alternative means to instantiate objects breaks this philosophy, IMO.<br>&gt;&gt; <br>&gt;&gt; Derive from Objective-C base class<br>&gt;&gt; <br>&gt;&gt; Another option is to simply derive from an Objective-C base class, and this is actually what I am doing right now in my framework. Unfortunately, there is one significant drawback: because the initialization is happening in Objective-C, you can only provide Objective-C compatible types for the initialization parameters (so no Swift structs for you!). Additionally, this (obviously) means whatever code is using it is limited to systems with Objective-C support, so it is not as portable as a pure-Swift solution.<br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/f9e8dd63/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>Proposal: Allow class cluster pattern via dynamic initializer return type</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>December  7, 2015 at 12:00:00pm</p></header><div class="content"><p>Well, the basic idea of a class cluster is to hide the internal implementation. The caller of the API is still supposed to get back an instance of the clustered type (or that conforms to the interface at least).<br></p><p>It’s still possible to create class clusters though; here’s an example playground:<br></p><p>private protocol _Cluster {<br>    func description() -&gt; String<br>}<br></p><p>class Cluster {<br>    <br>    private var _instance: _Cluster<br>    <br>    init(name: String) {<br>        _instance = _ClusterString(name: name)<br>    }<br>    <br>    init(value: Int) {<br>        _instance = _ClusterValue(value: value)<br>    }<br>    <br>    func description() -&gt; String {<br>        return _instance.description()<br>    }<br>}<br></p><p>private class _ClusterString: _Cluster {<br>    private var name: String<br>    init(name: String) { self.name = name }<br>    func description() -&gt; String {<br>        return &quot;_ClusterString: \(name)&quot;<br>    }<br>}<br></p><p>private class _ClusterValue: _Cluster {<br>    private var value: Int<br>    init(value: Int) { self.value = value }<br>    func description() -&gt; String {<br>        return &quot;_ClusterValue: \(value)&quot;<br>    }<br>}<br></p><p>let s = Cluster(name: &quot;a string&quot;)<br>s.description()<br></p><p>let v = Cluster(value: 12)<br>v.description()<br></p><p><br>The implementation is different from how ObjC implements class clusters, but the end result is nearly identical in functionality. If Swift had a form of function redirection, this pattern could be supported with less boiler-plate. However, I don’t believe this proposal is necessary to support class clusters.<br></p><p>-David<br></p><p><br>&gt; On Dec 7, 2015, at 12:19 PM, Riley Testut via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Happy Monday everyone!<br>&gt; <br>&gt; I wrote up a prototype proposal, which is probably best viewed on GitHub (https://github.com/rileytestut/swift-proposals/blob/master/class-cluster.md &lt;https://github.com/rileytestut/swift-proposals/blob/master/class-cluster.md&gt;). But for convenience, I’ve included it in this email body as well. Hopefully someone else thinks this would be an idea worth considering :-) <br>&gt; <br>&gt; ## Introduction<br>&gt; <br>&gt; Throughout its frameworks, Apple makes use of the “class cluster” pattern as a means to separate the public API out from the (potentially complex) internal representations of the data. Clients of the API simply use the public API, while under the hood a different implementation is chosen to most efficiently represent the provided initialization parameter values.<br>&gt; <br>&gt; Unfortunately, because initializers in Swift are not methods like in Objective-C, there is no way to specify what the actual return value should be (short of returning nil for failable initializers). This makes it *impossible* to actually implement the class cluster pattern in Swift.<br>&gt; <br>&gt; ## Motivation<br>&gt; <br>&gt; While developing my own Swift framework, I found myself wanting to provide a similar functionality. For the client of said framework, I wanted them to be able to create an instance of an essentially abstract class, and be returned a private subclass instance suited best for handling whatever input initialization parameters they provided. It didn’t make sense given the circumstances to ask the user to decide which class would be the best representation of the data; it should “just work”.<br>&gt; <br>&gt; Additionally, the class cluster pattern can make backwards compatibility significantly easier; instead of littering your code with branches for different versions of an OS, you could instead have one if/switch statement to determine the appropriate subclass for the current OS you’re running on. This allows the developer to trivially keep legacy code for older platforms while taking advantage of new APIs/designs, and also without changing *any* client code. An example of the class cluster pattern being used for this reason can be seen here: http://www.xs-labs.com/en/blog/2013/06/18/ios7-new-ui-strategies/ &lt;http://www.xs-labs.com/en/blog/2013/06/18/ios7-new-ui-strategies/&gt;<br>&gt; <br>&gt; ## Proposed solution<br>&gt; <br>&gt; I propose that we allow for implementation of the class cluster pattern by providing a way to (at run time) specify the actual type that should be initialized depending on the provided initialization parameters.<br>&gt; <br>&gt; ## Detailed design<br>&gt; <br>&gt; Introduce a new class method that can return an appropriate type that should be used for initialization, depending on the provided initialization parameters.<br>&gt; <br>&gt; This is what I believe to be the most clean solution, and with (assumedly) minimal impact on the existing nature of Swift’s initialization process. To ensure this remains safe, the only types allowed to be returned should be subclasses of the parent class (such as returning a __NSArrayI for NSArray). Notably, beyond this method, everything else remains the same; all this does is change what class the initializer is called on initially.<br>&gt; <br>&gt; Here is an ideal implementation gist:<br>&gt; https://gist.github.com/rileytestut/0e6e80d3f22b845502e7 &lt;https://gist.github.com/rileytestut/0e6e80d3f22b845502e7&gt;<br>&gt; <br>&gt; ## Impact on existing code<br>&gt; <br>&gt; There will be zero impact on existing code; if the proposed class method is not implemented, then it will default to simply initializing the “base” class, as it always has.<br>&gt; <br>&gt; ## Alternatives considered<br>&gt; <br>&gt; Allow for return values in initializers<br>&gt; <br>&gt; This is essentially how most class cluster patterns are implemented in Objective-C. Inside the init method, the class inspects the provided parameters, then assigns self to an instance of the appropriate subclass. Unfortunately, this is wasteful; memory is allocated for the base class, and then subsequently replaced with new memory allocated for the appropriate base class. More importantly though, the whole process can be complicated; it can be very easy to make an infinite recursive loop by calling [super init] in the subclass, which then assigns self to a new instance of the subclass, which then calls [super init]…etc. <br>&gt; <br>&gt; tl;dr; this method would work, but would be somewhat inconvenient to implement.<br>&gt; <br>&gt; Class function to return appropriate instance<br>&gt; <br>&gt; This is probably the simplest approach: simply make a class function that returns an instance of the appropriate class given a few input parameters. This totally works, but it means consumers of the API have to remember to use the class method instead of the initializer. Even if all initializers for the class were marked private, it would be strange to have the dissonance between using initializers and class methods to instantiate types in code. The consumer should not have to know about *any* of the implementation details; everything should “just work”. Forcing them to use alternative means to instantiate objects breaks this philosophy, IMO.<br>&gt; <br>&gt; Derive from Objective-C base class<br>&gt; <br>&gt; Another option is to simply derive from an Objective-C base class, and this is actually what I am doing right now in my framework. Unfortunately, there is one significant drawback: because the initialization is happening in Objective-C, you can only provide Objective-C compatible types for the initialization parameters (so no Swift structs for you!). Additionally, this (obviously) means whatever code is using it is limited to systems with Objective-C support, so it is not as portable as a pure-Swift solution.<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/50368c46/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Proposal: Allow class cluster pattern via dynamic initializer return type</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>December  7, 2015 at 08:00:00pm</p></header><div class="content"><p>To me it seems a simpler solution would be to allow `return`ing a different<br>object (or assigning to self) from inside init.<br></p><p>On Mon, Dec 7, 2015 at 12:55 PM David Owens II via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Well, the basic idea of a class cluster is to hide the internal<br>&gt; implementation. The caller of the API is still supposed to get back an<br>&gt; instance of the clustered type (or that conforms to the interface at least).<br>&gt;<br>&gt; It’s still possible to create class clusters though; here’s an example<br>&gt; playground:<br>&gt;<br>&gt; private protocol _Cluster {<br>&gt;     func description() -&gt; String<br>&gt; }<br>&gt;<br>&gt; class Cluster {<br>&gt;<br>&gt;     private var _instance: _Cluster<br>&gt;<br>&gt;     init(name: String) {<br>&gt;         _instance = _ClusterString(name: name)<br>&gt;     }<br>&gt;<br>&gt;     init(value: Int) {<br>&gt;         _instance = _ClusterValue(value: value)<br>&gt;     }<br>&gt;<br>&gt;     func description() -&gt; String {<br>&gt;         return _instance.description()<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; private class _ClusterString: _Cluster {<br>&gt;     private var name: String<br>&gt;     init(name: String) { self.name = name }<br>&gt;     func description() -&gt; String {<br>&gt;         return &quot;_ClusterString: \(name)&quot;<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; private class _ClusterValue: _Cluster {<br>&gt;     private var value: Int<br>&gt;     init(value: Int) { self.value = value }<br>&gt;     func description() -&gt; String {<br>&gt;         return &quot;_ClusterValue: \(value)&quot;<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; let s = Cluster(name: &quot;a string&quot;)<br>&gt; s.description()<br>&gt;<br>&gt; let v = Cluster(value: 12)<br>&gt; v.description()<br>&gt;<br>&gt;<br>&gt;<br>&gt; The implementation is different from how ObjC implements class clusters,<br>&gt; but the end result is nearly identical in functionality. If Swift had a<br>&gt; form of function redirection, this pattern could be supported with less<br>&gt; boiler-plate. However, I don’t believe this proposal is necessary to<br>&gt; support class clusters.<br>&gt;<br>&gt; -David<br>&gt;<br>&gt;<br>&gt; On Dec 7, 2015, at 12:19 PM, Riley Testut via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Happy Monday everyone!<br>&gt;<br>&gt; I wrote up a prototype proposal, which is probably best viewed on GitHub (<br>&gt; https://github.com/rileytestut/swift-proposals/blob/master/class-cluster.md).<br>&gt; But for convenience, I’ve included it in this email body as well. Hopefully<br>&gt; someone else thinks this would be an idea worth considering :-)<br>&gt;<br>&gt; *## Introduction*<br>&gt;<br>&gt; Throughout its frameworks, Apple makes use of the “class cluster” pattern<br>&gt; as a means to separate the public API out from the (potentially complex)<br>&gt; internal representations of the data. Clients of the API simply use the<br>&gt; public API, while under the hood a different implementation is chosen to<br>&gt; most efficiently represent the provided initialization parameter values.<br>&gt;<br>&gt; Unfortunately, because initializers in Swift are not methods like in<br>&gt; Objective-C, there is no way to specify what the actual return value should<br>&gt; be (short of returning nil for failable initializers). This makes it<br>&gt; *impossible* to actually implement the class cluster pattern in Swift.<br>&gt;<br>&gt; *## Motivation*<br>&gt;<br>&gt; While developing my own Swift framework, I found myself wanting to provide<br>&gt; a similar functionality. For the client of said framework, I wanted them to<br>&gt; be able to create an instance of an essentially abstract class, and be<br>&gt; returned a private subclass instance suited best for handling whatever<br>&gt; input initialization parameters they provided. It didn’t make sense given<br>&gt; the circumstances to ask the user to decide which class would be the best<br>&gt; representation of the data; it should “just work”.<br>&gt;<br>&gt; Additionally, the class cluster pattern can make backwards compatibility<br>&gt; significantly easier; instead of littering your code with branches for<br>&gt; different versions of an OS, you could instead have one if/switch statement<br>&gt; to determine the appropriate subclass for the current OS you’re running on.<br>&gt; This allows the developer to trivially keep legacy code for older platforms<br>&gt; while taking advantage of new APIs/designs, and also without changing *any*<br>&gt; client code. An example of the class cluster pattern being used for this<br>&gt; reason can be seen here:<br>&gt; http://www.xs-labs.com/en/blog/2013/06/18/ios7-new-ui-strategies/<br>&gt;<br>&gt; *## Proposed solution*<br>&gt;<br>&gt; I propose that we allow for implementation of the class cluster pattern by<br>&gt; providing a way to (at run time) specify the actual type that should be<br>&gt; initialized depending on the provided initialization parameters.<br>&gt;<br>&gt; *## Detailed design*<br>&gt;<br>&gt; *Introduce a new class method that can return an appropriate type that<br>&gt; should be used for initialization, depending on the provided initialization<br>&gt; parameters.*<br>&gt;<br>&gt; This is what I believe to be the most clean solution, and with (assumedly)<br>&gt; minimal impact on the existing nature of Swift’s initialization process. To<br>&gt; ensure this remains safe, the only types allowed to be returned should be<br>&gt; subclasses of the parent class (such as returning a __NSArrayI for<br>&gt; NSArray). Notably, beyond this method, everything else remains the same;<br>&gt; all this does is change what class the initializer is called on initially.<br>&gt;<br>&gt; Here is an ideal implementation gist:<br>&gt; https://gist.github.com/rileytestut/0e6e80d3f22b845502e7<br>&gt;<br>&gt; *## Impact on existing code*<br>&gt;<br>&gt; There will be zero impact on existing code; if the proposed class method<br>&gt; is not implemented, then it will default to simply initializing the “base”<br>&gt; class, as it always has.<br>&gt;<br>&gt; *## Alternatives considered*<br>&gt;<br>&gt; *Allow for return values in initializers*<br>&gt;<br>&gt; This is essentially how most class cluster patterns are implemented in<br>&gt; Objective-C. Inside the init method, the class inspects the provided<br>&gt; parameters, then assigns self to an instance of the appropriate subclass.<br>&gt; Unfortunately, this is wasteful; memory is allocated for the base class,<br>&gt; and then subsequently replaced with new memory allocated for the<br>&gt; appropriate base class. More importantly though, the whole process can be<br>&gt; complicated; it can be very easy to make an infinite recursive loop by<br>&gt; calling [super init] in the subclass, which then assigns self to a new<br>&gt; instance of the subclass, which then calls [super init]…etc.<br>&gt;<br>&gt; tl;dr; this method would work, but would be somewhat inconvenient to<br>&gt; implement.<br>&gt;<br>&gt; *Class function to return appropriate instance*<br>&gt;<br>&gt; This is probably the simplest approach: simply make a class function that<br>&gt; returns an instance of the appropriate class given a few input parameters.<br>&gt; This totally works, but it means consumers of the API have to remember to<br>&gt; use the class method instead of the initializer. Even if all initializers<br>&gt; for the class were marked private, it would be strange to have the<br>&gt; dissonance between using initializers and class methods to instantiate<br>&gt; types in code. The consumer should not have to know about *any* of the<br>&gt; implementation details; everything should “just work”. Forcing them to use<br>&gt; alternative means to instantiate objects breaks this philosophy, IMO.<br>&gt;<br>&gt; *Derive from Objective-C base class*<br>&gt;<br>&gt; Another option is to simply derive from an Objective-C base class, and<br>&gt; this is actually what I am doing right now in my framework. Unfortunately,<br>&gt; there is one significant drawback: because the initialization is happening<br>&gt; in Objective-C, you can only provide Objective-C compatible types for the<br>&gt; initialization parameters (so no Swift structs for you!). Additionally,<br>&gt; this (obviously) means whatever code is using it is limited to systems with<br>&gt; Objective-C support, so it is not as portable as a pure-Swift solution.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/201bdafb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>Proposal: Allow class cluster pattern via dynamic initializer return type</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>December  7, 2015 at 01:00:00pm</p></header><div class="content"><p>You still need everything else if can return arbitrary types from init(). The only thing you don’t get from Swift today is the forwarding that is required for the _Cluster protocol. However, that problem is a more general one that has been discussed by many outside of the swift-evolution (surprised there is no proposal for that yet).<br></p><p>If forwarding was in the language, there is no difference between the implementations other than the requirement of the _instance variable.<br></p><p>&gt; On Dec 7, 2015, at 12:59 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt; To me it seems a simpler solution would be to allow `return`ing a different object (or assigning to self) from inside init.<br>&gt; <br>&gt; On Mon, Dec 7, 2015 at 12:55 PM David Owens II via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Well, the basic idea of a class cluster is to hide the internal implementation. The caller of the API is still supposed to get back an instance of the clustered type (or that conforms to the interface at least).<br>&gt; <br>&gt; It’s still possible to create class clusters though; here’s an example playground:<br>&gt; <br>&gt; private protocol _Cluster {<br>&gt;     func description() -&gt; String<br>&gt; }<br>&gt; <br>&gt; class Cluster {<br>&gt;     <br>&gt;     private var _instance: _Cluster<br>&gt;     <br>&gt;     init(name: String) {<br>&gt;         _instance = _ClusterString(name: name)<br>&gt;     }<br>&gt;     <br>&gt;     init(value: Int) {<br>&gt;         _instance = _ClusterValue(value: value)<br>&gt;     }<br>&gt;     <br>&gt;     func description() -&gt; String {<br>&gt;         return _instance.description()<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; private class _ClusterString: _Cluster {<br>&gt;     private var name: String<br>&gt;     init(name: String) { self.name &lt;http://self.name/&gt; = name }<br>&gt;     func description() -&gt; String {<br>&gt;         return &quot;_ClusterString: \(name)&quot;<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; private class _ClusterValue: _Cluster {<br>&gt;     private var value: Int<br>&gt;     init(value: Int) { self.value = value }<br>&gt;     func description() -&gt; String {<br>&gt;         return &quot;_ClusterValue: \(value)&quot;<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; let s = Cluster(name: &quot;a string&quot;)<br>&gt; s.description()<br>&gt; <br>&gt; let v = Cluster(value: 12)<br>&gt; v.description()<br>&gt; <br>&gt; <br>&gt; The implementation is different from how ObjC implements class clusters, but the end result is nearly identical in functionality. If Swift had a form of function redirection, this pattern could be supported with less boiler-plate. However, I don’t believe this proposal is necessary to support class clusters.<br>&gt; <br>&gt; -David<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 7, 2015, at 12:19 PM, Riley Testut via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Happy Monday everyone!<br>&gt;&gt; <br>&gt;&gt; I wrote up a prototype proposal, which is probably best viewed on GitHub (https://github.com/rileytestut/swift-proposals/blob/master/class-cluster.md &lt;https://github.com/rileytestut/swift-proposals/blob/master/class-cluster.md&gt;). But for convenience, I’ve included it in this email body as well. Hopefully someone else thinks this would be an idea worth considering :-) <br>&gt;&gt; <br>&gt;&gt; ## Introduction<br>&gt;&gt; <br>&gt;&gt; Throughout its frameworks, Apple makes use of the “class cluster” pattern as a means to separate the public API out from the (potentially complex) internal representations of the data. Clients of the API simply use the public API, while under the hood a different implementation is chosen to most efficiently represent the provided initialization parameter values.<br>&gt;&gt; <br>&gt;&gt; Unfortunately, because initializers in Swift are not methods like in Objective-C, there is no way to specify what the actual return value should be (short of returning nil for failable initializers). This makes it *impossible* to actually implement the class cluster pattern in Swift.<br>&gt;&gt; <br>&gt;&gt; ## Motivation<br>&gt;&gt; <br>&gt;&gt; While developing my own Swift framework, I found myself wanting to provide a similar functionality. For the client of said framework, I wanted them to be able to create an instance of an essentially abstract class, and be returned a private subclass instance suited best for handling whatever input initialization parameters they provided. It didn’t make sense given the circumstances to ask the user to decide which class would be the best representation of the data; it should “just work”.<br>&gt;&gt; <br>&gt;&gt; Additionally, the class cluster pattern can make backwards compatibility significantly easier; instead of littering your code with branches for different versions of an OS, you could instead have one if/switch statement to determine the appropriate subclass for the current OS you’re running on. This allows the developer to trivially keep legacy code for older platforms while taking advantage of new APIs/designs, and also without changing *any* client code. An example of the class cluster pattern being used for this reason can be seen here: http://www.xs-labs.com/en/blog/2013/06/18/ios7-new-ui-strategies/ &lt;http://www.xs-labs.com/en/blog/2013/06/18/ios7-new-ui-strategies/&gt;<br>&gt;&gt; <br>&gt;&gt; ## Proposed solution<br>&gt;&gt; <br>&gt;&gt; I propose that we allow for implementation of the class cluster pattern by providing a way to (at run time) specify the actual type that should be initialized depending on the provided initialization parameters.<br>&gt;&gt; <br>&gt;&gt; ## Detailed design<br>&gt;&gt; <br>&gt;&gt; Introduce a new class method that can return an appropriate type that should be used for initialization, depending on the provided initialization parameters.<br>&gt;&gt; <br>&gt;&gt; This is what I believe to be the most clean solution, and with (assumedly) minimal impact on the existing nature of Swift’s initialization process. To ensure this remains safe, the only types allowed to be returned should be subclasses of the parent class (such as returning a __NSArrayI for NSArray). Notably, beyond this method, everything else remains the same; all this does is change what class the initializer is called on initially.<br>&gt;&gt; <br>&gt;&gt; Here is an ideal implementation gist:<br>&gt;&gt; https://gist.github.com/rileytestut/0e6e80d3f22b845502e7 &lt;https://gist.github.com/rileytestut/0e6e80d3f22b845502e7&gt;<br>&gt;&gt; <br>&gt;&gt; ## Impact on existing code<br>&gt;&gt; <br>&gt;&gt; There will be zero impact on existing code; if the proposed class method is not implemented, then it will default to simply initializing the “base” class, as it always has.<br>&gt;&gt; <br>&gt;&gt; ## Alternatives considered<br>&gt;&gt; <br>&gt;&gt; Allow for return values in initializers<br>&gt;&gt; <br>&gt;&gt; This is essentially how most class cluster patterns are implemented in Objective-C. Inside the init method, the class inspects the provided parameters, then assigns self to an instance of the appropriate subclass. Unfortunately, this is wasteful; memory is allocated for the base class, and then subsequently replaced with new memory allocated for the appropriate base class. More importantly though, the whole process can be complicated; it can be very easy to make an infinite recursive loop by calling [super init] in the subclass, which then assigns self to a new instance of the subclass, which then calls [super init]…etc. <br>&gt;&gt; <br>&gt;&gt; tl;dr; this method would work, but would be somewhat inconvenient to implement.<br>&gt;&gt; <br>&gt;&gt; Class function to return appropriate instance<br>&gt;&gt; <br>&gt;&gt; This is probably the simplest approach: simply make a class function that returns an instance of the appropriate class given a few input parameters. This totally works, but it means consumers of the API have to remember to use the class method instead of the initializer. Even if all initializers for the class were marked private, it would be strange to have the dissonance between using initializers and class methods to instantiate types in code. The consumer should not have to know about *any* of the implementation details; everything should “just work”. Forcing them to use alternative means to instantiate objects breaks this philosophy, IMO.<br>&gt;&gt; <br>&gt;&gt; Derive from Objective-C base class<br>&gt;&gt; <br>&gt;&gt; Another option is to simply derive from an Objective-C base class, and this is actually what I am doing right now in my framework. Unfortunately, there is one significant drawback: because the initialization is happening in Objective-C, you can only provide Objective-C compatible types for the initialization parameters (so no Swift structs for you!). Additionally, this (obviously) means whatever code is using it is limited to systems with Objective-C support, so it is not as portable as a pure-Swift solution.<br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/99af5602/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/009173d589176cfd9c8146cc49849ff6?s=50"></div><header><strong>Proposal: Allow class cluster pattern via dynamic initializer return type</strong> from <string>Riley Testut</string> &lt;rileytestut at gmail.com&gt;<p>December  7, 2015 at 01:00:00pm</p></header><div class="content"><p>Worth starting another thread discussing the pros and cons of method forwarding in Swift? I think that would definitely solve the class cluster problem<br></p><p>&gt; On Dec 7, 2015, at 1:06 PM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt; <br>&gt; You still need everything else if can return arbitrary types from init(). The only thing you don’t get from Swift today is the forwarding that is required for the _Cluster protocol. However, that problem is a more general one that has been discussed by many outside of the swift-evolution (surprised there is no proposal for that yet).<br>&gt; <br>&gt; If forwarding was in the language, there is no difference between the implementations other than the requirement of the _instance variable.<br>&gt; <br>&gt;&gt; On Dec 7, 2015, at 12:59 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; To me it seems a simpler solution would be to allow `return`ing a different object (or assigning to self) from inside init.<br>&gt;&gt; <br>&gt;&gt; On Mon, Dec 7, 2015 at 12:55 PM David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; Well, the basic idea of a class cluster is to hide the internal implementation. The caller of the API is still supposed to get back an instance of the clustered type (or that conforms to the interface at least).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It’s still possible to create class clusters though; here’s an example playground:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; private protocol _Cluster {<br>&gt;&gt;&gt;     func description() -&gt; String<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Cluster {<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     private var _instance: _Cluster<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     init(name: String) {<br>&gt;&gt;&gt;         _instance = _ClusterString(name: name)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     init(value: Int) {<br>&gt;&gt;&gt;         _instance = _ClusterValue(value: value)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     func description() -&gt; String {<br>&gt;&gt;&gt;         return _instance.description()<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; private class _ClusterString: _Cluster {<br>&gt;&gt;&gt;     private var name: String<br>&gt;&gt;&gt;     init(name: String) { self.name = name }<br>&gt;&gt;&gt;     func description() -&gt; String {<br>&gt;&gt;&gt;         return &quot;_ClusterString: \(name)&quot;<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; private class _ClusterValue: _Cluster {<br>&gt;&gt;&gt;     private var value: Int<br>&gt;&gt;&gt;     init(value: Int) { self.value = value }<br>&gt;&gt;&gt;     func description() -&gt; String {<br>&gt;&gt;&gt;         return &quot;_ClusterValue: \(value)&quot;<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let s = Cluster(name: &quot;a string&quot;)<br>&gt;&gt;&gt; s.description()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let v = Cluster(value: 12)<br>&gt;&gt;&gt; v.description()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The implementation is different from how ObjC implements class clusters, but the end result is nearly identical in functionality. If Swift had a form of function redirection, this pattern could be supported with less boiler-plate. However, I don’t believe this proposal is necessary to support class clusters.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -David<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 7, 2015, at 12:19 PM, Riley Testut via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Happy Monday everyone!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I wrote up a prototype proposal, which is probably best viewed on GitHub (https://github.com/rileytestut/swift-proposals/blob/master/class-cluster.md). But for convenience, I’ve included it in this email body as well. Hopefully someone else thinks this would be an idea worth considering :-) <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ## Introduction<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Throughout its frameworks, Apple makes use of the “class cluster” pattern as a means to separate the public API out from the (potentially complex) internal representations of the data. Clients of the API simply use the public API, while under the hood a different implementation is chosen to most efficiently represent the provided initialization parameter values.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Unfortunately, because initializers in Swift are not methods like in Objective-C, there is no way to specify what the actual return value should be (short of returning nil for failable initializers). This makes it *impossible* to actually implement the class cluster pattern in Swift.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ## Motivation<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; While developing my own Swift framework, I found myself wanting to provide a similar functionality. For the client of said framework, I wanted them to be able to create an instance of an essentially abstract class, and be returned a private subclass instance suited best for handling whatever input initialization parameters they provided. It didn’t make sense given the circumstances to ask the user to decide which class would be the best representation of the data; it should “just work”.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Additionally, the class cluster pattern can make backwards compatibility significantly easier; instead of littering your code with branches for different versions of an OS, you could instead have one if/switch statement to determine the appropriate subclass for the current OS you’re running on. This allows the developer to trivially keep legacy code for older platforms while taking advantage of new APIs/designs, and also without changing *any* client code. An example of the class cluster pattern being used for this reason can be seen here: http://www.xs-labs.com/en/blog/2013/06/18/ios7-new-ui-strategies/<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ## Proposed solution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I propose that we allow for implementation of the class cluster pattern by providing a way to (at run time) specify the actual type that should be initialized depending on the provided initialization parameters.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ## Detailed design<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Introduce a new class method that can return an appropriate type that should be used for initialization, depending on the provided initialization parameters.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is what I believe to be the most clean solution, and with (assumedly) minimal impact on the existing nature of Swift’s initialization process. To ensure this remains safe, the only types allowed to be returned should be subclasses of the parent class (such as returning a __NSArrayI for NSArray). Notably, beyond this method, everything else remains the same; all this does is change what class the initializer is called on initially.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here is an ideal implementation gist:<br>&gt;&gt;&gt;&gt; https://gist.github.com/rileytestut/0e6e80d3f22b845502e7<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ## Impact on existing code<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There will be zero impact on existing code; if the proposed class method is not implemented, then it will default to simply initializing the “base” class, as it always has.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ## Alternatives considered<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Allow for return values in initializers<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is essentially how most class cluster patterns are implemented in Objective-C. Inside the init method, the class inspects the provided parameters, then assigns self to an instance of the appropriate subclass. Unfortunately, this is wasteful; memory is allocated for the base class, and then subsequently replaced with new memory allocated for the appropriate base class. More importantly though, the whole process can be complicated; it can be very easy to make an infinite recursive loop by calling [super init] in the subclass, which then assigns self to a new instance of the subclass, which then calls [super init]…etc. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; tl;dr; this method would work, but would be somewhat inconvenient to implement.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Class function to return appropriate instance<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is probably the simplest approach: simply make a class function that returns an instance of the appropriate class given a few input parameters. This totally works, but it means consumers of the API have to remember to use the class method instead of the initializer. Even if all initializers for the class were marked private, it would be strange to have the dissonance between using initializers and class methods to instantiate types in code. The consumer should not have to know about *any* of the implementation details; everything should “just work”. Forcing them to use alternative means to instantiate objects breaks this philosophy, IMO.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Derive from Objective-C base class<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Another option is to simply derive from an Objective-C base class, and this is actually what I am doing right now in my framework. Unfortunately, there is one significant drawback: because the initialization is happening in Objective-C, you can only provide Objective-C compatible types for the initialization parameters (so no Swift structs for you!). Additionally, this (obviously) means whatever code is using it is limited to systems with Objective-C support, so it is not as portable as a pure-Swift solution.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/679c5e92/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2861bfeb71de9de58206bb6ae750bc2f?s=50"></div><header><strong>Proposal: Allow class cluster pattern via dynamic initializer return type</strong> from <string>ilya</string> &lt;ilya.nikokoshev at gmail.com&gt;<p>December  8, 2015 at 12:00:00am</p></header><div class="content"><p>I actually like the way it&#39;s done in the Objective-C, where _isa pointer<br>will be changed appropriately.<br></p><p>Perhaps it&#39;s actually possible to solve this problem:<br></p><p>&gt; Unfortunately, this is wasteful; memory is allocated for the base class,<br>and then subsequently replaced with new memory allocated for the<br>appropriate base class. More importantly though, the whole process can be<br>complicated;<br></p><p>by noting that we can formally mark this initializer as convenience<br>initializer, and memory allocation doesn&#39;t need to happen until we hit a<br>designated initializer. So far I see no reason why this cannot be made to<br>work:<br></p><p>class Cluster {<br></p><p>    convenience init(parameters) {<br>        if stuff {<br>            self = _Cluster1(...)<br>        } else {<br>            self = _Cluster2(...)<br>        }<br></p><p>        // it&#39;s safe to continue with second init phase<br>        self.configure(...)<br>   }<br>}<br></p><p>class _Cluster1 {<br>    init(parameters: ...) { ... } // designated init, guaranteed never to<br>call convenience inits<br>}<br></p><p><br>On Mon, Dec 7, 2015 at 11:55 PM, David Owens II via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Well, the basic idea of a class cluster is to hide the internal<br>&gt; implementation. The caller of the API is still supposed to get back an<br>&gt; instance of the clustered type (or that conforms to the interface at least).<br>&gt;<br>&gt; It’s still possible to create class clusters though; here’s an example<br>&gt; playground:<br>&gt;<br>&gt; private protocol _Cluster {<br>&gt;     func description() -&gt; String<br>&gt; }<br>&gt;<br>&gt; class Cluster {<br>&gt;<br>&gt;     private var _instance: _Cluster<br>&gt;<br>&gt;     init(name: String) {<br>&gt;         _instance = _ClusterString(name: name)<br>&gt;     }<br>&gt;<br>&gt;     init(value: Int) {<br>&gt;         _instance = _ClusterValue(value: value)<br>&gt;     }<br>&gt;<br>&gt;     func description() -&gt; String {<br>&gt;         return _instance.description()<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; private class _ClusterString: _Cluster {<br>&gt;     private var name: String<br>&gt;     init(name: String) { self.name = name }<br>&gt;     func description() -&gt; String {<br>&gt;         return &quot;_ClusterString: \(name)&quot;<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; private class _ClusterValue: _Cluster {<br>&gt;     private var value: Int<br>&gt;     init(value: Int) { self.value = value }<br>&gt;     func description() -&gt; String {<br>&gt;         return &quot;_ClusterValue: \(value)&quot;<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; let s = Cluster(name: &quot;a string&quot;)<br>&gt; s.description()<br>&gt;<br>&gt; let v = Cluster(value: 12)<br>&gt; v.description()<br>&gt;<br>&gt;<br>&gt;<br>&gt; The implementation is different from how ObjC implements class clusters,<br>&gt; but the end result is nearly identical in functionality. If Swift had a<br>&gt; form of function redirection, this pattern could be supported with less<br>&gt; boiler-plate. However, I don’t believe this proposal is necessary to<br>&gt; support class clusters.<br>&gt;<br>&gt; -David<br>&gt;<br>&gt;<br>&gt; On Dec 7, 2015, at 12:19 PM, Riley Testut via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Happy Monday everyone!<br>&gt;<br>&gt; I wrote up a prototype proposal, which is probably best viewed on GitHub (<br>&gt; https://github.com/rileytestut/swift-proposals/blob/master/class-cluster.md).<br>&gt; But for convenience, I’ve included it in this email body as well. Hopefully<br>&gt; someone else thinks this would be an idea worth considering :-)<br>&gt;<br>&gt; *## Introduction*<br>&gt;<br>&gt; Throughout its frameworks, Apple makes use of the “class cluster” pattern<br>&gt; as a means to separate the public API out from the (potentially complex)<br>&gt; internal representations of the data. Clients of the API simply use the<br>&gt; public API, while under the hood a different implementation is chosen to<br>&gt; most efficiently represent the provided initialization parameter values.<br>&gt;<br>&gt; Unfortunately, because initializers in Swift are not methods like in<br>&gt; Objective-C, there is no way to specify what the actual return value should<br>&gt; be (short of returning nil for failable initializers). This makes it<br>&gt; *impossible* to actually implement the class cluster pattern in Swift.<br>&gt;<br>&gt; *## Motivation*<br>&gt;<br>&gt; While developing my own Swift framework, I found myself wanting to provide<br>&gt; a similar functionality. For the client of said framework, I wanted them to<br>&gt; be able to create an instance of an essentially abstract class, and be<br>&gt; returned a private subclass instance suited best for handling whatever<br>&gt; input initialization parameters they provided. It didn’t make sense given<br>&gt; the circumstances to ask the user to decide which class would be the best<br>&gt; representation of the data; it should “just work”.<br>&gt;<br>&gt; Additionally, the class cluster pattern can make backwards compatibility<br>&gt; significantly easier; instead of littering your code with branches for<br>&gt; different versions of an OS, you could instead have one if/switch statement<br>&gt; to determine the appropriate subclass for the current OS you’re running on.<br>&gt; This allows the developer to trivially keep legacy code for older platforms<br>&gt; while taking advantage of new APIs/designs, and also without changing *any*<br>&gt; client code. An example of the class cluster pattern being used for this<br>&gt; reason can be seen here:<br>&gt; http://www.xs-labs.com/en/blog/2013/06/18/ios7-new-ui-strategies/<br>&gt;<br>&gt; *## Proposed solution*<br>&gt;<br>&gt; I propose that we allow for implementation of the class cluster pattern by<br>&gt; providing a way to (at run time) specify the actual type that should be<br>&gt; initialized depending on the provided initialization parameters.<br>&gt;<br>&gt; *## Detailed design*<br>&gt;<br>&gt; *Introduce a new class method that can return an appropriate type that<br>&gt; should be used for initialization, depending on the provided initialization<br>&gt; parameters.*<br>&gt;<br>&gt; This is what I believe to be the most clean solution, and with (assumedly)<br>&gt; minimal impact on the existing nature of Swift’s initialization process. To<br>&gt; ensure this remains safe, the only types allowed to be returned should be<br>&gt; subclasses of the parent class (such as returning a __NSArrayI for<br>&gt; NSArray). Notably, beyond this method, everything else remains the same;<br>&gt; all this does is change what class the initializer is called on initially.<br>&gt;<br>&gt; Here is an ideal implementation gist:<br>&gt; https://gist.github.com/rileytestut/0e6e80d3f22b845502e7<br>&gt;<br>&gt; *## Impact on existing code*<br>&gt;<br>&gt; There will be zero impact on existing code; if the proposed class method<br>&gt; is not implemented, then it will default to simply initializing the “base”<br>&gt; class, as it always has.<br>&gt;<br>&gt; *## Alternatives considered*<br>&gt;<br>&gt; *Allow for return values in initializers*<br>&gt;<br>&gt; This is essentially how most class cluster patterns are implemented in<br>&gt; Objective-C. Inside the init method, the class inspects the provided<br>&gt; parameters, then assigns self to an instance of the appropriate subclass.<br>&gt; Unfortunately, this is wasteful; memory is allocated for the base class,<br>&gt; and then subsequently replaced with new memory allocated for the<br>&gt; appropriate base class. More importantly though, the whole process can be<br>&gt; complicated; it can be very easy to make an infinite recursive loop by<br>&gt; calling [super init] in the subclass, which then assigns self to a new<br>&gt; instance of the subclass, which then calls [super init]…etc.<br>&gt;<br>&gt; tl;dr; this method would work, but would be somewhat inconvenient to<br>&gt; implement.<br>&gt;<br>&gt; *Class function to return appropriate instance*<br>&gt;<br>&gt; This is probably the simplest approach: simply make a class function that<br>&gt; returns an instance of the appropriate class given a few input parameters.<br>&gt; This totally works, but it means consumers of the API have to remember to<br>&gt; use the class method instead of the initializer. Even if all initializers<br>&gt; for the class were marked private, it would be strange to have the<br>&gt; dissonance between using initializers and class methods to instantiate<br>&gt; types in code. The consumer should not have to know about *any* of the<br>&gt; implementation details; everything should “just work”. Forcing them to use<br>&gt; alternative means to instantiate objects breaks this philosophy, IMO.<br>&gt;<br>&gt; *Derive from Objective-C base class*<br>&gt;<br>&gt; Another option is to simply derive from an Objective-C base class, and<br>&gt; this is actually what I am doing right now in my framework. Unfortunately,<br>&gt; there is one significant drawback: because the initialization is happening<br>&gt; in Objective-C, you can only provide Objective-C compatible types for the<br>&gt; initialization parameters (so no Swift structs for you!). Additionally,<br>&gt; this (obviously) means whatever code is using it is limited to systems with<br>&gt; Objective-C support, so it is not as portable as a pure-Swift solution.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/fa5258b8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/009173d589176cfd9c8146cc49849ff6?s=50"></div><header><strong>Proposal: Allow class cluster pattern via dynamic initializer return type</strong> from <string>Riley Testut</string> &lt;rileytestut at gmail.com&gt;<p>December  7, 2015 at 01:00:00pm</p></header><div class="content"><p>I actually really like the idea of using a convenience initializer for this, it works well with the Swift initiation process. +1 (though maybe a different keyword than &quot;convenience&quot; to show that it actually assigns to self?)<br></p><p>&gt; On Dec 7, 2015, at 1:07 PM, ilya &lt;ilya.nikokoshev at gmail.com&gt; wrote:<br>&gt; <br>&gt; I actually like the way it&#39;s done in the Objective-C, where _isa pointer will be changed appropriately.<br>&gt; <br>&gt; Perhaps it&#39;s actually possible to solve this problem:<br>&gt; <br>&gt; &gt; Unfortunately, this is wasteful; memory is allocated for the base class, and then subsequently replaced with new memory allocated for the appropriate base class. More importantly though, the whole process can be complicated;<br>&gt; <br>&gt; by noting that we can formally mark this initializer as convenience initializer, and memory allocation doesn&#39;t need to happen until we hit a designated initializer. So far I see no reason why this cannot be made to work:<br>&gt; <br>&gt; class Cluster {<br>&gt; <br>&gt;     convenience init(parameters) {<br>&gt;         if stuff {<br>&gt;             self = _Cluster1(...)<br>&gt;         } else {<br>&gt;             self = _Cluster2(...)<br>&gt;         }<br>&gt; <br>&gt;         // it&#39;s safe to continue with second init phase<br>&gt;         self.configure(...)<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; class _Cluster1 { <br>&gt;     init(parameters: ...) { ... } // designated init, guaranteed never to call convenience inits<br>&gt; }<br>&gt; <br>&gt; <br>&gt;&gt; On Mon, Dec 7, 2015 at 11:55 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Well, the basic idea of a class cluster is to hide the internal implementation. The caller of the API is still supposed to get back an instance of the clustered type (or that conforms to the interface at least).<br>&gt;&gt; <br>&gt;&gt; It’s still possible to create class clusters though; here’s an example playground:<br>&gt;&gt; <br>&gt;&gt; private protocol _Cluster {<br>&gt;&gt;     func description() -&gt; String<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class Cluster {<br>&gt;&gt;     <br>&gt;&gt;     private var _instance: _Cluster<br>&gt;&gt;     <br>&gt;&gt;     init(name: String) {<br>&gt;&gt;         _instance = _ClusterString(name: name)<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     init(value: Int) {<br>&gt;&gt;         _instance = _ClusterValue(value: value)<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     func description() -&gt; String {<br>&gt;&gt;         return _instance.description()<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; private class _ClusterString: _Cluster {<br>&gt;&gt;     private var name: String<br>&gt;&gt;     init(name: String) { self.name = name }<br>&gt;&gt;     func description() -&gt; String {<br>&gt;&gt;         return &quot;_ClusterString: \(name)&quot;<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; private class _ClusterValue: _Cluster {<br>&gt;&gt;     private var value: Int<br>&gt;&gt;     init(value: Int) { self.value = value }<br>&gt;&gt;     func description() -&gt; String {<br>&gt;&gt;         return &quot;_ClusterValue: \(value)&quot;<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let s = Cluster(name: &quot;a string&quot;)<br>&gt;&gt; s.description()<br>&gt;&gt; <br>&gt;&gt; let v = Cluster(value: 12)<br>&gt;&gt; v.description()<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; The implementation is different from how ObjC implements class clusters, but the end result is nearly identical in functionality. If Swift had a form of function redirection, this pattern could be supported with less boiler-plate. However, I don’t believe this proposal is necessary to support class clusters.<br>&gt;&gt; <br>&gt;&gt; -David<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 7, 2015, at 12:19 PM, Riley Testut via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Happy Monday everyone!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I wrote up a prototype proposal, which is probably best viewed on GitHub (https://github.com/rileytestut/swift-proposals/blob/master/class-cluster.md). But for convenience, I’ve included it in this email body as well. Hopefully someone else thinks this would be an idea worth considering :-) <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Throughout its frameworks, Apple makes use of the “class cluster” pattern as a means to separate the public API out from the (potentially complex) internal representations of the data. Clients of the API simply use the public API, while under the hood a different implementation is chosen to most efficiently represent the provided initialization parameter values.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Unfortunately, because initializers in Swift are not methods like in Objective-C, there is no way to specify what the actual return value should be (short of returning nil for failable initializers). This makes it *impossible* to actually implement the class cluster pattern in Swift.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; While developing my own Swift framework, I found myself wanting to provide a similar functionality. For the client of said framework, I wanted them to be able to create an instance of an essentially abstract class, and be returned a private subclass instance suited best for handling whatever input initialization parameters they provided. It didn’t make sense given the circumstances to ask the user to decide which class would be the best representation of the data; it should “just work”.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Additionally, the class cluster pattern can make backwards compatibility significantly easier; instead of littering your code with branches for different versions of an OS, you could instead have one if/switch statement to determine the appropriate subclass for the current OS you’re running on. This allows the developer to trivially keep legacy code for older platforms while taking advantage of new APIs/designs, and also without changing *any* client code. An example of the class cluster pattern being used for this reason can be seen here: http://www.xs-labs.com/en/blog/2013/06/18/ios7-new-ui-strategies/<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I propose that we allow for implementation of the class cluster pattern by providing a way to (at run time) specify the actual type that should be initialized depending on the provided initialization parameters.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Detailed design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Introduce a new class method that can return an appropriate type that should be used for initialization, depending on the provided initialization parameters.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is what I believe to be the most clean solution, and with (assumedly) minimal impact on the existing nature of Swift’s initialization process. To ensure this remains safe, the only types allowed to be returned should be subclasses of the parent class (such as returning a __NSArrayI for NSArray). Notably, beyond this method, everything else remains the same; all this does is change what class the initializer is called on initially.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here is an ideal implementation gist:<br>&gt;&gt;&gt; https://gist.github.com/rileytestut/0e6e80d3f22b845502e7<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There will be zero impact on existing code; if the proposed class method is not implemented, then it will default to simply initializing the “base” class, as it always has.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Alternatives considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Allow for return values in initializers<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is essentially how most class cluster patterns are implemented in Objective-C. Inside the init method, the class inspects the provided parameters, then assigns self to an instance of the appropriate subclass. Unfortunately, this is wasteful; memory is allocated for the base class, and then subsequently replaced with new memory allocated for the appropriate base class. More importantly though, the whole process can be complicated; it can be very easy to make an infinite recursive loop by calling [super init] in the subclass, which then assigns self to a new instance of the subclass, which then calls [super init]…etc. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; tl;dr; this method would work, but would be somewhat inconvenient to implement.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Class function to return appropriate instance<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is probably the simplest approach: simply make a class function that returns an instance of the appropriate class given a few input parameters. This totally works, but it means consumers of the API have to remember to use the class method instead of the initializer. Even if all initializers for the class were marked private, it would be strange to have the dissonance between using initializers and class methods to instantiate types in code. The consumer should not have to know about *any* of the implementation details; everything should “just work”. Forcing them to use alternative means to instantiate objects breaks this philosophy, IMO.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Derive from Objective-C base class<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another option is to simply derive from an Objective-C base class, and this is actually what I am doing right now in my framework. Unfortunately, there is one significant drawback: because the initialization is happening in Objective-C, you can only provide Objective-C compatible types for the initialization parameters (so no Swift structs for you!). Additionally, this (obviously) means whatever code is using it is limited to systems with Objective-C support, so it is not as portable as a pure-Swift solution.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/3642c560/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/009173d589176cfd9c8146cc49849ff6?s=50"></div><header><strong>Proposal: Allow class cluster pattern via dynamic initializer return type</strong> from <string>Riley Testut</string> &lt;rileytestut at gmail.com&gt;<p>December  7, 2015 at 02:00:00pm</p></header><div class="content"><p>So instead of chaining convenience initializers to required ones via self.init(), you’d recommend instead assigning them directly to self? I think this would be a nice change; currently it can be hard to know the correct method of chaining initializers (at least as far as I’ve seen when attempting to explain it to newcomers).<br></p><p>Proposed new rules for initialization:<br></p><p>required initializers: must call super (unless base class)<br>convenience initializers: must assign to self via a required initializer<br></p><p>I think this also would help with the confusion of why convenience methods can’t call super, but required ones can, since now convenience methods can’t chain to any initializers directly. Thoughts from others?<br></p><p>&gt; On Dec 7, 2015, at 1:17 PM, ilya &lt;ilya.nikokoshev at gmail.com &lt;mailto:ilya.nikokoshev at gmail.com&gt;&gt; wrote:<br>&gt; <br>&gt; more precisely like this for regular convenience initializers<br>&gt; <br>&gt; class SomeClass {<br>&gt; <br>&gt;     convenience init(x: Int) {<br>&gt;         let y = someComputation(x) // &lt;- can&#39;t use self here<br>&gt;         self = init(y: y) <br>&gt;         self.configure() // &lt;- can use self here<br>&gt;     }<br>&gt;      <br>&gt;     init(y:Int)  { // designated<br>&gt;     ...<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; On Tue, Dec 8, 2015 at 12:14 AM, ilya &lt;ilya.nikokoshev at gmail.com &lt;mailto:ilya.nikokoshev at gmail.com&gt;&gt; wrote:<br>&gt; Actually I think self = SomeClass(anotherInit: ...) would be a better syntax of choice for *all* convenience initializers, as it would make intuitively clear that self cannot be used until this call.<br>&gt; <br>&gt; On Tue, Dec 8, 2015 at 12:11 AM, Riley Testut &lt;rileytestut at gmail.com &lt;mailto:rileytestut at gmail.com&gt;&gt; wrote:<br>&gt; I actually really like the idea of using a convenience initializer for this, it works well with the Swift initiation process. +1 (though maybe a different keyword than &quot;convenience&quot; to show that it actually assigns to self?)<br>&gt; <br>&gt; On Dec 7, 2015, at 1:07 PM, ilya &lt;ilya.nikokoshev at gmail.com &lt;mailto:ilya.nikokoshev at gmail.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; I actually like the way it&#39;s done in the Objective-C, where _isa pointer will be changed appropriately.<br>&gt;&gt; <br>&gt;&gt; Perhaps it&#39;s actually possible to solve this problem:<br>&gt;&gt; <br>&gt;&gt; &gt; Unfortunately, this is wasteful; memory is allocated for the base class, and then subsequently replaced with new memory allocated for the appropriate base class. More importantly though, the whole process can be complicated;<br>&gt;&gt; <br>&gt;&gt; by noting that we can formally mark this initializer as convenience initializer, and memory allocation doesn&#39;t need to happen until we hit a designated initializer. So far I see no reason why this cannot be made to work:<br>&gt;&gt; <br>&gt;&gt; class Cluster {<br>&gt;&gt; <br>&gt;&gt;     convenience init(parameters) {<br>&gt;&gt;         if stuff {<br>&gt;&gt;             self = _Cluster1(...)<br>&gt;&gt;         } else {<br>&gt;&gt;             self = _Cluster2(...)<br>&gt;&gt;         }<br>&gt;&gt; <br>&gt;&gt;         // it&#39;s safe to continue with second init phase<br>&gt;&gt;         self.configure(...)<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class _Cluster1 { <br>&gt;&gt;     init(parameters: ...) { ... } // designated init, guaranteed never to call convenience inits<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Mon, Dec 7, 2015 at 11:55 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Well, the basic idea of a class cluster is to hide the internal implementation. The caller of the API is still supposed to get back an instance of the clustered type (or that conforms to the interface at least).<br>&gt;&gt; <br>&gt;&gt; It’s still possible to create class clusters though; here’s an example playground:<br>&gt;&gt; <br>&gt;&gt; private protocol _Cluster {<br>&gt;&gt;     func description() -&gt; String<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class Cluster {<br>&gt;&gt;     <br>&gt;&gt;     private var _instance: _Cluster<br>&gt;&gt;     <br>&gt;&gt;     init(name: String) {<br>&gt;&gt;         _instance = _ClusterString(name: name)<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     init(value: Int) {<br>&gt;&gt;         _instance = _ClusterValue(value: value)<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     func description() -&gt; String {<br>&gt;&gt;         return _instance.description()<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; private class _ClusterString: _Cluster {<br>&gt;&gt;     private var name: String<br>&gt;&gt;     init(name: String) { self.name &lt;http://self.name/&gt; = name }<br>&gt;&gt;     func description() -&gt; String {<br>&gt;&gt;         return &quot;_ClusterString: \(name)&quot;<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; private class _ClusterValue: _Cluster {<br>&gt;&gt;     private var value: Int<br>&gt;&gt;     init(value: Int) { self.value = value }<br>&gt;&gt;     func description() -&gt; String {<br>&gt;&gt;         return &quot;_ClusterValue: \(value)&quot;<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let s = Cluster(name: &quot;a string&quot;)<br>&gt;&gt; s.description()<br>&gt;&gt; <br>&gt;&gt; let v = Cluster(value: 12)<br>&gt;&gt; v.description()<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; The implementation is different from how ObjC implements class clusters, but the end result is nearly identical in functionality. If Swift had a form of function redirection, this pattern could be supported with less boiler-plate. However, I don’t believe this proposal is necessary to support class clusters.<br>&gt;&gt; <br>&gt;&gt; -David<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 7, 2015, at 12:19 PM, Riley Testut via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Happy Monday everyone!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I wrote up a prototype proposal, which is probably best viewed on GitHub (https://github.com/rileytestut/swift-proposals/blob/master/class-cluster.md &lt;https://github.com/rileytestut/swift-proposals/blob/master/class-cluster.md&gt;). But for convenience, I’ve included it in this email body as well. Hopefully someone else thinks this would be an idea worth considering :-) <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Throughout its frameworks, Apple makes use of the “class cluster” pattern as a means to separate the public API out from the (potentially complex) internal representations of the data. Clients of the API simply use the public API, while under the hood a different implementation is chosen to most efficiently represent the provided initialization parameter values.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Unfortunately, because initializers in Swift are not methods like in Objective-C, there is no way to specify what the actual return value should be (short of returning nil for failable initializers). This makes it *impossible* to actually implement the class cluster pattern in Swift.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; While developing my own Swift framework, I found myself wanting to provide a similar functionality. For the client of said framework, I wanted them to be able to create an instance of an essentially abstract class, and be returned a private subclass instance suited best for handling whatever input initialization parameters they provided. It didn’t make sense given the circumstances to ask the user to decide which class would be the best representation of the data; it should “just work”.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Additionally, the class cluster pattern can make backwards compatibility significantly easier; instead of littering your code with branches for different versions of an OS, you could instead have one if/switch statement to determine the appropriate subclass for the current OS you’re running on. This allows the developer to trivially keep legacy code for older platforms while taking advantage of new APIs/designs, and also without changing *any* client code. An example of the class cluster pattern being used for this reason can be seen here: http://www.xs-labs.com/en/blog/2013/06/18/ios7-new-ui-strategies/ &lt;http://www.xs-labs.com/en/blog/2013/06/18/ios7-new-ui-strategies/&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I propose that we allow for implementation of the class cluster pattern by providing a way to (at run time) specify the actual type that should be initialized depending on the provided initialization parameters.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Detailed design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Introduce a new class method that can return an appropriate type that should be used for initialization, depending on the provided initialization parameters.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is what I believe to be the most clean solution, and with (assumedly) minimal impact on the existing nature of Swift’s initialization process. To ensure this remains safe, the only types allowed to be returned should be subclasses of the parent class (such as returning a __NSArrayI for NSArray). Notably, beyond this method, everything else remains the same; all this does is change what class the initializer is called on initially.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here is an ideal implementation gist:<br>&gt;&gt;&gt; https://gist.github.com/rileytestut/0e6e80d3f22b845502e7 &lt;https://gist.github.com/rileytestut/0e6e80d3f22b845502e7&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There will be zero impact on existing code; if the proposed class method is not implemented, then it will default to simply initializing the “base” class, as it always has.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Alternatives considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Allow for return values in initializers<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is essentially how most class cluster patterns are implemented in Objective-C. Inside the init method, the class inspects the provided parameters, then assigns self to an instance of the appropriate subclass. Unfortunately, this is wasteful; memory is allocated for the base class, and then subsequently replaced with new memory allocated for the appropriate base class. More importantly though, the whole process can be complicated; it can be very easy to make an infinite recursive loop by calling [super init] in the subclass, which then assigns self to a new instance of the subclass, which then calls [super init]…etc. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; tl;dr; this method would work, but would be somewhat inconvenient to implement.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Class function to return appropriate instance<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is probably the simplest approach: simply make a class function that returns an instance of the appropriate class given a few input parameters. This totally works, but it means consumers of the API have to remember to use the class method instead of the initializer. Even if all initializers for the class were marked private, it would be strange to have the dissonance between using initializers and class methods to instantiate types in code. The consumer should not have to know about *any* of the implementation details; everything should “just work”. Forcing them to use alternative means to instantiate objects breaks this philosophy, IMO.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Derive from Objective-C base class<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another option is to simply derive from an Objective-C base class, and this is actually what I am doing right now in my framework. Unfortunately, there is one significant drawback: because the initialization is happening in Objective-C, you can only provide Objective-C compatible types for the initialization parameters (so no Swift structs for you!). Additionally, this (obviously) means whatever code is using it is limited to systems with Objective-C support, so it is not as portable as a pure-Swift solution.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/2e352009/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2861bfeb71de9de58206bb6ae750bc2f?s=50"></div><header><strong>Proposal: Allow class cluster pattern via dynamic initializer return type</strong> from <string>ilya</string> &lt;ilya.nikokoshev at gmail.com&gt;<p>December  8, 2015 at 01:00:00am</p></header><div class="content"><p>Yes, that&#39;s what I suggest:<br></p><p>*required initializers*: must call super (autogenerated for base class)<br>*convenience initializers*: must assign to self via another initializer<br>(including via subclass)<br></p><p>(with the minor technical correction that convenience initializers, as is<br>now, are able to call other convenience initializers)<br></p><p>Although note that inheritance rules for &quot;class cluster&quot; initializers will<br>be very different, the reason being that regular convenience init is<br>essentially<br></p><p>init(x...) -&gt; Self {<br>   self = Self(y: ...)<br>}<br></p><p>which is covariant enough to be able to be inherited, while &quot;class cluster<br>init&quot; is<br></p><p>init (x...) -&gt; BaseClass {<br>    self = SomeConcreteClass(y: ...)<br>}<br></p><p>which is not covariant.<br></p><p>On Tue, Dec 8, 2015 at 1:06 AM, Riley Testut &lt;rileytestut at gmail.com&gt; wrote:<br></p><p>&gt; So instead of chaining convenience initializers to required ones via<br>&gt; self.init(), you’d recommend instead assigning them directly to self? I<br>&gt; think this would be a nice change; currently it can be hard to know the<br>&gt; correct method of chaining initializers (at least as far as I’ve seen when<br>&gt; attempting to explain it to newcomers).<br>&gt;<br>&gt; Proposed new rules for initialization:<br>&gt;<br>&gt; required initializers: must call super (unless base class)<br>&gt; convenience initializers: must assign to self via a required initializer<br>&gt;<br>&gt; I think this also would help with the confusion of why convenience methods<br>&gt; can’t call super, but required ones can, since now convenience methods<br>&gt; can’t chain to *any* initializers directly. Thoughts from others?<br>&gt;<br>&gt; On Dec 7, 2015, at 1:17 PM, ilya &lt;ilya.nikokoshev at gmail.com&gt; wrote:<br>&gt;<br>&gt; more precisely like this for regular convenience initializers<br>&gt;<br>&gt; class SomeClass {<br>&gt;<br>&gt;     convenience init(x: Int) {<br>&gt;         let y = someComputation(x) // &lt;- can&#39;t use self here<br>&gt;         self = init(y: y)<br>&gt;         self.configure() // &lt;- can use self here<br>&gt;     }<br>&gt;<br>&gt;     init(y:Int)  { // designated<br>&gt;     ...<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; On Tue, Dec 8, 2015 at 12:14 AM, ilya &lt;ilya.nikokoshev at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; Actually I think self = SomeClass(anotherInit: ...) would be a better<br>&gt;&gt; syntax of choice for *all* convenience initializers, as it would make<br>&gt;&gt; intuitively clear that self cannot be used until this call.<br>&gt;&gt;<br>&gt;&gt; On Tue, Dec 8, 2015 at 12:11 AM, Riley Testut &lt;rileytestut at gmail.com&gt;<br>&gt;&gt;  wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; I actually really like the idea of using a convenience initializer for<br>&gt;&gt;&gt; this, it works well with the Swift initiation process. +1 (though maybe a<br>&gt;&gt;&gt; different keyword than &quot;convenience&quot; to show that it actually assigns to<br>&gt;&gt;&gt; self?)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Dec 7, 2015, at 1:07 PM, ilya &lt;ilya.nikokoshev at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I actually like the way it&#39;s done in the Objective-C, where _isa pointer<br>&gt;&gt;&gt; will be changed appropriately.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Perhaps it&#39;s actually possible to solve this problem:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; Unfortunately, this is wasteful; memory is allocated for the base<br>&gt;&gt;&gt; class, and then subsequently replaced with new memory allocated for the<br>&gt;&gt;&gt; appropriate base class. More importantly though, the whole process can be<br>&gt;&gt;&gt; complicated;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; by noting that we can formally mark this initializer as convenience<br>&gt;&gt;&gt; initializer, and memory allocation doesn&#39;t need to happen until we hit a<br>&gt;&gt;&gt; designated initializer. So far I see no reason why this cannot be made to<br>&gt;&gt;&gt; work:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; class Cluster {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     convenience init(parameters) {<br>&gt;&gt;&gt;         if stuff {<br>&gt;&gt;&gt;             self = _Cluster1(...)<br>&gt;&gt;&gt;         } else {<br>&gt;&gt;&gt;             self = _Cluster2(...)<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         // it&#39;s safe to continue with second init phase<br>&gt;&gt;&gt;         self.configure(...)<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; class _Cluster1 {<br>&gt;&gt;&gt;     init(parameters: ...) { ... } // designated init, guaranteed never<br>&gt;&gt;&gt; to call convenience inits<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Mon, Dec 7, 2015 at 11:55 PM, David Owens II via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Well, the basic idea of a class cluster is to hide the internal<br>&gt;&gt;&gt;&gt; implementation. The caller of the API is still supposed to get back an<br>&gt;&gt;&gt;&gt; instance of the clustered type (or that conforms to the interface at least).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; It’s still possible to create class clusters though; here’s an example<br>&gt;&gt;&gt;&gt; playground:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; private protocol _Cluster {<br>&gt;&gt;&gt;&gt;     func description() -&gt; String<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; class Cluster {<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     private var _instance: _Cluster<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     init(name: String) {<br>&gt;&gt;&gt;&gt;         _instance = _ClusterString(name: name)<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     init(value: Int) {<br>&gt;&gt;&gt;&gt;         _instance = _ClusterValue(value: value)<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     func description() -&gt; String {<br>&gt;&gt;&gt;&gt;         return _instance.description()<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; private class _ClusterString: _Cluster {<br>&gt;&gt;&gt;&gt;     private var name: String<br>&gt;&gt;&gt;&gt;     init(name: String) { self.name = name }<br>&gt;&gt;&gt;&gt;     func description() -&gt; String {<br>&gt;&gt;&gt;&gt;         return &quot;_ClusterString: \(name)&quot;<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; private class _ClusterValue: _Cluster {<br>&gt;&gt;&gt;&gt;     private var value: Int<br>&gt;&gt;&gt;&gt;     init(value: Int) { self.value = value }<br>&gt;&gt;&gt;&gt;     func description() -&gt; String {<br>&gt;&gt;&gt;&gt;         return &quot;_ClusterValue: \(value)&quot;<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; let s = Cluster(name: &quot;a string&quot;)<br>&gt;&gt;&gt;&gt; s.description()<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; let v = Cluster(value: 12)<br>&gt;&gt;&gt;&gt; v.description()<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The implementation is different from how ObjC implements class<br>&gt;&gt;&gt;&gt; clusters, but the end result is nearly identical in functionality. If Swift<br>&gt;&gt;&gt;&gt; had a form of function redirection, this pattern could be supported with<br>&gt;&gt;&gt;&gt; less boiler-plate. However, I don’t believe this proposal is necessary to<br>&gt;&gt;&gt;&gt; support class clusters.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; -David<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Dec 7, 2015, at 12:19 PM, Riley Testut via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Happy Monday everyone!<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I wrote up a prototype proposal, which is probably best viewed on<br>&gt;&gt;&gt;&gt; GitHub (<br>&gt;&gt;&gt;&gt; https://github.com/rileytestut/swift-proposals/blob/master/class-cluster.md).<br>&gt;&gt;&gt;&gt; But for convenience, I’ve included it in this email body as well. Hopefully<br>&gt;&gt;&gt;&gt; someone else thinks this would be an idea worth considering :-)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; *## Introduction*<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Throughout its frameworks, Apple makes use of the “class cluster”<br>&gt;&gt;&gt;&gt; pattern as a means to separate the public API out from the (potentially<br>&gt;&gt;&gt;&gt; complex) internal representations of the data. Clients of the API simply<br>&gt;&gt;&gt;&gt; use the public API, while under the hood a different implementation is<br>&gt;&gt;&gt;&gt; chosen to most efficiently represent the provided initialization parameter<br>&gt;&gt;&gt;&gt; values.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Unfortunately, because initializers in Swift are not methods like in<br>&gt;&gt;&gt;&gt; Objective-C, there is no way to specify what the actual return value should<br>&gt;&gt;&gt;&gt; be (short of returning nil for failable initializers). This makes it<br>&gt;&gt;&gt;&gt; *impossible* to actually implement the class cluster pattern in Swift.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; *## Motivation*<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; While developing my own Swift framework, I found myself wanting to<br>&gt;&gt;&gt;&gt; provide a similar functionality. For the client of said framework, I wanted<br>&gt;&gt;&gt;&gt; them to be able to create an instance of an essentially abstract class, and<br>&gt;&gt;&gt;&gt; be returned a private subclass instance suited best for handling whatever<br>&gt;&gt;&gt;&gt; input initialization parameters they provided. It didn’t make sense given<br>&gt;&gt;&gt;&gt; the circumstances to ask the user to decide which class would be the best<br>&gt;&gt;&gt;&gt; representation of the data; it should “just work”.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Additionally, the class cluster pattern can make backwards<br>&gt;&gt;&gt;&gt; compatibility significantly easier; instead of littering your code with<br>&gt;&gt;&gt;&gt; branches for different versions of an OS, you could instead have one<br>&gt;&gt;&gt;&gt; if/switch statement to determine the appropriate subclass for the current<br>&gt;&gt;&gt;&gt; OS you’re running on. This allows the developer to trivially keep legacy<br>&gt;&gt;&gt;&gt; code for older platforms while taking advantage of new APIs/designs, and<br>&gt;&gt;&gt;&gt; also without changing *any* client code. An example of the class cluster<br>&gt;&gt;&gt;&gt; pattern being used for this reason can be seen here:<br>&gt;&gt;&gt;&gt; http://www.xs-labs.com/en/blog/2013/06/18/ios7-new-ui-strategies/<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; *## Proposed solution*<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I propose that we allow for implementation of the class cluster pattern<br>&gt;&gt;&gt;&gt; by providing a way to (at run time) specify the actual type that should be<br>&gt;&gt;&gt;&gt; initialized depending on the provided initialization parameters.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; *## Detailed design*<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; *Introduce a new class method that can return an appropriate type that<br>&gt;&gt;&gt;&gt; should be used for initialization, depending on the provided initialization<br>&gt;&gt;&gt;&gt; parameters.*<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This is what I believe to be the most clean solution, and with<br>&gt;&gt;&gt;&gt; (assumedly) minimal impact on the existing nature of Swift’s initialization<br>&gt;&gt;&gt;&gt; process. To ensure this remains safe, the only types allowed to be returned<br>&gt;&gt;&gt;&gt; should be subclasses of the parent class (such as returning a __NSArrayI<br>&gt;&gt;&gt;&gt; for NSArray). Notably, beyond this method, everything else remains the<br>&gt;&gt;&gt;&gt; same; all this does is change what class the initializer is called on<br>&gt;&gt;&gt;&gt; initially.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Here is an ideal implementation gist:<br>&gt;&gt;&gt;&gt; https://gist.github.com/rileytestut/0e6e80d3f22b845502e7<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; *## Impact on existing code*<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; There will be zero impact on existing code; if the proposed class<br>&gt;&gt;&gt;&gt; method is not implemented, then it will default to simply initializing the<br>&gt;&gt;&gt;&gt; “base” class, as it always has.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; *## Alternatives considered*<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; *Allow for return values in initializers*<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This is essentially how most class cluster patterns are implemented in<br>&gt;&gt;&gt;&gt; Objective-C. Inside the init method, the class inspects the provided<br>&gt;&gt;&gt;&gt; parameters, then assigns self to an instance of the appropriate subclass.<br>&gt;&gt;&gt;&gt; Unfortunately, this is wasteful; memory is allocated for the base class,<br>&gt;&gt;&gt;&gt; and then subsequently replaced with new memory allocated for the<br>&gt;&gt;&gt;&gt; appropriate base class. More importantly though, the whole process can be<br>&gt;&gt;&gt;&gt; complicated; it can be very easy to make an infinite recursive loop by<br>&gt;&gt;&gt;&gt; calling [super init] in the subclass, which then assigns self to a new<br>&gt;&gt;&gt;&gt; instance of the subclass, which then calls [super init]…etc.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; tl;dr; this method would work, but would be somewhat inconvenient to<br>&gt;&gt;&gt;&gt; implement.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; *Class function to return appropriate instance*<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This is probably the simplest approach: simply make a class function<br>&gt;&gt;&gt;&gt; that returns an instance of the appropriate class given a few input<br>&gt;&gt;&gt;&gt; parameters. This totally works, but it means consumers of the API have to<br>&gt;&gt;&gt;&gt; remember to use the class method instead of the initializer. Even if all<br>&gt;&gt;&gt;&gt; initializers for the class were marked private, it would be strange to have<br>&gt;&gt;&gt;&gt; the dissonance between using initializers and class methods to instantiate<br>&gt;&gt;&gt;&gt; types in code. The consumer should not have to know about *any* of the<br>&gt;&gt;&gt;&gt; implementation details; everything should “just work”. Forcing them to use<br>&gt;&gt;&gt;&gt; alternative means to instantiate objects breaks this philosophy, IMO.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; *Derive from Objective-C base class*<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Another option is to simply derive from an Objective-C base class, and<br>&gt;&gt;&gt;&gt; this is actually what I am doing right now in my framework. Unfortunately,<br>&gt;&gt;&gt;&gt; there is one significant drawback: because the initialization is happening<br>&gt;&gt;&gt;&gt; in Objective-C, you can only provide Objective-C compatible types for the<br>&gt;&gt;&gt;&gt; initialization parameters (so no Swift structs for you!). Additionally,<br>&gt;&gt;&gt;&gt; this (obviously) means whatever code is using it is limited to systems with<br>&gt;&gt;&gt;&gt; Objective-C support, so it is not as portable as a pure-Swift solution.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/ec7af26c/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Proposal: Allow class cluster pattern via dynamic initializer return type</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December  7, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; Throughout its frameworks, Apple makes use of the “class cluster” pattern as a means to separate the public API out from the (potentially complex) internal representations of the data. Clients of the API simply use the public API, while under the hood a different implementation is chosen to most efficiently represent the provided initialization parameter values.<br>&gt; <br>&gt; Unfortunately, because initializers in Swift are not methods like in Objective-C, there is no way to specify what the actual return value should be (short of returning nil for failable initializers). This makes it *impossible* to actually implement the class cluster pattern in Swift.<br></p><p>I’d actually like to put Objective-C interop aside for a moment. There are many class clusters in Objective-C, but most of them are things you rarely need to subclass yourself. When was the last time you wrote an NSArray subclass? What’s more interesting to me is how we can provide a similar native Swift pattern.<br></p><p>Here’s my thinking.<br></p><p>First of all, we call them “class” clusters, but there’s no reason this should be only for classes. A “class cluster” is basically a single API which offers access to many different implementations of an interface. The phrase “many different implementations of an interface” is a hint that we should be thinking about protocols.<br></p><p>Here’s what I think Swift should support:<br></p><p>	protocol HTTPParameterListType {<br>		var all: DictionaryLiteral&lt;String, Strong&gt; { get }<br>		subscript (name: String) -&gt; [String] { get }<br>	}<br>	<br>	// Various implementations include:<br>	struct JSONParameterList: HTTPParameterList {...}<br>	struct MultipartParameterList: HTTParameterList {…}<br>	struct URLEncodedFormParameterList: HTTPParameterList {…}<br>	struct QueryParameterList: HTTPParameterList {…}<br>	<br>	extension HTTPParameterListType {<br>		protocol init(request: NSHTTPRequest, bodyData: NSData) throws {<br>			switch request.valueForHTTPHeaderField(“Content-Type”).map({ MIMEType(rawValue: $0) }) {<br>			case .JSON?:<br>				return try JSONParameterList(data: bodyData)<br>			<br>			case .MultipartFormData?:<br>				return try MultipartParameterList(data: bodyData)<br>			<br>			case .URLEncodedForm?:<br>				return try URLEncodedFormParameterList(data: bodyData)<br>			<br>			default:<br>				return try QueryParameterList(request: request)<br>			}<br>		}<br>	}<br></p><p>	// Usage:<br>	self.parameters = HTTPParameterListType(request: request, bodyData: data)<br></p><p>A `protocol init` in a protocol extension creates an initializer which is *not* applied to types conforming to the protocol. Instead, it is actually an initializer on the protocol itself. `self` is the protocol metatype, not an instance of anything. The provided implementation should `return` an instance conforming to (and implicitly casted to) the protocol. Just like any other initializer, a `protocol init` can be failable or throwing.<br></p><p>Unlike other initializers, Swift usually won’t be able to tell at compile time which concrete type will be returned by a protocol init(), reducing opportunities to statically bind methods and perform other optimization tricks. Frankly, though, that’s just the cost of doing business. If you want to select a type dynamically, you’re going to lose the ability to aggressively optimize calls to the resulting instance.<br></p><p>Perhaps this feature can then be extended back to classes, with a `class init` being an un-inherited initializer which uses `return` to give the caller a new object. `self` would be the class object, and only class variables and methods would be callable from it. But like I said, I’m not particularly interested in Objective-C interop right now.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2861bfeb71de9de58206bb6ae750bc2f?s=50"></div><header><strong>Proposal: Allow class cluster pattern via dynamic initializer return type</strong> from <string>ilya</string> &lt;ilya.nikokoshev at gmail.com&gt;<p>December  7, 2015 at 11:00:00pm</p></header><div class="content"><p>Some thoughts:<br></p><p>1 &quot;self =&quot; is better in inits because of a common pattern of configuring an<br>object in the second init stage<br></p><p>2 since there is already an existing syntax for protocol implementation<br>functions, the role of init keyword is basically to stand for &quot;empty<br>function name&quot; syntax. This sounds interesting.<br></p><p>3 you can also add init to the protocol (with Self return value and<br>required keyword) for some interesting effects.<br></p><p>4 final init, not class init (because init is already called on the class):<br></p><p>class BaseClass {<br>init(x: ...) -&gt; Self // regular, inheritable init, Self can be omitted<br>final init(y:...) -&gt; Self // Self always = BaseClass, can return Derived()<br></p><p>5 yes, that would nicely work with ObjC, even if that was not the original<br>goal :)<br></p><p>On Tue, Dec 8, 2015 at 02:24 Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; Throughout its frameworks, Apple makes use of the “class cluster”<br>&gt; pattern as a means to separate the public API out from the (potentially<br>&gt; complex) internal representations of the data. Clients of the API simply<br>&gt; use the public API, while under the hood a different implementation is<br>&gt; chosen to most efficiently represent the provided initialization parameter<br>&gt; values.<br>&gt; &gt;<br>&gt; &gt; Unfortunately, because initializers in Swift are not methods like in<br>&gt; Objective-C, there is no way to specify what the actual return value should<br>&gt; be (short of returning nil for failable initializers). This makes it<br>&gt; *impossible* to actually implement the class cluster pattern in Swift.<br>&gt;<br>&gt; I’d actually like to put Objective-C interop aside for a moment. There are<br>&gt; many class clusters in Objective-C, but most of them are things you rarely<br>&gt; need to subclass yourself. When was the last time you wrote an NSArray<br>&gt; subclass? What’s more interesting to me is how we can provide a similar<br>&gt; native Swift pattern.<br>&gt;<br>&gt; Here’s my thinking.<br>&gt;<br>&gt; First of all, we call them “class” clusters, but there’s no reason this<br>&gt; should be only for classes. A “class cluster” is basically a single API<br>&gt; which offers access to many different implementations of an interface. The<br>&gt; phrase “many different implementations of an interface” is a hint that we<br>&gt; should be thinking about protocols.<br>&gt;<br>&gt; Here’s what I think Swift should support:<br>&gt;<br>&gt;         protocol HTTPParameterListType {<br>&gt;                 var all: DictionaryLiteral&lt;String, Strong&gt; { get }<br>&gt;                 subscript (name: String) -&gt; [String] { get }<br>&gt;         }<br>&gt;<br>&gt;         // Various implementations include:<br>&gt;         struct JSONParameterList: HTTPParameterList {...}<br>&gt;         struct MultipartParameterList: HTTParameterList {…}<br>&gt;         struct URLEncodedFormParameterList: HTTPParameterList {…}<br>&gt;         struct QueryParameterList: HTTPParameterList {…}<br>&gt;<br>&gt;         extension HTTPParameterListType {<br>&gt;                 protocol init(request: NSHTTPRequest, bodyData: NSData)<br>&gt; throws {<br>&gt;                         switch<br>&gt; request.valueForHTTPHeaderField(“Content-Type”).map({ MIMEType(rawValue:<br>&gt; $0) }) {<br>&gt;                         case .JSON?:<br>&gt;                                 return try JSONParameterList(data:<br>&gt; bodyData)<br>&gt;<br>&gt;                         case .MultipartFormData?:<br>&gt;                                 return try MultipartParameterList(data:<br>&gt; bodyData)<br>&gt;<br>&gt;                         case .URLEncodedForm?:<br>&gt;                                 return try<br>&gt; URLEncodedFormParameterList(data: bodyData)<br>&gt;<br>&gt;                         default:<br>&gt;                                 return try QueryParameterList(request:<br>&gt; request)<br>&gt;                         }<br>&gt;                 }<br>&gt;         }<br>&gt;<br>&gt;         // Usage:<br>&gt;         self.parameters = HTTPParameterListType(request: request,<br>&gt; bodyData: data)<br>&gt;<br>&gt; A `protocol init` in a protocol extension creates an initializer which is<br>&gt; *not* applied to types conforming to the protocol. Instead, it is actually<br>&gt; an initializer on the protocol itself. `self` is the protocol metatype, not<br>&gt; an instance of anything. The provided implementation should `return` an<br>&gt; instance conforming to (and implicitly casted to) the protocol. Just like<br>&gt; any other initializer, a `protocol init` can be failable or throwing.<br>&gt;<br>&gt; Unlike other initializers, Swift usually won’t be able to tell at compile<br>&gt; time which concrete type will be returned by a protocol init(), reducing<br>&gt; opportunities to statically bind methods and perform other optimization<br>&gt; tricks. Frankly, though, that’s just the cost of doing business. If you<br>&gt; want to select a type dynamically, you’re going to lose the ability to<br>&gt; aggressively optimize calls to the resulting instance.<br>&gt;<br>&gt; Perhaps this feature can then be extended back to classes, with a `class<br>&gt; init` being an un-inherited initializer which uses `return` to give the<br>&gt; caller a new object. `self` would be the class object, and only class<br>&gt; variables and methods would be callable from it. But like I said, I’m not<br>&gt; particularly interested in Objective-C interop right now.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/e9905b08/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/009173d589176cfd9c8146cc49849ff6?s=50"></div><header><strong>Proposal: Allow class cluster pattern via dynamic initializer return type</strong> from <string>Riley Testut</string> &lt;rileytestut at gmail.com&gt;<p>December  7, 2015 at 06:00:00pm</p></header><div class="content"><p>Brent, I agree we shouldn’t be focused on Objective-C interop. In fact, this proposal was designed to copy over a pattern implemented in Objective-C, but to then come up with a “swifty” solution. I don’t think dealing with classes necessarily defeats this goal? Sure, Swift has structs too, but classes still play a big role in the language.<br></p><p>Besides that, I like the idea of a protocol-based approach. I don’t necessarily see the need for a class-specific init as you mentioned at the end, because the returned values for the protocols could still be subclasses of a base class. Of course, I’m working with only assumptions right now about when this is useful; all I know is given my current situation, a protocol-based initializer, as you suggested will work well. The only benefit I see would be to not have to create a separate protocol (which isn’t that hard to do), so if we had to stick with just one option, I think you nailed a great implementation.<br></p><p>Additionally, I’m neutral towards whether we should assign self directly in the proposed “protocol init”, or return a type; both seem like good solutions to me.<br></p><p>&gt; On Dec 7, 2015, at 3:39 PM, ilya &lt;ilya.nikokoshev at gmail.com&gt; wrote:<br>&gt; <br>&gt; Some thoughts: <br>&gt; <br>&gt; 1 &quot;self =&quot; is better in inits because of a common pattern of configuring an object in the second init stage <br>&gt; <br>&gt; 2 since there is already an existing syntax for protocol implementation functions, the role of init keyword is basically to stand for &quot;empty function name&quot; syntax. This sounds interesting. <br>&gt; <br>&gt; 3 you can also add init to the protocol (with Self return value and required keyword) for some interesting effects. <br>&gt; <br>&gt; 4 final init, not class init (because init is already called on the class):<br>&gt; <br>&gt; class BaseClass {<br>&gt; init(x: ...) -&gt; Self // regular, inheritable init, Self can be omitted <br>&gt; final init(y:...) -&gt; Self // Self always = BaseClass, can return Derived()<br>&gt; <br>&gt; 5 yes, that would nicely work with ObjC, even if that was not the original goal :)<br>&gt; <br>&gt; On Tue, Dec 8, 2015 at 02:24 Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt; Throughout its frameworks, Apple makes use of the “class cluster” pattern as a means to separate the public API out from the (potentially complex) internal representations of the data. Clients of the API simply use the public API, while under the hood a different implementation is chosen to most efficiently represent the provided initialization parameter values.<br>&gt; &gt;<br>&gt; &gt; Unfortunately, because initializers in Swift are not methods like in Objective-C, there is no way to specify what the actual return value should be (short of returning nil for failable initializers). This makes it *impossible* to actually implement the class cluster pattern in Swift.<br>&gt; <br>&gt; I’d actually like to put Objective-C interop aside for a moment. There are many class clusters in Objective-C, but most of them are things you rarely need to subclass yourself. When was the last time you wrote an NSArray subclass? What’s more interesting to me is how we can provide a similar native Swift pattern.<br>&gt; <br>&gt; Here’s my thinking.<br>&gt; <br>&gt; First of all, we call them “class” clusters, but there’s no reason this should be only for classes. A “class cluster” is basically a single API which offers access to many different implementations of an interface. The phrase “many different implementations of an interface” is a hint that we should be thinking about protocols.<br>&gt; <br>&gt; Here’s what I think Swift should support:<br>&gt; <br>&gt;         protocol HTTPParameterListType {<br>&gt;                 var all: DictionaryLiteral&lt;String, Strong&gt; { get }<br>&gt;                 subscript (name: String) -&gt; [String] { get }<br>&gt;         }<br>&gt; <br>&gt;         // Various implementations include:<br>&gt;         struct JSONParameterList: HTTPParameterList {...}<br>&gt;         struct MultipartParameterList: HTTParameterList {…}<br>&gt;         struct URLEncodedFormParameterList: HTTPParameterList {…}<br>&gt;         struct QueryParameterList: HTTPParameterList {…}<br>&gt; <br>&gt;         extension HTTPParameterListType {<br>&gt;                 protocol init(request: NSHTTPRequest, bodyData: NSData) throws {<br>&gt;                         switch request.valueForHTTPHeaderField(“Content-Type”).map({ MIMEType(rawValue: $0) }) {<br>&gt;                         case .JSON?:<br>&gt;                                 return try JSONParameterList(data: bodyData)<br>&gt; <br>&gt;                         case .MultipartFormData?:<br>&gt;                                 return try MultipartParameterList(data: bodyData)<br>&gt; <br>&gt;                         case .URLEncodedForm?:<br>&gt;                                 return try URLEncodedFormParameterList(data: bodyData)<br>&gt; <br>&gt;                         default:<br>&gt;                                 return try QueryParameterList(request: request)<br>&gt;                         }<br>&gt;                 }<br>&gt;         }<br>&gt; <br>&gt;         // Usage:<br>&gt;         self.parameters = HTTPParameterListType(request: request, bodyData: data)<br>&gt; <br>&gt; A `protocol init` in a protocol extension creates an initializer which is *not* applied to types conforming to the protocol. Instead, it is actually an initializer on the protocol itself. `self` is the protocol metatype, not an instance of anything. The provided implementation should `return` an instance conforming to (and implicitly casted to) the protocol. Just like any other initializer, a `protocol init` can be failable or throwing.<br>&gt; <br>&gt; Unlike other initializers, Swift usually won’t be able to tell at compile time which concrete type will be returned by a protocol init(), reducing opportunities to statically bind methods and perform other optimization tricks. Frankly, though, that’s just the cost of doing business. If you want to select a type dynamically, you’re going to lose the ability to aggressively optimize calls to the resulting instance.<br>&gt; <br>&gt; Perhaps this feature can then be extended back to classes, with a `class init` being an un-inherited initializer which uses `return` to give the caller a new object. `self` would be the class object, and only class variables and methods would be callable from it. But like I said, I’m not particularly interested in Objective-C interop right now.<br>&gt; <br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/76b04d24/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Proposal: Allow class cluster pattern via dynamic initializer return type</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>December  7, 2015 at 06:00:00pm</p></header><div class="content"><p>I really like the idea of having a &#39;protocol initializer&#39; which<br>transparently chooses an appropriate concrete type to return. Once<br>recursive protocol conformance and conditional conformance has been<br>implemented, you&#39;d be able to work with type &quot;aggregates&quot; (imagine JSON or<br>plist types implemented exclusively as protocol conformances on existing<br>types) almost completely in terms of the generic protocol interface.<br></p><p>Austin<br></p><p>On Mon, Dec 7, 2015 at 3:24 PM, Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; Throughout its frameworks, Apple makes use of the “class cluster”<br>&gt; pattern as a means to separate the public API out from the (potentially<br>&gt; complex) internal representations of the data. Clients of the API simply<br>&gt; use the public API, while under the hood a different implementation is<br>&gt; chosen to most efficiently represent the provided initialization parameter<br>&gt; values.<br>&gt; &gt;<br>&gt; &gt; Unfortunately, because initializers in Swift are not methods like in<br>&gt; Objective-C, there is no way to specify what the actual return value should<br>&gt; be (short of returning nil for failable initializers). This makes it<br>&gt; *impossible* to actually implement the class cluster pattern in Swift.<br>&gt;<br>&gt; I’d actually like to put Objective-C interop aside for a moment. There are<br>&gt; many class clusters in Objective-C, but most of them are things you rarely<br>&gt; need to subclass yourself. When was the last time you wrote an NSArray<br>&gt; subclass? What’s more interesting to me is how we can provide a similar<br>&gt; native Swift pattern.<br>&gt;<br>&gt; Here’s my thinking.<br>&gt;<br>&gt; First of all, we call them “class” clusters, but there’s no reason this<br>&gt; should be only for classes. A “class cluster” is basically a single API<br>&gt; which offers access to many different implementations of an interface. The<br>&gt; phrase “many different implementations of an interface” is a hint that we<br>&gt; should be thinking about protocols.<br>&gt;<br>&gt; Here’s what I think Swift should support:<br>&gt;<br>&gt;         protocol HTTPParameterListType {<br>&gt;                 var all: DictionaryLiteral&lt;String, Strong&gt; { get }<br>&gt;                 subscript (name: String) -&gt; [String] { get }<br>&gt;         }<br>&gt;<br>&gt;         // Various implementations include:<br>&gt;         struct JSONParameterList: HTTPParameterList {...}<br>&gt;         struct MultipartParameterList: HTTParameterList {…}<br>&gt;         struct URLEncodedFormParameterList: HTTPParameterList {…}<br>&gt;         struct QueryParameterList: HTTPParameterList {…}<br>&gt;<br>&gt;         extension HTTPParameterListType {<br>&gt;                 protocol init(request: NSHTTPRequest, bodyData: NSData)<br>&gt; throws {<br>&gt;                         switch<br>&gt; request.valueForHTTPHeaderField(“Content-Type”).map({ MIMEType(rawValue:<br>&gt; $0) }) {<br>&gt;                         case .JSON?:<br>&gt;                                 return try JSONParameterList(data:<br>&gt; bodyData)<br>&gt;<br>&gt;                         case .MultipartFormData?:<br>&gt;                                 return try MultipartParameterList(data:<br>&gt; bodyData)<br>&gt;<br>&gt;                         case .URLEncodedForm?:<br>&gt;                                 return try<br>&gt; URLEncodedFormParameterList(data: bodyData)<br>&gt;<br>&gt;                         default:<br>&gt;                                 return try QueryParameterList(request:<br>&gt; request)<br>&gt;                         }<br>&gt;                 }<br>&gt;         }<br>&gt;<br>&gt;         // Usage:<br>&gt;         self.parameters = HTTPParameterListType(request: request,<br>&gt; bodyData: data)<br>&gt;<br>&gt; A `protocol init` in a protocol extension creates an initializer which is<br>&gt; *not* applied to types conforming to the protocol. Instead, it is actually<br>&gt; an initializer on the protocol itself. `self` is the protocol metatype, not<br>&gt; an instance of anything. The provided implementation should `return` an<br>&gt; instance conforming to (and implicitly casted to) the protocol. Just like<br>&gt; any other initializer, a `protocol init` can be failable or throwing.<br>&gt;<br>&gt; Unlike other initializers, Swift usually won’t be able to tell at compile<br>&gt; time which concrete type will be returned by a protocol init(), reducing<br>&gt; opportunities to statically bind methods and perform other optimization<br>&gt; tricks. Frankly, though, that’s just the cost of doing business. If you<br>&gt; want to select a type dynamically, you’re going to lose the ability to<br>&gt; aggressively optimize calls to the resulting instance.<br>&gt;<br>&gt; Perhaps this feature can then be extended back to classes, with a `class<br>&gt; init` being an un-inherited initializer which uses `return` to give the<br>&gt; caller a new object. `self` would be the class object, and only class<br>&gt; variables and methods would be callable from it. But like I said, I’m not<br>&gt; particularly interested in Objective-C interop right now.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/c71d7be3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/009173d589176cfd9c8146cc49849ff6?s=50"></div><header><strong>Proposal: Allow class cluster pattern via dynamic initializer return type</strong> from <string>Riley Testut</string> &lt;rileytestut at gmail.com&gt;<p>December  7, 2015 at 10:00:00pm</p></header><div class="content"><p>While I agree this solves the issue, I feel this enhancement could be useful for far more than replicating the simple class cluster pattern. Because of this, I think might make a new proposal focusing on protocol initializers, and have the class cluster pattern be just one example of an advantage. Are there any other problems this might be able to solve?<br></p><p>&gt; On Dec 7, 2015, at 6:17 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; I really like the idea of having a &#39;protocol initializer&#39; which transparently chooses an appropriate concrete type to return. Once recursive protocol conformance and conditional conformance has been implemented, you&#39;d be able to work with type &quot;aggregates&quot; (imagine JSON or plist types implemented exclusively as protocol conformances on existing types) almost completely in terms of the generic protocol interface.<br>&gt; <br>&gt; Austin<br>&gt; <br>&gt; On Mon, Dec 7, 2015 at 3:24 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt; Throughout its frameworks, Apple makes use of the “class cluster” pattern as a means to separate the public API out from the (potentially complex) internal representations of the data. Clients of the API simply use the public API, while under the hood a different implementation is chosen to most efficiently represent the provided initialization parameter values.<br>&gt; &gt;<br>&gt; &gt; Unfortunately, because initializers in Swift are not methods like in Objective-C, there is no way to specify what the actual return value should be (short of returning nil for failable initializers). This makes it *impossible* to actually implement the class cluster pattern in Swift.<br>&gt; <br>&gt; I’d actually like to put Objective-C interop aside for a moment. There are many class clusters in Objective-C, but most of them are things you rarely need to subclass yourself. When was the last time you wrote an NSArray subclass? What’s more interesting to me is how we can provide a similar native Swift pattern.<br>&gt; <br>&gt; Here’s my thinking.<br>&gt; <br>&gt; First of all, we call them “class” clusters, but there’s no reason this should be only for classes. A “class cluster” is basically a single API which offers access to many different implementations of an interface. The phrase “many different implementations of an interface” is a hint that we should be thinking about protocols.<br>&gt; <br>&gt; Here’s what I think Swift should support:<br>&gt; <br>&gt;         protocol HTTPParameterListType {<br>&gt;                 var all: DictionaryLiteral&lt;String, Strong&gt; { get }<br>&gt;                 subscript (name: String) -&gt; [String] { get }<br>&gt;         }<br>&gt; <br>&gt;         // Various implementations include:<br>&gt;         struct JSONParameterList: HTTPParameterList {...}<br>&gt;         struct MultipartParameterList: HTTParameterList {…}<br>&gt;         struct URLEncodedFormParameterList: HTTPParameterList {…}<br>&gt;         struct QueryParameterList: HTTPParameterList {…}<br>&gt; <br>&gt;         extension HTTPParameterListType {<br>&gt;                 protocol init(request: NSHTTPRequest, bodyData: NSData) throws {<br>&gt;                         switch request.valueForHTTPHeaderField(“Content-Type”).map({ MIMEType(rawValue: $0) }) {<br>&gt;                         case .JSON?:<br>&gt;                                 return try JSONParameterList(data: bodyData)<br>&gt; <br>&gt;                         case .MultipartFormData?:<br>&gt;                                 return try MultipartParameterList(data: bodyData)<br>&gt; <br>&gt;                         case .URLEncodedForm?:<br>&gt;                                 return try URLEncodedFormParameterList(data: bodyData)<br>&gt; <br>&gt;                         default:<br>&gt;                                 return try QueryParameterList(request: request)<br>&gt;                         }<br>&gt;                 }<br>&gt;         }<br>&gt; <br>&gt;         // Usage:<br>&gt;         self.parameters = HTTPParameterListType(request: request, bodyData: data)<br>&gt; <br>&gt; A `protocol init` in a protocol extension creates an initializer which is *not* applied to types conforming to the protocol. Instead, it is actually an initializer on the protocol itself. `self` is the protocol metatype, not an instance of anything. The provided implementation should `return` an instance conforming to (and implicitly casted to) the protocol. Just like any other initializer, a `protocol init` can be failable or throwing.<br>&gt; <br>&gt; Unlike other initializers, Swift usually won’t be able to tell at compile time which concrete type will be returned by a protocol init(), reducing opportunities to statically bind methods and perform other optimization tricks. Frankly, though, that’s just the cost of doing business. If you want to select a type dynamically, you’re going to lose the ability to aggressively optimize calls to the resulting instance.<br>&gt; <br>&gt; Perhaps this feature can then be extended back to classes, with a `class init` being an un-inherited initializer which uses `return` to give the caller a new object. `self` would be the class object, and only class variables and methods would be callable from it. But like I said, I’m not particularly interested in Objective-C interop right now.<br>&gt; <br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/71fcc316/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/00f9939846257c9db8ddc42ce61ec6d1?s=50"></div><header><strong>Proposal: Allow class cluster pattern via dynamic initializer return type</strong> from <string>Philippe Hausler</string> &lt;phausler at apple.com&gt;<p>December  9, 2015 at 11:00:00am</p></header><div class="content"><p>I can definitely attest that in implementing Foundation we could have much more idiomatic swift and much more similar behavior to the way Foundation on Darwin actually works if we had factory initializers. <br></p><p>It would be interesting to simplify the syntax down to something along the lines of<br></p><p>class AbstractBase {<br>    public factory init(type: InformationToSwitchOn) {<br>        return ConcreteImplementation(type)<br>    }<br>}<br></p><p>class ConcreteImplementation : AbstractBase {<br></p><p>}<br></p><p>This way the initialization would be returned from a standard init method and the return value is inherited correctly. The one potential issue with this is that structs would not fit well into this since the layout size must be known.<br></p><p>&gt; On Dec 7, 2015, at 12:19 PM, Riley Testut via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Happy Monday everyone!<br>&gt; <br>&gt; I wrote up a prototype proposal, which is probably best viewed on GitHub (https://github.com/rileytestut/swift-proposals/blob/master/class-cluster.md &lt;https://github.com/rileytestut/swift-proposals/blob/master/class-cluster.md&gt;). But for convenience, I’ve included it in this email body as well. Hopefully someone else thinks this would be an idea worth considering :-) <br>&gt; <br>&gt; ## Introduction<br>&gt; <br>&gt; Throughout its frameworks, Apple makes use of the “class cluster” pattern as a means to separate the public API out from the (potentially complex) internal representations of the data. Clients of the API simply use the public API, while under the hood a different implementation is chosen to most efficiently represent the provided initialization parameter values.<br>&gt; <br>&gt; Unfortunately, because initializers in Swift are not methods like in Objective-C, there is no way to specify what the actual return value should be (short of returning nil for failable initializers). This makes it *impossible* to actually implement the class cluster pattern in Swift.<br>&gt; <br>&gt; ## Motivation<br>&gt; <br>&gt; While developing my own Swift framework, I found myself wanting to provide a similar functionality. For the client of said framework, I wanted them to be able to create an instance of an essentially abstract class, and be returned a private subclass instance suited best for handling whatever input initialization parameters they provided. It didn’t make sense given the circumstances to ask the user to decide which class would be the best representation of the data; it should “just work”.<br>&gt; <br>&gt; Additionally, the class cluster pattern can make backwards compatibility significantly easier; instead of littering your code with branches for different versions of an OS, you could instead have one if/switch statement to determine the appropriate subclass for the current OS you’re running on. This allows the developer to trivially keep legacy code for older platforms while taking advantage of new APIs/designs, and also without changing *any* client code. An example of the class cluster pattern being used for this reason can be seen here: http://www.xs-labs.com/en/blog/2013/06/18/ios7-new-ui-strategies/ &lt;http://www.xs-labs.com/en/blog/2013/06/18/ios7-new-ui-strategies/&gt;<br>&gt; <br>&gt; ## Proposed solution<br>&gt; <br>&gt; I propose that we allow for implementation of the class cluster pattern by providing a way to (at run time) specify the actual type that should be initialized depending on the provided initialization parameters.<br>&gt; <br>&gt; ## Detailed design<br>&gt; <br>&gt; Introduce a new class method that can return an appropriate type that should be used for initialization, depending on the provided initialization parameters.<br>&gt; <br>&gt; This is what I believe to be the most clean solution, and with (assumedly) minimal impact on the existing nature of Swift’s initialization process. To ensure this remains safe, the only types allowed to be returned should be subclasses of the parent class (such as returning a __NSArrayI for NSArray). Notably, beyond this method, everything else remains the same; all this does is change what class the initializer is called on initially.<br>&gt; <br>&gt; Here is an ideal implementation gist:<br>&gt; https://gist.github.com/rileytestut/0e6e80d3f22b845502e7 &lt;https://gist.github.com/rileytestut/0e6e80d3f22b845502e7&gt;<br>&gt; <br>&gt; ## Impact on existing code<br>&gt; <br>&gt; There will be zero impact on existing code; if the proposed class method is not implemented, then it will default to simply initializing the “base” class, as it always has.<br>&gt; <br>&gt; ## Alternatives considered<br>&gt; <br>&gt; Allow for return values in initializers<br>&gt; <br>&gt; This is essentially how most class cluster patterns are implemented in Objective-C. Inside the init method, the class inspects the provided parameters, then assigns self to an instance of the appropriate subclass. Unfortunately, this is wasteful; memory is allocated for the base class, and then subsequently replaced with new memory allocated for the appropriate base class. More importantly though, the whole process can be complicated; it can be very easy to make an infinite recursive loop by calling [super init] in the subclass, which then assigns self to a new instance of the subclass, which then calls [super init]…etc. <br>&gt; <br>&gt; tl;dr; this method would work, but would be somewhat inconvenient to implement.<br>&gt; <br>&gt; Class function to return appropriate instance<br>&gt; <br>&gt; This is probably the simplest approach: simply make a class function that returns an instance of the appropriate class given a few input parameters. This totally works, but it means consumers of the API have to remember to use the class method instead of the initializer. Even if all initializers for the class were marked private, it would be strange to have the dissonance between using initializers and class methods to instantiate types in code. The consumer should not have to know about *any* of the implementation details; everything should “just work”. Forcing them to use alternative means to instantiate objects breaks this philosophy, IMO.<br>&gt; <br>&gt; Derive from Objective-C base class<br>&gt; <br>&gt; Another option is to simply derive from an Objective-C base class, and this is actually what I am doing right now in my framework. Unfortunately, there is one significant drawback: because the initialization is happening in Objective-C, you can only provide Objective-C compatible types for the initialization parameters (so no Swift structs for you!). Additionally, this (obviously) means whatever code is using it is limited to systems with Objective-C support, so it is not as portable as a pure-Swift solution.<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/9e18488d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/73a38bb7bc9528e31098defe30e68ea4?s=50"></div><header><strong>Proposal: Allow class cluster pattern via dynamic initializer return type</strong> from <string>Jean-Daniel Dupas</string> &lt;mailing at xenonium.com&gt;<p>December  9, 2015 at 11:00:00pm</p></header><div class="content"><p>My experience with class cluster, is that they are confusing and almost implemented wrong. You can as easily create a « class cluster » simply be not exposing the constructor of your class and providing factory methods instead. While it may have some drawback in the Obj-C days (class methods are used to returned autoreleased objects), that point no longer apply in modern obj-c (using ARC) and swift code.<br></p><p>For instance, instead of having NSNumber(float:0), NSNumber(int:0) you can just have NSNumber.float(0), and NSNumber.int(0) with float and int being class or static method returning instance of subclasses of NSNumber.<br></p><p>I don’t see what is the benefit of having a class cluster designed by providing fake initialization method vs using a factory method.<br></p><p><br>&gt; Le 9 déc. 2015 à 20:06, Philippe Hausler via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; I can definitely attest that in implementing Foundation we could have much more idiomatic swift and much more similar behavior to the way Foundation on Darwin actually works if we had factory initializers. <br>&gt; <br>&gt; It would be interesting to simplify the syntax down to something along the lines of<br>&gt; <br>&gt; class AbstractBase {<br>&gt;     public factory init(type: InformationToSwitchOn) {<br>&gt;         return ConcreteImplementation(type)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; class ConcreteImplementation : AbstractBase {<br>&gt; <br>&gt; }<br>&gt; <br>&gt; This way the initialization would be returned from a standard init method and the return value is inherited correctly. The one potential issue with this is that structs would not fit well into this since the layout size must be known.<br>&gt; <br>&gt;&gt; On Dec 7, 2015, at 12:19 PM, Riley Testut via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Happy Monday everyone!<br>&gt;&gt; <br>&gt;&gt; I wrote up a prototype proposal, which is probably best viewed on GitHub (https://github.com/rileytestut/swift-proposals/blob/master/class-cluster.md &lt;https://github.com/rileytestut/swift-proposals/blob/master/class-cluster.md&gt;). But for convenience, I’ve included it in this email body as well. Hopefully someone else thinks this would be an idea worth considering :-) <br>&gt;&gt; <br>&gt;&gt; ## Introduction<br>&gt;&gt; <br>&gt;&gt; Throughout its frameworks, Apple makes use of the “class cluster” pattern as a means to separate the public API out from the (potentially complex) internal representations of the data. Clients of the API simply use the public API, while under the hood a different implementation is chosen to most efficiently represent the provided initialization parameter values.<br>&gt;&gt; <br>&gt;&gt; Unfortunately, because initializers in Swift are not methods like in Objective-C, there is no way to specify what the actual return value should be (short of returning nil for failable initializers). This makes it *impossible* to actually implement the class cluster pattern in Swift.<br>&gt;&gt; <br>&gt;&gt; ## Motivation<br>&gt;&gt; <br>&gt;&gt; While developing my own Swift framework, I found myself wanting to provide a similar functionality. For the client of said framework, I wanted them to be able to create an instance of an essentially abstract class, and be returned a private subclass instance suited best for handling whatever input initialization parameters they provided. It didn’t make sense given the circumstances to ask the user to decide which class would be the best representation of the data; it should “just work”.<br>&gt;&gt; <br>&gt;&gt; Additionally, the class cluster pattern can make backwards compatibility significantly easier; instead of littering your code with branches for different versions of an OS, you could instead have one if/switch statement to determine the appropriate subclass for the current OS you’re running on. This allows the developer to trivially keep legacy code for older platforms while taking advantage of new APIs/designs, and also without changing *any* client code. An example of the class cluster pattern being used for this reason can be seen here: http://www.xs-labs.com/en/blog/2013/06/18/ios7-new-ui-strategies/ &lt;http://www.xs-labs.com/en/blog/2013/06/18/ios7-new-ui-strategies/&gt;<br>&gt;&gt; <br>&gt;&gt; ## Proposed solution<br>&gt;&gt; <br>&gt;&gt; I propose that we allow for implementation of the class cluster pattern by providing a way to (at run time) specify the actual type that should be initialized depending on the provided initialization parameters.<br>&gt;&gt; <br>&gt;&gt; ## Detailed design<br>&gt;&gt; <br>&gt;&gt; Introduce a new class method that can return an appropriate type that should be used for initialization, depending on the provided initialization parameters.<br>&gt;&gt; <br>&gt;&gt; This is what I believe to be the most clean solution, and with (assumedly) minimal impact on the existing nature of Swift’s initialization process. To ensure this remains safe, the only types allowed to be returned should be subclasses of the parent class (such as returning a __NSArrayI for NSArray). Notably, beyond this method, everything else remains the same; all this does is change what class the initializer is called on initially.<br>&gt;&gt; <br>&gt;&gt; Here is an ideal implementation gist:<br>&gt;&gt; https://gist.github.com/rileytestut/0e6e80d3f22b845502e7 &lt;https://gist.github.com/rileytestut/0e6e80d3f22b845502e7&gt;<br>&gt;&gt; <br>&gt;&gt; ## Impact on existing code<br>&gt;&gt; <br>&gt;&gt; There will be zero impact on existing code; if the proposed class method is not implemented, then it will default to simply initializing the “base” class, as it always has.<br>&gt;&gt; <br>&gt;&gt; ## Alternatives considered<br>&gt;&gt; <br>&gt;&gt; Allow for return values in initializers<br>&gt;&gt; <br>&gt;&gt; This is essentially how most class cluster patterns are implemented in Objective-C. Inside the init method, the class inspects the provided parameters, then assigns self to an instance of the appropriate subclass. Unfortunately, this is wasteful; memory is allocated for the base class, and then subsequently replaced with new memory allocated for the appropriate base class. More importantly though, the whole process can be complicated; it can be very easy to make an infinite recursive loop by calling [super init] in the subclass, which then assigns self to a new instance of the subclass, which then calls [super init]…etc. <br>&gt;&gt; <br>&gt;&gt; tl;dr; this method would work, but would be somewhat inconvenient to implement.<br>&gt;&gt; <br>&gt;&gt; Class function to return appropriate instance<br>&gt;&gt; <br>&gt;&gt; This is probably the simplest approach: simply make a class function that returns an instance of the appropriate class given a few input parameters. This totally works, but it means consumers of the API have to remember to use the class method instead of the initializer. Even if all initializers for the class were marked private, it would be strange to have the dissonance between using initializers and class methods to instantiate types in code. The consumer should not have to know about *any* of the implementation details; everything should “just work”. Forcing them to use alternative means to instantiate objects breaks this philosophy, IMO.<br>&gt;&gt; <br>&gt;&gt; Derive from Objective-C base class<br>&gt;&gt; <br>&gt;&gt; Another option is to simply derive from an Objective-C base class, and this is actually what I am doing right now in my framework. Unfortunately, there is one significant drawback: because the initialization is happening in Objective-C, you can only provide Objective-C compatible types for the initialization parameters (so no Swift structs for you!). Additionally, this (obviously) means whatever code is using it is limited to systems with Objective-C support, so it is not as portable as a pure-Swift solution.<br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/9858fc3b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Proposal: Allow class cluster pattern via dynamic initializer return type</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>December  9, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; On Dec 9, 2015, at 4:11 PM, Jean-Daniel Dupas via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; My experience with class cluster, is that they are confusing and almost implemented wrong. You can as easily create a « class cluster » simply be not exposing the constructor of your class and providing factory methods instead.<br></p><p>This is not possible with Swift, because it does not have a “private” access modifier. In order for subclasses to be able to override the abstract superclass’s designated initializer, that initializer has to be public. Callers can then call the initializer on the superclass and get undefined behavior.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/fffa0c95/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Proposal: Allow class cluster pattern via dynamic initializer return type</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>December  9, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; On Dec 9, 2015, at 4:54 PM, Charles Srstka &lt;cocoadev at charlessoft.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 9, 2015, at 4:11 PM, Jean-Daniel Dupas via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; My experience with class cluster, is that they are confusing and almost implemented wrong. You can as easily create a « class cluster » simply be not exposing the constructor of your class and providing factory methods instead.<br>&gt; <br>&gt; This is not possible with Swift, because it does not have a “private” access modifier. In order for subclasses to be able to override the abstract superclass’s designated initializer, that initializer has to be public. Callers can then call the initializer on the superclass and get undefined behavior.<br>&gt; <br>&gt; Charles<br></p><p>This was meant to say that Swift does not have “protected”, not “private”. Apologies for the typo.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/f9dfe0f3/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/009173d589176cfd9c8146cc49849ff6?s=50"></div><header><strong>Proposal: Allow class cluster pattern via dynamic initializer return type</strong> from <string>Riley Testut</string> &lt;rileytestut at gmail.com&gt;<p>December 10, 2015 at 12:00:00pm</p></header><div class="content"><p>Glad you mentioned the Foundation port, because I was curious how the lack of true class cluster support would affect that project. Nice to see some validation that it would be a useful feature :-)<br></p><p>I really like the proposed syntax; I think it is the simplest to both implement and understand of the solutions in this thread. But as you said, it wouldn’t work for structs, which while personally is not a major factor for my project, I agree if we’re adding a new feature to the language, it might seem strange to limit it to classes because of a technicality like that.<br></p><p>Maybe the AbstractBase of a “cluster&quot; of structs could be implemented similarly to indirect enums? I’m no compiler guru by any stretch of the imagination, but if it is known that the AbstractBase will never be used directly, maybe it’s easier to “fake” it then? I definitely want whatever solution decided on (if it’s decided that this is a worthwhile feature) to work for both value and reference types. Additionally, if we can pull this off, maybe we could extend the “public factory init” syntax to protocols as well, so either a reference or a value type could be returned from a protocol’s factory init method (implemented through a protocol extension), though I don’t think that needs to be as high priority.<br></p><p>&gt; On Dec 9, 2015, at 11:06 AM, Philippe Hausler &lt;phausler at apple.com&gt; wrote:<br>&gt; <br>&gt; I can definitely attest that in implementing Foundation we could have much more idiomatic swift and much more similar behavior to the way Foundation on Darwin actually works if we had factory initializers. <br>&gt; <br>&gt; It would be interesting to simplify the syntax down to something along the lines of<br>&gt; <br>&gt; class AbstractBase {<br>&gt;     public factory init(type: InformationToSwitchOn) {<br>&gt;         return ConcreteImplementation(type)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; class ConcreteImplementation : AbstractBase {<br>&gt; <br>&gt; }<br>&gt; <br>&gt; This way the initialization would be returned from a standard init method and the return value is inherited correctly. The one potential issue with this is that structs would not fit well into this since the layout size must be known.<br>&gt; <br>&gt;&gt; On Dec 7, 2015, at 12:19 PM, Riley Testut via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Happy Monday everyone!<br>&gt;&gt; <br>&gt;&gt; I wrote up a prototype proposal, which is probably best viewed on GitHub (https://github.com/rileytestut/swift-proposals/blob/master/class-cluster.md &lt;https://github.com/rileytestut/swift-proposals/blob/master/class-cluster.md&gt;). But for convenience, I’ve included it in this email body as well. Hopefully someone else thinks this would be an idea worth considering :-) <br>&gt;&gt; <br>&gt;&gt; ## Introduction<br>&gt;&gt; <br>&gt;&gt; Throughout its frameworks, Apple makes use of the “class cluster” pattern as a means to separate the public API out from the (potentially complex) internal representations of the data. Clients of the API simply use the public API, while under the hood a different implementation is chosen to most efficiently represent the provided initialization parameter values.<br>&gt;&gt; <br>&gt;&gt; Unfortunately, because initializers in Swift are not methods like in Objective-C, there is no way to specify what the actual return value should be (short of returning nil for failable initializers). This makes it *impossible* to actually implement the class cluster pattern in Swift.<br>&gt;&gt; <br>&gt;&gt; ## Motivation<br>&gt;&gt; <br>&gt;&gt; While developing my own Swift framework, I found myself wanting to provide a similar functionality. For the client of said framework, I wanted them to be able to create an instance of an essentially abstract class, and be returned a private subclass instance suited best for handling whatever input initialization parameters they provided. It didn’t make sense given the circumstances to ask the user to decide which class would be the best representation of the data; it should “just work”.<br>&gt;&gt; <br>&gt;&gt; Additionally, the class cluster pattern can make backwards compatibility significantly easier; instead of littering your code with branches for different versions of an OS, you could instead have one if/switch statement to determine the appropriate subclass for the current OS you’re running on. This allows the developer to trivially keep legacy code for older platforms while taking advantage of new APIs/designs, and also without changing *any* client code. An example of the class cluster pattern being used for this reason can be seen here: http://www.xs-labs.com/en/blog/2013/06/18/ios7-new-ui-strategies/ &lt;http://www.xs-labs.com/en/blog/2013/06/18/ios7-new-ui-strategies/&gt;<br>&gt;&gt; <br>&gt;&gt; ## Proposed solution<br>&gt;&gt; <br>&gt;&gt; I propose that we allow for implementation of the class cluster pattern by providing a way to (at run time) specify the actual type that should be initialized depending on the provided initialization parameters.<br>&gt;&gt; <br>&gt;&gt; ## Detailed design<br>&gt;&gt; <br>&gt;&gt; Introduce a new class method that can return an appropriate type that should be used for initialization, depending on the provided initialization parameters.<br>&gt;&gt; <br>&gt;&gt; This is what I believe to be the most clean solution, and with (assumedly) minimal impact on the existing nature of Swift’s initialization process. To ensure this remains safe, the only types allowed to be returned should be subclasses of the parent class (such as returning a __NSArrayI for NSArray). Notably, beyond this method, everything else remains the same; all this does is change what class the initializer is called on initially.<br>&gt;&gt; <br>&gt;&gt; Here is an ideal implementation gist:<br>&gt;&gt; https://gist.github.com/rileytestut/0e6e80d3f22b845502e7 &lt;https://gist.github.com/rileytestut/0e6e80d3f22b845502e7&gt;<br>&gt;&gt; <br>&gt;&gt; ## Impact on existing code<br>&gt;&gt; <br>&gt;&gt; There will be zero impact on existing code; if the proposed class method is not implemented, then it will default to simply initializing the “base” class, as it always has.<br>&gt;&gt; <br>&gt;&gt; ## Alternatives considered<br>&gt;&gt; <br>&gt;&gt; Allow for return values in initializers<br>&gt;&gt; <br>&gt;&gt; This is essentially how most class cluster patterns are implemented in Objective-C. Inside the init method, the class inspects the provided parameters, then assigns self to an instance of the appropriate subclass. Unfortunately, this is wasteful; memory is allocated for the base class, and then subsequently replaced with new memory allocated for the appropriate base class. More importantly though, the whole process can be complicated; it can be very easy to make an infinite recursive loop by calling [super init] in the subclass, which then assigns self to a new instance of the subclass, which then calls [super init]…etc. <br>&gt;&gt; <br>&gt;&gt; tl;dr; this method would work, but would be somewhat inconvenient to implement.<br>&gt;&gt; <br>&gt;&gt; Class function to return appropriate instance<br>&gt;&gt; <br>&gt;&gt; This is probably the simplest approach: simply make a class function that returns an instance of the appropriate class given a few input parameters. This totally works, but it means consumers of the API have to remember to use the class method instead of the initializer. Even if all initializers for the class were marked private, it would be strange to have the dissonance between using initializers and class methods to instantiate types in code. The consumer should not have to know about *any* of the implementation details; everything should “just work”. Forcing them to use alternative means to instantiate objects breaks this philosophy, IMO.<br>&gt;&gt; <br>&gt;&gt; Derive from Objective-C base class<br>&gt;&gt; <br>&gt;&gt; Another option is to simply derive from an Objective-C base class, and this is actually what I am doing right now in my framework. Unfortunately, there is one significant drawback: because the initialization is happening in Objective-C, you can only provide Objective-C compatible types for the initialization parameters (so no Swift structs for you!). Additionally, this (obviously) means whatever code is using it is limited to systems with Objective-C support, so it is not as portable as a pure-Swift solution.<br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/deda4253/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
