<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>MemoryLayout for a value</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>August  3, 2016 at 01:00:00pm</p></header><div class="content"><p>Having seen the effects in the standard library and in other<br>code, I&#39;m concerned that we may have made a mistake in removing<br>`sizeofValue` et al without providing a replacement.  In the standard<br>library, we ended up adding an underscored API that allows<br></p><p>  MemoryLayout._ofInstance(someExpression).size<br></p><p>Where someExpression is an autoclosure, and thus not evaluated.  I<br>wanted to bring up the possibility of introducing a replacement as a<br>bufix.<br></p><p>I propose that the way to express the above should be:<br></p><p>  MemoryLayout.of(type(of: someExpression)).size<br></p><p>implementable as:<br></p><p>  extension MemoryLayout {<br>    @_transparent<br>    public<br>    static func of(_: T.Type) -&gt; MemoryLayout&lt;T&gt;.Type {<br>      return MemoryLayout&lt;T&gt;.self<br>    }<br>  }<br></p><p>I think this API would solve the concerns I had about confusability that<br>led me to advocate dropping the ability to ask for the size of a value.<br>The only way to use it is to pass a type and these two expressions have<br>equivalent meaning:<br></p><p>    MemoryLayout&lt;Int&gt;<br>    MemoryLayout.of(Int.self)<br></p><p>It also has the benefit of isolating the autoclosure magic to type(of:).<br></p><p>,----[ Aside ]<br>| A slightly cleaner use site is possible with a larger API change:<br>| <br>|   MemoryLayout(type(of: someExpression)).size<br>| <br>| Which would involve changing MemoryLayout from an `enum` to<br>| a `struct` and adding the following:<br>| <br>|   extension MemoryLayout {<br>|     public init(_: T.Type) {}<br>| <br>|     public var size: Int { return MemoryLayout.size }<br>|     public var stride: Int { return MemoryLayout.stride }<br>|     public var alignment: Int { return MemoryLayout.alignment }<br>|   }<br>| <br>| However I am concerned that dropping &quot;.of&quot; at the use site is worth the<br>| added API complexity.<br>`----<br></p><p>Thoughts?<br>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>MemoryLayout for a value</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August  3, 2016 at 10:00:00pm</p></header><div class="content"><p>Why not just MemoryLayout.init(of instance: T), and drop the autoclosure<br>magic altogether?<br></p><p>The classic sizeofValue evaluated its argument, and in Foundation several<br>uses of it actually relied on that side effect. While autoclosures are<br>quite clever, in general I think the user expectation is that given<br>`a(b(c))` both a and b are invoked, side effects and all.<br></p><p>Note that both type(of:) as it&#39;s currently implemented and the old<br>dynamicType evaluate its argument/receiver. No one afaik has ever thought<br>that behavior to be anomalous (though I bet we&#39;re about to hear some<br>arguments to that effect now).<br>On Wed, Aug 3, 2016 at 15:46 Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; Having seen the effects in the standard library and in other<br>&gt; code, I&#39;m concerned that we may have made a mistake in removing<br>&gt; `sizeofValue` et al without providing a replacement.  In the standard<br>&gt; library, we ended up adding an underscored API that allows<br>&gt;<br>&gt;   MemoryLayout._ofInstance(someExpression).size<br>&gt;<br>&gt; Where someExpression is an autoclosure, and thus not evaluated.  I<br>&gt; wanted to bring up the possibility of introducing a replacement as a<br>&gt; bufix.<br>&gt;<br>&gt; I propose that the way to express the above should be:<br>&gt;<br>&gt;   MemoryLayout.of(type(of: someExpression)).size<br>&gt;<br>&gt; implementable as:<br>&gt;<br>&gt;   extension MemoryLayout {<br>&gt;     @_transparent<br>&gt;     public<br>&gt;     static func of(_: T.Type) -&gt; MemoryLayout&lt;T&gt;.Type {<br>&gt;       return MemoryLayout&lt;T&gt;.self<br>&gt;     }<br>&gt;   }<br>&gt;<br>&gt; I think this API would solve the concerns I had about confusability that<br>&gt; led me to advocate dropping the ability to ask for the size of a value.<br>&gt; The only way to use it is to pass a type and these two expressions have<br>&gt; equivalent meaning:<br>&gt;<br>&gt;     MemoryLayout&lt;Int&gt;<br>&gt;     MemoryLayout.of(Int.self)<br>&gt;<br>&gt; It also has the benefit of isolating the autoclosure magic to type(of:).<br>&gt;<br>&gt; ,----[ Aside ]<br>&gt; | A slightly cleaner use site is possible with a larger API change:<br>&gt; |<br>&gt; |   MemoryLayout(type(of: someExpression)).size<br>&gt; |<br>&gt; | Which would involve changing MemoryLayout from an `enum` to<br>&gt; | a `struct` and adding the following:<br>&gt; |<br>&gt; |   extension MemoryLayout {<br>&gt; |     public init(_: T.Type) {}<br>&gt; |<br>&gt; |     public var size: Int { return MemoryLayout.size }<br>&gt; |     public var stride: Int { return MemoryLayout.stride }<br>&gt; |     public var alignment: Int { return MemoryLayout.alignment }<br>&gt; |   }<br>&gt; |<br>&gt; | However I am concerned that dropping &quot;.of&quot; at the use site is worth the<br>&gt; | added API complexity.<br>&gt; `----<br>&gt;<br>&gt; Thoughts?<br>&gt; --<br>&gt; -Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160803/3108877c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>MemoryLayout for a value</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>August  3, 2016 at 09:00:00pm</p></header><div class="content"><p>on Wed Aug 03 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br></p><p>&gt; Why not just MemoryLayout.init(of instance: T), and drop the autoclosure<br>&gt; magic altogether?<br></p><p>My proposal *does* drop the autoclosure magic.  `type(of: x)` is already in<br>the standard library (replacing `x.dynamicType`). The reasons not to have:<br></p><p>   MemoryLayout(of: x)<br></p><p>where x is an arbitrary instance, is that it reads and pronounces the<br>same as<br></p><p>   MemoryLayout&lt;X&gt;<br></p><p>but has different meaning, and even a different type (which results in<br>additional API complexity—the forwarding vars I showed in the [Aside]<br>box from my previous post).  Imagine explaining the difference between<br>these two in that world:<br></p><p>   MemoryLayout&lt;Int&gt;<br>   MemoryLayout(of: Int.self)<br></p><p>The first is a type representing the layout of Int.  The second is an<br>instance of that type representing the layout of Int&#39;s metatype.<br> <br>&gt; The classic sizeofValue evaluated its argument, and in Foundation several<br>&gt; uses of it actually relied on that side effect. While autoclosures are<br>&gt; quite clever, in general I think the user expectation is that given<br>&gt; `a(b(c))` both a and b are invoked, side effects and all.<br>&gt;<br>&gt; Note that both type(of:) as it&#39;s currently implemented and the old<br>&gt; dynamicType evaluate its argument/receiver. <br></p><p>I didn&#39;t realize that, but it&#39;s fine.  I&#39;m attached to the use of<br>`type(of:)` in this idiom, not to having an autoclosure involved.<br></p><p>&gt; No one afaik has ever thought that behavior to be anomalous (though I<br>&gt; bet we&#39;re about to hear some arguments to that effect now).  <br>&gt;<br>&gt; On Wed, Aug 3, 2016 at 15:46 Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; Having seen the effects in the standard library and in other<br>&gt;&gt; code, I&#39;m concerned that we may have made a mistake in removing<br>&gt;&gt; `sizeofValue` et al without providing a replacement.  In the standard<br>&gt;&gt; library, we ended up adding an underscored API that allows<br>&gt;&gt;<br>&gt;&gt;   MemoryLayout._ofInstance(someExpression).size<br>&gt;&gt;<br>&gt;&gt; Where someExpression is an autoclosure, and thus not evaluated.  I<br>&gt;&gt; wanted to bring up the possibility of introducing a replacement as a<br>&gt;&gt; bufix.<br>&gt;&gt;<br>&gt;&gt; I propose that the way to express the above should be:<br>&gt;&gt;<br>&gt;&gt;   MemoryLayout.of(type(of: someExpression)).size<br>&gt;&gt;<br>&gt;&gt; implementable as:<br>&gt;&gt;<br>&gt;&gt;   extension MemoryLayout {<br>&gt;&gt;     @_transparent<br>&gt;&gt;     public<br>&gt;&gt;     static func of(_: T.Type) -&gt; MemoryLayout&lt;T&gt;.Type {<br>&gt;&gt;       return MemoryLayout&lt;T&gt;.self<br>&gt;&gt;     }<br>&gt;&gt;   }<br>&gt;&gt;<br>&gt;&gt; I think this API would solve the concerns I had about confusability that<br>&gt;&gt; led me to advocate dropping the ability to ask for the size of a value.<br>&gt;&gt; The only way to use it is to pass a type and these two expressions have<br>&gt;&gt; equivalent meaning:<br>&gt;&gt;<br>&gt;&gt;     MemoryLayout&lt;Int&gt;<br>&gt;&gt;     MemoryLayout.of(Int.self)<br>&gt;&gt;<br>&gt;&gt; It also has the benefit of isolating the autoclosure magic to type(of:).<br>&gt;&gt;<br>&gt;&gt; ,----[ Aside ]<br>&gt;&gt; | A slightly cleaner use site is possible with a larger API change:<br>&gt;&gt; |<br>&gt;&gt; |   MemoryLayout(type(of: someExpression)).size<br>&gt;&gt; |<br>&gt;&gt; | Which would involve changing MemoryLayout from an `enum` to<br>&gt;&gt; | a `struct` and adding the following:<br>&gt;&gt; |<br>&gt;&gt; |   extension MemoryLayout {<br>&gt;&gt; |     public init(_: T.Type) {}<br>&gt;&gt; |<br>&gt;&gt; |     public var size: Int { return MemoryLayout.size }<br>&gt;&gt; |     public var stride: Int { return MemoryLayout.stride }<br>&gt;&gt; |     public var alignment: Int { return MemoryLayout.alignment }<br>&gt;&gt; |   }<br>&gt;&gt; |<br>&gt;&gt; | However I am concerned that dropping &quot;.of&quot; at the use site is worth the<br>&gt;&gt; | added API complexity.<br>&gt;&gt; `----<br>&gt;&gt;<br>&gt;&gt; Thoughts?<br>&gt;&gt; --<br>&gt;&gt; -Dave<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>MemoryLayout for a value</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>August  4, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On 4 Aug 2016, at 06:27, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Wed Aug 03 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com &lt;http://xiaodi.wu-at-gmail.com/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Why not just MemoryLayout.init(of instance: T), and drop the autoclosure<br>&gt;&gt; magic altogether?<br>&gt; <br>&gt; My proposal *does* drop the autoclosure magic.  `type(of: x)` is already in<br>&gt; the standard library (replacing `x.dynamicType`). The reasons not to have:<br>&gt; <br>&gt;   MemoryLayout(of: x)<br>&gt; <br>&gt; where x is an arbitrary instance, is that it reads and pronounces the<br>&gt; same as<br>&gt; <br>&gt;   MemoryLayout&lt;X&gt;<br>&gt; <br>&gt; but has different meaning, and even a different type (which results in<br>&gt; additional API complexity—the forwarding vars I showed in the [Aside]<br>&gt; box from my previous post).  Imagine explaining the difference between<br>&gt; these two in that world:<br>&gt; <br>&gt;   MemoryLayout&lt;Int&gt;<br>&gt;   MemoryLayout(of: Int.self)<br>&gt; <br>&gt; The first is a type representing the layout of Int.  The second is an<br>&gt; instance of that type representing the layout of Int&#39;s metatype.<br>&gt; <br></p><p>It’s confusing because metatypes in Swift are pretty confusing in general: Int.self returns Int.Type which is not the same as `type(of: &lt;some Int&gt;)` (that would be Int).<br></p><p>If a novice wants to jump in, they’ll have to know that MemoryLayout(of: Int.self) would return a MemoryLayout&lt;Int.Type&gt;.<br></p><p>&gt;&gt; The classic sizeofValue evaluated its argument, and in Foundation several<br>&gt;&gt; uses of it actually relied on that side effect. While autoclosures are<br>&gt;&gt; quite clever, in general I think the user expectation is that given<br>&gt;&gt; `a(b(c))` both a and b are invoked, side effects and all.<br>&gt;&gt; <br>&gt;&gt; Note that both type(of:) as it&#39;s currently implemented and the old<br>&gt;&gt; dynamicType evaluate its argument/receiver. <br>&gt; <br>&gt; I didn&#39;t realize that, but it&#39;s fine.  I&#39;m attached to the use of<br>&gt; `type(of:)` in this idiom, not to having an autoclosure involved.<br>&gt; <br>&gt;&gt; No one afaik has ever thought that behavior to be anomalous (though I<br>&gt;&gt; bet we&#39;re about to hear some arguments to that effect now).  <br>&gt;&gt; <br>&gt;&gt; On Wed, Aug 3, 2016 at 15:46 Dave Abrahams via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Having seen the effects in the standard library and in other<br>&gt;&gt;&gt; code, I&#39;m concerned that we may have made a mistake in removing<br>&gt;&gt;&gt; `sizeofValue` et al without providing a replacement.  In the standard<br>&gt;&gt;&gt; library, we ended up adding an underscored API that allows<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  MemoryLayout._ofInstance(someExpression).size<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Where someExpression is an autoclosure, and thus not evaluated.  I<br>&gt;&gt;&gt; wanted to bring up the possibility of introducing a replacement as a<br>&gt;&gt;&gt; bufix.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I propose that the way to express the above should be:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  MemoryLayout.of(type(of: someExpression)).size<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; implementable as:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  extension MemoryLayout {<br>&gt;&gt;&gt;    @_transparent<br>&gt;&gt;&gt;    public<br>&gt;&gt;&gt;    static func of(_: T.Type) -&gt; MemoryLayout&lt;T&gt;.Type {<br>&gt;&gt;&gt;      return MemoryLayout&lt;T&gt;.self<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think this API would solve the concerns I had about confusability that<br>&gt;&gt;&gt; led me to advocate dropping the ability to ask for the size of a value.<br>&gt;&gt;&gt; The only way to use it is to pass a type and these two expressions have<br>&gt;&gt;&gt; equivalent meaning:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    MemoryLayout&lt;Int&gt;<br>&gt;&gt;&gt;    MemoryLayout.of(Int.self)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It also has the benefit of isolating the autoclosure magic to type(of:).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ,----[ Aside ]<br>&gt;&gt;&gt; | A slightly cleaner use site is possible with a larger API change:<br>&gt;&gt;&gt; |<br>&gt;&gt;&gt; |   MemoryLayout(type(of: someExpression)).size<br>&gt;&gt;&gt; |<br>&gt;&gt;&gt; | Which would involve changing MemoryLayout from an `enum` to<br>&gt;&gt;&gt; | a `struct` and adding the following:<br>&gt;&gt;&gt; |<br>&gt;&gt;&gt; |   extension MemoryLayout {<br>&gt;&gt;&gt; |     public init(_: T.Type) {}<br>&gt;&gt;&gt; |<br>&gt;&gt;&gt; |     public var size: Int { return MemoryLayout.size }<br>&gt;&gt;&gt; |     public var stride: Int { return MemoryLayout.stride }<br>&gt;&gt;&gt; |     public var alignment: Int { return MemoryLayout.alignment }<br>&gt;&gt;&gt; |   }<br>&gt;&gt;&gt; |<br>&gt;&gt;&gt; | However I am concerned that dropping &quot;.of&quot; at the use site is worth the<br>&gt;&gt;&gt; | added API complexity.<br>&gt;&gt;&gt; `----<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160804/181fc553/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>MemoryLayout for a value</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August  4, 2016 at 02:00:00am</p></header><div class="content"><p>On Thu, Aug 4, 2016 at 2:29 AM, Karl &lt;razielim at gmail.com&gt; wrote:<br></p><p>&gt;<br>&gt; On 4 Aug 2016, at 06:27, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; on Wed Aug 03 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com<br>&gt; &lt;http://xiaodi.wu-at-gmail.com/&gt;&gt; wrote:<br>&gt;<br>&gt; Why not just MemoryLayout.init(of instance: T), and drop the autoclosure<br>&gt; magic altogether?<br>&gt;<br>&gt;<br>&gt; My proposal *does* drop the autoclosure magic.  `type(of: x)` is already in<br>&gt; the standard library (replacing `x.dynamicType`). The reasons not to have:<br>&gt;<br>&gt;   MemoryLayout(of: x)<br>&gt;<br>&gt; where x is an arbitrary instance, is that it reads and pronounces the<br>&gt; same as<br>&gt;<br>&gt;   MemoryLayout&lt;X&gt;<br>&gt;<br>&gt; but has different meaning, and even a different type (which results in<br>&gt; additional API complexity—the forwarding vars I showed in the [Aside]<br>&gt; box from my previous post).  Imagine explaining the difference between<br>&gt; these two in that world:<br>&gt;<br>&gt;   MemoryLayout&lt;Int&gt;<br>&gt;   MemoryLayout(of: Int.self)<br>&gt;<br>&gt; The first is a type representing the layout of Int.  The second is an<br>&gt; instance of that type representing the layout of Int&#39;s metatype.<br>&gt;<br>&gt;<br>&gt; It’s confusing because metatypes in Swift are pretty confusing in general:<br>&gt; Int.self returns Int.Type which is not the same as `type(of: &lt;some Int&gt;)`<br>&gt; (that would be Int).<br>&gt;<br>&gt; If a novice wants to jump in, they’ll have to know that MemoryLayout(of:<br>&gt; Int.self) would return a MemoryLayout&lt;Int.Type&gt;.<br>&gt;<br></p><p>Yes, here, I agree Dave is absolutely right. You and Dave have convinced me<br>that neither `MemoryLayout(of: x)` nor `MemoryLayout.of(x)`, where x is an<br>instance, would be appropriate.<br></p><p>&gt; The classic sizeofValue evaluated its argument, and in Foundation several<br>&gt; uses of it actually relied on that side effect. While autoclosures are<br>&gt; quite clever, in general I think the user expectation is that given<br>&gt; `a(b(c))` both a and b are invoked, side effects and all.<br>&gt;<br>&gt; Note that both type(of:) as it&#39;s currently implemented and the old<br>&gt; dynamicType evaluate its argument/receiver.<br>&gt;<br>&gt;<br>&gt; I didn&#39;t realize that, but it&#39;s fine.  I&#39;m attached to the use of<br>&gt; `type(of:)` in this idiom, not to having an autoclosure involved.<br>&gt;<br>&gt; No one afaik has ever thought that behavior to be anomalous (though I<br>&gt; bet we&#39;re about to hear some arguments to that effect now).<br>&gt;<br>&gt; On Wed, Aug 3, 2016 at 15:46 Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; Having seen the effects in the standard library and in other<br>&gt; code, I&#39;m concerned that we may have made a mistake in removing<br>&gt; `sizeofValue` et al without providing a replacement.  In the standard<br>&gt; library, we ended up adding an underscored API that allows<br>&gt;<br>&gt;  MemoryLayout._ofInstance(someExpression).size<br>&gt;<br>&gt; Where someExpression is an autoclosure, and thus not evaluated.  I<br>&gt; wanted to bring up the possibility of introducing a replacement as a<br>&gt; bufix.<br>&gt;<br>&gt; I propose that the way to express the above should be:<br>&gt;<br>&gt;  MemoryLayout.of(type(of: someExpression)).size<br>&gt;<br>&gt; implementable as:<br>&gt;<br>&gt;  extension MemoryLayout {<br>&gt;    @_transparent<br>&gt;    public<br>&gt;    static func of(_: T.Type) -&gt; MemoryLayout&lt;T&gt;.Type {<br>&gt;      return MemoryLayout&lt;T&gt;.self<br>&gt;    }<br>&gt;  }<br>&gt;<br>&gt; I think this API would solve the concerns I had about confusability that<br>&gt; led me to advocate dropping the ability to ask for the size of a value.<br>&gt; The only way to use it is to pass a type and these two expressions have<br>&gt; equivalent meaning:<br>&gt;<br>&gt;    MemoryLayout&lt;Int&gt;<br>&gt;    MemoryLayout.of(Int.self)<br>&gt;<br>&gt; It also has the benefit of isolating the autoclosure magic to type(of:).<br>&gt;<br>&gt; ,----[ Aside ]<br>&gt; | A slightly cleaner use site is possible with a larger API change:<br>&gt; |<br>&gt; |   MemoryLayout(type(of: someExpression)).size<br>&gt; |<br>&gt; | Which would involve changing MemoryLayout from an `enum` to<br>&gt; | a `struct` and adding the following:<br>&gt; |<br>&gt; |   extension MemoryLayout {<br>&gt; |     public init(_: T.Type) {}<br>&gt; |<br>&gt; |     public var size: Int { return MemoryLayout.size }<br>&gt; |     public var stride: Int { return MemoryLayout.stride }<br>&gt; |     public var alignment: Int { return MemoryLayout.alignment }<br>&gt; |   }<br>&gt; |<br>&gt; | However I am concerned that dropping &quot;.of&quot; at the use site is worth the<br>&gt; | added API complexity.<br>&gt; `----<br>&gt;<br>&gt; Thoughts?<br>&gt; --<br>&gt; -Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; --<br>&gt; -Dave<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160804/0504ff86/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/242e18b243022bcb7573443e06444423?s=50"></div><header><strong>MemoryLayout for a value</strong> from <string>Boris Wang</string> &lt;kona.ming at gmail.com&gt;<p>August  4, 2016 at 10:00:00am</p></header><div class="content"><p>excuse me, does this means there no sizeof(), like C language?<br></p><p>In C:<br></p><p>Struct S {}<br></p><p>Let x= S()<br></p><p>size of(S) == size of(x)<br></p><p><br>Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt;于2016年8月4日<br>周四15:32写道：<br></p><p>&gt; On Thu, Aug 4, 2016 at 2:29 AM, Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On 4 Aug 2016, at 06:27, Dave Abrahams via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; on Wed Aug 03 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com<br>&gt;&gt; &lt;http://xiaodi.wu-at-gmail.com/&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Why not just MemoryLayout.init(of instance: T), and drop the autoclosure<br>&gt;&gt; magic altogether?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; My proposal *does* drop the autoclosure magic.  `type(of: x)` is already<br>&gt;&gt; in<br>&gt;&gt; the standard library (replacing `x.dynamicType`). The reasons not to have:<br>&gt;&gt;<br>&gt;&gt;   MemoryLayout(of: x)<br>&gt;&gt;<br>&gt;&gt; where x is an arbitrary instance, is that it reads and pronounces the<br>&gt;&gt; same as<br>&gt;&gt;<br>&gt;&gt;   MemoryLayout&lt;X&gt;<br>&gt;&gt;<br>&gt;&gt; but has different meaning, and even a different type (which results in<br>&gt;&gt; additional API complexity—the forwarding vars I showed in the [Aside]<br>&gt;&gt; box from my previous post).  Imagine explaining the difference between<br>&gt;&gt; these two in that world:<br>&gt;&gt;<br>&gt;&gt;   MemoryLayout&lt;Int&gt;<br>&gt;&gt;   MemoryLayout(of: Int.self)<br>&gt;&gt;<br>&gt;&gt; The first is a type representing the layout of Int.  The second is an<br>&gt;&gt; instance of that type representing the layout of Int&#39;s metatype.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; It’s confusing because metatypes in Swift are pretty confusing in<br>&gt;&gt; general: Int.self returns Int.Type which is not the same as `type(of: &lt;some<br>&gt;&gt; Int&gt;)` (that would be Int).<br>&gt;&gt;<br>&gt;&gt; If a novice wants to jump in, they’ll have to know that MemoryLayout(of:<br>&gt;&gt; Int.self) would return a MemoryLayout&lt;Int.Type&gt;.<br>&gt;&gt;<br>&gt;<br>&gt; Yes, here, I agree Dave is absolutely right. You and Dave have convinced<br>&gt; me that neither `MemoryLayout(of: x)` nor `MemoryLayout.of(x)`, where x is<br>&gt; an instance, would be appropriate.<br>&gt;<br>&gt;&gt; The classic sizeofValue evaluated its argument, and in Foundation several<br>&gt;&gt; uses of it actually relied on that side effect. While autoclosures are<br>&gt;&gt; quite clever, in general I think the user expectation is that given<br>&gt;&gt; `a(b(c))` both a and b are invoked, side effects and all.<br>&gt;&gt;<br>&gt;&gt; Note that both type(of:) as it&#39;s currently implemented and the old<br>&gt;&gt; dynamicType evaluate its argument/receiver.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I didn&#39;t realize that, but it&#39;s fine.  I&#39;m attached to the use of<br>&gt;&gt; `type(of:)` in this idiom, not to having an autoclosure involved.<br>&gt;&gt;<br>&gt;&gt; No one afaik has ever thought that behavior to be anomalous (though I<br>&gt;&gt; bet we&#39;re about to hear some arguments to that effect now).<br>&gt;&gt;<br>&gt;&gt; On Wed, Aug 3, 2016 at 15:46 Dave Abrahams via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Having seen the effects in the standard library and in other<br>&gt;&gt; code, I&#39;m concerned that we may have made a mistake in removing<br>&gt;&gt; `sizeofValue` et al without providing a replacement.  In the standard<br>&gt;&gt; library, we ended up adding an underscored API that allows<br>&gt;&gt;<br>&gt;&gt;  MemoryLayout._ofInstance(someExpression).size<br>&gt;&gt;<br>&gt;&gt; Where someExpression is an autoclosure, and thus not evaluated.  I<br>&gt;&gt; wanted to bring up the possibility of introducing a replacement as a<br>&gt;&gt; bufix.<br>&gt;&gt;<br>&gt;&gt; I propose that the way to express the above should be:<br>&gt;&gt;<br>&gt;&gt;  MemoryLayout.of(type(of: someExpression)).size<br>&gt;&gt;<br>&gt;&gt; implementable as:<br>&gt;&gt;<br>&gt;&gt;  extension MemoryLayout {<br>&gt;&gt;    @_transparent<br>&gt;&gt;    public<br>&gt;&gt;    static func of(_: T.Type) -&gt; MemoryLayout&lt;T&gt;.Type {<br>&gt;&gt;      return MemoryLayout&lt;T&gt;.self<br>&gt;&gt;    }<br>&gt;&gt;  }<br>&gt;&gt;<br>&gt;&gt; I think this API would solve the concerns I had about confusability that<br>&gt;&gt; led me to advocate dropping the ability to ask for the size of a value.<br>&gt;&gt; The only way to use it is to pass a type and these two expressions have<br>&gt;&gt; equivalent meaning:<br>&gt;&gt;<br>&gt;&gt;    MemoryLayout&lt;Int&gt;<br>&gt;&gt;    MemoryLayout.of(Int.self)<br>&gt;&gt;<br>&gt;&gt; It also has the benefit of isolating the autoclosure magic to type(of:).<br>&gt;&gt;<br>&gt;&gt; ,----[ Aside ]<br>&gt;&gt; | A slightly cleaner use site is possible with a larger API change:<br>&gt;&gt; |<br>&gt;&gt; |   MemoryLayout(type(of: someExpression)).size<br>&gt;&gt; |<br>&gt;&gt; | Which would involve changing MemoryLayout from an `enum` to<br>&gt;&gt; | a `struct` and adding the following:<br>&gt;&gt; |<br>&gt;&gt; |   extension MemoryLayout {<br>&gt;&gt; |     public init(_: T.Type) {}<br>&gt;&gt; |<br>&gt;&gt; |     public var size: Int { return MemoryLayout.size }<br>&gt;&gt; |     public var stride: Int { return MemoryLayout.stride }<br>&gt;&gt; |     public var alignment: Int { return MemoryLayout.alignment }<br>&gt;&gt; |   }<br>&gt;&gt; |<br>&gt;&gt; | However I am concerned that dropping &quot;.of&quot; at the use site is worth the<br>&gt;&gt; | added API complexity.<br>&gt;&gt; `----<br>&gt;&gt;<br>&gt;&gt; Thoughts?<br>&gt;&gt; --<br>&gt;&gt; -Dave<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; -Dave<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160804/dd49df78/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>MemoryLayout for a value</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>August  4, 2016 at 08:00:00pm</p></header><div class="content"><p>2016-08-04 10:31 GMT+03:00 Xiaodi Wu via swift-evolution &lt;<br>swift-evolution at swift.org&gt;:<br></p><p>&gt; On Thu, Aug 4, 2016 at 2:29 AM, Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; It’s confusing because metatypes in Swift are pretty confusing in<br>&gt;&gt; general: Int.self returns Int.Type which is not the same as `type(of: &lt;some<br>&gt;&gt; Int&gt;)` (that would be Int).<br>&gt;&gt;<br>&gt;&gt; If a novice wants to jump in, they’ll have to know that MemoryLayout(of:<br>&gt;&gt; Int.self) would return a MemoryLayout&lt;Int.Type&gt;.<br>&gt;&gt;<br>&gt;<br>&gt; Yes, here, I agree Dave is absolutely right. You and Dave have convinced<br>&gt; me that neither `MemoryLayout(of: x)` nor `MemoryLayout.of(x)`, where x is<br>&gt; an instance, would be appropriate.<br>&gt;<br></p><p>Two weeks ago Adrian and I suggested adding dynamic &#39;size&#39;, &#39;stride&#39;,<br>&#39;alignment&#39; to Mirror, which definition would look like:<br></p><p>public struct Mirror {<br>    internal metatype_: Any.Type<br></p><p>    public init&lt;T&gt;(_: T.Type)<br></p><p>    public var size: Int { get }<br>    public var stride: Int { get }<br>    public var align: Int { get }<br></p><p>    // ...<br>}<br></p><p>There are some problems with it right now, but I do believe that reflection<br>API is where dynamic `size`, `stride`, `alignment` belong.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160804/ae4c1f23/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>MemoryLayout for a value</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>August  4, 2016 at 11:00:00am</p></header><div class="content"><p>on Thu Aug 04 2016, Anton Zhilin &lt;antonyzhilin-AT-gmail.com&gt; wrote:<br></p><p>&gt; 2016-08-04 10:31 GMT+03:00 Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt;<br>&gt;&gt; On Thu, Aug 4, 2016 at 2:29 AM, Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; It’s confusing because metatypes in Swift are pretty confusing in<br>&gt;&gt;&gt; general: Int.self returns Int.Type which is not the same as `type(of: &lt;some<br>&gt;&gt;&gt; Int&gt;)` (that would be Int).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If a novice wants to jump in, they’ll have to know that MemoryLayout(of:<br>&gt;&gt;&gt; Int.self) would return a MemoryLayout&lt;Int.Type&gt;.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Yes, here, I agree Dave is absolutely right. You and Dave have convinced<br>&gt;&gt; me that neither `MemoryLayout(of: x)` nor `MemoryLayout.of(x)`, where x is<br>&gt;&gt; an instance, would be appropriate.<br>&gt;&gt;<br>&gt;<br>&gt; Two weeks ago Adrian and I suggested adding dynamic &#39;size&#39;, &#39;stride&#39;,<br>&gt; &#39;alignment&#39; to Mirror, which definition would look like:<br>&gt;<br>&gt; public struct Mirror {<br>&gt;     internal metatype_: Any.Type<br>&gt;<br>&gt;     public init&lt;T&gt;(_: T.Type)<br>&gt;<br>&gt;     public var size: Int { get }<br>&gt;     public var stride: Int { get }<br>&gt;     public var align: Int { get }<br>&gt;<br>&gt;     // ...<br>&gt; }<br>&gt;<br>&gt; There are some problems with it right now, but I do believe that reflection<br>&gt; API is where dynamic `size`, `stride`, `alignment` belong.<br></p><p>I see your point, but that would unfortunately be an unacceptably<br>expensive way to get that information.  Constructing a mirror is a<br>nontrivial bit of work.<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>MemoryLayout for a value</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>August  4, 2016 at 09:00:00pm</p></header><div class="content"><p>2016-08-04 21:31 GMT+03:00 Dave Abrahams &lt;dabrahams at apple.com&gt;:<br></p><p>&gt;<br>&gt; on Thu Aug 04 2016, Anton Zhilin &lt;antonyzhilin-AT-gmail.com&gt; wrote:<br>&gt; &gt; Two weeks ago Adrian and I suggested adding dynamic &#39;size&#39;, &#39;stride&#39;,<br>&gt; &gt; &#39;alignment&#39; to Mirror, which definition would look like:<br>&gt; &gt;<br>&gt; &gt; public struct ReflectionWrapper {  // fixed!<br>&gt; &gt;     internal metatype_: Any.Type<br>&gt; &gt;<br>&gt; &gt;     public init&lt;T&gt;(_: T.Type)<br>&gt; &gt;<br>&gt; &gt;     public var size: Int { get }<br>&gt; &gt;     public var stride: Int { get }<br>&gt; &gt;     public var align: Int { get }<br>&gt; &gt;<br>&gt; &gt;     // ...<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; There are some problems with it right now, but I do believe that<br>&gt; reflection<br>&gt; &gt; API is where dynamic `size`, `stride`, `alignment` belong.<br>&gt;<br>&gt; I see your point, but that would unfortunately be an unacceptably<br>&gt; expensive way to get that information.  Constructing a mirror is a<br>&gt; nontrivial bit of work.<br></p><p><br>I don&#39;t mean current heavyweight Mirror. Call that type ReflectionWrapper,<br>if you want. It would only contain &#39;Any.Type&#39; stored property.<br>Largest of &#39;problems&#39; that I meant is that reflection is postponed, and my<br>type would look odd without full reflection capabilities (only with &#39;size&#39;<br>and friends).<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160804/ad12219e/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>MemoryLayout for a value</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>August  4, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Aug 4, 2016, at 13:31, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; on Thu Aug 04 2016, Anton Zhilin &lt;antonyzhilin-AT-gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; 2016-08-04 10:31 GMT+03:00 Xiaodi Wu via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Thu, Aug 4, 2016 at 2:29 AM, Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It’s confusing because metatypes in Swift are pretty confusing in<br>&gt;&gt;&gt;&gt; general: Int.self returns Int.Type which is not the same as `type(of: &lt;some<br>&gt;&gt;&gt;&gt; Int&gt;)` (that would be Int).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If a novice wants to jump in, they’ll have to know that MemoryLayout(of:<br>&gt;&gt;&gt;&gt; Int.self) would return a MemoryLayout&lt;Int.Type&gt;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, here, I agree Dave is absolutely right. You and Dave have convinced<br>&gt;&gt;&gt; me that neither `MemoryLayout(of: x)` nor `MemoryLayout.of(x)`, where x is<br>&gt;&gt;&gt; an instance, would be appropriate.<br>&gt;&gt; <br>&gt;&gt; Two weeks ago Adrian and I suggested adding dynamic &#39;size&#39;, &#39;stride&#39;,<br>&gt;&gt; &#39;alignment&#39; to Mirror, which definition would look like:<br>&gt;&gt; <br>&gt;&gt; public struct Mirror {<br>&gt;&gt;    internal metatype_: Any.Type<br>&gt;&gt; <br>&gt;&gt;    public init&lt;T&gt;(_: T.Type)<br>&gt;&gt; <br>&gt;&gt;    public var size: Int { get }<br>&gt;&gt;    public var stride: Int { get }<br>&gt;&gt;    public var align: Int { get }<br>&gt;&gt; <br>&gt;&gt;    // ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; There are some problems with it right now, but I do believe that reflection<br>&gt;&gt; API is where dynamic `size`, `stride`, `alignment` belong.<br>&gt; <br>&gt; I see your point, but that would unfortunately be an unacceptably<br>&gt; expensive way to get that information.  Constructing a mirror is a<br>&gt; nontrivial bit of work.<br></p><p>Two quick questions:<br>1) Can the expensive bits of mirrors be done lazily?<br>2) IIRC, the reflection API is supposed to be reworked for Swift 4. With that in mind, are mirrors likely to remain too be expensive to construct for this approach?<br></p><p>- Dave Sweeris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>MemoryLayout for a value</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>August  4, 2016 at 11:00:00am</p></header><div class="content"><p>on Thu Aug 04 2016, David Sweeris &lt;davesweeris-AT-mac.com&gt; wrote:<br></p><p>&gt;&gt; On Aug 4, 2016, at 13:31, Dave Abrahams via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; on Thu Aug 04 2016, Anton Zhilin &lt;antonyzhilin-AT-gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2016-08-04 10:31 GMT+03:00 Xiaodi Wu via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Thu, Aug 4, 2016 at 2:29 AM, Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It’s confusing because metatypes in Swift are pretty confusing in<br>&gt;&gt;&gt;&gt;&gt; general: Int.self returns Int.Type which is not the same as `type(of: &lt;some<br>&gt;&gt;&gt;&gt;&gt; Int&gt;)` (that would be Int).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If a novice wants to jump in, they’ll have to know that MemoryLayout(of:<br>&gt;&gt;&gt;&gt;&gt; Int.self) would return a MemoryLayout&lt;Int.Type&gt;.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, here, I agree Dave is absolutely right. You and Dave have convinced<br>&gt;&gt;&gt;&gt; me that neither `MemoryLayout(of: x)` nor `MemoryLayout.of(x)`, where x is<br>&gt;&gt;&gt;&gt; an instance, would be appropriate.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Two weeks ago Adrian and I suggested adding dynamic &#39;size&#39;, &#39;stride&#39;,<br>&gt;&gt;&gt; &#39;alignment&#39; to Mirror, which definition would look like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public struct Mirror {<br>&gt;&gt;&gt;    internal metatype_: Any.Type<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    public init&lt;T&gt;(_: T.Type)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    public var size: Int { get }<br>&gt;&gt;&gt;    public var stride: Int { get }<br>&gt;&gt;&gt;    public var align: Int { get }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    // ...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are some problems with it right now, but I do believe that reflection<br>&gt;&gt;&gt; API is where dynamic `size`, `stride`, `alignment` belong.<br>&gt;&gt; <br>&gt;&gt; I see your point, but that would unfortunately be an unacceptably<br>&gt;&gt; expensive way to get that information.  Constructing a mirror is a<br>&gt;&gt; nontrivial bit of work.<br>&gt;<br>&gt; Two quick questions:<br>&gt; 1) Can the expensive bits of mirrors be done lazily?<br>&gt; 2) IIRC, the reflection API is supposed to be reworked for Swift<br>&gt; 4. With that in mind, are mirrors likely to remain too be expensive to<br>&gt; construct for this approach?<br></p><p>I don&#39;t know.  IMO none of these questions can be answered in time to<br>solve the cited problem for Swift 3.<br></p><p>-- <br>-Dave<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>MemoryLayout for a value</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>August  4, 2016 at 09:00:00pm</p></header><div class="content"><p>2016-08-04 21:42 GMT+03:00 David Sweeris &lt;davesweeris at mac.com&gt;:<br>&gt;<br>&gt; Two quick questions:<br>&gt; 1) Can the expensive bits of mirrors be done lazily?<br>&gt; 2) IIRC, the reflection API is supposed to be reworked for Swift 4. With<br>&gt; that in mind, are mirrors likely to remain too be expensive to construct<br>&gt; for this approach?<br>&gt;<br>&gt; - Dave Sweeris<br></p><p><br>First is not really a problem, but we need reflection in place for my<br>suggestion. If we are going for a &quot;quick fix&quot;, then we can&#39;t wait for full<br>API designed. I have to agree with Dave on that matter.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160804/8c378310/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>MemoryLayout for a value</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August  4, 2016 at 02:00:00am</p></header><div class="content"><p>On Wed, Aug 3, 2016 at 11:27 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; on Wed Aug 03 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt;<br>&gt; &gt; Why not just MemoryLayout.init(of instance: T), and drop the autoclosure<br>&gt; &gt; magic altogether?<br>&gt;<br>&gt; My proposal *does* drop the autoclosure magic.  `type(of: x)` is already in<br>&gt; the standard library (replacing `x.dynamicType`). The reasons not to have:<br>&gt;<br>&gt;    MemoryLayout(of: x)<br>&gt;<br>&gt; where x is an arbitrary instance, is that it reads and pronounces the<br>&gt; same as<br>&gt;<br>&gt;    MemoryLayout&lt;X&gt;<br>&gt;<br>&gt; but has different meaning, and even a different type (which results in<br>&gt; additional API complexity—the forwarding vars I showed in the [Aside]<br>&gt; box from my previous post).  Imagine explaining the difference between<br>&gt; these two in that world:<br>&gt;<br>&gt;    MemoryLayout&lt;Int&gt;<br>&gt;    MemoryLayout(of: Int.self)<br>&gt;<br>&gt; The first is a type representing the layout of Int.  The second is an<br>&gt; instance of that type representing the layout of Int&#39;s metatype.<br>&gt;<br>&gt; &gt; The classic sizeofValue evaluated its argument, and in Foundation several<br>&gt; &gt; uses of it actually relied on that side effect. While autoclosures are<br>&gt; &gt; quite clever, in general I think the user expectation is that given<br>&gt; &gt; `a(b(c))` both a and b are invoked, side effects and all.<br>&gt; &gt;<br>&gt; &gt; Note that both type(of:) as it&#39;s currently implemented and the old<br>&gt; &gt; dynamicType evaluate its argument/receiver.<br>&gt;<br>&gt; I didn&#39;t realize that, but it&#39;s fine.  I&#39;m attached to the use of<br>&gt; `type(of:)` in this idiom, not to having an autoclosure involved.<br>&gt;<br></p><p>Your proposed `.of(type(of: x)).size` differs from the original<br>`sizeofValue()` in at least one other way--is this in fact *why* you&#39;re<br>proposing the change? In the classic syntax:<br></p><p>```<br>protocol P { }<br>print(sizeof(P.self)) // 40<br></p><p>struct S : P {<br>  let x = 2<br>}<br>print(sizeof(S.self)) // 8<br></p><p>var a: P = S()<br>print(a.dynamicType) // S<br>print(sizeofValue(a)) // 40<br>```<br></p><p>&gt; No one afaik has ever thought that behavior to be anomalous (though I<br>&gt; &gt; bet we&#39;re about to hear some arguments to that effect now).<br>&gt; &gt;<br>&gt; &gt; On Wed, Aug 3, 2016 at 15:46 Dave Abrahams via swift-evolution &lt;<br>&gt; &gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Having seen the effects in the standard library and in other<br>&gt; &gt;&gt; code, I&#39;m concerned that we may have made a mistake in removing<br>&gt; &gt;&gt; `sizeofValue` et al without providing a replacement.  In the standard<br>&gt; &gt;&gt; library, we ended up adding an underscored API that allows<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;   MemoryLayout._ofInstance(someExpression).size<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Where someExpression is an autoclosure, and thus not evaluated.  I<br>&gt; &gt;&gt; wanted to bring up the possibility of introducing a replacement as a<br>&gt; &gt;&gt; bufix.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I propose that the way to express the above should be:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;   MemoryLayout.of(type(of: someExpression)).size<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; implementable as:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;   extension MemoryLayout {<br>&gt; &gt;&gt;     @_transparent<br>&gt; &gt;&gt;     public<br>&gt; &gt;&gt;     static func of(_: T.Type) -&gt; MemoryLayout&lt;T&gt;.Type {<br>&gt; &gt;&gt;       return MemoryLayout&lt;T&gt;.self<br>&gt; &gt;&gt;     }<br>&gt; &gt;&gt;   }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I think this API would solve the concerns I had about confusability that<br>&gt; &gt;&gt; led me to advocate dropping the ability to ask for the size of a value.<br>&gt; &gt;&gt; The only way to use it is to pass a type and these two expressions have<br>&gt; &gt;&gt; equivalent meaning:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;     MemoryLayout&lt;Int&gt;<br>&gt; &gt;&gt;     MemoryLayout.of(Int.self)<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; It also has the benefit of isolating the autoclosure magic to type(of:).<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; ,----[ Aside ]<br>&gt; &gt;&gt; | A slightly cleaner use site is possible with a larger API change:<br>&gt; &gt;&gt; |<br>&gt; &gt;&gt; |   MemoryLayout(type(of: someExpression)).size<br>&gt; &gt;&gt; |<br>&gt; &gt;&gt; | Which would involve changing MemoryLayout from an `enum` to<br>&gt; &gt;&gt; | a `struct` and adding the following:<br>&gt; &gt;&gt; |<br>&gt; &gt;&gt; |   extension MemoryLayout {<br>&gt; &gt;&gt; |     public init(_: T.Type) {}<br>&gt; &gt;&gt; |<br>&gt; &gt;&gt; |     public var size: Int { return MemoryLayout.size }<br>&gt; &gt;&gt; |     public var stride: Int { return MemoryLayout.stride }<br>&gt; &gt;&gt; |     public var alignment: Int { return MemoryLayout.alignment }<br>&gt; &gt;&gt; |   }<br>&gt; &gt;&gt; |<br>&gt; &gt;&gt; | However I am concerned that dropping &quot;.of&quot; at the use site is worth<br>&gt; the<br>&gt; &gt;&gt; | added API complexity.<br>&gt; &gt;&gt; `----<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Thoughts?<br>&gt; &gt;&gt; --<br>&gt; &gt;&gt; -Dave<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;<br>&gt;<br>&gt; --<br>&gt; -Dave<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160804/05fef64b/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>MemoryLayout for a value</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>August  3, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Aug 3, 2016, at 2:43 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Having seen the effects in the standard library and in other<br>&gt; code, I&#39;m concerned that we may have made a mistake in removing<br>&gt; `sizeofValue` et al without providing a replacement.  In the standard<br>&gt; library, we ended up adding an underscored API that allows<br>&gt; <br>&gt;  MemoryLayout._ofInstance(someExpression).size<br>&gt; <br>&gt; Where someExpression is an autoclosure, and thus not evaluated.  I<br>&gt; wanted to bring up the possibility of introducing a replacement as a<br>&gt; bufix.<br>&gt; <br>&gt; I propose that the way to express the above should be:<br>&gt; <br>&gt;  MemoryLayout.of(type(of: someExpression)).size<br>&gt; <br>&gt; implementable as:<br>&gt; <br>&gt;  extension MemoryLayout {<br>&gt;    @_transparent<br>&gt;    public<br>&gt;    static func of(_: T.Type) -&gt; MemoryLayout&lt;T&gt;.Type {<br>&gt;      return MemoryLayout&lt;T&gt;.self<br>&gt;    }<br>&gt;  }<br>&gt; <br>&gt; I think this API would solve the concerns I had about confusability that<br>&gt; led me to advocate dropping the ability to ask for the size of a value.<br>&gt; The only way to use it is to pass a type and these two expressions have<br>&gt; equivalent meaning:<br>&gt; <br>&gt;    MemoryLayout&lt;Int&gt;<br>&gt;    MemoryLayout.of(Int.self)<br>&gt; <br>&gt; It also has the benefit of isolating the autoclosure magic to type(of:).<br>&gt; <br>&gt; ,----[ Aside ]<br>&gt; | A slightly cleaner use site is possible with a larger API change:<br>&gt; | <br>&gt; |   MemoryLayout(type(of: someExpression)).size<br>&gt; | <br>&gt; | Which would involve changing MemoryLayout from an `enum` to<br>&gt; | a `struct` and adding the following:<br>&gt; | <br>&gt; |   extension MemoryLayout {<br>&gt; |     public init(_: T.Type) {}<br>&gt; | <br>&gt; |     public var size: Int { return MemoryLayout.size }<br>&gt; |     public var stride: Int { return MemoryLayout.stride }<br>&gt; |     public var alignment: Int { return MemoryLayout.alignment }<br>&gt; |   }<br>&gt; | <br>&gt; | However I am concerned that dropping &quot;.of&quot; at the use site is worth the<br>&gt; | added API complexity.<br>&gt; `----<br>&gt; <br>&gt; Thoughts?<br>&gt; -- <br>&gt; -Dave<br></p><p><br>I don&#39;t think using &quot;of&quot; is a great burden.<br></p><p>-- E<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>MemoryLayout for a value</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August  3, 2016 at 09:00:00pm</p></header><div class="content"><p>On Wed, Aug 3, 2016 at 8:47 PM, Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; On Aug 3, 2016, at 2:43 PM, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Having seen the effects in the standard library and in other<br>&gt; &gt; code, I&#39;m concerned that we may have made a mistake in removing<br>&gt; &gt; `sizeofValue` et al without providing a replacement.  In the standard<br>&gt; &gt; library, we ended up adding an underscored API that allows<br>&gt; &gt;<br>&gt; &gt;  MemoryLayout._ofInstance(someExpression).size<br>&gt; &gt;<br>&gt; &gt; Where someExpression is an autoclosure, and thus not evaluated.  I<br>&gt; &gt; wanted to bring up the possibility of introducing a replacement as a<br>&gt; &gt; bufix.<br>&gt; &gt;<br>&gt; &gt; I propose that the way to express the above should be:<br>&gt; &gt;<br>&gt; &gt;  MemoryLayout.of(type(of: someExpression)).size<br>&gt; &gt;<br>&gt; &gt; implementable as:<br>&gt; &gt;<br>&gt; &gt;  extension MemoryLayout {<br>&gt; &gt;    @_transparent<br>&gt; &gt;    public<br>&gt; &gt;    static func of(_: T.Type) -&gt; MemoryLayout&lt;T&gt;.Type {<br>&gt; &gt;      return MemoryLayout&lt;T&gt;.self<br>&gt; &gt;    }<br>&gt; &gt;  }<br>&gt; &gt;<br>&gt; &gt; I think this API would solve the concerns I had about confusability that<br>&gt; &gt; led me to advocate dropping the ability to ask for the size of a value.<br>&gt; &gt; The only way to use it is to pass a type and these two expressions have<br>&gt; &gt; equivalent meaning:<br>&gt; &gt;<br>&gt; &gt;    MemoryLayout&lt;Int&gt;<br>&gt; &gt;    MemoryLayout.of(Int.self)<br>&gt; &gt;<br>&gt; &gt; It also has the benefit of isolating the autoclosure magic to type(of:).<br>&gt; &gt;<br>&gt; &gt; ,----[ Aside ]<br>&gt; &gt; | A slightly cleaner use site is possible with a larger API change:<br>&gt; &gt; |<br>&gt; &gt; |   MemoryLayout(type(of: someExpression)).size<br>&gt; &gt; |<br>&gt; &gt; | Which would involve changing MemoryLayout from an `enum` to<br>&gt; &gt; | a `struct` and adding the following:<br>&gt; &gt; |<br>&gt; &gt; |   extension MemoryLayout {<br>&gt; &gt; |     public init(_: T.Type) {}<br>&gt; &gt; |<br>&gt; &gt; |     public var size: Int { return MemoryLayout.size }<br>&gt; &gt; |     public var stride: Int { return MemoryLayout.stride }<br>&gt; &gt; |     public var alignment: Int { return MemoryLayout.alignment }<br>&gt; &gt; |   }<br>&gt; &gt; |<br>&gt; &gt; | However I am concerned that dropping &quot;.of&quot; at the use site is worth the<br>&gt; &gt; | added API complexity.<br>&gt; &gt; `----<br>&gt; &gt;<br>&gt; &gt; Thoughts?<br>&gt; &gt; --<br>&gt; &gt; -Dave<br>&gt;<br>&gt;<br>&gt; I don&#39;t think using &quot;of&quot; is a great burden.<br>&gt;<br></p><p>Agreed, but I do think &quot;memory layout of type of my value, size&quot; is a<br>mouthful compared to &quot;size of value&quot;. Moreover, something doesn&#39;t sit right<br>with me that MemoryLayout&lt;T&gt; and MemoryLayout.of(T.self) would be one and<br>the same thing.<br></p><p>Could I suggest an alternative? It&#39;s conservative in that it mimics the<br>relationships we had before the proposal was implemented and also maintains<br>the simplicity of the caseless enum:<br></p><p>```<br>extension MemoryLayout {<br>  static func size(ofValue _: T) -&gt; Int { return MemoryLayout.size }<br>  // etc.<br>}<br>```<br></p><p><br>&gt; -- E<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160803/c18ec95e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>MemoryLayout for a value</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>August  3, 2016 at 09:00:00pm</p></header><div class="content"><p>on Wed Aug 03 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br></p><p>&gt; Agreed, but I do think &quot;memory layout of type of my value, size&quot; is a<br>&gt; mouthful compared to &quot;size of value&quot;. <br></p><p>It is, but it would avoid confusion.<br></p><p>&gt; Moreover, something doesn&#39;t sit right with me that MemoryLayout&lt;T&gt; and<br>&gt; MemoryLayout.of(T.self) would be one and the same thing.<br></p><p>As far as I&#39;m concerned, that&#39;s a feature, not a bug.  Unless you can<br>describe why it should be different, “it doesn&#39;t sit right” is not a<br>helpful argument.<br></p><p>&gt; Could I suggest an alternative? It&#39;s conservative in that it mimics the<br>&gt; relationships we had before the proposal was implemented and also maintains<br>&gt; the simplicity of the caseless enum:<br>&gt;<br>&gt; ```<br>&gt; extension MemoryLayout {<br>&gt;   static func size(ofValue _: T) -&gt; Int { return MemoryLayout.size }<br>&gt;   // etc.<br>&gt; }<br>&gt; ```<br></p><p>That introduces even more potential for confusion than adding forwarding<br>vars to instances does.  Now you&#39;re talking about “overloading” a static<br>property with a static method having the same base name.<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>MemoryLayout for a value</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August  4, 2016 at 02:00:00am</p></header><div class="content"><p>On Wed, Aug 3, 2016 at 11:32 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; on Wed Aug 03 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt;<br>&gt; &gt; Agreed, but I do think &quot;memory layout of type of my value, size&quot; is a<br>&gt; &gt; mouthful compared to &quot;size of value&quot;.<br>&gt;<br>&gt; It is, but it would avoid confusion.<br>&gt;<br>&gt; &gt; Moreover, something doesn&#39;t sit right with me that MemoryLayout&lt;T&gt; and<br>&gt; &gt; MemoryLayout.of(T.self) would be one and the same thing.<br>&gt;<br>&gt; As far as I&#39;m concerned, that&#39;s a feature, not a bug.  Unless you can<br>&gt; describe why it should be different, “it doesn&#39;t sit right” is not a<br>&gt; helpful argument.<br>&gt;<br></p><p>Originally, I&#39;d actually half-way typed out a fuller argument, then deleted<br>it, assuming most would find it to be uninteresting due to obviousness.<br>Let&#39;s see:<br></p><p>Unless I&#39;m mistaken, every place where one might write `MemoryLayout&lt;T&gt;`<br>can be replaced with `MemoryLayout.of(T.self)`. (Yes, I understand that<br>there are places where substituting in the other direction would be<br>unsatisfactory, hence this follow-up thread.) However, I understand it to<br>be a bug, not a feature, to have two different ways of spelling the same<br>thing, because it necessarily brings confusion as to why there must be two<br>of them, and I therefore consider this proposed design to be suboptimal.<br>You titled this thread &quot;MemoryLayout for a value&quot;: I agree that that&#39;s what<br>we need. It ought to be possible to provide facilities for exactly that<br>*without* also providing an entirely duplicative way of spelling<br>MemoryLayout for a type.<br></p><p>&gt; Could I suggest an alternative? It&#39;s conservative in that it mimics the<br>&gt; &gt; relationships we had before the proposal was implemented and also<br>&gt; maintains<br>&gt; &gt; the simplicity of the caseless enum:<br>&gt; &gt;<br>&gt; &gt; ```<br>&gt; &gt; extension MemoryLayout {<br>&gt; &gt;   static func size(ofValue _: T) -&gt; Int { return MemoryLayout.size }<br>&gt; &gt;   // etc.<br>&gt; &gt; }<br>&gt; &gt; ```<br>&gt;<br>&gt; That introduces even more potential for confusion than adding forwarding<br>&gt; vars to instances does.  Now you&#39;re talking about “overloading” a static<br>&gt; property with a static method having the same base name.<br>&gt;<br></p><p>IMO, here&#39;s where it&#39;s a feature, not a bug. I propose `size(ofValue:)` and<br>`size` because they *are* related, just like how `first(where:)` and<br>`first` are related for a Collection. Moreover, the whole thing reads<br>exactly as it should (and, not by accident, nearly identically to this<br>thread&#39;s subject line): &quot;memory layout size of value x&quot;. What is the source<br>of confusion that you think would arise from this pseudo-overloading, and<br>why are you emphasizing the fact that both would be static<br>properties/methods (is it less confusing when it&#39;s not static)?<br></p><p><br>&gt;<br>&gt; --<br>&gt; -Dave<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160804/2e720477/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>MemoryLayout for a value</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>August  4, 2016 at 11:00:00am</p></header><div class="content"><p>on Thu Aug 04 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br></p><p>&gt; On Wed, Aug 3, 2016 at 11:32 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; on Wed Aug 03 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; &gt; Agreed, but I do think &quot;memory layout of type of my value, size&quot; is a<br>&gt;&gt; &gt; mouthful compared to &quot;size of value&quot;.<br>&gt;&gt;<br>&gt;&gt; It is, but it would avoid confusion.<br>&gt;&gt;<br>&gt;&gt; &gt; Moreover, something doesn&#39;t sit right with me that MemoryLayout&lt;T&gt; and<br>&gt;&gt; &gt; MemoryLayout.of(T.self) would be one and the same thing.<br>&gt;&gt;<br>&gt;&gt; As far as I&#39;m concerned, that&#39;s a feature, not a bug.  Unless you can<br>&gt;&gt; describe why it should be different, “it doesn&#39;t sit right” is not a<br>&gt;&gt; helpful argument.<br>&gt;&gt;<br>&gt;<br>&gt; Originally, I&#39;d actually half-way typed out a fuller argument, then deleted<br>&gt; it, assuming most would find it to be uninteresting due to obviousness.<br>&gt; Let&#39;s see:<br>&gt;<br>&gt; Unless I&#39;m mistaken, every place where one might write `MemoryLayout&lt;T&gt;`<br>&gt; can be replaced with `MemoryLayout.of(T.self)`. <br></p><p>In my proposal, yes.<br></p><p>&gt; (Yes, I understand that there are places where substituting in the<br>&gt; other direction would be unsatisfactory, hence this follow-up thread.)<br>&gt; However, I understand it to be a bug, not a feature, to have two<br>&gt; different ways of spelling the same thing, because it necessarily<br>&gt; brings confusion as to why there must be two of them, and I therefore<br>&gt; consider this proposed design to be suboptimal.  You titled this<br>&gt; thread &quot;MemoryLayout for a value&quot;: I agree that that&#39;s what we<br>&gt; need. It ought to be possible to provide facilities for exactly that<br>&gt; *without* also providing an entirely duplicative way of spelling<br>&gt; MemoryLayout for a type.<br></p><p>Fair enough.<br></p><p>&gt;&gt; &gt; Could I suggest an alternative? It&#39;s conservative in that it mimics<br>&gt;&gt; &gt; the relationships we had before the proposal was implemented and<br>&gt;&gt; &gt; also maintains the simplicity of the caseless enum:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; ```<br>&gt;&gt; &gt; extension MemoryLayout {<br>&gt;&gt; &gt;   static func size(ofValue _: T) -&gt; Int { return MemoryLayout.size }<br>&gt;&gt; &gt;   // etc.<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt; ```<br>&gt;&gt;<br>&gt;&gt; That introduces even more potential for confusion than adding forwarding<br>&gt;&gt; vars to instances does.  Now you&#39;re talking about “overloading” a static<br>&gt;&gt; property with a static method having the same base name.<br>&gt;<br>&gt; IMO, here&#39;s where it&#39;s a feature, not a bug. I propose `size(ofValue:)` and<br>&gt; `size` because they *are* related, just like how `first(where:)` and<br>&gt; `first` are related for a Collection. <br></p><p>GOod point.<br></p><p>&gt; Moreover, the whole thing reads exactly as it should (and, not by<br>&gt; accident, nearly identically to this thread&#39;s subject line): &quot;memory<br>&gt; layout size of value x&quot;. What is the source of confusion that you<br>&gt; think would arise from this pseudo-overloading, and why are you<br>&gt; emphasizing the fact that both would be static properties/methods (is<br>&gt; it less confusing when it&#39;s not static)?<br></p><p>It&#39;s less confusing when only one of them is static and the other isn&#39;t.<br></p><p>But you&#39;ve made some excellent points here.  Mulling...<br></p><p>-- <br>-Dave<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>MemoryLayout for a value</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>August  4, 2016 at 03:00:00pm</p></header><div class="content"><p>On Wed, Aug 3, 2016 at 7:28 PM, Xiaodi Wu via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Could I suggest an alternative? It&#39;s conservative in that it mimics the<br>&gt; relationships we had before the proposal was implemented and also maintains<br>&gt; the simplicity of the caseless enum:<br>&gt;<br>&gt; ```<br>&gt; extension MemoryLayout {<br>&gt;   static func size(ofValue _: T) -&gt; Int { return MemoryLayout.size }<br>&gt;   // etc.<br>&gt; }<br>&gt; ```<br></p><p>I like this API.  I think given all the alternatives that we explored,<br>it is better than those.  I also think that it nicely avoids the<br>following issue with the proposed MemoryLayout.of(type(of:<br>someExpression)).size syntax.<br></p><p>Imagine that you have a value whose static type differs from the<br>dynamic type.  For example, a protocol existential:<br></p><p>protocol P {}<br>extension Int : P {}<br>var x: P = 10<br></p><p>The question is, what does MemoryLayout.of(type(of: x)).size compute,<br>size of the existential box, or the size of an Int instance?  The<br>semantics of &#39;type(of:)&#39; are &quot;return the dynamic type&quot;, so the<br>straightforward conclusion is that MemoryLayout.of(type(of: x)).size<br>returns the size of the dynamic type instance, of Int.<br></p><p>What actually happens is that &#39;type(of: x)&#39; returns a dynamic value of<br>&#39;Int.self&#39;, statically typed as &#39;P.Type&#39;.  So P gets deduced for the<br>generic parameter of MemoryLayout, and MemoryLayout.of(type(of:<br>x)).size returns the size of the protocol box.<br></p><p>I think due to this complex interaction, using type(of:) might lead to<br>confusing code, and thus I like Xiaodi&#39;s approach better.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>MemoryLayout for a value</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>August  4, 2016 at 04:00:00pm</p></header><div class="content"><p>on Thu Aug 04 2016, Dmitri Gribenko &lt;gribozavr-AT-gmail.com&gt; wrote:<br></p><p>&gt; On Wed, Aug 3, 2016 at 7:28 PM, Xiaodi Wu via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Could I suggest an alternative? It&#39;s conservative in that it mimics the<br>&gt;&gt; relationships we had before the proposal was implemented and also maintains<br>&gt;&gt; the simplicity of the caseless enum:<br>&gt;&gt;<br>&gt;&gt; ```<br>&gt;&gt; extension MemoryLayout {<br>&gt;&gt;   static func size(ofValue _: T) -&gt; Int { return MemoryLayout.size }<br>&gt;&gt;   // etc.<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;<br>&gt; I like this API.  I think given all the alternatives that we explored,<br>&gt; it is better than those.  I also think that it nicely avoids the<br>&gt; following issue with the proposed MemoryLayout.of(type(of:<br>&gt; someExpression)).size syntax.<br>&gt;<br>&gt; Imagine that you have a value whose static type differs from the<br>&gt; dynamic type.  For example, a protocol existential:<br>&gt;<br>&gt; protocol P {}<br>&gt; extension Int : P {}<br>&gt; var x: P = 10<br>&gt;<br>&gt; The question is, what does MemoryLayout.of(type(of: x)).size compute,<br>&gt; size of the existential box, or the size of an Int instance?  The<br>&gt; semantics of &#39;type(of:)&#39; are &quot;return the dynamic type&quot;, so the<br>&gt; straightforward conclusion is that MemoryLayout.of(type(of: x)).size<br>&gt; returns the size of the dynamic type instance, of Int.<br>&gt;<br>&gt; What actually happens is that &#39;type(of: x)&#39; returns a dynamic value of<br>&gt; &#39;Int.self&#39;, statically typed as &#39;P.Type&#39;.  So P gets deduced for the<br>&gt; generic parameter of MemoryLayout, and MemoryLayout.of(type(of:<br>&gt; x)).size returns the size of the protocol box.<br>&gt;<br>&gt; I think due to this complex interaction, using type(of:) might lead to<br>&gt; confusing code, and thus I like Xiaodi&#39;s approach better.<br>&gt;<br>&gt; Dmitri<br></p><p>Okay, I&#39;m convinced; that&#39;s what we should do.<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>MemoryLayout for a value</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August  5, 2016 at 03:00:00am</p></header><div class="content"><p>On Thu, Aug 4, 2016 at 6:02 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; on Thu Aug 04 2016, Dmitri Gribenko &lt;gribozavr-AT-gmail.com&gt; wrote:<br>&gt;<br>&gt; &gt; On Wed, Aug 3, 2016 at 7:28 PM, Xiaodi Wu via swift-evolution<br>&gt; &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt; Could I suggest an alternative? It&#39;s conservative in that it mimics the<br>&gt; &gt;&gt; relationships we had before the proposal was implemented and also<br>&gt; maintains<br>&gt; &gt;&gt; the simplicity of the caseless enum:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; ```<br>&gt; &gt;&gt; extension MemoryLayout {<br>&gt; &gt;&gt;   static func size(ofValue _: T) -&gt; Int { return MemoryLayout.size }<br>&gt; &gt;&gt;   // etc.<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; ```<br>&gt; &gt;<br>&gt; &gt; I like this API.  I think given all the alternatives that we explored,<br>&gt; &gt; it is better than those.  I also think that it nicely avoids the<br>&gt; &gt; following issue with the proposed MemoryLayout.of(type(of:<br>&gt; &gt; someExpression)).size syntax.<br>&gt; &gt;<br>&gt; &gt; Imagine that you have a value whose static type differs from the<br>&gt; &gt; dynamic type.  For example, a protocol existential:<br>&gt; &gt;<br>&gt; &gt; protocol P {}<br>&gt; &gt; extension Int : P {}<br>&gt; &gt; var x: P = 10<br>&gt; &gt;<br>&gt; &gt; The question is, what does MemoryLayout.of(type(of: x)).size compute,<br>&gt; &gt; size of the existential box, or the size of an Int instance?  The<br>&gt; &gt; semantics of &#39;type(of:)&#39; are &quot;return the dynamic type&quot;, so the<br>&gt; &gt; straightforward conclusion is that MemoryLayout.of(type(of: x)).size<br>&gt; &gt; returns the size of the dynamic type instance, of Int.<br>&gt; &gt;<br>&gt; &gt; What actually happens is that &#39;type(of: x)&#39; returns a dynamic value of<br>&gt; &gt; &#39;Int.self&#39;, statically typed as &#39;P.Type&#39;.  So P gets deduced for the<br>&gt; &gt; generic parameter of MemoryLayout, and MemoryLayout.of(type(of:<br>&gt; &gt; x)).size returns the size of the protocol box.<br>&gt; &gt;<br>&gt; &gt; I think due to this complex interaction, using type(of:) might lead to<br>&gt; &gt; confusing code, and thus I like Xiaodi&#39;s approach better.<br>&gt; &gt;<br>&gt; &gt; Dmitri<br>&gt;<br>&gt; Okay, I&#39;m convinced; that&#39;s what we should do.<br>&gt;<br></p><p>Proposal and stdlib PRs have both been created.<br></p><p><br>&gt; --<br>&gt; -Dave<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160805/54b8125c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/242e18b243022bcb7573443e06444423?s=50"></div><header><strong>MemoryLayout for a value</strong> from <string>Boris Wang</string> &lt;kona.ming at gmail.com&gt;<p>August  6, 2016 at 02:00:00am</p></header><div class="content"><p>codes in swift REPL:<br></p><p>protocol P {<br>var x:Int {get}<br>}<br>MemoryLayout&lt;P&gt;.size<br>//r0 : Int = 40<br></p><p>struct S1 {<br>var v1:Int = 0<br>}<br>MemoryLayout&lt;S1&gt;.size<br>//r1: Int =8<br></p><p>struct S2: P {<br>var v2: Int<br>var x:Int<br>}<br>MemoryLayout &lt;S2&gt;.size<br>//r2: Int = 16<br></p><p>** Question:<br>Why we need to known the size of a object that can&#39;t be instanced?<br></p><p>** Confuse:<br>MemoryLayout &lt;S2.Type&gt;.size<br>//r3: Int = 0<br></p><p>MemoryLayout &lt;P.Type&gt;.size<br>//r4: Int = 16<br></p><p><br></p><p>Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt;于2016年8月5日<br>周五16:34写道：<br></p><p>&gt; On Thu, Aug 4, 2016 at 6:02 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; on Thu Aug 04 2016, Dmitri Gribenko &lt;gribozavr-AT-gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; &gt; On Wed, Aug 3, 2016 at 7:28 PM, Xiaodi Wu via swift-evolution<br>&gt;&gt; &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt; Could I suggest an alternative? It&#39;s conservative in that it mimics the<br>&gt;&gt; &gt;&gt; relationships we had before the proposal was implemented and also<br>&gt;&gt; maintains<br>&gt;&gt; &gt;&gt; the simplicity of the caseless enum:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; ```<br>&gt;&gt; &gt;&gt; extension MemoryLayout {<br>&gt;&gt; &gt;&gt;   static func size(ofValue _: T) -&gt; Int { return MemoryLayout.size }<br>&gt;&gt; &gt;&gt;   // etc.<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt; ```<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I like this API.  I think given all the alternatives that we explored,<br>&gt;&gt; &gt; it is better than those.  I also think that it nicely avoids the<br>&gt;&gt; &gt; following issue with the proposed MemoryLayout.of(type(of:<br>&gt;&gt; &gt; someExpression)).size syntax.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Imagine that you have a value whose static type differs from the<br>&gt;&gt; &gt; dynamic type.  For example, a protocol existential:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; protocol P {}<br>&gt;&gt; &gt; extension Int : P {}<br>&gt;&gt; &gt; var x: P = 10<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The question is, what does MemoryLayout.of(type(of: x)).size compute,<br>&gt;&gt; &gt; size of the existential box, or the size of an Int instance?  The<br>&gt;&gt; &gt; semantics of &#39;type(of:)&#39; are &quot;return the dynamic type&quot;, so the<br>&gt;&gt; &gt; straightforward conclusion is that MemoryLayout.of(type(of: x)).size<br>&gt;&gt; &gt; returns the size of the dynamic type instance, of Int.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; What actually happens is that &#39;type(of: x)&#39; returns a dynamic value of<br>&gt;&gt; &gt; &#39;Int.self&#39;, statically typed as &#39;P.Type&#39;.  So P gets deduced for the<br>&gt;&gt; &gt; generic parameter of MemoryLayout, and MemoryLayout.of(type(of:<br>&gt;&gt; &gt; x)).size returns the size of the protocol box.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I think due to this complex interaction, using type(of:) might lead to<br>&gt;&gt; &gt; confusing code, and thus I like Xiaodi&#39;s approach better.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Dmitri<br>&gt;&gt;<br>&gt;&gt; Okay, I&#39;m convinced; that&#39;s what we should do.<br>&gt;&gt;<br>&gt;<br>&gt; Proposal and stdlib PRs have both been created.<br>&gt;<br>&gt;<br>&gt;&gt; --<br>&gt;&gt; -Dave<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160806/42d60c96/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/242e18b243022bcb7573443e06444423?s=50"></div><header><strong>MemoryLayout for a value</strong> from <string>Boris Wang</string> &lt;kona.ming at gmail.com&gt;<p>August  6, 2016 at 03:00:00am</p></header><div class="content"><p>Addition:<br></p><p>I think protocol should&#39;t has size, or it&#39;s size should be zero.<br>Because you can&#39;t put the 40 bytes data in anywhere.<br></p><p><br>Boris Wang &lt;kona.ming at gmail.com&gt;于2016年8月6日 周六10:35写道：<br></p><p>&gt; codes in swift REPL:<br>&gt;<br>&gt; protocol P {<br>&gt; var x:Int {get}<br>&gt; }<br>&gt; MemoryLayout&lt;P&gt;.size<br>&gt; //r0 : Int = 40<br>&gt;<br>&gt; struct S1 {<br>&gt; var v1:Int = 0<br>&gt; }<br>&gt; MemoryLayout&lt;S1&gt;.size<br>&gt; //r1: Int =8<br>&gt;<br>&gt; struct S2: P {<br>&gt; var v2: Int<br>&gt; var x:Int<br>&gt; }<br>&gt; MemoryLayout &lt;S2&gt;.size<br>&gt; //r2: Int = 16<br>&gt;<br>&gt; ** Question:<br>&gt; Why we need to known the size of a object that can&#39;t be instanced?<br>&gt;<br>&gt; ** Confuse:<br>&gt; MemoryLayout &lt;S2.Type&gt;.size<br>&gt; //r3: Int = 0<br>&gt;<br>&gt; MemoryLayout &lt;P.Type&gt;.size<br>&gt; //r4: Int = 16<br>&gt;<br>&gt;<br>&gt;<br>&gt; Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt;于2016年8月5日<br>&gt; 周五16:34写道：<br>&gt;<br>&gt;&gt; On Thu, Aug 4, 2016 at 6:02 PM, Dave Abrahams &lt;dabrahams at apple.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; on Thu Aug 04 2016, Dmitri Gribenko &lt;gribozavr-AT-gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; On Wed, Aug 3, 2016 at 7:28 PM, Xiaodi Wu via swift-evolution<br>&gt;&gt;&gt; &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt; Could I suggest an alternative? It&#39;s conservative in that it mimics<br>&gt;&gt;&gt; the<br>&gt;&gt;&gt; &gt;&gt; relationships we had before the proposal was implemented and also<br>&gt;&gt;&gt; maintains<br>&gt;&gt;&gt; &gt;&gt; the simplicity of the caseless enum:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; ```<br>&gt;&gt;&gt; &gt;&gt; extension MemoryLayout {<br>&gt;&gt;&gt; &gt;&gt;   static func size(ofValue _: T) -&gt; Int { return MemoryLayout.size }<br>&gt;&gt;&gt; &gt;&gt;   // etc.<br>&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt; ```<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I like this API.  I think given all the alternatives that we explored,<br>&gt;&gt;&gt; &gt; it is better than those.  I also think that it nicely avoids the<br>&gt;&gt;&gt; &gt; following issue with the proposed MemoryLayout.of(type(of:<br>&gt;&gt;&gt; &gt; someExpression)).size syntax.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Imagine that you have a value whose static type differs from the<br>&gt;&gt;&gt; &gt; dynamic type.  For example, a protocol existential:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; protocol P {}<br>&gt;&gt;&gt; &gt; extension Int : P {}<br>&gt;&gt;&gt; &gt; var x: P = 10<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; The question is, what does MemoryLayout.of(type(of: x)).size compute,<br>&gt;&gt;&gt; &gt; size of the existential box, or the size of an Int instance?  The<br>&gt;&gt;&gt; &gt; semantics of &#39;type(of:)&#39; are &quot;return the dynamic type&quot;, so the<br>&gt;&gt;&gt; &gt; straightforward conclusion is that MemoryLayout.of(type(of: x)).size<br>&gt;&gt;&gt; &gt; returns the size of the dynamic type instance, of Int.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; What actually happens is that &#39;type(of: x)&#39; returns a dynamic value of<br>&gt;&gt;&gt; &gt; &#39;Int.self&#39;, statically typed as &#39;P.Type&#39;.  So P gets deduced for the<br>&gt;&gt;&gt; &gt; generic parameter of MemoryLayout, and MemoryLayout.of(type(of:<br>&gt;&gt;&gt; &gt; x)).size returns the size of the protocol box.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I think due to this complex interaction, using type(of:) might lead to<br>&gt;&gt;&gt; &gt; confusing code, and thus I like Xiaodi&#39;s approach better.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Dmitri<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Okay, I&#39;m convinced; that&#39;s what we should do.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Proposal and stdlib PRs have both been created.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160806/d6a9b081/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>MemoryLayout for a value</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>August  6, 2016 at 11:00:00am</p></header><div class="content"><p>What’s so confusing about MemoryLayout&lt;T.Type&gt;.size?<br></p><p>size in this context gives you the size for the metatype of T, not the size of T.<br></p><p>If I memorize correctly:<br></p><p>Size of metatypes of value types and functions/closures is 0.<br>Size for class metatypes is 8.<br>Size for protocols metatypes (in your case it’s P.Protocol, not P.Type) is 16 except for the (old) empty protocol Any which is 8.<br>You may ask why these metatypes have these sizes?! I can’t answer this question, because I don’t know the technical reason, but it doesn’t matter in our case.<br></p><p>Furthermore there is a difference between T.Type and what you get from T.self.<br></p><p>T.self returns a concrete metatype for T. T.Type is a metatype supertype for all subtypes of T if there exist a subtype relationship.<br></p><p>That’s why something like this works fine:<br></p><p>let a1: Any.Type = Int.self // `Int.self` is 0 where `Any.self` is 8<br>let a2: Any.Type = P.self // same story with different sizes<br>We’re revising our proposal to provide a clear distinction of this behavior and get rid of .Protocol and .Type.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 6. August 2016 um 04:35:50, Boris Wang via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p>codes in swift REPL:<br></p><p>protocol P {<br>var x:Int {get}<br>}<br>MemoryLayout&lt;P&gt;.size<br>//r0 : Int = 40<br></p><p>struct S1 {<br>var v1:Int = 0<br>}<br>MemoryLayout&lt;S1&gt;.size<br>//r1: Int =8<br></p><p>struct S2: P {<br>var v2: Int<br>var x:Int<br>}<br>MemoryLayout &lt;S2&gt;.size<br>//r2: Int = 16<br></p><p>** Question:<br>Why we need to known the size of a object that can&#39;t be instanced?<br></p><p>** Confuse:<br>MemoryLayout &lt;S2.Type&gt;.size<br>//r3: Int = 0<br></p><p>MemoryLayout &lt;P.Type&gt;.size<br>//r4: Int = 16<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160806/03af79b3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>MemoryLayout for a value</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>August  6, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On 6 Aug 2016, at 11:05, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; What’s so confusing about MemoryLayout&lt;T.Type&gt;.size?<br>&gt; <br>&gt; size in this context gives you the size for the metatype of T, not the size of T.<br>&gt; <br>&gt; If I memorize correctly:<br>&gt; <br>&gt; Size of metatypes of value types and functions/closures is 0.<br>&gt; Size for class metatypes is 8.<br>&gt; Size for protocols metatypes (in your case it’s P.Protocol, not P.Type) is 16 except for the (old) empty protocol Any which is 8.<br>&gt; You may ask why these metatypes have these sizes?! I can’t answer this question, because I don’t know the technical reason, but it doesn’t matter in our case.<br>&gt; <br>&gt; Furthermore there is a difference between T.Type and what you get from T.self.<br>&gt; <br>&gt; T.self returns a concrete metatype for T. T.Type is a metatype supertype for all subtypes of T if there exist a subtype relationship.<br>&gt; <br>&gt; That’s why something like this works fine:<br>&gt; <br>&gt; let a1: Any.Type = Int.self // `Int.self` is 0 where `Any.self` is 8<br>&gt; let a2: Any.Type = P.self // same story with different sizes<br>&gt; We’re revising our proposal to provide a clear distinction of this behavior and get rid of .Protocol and .Type.<br>&gt; <br>&gt; <br></p><p>I think the underlying issue isn’t that MemoryLayout&lt;T&gt; vs MemoryLayout&lt;T.Type&gt; is confusing, it’s that our metatype system is a little awkward, so the way you construct a MemoryLayout&lt;X&gt; can lead to non-obvious results unless you’re an expert. Given time constraints, the most practical solution which gives us the best product for Swift 3.0 is to revise the MemoryLayout interface, but I think most users would be happy to see some simplification of the metatype system for Swift &gt;3.0.<br></p><p>Personally I only sporadically remember which name means what in a given context. Oh, the dark corners I would have been lost in without code-completion…<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160806/4f141349/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/242e18b243022bcb7573443e06444423?s=50"></div><header><strong>MemoryLayout for a value</strong> from <string>Boris Wang</string> &lt;kona.ming at gmail.com&gt;<p>August  6, 2016 at 10:00:00pm</p></header><div class="content"><p>+1<br></p><p>* I think swift expose too much informations inside compiler to the user。<br></p><p>* I can&#39;t imagine, a modern, swift language can&#39;t get the size of T/t with<br>same API:<br>MemoryLayout&lt;T&gt;.size<br>MemoryLayout.size(ofValue:t)<br></p><p><br></p><p>Karl via swift-evolution &lt;swift-evolution at swift.org&gt;于2016年8月6日 周六23:23写道：<br></p><p>&gt;<br>&gt; On 6 Aug 2016, at 11:05, Adrian Zubarev via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; What’s so confusing about MemoryLayout&lt;T.Type&gt;.size?<br>&gt;<br>&gt; size in this context gives you the size for the metatype of T, not the<br>&gt; size of T.<br>&gt;<br>&gt; If I memorize correctly:<br>&gt;<br>&gt;    - Size of metatypes of value types and functions/closures is 0.<br>&gt;    - Size for class metatypes is 8.<br>&gt;    - Size for protocols metatypes (in your case it’s P.Protocol, not<br>&gt;    P.Type) is 16 except for the (old) empty protocol Any which is 8.<br>&gt;<br>&gt; You may ask why these metatypes have these sizes?! I can’t answer this<br>&gt; question, because I don’t know the technical reason, but it doesn’t matter<br>&gt; in our case.<br>&gt;<br>&gt; Furthermore there is a difference between T.Type and what you get from<br>&gt; T.self.<br>&gt;<br>&gt; T.self returns a concrete metatype for T. T.Type is a metatype supertype<br>&gt; for all subtypes of T if there exist a subtype relationship.<br>&gt;<br>&gt; That’s why something like this works fine:<br>&gt;<br>&gt; let a1: Any.Type = Int.self // `Int.self` is 0 where `Any.self` is 8<br>&gt; let a2: Any.Type = P.self // same story with different sizes<br>&gt;<br>&gt; We’re revising our proposal to provide a clear distinction of this<br>&gt; behavior and get rid of .Protocol and .Type.<br>&gt;<br>&gt;<br>&gt; I think the underlying issue isn’t that MemoryLayout&lt;T&gt; vs<br>&gt; MemoryLayout&lt;T.Type&gt; is confusing, it’s that our metatype system is a<br>&gt; little awkward, so the way you construct a MemoryLayout&lt;X&gt; can lead to<br>&gt; non-obvious results unless you’re an expert. Given time constraints, the<br>&gt; most practical solution which gives us the best product for Swift 3.0 is to<br>&gt; revise the MemoryLayout interface, but I think most users would be happy to<br>&gt; see some simplification of the metatype system for Swift &gt;3.0.<br>&gt;<br>&gt; Personally I only sporadically remember which name means what in a given<br>&gt; context. Oh, the dark corners I would have been lost in without<br>&gt; code-completion…<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160806/2c9bf830/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>MemoryLayout for a value</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>August  6, 2016 at 02:00:00pm</p></header><div class="content"><p>On Fri, Aug 5, 2016 at 7:35 PM, Boris Wang via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; codes in swift REPL:<br>&gt;<br>&gt; protocol P {<br>&gt; var x:Int {get}<br>&gt; }<br>&gt; MemoryLayout&lt;P&gt;.size<br>&gt; //r0 : Int = 40<br>&gt;<br>&gt; struct S1 {<br>&gt; var v1:Int = 0<br>&gt; }<br>&gt; MemoryLayout&lt;S1&gt;.size<br>&gt; //r1: Int =8<br>&gt;<br>&gt; struct S2: P {<br>&gt; var v2: Int<br>&gt; var x:Int<br>&gt; }<br>&gt; MemoryLayout &lt;S2&gt;.size<br>&gt; //r2: Int = 16<br>&gt;<br>&gt; ** Question:<br>&gt; Why we need to known the size of a object that can&#39;t be instanced?<br></p><p>The size of a variable of static type S2 is not equal to the size of<br>the variable of static type P, even though it can dynamically contain<br>an instance of S2.<br></p><p>Consider:<br></p><p>var x: P = S2(v2: 0, x: 0)<br></p><p>The size of x is not equal to the size of S2.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ea125c5cd93ba84769387c17c973e2b3?s=50"></div><header><strong>MemoryLayout for a value</strong> from <string>rintaro ishizaki</string> &lt;fs.output at gmail.com&gt;<p>August  5, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; ```<br>&gt; extension MemoryLayout {<br>&gt;   static func size(ofValue _: T) -&gt; Int { return MemoryLayout.size }<br>&gt;   // etc.<br>&gt; }<br>&gt; ```<br></p><p>I don&#39;t think we can do this while we have:<br></p><p>  public static var size: Int {<br></p><p>maybe `sizeOf(value _: T) -&gt; Int` ?<br></p><p><br>2016-08-04 11:28 GMT+09:00 Xiaodi Wu via swift-evolution &lt;<br>swift-evolution at swift.org&gt;:<br></p><p>&gt; On Wed, Aug 3, 2016 at 8:47 PM, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; &gt; On Aug 3, 2016, at 2:43 PM, Dave Abrahams via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Having seen the effects in the standard library and in other<br>&gt;&gt; &gt; code, I&#39;m concerned that we may have made a mistake in removing<br>&gt;&gt; &gt; `sizeofValue` et al without providing a replacement.  In the standard<br>&gt;&gt; &gt; library, we ended up adding an underscored API that allows<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;  MemoryLayout._ofInstance(someExpression).size<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Where someExpression is an autoclosure, and thus not evaluated.  I<br>&gt;&gt; &gt; wanted to bring up the possibility of introducing a replacement as a<br>&gt;&gt; &gt; bufix.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I propose that the way to express the above should be:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;  MemoryLayout.of(type(of: someExpression)).size<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; implementable as:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;  extension MemoryLayout {<br>&gt;&gt; &gt;    @_transparent<br>&gt;&gt; &gt;    public<br>&gt;&gt; &gt;    static func of(_: T.Type) -&gt; MemoryLayout&lt;T&gt;.Type {<br>&gt;&gt; &gt;      return MemoryLayout&lt;T&gt;.self<br>&gt;&gt; &gt;    }<br>&gt;&gt; &gt;  }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I think this API would solve the concerns I had about confusability that<br>&gt;&gt; &gt; led me to advocate dropping the ability to ask for the size of a value.<br>&gt;&gt; &gt; The only way to use it is to pass a type and these two expressions have<br>&gt;&gt; &gt; equivalent meaning:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;    MemoryLayout&lt;Int&gt;<br>&gt;&gt; &gt;    MemoryLayout.of(Int.self)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; It also has the benefit of isolating the autoclosure magic to type(of:).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; ,----[ Aside ]<br>&gt;&gt; &gt; | A slightly cleaner use site is possible with a larger API change:<br>&gt;&gt; &gt; |<br>&gt;&gt; &gt; |   MemoryLayout(type(of: someExpression)).size<br>&gt;&gt; &gt; |<br>&gt;&gt; &gt; | Which would involve changing MemoryLayout from an `enum` to<br>&gt;&gt; &gt; | a `struct` and adding the following:<br>&gt;&gt; &gt; |<br>&gt;&gt; &gt; |   extension MemoryLayout {<br>&gt;&gt; &gt; |     public init(_: T.Type) {}<br>&gt;&gt; &gt; |<br>&gt;&gt; &gt; |     public var size: Int { return MemoryLayout.size }<br>&gt;&gt; &gt; |     public var stride: Int { return MemoryLayout.stride }<br>&gt;&gt; &gt; |     public var alignment: Int { return MemoryLayout.alignment }<br>&gt;&gt; &gt; |   }<br>&gt;&gt; &gt; |<br>&gt;&gt; &gt; | However I am concerned that dropping &quot;.of&quot; at the use site is worth<br>&gt;&gt; the<br>&gt;&gt; &gt; | added API complexity.<br>&gt;&gt; &gt; `----<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Thoughts?<br>&gt;&gt; &gt; --<br>&gt;&gt; &gt; -Dave<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I don&#39;t think using &quot;of&quot; is a great burden.<br>&gt;&gt;<br>&gt;<br>&gt; Agreed, but I do think &quot;memory layout of type of my value, size&quot; is a<br>&gt; mouthful compared to &quot;size of value&quot;. Moreover, something doesn&#39;t sit right<br>&gt; with me that MemoryLayout&lt;T&gt; and MemoryLayout.of(T.self) would be one and<br>&gt; the same thing.<br>&gt;<br>&gt; Could I suggest an alternative? It&#39;s conservative in that it mimics the<br>&gt; relationships we had before the proposal was implemented and also maintains<br>&gt; the simplicity of the caseless enum:<br>&gt;<br>&gt; ```<br>&gt; extension MemoryLayout {<br>&gt;   static func size(ofValue _: T) -&gt; Int { return MemoryLayout.size }<br>&gt;   // etc.<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt;<br>&gt;&gt; -- E<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160805/55340eb9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>MemoryLayout for a value</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August  5, 2016 at 02:00:00am</p></header><div class="content"><p>On Fri, Aug 5, 2016 at 2:06 AM, rintaro ishizaki &lt;fs.output at gmail.com&gt;<br>wrote:<br></p><p>&gt; &gt; ```<br>&gt; &gt; extension MemoryLayout {<br>&gt; &gt;   static func size(ofValue _: T) -&gt; Int { return MemoryLayout.size }<br>&gt; &gt;   // etc.<br>&gt; &gt; }<br>&gt; &gt; ```<br>&gt;<br>&gt; I don&#39;t think we can do this while we have:<br>&gt;<br>&gt;   public static var size: Int {<br>&gt;<br></p><p>Why not?<br></p><p>maybe `sizeOf(value _: T) -&gt; Int` ?<br>&gt;<br>&gt;<br>&gt; 2016-08-04 11:28 GMT+09:00 Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt;<br>&gt;&gt; On Wed, Aug 3, 2016 at 8:47 PM, Erica Sadun via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; &gt; On Aug 3, 2016, at 2:43 PM, Dave Abrahams via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Having seen the effects in the standard library and in other<br>&gt;&gt;&gt; &gt; code, I&#39;m concerned that we may have made a mistake in removing<br>&gt;&gt;&gt; &gt; `sizeofValue` et al without providing a replacement.  In the standard<br>&gt;&gt;&gt; &gt; library, we ended up adding an underscored API that allows<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;  MemoryLayout._ofInstance(someExpression).size<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Where someExpression is an autoclosure, and thus not evaluated.  I<br>&gt;&gt;&gt; &gt; wanted to bring up the possibility of introducing a replacement as a<br>&gt;&gt;&gt; &gt; bufix.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I propose that the way to express the above should be:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;  MemoryLayout.of(type(of: someExpression)).size<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; implementable as:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;  extension MemoryLayout {<br>&gt;&gt;&gt; &gt;    @_transparent<br>&gt;&gt;&gt; &gt;    public<br>&gt;&gt;&gt; &gt;    static func of(_: T.Type) -&gt; MemoryLayout&lt;T&gt;.Type {<br>&gt;&gt;&gt; &gt;      return MemoryLayout&lt;T&gt;.self<br>&gt;&gt;&gt; &gt;    }<br>&gt;&gt;&gt; &gt;  }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I think this API would solve the concerns I had about confusability<br>&gt;&gt;&gt; that<br>&gt;&gt;&gt; &gt; led me to advocate dropping the ability to ask for the size of a value.<br>&gt;&gt;&gt; &gt; The only way to use it is to pass a type and these two expressions have<br>&gt;&gt;&gt; &gt; equivalent meaning:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;    MemoryLayout&lt;Int&gt;<br>&gt;&gt;&gt; &gt;    MemoryLayout.of(Int.self)<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; It also has the benefit of isolating the autoclosure magic to<br>&gt;&gt;&gt; type(of:).<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; ,----[ Aside ]<br>&gt;&gt;&gt; &gt; | A slightly cleaner use site is possible with a larger API change:<br>&gt;&gt;&gt; &gt; |<br>&gt;&gt;&gt; &gt; |   MemoryLayout(type(of: someExpression)).size<br>&gt;&gt;&gt; &gt; |<br>&gt;&gt;&gt; &gt; | Which would involve changing MemoryLayout from an `enum` to<br>&gt;&gt;&gt; &gt; | a `struct` and adding the following:<br>&gt;&gt;&gt; &gt; |<br>&gt;&gt;&gt; &gt; |   extension MemoryLayout {<br>&gt;&gt;&gt; &gt; |     public init(_: T.Type) {}<br>&gt;&gt;&gt; &gt; |<br>&gt;&gt;&gt; &gt; |     public var size: Int { return MemoryLayout.size }<br>&gt;&gt;&gt; &gt; |     public var stride: Int { return MemoryLayout.stride }<br>&gt;&gt;&gt; &gt; |     public var alignment: Int { return MemoryLayout.alignment }<br>&gt;&gt;&gt; &gt; |   }<br>&gt;&gt;&gt; &gt; |<br>&gt;&gt;&gt; &gt; | However I am concerned that dropping &quot;.of&quot; at the use site is worth<br>&gt;&gt;&gt; the<br>&gt;&gt;&gt; &gt; | added API complexity.<br>&gt;&gt;&gt; &gt; `----<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Thoughts?<br>&gt;&gt;&gt; &gt; --<br>&gt;&gt;&gt; &gt; -Dave<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I don&#39;t think using &quot;of&quot; is a great burden.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Agreed, but I do think &quot;memory layout of type of my value, size&quot; is a<br>&gt;&gt; mouthful compared to &quot;size of value&quot;. Moreover, something doesn&#39;t sit right<br>&gt;&gt; with me that MemoryLayout&lt;T&gt; and MemoryLayout.of(T.self) would be one and<br>&gt;&gt; the same thing.<br>&gt;&gt;<br>&gt;&gt; Could I suggest an alternative? It&#39;s conservative in that it mimics the<br>&gt;&gt; relationships we had before the proposal was implemented and also maintains<br>&gt;&gt; the simplicity of the caseless enum:<br>&gt;&gt;<br>&gt;&gt; ```<br>&gt;&gt; extension MemoryLayout {<br>&gt;&gt;   static func size(ofValue _: T) -&gt; Int { return MemoryLayout.size }<br>&gt;&gt;   // etc.<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; -- E<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160805/c3e62b41/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ea125c5cd93ba84769387c17c973e2b3?s=50"></div><header><strong>MemoryLayout for a value</strong> from <string>rintaro ishizaki</string> &lt;fs.output at gmail.com&gt;<p>August  5, 2016 at 04:00:00pm</p></header><div class="content"><p>2016-08-05 16:20 GMT+09:00 Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt;:<br></p><p>&gt; On Fri, Aug 5, 2016 at 2:06 AM, rintaro ishizaki &lt;fs.output at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; &gt; ```<br>&gt;&gt; &gt; extension MemoryLayout {<br>&gt;&gt; &gt;   static func size(ofValue _: T) -&gt; Int { return MemoryLayout.size }<br>&gt;&gt; &gt;   // etc.<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt; ```<br>&gt;&gt;<br>&gt;&gt; I don&#39;t think we can do this while we have:<br>&gt;&gt;<br>&gt;&gt;   public static var size: Int {<br>&gt;&gt;<br>&gt;<br>&gt; Why not?<br>&gt;<br></p><p>My bad. Sorry, never mind.<br>I didn&#39;t know we can have such overloads (property and func, same basename)<br>:O<br></p><p><br></p><p>&gt;<br>&gt; maybe `sizeOf(value _: T) -&gt; Int` ?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; 2016-08-04 11:28 GMT+09:00 Xiaodi Wu via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt;:<br>&gt;&gt;<br>&gt;&gt;&gt; On Wed, Aug 3, 2016 at 8:47 PM, Erica Sadun via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt; On Aug 3, 2016, at 2:43 PM, Dave Abrahams via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; Having seen the effects in the standard library and in other<br>&gt;&gt;&gt;&gt; &gt; code, I&#39;m concerned that we may have made a mistake in removing<br>&gt;&gt;&gt;&gt; &gt; `sizeofValue` et al without providing a replacement.  In the standard<br>&gt;&gt;&gt;&gt; &gt; library, we ended up adding an underscored API that allows<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;  MemoryLayout._ofInstance(someExpression).size<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; Where someExpression is an autoclosure, and thus not evaluated.  I<br>&gt;&gt;&gt;&gt; &gt; wanted to bring up the possibility of introducing a replacement as a<br>&gt;&gt;&gt;&gt; &gt; bufix.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; I propose that the way to express the above should be:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;  MemoryLayout.of(type(of: someExpression)).size<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; implementable as:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;  extension MemoryLayout {<br>&gt;&gt;&gt;&gt; &gt;    @_transparent<br>&gt;&gt;&gt;&gt; &gt;    public<br>&gt;&gt;&gt;&gt; &gt;    static func of(_: T.Type) -&gt; MemoryLayout&lt;T&gt;.Type {<br>&gt;&gt;&gt;&gt; &gt;      return MemoryLayout&lt;T&gt;.self<br>&gt;&gt;&gt;&gt; &gt;    }<br>&gt;&gt;&gt;&gt; &gt;  }<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; I think this API would solve the concerns I had about confusability<br>&gt;&gt;&gt;&gt; that<br>&gt;&gt;&gt;&gt; &gt; led me to advocate dropping the ability to ask for the size of a<br>&gt;&gt;&gt;&gt; value.<br>&gt;&gt;&gt;&gt; &gt; The only way to use it is to pass a type and these two expressions<br>&gt;&gt;&gt;&gt; have<br>&gt;&gt;&gt;&gt; &gt; equivalent meaning:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;    MemoryLayout&lt;Int&gt;<br>&gt;&gt;&gt;&gt; &gt;    MemoryLayout.of(Int.self)<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; It also has the benefit of isolating the autoclosure magic to<br>&gt;&gt;&gt;&gt; type(of:).<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; ,----[ Aside ]<br>&gt;&gt;&gt;&gt; &gt; | A slightly cleaner use site is possible with a larger API change:<br>&gt;&gt;&gt;&gt; &gt; |<br>&gt;&gt;&gt;&gt; &gt; |   MemoryLayout(type(of: someExpression)).size<br>&gt;&gt;&gt;&gt; &gt; |<br>&gt;&gt;&gt;&gt; &gt; | Which would involve changing MemoryLayout from an `enum` to<br>&gt;&gt;&gt;&gt; &gt; | a `struct` and adding the following:<br>&gt;&gt;&gt;&gt; &gt; |<br>&gt;&gt;&gt;&gt; &gt; |   extension MemoryLayout {<br>&gt;&gt;&gt;&gt; &gt; |     public init(_: T.Type) {}<br>&gt;&gt;&gt;&gt; &gt; |<br>&gt;&gt;&gt;&gt; &gt; |     public var size: Int { return MemoryLayout.size }<br>&gt;&gt;&gt;&gt; &gt; |     public var stride: Int { return MemoryLayout.stride }<br>&gt;&gt;&gt;&gt; &gt; |     public var alignment: Int { return MemoryLayout.alignment }<br>&gt;&gt;&gt;&gt; &gt; |   }<br>&gt;&gt;&gt;&gt; &gt; |<br>&gt;&gt;&gt;&gt; &gt; | However I am concerned that dropping &quot;.of&quot; at the use site is worth<br>&gt;&gt;&gt;&gt; the<br>&gt;&gt;&gt;&gt; &gt; | added API complexity.<br>&gt;&gt;&gt;&gt; &gt; `----<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; Thoughts?<br>&gt;&gt;&gt;&gt; &gt; --<br>&gt;&gt;&gt;&gt; &gt; -Dave<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I don&#39;t think using &quot;of&quot; is a great burden.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Agreed, but I do think &quot;memory layout of type of my value, size&quot; is a<br>&gt;&gt;&gt; mouthful compared to &quot;size of value&quot;. Moreover, something doesn&#39;t sit right<br>&gt;&gt;&gt; with me that MemoryLayout&lt;T&gt; and MemoryLayout.of(T.self) would be one and<br>&gt;&gt;&gt; the same thing.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Could I suggest an alternative? It&#39;s conservative in that it mimics the<br>&gt;&gt;&gt; relationships we had before the proposal was implemented and also maintains<br>&gt;&gt;&gt; the simplicity of the caseless enum:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; extension MemoryLayout {<br>&gt;&gt;&gt;   static func size(ofValue _: T) -&gt; Int { return MemoryLayout.size }<br>&gt;&gt;&gt;   // etc.<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; -- E<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160805/6d0e63c1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>MemoryLayout for a value</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August  5, 2016 at 03:00:00am</p></header><div class="content"><p>On Fri, Aug 5, 2016 at 2:46 AM, rintaro ishizaki &lt;fs.output at gmail.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt;<br>&gt; 2016-08-05 16:20 GMT+09:00 Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt;:<br>&gt;<br>&gt;&gt; On Fri, Aug 5, 2016 at 2:06 AM, rintaro ishizaki &lt;fs.output at gmail.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; &gt; ```<br>&gt;&gt;&gt; &gt; extension MemoryLayout {<br>&gt;&gt;&gt; &gt;   static func size(ofValue _: T) -&gt; Int { return MemoryLayout.size }<br>&gt;&gt;&gt; &gt;   // etc.<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; &gt; ```<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I don&#39;t think we can do this while we have:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   public static var size: Int {<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Why not?<br>&gt;&gt;<br>&gt;<br>&gt; My bad. Sorry, never mind.<br>&gt; I didn&#39;t know we can have such overloads (property and func, same<br>&gt; basename) :O<br>&gt;<br></p><p>As I mentioned above, it&#39;s not only possible but already used in the<br>standard library. For instance, `first` and `first(where:)` for Collection<br>types.<br></p><p><br>&gt; maybe `sizeOf(value _: T) -&gt; Int` ?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 2016-08-04 11:28 GMT+09:00 Xiaodi Wu via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Wed, Aug 3, 2016 at 8:47 PM, Erica Sadun via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; On Aug 3, 2016, at 2:43 PM, Dave Abrahams via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Having seen the effects in the standard library and in other<br>&gt;&gt;&gt;&gt;&gt; &gt; code, I&#39;m concerned that we may have made a mistake in removing<br>&gt;&gt;&gt;&gt;&gt; &gt; `sizeofValue` et al without providing a replacement.  In the standard<br>&gt;&gt;&gt;&gt;&gt; &gt; library, we ended up adding an underscored API that allows<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;  MemoryLayout._ofInstance(someExpression).size<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Where someExpression is an autoclosure, and thus not evaluated.  I<br>&gt;&gt;&gt;&gt;&gt; &gt; wanted to bring up the possibility of introducing a replacement as a<br>&gt;&gt;&gt;&gt;&gt; &gt; bufix.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; I propose that the way to express the above should be:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;  MemoryLayout.of(type(of: someExpression)).size<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; implementable as:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;  extension MemoryLayout {<br>&gt;&gt;&gt;&gt;&gt; &gt;    @_transparent<br>&gt;&gt;&gt;&gt;&gt; &gt;    public<br>&gt;&gt;&gt;&gt;&gt; &gt;    static func of(_: T.Type) -&gt; MemoryLayout&lt;T&gt;.Type {<br>&gt;&gt;&gt;&gt;&gt; &gt;      return MemoryLayout&lt;T&gt;.self<br>&gt;&gt;&gt;&gt;&gt; &gt;    }<br>&gt;&gt;&gt;&gt;&gt; &gt;  }<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; I think this API would solve the concerns I had about confusability<br>&gt;&gt;&gt;&gt;&gt; that<br>&gt;&gt;&gt;&gt;&gt; &gt; led me to advocate dropping the ability to ask for the size of a<br>&gt;&gt;&gt;&gt;&gt; value.<br>&gt;&gt;&gt;&gt;&gt; &gt; The only way to use it is to pass a type and these two expressions<br>&gt;&gt;&gt;&gt;&gt; have<br>&gt;&gt;&gt;&gt;&gt; &gt; equivalent meaning:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;    MemoryLayout&lt;Int&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;    MemoryLayout.of(Int.self)<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; It also has the benefit of isolating the autoclosure magic to<br>&gt;&gt;&gt;&gt;&gt; type(of:).<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; ,----[ Aside ]<br>&gt;&gt;&gt;&gt;&gt; &gt; | A slightly cleaner use site is possible with a larger API change:<br>&gt;&gt;&gt;&gt;&gt; &gt; |<br>&gt;&gt;&gt;&gt;&gt; &gt; |   MemoryLayout(type(of: someExpression)).size<br>&gt;&gt;&gt;&gt;&gt; &gt; |<br>&gt;&gt;&gt;&gt;&gt; &gt; | Which would involve changing MemoryLayout from an `enum` to<br>&gt;&gt;&gt;&gt;&gt; &gt; | a `struct` and adding the following:<br>&gt;&gt;&gt;&gt;&gt; &gt; |<br>&gt;&gt;&gt;&gt;&gt; &gt; |   extension MemoryLayout {<br>&gt;&gt;&gt;&gt;&gt; &gt; |     public init(_: T.Type) {}<br>&gt;&gt;&gt;&gt;&gt; &gt; |<br>&gt;&gt;&gt;&gt;&gt; &gt; |     public var size: Int { return MemoryLayout.size }<br>&gt;&gt;&gt;&gt;&gt; &gt; |     public var stride: Int { return MemoryLayout.stride }<br>&gt;&gt;&gt;&gt;&gt; &gt; |     public var alignment: Int { return MemoryLayout.alignment }<br>&gt;&gt;&gt;&gt;&gt; &gt; |   }<br>&gt;&gt;&gt;&gt;&gt; &gt; |<br>&gt;&gt;&gt;&gt;&gt; &gt; | However I am concerned that dropping &quot;.of&quot; at the use site is<br>&gt;&gt;&gt;&gt;&gt; worth the<br>&gt;&gt;&gt;&gt;&gt; &gt; | added API complexity.<br>&gt;&gt;&gt;&gt;&gt; &gt; `----<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Thoughts?<br>&gt;&gt;&gt;&gt;&gt; &gt; --<br>&gt;&gt;&gt;&gt;&gt; &gt; -Dave<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I don&#39;t think using &quot;of&quot; is a great burden.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Agreed, but I do think &quot;memory layout of type of my value, size&quot; is a<br>&gt;&gt;&gt;&gt; mouthful compared to &quot;size of value&quot;. Moreover, something doesn&#39;t sit right<br>&gt;&gt;&gt;&gt; with me that MemoryLayout&lt;T&gt; and MemoryLayout.of(T.self) would be one and<br>&gt;&gt;&gt;&gt; the same thing.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Could I suggest an alternative? It&#39;s conservative in that it mimics the<br>&gt;&gt;&gt;&gt; relationships we had before the proposal was implemented and also maintains<br>&gt;&gt;&gt;&gt; the simplicity of the caseless enum:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; extension MemoryLayout {<br>&gt;&gt;&gt;&gt;   static func size(ofValue _: T) -&gt; Int { return MemoryLayout.size }<br>&gt;&gt;&gt;&gt;   // etc.<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; -- E<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160805/e89c1d1a/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
