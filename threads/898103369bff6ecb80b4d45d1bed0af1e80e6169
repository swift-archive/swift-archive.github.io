<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>February 14, 2016 at 08:00:00am</p></header><div class="content"><p>on Sun Feb 14 2016, David Hart &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I don’t really agree with Dave’s comments about removing ‘with&#39;, <br></p><p>When one road merges with another, both are changed.<br></p><p>&gt; but here’s one of mine – making the non-mutating difference an<br>&gt; override of intersection because it sounds clearer to me and is<br>&gt; consistent with the mutable versions being overrides:<br></p><p>I don&#39;t see any overrides around here.  Care to clarify?<br></p><p>&gt; Non-mutable<br>&gt;<br>&gt; let union = a.merged(with: b)<br>&gt; let intersection = a.members(in: b)<br>&gt; let difference = a.members(notIn: b)<br>&gt; let symmetricDifference = a.merged(with: b, removingMembersInCommon: true)<br>&gt;<br>&gt; Mutable (In-Place)<br>&gt;<br>&gt; a.merge(with: b) // union in-place<br>&gt; a.removeMembers(notIn: b) // intersect in-place<br>&gt; a.removeMembers(in: b)	// difference in-place<br>&gt; a.merge(with: b, removingMembersInCommon: true) // symmetric difference in-place<br>&gt;<br>&gt;&gt; On 14 Feb 2016, at 17:10, Dave Abrahams via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Sat Feb 13 2016, Ricardo Parada &lt;rparada-AT-mac.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Hi Dave,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would be okay with staying away from the mathematical terms similar<br>&gt;&gt;&gt; to what you are suggesting except that the union can still be made<br>&gt;&gt;&gt; more concise if you use merged / merge for the base name and shorten<br>&gt;&gt;&gt; the labels to a bare minimum without loosing clarity.  In addition,<br>&gt;&gt;&gt; the merge can have a second parameter with a default to false in order<br>&gt;&gt;&gt; to implement the symmetric difference (a.k.a. exclusive or).  Recall<br>&gt;&gt;&gt; that symmetric difference is the union of two sets and then removing<br>&gt;&gt;&gt; the intersection (or members in common).  I think it looks perfect<br>&gt;&gt;&gt; (concise and clear).  What does everybody else think?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Non-mutable<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let union = 			a.merged(with: b)<br>&gt;&gt;&gt; let intersection = 		a.members(in: b)<br>&gt;&gt;&gt; let difference = 		a.removingMembers(in: b)<br>&gt;&gt;&gt; let symmetricDifference = 	a.merged(with: b, removingMembersInCommon: true)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Mutable (In-Place)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; a.merge(with: b)		// union in-place<br>&gt;&gt;&gt; a.removeMembers(notIn: b)	// intersect in-place<br>&gt;&gt;&gt; a.removeMembers(in: b)		// difference in-place<br>&gt;&gt;&gt; a.merge(with: b, removeMembersInCommon: true)	// symmetric difference in-place<br>&gt;&gt; <br>&gt;&gt; I love your changes to my suggestion, Ricardo!  The minor alterations I<br>&gt;&gt; would make are:<br>&gt;&gt; <br>&gt;&gt; 1. In both cases the Bool parameter ought to be called<br>&gt;&gt;   “removingMembersInCommon”<br>&gt;&gt; <br>&gt;&gt; 2. I would remove “with” from the in-place merge operation.  We&#39;re<br>&gt;&gt;   really asking the receiver to merge b into itself.  “With” gives it<br>&gt;&gt;   the sense that it might almost be mutating b.<br>&gt;&gt; <br>&gt;&gt;&gt; Ricardo Parada<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 13, 2016, at 1:16 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Fri Feb 12 2016, Ricardo Parada &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I can’t make up my mind.  Let me propose two different alternatives<br>&gt;&gt;&gt;&gt;&gt; that I’m not sure if they have been considered:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ALTERNATIVE 1<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Non-mutable (noun-based)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -  func union(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt; +  func union(other: Self) -&gt; Self		Assumes union is a noun, i.e. not a verb<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -  func intersect(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt; +  func intersection(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -  func subtract(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt; +  func subtraction(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -  func exclusiveOr(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt; +  func symmetricSubtraction(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Mutable (verb-based)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -  mutating func unionInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt; +  mutating func unite(other: Self)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -  mutating func intersectInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt; +  mutating func intersect(other: Self)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -  mutating func subtractInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt; +  mutating func subtract(other: Self)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -  mutating func exclusiveOrInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt; +  mutating func symmetricSubtract(other: Self)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Comments: <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; With this alternative we keep the union name which I assume is<br>&gt;&gt;&gt;&gt;&gt; popular.  However, one has to accept unite as a verb (for the mutable<br>&gt;&gt;&gt;&gt;&gt; version) as I wanted all the mutable methods use verbs for<br>&gt;&gt;&gt;&gt;&gt; consistency.  I think unite is acceptable because it can be found in<br>&gt;&gt;&gt;&gt;&gt; the dictionary and it is a verb.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Notice that all the non-mutable methods use nouns: union,<br>&gt;&gt;&gt;&gt;&gt; intersection, subtraction and symmetricSubtraction.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I understand some may oppose to symmetricSubtraction saying that<br>&gt;&gt;&gt;&gt;&gt; symmetricSubraction is not as common as &quot;exclusive or&quot;.  However,<br>&gt;&gt;&gt;&gt;&gt; using symmetricSubtraction is consistent with subtraction and it hints<br>&gt;&gt;&gt;&gt;&gt; to a variation of the “subtraction&quot; operation.  We will get used to it<br>&gt;&gt;&gt;&gt;&gt; quickly / easily.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The mutable methods all use verbs:  unite, intersect, subtract and symmetricSubtract.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ALTERNATIVE 2<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Non-mutable<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -  func union(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt; +  func adding(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -  func intersect(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt; +  func intersecting(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -  func exclusiveOr(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt; +  func exclusiveOring(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -  func subtract(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt; +  func removing(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Mutable<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -  mutating func unionInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt; +  mutating func add(other: Self)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -  mutating func intersectInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt; +  mutating func intersect(other: Self)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -  mutating func exclusiveOrInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt; +  mutating func exclusiveOr(other: Self)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -  mutating func subtractInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt; +  mutating func remove(other: Self)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Comments: This alternative gives up on union in favor or add.  Many<br>&gt;&gt;&gt;&gt;&gt; may not like this, that is why I have it as the second alternative.<br>&gt;&gt;&gt;&gt;&gt; It brings back exclusiveOr and treats it as a verb.  Some may argue<br>&gt;&gt;&gt;&gt;&gt; that exclusiveOr is a noun for the &quot;exclusive or&quot; operation.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If we are going to force Set fit the naming guidelines, I would prefer<br>&gt;&gt;&gt;&gt; to stay away from the mathematical terms altogether.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  func insertingContentsOf(other: Self) -&gt; Self                 // union<br>&gt;&gt;&gt;&gt;  mutating func insertContentsOf(other)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  func members(in other: Self) -&gt; Self                           // intersection<br>&gt;&gt;&gt;&gt;  mutating func removeMembers(notIn: other)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  func removingMembersAndAddingNonMembers(in other: Self) -&gt; Self // symmetric difference<br>&gt;&gt;&gt;&gt;  mutating func removeMembersAndAddingNonMembers(in other: Self)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  func removingMembers(in other: Self) -&gt; Self                    // subtract<br>&gt;&gt;&gt;&gt;  mutating func removeMembers(in other: Self)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If it would help with clarity, we could replace &quot;in&quot; with &quot;foundIn&quot;<br>&gt;&gt;&gt;&gt; above.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>February 14, 2016 at 05:00:00pm</p></header><div class="content"><p>My vocabulary is probably not precise (and please correct me if so), but:<br></p><p>a.members(in: b)<br>a.members(notIn: b)<br></p><p>Are both overrides in my original message, because they use the same base name before the parentheses. I know that argument labels are part of the function signature. I was just trying to say that I find the code above more consistent because the mutating versions also share the same base name:<br></p><p>a.removeMembers(notIn: b)<br>a.removeMembers(in: b)<br></p><p>&gt; On 14 Feb 2016, at 17:39, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Sun Feb 14 2016, David Hart &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; I don’t really agree with Dave’s comments about removing ‘with&#39;, <br>&gt; <br>&gt; When one road merges with another, both are changed.<br>&gt; <br>&gt;&gt; but here’s one of mine – making the non-mutating difference an<br>&gt;&gt; override of intersection because it sounds clearer to me and is<br>&gt;&gt; consistent with the mutable versions being overrides:<br>&gt; <br>&gt; I don&#39;t see any overrides around here.  Care to clarify?<br>&gt; <br>&gt;&gt; Non-mutable<br>&gt;&gt; <br>&gt;&gt; let union = a.merged(with: b)<br>&gt;&gt; let intersection = a.members(in: b)<br>&gt;&gt; let difference = a.members(notIn: b)<br>&gt;&gt; let symmetricDifference = a.merged(with: b, removingMembersInCommon: true)<br>&gt;&gt; <br>&gt;&gt; Mutable (In-Place)<br>&gt;&gt; <br>&gt;&gt; a.merge(with: b) // union in-place<br>&gt;&gt; a.removeMembers(notIn: b) // intersect in-place<br>&gt;&gt; a.removeMembers(in: b)	// difference in-place<br>&gt;&gt; a.merge(with: b, removingMembersInCommon: true) // symmetric difference in-place<br>&gt;&gt; <br>&gt;&gt;&gt; On 14 Feb 2016, at 17:10, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Sat Feb 13 2016, Ricardo Parada &lt;rparada-AT-mac.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi Dave,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I would be okay with staying away from the mathematical terms similar<br>&gt;&gt;&gt;&gt; to what you are suggesting except that the union can still be made<br>&gt;&gt;&gt;&gt; more concise if you use merged / merge for the base name and shorten<br>&gt;&gt;&gt;&gt; the labels to a bare minimum without loosing clarity.  In addition,<br>&gt;&gt;&gt;&gt; the merge can have a second parameter with a default to false in order<br>&gt;&gt;&gt;&gt; to implement the symmetric difference (a.k.a. exclusive or).  Recall<br>&gt;&gt;&gt;&gt; that symmetric difference is the union of two sets and then removing<br>&gt;&gt;&gt;&gt; the intersection (or members in common).  I think it looks perfect<br>&gt;&gt;&gt;&gt; (concise and clear).  What does everybody else think?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Non-mutable<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let union = 			a.merged(with: b)<br>&gt;&gt;&gt;&gt; let intersection = 		a.members(in: b)<br>&gt;&gt;&gt;&gt; let difference = 		a.removingMembers(in: b)<br>&gt;&gt;&gt;&gt; let symmetricDifference = 	a.merged(with: b, removingMembersInCommon: true)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Mutable (In-Place)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; a.merge(with: b)		// union in-place<br>&gt;&gt;&gt;&gt; a.removeMembers(notIn: b)	// intersect in-place<br>&gt;&gt;&gt;&gt; a.removeMembers(in: b)		// difference in-place<br>&gt;&gt;&gt;&gt; a.merge(with: b, removeMembersInCommon: true)	// symmetric difference in-place<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I love your changes to my suggestion, Ricardo!  The minor alterations I<br>&gt;&gt;&gt; would make are:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. In both cases the Bool parameter ought to be called<br>&gt;&gt;&gt;  “removingMembersInCommon”<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2. I would remove “with” from the in-place merge operation.  We&#39;re<br>&gt;&gt;&gt;  really asking the receiver to merge b into itself.  “With” gives it<br>&gt;&gt;&gt;  the sense that it might almost be mutating b.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Ricardo Parada<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Feb 13, 2016, at 1:16 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Fri Feb 12 2016, Ricardo Parada &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I can’t make up my mind.  Let me propose two different alternatives<br>&gt;&gt;&gt;&gt;&gt;&gt; that I’m not sure if they have been considered:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ALTERNATIVE 1<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Non-mutable (noun-based)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -  func union(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt; +  func union(other: Self) -&gt; Self		Assumes union is a noun, i.e. not a verb<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -  func intersect(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt; +  func intersection(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -  func subtract(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt; +  func subtraction(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -  func exclusiveOr(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt; +  func symmetricSubtraction(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Mutable (verb-based)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func unionInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func unite(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func intersectInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func intersect(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func subtractInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func subtract(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func exclusiveOrInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func symmetricSubtract(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Comments: <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; With this alternative we keep the union name which I assume is<br>&gt;&gt;&gt;&gt;&gt;&gt; popular.  However, one has to accept unite as a verb (for the mutable<br>&gt;&gt;&gt;&gt;&gt;&gt; version) as I wanted all the mutable methods use verbs for<br>&gt;&gt;&gt;&gt;&gt;&gt; consistency.  I think unite is acceptable because it can be found in<br>&gt;&gt;&gt;&gt;&gt;&gt; the dictionary and it is a verb.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Notice that all the non-mutable methods use nouns: union,<br>&gt;&gt;&gt;&gt;&gt;&gt; intersection, subtraction and symmetricSubtraction.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I understand some may oppose to symmetricSubtraction saying that<br>&gt;&gt;&gt;&gt;&gt;&gt; symmetricSubraction is not as common as &quot;exclusive or&quot;.  However,<br>&gt;&gt;&gt;&gt;&gt;&gt; using symmetricSubtraction is consistent with subtraction and it hints<br>&gt;&gt;&gt;&gt;&gt;&gt; to a variation of the “subtraction&quot; operation.  We will get used to it<br>&gt;&gt;&gt;&gt;&gt;&gt; quickly / easily.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The mutable methods all use verbs:  unite, intersect, subtract and symmetricSubtract.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ALTERNATIVE 2<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Non-mutable<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -  func union(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt; +  func adding(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -  func intersect(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt; +  func intersecting(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -  func exclusiveOr(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt; +  func exclusiveOring(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -  func subtract(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt; +  func removing(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Mutable<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func unionInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func add(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func intersectInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func intersect(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func exclusiveOrInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func exclusiveOr(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func subtractInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func remove(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Comments: This alternative gives up on union in favor or add.  Many<br>&gt;&gt;&gt;&gt;&gt;&gt; may not like this, that is why I have it as the second alternative.<br>&gt;&gt;&gt;&gt;&gt;&gt; It brings back exclusiveOr and treats it as a verb.  Some may argue<br>&gt;&gt;&gt;&gt;&gt;&gt; that exclusiveOr is a noun for the &quot;exclusive or&quot; operation.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If we are going to force Set fit the naming guidelines, I would prefer<br>&gt;&gt;&gt;&gt;&gt; to stay away from the mathematical terms altogether.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func insertingContentsOf(other: Self) -&gt; Self                 // union<br>&gt;&gt;&gt;&gt;&gt; mutating func insertContentsOf(other)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func members(in other: Self) -&gt; Self                           // intersection<br>&gt;&gt;&gt;&gt;&gt; mutating func removeMembers(notIn: other)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func removingMembersAndAddingNonMembers(in other: Self) -&gt; Self // symmetric difference<br>&gt;&gt;&gt;&gt;&gt; mutating func removeMembersAndAddingNonMembers(in other: Self)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func removingMembers(in other: Self) -&gt; Self                    // subtract<br>&gt;&gt;&gt;&gt;&gt; mutating func removeMembers(in other: Self)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If it would help with clarity, we could replace &quot;in&quot; with &quot;foundIn&quot;<br>&gt;&gt;&gt;&gt;&gt; above.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160214/72ce0370/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>February 14, 2016 at 05:00:00pm</p></header><div class="content"><p>Hi David,<br></p><p>It had to read your code a few times to realize what you had changed. :-)  It&#39;s subtle and makes the names more consistent. I agree with your suggestion. <br></p><p>As for whether or not the &#39;with&#39; label should be removed from the mutable merge, I think it would work well either way.  However the code is more concise without it and still reads well. <br></p><p>Ricardo Parada<br></p><p><br>&gt; On Feb 14, 2016, at 11:52 AM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; a.members(notIn: b)<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160214/afc0ff57/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be4c3c3b76631a155e1358db48066692?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Tony Parker</string> &lt;anthony.parker at apple.com&gt;<p>February 14, 2016 at 04:00:00pm</p></header><div class="content"><p>Hi Ricardo,<br></p><p>Your idea for exclusiveOr as a default arg had a lot of appeal to me at first, but when I went to go try it I realized that it doesn’t appear to be possible to enforce a value for a default argument in a protocol (which is the root of the API we’re talking about, in SetAlgebraType).<br></p><p>All adopters of the protocol would be required to provide the default value in their implementation. It’s less than ideal to me to have each type that adopts the protocol decide what the default is, because a mistake would lead to confusing behavior:<br></p><p>var s1 = /// … some kind of SetAlgebraType, where func merge(other: Self, removingMembersInCommon: Bool  = true)<br>var s2 = /// … some other kind of SetAlgebraType, where func merge(other: Self, removingMembersInCommon: Bool  = false)<br></p><p>s1.merge(s2) // xor<br>s2.merge(s1) // union<br></p><p>It is possible to set the default in a protocol extension, but both union and exclusiveOr are abstract in today’s SetAlgebraType.<br></p><p>Of course the blame lies on the implementation of s1 here, but this approach does introduce a unique kind of sharp edge that we cannot warn about at compile time. I think that this is a consequence of putting something fundamental to the behavior of the method into an argument instead of into the base name.<br></p><p>Here is another idea that we are considering:<br></p><p>func intersected(other: Self) -&gt; Self // was: intersect<br>mutating func intersect(other: Self) // was: intersectInPlace<br>func invertedIntersection(other: Self) -&gt; Self // was: exclusiveOr<br>mutating func invertIntersection(other: Self) // was: exclusiveOrInPlace<br></p><p>- Tony<br></p><p>&gt; On Feb 14, 2016, at 2:36 PM, Ricardo Parada via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi David,<br>&gt; <br>&gt; It had to read your code a few times to realize what you had changed. :-)  It&#39;s subtle and makes the names more consistent. I agree with your suggestion. <br>&gt; <br>&gt; As for whether or not the &#39;with&#39; label should be removed from the mutable merge, I think it would work well either way.  However the code is more concise without it and still reads well. <br>&gt; <br>&gt; Ricardo Parada<br>&gt; <br>&gt; <br>&gt; On Feb 14, 2016, at 11:52 AM, David Hart via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; a.members(notIn: b)<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160214/bc83bb0a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>February 15, 2016 at 08:00:00pm</p></header><div class="content"><p>Hi Tony,<br></p><p>Is “inverted&quot; a well known term for sets? <br></p><p>If the default argument is a problem for protocols then perhaps this alternative:<br></p><p>Non-mutable (noun-based)<br></p><p>let union = 			a.union(b)<br>let intersection = 		a.intersection(b)<br>let difference = 		a.difference(b)<br>let symmetricDifference = 	a.symmetricDifference(b)	// alternative 1<br>let symmetricDifference =	a.intersectionComplement(b)	// alternative 2<br>let symmetricDifference = 	a.unionWithoutIntersection(b)	// alternative 3<br>let symmetricDifference = 	a.unionMinusIntersection(b)	// atternative 4<br></p><p>Mutable (verb-based)<br></p><p>set.merge(membersIn: someSet)			// union in-place<br>set.remove(membersNotIn: someSet)		// intersection in-place<br>set.remove(membersIn: someSet)			// difference in-place<br>set.merge(membersRemovingIntersection: someSet)	// symmetric difference in-place<br></p><p>I considered and discarded all the following for symmetric difference in-place:<br></p><p>set.merge(membersWithIntersectionRemoved: someSet)	// Not clear in my opinion<br>set.merge(membersRemovingIntersectionWith: someSet)	// The With seems not necessary<br>set.merge(removingMembersInCommonWith: someSet)		// Two verbs next to each other?<br>set.merge(allMembersRemovingIntersectionWith: someSet)	// Long and not more clear<br>set.merge(allRemovingMembersInCommon: someSet)		// All what?<br>set.merge(allMembersRemovingIntersection: someSet)	// Clear but longer<br>set.merge(membersRemovingIntersectionWith: someSet)	// With not necessary<br></p><p><br></p><p><br>&gt; On Feb 14, 2016, at 7:35 PM, Tony Parker &lt;anthony.parker at apple.com&gt; wrote:<br>&gt; <br>&gt; Hi Ricardo,<br>&gt; <br>&gt; Your idea for exclusiveOr as a default arg had a lot of appeal to me at first, but when I went to go try it I realized that it doesn’t appear to be possible to enforce a value for a default argument in a protocol (which is the root of the API we’re talking about, in SetAlgebraType).<br>&gt; <br>&gt; All adopters of the protocol would be required to provide the default value in their implementation. It’s less than ideal to me to have each type that adopts the protocol decide what the default is, because a mistake would lead to confusing behavior:<br>&gt; <br>&gt; var s1 = /// … some kind of SetAlgebraType, where func merge(other: Self, removingMembersInCommon: Bool  = true)<br>&gt; var s2 = /// … some other kind of SetAlgebraType, where func merge(other: Self, removingMembersInCommon: Bool  = false)<br>&gt; <br>&gt; s1.merge(s2) // xor<br>&gt; s2.merge(s1) // union<br>&gt; <br>&gt; It is possible to set the default in a protocol extension, but both union and exclusiveOr are abstract in today’s SetAlgebraType.<br>&gt; <br>&gt; Of course the blame lies on the implementation of s1 here, but this approach does introduce a unique kind of sharp edge that we cannot warn about at compile time. I think that this is a consequence of putting something fundamental to the behavior of the method into an argument instead of into the base name.<br>&gt; <br>&gt; Here is another idea that we are considering:<br>&gt; <br>&gt; func intersected(other: Self) -&gt; Self // was: intersect<br>&gt; mutating func intersect(other: Self) // was: intersectInPlace<br>&gt; func invertedIntersection(other: Self) -&gt; Self // was: exclusiveOr<br>&gt; mutating func invertIntersection(other: Self) // was: exclusiveOrInPlace<br>&gt; <br>&gt; - Tony<br>&gt; <br>&gt;&gt; On Feb 14, 2016, at 2:36 PM, Ricardo Parada via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi David,<br>&gt;&gt; <br>&gt;&gt; It had to read your code a few times to realize what you had changed. :-)  It&#39;s subtle and makes the names more consistent. I agree with your suggestion. <br>&gt;&gt; <br>&gt;&gt; As for whether or not the &#39;with&#39; label should be removed from the mutable merge, I think it would work well either way.  However the code is more concise without it and still reads well. <br>&gt;&gt; <br>&gt;&gt; Ricardo Parada<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Feb 14, 2016, at 11:52 AM, David Hart via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; a.members(notIn: b)<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160215/98fd4152/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>February 16, 2016 at 03:00:00am</p></header><div class="content"><p>As a drive by... I think the follow are a little more consistent with the<br>other names.<br></p><p>invertedIntersection &amp; invertedIntersect<br></p><p>On Mon, Feb 15, 2016 at 5:59 PM Ricardo Parada via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi Tony,<br>&gt;<br>&gt; Is “inverted&quot; a well known term for sets?<br>&gt;<br>&gt; If the default argument is a problem for protocols then perhaps this<br>&gt; alternative:<br>&gt;<br>&gt; *Non-mutable (noun-based)*<br>&gt;<br>&gt; let union = a.union(b)<br>&gt; let intersection = a.intersection(b)<br>&gt; let difference = a.difference(b)<br>&gt; let symmetricDifference = a.symmetricDifference(b) // alternative 1<br>&gt; let symmetricDifference = a.intersectionComplement(b) // alternative 2<br>&gt; let symmetricDifference =  a.unionWithoutIntersection(b) // alternative 3<br>&gt; let symmetricDifference = a.unionMinusIntersection(b) // atternative 4<br>&gt;<br>&gt;<br>&gt; *Mutable (verb-based)*<br>&gt;<br>&gt; set.merge(membersIn: someSet) // union in-place<br>&gt; set.remove(membersNotIn: someSet) // intersection in-place<br>&gt; set.remove(membersIn: someSet) // difference in-place<br>&gt; set.merge(membersRemovingIntersection: someSet) // symmetric difference<br>&gt; in-place<br>&gt;<br>&gt;<br>&gt; I considered and discarded all the following for symmetric difference<br>&gt; in-place:<br>&gt;<br>&gt; set.merge(membersWithIntersectionRemoved: someSet) // Not clear in my<br>&gt; opinion<br>&gt; set.merge(membersRemovingIntersectionWith: someSet) // The With seems not<br>&gt; necessary<br>&gt; set.merge(removingMembersInCommonWith: someSet) // Two verbs next to each<br>&gt; other?<br>&gt; set.merge(allMembersRemovingIntersectionWith: someSet) // Long and not<br>&gt; more clear<br>&gt; set.merge(allRemovingMembersInCommon: someSet) // All what?<br>&gt; set.merge(allMembersRemovingIntersection: someSet) // Clear but longer<br>&gt; set.merge(membersRemovingIntersectionWith: someSet) // With not necessary<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Feb 14, 2016, at 7:35 PM, Tony Parker &lt;anthony.parker at apple.com&gt; wrote:<br>&gt;<br>&gt; Hi Ricardo,<br>&gt;<br>&gt; Your idea for exclusiveOr as a default arg had a lot of appeal to me at<br>&gt; first, but when I went to go try it I realized that it doesn’t appear to be<br>&gt; possible to enforce a value for a default argument in a protocol (which is<br>&gt; the root of the API we’re talking about, in SetAlgebraType).<br>&gt;<br>&gt; All adopters of the protocol would be required to provide the default<br>&gt; value in their implementation. It’s less than ideal to me to have each type<br>&gt; that adopts the protocol decide what the default is, because a mistake<br>&gt; would lead to confusing behavior:<br>&gt;<br>&gt; var s1 = /// … some kind of SetAlgebraType, where func merge(other: Self,<br>&gt; removingMembersInCommon: Bool  = true)<br>&gt; var s2 = /// … some other kind of SetAlgebraType, where func merge(other:<br>&gt; Self, removingMembersInCommon: Bool  = false)<br>&gt;<br>&gt; s1.merge(s2) // xor<br>&gt; s2.merge(s1) // union<br>&gt;<br>&gt; It is possible to set the default in a protocol extension, but both union<br>&gt; and exclusiveOr are abstract in today’s SetAlgebraType.<br>&gt;<br>&gt; Of course the blame lies on the implementation of s1 here, but this<br>&gt; approach does introduce a unique kind of sharp edge that we cannot warn<br>&gt; about at compile time. I think that this is a consequence of putting<br>&gt; something fundamental to the behavior of the method into an argument<br>&gt; instead of into the base name.<br>&gt;<br>&gt; Here is another idea that we are considering:<br>&gt;<br>&gt; func intersected(other: Self) -&gt; Self // was: intersect<br>&gt; mutating func intersect(other: Self) // was: intersectInPlace<br>&gt; func invertedIntersection(other: Self) -&gt; Self // was: exclusiveOr<br>&gt; mutating func invertIntersection(other: Self) // was: exclusiveOrInPlace<br>&gt;<br>&gt; - Tony<br>&gt;<br>&gt; On Feb 14, 2016, at 2:36 PM, Ricardo Parada via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Hi David,<br>&gt;<br>&gt; It had to read your code a few times to realize what you had changed. :-)<br>&gt;  It&#39;s subtle and makes the names more consistent. I agree with your<br>&gt; suggestion.<br>&gt;<br>&gt; As for whether or not the &#39;with&#39; label should be removed from the mutable<br>&gt; merge, I think it would work well either way.  However the code is more<br>&gt; concise without it and still reads well.<br>&gt;<br>&gt; Ricardo Parada<br>&gt;<br>&gt;<br>&gt; On Feb 14, 2016, at 11:52 AM, David Hart via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; a.members(notIn: b)<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160216/0090eb7e/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>February 14, 2016 at 11:00:00pm</p></header><div class="content"><p>Yes, one stops being used - i.e. ends it useful cycle… while the other contains all the cars.<br></p><p>&gt; On 2016-02-14, at 23:39:31, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Sun Feb 14 2016, David Hart &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; I don’t really agree with Dave’s comments about removing ‘with&#39;, <br>&gt; <br>&gt; When one road merges with another, both are changed.<br>&gt; <br>&gt;&gt; but here’s one of mine – making the non-mutating difference an<br>&gt;&gt; override of intersection because it sounds clearer to me and is<br>&gt;&gt; consistent with the mutable versions being overrides:<br>&gt; <br>&gt; I don&#39;t see any overrides around here.  Care to clarify?<br>&gt; <br>&gt;&gt; Non-mutable<br>&gt;&gt; <br>&gt;&gt; let union = a.merged(with: b)<br>&gt;&gt; let intersection = a.members(in: b)<br>&gt;&gt; let difference = a.members(notIn: b)<br>&gt;&gt; let symmetricDifference = a.merged(with: b, removingMembersInCommon: true)<br>&gt;&gt; <br>&gt;&gt; Mutable (In-Place)<br>&gt;&gt; <br>&gt;&gt; a.merge(with: b) // union in-place<br>&gt;&gt; a.removeMembers(notIn: b) // intersect in-place<br>&gt;&gt; a.removeMembers(in: b)	// difference in-place<br>&gt;&gt; a.merge(with: b, removingMembersInCommon: true) // symmetric difference in-place<br>&gt;&gt; <br>&gt;&gt;&gt; On 14 Feb 2016, at 17:10, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Sat Feb 13 2016, Ricardo Parada &lt;rparada-AT-mac.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi Dave,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I would be okay with staying away from the mathematical terms similar<br>&gt;&gt;&gt;&gt; to what you are suggesting except that the union can still be made<br>&gt;&gt;&gt;&gt; more concise if you use merged / merge for the base name and shorten<br>&gt;&gt;&gt;&gt; the labels to a bare minimum without loosing clarity.  In addition,<br>&gt;&gt;&gt;&gt; the merge can have a second parameter with a default to false in order<br>&gt;&gt;&gt;&gt; to implement the symmetric difference (a.k.a. exclusive or).  Recall<br>&gt;&gt;&gt;&gt; that symmetric difference is the union of two sets and then removing<br>&gt;&gt;&gt;&gt; the intersection (or members in common).  I think it looks perfect<br>&gt;&gt;&gt;&gt; (concise and clear).  What does everybody else think?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Non-mutable<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let union = 			a.merged(with: b)<br>&gt;&gt;&gt;&gt; let intersection = 		a.members(in: b)<br>&gt;&gt;&gt;&gt; let difference = 		a.removingMembers(in: b)<br>&gt;&gt;&gt;&gt; let symmetricDifference = 	a.merged(with: b, removingMembersInCommon: true)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Mutable (In-Place)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; a.merge(with: b)		// union in-place<br>&gt;&gt;&gt;&gt; a.removeMembers(notIn: b)	// intersect in-place<br>&gt;&gt;&gt;&gt; a.removeMembers(in: b)		// difference in-place<br>&gt;&gt;&gt;&gt; a.merge(with: b, removeMembersInCommon: true)	// symmetric difference in-place<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I love your changes to my suggestion, Ricardo!  The minor alterations I<br>&gt;&gt;&gt; would make are:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. In both cases the Bool parameter ought to be called<br>&gt;&gt;&gt;  “removingMembersInCommon”<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2. I would remove “with” from the in-place merge operation.  We&#39;re<br>&gt;&gt;&gt;  really asking the receiver to merge b into itself.  “With” gives it<br>&gt;&gt;&gt;  the sense that it might almost be mutating b.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Ricardo Parada<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Feb 13, 2016, at 1:16 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Fri Feb 12 2016, Ricardo Parada &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I can’t make up my mind.  Let me propose two different alternatives<br>&gt;&gt;&gt;&gt;&gt;&gt; that I’m not sure if they have been considered:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ALTERNATIVE 1<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Non-mutable (noun-based)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -  func union(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt; +  func union(other: Self) -&gt; Self		Assumes union is a noun, i.e. not a verb<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -  func intersect(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt; +  func intersection(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -  func subtract(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt; +  func subtraction(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -  func exclusiveOr(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt; +  func symmetricSubtraction(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Mutable (verb-based)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func unionInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func unite(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func intersectInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func intersect(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func subtractInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func subtract(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func exclusiveOrInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func symmetricSubtract(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Comments: <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; With this alternative we keep the union name which I assume is<br>&gt;&gt;&gt;&gt;&gt;&gt; popular.  However, one has to accept unite as a verb (for the mutable<br>&gt;&gt;&gt;&gt;&gt;&gt; version) as I wanted all the mutable methods use verbs for<br>&gt;&gt;&gt;&gt;&gt;&gt; consistency.  I think unite is acceptable because it can be found in<br>&gt;&gt;&gt;&gt;&gt;&gt; the dictionary and it is a verb.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Notice that all the non-mutable methods use nouns: union,<br>&gt;&gt;&gt;&gt;&gt;&gt; intersection, subtraction and symmetricSubtraction.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I understand some may oppose to symmetricSubtraction saying that<br>&gt;&gt;&gt;&gt;&gt;&gt; symmetricSubraction is not as common as &quot;exclusive or&quot;.  However,<br>&gt;&gt;&gt;&gt;&gt;&gt; using symmetricSubtraction is consistent with subtraction and it hints<br>&gt;&gt;&gt;&gt;&gt;&gt; to a variation of the “subtraction&quot; operation.  We will get used to it<br>&gt;&gt;&gt;&gt;&gt;&gt; quickly / easily.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The mutable methods all use verbs:  unite, intersect, subtract and symmetricSubtract.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ALTERNATIVE 2<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Non-mutable<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -  func union(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt; +  func adding(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -  func intersect(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt; +  func intersecting(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -  func exclusiveOr(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt; +  func exclusiveOring(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -  func subtract(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt; +  func removing(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Mutable<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func unionInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func add(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func intersectInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func intersect(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func exclusiveOrInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func exclusiveOr(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func subtractInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func remove(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Comments: This alternative gives up on union in favor or add.  Many<br>&gt;&gt;&gt;&gt;&gt;&gt; may not like this, that is why I have it as the second alternative.<br>&gt;&gt;&gt;&gt;&gt;&gt; It brings back exclusiveOr and treats it as a verb.  Some may argue<br>&gt;&gt;&gt;&gt;&gt;&gt; that exclusiveOr is a noun for the &quot;exclusive or&quot; operation.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If we are going to force Set fit the naming guidelines, I would prefer<br>&gt;&gt;&gt;&gt;&gt; to stay away from the mathematical terms altogether.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func insertingContentsOf(other: Self) -&gt; Self                 // union<br>&gt;&gt;&gt;&gt;&gt; mutating func insertContentsOf(other)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func members(in other: Self) -&gt; Self                           // intersection<br>&gt;&gt;&gt;&gt;&gt; mutating func removeMembers(notIn: other)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func removingMembersAndAddingNonMembers(in other: Self) -&gt; Self // symmetric difference<br>&gt;&gt;&gt;&gt;&gt; mutating func removeMembersAndAddingNonMembers(in other: Self)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func removingMembers(in other: Self) -&gt; Self                    // subtract<br>&gt;&gt;&gt;&gt;&gt; mutating func removeMembers(in other: Self)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If it would help with clarity, we could replace &quot;in&quot; with &quot;foundIn&quot;<br>&gt;&gt;&gt;&gt;&gt; above.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160214/45c13451/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
