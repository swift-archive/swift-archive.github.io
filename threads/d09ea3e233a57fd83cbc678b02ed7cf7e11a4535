<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bce64da43e291f2ce30987a83780502c?s=50"></div><header><strong>[Pitch] Add toplevel keyword for protocols</strong> from <string>Patrick Pijnappel</string> &lt;patrickpijnappel at gmail.com&gt;<p>May 13, 2016 at 09:00:00am</p></header><div class="content"><p>For some protocols we&#39;d like to require top-level (free) functions, e.g.<br>for many math functions such as abs() or sin(). We already do this<br>implicitly for operators.<br></p><p>*Proposal*<br>Allow top-level function/property requirements in protocols, e.g.:<br></p><p>public protocol AbsoluteValuable : SignedNumber { /// Returns the absolute<br>value of `x`. @warn_unused_result toplevel func abs(_ x: Self) -&gt; Self }<br></p><p>We&#39;d probably want to require this for operators. This also opens up syntax<br>if we ever get dynamically dispatched operators.<br></p><p><br>public protocol SignedNumber : Comparable, IntegerLiteralConvertible { ///<br>Returns the result of negating `x`. @warn_unused_result toplevel prefix func<br>- (x: Self) -&gt; Self }<br></p><p>Currently this is done using the combination of a static method and a<br>top-level generic function on that protocol. As I understand that approach<br>does have some benefits in terms of type-checker performance, though I&#39;m<br>not sure whether that is likely to stay relevant in the future.<br></p><p>*Advantages*<br></p><p>   - Cleaner than current approach (esp. floating point types have tons of<br>   top-level functions)<br>   - Makes operators less of a special case<br>   - Opens up syntax for member operators<br>   - Could also apply to top-level properties (esp. useful if we get<br>   generic properties, for e.g. π&lt;...&gt;)<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/d09e4535/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[Pitch] Add toplevel keyword for protocols</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>May 13, 2016 at 01:00:00pm</p></header><div class="content"><p>To me this makes more sense for operators than for other functions or<br>properties. For the former you could create conflict with previously<br>declared function (or properties with variables) and there is no<br>restriction in Swift that says you cannot or should not create a top level<br>function or property.<br></p><p>In this sense, having an operator declared inside a class/struct/enum would<br>already make them top level as you proposed, no need for another keyword. I<br>would only add one requirement: that the first argument should always be of<br>type Self (and have it checked by the compiler). It ensures the operator<br>operates on that type and helps minimising conflicts with a previously<br>declared operator.<br></p><p>- Leonardo<br></p><p>On 13 May 2016 at 04:12, Patrick Pijnappel via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; For some protocols we&#39;d like to require top-level (free) functions, e.g.<br>&gt; for many math functions such as abs() or sin(). We already do this<br>&gt; implicitly for operators.<br>&gt;<br>&gt; *Proposal*<br>&gt; Allow top-level function/property requirements in protocols, e.g.:<br>&gt;<br>&gt; public protocol AbsoluteValuable : SignedNumber { /// Returns the<br>&gt; absolute value of `x`. @warn_unused_result toplevel func abs(_ x: Self) -&gt;<br>&gt; Self }<br>&gt;<br>&gt; We&#39;d probably want to require this for operators. This also opens up<br>&gt; syntax if we ever get dynamically dispatched operators.<br>&gt;<br>&gt;<br>&gt; public protocol SignedNumber : Comparable, IntegerLiteralConvertible { ///<br>&gt; Returns the result of negating `x`. @warn_unused_result toplevel prefix<br>&gt; func - (x: Self) -&gt; Self }<br>&gt;<br>&gt; Currently this is done using the combination of a static method and a<br>&gt; top-level generic function on that protocol. As I understand that approach<br>&gt; does have some benefits in terms of type-checker performance, though I&#39;m<br>&gt; not sure whether that is likely to stay relevant in the future.<br>&gt;<br>&gt; *Advantages*<br>&gt;<br>&gt;    - Cleaner than current approach (esp. floating point types have tons<br>&gt;    of top-level functions)<br>&gt;    - Makes operators less of a special case<br>&gt;    - Opens up syntax for member operators<br>&gt;    - Could also apply to top-level properties (esp. useful if we get<br>&gt;    generic properties, for e.g. π&lt;...&gt;)<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/fc76c7e4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bce64da43e291f2ce30987a83780502c?s=50"></div><header><strong>[Pitch] Add toplevel keyword for protocols</strong> from <string>Patrick Pijnappel</string> &lt;patrickpijnappel at gmail.com&gt;<p>May 14, 2016 at 08:00:00am</p></header><div class="content"><p>Hmm good point. Defining a toplevel function or property could reserve that<br>name in toplevel scope, but you&#39;d be in trouble when two protocols from<br>different modules require a toplevel function or property with the same<br>signature.<br></p><p>I&#39;m not sure how operators deal with this because they should have the<br>same problem...<br></p><p>On Friday, 13 May 2016, Leonardo Pessoa via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; To me this makes more sense for operators than for other functions or<br>&gt; properties. For the former you could create conflict with previously<br>&gt; declared function (or properties with variables) and there is no<br>&gt; restriction in Swift that says you cannot or should not create a top level<br>&gt; function or property.<br>&gt;<br>&gt; In this sense, having an operator declared inside a class/struct/enum<br>&gt; would already make them top level as you proposed, no need for another<br>&gt; keyword. I would only add one requirement: that the first argument should<br>&gt; always be of type Self (and have it checked by the compiler). It ensures<br>&gt; the operator operates on that type and helps minimising conflicts with a<br>&gt; previously declared operator.<br>&gt;<br>&gt; - Leonardo<br>&gt;<br>&gt; On 13 May 2016 at 04:12, Patrick Pijnappel via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt;&gt; For some protocols we&#39;d like to require top-level (free) functions, e.g.<br>&gt;&gt; for many math functions such as abs() or sin(). We already do this<br>&gt;&gt; implicitly for operators.<br>&gt;&gt;<br>&gt;&gt; *Proposal*<br>&gt;&gt; Allow top-level function/property requirements in protocols, e.g.:<br>&gt;&gt;<br>&gt;&gt; public protocol AbsoluteValuable : SignedNumber { /// Returns the<br>&gt;&gt; absolute value of `x`. @warn_unused_result toplevel func abs(_ x: Self)<br>&gt;&gt; -&gt; Self }<br>&gt;&gt;<br>&gt;&gt; We&#39;d probably want to require this for operators. This also opens up<br>&gt;&gt; syntax if we ever get dynamically dispatched operators.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; public protocol SignedNumber : Comparable, IntegerLiteralConvertible { ///<br>&gt;&gt; Returns the result of negating `x`. @warn_unused_result toplevel prefix<br>&gt;&gt; func - (x: Self) -&gt; Self }<br>&gt;&gt;<br>&gt;&gt; Currently this is done using the combination of a static method and a<br>&gt;&gt; top-level generic function on that protocol. As I understand that approach<br>&gt;&gt; does have some benefits in terms of type-checker performance, though I&#39;m<br>&gt;&gt; not sure whether that is likely to stay relevant in the future.<br>&gt;&gt;<br>&gt;&gt; *Advantages*<br>&gt;&gt;<br>&gt;&gt;    - Cleaner than current approach (esp. floating point types have tons<br>&gt;&gt;    of top-level functions)<br>&gt;&gt;    - Makes operators less of a special case<br>&gt;&gt;    - Opens up syntax for member operators<br>&gt;&gt;    - Could also apply to top-level properties (esp. useful if we get<br>&gt;&gt;    generic properties, for e.g. π&lt;...&gt;)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160514/3d5e9697/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[Pitch] Add toplevel keyword for protocols</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>May 14, 2016 at 10:00:00am</p></header><div class="content"><p>Operators will overload the function with new arguments. That&#39;s why I<br>suggested this change in syntax only for operators and force them to have<br>the first argument or the type Self.<br></p><p>- Leonardo<br></p><p>On 14 May 2016 at 03:39, Patrick Pijnappel via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hmm good point. Defining a toplevel function or property could reserve<br>&gt; that name in toplevel scope, but you&#39;d be in trouble when two protocols<br>&gt; from different modules require a toplevel function or property with the<br>&gt; same signature.<br>&gt;<br>&gt; I&#39;m not sure how operators deal with this because they should have the<br>&gt; same problem...<br>&gt;<br>&gt; On Friday, 13 May 2016, Leonardo Pessoa via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; To me this makes more sense for operators than for other functions or<br>&gt;&gt; properties. For the former you could create conflict with previously<br>&gt;&gt; declared function (or properties with variables) and there is no<br>&gt;&gt; restriction in Swift that says you cannot or should not create a top level<br>&gt;&gt; function or property.<br>&gt;&gt;<br>&gt;&gt; In this sense, having an operator declared inside a class/struct/enum<br>&gt;&gt; would already make them top level as you proposed, no need for another<br>&gt;&gt; keyword. I would only add one requirement: that the first argument should<br>&gt;&gt; always be of type Self (and have it checked by the compiler). It ensures<br>&gt;&gt; the operator operates on that type and helps minimising conflicts with a<br>&gt;&gt; previously declared operator.<br>&gt;&gt;<br>&gt;&gt; - Leonardo<br>&gt;&gt;<br>&gt;&gt; On 13 May 2016 at 04:12, Patrick Pijnappel via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; For some protocols we&#39;d like to require top-level (free) functions, e.g.<br>&gt;&gt;&gt; for many math functions such as abs() or sin(). We already do this<br>&gt;&gt;&gt; implicitly for operators.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *Proposal*<br>&gt;&gt;&gt; Allow top-level function/property requirements in protocols, e.g.:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; public protocol AbsoluteValuable : SignedNumber { /// Returns the<br>&gt;&gt;&gt; absolute value of `x`. @warn_unused_result toplevel func abs(_ x: Self)<br>&gt;&gt;&gt; -&gt; Self }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; We&#39;d probably want to require this for operators. This also opens up<br>&gt;&gt;&gt; syntax if we ever get dynamically dispatched operators.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; public protocol SignedNumber : Comparable, IntegerLiteralConvertible { ///<br>&gt;&gt;&gt; Returns the result of negating `x`. @warn_unused_result toplevel prefix<br>&gt;&gt;&gt; func - (x: Self) -&gt; Self }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Currently this is done using the combination of a static method and a<br>&gt;&gt;&gt; top-level generic function on that protocol. As I understand that approach<br>&gt;&gt;&gt; does have some benefits in terms of type-checker performance, though I&#39;m<br>&gt;&gt;&gt; not sure whether that is likely to stay relevant in the future.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *Advantages*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    - Cleaner than current approach (esp. floating point types have tons<br>&gt;&gt;&gt;    of top-level functions)<br>&gt;&gt;&gt;    - Makes operators less of a special case<br>&gt;&gt;&gt;    - Opens up syntax for member operators<br>&gt;&gt;&gt;    - Could also apply to top-level properties (esp. useful if we get<br>&gt;&gt;&gt;    generic properties, for e.g. π&lt;...&gt;)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160514/74c2c659/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Pitch] Add toplevel keyword for protocols</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 14, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On May 13, 2016, at 12:12 AM, Patrick Pijnappel via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; For some protocols we&#39;d like to require top-level (free) functions, e.g. for many math functions such as abs() or sin(). We already do this implicitly for operators. <br></p><p>Hi Patrick,<br></p><p>FYI, we’re very likely to remove this special behavior for operators, by making operator requirements only find operators declared in a conforming type.  This would eliminate the special case for operators that exists now, and has other advantages as well.  Check out this proposal for more information:<br>https://github.com/apple/swift-evolution/blob/master/proposals/0091-improving-operators-in-protocols.md<br></p><p>-Chris<br></p><p>&gt; <br>&gt; Proposal<br>&gt; Allow top-level function/property requirements in protocols, e.g.:<br>&gt; <br>&gt; public protocol AbsoluteValuable : SignedNumber {<br>&gt;   /// Returns the absolute value of `x`.<br>&gt;   @warn_unused_result<br>&gt;   toplevel func abs(_ x: Self) -&gt; Self<br>&gt; }<br>&gt; <br>&gt; We&#39;d probably want to require this for operators. This also opens up syntax if we ever get dynamically dispatched operators.<br>&gt; <br>&gt; public protocol SignedNumber : Comparable, IntegerLiteralConvertible {<br>&gt;   /// Returns the result of negating `x`.<br>&gt;   @warn_unused_result<br>&gt;   toplevel prefix func - (x: Self) -&gt; Self<br>&gt; }<br>&gt; <br>&gt; Currently this is done using the combination of a static method and a top-level generic function on that protocol. As I understand that approach does have some benefits in terms of type-checker performance, though I&#39;m not sure whether that is likely to stay relevant in the future.<br>&gt; <br>&gt; Advantages<br>&gt; Cleaner than current approach (esp. floating point types have tons of top-level functions)<br>&gt; Makes operators less of a special case<br>&gt; Opens up syntax for member operators<br>&gt; Could also apply to top-level properties (esp. useful if we get generic properties, for e.g. π&lt;...&gt;)<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160514/64e3b04b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bce64da43e291f2ce30987a83780502c?s=50"></div><header><strong>[Pitch] Add toplevel keyword for protocols</strong> from <string>Patrick Pijnappel</string> &lt;patrickpijnappel at gmail.com&gt;<p>May 16, 2016 at 08:00:00am</p></header><div class="content"><p>&gt;<br>&gt; Hi Patrick,<br>&gt; FYI, we’re very likely to remove this special behavior for operators, by<br>&gt; making operator requirements only find operators declared in a conforming<br>&gt; type.  This would eliminate the special case for operators that exists now,<br>&gt; and has other advantages as well.  Check out this proposal for more<br>&gt; information:<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0091-improving-operators-in-protocols.md<br></p><p><br>Thanks, hadn&#39;t seen that one yet! Looks like a good solution.<br></p><p>On Sun, May 15, 2016 at 7:10 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On May 13, 2016, at 12:12 AM, Patrick Pijnappel via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; For some protocols we&#39;d like to require top-level (free) functions, e.g.<br>&gt; for many math functions such as abs() or sin(). We already do this<br>&gt; implicitly for operators.<br>&gt;<br>&gt;<br>&gt; Hi Patrick,<br>&gt;<br>&gt; FYI, we’re very likely to remove this special behavior for operators, by<br>&gt; making operator requirements only find operators declared in a conforming<br>&gt; type.  This would eliminate the special case for operators that exists now,<br>&gt; and has other advantages as well.  Check out this proposal for more<br>&gt; information:<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0091-improving-operators-in-protocols.md<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>&gt; *Proposal*<br>&gt; Allow top-level function/property requirements in protocols, e.g.:<br>&gt;<br>&gt; public protocol AbsoluteValuable : SignedNumber { /// Returns the<br>&gt; absolute value of `x`. @warn_unused_result toplevel func abs(_ x: Self) -&gt;<br>&gt; Self }<br>&gt;<br>&gt; We&#39;d probably want to require this for operators. This also opens up<br>&gt; syntax if we ever get dynamically dispatched operators.<br>&gt;<br>&gt; public protocol SignedNumber : Comparable, IntegerLiteralConvertible { ///<br>&gt; Returns the result of negating `x`. @warn_unused_result toplevel prefix<br>&gt; func - (x: Self) -&gt; Self }<br>&gt;<br>&gt; Currently this is done using the combination of a static method and a<br>&gt; top-level generic function on that protocol. As I understand that approach<br>&gt; does have some benefits in terms of type-checker performance, though I&#39;m<br>&gt; not sure whether that is likely to stay relevant in the future.<br>&gt;<br>&gt; *Advantages*<br>&gt;<br>&gt;    - Cleaner than current approach (esp. floating point types have tons<br>&gt;    of top-level functions)<br>&gt;    - Makes operators less of a special case<br>&gt;    - Opens up syntax for member operators<br>&gt;    - Could also apply to top-level properties (esp. useful if we get<br>&gt;    generic properties, for e.g. π&lt;...&gt;)<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160516/ced49c18/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
