<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/421f5b513b7d921519635cd23d723191?s=50"></div><header><strong>[Pitch] Add namespacing to associatedTypes</strong> from <string>Noah Blake</string> &lt;nononoah at gmail.com&gt;<p>April  5, 2016 at 12:00:00pm</p></header><div class="content"><p>Types associated with a protocol are not namespaced by the protocol, but<br>rather by the protocol&#39;s adopters. As such, when two protocols declare a<br>common associatedType, adoption of those protocols introduces undesirable<br>ambiguity.<br></p><p>Given the understandable propensity of developers to arrive at similarly<br>named types (T, for example), it is likely that this problem will reduce<br>the compatibility of packages for reasons that may not be entirely clear to<br>the package consumer.<br></p><p>Here is a demonstration of the issue. Apologies, I&#39;m a longtime reader of<br>the list, but this is my first time posting, and I&#39;m not sure how best to<br>format this. You may also find this example on Jira (<br>https://bugs.swift.org/browse/SR-1065).<br></p><p>```<br>protocol A {<br>    associatedtype T<br>    var aT: T { get }<br>}<br></p><p>protocol B {<br>    associatedtype T<br>    var bT: T { get }<br>}<br>```<br></p><p>T is ambiguous: &quot;Type C does not conform to protocol &#39;B&#39;.&quot;<br>```<br>class C: A, B {<br>    var aT = String()<br>    var bT = Int()<br>}<br>```<br></p><p><br>T is inferred unambiguously, compiles without error.<br>```<br>class C: A, B {<br>    var aT = String()<br>    var bT = String()<br>}<br>```<br></p><p>T is explicit, but problematic: &quot;Type C does not conform to protocol &#39;A&#39;.&quot;<br>```<br>class C: A, B {<br>    typealias T = Int<br>    var aT = String()<br>    var bT = Int()<br>}<br>```<br></p><p>I would greatly appreciate any advice or direction as to next steps. I have<br>a proposal for resolving this in mind, but it seemed premature to offer it<br>before finding some agreement that this was worth carrying forward.<br></p><p>Best regards,<br>Noah Blake<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160405/825061d8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6d3081a5b9c408dfecc2681ab82af734?s=50"></div><header><strong>[Pitch] Add namespacing to associatedTypes</strong> from <string>Milos Rankovic</string> &lt;milos at milos-and-slavica.net&gt;<p>April  5, 2016 at 06:00:00pm</p></header><div class="content"><p>I agree that this is counterintuitive behaviour and should ideally be changed to match things like:<br></p><p>    func f &lt;T&gt; (_: T.Type) {}<br>    func f2 &lt;T&gt; (_: T.Type) {}<br></p><p>    f(Int)<br>    f2(String)<br></p><p>milos<br></p><p>&gt; On 5 Apr 2016, at 17:16, Noah Blake via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Types associated with a protocol are not namespaced by the protocol, but rather by the protocol&#39;s adopters. As such, when two protocols declare a common associatedType, adoption of those protocols introduces undesirable ambiguity.<br>&gt; <br>&gt; Given the understandable propensity of developers to arrive at similarly named types (T, for example), it is likely that this problem will reduce the compatibility of packages for reasons that may not be entirely clear to the package consumer.<br>&gt; <br>&gt; Here is a demonstration of the issue. Apologies, I&#39;m a longtime reader of the list, but this is my first time posting, and I&#39;m not sure how best to format this. You may also find this example on Jira (https://bugs.swift.org/browse/SR-1065 &lt;https://bugs.swift.org/browse/SR-1065&gt;).<br>&gt; <br>&gt; ```<br>&gt; protocol A {<br>&gt;     associatedtype T<br>&gt;     var aT: T { get }<br>&gt; }<br>&gt; <br>&gt; protocol B {<br>&gt;     associatedtype T<br>&gt;     var bT: T { get }<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; T is ambiguous: &quot;Type C does not conform to protocol &#39;B&#39;.&quot;<br>&gt; ```<br>&gt; class C: A, B {<br>&gt;     var aT = String()<br>&gt;     var bT = Int()<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; <br>&gt; T is inferred unambiguously, compiles without error.<br>&gt; ```<br>&gt; class C: A, B {<br>&gt;     var aT = String()<br>&gt;     var bT = String()<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; T is explicit, but problematic: &quot;Type C does not conform to protocol &#39;A&#39;.&quot;<br>&gt; ```<br>&gt; class C: A, B {<br>&gt;     typealias T = Int<br>&gt;     var aT = String()<br>&gt;     var bT = Int()<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; I would greatly appreciate any advice or direction as to next steps. I have a proposal for resolving this in mind, but it seemed premature to offer it before finding some agreement that this was worth carrying forward.<br>&gt; <br>&gt; Best regards,<br>&gt; Noah Blake<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160405/b02670a1/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Pitch] Add namespacing to associatedTypes</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April  5, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; Types associated with a protocol are not namespaced by the protocol, but rather by the protocol&#39;s adopters. As such, when two protocols declare a common associatedType, adoption of those protocols introduces undesirable ambiguity.<br></p><p>I don&#39;t think there&#39;s much of a point solving this just for associated types. The same issue exists for all protocol requirements.<br></p><p>&gt; Given the understandable propensity of developers to arrive at similarly named types (T, for example), it is likely that this problem will reduce the compatibility of packages for reasons that may not be entirely clear to the package consumer.<br></p><p>Then don&#39;t do that. Absurdly short associated/generic type names are like absurdly short variable or function names—they&#39;re okay in a very small context like a short function or a single loop, but a bad idea in a wider context. That&#39;s why the Swift 2 standard library moved away from using short names like `T` in generic types like Array and Optional.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/421f5b513b7d921519635cd23d723191?s=50"></div><header><strong>[Pitch] Add namespacing to associatedTypes</strong> from <string>Noah Blake</string> &lt;nononoah at gmail.com&gt;<p>April  6, 2016 at 06:00:00am</p></header><div class="content"><p>&gt;<br>&gt; I don&#39;t think there&#39;s much of a point solving this just for associated<br>&gt; types. The same issue exists for all protocol requirements.<br></p><p><br>True enough. The one difference worth noting, however, is that there&#39;s no<br>way to address the ambiguity of identical protocol requirements without<br>adding syntactical overhead. In the case of associatedtype inferencing,<br>however, it should be possible.<br></p><p>Then don&#39;t do that. Absurdly short associated/generic type names are like<br>&gt; absurdly short variable or function names—they&#39;re okay in a very small<br>&gt; context like a short function or a single loop, but a bad idea in a wider<br>&gt; context. That&#39;s why the Swift 2 standard library moved away from using<br>&gt; short names like `T` in generic types like Array and Optional.<br></p><p>While this may be a bit orthogonal, it&#39;s worth noting that the standard<br>library has increased its usage of T over the past month. Right now, it<br>contains 3932 occurrences of &lt;T&gt;. Plenty of these usages are type-scoped.<br>To your point, there are only 46 occurrences of &quot;associatedtype T&quot;.<br></p><p>Regardless, there are plenty of longer, arguably better associatedtype<br>names that writers of different packages may commonly reach for. &quot;Element&quot;<br>may be known to be somewhat off limits, but it is representative of this<br>category.<br></p><p>On Wed, Apr 6, 2016 at 1:45 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>wrote:<br></p><p>&gt; &gt; Types associated with a protocol are not namespaced by the protocol, but<br>&gt; rather by the protocol&#39;s adopters. As such, when two protocols declare a<br>&gt; common associatedType, adoption of those protocols introduces undesirable<br>&gt; ambiguity.<br>&gt;<br>&gt; I don&#39;t think there&#39;s much of a point solving this just for associated<br>&gt; types. The same issue exists for all protocol requirements.<br>&gt;<br>&gt; &gt; Given the understandable propensity of developers to arrive at similarly<br>&gt; named types (T, for example), it is likely that this problem will reduce<br>&gt; the compatibility of packages for reasons that may not be entirely clear to<br>&gt; the package consumer.<br>&gt;<br>&gt; Then don&#39;t do that. Absurdly short associated/generic type names are like<br>&gt; absurdly short variable or function names—they&#39;re okay in a very small<br>&gt; context like a short function or a single loop, but a bad idea in a wider<br>&gt; context. That&#39;s why the Swift 2 standard library moved away from using<br>&gt; short names like `T` in generic types like Array and Optional.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/30974b7a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/421f5b513b7d921519635cd23d723191?s=50"></div><header><strong>[Pitch] Add namespacing to associatedTypes</strong> from <string>Noah Blake</string> &lt;nononoah at gmail.com&gt;<p>April  6, 2016 at 08:00:00am</p></header><div class="content"><p>Apologies - in /stdlib proper, there are only 207 usages of &quot;&lt;T&gt;&quot;, and no<br>occurrences of &quot;associatedtype T.&quot; My previous figures come from a grep of<br>the entire repo.<br></p><p>On Wed, Apr 6, 2016 at 6:19 AM, Noah Blake &lt;nononoah at gmail.com&gt; wrote:<br></p><p>&gt; I don&#39;t think there&#39;s much of a point solving this just for associated<br>&gt;&gt; types. The same issue exists for all protocol requirements.<br>&gt;<br>&gt;<br>&gt; True enough. The one difference worth noting, however, is that there&#39;s no<br>&gt; way to address the ambiguity of identical protocol requirements without<br>&gt; adding syntactical overhead. In the case of associatedtype inferencing,<br>&gt; however, it should be possible.<br>&gt;<br>&gt; Then don&#39;t do that. Absurdly short associated/generic type names are like<br>&gt;&gt; absurdly short variable or function names—they&#39;re okay in a very small<br>&gt;&gt; context like a short function or a single loop, but a bad idea in a wider<br>&gt;&gt; context. That&#39;s why the Swift 2 standard library moved away from using<br>&gt;&gt; short names like `T` in generic types like Array and Optional.<br>&gt;<br>&gt; While this may be a bit orthogonal, it&#39;s worth noting that the standard<br>&gt; library has increased its usage of T over the past month. Right now, it<br>&gt; contains 3932 occurrences of &lt;T&gt;. Plenty of these usages are type-scoped.<br>&gt; To your point, there are only 46 occurrences of &quot;associatedtype T&quot;.<br>&gt;<br>&gt; Regardless, there are plenty of longer, arguably better associatedtype<br>&gt; names that writers of different packages may commonly reach for. &quot;Element&quot;<br>&gt; may be known to be somewhat off limits, but it is representative of this<br>&gt; category.<br>&gt;<br>&gt; On Wed, Apr 6, 2016 at 1:45 AM, Brent Royal-Gordon &lt;brent at architechies.com<br>&gt; &gt; wrote:<br>&gt;<br>&gt;&gt; &gt; Types associated with a protocol are not namespaced by the protocol,<br>&gt;&gt; but rather by the protocol&#39;s adopters. As such, when two protocols declare<br>&gt;&gt; a common associatedType, adoption of those protocols introduces undesirable<br>&gt;&gt; ambiguity.<br>&gt;&gt;<br>&gt;&gt; I don&#39;t think there&#39;s much of a point solving this just for associated<br>&gt;&gt; types. The same issue exists for all protocol requirements.<br>&gt;&gt;<br>&gt;&gt; &gt; Given the understandable propensity of developers to arrive at<br>&gt;&gt; similarly named types (T, for example), it is likely that this problem will<br>&gt;&gt; reduce the compatibility of packages for reasons that may not be entirely<br>&gt;&gt; clear to the package consumer.<br>&gt;&gt;<br>&gt;&gt; Then don&#39;t do that. Absurdly short associated/generic type names are like<br>&gt;&gt; absurdly short variable or function names—they&#39;re okay in a very small<br>&gt;&gt; context like a short function or a single loop, but a bad idea in a wider<br>&gt;&gt; context. That&#39;s why the Swift 2 standard library moved away from using<br>&gt;&gt; short names like `T` in generic types like Array and Optional.<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/60302e70/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
