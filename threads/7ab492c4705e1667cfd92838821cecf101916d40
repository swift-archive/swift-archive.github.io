<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>Fixing the confusion between non-mutating algorithms and single-pass sequences</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>July 14, 2016 at 02:00:00am</p></header><div class="content"><p>I have also been thinking about this problem for the last week or so (as well as the finite/infinite bit).  I don’t really have anything detailed that is ready to share (and it sounds like you are headed in a different direction now).  I still wanted to share the gist of my thoughts, in case they help spark ideas in others…<br></p><p>My thought was to follow the first rejected approach: removing sequence and letting the Iterator protocol model single-pass.  Iterators would be reference types.<br></p><p>I followed a similar path, and my version also has a pretty large duplication of API between Iterator and Collection… the difference though, is I think I have a way to avoid most external duplication of API.<br></p><p>Basically, I added back in a super-minimal protocol to fill the structural gap left by Sequence.  I call it “IteratorProvider” and it only has a single function which vends an iterator.  Collection adheres to this, and Iterator adheres to it by returning itself.  All of the other methods from Sequence remain on Iterator.  Thus anyone with API that only needs a single pass would take a IteratorProvider and then work on the iterator it provides.<br></p><p>The big difference is that Collection and Iterator are still separate protocols, iterator is a reference type, and most of the methods from sequence are now on iterator.<br></p><p>I think this makes more sense semantically than the current model (or renaming sequence).  I also really think it is important to have iterators be reference types (anything else is really a lie)<br></p><p><br>The rejected “consumedIn” idea also gave me an idea of how to reduce the internal API repetition, if desired. <br></p><p>Have a fileprivate method on Iterator (I will call it “consumedIn” here, but it is private, so call it whatever) that wraps the Iterator in a collection. The multi-pass-ness of that secret collection is a lie, but it is fileprivate so it should never get into the wild where someone can find that out. Then you would just define map() etc… on an extension of Iterator and have them forward to “self.consumedIn.map”, etc….  It does still have duplication of definitions, but the implementations would be in a single spot.<br></p><p>Another option, if the subterfuge of a secret collection is undesirable, would be to make “consumedIn” be public and have it create an array-like collection.  The default implementation would actually make an eager copy, but specialized cases could work with the created collection to avoid copying the iterator’s contents where possible.  Then you would remove all of the eager methods from Iterator and just use collection’s version.<br></p><p>Food for thought…<br></p><p>Thanks,<br>Jon<br></p><p>&gt; Hi,<br>&gt; <br>&gt; I&#39;d like to continue the discussion of the issue raised by David Waite<br>&gt; inhttp://thread.gmane.org/gmane.comp.lang.swift.evolution/21295/: &lt;inhttp://thread.gmane.org/gmane.comp.lang.swift.evolution/21295/:&gt;<br>&gt; <br>&gt; &gt; My main motivation for proposing this is the potential for developer confusion. As stated during one of the previous threads on the naming of map, flatMap, filter, etc. methods on Sequence, Sequence has a naming requirement not typical of the rest of the Swift standard library in that many methods on Sequence may or may not be destructive. As such, naming methods for any extensions on Sequence is challenging as the names need to not imply immutability.<br>&gt; <br>&gt; I&#39;d like to focus on a particular point: methods on Sequence can<br>&gt; consume elements, but the APIs are not markedmutating.<br>&gt; <br>&gt; Dave Abrahams, Max Moiseev, and I have discussed this issue and we<br>&gt; agree this problem is severe and worth solving, we also think that the<br>&gt; likely solutions would be source-breaking, so it is important that we<br>&gt; discuss it now.<br>&gt; <br>&gt; We have discussed a few options.<br>&gt; <br>&gt; - Rejected option: remove Sequence, let IteratorProtocol model<br>&gt; single-pass data streams<br>&gt; <br>&gt; - Rejected option: use a syntactic marker, like sequence.consumedIn.map {}<br>&gt; <br>&gt; - Rejected option: mutating APIs on Sequence, non-mutating APIs on Collection<br>&gt; <br>&gt; Proposed: rename Sequence to IterableOnce or TraversableOnce. We think<br>&gt; that Sequence does not convey the single-pass restriction clearly. The<br>&gt; term &quot;sequence&quot; has been used in math (as in &quot;integer sequence&quot;), and<br>&gt; since the math domain does not have mutation, &quot;sequence&quot; can be<br>&gt; understood to mean &quot;multi-pass&quot;, since you can traverse a sequence of<br>&gt; integers an arbitrary number of times.<br>&gt; <br>&gt; We think that only the last option is viable in the Swift language as<br>&gt; it exists now, without creating an undue burden for API vendors and<br>&gt; users.<br>&gt; <br>&gt; For more details about rejection options, please see the full writeup:<br>&gt; https://gist.github.com/gribozavr/47f4717f3afc762549383e94da7f748b &lt;https://gist.github.com/gribozavr/47f4717f3afc762549383e94da7f748b&gt;<br>&gt; <br>&gt; Dmitri<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160714/7ab46d40/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Fixing the confusion between non-mutating algorithms and single-pass sequences</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July 15, 2016 at 11:00:00am</p></header><div class="content"><p>on Thu Jul 14 2016, Jonathan Hull &lt;jhull-AT-gbis.com&gt; wrote:<br></p><p>&gt; I have also been thinking about this problem for the last week or so<br>&gt; (as well as the finite/infinite bit).  I don’t really have anything<br>&gt; detailed that is ready to share (and it sounds like you are headed in<br>&gt; a different direction now).  I still wanted to share the gist of my<br>&gt; thoughts, in case they help spark ideas in others…<br></p><p>Hi Jonathan,<br></p><p>Thanks for your thoughts...<br></p><p>&gt; My thought was to follow the first rejected approach: removing<br>&gt; sequence and letting the Iterator protocol model single-pass.<br>&gt; Iterators would be reference types.<br>&gt;<br>&gt; I followed a similar path, and my version also has a pretty large<br>&gt; duplication of API between Iterator and Collection… the difference<br>&gt; though, is I think I have a way to avoid most external duplication of<br>&gt; API.<br>&gt;<br>&gt; Basically, I added back in a super-minimal protocol to fill the<br>&gt; structural gap left by Sequence.  I call it “IteratorProvider” and it<br>&gt; only has a single function which vends an iterator.  Collection<br>&gt; adheres to this, and Iterator adheres to it by returning itself.  All<br>&gt; of the other methods from Sequence remain on Iterator.  Thus anyone<br>&gt; with API that only needs a single pass would take a IteratorProvider<br>&gt; and then work on the iterator it provides.<br></p><p>That leaves us back where we are now: people will see that<br>IteratorProvider is a simple, universal protocol for both single-and<br>multi-pass sequences, write algorithm libraries that depend on<br>multi-pass-ness, and test them with the most prevalent examples, which<br>happen to be multipass. <br></p><p>&gt; The big difference is that Collection and Iterator are still separate<br>&gt; protocols, <br></p><p>That&#39;s currently the case.<br></p><p>&gt; iterator is a reference type, <br></p><p>That&#39;s slightly different, but we have reasons for not wanting to make<br>that requirement.<br></p><p>&gt; and most of the methods from sequence are now on iterator.<br>&gt;<br>&gt; I think this makes more sense semantically than the current model (or<br>&gt; renaming sequence).  I also really think it is important to have<br>&gt; iterators be reference types (anything else is really a lie)<br></p><p>Once they&#39;re reference types, you might as well just make them conform<br>to the same protocol as collections for algorithms, because none of the<br>“mutating/nonmutating” distinctions will be honored anyway.  Furthermore<br>it implies efficiency costs we&#39;re not prepared to pay.  The main problem<br>is that the right way to model single-pass traversal is with move-only<br>types, which can&#39;t be copied... and that&#39;s not something we can express<br>in Swift today.<br></p><p><br>&gt; The rejected “consumedIn” idea also gave me an idea of how to reduce<br>&gt; the internal API repetition, if desired.<br>&gt;<br>&gt; Have a fileprivate method on Iterator (I will call it “consumedIn”<br>&gt; here, but it is private, so call it whatever) that wraps the Iterator<br>&gt; in a collection. The multi-pass-ness of that secret collection is a<br>&gt; lie, but it is fileprivate so it should never get into the wild where<br>&gt; someone can find that out. Then you would just define map() etc… on an<br>&gt; extension of Iterator and have them forward to “self.consumedIn.map”,<br>&gt; etc….  It does still have duplication of definitions, but the<br>&gt; implementations would be in a single spot.<br></p><p>Yeah, we thought about that, too.  That doesn&#39;t really help the public<br>API, though. That&#39;s the problem we&#39;re trying to solve.  And if we don&#39;t<br>expose the thing publicly, any user wishing to write her own algorithm<br>that works on both Iterator and Collection has to write it herself.<br></p><p>&gt; Another option, if the subterfuge of a secret collection is<br>&gt; undesirable, would be to make “consumedIn” be public and have it<br>&gt; create an array-like collection.  The default implementation would<br>&gt; actually make an eager copy, but specialized cases could work with the<br>&gt; created collection to avoid copying the iterator’s contents where<br>&gt; possible.  Then you would remove all of the eager methods from<br>&gt; Iterator and just use collection’s version.<br></p><p>Ultimately, there are lots of interesting ideas for addressing this<br>space, but none of them lead to an answer that we we&#39;re willing to bet<br>solves the design problems and is implementable in time for Swift<br>3... except for the renaming.<br></p><p>&gt; Food for thought…<br>&gt;<br>&gt; Thanks,<br>&gt; Jon<br>&gt;<br>&gt;&gt; Hi,<br>&gt;&gt; <br>&gt;&gt; I&#39;d like to continue the discussion of the issue raised by David Waite<br>&gt;&gt; inhttp://thread.gmane.org/gmane.comp.lang.swift.evolution/21295/: &lt;inhttp://thread.gmane.org/gmane.comp.lang.swift.evolution/21295/:&gt;<br>&gt;&gt; <br>&gt;&gt; &gt; My main motivation for proposing this is the potential for<br>&gt;&gt; developer confusion. As stated during one of the previous threads on<br>&gt;&gt; the naming of map, flatMap, filter, etc. methods on Sequence,<br>&gt;&gt; Sequence has a naming requirement not typical of the rest of the<br>&gt;&gt; Swift standard library in that many methods on Sequence may or may<br>&gt;&gt; not be destructive. As such, naming methods for any extensions on<br>&gt;&gt; Sequence is challenging as the names need to not imply immutability.<br>&gt;&gt; <br>&gt;&gt; I&#39;d like to focus on a particular point: methods on Sequence can<br>&gt;&gt; consume elements, but the APIs are not markedmutating.<br>&gt;&gt; <br>&gt;&gt; Dave Abrahams, Max Moiseev, and I have discussed this issue and we<br>&gt;&gt; agree this problem is severe and worth solving, we also think that the<br>&gt;&gt; likely solutions would be source-breaking, so it is important that we<br>&gt;&gt; discuss it now.<br>&gt;&gt; <br>&gt;&gt; We have discussed a few options.<br>&gt;&gt; <br>&gt;&gt; - Rejected option: remove Sequence, let IteratorProtocol model<br>&gt;&gt; single-pass data streams<br>&gt;&gt; <br>&gt;&gt; - Rejected option: use a syntactic marker, like sequence.consumedIn.map {}<br>&gt;&gt; <br>&gt;&gt; - Rejected option: mutating APIs on Sequence, non-mutating APIs on Collection<br>&gt;&gt; <br>&gt;&gt; Proposed: rename Sequence to IterableOnce or TraversableOnce. We think<br>&gt;&gt; that Sequence does not convey the single-pass restriction clearly. The<br>&gt;&gt; term &quot;sequence&quot; has been used in math (as in &quot;integer sequence&quot;), and<br>&gt;&gt; since the math domain does not have mutation, &quot;sequence&quot; can be<br>&gt;&gt; understood to mean &quot;multi-pass&quot;, since you can traverse a sequence of<br>&gt;&gt; integers an arbitrary number of times.<br>&gt;&gt; <br>&gt;&gt; We think that only the last option is viable in the Swift language as<br>&gt;&gt; it exists now, without creating an undue burden for API vendors and<br>&gt;&gt; users.<br>&gt;&gt; <br>&gt;&gt; For more details about rejection options, please see the full writeup:<br>&gt;&gt; https://gist.github.com/gribozavr/47f4717f3afc762549383e94da7f748b &lt;https://gist.github.com/gribozavr/47f4717f3afc762549383e94da7f748b&gt;<br>&gt;&gt; <br>&gt;&gt; Dmitri<br>&gt;<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>Fixing the confusion between non-mutating algorithms and single-pass sequences</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>July 18, 2016 at 04:00:00pm</p></header><div class="content"><p>Comments inline:<br></p><p>&gt; On Jul 15, 2016, at 11:47 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Thu Jul 14 2016, Jonathan Hull &lt;jhull-AT-gbis.com &lt;http://jhull-at-gbis.com/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; I have also been thinking about this problem for the last week or so<br>&gt;&gt; (as well as the finite/infinite bit).  I don’t really have anything<br>&gt;&gt; detailed that is ready to share (and it sounds like you are headed in<br>&gt;&gt; a different direction now).  I still wanted to share the gist of my<br>&gt;&gt; thoughts, in case they help spark ideas in others…<br>&gt; <br>&gt; Hi Jonathan,<br>&gt; <br>&gt; Thanks for your thoughts...<br>&gt; <br>&gt;&gt; My thought was to follow the first rejected approach: removing<br>&gt;&gt; sequence and letting the Iterator protocol model single-pass.<br>&gt;&gt; Iterators would be reference types.<br>&gt;&gt; <br>&gt;&gt; I followed a similar path, and my version also has a pretty large<br>&gt;&gt; duplication of API between Iterator and Collection… the difference<br>&gt;&gt; though, is I think I have a way to avoid most external duplication of<br>&gt;&gt; API.<br>&gt;&gt; <br>&gt;&gt; Basically, I added back in a super-minimal protocol to fill the<br>&gt;&gt; structural gap left by Sequence.  I call it “IteratorProvider” and it<br>&gt;&gt; only has a single function which vends an iterator.  Collection<br>&gt;&gt; adheres to this, and Iterator adheres to it by returning itself.  All<br>&gt;&gt; of the other methods from Sequence remain on Iterator.  Thus anyone<br>&gt;&gt; with API that only needs a single pass would take a IteratorProvider<br>&gt;&gt; and then work on the iterator it provides.<br>&gt; <br>&gt; That leaves us back where we are now: people will see that<br>&gt; IteratorProvider is a simple, universal protocol for both single-and<br>&gt; multi-pass sequences, write algorithm libraries that depend on<br>&gt; multi-pass-ness, and test them with the most prevalent examples, which<br>&gt; happen to be multi pass.<br></p><p>Let me make a quick counter-argument, because I thought about it a bit, and I don’t think it does have the same problem (especially with careful/better naming).<br></p><p>The difference is that the ONLY method on IteratorProvider is the one to get an iterator.  There is no map, filter, sort, first, count, etc…  just a way to get a single-pass iterator.  This changes the mindset when using it.  You are aware that you are getting a single-pass iterator.<br></p><p>True, people might try to get the iterator a second time, but we can make the iteratorProvider method optional (and trying to get an iterator from an iterator which is spent would return nil) and then they are forced to deal with the case where it was single-pass.<br></p><p>It is a fairly subtle difference, but an important one IMHO.<br></p><p><br>&gt;&gt; The big difference is that Collection and Iterator are still separate<br>&gt;&gt; protocols, <br>&gt; <br>&gt; That&#39;s currently the case.<br>Yes, you are correct.  I don’t know why I thought they were connected in the current version.<br></p><p>&gt;&gt; iterator is a reference type, <br>&gt; <br>&gt; That&#39;s slightly different, but we have reasons for not wanting to make<br>&gt; that requirement.<br></p><p>Would you mind expanding on those reasons?<br></p><p><br>&gt; <br>&gt;&gt; and most of the methods from sequence are now on iterator.<br>&gt;&gt; <br>&gt;&gt; I think this makes more sense semantically than the current model (or<br>&gt;&gt; renaming sequence).  I also really think it is important to have<br>&gt;&gt; iterators be reference types (anything else is really a lie)<br>&gt; <br>&gt; Once they&#39;re reference types, you might as well just make them conform<br>&gt; to the same protocol as collections for algorithms, because none of the<br>&gt; “mutating/nonmutating” distinctions will be honored anyway.  Furthermore<br>&gt; it implies efficiency costs we&#39;re not prepared to pay.  The main problem<br>&gt; is that the right way to model single-pass traversal is with move-only<br>&gt; types, which can&#39;t be copied... and that&#39;s not something we can express<br>&gt; in Swift today.<br>ah.<br></p><p><br>&gt;&gt; The rejected “consumedIn” idea also gave me an idea of how to reduce<br>&gt;&gt; the internal API repetition, if desired.<br>&gt;&gt; <br>&gt;&gt; Have a fileprivate method on Iterator (I will call it “consumedIn”<br>&gt;&gt; here, but it is private, so call it whatever) that wraps the Iterator<br>&gt;&gt; in a collection. The multi-pass-ness of that secret collection is a<br>&gt;&gt; lie, but it is fileprivate so it should never get into the wild where<br>&gt;&gt; someone can find that out. Then you would just define map() etc… on an<br>&gt;&gt; extension of Iterator and have them forward to “self.consumedIn.map”,<br>&gt;&gt; etc….  It does still have duplication of definitions, but the<br>&gt;&gt; implementations would be in a single spot.<br>&gt; <br>&gt; Yeah, we thought about that, too.  That doesn&#39;t really help the public<br>&gt; API, though. That&#39;s the problem we&#39;re trying to solve.  And if we don&#39;t<br>&gt; expose the thing publicly, any user wishing to write her own algorithm<br>&gt; that works on both Iterator and Collection has to write it herself.<br>&gt; <br>&gt;&gt; Another option, if the subterfuge of a secret collection is<br>&gt;&gt; undesirable, would be to make “consumedIn” be public and have it<br>&gt;&gt; create an array-like collection.  The default implementation would<br>&gt;&gt; actually make an eager copy, but specialized cases could work with the<br>&gt;&gt; created collection to avoid copying the iterator’s contents where<br>&gt;&gt; possible.  Then you would remove all of the eager methods from<br>&gt;&gt; Iterator and just use collection’s version.<br>&gt; <br>&gt; Ultimately, there are lots of interesting ideas for addressing this<br>&gt; space, but none of them lead to an answer that we we&#39;re willing to bet<br>&gt; solves the design problems and is implementable in time for Swift<br>&gt; 3... except for the renaming.<br></p><p>Yeah.  We are out of time.  Is there any hope of coming back to this in Swift 4, or would it be too much of a breaking change?<br></p><p>Thanks,<br>Jon<br></p><p><br>&gt; <br>&gt;&gt; Food for thought…<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; Jon<br>&gt;&gt; <br>&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;d like to continue the discussion of the issue raised by David Waite<br>&gt;&gt;&gt; inhttp://thread.gmane.org/gmane.comp.lang.swift.evolution/21295/: &lt;inhttp://thread.gmane.org/gmane.comp.lang.swift.evolution/21295/:&gt; &lt;inhttp://thread.gmane.org/gmane.comp.lang.swift.evolution/21295/: &lt;inhttp://thread.gmane.org/gmane.comp.lang.swift.evolution/21295/:&gt;&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; My main motivation for proposing this is the potential for<br>&gt;&gt;&gt; developer confusion. As stated during one of the previous threads on<br>&gt;&gt;&gt; the naming of map, flatMap, filter, etc. methods on Sequence,<br>&gt;&gt;&gt; Sequence has a naming requirement not typical of the rest of the<br>&gt;&gt;&gt; Swift standard library in that many methods on Sequence may or may<br>&gt;&gt;&gt; not be destructive. As such, naming methods for any extensions on<br>&gt;&gt;&gt; Sequence is challenging as the names need to not imply immutability.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;d like to focus on a particular point: methods on Sequence can<br>&gt;&gt;&gt; consume elements, but the APIs are not markedmutating.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Dave Abrahams, Max Moiseev, and I have discussed this issue and we<br>&gt;&gt;&gt; agree this problem is severe and worth solving, we also think that the<br>&gt;&gt;&gt; likely solutions would be source-breaking, so it is important that we<br>&gt;&gt;&gt; discuss it now.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We have discussed a few options.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Rejected option: remove Sequence, let IteratorProtocol model<br>&gt;&gt;&gt; single-pass data streams<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Rejected option: use a syntactic marker, like sequence.consumedIn.map {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Rejected option: mutating APIs on Sequence, non-mutating APIs on Collection<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposed: rename Sequence to IterableOnce or TraversableOnce. We think<br>&gt;&gt;&gt; that Sequence does not convey the single-pass restriction clearly. The<br>&gt;&gt;&gt; term &quot;sequence&quot; has been used in math (as in &quot;integer sequence&quot;), and<br>&gt;&gt;&gt; since the math domain does not have mutation, &quot;sequence&quot; can be<br>&gt;&gt;&gt; understood to mean &quot;multi-pass&quot;, since you can traverse a sequence of<br>&gt;&gt;&gt; integers an arbitrary number of times.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We think that only the last option is viable in the Swift language as<br>&gt;&gt;&gt; it exists now, without creating an undue burden for API vendors and<br>&gt;&gt;&gt; users.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For more details about rejection options, please see the full writeup:<br>&gt;&gt;&gt; https://gist.github.com/gribozavr/47f4717f3afc762549383e94da7f748b &lt;https://gist.github.com/gribozavr/47f4717f3afc762549383e94da7f748b&gt; &lt;https://gist.github.com/gribozavr/47f4717f3afc762549383e94da7f748b &lt;https://gist.github.com/gribozavr/47f4717f3afc762549383e94da7f748b&gt;&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Dmitri<br>&gt;&gt; <br>&gt; <br>&gt; -- <br>&gt; Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160718/83045eeb/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
