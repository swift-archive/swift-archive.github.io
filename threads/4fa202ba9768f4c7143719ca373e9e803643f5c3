<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Pitch] Change the endIndex value for closed Ranges and Collections</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>March 23, 2016 at 05:00:00pm</p></header><div class="content"><p>on Wed Mar 23 2016, Pedro Vieira &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi Swift developers,<br>&gt; I hereby present my first Swift proposal regarding the endIndex on<br>&gt; `Collections` and closed `Ranges`. I’ve searched the mailing list archives<br>&gt; for something similar to this but couldn’t find it, so I decided to come<br>&gt; forward.<br>&gt;<br>&gt; *The problem:*<br>&gt; I was recently working on a library and used a closed Range to define the<br>&gt; bounds of a board game and the tests that used its endIndex were all<br>&gt; failing. Started debugging it around and, to my complete surprise, found<br>&gt; out that the endIndex of the closed Ranges was always +1 from the value I<br>&gt; initially set. With this, I decided to dive into the Range source code and<br>&gt; discovered that all closed ranges are converted to half-open ones when<br>&gt; initialized:<br>&gt; a) 1..&lt;10 stays 1..&lt;10 (endIndex = 10)<br>&gt; b) 1...10 is converted to 1..&lt;11 (endIndex = 11)<br>&gt;<br>&gt; To work around this behavior I had to subtract 1 every time I checked for<br>&gt; the endIndex, since I didn&#39;t want to use last! (force unwrapping) or<br>&gt; if-let, which ultimately polluted my code. <br></p><p>Please see the work currently underway in<br>https://github.com/apple/swift/blob/swift-3-indexing-model/stdlib/public/core/ClosedRange.swift,<br>which we intend to propose soon.  ClosedRange becomes a separate type<br>that represents its upperBound without modification.<br></p><p><br>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>[Pitch] Change the endIndex value for closed Ranges and Collections</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>March 24, 2016 at 02:00:00pm</p></header><div class="content"><p>Hi Pedro,<br></p><p>I&#39;m going to refer to what you&#39;re proposing as *lastIndex* to distinguish<br>it from the current endIndex.<br></p><p>Worth considering is indexes for things like a linked list (or other<br>ForwardIndexType collections):<br></p><p>   - You can represent the endIndex in O(1) by using a nullable internally.<br>   - It&#39;s likely to be an O(n) operation resolve the *lastIndex* property*.*<br></p><p>The current system seems much cleaner to represent empty ranges:<br></p><p>   - How do you represent an empty range with *lastIndex*? Range(start: 0,<br>   end: -1) ?<br>   - Does this mean that UInt cannot be a ForwardIndexType, or cannot be<br>   used with Range, how do you show this in the protocol?<br></p><p>You should also consider migration in your proposal:<br></p><p>   - I don&#39;t think migration will be trivial, or even necessarily safely<br>   automated. I think the changes will be extensive.<br>   - Reusing the same name will likely make it confusing when people google<br>   Swift code, it will be unclear if code is in the old system or the new one.<br>   - If you do a formal proposal I recommend it proposes to deprecate the<br>   current system and introduce a new property with a different, clearer,<br>   name. I recommend *lastIndex*.<br></p><p><br>It&#39;s probably worthwhile for you to consider your proposed changes in the<br>context of this upcoming proposal, I think it&#39;s very likely to go ahead in<br>some form:<br></p><p>https://github.com/gribozavr/swift-evolution/blob/new-collections/proposals/NNNN-collections-move-indices.md<br></p><p>I&#39;m in favour of having a new field:<br>    // for example<br>    var lastIndex: Index? {<br>        let count = self.count<br>        guard count &gt; 0 else { return nil }<br>        return startIndex.advancedBy(count-1)<br>    }<br></p><p>It&#39;s optional to represent an empty collection.<br></p><p>I&#39;m not in favour of the proposal as it is stated. It&#39;s a fairly well<br>established convention for endIndex to be the index after the last element,<br>although perhaps it could be called something clearer. I think that<br>discussion is a good idea.<br></p><p><br>Andrew Bennett<br></p><p>On Thu, Mar 24, 2016 at 11:15 AM, Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; on Wed Mar 23 2016, Pedro Vieira &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; &gt; Hi Swift developers,<br>&gt; &gt; I hereby present my first Swift proposal regarding the endIndex on<br>&gt; &gt; `Collections` and closed `Ranges`. I’ve searched the mailing list<br>&gt; archives<br>&gt; &gt; for something similar to this but couldn’t find it, so I decided to come<br>&gt; &gt; forward.<br>&gt; &gt;<br>&gt; &gt; *The problem:*<br>&gt; &gt; I was recently working on a library and used a closed Range to define the<br>&gt; &gt; bounds of a board game and the tests that used its endIndex were all<br>&gt; &gt; failing. Started debugging it around and, to my complete surprise, found<br>&gt; &gt; out that the endIndex of the closed Ranges was always +1 from the value I<br>&gt; &gt; initially set. With this, I decided to dive into the Range source code<br>&gt; and<br>&gt; &gt; discovered that all closed ranges are converted to half-open ones when<br>&gt; &gt; initialized:<br>&gt; &gt; a) 1..&lt;10 stays 1..&lt;10 (endIndex = 10)<br>&gt; &gt; b) 1...10 is converted to 1..&lt;11 (endIndex = 11)<br>&gt; &gt;<br>&gt; &gt; To work around this behavior I had to subtract 1 every time I checked for<br>&gt; &gt; the endIndex, since I didn&#39;t want to use last! (force unwrapping) or<br>&gt; &gt; if-let, which ultimately polluted my code.<br>&gt;<br>&gt; Please see the work currently underway in<br>&gt;<br>&gt; https://github.com/apple/swift/blob/swift-3-indexing-model/stdlib/public/core/ClosedRange.swift<br>&gt; ,<br>&gt; which we intend to propose soon.  ClosedRange becomes a separate type<br>&gt; that represents its upperBound without modification.<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/703a4f33/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Pitch] Change the endIndex value for closed Ranges and Collections</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>March 24, 2016 at 05:00:00pm</p></header><div class="content"><p>+1 I think it is a good idea to make a collection run from firstIndex to<br>lastIndex inclusively (note name change to match firstElement and<br>lastElement). For an empty collection both firstIndex and lastIndex would<br>be invalid values that would cause both c[c.firstIndex] and c.[c,lastIndex]<br>to fail.<br></p><p>  -- Howard.<br></p><p>On 24 March 2016 at 14:07, Andrew Bennett via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi Pedro,<br>&gt;<br>&gt; I&#39;m going to refer to what you&#39;re proposing as *lastIndex* to distinguish<br>&gt; it from the current endIndex.<br>&gt;<br>&gt; Worth considering is indexes for things like a linked list (or other<br>&gt; ForwardIndexType collections):<br>&gt;<br>&gt;    - You can represent the endIndex in O(1) by using a nullable<br>&gt;    internally.<br>&gt;    - It&#39;s likely to be an O(n) operation resolve the *lastIndex* property<br>&gt;    *.*<br>&gt;<br>&gt; The current system seems much cleaner to represent empty ranges:<br>&gt;<br>&gt;    - How do you represent an empty range with *lastIndex*? Range(start:<br>&gt;    0, end: -1) ?<br>&gt;    - Does this mean that UInt cannot be a ForwardIndexType, or cannot be<br>&gt;    used with Range, how do you show this in the protocol?<br>&gt;<br>&gt; You should also consider migration in your proposal:<br>&gt;<br>&gt;    - I don&#39;t think migration will be trivial, or even necessarily safely<br>&gt;    automated. I think the changes will be extensive.<br>&gt;    - Reusing the same name will likely make it confusing when people<br>&gt;    google Swift code, it will be unclear if code is in the old system or the<br>&gt;    new one.<br>&gt;    - If you do a formal proposal I recommend it proposes to deprecate the<br>&gt;    current system and introduce a new property with a different, clearer,<br>&gt;    name. I recommend *lastIndex*.<br>&gt;<br>&gt;<br>&gt; It&#39;s probably worthwhile for you to consider your proposed changes in the<br>&gt; context of this upcoming proposal, I think it&#39;s very likely to go ahead in<br>&gt; some form:<br>&gt;<br>&gt; https://github.com/gribozavr/swift-evolution/blob/new-collections/proposals/NNNN-collections-move-indices.md<br>&gt;<br>&gt; I&#39;m in favour of having a new field:<br>&gt;     // for example<br>&gt;     var lastIndex: Index? {<br>&gt;         let count = self.count<br>&gt;         guard count &gt; 0 else { return nil }<br>&gt;         return startIndex.advancedBy(count-1)<br>&gt;     }<br>&gt;<br>&gt; It&#39;s optional to represent an empty collection.<br>&gt;<br>&gt; I&#39;m not in favour of the proposal as it is stated. It&#39;s a fairly well<br>&gt; established convention for endIndex to be the index after the last element,<br>&gt; although perhaps it could be called something clearer. I think that<br>&gt; discussion is a good idea.<br>&gt;<br>&gt;<br>&gt; Andrew Bennett<br>&gt;<br>&gt; On Thu, Mar 24, 2016 at 11:15 AM, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; on Wed Mar 23 2016, Pedro Vieira &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; &gt; Hi Swift developers,<br>&gt;&gt; &gt; I hereby present my first Swift proposal regarding the endIndex on<br>&gt;&gt; &gt; `Collections` and closed `Ranges`. I’ve searched the mailing list<br>&gt;&gt; archives<br>&gt;&gt; &gt; for something similar to this but couldn’t find it, so I decided to come<br>&gt;&gt; &gt; forward.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; *The problem:*<br>&gt;&gt; &gt; I was recently working on a library and used a closed Range to define<br>&gt;&gt; the<br>&gt;&gt; &gt; bounds of a board game and the tests that used its endIndex were all<br>&gt;&gt; &gt; failing. Started debugging it around and, to my complete surprise, found<br>&gt;&gt; &gt; out that the endIndex of the closed Ranges was always +1 from the value<br>&gt;&gt; I<br>&gt;&gt; &gt; initially set. With this, I decided to dive into the Range source code<br>&gt;&gt; and<br>&gt;&gt; &gt; discovered that all closed ranges are converted to half-open ones when<br>&gt;&gt; &gt; initialized:<br>&gt;&gt; &gt; a) 1..&lt;10 stays 1..&lt;10 (endIndex = 10)<br>&gt;&gt; &gt; b) 1...10 is converted to 1..&lt;11 (endIndex = 11)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; To work around this behavior I had to subtract 1 every time I checked<br>&gt;&gt; for<br>&gt;&gt; &gt; the endIndex, since I didn&#39;t want to use last! (force unwrapping) or<br>&gt;&gt; &gt; if-let, which ultimately polluted my code.<br>&gt;&gt;<br>&gt;&gt; Please see the work currently underway in<br>&gt;&gt;<br>&gt;&gt; https://github.com/apple/swift/blob/swift-3-indexing-model/stdlib/public/core/ClosedRange.swift<br>&gt;&gt; ,<br>&gt;&gt; which we intend to propose soon.  ClosedRange becomes a separate type<br>&gt;&gt; that represents its upperBound without modification.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Dave<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/3516eb6e/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
