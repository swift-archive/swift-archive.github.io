<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Add types BufferedSequence, BufferedGenerator</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 31, 2015 at 04:00:00pm</p></header><div class="content"><p>BufferedSequence is a sequence adaptor that wraps any underlying sequence and provides a stable `first` property. BufferedGenerator is a generator adaptor that wraps any underlying generator and provides arbitrary lookahead with a `peek(n: Int)` method.<br></p><p>The method name &quot;peek()&quot; has precedent in various languages (e.g. Rust<br>with std::iter::Peekable, C++ with std::basic_istream::peek, Ruby with<br>Enumerator#peek, etc). I considered the name &quot;lookahead()&quot; but I decided<br>it made more sense to use that name for the property that describes how<br>much lookahead there is.<br></p><p>The proposed API looks like this:<br></p><p>/// A sequence adaptor that adds a nondestructive `first`<br>property to any<br></p><p><br>/// underlying sequence.<br></p><p><br>/// - Note: If the underlying sequence is not destructively<br>&quot;consumed&quot; by<br></p><p><br>///   iteration, then neither is `BufferedSequence`.<br></p><p><br>public class BufferedSequence&lt;Base : SequenceType&gt; : SequenceType {<br></p><p><br>public init(_ base: Base)<br></p><p><br></p><p><br>/// Returns ` BufferedGenerator` with a lookahead size of `1`.<br></p><p><br>public func generate() -&gt;<br>BufferedSequence.BufferedGenerator&lt;Base.Generator&gt;<br></p><p><br></p><p><br></p><p>/// Returns the first element of the underlying sequence,<br>**nondestructively**.<br></p><p><br>public var first: Base.Generator.Element? { get }<br></p><p><br>}<br></p><p><br></p><p><br></p><p>/// A generator adaptor that adds a nondestructive `peek()`<br>method to any<br></p><p><br>/// underlying generator.<br></p><p><br>public struct BufferedGenerator&lt;Base : GeneratorType&gt; : GeneratorType {<br></p><p><br>/// Construct an instance that buffers access to an underlying<br>generator.<br></p><p><br>/// - Parameter base: The underlying generator.<br></p><p><br>/// - Parameter lookahead: The amount of lookahead to allow.<br>Default is `1`.<br></p><p><br>///   Values less than `1` will be treated the same as `1`.<br></p><p><br>public init(_ base: Base, lookahead: Int = default)<br></p><p><br></p><p><br></p><p>/// The amount of lookahead that this generator offers.<br></p><p><br>/// - Invariant: `lookahead &gt;= 1`.<br></p><p><br>public let lookahead: Int<br></p><p><br></p><p><br></p><p>/// Advance to the next element and return it, or `nil` if no next<br>element exists.<br></p><p><br>///<br></p><p><br>/// - Requires: Neither `next()` nor `peek()` have been applied<br>to a copy of<br></p><p><br>///   `self` since the copy was made, and no preceding call to<br>`self.next()` has<br></p><p><br>///   returned `nil`.<br></p><p><br>public mutating func next() -&gt; Base.Element?<br></p><p><br></p><p><br></p><p>/// Returns the value that will be returned from subsequent calls<br>to `next()`.<br></p><p><br>/// - Parameter n: The number of elements to look ahead. Default is<br>`0`. A value<br></p><p><br>///   of `0` means to look at the next element.<br></p><p><br>/// - Precondition: `n &gt;= 0 &amp;&amp; n &lt; lookahead`.<br></p><p><br>/// - Requires: Neither `next()` nor `peek()` have been applied<br>to a copy of<br></p><p><br>///   `self` since the copy was made, and no preceding call to<br>`self.next()` has<br></p><p><br>///   returned `nil`.<br></p><p><br>/// - Note: It is safe to peek at values past the end of the<br>underlying generator<br></p><p><br>///  (`peek()` will return `nil` in such cases). It is also safe to<br>call `peek()`<br></p><p><br>///  repeatedly, even after it&#39;s returned `nil`, and similarly it is<br>safe to call<br></p><p><br>///  `next()` after `peek()` has returned `nil`.<br></p><p><br>public mutating func peek(n: Int = default) -&gt; Base.Element?<br></p><p><br>}<br></p><p><br></p><p><br></p><p>BufferedSequence is a class because the generate() function needs to<br>mutate it. After the `first` property has been accessed, it needs to<br>cache the generator it used for that so it can return it from the next<br>call to generate(), but it also needs to nil out that cache at that time<br>so it doesn&#39;t try and return the same generator instance a second time<br>on a subsequent call to generate() (this way BufferedSequence can be<br>written to support non-destructive iteration if the underlying sequence<br>is non-destructive).<br></p><p>I&#39;ve already started sketching out an implementation as well. I believe<br>it should be possible to optimize BufferedGenerator for a lookahead of 1<br>to avoid the heap allocation of an array.<br></p><p>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/d05719a5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Proposal: Add types BufferedSequence, BufferedGenerator</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January  1, 2016 at 12:00:00pm</p></header><div class="content"><p>+1<br></p><p>Sent from my iPad<br></p><p>&gt; On 1 Jan 2016, at 11:16 AM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; BufferedSequence is a sequence adaptor that wraps any underlying sequence and provides a stable `first` property. BufferedGenerator is a generator adaptor that wraps any underlying generator and provides arbitrary lookahead with a `peek(n: Int)` method.<br>&gt;  <br>&gt; The method name &quot;peek()&quot; has precedent in various languages (e.g. Rust with std::iter::Peekable, C++ with std::basic_istream::peek, Ruby with Enumerator#peek, etc). I considered the name &quot;lookahead()&quot; but I decided it made more sense to use that name for the property that describes how much lookahead there is.<br>&gt;  <br>&gt; The proposed API looks like this:<br>&gt;  <br>&gt; /// A sequence adaptor that adds a nondestructive `first` property to any<br>&gt; /// underlying sequence.<br>&gt; /// - Note: If the underlying sequence is not destructively &quot;consumed&quot; by<br>&gt; ///   iteration, then neither is `BufferedSequence`.<br>&gt; public class BufferedSequence&lt;Base : SequenceType&gt; : SequenceType {<br>&gt;     public init(_ base: Base)<br>&gt; <br>&gt;     /// Returns ` BufferedGenerator` with a lookahead size of `1`.<br>&gt;     public func generate() -&gt; BufferedSequence.BufferedGenerator&lt;Base.Generator&gt;<br>&gt; <br>&gt;     /// Returns the first element of the underlying sequence, **nondestructively**.<br>&gt;     public var first: Base.Generator.Element? { get }<br>&gt; }<br>&gt; <br>&gt; /// A generator adaptor that adds a nondestructive `peek()` method to any<br>&gt; /// underlying generator.<br>&gt; public struct BufferedGenerator&lt;Base : GeneratorType&gt; : GeneratorType {<br>&gt;     /// Construct an instance that buffers access to an underlying generator.<br>&gt;     /// - Parameter base: The underlying generator.<br>&gt;     /// - Parameter lookahead: The amount of lookahead to allow. Default is `1`.<br>&gt;     ///   Values less than `1` will be treated the same as `1`.<br>&gt;     public init(_ base: Base, lookahead: Int = default)<br>&gt; <br>&gt;     /// The amount of lookahead that this generator offers.<br>&gt;     /// - Invariant: `lookahead &gt;= 1`.<br>&gt;     public let lookahead: Int<br>&gt; <br>&gt;     /// Advance to the next element and return it, or `nil` if no next element exists.<br>&gt;     ///<br>&gt;     /// - Requires: Neither `next()` nor `peek()` have been applied to a copy of<br>&gt;     ///   `self` since the copy was made, and no preceding call to `self.next()` has<br>&gt;     ///   returned `nil`.<br>&gt;     public mutating func next() -&gt; Base.Element?<br>&gt; <br>&gt;     /// Returns the value that will be returned from subsequent calls to `next()`.<br>&gt;     /// - Parameter n: The number of elements to look ahead. Default is `0`. A value<br>&gt;     ///   of `0` means to look at the next element.<br>&gt;     /// - Precondition: `n &gt;= 0 &amp;&amp; n &lt; lookahead`.<br>&gt;     /// - Requires: Neither `next()` nor `peek()` have been applied to a copy of<br>&gt;     ///   `self` since the copy was made, and no preceding call to `self.next()` has<br>&gt;     ///   returned `nil`.<br>&gt;     /// - Note: It is safe to peek at values past the end of the underlying generator<br>&gt;     ///  (`peek()` will return `nil` in such cases). It is also safe to call `peek()`<br>&gt;     ///  repeatedly, even after it&#39;s returned `nil`, and similarly it is safe to call<br>&gt;     ///  `next()` after `peek()` has returned `nil`.<br>&gt;     public mutating func peek(n: Int = default) -&gt; Base.Element?<br>&gt; }<br>&gt; <br>&gt; BufferedSequence is a class because the generate() function needs to mutate it. After the `first` property has been accessed, it needs to cache the generator it used for that so it can return it from the next call to generate(), but it also needs to nil out that cache at that time so it doesn&#39;t try and return the same generator instance a second time on a subsequent call to generate() (this way BufferedSequence can be written to support non-destructive iteration if the underlying sequence is non-destructive).<br>&gt;  <br>&gt; I&#39;ve already started sketching out an implementation as well. I believe it should be possible to optimize BufferedGenerator for a lookahead of 1 to avoid the heap allocation of an array.<br>&gt;  <br>&gt; -Kevin Ballard<br>&gt;  <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160101/07934c50/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Proposal: Add types BufferedSequence, BufferedGenerator</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January  1, 2016 at 03:00:00pm</p></header><div class="content"><p>Not a fan of anything that reminds me of Java streams.<br></p><p>Is the case where making an array from the sequence isn&#39;t possible significant enough for a new standard API?<br></p><p>Félix<br></p><p>&gt; Le 31 déc. 2015 à 20:50:40, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; +1<br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On 1 Jan 2016, at 11:16 AM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; BufferedSequence is a sequence adaptor that wraps any underlying sequence and provides a stable `first` property. BufferedGenerator is a generator adaptor that wraps any underlying generator and provides arbitrary lookahead with a `peek(n: Int)` method.<br>&gt;&gt;  <br>&gt;&gt; The method name &quot;peek()&quot; has precedent in various languages (e.g. Rust with std::iter::Peekable, C++ with std::basic_istream::peek, Ruby with Enumerator#peek, etc). I considered the name &quot;lookahead()&quot; but I decided it made more sense to use that name for the property that describes how much lookahead there is.<br>&gt;&gt;  <br>&gt;&gt; The proposed API looks like this:<br>&gt;&gt;  <br>&gt;&gt; /// A sequence adaptor that adds a nondestructive `first` property to any<br>&gt;&gt; /// underlying sequence.<br>&gt;&gt; /// - Note: If the underlying sequence is not destructively &quot;consumed&quot; by<br>&gt;&gt; ///   iteration, then neither is `BufferedSequence`.<br>&gt;&gt; public class BufferedSequence&lt;Base : SequenceType&gt; : SequenceType {<br>&gt;&gt;     public init(_ base: Base)<br>&gt;&gt; <br>&gt;&gt;     /// Returns ` BufferedGenerator` with a lookahead size of `1`.<br>&gt;&gt;     public func generate() -&gt; BufferedSequence.BufferedGenerator&lt;Base.Generator&gt;<br>&gt;&gt; <br>&gt;&gt;     /// Returns the first element of the underlying sequence, **nondestructively**.<br>&gt;&gt;     public var first: Base.Generator.Element? { get }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; /// A generator adaptor that adds a nondestructive `peek()` method to any<br>&gt;&gt; /// underlying generator.<br>&gt;&gt; public struct BufferedGenerator&lt;Base : GeneratorType&gt; : GeneratorType {<br>&gt;&gt;     /// Construct an instance that buffers access to an underlying generator.<br>&gt;&gt;     /// - Parameter base: The underlying generator.<br>&gt;&gt;     /// - Parameter lookahead: The amount of lookahead to allow. Default is `1`.<br>&gt;&gt;     ///   Values less than `1` will be treated the same as `1`.<br>&gt;&gt;     public init(_ base: Base, lookahead: Int = default)<br>&gt;&gt; <br>&gt;&gt;     /// The amount of lookahead that this generator offers.<br>&gt;&gt;     /// - Invariant: `lookahead &gt;= 1`.<br>&gt;&gt;     public let lookahead: Int<br>&gt;&gt; <br>&gt;&gt;     /// Advance to the next element and return it, or `nil` if no next element exists.<br>&gt;&gt;     ///<br>&gt;&gt;     /// - Requires: Neither `next()` nor `peek()` have been applied to a copy of<br>&gt;&gt;     ///   `self` since the copy was made, and no preceding call to `self.next()` has<br>&gt;&gt;     ///   returned `nil`.<br>&gt;&gt;     public mutating func next() -&gt; Base.Element?<br>&gt;&gt; <br>&gt;&gt;     /// Returns the value that will be returned from subsequent calls to `next()`.<br>&gt;&gt;     /// - Parameter n: The number of elements to look ahead. Default is `0`. A value<br>&gt;&gt;     ///   of `0` means to look at the next element.<br>&gt;&gt;     /// - Precondition: `n &gt;= 0 &amp;&amp; n &lt; lookahead`.<br>&gt;&gt;     /// - Requires: Neither `next()` nor `peek()` have been applied to a copy of<br>&gt;&gt;     ///   `self` since the copy was made, and no preceding call to `self.next()` has<br>&gt;&gt;     ///   returned `nil`.<br>&gt;&gt;     /// - Note: It is safe to peek at values past the end of the underlying generator<br>&gt;&gt;     ///  (`peek()` will return `nil` in such cases). It is also safe to call `peek()`<br>&gt;&gt;     ///  repeatedly, even after it&#39;s returned `nil`, and similarly it is safe to call<br>&gt;&gt;     ///  `next()` after `peek()` has returned `nil`.<br>&gt;&gt;     public mutating func peek(n: Int = default) -&gt; Base.Element?<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; BufferedSequence is a class because the generate() function needs to mutate it. After the `first` property has been accessed, it needs to cache the generator it used for that so it can return it from the next call to generate(), but it also needs to nil out that cache at that time so it doesn&#39;t try and return the same generator instance a second time on a subsequent call to generate() (this way BufferedSequence can be written to support non-destructive iteration if the underlying sequence is non-destructive).<br>&gt;&gt;  <br>&gt;&gt; I&#39;ve already started sketching out an implementation as well. I believe it should be possible to optimize BufferedGenerator for a lookahead of 1 to avoid the heap allocation of an array.<br>&gt;&gt;  <br>&gt;&gt; -Kevin Ballard<br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160101/1620d5a7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Add types BufferedSequence, BufferedGenerator</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>January  1, 2016 at 06:00:00pm</p></header><div class="content"><p>On Fri, Jan 1, 2016, at 12:35 PM, Félix Cloutier wrote:<br>&gt; Not a fan of anything that reminds me of Java streams.<br></p><p>I don&#39;t know anything at all about Java streams, but this is based on<br>the very common concept of being able to &quot;peek&quot; at the next element<br>of an enumerable value, just extended a bit to support lookahead of<br>more than 1.<br></p><p>&gt; Is the case where making an array from the sequence isn&#39;t possible<br>&gt; significant enough for a new standard API?<br></p><p>Why would you make an array from the sequence? That&#39;s flagrantly<br>wasteful if all you&#39;re doing is processing a sequence and simply need<br>some lookahead. And in the case of an infinite sequence it&#39;s downright<br>impossible.<br></p><p>-Kevin Ballard<br></p><p>&gt; Félix<br>&gt;<br>&gt;&gt; Le 31 déc. 2015 à 20:50:40, Howard Lovatt via swift-evolution &lt;swift-<br>&gt;&gt; evolution at swift.org&gt; a écrit :<br>&gt;&gt;<br>&gt;&gt; +1<br>&gt;&gt;<br>&gt;&gt; Sent from my iPad<br>&gt;&gt;<br>&gt;&gt; On 1 Jan 2016, at 11:16 AM, Kevin Ballard via swift-evolution &lt;swift-<br>&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; BufferedSequence is a sequence adaptor that wraps any underlying<br>&gt;&gt;&gt; sequence and provides a stable `first` property. BufferedGenerator<br>&gt;&gt;&gt; is a generator adaptor that wraps any underlying generator and<br>&gt;&gt;&gt; provides arbitrary lookahead with a `peek(n: Int)` method.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The method name &quot;peek()&quot; has precedent in various languages (e.g.<br>&gt;&gt;&gt; Rust with std::iter::Peekable, C++ with std::basic_istream::peek,<br>&gt;&gt;&gt; Ruby with Enumerator#peek, etc). I considered the name &quot;lookahead()&quot;<br>&gt;&gt;&gt; but I decided it made more sense to use that name for the property<br>&gt;&gt;&gt; that describes how much lookahead there is.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The proposed API looks like this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; /// A sequence adaptor that adds a nondestructive `first` property<br>&gt;&gt;&gt; to any /// underlying sequence. /// - Note: If the underlying<br>&gt;&gt;&gt; sequence is not destructively &quot;consumed&quot; by ///   iteration, then<br>&gt;&gt;&gt; neither is `BufferedSequence`. public class BufferedSequence&lt;Base :<br>&gt;&gt;&gt; SequenceType&gt; : SequenceType { public init(_ base: Base)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; /// Returns ` BufferedGenerator` with a lookahead size of `1`.<br>&gt;&gt;&gt; public func generate() -&gt;<br>&gt;&gt;&gt; BufferedSequence.BufferedGenerator&lt;Base.Generator&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; /// Returns the first element of the underlying sequence,<br>&gt;&gt;&gt; **nondestructively**. public var first: Base.Generator.Element? {<br>&gt;&gt;&gt; get } }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; /// A generator adaptor that adds a nondestructive `peek()` method<br>&gt;&gt;&gt; to any /// underlying generator. public struct<br>&gt;&gt;&gt; BufferedGenerator&lt;Base : GeneratorType&gt; : GeneratorType { ///<br>&gt;&gt;&gt; Construct an instance that buffers access to an underlying<br>&gt;&gt;&gt; generator. /// - Parameter base: The underlying generator. /// -<br>&gt;&gt;&gt; Parameter lookahead: The amount of lookahead to allow. Default is<br>&gt;&gt;&gt; `1`. ///   Values less than `1` will be treated the same as `1`.<br>&gt;&gt;&gt; public init(_ base: Base, lookahead: Int = default)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; /// The amount of lookahead that this generator offers. /// -<br>&gt;&gt;&gt; Invariant: `lookahead &gt;= 1`. public let lookahead: Int<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; /// Advance to the next element and return it, or `nil` if no next<br>&gt;&gt;&gt; element exists. /// /// - Requires: Neither `next()` nor `peek()`<br>&gt;&gt;&gt; have been applied to a copy of ///   `self` since the copy was made,<br>&gt;&gt;&gt; and no preceding call to `self.next()` has ///   returned `nil`.<br>&gt;&gt;&gt; public mutating func next() -&gt; Base.Element?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; /// Returns the value that will be returned from subsequent calls to<br>&gt;&gt;&gt; `next()`. /// - Parameter n: The number of elements to look ahead.<br>&gt;&gt;&gt; Default is `0`. A value ///   of `0` means to look at the next<br>&gt;&gt;&gt; element. /// - Precondition: `n &gt;= 0 &amp;&amp; n &lt; lookahead`. /// -<br>&gt;&gt;&gt; Requires: Neither `next()` nor `peek()` have been applied to a copy<br>&gt;&gt;&gt; of ///   `self` since the copy was made, and no preceding call to<br>&gt;&gt;&gt; `self.next()` has ///   returned `nil`. /// - Note: It is safe to<br>&gt;&gt;&gt; peek at values past the end of the underlying generator ///<br>&gt;&gt;&gt; (`peek()` will return `nil` in such cases). It is also safe to call<br>&gt;&gt;&gt; `peek()` ///  repeatedly, even after it&#39;s returned `nil`, and<br>&gt;&gt;&gt; similarly it is safe to call ///  `next()` after `peek()` has<br>&gt;&gt;&gt; returned `nil`. public mutating func peek(n: Int = default) -&gt;<br>&gt;&gt;&gt; Base.Element? }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; BufferedSequence is a class because the generate() function needs to<br>&gt;&gt;&gt; mutate it. After the `first` property has been accessed, it needs to<br>&gt;&gt;&gt; cache the generator it used for that so it can return it from the<br>&gt;&gt;&gt; next call to generate(), but it also needs to nil out that cache at<br>&gt;&gt;&gt; that time so it doesn&#39;t try and return the same generator instance a<br>&gt;&gt;&gt; second time on a subsequent call to generate() (this way<br>&gt;&gt;&gt; BufferedSequence can be written to support non-destructive iteration<br>&gt;&gt;&gt; if the underlying sequence is non-destructive).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;ve already started sketching out an implementation as well. I<br>&gt;&gt;&gt; believe it should be possible to optimize BufferedGenerator for a<br>&gt;&gt;&gt; lookahead of 1 to avoid the heap allocation of an array.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160101/0b45c01e/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Add types BufferedSequence, BufferedGenerator</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>January  1, 2016 at 07:00:00pm</p></header><div class="content"><p>Incidentally I forgot to mention that I’d also want to add:<br></p><p>extension SequenceType {<br>    /// Returns a `BufferedSequence` that wraps `self`.<br>    /// - SeeAlso: `BufferedSequence&lt;Base&gt;`.<br>    public var buffered: BufferedSequence&lt;Self&gt; { get }<br>}<br></p><p>extension BufferedSequence {<br>    /// Identical to `self`.<br>    public var buffered: BufferedSequence&lt;Base&gt; { get }<br>}<br></p><p>extension GeneratorType {<br>    /// Returns a `BufferedGenerator` that wraps `self`.<br>    /// - Parameter lookahead: The amount of lookahead to allow. Default is `1`.<br>    /// - Note: The new generator should be considered a copy of `self` for the<br>    ///   purposes of evaluating requirements (e.g. for `next()`).<br>    /// - SeeAlso: `BufferedGenerator&lt;Base&gt;`.<br>    public func buffered(lookahead: Int = default) -&gt; BufferedGenerator&lt;Self&gt;<br>}<br></p><p>extension BufferedGenerator {<br>    /// Returns a new `BufferedGenerator` that wraps `self.base`.<br>    /// If `lookahead &lt; self.lookahead`, the new generator may have a lookahead<br>    /// that&#39;s larger than `lookahead` if necessary to avoid losing elements.<br>    /// - Parameter lookahead: The amount of lookahead to allow. Default is `1`.<br>    /// - Invariant: The sequence of elements returned from calling `next()` on<br>    ///   the new generator is identical to the sequence of elements that would<br>    ///   have been returned from calling `next()` on `self` regardless of any<br>    ///   changes to the lookahead amount.<br>    /// - Note: The new generator should be considered a copy of `self` for the<br>    ///   purposes of evaluating requirements (e.g. for `next()`).<br>    public func buffered(lookahead: Int = default) -&gt; BufferedGenerator&lt;Base&gt;<br>}<br></p><p>As well as exposing the base sequence/generator on both types through a property named `base`.<br></p><p>-Kevin Ballard<br></p><p>&gt; On Dec 31, 2015, at 4:16 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; <br>&gt; BufferedSequence is a sequence adaptor that wraps any underlying sequence and provides a stable `first` property. BufferedGenerator is a generator adaptor that wraps any underlying generator and provides arbitrary lookahead with a `peek(n: Int)` method.<br>&gt;  <br>&gt; The method name &quot;peek()&quot; has precedent in various languages (e.g. Rust with std::iter::Peekable, C++ with std::basic_istream::peek, Ruby with Enumerator#peek, etc). I considered the name &quot;lookahead()&quot; but I decided it made more sense to use that name for the property that describes how much lookahead there is.<br>&gt;  <br>&gt; The proposed API looks like this:<br>&gt;  <br>&gt; /// A sequence adaptor that adds a nondestructive `first` property to any<br>&gt; /// underlying sequence.<br>&gt; /// - Note: If the underlying sequence is not destructively &quot;consumed&quot; by<br>&gt; ///   iteration, then neither is `BufferedSequence`.<br>&gt; public class BufferedSequence&lt;Base : SequenceType&gt; : SequenceType {<br>&gt;     public init(_ base: Base)<br>&gt; <br>&gt;     /// Returns ` BufferedGenerator` with a lookahead size of `1`.<br>&gt;     public func generate() -&gt; BufferedSequence.BufferedGenerator&lt;Base.Generator&gt;<br>&gt; <br>&gt;     /// Returns the first element of the underlying sequence, **nondestructively**.<br>&gt;     public var first: Base.Generator.Element? { get }<br>&gt; }<br>&gt; <br>&gt; /// A generator adaptor that adds a nondestructive `peek()` method to any<br>&gt; /// underlying generator.<br>&gt; public struct BufferedGenerator&lt;Base : GeneratorType&gt; : GeneratorType {<br>&gt;     /// Construct an instance that buffers access to an underlying generator.<br>&gt;     /// - Parameter base: The underlying generator.<br>&gt;     /// - Parameter lookahead: The amount of lookahead to allow. Default is `1`.<br>&gt;     ///   Values less than `1` will be treated the same as `1`.<br>&gt;     public init(_ base: Base, lookahead: Int = default)<br>&gt; <br>&gt;     /// The amount of lookahead that this generator offers.<br>&gt;     /// - Invariant: `lookahead &gt;= 1`.<br>&gt;     public let lookahead: Int<br>&gt; <br>&gt;     /// Advance to the next element and return it, or `nil` if no next element exists.<br>&gt;     ///<br>&gt;     /// - Requires: Neither `next()` nor `peek()` have been applied to a copy of<br>&gt;     ///   `self` since the copy was made, and no preceding call to `self.next()` has<br>&gt;     ///   returned `nil`.<br>&gt;     public mutating func next() -&gt; Base.Element?<br>&gt; <br>&gt;     /// Returns the value that will be returned from subsequent calls to `next()`.<br>&gt;     /// - Parameter n: The number of elements to look ahead. Default is `0`. A value<br>&gt;     ///   of `0` means to look at the next element.<br>&gt;     /// - Precondition: `n &gt;= 0 &amp;&amp; n &lt; lookahead`.<br>&gt;     /// - Requires: Neither `next()` nor `peek()` have been applied to a copy of<br>&gt;     ///   `self` since the copy was made, and no preceding call to `self.next()` has<br>&gt;     ///   returned `nil`.<br>&gt;     /// - Note: It is safe to peek at values past the end of the underlying generator<br>&gt;     ///  (`peek()` will return `nil` in such cases). It is also safe to call `peek()`<br>&gt;     ///  repeatedly, even after it&#39;s returned `nil`, and similarly it is safe to call<br>&gt;     ///  `next()` after `peek()` has returned `nil`.<br>&gt;     public mutating func peek(n: Int = default) -&gt; Base.Element?<br>&gt; }<br>&gt; <br>&gt; BufferedSequence is a class because the generate() function needs to mutate it. After the `first` property has been accessed, it needs to cache the generator it used for that so it can return it from the next call to generate(), but it also needs to nil out that cache at that time so it doesn&#39;t try and return the same generator instance a second time on a subsequent call to generate() (this way BufferedSequence can be written to support non-destructive iteration if the underlying sequence is non-destructive).<br>&gt;  <br>&gt; I&#39;ve already started sketching out an implementation as well. I believe it should be possible to optimize BufferedGenerator for a lookahead of 1 to avoid the heap allocation of an array.<br>&gt;  <br>&gt; -Kevin Ballard<br>&gt;  <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160101/a153d762/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
