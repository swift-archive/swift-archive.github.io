<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9b5e7f229ebf32c8eca02e7cee0f379f?s=50"></div><header><strong>Proposal: Add a sequence-based initializer to Dictionary</strong> from <string>Nicola Salmoria</string> &lt;nicola.salmoria at gmail.com&gt;<p>January 15, 2016 at 11:00:00am</p></header><div class="content"><p>To handle the case of duplicate keys, why not allow to pass in a &#39;combine&#39;<br>function?<br>The function could default to a preconditionFailure to be consistent with<br>the DictionaryLiteral behavior, but be overridden by the caller as needed.<br></p><p>extension Dictionary {<br>    /// Creates a dictionary with the keys and values in the given sequence.<br>    init&lt;S: SequenceType where S.Generator.Element == Generator.Element&gt;(_<br>sequence: S, combine: (existing: Value, other: Value) -&gt; Value = {<br>preconditionFailure(&quot;Sequence contains duplicate keys&quot;); return $1 } ) {<br>        self.init()<br>        for (key, value) in sequence {<br>            if let existing = updateValue(value, forKey: key) {<br>                updateValue(combine(existing: existing, other: value),<br>forKey: key)<br>            }<br>        }<br>    }<br>}<br></p><p><br>usage examples:<br></p><p>let samples = [(&quot;Rome&quot;, 40.2), (&quot;New York&quot;, 35.1), (&quot;Rome&quot;, 42.5), (&quot;New<br>York&quot;, 32.8)]<br>let minTemperatures = Dictionary(samples, combine: min)<br>// [&quot;Rome&quot;: 40.2, &quot;New York&quot;: 32.8]<br>let maxTemperatures = Dictionary(samples, combine: max)<br>// [&quot;Rome&quot;: 42.5, &quot;New York&quot;: 35.1]<br></p><p>let probabilities = [(&quot;a&quot;, 0.25), (&quot;b&quot;, 0.25), (&quot;c&quot;, 0.25), (&quot;a&quot;, 0.25)]<br>let stateProbabilities = Dictionary(probabilities, combine: +)<br>// [&quot;b&quot;: 0.25, &quot;a&quot;: 0.5, &quot;c&quot;: 0.25]<br></p><p><br>Nicola<br></p><p><br>&gt; A brief draft is below... I had mostly written this up before I saw the<br>thread and Gwendal&#39;s similar contribution -- happy to hear feedback and<br>fold in comments/revisions!<br>&gt;<br>&gt; Nate<br>&gt;<br>&gt;<br>&gt; ---<br>&gt;<br>&gt;<br>&gt; Introduction<br>&gt;<br>&gt; The Dictionary type should allow initialization from a sequence of (Key,<br>Value) tuples.<br>&gt;<br>&gt; Motivation<br>&gt;<br>&gt; Array and Set both have initializers that create a new instance from a<br>sequence of elements. The Array initializer is useful for converting other<br>sequences and collections to the &quot;standard&quot; collection type, but the Set<br>initializer is essential for recovering set operations after performing any<br>functional operations on a set. For example, filtering a set produces a<br>collection without any kind of set operations available:<br>&gt;<br>&gt; let numberSet = Set(1 ... 100)<br>&gt; let fivesOnly = numberSet.lazy.filter { $0 % 5 == 0 }<br>&gt;<br>&gt; &quot;fivesOnly&quot; is a LazyFilterCollection&lt;Set&lt;Int&gt;&gt; instead of a Set --<br>sending that back through the Set sequence initializer restores the<br>expected methods:<br>&gt;<br>&gt; let fivesOnlySet = Set(numberSet.lazy.filter { $0 % 5 == 0 })<br>&gt; fivesOnlySet.isSubsetOf(numberSet) // true<br>&gt;<br>&gt; Dictionary, on the other hand, has no such initializer, so a similar<br>operation leaves no room except for building a mutable Dictionary via<br>iteration or functional methods with dubious performance. These techniques<br>also don&#39;t support type inference from the source sequence, increasing<br>verbosity:<br>&gt;<br>&gt; var viaIteration: [String: Int] = [:]<br>&gt; for (key, value) in evenOnly {<br>&gt;     viaIteration[key] = value<br>&gt; }<br>&gt;<br>&gt; let viaFunction: [String: Int] = evenOnly.reduce([:]) { (cumulative,<br>keyValue) in<br>&gt;     var mutableDictionary = cumulative<br>&gt;     mutableDictionary[keyValue.0] = keyValue.1<br>&gt;     return mutableDictionary<br>&gt; }<br>&gt;<br>&gt; Proposed solution<br>&gt;<br>&gt; The proposed solution would add an initializer to Dictionary that accepts<br>any sequence of (Key, Value) tuple pairs, matching the Dictionary&#39;s element<br>type when treated as a sequence:<br>&gt;<br>&gt; init&lt;S: SequenceType where S.Generator.Element == Generator.Element&gt;(_<br>sequence: S)<br>&gt;<br>&gt; Instead of the techniques for recovering a Dictionary shown above, the<br>proposed initializer would allow a much cleaner syntax to be written:<br>&gt;<br>&gt; let viaProposed = Dictionary(evenOnly)<br>&gt;<br>&gt; Moreover, this new initializer would allow for some convenient uses that<br>aren&#39;t currently possible.<br>&gt;<br>&gt; ???? Initializing from an array of tuples:<br>&gt;<br>&gt; let dictFromArray = Dictionary([(&quot;a&quot;, 1), (&quot;b&quot;, 2), (&quot;c&quot;, 3), (&quot;d&quot;, 4)])<br>&gt;<br>&gt; ???? Initializing from a DictionaryLiteral (the type, not an actual<br>literal):<br>&gt;<br>&gt; let literal: DictionaryLiteral = [&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3, &quot;d&quot;: 4]<br>&gt; let dictFromDL = Dictionary(literal)<br>&gt;<br>&gt; ?? Initializing from a pair of zipped sequences (examples abound):<br>&gt;<br>&gt; let letters = &quot;abcdefghij&quot;.characters.lazy.map { String($0) }<br>&gt; let dictFromZip = Dictionary(zip(letters, 1...10))<br>&gt; // [&quot;b&quot;: 2, &quot;a&quot;: 1, &quot;i&quot;: 9, &quot;j&quot;: 10, &quot;c&quot;: 3, &quot;e&quot;: 5, &quot;f&quot;: 6, &quot;g&quot;: 7, &quot;d&quot;:<br>4, &quot;h&quot;: 8]<br>&gt;<br>&gt; Potential pitfalls<br>&gt;<br>&gt; One caveat is that the new initializer doesn&#39;t prevent using a sequence<br>with multiple identical keys. In such a case, the last key/value would<br>&quot;win&quot; and exist in the dictionary. Such an initialization is a compile-time<br>error with a dictionary literal, but succeeds under the new initializer:<br>&gt;<br>&gt; let _ = [&quot;z&quot;: 1, &quot;z&quot;: 2, &quot;z&quot;: 3, &quot;z&quot;: 4]<br>&gt; // fatal error: Dictionary literal contains duplicate keys<br>&gt; Dictionary([(&quot;z&quot;, 1), (&quot;z&quot;, 2), (&quot;z&quot;, 3), (&quot;z&quot;, 4)])<br>&gt; // [&quot;z&quot;: 4]<br>&gt;<br>&gt; This behavior is particularly troublesome when used in conjunction with a<br>mapping operation that modifies a dictionary&#39;s keys, since dictionaries<br>have no particular guaranteed order:<br>&gt;<br>&gt; let overlapping = Dictionary(dictFromArray.lazy.map { (_, value) in (&quot;z&quot;,<br>value) })<br>&gt; // [&quot;z&quot;: ???]<br>&gt;<br>&gt; While a pitfall, this behavior is less a symptom of the proposed API and<br>more an inherent problem with recovering a dictionary after modifying its<br>keys. The current ways of rebuilding a dictionary (as shown above) are just<br>as susceptible to silently dropping values. Moreover, the sequence-based<br>initializer for Set exhibits the same behavior, though slightly less<br>problematic in most cases:<br>&gt;<br>&gt; let dividedNumbers = Set(numberSet.map { $0 / 20 })<br>&gt; // {4, 5, 2, 0, 1, 3}<br>&gt;<br>&gt; Given the potential lossiness of the initializer, should it use a<br>parameter name for the sequence? I would suggest not, to match the syntax<br>of Array.init(_:) and Set.init(_:), but a parameter like &quot;collapsingKeys&quot;<br>would make the risk clear to users.<br>&gt;<br>&gt; Detailed design<br>&gt;<br>&gt; The implementation is simple enough to show in the proposal:<br>&gt;<br>&gt; extension Dictionary {<br>&gt;     /// Creates a dictionary with the keys and values in the given<br>sequence.<br>&gt;     init&lt;S: SequenceType where S.Generator.Element ==<br>Generator.Element&gt;(_ sequence: S) {<br>&gt;         self.init()<br>&gt;         for (key, value) in sequence {<br>&gt;             updateValue(value, forKey: key)<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; (As part of the standard library, this could use the nativeUpdateValue<br>method.)<br>&gt;<br>&gt; Impact on existing code<br>&gt;<br>&gt; As a new API, this will have no impact on existing code.<br>&gt;<br>&gt; Alternatives considered<br>&gt;<br>&gt; As suggested in the thread below, a method could be added to SequenceType<br>that would build a dictionary. This approach seems less of a piece with the<br>rest of the standard library, and overly verbose when used with a<br>Dictionary that is only passing through filtering or mapping operations. I<br>don&#39;t think the current protocol extension system could handle a<br>passthrough case (i.e., something like &quot;extension SequenceType where<br>Generator.Element == (Key, Value)&quot;).<br>&gt;<br>&gt; Alternately, the status quo could be maintained. Which would be sad.<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; &gt; On Jan 13, 2016, at 11:55 AM, Gwendal Roué via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Doesn’t Swift prefer initializers?<br>&gt; &gt;<br>&gt; &gt; So let’s build a Dictionary initializer that eats any sequence of (key,<br>value) pairs:<br>&gt; &gt;<br>&gt; &gt; extension Dictionary {<br>&gt; &gt;     init&lt;S: SequenceType where S.Generator.Element == (Key,<br>Value)&gt;(keyValueSequence s: S) {<br>&gt; &gt;         self.init()<br>&gt; &gt;         for (key, value) in s {<br>&gt; &gt;             self[key] = value<br>&gt; &gt;         }<br>&gt; &gt;     }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; do {<br>&gt; &gt;     // From array of (key, value) pairs<br>&gt; &gt;     let input = [(&quot;foo&quot;, 1), (&quot;bar&quot;, 2)]<br>&gt; &gt;     let d = Dictionary(keyValueSequence: input)<br>&gt; &gt;     print(d)<br>&gt; &gt; }<br>&gt; &gt; do {<br>&gt; &gt;     // From another dictionary<br>&gt; &gt;     let input = [1: &quot;foo&quot;, 2: &quot;bar&quot;]<br>&gt; &gt;     let d = Dictionary(keyValueSequence: input)<br>&gt; &gt;     print(d)<br>&gt; &gt; }<br>&gt; &gt; do {<br>&gt; &gt;     // Reverse key and values<br>&gt; &gt;     let input = [1: &quot;foo&quot;, 2: &quot;bar&quot;]<br>&gt; &gt;     let d = Dictionary(keyValueSequence: input.map { ($1, $0) })<br>&gt; &gt;     print(d)<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; Gwendal<br>&gt; &gt;<br>&gt; &gt;&gt; Le 13 janv. 2016 à 18:41, Thorsten Seitz via swift-evolution<br>&lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a<br>écrit :<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I&#39;d prefer &quot;mapToDict&quot; otherwise it sounds like a dictionary gets<br>mapped, at least for me.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; -Thorsten<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; Am 13.01.2016 um 17:13 schrieb Kenny Leung via swift-evolution<br>&lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; This solution looks great! How do you feel about “mapDict”?<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; -Kenny<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; On Jan 12, 2016, at 10:28 AM, Craig Cruden &lt;ccruden at novafore.com<br>&lt;mailto:ccruden at novafore.com&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; I named the method(s) „toDict“ instead of „map“ because map<br>normally returns a collection which is either the same as the receiver or a<br>simple one.<br>&gt; &gt;&gt;&gt;&gt;&gt; The second version is more general and allows to do things like<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; let dict = [&quot;Tom&quot;, &quot;Dick&quot;, &quot;Harry&quot;].enumerate().toDict { (index,<br>value) in (index + 1, value) }<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Map would probably be a more correct mathematically speaking — but<br>it would be inconsistent with the naming convention already chosen for<br>Swift.  So for Swift - toDict (or toDictionary) would be the best choice.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160115/f003880c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7411024ff3fb3fdbb0624c41b72a1b92?s=50"></div><header><strong>Proposal: Add a sequence-based initializer to Dictionary</strong> from <string>Alan Skipp</string> &lt;al_skipp at icloud.com&gt;<p>January 15, 2016 at 10:00:00am</p></header><div class="content"><p>I’ve been absorbed in the world of Monoids lately, so I find the suggestion below to be particularly brilliant. : )<br>It solves the issue of arbitrarily choosing the value for duplicate keys rather nicely. Only thing I’m not too sure about is the idea of failing by default on duplicate keys?<br></p><p>&gt; On 15 Jan 2016, at 10:18, Nicola Salmoria via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; To handle the case of duplicate keys, why not allow to pass in a &#39;combine&#39; function?<br>&gt; The function could default to a preconditionFailure to be consistent with the DictionaryLiteral behavior, but be overridden by the caller as needed.<br>&gt; <br>&gt; extension Dictionary {<br>&gt;     /// Creates a dictionary with the keys and values in the given sequence.<br>&gt;     init&lt;S: SequenceType where S.Generator.Element == Generator.Element&gt;(_ sequence: S, combine: (existing: Value, other: Value) -&gt; Value = { preconditionFailure(&quot;Sequence contains duplicate keys&quot;); return $1 } ) {<br>&gt;         self.init()<br>&gt;         for (key, value) in sequence {<br>&gt;             if let existing = updateValue(value, forKey: key) {<br>&gt;                 updateValue(combine(existing: existing, other: value), forKey: key)<br>&gt;             }<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; usage examples:<br>&gt; <br>&gt; let samples = [(&quot;Rome&quot;, 40.2), (&quot;New York&quot;, 35.1), (&quot;Rome&quot;, 42.5), (&quot;New York&quot;, 32.8)]<br>&gt; let minTemperatures = Dictionary(samples, combine: min)<br>&gt; // [&quot;Rome&quot;: 40.2, &quot;New York&quot;: 32.8]<br>&gt; let maxTemperatures = Dictionary(samples, combine: max)<br>&gt; // [&quot;Rome&quot;: 42.5, &quot;New York&quot;: 35.1]<br>&gt; <br>&gt; let probabilities = [(&quot;a&quot;, 0.25), (&quot;b&quot;, 0.25), (&quot;c&quot;, 0.25), (&quot;a&quot;, 0.25)]<br>&gt; let stateProbabilities = Dictionary(probabilities, combine: +)<br>&gt; // [&quot;b&quot;: 0.25, &quot;a&quot;: 0.5, &quot;c&quot;: 0.25]<br>&gt; <br>&gt; <br>&gt; Nicola<br></p><p>It’d be great if there was also an init that restricted the Values to Monoids, which would mean the combine function would be taken from the supplied Monoid values (I understand I’ve departed to fantasy island at this point, but one can dream : )<br></p><p>Al<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160115/4c683865/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f5228ad4a1fad94f1a7d3d05b0c0ff6a?s=50"></div><header><strong>Proposal: Add a sequence-based initializer to Dictionary</strong> from <string>Donnacha Oisín Kidney</string> &lt;oisin.kidney at gmail.com&gt;<p>January 15, 2016 at 02:00:00pm</p></header><div class="content"><p>I think the idea of a combine closure is great - it lets users of the initialiser decide on whether or not the want duplicate keys to be an error. Also, the default “silently keep the last value” behaviour can be provided as the default closure. I also think that a closure (probably) gives enough flexibility to do most of the interesting things you might do with dictionaries (a “frequencies” function, or “categorise”, for instance).<br></p><p>extension Dictionary {<br>  /// Creates a dictionary with the keys and values in the given sequence.<br>  /// Takes a closure which is called on the values of duplicate keys. The<br>  /// default behaviour is that the last value for a duplicate key is kept.<br>  init&lt;S: SequenceType where S.Generator.Element == (Key,Value)&gt;<br>    (_ sequence: S, combine: (Value,Value) -&gt; Value = { (_,snd) in snd } ) {<br>    self.init()<br>    for (k,v) in sequence {<br>      self[k] = self[k].map { fst in combine(fst,v) } ?? v<br>    }<br>  }<br>}<br></p><p>extension SequenceType where Generator.Element: Hashable {<br>  func frequencies() -&gt; [Generator.Element:Int] {<br>    return Dictionary(self.lazy.map { v in (v,1) }, combine: +)<br>  }<br>}<br></p><p>&quot;hello&quot;.characters.frequencies() // [&quot;e&quot;: 1, &quot;o&quot;: 1, &quot;l&quot;: 2, &quot;h&quot;: 1]<br></p><p> <br>&gt; On 15 Jan 2016, at 10:53, Alan Skipp via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I’ve been absorbed in the world of Monoids lately, so I find the suggestion below to be particularly brilliant. : )<br>&gt; It solves the issue of arbitrarily choosing the value for duplicate keys rather nicely. Only thing I’m not too sure about is the idea of failing by default on duplicate keys?<br>&gt; <br>&gt;&gt; On 15 Jan 2016, at 10:18, Nicola Salmoria via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; To handle the case of duplicate keys, why not allow to pass in a &#39;combine&#39; function?<br>&gt;&gt; The function could default to a preconditionFailure to be consistent with the DictionaryLiteral behavior, but be overridden by the caller as needed.<br>&gt;&gt; <br>&gt;&gt; extension Dictionary {<br>&gt;&gt;     /// Creates a dictionary with the keys and values in the given sequence.<br>&gt;&gt;     init&lt;S: SequenceType where S.Generator.Element == Generator.Element&gt;(_ sequence: S, combine: (existing: Value, other: Value) -&gt; Value = { preconditionFailure(&quot;Sequence contains duplicate keys&quot;); return $1 } ) {<br>&gt;&gt;         self.init()<br>&gt;&gt;         for (key, value) in sequence {<br>&gt;&gt;             if let existing = updateValue(value, forKey: key) {<br>&gt;&gt;                 updateValue(combine(existing: existing, other: value), forKey: key)<br>&gt;&gt;             }<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; usage examples:<br>&gt;&gt; <br>&gt;&gt; let samples = [(&quot;Rome&quot;, 40.2), (&quot;New York&quot;, 35.1), (&quot;Rome&quot;, 42.5), (&quot;New York&quot;, 32.8)]<br>&gt;&gt; let minTemperatures = Dictionary(samples, combine: min)<br>&gt;&gt; // [&quot;Rome&quot;: 40.2, &quot;New York&quot;: 32.8]<br>&gt;&gt; let maxTemperatures = Dictionary(samples, combine: max)<br>&gt;&gt; // [&quot;Rome&quot;: 42.5, &quot;New York&quot;: 35.1]<br>&gt;&gt; <br>&gt;&gt; let probabilities = [(&quot;a&quot;, 0.25), (&quot;b&quot;, 0.25), (&quot;c&quot;, 0.25), (&quot;a&quot;, 0.25)]<br>&gt;&gt; let stateProbabilities = Dictionary(probabilities, combine: +)<br>&gt;&gt; // [&quot;b&quot;: 0.25, &quot;a&quot;: 0.5, &quot;c&quot;: 0.25]<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Nicola<br>&gt; <br>&gt; It’d be great if there was also an init that restricted the Values to Monoids, which would mean the combine function would be taken from the supplied Monoid values (I understand I’ve departed to fantasy island at this point, but one can dream : )<br>&gt; <br>&gt; Al<br>&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160115/13427967/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Proposal: Add a sequence-based initializer to Dictionary</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January 15, 2016 at 03:00:00pm</p></header><div class="content"><p>+1<br></p><p>-Thorsten <br></p><p>&gt; Am 15.01.2016 um 15:32 schrieb Donnacha Oisín Kidney via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; I think the idea of a combine closure is great - it lets users of the initialiser decide on whether or not the want duplicate keys to be an error. Also, the default “silently keep the last value” behaviour can be provided as the default closure. I also think that a closure (probably) gives enough flexibility to do most of the interesting things you might do with dictionaries (a “frequencies” function, or “categorise”, for instance).<br>&gt; <br>&gt; extension Dictionary {<br>&gt;   /// Creates a dictionary with the keys and values in the given sequence.<br>&gt;   /// Takes a closure which is called on the values of duplicate keys. The<br>&gt;   /// default behaviour is that the last value for a duplicate key is kept.<br>&gt;   init&lt;S: SequenceType where S.Generator.Element == (Key,Value)&gt;<br>&gt;     (_ sequence: S, combine: (Value,Value) -&gt; Value = { (_,snd) in snd } ) {<br>&gt;     self.init()<br>&gt;     for (k,v) in sequence {<br>&gt;       self[k] = self[k].map { fst in combine(fst,v) } ?? v<br>&gt;     }<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; extension SequenceType where Generator.Element: Hashable {<br>&gt;   func frequencies() -&gt; [Generator.Element:Int] {<br>&gt;     return Dictionary(self.lazy.map { v in (v,1) }, combine: +)<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; &quot;hello&quot;.characters.frequencies() // [&quot;e&quot;: 1, &quot;o&quot;: 1, &quot;l&quot;: 2, &quot;h&quot;: 1]<br>&gt; <br>&gt;  <br>&gt;&gt; On 15 Jan 2016, at 10:53, Alan Skipp via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I’ve been absorbed in the world of Monoids lately, so I find the suggestion below to be particularly brilliant. : )<br>&gt;&gt; It solves the issue of arbitrarily choosing the value for duplicate keys rather nicely. Only thing I’m not too sure about is the idea of failing by default on duplicate keys?<br>&gt;&gt; <br>&gt;&gt;&gt; On 15 Jan 2016, at 10:18, Nicola Salmoria via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To handle the case of duplicate keys, why not allow to pass in a &#39;combine&#39; function?<br>&gt;&gt;&gt; The function could default to a preconditionFailure to be consistent with the DictionaryLiteral behavior, but be overridden by the caller as needed.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Dictionary {<br>&gt;&gt;&gt;     /// Creates a dictionary with the keys and values in the given sequence.<br>&gt;&gt;&gt;     init&lt;S: SequenceType where S.Generator.Element == Generator.Element&gt;(_ sequence: S, combine: (existing: Value, other: Value) -&gt; Value = { preconditionFailure(&quot;Sequence contains duplicate keys&quot;); return $1 } ) {<br>&gt;&gt;&gt;         self.init()<br>&gt;&gt;&gt;         for (key, value) in sequence {<br>&gt;&gt;&gt;             if let existing = updateValue(value, forKey: key) {<br>&gt;&gt;&gt;                 updateValue(combine(existing: existing, other: value), forKey: key)<br>&gt;&gt;&gt;             }<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; usage examples:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let samples = [(&quot;Rome&quot;, 40.2), (&quot;New York&quot;, 35.1), (&quot;Rome&quot;, 42.5), (&quot;New York&quot;, 32.8)]<br>&gt;&gt;&gt; let minTemperatures = Dictionary(samples, combine: min)<br>&gt;&gt;&gt; // [&quot;Rome&quot;: 40.2, &quot;New York&quot;: 32.8]<br>&gt;&gt;&gt; let maxTemperatures = Dictionary(samples, combine: max)<br>&gt;&gt;&gt; // [&quot;Rome&quot;: 42.5, &quot;New York&quot;: 35.1]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let probabilities = [(&quot;a&quot;, 0.25), (&quot;b&quot;, 0.25), (&quot;c&quot;, 0.25), (&quot;a&quot;, 0.25)]<br>&gt;&gt;&gt; let stateProbabilities = Dictionary(probabilities, combine: +)<br>&gt;&gt;&gt; // [&quot;b&quot;: 0.25, &quot;a&quot;: 0.5, &quot;c&quot;: 0.25]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Nicola<br>&gt;&gt; <br>&gt;&gt; It’d be great if there was also an init that restricted the Values to Monoids, which would mean the combine function would be taken from the supplied Monoid values (I understand I’ve departed to fantasy island at this point, but one can dream : )<br>&gt;&gt; <br>&gt;&gt; Al<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160115/13fb9c92/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9b5e7f229ebf32c8eca02e7cee0f379f?s=50"></div><header><strong>Proposal: Add a sequence-based initializer to Dictionary</strong> from <string>Nicola Salmoria</string> &lt;nicola.salmoria at gmail.com&gt;<p>January 15, 2016 at 04:00:00pm</p></header><div class="content"><p>I&#39;m ambivalent about the preconditionFailure. Since there would otherwise<br>be silent loss of data, I think it fits Swift&#39;s &quot;safe by default&quot; paradigm.<br>It&#39;s also consistent with what the normal initialization from a<br>DictionaryLiteral does.<br>However, I can also see how it might be more convenient to just pick the<br>last value.<br></p><p>Nicola<br></p><p>On Fri, Jan 15, 2016 at 11:53 AM, Alan Skipp &lt;al_skipp at icloud.com&gt; wrote:<br></p><p>&gt; I’ve been absorbed in the world of Monoids lately, so I find the<br>&gt; suggestion below to be particularly brilliant. : )<br>&gt; It solves the issue of arbitrarily choosing the value for duplicate keys<br>&gt; rather nicely. Only thing I’m not too sure about is the idea of failing by<br>&gt; default on duplicate keys?<br>&gt;<br>&gt; On 15 Jan 2016, at 10:18, Nicola Salmoria via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; To handle the case of duplicate keys, why not allow to pass in a &#39;combine&#39;<br>&gt; function?<br>&gt; The function could default to a preconditionFailure to be consistent with<br>&gt; the DictionaryLiteral behavior, but be overridden by the caller as needed.<br>&gt;<br>&gt; extension Dictionary {<br>&gt;     /// Creates a dictionary with the keys and values in the given<br>&gt; sequence.<br>&gt;     init&lt;S: SequenceType where S.Generator.Element == Generator.Element&gt;(_<br>&gt; sequence: S, combine: (existing: Value, other: Value) -&gt; Value = {<br>&gt; preconditionFailure(&quot;Sequence contains duplicate keys&quot;); return $1 } ) {<br>&gt;         self.init()<br>&gt;         for (key, value) in sequence {<br>&gt;             if let existing = updateValue(value, forKey: key) {<br>&gt;                 updateValue(combine(existing: existing, other: value),<br>&gt; forKey: key)<br>&gt;             }<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; usage examples:<br>&gt;<br>&gt; let samples = [(&quot;Rome&quot;, 40.2), (&quot;New York&quot;, 35.1), (&quot;Rome&quot;, 42.5), (&quot;New<br>&gt; York&quot;, 32.8)]<br>&gt; let minTemperatures = Dictionary(samples, combine: min)<br>&gt; // [&quot;Rome&quot;: 40.2, &quot;New York&quot;: 32.8]<br>&gt; let maxTemperatures = Dictionary(samples, combine: max)<br>&gt; // [&quot;Rome&quot;: 42.5, &quot;New York&quot;: 35.1]<br>&gt;<br>&gt; let probabilities = [(&quot;a&quot;, 0.25), (&quot;b&quot;, 0.25), (&quot;c&quot;, 0.25), (&quot;a&quot;, 0.25)]<br>&gt; let stateProbabilities = Dictionary(probabilities, combine: +)<br>&gt; // [&quot;b&quot;: 0.25, &quot;a&quot;: 0.5, &quot;c&quot;: 0.25]<br>&gt;<br>&gt;<br>&gt; Nicola<br>&gt;<br>&gt;<br>&gt; It’d be great if there was also an init that restricted the Values to<br>&gt; Monoids, which would mean the combine function would be taken from the<br>&gt; supplied Monoid values (I understand I’ve departed to fantasy island at<br>&gt; this point, but one can dream : )<br>&gt;<br>&gt; Al<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160115/1e40a73f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5f463dd4e7af28b64ad8f0e032ee82dc?s=50"></div><header><strong>Proposal: Add a sequence-based initializer to Dictionary</strong> from <string>Nate Cook</string> &lt;natecook at gmail.com&gt;<p>January 16, 2016 at 01:00:00am</p></header><div class="content"><p>Adding a `combine` closure with Donnacha&#39;s default seems like a pretty good solution for this, but giving a `try`-marked closure parameter a default  messes with the rethrows behavior and requires a try on every call. I think it&#39;s important that when used by default, this initializer has the same behavior as looping over the sequence and setting values for keys. That is, it should replicate:<br></p><p>for (key, value) in sequence { <br>    newDictionary[key] = value <br>}<br></p><p>and use the last value for any duplicate keys, rather than failing or trapping.<br></p><p>To handle this properly we&#39;d need two new initializers:<br></p><p>init&lt;S: SequenceType where S.Generator.Element == Generator.Element&gt;(_ sequence: S)<br></p><p>init&lt;S: SequenceType where S.Generator.Element == Generator.Element&gt;<br>    (_ sequence: S, @noescape combine: (Value, Value) throws -&gt; Value) rethrows<br></p><p>Perhaps we also need a mutating `mergeContentsOf` function with the same signatures as the initializers:<br></p><p>mutating func mergeContentsOf&lt;S: SequenceType where S.Generator.Element == Generator.Element&gt;(_ sequence: S)<br></p><p>mutating func mergeContentsOf&lt;S: SequenceType where S.Generator.Element == Generator.Element&gt;<br>    (_ sequence: S, @noescape combine: (Value, Value) throws -&gt; Value) rethrows<br></p><p>I&#39;m pretty sure I would use all four of those, and that would bring Dictionary more into alignment with how you can use Array and Set. Would a slightly expanded proposal make sense?<br></p><p>Nate<br></p><p><br>&gt; On Jan 15, 2016, at 9:01 AM, Nicola Salmoria via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;m ambivalent about the preconditionFailure. Since there would otherwise be silent loss of data, I think it fits Swift&#39;s &quot;safe by default&quot; paradigm. It&#39;s also consistent with what the normal initialization from a DictionaryLiteral does.<br>&gt; However, I can also see how it might be more convenient to just pick the last value.<br>&gt; <br>&gt; Nicola<br>&gt; <br>&gt; On Fri, Jan 15, 2016 at 11:53 AM, Alan Skipp &lt;al_skipp at icloud.com &lt;mailto:al_skipp at icloud.com&gt;&gt; wrote:<br>&gt; I’ve been absorbed in the world of Monoids lately, so I find the suggestion below to be particularly brilliant. : )<br>&gt; It solves the issue of arbitrarily choosing the value for duplicate keys rather nicely. Only thing I’m not too sure about is the idea of failing by default on duplicate keys?<br>&gt; <br>&gt;&gt; On 15 Jan 2016, at 10:18, Nicola Salmoria via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; To handle the case of duplicate keys, why not allow to pass in a &#39;combine&#39; function?<br>&gt;&gt; The function could default to a preconditionFailure to be consistent with the DictionaryLiteral behavior, but be overridden by the caller as needed.<br>&gt;&gt; <br>&gt;&gt; extension Dictionary {<br>&gt;&gt;     /// Creates a dictionary with the keys and values in the given sequence.<br>&gt;&gt;     init&lt;S: SequenceType where S.Generator.Element == Generator.Element&gt;(_ sequence: S, combine: (existing: Value, other: Value) -&gt; Value = { preconditionFailure(&quot;Sequence contains duplicate keys&quot;); return $1 } ) {<br>&gt;&gt;         self.init()<br>&gt;&gt;         for (key, value) in sequence {<br>&gt;&gt;             if let existing = updateValue(value, forKey: key) {<br>&gt;&gt;                 updateValue(combine(existing: existing, other: value), forKey: key)<br>&gt;&gt;             }<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; usage examples:<br>&gt;&gt; <br>&gt;&gt; let samples = [(&quot;Rome&quot;, 40.2), (&quot;New York&quot;, 35.1), (&quot;Rome&quot;, 42.5), (&quot;New York&quot;, 32.8)]<br>&gt;&gt; let minTemperatures = Dictionary(samples, combine: min)<br>&gt;&gt; // [&quot;Rome&quot;: 40.2, &quot;New York&quot;: 32.8]<br>&gt;&gt; let maxTemperatures = Dictionary(samples, combine: max)<br>&gt;&gt; // [&quot;Rome&quot;: 42.5, &quot;New York&quot;: 35.1]<br>&gt;&gt; <br>&gt;&gt; let probabilities = [(&quot;a&quot;, 0.25), (&quot;b&quot;, 0.25), (&quot;c&quot;, 0.25), (&quot;a&quot;, 0.25)]<br>&gt;&gt; let stateProbabilities = Dictionary(probabilities, combine: +)<br>&gt;&gt; // [&quot;b&quot;: 0.25, &quot;a&quot;: 0.5, &quot;c&quot;: 0.25]<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Nicola<br>&gt; <br>&gt; It’d be great if there was also an init that restricted the Values to Monoids, which would mean the combine function would be taken from the supplied Monoid values (I understand I’ve departed to fantasy island at this point, but one can dream : )<br>&gt; <br>&gt; Al<br>&gt; <br>&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160116/869187ab/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9b5e7f229ebf32c8eca02e7cee0f379f?s=50"></div><header><strong>Proposal: Add a sequence-based initializer to Dictionary</strong> from <string>Nicola Salmoria</string> &lt;nicola.salmoria at gmail.com&gt;<p>January 16, 2016 at 11:00:00am</p></header><div class="content"><p>+1 for the mutating methods. That&#39;s a pretty common use case and would<br>nicely complement the Dictionary features.<br></p><p>As for the implementation details, I think all the examples we made are<br>inefficient, requiring two dictionary lookups to combine a value. In e.g.<br>C++ you can do something like this<br></p><p>auto it = m.find(x);<br>if (it != end(m)) {<br>   it-&gt;second = value;<br>}<br></p><p>In Swift we have<br></p><p>func indexForKey(key: Key) -&gt; DictionaryIndex&lt;Key, Value&gt;?<br></p><p>but then there are only<br></p><p>subscript(position: DictionaryIndex&lt;Key, Value&gt;) -&gt; (Key, Value) { get }<br>mutating func removeAtIndex(index: DictionaryIndex&lt;Key, Value&gt;) -&gt; (Key,<br>Value)<br></p><p>It would probably be appropriate to have a new method<br></p><p>mutating func updateValue(value: Value, atIndex: DictionaryIndex&lt;Key,<br>Value&gt;) -&gt; Value<br></p><p>which would allow to efficiently combine the values with a single lookup.<br></p><p>Nicola<br></p><p><br>On Sat, Jan 16, 2016 at 8:28 AM, Nate Cook &lt;natecook at gmail.com&gt; wrote:<br></p><p>&gt; Adding a `combine` closure with Donnacha&#39;s default seems like a pretty<br>&gt; good solution for this, but giving a `try`-marked closure parameter a<br>&gt; default  messes with the rethrows behavior and requires a try on every<br>&gt; call. I think it&#39;s important that when used by default, this initializer<br>&gt; has the same behavior as looping over the sequence and setting values for<br>&gt; keys. That is, it should replicate:<br>&gt;<br>&gt; for (key, value) in sequence {<br>&gt;     newDictionary[key] = value<br>&gt; }<br>&gt;<br>&gt; and use the last value for any duplicate keys, rather than failing or<br>&gt; trapping.<br>&gt;<br>&gt; To handle this properly we&#39;d need two new initializers:<br>&gt;<br>&gt; init&lt;S: SequenceType where S.Generator.Element == Generator.Element&gt;(_<br>&gt; sequence: S)<br>&gt;<br>&gt; init&lt;S: SequenceType where S.Generator.Element == Generator.Element&gt;<br>&gt;     (_ sequence: S, @noescape combine: (Value, Value) throws -&gt; Value)<br>&gt; rethrows<br>&gt;<br>&gt; Perhaps we also need a mutating `mergeContentsOf` function with the same<br>&gt; signatures as the initializers:<br>&gt;<br>&gt; mutating func mergeContentsOf&lt;S: SequenceType where S.Generator.Element<br>&gt; == Generator.Element&gt;(_ sequence: S)<br>&gt;<br>&gt; mutating func mergeContentsOf&lt;S: SequenceType where S.Generator.Element<br>&gt; == Generator.Element&gt;<br>&gt;     (_ sequence: S, @noescape combine: (Value, Value) throws -&gt; Value)<br>&gt; rethrows<br>&gt;<br>&gt; I&#39;m pretty sure I would use all four of those, and that would bring<br>&gt; Dictionary more into alignment with how you can use Array and Set. Would a<br>&gt; slightly expanded proposal make sense?<br>&gt;<br>&gt; Nate<br>&gt;<br>&gt;<br>&gt; On Jan 15, 2016, at 9:01 AM, Nicola Salmoria via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I&#39;m ambivalent about the preconditionFailure. Since there would otherwise<br>&gt; be silent loss of data, I think it fits Swift&#39;s &quot;safe by default&quot; paradigm.<br>&gt; It&#39;s also consistent with what the normal initialization from a<br>&gt; DictionaryLiteral does.<br>&gt; However, I can also see how it might be more convenient to just pick the<br>&gt; last value.<br>&gt;<br>&gt; Nicola<br>&gt;<br>&gt; On Fri, Jan 15, 2016 at 11:53 AM, Alan Skipp &lt;al_skipp at icloud.com&gt; wrote:<br>&gt;<br>&gt;&gt; I’ve been absorbed in the world of Monoids lately, so I find the<br>&gt;&gt; suggestion below to be particularly brilliant. : )<br>&gt;&gt; It solves the issue of arbitrarily choosing the value for duplicate keys<br>&gt;&gt; rather nicely. Only thing I’m not too sure about is the idea of failing by<br>&gt;&gt; default on duplicate keys?<br>&gt;&gt;<br>&gt;&gt; On 15 Jan 2016, at 10:18, Nicola Salmoria via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; To handle the case of duplicate keys, why not allow to pass in a<br>&gt;&gt; &#39;combine&#39; function?<br>&gt;&gt; The function could default to a preconditionFailure to be consistent with<br>&gt;&gt; the DictionaryLiteral behavior, but be overridden by the caller as needed.<br>&gt;&gt;<br>&gt;&gt; extension Dictionary {<br>&gt;&gt;     /// Creates a dictionary with the keys and values in the given<br>&gt;&gt; sequence.<br>&gt;&gt;     init&lt;S: SequenceType where S.Generator.Element ==<br>&gt;&gt; Generator.Element&gt;(_ sequence: S, combine: (existing: Value, other: Value)<br>&gt;&gt; -&gt; Value = { preconditionFailure(&quot;Sequence contains duplicate keys&quot;);<br>&gt;&gt; return $1 } ) {<br>&gt;&gt;         self.init()<br>&gt;&gt;         for (key, value) in sequence {<br>&gt;&gt;             if let existing = updateValue(value, forKey: key) {<br>&gt;&gt;                 updateValue(combine(existing: existing, other: value),<br>&gt;&gt; forKey: key)<br>&gt;&gt;             }<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; usage examples:<br>&gt;&gt;<br>&gt;&gt; let samples = [(&quot;Rome&quot;, 40.2), (&quot;New York&quot;, 35.1), (&quot;Rome&quot;, 42.5), (&quot;New<br>&gt;&gt; York&quot;, 32.8)]<br>&gt;&gt; let minTemperatures = Dictionary(samples, combine: min)<br>&gt;&gt; // [&quot;Rome&quot;: 40.2, &quot;New York&quot;: 32.8]<br>&gt;&gt; let maxTemperatures = Dictionary(samples, combine: max)<br>&gt;&gt; // [&quot;Rome&quot;: 42.5, &quot;New York&quot;: 35.1]<br>&gt;&gt;<br>&gt;&gt; let probabilities = [(&quot;a&quot;, 0.25), (&quot;b&quot;, 0.25), (&quot;c&quot;, 0.25), (&quot;a&quot;, 0.25)]<br>&gt;&gt; let stateProbabilities = Dictionary(probabilities, combine: +)<br>&gt;&gt; // [&quot;b&quot;: 0.25, &quot;a&quot;: 0.5, &quot;c&quot;: 0.25]<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Nicola<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; It’d be great if there was also an init that restricted the Values to<br>&gt;&gt; Monoids, which would mean the combine function would be taken from the<br>&gt;&gt; supplied Monoid values (I understand I’ve departed to fantasy island at<br>&gt;&gt; this point, but one can dream : )<br>&gt;&gt;<br>&gt;&gt; Al<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160116/40f387b5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Proposal: Add a sequence-based initializer to Dictionary</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January 18, 2016 at 07:00:00am</p></header><div class="content"><p>Alternatively the update method could take a combine function.<br>But I like the idea with using the dictionary index as opposed to the key.<br></p><p>-Thorsten<br></p><p>&gt; Am 16.01.2016 um 11:28 schrieb Nicola Salmoria via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; +1 for the mutating methods. That&#39;s a pretty common use case and would nicely complement the Dictionary features.<br>&gt; <br>&gt; As for the implementation details, I think all the examples we made are inefficient, requiring two dictionary lookups to combine a value. In e.g. C++ you can do something like this<br>&gt; <br>&gt; auto it = m.find(x);<br>&gt; if (it != end(m)) {<br>&gt;    it-&gt;second = value;<br>&gt; }<br>&gt; <br>&gt; In Swift we have<br>&gt; <br>&gt; func indexForKey(key: Key) -&gt; DictionaryIndex&lt;Key, Value&gt;?<br>&gt; <br>&gt; but then there are only<br>&gt; <br>&gt; subscript(position: DictionaryIndex&lt;Key, Value&gt;) -&gt; (Key, Value) { get }<br>&gt; mutating func removeAtIndex(index: DictionaryIndex&lt;Key, Value&gt;) -&gt; (Key, Value)<br>&gt; <br>&gt; It would probably be appropriate to have a new method<br>&gt; <br>&gt; mutating func updateValue(value: Value, atIndex: DictionaryIndex&lt;Key, Value&gt;) -&gt; Value<br>&gt; <br>&gt; which would allow to efficiently combine the values with a single lookup.<br>&gt; <br>&gt; Nicola<br>&gt; <br>&gt; <br>&gt;&gt; On Sat, Jan 16, 2016 at 8:28 AM, Nate Cook &lt;natecook at gmail.com&gt; wrote:<br>&gt;&gt; Adding a `combine` closure with Donnacha&#39;s default seems like a pretty good solution for this, but giving a `try`-marked closure parameter a default  messes with the rethrows behavior and requires a try on every call. I think it&#39;s important that when used by default, this initializer has the same behavior as looping over the sequence and setting values for keys. That is, it should replicate:<br>&gt;&gt; <br>&gt;&gt; for (key, value) in sequence { <br>&gt;&gt;     newDictionary[key] = value <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; and use the last value for any duplicate keys, rather than failing or trapping.<br>&gt;&gt; <br>&gt;&gt; To handle this properly we&#39;d need two new initializers:<br>&gt;&gt; <br>&gt;&gt; init&lt;S: SequenceType where S.Generator.Element == Generator.Element&gt;(_ sequence: S)<br>&gt;&gt; <br>&gt;&gt; init&lt;S: SequenceType where S.Generator.Element == Generator.Element&gt;<br>&gt;&gt;     (_ sequence: S, @noescape combine: (Value, Value) throws -&gt; Value) rethrows<br>&gt;&gt; <br>&gt;&gt; Perhaps we also need a mutating `mergeContentsOf` function with the same signatures as the initializers:<br>&gt;&gt; <br>&gt;&gt; mutating func mergeContentsOf&lt;S: SequenceType where S.Generator.Element == Generator.Element&gt;(_ sequence: S)<br>&gt;&gt; <br>&gt;&gt; mutating func mergeContentsOf&lt;S: SequenceType where S.Generator.Element == Generator.Element&gt;<br>&gt;&gt;     (_ sequence: S, @noescape combine: (Value, Value) throws -&gt; Value) rethrows<br>&gt;&gt; <br>&gt;&gt; I&#39;m pretty sure I would use all four of those, and that would bring Dictionary more into alignment with how you can use Array and Set. Would a slightly expanded proposal make sense?<br>&gt;&gt; <br>&gt;&gt; Nate<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 15, 2016, at 9:01 AM, Nicola Salmoria via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m ambivalent about the preconditionFailure. Since there would otherwise be silent loss of data, I think it fits Swift&#39;s &quot;safe by default&quot; paradigm. It&#39;s also consistent with what the normal initialization from a DictionaryLiteral does.<br>&gt;&gt;&gt; However, I can also see how it might be more convenient to just pick the last value.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Nicola<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Fri, Jan 15, 2016 at 11:53 AM, Alan Skipp &lt;al_skipp at icloud.com&gt; wrote:<br>&gt;&gt;&gt;&gt; I’ve been absorbed in the world of Monoids lately, so I find the suggestion below to be particularly brilliant. : )<br>&gt;&gt;&gt;&gt; It solves the issue of arbitrarily choosing the value for duplicate keys rather nicely. Only thing I’m not too sure about is the idea of failing by default on duplicate keys?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 15 Jan 2016, at 10:18, Nicola Salmoria via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; To handle the case of duplicate keys, why not allow to pass in a &#39;combine&#39; function?<br>&gt;&gt;&gt;&gt;&gt; The function could default to a preconditionFailure to be consistent with the DictionaryLiteral behavior, but be overridden by the caller as needed.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; extension Dictionary {<br>&gt;&gt;&gt;&gt;&gt;     /// Creates a dictionary with the keys and values in the given sequence.<br>&gt;&gt;&gt;&gt;&gt;     init&lt;S: SequenceType where S.Generator.Element == Generator.Element&gt;(_ sequence: S, combine: (existing: Value, other: Value) -&gt; Value = { preconditionFailure(&quot;Sequence contains duplicate keys&quot;); return $1 } ) {<br>&gt;&gt;&gt;&gt;&gt;         self.init()<br>&gt;&gt;&gt;&gt;&gt;         for (key, value) in sequence {<br>&gt;&gt;&gt;&gt;&gt;             if let existing = updateValue(value, forKey: key) {<br>&gt;&gt;&gt;&gt;&gt;                 updateValue(combine(existing: existing, other: value), forKey: key)<br>&gt;&gt;&gt;&gt;&gt;             }<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; usage examples:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let samples = [(&quot;Rome&quot;, 40.2), (&quot;New York&quot;, 35.1), (&quot;Rome&quot;, 42.5), (&quot;New York&quot;, 32.8)]<br>&gt;&gt;&gt;&gt;&gt; let minTemperatures = Dictionary(samples, combine: min)<br>&gt;&gt;&gt;&gt;&gt; // [&quot;Rome&quot;: 40.2, &quot;New York&quot;: 32.8]<br>&gt;&gt;&gt;&gt;&gt; let maxTemperatures = Dictionary(samples, combine: max)<br>&gt;&gt;&gt;&gt;&gt; // [&quot;Rome&quot;: 42.5, &quot;New York&quot;: 35.1]<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let probabilities = [(&quot;a&quot;, 0.25), (&quot;b&quot;, 0.25), (&quot;c&quot;, 0.25), (&quot;a&quot;, 0.25)]<br>&gt;&gt;&gt;&gt;&gt; let stateProbabilities = Dictionary(probabilities, combine: +)<br>&gt;&gt;&gt;&gt;&gt; // [&quot;b&quot;: 0.25, &quot;a&quot;: 0.5, &quot;c&quot;: 0.25]<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Nicola<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It’d be great if there was also an init that restricted the Values to Monoids, which would mean the combine function would be taken from the supplied Monoid values (I understand I’ve departed to fantasy island at this point, but one can dream : )<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Al<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160118/2ba58db0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Proposal: Add a sequence-based initializer to Dictionary</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>January 18, 2016 at 07:00:00pm</p></header><div class="content"><p>+1 I&#39;ve been wishing the protocol had something like this.<br></p><p>It would be nice if a protocol extension had default implementations<br>similar to these:<br></p><p>init&lt;S: SequenceType where S.Generator.Element == Generator.Element&gt;(_<br> sequence: S)<br>{<br>    self.init(minimumCapacity: sequence.underestimateCount())<br>    self.mergeContentsOf(sequence)<br>}<br></p><p>init&lt;S: SequenceType where S.Generator.Element == Generator.Element&gt;<br>    (_ sequence: S, @noescape combine: (Value, Value) throws -&gt; Value = {<br>(_,x) in x }) rethrows<br>{<br>    self.init(minimumCapacity: sequence.underestimateCount())<br>    try self.mergeContentsOf(sequence, combine: combine)<br>}<br></p><p>mutating func mergeContentsOf&lt;S: SequenceType where S.Generator.Element ==<br>Generator.Element&gt;<br>    (_ sequence: S)<br>{<br>    for (key, value) in sequence {<br>        self[key] = value<br>    }<br>}<br></p><p>mutating func mergeContentsOf&lt;S: SequenceType where S.Generator.Element ==<br>Generator.Element&gt;<br>    (_ sequence: S, @noescape combine: (Value, Value) throws -&gt; Value = {<br>(_,x) in x }) rethrows<br>{<br>    for (key, value) in sequence {<br>        if let oldValue = self[key] {<br>            self[key] = try combine(oldValue, value)<br>        }<br>        else {<br>            self[key] = value<br>        }<br>    }<br>}<br></p><p><br>On Mon, Jan 18, 2016 at 5:04 PM, Thorsten Seitz via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Alternatively the update method could take a combine function.<br>&gt; But I like the idea with using the dictionary index as opposed to the key.<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt; Am 16.01.2016 um 11:28 schrieb Nicola Salmoria via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt;<br>&gt; +1 for the mutating methods. That&#39;s a pretty common use case and would<br>&gt; nicely complement the Dictionary features.<br>&gt;<br>&gt; As for the implementation details, I think all the examples we made are<br>&gt; inefficient, requiring two dictionary lookups to combine a value. In e.g.<br>&gt; C++ you can do something like this<br>&gt;<br>&gt; auto it = m.find(x);<br>&gt; if (it != end(m)) {<br>&gt;    it-&gt;second = value;<br>&gt; }<br>&gt;<br>&gt; In Swift we have<br>&gt;<br>&gt; func indexForKey(key: Key) -&gt; DictionaryIndex&lt;Key, Value&gt;?<br>&gt;<br>&gt; but then there are only<br>&gt;<br>&gt; subscript(position: DictionaryIndex&lt;Key, Value&gt;) -&gt; (Key, Value) { get }<br>&gt; mutating func removeAtIndex(index: DictionaryIndex&lt;Key, Value&gt;) -&gt; (Key,<br>&gt; Value)<br>&gt;<br>&gt; It would probably be appropriate to have a new method<br>&gt;<br>&gt; mutating func updateValue(value: Value, atIndex: DictionaryIndex&lt;Key,<br>&gt; Value&gt;) -&gt; Value<br>&gt;<br>&gt; which would allow to efficiently combine the values with a single lookup.<br>&gt;<br>&gt; Nicola<br>&gt;<br>&gt;<br>&gt; On Sat, Jan 16, 2016 at 8:28 AM, Nate Cook &lt;natecook at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; Adding a `combine` closure with Donnacha&#39;s default seems like a pretty<br>&gt;&gt; good solution for this, but giving a `try`-marked closure parameter a<br>&gt;&gt; default  messes with the rethrows behavior and requires a try on every<br>&gt;&gt; call. I think it&#39;s important that when used by default, this initializer<br>&gt;&gt; has the same behavior as looping over the sequence and setting values for<br>&gt;&gt; keys. That is, it should replicate:<br>&gt;&gt;<br>&gt;&gt; for (key, value) in sequence {<br>&gt;&gt;     newDictionary[key] = value<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; and use the last value for any duplicate keys, rather than failing or<br>&gt;&gt; trapping.<br>&gt;&gt;<br>&gt;&gt; To handle this properly we&#39;d need two new initializers:<br>&gt;&gt;<br>&gt;&gt; init&lt;S: SequenceType where S.Generator.Element == Generator.Element&gt;(_<br>&gt;&gt; sequence: S)<br>&gt;&gt;<br>&gt;&gt; init&lt;S: SequenceType where S.Generator.Element == Generator.Element&gt;<br>&gt;&gt;     (_ sequence: S, @noescape combine: (Value, Value) throws -&gt; Value)<br>&gt;&gt; rethrows<br>&gt;&gt;<br>&gt;&gt; Perhaps we also need a mutating `mergeContentsOf` function with the same<br>&gt;&gt; signatures as the initializers:<br>&gt;&gt;<br>&gt;&gt; mutating func mergeContentsOf&lt;S: SequenceType where S.Generator.Element<br>&gt;&gt; == Generator.Element&gt;(_ sequence: S)<br>&gt;&gt;<br>&gt;&gt; mutating func mergeContentsOf&lt;S: SequenceType where S.Generator.Element<br>&gt;&gt; == Generator.Element&gt;<br>&gt;&gt;     (_ sequence: S, @noescape combine: (Value, Value) throws -&gt; Value)<br>&gt;&gt; rethrows<br>&gt;&gt;<br>&gt;&gt; I&#39;m pretty sure I would use all four of those, and that would bring<br>&gt;&gt; Dictionary more into alignment with how you can use Array and Set. Would a<br>&gt;&gt; slightly expanded proposal make sense?<br>&gt;&gt;<br>&gt;&gt; Nate<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Jan 15, 2016, at 9:01 AM, Nicola Salmoria via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I&#39;m ambivalent about the preconditionFailure. Since there would otherwise<br>&gt;&gt; be silent loss of data, I think it fits Swift&#39;s &quot;safe by default&quot; paradigm.<br>&gt;&gt; It&#39;s also consistent with what the normal initialization from a<br>&gt;&gt; DictionaryLiteral does.<br>&gt;&gt; However, I can also see how it might be more convenient to just pick the<br>&gt;&gt; last value.<br>&gt;&gt;<br>&gt;&gt; Nicola<br>&gt;&gt;<br>&gt;&gt; On Fri, Jan 15, 2016 at 11:53 AM, Alan Skipp &lt;al_skipp at icloud.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; I’ve been absorbed in the world of Monoids lately, so I find the<br>&gt;&gt;&gt; suggestion below to be particularly brilliant. : )<br>&gt;&gt;&gt; It solves the issue of arbitrarily choosing the value for duplicate keys<br>&gt;&gt;&gt; rather nicely. Only thing I’m not too sure about is the idea of failing by<br>&gt;&gt;&gt; default on duplicate keys?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 15 Jan 2016, at 10:18, Nicola Salmoria via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; To handle the case of duplicate keys, why not allow to pass in a<br>&gt;&gt;&gt; &#39;combine&#39; function?<br>&gt;&gt;&gt; The function could default to a preconditionFailure to be consistent<br>&gt;&gt;&gt; with the DictionaryLiteral behavior, but be overridden by the caller as<br>&gt;&gt;&gt; needed.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; extension Dictionary {<br>&gt;&gt;&gt;     /// Creates a dictionary with the keys and values in the given<br>&gt;&gt;&gt; sequence.<br>&gt;&gt;&gt;     init&lt;S: SequenceType where S.Generator.Element ==<br>&gt;&gt;&gt; Generator.Element&gt;(_ sequence: S, combine: (existing: Value, other: Value)<br>&gt;&gt;&gt; -&gt; Value = { preconditionFailure(&quot;Sequence contains duplicate keys&quot;);<br>&gt;&gt;&gt; return $1 } ) {<br>&gt;&gt;&gt;         self.init()<br>&gt;&gt;&gt;         for (key, value) in sequence {<br>&gt;&gt;&gt;             if let existing = updateValue(value, forKey: key) {<br>&gt;&gt;&gt;                 updateValue(combine(existing: existing, other: value),<br>&gt;&gt;&gt; forKey: key)<br>&gt;&gt;&gt;             }<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; usage examples:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let samples = [(&quot;Rome&quot;, 40.2), (&quot;New York&quot;, 35.1), (&quot;Rome&quot;, 42.5), (&quot;New<br>&gt;&gt;&gt; York&quot;, 32.8)]<br>&gt;&gt;&gt; let minTemperatures = Dictionary(samples, combine: min)<br>&gt;&gt;&gt; // [&quot;Rome&quot;: 40.2, &quot;New York&quot;: 32.8]<br>&gt;&gt;&gt; let maxTemperatures = Dictionary(samples, combine: max)<br>&gt;&gt;&gt; // [&quot;Rome&quot;: 42.5, &quot;New York&quot;: 35.1]<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let probabilities = [(&quot;a&quot;, 0.25), (&quot;b&quot;, 0.25), (&quot;c&quot;, 0.25), (&quot;a&quot;, 0.25)]<br>&gt;&gt;&gt; let stateProbabilities = Dictionary(probabilities, combine: +)<br>&gt;&gt;&gt; // [&quot;b&quot;: 0.25, &quot;a&quot;: 0.5, &quot;c&quot;: 0.25]<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Nicola<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It’d be great if there was also an init that restricted the Values to<br>&gt;&gt;&gt; Monoids, which would mean the combine function would be taken from the<br>&gt;&gt;&gt; supplied Monoid values (I understand I’ve departed to fantasy island at<br>&gt;&gt;&gt; this point, but one can dream : )<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Al<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160118/e45edd45/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Proposal: Add a sequence-based initializer to Dictionary</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January 18, 2016 at 06:00:00am</p></header><div class="content"><p>+1 <br>Splitting the init seems to be a good idea, though I would have thought that a non-throwing default would not require a try on a call using the default (I&#39;m not near a Swift compiler currently, so can&#39;t check that right now).<br>I like the mutating functions!<br></p><p>-Thorsten<br></p><p>&gt; Am 16.01.2016 um 08:28 schrieb Nate Cook via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Adding a `combine` closure with Donnacha&#39;s default seems like a pretty good solution for this, but giving a `try`-marked closure parameter a default  messes with the rethrows behavior and requires a try on every call. I think it&#39;s important that when used by default, this initializer has the same behavior as looping over the sequence and setting values for keys. That is, it should replicate:<br>&gt; <br>&gt; for (key, value) in sequence { <br>&gt;     newDictionary[key] = value <br>&gt; }<br>&gt; <br>&gt; and use the last value for any duplicate keys, rather than failing or trapping.<br>&gt; <br>&gt; To handle this properly we&#39;d need two new initializers:<br>&gt; <br>&gt; init&lt;S: SequenceType where S.Generator.Element == Generator.Element&gt;(_ sequence: S)<br>&gt; <br>&gt; init&lt;S: SequenceType where S.Generator.Element == Generator.Element&gt;<br>&gt;     (_ sequence: S, @noescape combine: (Value, Value) throws -&gt; Value) rethrows<br>&gt; <br>&gt; Perhaps we also need a mutating `mergeContentsOf` function with the same signatures as the initializers:<br>&gt; <br>&gt; mutating func mergeContentsOf&lt;S: SequenceType where S.Generator.Element == Generator.Element&gt;(_ sequence: S)<br>&gt; <br>&gt; mutating func mergeContentsOf&lt;S: SequenceType where S.Generator.Element == Generator.Element&gt;<br>&gt;     (_ sequence: S, @noescape combine: (Value, Value) throws -&gt; Value) rethrows<br>&gt; <br>&gt; I&#39;m pretty sure I would use all four of those, and that would bring Dictionary more into alignment with how you can use Array and Set. Would a slightly expanded proposal make sense?<br>&gt; <br>&gt; Nate<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 15, 2016, at 9:01 AM, Nicola Salmoria via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;m ambivalent about the preconditionFailure. Since there would otherwise be silent loss of data, I think it fits Swift&#39;s &quot;safe by default&quot; paradigm. It&#39;s also consistent with what the normal initialization from a DictionaryLiteral does.<br>&gt;&gt; However, I can also see how it might be more convenient to just pick the last value.<br>&gt;&gt; <br>&gt;&gt; Nicola<br>&gt;&gt; <br>&gt;&gt;&gt; On Fri, Jan 15, 2016 at 11:53 AM, Alan Skipp &lt;al_skipp at icloud.com&gt; wrote:<br>&gt;&gt;&gt; I’ve been absorbed in the world of Monoids lately, so I find the suggestion below to be particularly brilliant. : )<br>&gt;&gt;&gt; It solves the issue of arbitrarily choosing the value for duplicate keys rather nicely. Only thing I’m not too sure about is the idea of failing by default on duplicate keys?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 15 Jan 2016, at 10:18, Nicola Salmoria via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; To handle the case of duplicate keys, why not allow to pass in a &#39;combine&#39; function?<br>&gt;&gt;&gt;&gt; The function could default to a preconditionFailure to be consistent with the DictionaryLiteral behavior, but be overridden by the caller as needed.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension Dictionary {<br>&gt;&gt;&gt;&gt;     /// Creates a dictionary with the keys and values in the given sequence.<br>&gt;&gt;&gt;&gt;     init&lt;S: SequenceType where S.Generator.Element == Generator.Element&gt;(_ sequence: S, combine: (existing: Value, other: Value) -&gt; Value = { preconditionFailure(&quot;Sequence contains duplicate keys&quot;); return $1 } ) {<br>&gt;&gt;&gt;&gt;         self.init()<br>&gt;&gt;&gt;&gt;         for (key, value) in sequence {<br>&gt;&gt;&gt;&gt;             if let existing = updateValue(value, forKey: key) {<br>&gt;&gt;&gt;&gt;                 updateValue(combine(existing: existing, other: value), forKey: key)<br>&gt;&gt;&gt;&gt;             }<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; usage examples:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let samples = [(&quot;Rome&quot;, 40.2), (&quot;New York&quot;, 35.1), (&quot;Rome&quot;, 42.5), (&quot;New York&quot;, 32.8)]<br>&gt;&gt;&gt;&gt; let minTemperatures = Dictionary(samples, combine: min)<br>&gt;&gt;&gt;&gt; // [&quot;Rome&quot;: 40.2, &quot;New York&quot;: 32.8]<br>&gt;&gt;&gt;&gt; let maxTemperatures = Dictionary(samples, combine: max)<br>&gt;&gt;&gt;&gt; // [&quot;Rome&quot;: 42.5, &quot;New York&quot;: 35.1]<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let probabilities = [(&quot;a&quot;, 0.25), (&quot;b&quot;, 0.25), (&quot;c&quot;, 0.25), (&quot;a&quot;, 0.25)]<br>&gt;&gt;&gt;&gt; let stateProbabilities = Dictionary(probabilities, combine: +)<br>&gt;&gt;&gt;&gt; // [&quot;b&quot;: 0.25, &quot;a&quot;: 0.5, &quot;c&quot;: 0.25]<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Nicola<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It’d be great if there was also an init that restricted the Values to Monoids, which would mean the combine function would be taken from the supplied Monoid values (I understand I’ve departed to fantasy island at this point, but one can dream : )<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Al<br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160118/5449c63f/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
