<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Public classes with private superclass</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>July  4, 2016 at 02:00:00pm</p></header><div class="content"><p>I&#39;m running into &quot;class cannot be declared public because its superclass is internal&quot; issues on a regular basis, and I wonder if it wouldn&#39;t make sense to allow this combination:<br>It might be less useful as soon as there are abstract classes or generic protocols, but even then I think I&#39;d like to have this &quot;feature&quot;.<br></p><p>Inheritance can be such a private thing ;-), so imho there should be an obvious way to hide it (marking all init-methods internal works, but I don&#39;t think this is a good way to express the intention).<br></p><p>Tino<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/30e3591a1afb94308593c435111126c1?s=50"></div><header><strong>Public classes with private superclass</strong> from <string>Andre</string> &lt;pyunpyun at me.com&gt;<p>July  5, 2016 at 03:00:00pm</p></header><div class="content"><p>Personally, it&#39;s perhaps more of an &quot;aesthetic&quot; thing I suppose but I would definitely prefer that my internal classes stay internal even if there is a public subclass... I don&#39;t like how that leaks my internal implementation like that...<br></p><p>Though maybe the more swift thing to do would be to use private extensions in place of private superclasses I suppose...<br></p><p>andre <br></p><p>iPhoneから送信<br></p><p>2016/07/04 21:31、Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br></p><p>&gt; I&#39;m running into &quot;class cannot be declared public because its superclass is internal&quot; issues on a regular basis, and I wonder if it wouldn&#39;t make sense to allow this combination:<br>&gt; It might be less useful as soon as there are abstract classes or generic protocols, but even then I think I&#39;d like to have this &quot;feature&quot;.<br>&gt; <br>&gt; Inheritance can be such a private thing ;-), so imho there should be an obvious way to hide it (marking all init-methods internal works, but I don&#39;t think this is a good way to express the intention).<br>&gt; <br>&gt; Tino<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>Public classes with private superclass</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>July  5, 2016 at 09:00:00am</p></header><div class="content"><p>How would this look in the exported API? Would it simply show itself as not inheriting from anything? If your base class inherited from something (e.g. NSObject), would the public subclasses show themselves as direct subclasses of that superclass (NSObject)?<br></p><p>IMHO these things can be solved by private protocols with default implementation to reuse the code:<br></p><p>internal protocol MyClassCore { }<br>extension MyClassCore {<br>	func doSomething() {<br>		print(&quot;123&quot;)<br>	}<br>}<br></p><p>public class MyClass1 { }<br>extension MyClass1: MyClassCore { }<br></p><p>Or you can just create a private class and use its instance in your classes:<br></p><p>internal class MyClassImplementation {<br>	/// Implement shared code<br>}<br></p><p>public class MyClass {<br>	private var _impl = MyClassImplementation()<br>}<br></p><p>Which is fairly common solution.<br></p><p>Anyway, this is definitely out of scope of Swift 3 and as has been pointed out several times in the past month here, all discussions here should now focus on Swift 3 features.<br></p><p>&gt; On Jul 5, 2016, at 8:49 AM, Andre via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Personally, it&#39;s perhaps more of an &quot;aesthetic&quot; thing I suppose but I would definitely prefer that my internal classes stay internal even if there is a public subclass... I don&#39;t like how that leaks my internal implementation like that...<br>&gt; <br>&gt; Though maybe the more swift thing to do would be to use private extensions in place of private superclasses I suppose...<br>&gt; <br>&gt; andre <br>&gt; <br>&gt; iPhoneから送信<br>&gt; <br>&gt; 2016/07/04 21:31、Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br>&gt; <br>&gt;&gt; I&#39;m running into &quot;class cannot be declared public because its superclass is internal&quot; issues on a regular basis, and I wonder if it wouldn&#39;t make sense to allow this combination:<br>&gt;&gt; It might be less useful as soon as there are abstract classes or generic protocols, but even then I think I&#39;d like to have this &quot;feature&quot;.<br>&gt;&gt; <br>&gt;&gt; Inheritance can be such a private thing ;-), so imho there should be an obvious way to hide it (marking all init-methods internal works, but I don&#39;t think this is a good way to express the intention).<br>&gt;&gt; <br>&gt;&gt; Tino<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Public classes with private superclass</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>July  5, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On 5 Jul 2016, at 08:01, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; IMHO these things can be solved by private protocols with default implementation to reuse the code:<br>&gt; Or you can just create a private class and use its instance in your classes:<br></p><p>The other alternative is to just declare the methods of the &quot;private&quot; class private/internal and then use them. For example:<br></p><p>	public class Foo {<br>		internal init() { … } // Can&#39;t be instantiated outside of this module<br>		internal func doSomething() { … }<br>		func publicMethod() { … }<br>	}<br></p><p>	public class Bar : Foo {<br>		public init() { super.init() } // Can be instantiated outside of this module<br>		public something() { super.doSomething() }<br>	}<br></p><p>But yeah, it seems like there are a lot of design patterns to solve this problem already; it&#39;s a nice idea, but proper abstract classes or traits/mixins are better possible solutions in the long-run, and the use of internal initialisers effectively result in abstract internal types for the time being.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160705/a061cb9d/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Public classes with private superclass</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>July  5, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; How would this look in the exported API? Would it simply show itself as not inheriting from anything? If your base class inherited from something (e.g. NSObject), would the public subclasses show themselves as direct subclasses of that superclass (NSObject)?<br>I wouldn&#39;t care, but the last option sounds sensible (although I hope I&#39;ll never have to directly subclass NSObject in the future ;-)<br></p><p>&gt; IMHO these things can be solved by private protocols with default implementation to reuse the code:<br>Not everything can be solved with protocols (stored properties, anyone?)<br></p><p>&gt; Or you can just create a private class and use its instance in your classes:<br>&gt; <br>&gt; internal class MyClassImplementation {<br>&gt; 	/// Implement shared code<br>&gt; }<br>&gt; <br>&gt; public class MyClass {<br>&gt; 	private var _impl = MyClassImplementation()<br>&gt; }<br>&gt; Which is fairly common solution.<br>Those six lines are written easily, but they don&#39;t do anything, so you have to add tons of boilerplate to do forwarding — and you destroy the internal class hierarchy.<br>Do you see a problem with &quot;internal init&quot;?<br></p><p>&gt; Anyway, this is definitely out of scope of Swift 3 and as has been pointed out several times in the past month here, all discussions here should now focus on Swift 3 features.<br>Sorry, I&#39;ve been busy with other things lately…<br>I know that anything that breaks compatibility with existing source has top priority now, and that there most likely won&#39;t be any resources to integrate stuff that doesn&#39;t fulfill that criterion — but has there been an actual announcement that no discussions about purely additive changes should be started at all?<br></p><p>Best regards,<br>Tino<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>Public classes with private superclass</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>July  5, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jul 5, 2016, at 12:03 PM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; How would this look in the exported API? Would it simply show itself as not inheriting from anything? If your base class inherited from something (e.g. NSObject), would the public subclasses show themselves as direct subclasses of that superclass (NSObject)?<br>&gt; I wouldn&#39;t care, but the last option sounds sensible (although I hope I&#39;ll never have to directly subclass NSObject in the future ;-)<br></p><p>NSObject was just an example, of course, you can base it on NSView, etc.<br></p><p>&gt;&gt; IMHO these things can be solved by private protocols with default implementation to reuse the code:<br>&gt; Not everything can be solved with protocols (stored properties, anyone?)<br></p><p>Sure, it&#39;s not completely painless, but you can declare<br></p><p>internal protocol MyClassProtocol {<br>	var foo: Bar { get set }<br>}<br></p><p>public class MyClass: MyClassProtocol {<br>	public var foo: Bar<br>}<br></p><p>It&#39;s 1 extra line of code. You declare the contract on stored properties by the protocol and just declare them on the class.<br></p><p>&gt;&gt; Or you can just create a private class and use its instance in your classes:<br>&gt;&gt; <br>&gt;&gt; internal class MyClassImplementation {<br>&gt;&gt; 	/// Implement shared code<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; public class MyClass {<br>&gt;&gt; 	private var _impl = MyClassImplementation()<br>&gt;&gt; }<br>&gt;&gt; Which is fairly common solution.<br>&gt; Those six lines are written easily, but they don&#39;t do anything, so you have to add tons of boilerplate to do forwarding — and you destroy the internal class hierarchy.<br></p><p>Yes, but I see a ton of various advantages such as breaking the code into various classes dealing with a particular problem. It seems to me like if you really need to hide the hierarchy, you should look into class clusters - such as NSString, where you declare a public abstract API and return internal subclasses using factory methods (yes, it is the exact opposite of what you want, but depending on your exact problem, it may get solved by this).<br></p><p>IMHO if you need to hide the hierarchy *that* bad, it usually points to a bad design.<br></p><p>&gt; I know that anything that breaks compatibility with existing source has top priority now, and that there most likely won&#39;t be any resources to integrate stuff that doesn&#39;t fulfill that criterion — but has there been an actual announcement that no discussions about purely additive changes should be started at all?<br></p><p>Yes. See http://article.gmane.org/gmane.comp.lang.swift.evolution/21198<br></p><p>&gt; Similarly, general discussions on this mailing list about blue sky additions to the language are distracting from our important goals, and the core  team generally isn’t paying attention to these anyway.  I would really appreciate it if we could stay focused on what is important, until the time is right to look beyond Swift 3.  This time is in August [...]<br></p><p><br></p><p><br>&gt; <br>&gt; Best regards,<br>&gt; Tino<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Public classes with private superclass</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>July  5, 2016 at 01:00:00pm</p></header><div class="content"><p>Thanks for the link — imho it&#39;s really hard to keep an overview of this list…<br></p><p>So, I&#39;ll follow the leader ;-) and delay further posts on this topic<br></p><p>&gt;&gt; Not everything can be solved with protocols (stored properties, anyone?)<br>&gt; <br>&gt; Sure, it&#39;s not completely painless, but you can declare<br>&gt; <br>&gt; internal protocol MyClassProtocol {<br>&gt; 	var foo: Bar { get set }<br>&gt; }<br>&gt; <br>&gt; public class MyClass: MyClassProtocol {<br>&gt; 	public var foo: Bar<br>&gt; }<br>&gt; <br>&gt; It&#39;s 1 extra line of code. You declare the contract on stored properties by the protocol and just declare them on the class.<br>… but this single line only covers a single property in a single class, and you have to implement willSet/didSet in every class if you depend on this behavior.<br>Protocols are nice, and if support for generics is added in the future, a whole set of problems could be covered with those — but imho even protocols are no silver bullet, and there are situations where they are not the right tool.<br></p><p>&gt; IMHO if you need to hide the hierarchy *that* bad, it usually points to a bad design.<br>I don&#39;t believe in fighting developers with obscurity, so for me, it is not about the hiding, but about clarity:<br>There is no clear way to express that a certain class shouldn&#39;t be used outside its library without hiding all subclasses, too (well, you could write documentation… but no one likes documentation ;-)<br></p><p>Best regards,<br>Tino<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>Public classes with private superclass</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>July  6, 2016 at 03:00:00am</p></header><div class="content"><p>&gt; On 5 Jul 2016, at 08:49, Andre via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Personally, it&#39;s perhaps more of an &quot;aesthetic&quot; thing I suppose but I would definitely prefer that my internal classes stay internal even if there is a public subclass... I don&#39;t like how that leaks my internal implementation like that...<br>&gt; <br>&gt; Though maybe the more swift thing to do would be to use private extensions in place of private superclasses I suppose...<br>&gt; <br>&gt; andre <br>&gt; <br>&gt; iPhoneから送信<br>&gt; <br>&gt; 2016/07/04 21:31、Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br>&gt; <br>&gt;&gt; I&#39;m running into &quot;class cannot be declared public because its superclass is internal&quot; issues on a regular basis, and I wonder if it wouldn&#39;t make sense to allow this combination:<br>&gt;&gt; It might be less useful as soon as there are abstract classes or generic protocols, but even then I think I&#39;d like to have this &quot;feature&quot;.<br>&gt;&gt; <br>&gt;&gt; Inheritance can be such a private thing ;-), so imho there should be an obvious way to hide it (marking all init-methods internal works, but I don&#39;t think this is a good way to express the intention).<br>&gt;&gt; <br>&gt;&gt; Tino<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>It certainly would be nice to selectively hide parts of the class hierarchy.<br></p><p>Karl<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Public classes with private superclass</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>July  5, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jul 5, 2016, at 6:48 PM, Karl via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; On 5 Jul 2016, at 08:49, Andre via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Personally, it&#39;s perhaps more of an &quot;aesthetic&quot; thing I suppose but I would definitely prefer that my internal classes stay internal even if there is a public subclass... I don&#39;t like how that leaks my internal implementation like that...<br>&gt;&gt; <br>&gt;&gt; Though maybe the more swift thing to do would be to use private extensions in place of private superclasses I suppose...<br>&gt;&gt; <br>&gt;&gt; andre <br>&gt;&gt; <br>&gt;&gt; iPhoneから送信<br>&gt;&gt; <br>&gt;&gt; 2016/07/04 21:31、Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br>&gt;&gt; <br>&gt;&gt;&gt; I&#39;m running into &quot;class cannot be declared public because its superclass is internal&quot; issues on a regular basis, and I wonder if it wouldn&#39;t make sense to allow this combination:<br>&gt;&gt;&gt; It might be less useful as soon as there are abstract classes or generic protocols, but even then I think I&#39;d like to have this &quot;feature&quot;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Inheritance can be such a private thing ;-), so imho there should be an obvious way to hide it (marking all init-methods internal works, but I don&#39;t think this is a good way to express the intention).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Tino<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; It certainly would be nice to selectively hide parts of the class hierarchy.<br></p><p>I agree that it&#39;s theoretically okay to hide parts of the hierarchy.  It would raise some secondary questions, like how to expose the &quot;public&quot; features of the internal superclass, but we could solve them.<br></p><p>However, it&#39;s clearly additive to do this, since it&#39;s just lifting a restriction, so please wait to propose this until Swift 3 is complete.<br></p><p>John.<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
