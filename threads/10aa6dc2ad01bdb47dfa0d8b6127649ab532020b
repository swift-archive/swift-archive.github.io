<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 22, 2016 at 01:00:00pm</p></header><div class="content"><p>Hello Swift community,<br></p><p>The review of SE-0005&quot;Better Translation of Objective-C APIs Into Swift&quot; begins now and runs through January 31, 2016. The proposal is available here:<br></p><p>https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md<br>Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br></p><p>https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br></p><p>Proposal link:<br></p><p>https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md<br>Reply text<br></p><p>Other replies<br> &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What goes into a review?<br></p><p>The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br></p><p>What is your evaluation of the proposal?<br>Is the problem being addressed significant enough to warrant a change to Swift?<br>Does this proposal fit well with the feel and direction of Swift?<br>If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>More information about the Swift evolution process is available at<br></p><p>https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>Thank you,<br></p><p>-Doug Gregor<br></p><p>Review Manager<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution-announce/attachments/20160122/10aa020b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>January 23, 2016 at 12:00:00am</p></header><div class="content"><p>Proposal link:<br>https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md<br></p><p>&gt; What is your evaluation of the proposal?<br></p><p>I would really appreciate seeing what *all* of the Foundation/Cocoa/Cocoa<br>Touch APIs would look like when imported using this scheme. If we&#39;re going<br>to bikeshed API translation, we should bikeshed all of it to avoid<br>inconsistency. (It may be that some issues aren&#39;t resolvable with the<br>simple rules proposed, and instead we should improve the API overlays.)<br></p><p>Some specific concerns:<br></p><p><br>     func *reversing()* -&gt; UIBezierPath<br></p><p>I believe this would be better named *reversed()*.<br></p><p><br>    var *dateComponentUndefined*: Int { get }<br></p><p>It seems pretty weird to have a global/top-level constant that starts with<br>a lowercase letter, and whose first 2 subwords are describing its type.<br></p><p><br>    class func *darkGray*() -&gt; UIColor<br></p><p>I would rather see this imported as `class var *DarkGray*: UIColor { get }`.<br></p><p><br>Otherwise, I&#39;m okay with the proposed changes. I really like the &quot;Add<br>Default Arguments&quot; section. :-)<br></p><p><br>&gt; Is the problem being addressed significant enough to warrant a change to<br>Swift?<br></p><p>Yes. The (current) majority of Swift users are writing software for Apple<br>platforms, so they interact constantly with Obj-C APIs such as these.<br></p><p><br>&gt; How much effort did you put into your review? A glance, a quick reading,<br>or an in-depth study?<br></p><p>Fairly in-depth.<br></p><p>Jacob<br></p><p>On Fri, Jan 22, 2016 at 1:02 PM, Douglas Gregor via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hello Swift community,<br>&gt;<br>&gt; The review of SE-0005&quot;Better Translation of Objective-C APIs Into Swift&quot;<br>&gt; begins now and runs through January 31, 2016. The proposal is available<br>&gt; here:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md<br>&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt; should be sent to the swift-evolution mailing list at<br>&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the<br>&gt; review manager. When replying, please try to keep the proposal link at the<br>&gt; top of the message:<br>&gt;<br>&gt; Proposal link:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md<br>&gt;<br>&gt; Reply text<br>&gt;<br>&gt; Other replies<br>&gt;<br>&gt; &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What<br>&gt; goes into a review?<br>&gt;<br>&gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and, eventually, determine the direction of<br>&gt; Swift. When writing your review, here are some questions you might want to<br>&gt; answer in your review:<br>&gt;<br>&gt;    - What is your evaluation of the proposal?<br>&gt;    - Is the problem being addressed significant enough to warrant a<br>&gt;    change to Swift?<br>&gt;    - Does this proposal fit well with the feel and direction of Swift?<br>&gt;    - If you have used other languages or libraries with a similar<br>&gt;    feature, how do you feel that this proposal compares to those?<br>&gt;    - How much effort did you put into your review? A glance, a quick<br>&gt;    reading, or an in-depth study?<br>&gt;<br>&gt; More information about the Swift evolution process is available at<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;<br>&gt; Thank you,<br>&gt;<br>&gt; -Doug Gregor<br>&gt;<br>&gt; Review Manager<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/5b371a7b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 23, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Jan 23, 2016, at 12:59 AM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt; Proposal link:<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md&gt;<br>&gt; <br>&gt; &gt; What is your evaluation of the proposal?<br>&gt; <br>&gt; I would really appreciate seeing what all of the Foundation/Cocoa/Cocoa Touch APIs would look like when imported using this scheme. If we&#39;re going to bikeshed API translation, we should bikeshed all of it to avoid inconsistency. (It may be that some issues aren&#39;t resolvable with the simple rules proposed, and instead we should improve the API overlays.)<br></p><p>I’ll come back to the rest laster, but we’ve provided this at<br></p><p>	https://github.com/apple/swift-3-api-guidelines-review/compare/swift-2...swift-3<br></p><p><br></p><p>	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/ec5df2ba/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>January 24, 2016 at 07:00:00am</p></header><div class="content"><p>My main reaction is the proposed translation is usually an improvement, but the proposal as-written is a bit hand-wavy on how to handle the situations where it doesn’t do a good job.<br></p><p>What I mean is, it is written from a perspective that comes across as “we have a solid-enough understanding of what Swift-y APIs should look like, and this proposal is sketching an automated approach to map Objective-C into that as best as possible; of course, in some cases the automated approach will be insufficient, and in those cases explicit annotations will be called for”.<br></p><p>But, as came up on the API guidelines discussion, there are parts of Objective-C for which there doesn’t seem to be any commonly-agreed-upon “Swift-y” equivalent; the delegate-style APIs are one such obvious case (and my motivating example), but there may be others once the enhanced translation starts seeing real use.<br></p><p>For such “problematic API styles” it’s not really going to be enough to say, for example, “we’ll add explicit annotations to deal with those”, because *what* those annotations *should be* doesn’t seem all that obvious right now; at least for the delegate-style APIs, even the enhanced translations are still wildly out of sync with the Swift API guidelines, and that style will either need to be grandfathered-in or some other form agreed-upon.<br></p><p>To make it concrete, here’s a few from the `UICollectionView*` family:<br></p><p>// IMHO an annoying inconsistency in how the type is incorporated into the 2nd argument’s label:<br>func collectionView(collectionView: UICollectionView, didEndDisplaying cell: UICollectionViewCell, forItemAt indexPath: IndexPath)<br>func collectionView(collectionView: UICollectionView, didEndDisplayingSupplementaryView view: UICollectionReusableView, forElementOfKind elementKind: String, at indexPath: IndexPath)<br></p><p>// IMHO an annoying inconsistency between the 2nd and 3rd argument labels:<br>func collectionView(collectionView: UICollectionView, targetIndexPathForMoveFromItemAt originalIndexPath: IndexPath, toProposedIndexPath proposedIndexPath: IndexPath) -&gt; IndexPath<br></p><p>// IMHO an annoying inconsistency vis-a-vis its 2nd and 3rd argument labels and those from the previous example:<br>func collectionView(collectionView: UICollectionView, moveItemAt sourceIndexPath: IndexPath, to destinationIndexPath: IndexPath)<br></p><p>…which I’d summarize by first reiterating that these are both:<br></p><p>- nowhere near in accord with the Swift API guidelines<br>- worse-off for being “partially translated” (the original APIs are verbose but predictable-and-mutually-consistent; these are verbose and neither predictable nor mutually-consistent)<br></p><p>I’m not sure what the right approach for the delegate APIs is — maybe they get grandfathered-in, maybe some Swift-ier form is chosen for them — but I think their presence shows a weakness of the *proposal* at this time: there are API territories for which there is as-yet no agreed-upon ideal translation to some Swift-ier form, and some more-explicit mention of such scenarios seems like it ought to go in the proposal (even if just in the future-steps section).<br></p><p>That’s my 2c at this time <br></p><p>&gt; <br>&gt; On Jan 22, 2016, at 3:02 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of SE-0005&quot;Better Translation of Objective-C APIs Into Swift&quot; begins now and runs through January 31, 2016. The proposal is available here:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br>&gt; <br>&gt; Proposal link:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md&gt;<br>&gt; Reply text<br>&gt; <br>&gt; Other replies<br>&gt;  &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; What is your evaluation of the proposal?<br>&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt; Thank you,<br>&gt; <br>&gt; -Doug Gregor<br>&gt; <br>&gt; Review Manager<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160124/a5d4b075/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c965d88fab90b7e85514d0e3011c3caf?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Tim Hawkins</string> &lt;tim.thawkins at gmail.com&gt;<p>January 24, 2016 at 10:00:00pm</p></header><div class="content"><p>Is the proposal going to improve support for &quot;c&quot; function import too, or is<br>it limited to objective-c?<br></p><p>Im asking because there are currently some weaknesses in importing libs<br>like glibc etc on linux, like the lack of support for functions with<br>varadic arguments, ie ioctrl etc. Which requires any interfaces to said<br>functions to have &quot;c&quot; wrappers built for them, before they can be imported.<br>On Jan 24, 2016 9:42 PM, &quot;plx via swift-evolution&quot; &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; My main reaction is the proposed translation is usually an improvement,<br>&gt; but the proposal as-written is a bit hand-wavy on how to handle the<br>&gt; situations where it doesn’t do a good job.<br>&gt;<br>&gt; What I mean is, it is written from a perspective that comes across as “we<br>&gt; have a solid-enough understanding of what Swift-y APIs should look like,<br>&gt; and this proposal is sketching an automated approach to map Objective-C<br>&gt; into that as best as possible; of course, in some cases the automated<br>&gt; approach will be insufficient, and in those cases explicit annotations will<br>&gt; be called for”.<br>&gt;<br>&gt; But, as came up on the API guidelines discussion, there are parts of<br>&gt; Objective-C for which there doesn’t seem to be any commonly-agreed-upon<br>&gt; “Swift-y” equivalent; the delegate-style APIs are one such obvious case<br>&gt; (and my motivating example), but there may be others once the enhanced<br>&gt; translation starts seeing real use.<br>&gt;<br>&gt; For such “problematic API styles” it’s not really going to be enough to<br>&gt; say, for example, “we’ll add explicit annotations to deal with those”,<br>&gt; because *what* those annotations *should be* doesn’t seem all that obvious<br>&gt; right now; at least for the delegate-style APIs, even the enhanced<br>&gt; translations are still wildly out of sync with the Swift API guidelines,<br>&gt; and that style will either need to be grandfathered-in or some other form<br>&gt; agreed-upon.<br>&gt;<br>&gt; To make it concrete, here’s a few from the `UICollectionView*` family:<br>&gt;<br>&gt; // IMHO an annoying inconsistency in how the type is incorporated into the<br>&gt; 2nd argument’s label:<br>&gt; func collectionView(collectionView: UICollectionView,<br>&gt; didEndDisplaying cell: UICollectionViewCell, forItemAt indexPath: IndexPath)<br>&gt; func collectionView(collectionView: UICollectionView,<br>&gt; didEndDisplayingSupplementaryView view: UICollectionReusableView,<br>&gt; forElementOfKind elementKind: String, at indexPath: IndexPath)<br>&gt;<br>&gt; // IMHO an annoying inconsistency between the 2nd and 3rd argument labels:<br>&gt; func collectionView(collectionView: UICollectionView,<br>&gt; targetIndexPathForMoveFromItemAt originalIndexPath: IndexPath,<br>&gt; toProposedIndexPath proposedIndexPath: IndexPath) -&gt; IndexPath<br>&gt;<br>&gt; // IMHO an annoying inconsistency vis-a-vis its 2nd and 3rd argument<br>&gt; labels and those from the previous example:<br>&gt; func collectionView(collectionView: UICollectionView,<br>&gt; moveItemAt sourceIndexPath: IndexPath, to destinationIndexPath: IndexPath)<br>&gt;<br>&gt; …which I’d summarize by first reiterating that these are both:<br>&gt;<br>&gt; - nowhere near in accord with the Swift API guidelines<br>&gt; - worse-off for being “partially translated” (the original APIs are<br>&gt; verbose but predictable-and-mutually-consistent; these are verbose and<br>&gt; neither predictable nor mutually-consistent)<br>&gt;<br>&gt; I’m not sure what the right approach for the delegate APIs is — maybe they<br>&gt; get grandfathered-in, maybe some Swift-ier form is chosen for them — but I<br>&gt; think their presence shows a weakness of the *proposal* at this time: there<br>&gt; are API territories for which there is as-yet no agreed-upon ideal<br>&gt; translation to some Swift-ier form, and some more-explicit mention of such<br>&gt; scenarios seems like it ought to go in the proposal (even if just in the<br>&gt; future-steps section).<br>&gt;<br>&gt; That’s my 2c at this time<br>&gt;<br>&gt;<br>&gt; On Jan 22, 2016, at 3:02 PM, Douglas Gregor via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Hello Swift community,<br>&gt;<br>&gt; The review of SE-0005&quot;Better Translation of Objective-C APIs Into Swift&quot;<br>&gt; begins now and runs through January 31, 2016. The proposal is available<br>&gt; here:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md<br>&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt; should be sent to the swift-evolution mailing list at<br>&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the<br>&gt; review manager. When replying, please try to keep the proposal link at the<br>&gt; top of the message:<br>&gt;<br>&gt; Proposal link:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md<br>&gt;<br>&gt; Reply text<br>&gt;<br>&gt; Other replies<br>&gt;<br>&gt; &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What<br>&gt; goes into a review?<br>&gt;<br>&gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and, eventually, determine the direction of<br>&gt; Swift. When writing your review, here are some questions you might want to<br>&gt; answer in your review:<br>&gt;<br>&gt;    - What is your evaluation of the proposal?<br>&gt;    - Is the problem being addressed significant enough to warrant a<br>&gt;    change to Swift?<br>&gt;    - Does this proposal fit well with the feel and direction of Swift?<br>&gt;    - If you have used other languages or libraries with a similar<br>&gt;    feature, how do you feel that this proposal compares to those?<br>&gt;    - How much effort did you put into your review? A glance, a quick<br>&gt;    reading, or an in-depth study?<br>&gt;<br>&gt; More information about the Swift evolution process is available at<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;<br>&gt; Thank you,<br>&gt;<br>&gt; -Doug Gregor<br>&gt;<br>&gt; Review Manager<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160124/ae913306/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/aeab22e60ba7b7e2bd445775850448d1?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Radosław Pietruszewski</string> &lt;radexpl at gmail.com&gt;<p>January 25, 2016 at 03:00:00pm</p></header><div class="content"><p>Hello all,<br></p><p>I’m overwhelmingly *for* this proposal. I think removing needless verbosity and keeping the signal-to-noise ratio high is one of the most immediately appealing aspects of Swift, as well as a great general improvement to the programming experience.<br></p><p>And so unswiftified (yes, it’s a word now) APIs from Objective-C stick out like a sore thumb. Not only are they harder to read and write, they visually overwhelm the less verbose, information-dense Swift-first code.<br></p><p>Just like previous 1.0—2.0 attempts at bridging the gap (with NSError params being translated to Swift errors, factory methods translated to initializers, etc.), automating this will be an error-prone process, and almost bound to be a bit annoying at first, before all the glitches and poor translations are smoothed out. And yet I feel like just like the previous automated translations were overwhelmingly a great thing, so will the result of this proposal.<br></p><p>* * *<br></p><p>&gt;    Add First Argument Labels<br>&gt;    <br>&gt;    - func enumerateObjectsWith(_: NSEnumerationOptions = [], using: (AnyObject, UnsafeMutablePointer) -&gt; Void)<br>&gt;    + func enumerateObjects(options _: NSEnumerationOptions = [], using: (AnyObject, UnsafeMutablePointer) -&gt; Void)<br></p><p>Good! The Guidelines recommend an explicit first parameter label for arguments with a default value, but this is a good change also for another reason, a use case not included in the Guidelines (I have more to say about this in the SE-0023 thread):<br></p><p>“Options” is the description of the parameter, not the method itself. Even if (for whatever reason!) `options` didn’t have a default value and the word “Options” wasn’t omitted in the translation,<br></p><p>   enumerateObjects(options: …)<br></p><p>would be clearer than<br></p><p>   enumerateObjectsWithOptions(…)<br></p><p>It’s not even about the extra word, about the four useless characters, it’s simply that “WithOptions” doesn’t describe the operation at all. It’s a word that conveys no information (“with”), and “options”, which describes the first parameter. In Objective-C, there’s no such thing as parameter labels, it’s all one name, so “With” is used as a separator. But in Swift, making the first parameter’s label explicit just makes more sense.<br></p><p>And with that in mind, I object to these translations:<br></p><p>   func fillWith(_: CGBlendMode, alpha: CGFloat)<br>   func strokeWith(_: CGBlendMode, alpha: CGFloat)<br>   func encodeWith(_: Coder)<br></p><p>Even though these don’t have default values, I believe this version to be clearer and make more sense, even if slightly more verbose:<br></p><p>   func fill(blendMode: CGBlendMode, alpha: CGFloat)<br>   func stroke(blendMode: CGBlendMode, alpha: CGFloat)<br>   func encode(coder: Coder)<br></p><p>Again, the method, the action itself (“fill”, “stroke”, “encode”) doesn’t naturally describe the first parameter in a way “insert” on a collection, or “addObserver” would. The blend mode and coder values here are merely _options_ of the method, not its _fundamental job_.<br></p><p>One way to conceptualize the difference is to think of arguments as being either “inputs” or “options”. A passed element to be inserted to a collection is an input, but blend mode is only an option of a fill, an operation that conceptually takes no inputs.<br></p><p>(I also don’t believe that “don’t repeat type information” rule applies here. “blend mode” is a description of the parameter, not only its type. Same with coder. We’re not needlessly repeating type information here, we’re describing option parameters, which happen to be the same as type names.)<br></p><p>* * *<br></p><p>&gt; 	• How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I’ve read the whole proposal, as well as the related proposals, and read the thread for this review.<br></p><p>&gt; 	• If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>Not other languages as far as I remember, but Swift has a precedent for similar-ish automatic translations of ObjC APIs and they were, on the whole, good.<br></p><p>&gt; 	• Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	• Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes, and oh gosh yes.<br></p><p>Thanks,<br>— Radek<br></p><p>&gt; On 22 Jan 2016, at 22:02, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of SE-0005&quot;Better Translation of Objective-C APIs Into Swift&quot; begins now and runs through January 31, 2016. The proposal is available here:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br>&gt; <br>&gt; Proposal link:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md&gt;<br>&gt; Reply text<br>&gt; <br>&gt; Other replies<br>&gt;  &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; What is your evaluation of the proposal?<br>&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt; Thank you,<br>&gt; <br>&gt; -Doug Gregor<br>&gt; <br>&gt; Review Manager<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160125/83bd72b3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 26, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Jan 25, 2016, at 6:55 AM, Radosław Pietruszewski &lt;radexpl at gmail.com&gt; wrote:<br>&gt; <br>&gt; Hello all,<br>&gt; <br>&gt; I’m overwhelmingly *for* this proposal. I think removing needless verbosity and keeping the signal-to-noise ratio high is one of the most immediately appealing aspects of Swift, as well as a great general improvement to the programming experience.<br>&gt; <br>&gt; And so unswiftified (yes, it’s a word now) APIs from Objective-C stick out like a sore thumb. Not only are they harder to read and write, they visually overwhelm the less verbose, information-dense Swift-first code.<br>&gt; <br>&gt; Just like previous 1.0—2.0 attempts at bridging the gap (with NSError params being translated to Swift errors, factory methods translated to initializers, etc.), automating this will be an error-prone process, and almost bound to be a bit annoying at first, before all the glitches and poor translations are smoothed out. And yet I feel like just like the previous automated translations were overwhelmingly a great thing, so will the result of this proposal.<br>&gt; <br>&gt; * * *<br>&gt; <br>&gt;&gt;    Add First Argument Labels<br>&gt;&gt;    <br>&gt;&gt;    - func enumerateObjectsWith(_: NSEnumerationOptions = [], using: (AnyObject, UnsafeMutablePointer) -&gt; Void)<br>&gt;&gt;    + func enumerateObjects(options _: NSEnumerationOptions = [], using: (AnyObject, UnsafeMutablePointer) -&gt; Void)<br>&gt; <br>&gt; Good! The Guidelines recommend an explicit first parameter label for arguments with a default value, but this is a good change also for another reason, a use case not included in the Guidelines (I have more to say about this in the SE-0023 thread):<br>&gt; <br>&gt; “Options” is the description of the parameter, not the method itself. Even if (for whatever reason!) `options` didn’t have a default value and the word “Options” wasn’t omitted in the translation,<br>&gt; <br>&gt;    enumerateObjects(options: …)<br>&gt; <br>&gt; would be clearer than<br>&gt; <br>&gt;    enumerateObjectsWithOptions(…)<br>&gt; <br>&gt; It’s not even about the extra word, about the four useless characters, it’s simply that “WithOptions” doesn’t describe the operation at all. It’s a word that conveys no information (“with”), and “options”, which describes the first parameter. In Objective-C, there’s no such thing as parameter labels, it’s all one name, so “With” is used as a separator. But in Swift, making the first parameter’s label explicit just makes more sense.<br></p><p>That’s an interesting thought! If “with” is truly used as a convention for separating the description of the operation from the description of the first parameter, that’s something that can be codified in the Clang importer. I was curious, so I hacked it up. Here’s a diff of the Cocoa APIs that shows what things would look like if we treated “with” as a separator:<br></p><p>	https://github.com/apple/swift-3-api-guidelines-review/pull/5/files<br></p><p>It’s a diff against SE-0005, and it introduces a significant number of first argument labels. Indeed, you’ll need to grab the patch to see them all:<br></p><p>	https://github.com/apple/swift-3-api-guidelines-review/pull/5.patch<br></p><p>A brief survey shows that some cases seem to be lining up with the guideline proposals that have been under discussion. For example, the patch includes:<br></p><p>-  func fillWith(blendMode: CGBlendMode, alpha: CGFloat)<br>-  func strokeWith(blendMode: CGBlendMode, alpha: CGFloat)<br>+  func fill(blendMode blendMode: CGBlendMode, alpha: CGFloat)<br>+  func stroke(blendMode blendMode: CGBlendMode, alpha: CGFloat)<br></p><p>-  func encodeWith(aCoder: Coder)<br>+  func encode(coder aCoder: Coder)<br></p><p>which you might recognize, because it’s the example you used:<br></p><p>&gt; And with that in mind, I object to these translations:<br>&gt; <br>&gt;    func fillWith(_: CGBlendMode, alpha: CGFloat)<br>&gt;    func strokeWith(_: CGBlendMode, alpha: CGFloat)<br>&gt;    func encodeWith(_: Coder)<br>&gt; <br>&gt; Even though these don’t have default values, I believe this version to be clearer and make more sense, even if slightly more verbose:<br>&gt; <br>&gt;    func fill(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;    func stroke(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;    func encode(coder: Coder)<br></p><p>Another random interesting example I encountered:<br></p><p>-  func addArcWithCenter(center: CGPoint, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: Bool)<br>+  func addArc(center center: CGPoint, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: Bool)<br></p><p>which seems to match the idea behind Erica’s &quot;semantic relationship between the parameters is stronger than their relation to the operation” (or Paul Cantrell’s similar notion of &quot;the direct object is several args taken together”, which feels more in line with the way the API guidelines are written).<br></p><p>There’s also this:<br></p><p>-  func tracksWithMediaType(mediaType: String) -&gt; [AVMovieTrack]<br>+  func tracks(mediaType mediaType: String) -&gt; [AVMovieTrack]<br></p><p>-  func tracksWithMediaCharacteristic(mediaCharacteristic: String) -&gt;<br>+  func tracks(mediaCharacteristic mediaCharacteristic: String) -&gt; [AVMovieTrack]<br></p><p>which feels reminiscent of Paul’s “resource” example:<br></p><p>    service.resource(&quot;/foo&quot;)<br>    service.resource(absoluteURL: &quot;http://bar.com &lt;http://bar.com/&gt;&quot;)<br>    service.resource(absoluteURL: NSURL(string: &quot;http://bar.com &lt;http://bar.com/&gt;&quot;))<br></p><p>where (I think) the argument is that the various methods should all have the same base name because they’re all returning “tracks” or a “resource”, respectively.<br></p><p>There is a ton of data in that patch. I’d be interested to hear whether the resulting Cocoa APIs feel better in Swift—are they following the evolving set of guidelines for first argument labels that are under discussion, and are the resulting APIs clearer/more Swifty? What specific APIs work well and where does this “with-as-separator” heuristic break down?<br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/074ea3e1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/aeab22e60ba7b7e2bd445775850448d1?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Radosław Pietruszewski</string> &lt;radexpl at gmail.com&gt;<p>January 27, 2016 at 11:00:00am</p></header><div class="content"><p>This is great! Thank you Doug for taking a look at this.<br></p><p>This is a huge patch, so I haven’t looked through it all, but a few interesting bits:<br></p><p>&gt; -  func finishWritingWithCompletionHandler(handler: () -&gt; Void)<br>&gt; +  func finishWriting(completionHandler handler: () -&gt; Void)<br></p><p>This is something I mentioned in my review of SE-0023. An example with a completionHandler param was made in the Guidelines (that should have an explicit label because it has a default value), and I argued that it would make sense for the “completionHandler” to have a label _even if it didn’t have a default value_. A few examples in the diff seem to confirm this notion for me.<br></p><p>&gt; -  func respondWith(data: Data)<br>&gt; +  func respond(data data: Data)<br></p><p>This one is unusual. I don’t mind `respond(data: …)`, but generally there’s a word to the right of “with”, and here the “with” was just to imply the argument without naming it.<br></p><p>&gt; -  class func instantiateWith(audioComponentDescription: AudioComponentDescription, options: AudioComponentInstantiationOptions = [], completionHandler: (AVAudioUnit?, Error?) -&gt; Void)<br>&gt; +  class func instantiate(componentDescription audioComponentDescription: AudioComponentDescription, options: AudioComponentInstantiationOptions = [], completionHandler: (AVAudioUnit?, Error?) -&gt; Void)<br></p><p>Another unusual one. I don’t know AV* APIs, but for whatever reason they have an “instantiate” class method instead of just init. But just like with init the first param name is moved from the “initWithFoo” name to an label, here it also seems to make a lot of sense.<br></p><p>&gt; -  func indexOfItemWithTitle(title: String) -&gt; Int<br>&gt; -  func indexOfItemWithTag(tag: Int) -&gt; Int<br>&gt; -  func indexOfItemWithRepresentedObject(obj: AnyObject?) -&gt; Int<br>&gt; -  func indexOfItemWithTarget(target: AnyObject?, andAction actionSelector: Selector) -&gt; Int<br>&gt; +  func indexOfItem(title title: String) -&gt; Int<br>&gt; +  func indexOfItem(tag tag: Int) -&gt; Int<br>&gt; +  func indexOfItem(representedObject obj: AnyObject?) -&gt; Int<br>&gt; +  func indexOfItem(target target: AnyObject?, andAction actionSelector: Selector) -&gt; Int<br></p><p>An example of a method family that does the same fundamental job but takes different parameters. To me, it makes a ton of sense that they have the same name and then overload it by parameters. You couldn’t do that in ObjC, but I suppose that’s how a Swift-first API would be designed. But if you do that, it’s good for readability to have the first parameter explicitly described.<br></p><p>— Radek<br></p><p>&gt; On 27 Jan 2016, at 08:50, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 25, 2016, at 6:55 AM, Radosław Pietruszewski &lt;radexpl at gmail.com &lt;mailto:radexpl at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello all,<br>&gt;&gt; <br>&gt;&gt; I’m overwhelmingly *for* this proposal. I think removing needless verbosity and keeping the signal-to-noise ratio high is one of the most immediately appealing aspects of Swift, as well as a great general improvement to the programming experience.<br>&gt;&gt; <br>&gt;&gt; And so unswiftified (yes, it’s a word now) APIs from Objective-C stick out like a sore thumb. Not only are they harder to read and write, they visually overwhelm the less verbose, information-dense Swift-first code.<br>&gt;&gt; <br>&gt;&gt; Just like previous 1.0—2.0 attempts at bridging the gap (with NSError params being translated to Swift errors, factory methods translated to initializers, etc.), automating this will be an error-prone process, and almost bound to be a bit annoying at first, before all the glitches and poor translations are smoothed out. And yet I feel like just like the previous automated translations were overwhelmingly a great thing, so will the result of this proposal.<br>&gt;&gt; <br>&gt;&gt; * * *<br>&gt;&gt; <br>&gt;&gt;&gt;    Add First Argument Labels<br>&gt;&gt;&gt;    <br>&gt;&gt;&gt;    - func enumerateObjectsWith(_: NSEnumerationOptions = [], using: (AnyObject, UnsafeMutablePointer) -&gt; Void)<br>&gt;&gt;&gt;    + func enumerateObjects(options _: NSEnumerationOptions = [], using: (AnyObject, UnsafeMutablePointer) -&gt; Void)<br>&gt;&gt; <br>&gt;&gt; Good! The Guidelines recommend an explicit first parameter label for arguments with a default value, but this is a good change also for another reason, a use case not included in the Guidelines (I have more to say about this in the SE-0023 thread):<br>&gt;&gt; <br>&gt;&gt; “Options” is the description of the parameter, not the method itself. Even if (for whatever reason!) `options` didn’t have a default value and the word “Options” wasn’t omitted in the translation,<br>&gt;&gt; <br>&gt;&gt;    enumerateObjects(options: …)<br>&gt;&gt; <br>&gt;&gt; would be clearer than<br>&gt;&gt; <br>&gt;&gt;    enumerateObjectsWithOptions(…)<br>&gt;&gt; <br>&gt;&gt; It’s not even about the extra word, about the four useless characters, it’s simply that “WithOptions” doesn’t describe the operation at all. It’s a word that conveys no information (“with”), and “options”, which describes the first parameter. In Objective-C, there’s no such thing as parameter labels, it’s all one name, so “With” is used as a separator. But in Swift, making the first parameter’s label explicit just makes more sense.<br>&gt; <br>&gt; That’s an interesting thought! If “with” is truly used as a convention for separating the description of the operation from the description of the first parameter, that’s something that can be codified in the Clang importer. I was curious, so I hacked it up. Here’s a diff of the Cocoa APIs that shows what things would look like if we treated “with” as a separator:<br>&gt; <br>&gt; 	https://github.com/apple/swift-3-api-guidelines-review/pull/5/files &lt;https://github.com/apple/swift-3-api-guidelines-review/pull/5/files&gt;<br>&gt; <br>&gt; It’s a diff against SE-0005, and it introduces a significant number of first argument labels. Indeed, you’ll need to grab the patch to see them all:<br>&gt; <br>&gt; 	https://github.com/apple/swift-3-api-guidelines-review/pull/5.patch &lt;https://github.com/apple/swift-3-api-guidelines-review/pull/5.patch&gt;<br>&gt; <br>&gt; A brief survey shows that some cases seem to be lining up with the guideline proposals that have been under discussion. For example, the patch includes:<br>&gt; <br>&gt; -  func fillWith(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt; -  func strokeWith(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt; +  func fill(blendMode blendMode: CGBlendMode, alpha: CGFloat)<br>&gt; +  func stroke(blendMode blendMode: CGBlendMode, alpha: CGFloat)<br>&gt; <br>&gt; -  func encodeWith(aCoder: Coder)<br>&gt; +  func encode(coder aCoder: Coder)<br>&gt; <br>&gt; which you might recognize, because it’s the example you used:<br>&gt; <br>&gt;&gt; And with that in mind, I object to these translations:<br>&gt;&gt; <br>&gt;&gt;    func fillWith(_: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;    func strokeWith(_: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;    func encodeWith(_: Coder)<br>&gt;&gt; <br>&gt;&gt; Even though these don’t have default values, I believe this version to be clearer and make more sense, even if slightly more verbose:<br>&gt;&gt; <br>&gt;&gt;    func fill(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;    func stroke(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;    func encode(coder: Coder)<br>&gt; <br>&gt; Another random interesting example I encountered:<br>&gt; <br>&gt; -  func addArcWithCenter(center: CGPoint, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: Bool)<br>&gt; +  func addArc(center center: CGPoint, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: Bool)<br>&gt; <br>&gt; which seems to match the idea behind Erica’s &quot;semantic relationship between the parameters is stronger than their relation to the operation” (or Paul Cantrell’s similar notion of &quot;the direct object is several args taken together”, which feels more in line with the way the API guidelines are written).<br>&gt; <br>&gt; There’s also this:<br>&gt; <br>&gt; -  func tracksWithMediaType(mediaType: String) -&gt; [AVMovieTrack]<br>&gt; +  func tracks(mediaType mediaType: String) -&gt; [AVMovieTrack]<br>&gt; <br>&gt; -  func tracksWithMediaCharacteristic(mediaCharacteristic: String) -&gt;<br>&gt; +  func tracks(mediaCharacteristic mediaCharacteristic: String) -&gt; [AVMovieTrack]<br>&gt; <br>&gt; which feels reminiscent of Paul’s “resource” example:<br>&gt; <br>&gt;     service.resource(&quot;/foo&quot;)<br>&gt;     service.resource(absoluteURL: &quot;http://bar.com &lt;http://bar.com/&gt;&quot;)<br>&gt;     service.resource(absoluteURL: NSURL(string: &quot;http://bar.com &lt;http://bar.com/&gt;&quot;))<br>&gt; <br>&gt; where (I think) the argument is that the various methods should all have the same base name because they’re all returning “tracks” or a “resource”, respectively.<br>&gt; <br>&gt; There is a ton of data in that patch. I’d be interested to hear whether the resulting Cocoa APIs feel better in Swift—are they following the evolving set of guidelines for first argument labels that are under discussion, and are the resulting APIs clearer/more Swifty? What specific APIs work well and where does this “with-as-separator” heuristic break down?<br>&gt; <br>&gt; 	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/61c273f3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 27, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jan 27, 2016, at 2:09 AM, Radosław Pietruszewski &lt;radexpl at gmail.com&gt; wrote:<br>&gt; <br>&gt; This is great! Thank you Doug for taking a look at this.<br>&gt; <br>&gt; This is a huge patch, so I haven’t looked through it all, but a few interesting bits:<br>&gt; <br>&gt;&gt; -  func finishWritingWithCompletionHandler(handler: () -&gt; Void)<br>&gt;&gt; +  func finishWriting(completionHandler handler: () -&gt; Void)<br>&gt; <br>&gt; This is something I mentioned in my review of SE-0023. An example with a completionHandler param was made in the Guidelines (that should have an explicit label because it has a default value), and I argued that it would make sense for the “completionHandler” to have a label _even if it didn’t have a default value_. A few examples in the diff seem to confirm this notion for me.<br></p><p>Ah, good point. “WithCompletionHandler” is a well-followed convention, so I’d expect to see more<br></p><p>&gt; <br>&gt;&gt; -  func respondWith(data: Data)<br>&gt;&gt; +  func respond(data data: Data)<br>&gt; <br>&gt; This one is unusual. I don’t mind `respond(data: …)`, but generally there’s a word to the right of “with”, and here the “with” was just to imply the argument without naming it.<br></p><p>The original ObjC method name was “respondWithData:”. “Data” restates type info, so SE-0023 stripped it off; this transformation makes it the first argument label.<br>&gt; <br>&gt;&gt; -  class func instantiateWith(audioComponentDescription: AudioComponentDescription, options: AudioComponentInstantiationOptions = [], completionHandler: (AVAudioUnit?, Error?) -&gt; Void)<br>&gt;&gt; +  class func instantiate(componentDescription audioComponentDescription: AudioComponentDescription, options: AudioComponentInstantiationOptions = [], completionHandler: (AVAudioUnit?, Error?) -&gt; Void)<br>&gt; <br>&gt; Another unusual one. I don’t know AV* APIs, but for whatever reason they have an “instantiate” class method instead of just init. But just like with init the first param name is moved from the “initWithFoo” name to an label, here it also seems to make a lot of sense.<br></p><p>Note that the instantiated audio unit is provided to a completion handler, so this can’t be an initializer.<br>&gt;&gt; -  func indexOfItemWithTitle(title: String) -&gt; Int<br>&gt;&gt; -  func indexOfItemWithTag(tag: Int) -&gt; Int<br>&gt;&gt; -  func indexOfItemWithRepresentedObject(obj: AnyObject?) -&gt; Int<br>&gt;&gt; -  func indexOfItemWithTarget(target: AnyObject?, andAction actionSelector: Selector) -&gt; Int<br>&gt;&gt; +  func indexOfItem(title title: String) -&gt; Int<br>&gt;&gt; +  func indexOfItem(tag tag: Int) -&gt; Int<br>&gt;&gt; +  func indexOfItem(representedObject obj: AnyObject?) -&gt; Int<br>&gt;&gt; +  func indexOfItem(target target: AnyObject?, andAction actionSelector: Selector) -&gt; Int<br>&gt; <br>&gt; An example of a method family that does the same fundamental job but takes different parameters. To me, it makes a ton of sense that they have the same name and then overload it by parameters. You couldn’t do that in ObjC, but I suppose that’s how a Swift-first API would be designed. But if you do that, it’s good for readability to have the first parameter explicitly described.<br></p><p>Thanks for the feedback!<br></p><p>	- Doug<br></p><p><br></p><p>&gt; — Radek<br>&gt; <br>&gt;&gt; On 27 Jan 2016, at 08:50, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 25, 2016, at 6:55 AM, Radosław Pietruszewski &lt;radexpl at gmail.com &lt;mailto:radexpl at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m overwhelmingly *for* this proposal. I think removing needless verbosity and keeping the signal-to-noise ratio high is one of the most immediately appealing aspects of Swift, as well as a great general improvement to the programming experience.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And so unswiftified (yes, it’s a word now) APIs from Objective-C stick out like a sore thumb. Not only are they harder to read and write, they visually overwhelm the less verbose, information-dense Swift-first code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Just like previous 1.0—2.0 attempts at bridging the gap (with NSError params being translated to Swift errors, factory methods translated to initializers, etc.), automating this will be an error-prone process, and almost bound to be a bit annoying at first, before all the glitches and poor translations are smoothed out. And yet I feel like just like the previous automated translations were overwhelmingly a great thing, so will the result of this proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * * *<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    Add First Argument Labels<br>&gt;&gt;&gt;&gt;    <br>&gt;&gt;&gt;&gt;    - func enumerateObjectsWith(_: NSEnumerationOptions = [], using: (AnyObject, UnsafeMutablePointer) -&gt; Void)<br>&gt;&gt;&gt;&gt;    + func enumerateObjects(options _: NSEnumerationOptions = [], using: (AnyObject, UnsafeMutablePointer) -&gt; Void)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Good! The Guidelines recommend an explicit first parameter label for arguments with a default value, but this is a good change also for another reason, a use case not included in the Guidelines (I have more to say about this in the SE-0023 thread):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; “Options” is the description of the parameter, not the method itself. Even if (for whatever reason!) `options` didn’t have a default value and the word “Options” wasn’t omitted in the translation,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    enumerateObjects(options: …)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; would be clearer than<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    enumerateObjectsWithOptions(…)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It’s not even about the extra word, about the four useless characters, it’s simply that “WithOptions” doesn’t describe the operation at all. It’s a word that conveys no information (“with”), and “options”, which describes the first parameter. In Objective-C, there’s no such thing as parameter labels, it’s all one name, so “With” is used as a separator. But in Swift, making the first parameter’s label explicit just makes more sense.<br>&gt;&gt; <br>&gt;&gt; That’s an interesting thought! If “with” is truly used as a convention for separating the description of the operation from the description of the first parameter, that’s something that can be codified in the Clang importer. I was curious, so I hacked it up. Here’s a diff of the Cocoa APIs that shows what things would look like if we treated “with” as a separator:<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-3-api-guidelines-review/pull/5/files &lt;https://github.com/apple/swift-3-api-guidelines-review/pull/5/files&gt;<br>&gt;&gt; <br>&gt;&gt; It’s a diff against SE-0005, and it introduces a significant number of first argument labels. Indeed, you’ll need to grab the patch to see them all:<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-3-api-guidelines-review/pull/5.patch &lt;https://github.com/apple/swift-3-api-guidelines-review/pull/5.patch&gt;<br>&gt;&gt; <br>&gt;&gt; A brief survey shows that some cases seem to be lining up with the guideline proposals that have been under discussion. For example, the patch includes:<br>&gt;&gt; <br>&gt;&gt; -  func fillWith(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt; -  func strokeWith(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt; +  func fill(blendMode blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt; +  func stroke(blendMode blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt; <br>&gt;&gt; -  func encodeWith(aCoder: Coder)<br>&gt;&gt; +  func encode(coder aCoder: Coder)<br>&gt;&gt; <br>&gt;&gt; which you might recognize, because it’s the example you used:<br>&gt;&gt; <br>&gt;&gt;&gt; And with that in mind, I object to these translations:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    func fillWith(_: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;    func strokeWith(_: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;    func encodeWith(_: Coder)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Even though these don’t have default values, I believe this version to be clearer and make more sense, even if slightly more verbose:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    func fill(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;    func stroke(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;    func encode(coder: Coder)<br>&gt;&gt; <br>&gt;&gt; Another random interesting example I encountered:<br>&gt;&gt; <br>&gt;&gt; -  func addArcWithCenter(center: CGPoint, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: Bool)<br>&gt;&gt; +  func addArc(center center: CGPoint, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: Bool)<br>&gt;&gt; <br>&gt;&gt; which seems to match the idea behind Erica’s &quot;semantic relationship between the parameters is stronger than their relation to the operation” (or Paul Cantrell’s similar notion of &quot;the direct object is several args taken together”, which feels more in line with the way the API guidelines are written).<br>&gt;&gt; <br>&gt;&gt; There’s also this:<br>&gt;&gt; <br>&gt;&gt; -  func tracksWithMediaType(mediaType: String) -&gt; [AVMovieTrack]<br>&gt;&gt; +  func tracks(mediaType mediaType: String) -&gt; [AVMovieTrack]<br>&gt;&gt; <br>&gt;&gt; -  func tracksWithMediaCharacteristic(mediaCharacteristic: String) -&gt;<br>&gt;&gt; +  func tracks(mediaCharacteristic mediaCharacteristic: String) -&gt; [AVMovieTrack]<br>&gt;&gt; <br>&gt;&gt; which feels reminiscent of Paul’s “resource” example:<br>&gt;&gt; <br>&gt;&gt;     service.resource(&quot;/foo&quot;)<br>&gt;&gt;     service.resource(absoluteURL: &quot;http://bar.com &lt;http://bar.com/&gt;&quot;)<br>&gt;&gt;     service.resource(absoluteURL: NSURL(string: &quot;http://bar.com &lt;http://bar.com/&gt;&quot;))<br>&gt;&gt; <br>&gt;&gt; where (I think) the argument is that the various methods should all have the same base name because they’re all returning “tracks” or a “resource”, respectively.<br>&gt;&gt; <br>&gt;&gt; There is a ton of data in that patch. I’d be interested to hear whether the resulting Cocoa APIs feel better in Swift—are they following the evolving set of guidelines for first argument labels that are under discussion, and are the resulting APIs clearer/more Swifty? What specific APIs work well and where does this “with-as-separator” heuristic break down?<br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/049523a3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5a72880ffed1a30cb9b8e3f372507145?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Rob Mayoff</string> &lt;mayoff at dqd.com&gt;<p>January 27, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt;<br>&gt; -  func respondWith(data: Data)<br>&gt; +  func respond(data data: Data)<br>&gt;<br>&gt; This one is unusual. I don’t mind `respond(data: …)`, but generally<br>&gt; there’s a word to the right of “with”, and here the “with” was just to<br>&gt; imply the argument without naming it.<br>&gt;<br>&gt;<br>&gt; The original ObjC method name was “respondWithData:”. “Data” restates type<br>&gt; info, so SE-0023 stripped it off; this transformation makes it the first<br>&gt; argument label.<br>&gt;<br></p><p>Can I tell, at a call site, whether `respond(data: someData)` is responding<br>with someData, or responding to someData?<br></p><p>That is, can I tell whether someData is the response, or instead is<br>something from the request that the receiver will use to compute the<br>response?<br></p><p>If I see `respondWith(someData)` or `respondWith(data: someData)` or<br>`respondWithData(someData)`, it&#39;s clear to me that someData is the<br>response, while a hypothetical call `respondTo(someData)` would tell me<br>that someData is the input to the response-computing algorithm.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/97691e75/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>January 27, 2016 at 10:00:00pm</p></header><div class="content"><p>On 27 Jan 2016, at 21:48, Rob Mayoff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; -  func respondWith(data: Data)<br>&gt;&gt;&gt; +  func respond(data data: Data)<br>&gt;&gt; <br>&gt;&gt; This one is unusual. I don’t mind `respond(data: …)`, but generally there’s a word to the right of “with”, and here the “with” was just to imply the argument without naming it.<br>&gt; <br>&gt; The original ObjC method name was “respondWithData:”. “Data” restates type info, so SE-0023 stripped it off; this transformation makes it the first argument label.<br>&gt; <br>&gt; Can I tell, at a call site, whether `respond(data: someData)` is responding with someData, or responding to someData?<br>&gt; <br>&gt; That is, can I tell whether someData is the response, or instead is something from the request that the receiver will use to compute the response?<br>&gt; <br>&gt; If I see `respondWith(someData)` or `respondWith(data: someData)` or `respondWithData(someData)`, it&#39;s clear to me that someData is the response, while a hypothetical call `respondTo(someData)` would tell me that someData is the input to the response-computing algorithm.<br></p><p>I’d like to reiterate that my preference for cases like these would be:<br></p><p>	respond(withData data: Data)<br></p><p>This way the action (function name) is still simplified to respond, but the sentence structure remains for clarity, which I still think is the best of both worlds.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/e8067517/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 27, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jan 27, 2016, at 2:15 PM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On 27 Jan 2016, at 21:48, Rob Mayoff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; -  func respondWith(data: Data)<br>&gt;&gt;&gt;&gt; +  func respond(data data: Data)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This one is unusual. I don’t mind `respond(data: …)`, but generally there’s a word to the right of “with”, and here the “with” was just to imply the argument without naming it.<br>&gt;&gt; <br>&gt;&gt; The original ObjC method name was “respondWithData:”. “Data” restates type info, so SE-0023 stripped it off; this transformation makes it the first argument label.<br>&gt;&gt; <br>&gt;&gt; Can I tell, at a call site, whether `respond(data: someData)` is responding with someData, or responding to someData?<br>&gt;&gt; <br>&gt;&gt; That is, can I tell whether someData is the response, or instead is something from the request that the receiver will use to compute the response?<br>&gt;&gt; <br>&gt;&gt; If I see `respondWith(someData)` or `respondWith(data: someData)` or `respondWithData(someData)`, it&#39;s clear to me that someData is the response, while a hypothetical call `respondTo(someData)` would tell me that someData is the input to the response-computing algorithm.<br>&gt; <br>&gt; I’d like to reiterate that my preference for cases like these would be:<br>&gt; <br>&gt; 	respond(withData data: Data)<br>&gt; <br>&gt; This way the action (function name) is still simplified to respond, but the sentence structure remains for clarity, which I still think is the best of both worlds.<br></p><p>Observation: I’ve never seen anyone write Swift code this way, with a proposition “with” on the first argument label. Have you?<br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/49bca45d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>January 28, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On 27 Jan 2016, at 22:37, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt; On Jan 27, 2016, at 2:15 PM, Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I’d like to reiterate that my preference for cases like these would be:<br>&gt;&gt; <br>&gt;&gt; 	respond(withData data: Data)<br>&gt;&gt; <br>&gt;&gt; This way the action (function name) is still simplified to respond, but the sentence structure remains for clarity, which I still think is the best of both worlds.<br>&gt; <br>&gt; Observation: I’ve never seen anyone write Swift code this way, with a proposition “with” on the first argument label. Have you?<br></p><p>I do ;)<br></p><p>One thing I really love about Swift’s external names is the ability to make my function calls read a lot like natural language, but in doing so actually clarify how a parameter is used, potentially eliminating the need to consult documentation at all.<br></p><p>Granted “with” may not be the best word, but in the example it implies to me more that the data itself is being returned, rather than being used to generate some kind of other response, whereas “data” on its own might require me to check to be sure I’ve understand what the function will do with that data.<br></p><p>For example, I might declare methods like:<br></p><p>	func find(theSearchTerm needle:String, inTheString haystack:String) -&gt; Range&lt;String.Index&gt;<br>	let match = matcher.find(theSearchTerm: “find me”, inTheString: “see if you can find me in this”)<br></p><p>Still might not be the best example but hopefully it gives you the idea. Sometimes there’s verbosity for the sake of maintaining the pattern, but the idea is to end up with self-documenting function declarations. Of course I had SwiftDoc anyway for clarity and because I’m an habitual documenter, but if a function can be understood purely from how it’s used then that’s a good thing IMO. I should mention I’m a huge fan of Applescript’s syntax (though I hate its performance).<br></p><p>Of course I realise we’re talking about converting Objective-C functions, but while I don’t like the overly long function names (I prefer functions with a similar action to have the same name) I do like that some of them are self-documenting thanks to the added verbosity, and I’m just concerned that we might lose some of that, as personally I try to keep my functions fairly descriptive in my own code.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/ed357510/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e941adb360692446106cebd7f6d2a1a3?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Charles Constant</string> &lt;charles at charlesism.com&gt;<p>February  2, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; Observation: I’ve never seen anyone write Swift code this way, with a<br>proposition “with” on the first argument label. Have you?<br></p><p>I started doing that a couple months ago. It&#39;s a fine option, imho. I&#39;d<br>prefer we keep func names as verbs only, I&#39;m fine with a bunch of<br>overloaded funds (the arguments are enough). I prefer arguments with<br>prepositions, since without can be too vague. The last couple months I&#39;ve<br>found naming things to be much easier, and understanding the functions<br>easier at a glance because each part of the name does the same thing every<br>time - unlike a verb sandwiched, sometimes with a noun, or argument labels<br>that &quot;seem good at the time&quot; but then are confusing for the reasons<br>Haaravik points out.<br></p><p>So for me, I prefer to read this type of thing:<br></p><p>func farfelize( to_foo foo:Obj!, using_bar bar:Obj!, with_options<br>opts:Choice! ){ ... }<br></p><p><br></p><p><br></p><p>On Wed, Jan 27, 2016 at 2:37 PM, Douglas Gregor via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Jan 27, 2016, at 2:15 PM, Haravikk via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On 27 Jan 2016, at 21:48, Rob Mayoff via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; -  func respondWith(data: Data)<br>&gt;&gt; +  func respond(data data: Data)<br>&gt;&gt;<br>&gt;&gt; This one is unusual. I don’t mind `respond(data: …)`, but generally<br>&gt;&gt; there’s a word to the right of “with”, and here the “with” was just to<br>&gt;&gt; imply the argument without naming it.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; The original ObjC method name was “respondWithData:”. “Data” restates<br>&gt;&gt; type info, so SE-0023 stripped it off; this transformation makes it the<br>&gt;&gt; first argument label.<br>&gt;&gt;<br>&gt;<br>&gt; Can I tell, at a call site, whether `respond(data: someData)` is<br>&gt; responding with someData, or responding to someData?<br>&gt;<br>&gt; That is, can I tell whether someData is the response, or instead is<br>&gt; something from the request that the receiver will use to compute the<br>&gt; response?<br>&gt;<br>&gt; If I see `respondWith(someData)` or `respondWith(data: someData)` or<br>&gt; `respondWithData(someData)`, it&#39;s clear to me that someData is the<br>&gt; response, while a hypothetical call `respondTo(someData)` would tell me<br>&gt; that someData is the input to the response-computing algorithm.<br>&gt;<br>&gt;<br>&gt; I’d like to reiterate that my preference for cases like these would be:<br>&gt;<br>&gt; respond(withData data: Data)<br>&gt;<br>&gt; This way the action (function name) is still simplified to respond, but<br>&gt; the sentence structure remains for clarity, which I still think is the best<br>&gt; of both worlds.<br>&gt;<br>&gt;<br>&gt; Observation: I’ve never seen anyone write Swift code this way, with a<br>&gt; proposition “with” on the first argument label. Have you?<br>&gt;<br>&gt; - Doug<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/b17501e4/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/aeab22e60ba7b7e2bd445775850448d1?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Radosław Pietruszewski</string> &lt;radexpl at gmail.com&gt;<p>January 27, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt;&gt; <br>&gt;&gt; Can I tell, at a call site, whether `respond(data: someData)` is responding with someData, or responding to someData?<br>&gt;&gt; <br>&gt;&gt; That is, can I tell whether someData is the response, or instead is something from the request that the receiver will use to compute the response?<br>&gt;&gt; <br>&gt;&gt; If I see `respondWith(someData)` or `respondWith(data: someData)` or `respondWithData(someData)`, it&#39;s clear to me that someData is the response, while a hypothetical call `respondTo(someData)` would tell me that someData is the input to the response-computing algorithm.<br>&gt; <br>&gt; I’d like to reiterate that my preference for cases like these would be:<br>&gt; <br>&gt; 	respond(withData data: Data)<br>&gt; <br>&gt; This way the action (function name) is still simplified to respond, but the sentence structure remains for clarity, which I still think is the best of both worlds.<br></p><p>That seems very weird.<br></p><p>I’d prefer<br></p><p>   respondWith(data: Data)<br></p><p>to “with” in the label.<br></p><p>(But honestly it seems like an edge case for “with” here to have some meaning aside from just being a separator. Unless there’s a reliable heuristic to differentiate, `respond(data data: Data)` isn’t bad.)<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/08a11245/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 27, 2016 at 10:00:00am</p></header><div class="content"><p>Doug,<br></p><p>I think this change looks great!  I don’t have time to look through the full patch but did look through quite a bit.  It adds clarity in the vast majority of cases I looked at.  <br></p><p>It seems like with-as-separator is a good heuristic for determining when the first parameter is not essential to a good name for the fundamental operation.  I agree with the comments earlier on that in these cases a label for the first parameter is the best approach.<br></p><p>I also really like that this groups methods with the same fundamental operation into overload families where they previously had independent names.  This is a big win IMO.<br></p><p>There is a first-parameter-is-an-ID pattern I noticed after this change.  I show a few examples here, but there are a lot more:<br></p><p>-  func trackWithTrackID(trackID: CMPersistentTrackID) -&gt; AVAssetTrack?<br>+  func track(trackID trackID: CMPersistentTrackID) -&gt; AVAssetTrack?<br></p><p>-  func trackWithTrackID(trackID: CMPersistentTrackID) -&gt; AVFragmentedAssetTrack?<br>+  func track(trackID trackID: CMPersistentTrackID) -&gt; AVFragmentedAssetTrack?<br></p><p>-  func trackWithTrackID(trackID: CMPersistentTrackID) -&gt; AVCompositionTrack?<br>+  func track(trackID trackID: CMPersistentTrackID) -&gt; AVCompositionTrack?<br></p><p>-  func discoverUserInfoWithUserRecordID(userRecordID: CKRecordID, completionHandler: (CKDiscoveredUserInfo?, Error?) -&gt; Void)<br></p><p>+  func discoverUserInfo(userRecordID userRecordID: CKRecordID, completionHandler: (CKDiscoveredUserInfo?, Error?) -&gt; Void)<br></p><p>The first argument label `trackID` seems like it repeats type information without adding clarity.  I think it would be better to just use `id` here.  It seems like a candidate for heuristics as well.  For example, if the type name ends in ID and the label is a suffix of the type name we could just use `id`.  This is a somewhat specific pattern, but IDs are common enough that it might make sense.<br></p><p>Interestingly, in at least one case the `WithID` was the original name of the method so we did receive a simple `id` label:<br></p><p>-  func parameterWithID(paramID: AudioUnitParameterID, scope: AudioUnitScope, element: AudioUnitElement) -&gt; AUParameter?<br>+  func parameter(id paramID: AudioUnitParameterID, scope: AudioUnitScope, element: AudioUnitElement) -&gt; AUParameter?<br></p><p>In another case, the method has a naked `With` at the end.  Somehow `id` was used in that scenario despite the parameter name being `objectID` and the type being `NSManagedObjectID`, which aligns with my suggested naming:<br></p><p>-  func newValuesForObjectWith(objectID: NSManagedObjectID, withContext context: NSManagedObjectContext) throws -&gt; NSIncrementalStoreNode<br>+  func newValuesForObject(id objectID: NSManagedObjectID, withContext context: NSManagedObjectContext) throws -&gt; NSIncrementalStoreNode<br></p><p>A case related to that used `iDs` for array arguments:  <br></p><p>-  func managedObjectContextDidRegisterObjectsWithIDs(objectIDs: [NSManagedObjectID])<br>-  func managedObjectContextDidUnregisterObjectsWithIDs(objectIDs: [NSManagedObjectID])<br>+  func managedObjectContextDidRegisterObjects(iDs objectIDs: [NSManagedObjectID])<br>+  func managedObjectContextDidUnregisterObjects(iDs objectIDs: [NSManagedObjectID])<br></p><p>I would prefer `ids` here.  This seems like a pattern that would be a problem for any all-caps plural acronym or initialism so it might be good to add a heuristic for this as well.<br></p><p><br>Here’s another interesting change:<br></p><p>-  func unionWith(s2: CIFilterShape) -&gt; CIFilterShape<br>-  func unionWith(r: CGRect) -&gt; CIFilterShape<br>-  func intersectWith(s2: CIFilterShape) -&gt; CIFilterShape<br>-  func intersectWith(r: CGRect) -&gt; CIFilterShape<br>+  func union(with s2: CIFilterShape) -&gt; CIFilterShape<br>+  func union(rect r: CGRect) -&gt; CIFilterShape<br>+  func intersect(with s2: CIFilterShape) -&gt; CIFilterShape<br>+  func intersect(rect r: CGRect) -&gt; CIFilterShape<br></p><p>Why do the CGRect arguments receive a type-derived label but the CIFilterShape arguments just receive `with`?  Shouldn’t these follow the same pattern?<br></p><p>-Matthew<br></p><p><br>&gt; On Jan 27, 2016, at 1:50 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 25, 2016, at 6:55 AM, Radosław Pietruszewski &lt;radexpl at gmail.com &lt;mailto:radexpl at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello all,<br>&gt;&gt; <br>&gt;&gt; I’m overwhelmingly *for* this proposal. I think removing needless verbosity and keeping the signal-to-noise ratio high is one of the most immediately appealing aspects of Swift, as well as a great general improvement to the programming experience.<br>&gt;&gt; <br>&gt;&gt; And so unswiftified (yes, it’s a word now) APIs from Objective-C stick out like a sore thumb. Not only are they harder to read and write, they visually overwhelm the less verbose, information-dense Swift-first code.<br>&gt;&gt; <br>&gt;&gt; Just like previous 1.0—2.0 attempts at bridging the gap (with NSError params being translated to Swift errors, factory methods translated to initializers, etc.), automating this will be an error-prone process, and almost bound to be a bit annoying at first, before all the glitches and poor translations are smoothed out. And yet I feel like just like the previous automated translations were overwhelmingly a great thing, so will the result of this proposal.<br>&gt;&gt; <br>&gt;&gt; * * *<br>&gt;&gt; <br>&gt;&gt;&gt;    Add First Argument Labels<br>&gt;&gt;&gt;    <br>&gt;&gt;&gt;    - func enumerateObjectsWith(_: NSEnumerationOptions = [], using: (AnyObject, UnsafeMutablePointer) -&gt; Void)<br>&gt;&gt;&gt;    + func enumerateObjects(options _: NSEnumerationOptions = [], using: (AnyObject, UnsafeMutablePointer) -&gt; Void)<br>&gt;&gt; <br>&gt;&gt; Good! The Guidelines recommend an explicit first parameter label for arguments with a default value, but this is a good change also for another reason, a use case not included in the Guidelines (I have more to say about this in the SE-0023 thread):<br>&gt;&gt; <br>&gt;&gt; “Options” is the description of the parameter, not the method itself. Even if (for whatever reason!) `options` didn’t have a default value and the word “Options” wasn’t omitted in the translation,<br>&gt;&gt; <br>&gt;&gt;    enumerateObjects(options: …)<br>&gt;&gt; <br>&gt;&gt; would be clearer than<br>&gt;&gt; <br>&gt;&gt;    enumerateObjectsWithOptions(…)<br>&gt;&gt; <br>&gt;&gt; It’s not even about the extra word, about the four useless characters, it’s simply that “WithOptions” doesn’t describe the operation at all. It’s a word that conveys no information (“with”), and “options”, which describes the first parameter. In Objective-C, there’s no such thing as parameter labels, it’s all one name, so “With” is used as a separator. But in Swift, making the first parameter’s label explicit just makes more sense.<br>&gt; <br>&gt; That’s an interesting thought! If “with” is truly used as a convention for separating the description of the operation from the description of the first parameter, that’s something that can be codified in the Clang importer. I was curious, so I hacked it up. Here’s a diff of the Cocoa APIs that shows what things would look like if we treated “with” as a separator:<br>&gt; <br>&gt; 	https://github.com/apple/swift-3-api-guidelines-review/pull/5/files &lt;https://github.com/apple/swift-3-api-guidelines-review/pull/5/files&gt;<br>&gt; <br>&gt; It’s a diff against SE-0005, and it introduces a significant number of first argument labels. Indeed, you’ll need to grab the patch to see them all:<br>&gt; <br>&gt; 	https://github.com/apple/swift-3-api-guidelines-review/pull/5.patch &lt;https://github.com/apple/swift-3-api-guidelines-review/pull/5.patch&gt;<br>&gt; <br>&gt; A brief survey shows that some cases seem to be lining up with the guideline proposals that have been under discussion. For example, the patch includes:<br>&gt; <br>&gt; -  func fillWith(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt; -  func strokeWith(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt; +  func fill(blendMode blendMode: CGBlendMode, alpha: CGFloat)<br>&gt; +  func stroke(blendMode blendMode: CGBlendMode, alpha: CGFloat)<br>&gt; <br>&gt; -  func encodeWith(aCoder: Coder)<br>&gt; +  func encode(coder aCoder: Coder)<br>&gt; <br>&gt; which you might recognize, because it’s the example you used:<br>&gt; <br>&gt;&gt; And with that in mind, I object to these translations:<br>&gt;&gt; <br>&gt;&gt;    func fillWith(_: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;    func strokeWith(_: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;    func encodeWith(_: Coder)<br>&gt;&gt; <br>&gt;&gt; Even though these don’t have default values, I believe this version to be clearer and make more sense, even if slightly more verbose:<br>&gt;&gt; <br>&gt;&gt;    func fill(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;    func stroke(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;    func encode(coder: Coder)<br>&gt; <br>&gt; Another random interesting example I encountered:<br>&gt; <br>&gt; -  func addArcWithCenter(center: CGPoint, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: Bool)<br>&gt; +  func addArc(center center: CGPoint, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: Bool)<br>&gt; <br>&gt; which seems to match the idea behind Erica’s &quot;semantic relationship between the parameters is stronger than their relation to the operation” (or Paul Cantrell’s similar notion of &quot;the direct object is several args taken together”, which feels more in line with the way the API guidelines are written).<br>&gt; <br>&gt; There’s also this:<br>&gt; <br>&gt; -  func tracksWithMediaType(mediaType: String) -&gt; [AVMovieTrack]<br>&gt; +  func tracks(mediaType mediaType: String) -&gt; [AVMovieTrack]<br>&gt; <br>&gt; -  func tracksWithMediaCharacteristic(mediaCharacteristic: String) -&gt;<br>&gt; +  func tracks(mediaCharacteristic mediaCharacteristic: String) -&gt; [AVMovieTrack]<br>&gt; <br>&gt; which feels reminiscent of Paul’s “resource” example:<br>&gt; <br>&gt;     service.resource(&quot;/foo&quot;)<br>&gt;     service.resource(absoluteURL: &quot;http://bar.com &lt;http://bar.com/&gt;&quot;)<br>&gt;     service.resource(absoluteURL: NSURL(string: &quot;http://bar.com &lt;http://bar.com/&gt;&quot;))<br>&gt; <br>&gt; where (I think) the argument is that the various methods should all have the same base name because they’re all returning “tracks” or a “resource”, respectively.<br>&gt; <br>&gt; There is a ton of data in that patch. I’d be interested to hear whether the resulting Cocoa APIs feel better in Swift—are they following the evolving set of guidelines for first argument labels that are under discussion, and are the resulting APIs clearer/more Swifty? What specific APIs work well and where does this “with-as-separator” heuristic break down?<br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/640e507d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 27, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jan 27, 2016, at 8:09 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; Doug,<br>&gt; <br>&gt; I think this change looks great!  I don’t have time to look through the full patch but did look through quite a bit.  It adds clarity in the vast majority of cases I looked at.  <br>&gt; <br>&gt; It seems like with-as-separator is a good heuristic for determining when the first parameter is not essential to a good name for the fundamental operation.  I agree with the comments earlier on that in these cases a label for the first parameter is the best approach.<br>&gt; <br>&gt; I also really like that this groups methods with the same fundamental operation into overload families where they previously had independent names.  This is a big win IMO.<br>&gt; <br>&gt; There is a first-parameter-is-an-ID pattern I noticed after this change.  I show a few examples here, but there are a lot more:<br>&gt; <br>&gt; -  func trackWithTrackID(trackID: CMPersistentTrackID) -&gt; AVAssetTrack?<br>&gt; +  func track(trackID trackID: CMPersistentTrackID) -&gt; AVAssetTrack?<br>&gt; <br>&gt; -  func trackWithTrackID(trackID: CMPersistentTrackID) -&gt; AVFragmentedAssetTrack?<br>&gt; +  func track(trackID trackID: CMPersistentTrackID) -&gt; AVFragmentedAssetTrack?<br>&gt; <br>&gt; -  func trackWithTrackID(trackID: CMPersistentTrackID) -&gt; AVCompositionTrack?<br>&gt; +  func track(trackID trackID: CMPersistentTrackID) -&gt; AVCompositionTrack?<br>&gt; <br>&gt; -  func discoverUserInfoWithUserRecordID(userRecordID: CKRecordID, completionHandler: (CKDiscoveredUserInfo?, Error?) -&gt; Void)<br>&gt; <br>&gt; +  func discoverUserInfo(userRecordID userRecordID: CKRecordID, completionHandler: (CKDiscoveredUserInfo?, Error?) -&gt; Void)<br>&gt; <br>&gt; The first argument label `trackID` seems like it repeats type information without adding clarity.  I think it would be better to just use `id` here.  It seems like a candidate for heuristics as well.  For example, if the type name ends in ID and the label is a suffix of the type name we could just use `id`.  This is a somewhat specific pattern, but IDs are common enough that it might make sense.<br></p><p>It affects 33 APIs; see attached patch.<br></p><p>&gt; Interestingly, in at least one case the `WithID` was the original name of the method so we did receive a simple `id` label:<br>&gt; <br>&gt; -  func parameterWithID(paramID: AudioUnitParameterID, scope: AudioUnitScope, element: AudioUnitElement) -&gt; AUParameter?<br>&gt; +  func parameter(id paramID: AudioUnitParameterID, scope: AudioUnitScope, element: AudioUnitElement) -&gt; AUParameter?<br></p><p>What’s happening here is that we see that “ID” in “WithID” is redundant, but we don’t want to provide a first argument label of “with”, so we grab whatever followed “with”.<br></p><p>&gt; In another case, the method has a naked `With` at the end.  Somehow `id` was used in that scenario despite the parameter name being `objectID` and the type being `NSManagedObjectID`, which aligns with my suggested naming:<br>&gt; <br>&gt; -  func newValuesForObjectWith(objectID: NSManagedObjectID, withContext context: NSManagedObjectContext) throws -&gt; NSIncrementalStoreNode<br>&gt; +  func newValuesForObject(id objectID: NSManagedObjectID, withContext context: NSManagedObjectContext) throws -&gt; NSIncrementalStoreNode<br></p><p>This was originally newValuesForObjectWithID; again, we trimmed ID both before and after, and you’re seeing us keeping “id” because it’s better than keeping “with”.<br></p><p>&gt; <br>&gt; A case related to that used `iDs` for array arguments:  <br>&gt; <br>&gt; -  func managedObjectContextDidRegisterObjectsWithIDs(objectIDs: [NSManagedObjectID])<br>&gt; -  func managedObjectContextDidUnregisterObjectsWithIDs(objectIDs: [NSManagedObjectID])<br>&gt; +  func managedObjectContextDidRegisterObjects(iDs objectIDs: [NSManagedObjectID])<br>&gt; +  func managedObjectContextDidUnregisterObjects(iDs objectIDs: [NSManagedObjectID])<br>&gt; <br>&gt; I would prefer `ids` here.  This seems like a pattern that would be a problem for any all-caps plural acronym or initialism so it might be good to add a heuristic for this as well.<br></p><p>Ah, it looks like I&#39;m handling lowercasing of plural initialisms badly. That’s a problem independent of first argument labels; thanks!<br></p><p>&gt; <br>&gt; <br>&gt; Here’s another interesting change:<br>&gt; <br>&gt; -  func unionWith(s2: CIFilterShape) -&gt; CIFilterShape<br>&gt; -  func unionWith(r: CGRect) -&gt; CIFilterShape<br>&gt; -  func intersectWith(s2: CIFilterShape) -&gt; CIFilterShape<br>&gt; -  func intersectWith(r: CGRect) -&gt; CIFilterShape<br>&gt; +  func union(with s2: CIFilterShape) -&gt; CIFilterShape<br>&gt; +  func union(rect r: CGRect) -&gt; CIFilterShape<br>&gt; +  func intersect(with s2: CIFilterShape) -&gt; CIFilterShape<br>&gt; +  func intersect(rect r: CGRect) -&gt; CIFilterShape<br>&gt; <br>&gt; Why do the CGRect arguments receive a type-derived label but the CIFilterShape arguments just receive `with`?  Shouldn’t these follow the same pattern?<br></p><p>The Objective-C methods are actually named unionWith: and unionWithRect:. That first name is not following Cocoa conventions.<br></p><p>	- Doug<br></p><p><br>&gt; <br>&gt;&gt; On Jan 27, 2016, at 1:50 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 25, 2016, at 6:55 AM, Radosław Pietruszewski &lt;radexpl at gmail.com &lt;mailto:radexpl at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m overwhelmingly *for* this proposal. I think removing needless verbosity and keeping the signal-to-noise ratio high is one of the most immediately appealing aspects of Swift, as well as a great general improvement to the programming experience.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And so unswiftified (yes, it’s a word now) APIs from Objective-C stick out like a sore thumb. Not only are they harder to read and write, they visually overwhelm the less verbose, information-dense Swift-first code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Just like previous 1.0—2.0 attempts at bridging the gap (with NSError params being translated to Swift errors, factory methods translated to initializers, etc.), automating this will be an error-prone process, and almost bound to be a bit annoying at first, before all the glitches and poor translations are smoothed out. And yet I feel like just like the previous automated translations were overwhelmingly a great thing, so will the result of this proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * * *<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    Add First Argument Labels<br>&gt;&gt;&gt;&gt;    <br>&gt;&gt;&gt;&gt;    - func enumerateObjectsWith(_: NSEnumerationOptions = [], using: (AnyObject, UnsafeMutablePointer) -&gt; Void)<br>&gt;&gt;&gt;&gt;    + func enumerateObjects(options _: NSEnumerationOptions = [], using: (AnyObject, UnsafeMutablePointer) -&gt; Void)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Good! The Guidelines recommend an explicit first parameter label for arguments with a default value, but this is a good change also for another reason, a use case not included in the Guidelines (I have more to say about this in the SE-0023 thread):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; “Options” is the description of the parameter, not the method itself. Even if (for whatever reason!) `options` didn’t have a default value and the word “Options” wasn’t omitted in the translation,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    enumerateObjects(options: …)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; would be clearer than<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    enumerateObjectsWithOptions(…)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It’s not even about the extra word, about the four useless characters, it’s simply that “WithOptions” doesn’t describe the operation at all. It’s a word that conveys no information (“with”), and “options”, which describes the first parameter. In Objective-C, there’s no such thing as parameter labels, it’s all one name, so “With” is used as a separator. But in Swift, making the first parameter’s label explicit just makes more sense.<br>&gt;&gt; <br>&gt;&gt; That’s an interesting thought! If “with” is truly used as a convention for separating the description of the operation from the description of the first parameter, that’s something that can be codified in the Clang importer. I was curious, so I hacked it up. Here’s a diff of the Cocoa APIs that shows what things would look like if we treated “with” as a separator:<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-3-api-guidelines-review/pull/5/files &lt;https://github.com/apple/swift-3-api-guidelines-review/pull/5/files&gt;<br>&gt;&gt; <br>&gt;&gt; It’s a diff against SE-0005, and it introduces a significant number of first argument labels. Indeed, you’ll need to grab the patch to see them all:<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-3-api-guidelines-review/pull/5.patch &lt;https://github.com/apple/swift-3-api-guidelines-review/pull/5.patch&gt;<br>&gt;&gt; <br>&gt;&gt; A brief survey shows that some cases seem to be lining up with the guideline proposals that have been under discussion. For example, the patch includes:<br>&gt;&gt; <br>&gt;&gt; -  func fillWith(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt; -  func strokeWith(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt; +  func fill(blendMode blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt; +  func stroke(blendMode blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt; <br>&gt;&gt; -  func encodeWith(aCoder: Coder)<br>&gt;&gt; +  func encode(coder aCoder: Coder)<br>&gt;&gt; <br>&gt;&gt; which you might recognize, because it’s the example you used:<br>&gt;&gt; <br>&gt;&gt;&gt; And with that in mind, I object to these translations:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    func fillWith(_: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;    func strokeWith(_: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;    func encodeWith(_: Coder)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Even though these don’t have default values, I believe this version to be clearer and make more sense, even if slightly more verbose:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    func fill(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;    func stroke(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;    func encode(coder: Coder)<br>&gt;&gt; <br>&gt;&gt; Another random interesting example I encountered:<br>&gt;&gt; <br>&gt;&gt; -  func addArcWithCenter(center: CGPoint, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: Bool)<br>&gt;&gt; +  func addArc(center center: CGPoint, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: Bool)<br>&gt;&gt; <br>&gt;&gt; which seems to match the idea behind Erica’s &quot;semantic relationship between the parameters is stronger than their relation to the operation” (or Paul Cantrell’s similar notion of &quot;the direct object is several args taken together”, which feels more in line with the way the API guidelines are written).<br>&gt;&gt; <br>&gt;&gt; There’s also this:<br>&gt;&gt; <br>&gt;&gt; -  func tracksWithMediaType(mediaType: String) -&gt; [AVMovieTrack]<br>&gt;&gt; +  func tracks(mediaType mediaType: String) -&gt; [AVMovieTrack]<br>&gt;&gt; <br>&gt;&gt; -  func tracksWithMediaCharacteristic(mediaCharacteristic: String) -&gt;<br>&gt;&gt; +  func tracks(mediaCharacteristic mediaCharacteristic: String) -&gt; [AVMovieTrack]<br>&gt;&gt; <br>&gt;&gt; which feels reminiscent of Paul’s “resource” example:<br>&gt;&gt; <br>&gt;&gt;     service.resource(&quot;/foo&quot;)<br>&gt;&gt;     service.resource(absoluteURL: &quot;http://bar.com &lt;http://bar.com/&gt;&quot;)<br>&gt;&gt;     service.resource(absoluteURL: NSURL(string: &quot;http://bar.com &lt;http://bar.com/&gt;&quot;))<br>&gt;&gt; <br>&gt;&gt; where (I think) the argument is that the various methods should all have the same base name because they’re all returning “tracks” or a “resource”, respectively.<br>&gt;&gt; <br>&gt;&gt; There is a ton of data in that patch. I’d be interested to hear whether the resulting Cocoa APIs feel better in Swift—are they following the evolving set of guidelines for first argument labels that are under discussion, and are the resulting APIs clearer/more Swifty? What specific APIs work well and where does this “with-as-separator” heuristic break down?<br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/2cb0f4b4/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: universal-id.patch<br>Type: application/octet-stream<br>Size: 12851 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/2cb0f4b4/attachment.obj&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/2cb0f4b4/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 27, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jan 27, 2016, at 5:20 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 27, 2016, at 8:09 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Doug,<br>&gt;&gt; <br>&gt;&gt; I think this change looks great!  I don’t have time to look through the full patch but did look through quite a bit.  It adds clarity in the vast majority of cases I looked at.  <br>&gt;&gt; <br>&gt;&gt; It seems like with-as-separator is a good heuristic for determining when the first parameter is not essential to a good name for the fundamental operation.  I agree with the comments earlier on that in these cases a label for the first parameter is the best approach.<br>&gt;&gt; <br>&gt;&gt; I also really like that this groups methods with the same fundamental operation into overload families where they previously had independent names.  This is a big win IMO.<br>&gt;&gt; <br>&gt;&gt; There is a first-parameter-is-an-ID pattern I noticed after this change.  I show a few examples here, but there are a lot more:<br>&gt;&gt; <br>&gt;&gt; -  func trackWithTrackID(trackID: CMPersistentTrackID) -&gt; AVAssetTrack?<br>&gt;&gt; +  func track(trackID trackID: CMPersistentTrackID) -&gt; AVAssetTrack?<br>&gt;&gt; <br>&gt;&gt; -  func trackWithTrackID(trackID: CMPersistentTrackID) -&gt; AVFragmentedAssetTrack?<br>&gt;&gt; +  func track(trackID trackID: CMPersistentTrackID) -&gt; AVFragmentedAssetTrack?<br>&gt;&gt; <br>&gt;&gt; -  func trackWithTrackID(trackID: CMPersistentTrackID) -&gt; AVCompositionTrack?<br>&gt;&gt; +  func track(trackID trackID: CMPersistentTrackID) -&gt; AVCompositionTrack?<br>&gt;&gt; <br>&gt;&gt; -  func discoverUserInfoWithUserRecordID(userRecordID: CKRecordID, completionHandler: (CKDiscoveredUserInfo?, Error?) -&gt; Void)<br>&gt;&gt; <br>&gt;&gt; +  func discoverUserInfo(userRecordID userRecordID: CKRecordID, completionHandler: (CKDiscoveredUserInfo?, Error?) -&gt; Void)<br>&gt;&gt; <br>&gt;&gt; The first argument label `trackID` seems like it repeats type information without adding clarity.  I think it would be better to just use `id` here.  It seems like a candidate for heuristics as well.  For example, if the type name ends in ID and the label is a suffix of the type name we could just use `id`.  This is a somewhat specific pattern, but IDs are common enough that it might make sense.<br>&gt; <br>&gt; It affects 33 APIs; see attached patch.<br></p><p>The patch looks good!<br></p><p>&gt; <br>&gt;&gt; Interestingly, in at least one case the `WithID` was the original name of the method so we did receive a simple `id` label:<br>&gt;&gt; <br>&gt;&gt; -  func parameterWithID(paramID: AudioUnitParameterID, scope: AudioUnitScope, element: AudioUnitElement) -&gt; AUParameter?<br>&gt;&gt; +  func parameter(id paramID: AudioUnitParameterID, scope: AudioUnitScope, element: AudioUnitElement) -&gt; AUParameter?<br>&gt; <br>&gt; What’s happening here is that we see that “ID” in “WithID” is redundant, but we don’t want to provide a first argument label of “with”, so we grab whatever followed “with”.<br></p><p>Yep, I was just noting that we already ended up with `id` in some cases.<br></p><p>&gt; <br>&gt;&gt; In another case, the method has a naked `With` at the end.  Somehow `id` was used in that scenario despite the parameter name being `objectID` and the type being `NSManagedObjectID`, which aligns with my suggested naming:<br>&gt;&gt; <br>&gt;&gt; -  func newValuesForObjectWith(objectID: NSManagedObjectID, withContext context: NSManagedObjectContext) throws -&gt; NSIncrementalStoreNode<br>&gt;&gt; +  func newValuesForObject(id objectID: NSManagedObjectID, withContext context: NSManagedObjectContext) throws -&gt; NSIncrementalStoreNode<br>&gt; <br>&gt; This was originally newValuesForObjectWithID; again, we trimmed ID both before and after, and you’re seeing us keeping “id” because it’s better than keeping “with”.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; A case related to that used `iDs` for array arguments:  <br>&gt;&gt; <br>&gt;&gt; -  func managedObjectContextDidRegisterObjectsWithIDs(objectIDs: [NSManagedObjectID])<br>&gt;&gt; -  func managedObjectContextDidUnregisterObjectsWithIDs(objectIDs: [NSManagedObjectID])<br>&gt;&gt; +  func managedObjectContextDidRegisterObjects(iDs objectIDs: [NSManagedObjectID])<br>&gt;&gt; +  func managedObjectContextDidUnregisterObjects(iDs objectIDs: [NSManagedObjectID])<br>&gt;&gt; <br>&gt;&gt; I would prefer `ids` here.  This seems like a pattern that would be a problem for any all-caps plural acronym or initialism so it might be good to add a heuristic for this as well.<br>&gt; <br>&gt; Ah, it looks like I&#39;m handling lowercasing of plural initialisms badly. That’s a problem independent of first argument labels; thanks!<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Here’s another interesting change:<br>&gt;&gt; <br>&gt;&gt; -  func unionWith(s2: CIFilterShape) -&gt; CIFilterShape<br>&gt;&gt; -  func unionWith(r: CGRect) -&gt; CIFilterShape<br>&gt;&gt; -  func intersectWith(s2: CIFilterShape) -&gt; CIFilterShape<br>&gt;&gt; -  func intersectWith(r: CGRect) -&gt; CIFilterShape<br>&gt;&gt; +  func union(with s2: CIFilterShape) -&gt; CIFilterShape<br>&gt;&gt; +  func union(rect r: CGRect) -&gt; CIFilterShape<br>&gt;&gt; +  func intersect(with s2: CIFilterShape) -&gt; CIFilterShape<br>&gt;&gt; +  func intersect(rect r: CGRect) -&gt; CIFilterShape<br>&gt;&gt; <br>&gt;&gt; Why do the CGRect arguments receive a type-derived label but the CIFilterShape arguments just receive `with`?  Shouldn’t these follow the same pattern?<br>&gt; <br>&gt; The Objective-C methods are actually named unionWith: and unionWithRect:. That first name is not following Cocoa conventions.<br></p><p>Ok, that makes sense then.  I didn’t think to look at the original Objective-C names.  I wonder if it might be better to make these consistent though.  Either discard the name if it matches the type:<br></p><p>func intersect(with r: CGRect) -&gt; CIFilterShape<br></p><p>Or use the type information to create a name rather than use “with”:<br></p><p>func intersect(filterShape s2: CIFilterShape) -&gt; CIFilterShape<br></p><p>What do you think?<br></p><p>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; &lt;universal-id.patch&gt;<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 27, 2016, at 1:50 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 25, 2016, at 6:55 AM, Radosław Pietruszewski &lt;radexpl at gmail.com &lt;mailto:radexpl at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m overwhelmingly *for* this proposal. I think removing needless verbosity and keeping the signal-to-noise ratio high is one of the most immediately appealing aspects of Swift, as well as a great general improvement to the programming experience.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And so unswiftified (yes, it’s a word now) APIs from Objective-C stick out like a sore thumb. Not only are they harder to read and write, they visually overwhelm the less verbose, information-dense Swift-first code.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Just like previous 1.0—2.0 attempts at bridging the gap (with NSError params being translated to Swift errors, factory methods translated to initializers, etc.), automating this will be an error-prone process, and almost bound to be a bit annoying at first, before all the glitches and poor translations are smoothed out. And yet I feel like just like the previous automated translations were overwhelmingly a great thing, so will the result of this proposal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * * *<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;    Add First Argument Labels<br>&gt;&gt;&gt;&gt;&gt;    <br>&gt;&gt;&gt;&gt;&gt;    - func enumerateObjectsWith(_: NSEnumerationOptions = [], using: (AnyObject, UnsafeMutablePointer) -&gt; Void)<br>&gt;&gt;&gt;&gt;&gt;    + func enumerateObjects(options _: NSEnumerationOptions = [], using: (AnyObject, UnsafeMutablePointer) -&gt; Void)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Good! The Guidelines recommend an explicit first parameter label for arguments with a default value, but this is a good change also for another reason, a use case not included in the Guidelines (I have more to say about this in the SE-0023 thread):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; “Options” is the description of the parameter, not the method itself. Even if (for whatever reason!) `options` didn’t have a default value and the word “Options” wasn’t omitted in the translation,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    enumerateObjects(options: …)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; would be clearer than<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    enumerateObjectsWithOptions(…)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It’s not even about the extra word, about the four useless characters, it’s simply that “WithOptions” doesn’t describe the operation at all. It’s a word that conveys no information (“with”), and “options”, which describes the first parameter. In Objective-C, there’s no such thing as parameter labels, it’s all one name, so “With” is used as a separator. But in Swift, making the first parameter’s label explicit just makes more sense.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That’s an interesting thought! If “with” is truly used as a convention for separating the description of the operation from the description of the first parameter, that’s something that can be codified in the Clang importer. I was curious, so I hacked it up. Here’s a diff of the Cocoa APIs that shows what things would look like if we treated “with” as a separator:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	https://github.com/apple/swift-3-api-guidelines-review/pull/5/files &lt;https://github.com/apple/swift-3-api-guidelines-review/pull/5/files&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It’s a diff against SE-0005, and it introduces a significant number of first argument labels. Indeed, you’ll need to grab the patch to see them all:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	https://github.com/apple/swift-3-api-guidelines-review/pull/5.patch &lt;https://github.com/apple/swift-3-api-guidelines-review/pull/5.patch&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A brief survey shows that some cases seem to be lining up with the guideline proposals that have been under discussion. For example, the patch includes:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  func fillWith(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt; -  func strokeWith(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt; +  func fill(blendMode blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt; +  func stroke(blendMode blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  func encodeWith(aCoder: Coder)<br>&gt;&gt;&gt; +  func encode(coder aCoder: Coder)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; which you might recognize, because it’s the example you used:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And with that in mind, I object to these translations:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    func fillWith(_: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt;    func strokeWith(_: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt;    func encodeWith(_: Coder)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Even though these don’t have default values, I believe this version to be clearer and make more sense, even if slightly more verbose:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    func fill(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt;    func stroke(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt;    func encode(coder: Coder)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another random interesting example I encountered:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  func addArcWithCenter(center: CGPoint, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: Bool)<br>&gt;&gt;&gt; +  func addArc(center center: CGPoint, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: Bool)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; which seems to match the idea behind Erica’s &quot;semantic relationship between the parameters is stronger than their relation to the operation” (or Paul Cantrell’s similar notion of &quot;the direct object is several args taken together”, which feels more in line with the way the API guidelines are written).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There’s also this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  func tracksWithMediaType(mediaType: String) -&gt; [AVMovieTrack]<br>&gt;&gt;&gt; +  func tracks(mediaType mediaType: String) -&gt; [AVMovieTrack]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  func tracksWithMediaCharacteristic(mediaCharacteristic: String) -&gt;<br>&gt;&gt;&gt; +  func tracks(mediaCharacteristic mediaCharacteristic: String) -&gt; [AVMovieTrack]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; which feels reminiscent of Paul’s “resource” example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     service.resource(&quot;/foo&quot;)<br>&gt;&gt;&gt;     service.resource(absoluteURL: &quot;http://bar.com &lt;http://bar.com/&gt;&quot;)<br>&gt;&gt;&gt;     service.resource(absoluteURL: NSURL(string: &quot;http://bar.com &lt;http://bar.com/&gt;&quot;))<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; where (I think) the argument is that the various methods should all have the same base name because they’re all returning “tracks” or a “resource”, respectively.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There is a ton of data in that patch. I’d be interested to hear whether the resulting Cocoa APIs feel better in Swift—are they following the evolving set of guidelines for first argument labels that are under discussion, and are the resulting APIs clearer/more Swifty? What specific APIs work well and where does this “with-as-separator” heuristic break down?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/ba46d3ae/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 27, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jan 27, 2016, at 3:41 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 27, 2016, at 5:20 PM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 27, 2016, at 8:09 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Doug,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think this change looks great!  I don’t have time to look through the full patch but did look through quite a bit.  It adds clarity in the vast majority of cases I looked at.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It seems like with-as-separator is a good heuristic for determining when the first parameter is not essential to a good name for the fundamental operation.  I agree with the comments earlier on that in these cases a label for the first parameter is the best approach.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I also really like that this groups methods with the same fundamental operation into overload families where they previously had independent names.  This is a big win IMO.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There is a first-parameter-is-an-ID pattern I noticed after this change.  I show a few examples here, but there are a lot more:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  func trackWithTrackID(trackID: CMPersistentTrackID) -&gt; AVAssetTrack?<br>&gt;&gt;&gt; +  func track(trackID trackID: CMPersistentTrackID) -&gt; AVAssetTrack?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  func trackWithTrackID(trackID: CMPersistentTrackID) -&gt; AVFragmentedAssetTrack?<br>&gt;&gt;&gt; +  func track(trackID trackID: CMPersistentTrackID) -&gt; AVFragmentedAssetTrack?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  func trackWithTrackID(trackID: CMPersistentTrackID) -&gt; AVCompositionTrack?<br>&gt;&gt;&gt; +  func track(trackID trackID: CMPersistentTrackID) -&gt; AVCompositionTrack?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  func discoverUserInfoWithUserRecordID(userRecordID: CKRecordID, completionHandler: (CKDiscoveredUserInfo?, Error?) -&gt; Void)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +  func discoverUserInfo(userRecordID userRecordID: CKRecordID, completionHandler: (CKDiscoveredUserInfo?, Error?) -&gt; Void)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The first argument label `trackID` seems like it repeats type information without adding clarity.  I think it would be better to just use `id` here.  It seems like a candidate for heuristics as well.  For example, if the type name ends in ID and the label is a suffix of the type name we could just use `id`.  This is a somewhat specific pattern, but IDs are common enough that it might make sense.<br>&gt;&gt; <br>&gt;&gt; It affects 33 APIs; see attached patch.<br>&gt; <br>&gt; The patch looks good!<br></p><p>Alright. I’d like to hear people’s opinions on the more drastic id/identifier/name changes DaveA was talking about.<br></p><p>&gt;&gt;&gt; Here’s another interesting change:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  func unionWith(s2: CIFilterShape) -&gt; CIFilterShape<br>&gt;&gt;&gt; -  func unionWith(r: CGRect) -&gt; CIFilterShape<br>&gt;&gt;&gt; -  func intersectWith(s2: CIFilterShape) -&gt; CIFilterShape<br>&gt;&gt;&gt; -  func intersectWith(r: CGRect) -&gt; CIFilterShape<br>&gt;&gt;&gt; +  func union(with s2: CIFilterShape) -&gt; CIFilterShape<br>&gt;&gt;&gt; +  func union(rect r: CGRect) -&gt; CIFilterShape<br>&gt;&gt;&gt; +  func intersect(with s2: CIFilterShape) -&gt; CIFilterShape<br>&gt;&gt;&gt; +  func intersect(rect r: CGRect) -&gt; CIFilterShape<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Why do the CGRect arguments receive a type-derived label but the CIFilterShape arguments just receive `with`?  Shouldn’t these follow the same pattern?<br>&gt;&gt; <br>&gt;&gt; The Objective-C methods are actually named unionWith: and unionWithRect:. That first name is not following Cocoa conventions.<br>&gt; <br>&gt; Ok, that makes sense then.  I didn’t think to look at the original Objective-C names.  I wonder if it might be better to make these consistent though.  Either discard the name if it matches the type:<br>&gt; <br>&gt; func intersect(with r: CGRect) -&gt; CIFilterShape<br></p><p>Personally, I think it’s better not to have any argument label here, but I don’t know how to mechanize that decision.<br></p><p>&gt; Or use the type information to create a name rather than use “with”:<br>&gt; <br>&gt; func intersect(filterShape s2: CIFilterShape) -&gt; CIFilterShape<br>&gt; <br>&gt; What do you think?<br></p><p>I don’t want to go here, because I have no idea how to automatically pick the right number of words from the type name. Also, grepping my Big List Of Selectors, there are only four cases where we have a selector whose first piece ends with “With”:<br></p><p>intersectWith:<br>scriptingBeginsWith:<br>scriptingEndsWith:<br>unionWith:<br></p><p>which drastically reduces my motivation to handle this via the Clang importer vs. just deciding the right names.<br></p><p>	- Doug<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt; &lt;universal-id.patch&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 27, 2016, at 1:50 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 25, 2016, at 6:55 AM, Radosław Pietruszewski &lt;radexpl at gmail.com &lt;mailto:radexpl at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’m overwhelmingly *for* this proposal. I think removing needless verbosity and keeping the signal-to-noise ratio high is one of the most immediately appealing aspects of Swift, as well as a great general improvement to the programming experience.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; And so unswiftified (yes, it’s a word now) APIs from Objective-C stick out like a sore thumb. Not only are they harder to read and write, they visually overwhelm the less verbose, information-dense Swift-first code.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Just like previous 1.0—2.0 attempts at bridging the gap (with NSError params being translated to Swift errors, factory methods translated to initializers, etc.), automating this will be an error-prone process, and almost bound to be a bit annoying at first, before all the glitches and poor translations are smoothed out. And yet I feel like just like the previous automated translations were overwhelmingly a great thing, so will the result of this proposal.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; * * *<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;    Add First Argument Labels<br>&gt;&gt;&gt;&gt;&gt;&gt;    <br>&gt;&gt;&gt;&gt;&gt;&gt;    - func enumerateObjectsWith(_: NSEnumerationOptions = [], using: (AnyObject, UnsafeMutablePointer) -&gt; Void)<br>&gt;&gt;&gt;&gt;&gt;&gt;    + func enumerateObjects(options _: NSEnumerationOptions = [], using: (AnyObject, UnsafeMutablePointer) -&gt; Void)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Good! The Guidelines recommend an explicit first parameter label for arguments with a default value, but this is a good change also for another reason, a use case not included in the Guidelines (I have more to say about this in the SE-0023 thread):<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; “Options” is the description of the parameter, not the method itself. Even if (for whatever reason!) `options` didn’t have a default value and the word “Options” wasn’t omitted in the translation,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;    enumerateObjects(options: …)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; would be clearer than<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;    enumerateObjectsWithOptions(…)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It’s not even about the extra word, about the four useless characters, it’s simply that “WithOptions” doesn’t describe the operation at all. It’s a word that conveys no information (“with”), and “options”, which describes the first parameter. In Objective-C, there’s no such thing as parameter labels, it’s all one name, so “With” is used as a separator. But in Swift, making the first parameter’s label explicit just makes more sense.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That’s an interesting thought! If “with” is truly used as a convention for separating the description of the operation from the description of the first parameter, that’s something that can be codified in the Clang importer. I was curious, so I hacked it up. Here’s a diff of the Cocoa APIs that shows what things would look like if we treated “with” as a separator:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	https://github.com/apple/swift-3-api-guidelines-review/pull/5/files &lt;https://github.com/apple/swift-3-api-guidelines-review/pull/5/files&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It’s a diff against SE-0005, and it introduces a significant number of first argument labels. Indeed, you’ll need to grab the patch to see them all:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	https://github.com/apple/swift-3-api-guidelines-review/pull/5.patch &lt;https://github.com/apple/swift-3-api-guidelines-review/pull/5.patch&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A brief survey shows that some cases seem to be lining up with the guideline proposals that have been under discussion. For example, the patch includes:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  func fillWith(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt; -  func strokeWith(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt; +  func fill(blendMode blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt; +  func stroke(blendMode blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  func encodeWith(aCoder: Coder)<br>&gt;&gt;&gt;&gt; +  func encode(coder aCoder: Coder)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; which you might recognize, because it’s the example you used:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; And with that in mind, I object to these translations:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;    func fillWith(_: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt;&gt;    func strokeWith(_: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt;&gt;    func encodeWith(_: Coder)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Even though these don’t have default values, I believe this version to be clearer and make more sense, even if slightly more verbose:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;    func fill(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt;&gt;    func stroke(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt;&gt;    func encode(coder: Coder)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Another random interesting example I encountered:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  func addArcWithCenter(center: CGPoint, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: Bool)<br>&gt;&gt;&gt;&gt; +  func addArc(center center: CGPoint, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: Bool)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; which seems to match the idea behind Erica’s &quot;semantic relationship between the parameters is stronger than their relation to the operation” (or Paul Cantrell’s similar notion of &quot;the direct object is several args taken together”, which feels more in line with the way the API guidelines are written).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There’s also this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  func tracksWithMediaType(mediaType: String) -&gt; [AVMovieTrack]<br>&gt;&gt;&gt;&gt; +  func tracks(mediaType mediaType: String) -&gt; [AVMovieTrack]<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  func tracksWithMediaCharacteristic(mediaCharacteristic: String) -&gt;<br>&gt;&gt;&gt;&gt; +  func tracks(mediaCharacteristic mediaCharacteristic: String) -&gt; [AVMovieTrack]<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; which feels reminiscent of Paul’s “resource” example:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     service.resource(&quot;/foo&quot;)<br>&gt;&gt;&gt;&gt;     service.resource(absoluteURL: &quot;http://bar.com &lt;http://bar.com/&gt;&quot;)<br>&gt;&gt;&gt;&gt;     service.resource(absoluteURL: NSURL(string: &quot;http://bar.com &lt;http://bar.com/&gt;&quot;))<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; where (I think) the argument is that the various methods should all have the same base name because they’re all returning “tracks” or a “resource”, respectively.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There is a ton of data in that patch. I’d be interested to hear whether the resulting Cocoa APIs feel better in Swift—are they following the evolving set of guidelines for first argument labels that are under discussion, and are the resulting APIs clearer/more Swifty? What specific APIs work well and where does this “with-as-separator” heuristic break down?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/341a1835/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bdd257c9369fb68e1d06923d10ff789e?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Ben Rimmington</string> &lt;me at benrimmington.com&gt;<p>January 27, 2016 at 07:00:00pm</p></header><div class="content"><p>Doug,<br></p><p>&gt; On 27 Jan 2016, at 07:50, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Another random interesting example I encountered:<br>&gt; <br>&gt; -  func addArcWithCenter(center: CGPoint, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: Bool)<br>&gt; +  func addArc(center center: CGPoint, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: Bool)<br>&gt; <br>&gt; which seems to match the idea behind Erica’s &quot;semantic relationship between the parameters is stronger than their relation to the operation” (or Paul Cantrell’s similar notion of &quot;the direct object is several args taken together”, which feels more in line with the way the API guidelines are written).<br></p><p>The related AppKit.NSBezierPath method contains two possible &quot;With&quot; separators:<br></p><p>&gt; - (void)appendBezierPathWithArcWithCenter:(NSPoint)center<br>&gt;                                    radius:(CGFloat)radius<br>&gt;                                startAngle:(CGFloat)startAngle<br>&gt;                                  endAngle:(CGFloat)endAngle<br>&gt;                                 clockwise:(BOOL)clockwise<br></p><p>Your patch replaces the second &quot;With&quot; separator, but the alternative might be better:<br></p><p>&gt; // YOUR PATCH:<br>&gt; func appendWithArc(center center: Point, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: Bool)<br>&gt; <br>&gt; // THE ALTERNATIVE:<br>&gt; func append(arcWithCenter center: Point, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: Bool)<br></p><p>-- Ben<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 27, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jan 27, 2016, at 1:22 PM, Ben Rimmington via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Doug,<br>&gt; <br>&gt;&gt; On 27 Jan 2016, at 07:50, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Another random interesting example I encountered:<br>&gt;&gt; <br>&gt;&gt; -  func addArcWithCenter(center: CGPoint, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: Bool)<br>&gt;&gt; +  func addArc(center center: CGPoint, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: Bool)<br>&gt;&gt; <br>&gt;&gt; which seems to match the idea behind Erica’s &quot;semantic relationship between the parameters is stronger than their relation to the operation” (or Paul Cantrell’s similar notion of &quot;the direct object is several args taken together”, which feels more in line with the way the API guidelines are written).<br>&gt; <br>&gt; The related AppKit.NSBezierPath method contains two possible &quot;With&quot; separators:<br>&gt; <br>&gt;&gt; - (void)appendBezierPathWithArcWithCenter:(NSPoint)center<br>&gt;&gt;                                   radius:(CGFloat)radius<br>&gt;&gt;                               startAngle:(CGFloat)startAngle<br>&gt;&gt;                                 endAngle:(CGFloat)endAngle<br>&gt;&gt;                                clockwise:(BOOL)clockwise<br>&gt; <br>&gt; Your patch replaces the second &quot;With&quot; separator, but the alternative might be better:<br>&gt; <br>&gt;&gt; // YOUR PATCH:<br>&gt;&gt; func appendWithArc(center center: Point, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: Bool)<br>&gt;&gt; <br>&gt;&gt; // THE ALTERNATIVE:<br>&gt;&gt; func append(arcWithCenter center: Point, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: Bool)<br></p><p>This is better IMO:<br></p><p>func appendArc(center center: Point, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: Bool)<br></p><p>However, I think this is an example of where explicit annotation is probably necessary to get the best result.  A heuristic can’t always do the right thing and I think this example is past the point of diminishing returns for heuristics.<br></p><p>-Matthew<br></p><p>&gt; <br>&gt; -- Ben<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bdd257c9369fb68e1d06923d10ff789e?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Ben Rimmington</string> &lt;me at benrimmington.com&gt;<p>January 27, 2016 at 07:00:00pm</p></header><div class="content"><p>Matthew,<br></p><p>&gt; On 27 Jan 2016, at 19:26, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; This is better IMO:<br>&gt; <br>&gt; func appendArc(center center: Point, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: Bool)<br>&gt; <br>&gt; However, I think this is an example of where explicit annotation is probably necessary to get the best result.  A heuristic can’t always do the right thing and I think this example is past the point of diminishing returns for heuristics.<br></p><p>The &quot;append&quot; methods of the AppKit.NSBezierPath patch are:<br></p><p>&gt;    func append(path: NSBezierPath)<br>&gt; +  func append(rect rect: Rect)<br>&gt; +  func append(points points: PointArray, count: Int)<br>&gt;    func appendWithOvalIn(rect: Rect)<br>&gt; +  func appendWithArc(center center: Point, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: Bool)<br>&gt; +  func appendWithArc(center center: Point, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat)<br>&gt;    func appendWithArcFrom(point1: Point, to point2: Point, radius: CGFloat)<br>&gt; +  func append(glyph glyph: NSGlyph, in font: NSFont)<br>&gt; +  func append(glyphs glyphs: UnsafeMutablePointer&lt;NSGlyph&gt;, count: Int, in font: NSFont)<br>&gt; +  func append(packedGlyphs packedGlyphs: UnsafePointer&lt;Int8&gt;)<br>&gt; +  func append(roundedRect rect: Rect, xRadius: CGFloat, yRadius: CGFloat)<br></p><p>Would you need to annotate all the methods?<br></p><p>-- Ben<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 27, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jan 27, 2016, at 1:45 PM, Ben Rimmington &lt;me at benrimmington.com&gt; wrote:<br>&gt; <br>&gt; Matthew,<br>&gt; <br>&gt;&gt; On 27 Jan 2016, at 19:26, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This is better IMO:<br>&gt;&gt; <br>&gt;&gt; func appendArc(center center: Point, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: Bool)<br>&gt;&gt; <br>&gt;&gt; However, I think this is an example of where explicit annotation is probably necessary to get the best result.  A heuristic can’t always do the right thing and I think this example is past the point of diminishing returns for heuristics.<br>&gt; <br>&gt; The &quot;append&quot; methods of the AppKit.NSBezierPath patch are:<br>&gt; <br>&gt;&gt;   func append(path: NSBezierPath)<br>&gt;&gt; +  func append(rect rect: Rect)<br>&gt;&gt; +  func append(points points: PointArray, count: Int)<br>&gt;&gt;   func appendWithOvalIn(rect: Rect)<br>&gt;&gt; +  func appendWithArc(center center: Point, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: Bool)<br>&gt;&gt; +  func appendWithArc(center center: Point, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat)<br>&gt;&gt;   func appendWithArcFrom(point1: Point, to point2: Point, radius: CGFloat)<br>&gt;&gt; +  func append(glyph glyph: NSGlyph, in font: NSFont)<br>&gt;&gt; +  func append(glyphs glyphs: UnsafeMutablePointer&lt;NSGlyph&gt;, count: Int, in font: NSFont)<br>&gt;&gt; +  func append(packedGlyphs packedGlyphs: UnsafePointer&lt;Int8&gt;)<br>&gt;&gt; +  func append(roundedRect rect: Rect, xRadius: CGFloat, yRadius: CGFloat)<br>&gt; <br>&gt; Would you need to annotate all the methods?<br></p><p>Not all of them, but it does appear to me like several of them would need annotation to get the best results, regardless of what you think the best results are.  Which ones require annotation depends on what results you want of course.<br></p><p>&gt; <br>&gt; -- Ben<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 27, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jan 27, 2016, at 11:22 AM, Ben Rimmington &lt;me at benrimmington.com&gt; wrote:<br>&gt; <br>&gt; Doug,<br>&gt; <br>&gt;&gt; On 27 Jan 2016, at 07:50, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Another random interesting example I encountered:<br>&gt;&gt; <br>&gt;&gt; -  func addArcWithCenter(center: CGPoint, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: Bool)<br>&gt;&gt; +  func addArc(center center: CGPoint, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: Bool)<br>&gt;&gt; <br>&gt;&gt; which seems to match the idea behind Erica’s &quot;semantic relationship between the parameters is stronger than their relation to the operation” (or Paul Cantrell’s similar notion of &quot;the direct object is several args taken together”, which feels more in line with the way the API guidelines are written).<br>&gt; <br>&gt; The related AppKit.NSBezierPath method contains two possible &quot;With&quot; separators:<br>&gt; <br>&gt;&gt; - (void)appendBezierPathWithArcWithCenter:(NSPoint)center<br>&gt;&gt;                                   radius:(CGFloat)radius<br>&gt;&gt;                               startAngle:(CGFloat)startAngle<br>&gt;&gt;                                 endAngle:(CGFloat)endAngle<br>&gt;&gt;                                clockwise:(BOOL)clockwise<br>&gt; <br>&gt; Your patch replaces the second &quot;With&quot; separator, but the alternative might be better:<br>&gt; <br>&gt;&gt; // YOUR PATCH:<br>&gt;&gt; func appendWithArc(center center: Point, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: Bool)<br>&gt;&gt; <br>&gt;&gt; // THE ALTERNATIVE:<br>&gt;&gt; func append(arcWithCenter center: Point, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: Bool)<br></p><p><br>Applying this heuristic changes the two “appendWithArcWithCenter” methods along, and one other place in the SDK:<br></p><p>-  func isUnifiedWithContact(identifier contactIdentifier: String) -&gt; Bool<br>+  func isUnified(contactWithIdentifier contactIdentifier: String) -&gt; Bool<br></p><p>this one seems worse.<br></p><p>	- Doug<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bdd257c9369fb68e1d06923d10ff789e?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Ben Rimmington</string> &lt;me at benrimmington.com&gt;<p>January 27, 2016 at 09:00:00pm</p></header><div class="content"><p>Doug,<br></p><p>For methods such as:<br></p><p>&gt; func description(locale locale: AnyObject?) -&gt; String<br>&gt; func description(locale locale: AnyObject?, indent level: Int) -&gt; String<br></p><p>1. Can the `locale` parameter be given a default `= nil` argument?<br></p><p>2. Can the parameter type be changed to `NSLocale?` when translated into Swift?<br></p><p>-- Ben<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be4c3c3b76631a155e1358db48066692?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Tony Parker</string> &lt;anthony.parker at apple.com&gt;<p>January 27, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jan 27, 2016, at 1:07 PM, Ben Rimmington via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Doug,<br>&gt; <br>&gt; For methods such as:<br>&gt; <br>&gt;&gt; func description(locale locale: AnyObject?) -&gt; String<br>&gt;&gt; func description(locale locale: AnyObject?, indent level: Int) -&gt; String<br>&gt; <br>&gt; 1. Can the `locale` parameter be given a default `= nil` argument?<br>&gt; <br>&gt; 2. Can the parameter type be changed to `NSLocale?` when translated into Swift?<br>&gt; <br></p><p>The Objective-C version takes either an NSDictionary or an NSLocale. I think we could consider it making NSLocale-only in Swift.<br></p><p>- Tony<br></p><p>&gt; -- Ben<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/aeab22e60ba7b7e2bd445775850448d1?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Radosław Pietruszewski</string> &lt;radexpl at gmail.com&gt;<p>January 30, 2016 at 05:00:00pm</p></header><div class="content"><p>Doug,<br></p><p>Here’s another observation:<br></p><p>I noticed that there’s another word commonly used to join words in ObjC method names, very similarly to “with”, and that’s “using”.<br></p><p>The vast majority of those is the phrase “usingBlock”:<br></p><p>    enumerateObjectsUsingBlock(_:)<br></p><p>How will this be handled? If I understand correctly, “block” will be dropped as it’s repeating type information, so we’d get:<br></p><p>    enumerateObjectsUsing(_:)<br></p><p>But perhaps it would make more sense to split by “using” the same way as “with”, yielding:<br></p><p>    enumerateObjects(block:)<br></p><p>Possibly dropping the label altogether (regardless of the position?) since it’s also redundant? Not sure:<br></p><p>   enumerateObjects(_:)<br></p><p>But I also see more cases that don’t involve blocks:<br></p><p>   dataUsingEncoding(_:)<br>   connectNodeUsingObstacles(_:)<br>   canMakePaymentsUsingNetworks(_:)<br>   awakeAfterUsingCoder(_:)<br>   filteredArrayUsingPredicate(_:)<br>   keysSortedByValueUsingComparator(_:)<br></p><p>Would become:<br>  <br>   data(encoding:)<br>   connectNode(obstacles:)<br>   canMakePayments(networks:)<br>   awakeAfter(coder:)<br>   filteredArray(predicate:)<br>   keysSortedByValue(comparator:)<br></p><p>What do you think?    <br></p><p>— Radek<br></p><p>&gt; On 27 Jan 2016, at 08:50, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 25, 2016, at 6:55 AM, Radosław Pietruszewski &lt;radexpl at gmail.com &lt;mailto:radexpl at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello all,<br>&gt;&gt; <br>&gt;&gt; I’m overwhelmingly *for* this proposal. I think removing needless verbosity and keeping the signal-to-noise ratio high is one of the most immediately appealing aspects of Swift, as well as a great general improvement to the programming experience.<br>&gt;&gt; <br>&gt;&gt; And so unswiftified (yes, it’s a word now) APIs from Objective-C stick out like a sore thumb. Not only are they harder to read and write, they visually overwhelm the less verbose, information-dense Swift-first code.<br>&gt;&gt; <br>&gt;&gt; Just like previous 1.0—2.0 attempts at bridging the gap (with NSError params being translated to Swift errors, factory methods translated to initializers, etc.), automating this will be an error-prone process, and almost bound to be a bit annoying at first, before all the glitches and poor translations are smoothed out. And yet I feel like just like the previous automated translations were overwhelmingly a great thing, so will the result of this proposal.<br>&gt;&gt; <br>&gt;&gt; * * *<br>&gt;&gt; <br>&gt;&gt;&gt;    Add First Argument Labels<br>&gt;&gt;&gt;    <br>&gt;&gt;&gt;    - func enumerateObjectsWith(_: NSEnumerationOptions = [], using: (AnyObject, UnsafeMutablePointer) -&gt; Void)<br>&gt;&gt;&gt;    + func enumerateObjects(options _: NSEnumerationOptions = [], using: (AnyObject, UnsafeMutablePointer) -&gt; Void)<br>&gt;&gt; <br>&gt;&gt; Good! The Guidelines recommend an explicit first parameter label for arguments with a default value, but this is a good change also for another reason, a use case not included in the Guidelines (I have more to say about this in the SE-0023 thread):<br>&gt;&gt; <br>&gt;&gt; “Options” is the description of the parameter, not the method itself. Even if (for whatever reason!) `options` didn’t have a default value and the word “Options” wasn’t omitted in the translation,<br>&gt;&gt; <br>&gt;&gt;    enumerateObjects(options: …)<br>&gt;&gt; <br>&gt;&gt; would be clearer than<br>&gt;&gt; <br>&gt;&gt;    enumerateObjectsWithOptions(…)<br>&gt;&gt; <br>&gt;&gt; It’s not even about the extra word, about the four useless characters, it’s simply that “WithOptions” doesn’t describe the operation at all. It’s a word that conveys no information (“with”), and “options”, which describes the first parameter. In Objective-C, there’s no such thing as parameter labels, it’s all one name, so “With” is used as a separator. But in Swift, making the first parameter’s label explicit just makes more sense.<br>&gt; <br>&gt; That’s an interesting thought! If “with” is truly used as a convention for separating the description of the operation from the description of the first parameter, that’s something that can be codified in the Clang importer. I was curious, so I hacked it up. Here’s a diff of the Cocoa APIs that shows what things would look like if we treated “with” as a separator:<br>&gt; <br>&gt; 	https://github.com/apple/swift-3-api-guidelines-review/pull/5/files &lt;https://github.com/apple/swift-3-api-guidelines-review/pull/5/files&gt;<br>&gt; <br>&gt; It’s a diff against SE-0005, and it introduces a significant number of first argument labels. Indeed, you’ll need to grab the patch to see them all:<br>&gt; <br>&gt; 	https://github.com/apple/swift-3-api-guidelines-review/pull/5.patch &lt;https://github.com/apple/swift-3-api-guidelines-review/pull/5.patch&gt;<br>&gt; <br>&gt; A brief survey shows that some cases seem to be lining up with the guideline proposals that have been under discussion. For example, the patch includes:<br>&gt; <br>&gt; -  func fillWith(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt; -  func strokeWith(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt; +  func fill(blendMode blendMode: CGBlendMode, alpha: CGFloat)<br>&gt; +  func stroke(blendMode blendMode: CGBlendMode, alpha: CGFloat)<br>&gt; <br>&gt; -  func encodeWith(aCoder: Coder)<br>&gt; +  func encode(coder aCoder: Coder)<br>&gt; <br>&gt; which you might recognize, because it’s the example you used:<br>&gt; <br>&gt;&gt; And with that in mind, I object to these translations:<br>&gt;&gt; <br>&gt;&gt;    func fillWith(_: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;    func strokeWith(_: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;    func encodeWith(_: Coder)<br>&gt;&gt; <br>&gt;&gt; Even though these don’t have default values, I believe this version to be clearer and make more sense, even if slightly more verbose:<br>&gt;&gt; <br>&gt;&gt;    func fill(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;    func stroke(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;    func encode(coder: Coder)<br>&gt; <br>&gt; Another random interesting example I encountered:<br>&gt; <br>&gt; -  func addArcWithCenter(center: CGPoint, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: Bool)<br>&gt; +  func addArc(center center: CGPoint, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: Bool)<br>&gt; <br>&gt; which seems to match the idea behind Erica’s &quot;semantic relationship between the parameters is stronger than their relation to the operation” (or Paul Cantrell’s similar notion of &quot;the direct object is several args taken together”, which feels more in line with the way the API guidelines are written).<br>&gt; <br>&gt; There’s also this:<br>&gt; <br>&gt; -  func tracksWithMediaType(mediaType: String) -&gt; [AVMovieTrack]<br>&gt; +  func tracks(mediaType mediaType: String) -&gt; [AVMovieTrack]<br>&gt; <br>&gt; -  func tracksWithMediaCharacteristic(mediaCharacteristic: String) -&gt;<br>&gt; +  func tracks(mediaCharacteristic mediaCharacteristic: String) -&gt; [AVMovieTrack]<br>&gt; <br>&gt; which feels reminiscent of Paul’s “resource” example:<br>&gt; <br>&gt;     service.resource(&quot;/foo&quot;)<br>&gt;     service.resource(absoluteURL: &quot;http://bar.com &lt;http://bar.com/&gt;&quot;)<br>&gt;     service.resource(absoluteURL: NSURL(string: &quot;http://bar.com &lt;http://bar.com/&gt;&quot;))<br>&gt; <br>&gt; where (I think) the argument is that the various methods should all have the same base name because they’re all returning “tracks” or a “resource”, respectively.<br>&gt; <br>&gt; There is a ton of data in that patch. I’d be interested to hear whether the resulting Cocoa APIs feel better in Swift—are they following the evolving set of guidelines for first argument labels that are under discussion, and are the resulting APIs clearer/more Swifty? What specific APIs work well and where does this “with-as-separator” heuristic break down?<br>&gt; <br>&gt; 	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160130/9e5ae6b2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>February  1, 2016 at 12:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>On Jan 30, 2016, at 8:03 AM, Radosław Pietruszewski &lt;radexpl at gmail.com &lt;mailto:radexpl at gmail.com&gt;&gt; wrote:<br></p><p>&gt; Doug,<br>&gt; <br>&gt; Here’s another observation:<br>&gt; <br>&gt; I noticed that there’s another word commonly used to join words in ObjC method names, very similarly to “with”, and that’s “using”.<br>&gt; <br>&gt; The vast majority of those is the phrase “usingBlock”:<br>&gt; <br>&gt;     enumerateObjectsUsingBlock(_:)<br>&gt; <br>&gt; How will this be handled? If I understand correctly, “block” will be dropped as it’s repeating type information, so we’d get:<br>&gt; <br>&gt;     enumerateObjectsUsing(_:)<br>&gt; <br>&gt; But perhaps it would make more sense to split by “using” the same way as “with”, yielding:<br>&gt; <br>&gt;     enumerateObjects(block:)<br></p><p>It&#39;s worth giving it a try. Here are the results:<br></p><p>	https://github.com/apple/swift-3-api-guidelines-review/pull/8<br></p><p>They look generally consistent with the “use a first argument label when the first parameter isn’t the direct object” guidelines being discussed.<br></p><p>&gt; Possibly dropping the label altogether (regardless of the position?) since it’s also redundant? Not sure:<br>&gt; <br>&gt;    enumerateObjects(_:)<br></p><p>I don&#39;t think I would drop the label. The first parameter is not the direct object of the verb enumerate, nor is it described by &quot;Objects&quot;.<br></p><p>&gt; But I also see more cases that don’t involve blocks:<br>&gt; <br>&gt;    dataUsingEncoding(_:)<br>&gt;    connectNodeUsingObstacles(_:)<br>&gt;    canMakePaymentsUsingNetworks(_:)<br>&gt;    awakeAfterUsingCoder(_:)<br>&gt;    filteredArrayUsingPredicate(_:)<br>&gt;    keysSortedByValueUsingComparator(_:)<br>&gt; <br>&gt; Would become:<br>&gt;   <br>&gt;    data(encoding:)<br>&gt;    connectNode(obstacles:)<br>&gt;    canMakePayments(networks:)<br>&gt;    awakeAfter(coder:)<br>&gt;    filteredArray(predicate:)<br>&gt;    keysSortedByValue(comparator:)<br>&gt; <br>&gt; What do you think?    <br></p><p>I didn’t dig through the results as much as I’d like, but this makes me *really* want to standardize the name of closure arguments:<br></p><p> -  func sortSubviewsUsing(compare: @convention(c) (NSView, NSView, UnsafeMutablePointer&lt;Void&gt;) -&gt; ComparisonResult, context: UnsafeMutablePointer&lt;Void&gt;)<br> +  func sortSubviews(function compare: @convention(c) (NSView, NSView, UnsafeMutablePointer&lt;Void&gt;) -&gt; ComparisonResult, context: UnsafeMutablePointer&lt;Void&gt;)<br></p><p>-  func enumerateAvailableRowViewsUsing(handler: (NSTableRowView, Int) -&gt; Void)<br> +  func enumerateAvailableRowViews(block handler: (NSTableRowView, Int) -&gt; Void)<br></p><p><br>	- Doug<br></p><p><br>&gt; — Radek<br>&gt; <br>&gt;&gt; On 27 Jan 2016, at 08:50, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 25, 2016, at 6:55 AM, Radosław Pietruszewski &lt;radexpl at gmail.com &lt;mailto:radexpl at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m overwhelmingly *for* this proposal. I think removing needless verbosity and keeping the signal-to-noise ratio high is one of the most immediately appealing aspects of Swift, as well as a great general improvement to the programming experience.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And so unswiftified (yes, it’s a word now) APIs from Objective-C stick out like a sore thumb. Not only are they harder to read and write, they visually overwhelm the less verbose, information-dense Swift-first code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Just like previous 1.0—2.0 attempts at bridging the gap (with NSError params being translated to Swift errors, factory methods translated to initializers, etc.), automating this will be an error-prone process, and almost bound to be a bit annoying at first, before all the glitches and poor translations are smoothed out. And yet I feel like just like the previous automated translations were overwhelmingly a great thing, so will the result of this proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * * *<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    Add First Argument Labels<br>&gt;&gt;&gt;&gt;    <br>&gt;&gt;&gt;&gt;    - func enumerateObjectsWith(_: NSEnumerationOptions = [], using: (AnyObject, UnsafeMutablePointer) -&gt; Void)<br>&gt;&gt;&gt;&gt;    + func enumerateObjects(options _: NSEnumerationOptions = [], using: (AnyObject, UnsafeMutablePointer) -&gt; Void)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Good! The Guidelines recommend an explicit first parameter label for arguments with a default value, but this is a good change also for another reason, a use case not included in the Guidelines (I have more to say about this in the SE-0023 thread):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; “Options” is the description of the parameter, not the method itself. Even if (for whatever reason!) `options` didn’t have a default value and the word “Options” wasn’t omitted in the translation,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    enumerateObjects(options: …)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; would be clearer than<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    enumerateObjectsWithOptions(…)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It’s not even about the extra word, about the four useless characters, it’s simply that “WithOptions” doesn’t describe the operation at all. It’s a word that conveys no information (“with”), and “options”, which describes the first parameter. In Objective-C, there’s no such thing as parameter labels, it’s all one name, so “With” is used as a separator. But in Swift, making the first parameter’s label explicit just makes more sense.<br>&gt;&gt; <br>&gt;&gt; That’s an interesting thought! If “with” is truly used as a convention for separating the description of the operation from the description of the first parameter, that’s something that can be codified in the Clang importer. I was curious, so I hacked it up. Here’s a diff of the Cocoa APIs that shows what things would look like if we treated “with” as a separator:<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-3-api-guidelines-review/pull/5/files &lt;https://github.com/apple/swift-3-api-guidelines-review/pull/5/files&gt;<br>&gt;&gt; <br>&gt;&gt; It’s a diff against SE-0005, and it introduces a significant number of first argument labels. Indeed, you’ll need to grab the patch to see them all:<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-3-api-guidelines-review/pull/5.patch &lt;https://github.com/apple/swift-3-api-guidelines-review/pull/5.patch&gt;<br>&gt;&gt; <br>&gt;&gt; A brief survey shows that some cases seem to be lining up with the guideline proposals that have been under discussion. For example, the patch includes:<br>&gt;&gt; <br>&gt;&gt; -  func fillWith(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt; -  func strokeWith(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt; +  func fill(blendMode blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt; +  func stroke(blendMode blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt; <br>&gt;&gt; -  func encodeWith(aCoder: Coder)<br>&gt;&gt; +  func encode(coder aCoder: Coder)<br>&gt;&gt; <br>&gt;&gt; which you might recognize, because it’s the example you used:<br>&gt;&gt; <br>&gt;&gt;&gt; And with that in mind, I object to these translations:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    func fillWith(_: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;    func strokeWith(_: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;    func encodeWith(_: Coder)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Even though these don’t have default values, I believe this version to be clearer and make more sense, even if slightly more verbose:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    func fill(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;    func stroke(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;    func encode(coder: Coder)<br>&gt;&gt; <br>&gt;&gt; Another random interesting example I encountered:<br>&gt;&gt; <br>&gt;&gt; -  func addArcWithCenter(center: CGPoint, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: Bool)<br>&gt;&gt; +  func addArc(center center: CGPoint, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: Bool)<br>&gt;&gt; <br>&gt;&gt; which seems to match the idea behind Erica’s &quot;semantic relationship between the parameters is stronger than their relation to the operation” (or Paul Cantrell’s similar notion of &quot;the direct object is several args taken together”, which feels more in line with the way the API guidelines are written).<br>&gt;&gt; <br>&gt;&gt; There’s also this:<br>&gt;&gt; <br>&gt;&gt; -  func tracksWithMediaType(mediaType: String) -&gt; [AVMovieTrack]<br>&gt;&gt; +  func tracks(mediaType mediaType: String) -&gt; [AVMovieTrack]<br>&gt;&gt; <br>&gt;&gt; -  func tracksWithMediaCharacteristic(mediaCharacteristic: String) -&gt;<br>&gt;&gt; +  func tracks(mediaCharacteristic mediaCharacteristic: String) -&gt; [AVMovieTrack]<br>&gt;&gt; <br>&gt;&gt; which feels reminiscent of Paul’s “resource” example:<br>&gt;&gt; <br>&gt;&gt;     service.resource(&quot;/foo&quot;)<br>&gt;&gt;     service.resource(absoluteURL: &quot;http://bar.com &lt;http://bar.com/&gt;&quot;)<br>&gt;&gt;     service.resource(absoluteURL: NSURL(string: &quot;http://bar.com &lt;http://bar.com/&gt;&quot;))<br>&gt;&gt; <br>&gt;&gt; where (I think) the argument is that the various methods should all have the same base name because they’re all returning “tracks” or a “resource”, respectively.<br>&gt;&gt; <br>&gt;&gt; There is a ton of data in that patch. I’d be interested to hear whether the resulting Cocoa APIs feel better in Swift—are they following the evolving set of guidelines for first argument labels that are under discussion, and are the resulting APIs clearer/more Swifty? What specific APIs work well and where does this “with-as-separator” heuristic break down?<br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/485ff113/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>February  1, 2016 at 04:00:00pm</p></header><div class="content"><p>I am not sure about these:<br></p><p>-  func tracksWithMediaType(mediaType: String) -&gt; [AVMovieTrack]<br>+  func tracks(mediaType mediaType: String) -&gt; [AVMovieTrack]<br></p><p>-  func tracksWithMediaCharacteristic(mediaCharacteristic: String) -&gt;<br>+  func tracks(mediaCharacteristic mediaCharacteristic: String) -&gt; [AVMovieTrack]<br></p><p>Using just tracks(…) is not as clear in my opinion.  I could get used to it, but I think the before version is more clear than the after version.  <br></p><p>An alternative could be to have one method name for all different ways to get tracks, i.e.  tracksWith(…) or tracksMatching(…) with different parameters each.  Or just leave them the way they are, i.e. tracksWithMediaType(…) and tracksWithMediaCharacteristic(…).  <br></p><p>Getting rid of With in other methods does seem to work though.  For example, encode(coder:)<br></p><p><br></p><p>&gt; On Feb 1, 2016, at 3:04 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt; On Jan 30, 2016, at 8:03 AM, Radosław Pietruszewski &lt;radexpl at gmail.com &lt;mailto:radexpl at gmail.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Doug,<br>&gt;&gt; <br>&gt;&gt; Here’s another observation:<br>&gt;&gt; <br>&gt;&gt; I noticed that there’s another word commonly used to join words in ObjC method names, very similarly to “with”, and that’s “using”.<br>&gt;&gt; <br>&gt;&gt; The vast majority of those is the phrase “usingBlock”:<br>&gt;&gt; <br>&gt;&gt;     enumerateObjectsUsingBlock(_:)<br>&gt;&gt; <br>&gt;&gt; How will this be handled? If I understand correctly, “block” will be dropped as it’s repeating type information, so we’d get:<br>&gt;&gt; <br>&gt;&gt;     enumerateObjectsUsing(_:)<br>&gt;&gt; <br>&gt;&gt; But perhaps it would make more sense to split by “using” the same way as “with”, yielding:<br>&gt;&gt; <br>&gt;&gt;     enumerateObjects(block:)<br>&gt; <br>&gt; It&#39;s worth giving it a try. Here are the results:<br>&gt; <br>&gt; 	https://github.com/apple/swift-3-api-guidelines-review/pull/8 &lt;https://github.com/apple/swift-3-api-guidelines-review/pull/8&gt;<br>&gt; <br>&gt; They look generally consistent with the “use a first argument label when the first parameter isn’t the direct object” guidelines being discussed.<br>&gt; <br>&gt;&gt; Possibly dropping the label altogether (regardless of the position?) since it’s also redundant? Not sure:<br>&gt;&gt; <br>&gt;&gt;    enumerateObjects(_:)<br>&gt; <br>&gt; I don&#39;t think I would drop the label. The first parameter is not the direct object of the verb enumerate, nor is it described by &quot;Objects&quot;.<br>&gt; <br>&gt;&gt; But I also see more cases that don’t involve blocks:<br>&gt;&gt; <br>&gt;&gt;    dataUsingEncoding(_:)<br>&gt;&gt;    connectNodeUsingObstacles(_:)<br>&gt;&gt;    canMakePaymentsUsingNetworks(_:)<br>&gt;&gt;    awakeAfterUsingCoder(_:)<br>&gt;&gt;    filteredArrayUsingPredicate(_:)<br>&gt;&gt;    keysSortedByValueUsingComparator(_:)<br>&gt;&gt; <br>&gt;&gt; Would become:<br>&gt;&gt;   <br>&gt;&gt;    data(encoding:)<br>&gt;&gt;    connectNode(obstacles:)<br>&gt;&gt;    canMakePayments(networks:)<br>&gt;&gt;    awakeAfter(coder:)<br>&gt;&gt;    filteredArray(predicate:)<br>&gt;&gt;    keysSortedByValue(comparator:)<br>&gt;&gt; <br>&gt;&gt; What do you think?    <br>&gt; <br>&gt; I didn’t dig through the results as much as I’d like, but this makes me *really* want to standardize the name of closure arguments:<br>&gt; <br>&gt;  -  func sortSubviewsUsing(compare: @convention(c) (NSView, NSView, UnsafeMutablePointer&lt;Void&gt;) -&gt; ComparisonResult, context: UnsafeMutablePointer&lt;Void&gt;)<br>&gt;  +  func sortSubviews(function compare: @convention(c) (NSView, NSView, UnsafeMutablePointer&lt;Void&gt;) -&gt; ComparisonResult, context: UnsafeMutablePointer&lt;Void&gt;)<br>&gt; <br>&gt; -  func enumerateAvailableRowViewsUsing(handler: (NSTableRowView, Int) -&gt; Void)<br>&gt;  +  func enumerateAvailableRowViews(block handler: (NSTableRowView, Int) -&gt; Void)<br>&gt; <br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; <br>&gt;&gt; — Radek<br>&gt;&gt; <br>&gt;&gt;&gt; On 27 Jan 2016, at 08:50, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 25, 2016, at 6:55 AM, Radosław Pietruszewski &lt;radexpl at gmail.com &lt;mailto:radexpl at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m overwhelmingly *for* this proposal. I think removing needless verbosity and keeping the signal-to-noise ratio high is one of the most immediately appealing aspects of Swift, as well as a great general improvement to the programming experience.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And so unswiftified (yes, it’s a word now) APIs from Objective-C stick out like a sore thumb. Not only are they harder to read and write, they visually overwhelm the less verbose, information-dense Swift-first code.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Just like previous 1.0—2.0 attempts at bridging the gap (with NSError params being translated to Swift errors, factory methods translated to initializers, etc.), automating this will be an error-prone process, and almost bound to be a bit annoying at first, before all the glitches and poor translations are smoothed out. And yet I feel like just like the previous automated translations were overwhelmingly a great thing, so will the result of this proposal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * * *<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;    Add First Argument Labels<br>&gt;&gt;&gt;&gt;&gt;    <br>&gt;&gt;&gt;&gt;&gt;    - func enumerateObjectsWith(_: NSEnumerationOptions = [], using: (AnyObject, UnsafeMutablePointer) -&gt; Void)<br>&gt;&gt;&gt;&gt;&gt;    + func enumerateObjects(options _: NSEnumerationOptions = [], using: (AnyObject, UnsafeMutablePointer) -&gt; Void)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Good! The Guidelines recommend an explicit first parameter label for arguments with a default value, but this is a good change also for another reason, a use case not included in the Guidelines (I have more to say about this in the SE-0023 thread):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; “Options” is the description of the parameter, not the method itself. Even if (for whatever reason!) `options` didn’t have a default value and the word “Options” wasn’t omitted in the translation,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    enumerateObjects(options: …)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; would be clearer than<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    enumerateObjectsWithOptions(…)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It’s not even about the extra word, about the four useless characters, it’s simply that “WithOptions” doesn’t describe the operation at all. It’s a word that conveys no information (“with”), and “options”, which describes the first parameter. In Objective-C, there’s no such thing as parameter labels, it’s all one name, so “With” is used as a separator. But in Swift, making the first parameter’s label explicit just makes more sense.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That’s an interesting thought! If “with” is truly used as a convention for separating the description of the operation from the description of the first parameter, that’s something that can be codified in the Clang importer. I was curious, so I hacked it up. Here’s a diff of the Cocoa APIs that shows what things would look like if we treated “with” as a separator:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	https://github.com/apple/swift-3-api-guidelines-review/pull/5/files &lt;https://github.com/apple/swift-3-api-guidelines-review/pull/5/files&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It’s a diff against SE-0005, and it introduces a significant number of first argument labels. Indeed, you’ll need to grab the patch to see them all:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	https://github.com/apple/swift-3-api-guidelines-review/pull/5.patch &lt;https://github.com/apple/swift-3-api-guidelines-review/pull/5.patch&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A brief survey shows that some cases seem to be lining up with the guideline proposals that have been under discussion. For example, the patch includes:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  func fillWith(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt; -  func strokeWith(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt; +  func fill(blendMode blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt; +  func stroke(blendMode blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  func encodeWith(aCoder: Coder)<br>&gt;&gt;&gt; +  func encode(coder aCoder: Coder)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; which you might recognize, because it’s the example you used:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And with that in mind, I object to these translations:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    func fillWith(_: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt;    func strokeWith(_: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt;    func encodeWith(_: Coder)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Even though these don’t have default values, I believe this version to be clearer and make more sense, even if slightly more verbose:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    func fill(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt;    func stroke(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt;    func encode(coder: Coder)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another random interesting example I encountered:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  func addArcWithCenter(center: CGPoint, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: Bool)<br>&gt;&gt;&gt; +  func addArc(center center: CGPoint, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: Bool)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; which seems to match the idea behind Erica’s &quot;semantic relationship between the parameters is stronger than their relation to the operation” (or Paul Cantrell’s similar notion of &quot;the direct object is several args taken together”, which feels more in line with the way the API guidelines are written).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There’s also this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  func tracksWithMediaType(mediaType: String) -&gt; [AVMovieTrack]<br>&gt;&gt;&gt; +  func tracks(mediaType mediaType: String) -&gt; [AVMovieTrack]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  func tracksWithMediaCharacteristic(mediaCharacteristic: String) -&gt;<br>&gt;&gt;&gt; +  func tracks(mediaCharacteristic mediaCharacteristic: String) -&gt; [AVMovieTrack]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; which feels reminiscent of Paul’s “resource” example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     service.resource(&quot;/foo&quot;)<br>&gt;&gt;&gt;     service.resource(absoluteURL: &quot;http://bar.com &lt;http://bar.com/&gt;&quot;)<br>&gt;&gt;&gt;     service.resource(absoluteURL: NSURL(string: &quot;http://bar.com &lt;http://bar.com/&gt;&quot;))<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; where (I think) the argument is that the various methods should all have the same base name because they’re all returning “tracks” or a “resource”, respectively.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There is a ton of data in that patch. I’d be interested to hear whether the resulting Cocoa APIs feel better in Swift—are they following the evolving set of guidelines for first argument labels that are under discussion, and are the resulting APIs clearer/more Swifty? What specific APIs work well and where does this “with-as-separator” heuristic break down?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/b2fb25c6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>February  1, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Feb 1, 2016, at 1:10 PM, Ricardo Parada via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I am not sure about these:<br>&gt; <br>&gt; -  func tracksWithMediaType(mediaType: String) -&gt; [AVMovieTrack]<br>&gt; +  func tracks(mediaType mediaType: String) -&gt; [AVMovieTrack]<br>&gt; <br>&gt; -  func tracksWithMediaCharacteristic(mediaCharacteristic: String) -&gt;<br>&gt; +  func tracks(mediaCharacteristic mediaCharacteristic: String) -&gt; [AVMovieTrack]<br>&gt; <br>&gt; Using just tracks(…) is not as clear in my opinion.  I could get used to it, but I think the before version is more clear than the after version.  <br>&gt; <br>&gt; An alternative could be to have one method name for all different ways to get tracks, i.e.  tracksWith(…) or tracksMatching(…) with different parameters each.  Or just leave them the way they are, i.e. tracksWithMediaType(…) and tracksWithMediaCharacteristic(…).  <br></p><p>Good to know. I’ve heard this feedback from a couple of others as well. Jordan Rose had an idea over in<br></p><p>	http://article.gmane.org/gmane.comp.lang.swift.evolution/5096<br></p><p>that I turned into an imported heuristic, described here:<br></p><p>	http://thread.gmane.org/gmane.comp.lang.swift.evolution/4179/focus=5096<br></p><p>It takes cases like this, where we have a leading noun in the method name, and avoids creating a first argument label. You can see the difference between the original “with” splitting and the Jordan-inspired heuristic here:<br></p><p>	https://github.com/apple/swift-3-api-guidelines-review/compare/swift-3-first-argument-labels...swift-3-first-argument-labels-verb &lt;https://github.com/apple/swift-3-api-guidelines-review/compare/swift-3-first-argument-labels...swift-3-first-argument-labels-verb&gt;<br></p><p>	<br>&gt; Getting rid of With in other methods does seem to work though.  For example, encode(coder:)<br></p><p>Okay, thanks for the feedback!<br></p><p>	- Doug<br></p><p>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Feb 1, 2016, at 3:04 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt; On Jan 30, 2016, at 8:03 AM, Radosław Pietruszewski &lt;radexpl at gmail.com &lt;mailto:radexpl at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Doug,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here’s another observation:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I noticed that there’s another word commonly used to join words in ObjC method names, very similarly to “with”, and that’s “using”.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The vast majority of those is the phrase “usingBlock”:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     enumerateObjectsUsingBlock(_:)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; How will this be handled? If I understand correctly, “block” will be dropped as it’s repeating type information, so we’d get:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     enumerateObjectsUsing(_:)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But perhaps it would make more sense to split by “using” the same way as “with”, yielding:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     enumerateObjects(block:)<br>&gt;&gt; <br>&gt;&gt; It&#39;s worth giving it a try. Here are the results:<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-3-api-guidelines-review/pull/8 &lt;https://github.com/apple/swift-3-api-guidelines-review/pull/8&gt;<br>&gt;&gt; <br>&gt;&gt; They look generally consistent with the “use a first argument label when the first parameter isn’t the direct object” guidelines being discussed.<br>&gt;&gt; <br>&gt;&gt;&gt; Possibly dropping the label altogether (regardless of the position?) since it’s also redundant? Not sure:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    enumerateObjects(_:)<br>&gt;&gt; <br>&gt;&gt; I don&#39;t think I would drop the label. The first parameter is not the direct object of the verb enumerate, nor is it described by &quot;Objects&quot;.<br>&gt;&gt; <br>&gt;&gt;&gt; But I also see more cases that don’t involve blocks:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    dataUsingEncoding(_:)<br>&gt;&gt;&gt;    connectNodeUsingObstacles(_:)<br>&gt;&gt;&gt;    canMakePaymentsUsingNetworks(_:)<br>&gt;&gt;&gt;    awakeAfterUsingCoder(_:)<br>&gt;&gt;&gt;    filteredArrayUsingPredicate(_:)<br>&gt;&gt;&gt;    keysSortedByValueUsingComparator(_:)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Would become:<br>&gt;&gt;&gt;   <br>&gt;&gt;&gt;    data(encoding:)<br>&gt;&gt;&gt;    connectNode(obstacles:)<br>&gt;&gt;&gt;    canMakePayments(networks:)<br>&gt;&gt;&gt;    awakeAfter(coder:)<br>&gt;&gt;&gt;    filteredArray(predicate:)<br>&gt;&gt;&gt;    keysSortedByValue(comparator:)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What do you think?    <br>&gt;&gt; <br>&gt;&gt; I didn’t dig through the results as much as I’d like, but this makes me *really* want to standardize the name of closure arguments:<br>&gt;&gt; <br>&gt;&gt;  -  func sortSubviewsUsing(compare: @convention(c) (NSView, NSView, UnsafeMutablePointer&lt;Void&gt;) -&gt; ComparisonResult, context: UnsafeMutablePointer&lt;Void&gt;)<br>&gt;&gt;  +  func sortSubviews(function compare: @convention(c) (NSView, NSView, UnsafeMutablePointer&lt;Void&gt;) -&gt; ComparisonResult, context: UnsafeMutablePointer&lt;Void&gt;)<br>&gt;&gt; <br>&gt;&gt; -  func enumerateAvailableRowViewsUsing(handler: (NSTableRowView, Int) -&gt; Void)<br>&gt;&gt;  +  func enumerateAvailableRowViews(block handler: (NSTableRowView, Int) -&gt; Void)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; — Radek<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 27 Jan 2016, at 08:50, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 25, 2016, at 6:55 AM, Radosław Pietruszewski &lt;radexpl at gmail.com &lt;mailto:radexpl at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’m overwhelmingly *for* this proposal. I think removing needless verbosity and keeping the signal-to-noise ratio high is one of the most immediately appealing aspects of Swift, as well as a great general improvement to the programming experience.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; And so unswiftified (yes, it’s a word now) APIs from Objective-C stick out like a sore thumb. Not only are they harder to read and write, they visually overwhelm the less verbose, information-dense Swift-first code.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Just like previous 1.0—2.0 attempts at bridging the gap (with NSError params being translated to Swift errors, factory methods translated to initializers, etc.), automating this will be an error-prone process, and almost bound to be a bit annoying at first, before all the glitches and poor translations are smoothed out. And yet I feel like just like the previous automated translations were overwhelmingly a great thing, so will the result of this proposal.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; * * *<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;    Add First Argument Labels<br>&gt;&gt;&gt;&gt;&gt;&gt;    <br>&gt;&gt;&gt;&gt;&gt;&gt;    - func enumerateObjectsWith(_: NSEnumerationOptions = [], using: (AnyObject, UnsafeMutablePointer) -&gt; Void)<br>&gt;&gt;&gt;&gt;&gt;&gt;    + func enumerateObjects(options _: NSEnumerationOptions = [], using: (AnyObject, UnsafeMutablePointer) -&gt; Void)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Good! The Guidelines recommend an explicit first parameter label for arguments with a default value, but this is a good change also for another reason, a use case not included in the Guidelines (I have more to say about this in the SE-0023 thread):<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; “Options” is the description of the parameter, not the method itself. Even if (for whatever reason!) `options` didn’t have a default value and the word “Options” wasn’t omitted in the translation,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;    enumerateObjects(options: …)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; would be clearer than<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;    enumerateObjectsWithOptions(…)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It’s not even about the extra word, about the four useless characters, it’s simply that “WithOptions” doesn’t describe the operation at all. It’s a word that conveys no information (“with”), and “options”, which describes the first parameter. In Objective-C, there’s no such thing as parameter labels, it’s all one name, so “With” is used as a separator. But in Swift, making the first parameter’s label explicit just makes more sense.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That’s an interesting thought! If “with” is truly used as a convention for separating the description of the operation from the description of the first parameter, that’s something that can be codified in the Clang importer. I was curious, so I hacked it up. Here’s a diff of the Cocoa APIs that shows what things would look like if we treated “with” as a separator:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	https://github.com/apple/swift-3-api-guidelines-review/pull/5/files &lt;https://github.com/apple/swift-3-api-guidelines-review/pull/5/files&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It’s a diff against SE-0005, and it introduces a significant number of first argument labels. Indeed, you’ll need to grab the patch to see them all:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	https://github.com/apple/swift-3-api-guidelines-review/pull/5.patch &lt;https://github.com/apple/swift-3-api-guidelines-review/pull/5.patch&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A brief survey shows that some cases seem to be lining up with the guideline proposals that have been under discussion. For example, the patch includes:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  func fillWith(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt; -  func strokeWith(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt; +  func fill(blendMode blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt; +  func stroke(blendMode blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  func encodeWith(aCoder: Coder)<br>&gt;&gt;&gt;&gt; +  func encode(coder aCoder: Coder)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; which you might recognize, because it’s the example you used:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; And with that in mind, I object to these translations:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;    func fillWith(_: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt;&gt;    func strokeWith(_: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt;&gt;    func encodeWith(_: Coder)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Even though these don’t have default values, I believe this version to be clearer and make more sense, even if slightly more verbose:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;    func fill(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt;&gt;    func stroke(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt;&gt;    func encode(coder: Coder)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Another random interesting example I encountered:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  func addArcWithCenter(center: CGPoint, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: Bool)<br>&gt;&gt;&gt;&gt; +  func addArc(center center: CGPoint, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: Bool)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; which seems to match the idea behind Erica’s &quot;semantic relationship between the parameters is stronger than their relation to the operation” (or Paul Cantrell’s similar notion of &quot;the direct object is several args taken together”, which feels more in line with the way the API guidelines are written).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There’s also this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  func tracksWithMediaType(mediaType: String) -&gt; [AVMovieTrack]<br>&gt;&gt;&gt;&gt; +  func tracks(mediaType mediaType: String) -&gt; [AVMovieTrack]<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  func tracksWithMediaCharacteristic(mediaCharacteristic: String) -&gt;<br>&gt;&gt;&gt;&gt; +  func tracks(mediaCharacteristic mediaCharacteristic: String) -&gt; [AVMovieTrack]<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; which feels reminiscent of Paul’s “resource” example:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     service.resource(&quot;/foo&quot;)<br>&gt;&gt;&gt;&gt;     service.resource(absoluteURL: &quot;http://bar.com &lt;http://bar.com/&gt;&quot;)<br>&gt;&gt;&gt;&gt;     service.resource(absoluteURL: NSURL(string: &quot;http://bar.com &lt;http://bar.com/&gt;&quot;))<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; where (I think) the argument is that the various methods should all have the same base name because they’re all returning “tracks” or a “resource”, respectively.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There is a ton of data in that patch. I’d be interested to hear whether the resulting Cocoa APIs feel better in Swift—are they following the evolving set of guidelines for first argument labels that are under discussion, and are the resulting APIs clearer/more Swifty? What specific APIs work well and where does this “with-as-separator” heuristic break down?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/4c1fe385/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/aeab22e60ba7b7e2bd445775850448d1?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Radosław Pietruszewski</string> &lt;radexpl at gmail.com&gt;<p>February  2, 2016 at 12:00:00am</p></header><div class="content"><p>&gt;&gt; Here’s another observation:<br>&gt;&gt; <br>&gt;&gt; I noticed that there’s another word commonly used to join words in ObjC method names, very similarly to “with”, and that’s “using”.<br>&gt;&gt; <br>&gt;&gt; The vast majority of those is the phrase “usingBlock”:<br>&gt;&gt; <br>&gt;&gt;     enumerateObjectsUsingBlock(_:)<br>&gt;&gt; <br>&gt;&gt; How will this be handled? If I understand correctly, “block” will be dropped as it’s repeating type information, so we’d get:<br>&gt;&gt; <br>&gt;&gt;     enumerateObjectsUsing(_:)<br>&gt;&gt; <br>&gt;&gt; But perhaps it would make more sense to split by “using” the same way as “with”, yielding:<br>&gt;&gt; <br>&gt;&gt;     enumerateObjects(block:)<br>&gt; <br>&gt; It&#39;s worth giving it a try. Here are the results:<br>&gt; <br>&gt; 	https://github.com/apple/swift-3-api-guidelines-review/pull/8 &lt;https://github.com/apple/swift-3-api-guidelines-review/pull/8&gt;<br>&gt; <br>&gt; They look generally consistent with the “use a first argument label when the first parameter isn’t the direct object” guidelines being discussed.<br></p><p>Awesome, thank you. The result seems overwhelmingly positive to my eyes.<br></p><p>&gt; <br>&gt;&gt; Possibly dropping the label altogether (regardless of the position?) since it’s also redundant? Not sure:<br>&gt;&gt; <br>&gt;&gt;    enumerateObjects(_:)<br>&gt; <br>&gt; I don&#39;t think I would drop the label. The first parameter is not the direct object of the verb enumerate, nor is it described by &quot;Objects”.<br></p><p>OK, agree. FWIW, when the passed block is the only argument, many people (me included) will generally use it using the trailing closure syntax, and the label will be dropped this way anyway.<br></p><p>&gt; <br>&gt;&gt; But I also see more cases that don’t involve blocks:<br>&gt;&gt; <br>&gt;&gt;    dataUsingEncoding(_:)<br>&gt;&gt;    connectNodeUsingObstacles(_:)<br>&gt;&gt;    canMakePaymentsUsingNetworks(_:)<br>&gt;&gt;    awakeAfterUsingCoder(_:)<br>&gt;&gt;    filteredArrayUsingPredicate(_:)<br>&gt;&gt;    keysSortedByValueUsingComparator(_:)<br>&gt;&gt; <br>&gt;&gt; Would become:<br>&gt;&gt;   <br>&gt;&gt;    data(encoding:)<br>&gt;&gt;    connectNode(obstacles:)<br>&gt;&gt;    canMakePayments(networks:)<br>&gt;&gt;    awakeAfter(coder:)<br>&gt;&gt;    filteredArray(predicate:)<br>&gt;&gt;    keysSortedByValue(comparator:)<br>&gt;&gt; <br>&gt;&gt; What do you think?    <br>&gt; <br>&gt; I didn’t dig through the results as much as I’d like, but this makes me *really* want to standardize the name of closure arguments:<br>&gt; <br>&gt;  -  func sortSubviewsUsing(compare: @convention(c) (NSView, NSView, UnsafeMutablePointer&lt;Void&gt;) -&gt; ComparisonResult, context: UnsafeMutablePointer&lt;Void&gt;)<br>&gt;  +  func sortSubviews(function compare: @convention(c) (NSView, NSView, UnsafeMutablePointer&lt;Void&gt;) -&gt; ComparisonResult, context: UnsafeMutablePointer&lt;Void&gt;)<br>&gt; <br>&gt; -  func enumerateAvailableRowViewsUsing(handler: (NSTableRowView, Int) -&gt; Void)<br>&gt;  +  func enumerateAvailableRowViews(block handler: (NSTableRowView, Int) -&gt; Void)<br>&gt; <br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; <br>&gt;&gt; — Radek<br>&gt;&gt; <br>&gt;&gt;&gt; On 27 Jan 2016, at 08:50, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 25, 2016, at 6:55 AM, Radosław Pietruszewski &lt;radexpl at gmail.com &lt;mailto:radexpl at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m overwhelmingly *for* this proposal. I think removing needless verbosity and keeping the signal-to-noise ratio high is one of the most immediately appealing aspects of Swift, as well as a great general improvement to the programming experience.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And so unswiftified (yes, it’s a word now) APIs from Objective-C stick out like a sore thumb. Not only are they harder to read and write, they visually overwhelm the less verbose, information-dense Swift-first code.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Just like previous 1.0—2.0 attempts at bridging the gap (with NSError params being translated to Swift errors, factory methods translated to initializers, etc.), automating this will be an error-prone process, and almost bound to be a bit annoying at first, before all the glitches and poor translations are smoothed out. And yet I feel like just like the previous automated translations were overwhelmingly a great thing, so will the result of this proposal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * * *<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;    Add First Argument Labels<br>&gt;&gt;&gt;&gt;&gt;    <br>&gt;&gt;&gt;&gt;&gt;    - func enumerateObjectsWith(_: NSEnumerationOptions = [], using: (AnyObject, UnsafeMutablePointer) -&gt; Void)<br>&gt;&gt;&gt;&gt;&gt;    + func enumerateObjects(options _: NSEnumerationOptions = [], using: (AnyObject, UnsafeMutablePointer) -&gt; Void)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Good! The Guidelines recommend an explicit first parameter label for arguments with a default value, but this is a good change also for another reason, a use case not included in the Guidelines (I have more to say about this in the SE-0023 thread):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; “Options” is the description of the parameter, not the method itself. Even if (for whatever reason!) `options` didn’t have a default value and the word “Options” wasn’t omitted in the translation,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    enumerateObjects(options: …)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; would be clearer than<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    enumerateObjectsWithOptions(…)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It’s not even about the extra word, about the four useless characters, it’s simply that “WithOptions” doesn’t describe the operation at all. It’s a word that conveys no information (“with”), and “options”, which describes the first parameter. In Objective-C, there’s no such thing as parameter labels, it’s all one name, so “With” is used as a separator. But in Swift, making the first parameter’s label explicit just makes more sense.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That’s an interesting thought! If “with” is truly used as a convention for separating the description of the operation from the description of the first parameter, that’s something that can be codified in the Clang importer. I was curious, so I hacked it up. Here’s a diff of the Cocoa APIs that shows what things would look like if we treated “with” as a separator:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	https://github.com/apple/swift-3-api-guidelines-review/pull/5/files &lt;https://github.com/apple/swift-3-api-guidelines-review/pull/5/files&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It’s a diff against SE-0005, and it introduces a significant number of first argument labels. Indeed, you’ll need to grab the patch to see them all:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	https://github.com/apple/swift-3-api-guidelines-review/pull/5.patch &lt;https://github.com/apple/swift-3-api-guidelines-review/pull/5.patch&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A brief survey shows that some cases seem to be lining up with the guideline proposals that have been under discussion. For example, the patch includes:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  func fillWith(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt; -  func strokeWith(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt; +  func fill(blendMode blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt; +  func stroke(blendMode blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  func encodeWith(aCoder: Coder)<br>&gt;&gt;&gt; +  func encode(coder aCoder: Coder)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; which you might recognize, because it’s the example you used:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And with that in mind, I object to these translations:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    func fillWith(_: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt;    func strokeWith(_: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt;    func encodeWith(_: Coder)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Even though these don’t have default values, I believe this version to be clearer and make more sense, even if slightly more verbose:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    func fill(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt;    func stroke(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt;    func encode(coder: Coder)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another random interesting example I encountered:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  func addArcWithCenter(center: CGPoint, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: Bool)<br>&gt;&gt;&gt; +  func addArc(center center: CGPoint, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: Bool)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; which seems to match the idea behind Erica’s &quot;semantic relationship between the parameters is stronger than their relation to the operation” (or Paul Cantrell’s similar notion of &quot;the direct object is several args taken together”, which feels more in line with the way the API guidelines are written).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There’s also this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  func tracksWithMediaType(mediaType: String) -&gt; [AVMovieTrack]<br>&gt;&gt;&gt; +  func tracks(mediaType mediaType: String) -&gt; [AVMovieTrack]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  func tracksWithMediaCharacteristic(mediaCharacteristic: String) -&gt;<br>&gt;&gt;&gt; +  func tracks(mediaCharacteristic mediaCharacteristic: String) -&gt; [AVMovieTrack]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; which feels reminiscent of Paul’s “resource” example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     service.resource(&quot;/foo&quot;)<br>&gt;&gt;&gt;     service.resource(absoluteURL: &quot;http://bar.com &lt;http://bar.com/&gt;&quot;)<br>&gt;&gt;&gt;     service.resource(absoluteURL: NSURL(string: &quot;http://bar.com &lt;http://bar.com/&gt;&quot;))<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; where (I think) the argument is that the various methods should all have the same base name because they’re all returning “tracks” or a “resource”, respectively.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There is a ton of data in that patch. I’d be interested to hear whether the resulting Cocoa APIs feel better in Swift—are they following the evolving set of guidelines for first argument labels that are under discussion, and are the resulting APIs clearer/more Swifty? What specific APIs work well and where does this “with-as-separator” heuristic break down?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/e2893c24/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>February  1, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Feb 1, 2016, at 3:26 PM, Radosław Pietruszewski &lt;radexpl at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here’s another observation:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I noticed that there’s another word commonly used to join words in ObjC method names, very similarly to “with”, and that’s “using”.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The vast majority of those is the phrase “usingBlock”:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     enumerateObjectsUsingBlock(_:)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; How will this be handled? If I understand correctly, “block” will be dropped as it’s repeating type information, so we’d get:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     enumerateObjectsUsing(_:)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But perhaps it would make more sense to split by “using” the same way as “with”, yielding:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     enumerateObjects(block:)<br>&gt;&gt; <br>&gt;&gt; It&#39;s worth giving it a try. Here are the results:<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-3-api-guidelines-review/pull/8 &lt;https://github.com/apple/swift-3-api-guidelines-review/pull/8&gt;<br>&gt;&gt; <br>&gt;&gt; They look generally consistent with the “use a first argument label when the first parameter isn’t the direct object” guidelines being discussed.<br>&gt; <br>&gt; Awesome, thank you. The result seems overwhelmingly positive to my eyes.<br></p><p>I’m not quite as convinced. The function/block/selector cases work extremely well, but cases like this:<br></p><p> -  func connectNodeUsingObstacles(node: GKGraphNode2D)<br> +  func connectNode(obstacles node: GKGraphNode2D)<br></p><p>don’t necessarily seem like a win: it’s completely fundamental to the method’s operation that it’s avoiding those obstacles, and I think the original is better than the update here.<br></p><p>&gt;&gt;&gt; Possibly dropping the label altogether (regardless of the position?) since it’s also redundant? Not sure:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    enumerateObjects(_:)<br>&gt;&gt; <br>&gt;&gt; I don&#39;t think I would drop the label. The first parameter is not the direct object of the verb enumerate, nor is it described by &quot;Objects”.<br>&gt; <br>&gt; OK, agree. FWIW, when the passed block is the only argument, many people (me included) will generally use it using the trailing closure syntax, and the label will be dropped this way anyway.<br></p><p>Yes, and I think it’s better not to have the “block” or “using” in the base name when you’re using trailing closure syntax. However, when you’re providing a function (not as a trailing closure), that function isn’t the direct object, so it should have a first argument label.<br></p><p>	- Doug<br></p><p>&gt;&gt; <br>&gt;&gt;&gt; But I also see more cases that don’t involve blocks:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    dataUsingEncoding(_:)<br>&gt;&gt;&gt;    connectNodeUsingObstacles(_:)<br>&gt;&gt;&gt;    canMakePaymentsUsingNetworks(_:)<br>&gt;&gt;&gt;    awakeAfterUsingCoder(_:)<br>&gt;&gt;&gt;    filteredArrayUsingPredicate(_:)<br>&gt;&gt;&gt;    keysSortedByValueUsingComparator(_:)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Would become:<br>&gt;&gt;&gt;   <br>&gt;&gt;&gt;    data(encoding:)<br>&gt;&gt;&gt;    connectNode(obstacles:)<br>&gt;&gt;&gt;    canMakePayments(networks:)<br>&gt;&gt;&gt;    awakeAfter(coder:)<br>&gt;&gt;&gt;    filteredArray(predicate:)<br>&gt;&gt;&gt;    keysSortedByValue(comparator:)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What do you think?    <br>&gt;&gt; <br>&gt;&gt; I didn’t dig through the results as much as I’d like, but this makes me *really* want to standardize the name of closure arguments:<br>&gt;&gt; <br>&gt;&gt;  -  func sortSubviewsUsing(compare: @convention(c) (NSView, NSView, UnsafeMutablePointer&lt;Void&gt;) -&gt; ComparisonResult, context: UnsafeMutablePointer&lt;Void&gt;)<br>&gt;&gt;  +  func sortSubviews(function compare: @convention(c) (NSView, NSView, UnsafeMutablePointer&lt;Void&gt;) -&gt; ComparisonResult, context: UnsafeMutablePointer&lt;Void&gt;)<br>&gt;&gt; <br>&gt;&gt; -  func enumerateAvailableRowViewsUsing(handler: (NSTableRowView, Int) -&gt; Void)<br>&gt;&gt;  +  func enumerateAvailableRowViews(block handler: (NSTableRowView, Int) -&gt; Void)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; — Radek<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 27 Jan 2016, at 08:50, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 25, 2016, at 6:55 AM, Radosław Pietruszewski &lt;radexpl at gmail.com &lt;mailto:radexpl at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’m overwhelmingly *for* this proposal. I think removing needless verbosity and keeping the signal-to-noise ratio high is one of the most immediately appealing aspects of Swift, as well as a great general improvement to the programming experience.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; And so unswiftified (yes, it’s a word now) APIs from Objective-C stick out like a sore thumb. Not only are they harder to read and write, they visually overwhelm the less verbose, information-dense Swift-first code.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Just like previous 1.0—2.0 attempts at bridging the gap (with NSError params being translated to Swift errors, factory methods translated to initializers, etc.), automating this will be an error-prone process, and almost bound to be a bit annoying at first, before all the glitches and poor translations are smoothed out. And yet I feel like just like the previous automated translations were overwhelmingly a great thing, so will the result of this proposal.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; * * *<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;    Add First Argument Labels<br>&gt;&gt;&gt;&gt;&gt;&gt;    <br>&gt;&gt;&gt;&gt;&gt;&gt;    - func enumerateObjectsWith(_: NSEnumerationOptions = [], using: (AnyObject, UnsafeMutablePointer) -&gt; Void)<br>&gt;&gt;&gt;&gt;&gt;&gt;    + func enumerateObjects(options _: NSEnumerationOptions = [], using: (AnyObject, UnsafeMutablePointer) -&gt; Void)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Good! The Guidelines recommend an explicit first parameter label for arguments with a default value, but this is a good change also for another reason, a use case not included in the Guidelines (I have more to say about this in the SE-0023 thread):<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; “Options” is the description of the parameter, not the method itself. Even if (for whatever reason!) `options` didn’t have a default value and the word “Options” wasn’t omitted in the translation,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;    enumerateObjects(options: …)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; would be clearer than<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;    enumerateObjectsWithOptions(…)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It’s not even about the extra word, about the four useless characters, it’s simply that “WithOptions” doesn’t describe the operation at all. It’s a word that conveys no information (“with”), and “options”, which describes the first parameter. In Objective-C, there’s no such thing as parameter labels, it’s all one name, so “With” is used as a separator. But in Swift, making the first parameter’s label explicit just makes more sense.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That’s an interesting thought! If “with” is truly used as a convention for separating the description of the operation from the description of the first parameter, that’s something that can be codified in the Clang importer. I was curious, so I hacked it up. Here’s a diff of the Cocoa APIs that shows what things would look like if we treated “with” as a separator:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	https://github.com/apple/swift-3-api-guidelines-review/pull/5/files &lt;https://github.com/apple/swift-3-api-guidelines-review/pull/5/files&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It’s a diff against SE-0005, and it introduces a significant number of first argument labels. Indeed, you’ll need to grab the patch to see them all:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	https://github.com/apple/swift-3-api-guidelines-review/pull/5.patch &lt;https://github.com/apple/swift-3-api-guidelines-review/pull/5.patch&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A brief survey shows that some cases seem to be lining up with the guideline proposals that have been under discussion. For example, the patch includes:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  func fillWith(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt; -  func strokeWith(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt; +  func fill(blendMode blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt; +  func stroke(blendMode blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  func encodeWith(aCoder: Coder)<br>&gt;&gt;&gt;&gt; +  func encode(coder aCoder: Coder)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; which you might recognize, because it’s the example you used:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; And with that in mind, I object to these translations:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;    func fillWith(_: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt;&gt;    func strokeWith(_: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt;&gt;    func encodeWith(_: Coder)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Even though these don’t have default values, I believe this version to be clearer and make more sense, even if slightly more verbose:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;    func fill(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt;&gt;    func stroke(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt;&gt;    func encode(coder: Coder)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Another random interesting example I encountered:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  func addArcWithCenter(center: CGPoint, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: Bool)<br>&gt;&gt;&gt;&gt; +  func addArc(center center: CGPoint, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: Bool)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; which seems to match the idea behind Erica’s &quot;semantic relationship between the parameters is stronger than their relation to the operation” (or Paul Cantrell’s similar notion of &quot;the direct object is several args taken together”, which feels more in line with the way the API guidelines are written).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There’s also this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  func tracksWithMediaType(mediaType: String) -&gt; [AVMovieTrack]<br>&gt;&gt;&gt;&gt; +  func tracks(mediaType mediaType: String) -&gt; [AVMovieTrack]<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  func tracksWithMediaCharacteristic(mediaCharacteristic: String) -&gt;<br>&gt;&gt;&gt;&gt; +  func tracks(mediaCharacteristic mediaCharacteristic: String) -&gt; [AVMovieTrack]<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; which feels reminiscent of Paul’s “resource” example:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     service.resource(&quot;/foo&quot;)<br>&gt;&gt;&gt;&gt;     service.resource(absoluteURL: &quot;http://bar.com &lt;http://bar.com/&gt;&quot;)<br>&gt;&gt;&gt;&gt;     service.resource(absoluteURL: NSURL(string: &quot;http://bar.com &lt;http://bar.com/&gt;&quot;))<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; where (I think) the argument is that the various methods should all have the same base name because they’re all returning “tracks” or a “resource”, respectively.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There is a ton of data in that patch. I’d be interested to hear whether the resulting Cocoa APIs feel better in Swift—are they following the evolving set of guidelines for first argument labels that are under discussion, and are the resulting APIs clearer/more Swifty? What specific APIs work well and where does this “with-as-separator” heuristic break down?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/b02aebbd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>February  2, 2016 at 12:00:00am</p></header><div class="content"><p>Here’s a few example with the latest pull request which I don’t like (taken from AppKit):<br></p><p>-  func window(windowNumber windowNum: Int) -&gt; NSWindow?<br>+  func windowWithWindowNumber(windowNum: Int) -&gt; NSWindow?<br></p><p>-  func transformUsing(transform: AffineTransform)<br>+  func transform(affineTransform transform: AffineTransform)<br></p><p>-  func invalidateLayout(context context: NSCollectionViewLayoutInvalidationContext)<br>+  func invalidateLayoutWith(context: NSCollectionViewLayoutInvalidationContext)<br></p><p>And here’s the big one from UIKit, which everybody uses, which stays very verbose with the latest pul request:<br></p><p>-  func dequeueReusableCell(reuseIdentifier identifier: String, forIndexPath indexPath: IndexPath) -&gt; UICollectionViewCell<br>+  func dequeueReusableCellWithReuseIdentifier(identifier: String, forIndexPath indexPath: IndexPath) -&gt; UICollectionViewCell<br></p><p>David.<br></p><p>&gt; On 02 Feb 2016, at 00:34, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Feb 1, 2016, at 3:26 PM, Radosław Pietruszewski &lt;radexpl at gmail.com &lt;mailto:radexpl at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here’s another observation:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I noticed that there’s another word commonly used to join words in ObjC method names, very similarly to “with”, and that’s “using”.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The vast majority of those is the phrase “usingBlock”:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     enumerateObjectsUsingBlock(_:)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; How will this be handled? If I understand correctly, “block” will be dropped as it’s repeating type information, so we’d get:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     enumerateObjectsUsing(_:)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But perhaps it would make more sense to split by “using” the same way as “with”, yielding:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     enumerateObjects(block:)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s worth giving it a try. Here are the results:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	https://github.com/apple/swift-3-api-guidelines-review/pull/8 &lt;https://github.com/apple/swift-3-api-guidelines-review/pull/8&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; They look generally consistent with the “use a first argument label when the first parameter isn’t the direct object” guidelines being discussed.<br>&gt;&gt; <br>&gt;&gt; Awesome, thank you. The result seems overwhelmingly positive to my eyes.<br>&gt; <br>&gt; I’m not quite as convinced. The function/block/selector cases work extremely well, but cases like this:<br>&gt; <br>&gt;  -  func connectNodeUsingObstacles(node: GKGraphNode2D)<br>&gt;  +  func connectNode(obstacles node: GKGraphNode2D)<br>&gt; <br>&gt; don’t necessarily seem like a win: it’s completely fundamental to the method’s operation that it’s avoiding those obstacles, and I think the original is better than the update here.<br>&gt; <br>&gt;&gt;&gt;&gt; Possibly dropping the label altogether (regardless of the position?) since it’s also redundant? Not sure:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    enumerateObjects(_:)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t think I would drop the label. The first parameter is not the direct object of the verb enumerate, nor is it described by &quot;Objects”.<br>&gt;&gt; <br>&gt;&gt; OK, agree. FWIW, when the passed block is the only argument, many people (me included) will generally use it using the trailing closure syntax, and the label will be dropped this way anyway.<br>&gt; <br>&gt; Yes, and I think it’s better not to have the “block” or “using” in the base name when you’re using trailing closure syntax. However, when you’re providing a function (not as a trailing closure), that function isn’t the direct object, so it should have a first argument label.<br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But I also see more cases that don’t involve blocks:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    dataUsingEncoding(_:)<br>&gt;&gt;&gt;&gt;    connectNodeUsingObstacles(_:)<br>&gt;&gt;&gt;&gt;    canMakePaymentsUsingNetworks(_:)<br>&gt;&gt;&gt;&gt;    awakeAfterUsingCoder(_:)<br>&gt;&gt;&gt;&gt;    filteredArrayUsingPredicate(_:)<br>&gt;&gt;&gt;&gt;    keysSortedByValueUsingComparator(_:)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Would become:<br>&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;    data(encoding:)<br>&gt;&gt;&gt;&gt;    connectNode(obstacles:)<br>&gt;&gt;&gt;&gt;    canMakePayments(networks:)<br>&gt;&gt;&gt;&gt;    awakeAfter(coder:)<br>&gt;&gt;&gt;&gt;    filteredArray(predicate:)<br>&gt;&gt;&gt;&gt;    keysSortedByValue(comparator:)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What do you think?    <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I didn’t dig through the results as much as I’d like, but this makes me *really* want to standardize the name of closure arguments:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  -  func sortSubviewsUsing(compare: @convention(c) (NSView, NSView, UnsafeMutablePointer&lt;Void&gt;) -&gt; ComparisonResult, context: UnsafeMutablePointer&lt;Void&gt;)<br>&gt;&gt;&gt;  +  func sortSubviews(function compare: @convention(c) (NSView, NSView, UnsafeMutablePointer&lt;Void&gt;) -&gt; ComparisonResult, context: UnsafeMutablePointer&lt;Void&gt;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  func enumerateAvailableRowViewsUsing(handler: (NSTableRowView, Int) -&gt; Void)<br>&gt;&gt;&gt;  +  func enumerateAvailableRowViews(block handler: (NSTableRowView, Int) -&gt; Void)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; — Radek<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 27 Jan 2016, at 08:50, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 25, 2016, at 6:55 AM, Radosław Pietruszewski &lt;radexpl at gmail.com &lt;mailto:radexpl at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I’m overwhelmingly *for* this proposal. I think removing needless verbosity and keeping the signal-to-noise ratio high is one of the most immediately appealing aspects of Swift, as well as a great general improvement to the programming experience.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; And so unswiftified (yes, it’s a word now) APIs from Objective-C stick out like a sore thumb. Not only are they harder to read and write, they visually overwhelm the less verbose, information-dense Swift-first code.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Just like previous 1.0—2.0 attempts at bridging the gap (with NSError params being translated to Swift errors, factory methods translated to initializers, etc.), automating this will be an error-prone process, and almost bound to be a bit annoying at first, before all the glitches and poor translations are smoothed out. And yet I feel like just like the previous automated translations were overwhelmingly a great thing, so will the result of this proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; * * *<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    Add First Argument Labels<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    - func enumerateObjectsWith(_: NSEnumerationOptions = [], using: (AnyObject, UnsafeMutablePointer) -&gt; Void)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    + func enumerateObjects(options _: NSEnumerationOptions = [], using: (AnyObject, UnsafeMutablePointer) -&gt; Void)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Good! The Guidelines recommend an explicit first parameter label for arguments with a default value, but this is a good change also for another reason, a use case not included in the Guidelines (I have more to say about this in the SE-0023 thread):<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; “Options” is the description of the parameter, not the method itself. Even if (for whatever reason!) `options` didn’t have a default value and the word “Options” wasn’t omitted in the translation,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;    enumerateObjects(options: …)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; would be clearer than<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;    enumerateObjectsWithOptions(…)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It’s not even about the extra word, about the four useless characters, it’s simply that “WithOptions” doesn’t describe the operation at all. It’s a word that conveys no information (“with”), and “options”, which describes the first parameter. In Objective-C, there’s no such thing as parameter labels, it’s all one name, so “With” is used as a separator. But in Swift, making the first parameter’s label explicit just makes more sense.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That’s an interesting thought! If “with” is truly used as a convention for separating the description of the operation from the description of the first parameter, that’s something that can be codified in the Clang importer. I was curious, so I hacked it up. Here’s a diff of the Cocoa APIs that shows what things would look like if we treated “with” as a separator:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	https://github.com/apple/swift-3-api-guidelines-review/pull/5/files &lt;https://github.com/apple/swift-3-api-guidelines-review/pull/5/files&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It’s a diff against SE-0005, and it introduces a significant number of first argument labels. Indeed, you’ll need to grab the patch to see them all:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	https://github.com/apple/swift-3-api-guidelines-review/pull/5.patch &lt;https://github.com/apple/swift-3-api-guidelines-review/pull/5.patch&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; A brief survey shows that some cases seem to be lining up with the guideline proposals that have been under discussion. For example, the patch includes:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -  func fillWith(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt;&gt; -  func strokeWith(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt;&gt; +  func fill(blendMode blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt;&gt; +  func stroke(blendMode blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -  func encodeWith(aCoder: Coder)<br>&gt;&gt;&gt;&gt;&gt; +  func encode(coder aCoder: Coder)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; which you might recognize, because it’s the example you used:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; And with that in mind, I object to these translations:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;    func fillWith(_: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt;&gt;&gt;    func strokeWith(_: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt;&gt;&gt;    func encodeWith(_: Coder)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Even though these don’t have default values, I believe this version to be clearer and make more sense, even if slightly more verbose:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;    func fill(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt;&gt;&gt;    func stroke(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt;&gt;&gt;    func encode(coder: Coder)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Another random interesting example I encountered:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -  func addArcWithCenter(center: CGPoint, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: Bool)<br>&gt;&gt;&gt;&gt;&gt; +  func addArc(center center: CGPoint, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: Bool)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; which seems to match the idea behind Erica’s &quot;semantic relationship between the parameters is stronger than their relation to the operation” (or Paul Cantrell’s similar notion of &quot;the direct object is several args taken together”, which feels more in line with the way the API guidelines are written).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There’s also this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -  func tracksWithMediaType(mediaType: String) -&gt; [AVMovieTrack]<br>&gt;&gt;&gt;&gt;&gt; +  func tracks(mediaType mediaType: String) -&gt; [AVMovieTrack]<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -  func tracksWithMediaCharacteristic(mediaCharacteristic: String) -&gt;<br>&gt;&gt;&gt;&gt;&gt; +  func tracks(mediaCharacteristic mediaCharacteristic: String) -&gt; [AVMovieTrack]<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; which feels reminiscent of Paul’s “resource” example:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     service.resource(&quot;/foo&quot;)<br>&gt;&gt;&gt;&gt;&gt;     service.resource(absoluteURL: &quot;http://bar.com &lt;http://bar.com/&gt;&quot;)<br>&gt;&gt;&gt;&gt;&gt;     service.resource(absoluteURL: NSURL(string: &quot;http://bar.com &lt;http://bar.com/&gt;&quot;))<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; where (I think) the argument is that the various methods should all have the same base name because they’re all returning “tracks” or a “resource”, respectively.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There is a ton of data in that patch. I’d be interested to hear whether the resulting Cocoa APIs feel better in Swift—are they following the evolving set of guidelines for first argument labels that are under discussion, and are the resulting APIs clearer/more Swifty? What specific APIs work well and where does this “with-as-separator” heuristic break down?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	- Doug<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/3f5d626c/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/aeab22e60ba7b7e2bd445775850448d1?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Radosław Pietruszewski</string> &lt;radexpl at gmail.com&gt;<p>February  2, 2016 at 12:00:00am</p></header><div class="content"><p>&gt;&gt;&gt;&gt; Here’s another observation:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I noticed that there’s another word commonly used to join words in ObjC method names, very similarly to “with”, and that’s “using”.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The vast majority of those is the phrase “usingBlock”:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     enumerateObjectsUsingBlock(_:)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; How will this be handled? If I understand correctly, “block” will be dropped as it’s repeating type information, so we’d get:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     enumerateObjectsUsing(_:)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But perhaps it would make more sense to split by “using” the same way as “with”, yielding:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     enumerateObjects(block:)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s worth giving it a try. Here are the results:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	https://github.com/apple/swift-3-api-guidelines-review/pull/8 &lt;https://github.com/apple/swift-3-api-guidelines-review/pull/8&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; They look generally consistent with the “use a first argument label when the first parameter isn’t the direct object” guidelines being discussed.<br>&gt;&gt; <br>&gt;&gt; Awesome, thank you. The result seems overwhelmingly positive to my eyes.<br>&gt; <br>&gt; I’m not quite as convinced. The function/block/selector cases work extremely well, but cases like this:<br>&gt; <br>&gt;  -  func connectNodeUsingObstacles(node: GKGraphNode2D)<br>&gt;  +  func connectNode(obstacles node: GKGraphNode2D)<br>&gt; <br>&gt; don’t necessarily seem like a win: it’s completely fundamental to the method’s operation that it’s avoiding those obstacles, and I think the original is better than the update here.<br></p><p>Fair. There are many cases that seem like an improvement still, but perhaps the heuristic isn’t reliable enough aside from function contexts.<br></p><p>I also see that cases of NSPredicate and NSSortDescriptor, though not too many, work really well AFAICT with this heuristic.<br></p><p>&gt; <br>&gt;&gt;&gt;&gt; Possibly dropping the label altogether (regardless of the position?) since it’s also redundant? Not sure:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    enumerateObjects(_:)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t think I would drop the label. The first parameter is not the direct object of the verb enumerate, nor is it described by &quot;Objects”.<br>&gt;&gt; <br>&gt;&gt; OK, agree. FWIW, when the passed block is the only argument, many people (me included) will generally use it using the trailing closure syntax, and the label will be dropped this way anyway.<br>&gt; <br>&gt; Yes, and I think it’s better not to have the “block” or “using” in the base name when you’re using trailing closure syntax. However, when you’re providing a function (not as a trailing closure), that function isn’t the direct object, so it should have a first argument label.<br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But I also see more cases that don’t involve blocks:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    dataUsingEncoding(_:)<br>&gt;&gt;&gt;&gt;    connectNodeUsingObstacles(_:)<br>&gt;&gt;&gt;&gt;    canMakePaymentsUsingNetworks(_:)<br>&gt;&gt;&gt;&gt;    awakeAfterUsingCoder(_:)<br>&gt;&gt;&gt;&gt;    filteredArrayUsingPredicate(_:)<br>&gt;&gt;&gt;&gt;    keysSortedByValueUsingComparator(_:)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Would become:<br>&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;    data(encoding:)<br>&gt;&gt;&gt;&gt;    connectNode(obstacles:)<br>&gt;&gt;&gt;&gt;    canMakePayments(networks:)<br>&gt;&gt;&gt;&gt;    awakeAfter(coder:)<br>&gt;&gt;&gt;&gt;    filteredArray(predicate:)<br>&gt;&gt;&gt;&gt;    keysSortedByValue(comparator:)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What do you think?    <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I didn’t dig through the results as much as I’d like, but this makes me *really* want to standardize the name of closure arguments:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  -  func sortSubviewsUsing(compare: @convention(c) (NSView, NSView, UnsafeMutablePointer&lt;Void&gt;) -&gt; ComparisonResult, context: UnsafeMutablePointer&lt;Void&gt;)<br>&gt;&gt;&gt;  +  func sortSubviews(function compare: @convention(c) (NSView, NSView, UnsafeMutablePointer&lt;Void&gt;) -&gt; ComparisonResult, context: UnsafeMutablePointer&lt;Void&gt;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  func enumerateAvailableRowViewsUsing(handler: (NSTableRowView, Int) -&gt; Void)<br>&gt;&gt;&gt;  +  func enumerateAvailableRowViews(block handler: (NSTableRowView, Int) -&gt; Void)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; — Radek<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 27 Jan 2016, at 08:50, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 25, 2016, at 6:55 AM, Radosław Pietruszewski &lt;radexpl at gmail.com &lt;mailto:radexpl at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I’m overwhelmingly *for* this proposal. I think removing needless verbosity and keeping the signal-to-noise ratio high is one of the most immediately appealing aspects of Swift, as well as a great general improvement to the programming experience.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; And so unswiftified (yes, it’s a word now) APIs from Objective-C stick out like a sore thumb. Not only are they harder to read and write, they visually overwhelm the less verbose, information-dense Swift-first code.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Just like previous 1.0—2.0 attempts at bridging the gap (with NSError params being translated to Swift errors, factory methods translated to initializers, etc.), automating this will be an error-prone process, and almost bound to be a bit annoying at first, before all the glitches and poor translations are smoothed out. And yet I feel like just like the previous automated translations were overwhelmingly a great thing, so will the result of this proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; * * *<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    Add First Argument Labels<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    - func enumerateObjectsWith(_: NSEnumerationOptions = [], using: (AnyObject, UnsafeMutablePointer) -&gt; Void)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    + func enumerateObjects(options _: NSEnumerationOptions = [], using: (AnyObject, UnsafeMutablePointer) -&gt; Void)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Good! The Guidelines recommend an explicit first parameter label for arguments with a default value, but this is a good change also for another reason, a use case not included in the Guidelines (I have more to say about this in the SE-0023 thread):<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; “Options” is the description of the parameter, not the method itself. Even if (for whatever reason!) `options` didn’t have a default value and the word “Options” wasn’t omitted in the translation,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;    enumerateObjects(options: …)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; would be clearer than<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;    enumerateObjectsWithOptions(…)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It’s not even about the extra word, about the four useless characters, it’s simply that “WithOptions” doesn’t describe the operation at all. It’s a word that conveys no information (“with”), and “options”, which describes the first parameter. In Objective-C, there’s no such thing as parameter labels, it’s all one name, so “With” is used as a separator. But in Swift, making the first parameter’s label explicit just makes more sense.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That’s an interesting thought! If “with” is truly used as a convention for separating the description of the operation from the description of the first parameter, that’s something that can be codified in the Clang importer. I was curious, so I hacked it up. Here’s a diff of the Cocoa APIs that shows what things would look like if we treated “with” as a separator:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	https://github.com/apple/swift-3-api-guidelines-review/pull/5/files &lt;https://github.com/apple/swift-3-api-guidelines-review/pull/5/files&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It’s a diff against SE-0005, and it introduces a significant number of first argument labels. Indeed, you’ll need to grab the patch to see them all:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	https://github.com/apple/swift-3-api-guidelines-review/pull/5.patch &lt;https://github.com/apple/swift-3-api-guidelines-review/pull/5.patch&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; A brief survey shows that some cases seem to be lining up with the guideline proposals that have been under discussion. For example, the patch includes:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -  func fillWith(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt;&gt; -  func strokeWith(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt;&gt; +  func fill(blendMode blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt;&gt; +  func stroke(blendMode blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -  func encodeWith(aCoder: Coder)<br>&gt;&gt;&gt;&gt;&gt; +  func encode(coder aCoder: Coder)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; which you might recognize, because it’s the example you used:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; And with that in mind, I object to these translations:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;    func fillWith(_: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt;&gt;&gt;    func strokeWith(_: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt;&gt;&gt;    func encodeWith(_: Coder)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Even though these don’t have default values, I believe this version to be clearer and make more sense, even if slightly more verbose:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;    func fill(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt;&gt;&gt;    func stroke(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt;&gt;&gt;    func encode(coder: Coder)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Another random interesting example I encountered:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -  func addArcWithCenter(center: CGPoint, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: Bool)<br>&gt;&gt;&gt;&gt;&gt; +  func addArc(center center: CGPoint, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: Bool)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; which seems to match the idea behind Erica’s &quot;semantic relationship between the parameters is stronger than their relation to the operation” (or Paul Cantrell’s similar notion of &quot;the direct object is several args taken together”, which feels more in line with the way the API guidelines are written).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There’s also this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -  func tracksWithMediaType(mediaType: String) -&gt; [AVMovieTrack]<br>&gt;&gt;&gt;&gt;&gt; +  func tracks(mediaType mediaType: String) -&gt; [AVMovieTrack]<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -  func tracksWithMediaCharacteristic(mediaCharacteristic: String) -&gt;<br>&gt;&gt;&gt;&gt;&gt; +  func tracks(mediaCharacteristic mediaCharacteristic: String) -&gt; [AVMovieTrack]<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; which feels reminiscent of Paul’s “resource” example:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     service.resource(&quot;/foo&quot;)<br>&gt;&gt;&gt;&gt;&gt;     service.resource(absoluteURL: &quot;http://bar.com &lt;http://bar.com/&gt;&quot;)<br>&gt;&gt;&gt;&gt;&gt;     service.resource(absoluteURL: NSURL(string: &quot;http://bar.com &lt;http://bar.com/&gt;&quot;))<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; where (I think) the argument is that the various methods should all have the same base name because they’re all returning “tracks” or a “resource”, respectively.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There is a ton of data in that patch. I’d be interested to hear whether the resulting Cocoa APIs feel better in Swift—are they following the evolving set of guidelines for first argument labels that are under discussion, and are the resulting APIs clearer/more Swifty? What specific APIs work well and where does this “with-as-separator” heuristic break down?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/2c3c065a/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January 29, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; The review of SE-0005&quot;Better Translation of Objective-C APIs Into Swift&quot; begins now and runs through January 31, 2016. The proposal is available here:<br></p><p>Specific comments:<br></p><p>&gt; 	• When the Objective-C type is a block, the type name is &quot;Block.&quot;<br></p><p><br>I think we should also consider &quot;Handler&quot; to be a type name for a block. The word appears in many Cocoa APIs, and it basically just means &quot;probably-escaping block&quot;. Moreover, it&#39;s applied *inconsistently*; for instance, older APIs often say &quot;completionHandler&quot; where more recent APIs say &quot;completion&quot;. I don&#39;t believe it carries much additional meaning and trimming it would improve API consistency.<br></p><p>&gt; extension UIViewController {<br>&gt;   func dismissAnimated(flag: Bool, completion: (() -&gt; Void)? = nil)<br>&gt; }<br></p><p>I believe this should be translated as `dismiss(animated flag: Bool, completion: (() -&gt; Void)? = nil)`. (Note the label on the first argument.) This pattern appears throughout the UI frameworks, particularly UIKit, and it always means exactly the same thing. Whether or not the operation is animated is fundamentally an option on the method, not a fundamental aspect of the operation. Though we don&#39;t supply a default for it, and I don&#39;t suggest we ought to, we very reasonably could.<br></p><p>I don&#39;t think there&#39;s a very large rule here—just `fooAnimated(_: Bool)` should be `foo(animated: Bool)`.<br></p><p>&gt; 	• What is your evaluation of the proposal?<br></p><p>Overall, I think this dramatically improves most Cocoa APIs. +1.<br></p><p>&gt; 	• Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes.<br></p><p>&gt; 	• Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes, particularly with the introduction of the API Guidelines.<br></p><p>&gt; 	• If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>Well, I&#39;ve tried using RubyCocoa and its ilk; does that count? This is way better than any of that stuff.<br></p><p>&gt; 	• How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I&#39;d say a quick reading, plus a read-through of the API Guidelines thread and this thread.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>January 30, 2016 at 05:00:00pm</p></header><div class="content"><p>I am in favor of this proposal on balance, and I leave the bulk of this to people who interop with Objective-C more often than I do.<br></p><p>I would like to confine my remarks to one corner where I think we are making a very serious mistake.<br></p><p>&gt; The removal of the &quot;NS&quot; prefix for the Foundation module (or other specifically identified modules) is a mechanical translation for all global symbols defined within that module that can be performed in the Clang importer. <br></p><p><br>As I understand it (and I am no Cocoa historian) the NS prefix was originally introduced because Objective-C lacks namespacing.<br></p><p>The thinking seems to be that since Swift has proper namespacing, this historicism is no longer necessary.  I find this argument very flimsy.<br></p><p>Of course Swift has stronger namespacing if one&#39;s frame of reference is Objective-C or C.  But for those of us coming from other language backgrounds, namespacing means something much stronger than Swift&#39;s concept of it.  I don&#39;t mean to suggest that Swift&#39;s design is wrong exactly (less is sometimes more), but I do mean to say that if we propose to undo a decision that worked for several decades and break every Swift project in existence on the theory that Swift&#39;s namespacing is strong enough we had better be right.<br></p><p>For those unfamiliar, I will explain some of the namespacing tools Swift lacks relative to other languages.  First, many languages have a &quot;hierarchical&quot; namespace system, where one can say<br></p><p>import Foundation.Net.URL<br>let s = Session(...)<br></p><p>instead of for example<br></p><p>import Foundation<br>let s = NSURLSession(...)<br></p><p>Some form of this is used in Rust, Python, and C#, as far as I know.  I believe Swift has some counterfeit version of this, as the book mentions you can import a &quot;submodule &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/import-declaration&gt;&quot;, but I do not know what that is, do not know how to make one, have never seen anyone use one, the book suggests it goes only 2 levels deep, and perhaps as a consequences of some of these problems nobody thought of using this for Foundation.<br></p><p>A closely related difference is the use of so-called &quot;selective&quot; imports, where we import only a single symbol (or a list of explicitly-identified symbols) into the scope.  We might express this as<br></p><p>from Foundation.Net.URL import Session, HTTP //import two classes only<br>let s = Session(...)<br></p><p>Again I think Swift technically supports some way to avoid importing a whole gigantic namespace like Foundation, but I am not aware of any actual uses of this feature, and certainly the convention is not to write code this way.  Meanwhile, let&#39;s check in with the Python community, who standardized the following guidance on these &quot;wildcard&quot; imports as part of their language evolution process:<br></p><p>&gt; Wildcard imports ( from &lt;module&gt; import * ) should be avoided, as they make it unclear which names are present in the namespace, confusing both readers and many automated tools. There is one defensible use case for a wildcard import...<br></p><p>When a language has a robust namespacing system, which we do not, there are many follow-on consequences.  One is that an import statement is much more of a scalpel than a bludgeon; each import statement only introduces a handful of new names (even if it is a so-called &quot;wildcard&quot; import that grabs all children of some namespace, most of those children are themselves namespaces), unlike importing Foundation which contains thousands of direct child types that are injected into the local scope.<br></p><p>Another consequence is that class names become quite short, shadow each other, and nobody bats an eye.  I searched the C# standard library for &quot;Session&quot;, and found some 12 classes with that name:<br></p><p><br></p><p>These &quot;standard library&quot; classes not only potentially shadow programmer-defined types, they also shadow each other.  But because the C# language has a robust namespacing system, the chances of there being more than one thing called &quot;Session&quot; in scope in your program (or for that matter, when developing the standard library itself) is quite small, so it&#39;s a non-issue.<br></p><p>Now we return to the question of dropping the NS prefix, which will rename thousands of classes in a typical program that has `import Foundation`, in a way that potentially (let&#39;s be honest.  More like &quot;probably&quot;) shadows one or more programmer-defined classes.  Our review criteria is:<br></p><p>&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p><br>No, the elimination of 2 characters is not significant enough of a problem to break all Swift programs, let alone to introduce literally thousands of new opportunities for shadowing.<br></p><p>To its credit, the proposal acknowledges this, and offers a concession:<br></p><p>&gt; Note that this removal can create conflicts with the standard library. For example, NSString and NSArray will become String and Array, respectively, and Foundation&#39;s versions will shadow the standard library&#39;s versions.  In cases where the Swift 3 names of standard library entities conflict with prefix-stripped Foundation entities, we retain the NS prefix. These Foundation entities are: NSArray, NSDictionary, NSInteger, NSRange, NSSet, and NSString.<br></p><p>But of course this needlessly draws a distinction between NSString et al and the &quot;normal&quot; Foundation types, and what&#39;s more it draws that distinction based on the present composition of the Swift standard library and the present composition of Foundation.  But we have already decided not to guarantee the source compatibility of the standard library, so what happens when that composition changes?  Will we then go back and tweak which classes get NS prefixed to them again?<br></p><p>In my view, if Swift&#39;s namespacing is not good enough to let us drop the NS in NSString it is not good enough to drop any prefix.  If we believe that a programmer will struggle to distinguish between Swift String and Foundation String then we should expect them to struggle for any two classes in any two frameworks, and this is special pleading on the part of Foundation.  C#&#39;s libraries declare *twelve* different `Session`s and nobody bats an eye, but we have two types share a name and everybody loses their minds?  Our namespacing is not good enough to kill the prefix, period.<br></p><p>We should either drop these prefixes or we should not; because the claimed motivation–that we have &quot;good enough&quot; namespacing in the language now–is either true or it is not.  This proposal admits that it is not, and tries to drop the prefixes anyway.  I believe that is a mistake.<br></p><p>I certainly support the goal of eliminating these prefixes, they are ugly, they need to be killed, and namespacing is the right solution.  But we must not jump out of the plane until we are very sure our parachute is in order.  In Swift 3 it is not.<br></p><p>I do think the bulk of the proposal is fine, and I apologize for using quite stark language for such a small paragraph in an otherwise reasonable proposal, but I think the problem buried in here is quite serious and is being overlooked.<br></p><p>Drew<br></p><p><br>&gt; On Jan 22, 2016, at 3:02 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of SE-0005&quot;Better Translation of Objective-C APIs Into Swift&quot; begins now and runs through January 31, 2016. The proposal is available here:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br>&gt; <br>&gt; Proposal link:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md&gt;<br>&gt; Reply text<br>&gt; <br>&gt; Other replies<br>&gt;  &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; What is your evaluation of the proposal?<br>&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt; Thank you,<br>&gt; <br>&gt; -Doug Gregor<br>&gt; <br>&gt; Review Manager<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160130/15501aca/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: Screen Shot 2016-01-30 at 3.44.23 PM.png<br>Type: image/png<br>Size: 231549 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160130/15501aca/attachment.png&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be4c3c3b76631a155e1358db48066692?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Tony Parker</string> &lt;anthony.parker at apple.com&gt;<p>February  1, 2016 at 11:00:00am</p></header><div class="content"><p>Hi Drew,<br></p><p>&gt; On Jan 30, 2016, at 3:01 PM, Drew Crawford via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I am in favor of this proposal on balance, and I leave the bulk of this to people who interop with Objective-C more often than I do.<br>&gt; <br>&gt; I would like to confine my remarks to one corner where I think we are making a very serious mistake.<br>&gt; <br>&gt;&gt; The removal of the &quot;NS&quot; prefix for the Foundation module (or other specifically identified modules) is a mechanical translation for all global symbols defined within that module that can be performed in the Clang importer. <br>&gt; <br>&gt; <br>&gt; As I understand it (and I am no Cocoa historian) the NS prefix was originally introduced because Objective-C lacks namespacing.<br>&gt; <br>&gt; The thinking seems to be that since Swift has proper namespacing, this historicism is no longer necessary.  I find this argument very flimsy.<br>&gt; <br>&gt; Of course Swift has stronger namespacing if one&#39;s frame of reference is Objective-C or C.  But for those of us coming from other language backgrounds, namespacing means something much stronger than Swift&#39;s concept of it.  I don&#39;t mean to suggest that Swift&#39;s design is wrong exactly (less is sometimes more), but I do mean to say that if we propose to undo a decision that worked for several decades and break every Swift project in existence on the theory that Swift&#39;s namespacing is strong enough we had better be right.<br>&gt; <br>&gt; For those unfamiliar, I will explain some of the namespacing tools Swift lacks relative to other languages.  First, many languages have a &quot;hierarchical&quot; namespace system, where one can say<br>&gt; <br>&gt; import Foundation.Net.URL<br>&gt; let s = Session(...)<br>&gt; <br>&gt; instead of for example<br>&gt; <br>&gt; import Foundation<br>&gt; let s = NSURLSession(...)<br>&gt; <br>&gt; Some form of this is used in Rust, Python, and C#, as far as I know.  I believe Swift has some counterfeit version of this, as the book mentions you can import a &quot;submodule &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/import-declaration&gt;&quot;, but I do not know what that is, do not know how to make one, have never seen anyone use one, the book suggests it goes only 2 levels deep, and perhaps as a consequences of some of these problems nobody thought of using this for Foundation.<br>&gt; <br>&gt; A closely related difference is the use of so-called &quot;selective&quot; imports, where we import only a single symbol (or a list of explicitly-identified symbols) into the scope.  We might express this as<br>&gt; <br>&gt; from Foundation.Net.URL import Session, HTTP //import two classes only<br>&gt; let s = Session(...)<br>&gt; <br>&gt; Again I think Swift technically supports some way to avoid importing a whole gigantic namespace like Foundation, but I am not aware of any actual uses of this feature, and certainly the convention is not to write code this way.  Meanwhile, let&#39;s check in with the Python community, who standardized the following guidance on these &quot;wildcard&quot; imports as part of their language evolution process:<br>&gt; <br>&gt;&gt; Wildcard imports ( from &lt;module&gt; import * ) should be avoided, as they make it unclear which names are present in the namespace, confusing both readers and many automated tools. There is one defensible use case for a wildcard import...<br>&gt; <br>&gt; When a language has a robust namespacing system, which we do not, there are many follow-on consequences.  One is that an import statement is much more of a scalpel than a bludgeon; each import statement only introduces a handful of new names (even if it is a so-called &quot;wildcard&quot; import that grabs all children of some namespace, most of those children are themselves namespaces), unlike importing Foundation which contains thousands of direct child types that are injected into the local scope.<br>&gt; <br>&gt; Another consequence is that class names become quite short, shadow each other, and nobody bats an eye.  I searched the C# standard library for &quot;Session&quot;, and found some 12 classes with that name:<br>&gt; <br>&gt; &lt;Screen Shot 2016-01-30 at 3.44.23 PM.png&gt;<br>&gt; <br>&gt; These &quot;standard library&quot; classes not only potentially shadow programmer-defined types, they also shadow each other.  But because the C# language has a robust namespacing system, the chances of there being more than one thing called &quot;Session&quot; in scope in your program (or for that matter, when developing the standard library itself) is quite small, so it&#39;s a non-issue.<br>&gt; <br>&gt; Now we return to the question of dropping the NS prefix, which will rename thousands of classes in a typical program that has `import Foundation`, in a way that potentially (let&#39;s be honest.  More like &quot;probably&quot;) shadows one or more programmer-defined classes.  Our review criteria is:<br>&gt; <br>&gt;&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; <br>&gt; <br>&gt; No, the elimination of 2 characters is not significant enough of a problem to break all Swift programs, let alone to introduce literally thousands of new opportunities for shadowing.<br>&gt; <br>&gt; To its credit, the proposal acknowledges this, and offers a concession:<br>&gt; <br>&gt;&gt; Note that this removal can create conflicts with the standard library. For example, NSString and NSArray will become String and Array, respectively, and Foundation&#39;s versions will shadow the standard library&#39;s versions.  In cases where the Swift 3 names of standard library entities conflict with prefix-stripped Foundation entities, we retain the NS prefix. These Foundation entities are: NSArray, NSDictionary, NSInteger, NSRange, NSSet, and NSString.<br>&gt; <br>&gt; But of course this needlessly draws a distinction between NSString et al and the &quot;normal&quot; Foundation types, and what&#39;s more it draws that distinction based on the present composition of the Swift standard library and the present composition of Foundation.  But we have already decided not to guarantee the source compatibility of the standard library, so what happens when that composition changes?  Will we then go back and tweak which classes get NS prefixed to them again?<br>&gt; <br>&gt; In my view, if Swift&#39;s namespacing is not good enough to let us drop the NS in NSString it is not good enough to drop any prefix.  If we believe that a programmer will struggle to distinguish between Swift String and Foundation String then we should expect them to struggle for any two classes in any two frameworks, and this is special pleading on the part of Foundation.  C#&#39;s libraries declare *twelve* different `Session`s and nobody bats an eye, but we have two types share a name and everybody loses their minds?  Our namespacing is not good enough to kill the prefix, period.<br></p><p>I’m actually not sure how this line about shadowing ended up in the guidelines, because it is not our plan. Instead, I have always wanted to do something very close to what you suggest and rename these to something like “Dynamic.Array” to reflect its role as a dynamically-dispatched, subclass-capable Array.<br></p><p>Types like NSURL are intended to be the canonical URL for everyone to use, so for me it feels very natural to drop the prefix and make them as accessible as Array, String, etc.<br></p><p>- Tony<br></p><p>&gt; <br>&gt; We should either drop these prefixes or we should not; because the claimed motivation–that we have &quot;good enough&quot; namespacing in the language now–is either true or it is not.  This proposal admits that it is not, and tries to drop the prefixes anyway.  I believe that is a mistake.<br>&gt; <br>&gt; I certainly support the goal of eliminating these prefixes, they are ugly, they need to be killed, and namespacing is the right solution.  But we must not jump out of the plane until we are very sure our parachute is in order.  In Swift 3 it is not.<br>&gt; <br>&gt; I do think the bulk of the proposal is fine, and I apologize for using quite stark language for such a small paragraph in an otherwise reasonable proposal, but I think the problem buried in here is quite serious and is being overlooked.<br>&gt; <br>&gt; Drew<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 22, 2016, at 3:02 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of SE-0005&quot;Better Translation of Objective-C APIs Into Swift&quot; begins now and runs through January 31, 2016. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md&gt;<br>&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt; <br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br>&gt;&gt; <br>&gt;&gt; Proposal link:<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md&gt;<br>&gt;&gt; Reply text<br>&gt;&gt; <br>&gt;&gt; Other replies<br>&gt;&gt;  &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What goes into a review?<br>&gt;&gt; <br>&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt; <br>&gt;&gt; What is your evaluation of the proposal?<br>&gt;&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt;&gt; Thank you,<br>&gt;&gt; <br>&gt;&gt; -Doug Gregor<br>&gt;&gt; <br>&gt;&gt; Review Manager<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/7433e56a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>February  1, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Feb 1, 2016, at 1:02 PM, Tony Parker &lt;anthony.parker at apple.com&gt; wrote:<br>&gt; <br>&gt; Types like NSURL are intended to be the canonical URL for everyone to use,<br></p><p><br>I think the &quot;canonical URL for everyone to use&quot; must be a value type / struct.  To me this seems axiomatic.<br></p><p>Meanwhile (NS)URL cannot be a value type because of the Darwin compatibility mandate, and to change from value-&gt;reference semantics would be &quot;off the charts&quot; breakage severity.<br></p><p>This is a requirements conflict.  corelibs-foundation can either be Darwin-compatible or it can be canonical, but we cannot do both.  Right now we have chosen Darwin-compatible, so we must let the canonical requirement go.   Unprefixed &quot;URL&quot; should be reserved for the value type that can actually work as a canonical API.<br></p><p>It&#39;s not clear to me if Foundation will actually be in a position to provide that API (e.g. in Swift 4, etc.) or whether some third party will provide a &quot;URL&quot; framework that gains traction first.  But in any case, we are not going to do it in the Swift 3 window, unless a lot of core scope decisions get re-decided.<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/bfda8a5b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>February  1, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Feb 1, 2016, at 1:38 PM, Drew Crawford &lt;drew at sealedabstract.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 1, 2016, at 1:02 PM, Tony Parker &lt;anthony.parker at apple.com &lt;mailto:anthony.parker at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Types like NSURL are intended to be the canonical URL for everyone to use,<br>&gt; <br>&gt; <br>&gt; I think the &quot;canonical URL for everyone to use&quot; must be a value type / struct.  To me this seems axiomatic.<br>&gt; <br>&gt; Meanwhile (NS)URL cannot be a value type because of the Darwin compatibility mandate, and to change from value-&gt;reference semantics would be &quot;off the charts&quot; breakage severity.<br>&gt; <br>&gt; This is a requirements conflict.  corelibs-foundation can either be Darwin-compatible or it can be canonical, but we cannot do both.  Right now we have chosen Darwin-compatible, so we must let the canonical requirement go.   Unprefixed &quot;URL&quot; should be reserved for the value type that can actually work as a canonical API.<br></p><p>One could imagine bridging NSURL to a value type URL (provided by Foundation, and initially implemented as a value-semantic wrapper around NSURL), the same way we bridge NSArray/NSDictionary/NSSet/NSString. <br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/79e34d95/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>February  1, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Feb 1, 2016, at 3:40 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; One could imagine bridging NSURL to a value type URL (provided by Foundation, and initially implemented as a value-semantic wrapper around NSURL), the same way we bridge NSArray/NSDictionary/NSSet/NSString. <br></p><p>We would have to make that change to Darwin Foundation in the Swift 3 timeframe as well, since deviations from Darwin Foundation are currently considered bugs.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/b51edcbe/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>February  1, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Feb 1, 2016, at 3:40 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Feb 1, 2016, at 1:38 PM, Drew Crawford &lt;drew at sealedabstract.com &lt;mailto:drew at sealedabstract.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 1, 2016, at 1:02 PM, Tony Parker &lt;anthony.parker at apple.com &lt;mailto:anthony.parker at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Types like NSURL are intended to be the canonical URL for everyone to use,<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I think the &quot;canonical URL for everyone to use&quot; must be a value type / struct.  To me this seems axiomatic.<br>&gt;&gt; <br>&gt;&gt; Meanwhile (NS)URL cannot be a value type because of the Darwin compatibility mandate, and to change from value-&gt;reference semantics would be &quot;off the charts&quot; breakage severity.<br>&gt;&gt; <br>&gt;&gt; This is a requirements conflict.  corelibs-foundation can either be Darwin-compatible or it can be canonical, but we cannot do both.  Right now we have chosen Darwin-compatible, so we must let the canonical requirement go.   Unprefixed &quot;URL&quot; should be reserved for the value type that can actually work as a canonical API.<br>&gt; <br>&gt; One could imagine bridging NSURL to a value type URL (provided by Foundation, and initially implemented as a value-semantic wrapper around NSURL), the same way we bridge NSArray/NSDictionary/NSSet/NSString. <br></p><p>Sure, and that would be perfectly acceptable.  If that (or something similar) is the long-term plan it seems like a particularly bad idea to drop `NS` from them right now.  <br></p><p>That would mean we have a `URL` reference type in Swift 3 Foundation which becomes a value type in a future Swift X Foundation.  This change would likely be very problematic.<br></p><p>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/f233a58c/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>February  1, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Feb 1, 2016, at 3:38 PM, Drew Crawford via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 1, 2016, at 1:02 PM, Tony Parker &lt;anthony.parker at apple.com &lt;mailto:anthony.parker at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Types like NSURL are intended to be the canonical URL for everyone to use,<br>&gt; <br>&gt; <br>&gt; I think the &quot;canonical URL for everyone to use&quot; must be a value type / struct.  To me this seems axiomatic.<br>&gt; <br>&gt; Meanwhile (NS)URL cannot be a value type because of the Darwin compatibility mandate, and to change from value-&gt;reference semantics would be &quot;off the charts&quot; breakage severity.<br>&gt; <br>&gt; This is a requirements conflict.  corelibs-foundation can either be Darwin-compatible or it can be canonical, but we cannot do both.  Right now we have chosen Darwin-compatible, so we must let the canonical requirement go.   Unprefixed &quot;URL&quot; should be reserved for the value type that can actually work as a canonical API.<br></p><p>+1.  I was pretty shocked by that sentence as well.  The intention to canonize reference types just because they already exist could not be INVHO further from the right intention for Swift.  I understand and accept the short-term rationale for leveraging them.  I do not understand why we would settle for them as the long-term canonical solution.<br></p><p>&gt; <br>&gt; It&#39;s not clear to me if Foundation will actually be in a position to provide that API (e.g. in Swift 4, etc.) or whether some third party will provide a &quot;URL&quot; framework that gains traction first.  But in any case, we are not going to do it in the Swift 3 window, unless a lot of core scope decisions get re-decided.<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/7074cf7d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be4c3c3b76631a155e1358db48066692?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Tony Parker</string> &lt;anthony.parker at apple.com&gt;<p>February  1, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Feb 1, 2016, at 1:49 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 1, 2016, at 3:38 PM, Drew Crawford via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 1, 2016, at 1:02 PM, Tony Parker &lt;anthony.parker at apple.com &lt;mailto:anthony.parker at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Types like NSURL are intended to be the canonical URL for everyone to use,<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I think the &quot;canonical URL for everyone to use&quot; must be a value type / struct.  To me this seems axiomatic.<br>&gt;&gt; <br>&gt;&gt; Meanwhile (NS)URL cannot be a value type because of the Darwin compatibility mandate, and to change from value-&gt;reference semantics would be &quot;off the charts&quot; breakage severity.<br>&gt;&gt; <br>&gt;&gt; This is a requirements conflict.  corelibs-foundation can either be Darwin-compatible or it can be canonical, but we cannot do both.  Right now we have chosen Darwin-compatible, so we must let the canonical requirement go.   Unprefixed &quot;URL&quot; should be reserved for the value type that can actually work as a canonical API.<br>&gt; <br>&gt; +1.  I was pretty shocked by that sentence as well.  The intention to canonize reference types just because they already exist could not be INVHO further from the right intention for Swift.  I understand and accept the short-term rationale for leveraging them.  I do not understand why we would settle for them as the long-term canonical solution.<br>&gt; <br></p><p>Foundation is not a short term library. The reason we put it into Swift core libraries is because we intend for it to provide the most commonly needed functionality in one well-known, well-maintained place.<br></p><p>Dropping the NS is one part of how we intend to make Foundation a great part of Swift. We are working on other ways as well.<br></p><p>- Tony<br></p><p>&gt;&gt; <br>&gt;&gt; It&#39;s not clear to me if Foundation will actually be in a position to provide that API (e.g. in Swift 4, etc.) or whether some third party will provide a &quot;URL&quot; framework that gains traction first.  But in any case, we are not going to do it in the Swift 3 window, unless a lot of core scope decisions get re-decided.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/d5cd5a9b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>February  1, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Feb 1, 2016, at 4:08 PM, Tony Parker &lt;anthony.parker at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Feb 1, 2016, at 1:49 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 1, 2016, at 3:38 PM, Drew Crawford via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 1, 2016, at 1:02 PM, Tony Parker &lt;anthony.parker at apple.com &lt;mailto:anthony.parker at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Types like NSURL are intended to be the canonical URL for everyone to use,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think the &quot;canonical URL for everyone to use&quot; must be a value type / struct.  To me this seems axiomatic.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Meanwhile (NS)URL cannot be a value type because of the Darwin compatibility mandate, and to change from value-&gt;reference semantics would be &quot;off the charts&quot; breakage severity.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a requirements conflict.  corelibs-foundation can either be Darwin-compatible or it can be canonical, but we cannot do both.  Right now we have chosen Darwin-compatible, so we must let the canonical requirement go.   Unprefixed &quot;URL&quot; should be reserved for the value type that can actually work as a canonical API.<br>&gt;&gt; <br>&gt;&gt; +1.  I was pretty shocked by that sentence as well.  The intention to canonize reference types just because they already exist could not be INVHO further from the right intention for Swift.  I understand and accept the short-term rationale for leveraging them.  I do not understand why we would settle for them as the long-term canonical solution.<br>&gt;&gt; <br>&gt; <br>&gt; Foundation is not a short term library. The reason we put it into Swift core libraries is because we intend for it to provide the most commonly needed functionality in one well-known, well-maintained place.<br></p><p>I applaud making the functionality available in a single source.  My objection is specifically focused on adopting reference types where value types make sense just because they already exist in Foundation.<br></p><p>&gt; <br>&gt; Dropping the NS is one part of how we intend to make Foundation a great part of Swift. We are working on other ways as well.<br></p><p>I hope that transitioning to value types where that is the more Swifty design is a part of that plan if we’re going to stick with Foundation (which is fine as long as it doesn’t interfere with the desire for value types).<br></p><p>-Matthew<br></p><p>&gt; <br>&gt; - Tony<br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s not clear to me if Foundation will actually be in a position to provide that API (e.g. in Swift 4, etc.) or whether some third party will provide a &quot;URL&quot; framework that gains traction first.  But in any case, we are not going to do it in the Swift 3 window, unless a lot of core scope decisions get re-decided.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/41e89fed/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>February  1, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Feb 1, 2016, at 4:08 PM, Tony Parker &lt;anthony.parker at apple.com&gt; wrote:<br>&gt; <br>&gt; Dropping the NS is one part of how we intend to make Foundation a great part of Swift. <br></p><p>This kind of response highlights I think an important disconnect between Foundation maintainers and some of us in the peanut gallery, along &quot;cathedral/bazaar&quot; lines.<br></p><p>In my mind, it is very far from certain that Foundation will be the &quot;other standard&quot; Swift library.  Like, I realize that is the goal, I realize that&#39;s what it says in the README, I realize I am contributing PRs to make it happen in the other window right now, but not all plans work out, right?<br></p><p>Foundation exists in an ecosystem, and it will face challenges from other approaches.  Foundation has taken its position.  Foundation has elected to be a monolithic library.  It has elected, in the Swift 3 timeframe to stay close to Darwin API surface.  It has elected not to initially target Darwin as a runtime environment.<br></p><p>But other tradeoffs were possible, and will be explored, and are being explored, by others.  I am constantly evaluating my Foundation dependency to see if keeping it makes sense.  I know very bright people who have already decided it does not.  I am not there quite yet, but I sense the hour growing later.<br></p><p>But the decision to ship a reference-type called `URL` in Swift 3 would probably put me there.  The decision to draw a distinction between `NSString` et al and the other Foundation types would probably put me there.  These are not decisions that are compatible with the Swift code I want to write, now or in the future.<br></p><p>I understand that you believe this change is part of &quot;making Swift great.&quot;  But there is room for debate about what &quot;great&quot; is, because in an open ecosystem, each project will make its choice whether to link Foundation or not.  Right now, Linux-target projects link with Foundation because there are no alternatives, but that will change presently.<br></p><p>For all the reasons in my review (and I separately concur with Nate), I believe that dropping the NS prefix on the present classes as they are implemented now (e.g. NSURL, etc.) is absolutely the wrong thing to do.  If we do it, it will confirm for me that my vision for a standard library and Foundation&#39;s are very different, and I need to start moving out of mom&#39;s house.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/b154359d/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0089229ece6e648767cff4dc6c6d38ab?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Charles Kissinger</string> &lt;crk at akkyra.com&gt;<p>February  1, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Feb 1, 2016, at 2:08 PM, Tony Parker via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Feb 1, 2016, at 1:49 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 1, 2016, at 3:38 PM, Drew Crawford via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 1, 2016, at 1:02 PM, Tony Parker &lt;anthony.parker at apple.com &lt;mailto:anthony.parker at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Types like NSURL are intended to be the canonical URL for everyone to use,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think the &quot;canonical URL for everyone to use&quot; must be a value type / struct.  To me this seems axiomatic.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Meanwhile (NS)URL cannot be a value type because of the Darwin compatibility mandate, and to change from value-&gt;reference semantics would be &quot;off the charts&quot; breakage severity.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a requirements conflict.  corelibs-foundation can either be Darwin-compatible or it can be canonical, but we cannot do both.  Right now we have chosen Darwin-compatible, so we must let the canonical requirement go.   Unprefixed &quot;URL&quot; should be reserved for the value type that can actually work as a canonical API.<br>&gt;&gt; <br>&gt;&gt; +1.  I was pretty shocked by that sentence as well.  The intention to canonize reference types just because they already exist could not be INVHO further from the right intention for Swift.  I understand and accept the short-term rationale for leveraging them.  I do not understand why we would settle for them as the long-term canonical solution.<br>&gt;&gt; <br>&gt; <br>&gt; Foundation is not a short term library. The reason we put it into Swift core libraries is because we intend for it to provide the most commonly needed functionality in one well-known, well-maintained place.<br></p><p>I don’t think anyone is thinking of Foundation as a short term library. I do think, though, that a lot of people will be disappointed if there is not a fairly short term plan to introduce types with value semantics into Foundation that would supersede some of the existing reference types. If that is going to happen, dropping NS would seem to complicate that significantly.<br></p><p>—CK<br></p><p>&gt; Dropping the NS is one part of how we intend to make Foundation a great part of Swift. We are working on other ways as well.<br>&gt; <br>&gt; - Tony<br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s not clear to me if Foundation will actually be in a position to provide that API (e.g. in Swift 4, etc.) or whether some third party will provide a &quot;URL&quot; framework that gains traction first.  But in any case, we are not going to do it in the Swift 3 window, unless a lot of core scope decisions get re-decided.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/a50ffea0/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d1bff9080a4237cc9b79c5751afb6f7?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Jarod Long</string> &lt;swift at lng.la&gt;<p>February  1, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Feb 1, 2016, at 13:38, Drew Crawford via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Feb 1, 2016, at 1:02 PM, Tony Parker &lt;anthony.parker at apple.com &lt;mailto:anthony.parker at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Types like NSURL are intended to be the canonical URL for everyone to use,<br>&gt; <br>&gt; <br>&gt; I think the &quot;canonical URL for everyone to use&quot; must be a value type / struct.  To me this seems axiomatic.<br>&gt; <br>&gt; Meanwhile (NS)URL cannot be a value type because of the Darwin compatibility mandate, and to change from value-&gt;reference semantics would be &quot;off the charts&quot; breakage severity.<br>&gt; <br>&gt; This is a requirements conflict.  corelibs-foundation can either be Darwin-compatible or it can be canonical, but we cannot do both.  Right now we have chosen Darwin-compatible, so we must let the canonical requirement go.   Unprefixed &quot;URL&quot; should be reserved for the value type that can actually work as a canonical API.<br>&gt; <br>&gt; It&#39;s not clear to me if Foundation will actually be in a position to provide that API (e.g. in Swift 4, etc.) or whether some third party will provide a &quot;URL&quot; framework that gains traction first.  But in any case, we are not going to do it in the Swift 3 window, unless a lot of core scope decisions get re-decided.<br></p><p>This is a major concern for me as well. I would much rather put up with NS prefixes for a while longer if it means we can improve on Foundation in the future. I think it would be very unfortunate if we forever locked ourselves into Swift anti-patterns like a reference-based URL type (among certainly many others) in what is intended to be like an extension to the Swift standard library.<br></p><p>Jarod<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/ffc67e3b/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5f463dd4e7af28b64ad8f0e032ee82dc?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Nate Cook</string> &lt;natecook at gmail.com&gt;<p>February  1, 2016 at 03:00:00pm</p></header><div class="content"><p>This is a concurring opinion with Drew&#39;s review, agreeing that we should reconsider removing the &quot;NS&quot; prefix but providing my own reasons. The proposal as a whole is exciting and far-reaching, but this particular change is misguided. My objections are:<br></p><p>1) The change will elide the different semantic expectations for Foundation and Swift standard library types.<br></p><p>Prefix-less Foundation types will blur the different norms and expectations for Foundation types vs what we have in the Swift standard library, particularly in regards to value vs reference semantics of collection types. <br></p><p>The Swift standard library defines Array, Set, and Dictionary as collection types with value semantics that operate quite differently from their peers in Foundation. This change will introduce OrderedSet, CountedSet, HashTable, MapTable, and others, all of which use reference semantics and therefore don&#39;t provide the same set of guarantees about ownership and immutability.<br></p><p>As an example, the seemingly similar Set and CountedSet types produce different results from nearly identical code. Swift&#39;s Set type has value semantics, so changes to a copy don&#39;t affect the original Set instance:<br></p><p>let simpleSet = Set([&quot;one&quot;, &quot;two&quot;, &quot;three&quot;])<br>var copiedSimpleSet = simpleSet<br>copiedSimpleSet.remove(&quot;one&quot;)<br></p><p>copiedSimpleSet.contains(&quot;one&quot;)  // false<br>simpleSet.contains(&quot;one&quot;)        // true<br></p><p>CountedSet (née NSCountedSet), on the other hand, uses reference semantics, so changes to a copy of an instance. This is true whether the copy is an explicit one made via assignment or the implicit copy made when calling a function with CountedSet as a parameter. This example shows how nearly code nearly identical to the above produces very different results:<br></p><p>let countedSet = CountedSet(array: [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;])<br>var copiedCountedSet = countedSet<br>copiedCountedSet.remove(&quot;one&quot;)<br></p><p>copiedCountedSet.contains(&quot;one&quot;) // false<br>countedSet.contains(&quot;one&quot;)       // false!<br></p><p>Collections constructed from immutable/mutable class clusters (like OrderedSet and MutableOrderedSet) pose the same problems, since you may be using a mutable instance of the &quot;immutable&quot; collection. We clearly are already dealing with this difference today, but eliminating the &quot;NS&quot; prefix implies that Foundation types are on the same level as the standard library. This makes the confusion more pronounced and significantly increases both the learning curve of the Swift &amp; Foundation APIs and the risk of errors when using different collection types.<br></p><p>2) The change may stifle the development of more Swift-oriented APIs.<br></p><p>Foundation types were developed in and for a language that uses reference semantics and subclassing, rather than value semantics and a protocol-oriented approach. The designs therefore use and reinforce norms that relate better to Objective-C than to Swift—class clusters of non-final, immutable types with mutable subclasses, immutable types with separate but related mutable counterparts, etc.<br></p><p>A Swift-native CountedSet (and other collections) would surely have value semantics built in. What about other types—do the new Calendar/Date/DateComponents types look like the system that we would design from the ground up in Swift? How about URL and URLComponents? Dropping the &quot;NS&quot; prefix would make it more difficult to gradually expand the standard library to encompass bridging versions of these and other common types.<br></p><p>3) The change will make it harder to find information about the revised APIs.<br></p><p>Excellent search-ability is an unintended benefit of the &quot;NS&quot; prefix, and can be understood as a way that these types avoid collisions in the vast namespace-less sea of Internet search results. Searching for help with URL and Calendar will be much more difficult than their NS&#39;ed counterparts.<br></p><p>Especially given the challenges that this proposal will pose for code sourced from tutorials, blog posts, Stack Overflow answers, etc., keeping at least the class names as sign posts seems valuable.<br></p><p>4) We&#39;ll still be using prefixes after the change.<br></p><p>While the removal of &quot;NS&quot; is far-reaching, prefixes will still be a common occurrence in code written in Swift. UIKit and AppKit, along with all the various frameworks, will still retain their prefixes, so removing prefixes in the case of Foundation types will be more the exception than the norm. As such, any benefit of the removal would be mitigated by the continued use of prefixes for the rest of the first-party types we rely on.<br></p><p><br>In sum, the change would make the language and its APIs more confusing and more difficult to use today, would make it more difficult to migrate to modern designs in the future, and would ultimately provide a very minor benefit. I encourage the Swift core team to reconsider the &quot;Strip the &quot;NS&quot; prefix from Foundation APIs&quot; portion of the proposal.<br></p><p>Nate<br></p><p><br>&gt; On Jan 30, 2016, at 5:01 PM, Drew Crawford via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I am in favor of this proposal on balance, and I leave the bulk of this to people who interop with Objective-C more often than I do.<br>&gt; <br>&gt; I would like to confine my remarks to one corner where I think we are making a very serious mistake.<br>&gt; <br>&gt;&gt; The removal of the &quot;NS&quot; prefix for the Foundation module (or other specifically identified modules) is a mechanical translation for all global symbols defined within that module that can be performed in the Clang importer. <br>&gt; <br>&gt; <br>&gt; As I understand it (and I am no Cocoa historian) the NS prefix was originally introduced because Objective-C lacks namespacing.<br>&gt; <br>&gt; The thinking seems to be that since Swift has proper namespacing, this historicism is no longer necessary.  I find this argument very flimsy.<br>&gt; <br>&gt; Of course Swift has stronger namespacing if one&#39;s frame of reference is Objective-C or C.  But for those of us coming from other language backgrounds, namespacing means something much stronger than Swift&#39;s concept of it.  I don&#39;t mean to suggest that Swift&#39;s design is wrong exactly (less is sometimes more), but I do mean to say that if we propose to undo a decision that worked for several decades and break every Swift project in existence on the theory that Swift&#39;s namespacing is strong enough we had better be right.<br>&gt; <br>&gt; For those unfamiliar, I will explain some of the namespacing tools Swift lacks relative to other languages.  First, many languages have a &quot;hierarchical&quot; namespace system, where one can say<br>&gt; <br>&gt; import Foundation.Net.URL<br>&gt; let s = Session(...)<br>&gt; <br>&gt; instead of for example<br>&gt; <br>&gt; import Foundation<br>&gt; let s = NSURLSession(...)<br>&gt; <br>&gt; Some form of this is used in Rust, Python, and C#, as far as I know.  I believe Swift has some counterfeit version of this, as the book mentions you can import a &quot;submodule &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/import-declaration&gt;&quot;, but I do not know what that is, do not know how to make one, have never seen anyone use one, the book suggests it goes only 2 levels deep, and perhaps as a consequences of some of these problems nobody thought of using this for Foundation.<br>&gt; <br>&gt; A closely related difference is the use of so-called &quot;selective&quot; imports, where we import only a single symbol (or a list of explicitly-identified symbols) into the scope.  We might express this as<br>&gt; <br>&gt; from Foundation.Net.URL import Session, HTTP //import two classes only<br>&gt; let s = Session(...)<br>&gt; <br>&gt; Again I think Swift technically supports some way to avoid importing a whole gigantic namespace like Foundation, but I am not aware of any actual uses of this feature, and certainly the convention is not to write code this way.  Meanwhile, let&#39;s check in with the Python community, who standardized the following guidance on these &quot;wildcard&quot; imports as part of their language evolution process:<br>&gt; <br>&gt;&gt; Wildcard imports ( from &lt;module&gt; import * ) should be avoided, as they make it unclear which names are present in the namespace, confusing both readers and many automated tools. There is one defensible use case for a wildcard import...<br>&gt; <br>&gt; When a language has a robust namespacing system, which we do not, there are many follow-on consequences.  One is that an import statement is much more of a scalpel than a bludgeon; each import statement only introduces a handful of new names (even if it is a so-called &quot;wildcard&quot; import that grabs all children of some namespace, most of those children are themselves namespaces), unlike importing Foundation which contains thousands of direct child types that are injected into the local scope.<br>&gt; <br>&gt; Another consequence is that class names become quite short, shadow each other, and nobody bats an eye.  I searched the C# standard library for &quot;Session&quot;, and found some 12 classes with that name:<br>&gt; <br>&gt; &lt;Screen Shot 2016-01-30 at 3.44.23 PM.png&gt;<br>&gt; <br>&gt; These &quot;standard library&quot; classes not only potentially shadow programmer-defined types, they also shadow each other.  But because the C# language has a robust namespacing system, the chances of there being more than one thing called &quot;Session&quot; in scope in your program (or for that matter, when developing the standard library itself) is quite small, so it&#39;s a non-issue.<br>&gt; <br>&gt; Now we return to the question of dropping the NS prefix, which will rename thousands of classes in a typical program that has `import Foundation`, in a way that potentially (let&#39;s be honest.  More like &quot;probably&quot;) shadows one or more programmer-defined classes.  Our review criteria is:<br>&gt; <br>&gt;&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; <br>&gt; <br>&gt; No, the elimination of 2 characters is not significant enough of a problem to break all Swift programs, let alone to introduce literally thousands of new opportunities for shadowing.<br>&gt; <br>&gt; To its credit, the proposal acknowledges this, and offers a concession:<br>&gt; <br>&gt;&gt; Note that this removal can create conflicts with the standard library. For example, NSString and NSArray will become String and Array, respectively, and Foundation&#39;s versions will shadow the standard library&#39;s versions.  In cases where the Swift 3 names of standard library entities conflict with prefix-stripped Foundation entities, we retain the NS prefix. These Foundation entities are: NSArray, NSDictionary, NSInteger, NSRange, NSSet, and NSString.<br>&gt; <br>&gt; But of course this needlessly draws a distinction between NSString et al and the &quot;normal&quot; Foundation types, and what&#39;s more it draws that distinction based on the present composition of the Swift standard library and the present composition of Foundation.  But we have already decided not to guarantee the source compatibility of the standard library, so what happens when that composition changes?  Will we then go back and tweak which classes get NS prefixed to them again?<br>&gt; <br>&gt; In my view, if Swift&#39;s namespacing is not good enough to let us drop the NS in NSString it is not good enough to drop any prefix.  If we believe that a programmer will struggle to distinguish between Swift String and Foundation String then we should expect them to struggle for any two classes in any two frameworks, and this is special pleading on the part of Foundation.  C#&#39;s libraries declare *twelve* different `Session`s and nobody bats an eye, but we have two types share a name and everybody loses their minds?  Our namespacing is not good enough to kill the prefix, period.<br>&gt; <br>&gt; We should either drop these prefixes or we should not; because the claimed motivation–that we have &quot;good enough&quot; namespacing in the language now–is either true or it is not.  This proposal admits that it is not, and tries to drop the prefixes anyway.  I believe that is a mistake.<br>&gt; <br>&gt; I certainly support the goal of eliminating these prefixes, they are ugly, they need to be killed, and namespacing is the right solution.  But we must not jump out of the plane until we are very sure our parachute is in order.  In Swift 3 it is not.<br>&gt; <br>&gt; I do think the bulk of the proposal is fine, and I apologize for using quite stark language for such a small paragraph in an otherwise reasonable proposal, but I think the problem buried in here is quite serious and is being overlooked.<br>&gt; <br>&gt; Drew<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 22, 2016, at 3:02 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of SE-0005&quot;Better Translation of Objective-C APIs Into Swift&quot; begins now and runs through January 31, 2016. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md&gt;<br>&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt; <br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br>&gt;&gt; <br>&gt;&gt; Proposal link:<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md&gt;<br>&gt;&gt; Reply text<br>&gt;&gt; <br>&gt;&gt; Other replies<br>&gt;&gt;  &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What goes into a review?<br>&gt;&gt; <br>&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt; <br>&gt;&gt; What is your evaluation of the proposal?<br>&gt;&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt;&gt; Thank you,<br>&gt;&gt; <br>&gt;&gt; -Doug Gregor<br>&gt;&gt; <br>&gt;&gt; Review Manager<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/c275a3ff/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>February  1, 2016 at 03:00:00pm</p></header><div class="content"><p>+1 to most of what Nate says here.  <br></p><p>I was about to reply in much more brief manner with the same general thoughts.  I’m glad Nate took the time to write a more complete response.  I don’t want to see a rush to retain reference types where value types are a better long-term design.  The `NS` prefix gives a subtle indication that the type is not the final solution for Swift.<br></p><p>The only comment I want to add is that the argument is mostly specific to Foundation.  In most cases removing the prefix for higher level frameworks is appropriate as the types would by reference types in Swift anyway and are not near-tern candidates for a Swifty redesign.  <br></p><p>Perhaps the best solution is an annotation in Objective-C similar to the null annotations.  In Foundation the default would be to leave the `NS` prefix (at least on classes).  Everywhere else the default would be to remove the prefix.  In specific cases an annotation could be used to override the default.<br></p><p>-Matthew<br></p><p>&gt; On Feb 1, 2016, at 3:10 PM, Nate Cook via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This is a concurring opinion with Drew&#39;s review, agreeing that we should reconsider removing the &quot;NS&quot; prefix but providing my own reasons. The proposal as a whole is exciting and far-reaching, but this particular change is misguided. My objections are:<br>&gt; <br>&gt; 1) The change will elide the different semantic expectations for Foundation and Swift standard library types.<br>&gt; <br>&gt; Prefix-less Foundation types will blur the different norms and expectations for Foundation types vs what we have in the Swift standard library, particularly in regards to value vs reference semantics of collection types. <br>&gt; <br>&gt; The Swift standard library defines Array, Set, and Dictionary as collection types with value semantics that operate quite differently from their peers in Foundation. This change will introduce OrderedSet, CountedSet, HashTable, MapTable, and others, all of which use reference semantics and therefore don&#39;t provide the same set of guarantees about ownership and immutability.<br>&gt; <br>&gt; As an example, the seemingly similar Set and CountedSet types produce different results from nearly identical code. Swift&#39;s Set type has value semantics, so changes to a copy don&#39;t affect the original Set instance:<br>&gt; <br>&gt; let simpleSet = Set([&quot;one&quot;, &quot;two&quot;, &quot;three&quot;])<br>&gt; var copiedSimpleSet = simpleSet<br>&gt; copiedSimpleSet.remove(&quot;one&quot;)<br>&gt; <br>&gt; copiedSimpleSet.contains(&quot;one&quot;)  // false<br>&gt; simpleSet.contains(&quot;one&quot;)        // true<br>&gt; <br>&gt; CountedSet (née NSCountedSet), on the other hand, uses reference semantics, so changes to a copy of an instance. This is true whether the copy is an explicit one made via assignment or the implicit copy made when calling a function with CountedSet as a parameter. This example shows how nearly code nearly identical to the above produces very different results:<br>&gt; <br>&gt; let countedSet = CountedSet(array: [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;])<br>&gt; var copiedCountedSet = countedSet<br>&gt; copiedCountedSet.remove(&quot;one&quot;)<br>&gt; <br>&gt; copiedCountedSet.contains(&quot;one&quot;) // false<br>&gt; countedSet.contains(&quot;one&quot;)       // false!<br>&gt; <br>&gt; Collections constructed from immutable/mutable class clusters (like OrderedSet and MutableOrderedSet) pose the same problems, since you may be using a mutable instance of the &quot;immutable&quot; collection. We clearly are already dealing with this difference today, but eliminating the &quot;NS&quot; prefix implies that Foundation types are on the same level as the standard library. This makes the confusion more pronounced and significantly increases both the learning curve of the Swift &amp; Foundation APIs and the risk of errors when using different collection types.<br>&gt; <br>&gt; 2) The change may stifle the development of more Swift-oriented APIs.<br>&gt; <br>&gt; Foundation types were developed in and for a language that uses reference semantics and subclassing, rather than value semantics and a protocol-oriented approach. The designs therefore use and reinforce norms that relate better to Objective-C than to Swift—class clusters of non-final, immutable types with mutable subclasses, immutable types with separate but related mutable counterparts, etc.<br>&gt; <br>&gt; A Swift-native CountedSet (and other collections) would surely have value semantics built in. What about other types—do the new Calendar/Date/DateComponents types look like the system that we would design from the ground up in Swift? How about URL and URLComponents? Dropping the &quot;NS&quot; prefix would make it more difficult to gradually expand the standard library to encompass bridging versions of these and other common types.<br>&gt; <br>&gt; 3) The change will make it harder to find information about the revised APIs.<br>&gt; <br>&gt; Excellent search-ability is an unintended benefit of the &quot;NS&quot; prefix, and can be understood as a way that these types avoid collisions in the vast namespace-less sea of Internet search results. Searching for help with URL and Calendar will be much more difficult than their NS&#39;ed counterparts.<br>&gt; <br>&gt; Especially given the challenges that this proposal will pose for code sourced from tutorials, blog posts, Stack Overflow answers, etc., keeping at least the class names as sign posts seems valuable.<br>&gt; <br>&gt; 4) We&#39;ll still be using prefixes after the change.<br>&gt; <br>&gt; While the removal of &quot;NS&quot; is far-reaching, prefixes will still be a common occurrence in code written in Swift. UIKit and AppKit, along with all the various frameworks, will still retain their prefixes, so removing prefixes in the case of Foundation types will be more the exception than the norm. As such, any benefit of the removal would be mitigated by the continued use of prefixes for the rest of the first-party types we rely on.<br>&gt; <br>&gt; <br>&gt; In sum, the change would make the language and its APIs more confusing and more difficult to use today, would make it more difficult to migrate to modern designs in the future, and would ultimately provide a very minor benefit. I encourage the Swift core team to reconsider the &quot;Strip the &quot;NS&quot; prefix from Foundation APIs&quot; portion of the proposal.<br>&gt; <br>&gt; Nate<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 30, 2016, at 5:01 PM, Drew Crawford via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I am in favor of this proposal on balance, and I leave the bulk of this to people who interop with Objective-C more often than I do.<br>&gt;&gt; <br>&gt;&gt; I would like to confine my remarks to one corner where I think we are making a very serious mistake.<br>&gt;&gt; <br>&gt;&gt;&gt; The removal of the &quot;NS&quot; prefix for the Foundation module (or other specifically identified modules) is a mechanical translation for all global symbols defined within that module that can be performed in the Clang importer. <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; As I understand it (and I am no Cocoa historian) the NS prefix was originally introduced because Objective-C lacks namespacing.<br>&gt;&gt; <br>&gt;&gt; The thinking seems to be that since Swift has proper namespacing, this historicism is no longer necessary.  I find this argument very flimsy.<br>&gt;&gt; <br>&gt;&gt; Of course Swift has stronger namespacing if one&#39;s frame of reference is Objective-C or C.  But for those of us coming from other language backgrounds, namespacing means something much stronger than Swift&#39;s concept of it.  I don&#39;t mean to suggest that Swift&#39;s design is wrong exactly (less is sometimes more), but I do mean to say that if we propose to undo a decision that worked for several decades and break every Swift project in existence on the theory that Swift&#39;s namespacing is strong enough we had better be right.<br>&gt;&gt; <br>&gt;&gt; For those unfamiliar, I will explain some of the namespacing tools Swift lacks relative to other languages.  First, many languages have a &quot;hierarchical&quot; namespace system, where one can say<br>&gt;&gt; <br>&gt;&gt; import Foundation.Net.URL<br>&gt;&gt; let s = Session(...)<br>&gt;&gt; <br>&gt;&gt; instead of for example<br>&gt;&gt; <br>&gt;&gt; import Foundation<br>&gt;&gt; let s = NSURLSession(...)<br>&gt;&gt; <br>&gt;&gt; Some form of this is used in Rust, Python, and C#, as far as I know.  I believe Swift has some counterfeit version of this, as the book mentions you can import a &quot;submodule &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/import-declaration&gt;&quot;, but I do not know what that is, do not know how to make one, have never seen anyone use one, the book suggests it goes only 2 levels deep, and perhaps as a consequences of some of these problems nobody thought of using this for Foundation.<br>&gt;&gt; <br>&gt;&gt; A closely related difference is the use of so-called &quot;selective&quot; imports, where we import only a single symbol (or a list of explicitly-identified symbols) into the scope.  We might express this as<br>&gt;&gt; <br>&gt;&gt; from Foundation.Net.URL import Session, HTTP //import two classes only<br>&gt;&gt; let s = Session(...)<br>&gt;&gt; <br>&gt;&gt; Again I think Swift technically supports some way to avoid importing a whole gigantic namespace like Foundation, but I am not aware of any actual uses of this feature, and certainly the convention is not to write code this way.  Meanwhile, let&#39;s check in with the Python community, who standardized the following guidance on these &quot;wildcard&quot; imports as part of their language evolution process:<br>&gt;&gt; <br>&gt;&gt;&gt; Wildcard imports ( from &lt;module&gt; import * ) should be avoided, as they make it unclear which names are present in the namespace, confusing both readers and many automated tools. There is one defensible use case for a wildcard import...<br>&gt;&gt; <br>&gt;&gt; When a language has a robust namespacing system, which we do not, there are many follow-on consequences.  One is that an import statement is much more of a scalpel than a bludgeon; each import statement only introduces a handful of new names (even if it is a so-called &quot;wildcard&quot; import that grabs all children of some namespace, most of those children are themselves namespaces), unlike importing Foundation which contains thousands of direct child types that are injected into the local scope.<br>&gt;&gt; <br>&gt;&gt; Another consequence is that class names become quite short, shadow each other, and nobody bats an eye.  I searched the C# standard library for &quot;Session&quot;, and found some 12 classes with that name:<br>&gt;&gt; <br>&gt;&gt; &lt;Screen Shot 2016-01-30 at 3.44.23 PM.png&gt;<br>&gt;&gt; <br>&gt;&gt; These &quot;standard library&quot; classes not only potentially shadow programmer-defined types, they also shadow each other.  But because the C# language has a robust namespacing system, the chances of there being more than one thing called &quot;Session&quot; in scope in your program (or for that matter, when developing the standard library itself) is quite small, so it&#39;s a non-issue.<br>&gt;&gt; <br>&gt;&gt; Now we return to the question of dropping the NS prefix, which will rename thousands of classes in a typical program that has `import Foundation`, in a way that potentially (let&#39;s be honest.  More like &quot;probably&quot;) shadows one or more programmer-defined classes.  Our review criteria is:<br>&gt;&gt; <br>&gt;&gt;&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; No, the elimination of 2 characters is not significant enough of a problem to break all Swift programs, let alone to introduce literally thousands of new opportunities for shadowing.<br>&gt;&gt; <br>&gt;&gt; To its credit, the proposal acknowledges this, and offers a concession:<br>&gt;&gt; <br>&gt;&gt;&gt; Note that this removal can create conflicts with the standard library. For example, NSString and NSArray will become String and Array, respectively, and Foundation&#39;s versions will shadow the standard library&#39;s versions.  In cases where the Swift 3 names of standard library entities conflict with prefix-stripped Foundation entities, we retain the NS prefix. These Foundation entities are: NSArray, NSDictionary, NSInteger, NSRange, NSSet, and NSString.<br>&gt;&gt; <br>&gt;&gt; But of course this needlessly draws a distinction between NSString et al and the &quot;normal&quot; Foundation types, and what&#39;s more it draws that distinction based on the present composition of the Swift standard library and the present composition of Foundation.  But we have already decided not to guarantee the source compatibility of the standard library, so what happens when that composition changes?  Will we then go back and tweak which classes get NS prefixed to them again?<br>&gt;&gt; <br>&gt;&gt; In my view, if Swift&#39;s namespacing is not good enough to let us drop the NS in NSString it is not good enough to drop any prefix.  If we believe that a programmer will struggle to distinguish between Swift String and Foundation String then we should expect them to struggle for any two classes in any two frameworks, and this is special pleading on the part of Foundation.  C#&#39;s libraries declare *twelve* different `Session`s and nobody bats an eye, but we have two types share a name and everybody loses their minds?  Our namespacing is not good enough to kill the prefix, period.<br>&gt;&gt; <br>&gt;&gt; We should either drop these prefixes or we should not; because the claimed motivation–that we have &quot;good enough&quot; namespacing in the language now–is either true or it is not.  This proposal admits that it is not, and tries to drop the prefixes anyway.  I believe that is a mistake.<br>&gt;&gt; <br>&gt;&gt; I certainly support the goal of eliminating these prefixes, they are ugly, they need to be killed, and namespacing is the right solution.  But we must not jump out of the plane until we are very sure our parachute is in order.  In Swift 3 it is not.<br>&gt;&gt; <br>&gt;&gt; I do think the bulk of the proposal is fine, and I apologize for using quite stark language for such a small paragraph in an otherwise reasonable proposal, but I think the problem buried in here is quite serious and is being overlooked.<br>&gt;&gt; <br>&gt;&gt; Drew<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 22, 2016, at 3:02 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The review of SE-0005&quot;Better Translation of Objective-C APIs Into Swift&quot; begins now and runs through January 31, 2016. The proposal is available here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md&gt;<br>&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposal link:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md&gt;<br>&gt;&gt;&gt; Reply text<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Other replies<br>&gt;&gt;&gt;  &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What goes into a review?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What is your evaluation of the proposal?<br>&gt;&gt;&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt;&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt;&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Doug Gregor<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Review Manager<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/e2c928e3/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>February  1, 2016 at 01:00:00pm</p></header><div class="content"><p>+1 to Nate&#39;s reasoning. I understand this might be quite controversial, and<br>I appreciate the work that&#39;s been done on Foundation, but I am wary about<br>canonicalizing a &quot;standard library&quot; that cannot fully embrace Swift<br>features and idioms as such, at least at this point in time. I understand<br>the desire to make open-source Foundation a standard for cross-platform<br>development, but this should not be at the expense of libraries which seek<br>to provide &#39;Swiftier&#39; solutions to the same problems.<br></p><p>Best,<br>Austin<br></p><p>On Mon, Feb 1, 2016 at 1:10 PM, Nate Cook via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; This is a concurring opinion with Drew&#39;s review, agreeing that we should<br>&gt; reconsider removing the &quot;NS&quot; prefix but providing my own reasons. The<br>&gt; proposal as a whole is exciting and far-reaching, but this particular<br>&gt; change is misguided. My objections are:<br>&gt;<br>&gt; *1) The change will elide the different semantic expectations for<br>&gt; Foundation and Swift standard library types.*<br>&gt;<br>&gt; Prefix-less Foundation types will blur the different norms and<br>&gt; expectations for Foundation types vs what we have in the Swift standard<br>&gt; library, particularly in regards to value vs reference semantics of<br>&gt; collection types.<br>&gt;<br>&gt; The Swift standard library defines Array, Set, and Dictionary as<br>&gt; collection types with value semantics that operate quite differently from<br>&gt; their peers in Foundation. This change will introduce OrderedSet,<br>&gt; CountedSet, HashTable, MapTable, and others, all of which use reference<br>&gt; semantics and therefore don&#39;t provide the same set of guarantees about<br>&gt; ownership and immutability.<br>&gt;<br>&gt; As an example, the seemingly similar Set and CountedSet types produce<br>&gt; different results from nearly identical code. Swift&#39;s Set type has value<br>&gt; semantics, so changes to a copy don&#39;t affect the original Set instance:<br>&gt;<br>&gt; let simpleSet = Set([&quot;one&quot;, &quot;two&quot;, &quot;three&quot;])<br>&gt; var copiedSimpleSet = simpleSet<br>&gt; copiedSimpleSet.remove(&quot;one&quot;)<br>&gt;<br>&gt; copiedSimpleSet.contains(&quot;one&quot;)  // false<br>&gt; simpleSet.contains(&quot;one&quot;)        // true<br>&gt;<br>&gt; CountedSet (née NSCountedSet), on the other hand, uses reference<br>&gt; semantics, so changes to a copy of an instance. This is true whether the<br>&gt; copy is an explicit one made via assignment or the implicit copy made when<br>&gt; calling a function with CountedSet as a parameter. This example shows how<br>&gt; nearly code nearly identical to the above produces very different results:<br>&gt;<br>&gt; let countedSet = CountedSet(array: [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;])<br>&gt; var copiedCountedSet = countedSet<br>&gt; copiedCountedSet.remove(&quot;one&quot;)<br>&gt;<br>&gt; copiedCountedSet.contains(&quot;one&quot;) // false<br>&gt; countedSet.contains(&quot;one&quot;)       // false!<br>&gt;<br>&gt; Collections constructed from immutable/mutable class clusters (like<br>&gt; OrderedSet and MutableOrderedSet) pose the same problems, since you may be<br>&gt; using a mutable instance of the &quot;immutable&quot; collection. We clearly are<br>&gt; already dealing with this difference today, but eliminating the &quot;NS&quot; prefix<br>&gt; implies that Foundation types are on the same level as the standard<br>&gt; library. This makes the confusion more pronounced and significantly<br>&gt; increases both the learning curve of the Swift &amp; Foundation APIs and the<br>&gt; risk of errors when using different collection types.<br>&gt;<br>&gt; *2) The change may stifle the development of more Swift-oriented APIs.*<br>&gt;<br>&gt; Foundation types were developed in and for a language that uses reference<br>&gt; semantics and subclassing, rather than value semantics and a<br>&gt; protocol-oriented approach. The designs therefore use and reinforce norms<br>&gt; that relate better to Objective-C than to Swift—class clusters of<br>&gt; non-final, immutable types with mutable subclasses, immutable types with<br>&gt; separate but related mutable counterparts, etc.<br>&gt;<br>&gt; A Swift-native CountedSet (and other collections) would surely have value<br>&gt; semantics built in. What about other types—do the new<br>&gt; Calendar/Date/DateComponents types look like the system that we would<br>&gt; design from the ground up in Swift? How about URL and URLComponents?<br>&gt; Dropping the &quot;NS&quot; prefix would make it more difficult to gradually expand<br>&gt; the standard library to encompass bridging versions of these and other<br>&gt; common types.<br>&gt;<br>&gt; *3) The change will make it harder to find information about the revised<br>&gt; APIs.*<br>&gt;<br>&gt; Excellent search-ability is an unintended benefit of the &quot;NS&quot; prefix, and<br>&gt; can be understood as a way that these types avoid collisions in the vast<br>&gt; namespace-less sea of Internet search results. Searching for help with URL<br>&gt; and Calendar will be much more difficult than their NS&#39;ed counterparts.<br>&gt;<br>&gt; Especially given the challenges that this proposal will pose for code<br>&gt; sourced from tutorials, blog posts, Stack Overflow answers, etc., keeping<br>&gt; at least the class names as sign posts seems valuable.<br>&gt;<br>&gt; *4) We&#39;ll still be using prefixes after the change.*<br>&gt;<br>&gt; While the removal of &quot;NS&quot; is far-reaching, prefixes will still be a common<br>&gt; occurrence in code written in Swift. UIKit and AppKit, along with all the<br>&gt; various frameworks, will still retain their prefixes, so removing prefixes<br>&gt; in the case of Foundation types will be more the exception than the norm.<br>&gt; As such, any benefit of the removal would be mitigated by the continued use<br>&gt; of prefixes for the rest of the first-party types we rely on.<br>&gt;<br>&gt;<br>&gt; In sum, the change would make the language and its APIs more confusing and<br>&gt; more difficult to use today, would make it more difficult to migrate to<br>&gt; modern designs in the future, and would ultimately provide a very minor<br>&gt; benefit. I encourage the Swift core team to reconsider the &quot;Strip the &quot;NS&quot;<br>&gt; prefix from Foundation APIs&quot; portion of the proposal.<br>&gt;<br>&gt; Nate<br>&gt;<br>&gt;<br>&gt; On Jan 30, 2016, at 5:01 PM, Drew Crawford via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I am in favor of this proposal on balance, and I leave the bulk of this to<br>&gt; people who interop with Objective-C more often than I do.<br>&gt;<br>&gt; I would like to confine my remarks to one corner where I think we are<br>&gt; making a very serious mistake.<br>&gt;<br>&gt; The removal of the &quot;NS&quot; prefix for the Foundation module (or other<br>&gt; specifically identified modules) is a mechanical translation for all global<br>&gt; symbols defined within that module that can be performed in the Clang<br>&gt; importer.<br>&gt;<br>&gt;<br>&gt; As I understand it (and I am no Cocoa historian) the NS prefix was<br>&gt; originally introduced because Objective-C lacks namespacing.<br>&gt;<br>&gt; The thinking seems to be that since Swift has proper namespacing, this<br>&gt; historicism is no longer necessary.  I find this argument very flimsy.<br>&gt;<br>&gt; Of course Swift has stronger namespacing if one&#39;s frame of reference is<br>&gt; Objective-C or C.  But for those of us coming from other language<br>&gt; backgrounds, namespacing means something much stronger than Swift&#39;s concept<br>&gt; of it.  I don&#39;t mean to suggest that Swift&#39;s design is wrong exactly (less<br>&gt; is sometimes more), but I do mean to say that if we propose to undo a<br>&gt; decision that worked for several decades and break every Swift project in<br>&gt; existence on the theory that Swift&#39;s namespacing is strong enough we had<br>&gt; better be right.<br>&gt;<br>&gt; For those unfamiliar, I will explain some of the namespacing tools Swift<br>&gt; lacks relative to other languages.  First, many languages have a<br>&gt; &quot;hierarchical&quot; namespace system, where one can say<br>&gt;<br>&gt; import Foundation.Net.URL<br>&gt; let s = Session(...)<br>&gt;<br>&gt;<br>&gt; instead of for example<br>&gt;<br>&gt; import Foundation<br>&gt; let s = NSURLSession(...)<br>&gt;<br>&gt;<br>&gt; Some form of this is used in Rust, Python, and C#, as far as I know.  I<br>&gt; believe Swift has some counterfeit version of this, as the book mentions<br>&gt; you can import a &quot;submodule<br>&gt; &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/import-declaration&gt;&quot;,<br>&gt; but I do not know what that is, do not know how to make one, have never<br>&gt; seen anyone use one, the book suggests it goes only 2 levels deep, and<br>&gt; perhaps as a consequences of some of these problems nobody thought of using<br>&gt; this for Foundation.<br>&gt;<br>&gt; A closely related difference is the use of so-called &quot;selective&quot; imports,<br>&gt; where we import only a single symbol (or a list of explicitly-identified<br>&gt; symbols) into the scope.  We might express this as<br>&gt;<br>&gt; from Foundation.Net.URL import Session, HTTP //import two classes only<br>&gt; let s = Session(...)<br>&gt;<br>&gt;<br>&gt; Again I think Swift technically supports some way to avoid importing a<br>&gt; whole gigantic namespace like Foundation, but I am not aware of any actual<br>&gt; uses of this feature, and certainly the convention is not to write code<br>&gt; this way.  Meanwhile, let&#39;s check in with the Python community, who<br>&gt; standardized the following guidance on these &quot;wildcard&quot; imports as part of<br>&gt; their language evolution process:<br>&gt;<br>&gt; Wildcard imports ( from &lt;module&gt; import * ) should be avoided, as they<br>&gt; make it unclear which names are present in the namespace, confusing both<br>&gt; readers and many automated tools. There is one defensible use case for a<br>&gt; wildcard import...<br>&gt;<br>&gt;<br>&gt; When a language has a robust namespacing system, which we do not, there<br>&gt; are many follow-on consequences.  One is that an import statement is much<br>&gt; more of a scalpel than a bludgeon; each import statement only introduces a<br>&gt; handful of new names (even if it is a so-called &quot;wildcard&quot; import that<br>&gt; grabs all children of some namespace, most of those children are themselves<br>&gt; namespaces), unlike importing Foundation which contains thousands of direct<br>&gt; child types that are injected into the local scope.<br>&gt;<br>&gt; Another consequence is that class names become quite short, shadow each<br>&gt; other, and nobody bats an eye.  I searched the C# standard library for<br>&gt; &quot;Session&quot;, and found some 12 classes with that name:<br>&gt;<br>&gt; &lt;Screen Shot 2016-01-30 at 3.44.23 PM.png&gt;<br>&gt;<br>&gt; These &quot;standard library&quot; classes not only potentially shadow<br>&gt; programmer-defined types, *they also shadow each other*.  But because the<br>&gt; C# language has a robust namespacing system, the chances of there being<br>&gt; more than one thing called &quot;Session&quot; in scope in your program (or for that<br>&gt; matter, when developing the standard library itself) is quite small, so<br>&gt; it&#39;s a non-issue.<br>&gt;<br>&gt; Now we return to the question of dropping the NS prefix, which will rename<br>&gt; thousands of classes in a typical program that has `import Foundation`, in<br>&gt; a way that potentially (let&#39;s be honest.  More like &quot;probably&quot;) shadows one<br>&gt; or more programmer-defined classes.  Our review criteria is:<br>&gt;<br>&gt; Is the problem being addressed significant enough to warrant a change to<br>&gt; Swift?<br>&gt;<br>&gt;<br>&gt; No, the elimination of 2 characters is not significant enough of a problem<br>&gt; to break all Swift programs, let alone to introduce literally thousands of<br>&gt; new opportunities for shadowing.<br>&gt;<br>&gt; To its credit, the proposal acknowledges this, and offers a concession:<br>&gt;<br>&gt; Note that this removal can create conflicts with the standard library. For<br>&gt; example, NSString and NSArray will become String and Array, respectively,<br>&gt; and Foundation&#39;s versions will shadow the standard library&#39;s versions.  In<br>&gt; cases where the Swift 3 names of standard library entities conflict with<br>&gt; prefix-stripped Foundation entities, we retain the NS prefix. These<br>&gt; Foundation entities are: NSArray, NSDictionary, NSInteger, NSRange, NSSet,<br>&gt; and NSString.<br>&gt;<br>&gt;<br>&gt; But of course this needlessly draws a distinction between NSString et al<br>&gt; and the &quot;normal&quot; Foundation types, and what&#39;s more it draws that<br>&gt; distinction based on the present composition of the Swift standard library<br>&gt; and the present composition of Foundation.  But we have already decided not<br>&gt; to guarantee the source compatibility of the standard library, so what<br>&gt; happens when that composition changes?  Will we then go back and tweak<br>&gt; which classes get NS prefixed to them again?<br>&gt;<br>&gt; In my view, if Swift&#39;s namespacing is not good enough to let us drop the<br>&gt; NS in NSString it is not good enough to drop any prefix.  If we believe<br>&gt; that a programmer will struggle to distinguish between Swift String and<br>&gt; Foundation String then we should expect them to struggle for any two<br>&gt; classes in any two frameworks, and this is special pleading on the part of<br>&gt; Foundation.  C#&#39;s libraries declare **twelve** different `Session`s and<br>&gt; nobody bats an eye, but we have two types share a name and everybody loses<br>&gt; their minds?  Our namespacing is not good enough to kill the prefix, period.<br>&gt;<br>&gt; We should either drop these prefixes or we should not; because the claimed<br>&gt; motivation–that we have &quot;good enough&quot; namespacing in the language now–is<br>&gt; either true or it is not.  This proposal admits that it is not, and tries<br>&gt; to drop the prefixes anyway.  I believe that is a mistake.<br>&gt;<br>&gt; I certainly support the goal of eliminating these prefixes, they are ugly,<br>&gt; they need to be killed, and namespacing is the right solution.  But we must<br>&gt; not jump out of the plane until we are very sure our parachute is in<br>&gt; order.  In Swift 3 it is not.<br>&gt;<br>&gt; I do think the bulk of the proposal is fine, and I apologize for using<br>&gt; quite stark language for such a small paragraph in an otherwise reasonable<br>&gt; proposal, but I think the problem buried in here is quite serious and is<br>&gt; being overlooked.<br>&gt;<br>&gt; Drew<br>&gt;<br>&gt;<br>&gt; On Jan 22, 2016, at 3:02 PM, Douglas Gregor via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Hello Swift community,<br>&gt;<br>&gt; The review of SE-0005&quot;Better Translation of Objective-C APIs Into Swift&quot;<br>&gt; begins now and runs through January 31, 2016. The proposal is available<br>&gt; here:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md<br>&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt; should be sent to the swift-evolution mailing list at<br>&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the<br>&gt; review manager. When replying, please try to keep the proposal link at the<br>&gt; top of the message:<br>&gt;<br>&gt; Proposal link:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md<br>&gt;<br>&gt; Reply text<br>&gt;<br>&gt; Other replies<br>&gt;<br>&gt; &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What<br>&gt; goes into a review?<br>&gt;<br>&gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and, eventually, determine the direction of<br>&gt; Swift. When writing your review, here are some questions you might want to<br>&gt; answer in your review:<br>&gt;<br>&gt;    - What is your evaluation of the proposal?<br>&gt;    - Is the problem being addressed significant enough to warrant a<br>&gt;    change to Swift?<br>&gt;    - Does this proposal fit well with the feel and direction of Swift?<br>&gt;    - If you have used other languages or libraries with a similar<br>&gt;    feature, how do you feel that this proposal compares to those?<br>&gt;    - How much effort did you put into your review? A glance, a quick<br>&gt;    reading, or an in-depth study?<br>&gt;<br>&gt; More information about the Swift evolution process is available at<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;<br>&gt; Thank you,<br>&gt;<br>&gt; -Doug Gregor<br>&gt;<br>&gt; Review Manager<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/be359707/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>February  5, 2016 at 01:00:00pm</p></header><div class="content"><p>I’d like to voice my opinion before is too late and reiterate what Nate said. Although I’m not going to add much, because Nate already said it all better than I could.<br></p><p>• What is your evaluation of the proposal?<br></p><p>I agree with most of the proposal except for &quot;Strip the &quot;NS&quot; prefix from Foundation APIs”. I strongly disagree with this change for the same reasons as Nate:<br></p><p>- This change will make Foundation types look Swift native enough to confuse some users between the stdlib’s value semantics and Foundation’s reference semantics.<br>- The change will complicate the creation of a Swift native foundation that uses the power of Swift to provide true value semantics to types that need them (URL, Data, CountedSet, etc…)<br></p><p>• Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>I don’t necessarily think that the problem being addressed is that significant, but the change is appreciated (except for the NS prefix). To be honest, I would have preferred more design and development effort to go towards enhancing the Swift language itself, or the emergence of a real Swift foundation framework.<br></p><p>• Does this proposal fit well with the feel and direction of Swift?<br></p><p>It does.<br></p><p>• If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>Nothing to say here.<br></p><p>• How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I have kept up with the discussion since the start and have tried to keep an open mind about everybody’s opinion.<br></p><p>David.<br></p><p><br>&gt; On 01 Feb 2016, at 22:10, Nate Cook via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This is a concurring opinion with Drew&#39;s review, agreeing that we should reconsider removing the &quot;NS&quot; prefix but providing my own reasons. The proposal as a whole is exciting and far-reaching, but this particular change is misguided. My objections are:<br>&gt; <br>&gt; 1) The change will elide the different semantic expectations for Foundation and Swift standard library types.<br>&gt; <br>&gt; Prefix-less Foundation types will blur the different norms and expectations for Foundation types vs what we have in the Swift standard library, particularly in regards to value vs reference semantics of collection types. <br>&gt; <br>&gt; The Swift standard library defines Array, Set, and Dictionary as collection types with value semantics that operate quite differently from their peers in Foundation. This change will introduce OrderedSet, CountedSet, HashTable, MapTable, and others, all of which use reference semantics and therefore don&#39;t provide the same set of guarantees about ownership and immutability.<br>&gt; <br>&gt; As an example, the seemingly similar Set and CountedSet types produce different results from nearly identical code. Swift&#39;s Set type has value semantics, so changes to a copy don&#39;t affect the original Set instance:<br>&gt; <br>&gt; let simpleSet = Set([&quot;one&quot;, &quot;two&quot;, &quot;three&quot;])<br>&gt; var copiedSimpleSet = simpleSet<br>&gt; copiedSimpleSet.remove(&quot;one&quot;)<br>&gt; <br>&gt; copiedSimpleSet.contains(&quot;one&quot;)  // false<br>&gt; simpleSet.contains(&quot;one&quot;)        // true<br>&gt; <br>&gt; CountedSet (née NSCountedSet), on the other hand, uses reference semantics, so changes to a copy of an instance. This is true whether the copy is an explicit one made via assignment or the implicit copy made when calling a function with CountedSet as a parameter. This example shows how nearly code nearly identical to the above produces very different results:<br>&gt; <br>&gt; let countedSet = CountedSet(array: [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;])<br>&gt; var copiedCountedSet = countedSet<br>&gt; copiedCountedSet.remove(&quot;one&quot;)<br>&gt; <br>&gt; copiedCountedSet.contains(&quot;one&quot;) // false<br>&gt; countedSet.contains(&quot;one&quot;)       // false!<br>&gt; <br>&gt; Collections constructed from immutable/mutable class clusters (like OrderedSet and MutableOrderedSet) pose the same problems, since you may be using a mutable instance of the &quot;immutable&quot; collection. We clearly are already dealing with this difference today, but eliminating the &quot;NS&quot; prefix implies that Foundation types are on the same level as the standard library. This makes the confusion more pronounced and significantly increases both the learning curve of the Swift &amp; Foundation APIs and the risk of errors when using different collection types.<br>&gt; <br>&gt; 2) The change may stifle the development of more Swift-oriented APIs.<br>&gt; <br>&gt; Foundation types were developed in and for a language that uses reference semantics and subclassing, rather than value semantics and a protocol-oriented approach. The designs therefore use and reinforce norms that relate better to Objective-C than to Swift—class clusters of non-final, immutable types with mutable subclasses, immutable types with separate but related mutable counterparts, etc.<br>&gt; <br>&gt; A Swift-native CountedSet (and other collections) would surely have value semantics built in. What about other types—do the new Calendar/Date/DateComponents types look like the system that we would design from the ground up in Swift? How about URL and URLComponents? Dropping the &quot;NS&quot; prefix would make it more difficult to gradually expand the standard library to encompass bridging versions of these and other common types.<br>&gt; <br>&gt; 3) The change will make it harder to find information about the revised APIs.<br>&gt; <br>&gt; Excellent search-ability is an unintended benefit of the &quot;NS&quot; prefix, and can be understood as a way that these types avoid collisions in the vast namespace-less sea of Internet search results. Searching for help with URL and Calendar will be much more difficult than their NS&#39;ed counterparts.<br>&gt; <br>&gt; Especially given the challenges that this proposal will pose for code sourced from tutorials, blog posts, Stack Overflow answers, etc., keeping at least the class names as sign posts seems valuable.<br>&gt; <br>&gt; 4) We&#39;ll still be using prefixes after the change.<br>&gt; <br>&gt; While the removal of &quot;NS&quot; is far-reaching, prefixes will still be a common occurrence in code written in Swift. UIKit and AppKit, along with all the various frameworks, will still retain their prefixes, so removing prefixes in the case of Foundation types will be more the exception than the norm. As such, any benefit of the removal would be mitigated by the continued use of prefixes for the rest of the first-party types we rely on.<br>&gt; <br>&gt; <br>&gt; In sum, the change would make the language and its APIs more confusing and more difficult to use today, would make it more difficult to migrate to modern designs in the future, and would ultimately provide a very minor benefit. I encourage the Swift core team to reconsider the &quot;Strip the &quot;NS&quot; prefix from Foundation APIs&quot; portion of the proposal.<br>&gt; <br>&gt; Nate<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 30, 2016, at 5:01 PM, Drew Crawford via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I am in favor of this proposal on balance, and I leave the bulk of this to people who interop with Objective-C more often than I do.<br>&gt;&gt; <br>&gt;&gt; I would like to confine my remarks to one corner where I think we are making a very serious mistake.<br>&gt;&gt; <br>&gt;&gt;&gt; The removal of the &quot;NS&quot; prefix for the Foundation module (or other specifically identified modules) is a mechanical translation for all global symbols defined within that module that can be performed in the Clang importer. <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; As I understand it (and I am no Cocoa historian) the NS prefix was originally introduced because Objective-C lacks namespacing.<br>&gt;&gt; <br>&gt;&gt; The thinking seems to be that since Swift has proper namespacing, this historicism is no longer necessary.  I find this argument very flimsy.<br>&gt;&gt; <br>&gt;&gt; Of course Swift has stronger namespacing if one&#39;s frame of reference is Objective-C or C.  But for those of us coming from other language backgrounds, namespacing means something much stronger than Swift&#39;s concept of it.  I don&#39;t mean to suggest that Swift&#39;s design is wrong exactly (less is sometimes more), but I do mean to say that if we propose to undo a decision that worked for several decades and break every Swift project in existence on the theory that Swift&#39;s namespacing is strong enough we had better be right.<br>&gt;&gt; <br>&gt;&gt; For those unfamiliar, I will explain some of the namespacing tools Swift lacks relative to other languages.  First, many languages have a &quot;hierarchical&quot; namespace system, where one can say<br>&gt;&gt; <br>&gt;&gt; import Foundation.Net.URL<br>&gt;&gt; let s = Session(...)<br>&gt;&gt; <br>&gt;&gt; instead of for example<br>&gt;&gt; <br>&gt;&gt; import Foundation<br>&gt;&gt; let s = NSURLSession(...)<br>&gt;&gt; <br>&gt;&gt; Some form of this is used in Rust, Python, and C#, as far as I know.  I believe Swift has some counterfeit version of this, as the book mentions you can import a &quot;submodule &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/import-declaration&gt;&quot;, but I do not know what that is, do not know how to make one, have never seen anyone use one, the book suggests it goes only 2 levels deep, and perhaps as a consequences of some of these problems nobody thought of using this for Foundation.<br>&gt;&gt; <br>&gt;&gt; A closely related difference is the use of so-called &quot;selective&quot; imports, where we import only a single symbol (or a list of explicitly-identified symbols) into the scope.  We might express this as<br>&gt;&gt; <br>&gt;&gt; from Foundation.Net.URL import Session, HTTP //import two classes only<br>&gt;&gt; let s = Session(...)<br>&gt;&gt; <br>&gt;&gt; Again I think Swift technically supports some way to avoid importing a whole gigantic namespace like Foundation, but I am not aware of any actual uses of this feature, and certainly the convention is not to write code this way.  Meanwhile, let&#39;s check in with the Python community, who standardized the following guidance on these &quot;wildcard&quot; imports as part of their language evolution process:<br>&gt;&gt; <br>&gt;&gt;&gt; Wildcard imports ( from &lt;module&gt; import * ) should be avoided, as they make it unclear which names are present in the namespace, confusing both readers and many automated tools. There is one defensible use case for a wildcard import...<br>&gt;&gt; <br>&gt;&gt; When a language has a robust namespacing system, which we do not, there are many follow-on consequences.  One is that an import statement is much more of a scalpel than a bludgeon; each import statement only introduces a handful of new names (even if it is a so-called &quot;wildcard&quot; import that grabs all children of some namespace, most of those children are themselves namespaces), unlike importing Foundation which contains thousands of direct child types that are injected into the local scope.<br>&gt;&gt; <br>&gt;&gt; Another consequence is that class names become quite short, shadow each other, and nobody bats an eye.  I searched the C# standard library for &quot;Session&quot;, and found some 12 classes with that name:<br>&gt;&gt; <br>&gt;&gt; &lt;Screen Shot 2016-01-30 at 3.44.23 PM.png&gt;<br>&gt;&gt; <br>&gt;&gt; These &quot;standard library&quot; classes not only potentially shadow programmer-defined types, they also shadow each other.  But because the C# language has a robust namespacing system, the chances of there being more than one thing called &quot;Session&quot; in scope in your program (or for that matter, when developing the standard library itself) is quite small, so it&#39;s a non-issue.<br>&gt;&gt; <br>&gt;&gt; Now we return to the question of dropping the NS prefix, which will rename thousands of classes in a typical program that has `import Foundation`, in a way that potentially (let&#39;s be honest.  More like &quot;probably&quot;) shadows one or more programmer-defined classes.  Our review criteria is:<br>&gt;&gt; <br>&gt;&gt;&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; No, the elimination of 2 characters is not significant enough of a problem to break all Swift programs, let alone to introduce literally thousands of new opportunities for shadowing.<br>&gt;&gt; <br>&gt;&gt; To its credit, the proposal acknowledges this, and offers a concession:<br>&gt;&gt; <br>&gt;&gt;&gt; Note that this removal can create conflicts with the standard library. For example, NSString and NSArray will become String and Array, respectively, and Foundation&#39;s versions will shadow the standard library&#39;s versions.  In cases where the Swift 3 names of standard library entities conflict with prefix-stripped Foundation entities, we retain the NS prefix. These Foundation entities are: NSArray, NSDictionary, NSInteger, NSRange, NSSet, and NSString.<br>&gt;&gt; <br>&gt;&gt; But of course this needlessly draws a distinction between NSString et al and the &quot;normal&quot; Foundation types, and what&#39;s more it draws that distinction based on the present composition of the Swift standard library and the present composition of Foundation.  But we have already decided not to guarantee the source compatibility of the standard library, so what happens when that composition changes?  Will we then go back and tweak which classes get NS prefixed to them again?<br>&gt;&gt; <br>&gt;&gt; In my view, if Swift&#39;s namespacing is not good enough to let us drop the NS in NSString it is not good enough to drop any prefix.  If we believe that a programmer will struggle to distinguish between Swift String and Foundation String then we should expect them to struggle for any two classes in any two frameworks, and this is special pleading on the part of Foundation.  C#&#39;s libraries declare *twelve* different `Session`s and nobody bats an eye, but we have two types share a name and everybody loses their minds?  Our namespacing is not good enough to kill the prefix, period.<br>&gt;&gt; <br>&gt;&gt; We should either drop these prefixes or we should not; because the claimed motivation–that we have &quot;good enough&quot; namespacing in the language now–is either true or it is not.  This proposal admits that it is not, and tries to drop the prefixes anyway.  I believe that is a mistake.<br>&gt;&gt; <br>&gt;&gt; I certainly support the goal of eliminating these prefixes, they are ugly, they need to be killed, and namespacing is the right solution.  But we must not jump out of the plane until we are very sure our parachute is in order.  In Swift 3 it is not.<br>&gt;&gt; <br>&gt;&gt; I do think the bulk of the proposal is fine, and I apologize for using quite stark language for such a small paragraph in an otherwise reasonable proposal, but I think the problem buried in here is quite serious and is being overlooked.<br>&gt;&gt; <br>&gt;&gt; Drew<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 22, 2016, at 3:02 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The review of SE-0005&quot;Better Translation of Objective-C APIs Into Swift&quot; begins now and runs through January 31, 2016. The proposal is available here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md&gt;<br>&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposal link:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md&gt;<br>&gt;&gt;&gt; Reply text<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Other replies<br>&gt;&gt;&gt;  &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What goes into a review?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What is your evaluation of the proposal?<br>&gt;&gt;&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt;&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt;&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Doug Gregor<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Review Manager<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160205/061802b8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>February  5, 2016 at 11:00:00am</p></header><div class="content"><p>Le 5 févr. 2016 à 7:14, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br></p><p>&gt; I agree with most of the proposal except for &quot;Strip the &quot;NS&quot; prefix from Foundation APIs”. I strongly disagree with this change for the same reasons as Nate:<br>&gt; <br>&gt; - This change will make Foundation types look Swift native enough to confuse some users between the stdlib’s value semantics and Foundation’s reference semantics.<br>&gt; - The change will complicate the creation of a Swift native foundation that uses the power of Swift to provide true value semantics to types that need them (URL, Data, CountedSet, etc…)<br></p><p>But there are also many classes that make perfect sense in Swift as a class: URLSession, Formatter, UndoManager, UserDefaults, XMLParser, Stream, NotificationCenter, RunLoop, etc. What we could do is decide now which Foundation classes should stay classes and which should become structs. Remove the NS prefix from the former, keep it for the later.<br></p><p>Eventually, classes such as NSCountedSet and NSIndexSet will have a proper struct wrapper that will claim the non-prefixed name. But there is no urgency in making those wrappers ready for Swift 3 because the class remains available.<br></p><p>Anyway, that&#39;s what I&#39;d propose. There aren&#39;t that many classes in Foundation; cases like this can be sorted out manually.<br></p><p>-- <br>Michel Fortin<br>https://michelf.ca<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5dd3d9ca6ca38fee028eda9aced22ada?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Erwin Mazariegos</string> &lt;erwinmaza at gmail.com&gt;<p>February  5, 2016 at 12:00:00pm</p></header><div class="content"><p>The points made by Nate regarding his reasons for keeping the &quot;NS&quot; prefix<br>for Foundation types resonated with me, but for slightly different reasons.<br></p><p>In particular, where Nate states &quot;Prefix-less Foundation types will blur<br>the different norms and expectations for Foundation types vs what we have<br>in the Swift standard library&quot; contrasting Foundation and the Swift<br>standard library, this is very similar to my concern for being able to<br>differentiate between Foundation and app-specific custom types.<br></p><p>When working with an app&#39;s codebase, it is helpful to immediately be able<br>to tell where a particular type &quot;comes from&quot;. Is this an instance of an<br>object defined in this app&#39;s codebase, or is it a Foundation object? There<br>are &quot;different norms and expectations for Foundation types&quot; in this<br>direction as well. Forcing readers of the code to click through to the<br>object type&#39;s definition (or perform a project-wide search) just to<br>discover the type is Foundation, is wasteful.<br></p><p>Swift&#39;s namespacing removes the technical requirement to prefix types as<br>became the norm in Objective-C. But there remain understandability<br>requirements that we should maintain.<br></p><p>Broadening the topic of prefixes beyond Foundation, it would be helpful to<br>keep the convention of prefixing types that are designed to be used as part<br>of a library, and leaving app-specific (or end-user-developer) types<br>unprefixed if desired.<br></p><p>Personally I am enjoying the safety of not having to prefix custom types in<br>my apps. But if I was writing a third-party library, I would want to use a<br>&quot;signature prefix&quot; on my types. Similarly, the NS prefix should remain on<br>Apple-supplied Foundation types.<br></p><p>This prefix-for-library-types convention would make it easier to quickly<br>grasp where a particular piece of functionality in a codebase is coming<br>from, so we can apply norms and expectations regarding the source.<br></p><p>Removing the NS prefix from Foundation types has large code<br>understandability/readability costs with little to no benefit for app<br>developers.<br></p><p><br></p><p>Regards,<br>----<br>Erwin Mazariegos<br>Austin, TX<br></p><p>On Fri, Feb 5, 2016 at 10:54 AM, Michel Fortin via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Le 5 févr. 2016 à 7:14, David Hart via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;<br>&gt; &gt; I agree with most of the proposal except for &quot;Strip the &quot;NS&quot; prefix from<br>&gt; Foundation APIs”. I strongly disagree with this change for the same reasons<br>&gt; as Nate:<br>&gt; &gt;<br>&gt; &gt; - This change will make Foundation types look Swift native enough to<br>&gt; confuse some users between the stdlib’s value semantics and Foundation’s<br>&gt; reference semantics.<br>&gt; &gt; - The change will complicate the creation of a Swift native foundation<br>&gt; that uses the power of Swift to provide true value semantics to types that<br>&gt; need them (URL, Data, CountedSet, etc…)<br>&gt;<br>&gt; But there are also many classes that make perfect sense in Swift as a<br>&gt; class: URLSession, Formatter, UndoManager, UserDefaults, XMLParser, Stream,<br>&gt; NotificationCenter, RunLoop, etc. What we could do is decide now which<br>&gt; Foundation classes should stay classes and which should become structs.<br>&gt; Remove the NS prefix from the former, keep it for the later.<br>&gt;<br>&gt; Eventually, classes such as NSCountedSet and NSIndexSet will have a proper<br>&gt; struct wrapper that will claim the non-prefixed name. But there is no<br>&gt; urgency in making those wrappers ready for Swift 3 because the class<br>&gt; remains available.<br>&gt;<br>&gt; Anyway, that&#39;s what I&#39;d propose. There aren&#39;t that many classes in<br>&gt; Foundation; cases like this can be sorted out manually.<br>&gt;<br>&gt; --<br>&gt; Michel Fortin<br>&gt; https://michelf.ca<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160205/5f8322d3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>February  5, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On 5 Feb 2016, at 18:22, Erwin Mazariegos via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Broadening the topic of prefixes beyond Foundation, it would be helpful to keep the convention of prefixing types that are designed to be used as part of a library, and leaving app-specific (or end-user-developer) types unprefixed if desired.<br></p><p>While I agree with this in theory, the problem with prefixing is what to choose; NS is nice and simple so it’s not much of a burden, but how many two letter prefixes can we expect before it gets confusing anyway, or you forget what the prefix is for?<br></p><p>Personally I’d prefer to make sure that Xcode exposes the namespace of a type as clearly as possible, e.g if you hover over the type it should expand to give a fully qualified name in addition to any documentation etc., leaving no ambiguity. In other words I wonder if name clashes is really a naming problem, or if it’s something that a good GUI should be able to handle for us. After all we can’t rely on every developer adding a prefix or suffix, and sometimes that commonly used name just happens to be the most appropriate.<br></p><p>I can’t count the number of times I’ve named something Node because I couldn’t think of anything more relevant, but likewise couldn’t find enough commonality to factor it out into a single type, resulting little nested Node types here and there. At least with the private keyword we can be clear that a developer need search no further, but I think it’s just a problem that can and will occur regardless of guidelines, so the tools need to be able to cope when it does.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>February  5, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; Le 5 févr. 2016 à 19:22, Erwin Mazariegos via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Personally I am enjoying the safety of not having to prefix custom types in my apps. But if I was writing a third-party library, I would want to use a &quot;signature prefix&quot; on my types. Similarly, the NS prefix should remain on Apple-supplied Foundation types. <br></p><p>This is a very interesting topic.<br></p><p>I personally don’t use any prefix, but I’m still very careful to avoid names that are too general.<br></p><p>Looking at the main public types of my http://github.com/groue/GRDB.swift (I mean the types that the library user is likely to write in her own code, not the types of temporary values that are usually not written thanks to the Swift type inference), you should be able to guess what the library is about:<br></p><p>Concrete types:<br>- Configuration<br>- DatabaseQueue<br>- DatabaseMigrator<br>- Record<br>- Row<br>- SQLColumn<br></p><p>Errors:<br>- PersistenceError<br>- DatabaseError<br></p><p>Protocols:<br>- DatabaseValueConvertible<br>- Persistable<br>- RowConvertible<br>- TableMapping<br></p><p>The only exceptions are Configuration and Row. I did not feel like I should have named them more precisely because both types are very locally and contextually used. Conflict with user types is possible, but an explicit scoping with the module name is not too costly. That’s a feeling I can rationalize, but mainly it has not been (yet) contradicted by experience.<br></p><p>Record and Persistable are arguably database-ish enough for being kind of self-documenting without any further prefixing.<br></p><p>So, no, I don’t think prefixes are mandatory, or even should be generally recommended. Third-party libraries need their author to avoid likely naming conflicts. BTW, it’s an interesting sub-topic of the discussion about the very general Either and Result types: I can understand why some don’t feel well when they expose such a type in their library, and why they ask for a standard one.<br></p><p>Now, Foundation is a different story, because both Foundation and the Swift Standard Library want to provide basic needs. I would not be disappointed if Foundation would keep the NS prefix, so that the Swift Standard Library has room to expand. Just as Set was eventually introduced as an alternative to NSSet, regular expressions, paths manipulation, trees, etc. are all basic types that will be happy having a blessed Swift version in the future.<br></p><p>Gwendal<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160205/8b59c034/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f1b93037cbc5f78f16450bd925ce3b5b?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Marco Masser</string> &lt;lists at duckcode.com&gt;<p>February  8, 2016 at 11:00:00am</p></header><div class="content"><p>I know I’m late to the party and the review period has ended, but I’d like to add a suggestion towards a possible solution to a point that was discussed in this context.<br></p><p>&gt; On 2016-02-05, at 17:54, Michel Fortin via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; […]<br>&gt; <br>&gt; Eventually, classes such as NSCountedSet and NSIndexSet will have a proper struct wrapper that will claim the non-prefixed name. But there is no urgency in making those wrappers ready for Swift 3 because the class remains available.<br>&gt; <br>&gt; Anyway, that&#39;s what I&#39;d propose. There aren&#39;t that many classes in Foundation; cases like this can be sorted out manually.<br></p><p>I wholeheartedly agree with this: I’d take a close look at every class in Foundation that should really be a value type in Swift (all collection types, NSURL, …) and keep the NS prefix for them. Then, at some later point (or with Swift 3 if there’s enough time), add struct wrappers without the NS prefix for these classes.<br></p><p>I want to outline a possible solution to this that allows all developers to annotate their classes and have them automatically imported as structs in Swift.<br>I think that could actually work with just a couple of annotations in the Objective-C headers and the correct interpretation of them in the Clang Importer. I’d propose something like this:<br></p><p>@interface NS_SWIFT_STRUCT(CountedSet) NSCountedSet&lt;ObjectType&gt; : NSMutableSet&lt;ObjectType&gt; {<br></p><p>@property BOOL foo; // Just for demonstration purposes.<br></p><p>- (NSUInteger)countForObject:(ObjectType)object;<br>- (void)addObject:(ObjectType)object NS_SWIFT_MUTATING;<br>- (void)removeObject:(ObjectType)object NS_SWIFT_MUTATING;<br></p><p>…<br></p><p>@end<br></p><p>In Swift, that would come through as the following (in addition to an NSCountedSet class):<br></p><p>struct CountedSet&lt;ObjectType&gt; {<br>    private let _internal: NSCountedSet<br></p><p>    var foo: Bool<br></p><p>    func countForObject(object: ObjectType) -&gt; Int<br>    mutating func addObject(object: ObjectType)<br>    mutating func removeObject(object: ObjectType)<br></p><p>    …<br></p><p>}<br></p><p>That is: NS_SWIFT_STRUCT(_name) specifies that a struct with the given _name should be created that has a private let member of the annotated class. All methods of the class and all its superclasses are automatically imported as methods of the struct. Methods annotated as  NS_SWIFT_MUTATING are imported as mutating methods in the Swift struct. For @property declarations, the importer could automatically infer that the setter is mutating and the getter nonmutating, although an NS_SWIFT_NONMUTATING might be useful to annotate that a property setter should be imported as nonmutating, if applicable.<br></p><p>After a quick glance over all of Foundation’s classes, I think the following could be eligible (probably not a complete list):<br>NSAttributedString<br>NSCharacterSet<br>NSCountedSet<br>NSData<br>NSDate<br>NSDecimalNumber<br>NSError<br>NSHashTable<br>NSIndexPath<br>NSIndexSet<br>NSNotification<br>NSNumber/NSValue<br>NSOrderedSet<br>NSURL<br>NSUUID<br></p><p>Whereas for some classes it would be better to use the mutable variants as the internal storage for the Swift struct:<br>NSMutableAttributedString (as AttributedString)<br>NSMutableCharacterSet (as CharacterSet)<br>NSMutableData (as Data)<br>NSMutableIndexSet (as IndexSet)<br>NSMutableOrderedSet (as OrderedSet)<br></p><p><br>The Clang Importer could also handle the case where passing a Swift URL to an Objective-C method that expects an NSURL could work automatically. Maybe an Objective-C methods like this:<br></p><p>- (void)methodImplementedInObjectiveC:(NSURL *)arg;<br></p><p>… could be imported into Swift like this:<br></p><p>func methodImplementedInObjectiveC(arg: NSURL)<br>func methodImplementedInObjectiveC(inout arg: URL) // Objective-C code operates on arg._internal<br></p><p><br>If the struct wraps a class that has a mutable counterpart (this would have to be annotated somehow), the import could do a better job for the nonmutating variant. This would require a variant of the NS_SWIFT_STRUCT(_name) macro that takes another parameter that points to the nonmutating variant. Then, the following methods:<br></p><p>- (void)nonmutatingMethodImplementedInObjectiveC:(NSData *)arg;<br>- (void)mutatingMethodImplementedInObjectiveC:(NSMutableData *)arg;<br></p><p>… could be imported into Swift like this:<br></p><p>func nonmutatingMethodImplementedInObjectiveC(arg: Data)<br>func mutatingMethodImplementedInObjectiveC(inout arg: Data) // Objective-C code operates on arg._internal<br></p><p><br>Annotations like this would be very useful because it would also allow developers to annotate their own classes like this. It’s not uncommon to have model objects that could sensibly be structs in Swift, but can’t because existing Objective-C code requires them to be classes.<br></p><p>When Objective-C classes become Swift structs, they obviously lose their inheritance chain and therefore polymorphic properties. I haven’t done a survey, but my gut feeling tells me that the classes for which all this is relevant – i.e. those that should have value semantics – aren’t usually subclassed and this point could therefore be moot. I may be wrong about that, though.<br></p><p><br>There are probably a lot of additional things to specify here, but maybe this could be a way forward. It would enable using things like NSCountedSet and NSURL in Swift just like it does now, with the possibility to add value types for them later without breaking existing code. In time, the classes could also be deprecated in favor of the struct, if that is desired.<br></p><p><br>Cheers,<br></p><p>Marco<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160208/87cbc40f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>February 11, 2016 at 02:00:00pm</p></header><div class="content"><p>I like your idea, I think you may need a protocol for each class though.<br>It&#39;s possible for NSNumber to be used as an NSValue, for example.<br></p><p>On Monday, 8 February 2016, Marco Masser via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I know I’m late to the party and the review period has ended, but I’d like<br>&gt; to add a suggestion towards a possible solution to a point that was<br>&gt; discussed in this context.<br>&gt;<br>&gt; On 2016-02-05, at 17:54, Michel Fortin via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt; […]<br>&gt;<br>&gt;<br>&gt; Eventually, classes such as NSCountedSet and NSIndexSet will have a proper<br>&gt; struct wrapper that will claim the non-prefixed name. But there is no<br>&gt; urgency in making those wrappers ready for Swift 3 because the class<br>&gt; remains available.<br>&gt;<br>&gt; Anyway, that&#39;s what I&#39;d propose. There aren&#39;t that many classes in<br>&gt; Foundation; cases like this can be sorted out manually.<br>&gt;<br>&gt;<br>&gt; I wholeheartedly agree with this: I’d take a close look at every class in<br>&gt; Foundation that should really be a value type in Swift (all collection<br>&gt; types, NSURL, …) and keep the NS prefix for them. Then, at some later point<br>&gt; (or with Swift 3 if there’s enough time), add struct wrappers without the<br>&gt; NS prefix for these classes.<br>&gt;<br>&gt; I want to outline a possible solution to this that allows all developers<br>&gt; to annotate their classes and have them automatically imported as structs<br>&gt; in Swift.<br>&gt; I think that could actually work with just a couple of annotations in the<br>&gt; Objective-C headers and the correct interpretation of them in the Clang<br>&gt; Importer. I’d propose something like this:<br>&gt;<br>&gt; @interface NS_SWIFT_STRUCT(CountedSet) NSCountedSet&lt;ObjectType&gt; :<br>&gt; NSMutableSet&lt;ObjectType&gt; {<br>&gt;<br>&gt; @property BOOL foo; // Just for demonstration purposes.<br>&gt;<br>&gt; - (NSUInteger)countForObject:(ObjectType)object;<br>&gt; - (void)addObject:(ObjectType)object NS_SWIFT_MUTATING;<br>&gt; - (void)removeObject:(ObjectType)object NS_SWIFT_MUTATING;<br>&gt;<br>&gt; …<br>&gt;<br>&gt; @end<br>&gt;<br>&gt; In Swift, that would come through as the following (in addition to an<br>&gt; NSCountedSet class):<br>&gt;<br>&gt; struct CountedSet&lt;ObjectType&gt; {<br>&gt;     private let _internal: NSCountedSet<br>&gt;<br>&gt;     var foo: Bool<br>&gt;<br>&gt;     func countForObject(object: ObjectType) -&gt; Int<br>&gt;     mutating func addObject(object: ObjectType)<br>&gt;     mutating func removeObject(object: ObjectType)<br>&gt;<br>&gt;     …<br>&gt;<br>&gt; }<br>&gt;<br>&gt; That is: NS_SWIFT_STRUCT(_name) specifies that a struct with the given<br>&gt; _name should be created that has a private let member of the annotated<br>&gt; class. All methods of the class and all its superclasses are<br>&gt; automatically imported as methods of the struct. Methods annotated as<br>&gt; NS_SWIFT_MUTATING are imported as mutating methods in the Swift struct.<br>&gt; For @property declarations, the importer could automatically infer that<br>&gt; the setter is mutating and the getter nonmutating, although an<br>&gt; NS_SWIFT_NONMUTATING might be useful to annotate that a property setter<br>&gt; should be imported as nonmutating, if applicable.<br>&gt;<br>&gt; After a quick glance over all of Foundation’s classes, I think the<br>&gt; following could be eligible (probably not a complete list):<br>&gt; NSAttributedString<br>&gt; NSCharacterSet<br>&gt; NSCountedSet<br>&gt; NSData<br>&gt; NSDate<br>&gt; NSDecimalNumber<br>&gt; NSError<br>&gt; NSHashTable<br>&gt; NSIndexPath<br>&gt; NSIndexSet<br>&gt; NSNotification<br>&gt; NSNumber/NSValue<br>&gt; NSOrderedSet<br>&gt; NSURL<br>&gt; NSUUID<br>&gt;<br>&gt; Whereas for some classes it would be better to use the mutable variants as<br>&gt; the internal storage for the Swift struct:<br>&gt; NSMutableAttributedString (as AttributedString)<br>&gt; NSMutableCharacterSet (as CharacterSet)<br>&gt; NSMutableData (as Data)<br>&gt; NSMutableIndexSet (as IndexSet)<br>&gt; NSMutableOrderedSet (as OrderedSet)<br>&gt;<br>&gt;<br>&gt; The Clang Importer could also handle the case where passing a Swift URL to<br>&gt; an Objective-C method that expects an NSURL could work automatically. Maybe<br>&gt; an Objective-C methods like this:<br>&gt;<br>&gt; - (void)methodImplementedInObjectiveC:(NSURL *)arg;<br>&gt;<br>&gt; … could be imported into Swift like this:<br>&gt;<br>&gt; func methodImplementedInObjectiveC(arg: NSURL)<br>&gt; func methodImplementedInObjectiveC(inout arg: URL) // Objective-C code<br>&gt; operates on arg._internal<br>&gt;<br>&gt;<br>&gt; If the struct wraps a class that has a mutable counterpart (this would<br>&gt; have to be annotated somehow), the import could do a better job for the<br>&gt; nonmutating variant. This would require a variant of the<br>&gt; NS_SWIFT_STRUCT(_name) macro that takes another parameter that points to<br>&gt; the nonmutating variant. Then, the following methods:<br>&gt;<br>&gt; - (void)nonmutatingMethodImplementedInObjectiveC:(NSData *)arg;<br>&gt; - (void)mutatingMethodImplementedInObjectiveC:(NSMutableData *)arg;<br>&gt;<br>&gt; … could be imported into Swift like this:<br>&gt;<br>&gt; func nonmutatingMethodImplementedInObjectiveC(arg: Data)<br>&gt; func mutatingMethodImplementedInObjectiveC(inout arg: Data) //<br>&gt; Objective-C code operates on arg._internal<br>&gt;<br>&gt;<br>&gt; Annotations like this would be very useful because it would also allow<br>&gt; developers to annotate their own classes like this. It’s not uncommon to<br>&gt; have model objects that could sensibly be structs in Swift, but can’t<br>&gt; because existing Objective-C code requires them to be classes.<br>&gt;<br>&gt; When Objective-C classes become Swift structs, they obviously lose their<br>&gt; inheritance chain and therefore polymorphic properties. I haven’t done a<br>&gt; survey, but my gut feeling tells me that the classes for which all this<br>&gt; is relevant – i.e. those that should have value semantics – aren’t usually<br>&gt; subclassed and this point could therefore be moot. I may be wrong about<br>&gt; that, though.<br>&gt;<br>&gt;<br>&gt; There are probably a lot of additional things to specify here, but maybe<br>&gt; this could be a way forward. It would enable using things like NSCountedSet<br>&gt; and NSURL in Swift just like it does now, with the possibility to add value<br>&gt; types for them later without breaking existing code. In time, the classes could<br>&gt; also be deprecated in favor of the struct, if that is desired.<br>&gt;<br>&gt;<br>&gt; Cheers,<br>&gt;<br>&gt; Marco<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/89ac8f94/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f1b93037cbc5f78f16450bd925ce3b5b?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Marco Masser</string> &lt;lists at duckcode.com&gt;<p>February 12, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On 2016-02-11, at 06:32, Andrew Bennett &lt;cacoyi at gmail.com&gt; wrote:<br>&gt; <br>&gt; I like your idea, I think you may need a protocol for each class though. It&#39;s possible for NSNumber to be used as an NSValue, for example.<br></p><p>You’re right, that’s one case where the missing inheritance hierarchy after changing to structs would cause troubles. Using protocols to fix that is a good idea that has two implications I think are worth mentioning:<br></p><p>• On the plus side: Converting Objective-C classes into protocols along with a conforming struct would make something like inheritance possible again via protocol conformance.<br>For example, if the NSCountedSet Objective-C class became a CountedSet Swift protocol along with a CountedSetImpl (or whatever) Swift struct that conforms to it, you could write your own type that conforms to the CountedSet protocol and use that with every existing Objective-C code that expects an NSCountedSet. That sounds super awesome!<br></p><p>• On the minus side: As the above point shows, this indirection via protocols makes everything more complex.<br>Maybe this takes just some getting used to Protocol Oriented Programming, but I’m not sure that if I’d design an API right now that has to work on a new type Foo that I’d declare a protocol called Foo along with a FooImpl (or whatever) class or struct.<br>OK, maybe I would 😀<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be4c3c3b76631a155e1358db48066692?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Tony Parker</string> &lt;anthony.parker at apple.com&gt;<p>February 12, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Feb 12, 2016, at 1:28 AM, Marco Masser via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 2016-02-11, at 06:32, Andrew Bennett &lt;cacoyi at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I like your idea, I think you may need a protocol for each class though. It&#39;s possible for NSNumber to be used as an NSValue, for example.<br>&gt; <br>&gt; You’re right, that’s one case where the missing inheritance hierarchy after changing to structs would cause troubles. Using protocols to fix that is a good idea that has two implications I think are worth mentioning:<br>&gt; <br>&gt; • On the plus side: Converting Objective-C classes into protocols along with a conforming struct would make something like inheritance possible again via protocol conformance.<br>&gt; For example, if the NSCountedSet Objective-C class became a CountedSet Swift protocol along with a CountedSetImpl (or whatever) Swift struct that conforms to it, you could write your own type that conforms to the CountedSet protocol and use that with every existing Objective-C code that expects an NSCountedSet. That sounds super awesome!<br></p><p>Close… but every Objective-C method that takes an NSCountedSet assumes that that NSCountedSet is a subclass of NSObject.<br></p><p>There are some other complexities to this approach as well: how do we deal with types that are pointers-to-pointers in Objective-C? (API that takes NSCountedSet **, e.g.). What about types where frameworks layer on functionality via categories?<br></p><p>I have some ideas on this topic but I’m still working on it.<br></p><p>- Tony<br></p><p>&gt; <br>&gt; • On the minus side: As the above point shows, this indirection via protocols makes everything more complex.<br>&gt; Maybe this takes just some getting used to Protocol Oriented Programming, but I’m not sure that if I’d design an API right now that has to work on a new type Foo that I’d declare a protocol called Foo along with a FooImpl (or whatever) class or struct.<br>&gt; OK, maybe I would 😀<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f1b93037cbc5f78f16450bd925ce3b5b?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Marco Masser</string> &lt;lists at duckcode.com&gt;<p>February 13, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On 2016-02-12, at 20:58, Tony Parker &lt;anthony.parker at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Feb 12, 2016, at 1:28 AM, Marco Masser via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; […]<br>&gt;&gt; <br>&gt;&gt; • On the plus side: Converting Objective-C classes into protocols along with a conforming struct would make something like inheritance possible again via protocol conformance.<br>&gt;&gt; For example, if the NSCountedSet Objective-C class became a CountedSet Swift protocol along with a CountedSetImpl (or whatever) Swift struct that conforms to it, you could write your own type that conforms to the CountedSet protocol and use that with every existing Objective-C code that expects an NSCountedSet. That sounds super awesome!<br>&gt; <br>&gt; Close… but every Objective-C method that takes an NSCountedSet assumes that that NSCountedSet is a subclass of NSObject.<br></p><p>Right, that’s a problem. It could work if the CountedSet protocol requires having an NSCountedSet property:<br></p><p>protocol CountedSet {<br>    var storage: NSCountedSet { get }<br></p><p>    // All of NSCountedSet and its superclasses&#39; methods<br>    ...<br>}<br></p><p>… and bridging between the CountedSet Swift protocol’s storage and NSCountedSet parameters to Objective-C methods worked automatically. But I don’t like this approach because the nice abstraction of the CountedSet protocol is useless when it is tied to the Objective-C class anyways.<br></p><p><br>&gt; There are some other complexities to this approach as well: how do we deal with types that are pointers-to-pointers in Objective-C? (API that takes NSCountedSet **, e.g.). What about types where frameworks layer on functionality via categories?<br></p><p>Yet another problem with this approach…<br></p><p><br>&gt; I have some ideas on this topic but I’m still working on it.<br></p><p>I’d love to hear those ideas when you’re ready to share them!<br></p><p><br>Taking a step back, I think all these problems seem like they have already been solved in Swift’s Array, String, Dictionary, and Set structs in that they bridge to their Foundation Objective-C counterparts seamlessly and they make categories to the Objective-C classes available on the Swift structs. I haven’t looked at the source, but I assume all of these bridges are special cases and require a lot of code to work. If that mechanism could be made to work for arbitrary class types, I think the problem would be solved, wouldn’t it?<br></p><p>Cheers,<br></p><p>Marco<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160213/b472dfd3/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>February  5, 2016 at 10:00:00pm</p></header><div class="content"><p>Seems my mail got lost, so I&#39;d like to add my voice to the concerns about removing the NS prefix expressed by Nate, David and others. As them I am strongly against dropping the NS prefix for types that are not Vey Swift-like meaning especially types which should be Swift value types (like an URL should be) but aren&#39;t.<br></p><p>I haven&#39;t followed the general discussion about this proposal closely except for this issue, so I won&#39;t say much about the rest of this proposal except that it did seem fine when glancing over the discussion.<br></p><p>-Thorsten <br></p><p>&gt; Am 05.02.2016 um 13:14 schrieb David Hart via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; I’d like to voice my opinion before is too late and reiterate what Nate said. Although I’m not going to add much, because Nate already said it all better than I could.<br>&gt; <br>&gt; • What is your evaluation of the proposal?<br>&gt; <br>&gt; I agree with most of the proposal except for &quot;Strip the &quot;NS&quot; prefix from Foundation APIs”. I strongly disagree with this change for the same reasons as Nate:<br>&gt; <br>&gt; - This change will make Foundation types look Swift native enough to confuse some users between the stdlib’s value semantics and Foundation’s reference semantics.<br>&gt; - The change will complicate the creation of a Swift native foundation that uses the power of Swift to provide true value semantics to types that need them (URL, Data, CountedSet, etc…)<br>&gt; <br>&gt; • Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; <br>&gt; I don’t necessarily think that the problem being addressed is that significant, but the change is appreciated (except for the NS prefix). To be honest, I would have preferred more design and development effort to go towards enhancing the Swift language itself, or the emergence of a real Swift foundation framework.<br>&gt; <br>&gt; • Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; It does.<br>&gt; <br>&gt; • If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; <br>&gt; Nothing to say here.<br>&gt; <br>&gt; • How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; I have kept up with the discussion since the start and have tried to keep an open mind about everybody’s opinion.<br>&gt; <br>&gt; David.<br>&gt; <br>&gt; <br>&gt;&gt; On 01 Feb 2016, at 22:10, Nate Cook via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This is a concurring opinion with Drew&#39;s review, agreeing that we should reconsider removing the &quot;NS&quot; prefix but providing my own reasons. The proposal as a whole is exciting and far-reaching, but this particular change is misguided. My objections are:<br>&gt;&gt; <br>&gt;&gt; 1) The change will elide the different semantic expectations for Foundation and Swift standard library types.<br>&gt;&gt; <br>&gt;&gt; Prefix-less Foundation types will blur the different norms and expectations for Foundation types vs what we have in the Swift standard library, particularly in regards to value vs reference semantics of collection types. <br>&gt;&gt; <br>&gt;&gt; The Swift standard library defines Array, Set, and Dictionary as collection types with value semantics that operate quite differently from their peers in Foundation. This change will introduce OrderedSet, CountedSet, HashTable, MapTable, and others, all of which use reference semantics and therefore don&#39;t provide the same set of guarantees about ownership and immutability.<br>&gt;&gt; <br>&gt;&gt; As an example, the seemingly similar Set and CountedSet types produce different results from nearly identical code. Swift&#39;s Set type has value semantics, so changes to a copy don&#39;t affect the original Set instance:<br>&gt;&gt; <br>&gt;&gt; let simpleSet = Set([&quot;one&quot;, &quot;two&quot;, &quot;three&quot;])<br>&gt;&gt; var copiedSimpleSet = simpleSet<br>&gt;&gt; copiedSimpleSet.remove(&quot;one&quot;)<br>&gt;&gt; <br>&gt;&gt; copiedSimpleSet.contains(&quot;one&quot;)  // false<br>&gt;&gt; simpleSet.contains(&quot;one&quot;)        // true<br>&gt;&gt; <br>&gt;&gt; CountedSet (née NSCountedSet), on the other hand, uses reference semantics, so changes to a copy of an instance. This is true whether the copy is an explicit one made via assignment or the implicit copy made when calling a function with CountedSet as a parameter. This example shows how nearly code nearly identical to the above produces very different results:<br>&gt;&gt; <br>&gt;&gt; let countedSet = CountedSet(array: [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;])<br>&gt;&gt; var copiedCountedSet = countedSet<br>&gt;&gt; copiedCountedSet.remove(&quot;one&quot;)<br>&gt;&gt; <br>&gt;&gt; copiedCountedSet.contains(&quot;one&quot;) // false<br>&gt;&gt; countedSet.contains(&quot;one&quot;)       // false!<br>&gt;&gt; <br>&gt;&gt; Collections constructed from immutable/mutable class clusters (like OrderedSet and MutableOrderedSet) pose the same problems, since you may be using a mutable instance of the &quot;immutable&quot; collection. We clearly are already dealing with this difference today, but eliminating the &quot;NS&quot; prefix implies that Foundation types are on the same level as the standard library. This makes the confusion more pronounced and significantly increases both the learning curve of the Swift &amp; Foundation APIs and the risk of errors when using different collection types.<br>&gt;&gt; <br>&gt;&gt; 2) The change may stifle the development of more Swift-oriented APIs.<br>&gt;&gt; <br>&gt;&gt; Foundation types were developed in and for a language that uses reference semantics and subclassing, rather than value semantics and a protocol-oriented approach. The designs therefore use and reinforce norms that relate better to Objective-C than to Swift—class clusters of non-final, immutable types with mutable subclasses, immutable types with separate but related mutable counterparts, etc.<br>&gt;&gt; <br>&gt;&gt; A Swift-native CountedSet (and other collections) would surely have value semantics built in. What about other types—do the new Calendar/Date/DateComponents types look like the system that we would design from the ground up in Swift? How about URL and URLComponents? Dropping the &quot;NS&quot; prefix would make it more difficult to gradually expand the standard library to encompass bridging versions of these and other common types.<br>&gt;&gt; <br>&gt;&gt; 3) The change will make it harder to find information about the revised APIs.<br>&gt;&gt; <br>&gt;&gt; Excellent search-ability is an unintended benefit of the &quot;NS&quot; prefix, and can be understood as a way that these types avoid collisions in the vast namespace-less sea of Internet search results. Searching for help with URL and Calendar will be much more difficult than their NS&#39;ed counterparts.<br>&gt;&gt; <br>&gt;&gt; Especially given the challenges that this proposal will pose for code sourced from tutorials, blog posts, Stack Overflow answers, etc., keeping at least the class names as sign posts seems valuable.<br>&gt;&gt; <br>&gt;&gt; 4) We&#39;ll still be using prefixes after the change.<br>&gt;&gt; <br>&gt;&gt; While the removal of &quot;NS&quot; is far-reaching, prefixes will still be a common occurrence in code written in Swift. UIKit and AppKit, along with all the various frameworks, will still retain their prefixes, so removing prefixes in the case of Foundation types will be more the exception than the norm. As such, any benefit of the removal would be mitigated by the continued use of prefixes for the rest of the first-party types we rely on.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; In sum, the change would make the language and its APIs more confusing and more difficult to use today, would make it more difficult to migrate to modern designs in the future, and would ultimately provide a very minor benefit. I encourage the Swift core team to reconsider the &quot;Strip the &quot;NS&quot; prefix from Foundation APIs&quot; portion of the proposal.<br>&gt;&gt; <br>&gt;&gt; Nate<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 30, 2016, at 5:01 PM, Drew Crawford via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I am in favor of this proposal on balance, and I leave the bulk of this to people who interop with Objective-C more often than I do.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would like to confine my remarks to one corner where I think we are making a very serious mistake.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The removal of the &quot;NS&quot; prefix for the Foundation module (or other specifically identified modules) is a mechanical translation for all global symbols defined within that module that can be performed in the Clang importer. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As I understand it (and I am no Cocoa historian) the NS prefix was originally introduced because Objective-C lacks namespacing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The thinking seems to be that since Swift has proper namespacing, this historicism is no longer necessary.  I find this argument very flimsy.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Of course Swift has stronger namespacing if one&#39;s frame of reference is Objective-C or C.  But for those of us coming from other language backgrounds, namespacing means something much stronger than Swift&#39;s concept of it.  I don&#39;t mean to suggest that Swift&#39;s design is wrong exactly (less is sometimes more), but I do mean to say that if we propose to undo a decision that worked for several decades and break every Swift project in existence on the theory that Swift&#39;s namespacing is strong enough we had better be right.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For those unfamiliar, I will explain some of the namespacing tools Swift lacks relative to other languages.  First, many languages have a &quot;hierarchical&quot; namespace system, where one can say<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; import Foundation.Net.URL<br>&gt;&gt;&gt; let s = Session(...)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; instead of for example<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; import Foundation<br>&gt;&gt;&gt; let s = NSURLSession(...)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Some form of this is used in Rust, Python, and C#, as far as I know.  I believe Swift has some counterfeit version of this, as the book mentions you can import a &quot;submodule&quot;, but I do not know what that is, do not know how to make one, have never seen anyone use one, the book suggests it goes only 2 levels deep, and perhaps as a consequences of some of these problems nobody thought of using this for Foundation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A closely related difference is the use of so-called &quot;selective&quot; imports, where we import only a single symbol (or a list of explicitly-identified symbols) into the scope.  We might express this as<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; from Foundation.Net.URL import Session, HTTP //import two classes only<br>&gt;&gt;&gt; let s = Session(...)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Again I think Swift technically supports some way to avoid importing a whole gigantic namespace like Foundation, but I am not aware of any actual uses of this feature, and certainly the convention is not to write code this way.  Meanwhile, let&#39;s check in with the Python community, who standardized the following guidance on these &quot;wildcard&quot; imports as part of their language evolution process:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Wildcard imports ( from &lt;module&gt; import * ) should be avoided, as they make it unclear which names are present in the namespace, confusing both readers and many automated tools. There is one defensible use case for a wildcard import...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When a language has a robust namespacing system, which we do not, there are many follow-on consequences.  One is that an import statement is much more of a scalpel than a bludgeon; each import statement only introduces a handful of new names (even if it is a so-called &quot;wildcard&quot; import that grabs all children of some namespace, most of those children are themselves namespaces), unlike importing Foundation which contains thousands of direct child types that are injected into the local scope.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another consequence is that class names become quite short, shadow each other, and nobody bats an eye.  I searched the C# standard library for &quot;Session&quot;, and found some 12 classes with that name:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &lt;Screen Shot 2016-01-30 at 3.44.23 PM.png&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; These &quot;standard library&quot; classes not only potentially shadow programmer-defined types, they also shadow each other.  But because the C# language has a robust namespacing system, the chances of there being more than one thing called &quot;Session&quot; in scope in your program (or for that matter, when developing the standard library itself) is quite small, so it&#39;s a non-issue.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now we return to the question of dropping the NS prefix, which will rename thousands of classes in a typical program that has `import Foundation`, in a way that potentially (let&#39;s be honest.  More like &quot;probably&quot;) shadows one or more programmer-defined classes.  Our review criteria is:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No, the elimination of 2 characters is not significant enough of a problem to break all Swift programs, let alone to introduce literally thousands of new opportunities for shadowing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To its credit, the proposal acknowledges this, and offers a concession:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Note that this removal can create conflicts with the standard library. For example, NSString and NSArray will become String and Array, respectively, and Foundation&#39;s versions will shadow the standard library&#39;s versions.  In cases where the Swift 3 names of standard library entities conflict with prefix-stripped Foundation entities, we retain the NS prefix. These Foundation entities are: NSArray, NSDictionary, NSInteger, NSRange, NSSet, and NSString.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But of course this needlessly draws a distinction between NSString et al and the &quot;normal&quot; Foundation types, and what&#39;s more it draws that distinction based on the present composition of the Swift standard library and the present composition of Foundation.  But we have already decided not to guarantee the source compatibility of the standard library, so what happens when that composition changes?  Will we then go back and tweak which classes get NS prefixed to them again?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In my view, if Swift&#39;s namespacing is not good enough to let us drop the NS in NSString it is not good enough to drop any prefix.  If we believe that a programmer will struggle to distinguish between Swift String and Foundation String then we should expect them to struggle for any two classes in any two frameworks, and this is special pleading on the part of Foundation.  C#&#39;s libraries declare *twelve* different `Session`s and nobody bats an eye, but we have two types share a name and everybody loses their minds?  Our namespacing is not good enough to kill the prefix, period.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We should either drop these prefixes or we should not; because the claimed motivation–that we have &quot;good enough&quot; namespacing in the language now–is either true or it is not.  This proposal admits that it is not, and tries to drop the prefixes anyway.  I believe that is a mistake.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I certainly support the goal of eliminating these prefixes, they are ugly, they need to be killed, and namespacing is the right solution.  But we must not jump out of the plane until we are very sure our parachute is in order.  In Swift 3 it is not.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I do think the bulk of the proposal is fine, and I apologize for using quite stark language for such a small paragraph in an otherwise reasonable proposal, but I think the problem buried in here is quite serious and is being overlooked.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Drew<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 22, 2016, at 3:02 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The review of SE-0005&quot;Better Translation of Objective-C APIs Into Swift&quot; begins now and runs through January 31, 2016. The proposal is available here:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md<br>&gt;&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Proposal link:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md<br>&gt;&gt;&gt;&gt; Reply text<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Other replies<br>&gt;&gt;&gt;&gt; What goes into a review?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt;&gt;&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt;&gt;&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt;&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Doug Gregor<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Review Manager<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160205/3536a871/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
