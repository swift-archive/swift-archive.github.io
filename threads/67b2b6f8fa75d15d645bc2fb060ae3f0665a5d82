<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3679b974d53f17b3b684fc9cadb99fa3?s=50"></div><header><strong>[Discussion] Enforcing Calling Super</strong> from <string>Kyle Sherman</string> &lt;kyledsherman at gmail.com&gt;<p>February 17, 2016 at 10:00:00am</p></header><div class="content"><p>I just saw that there was a discussion started about this topic just recently while I was developing this idea with my colleague Peter Livesey. So, I figured I would submit this proposal for discussion.<br></p><p>The link to the original discussion is here: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160215/010310.html<br></p><p>The subject was: ‚ÄúReplace the override keyword by ‚Äòextend‚Äô and ‚Äòreplace‚Äô or add an annotation like @SuppressSuperCall‚Äù<br></p><p>-Kyle<br></p><p># Enforcing Calling Super<br></p><p>* Proposal: [SE-NNNN](https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md)<br>* Author(s): [Swift Developer](https://github.com/swiftdev)<br>* Status: **Awaiting review**<br>* Review manager: TBD<br></p><p>## Introduction<br></p><p>Many times when creating a subclass the superclass has reasons for certain overridden methods to call the superclass‚Äôs version of the method. This change would enforce that the subclass called the superclass&#39;s method in its overridden version at compile time. Also, it would optionally enforce that the superclass&#39;s version would be called before any other implementation in the method (similar to initialization rules). <br></p><p>Swift-evolution thread: [link to the discussion thread for that proposal](https://lists.swift.org/pipermail/swift-evolution)<br></p><p>## Motivation<br></p><p>A concrete example of the type of problem this solves can be taken from simple iOS code. When creating a subclass of UIViewController, you often need to override methods like viewDidLoad or viewWillAppear. You are supposed to call super.viewDidLoad or super.viewWillAppear, respectively, in your overridden implementation. If you don&#39;t, you will have undefined behavior and run into issues. Of course, this type of situation can be extrapolated to any class created in Swift. <br></p><p>Currently, the only way this can be enforced is by commenting the superclass&#39;s code and making a note in the documentation. Quite obviously this can cause many issues as mistakes can be made by new developers quite easily who didn&#39;t look at the documentation for the method or even seasoned developers who simply overlooked this small detail. <br></p><p>## Proposed solution<br></p><p>The solution proposed here would be to use an annotation similar to @available and @noescape in order to convey this information. Optionally, the developer can also choose to specify that the super method must be called as the first line or last line of the overridden method. <br></p><p>The compiler would use the information from the annotation to ensure that any overridden version of the method must call super at the appropriate time according to the information given in the annotation. The compiler would also need to ensure that any method that was going to use this annotation had the same access control level as the class that contains it.<br></p><p>This solution will be much safer than what is currently available, because there is currently no way to enforce super being called in an overridden method. This bug happens constantly for iOS developers.<br></p><p>## Detailed design<br></p><p>A possible implementation of this may look like this:<br></p><p>```<br>class MyClass {<br>    @requiredSuper func foo1() { }<br></p><p>    @requiredSuper(start) func foo2() { }<br></p><p>    @requiredSuper(end) func foo3() { }<br>}<br>```<br></p><p>Now, if the developer were to create a subclass and not call the super method, the compiler should display an error. The errors that should be displayed should be similar to: <br>Overridden method must call the superclass‚Äôs implementation<br>Overridden method must call the superclass‚Äôs implementation as the first line of the method.<br>Overridden method must call the superclass‚Äôs implementation as the last line of the method.<br>for the cases of `@requiredSuper`, `@requiredSuper(start)`, and `@requiredSuper(end)` respectively.<br></p><p>The compiler would also need to display an error in this case where the access control of the method is stricter than that of the class:<br></p><p>```<br>public class MyClass {<br>    @requiredSuper func foo() { }<br>}<br>```<br></p><p>The compiler should show an error, such as ‚ÄúA method using @requiredSuper must have access control set to be at least as accessible as the class that contains it‚Äù.<br></p><p>## Impact on existing code<br></p><p>Implementation of this feature by the developer is completely optional. Therefore, existing code will be unaffected and no migration of code will be necessary. However, when APIs are updated to use this new feature, some code will not compile if the developer did not use the APIs correctly. This should be a welcomed compilation error as it will result in less buggy code at runtime. The impact of this change is similar to adding nullability annotations to Objective-C.<br></p><p>It will be impossible to migrate code automatically, because this information cannot be derived in any way aside from reading comments if and only if the API author documented it.<br></p><p>## Alternatives considered<br></p><p>The alternative would simply be to not implement this feature.<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160217/67b25d82/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e01e37acbfad671da1b94a61cf819d82?s=50"></div><header><strong>[Discussion] Enforcing Calling Super</strong> from <string>Kenny Leung</string> &lt;kenny_leung at pobox.com&gt;<p>February 17, 2016 at 11:00:00am</p></header><div class="content"><p>Hi Kyle.<br></p><p>There is just no way to know what may be required by clients of a framework when it comes time to write actual shipping code. To require users to call super - and to even extend that to knowing whether they should call super at the beginning or end of their methods is too restrictive. If this feature were to go forward, I would limit it to a warning. It may belong more in a linter.<br></p><p>I‚Äôve been using IntelliJ IDEA a lot lately, and they basically have a live linter that they call ‚Äúcode inspections‚Äù. I like this a lot. It goes waaay beyond compiler-level warnings to offering you suggestions to improve your code, finding sections of duplicated code, anything under the sun. They also allow you to suppress any individual warning by putting an @suppress in your code. Maybe Swift could benefit from another layer like this in general, where you could be warned about a lot of stuff, but not be locked into it.<br></p><p>-Kenny<br></p><p><br>&gt; On Feb 17, 2016, at 10:02 AM, Kyle Sherman via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I just saw that there was a discussion started about this topic just recently while I was developing this idea with my colleague Peter Livesey. So, I figured I would submit this proposal for discussion.<br>&gt; <br>&gt; The link to the original discussion is here: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160215/010310.html<br>&gt; <br>&gt; The subject was: ‚ÄúReplace the override keyword by ‚Äòextend‚Äô and ‚Äòreplace‚Äô or add an annotation like @SuppressSuperCall‚Äù<br>&gt; <br>&gt; -Kyle<br>&gt; <br>&gt; # Enforcing Calling Super<br>&gt; <br>&gt; * Proposal: [SE-NNNN](https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md)<br>&gt; * Author(s): [Swift Developer](https://github.com/swiftdev)<br>&gt; * Status: **Awaiting review**<br>&gt; * Review manager: TBD<br>&gt; <br>&gt; ## Introduction<br>&gt; <br>&gt; Many times when creating a subclass the superclass has reasons for certain overridden methods to call the superclass‚Äôs version of the method. This change would enforce that the subclass called the superclass&#39;s method in its overridden version at compile time. Also, it would optionally enforce that the superclass&#39;s version would be called before any other implementation in the method (similar to initialization rules). <br>&gt; <br>&gt; Swift-evolution thread: [link to the discussion thread for that proposal](https://lists.swift.org/pipermail/swift-evolution)<br>&gt; <br>&gt; ## Motivation<br>&gt; <br>&gt; A concrete example of the type of problem this solves can be taken from simple iOS code. When creating a subclass of UIViewController, you often need to override methods like viewDidLoad or viewWillAppear. You are supposed to call super.viewDidLoad or super.viewWillAppear, respectively, in your overridden implementation. If you don&#39;t, you will have undefined behavior and run into issues. Of course, this type of situation can be extrapolated to any class created in Swift. <br>&gt; <br>&gt; Currently, the only way this can be enforced is by commenting the superclass&#39;s code and making a note in the documentation. Quite obviously this can cause many issues as mistakes can be made by new developers quite easily who didn&#39;t look at the documentation for the method or even seasoned developers who simply overlooked this small detail. <br>&gt; <br>&gt; ## Proposed solution<br>&gt; <br>&gt; The solution proposed here would be to use an annotation similar to @available and @noescape in order to convey this information. Optionally, the developer can also choose to specify that the super method must be called as the first line or last line of the overridden method. <br>&gt; <br>&gt; The compiler would use the information from the annotation to ensure that any overridden version of the method must call super at the appropriate time according to the information given in the annotation. The compiler would also need to ensure that any method that was going to use this annotation had the same access control level as the class that contains it.<br>&gt; <br>&gt; This solution will be much safer than what is currently available, because there is currently no way to enforce super being called in an overridden method. This bug happens constantly for iOS developers.<br>&gt; <br>&gt; ## Detailed design<br>&gt; <br>&gt; A possible implementation of this may look like this:<br>&gt; <br>&gt; ```<br>&gt; class MyClass {<br>&gt;     @requiredSuper func foo1() { }<br>&gt; <br>&gt;     @requiredSuper(start) func foo2() { }<br>&gt; <br>&gt;     @requiredSuper(end) func foo3() { }<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; Now, if the developer were to create a subclass and not call the super method, the compiler should display an error. The errors that should be displayed should be similar to: <br>&gt; 	‚Ä¢ Overridden method must call the superclass‚Äôs implementation<br>&gt; 	‚Ä¢ Overridden method must call the superclass‚Äôs implementation as the first line of the method.<br>&gt; 	‚Ä¢ Overridden method must call the superclass‚Äôs implementation as the last line of the method.<br>&gt; for the cases of `@requiredSuper`, `@requiredSuper(start)`, and `@requiredSuper(end)` respectively.<br>&gt; <br>&gt; The compiler would also need to display an error in this case where the access control of the method is stricter than that of the class:<br>&gt; <br>&gt; ```<br>&gt; public class MyClass {<br>&gt;     @requiredSuper func foo() { }<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; The compiler should show an error, such as ‚ÄúA method using @requiredSuper must have access control set to be at least as accessible as the class that contains it‚Äù.<br>&gt; <br>&gt; ## Impact on existing code<br>&gt; <br>&gt; Implementation of this feature by the developer is completely optional. Therefore, existing code will be unaffected and no migration of code will be necessary. However, when APIs are updated to use this new feature, some code will not compile if the developer did not use the APIs correctly. This should be a welcomed compilation error as it will result in less buggy code at runtime. The impact of this change is similar to adding nullability annotations to Objective-C.<br>&gt; <br>&gt; It will be impossible to migrate code automatically, because this information cannot be derived in any way aside from reading comments if and only if the API author documented it.<br>&gt; <br>&gt; ## Alternatives considered<br>&gt; <br>&gt; The alternative would simply be to not implement this feature.<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Discussion] Enforcing Calling Super</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>February 17, 2016 at 08:00:00pm</p></header><div class="content"><p>Since this proposal is along the same lines as another current thread I‚Äôm contributing to I‚Äôm of course very much for the basic functionality ;-)<br>From that other discussion my current preference is towards either an attribute named @super, or allow the super keyword to be used in the method declaration. So a declaration might look like:<br></p><p>	@super(required)<br>	func someMethod() { ‚Ä¶ }<br></p><p>Or (if you prefer):<br></p><p>	super(required) func someMethod() { ‚Ä¶ }<br></p><p>The main ones needed are required and optional, with optional being what we have now, and required simply ensuring that the super method is called (no requirement on where). Options for before and after will be more useful if we get abstract classes whose sole purpose is to be extended, as they may have more specific requirements. The other possibly useful option would @super(replace), in which case super may not be called by extending methods at all, as it‚Äôs implementation may be very tightly coupled to the specific implementation at that level, thus requiring a sub-class to re-implement it; the parent method could also be some kind of stub for a feature it doesn‚Äôt support, but which was required by a protocol for example.<br></p><p>Howard Lovatt also mentioned another interesting extension to the idea which is that methods would effectively become final by default, requiring a @super attribute if they are to be overridable, which I think would be good for ensuring that only classes designed with extension in mind can actually be extended. For this reason the @super attribute could also be used on a class to set a new default for all methods. If we go with this aspect then the final keyword would probably be moved into the @super attribute for methods (properties would still have access to it though I think).<br></p><p>&gt; On 17 Feb 2016, at 19:55, Kenny Leung via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; There is just no way to know what may be required by clients of a framework when it comes time to write actual shipping code. To require users to call super - and to even extend that to knowing whether they should call super at the beginning or end of their methods is too restrictive. If this feature were to go forward, I would limit it to a warning. It may belong more in a linter.<br></p><p>A lot of people have reacted negatively to the idea of before and after requirements, but I think it‚Äôs important to note that they‚Äôre unlikely to be commonly added; in most cases it won‚Äôt matter when the super method is called so required or optional should be used as appropriate. Before and after requirements are more useful for abstract or abstract-style classes that offer partial implementations specifically designed to be extended, in which case the order may be more important. Most of the time the deciding factor will be whether your method performs some kind of updates to cached values, in which case it will be important that it is called; the requirement can also be used to serve as a reminder to read the documentation about how exactly the parent method should be used by extending classes, if it has any more unusual caveats.<br></p><p>&gt; I‚Äôve been using IntelliJ IDEA a lot lately, and they basically have a live linter that they call ‚Äúcode inspections‚Äù. I like this a lot. It goes waaay beyond compiler-level warnings to offering you suggestions to improve your code, finding sections of duplicated code, anything under the sun. They also allow you to suppress any individual warning by putting an @suppress in your code. Maybe Swift could benefit from another layer like this in general, where you could be warned about a lot of stuff, but not be locked into it.<br></p><p>It could make sense to have an option for whether breaking a requirement produces a warning or an error? For example @super(required, warn) will warn the developer that they are going against the parent class‚Äô requirement to include the super method, but won‚Äôt actually stop them from doing so if they really want to. This could provide a useful middle-ground between optional and required, plus if the code of the parent class isn‚Äôt under your control it gives you a fallback until there‚Äôs an update if the warning behaviour were the default, with @super(required, error) style declarations for developers who really know what their parent class needs from sub-classes.<br></p><p>It‚Äôs also worth considering that most code will be under your control, so you‚Äôll just need to tweak (or add) the requirements, in the latter case it forces you to consider how that class may be extended which I think is a good thing.<br></p><p>&gt;&gt; On Feb 17, 2016, at 10:02 AM, Kyle Sherman via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I just saw that there was a discussion started about this topic just recently while I was developing this idea with my colleague Peter Livesey. So, I figured I would submit this proposal for discussion.<br>&gt;&gt; <br>&gt;&gt; The link to the original discussion is here: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160215/010310.html<br>&gt;&gt; <br>&gt;&gt; The subject was: ‚ÄúReplace the override keyword by ‚Äòextend‚Äô and ‚Äòreplace‚Äô or add an annotation like @SuppressSuperCall‚Äù<br>&gt;&gt; <br>&gt;&gt; -Kyle<br>&gt;&gt; <br>&gt;&gt; # Enforcing Calling Super<br>&gt;&gt; <br>&gt;&gt; * Proposal: [SE-NNNN](https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md)<br>&gt;&gt; * Author(s): [Swift Developer](https://github.com/swiftdev)<br>&gt;&gt; * Status: **Awaiting review**<br>&gt;&gt; * Review manager: TBD<br>&gt;&gt; <br>&gt;&gt; ## Introduction<br>&gt;&gt; <br>&gt;&gt; Many times when creating a subclass the superclass has reasons for certain overridden methods to call the superclass‚Äôs version of the method. This change would enforce that the subclass called the superclass&#39;s method in its overridden version at compile time. Also, it would optionally enforce that the superclass&#39;s version would be called before any other implementation in the method (similar to initialization rules). <br>&gt;&gt; <br>&gt;&gt; Swift-evolution thread: [link to the discussion thread for that proposal](https://lists.swift.org/pipermail/swift-evolution)<br>&gt;&gt; <br>&gt;&gt; ## Motivation<br>&gt;&gt; <br>&gt;&gt; A concrete example of the type of problem this solves can be taken from simple iOS code. When creating a subclass of UIViewController, you often need to override methods like viewDidLoad or viewWillAppear. You are supposed to call super.viewDidLoad or super.viewWillAppear, respectively, in your overridden implementation. If you don&#39;t, you will have undefined behavior and run into issues. Of course, this type of situation can be extrapolated to any class created in Swift. <br>&gt;&gt; <br>&gt;&gt; Currently, the only way this can be enforced is by commenting the superclass&#39;s code and making a note in the documentation. Quite obviously this can cause many issues as mistakes can be made by new developers quite easily who didn&#39;t look at the documentation for the method or even seasoned developers who simply overlooked this small detail. <br>&gt;&gt; <br>&gt;&gt; ## Proposed solution<br>&gt;&gt; <br>&gt;&gt; The solution proposed here would be to use an annotation similar to @available and @noescape in order to convey this information. Optionally, the developer can also choose to specify that the super method must be called as the first line or last line of the overridden method. <br>&gt;&gt; <br>&gt;&gt; The compiler would use the information from the annotation to ensure that any overridden version of the method must call super at the appropriate time according to the information given in the annotation. The compiler would also need to ensure that any method that was going to use this annotation had the same access control level as the class that contains it.<br>&gt;&gt; <br>&gt;&gt; This solution will be much safer than what is currently available, because there is currently no way to enforce super being called in an overridden method. This bug happens constantly for iOS developers.<br>&gt;&gt; <br>&gt;&gt; ## Detailed design<br>&gt;&gt; <br>&gt;&gt; A possible implementation of this may look like this:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; class MyClass {<br>&gt;&gt;    @requiredSuper func foo1() { }<br>&gt;&gt; <br>&gt;&gt;    @requiredSuper(start) func foo2() { }<br>&gt;&gt; <br>&gt;&gt;    @requiredSuper(end) func foo3() { }<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; Now, if the developer were to create a subclass and not call the super method, the compiler should display an error. The errors that should be displayed should be similar to: <br>&gt;&gt; 	‚Ä¢ Overridden method must call the superclass‚Äôs implementation<br>&gt;&gt; 	‚Ä¢ Overridden method must call the superclass‚Äôs implementation as the first line of the method.<br>&gt;&gt; 	‚Ä¢ Overridden method must call the superclass‚Äôs implementation as the last line of the method.<br>&gt;&gt; for the cases of `@requiredSuper`, `@requiredSuper(start)`, and `@requiredSuper(end)` respectively.<br>&gt;&gt; <br>&gt;&gt; The compiler would also need to display an error in this case where the access control of the method is stricter than that of the class:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; public class MyClass {<br>&gt;&gt;    @requiredSuper func foo() { }<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; The compiler should show an error, such as ‚ÄúA method using @requiredSuper must have access control set to be at least as accessible as the class that contains it‚Äù.<br>&gt;&gt; <br>&gt;&gt; ## Impact on existing code<br>&gt;&gt; <br>&gt;&gt; Implementation of this feature by the developer is completely optional. Therefore, existing code will be unaffected and no migration of code will be necessary. However, when APIs are updated to use this new feature, some code will not compile if the developer did not use the APIs correctly. This should be a welcomed compilation error as it will result in less buggy code at runtime. The impact of this change is similar to adding nullability annotations to Objective-C.<br>&gt;&gt; <br>&gt;&gt; It will be impossible to migrate code automatically, because this information cannot be derived in any way aside from reading comments if and only if the API author documented it.<br>&gt;&gt; <br>&gt;&gt; ## Alternatives considered<br>&gt;&gt; <br>&gt;&gt; The alternative would simply be to not implement this feature.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160217/430ccc11/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3679b974d53f17b3b684fc9cadb99fa3?s=50"></div><header><strong>[Discussion] Enforcing Calling Super</strong> from <string>Kyle Sherman</string> &lt;kyledsherman at gmail.com&gt;<p>February 17, 2016 at 02:00:00pm</p></header><div class="content"><p>Thanks for the replies.<br></p><p>Kenny: After thinking about it more, discussing with Peter, and looking Haravikk‚Äôs comments, I think the best thing would be for this to be a warning as suggested. I respectfully disagree that as a library creator you would not be able to know that a call to super should be required. A perfect example of this is the one stated in the proposal: viewDidLoad, viewWillAppear, etc. In these cases, the library writers know that the super version must be called and no matter what the subclasser does, they will not be able to have correct behavior without calling super. This is present in many places throughout the iOS SDK as example. In the static analyzer in Xcode, for ObjC code, it warns when the developer doesn‚Äôt call super in certain cases. Having these annotations would allow for developers to specify this for their own code. Being able to suppress the warning could also be a good feature, but I definitely don‚Äôt feel it would be necessary for the implementation of the feature.<br></p><p>Haravikk: I don‚Äôt agree with using ‚Äú(required)‚Äù as that will be a sort of overloaded usage of the keyword. Also, I think that simply not specifying anything would be a better way to go about it. So, @super would mean you require the super method to be called, and simply not having an annotation means that you do not have to call the super method. Peter and I have a separate proposal that we will put up here soon for extending the ‚Äúrequired‚Äù keyword for all methods that I think will solve the problem of abstract classes. I don‚Äôt think that we should conflate that issue, which we feel is a separate issue, in with the issue of requiring the super method to be called. Along the same lines, final by default was already being discussed much earlier and I believe there was already a conclusion to that saying it would not be implemented. I think the final keyword should stay separate, especially since it is a compiler error vs this which we are now saying would be a warning.<br></p><p>-Kyle<br></p><p>&gt; On Feb 17, 2016, at 12:31 PM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Since this proposal is along the same lines as another current thread I‚Äôm contributing to I‚Äôm of course very much for the basic functionality ;-)<br>&gt; From that other discussion my current preference is towards either an attribute named @super, or allow the super keyword to be used in the method declaration. So a declaration might look like:<br>&gt; <br>&gt; 	@super(required)<br>&gt; 	func someMethod() { ‚Ä¶ }<br>&gt; <br>&gt; Or (if you prefer):<br>&gt; <br>&gt; 	super(required) func someMethod() { ‚Ä¶ }<br>&gt; <br>&gt; The main ones needed are required and optional, with optional being what we have now, and required simply ensuring that the super method is called (no requirement on where). Options for before and after will be more useful if we get abstract classes whose sole purpose is to be extended, as they may have more specific requirements. The other possibly useful option would @super(replace), in which case super may not be called by extending methods at all, as it‚Äôs implementation may be very tightly coupled to the specific implementation at that level, thus requiring a sub-class to re-implement it; the parent method could also be some kind of stub for a feature it doesn‚Äôt support, but which was required by a protocol for example.<br>&gt; <br>&gt; Howard Lovatt also mentioned another interesting extension to the idea which is that methods would effectively become final by default, requiring a @super attribute if they are to be overridable, which I think would be good for ensuring that only classes designed with extension in mind can actually be extended. For this reason the @super attribute could also be used on a class to set a new default for all methods. If we go with this aspect then the final keyword would probably be moved into the @super attribute for methods (properties would still have access to it though I think).<br>&gt; <br>&gt;&gt; On 17 Feb 2016, at 19:55, Kenny Leung via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; There is just no way to know what may be required by clients of a framework when it comes time to write actual shipping code. To require users to call super - and to even extend that to knowing whether they should call super at the beginning or end of their methods is too restrictive. If this feature were to go forward, I would limit it to a warning. It may belong more in a linter.<br>&gt; <br>&gt; A lot of people have reacted negatively to the idea of before and after requirements, but I think it‚Äôs important to note that they‚Äôre unlikely to be commonly added; in most cases it won‚Äôt matter when the super method is called so required or optional should be used as appropriate. Before and after requirements are more useful for abstract or abstract-style classes that offer partial implementations specifically designed to be extended, in which case the order may be more important. Most of the time the deciding factor will be whether your method performs some kind of updates to cached values, in which case it will be important that it is called; the requirement can also be used to serve as a reminder to read the documentation about how exactly the parent method should be used by extending classes, if it has any more unusual caveats.<br>&gt; <br>&gt;&gt; I‚Äôve been using IntelliJ IDEA a lot lately, and they basically have a live linter that they call ‚Äúcode inspections‚Äù. I like this a lot. It goes waaay beyond compiler-level warnings to offering you suggestions to improve your code, finding sections of duplicated code, anything under the sun. They also allow you to suppress any individual warning by putting an @suppress in your code. Maybe Swift could benefit from another layer like this in general, where you could be warned about a lot of stuff, but not be locked into it.<br>&gt; <br>&gt; It could make sense to have an option for whether breaking a requirement produces a warning or an error? For example @super(required, warn) will warn the developer that they are going against the parent class‚Äô requirement to include the super method, but won‚Äôt actually stop them from doing so if they really want to. This could provide a useful middle-ground between optional and required, plus if the code of the parent class isn‚Äôt under your control it gives you a fallback until there‚Äôs an update if the warning behaviour were the default, with @super(required, error) style declarations for developers who really know what their parent class needs from sub-classes.<br>&gt; <br>&gt; It‚Äôs also worth considering that most code will be under your control, so you‚Äôll just need to tweak (or add) the requirements, in the latter case it forces you to consider how that class may be extended which I think is a good thing.<br>&gt; <br>&gt;&gt;&gt; On Feb 17, 2016, at 10:02 AM, Kyle Sherman via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I just saw that there was a discussion started about this topic just recently while I was developing this idea with my colleague Peter Livesey. So, I figured I would submit this proposal for discussion.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The link to the original discussion is here: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160215/010310.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160215/010310.html&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The subject was: ‚ÄúReplace the override keyword by ‚Äòextend‚Äô and ‚Äòreplace‚Äô or add an annotation like @SuppressSuperCall‚Äù<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Kyle<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; # Enforcing Calling Super<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Proposal: [SE-NNNN](https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;)<br>&gt;&gt;&gt; * Author(s): [Swift Developer](https://github.com/swiftdev &lt;https://github.com/swiftdev&gt;)<br>&gt;&gt;&gt; * Status: **Awaiting review**<br>&gt;&gt;&gt; * Review manager: TBD<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Many times when creating a subclass the superclass has reasons for certain overridden methods to call the superclass‚Äôs version of the method. This change would enforce that the subclass called the superclass&#39;s method in its overridden version at compile time. Also, it would optionally enforce that the superclass&#39;s version would be called before any other implementation in the method (similar to initialization rules). <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift-evolution thread: [link to the discussion thread for that proposal](https://lists.swift.org/pipermail/swift-evolution &lt;https://lists.swift.org/pipermail/swift-evolution&gt;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A concrete example of the type of problem this solves can be taken from simple iOS code. When creating a subclass of UIViewController, you often need to override methods like viewDidLoad or viewWillAppear. You are supposed to call super.viewDidLoad or super.viewWillAppear, respectively, in your overridden implementation. If you don&#39;t, you will have undefined behavior and run into issues. Of course, this type of situation can be extrapolated to any class created in Swift. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Currently, the only way this can be enforced is by commenting the superclass&#39;s code and making a note in the documentation. Quite obviously this can cause many issues as mistakes can be made by new developers quite easily who didn&#39;t look at the documentation for the method or even seasoned developers who simply overlooked this small detail. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The solution proposed here would be to use an annotation similar to @available and @noescape in order to convey this information. Optionally, the developer can also choose to specify that the super method must be called as the first line or last line of the overridden method. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The compiler would use the information from the annotation to ensure that any overridden version of the method must call super at the appropriate time according to the information given in the annotation. The compiler would also need to ensure that any method that was going to use this annotation had the same access control level as the class that contains it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This solution will be much safer than what is currently available, because there is currently no way to enforce super being called in an overridden method. This bug happens constantly for iOS developers.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Detailed design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A possible implementation of this may look like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; class MyClass {<br>&gt;&gt;&gt;    @requiredSuper func foo1() { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    @requiredSuper(start) func foo2() { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    @requiredSuper(end) func foo3() { }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now, if the developer were to create a subclass and not call the super method, the compiler should display an error. The errors that should be displayed should be similar to: <br>&gt;&gt;&gt; 	‚Ä¢ Overridden method must call the superclass‚Äôs implementation<br>&gt;&gt;&gt; 	‚Ä¢ Overridden method must call the superclass‚Äôs implementation as the first line of the method.<br>&gt;&gt;&gt; 	‚Ä¢ Overridden method must call the superclass‚Äôs implementation as the last line of the method.<br>&gt;&gt;&gt; for the cases of `@requiredSuper`, `@requiredSuper(start)`, and `@requiredSuper(end)` respectively.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The compiler would also need to display an error in this case where the access control of the method is stricter than that of the class:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; public class MyClass {<br>&gt;&gt;&gt;    @requiredSuper func foo() { }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The compiler should show an error, such as ‚ÄúA method using @requiredSuper must have access control set to be at least as accessible as the class that contains it‚Äù.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Implementation of this feature by the developer is completely optional. Therefore, existing code will be unaffected and no migration of code will be necessary. However, when APIs are updated to use this new feature, some code will not compile if the developer did not use the APIs correctly. This should be a welcomed compilation error as it will result in less buggy code at runtime. The impact of this change is similar to adding nullability annotations to Objective-C.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It will be impossible to migrate code automatically, because this information cannot be derived in any way aside from reading comments if and only if the API author documented it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Alternatives considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The alternative would simply be to not implement this feature.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160217/35c18b91/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Discussion] Enforcing Calling Super</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>February 17, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On 17 Feb 2016, at 22:26, Kyle Sherman &lt;kyledsherman at gmail.com&gt; wrote:<br>&gt; <br>&gt; Haravikk: I don‚Äôt agree with using ‚Äú(required)‚Äù as that will be a sort of overloaded usage of the keyword.<br></p><p>I don‚Äôt believe so, at least in the case of a @super attribute, in which case it‚Äôs an option of that attribute, so a separate use-case, of course if there‚Äôs another term that can be used then I‚Äôve no particular attachment to required, it‚Äôs just the most obvious term to me.<br></p><p>While I agree that @super on its own should imply required, I think we should still have the ability to explicitly state that that is the case (personally I prefer to be as clear as possible rather than relying on defaults) in cases like these.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ec8a60462a511e833c5c4a83b424c958?s=50"></div><header><strong>[Discussion] Enforcing Calling Super</strong> from <string>Dennis Weissmann</string> &lt;dennis at dennisweissmann.me&gt;<p>February 18, 2016 at 12:00:00am</p></header><div class="content"><p>Can‚Äôt the compiler generate them?<br></p><p>&gt; @requiredSuper(end) func foo3()<br></p><p><br>If the compiler can tell you that you need to call super() at the very beginning (or the very end) of a method, it should be able to do that for you.<br></p><p>What I imagine is a syntax like this:<br></p><p>Note: I‚Äôve changed the syntax to # because I think this is compiler-magic and as Chris mentioned the following in the property behavior thread:<br></p><p>&gt; Where [lazy] is currently used, could the syntax instead be #behavior(lazy)? That prevents a possible future naming clash, keeps the # meaning compiler-magic, and doesn&#39;t use the [], which is contentious.<br></p><p><br>class Base {<br></p><p>  #requireSuperStart			// nitpicking, but I‚Äôd like #requireSuperAtBeginning actually better<br>  func mustCallSuperMethod() {<br>    // Some code<br>  }<br></p><p>}<br></p><p>class Subclass: Base {<br></p><p>  // All subclasses automatically (implicitly) inherit #requireSuperX, this is visible across module boundaries<br>  override func mustCallSuperMethod() {<br>    // Do your setup<br>  }<br>  <br>}<br></p><p>The compiler would inject (invisible to the dev) the super() call at the very beginning. The same is true for #requireSuperEnd.<br>I don‚Äôt think we need a #requireSuper because it means we don‚Äôt care when it‚Äôs called so the compiler can decide where to put it.<br></p><p>The only problematic point might be a super call with arguments but I have never ever changed the argument of a super call (e.g. in viewDidAppear(animated: Bool) I never called the super implementation other than super.viewDidAppear(animated)).<br></p><p>- Dennis, who is sick =&gt; please forgive any mistakes or oversights üôè<br></p><p>&gt; On Feb 17, 2016, at 11:26 PM, Kyle Sherman via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Thanks for the replies.<br>&gt; <br>&gt; Kenny: After thinking about it more, discussing with Peter, and looking Haravikk‚Äôs comments, I think the best thing would be for this to be a warning as suggested. I respectfully disagree that as a library creator you would not be able to know that a call to super should be required. A perfect example of this is the one stated in the proposal: viewDidLoad, viewWillAppear, etc. In these cases, the library writers know that the super version must be called and no matter what the subclasser does, they will not be able to have correct behavior without calling super. This is present in many places throughout the iOS SDK as example. In the static analyzer in Xcode, for ObjC code, it warns when the developer doesn‚Äôt call super in certain cases. Having these annotations would allow for developers to specify this for their own code. Being able to suppress the warning could also be a good feature, but I definitely don‚Äôt feel it would be necessary for the implementation of the feature.<br>&gt; <br>&gt; Haravikk: I don‚Äôt agree with using ‚Äú(required)‚Äù as that will be a sort of overloaded usage of the keyword. Also, I think that simply not specifying anything would be a better way to go about it. So, @super would mean you require the super method to be called, and simply not having an annotation means that you do not have to call the super method. Peter and I have a separate proposal that we will put up here soon for extending the ‚Äúrequired‚Äù keyword for all methods that I think will solve the problem of abstract classes. I don‚Äôt think that we should conflate that issue, which we feel is a separate issue, in with the issue of requiring the super method to be called. Along the same lines, final by default was already being discussed much earlier and I believe there was already a conclusion to that saying it would not be implemented. I think the final keyword should stay separate, especially since it is a compiler error vs this which we are now saying would be a warning.<br>&gt; <br>&gt; -Kyle<br>&gt; <br>&gt;&gt; On Feb 17, 2016, at 12:31 PM, Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Since this proposal is along the same lines as another current thread I‚Äôm contributing to I‚Äôm of course very much for the basic functionality ;-)<br>&gt;&gt; From that other discussion my current preference is towards either an attribute named @super, or allow the super keyword to be used in the method declaration. So a declaration might look like:<br>&gt;&gt; <br>&gt;&gt; 	@super(required)<br>&gt;&gt; 	func someMethod() { ‚Ä¶ }<br>&gt;&gt; <br>&gt;&gt; Or (if you prefer):<br>&gt;&gt; <br>&gt;&gt; 	super(required) func someMethod() { ‚Ä¶ }<br>&gt;&gt; <br>&gt;&gt; The main ones needed are required and optional, with optional being what we have now, and required simply ensuring that the super method is called (no requirement on where). Options for before and after will be more useful if we get abstract classes whose sole purpose is to be extended, as they may have more specific requirements. The other possibly useful option would @super(replace), in which case super may not be called by extending methods at all, as it‚Äôs implementation may be very tightly coupled to the specific implementation at that level, thus requiring a sub-class to re-implement it; the parent method could also be some kind of stub for a feature it doesn‚Äôt support, but which was required by a protocol for example.<br>&gt;&gt; <br>&gt;&gt; Howard Lovatt also mentioned another interesting extension to the idea which is that methods would effectively become final by default, requiring a @super attribute if they are to be overridable, which I think would be good for ensuring that only classes designed with extension in mind can actually be extended. For this reason the @super attribute could also be used on a class to set a new default for all methods. If we go with this aspect then the final keyword would probably be moved into the @super attribute for methods (properties would still have access to it though I think).<br>&gt;&gt; <br>&gt;&gt;&gt; On 17 Feb 2016, at 19:55, Kenny Leung via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There is just no way to know what may be required by clients of a framework when it comes time to write actual shipping code. To require users to call super - and to even extend that to knowing whether they should call super at the beginning or end of their methods is too restrictive. If this feature were to go forward, I would limit it to a warning. It may belong more in a linter.<br>&gt;&gt; <br>&gt;&gt; A lot of people have reacted negatively to the idea of before and after requirements, but I think it‚Äôs important to note that they‚Äôre unlikely to be commonly added; in most cases it won‚Äôt matter when the super method is called so required or optional should be used as appropriate. Before and after requirements are more useful for abstract or abstract-style classes that offer partial implementations specifically designed to be extended, in which case the order may be more important. Most of the time the deciding factor will be whether your method performs some kind of updates to cached values, in which case it will be important that it is called; the requirement can also be used to serve as a reminder to read the documentation about how exactly the parent method should be used by extending classes, if it has any more unusual caveats.<br>&gt;&gt; <br>&gt;&gt;&gt; I‚Äôve been using IntelliJ IDEA a lot lately, and they basically have a live linter that they call ‚Äúcode inspections‚Äù. I like this a lot. It goes waaay beyond compiler-level warnings to offering you suggestions to improve your code, finding sections of duplicated code, anything under the sun. They also allow you to suppress any individual warning by putting an @suppress in your code. Maybe Swift could benefit from another layer like this in general, where you could be warned about a lot of stuff, but not be locked into it.<br>&gt;&gt; <br>&gt;&gt; It could make sense to have an option for whether breaking a requirement produces a warning or an error? For example @super(required, warn) will warn the developer that they are going against the parent class‚Äô requirement to include the super method, but won‚Äôt actually stop them from doing so if they really want to. This could provide a useful middle-ground between optional and required, plus if the code of the parent class isn‚Äôt under your control it gives you a fallback until there‚Äôs an update if the warning behaviour were the default, with @super(required, error) style declarations for developers who really know what their parent class needs from sub-classes.<br>&gt;&gt; <br>&gt;&gt; It‚Äôs also worth considering that most code will be under your control, so you‚Äôll just need to tweak (or add) the requirements, in the latter case it forces you to consider how that class may be extended which I think is a good thing.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 17, 2016, at 10:02 AM, Kyle Sherman via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I just saw that there was a discussion started about this topic just recently while I was developing this idea with my colleague Peter Livesey. So, I figured I would submit this proposal for discussion.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The link to the original discussion is here: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160215/010310.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160215/010310.html&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The subject was: ‚ÄúReplace the override keyword by ‚Äòextend‚Äô and ‚Äòreplace‚Äô or add an annotation like @SuppressSuperCall‚Äù<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Kyle<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; # Enforcing Calling Super<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * Proposal: [SE-NNNN](https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;)<br>&gt;&gt;&gt;&gt; * Author(s): [Swift Developer](https://github.com/swiftdev &lt;https://github.com/swiftdev&gt;)<br>&gt;&gt;&gt;&gt; * Status: **Awaiting review**<br>&gt;&gt;&gt;&gt; * Review manager: TBD<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ## Introduction<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Many times when creating a subclass the superclass has reasons for certain overridden methods to call the superclass‚Äôs version of the method. This change would enforce that the subclass called the superclass&#39;s method in its overridden version at compile time. Also, it would optionally enforce that the superclass&#39;s version would be called before any other implementation in the method (similar to initialization rules). <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Swift-evolution thread: [link to the discussion thread for that proposal](https://lists.swift.org/pipermail/swift-evolution &lt;https://lists.swift.org/pipermail/swift-evolution&gt;)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ## Motivation<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A concrete example of the type of problem this solves can be taken from simple iOS code. When creating a subclass of UIViewController, you often need to override methods like viewDidLoad or viewWillAppear. You are supposed to call super.viewDidLoad or super.viewWillAppear, respectively, in your overridden implementation. If you don&#39;t, you will have undefined behavior and run into issues. Of course, this type of situation can be extrapolated to any class created in Swift. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Currently, the only way this can be enforced is by commenting the superclass&#39;s code and making a note in the documentation. Quite obviously this can cause many issues as mistakes can be made by new developers quite easily who didn&#39;t look at the documentation for the method or even seasoned developers who simply overlooked this small detail. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ## Proposed solution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The solution proposed here would be to use an annotation similar to @available and @noescape in order to convey this information. Optionally, the developer can also choose to specify that the super method must be called as the first line or last line of the overridden method. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The compiler would use the information from the annotation to ensure that any overridden version of the method must call super at the appropriate time according to the information given in the annotation. The compiler would also need to ensure that any method that was going to use this annotation had the same access control level as the class that contains it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This solution will be much safer than what is currently available, because there is currently no way to enforce super being called in an overridden method. This bug happens constantly for iOS developers.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ## Detailed design<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A possible implementation of this may look like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; class MyClass {<br>&gt;&gt;&gt;&gt;    @requiredSuper func foo1() { }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    @requiredSuper(start) func foo2() { }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    @requiredSuper(end) func foo3() { }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Now, if the developer were to create a subclass and not call the super method, the compiler should display an error. The errors that should be displayed should be similar to: <br>&gt;&gt;&gt;&gt; 	‚Ä¢ Overridden method must call the superclass‚Äôs implementation<br>&gt;&gt;&gt;&gt; 	‚Ä¢ Overridden method must call the superclass‚Äôs implementation as the first line of the method.<br>&gt;&gt;&gt;&gt; 	‚Ä¢ Overridden method must call the superclass‚Äôs implementation as the last line of the method.<br>&gt;&gt;&gt;&gt; for the cases of `@requiredSuper`, `@requiredSuper(start)`, and `@requiredSuper(end)` respectively.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The compiler would also need to display an error in this case where the access control of the method is stricter than that of the class:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; public class MyClass {<br>&gt;&gt;&gt;&gt;    @requiredSuper func foo() { }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The compiler should show an error, such as ‚ÄúA method using @requiredSuper must have access control set to be at least as accessible as the class that contains it‚Äù.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ## Impact on existing code<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Implementation of this feature by the developer is completely optional. Therefore, existing code will be unaffected and no migration of code will be necessary. However, when APIs are updated to use this new feature, some code will not compile if the developer did not use the APIs correctly. This should be a welcomed compilation error as it will result in less buggy code at runtime. The impact of this change is similar to adding nullability annotations to Objective-C.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It will be impossible to migrate code automatically, because this information cannot be derived in any way aside from reading comments if and only if the API author documented it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ## Alternatives considered<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The alternative would simply be to not implement this feature.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160218/1692b43f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>[Discussion] Enforcing Calling Super</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>February 18, 2016 at 06:00:00pm</p></header><div class="content"><p>I like what this thread could mean for better protocol conformance, but I<br>think that requiring things like start/end need to be used sparingly, and<br>only when a clean API can&#39;t be designed without it. This is mainly because<br>of the reasons Kenny mentions, but also due to the restrictions it may<br>place on debugging.<br></p><p>*Require once*<br>Worth considering is that you may want to enforce that super is only called<br>once, I&#39;m sure there&#39;s counter examples, but it seems like something worth<br>considering.<br></p><p>*Implicit calls (-1)*<br>I like what Dennis has suggested with implicit calls. Although I don&#39;t<br>think it would work in the general case, and I think it&#39;s sufficiently<br>unexpected that you wouldn&#39;t want it to only happen sometimes.<br></p><p>I&#39;ve had a few hard to track bugs that have happened in the super call at<br>the start of a method. For things like delegate methods for out-of-module<br>classes it&#39;s useful to be able to put a breakpoint before the super call to<br>debug it.<br></p><p>It&#39;s also possible that super must be called first, but you want to use the<br>result of that call.<br></p><p>*#requireSuper (+1)*<br>I think we would definitely need #requireSuper, for example: if other<br>operations must be performed either side of the call.<br></p><p>I believe there&#39;s a few Cocoa cases where calling multiple methods in a<br>specific order is required, but not necessarily as the first or last calls.<br>For example:<br></p><p>UIViewController&#39;s willMoveToParentViewController the documentation states:<br></p><p>If you are implementing your own container view controller, it must call<br>the willMoveToParentViewController: method of the child view controller<br>before calling the removeFromParentViewController method, passing in a<br>parent value of nil.<br></p><p><br>This means that willMoveToParentViewController: cannot be last, nor is it<br>explicitly required to be first. This allows calls before the call to<br>super, and requires a call after it. I imagine a lot of code would break if<br>this was made more strict. Perhaps this example could be fixed with a<br>different UIViewController API, but that&#39;s out of scope.<br></p><p>*Generalisation?*<br>I wonder if this proposal could/should be generalised to something like<br>this (all arguments optional):<br></p><p>@callRequirements(<br></p><p>    super=first|last|once|never|optional,<br></p><p>    require=[someProtocolMethod,someClassMethod],<br></p><p>    require_once=[closureArgument],<br></p><p>    require_ordered=[super,someProtocolMethod(:argument:)],<br>    disallow=[someProtocolProperty])<br></p><p><br>The identifiers would have to be defined and unambiguous on the current<br>type or function.<br></p><p>By closureArgument I mean that a closure passed to the function must be<br>called.<br></p><p>Perhaps require_ordered can be removed if existing APIs can be made to use<br>an cleaner/enforceable pattern.<br></p><p>Note that requiring a closureArgument to be called potentially overlaps<br>with another thread &quot;Guaranteed closure execution&quot; (with an argument like<br>@noescape):<br></p><p>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160125/008167.html<br></p><p><br>My suggestion lacks some flexibility, at some point it would be nice to be<br>able to write custom validator functions (for protocols and classes) that<br>can be referenced by name. There&#39;s a similar proposal for that recently<br>called &quot;Proposal: Allow functions to participate in the compile so they can<br>generate warnings about their usage&quot; if you&#39;re interested:<br></p><p>http://comments.gmane.org/gmane.comp.lang.swift.evolution/6870<br></p><p><br>This could allow us to do things like this:<br></p><p>@verifyCall(superFirst, pure, disallowDirectPropertyUsage)<br></p><p><br>Andrew Bennett<br></p><p>On Thursday, 18 February 2016, Dennis Weissmann via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Can‚Äôt the compiler generate them?<br>&gt;<br>&gt; @requiredSuper(end) func foo3()<br>&gt;<br>&gt;<br>&gt; If the compiler can tell you that you need to call super() at the very<br>&gt; beginning (or the very end) of a method, it should be able to do that for<br>&gt; you.<br>&gt;<br>&gt; What I imagine is a syntax like this:<br>&gt;<br>&gt; Note: I‚Äôve changed the syntax to # because I think this is compiler-magic<br>&gt; and as Chris mentioned the following in the property behavior thread:<br>&gt;<br>&gt; Where [lazy] is currently used, could the syntax instead be<br>&gt; #behavior(lazy)? That prevents a possible future naming clash, keeps the #<br>&gt; meaning compiler-magic, and doesn&#39;t use the [], which is contentious.<br>&gt;<br>&gt;<br>&gt; class Base {<br>&gt;<br>&gt;   #requireSuperStart // nitpicking, but I‚Äôd like #requireSuperAtBeginning<br>&gt; actually better<br>&gt;   func mustCallSuperMethod() {<br>&gt;     // Some code<br>&gt;   }<br>&gt;<br>&gt; }<br>&gt;<br>&gt; class Subclass: Base {<br>&gt;<br>&gt;   // All subclasses automatically (implicitly) inherit #requireSuperX,<br>&gt; this is visible across module boundaries<br>&gt;   override func mustCallSuperMethod() {<br>&gt;     // Do your setup<br>&gt;   }<br>&gt;<br>&gt; }<br>&gt;<br>&gt; The compiler would inject (invisible to the dev) the super() call at the<br>&gt; very beginning. The same is true for #requireSuperEnd.<br>&gt; I don‚Äôt think we need a #requireSuper because it means we don‚Äôt care when<br>&gt; it‚Äôs called so the compiler can decide where to put it.<br>&gt;<br>&gt; The only problematic point might be a super call with arguments but I have<br>&gt; never ever changed the argument of a super call (e.g. in<br>&gt; viewDidAppear(animated: Bool) I never called the super implementation<br>&gt; other than super.viewDidAppear(animated)).<br>&gt;<br>&gt; - Dennis, who is sick =&gt; please forgive any mistakes or oversights üôè<br>&gt;<br>&gt; On Feb 17, 2016, at 11:26 PM, Kyle Sherman via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Thanks for the replies.<br>&gt;<br>&gt; Kenny: After thinking about it more, discussing with Peter, and looking<br>&gt; Haravikk‚Äôs comments, I think the best thing would be for this to be a<br>&gt; warning as suggested. I respectfully disagree that as a library creator you<br>&gt; would not be able to know that a call to super should be required. A<br>&gt; perfect example of this is the one stated in the proposal: viewDidLoad,<br>&gt; viewWillAppear, etc. In these cases, the library writers know that the<br>&gt; super version must be called and no matter what the subclasser does, they<br>&gt; will not be able to have correct behavior without calling super. This is<br>&gt; present in many places throughout the iOS SDK as example. In the static<br>&gt; analyzer in Xcode, for ObjC code, it warns when the developer doesn‚Äôt call<br>&gt; super in certain cases. Having these annotations would allow for developers<br>&gt; to specify this for their own code. Being able to suppress the warning<br>&gt; could also be a good feature, but I definitely don‚Äôt feel it would be<br>&gt; necessary for the implementation of the feature.<br>&gt;<br>&gt; Haravikk: I don‚Äôt agree with using ‚Äú(required)‚Äù as that will be a sort of<br>&gt; overloaded usage of the keyword. Also, I think that simply not specifying<br>&gt; anything would be a better way to go about it. So, @super would mean you<br>&gt; require the super method to be called, and simply not having an annotation<br>&gt; means that you do not have to call the super method. Peter and I have a<br>&gt; separate proposal that we will put up here soon for extending the<br>&gt; ‚Äúrequired‚Äù keyword for all methods that I think will solve the problem of<br>&gt; abstract classes. I don‚Äôt think that we should conflate that issue, which<br>&gt; we feel is a separate issue, in with the issue of requiring the super<br>&gt; method to be called. Along the same lines, final by default was already<br>&gt; being discussed much earlier and I believe there was already a conclusion<br>&gt; to that saying it would not be implemented. I think the final keyword<br>&gt; should stay separate, especially since it is a compiler error vs this which<br>&gt; we are now saying would be a warning.<br>&gt;<br>&gt; -Kyle<br>&gt;<br>&gt; On Feb 17, 2016, at 12:31 PM, Haravikk via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Since this proposal is along the same lines as another current thread I‚Äôm<br>&gt; contributing to I‚Äôm of course very much for the basic functionality ;-)<br>&gt; From that other discussion my current preference is towards either an<br>&gt; attribute named @super, or allow the super keyword to be used in the method<br>&gt; declaration. So a declaration might look like:<br>&gt;<br>&gt; @super(required)<br>&gt; func someMethod() { ‚Ä¶ }<br>&gt;<br>&gt; Or (if you prefer):<br>&gt;<br>&gt; super(required) func someMethod() { ‚Ä¶ }<br>&gt;<br>&gt; The main ones needed are required and optional, with optional being what<br>&gt; we have now, and required simply ensuring that the super method is called<br>&gt; (no requirement on where). Options for before and after will be more useful<br>&gt; if we get abstract classes whose sole purpose is to be extended, as they<br>&gt; may have more specific requirements. The other possibly useful option would<br>&gt; @super(replace), in which case super may not be called by extending methods<br>&gt; at all, as it‚Äôs implementation may be very tightly coupled to the specific<br>&gt; implementation at that level, thus requiring a sub-class to re-implement<br>&gt; it; the parent method could also be some kind of stub for a feature it<br>&gt; doesn‚Äôt support, but which was required by a protocol for example.<br>&gt;<br>&gt; Howard Lovatt also mentioned another interesting extension to the idea<br>&gt; which is that methods would effectively become final by default, requiring<br>&gt; a @super attribute if they are to be overridable, which I think would be<br>&gt; good for ensuring that only classes designed with extension in mind can<br>&gt; actually be extended. For this reason the @super attribute could also be<br>&gt; used on a class to set a new default for all methods. If we go with this<br>&gt; aspect then the final keyword would probably be moved into the @super<br>&gt; attribute for methods (properties would still have access to it though I<br>&gt; think).<br>&gt;<br>&gt; On 17 Feb 2016, at 19:55, Kenny Leung via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; There is just no way to know what may be required by clients of a<br>&gt; framework when it comes time to write actual shipping code. To require<br>&gt; users to call super - and to even extend that to knowing whether they<br>&gt; should call super at the beginning or end of their methods is too<br>&gt; restrictive. If this feature were to go forward, I would limit it to a<br>&gt; warning. It may belong more in a linter.<br>&gt;<br>&gt;<br>&gt; A lot of people have reacted negatively to the idea of before and after<br>&gt; requirements, but I think it‚Äôs important to note that they‚Äôre unlikely to<br>&gt; be commonly added; in most cases it won‚Äôt matter when the super method is<br>&gt; called so required or optional should be used as appropriate. Before and<br>&gt; after requirements are more useful for abstract or abstract-style classes<br>&gt; that offer partial implementations specifically designed to be extended, in<br>&gt; which case the order may be more important. Most of the time the deciding<br>&gt; factor will be whether your method performs some kind of updates to cached<br>&gt; values, in which case it will be important that it is called; the<br>&gt; requirement can also be used to serve as a reminder to read the<br>&gt; documentation about how exactly the parent method should be used by<br>&gt; extending classes, if it has any more unusual caveats.<br>&gt;<br>&gt; I‚Äôve been using IntelliJ IDEA a lot lately, and they basically have a live<br>&gt; linter that they call ‚Äúcode inspections‚Äù. I like this a lot. It goes waaay<br>&gt; beyond compiler-level warnings to offering you suggestions to improve your<br>&gt; code, finding sections of duplicated code, anything under the sun. They<br>&gt; also allow you to suppress any individual warning by putting an @suppress<br>&gt; in your code. Maybe Swift could benefit from another layer like this in<br>&gt; general, where you could be warned about a lot of stuff, but not be locked<br>&gt; into it.<br>&gt;<br>&gt;<br>&gt; It could make sense to have an option for whether breaking a requirement<br>&gt; produces a warning or an error? For example @super(required, warn) will<br>&gt; warn the developer that they are going against the parent class‚Äô<br>&gt; requirement to include the super method, but won‚Äôt actually stop them from<br>&gt; doing so if they really want to. This could provide a useful middle-ground<br>&gt; between optional and required, plus if the code of the parent class isn‚Äôt<br>&gt; under your control it gives you a fallback until there‚Äôs an update if the<br>&gt; warning behaviour were the default, with @super(required, error) style<br>&gt; declarations for developers who really know what their parent class needs<br>&gt; from sub-classes.<br>&gt;<br>&gt; It‚Äôs also worth considering that most code will be under your control, so<br>&gt; you‚Äôll just need to tweak (or add) the requirements, in the latter case it<br>&gt; forces you to consider how that class may be extended which I think is a<br>&gt; good thing.<br>&gt;<br>&gt; On Feb 17, 2016, at 10:02 AM, Kyle Sherman via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I just saw that there was a discussion started about this topic just<br>&gt; recently while I was developing this idea with my colleague Peter Livesey.<br>&gt; So, I figured I would submit this proposal for discussion.<br>&gt;<br>&gt; The link to the original discussion is here:<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160215/010310.html<br>&gt;<br>&gt; The subject was: ‚ÄúReplace the override keyword by ‚Äòextend‚Äô and ‚Äòreplace‚Äô<br>&gt; or add an annotation like @SuppressSuperCall‚Äù<br>&gt;<br>&gt; -Kyle<br>&gt;<br>&gt; # Enforcing Calling Super<br>&gt;<br>&gt; * Proposal: [SE-NNNN](<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md<br>&gt; )<br>&gt; * Author(s): [Swift Developer](https://github.com/swiftdev)<br>&gt; * Status: **Awaiting review**<br>&gt; * Review manager: TBD<br>&gt;<br>&gt; ## Introduction<br>&gt;<br>&gt; Many times when creating a subclass the superclass has reasons for certain<br>&gt; overridden methods to call the superclass‚Äôs version of the method. This<br>&gt; change would enforce that the subclass called the superclass&#39;s method in<br>&gt; its overridden version at compile time. Also, it would optionally enforce<br>&gt; that the superclass&#39;s version would be called before any other<br>&gt; implementation in the method (similar to initialization rules).<br>&gt;<br>&gt; Swift-evolution thread: [link to the discussion thread for that proposal](<br>&gt; https://lists.swift.org/pipermail/swift-evolution)<br>&gt;<br>&gt; ## Motivation<br>&gt;<br>&gt; A concrete example of the type of problem this solves can be taken from<br>&gt; simple iOS code. When creating a subclass of UIViewController, you often<br>&gt; need to override methods like viewDidLoad or viewWillAppear. You are<br>&gt; supposed to call super.viewDidLoad or super.viewWillAppear, respectively,<br>&gt; in your overridden implementation. If you don&#39;t, you will have undefined<br>&gt; behavior and run into issues. Of course, this type of situation can be<br>&gt; extrapolated to any class created in Swift.<br>&gt;<br>&gt; Currently, the only way this can be enforced is by commenting the<br>&gt; superclass&#39;s code and making a note in the documentation. Quite obviously<br>&gt; this can cause many issues as mistakes can be made by new developers quite<br>&gt; easily who didn&#39;t look at the documentation for the method or even seasoned<br>&gt; developers who simply overlooked this small detail.<br>&gt;<br>&gt; ## Proposed solution<br>&gt;<br>&gt; The solution proposed here would be to use an annotation similar to<br>&gt; @available and @noescape in order to convey this information. Optionally,<br>&gt; the developer can also choose to specify that the super method must be<br>&gt; called as the first line or last line of the overridden method.<br>&gt;<br>&gt; The compiler would use the information from the annotation to ensure that<br>&gt; any overridden version of the method must call super at the appropriate<br>&gt; time according to the information given in the annotation. The compiler<br>&gt; would also need to ensure that any method that was going to use this<br>&gt; annotation had the same access control level as the class that contains it.<br>&gt;<br>&gt; This solution will be much safer than what is currently available, because<br>&gt; there is currently no way to enforce super being called in an overridden<br>&gt; method. This bug happens constantly for iOS developers.<br>&gt;<br>&gt; ## Detailed design<br>&gt;<br>&gt; A possible implementation of this may look like this:<br>&gt;<br>&gt; ```<br>&gt; class MyClass {<br>&gt;    @requiredSuper func foo1() { }<br>&gt;<br>&gt;    @requiredSuper(start) func foo2() { }<br>&gt;<br>&gt;    @requiredSuper(end) func foo3() { }<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; Now, if the developer were to create a subclass and not call the super<br>&gt; method, the compiler should display an error. The errors that should be<br>&gt; displayed should be similar to:<br>&gt; ‚Ä¢ Overridden method must call the superclass‚Äôs implementation<br>&gt; ‚Ä¢ Overridden method must call the superclass‚Äôs implementation as the first<br>&gt; line of the method.<br>&gt; ‚Ä¢ Overridden method must call the superclass‚Äôs implementation as the last<br>&gt; line of the method.<br>&gt; for the cases of `@requiredSuper`, `@requiredSuper(start)`, and<br>&gt; `@requiredSuper(end)` respectively.<br>&gt;<br>&gt; The compiler would also need to display an error in this case where the<br>&gt; access control of the method is stricter than that of the class:<br>&gt;<br>&gt; ```<br>&gt; public class MyClass {<br>&gt;    @requiredSuper func foo() { }<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; The compiler should show an error, such as ‚ÄúA method using @requiredSuper<br>&gt; must have access control set to be at least as accessible as the class that<br>&gt; contains it‚Äù.<br>&gt;<br>&gt; ## Impact on existing code<br>&gt;<br>&gt; Implementation of this feature by the developer is completely optional.<br>&gt; Therefore, existing code will be unaffected and no migration of code will<br>&gt; be necessary. However, when APIs are updated to use this new feature, some<br>&gt; code will not compile if the developer did not use the APIs correctly. This<br>&gt; should be a welcomed compilation error as it will result in less buggy code<br>&gt; at runtime. The impact of this change is similar to adding nullability<br>&gt; annotations to Objective-C.<br>&gt;<br>&gt; It will be impossible to migrate code automatically, because this<br>&gt; information cannot be derived in any way aside from reading comments if and<br>&gt; only if the API author documented it.<br>&gt;<br>&gt; ## Alternatives considered<br>&gt;<br>&gt; The alternative would simply be to not implement this feature.<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160218/e9a36d7c/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[Discussion] Enforcing Calling Super</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>February 18, 2016 at 09:00:00am</p></header><div class="content"><p>I think your suggestion is structured, flexible, and entirely optional. Like it a lot because it would allow code to be even more expressive.<br></p><p>Sent from my iPhone<br></p><p>&gt; On 18 Feb 2016, at 09:00, Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I like what this thread could mean for better protocol conformance, but I think that requiring things like start/end need to be used sparingly, and only when a clean API can&#39;t be designed without it. This is mainly because of the reasons Kenny mentions, but also due to the restrictions it may place on debugging.<br>&gt; <br>&gt; Require once<br>&gt; Worth considering is that you may want to enforce that super is only called once, I&#39;m sure there&#39;s counter examples, but it seems like something worth considering.<br>&gt; <br>&gt; Implicit calls (-1)<br>&gt; I like what Dennis has suggested with implicit calls. Although I don&#39;t think it would work in the general case, and I think it&#39;s sufficiently unexpected that you wouldn&#39;t want it to only happen sometimes.<br>&gt; <br>&gt; I&#39;ve had a few hard to track bugs that have happened in the super call at the start of a method. For things like delegate methods for out-of-module classes it&#39;s useful to be able to put a breakpoint before the super call to debug it.<br>&gt; <br>&gt; It&#39;s also possible that super must be called first, but you want to use the result of that call.<br>&gt; <br>&gt; #requireSuper (+1)<br>&gt; I think we would definitely need #requireSuper, for example: if other operations must be performed either side of the call.<br>&gt; <br>&gt; I believe there&#39;s a few Cocoa cases where calling multiple methods in a specific order is required, but not necessarily as the first or last calls. For example:<br>&gt; <br>&gt; UIViewController&#39;s willMoveToParentViewController the documentation states:<br>&gt; <br>&gt; If you are implementing your own container view controller, it must call the willMoveToParentViewController: method of the child view controller before calling the removeFromParentViewController method, passing in a parent value of nil.<br>&gt; <br>&gt; This means that willMoveToParentViewController: cannot be last, nor is it explicitly required to be first. This allows calls before the call to super, and requires a call after it. I imagine a lot of code would break if this was made more strict. Perhaps this example could be fixed with a different UIViewController API, but that&#39;s out of scope.<br>&gt; <br>&gt; Generalisation?<br>&gt; I wonder if this proposal could/should be generalised to something like this (all arguments optional):<br>&gt; <br>&gt; @callRequirements(<br>&gt;     super=first|last|once|never|optional,<br>&gt;     require=[someProtocolMethod,someClassMethod],<br>&gt;     require_once=[closureArgument],<br>&gt;     require_ordered=[super,someProtocolMethod(:argument:)],<br>&gt;     disallow=[someProtocolProperty])<br>&gt; <br>&gt; The identifiers would have to be defined and unambiguous on the current type or function.<br>&gt; <br>&gt; By closureArgument I mean that a closure passed to the function must be called.<br>&gt; <br>&gt; Perhaps require_ordered can be removed if existing APIs can be made to use an cleaner/enforceable pattern.<br>&gt; <br>&gt; Note that requiring a closureArgument to be called potentially overlaps with another thread &quot;Guaranteed closure execution&quot; (with an argument like @noescape):<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160125/008167.html<br>&gt; <br>&gt; My suggestion lacks some flexibility, at some point it would be nice to be able to write custom validator functions (for protocols and classes) that can be referenced by name. There&#39;s a similar proposal for that recently called &quot;Proposal: Allow functions to participate in the compile so they can generate warnings about their usage&quot; if you&#39;re interested:<br>&gt; http://comments.gmane.org/gmane.comp.lang.swift.evolution/6870<br>&gt; <br>&gt; This could allow us to do things like this:<br>&gt; <br>&gt; @verifyCall(superFirst, pure, disallowDirectPropertyUsage)<br>&gt; <br>&gt; Andrew Bennett<br>&gt; <br>&gt;&gt; On Thursday, 18 February 2016, Dennis Weissmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Can‚Äôt the compiler generate them?<br>&gt;&gt; <br>&gt;&gt;&gt; @requiredSuper(end) func foo3()<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; If the compiler can tell you that you need to call super() at the very beginning (or the very end) of a method, it should be able to do that for you.<br>&gt;&gt; <br>&gt;&gt; What I imagine is a syntax like this:<br>&gt;&gt; <br>&gt;&gt; Note: I‚Äôve changed the syntax to # because I think this is compiler-magic and as Chris mentioned the following in the property behavior thread:<br>&gt;&gt; <br>&gt;&gt;&gt; Where [lazy] is currently used, could the syntax instead be #behavior(lazy)? That prevents a possible future naming clash, keeps the # meaning compiler-magic, and doesn&#39;t use the [], which is contentious.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; class Base {<br>&gt;&gt; <br>&gt;&gt;   #requireSuperStart			// nitpicking, but I‚Äôd like #requireSuperAtBeginning actually better<br>&gt;&gt;   func mustCallSuperMethod() {<br>&gt;&gt;     // Some code<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class Subclass: Base {<br>&gt;&gt; <br>&gt;&gt;   // All subclasses automatically (implicitly) inherit #requireSuperX, this is visible across module boundaries<br>&gt;&gt;   override func mustCallSuperMethod() {<br>&gt;&gt;     // Do your setup<br>&gt;&gt;   }<br>&gt;&gt;   <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The compiler would inject (invisible to the dev) the super() call at the very beginning. The same is true for #requireSuperEnd.<br>&gt;&gt; I don‚Äôt think we need a #requireSuper because it means we don‚Äôt care when it‚Äôs called so the compiler can decide where to put it.<br>&gt;&gt; <br>&gt;&gt; The only problematic point might be a super call with arguments but I have never ever changed the argument of a super call (e.g. in viewDidAppear(animated: Bool) I never called the super implementation other than super.viewDidAppear(animated)).<br>&gt;&gt; <br>&gt;&gt; - Dennis, who is sick =&gt; please forgive any mistakes or oversights üôè<br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 17, 2016, at 11:26 PM, Kyle Sherman via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks for the replies.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Kenny: After thinking about it more, discussing with Peter, and looking Haravikk‚Äôs comments, I think the best thing would be for this to be a warning as suggested. I respectfully disagree that as a library creator you would not be able to know that a call to super should be required. A perfect example of this is the one stated in the proposal: viewDidLoad, viewWillAppear, etc. In these cases, the library writers know that the super version must be called and no matter what the subclasser does, they will not be able to have correct behavior without calling super. This is present in many places throughout the iOS SDK as example. In the static analyzer in Xcode, for ObjC code, it warns when the developer doesn‚Äôt call super in certain cases. Having these annotations would allow for developers to specify this for their own code. Being able to suppress the warning could also be a good feature, but I definitely don‚Äôt feel it would be necessary for the implementation of the feature.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Haravikk: I don‚Äôt agree with using ‚Äú(required)‚Äù as that will be a sort of overloaded usage of the keyword. Also, I think that simply not specifying anything would be a better way to go about it. So, @super would mean you require the super method to be called, and simply not having an annotation means that you do not have to call the super method. Peter and I have a separate proposal that we will put up here soon for extending the ‚Äúrequired‚Äù keyword for all methods that I think will solve the problem of abstract classes. I don‚Äôt think that we should conflate that issue, which we feel is a separate issue, in with the issue of requiring the super method to be called. Along the same lines, final by default was already being discussed much earlier and I believe there was already a conclusion to that saying it would not be implemented. I think the final keyword should stay separate, especially since it is a compiler error vs this which we are now saying would be a warning.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Kyle<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 17, 2016, at 12:31 PM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Since this proposal is along the same lines as another current thread I‚Äôm contributing to I‚Äôm of course very much for the basic functionality ;-)<br>&gt;&gt;&gt;&gt; From that other discussion my current preference is towards either an attribute named @super, or allow the super keyword to be used in the method declaration. So a declaration might look like:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	@super(required)<br>&gt;&gt;&gt;&gt; 	func someMethod() { ‚Ä¶ }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Or (if you prefer):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	super(required) func someMethod() { ‚Ä¶ }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The main ones needed are required and optional, with optional being what we have now, and required simply ensuring that the super method is called (no requirement on where). Options for before and after will be more useful if we get abstract classes whose sole purpose is to be extended, as they may have more specific requirements. The other possibly useful option would @super(replace), in which case super may not be called by extending methods at all, as it‚Äôs implementation may be very tightly coupled to the specific implementation at that level, thus requiring a sub-class to re-implement it; the parent method could also be some kind of stub for a feature it doesn‚Äôt support, but which was required by a protocol for example.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Howard Lovatt also mentioned another interesting extension to the idea which is that methods would effectively become final by default, requiring a @super attribute if they are to be overridable, which I think would be good for ensuring that only classes designed with extension in mind can actually be extended. For this reason the @super attribute could also be used on a class to set a new default for all methods. If we go with this aspect then the final keyword would probably be moved into the @super attribute for methods (properties would still have access to it though I think).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 17 Feb 2016, at 19:55, Kenny Leung via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There is just no way to know what may be required by clients of a framework when it comes time to write actual shipping code. To require users to call super - and to even extend that to knowing whether they should call super at the beginning or end of their methods is too restrictive. If this feature were to go forward, I would limit it to a warning. It may belong more in a linter.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A lot of people have reacted negatively to the idea of before and after requirements, but I think it‚Äôs important to note that they‚Äôre unlikely to be commonly added; in most cases it won‚Äôt matter when the super method is called so required or optional should be used as appropriate. Before and after requirements are more useful for abstract or abstract-style classes that offer partial implementations specifically designed to be extended, in which case the order may be more important. Most of the time the deciding factor will be whether your method performs some kind of updates to cached values, in which case it will be important that it is called; the requirement can also be used to serve as a reminder to read the documentation about how exactly the parent method should be used by extending classes, if it has any more unusual caveats.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I‚Äôve been using IntelliJ IDEA a lot lately, and they basically have a live linter that they call ‚Äúcode inspections‚Äù. I like this a lot. It goes waaay beyond compiler-level warnings to offering you suggestions to improve your code, finding sections of duplicated code, anything under the sun. They also allow you to suppress any individual warning by putting an @suppress in your code. Maybe Swift could benefit from another layer like this in general, where you could be warned about a lot of stuff, but not be locked into it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It could make sense to have an option for whether breaking a requirement produces a warning or an error? For example @super(required, warn) will warn the developer that they are going against the parent class‚Äô requirement to include the super method, but won‚Äôt actually stop them from doing so if they really want to. This could provide a useful middle-ground between optional and required, plus if the code of the parent class isn‚Äôt under your control it gives you a fallback until there‚Äôs an update if the warning behaviour were the default, with @super(required, error) style declarations for developers who really know what their parent class needs from sub-classes.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It‚Äôs also worth considering that most code will be under your control, so you‚Äôll just need to tweak (or add) the requirements, in the latter case it forces you to consider how that class may be extended which I think is a good thing.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Feb 17, 2016, at 10:02 AM, Kyle Sherman via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I just saw that there was a discussion started about this topic just recently while I was developing this idea with my colleague Peter Livesey. So, I figured I would submit this proposal for discussion.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The link to the original discussion is here: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160215/010310.html<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The subject was: ‚ÄúReplace the override keyword by ‚Äòextend‚Äô and ‚Äòreplace‚Äô or add an annotation like @SuppressSuperCall‚Äù<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Kyle<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; # Enforcing Calling Super<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; * Proposal: [SE-NNNN](https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md)<br>&gt;&gt;&gt;&gt;&gt;&gt; * Author(s): [Swift Developer](https://github.com/swiftdev)<br>&gt;&gt;&gt;&gt;&gt;&gt; * Status: **Awaiting review**<br>&gt;&gt;&gt;&gt;&gt;&gt; * Review manager: TBD<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ## Introduction<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Many times when creating a subclass the superclass has reasons for certain overridden methods to call the superclass‚Äôs version of the method. This change would enforce that the subclass called the superclass&#39;s method in its overridden version at compile time. Also, it would optionally enforce that the superclass&#39;s version would be called before any other implementation in the method (similar to initialization rules). <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Swift-evolution thread: [link to the discussion thread for that proposal](https://lists.swift.org/pipermail/swift-evolution)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ## Motivation<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; A concrete example of the type of problem this solves can be taken from simple iOS code. When creating a subclass of UIViewController, you often need to override methods like viewDidLoad or viewWillAppear. You are supposed to call super.viewDidLoad or super.viewWillAppear, respectively, in your overridden implementation. If you don&#39;t, you will have undefined behavior and run into issues. Of course, this type of situation can be extrapolated to any class created in Swift. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Currently, the only way this can be enforced is by commenting the superclass&#39;s code and making a note in the documentation. Quite obviously this can cause many issues as mistakes can be made by new developers quite easily who didn&#39;t look at the documentation for the method or even seasoned developers who simply overlooked this small detail. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ## Proposed solution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The solution proposed here would be to use an annotation similar to @available and @noescape in order to convey this information. Optionally, the developer can also choose to specify that the super method must be called as the first line or last line of the overridden method. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The compiler would use the information from the annotation to ensure that any overridden version of the method must call super at the appropriate time according to the information given in the annotation. The compiler would also need to ensure that any method that was going to use this annotation had the same access control level as the class that contains it.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This solution will be much safer than what is currently available, because there is currently no way to enforce super being called in an overridden method. This bug happens constantly for iOS developers.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ## Detailed design<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; A possible implementation of this may look like this:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt; class MyClass {<br>&gt;&gt;&gt;&gt;&gt;&gt;    @requiredSuper func foo1() { }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;    @requiredSuper(start) func foo2() { }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;    @requiredSuper(end) func foo3() { }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Now, if the developer were to create a subclass and not call the super method, the compiler should display an error. The errors that should be displayed should be similar to: <br>&gt;&gt;&gt;&gt;&gt;&gt; 	‚Ä¢ Overridden method must call the superclass‚Äôs implementation<br>&gt;&gt;&gt;&gt;&gt;&gt; 	‚Ä¢ Overridden method must call the superclass‚Äôs implementation as the first line of the method.<br>&gt;&gt;&gt;&gt;&gt;&gt; 	‚Ä¢ Overridden method must call the superclass‚Äôs implementation as the last line of the method.<br>&gt;&gt;&gt;&gt;&gt;&gt; for the cases of `@requiredSuper`, `@requiredSuper(start)`, and `@requiredSuper(end)` respectively.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The compiler would also need to display an error in this case where the access control of the method is stricter than that of the class:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt; public class MyClass {<br>&gt;&gt;&gt;&gt;&gt;&gt;    @requiredSuper func foo() { }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The compiler should show an error, such as ‚ÄúA method using @requiredSuper must have access control set to be at least as accessible as the class that contains it‚Äù.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ## Impact on existing code<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Implementation of this feature by the developer is completely optional. Therefore, existing code will be unaffected and no migration of code will be necessary. However, when APIs are updated to use this new feature, some code will not compile if the developer did not use the APIs correctly. This should be a welcomed compilation error as it will result in less buggy code at runtime. The impact of this change is similar to adding nullability annotations to Objective-C.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It will be impossible to migrate code automatically, because this information cannot be derived in any way aside from reading comments if and only if the API author documented it.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ## Alternatives considered<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The alternative would simply be to not implement this feature.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160218/7b2d807c/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Discussion] Enforcing Calling Super</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>February 18, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On 17 Feb 2016, at 23:56, Dennis Weissmann &lt;dennis at dennisweissmann.me&gt; wrote:<br>&gt; <br>&gt; Note: I‚Äôve changed the syntax to # because I think this is compiler-magic and as Chris mentioned the following in the property behavior thread:<br></p><p>Is it compiler magic though? To me compiler magic is something that the compiler does to change your code, for example testing for OS version lets you add code specific to that OS. This wouldn‚Äôt actually change anything, it‚Äôs really just a directive in how the method should be implemented, personally that puts it closer to attributes such as @warn_unused_result IMO. You cite the case of the property behaviours proposal, however that is a proposal that introduces custom code that the compiler would connect to your properties for you, so it‚Äôs undoubtedly compiler magic of a sort.<br></p><p>If we do go for the hash prefix though, I don‚Äôt think that we need #requireSuperStart etc., just a general #requireSuper would do with optional brackets to add more specific requirements as has been proposed with attributes and keywords. That said, I think #requireSuper may be the wrong term, unless your intention was to also have #optionalSuper and #warnSuper? Personally I think it‚Äôd be easier to just to #super(required, before, warn) or whatever, same as we‚Äôve been discussing for attributes and keywords, as it groups everything into the one command; there should be no reason we can‚Äôt just use super for the naming either since it‚Äôs unambiguous (and actually it‚Äôs relevant).<br></p><p>&gt; The compiler would inject (invisible to the dev) the super() call at the very beginning. The same is true for #requireSuperEnd.<br>&gt; I don‚Äôt think we need a #requireSuper because it means we don‚Äôt care when it‚Äôs called so the compiler can decide where to put it.<br></p><p>Like others have said I think we should shy away from the compiler adding this for us, as it may introduce debugging issues if someone didn‚Äôt notice the requirements and the compiler just went and fulfilled them automatically. By encouraging/forcing the developer to actually add the call then the implementation is at least complete and self-contained in its own right. I suppose maybe this is why you favoured the hash prefix as it definitely would be compiler magic for these cases, but I think without auto-insertion it isn‚Äôt really compiler magic, certainly no more than visibility keywords are.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160218/5b41a89c/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6b82ec7032daa9f5ac2c8aa489770557?s=50"></div><header><strong>[Discussion] Enforcing Calling Super</strong> from <string>Peter Livesey</string> &lt;pdlivesey at gmail.com&gt;<p>February 17, 2016 at 10:00:00pm</p></header><div class="content"><p>I am not sure why some compiler hints use @ and others don&#39;t, but this<br>feature seems closer in functionality to @available instead of final or<br>required.<br></p><p>So I agree that overloading the required keyword seems out of place and<br>using a different syntax (using @) seems more appropriate.<br>On Wed, Feb 17, 2016 at 2:26 PM Kyle Sherman via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Thanks for the replies.<br>&gt;<br>&gt; Kenny: After thinking about it more, discussing with Peter, and looking<br>&gt; Haravikk‚Äôs comments, I think the best thing would be for this to be a<br>&gt; warning as suggested. I respectfully disagree that as a library creator you<br>&gt; would not be able to know that a call to super should be required. A<br>&gt; perfect example of this is the one stated in the proposal: viewDidLoad,<br>&gt; viewWillAppear, etc. In these cases, the library writers know that the<br>&gt; super version must be called and no matter what the subclasser does, they<br>&gt; will not be able to have correct behavior without calling super. This is<br>&gt; present in many places throughout the iOS SDK as example. In the static<br>&gt; analyzer in Xcode, for ObjC code, it warns when the developer doesn‚Äôt call<br>&gt; super in certain cases. Having these annotations would allow for developers<br>&gt; to specify this for their own code. Being able to suppress the warning<br>&gt; could also be a good feature, but I definitely don‚Äôt feel it would be<br>&gt; necessary for the implementation of the feature.<br>&gt;<br>&gt; Haravikk: I don‚Äôt agree with using ‚Äú(required)‚Äù as that will be a sort of<br>&gt; overloaded usage of the keyword. Also, I think that simply not specifying<br>&gt; anything would be a better way to go about it. So, @super would mean you<br>&gt; require the super method to be called, and simply not having an annotation<br>&gt; means that you do not have to call the super method. Peter and I have a<br>&gt; separate proposal that we will put up here soon for extending the<br>&gt; ‚Äúrequired‚Äù keyword for all methods that I think will solve the problem of<br>&gt; abstract classes. I don‚Äôt think that we should conflate that issue, which<br>&gt; we feel is a separate issue, in with the issue of requiring the super<br>&gt; method to be called. Along the same lines, final by default was already<br>&gt; being discussed much earlier and I believe there was already a conclusion<br>&gt; to that saying it would not be implemented. I think the final keyword<br>&gt; should stay separate, especially since it is a compiler error vs this which<br>&gt; we are now saying would be a warning.<br>&gt;<br>&gt; -Kyle<br>&gt;<br>&gt; On Feb 17, 2016, at 12:31 PM, Haravikk via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Since this proposal is along the same lines as another current thread I‚Äôm<br>&gt; contributing to I‚Äôm of course very much for the basic functionality ;-)<br>&gt; From that other discussion my current preference is towards either an<br>&gt; attribute named @super, or allow the super keyword to be used in the method<br>&gt; declaration. So a declaration might look like:<br>&gt;<br>&gt; @super(required)<br>&gt; func someMethod() { ‚Ä¶ }<br>&gt;<br>&gt; Or (if you prefer):<br>&gt;<br>&gt; super(required) func someMethod() { ‚Ä¶ }<br>&gt;<br>&gt; The main ones needed are required and optional, with optional being what<br>&gt; we have now, and required simply ensuring that the super method is called<br>&gt; (no requirement on where). Options for before and after will be more useful<br>&gt; if we get abstract classes whose sole purpose is to be extended, as they<br>&gt; may have more specific requirements. The other possibly useful option would<br>&gt; @super(replace), in which case super may not be called by extending methods<br>&gt; at all, as it‚Äôs implementation may be very tightly coupled to the specific<br>&gt; implementation at that level, thus requiring a sub-class to re-implement<br>&gt; it; the parent method could also be some kind of stub for a feature it<br>&gt; doesn‚Äôt support, but which was required by a protocol for example.<br>&gt;<br>&gt; Howard Lovatt also mentioned another interesting extension to the idea<br>&gt; which is that methods would effectively become final by default, requiring<br>&gt; a @super attribute if they are to be overridable, which I think would be<br>&gt; good for ensuring that only classes designed with extension in mind can<br>&gt; actually be extended. For this reason the @super attribute could also be<br>&gt; used on a class to set a new default for all methods. If we go with this<br>&gt; aspect then the final keyword would probably be moved into the @super<br>&gt; attribute for methods (properties would still have access to it though I<br>&gt; think).<br>&gt;<br>&gt; On 17 Feb 2016, at 19:55, Kenny Leung via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; There is just no way to know what may be required by clients of a<br>&gt; framework when it comes time to write actual shipping code. To require<br>&gt; users to call super - and to even extend that to knowing whether they<br>&gt; should call super at the beginning or end of their methods is too<br>&gt; restrictive. If this feature were to go forward, I would limit it to a<br>&gt; warning. It may belong more in a linter.<br>&gt;<br>&gt;<br>&gt; A lot of people have reacted negatively to the idea of before and after<br>&gt; requirements, but I think it‚Äôs important to note that they‚Äôre unlikely to<br>&gt; be commonly added; in most cases it won‚Äôt matter when the super method is<br>&gt; called so required or optional should be used as appropriate. Before and<br>&gt; after requirements are more useful for abstract or abstract-style classes<br>&gt; that offer partial implementations specifically designed to be extended, in<br>&gt; which case the order may be more important. Most of the time the deciding<br>&gt; factor will be whether your method performs some kind of updates to cached<br>&gt; values, in which case it will be important that it is called; the<br>&gt; requirement can also be used to serve as a reminder to read the<br>&gt; documentation about how exactly the parent method should be used by<br>&gt; extending classes, if it has any more unusual caveats.<br>&gt;<br>&gt; I‚Äôve been using IntelliJ IDEA a lot lately, and they basically have a live<br>&gt; linter that they call ‚Äúcode inspections‚Äù. I like this a lot. It goes waaay<br>&gt; beyond compiler-level warnings to offering you suggestions to improve your<br>&gt; code, finding sections of duplicated code, anything under the sun. They<br>&gt; also allow you to suppress any individual warning by putting an @suppress<br>&gt; in your code. Maybe Swift could benefit from another layer like this in<br>&gt; general, where you could be warned about a lot of stuff, but not be locked<br>&gt; into it.<br>&gt;<br>&gt;<br>&gt; It could make sense to have an option for whether breaking a requirement<br>&gt; produces a warning or an error? For example @super(required, warn) will<br>&gt; warn the developer that they are going against the parent class‚Äô<br>&gt; requirement to include the super method, but won‚Äôt actually stop them from<br>&gt; doing so if they really want to. This could provide a useful middle-ground<br>&gt; between optional and required, plus if the code of the parent class isn‚Äôt<br>&gt; under your control it gives you a fallback until there‚Äôs an update if the<br>&gt; warning behaviour were the default, with @super(required, error) style<br>&gt; declarations for developers who really know what their parent class needs<br>&gt; from sub-classes.<br>&gt;<br>&gt; It‚Äôs also worth considering that most code will be under your control, so<br>&gt; you‚Äôll just need to tweak (or add) the requirements, in the latter case it<br>&gt; forces you to consider how that class may be extended which I think is a<br>&gt; good thing.<br>&gt;<br>&gt; On Feb 17, 2016, at 10:02 AM, Kyle Sherman via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I just saw that there was a discussion started about this topic just<br>&gt; recently while I was developing this idea with my colleague Peter Livesey.<br>&gt; So, I figured I would submit this proposal for discussion.<br>&gt;<br>&gt; The link to the original discussion is here:<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160215/010310.html<br>&gt;<br>&gt; The subject was: ‚ÄúReplace the override keyword by ‚Äòextend‚Äô and ‚Äòreplace‚Äô<br>&gt; or add an annotation like @SuppressSuperCall‚Äù<br>&gt;<br>&gt; -Kyle<br>&gt;<br>&gt; # Enforcing Calling Super<br>&gt;<br>&gt; * Proposal: [SE-NNNN](<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md<br>&gt; )<br>&gt; * Author(s): [Swift Developer](https://github.com/swiftdev)<br>&gt; * Status: **Awaiting review**<br>&gt; * Review manager: TBD<br>&gt;<br>&gt; ## Introduction<br>&gt;<br>&gt; Many times when creating a subclass the superclass has reasons for certain<br>&gt; overridden methods to call the superclass‚Äôs version of the method. This<br>&gt; change would enforce that the subclass called the superclass&#39;s method in<br>&gt; its overridden version at compile time. Also, it would optionally enforce<br>&gt; that the superclass&#39;s version would be called before any other<br>&gt; implementation in the method (similar to initialization rules).<br>&gt;<br>&gt; Swift-evolution thread: [link to the discussion thread for that proposal](<br>&gt; https://lists.swift.org/pipermail/swift-evolution)<br>&gt;<br>&gt; ## Motivation<br>&gt;<br>&gt; A concrete example of the type of problem this solves can be taken from<br>&gt; simple iOS code. When creating a subclass of UIViewController, you often<br>&gt; need to override methods like viewDidLoad or viewWillAppear. You are<br>&gt; supposed to call super.viewDidLoad or super.viewWillAppear, respectively,<br>&gt; in your overridden implementation. If you don&#39;t, you will have undefined<br>&gt; behavior and run into issues. Of course, this type of situation can be<br>&gt; extrapolated to any class created in Swift.<br>&gt;<br>&gt; Currently, the only way this can be enforced is by commenting the<br>&gt; superclass&#39;s code and making a note in the documentation. Quite obviously<br>&gt; this can cause many issues as mistakes can be made by new developers quite<br>&gt; easily who didn&#39;t look at the documentation for the method or even seasoned<br>&gt; developers who simply overlooked this small detail.<br>&gt;<br>&gt; ## Proposed solution<br>&gt;<br>&gt; The solution proposed here would be to use an annotation similar to<br>&gt; @available and @noescape in order to convey this information. Optionally,<br>&gt; the developer can also choose to specify that the super method must be<br>&gt; called as the first line or last line of the overridden method.<br>&gt;<br>&gt; The compiler would use the information from the annotation to ensure that<br>&gt; any overridden version of the method must call super at the appropriate<br>&gt; time according to the information given in the annotation. The compiler<br>&gt; would also need to ensure that any method that was going to use this<br>&gt; annotation had the same access control level as the class that contains it.<br>&gt;<br>&gt; This solution will be much safer than what is currently available, because<br>&gt; there is currently no way to enforce super being called in an overridden<br>&gt; method. This bug happens constantly for iOS developers.<br>&gt;<br>&gt; ## Detailed design<br>&gt;<br>&gt; A possible implementation of this may look like this:<br>&gt;<br>&gt; ```<br>&gt; class MyClass {<br>&gt;    @requiredSuper func foo1() { }<br>&gt;<br>&gt;    @requiredSuper(start) func foo2() { }<br>&gt;<br>&gt;    @requiredSuper(end) func foo3() { }<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; Now, if the developer were to create a subclass and not call the super<br>&gt; method, the compiler should display an error. The errors that should be<br>&gt; displayed should be similar to:<br>&gt; ‚Ä¢ Overridden method must call the superclass‚Äôs implementation<br>&gt; ‚Ä¢ Overridden method must call the superclass‚Äôs implementation as the first<br>&gt; line of the method.<br>&gt; ‚Ä¢ Overridden method must call the superclass‚Äôs implementation as the last<br>&gt; line of the method.<br>&gt; for the cases of `@requiredSuper`, `@requiredSuper(start)`, and<br>&gt; `@requiredSuper(end)` respectively.<br>&gt;<br>&gt; The compiler would also need to display an error in this case where the<br>&gt; access control of the method is stricter than that of the class:<br>&gt;<br>&gt; ```<br>&gt; public class MyClass {<br>&gt;    @requiredSuper func foo() { }<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; The compiler should show an error, such as ‚ÄúA method using @requiredSuper<br>&gt; must have access control set to be at least as accessible as the class that<br>&gt; contains it‚Äù.<br>&gt;<br>&gt; ## Impact on existing code<br>&gt;<br>&gt; Implementation of this feature by the developer is completely optional.<br>&gt; Therefore, existing code will be unaffected and no migration of code will<br>&gt; be necessary. However, when APIs are updated to use this new feature, some<br>&gt; code will not compile if the developer did not use the APIs correctly. This<br>&gt; should be a welcomed compilation error as it will result in less buggy code<br>&gt; at runtime. The impact of this change is similar to adding nullability<br>&gt; annotations to Objective-C.<br>&gt;<br>&gt; It will be impossible to migrate code automatically, because this<br>&gt; information cannot be derived in any way aside from reading comments if and<br>&gt; only if the API author documented it.<br>&gt;<br>&gt; ## Alternatives considered<br>&gt;<br>&gt; The alternative would simply be to not implement this feature.<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160217/8a9ce503/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be09ed656d5d90501c958b001261f218?s=50"></div><header><strong>[Discussion] Enforcing Calling Super</strong> from <string>Jeremy Pereira</string> &lt;jeremy.j.pereira at googlemail.com&gt;<p>February 25, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On 17 Feb 2016, at 22:26, Kyle Sherman via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Thanks for the replies.<br>&gt; <br>&gt; Kenny: After thinking about it more, discussing with Peter, and looking Haravikk‚Äôs comments, I think the best thing would be for this to be a warning as suggested. I respectfully disagree that as a library creator you would not be able to know that a call to super should be required.<br></p><p>I disagree. You can‚Äôt possibly know all the use-cases in which your class might be subclassed. <br></p><p>In particular, it is absurd to enforce having the call to super as the first or last line of the method. That would stop me doing things like this:<br></p><p>    override func viewDidLoad()<br>    {<br>        print(‚ÄúAbout to run super.viewDidLoad()‚Äù)<br>        super.viewDidLoad()<br>        print(‚ÄúFinished super.viewDidLoad()‚Äù)<br>    }<br></p><p>Then there‚Äôs the perfectly reasonable case like this:<br></p><p>    override func viewDidLoad()<br>    {<br>        functionThatCallsSuperViewDidLoad()<br>    }<br></p><p>Why shouldn‚Äôt I be allowed to do that?<br></p><p>I‚Äôm not a fan of &quot;final by default‚Äù either because people will leave the virtual (or whatever is called) keyword off through laziness, not because it is definitely impossible to override the method or or subclass the class and make their classes impossible to reuse.<br></p><p>I would, however, accept a warning as long as I can turn it off. I like my tools sharp even though there is a higher risk I might cut myself.<br></p><p>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/73a38bb7bc9528e31098defe30e68ea4?s=50"></div><header><strong>[Discussion] Enforcing Calling Super</strong> from <string>Jean-Daniel Dupas</string> &lt;mailing at xenonium.com&gt;<p>February 25, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; Le 25 f√©vr. 2016 √† 16:47, Jeremy Pereira via swift-evolution &lt;swift-evolution at swift.org&gt; a √©crit :<br>&gt; <br>&gt; <br>&gt;&gt; On 17 Feb 2016, at 22:26, Kyle Sherman via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Thanks for the replies.<br>&gt;&gt; <br>&gt;&gt; Kenny: After thinking about it more, discussing with Peter, and looking Haravikk‚Äôs comments, I think the best thing would be for this to be a warning as suggested. I respectfully disagree that as a library creator you would not be able to know that a call to super should be required.<br>&gt; <br>&gt; I disagree. You can‚Äôt possibly know all the use-cases in which your class might be subclassed. <br>&gt; <br>&gt; In particular, it is absurd to enforce having the call to super as the first or last line of the method. That would stop me doing things like this:<br>&gt; <br>&gt;    override func viewDidLoad()<br>&gt;    {<br>&gt;        print(‚ÄúAbout to run super.viewDidLoad()‚Äù)<br>&gt;        super.viewDidLoad()<br>&gt;        print(‚ÄúFinished super.viewDidLoad()‚Äù)<br>&gt;    }<br>&gt; <br>&gt; Then there‚Äôs the perfectly reasonable case like this:<br>&gt; <br>&gt;    override func viewDidLoad()<br>&gt;    {<br>&gt;        functionThatCallsSuperViewDidLoad()<br>&gt;    }<br>&gt; <br>&gt; Why shouldn‚Äôt I be allowed to do that?<br></p><p>+1 with your concern. I‚Äôd be curious to see a single real world use case where enforcing first or last is required.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] Enforcing Calling Super</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>February 25, 2016 at 01:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Feb 25, 2016, at 1:17 PM, Jean-Daniel Dupas via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Le 25 f√©vr. 2016 √† 16:47, Jeremy Pereira via swift-evolution &lt;swift-evolution at swift.org&gt; a √©crit :<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 17 Feb 2016, at 22:26, Kyle Sherman via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks for the replies.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Kenny: After thinking about it more, discussing with Peter, and looking Haravikk‚Äôs comments, I think the best thing would be for this to be a warning as suggested. I respectfully disagree that as a library creator you would not be able to know that a call to super should be required.<br>&gt;&gt; <br>&gt;&gt; I disagree. You can‚Äôt possibly know all the use-cases in which your class might be subclassed. <br>&gt;&gt; <br>&gt;&gt; In particular, it is absurd to enforce having the call to super as the first or last line of the method. That would stop me doing things like this:<br>&gt;&gt; <br>&gt;&gt;   override func viewDidLoad()<br>&gt;&gt;   {<br>&gt;&gt;       print(‚ÄúAbout to run super.viewDidLoad()‚Äù)<br>&gt;&gt;       super.viewDidLoad()<br>&gt;&gt;       print(‚ÄúFinished super.viewDidLoad()‚Äù)<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; Then there‚Äôs the perfectly reasonable case like this:<br>&gt;&gt; <br>&gt;&gt;   override func viewDidLoad()<br>&gt;&gt;   {<br>&gt;&gt;       functionThatCallsSuperViewDidLoad()<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; Why shouldn‚Äôt I be allowed to do that?<br>&gt; <br>&gt; +1 with your concern. I‚Äôd be curious to see a single real world use case where enforcing first or last is required.<br></p><p>I posted several examples from Apple frameworks in an old thread about this.  You might want to look for that message in the archives.<br></p><p>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/73a38bb7bc9528e31098defe30e68ea4?s=50"></div><header><strong>[Discussion] Enforcing Calling Super</strong> from <string>Jean-Daniel Dupas</string> &lt;mailing at xenonium.com&gt;<p>February 25, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; Le 25 f√©vr. 2016 √† 20:19, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; a √©crit :<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt;&gt; On Feb 25, 2016, at 1:17 PM, Jean-Daniel Dupas via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Le 25 f√©vr. 2016 √† 16:47, Jeremy Pereira via swift-evolution &lt;swift-evolution at swift.org&gt; a √©crit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 17 Feb 2016, at 22:26, Kyle Sherman via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks for the replies.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Kenny: After thinking about it more, discussing with Peter, and looking Haravikk‚Äôs comments, I think the best thing would be for this to be a warning as suggested. I respectfully disagree that as a library creator you would not be able to know that a call to super should be required.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I disagree. You can‚Äôt possibly know all the use-cases in which your class might be subclassed. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In particular, it is absurd to enforce having the call to super as the first or last line of the method. That would stop me doing things like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  override func viewDidLoad()<br>&gt;&gt;&gt;  {<br>&gt;&gt;&gt;      print(‚ÄúAbout to run super.viewDidLoad()‚Äù)<br>&gt;&gt;&gt;      super.viewDidLoad()<br>&gt;&gt;&gt;      print(‚ÄúFinished super.viewDidLoad()‚Äù)<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Then there‚Äôs the perfectly reasonable case like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  override func viewDidLoad()<br>&gt;&gt;&gt;  {<br>&gt;&gt;&gt;      functionThatCallsSuperViewDidLoad()<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Why shouldn‚Äôt I be allowed to do that?<br>&gt;&gt; <br>&gt;&gt; +1 with your concern. I‚Äôd be curious to see a single real world use case where enforcing first or last is required.<br>&gt; <br>&gt; I posted several examples from Apple frameworks in an old thread about this.  You might want to look for that message in the archives.<br></p><p>And not a single one has a strong requirement about prohibiting code to be call before or after the super class implementation.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] Enforcing Calling Super</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>February 25, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Feb 25, 2016, at 1:23 PM, Jean-Daniel Dupas &lt;mailing at xenonium.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Le 25 f√©vr. 2016 √† 20:19, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; a √©crit :<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 25, 2016, at 1:17 PM, Jean-Daniel Dupas via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Le 25 f√©vr. 2016 √† 16:47, Jeremy Pereira via swift-evolution &lt;swift-evolution at swift.org&gt; a √©crit :<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 17 Feb 2016, at 22:26, Kyle Sherman via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thanks for the replies.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Kenny: After thinking about it more, discussing with Peter, and looking Haravikk‚Äôs comments, I think the best thing would be for this to be a warning as suggested. I respectfully disagree that as a library creator you would not be able to know that a call to super should be required.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I disagree. You can‚Äôt possibly know all the use-cases in which your class might be subclassed. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In particular, it is absurd to enforce having the call to super as the first or last line of the method. That would stop me doing things like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; override func viewDidLoad()<br>&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;     print(‚ÄúAbout to run super.viewDidLoad()‚Äù)<br>&gt;&gt;&gt;&gt;     super.viewDidLoad()<br>&gt;&gt;&gt;&gt;     print(‚ÄúFinished super.viewDidLoad()‚Äù)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Then there‚Äôs the perfectly reasonable case like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; override func viewDidLoad()<br>&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;     functionThatCallsSuperViewDidLoad()<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Why shouldn‚Äôt I be allowed to do that?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +1 with your concern. I‚Äôd be curious to see a single real world use case where enforcing first or last is required.<br>&gt;&gt; <br>&gt;&gt; I posted several examples from Apple frameworks in an old thread about this.  You might want to look for that message in the archives.<br>&gt; <br>&gt; And not a single one has a strong requirement about prohibiting code to be call before or after the super class implementation.<br></p><p>It depends what you mean by ‚Äústrong‚Äù.  Sure, a log statement won‚Äôt make much difference.  But the examples I gave do have semantic requirements that super should either go first or last in performing real work to be done by the method.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160225/5552306e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/73a38bb7bc9528e31098defe30e68ea4?s=50"></div><header><strong>[Discussion] Enforcing Calling Super</strong> from <string>Jean-Daniel Dupas</string> &lt;mailing at xenonium.com&gt;<p>February 25, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; Le 25 f√©vr. 2016 √† 20:28, Matthew Johnson &lt;matthew at anandabits.com&gt; a √©crit :<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 25, 2016, at 1:23 PM, Jean-Daniel Dupas &lt;mailing at xenonium.com &lt;mailto:mailing at xenonium.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Le 25 f√©vr. 2016 √† 20:19, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a √©crit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 25, 2016, at 1:17 PM, Jean-Daniel Dupas via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Le 25 f√©vr. 2016 √† 16:47, Jeremy Pereira via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a √©crit :<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 17 Feb 2016, at 22:26, Kyle Sherman via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Thanks for the replies.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Kenny: After thinking about it more, discussing with Peter, and looking Haravikk‚Äôs comments, I think the best thing would be for this to be a warning as suggested. I respectfully disagree that as a library creator you would not be able to know that a call to super should be required.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I disagree. You can‚Äôt possibly know all the use-cases in which your class might be subclassed. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In particular, it is absurd to enforce having the call to super as the first or last line of the method. That would stop me doing things like this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; override func viewDidLoad()<br>&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;     print(‚ÄúAbout to run super.viewDidLoad()‚Äù)<br>&gt;&gt;&gt;&gt;&gt;     super.viewDidLoad()<br>&gt;&gt;&gt;&gt;&gt;     print(‚ÄúFinished super.viewDidLoad()‚Äù)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Then there‚Äôs the perfectly reasonable case like this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; override func viewDidLoad()<br>&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;     functionThatCallsSuperViewDidLoad()<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Why shouldn‚Äôt I be allowed to do that?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; +1 with your concern. I‚Äôd be curious to see a single real world use case where enforcing first or last is required.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I posted several examples from Apple frameworks in an old thread about this.  You might want to look for that message in the archives.<br>&gt;&gt; <br>&gt;&gt; And not a single one has a strong requirement about prohibiting code to be call before or after the super class implementation.<br>&gt; <br>&gt; It depends what you mean by ‚Äústrong‚Äù.  Sure, a log statement won‚Äôt make much difference.  But the examples I gave do have semantic requirements that super should either go first or last in performing real work to be done by the method.<br></p><p>For instance:<br>// If you override this method, you must call super first to get the invalidation context object to return. After getting this object, set any custom properties and return it.<br>func invalidationContextForBoundsChange(_ newBounds: CGRect) -&gt; UICollectionViewLayoutInvalidationContext<br></p><p>Why must I call super first ? Why can‚Äôt I don‚Äôt a bunch of things that are related to my subclass first ?<br></p><p>How am I supposed to do if I want to compute a new bound to pass to super instead of forwarding it naively.<br></p><p>ditto for <br>// call super first to retrieve the item‚Äôs existing attributes and then make your changes to the returned structure.<br>layoutAttributesForInteractivelyMovingItemAtIndexPath(_ indexPath: NSIndexPath, withTargetPosition position: CGPoint) -&gt; UICollectionViewLayoutAttributes<br>Why would you prevent a subclass to compute an other indexPath or target position before calling super ?<br></p><p><br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160225/2a5fa834/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d0659d0725d0f35fa2b7d2cd23631502?s=50"></div><header><strong>[Discussion] Enforcing Calling Super</strong> from <string>Vanderlei Martinelli</string> &lt;vmartinelli at alecrim.com&gt;<p>February 25, 2016 at 05:00:00pm</p></header><div class="content"><p>I vote (again) to only specify if a func requires super. When to call super<br>is up to the developer after reading the docs.<br></p><p>-Van<br></p><p>On Thu, Feb 25, 2016 at 5:02 PM, Jean-Daniel Dupas via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; Le 25 f√©vr. 2016 √† 20:28, Matthew Johnson &lt;matthew at anandabits.com&gt; a<br>&gt; √©crit :<br>&gt;<br>&gt;<br>&gt; On Feb 25, 2016, at 1:23 PM, Jean-Daniel Dupas &lt;mailing at xenonium.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;<br>&gt; Le 25 f√©vr. 2016 √† 20:19, Matthew Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a √©crit :<br>&gt;<br>&gt;<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On Feb 25, 2016, at 1:17 PM, Jean-Daniel Dupas via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; Le 25 f√©vr. 2016 √† 16:47, Jeremy Pereira via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a √©crit :<br>&gt;<br>&gt;<br>&gt; On 17 Feb 2016, at 22:26, Kyle Sherman via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Thanks for the replies.<br>&gt;<br>&gt; Kenny: After thinking about it more, discussing with Peter, and looking<br>&gt; Haravikk‚Äôs comments, I think the best thing would be for this to be a<br>&gt; warning as suggested. I respectfully disagree that as a library creator you<br>&gt; would not be able to know that a call to super should be required.<br>&gt;<br>&gt;<br>&gt; I disagree. You can‚Äôt possibly know all the use-cases in which your class<br>&gt; might be subclassed.<br>&gt;<br>&gt; In particular, it is absurd to enforce having the call to super as the<br>&gt; first or last line of the method. That would stop me doing things like this:<br>&gt;<br>&gt; override func viewDidLoad()<br>&gt; {<br>&gt;     print(‚ÄúAbout to run super.viewDidLoad()‚Äù)<br>&gt;     super.viewDidLoad()<br>&gt;     print(‚ÄúFinished super.viewDidLoad()‚Äù)<br>&gt; }<br>&gt;<br>&gt; Then there‚Äôs the perfectly reasonable case like this:<br>&gt;<br>&gt; override func viewDidLoad()<br>&gt; {<br>&gt;     functionThatCallsSuperViewDidLoad()<br>&gt; }<br>&gt;<br>&gt; Why shouldn‚Äôt I be allowed to do that?<br>&gt;<br>&gt;<br>&gt; +1 with your concern. I‚Äôd be curious to see a single real world use case<br>&gt; where enforcing first or last is required.<br>&gt;<br>&gt;<br>&gt; I posted several examples from Apple frameworks in an old thread about<br>&gt; this.  You might want to look for that message in the archives.<br>&gt;<br>&gt;<br>&gt; And not a single one has a strong requirement about prohibiting code to be<br>&gt; call before or after the super class implementation.<br>&gt;<br>&gt;<br>&gt; It depends what you mean by ‚Äústrong‚Äù.  Sure, a log statement won‚Äôt make<br>&gt; much difference.  But the examples I gave do have semantic requirements<br>&gt; that super should either go first or last in performing real work to be<br>&gt; done by the method.<br>&gt;<br>&gt;<br>&gt; For instance:<br>&gt;<br>&gt; // If you override this method, you must call super first to get the invalidation context object to return. After getting this object, set any custom properties and return it.<br>&gt; func invalidationContextForBoundsChange(_ newBounds: CGRect) -&gt; UICollectionViewLayoutInvalidationContext<br>&gt;<br>&gt;<br>&gt; Why must I call super first ? Why can‚Äôt I don‚Äôt a bunch of things that are<br>&gt; related to my subclass first ?<br>&gt;<br>&gt; How am I supposed to do if I want to compute a new bound to pass to super<br>&gt; instead of forwarding it naively.<br>&gt;<br>&gt; ditto for<br>&gt;<br>&gt; // call super first to retrieve the item‚Äôs existing attributes and then make your changes to the returned structure.<br>&gt; layoutAttributesForInteractivelyMovingItemAtIndexPath(_ indexPath: NSIndexPath, withTargetPosition position: CGPoint) -&gt; UICollectionViewLayoutAttributes<br>&gt;<br>&gt; Why would you prevent a subclass to compute an other indexPath or target<br>&gt; position before calling super ?<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160225/d6a046aa/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>[Discussion] Enforcing Calling Super</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>February 26, 2016 at 08:00:00am</p></header><div class="content"><p>I agree.<br></p><p>While there may be specific cases where super must be called first or last, I think the examples provided were exceptions, rather than rules. The dealloc method in Obj-C for example was one case, and it was so overarching that the compiler took control of that with ARC.<br></p><p>I fail to see in mainstream code why it would ever be necessary to force a programmer not to do a single line of work prior, or prior to the end of, a super call. Could there be exceptions? I‚Äôm sure we could eventually find a use case. But I don‚Äôt think this is prolific enough that we need to start adding to the language for it. We can document the requirement on the method if we need to.<br></p><p>&gt; On 26 Feb 2016, at 7:38 AM, Vanderlei Martinelli via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I vote (again) to only specify if a func requires super. When to call super is up to the developer after reading the docs.<br>&gt; <br>&gt; -Van<br>&gt; <br>&gt; On Thu, Feb 25, 2016 at 5:02 PM, Jean-Daniel Dupas via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Le 25 f√©vr. 2016 √† 20:28, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; a √©crit :<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 25, 2016, at 1:23 PM, Jean-Daniel Dupas &lt;mailing at xenonium.com &lt;mailto:mailing at xenonium.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Le 25 f√©vr. 2016 √† 20:19, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a √©crit :<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Feb 25, 2016, at 1:17 PM, Jean-Daniel Dupas via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Le 25 f√©vr. 2016 √† 16:47, Jeremy Pereira via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a √©crit :<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 17 Feb 2016, at 22:26, Kyle Sherman via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks for the replies.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Kenny: After thinking about it more, discussing with Peter, and looking Haravikk‚Äôs comments, I think the best thing would be for this to be a warning as suggested. I respectfully disagree that as a library creator you would not be able to know that a call to super should be required.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I disagree. You can‚Äôt possibly know all the use-cases in which your class might be subclassed. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In particular, it is absurd to enforce having the call to super as the first or last line of the method. That would stop me doing things like this:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; override func viewDidLoad()<br>&gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt;     print(‚ÄúAbout to run super.viewDidLoad()‚Äù)<br>&gt;&gt;&gt;&gt;&gt;&gt;     super.viewDidLoad()<br>&gt;&gt;&gt;&gt;&gt;&gt;     print(‚ÄúFinished super.viewDidLoad()‚Äù)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Then there‚Äôs the perfectly reasonable case like this:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; override func viewDidLoad()<br>&gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt;     functionThatCallsSuperViewDidLoad()<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Why shouldn‚Äôt I be allowed to do that?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; +1 with your concern. I‚Äôd be curious to see a single real world use case where enforcing first or last is required.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I posted several examples from Apple frameworks in an old thread about this.  You might want to look for that message in the archives.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And not a single one has a strong requirement about prohibiting code to be call before or after the super class implementation.<br>&gt;&gt; <br>&gt;&gt; It depends what you mean by ‚Äústrong‚Äù.  Sure, a log statement won‚Äôt make much difference.  But the examples I gave do have semantic requirements that super should either go first or last in performing real work to be done by the method.<br>&gt; <br>&gt; For instance:<br>&gt; // If you override this method, you must call super first to get the invalidation context object to return. After getting this object, set any custom properties and return it.<br>&gt; func invalidationContextForBoundsChange(_ newBounds: CGRect) -&gt; UICollectionViewLayoutInvalidationContext<br>&gt; <br>&gt; Why must I call super first ? Why can‚Äôt I don‚Äôt a bunch of things that are related to my subclass first ?<br>&gt; <br>&gt; How am I supposed to do if I want to compute a new bound to pass to super instead of forwarding it naively.<br>&gt; <br>&gt; ditto for <br>&gt; // call super first to retrieve the item‚Äôs existing attributes and then make your changes to the returned structure.<br>&gt; layoutAttributesForInteractivelyMovingItemAtIndexPath(_ indexPath: NSIndexPath, withTargetPosition position: CGPoint) -&gt; UICollectionViewLayoutAttributes<br>&gt; Why would you prevent a subclass to compute an other indexPath or target position before calling super ?<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160226/dc168fbd/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Discussion] Enforcing Calling Super</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>February 25, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On 25 Feb 2016, at 15:47, Jeremy Pereira via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; In particular, it is absurd to enforce having the call to super as the first or last line of the method. That would stop me doing things like this:<br>&gt; <br>&gt;    override func viewDidLoad()<br>&gt;    {<br>&gt;        print(‚ÄúAbout to run super.viewDidLoad()‚Äù)<br>&gt;        super.viewDidLoad()<br>&gt;        print(‚ÄúFinished super.viewDidLoad()‚Äù)<br>&gt;    }<br>&gt; <br>&gt; Then there‚Äôs the perfectly reasonable case like this:<br>&gt; <br>&gt;    override func viewDidLoad()<br>&gt;    {<br>&gt;        functionThatCallsSuperViewDidLoad()<br>&gt;    }<br>&gt; <br>&gt; Why shouldn‚Äôt I be allowed to do that?<br></p><p>Because the parent class told you not to? I‚Äôve said repeatedly on the subject now however that before/after constraints aren‚Äôt something that you should expect to see commonly, as they‚Äôre something that developers should only set if they are absolutely certain that they will be required. The way I see it they will be most commonly used in two particular cases:<br></p><p>Partial Implementation: For an abstract-style class, a provided partial implementation might only handle the preliminary setup or final handling of values, in which case it must be called first or last in order for an implementation to be completing it correctly.<br>Undefined State: If the parent class shares values and methods for sub-classes to use, but cannot guarantee a consistent state if they are called without the super method. Again this is really more likely to happen in types that are specifically intended for extension where order may be important, rather than a complete type that you just happen to decide to extend.<br></p><p>To reiterate, these should one of the less commonly used operations, and since the default is going to be to issue a warning then you aren‚Äôt prevented from doing anything.<br></p><p>It‚Äôs also possible that if the compiler can better detect ‚Äúmutating‚Äù class methods then it would be possible for it to allow non-mutating code in front of a before condition, though could still potentially need to be warned against (in the undefined state you could be retrieving a value before it‚Äôs ready to be used). But once again, it‚Äôll be a warning, so you can just ignore, and that‚Äôs assuming the condition is even being used, which shouldn‚Äôt be very common if it‚Äôs being used sensibly.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160225/2a351a5c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5c9df42e3c293e3cdb5f3e1b34d44ef9?s=50"></div><header><strong>[Discussion] Enforcing Calling Super</strong> from <string>Step C</string> &lt;schristopher at bignerdranch.com&gt;<p>February 26, 2016 at 08:00:00am</p></header><div class="content"><p>I keep seeing the argument made that people can just ignore warnings so it does not stop them. I think that is a misuse of warnings. We should not be providing warnings that we expect some people to just ignore. Further, at many places warnings are treated the same as errors. <br></p><p>- Step<br></p><p>&gt; On Feb 25, 2016, at 5:02 PM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 25 Feb 2016, at 15:47, Jeremy Pereira via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; In particular, it is absurd to enforce having the call to super as the first or last line of the method. That would stop me doing things like this:<br>&gt;&gt; <br>&gt;&gt;    override func viewDidLoad()<br>&gt;&gt;    {<br>&gt;&gt;        print(‚ÄúAbout to run super.viewDidLoad()‚Äù)<br>&gt;&gt;        super.viewDidLoad()<br>&gt;&gt;        print(‚ÄúFinished super.viewDidLoad()‚Äù)<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; Then there‚Äôs the perfectly reasonable case like this:<br>&gt;&gt; <br>&gt;&gt;    override func viewDidLoad()<br>&gt;&gt;    {<br>&gt;&gt;        functionThatCallsSuperViewDidLoad()<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; Why shouldn‚Äôt I be allowed to do that?<br>&gt; <br>&gt; Because the parent class told you not to? I‚Äôve said repeatedly on the subject now however that before/after constraints aren‚Äôt something that you should expect to see commonly, as they‚Äôre something that developers should only set if they are absolutely certain that they will be required. The way I see it they will be most commonly used in two particular cases:<br>&gt; <br>&gt; Partial Implementation: For an abstract-style class, a provided partial implementation might only handle the preliminary setup or final handling of values, in which case it must be called first or last in order for an implementation to be completing it correctly.<br>&gt; Undefined State: If the parent class shares values and methods for sub-classes to use, but cannot guarantee a consistent state if they are called without the super method. Again this is really more likely to happen in types that are specifically intended for extension where order may be important, rather than a complete type that you just happen to decide to extend.<br>&gt; <br>&gt; To reiterate, these should one of the less commonly used operations, and since the default is going to be to issue a warning then you aren‚Äôt prevented from doing anything.<br>&gt; <br>&gt; It‚Äôs also possible that if the compiler can better detect ‚Äúmutating‚Äù class methods then it would be possible for it to allow non-mutating code in front of a before condition, though could still potentially need to be warned against (in the undefined state you could be retrieving a value before it‚Äôs ready to be used). But once again, it‚Äôll be a warning, so you can just ignore, and that‚Äôs assuming the condition is even being used, which shouldn‚Äôt be very common if it‚Äôs being used sensibly.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160226/05cb4112/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d0659d0725d0f35fa2b7d2cd23631502?s=50"></div><header><strong>[Discussion] Enforcing Calling Super</strong> from <string>Vanderlei Martinelli</string> &lt;vmartinelli at alecrim.com&gt;<p>February 26, 2016 at 12:00:00pm</p></header><div class="content"><p>@Step: I agree with you. I just cannot ignore a single warning and I&#39;m not<br>happy until my project compiles without errors *and* without any warnings.<br></p><p>-Van<br></p><p>On Fri, Feb 26, 2016 at 10:28 AM, Step C via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I keep seeing the argument made that people can just ignore warnings so it<br>&gt; does not stop them. I think that is a misuse of warnings. We should not be<br>&gt; providing warnings that we expect some people to just ignore. Further, at<br>&gt; many places warnings are treated the same as errors.<br>&gt;<br>&gt; - Step<br>&gt;<br>&gt; On Feb 25, 2016, at 5:02 PM, Haravikk via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On 25 Feb 2016, at 15:47, Jeremy Pereira via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; In particular, it is absurd to enforce having the call to super as the<br>&gt; first or last line of the method. That would stop me doing things like this:<br>&gt;<br>&gt;    override func viewDidLoad()<br>&gt;    {<br>&gt;        print(‚ÄúAbout to run super.viewDidLoad()‚Äù)<br>&gt;        super.viewDidLoad()<br>&gt;        print(‚ÄúFinished super.viewDidLoad()‚Äù)<br>&gt;    }<br>&gt;<br>&gt; Then there‚Äôs the perfectly reasonable case like this:<br>&gt;<br>&gt;    override func viewDidLoad()<br>&gt;    {<br>&gt;        functionThatCallsSuperViewDidLoad()<br>&gt;    }<br>&gt;<br>&gt; Why shouldn‚Äôt I be allowed to do that?<br>&gt;<br>&gt;<br>&gt; Because the parent class told you not to? I‚Äôve said repeatedly on the<br>&gt; subject now however that before/after constraints aren‚Äôt something that you<br>&gt; should expect to see commonly, as they‚Äôre something that developers should<br>&gt; only set if they are absolutely certain that they will be required. The way<br>&gt; I see it they will be most commonly used in two particular cases:<br>&gt;<br>&gt;<br>&gt;    - *Partial Implementation:* For an abstract-style class, a provided<br>&gt;    partial implementation might only handle the preliminary setup or final<br>&gt;    handling of values, in which case it must be called first or last in order<br>&gt;    for an implementation to be completing it correctly.<br>&gt;    - *Undefined State:* If the parent class shares values and methods for<br>&gt;    sub-classes to use, but cannot guarantee a consistent state if they are<br>&gt;    called without the super method. Again this is really more likely to happen<br>&gt;    in types that are specifically intended for extension where order may be<br>&gt;    important, rather than a complete type that you just happen to decide to<br>&gt;    extend.<br>&gt;<br>&gt;<br>&gt; To reiterate, these should one of the less commonly used operations, and<br>&gt; since the default is going to be to issue a warning then *you aren‚Äôt<br>&gt; prevented from doing anything*.<br>&gt;<br>&gt; It‚Äôs also possible that if the compiler can better detect ‚Äúmutating‚Äù class<br>&gt; methods then it would be possible for it to allow non-mutating code in<br>&gt; front of a before condition, though could still potentially need to be<br>&gt; warned against (in the undefined state you could be retrieving a value<br>&gt; before it‚Äôs ready to be used). But once again, it‚Äôll be a warning, so you<br>&gt; can just ignore, and that‚Äôs assuming the condition is even being used,<br>&gt; which shouldn‚Äôt be very common if it‚Äôs being used sensibly.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160226/0d81719f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/73a38bb7bc9528e31098defe30e68ea4?s=50"></div><header><strong>[Discussion] Enforcing Calling Super</strong> from <string>Jean-Daniel Dupas</string> &lt;mailing at xenonium.com&gt;<p>February 26, 2016 at 07:00:00pm</p></header><div class="content"><p>+1, and I would add that I don‚Äôt consider adding a &quot;silence warning&quot; attribute a valid solution to avoid a warning.<br></p><p>&gt; Le 26 f√©vr. 2016 √† 16:50, Vanderlei Martinelli via swift-evolution &lt;swift-evolution at swift.org&gt; a √©crit :<br>&gt; <br>&gt; @Step: I agree with you. I just cannot ignore a single warning and I&#39;m not happy until my project compiles without errors *and* without any warnings.<br>&gt; <br>&gt; -Van<br>&gt; <br>&gt; On Fri, Feb 26, 2016 at 10:28 AM, Step C via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; I keep seeing the argument made that people can just ignore warnings so it does not stop them. I think that is a misuse of warnings. We should not be providing warnings that we expect some people to just ignore. Further, at many places warnings are treated the same as errors. <br>&gt; <br>&gt; - Step<br>&gt; <br>&gt; On Feb 25, 2016, at 5:02 PM, Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 25 Feb 2016, at 15:47, Jeremy Pereira via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In particular, it is absurd to enforce having the call to super as the first or last line of the method. That would stop me doing things like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    override func viewDidLoad()<br>&gt;&gt;&gt;    {<br>&gt;&gt;&gt;        print(‚ÄúAbout to run super.viewDidLoad()‚Äù)<br>&gt;&gt;&gt;        super.viewDidLoad()<br>&gt;&gt;&gt;        print(‚ÄúFinished super.viewDidLoad()‚Äù)<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Then there‚Äôs the perfectly reasonable case like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    override func viewDidLoad()<br>&gt;&gt;&gt;    {<br>&gt;&gt;&gt;        functionThatCallsSuperViewDidLoad()<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Why shouldn‚Äôt I be allowed to do that?<br>&gt;&gt; <br>&gt;&gt; Because the parent class told you not to? I‚Äôve said repeatedly on the subject now however that before/after constraints aren‚Äôt something that you should expect to see commonly, as they‚Äôre something that developers should only set if they are absolutely certain that they will be required. The way I see it they will be most commonly used in two particular cases:<br>&gt;&gt; <br>&gt;&gt; Partial Implementation: For an abstract-style class, a provided partial implementation might only handle the preliminary setup or final handling of values, in which case it must be called first or last in order for an implementation to be completing it correctly.<br>&gt;&gt; Undefined State: If the parent class shares values and methods for sub-classes to use, but cannot guarantee a consistent state if they are called without the super method. Again this is really more likely to happen in types that are specifically intended for extension where order may be important, rather than a complete type that you just happen to decide to extend.<br>&gt;&gt; <br>&gt;&gt; To reiterate, these should one of the less commonly used operations, and since the default is going to be to issue a warning then you aren‚Äôt prevented from doing anything.<br>&gt;&gt; <br>&gt;&gt; It‚Äôs also possible that if the compiler can better detect ‚Äúmutating‚Äù class methods then it would be possible for it to allow non-mutating code in front of a before condition, though could still potentially need to be warned against (in the undefined state you could be retrieving a value before it‚Äôs ready to be used). But once again, it‚Äôll be a warning, so you can just ignore, and that‚Äôs assuming the condition is even being used, which shouldn‚Äôt be very common if it‚Äôs being used sensibly.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160226/f54fff66/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be09ed656d5d90501c958b001261f218?s=50"></div><header><strong>[Discussion] Enforcing Calling Super</strong> from <string>Jeremy Pereira</string> &lt;jeremy.j.pereira at googlemail.com&gt;<p>February 29, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On 25 Feb 2016, at 23:02, Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 25 Feb 2016, at 15:47, Jeremy Pereira via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; In particular, it is absurd to enforce having the call to super as the first or last line of the method. That would stop me doing things like this:<br>&gt;&gt; <br>&gt;&gt;    override func viewDidLoad()<br>&gt;&gt;    {<br>&gt;&gt;        print(‚ÄúAbout to run super.viewDidLoad()‚Äù)<br>&gt;&gt;        super.viewDidLoad()<br>&gt;&gt;        print(‚ÄúFinished super.viewDidLoad()‚Äù)<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; Then there‚Äôs the perfectly reasonable case like this:<br>&gt;&gt; <br>&gt;&gt;    override func viewDidLoad()<br>&gt;&gt;    {<br>&gt;&gt;        functionThatCallsSuperViewDidLoad()<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; Why shouldn‚Äôt I be allowed to do that?<br>&gt; <br>&gt; Because the parent class told you not to?<br></p><p>And what right does the parent class have to tell me not to?<br></p><p><br>&gt; I‚Äôve said repeatedly on the subject now however that before/after constraints aren‚Äôt something that you should expect to see commonly,<br></p><p>Before and after constraints should never be seen. How can the designer of the superclass possibly know what code is safe in front of the call to super and what isn‚Äôt?<br></p><p><br>&gt; as they‚Äôre something that developers should only set if they are absolutely certain that they will be required. The way I see it they will be most commonly used in two particular cases:<br>&gt; <br>&gt; 	‚Ä¢ Partial Implementation: For an abstract-style class, a provided partial implementation might only handle the preliminary setup or final handling of values, in which case it must be called first or last in order for an implementation to be completing it correctly.<br></p><p>And what if I want to put a log message in front of the call?<br></p><p>&gt; 	‚Ä¢ Undefined State: If the parent class shares values and methods for sub-classes to use, but cannot guarantee a consistent state if they are called without the super method. Again this is really more likely to happen in types that are specifically intended for extension where order may be important, rather than a complete type that you just happen to decide to extend.<br></p><p>I think I would design my superclass better so that this situation doesn‚Äôt arise.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3679b974d53f17b3b684fc9cadb99fa3?s=50"></div><header><strong>[Discussion] Enforcing Calling Super</strong> from <string>Kyle Sherman</string> &lt;kyledsherman at gmail.com&gt;<p>February 29, 2016 at 09:00:00am</p></header><div class="content"><p>I&#39;m convinced that we shouldn&#39;t add the begin/end functionality to this proposal. So, I will remove that from the proposal, add in reference to the NS_REQUIRES_SUPER macro, and post the final proposal for review. <br></p><p>Sent from my iPhone<br></p><p>On Feb 29, 2016, at 8:01 AM, Jeremy Pereira &lt;jeremy.j.pereira at googlemail.com&gt; wrote:<br></p><p><br>&gt; On 25 Feb 2016, at 23:02, Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 25 Feb 2016, at 15:47, Jeremy Pereira via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; In particular, it is absurd to enforce having the call to super as the first or last line of the method. That would stop me doing things like this:<br>&gt;&gt; <br>&gt;&gt;   override func viewDidLoad()<br>&gt;&gt;   {<br>&gt;&gt;       print(‚ÄúAbout to run super.viewDidLoad()‚Äù)<br>&gt;&gt;       super.viewDidLoad()<br>&gt;&gt;       print(‚ÄúFinished super.viewDidLoad()‚Äù)<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; Then there‚Äôs the perfectly reasonable case like this:<br>&gt;&gt; <br>&gt;&gt;   override func viewDidLoad()<br>&gt;&gt;   {<br>&gt;&gt;       functionThatCallsSuperViewDidLoad()<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; Why shouldn‚Äôt I be allowed to do that?<br>&gt; <br>&gt; Because the parent class told you not to?<br></p><p>And what right does the parent class have to tell me not to?<br></p><p><br>&gt; I‚Äôve said repeatedly on the subject now however that before/after constraints aren‚Äôt something that you should expect to see commonly,<br></p><p>Before and after constraints should never be seen. How can the designer of the superclass possibly know what code is safe in front of the call to super and what isn‚Äôt?<br></p><p><br>&gt; as they‚Äôre something that developers should only set if they are absolutely certain that they will be required. The way I see it they will be most commonly used in two particular cases:<br>&gt; <br>&gt;    ‚Ä¢ Partial Implementation: For an abstract-style class, a provided partial implementation might only handle the preliminary setup or final handling of values, in which case it must be called first or last in order for an implementation to be completing it correctly.<br></p><p>And what if I want to put a log message in front of the call?<br></p><p>&gt;    ‚Ä¢ Undefined State: If the parent class shares values and methods for sub-classes to use, but cannot guarantee a consistent state if they are called without the super method. Again this is really more likely to happen in types that are specifically intended for extension where order may be important, rather than a complete type that you just happen to decide to extend.<br></p><p>I think I would design my superclass better so that this situation doesn‚Äôt arise.<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Discussion] Enforcing Calling Super</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>February 18, 2016 at 09:00:00am</p></header><div class="content"><p>I think something like this making it into Swift at some point would be great, even if it‚Äôs just the `@requiresSuper` form; the positional variants would be even better.<br></p><p>However, I think any proposal like this will be *unusable* unless it *also* includes some way of explicitly marking a specific super-call as ‚ÄúOK, despite how it looks!‚Äù‚Ä¶and this is true even if you spec the feature out to only produce warnings, b/c even then you may want to silence those warnings at specific, ‚Äúknown-no-problem‚Äù call sites.<br></p><p>Here are two concrete examples:<br></p><p>// suppose `updateConstraints` has `@super(end)` applied to it:<br>override func updateConstraints() {<br>  // figure out where a bug is coming from:<br>  debugLog(‚Äú&lt;ISSUE 124&gt;#before constraints.horizontal: \(self.constraintsAffectingLayoutForAxis(.Horizontal))‚Äù)<br>  debugLog(‚Äú&lt;ISSUE 124&gt;#before constraints.vertical: \(self.constraintsAffectingLayoutForAxis(.Vertical))‚Äù)<br>  self.updateMyLocalConstraints()<br>  debugLog(‚Äú&lt;ISSUE 124&gt;#after constraints.horizontal: \(self.constraintsAffectingLayoutForAxis(.Horizontal))‚Äù)<br>  debugLog(‚Äú&lt;ISSUE 124&gt;#after constraints.vertical: \(self.constraintsAffectingLayoutForAxis(.Vertical))‚Äù)<br>  super.updateConstraints() // &lt;- not last call, but actually ok<br>  debugLog(‚Äú&lt;ISSUE 124&gt;#final constraints.horizontal: \(self.constraintsAffectingLayoutForAxis(.Horizontal))‚Äù)<br>  debugLog(‚Äú&lt;ISSUE 124&gt;#final constraints.vertical: \(self.constraintsAffectingLayoutForAxis(.Vertical))‚Äù)<br>}<br></p><p>// suppose `layoutSubviews` has `@super(begin)` applied to it:<br>override func layoutSubviews() {<br>  // capture timing info in debug runs:<br>  #if DEBUG<br>  self.performTimedBlock(‚ÄúupdateConstraints‚Äù) {<br>    super.layoutSubviews() // &lt;- not ‚Äúfirst call‚Äù, but actually ok<br>    self.layoutMyCustomSubviews()<br>  }<br>  #else<br>  super.layoutSubviews()<br>  self.layoutMyCustomSubviews()<br>  #endif<br>}<br></p><p>‚Ä¶and I picked these because they‚Äôre examples where we are actually obeying the ‚Äúspirit&quot; of the @super annotation.<br></p><p>Such an annotation could either be applied to the method (something like: `@force(@super(end):true)`?), or perhaps an annotation applied to the specific call-site‚Ä¶but right now, I don‚Äôt think Swift has anything at all that uses a &quot;call-site‚Äù attribute. <br></p><p>Are there any?<br></p><p>&gt; On Feb 17, 2016, at 12:02 PM, Kyle Sherman via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I just saw that there was a discussion started about this topic just recently while I was developing this idea with my colleague Peter Livesey. So, I figured I would submit this proposal for discussion.<br>&gt; <br>&gt; The link to the original discussion is here: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160215/010310.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160215/010310.html&gt;<br>&gt; <br>&gt; The subject was: ‚ÄúReplace the override keyword by ‚Äòextend‚Äô and ‚Äòreplace‚Äô or add an annotation like @SuppressSuperCall‚Äù<br>&gt; <br>&gt; -Kyle<br>&gt; <br>&gt; # Enforcing Calling Super<br>&gt; <br>&gt; * Proposal: [SE-NNNN](https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;)<br>&gt; * Author(s): [Swift Developer](https://github.com/swiftdev &lt;https://github.com/swiftdev&gt;)<br>&gt; * Status: **Awaiting review**<br>&gt; * Review manager: TBD<br>&gt; <br>&gt; ## Introduction<br>&gt; <br>&gt; Many times when creating a subclass the superclass has reasons for certain overridden methods to call the superclass‚Äôs version of the method. This change would enforce that the subclass called the superclass&#39;s method in its overridden version at compile time. Also, it would optionally enforce that the superclass&#39;s version would be called before any other implementation in the method (similar to initialization rules). <br>&gt; <br>&gt; Swift-evolution thread: [link to the discussion thread for that proposal](https://lists.swift.org/pipermail/swift-evolution &lt;https://lists.swift.org/pipermail/swift-evolution&gt;)<br>&gt; <br>&gt; ## Motivation<br>&gt; <br>&gt; A concrete example of the type of problem this solves can be taken from simple iOS code. When creating a subclass of UIViewController, you often need to override methods like viewDidLoad or viewWillAppear. You are supposed to call super.viewDidLoad or super.viewWillAppear, respectively, in your overridden implementation. If you don&#39;t, you will have undefined behavior and run into issues. Of course, this type of situation can be extrapolated to any class created in Swift. <br>&gt; <br>&gt; Currently, the only way this can be enforced is by commenting the superclass&#39;s code and making a note in the documentation. Quite obviously this can cause many issues as mistakes can be made by new developers quite easily who didn&#39;t look at the documentation for the method or even seasoned developers who simply overlooked this small detail. <br>&gt; <br>&gt; ## Proposed solution<br>&gt; <br>&gt; The solution proposed here would be to use an annotation similar to @available and @noescape in order to convey this information. Optionally, the developer can also choose to specify that the super method must be called as the first line or last line of the overridden method. <br>&gt; <br>&gt; The compiler would use the information from the annotation to ensure that any overridden version of the method must call super at the appropriate time according to the information given in the annotation. The compiler would also need to ensure that any method that was going to use this annotation had the same access control level as the class that contains it.<br>&gt; <br>&gt; This solution will be much safer than what is currently available, because there is currently no way to enforce super being called in an overridden method. This bug happens constantly for iOS developers.<br>&gt; <br>&gt; ## Detailed design<br>&gt; <br>&gt; A possible implementation of this may look like this:<br>&gt; <br>&gt; ```<br>&gt; class MyClass {<br>&gt;     @requiredSuper func foo1() { }<br>&gt; <br>&gt;     @requiredSuper(start) func foo2() { }<br>&gt; <br>&gt;     @requiredSuper(end) func foo3() { }<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; Now, if the developer were to create a subclass and not call the super method, the compiler should display an error. The errors that should be displayed should be similar to: <br>&gt; Overridden method must call the superclass‚Äôs implementation<br>&gt; Overridden method must call the superclass‚Äôs implementation as the first line of the method.<br>&gt; Overridden method must call the superclass‚Äôs implementation as the last line of the method.<br>&gt; for the cases of `@requiredSuper`, `@requiredSuper(start)`, and `@requiredSuper(end)` respectively.<br>&gt; <br>&gt; The compiler would also need to display an error in this case where the access control of the method is stricter than that of the class:<br>&gt; <br>&gt; ```<br>&gt; public class MyClass {<br>&gt;     @requiredSuper func foo() { }<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; The compiler should show an error, such as ‚ÄúA method using @requiredSuper must have access control set to be at least as accessible as the class that contains it‚Äù.<br>&gt; <br>&gt; ## Impact on existing code<br>&gt; <br>&gt; Implementation of this feature by the developer is completely optional. Therefore, existing code will be unaffected and no migration of code will be necessary. However, when APIs are updated to use this new feature, some code will not compile if the developer did not use the APIs correctly. This should be a welcomed compilation error as it will result in less buggy code at runtime. The impact of this change is similar to adding nullability annotations to Objective-C.<br>&gt; <br>&gt; It will be impossible to migrate code automatically, because this information cannot be derived in any way aside from reading comments if and only if the API author documented it.<br>&gt; <br>&gt; ## Alternatives considered<br>&gt; <br>&gt; The alternative would simply be to not implement this feature.<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160218/aab8f4be/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6b82ec7032daa9f5ac2c8aa489770557?s=50"></div><header><strong>[Discussion] Enforcing Calling Super</strong> from <string>Peter Livesey</string> &lt;pdlivesey at gmail.com&gt;<p>February 18, 2016 at 04:00:00pm</p></header><div class="content"><p>+1 to most of what Andrew Bennet said.<br></p><p>I also disagree that implicit calls is the right solution. If the compiler<br>autocompletes the super call for me, there&#39;s little reason for this. It<br>just makes debugging much harder.<br></p><p>For the generalization part, honestly, it just looks too complicated. I<br>don&#39;t think this feature should require a chapter in the learn swift book<br>to learn all the options - it should be a footnote. In Kyle&#39;s original<br>proposal, one of the motivations for this feature is making the language<br>easier to learn - calling super isn&#39;t natural for some beginners and having<br>the compiler warn you when you&#39;re missing it is really helpful.<br></p><p>@plx: I think you bring up a great point with start and end. It may hint at<br>a deeper problem as to how to define start and end. More code runs than the<br>lines you write. There are retains and releases inserted by ARC, there are<br>assembly instructions run, etc. I think your block examples give a great<br>example of when this may be not desirable.<br></p><p>I think we have a good example of when not calling super can lead to bad<br>bugs (viewDidAppear), but do we have an example of when calling super in<br>the wrong place can lead to a bug? In most cases, does it matter?<br></p><p>On Thu, Feb 18, 2016 at 7:02 AM plx via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I think something like this making it into Swift at some point would be<br>&gt; great, even if it‚Äôs just the `@requiresSuper` form; the positional variants<br>&gt; would be even better.<br>&gt;<br>&gt; However, I think any proposal like this will be *unusable* unless it<br>&gt; *also* includes some way of explicitly marking a specific super-call as<br>&gt; ‚ÄúOK, despite how it looks!‚Äù‚Ä¶and this is true even if you spec the feature<br>&gt; out to only produce warnings, b/c even then you may want to silence those<br>&gt; warnings at specific, ‚Äúknown-no-problem‚Äù call sites.<br>&gt;<br>&gt; Here are two concrete examples:<br>&gt;<br>&gt; // suppose `updateConstraints` has `@super(end)` applied to it:<br>&gt; override func updateConstraints() {<br>&gt;   // figure out where a bug is coming from:<br>&gt;   debugLog(‚Äú&lt;ISSUE 124&gt;#before constraints.horizontal:<br>&gt; \(self.constraintsAffectingLayoutForAxis(.Horizontal))‚Äù)<br>&gt;   debugLog(‚Äú&lt;ISSUE 124&gt;#before constraints.vertical:<br>&gt; \(self.constraintsAffectingLayoutForAxis(.Vertical))‚Äù)<br>&gt;   self.updateMyLocalConstraints()<br>&gt;   debugLog(‚Äú&lt;ISSUE 124&gt;#after constraints.horizontal:<br>&gt; \(self.constraintsAffectingLayoutForAxis(.Horizontal))‚Äù)<br>&gt;   debugLog(‚Äú&lt;ISSUE 124&gt;#after constraints.vertical:<br>&gt; \(self.constraintsAffectingLayoutForAxis(.Vertical))‚Äù)<br>&gt;   super.updateConstraints() // &lt;- not last call, but actually ok<br>&gt;   debugLog(‚Äú&lt;ISSUE 124&gt;#final constraints.horizontal:<br>&gt; \(self.constraintsAffectingLayoutForAxis(.Horizontal))‚Äù)<br>&gt;   debugLog(‚Äú&lt;ISSUE 124&gt;#final constraints.vertical:<br>&gt; \(self.constraintsAffectingLayoutForAxis(.Vertical))‚Äù)<br>&gt; }<br>&gt;<br>&gt; // suppose `layoutSubviews` has `@super(begin)` applied to it:<br>&gt; override func layoutSubviews() {<br>&gt;   // capture timing info in debug runs:<br>&gt;   #if DEBUG<br>&gt;   self.performTimedBlock(‚ÄúupdateConstraints‚Äù) {<br>&gt;     super.layoutSubviews() // &lt;- not ‚Äúfirst call‚Äù, but actually ok<br>&gt;     self.layoutMyCustomSubviews()<br>&gt;   }<br>&gt;   #else<br>&gt;   super.layoutSubviews()<br>&gt;   self.layoutMyCustomSubviews()<br>&gt;   #endif<br>&gt; }<br>&gt;<br>&gt; ‚Ä¶and I picked these because they‚Äôre examples where we are actually obeying<br>&gt; the ‚Äúspirit&quot; of the @super annotation.<br>&gt;<br>&gt; Such an annotation could either be applied to the method (something like:<br>&gt; `@force(@super(end):true)`?), or perhaps an annotation applied to the<br>&gt; specific call-site‚Ä¶but right now, I don‚Äôt think Swift has anything at all<br>&gt; that uses a &quot;call-site‚Äù attribute.<br>&gt;<br>&gt; Are there any?<br>&gt;<br>&gt; On Feb 17, 2016, at 12:02 PM, Kyle Sherman via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I just saw that there was a discussion started about this topic just<br>&gt; recently while I was developing this idea with my colleague Peter Livesey.<br>&gt; So, I figured I would submit this proposal for discussion.<br>&gt;<br>&gt; The link to the original discussion is here:<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160215/010310.html<br>&gt;<br>&gt; The subject was: ‚ÄúReplace the override keyword by ‚Äòextend‚Äô and ‚Äòreplace‚Äô<br>&gt; or add an annotation like @SuppressSuperCall‚Äù<br>&gt;<br>&gt; -Kyle<br>&gt;<br>&gt; # Enforcing Calling Super<br>&gt;<br>&gt; * Proposal: [SE-NNNN](<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md<br>&gt; )<br>&gt; * Author(s): [Swift Developer](https://github.com/swiftdev)<br>&gt; * Status: **Awaiting review**<br>&gt; * Review manager: TBD<br>&gt;<br>&gt; ## Introduction<br>&gt;<br>&gt; Many times when creating a subclass the superclass has reasons for certain<br>&gt; overridden methods to call the superclass‚Äôs version of the method. This<br>&gt; change would enforce that the subclass called the superclass&#39;s method in<br>&gt; its overridden version at compile time. Also, it would optionally enforce<br>&gt; that the superclass&#39;s version would be called before any other<br>&gt; implementation in the method (similar to initialization rules).<br>&gt;<br>&gt; Swift-evolution thread: [link to the discussion thread for that proposal](<br>&gt; https://lists.swift.org/pipermail/swift-evolution)<br>&gt;<br>&gt; ## Motivation<br>&gt;<br>&gt; A concrete example of the type of problem this solves can be taken from<br>&gt; simple iOS code. When creating a subclass of UIViewController, you often<br>&gt; need to override methods like viewDidLoad or viewWillAppear. You are<br>&gt; supposed to call super.viewDidLoad or super.viewWillAppear, respectively,<br>&gt; in your overridden implementation. If you don&#39;t, you will have undefined<br>&gt; behavior and run into issues. Of course, this type of situation can be<br>&gt; extrapolated to any class created in Swift.<br>&gt;<br>&gt; Currently, the only way this can be enforced is by commenting the<br>&gt; superclass&#39;s code and making a note in the documentation. Quite obviously<br>&gt; this can cause many issues as mistakes can be made by new developers quite<br>&gt; easily who didn&#39;t look at the documentation for the method or even seasoned<br>&gt; developers who simply overlooked this small detail.<br>&gt;<br>&gt; ## Proposed solution<br>&gt;<br>&gt; The solution proposed here would be to use an annotation similar to<br>&gt; @available and @noescape in order to convey this information. Optionally,<br>&gt; the developer can also choose to specify that the super method must be<br>&gt; called as the first line or last line of the overridden method.<br>&gt;<br>&gt; The compiler would use the information from the annotation to ensure that<br>&gt; any overridden version of the method must call super at the appropriate<br>&gt; time according to the information given in the annotation. The compiler<br>&gt; would also need to ensure that any method that was going to use this<br>&gt; annotation had the same access control level as the class that contains it.<br>&gt;<br>&gt; This solution will be much safer than what is currently available, because<br>&gt; there is currently no way to enforce super being called in an overridden<br>&gt; method. This bug happens constantly for iOS developers.<br>&gt;<br>&gt; ## Detailed design<br>&gt;<br>&gt; A possible implementation of this may look like this:<br>&gt;<br>&gt; ```<br>&gt; class MyClass {<br>&gt;    @requiredSuper func foo1() { }<br>&gt;<br>&gt;    @requiredSuper(start) func foo2() { }<br>&gt;<br>&gt;    @requiredSuper(end) func foo3() { }<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; Now, if the developer were to create a subclass and not call the super<br>&gt; method, the compiler should display an error. The errors that should be<br>&gt; displayed should be similar to:<br>&gt;<br>&gt;    1. Overridden method must call the superclass‚Äôs implementation<br>&gt;    2. Overridden method must call the superclass‚Äôs implementation as the<br>&gt;    first line of the method.<br>&gt;    3. Overridden method must call the superclass‚Äôs implementation as the<br>&gt;    last line of the method.<br>&gt;<br>&gt; for the cases of `@requiredSuper`, `@requiredSuper(start)`, and<br>&gt; `@requiredSuper(end)` respectively.<br>&gt;<br>&gt; The compiler would also need to display an error in this case where the<br>&gt; access control of the method is stricter than that of the class:<br>&gt;<br>&gt; ```<br>&gt; public class MyClass {<br>&gt;    @requiredSuper func foo() { }<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; The compiler should show an error, such as ‚ÄúA method using @requiredSuper<br>&gt; must have access control set to be at least as accessible as the class that<br>&gt; contains it‚Äù.<br>&gt;<br>&gt; ## Impact on existing code<br>&gt;<br>&gt; Implementation of this feature by the developer is completely optional.<br>&gt; Therefore, existing code will be unaffected and no migration of code will<br>&gt; be necessary. However, when APIs are updated to use this new feature, some<br>&gt; code will not compile if the developer did not use the APIs correctly. This<br>&gt; should be a welcomed compilation error as it will result in less buggy code<br>&gt; at runtime. The impact of this change is similar to adding nullability<br>&gt; annotations to Objective-C.<br>&gt;<br>&gt; It will be impossible to migrate code automatically, because this<br>&gt; information cannot be derived in any way aside from reading comments if and<br>&gt; only if the API author documented it.<br>&gt;<br>&gt; ## Alternatives considered<br>&gt;<br>&gt; The alternative would simply be to not implement this feature.<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160218/9783c7be/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[Discussion] Enforcing Calling Super</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>February 18, 2016 at 08:00:00pm</p></header><div class="content"><p>I hope we will be able to use something like the clang diagnostic macro&#39;s to do that...<br></p><p>Sent from my iPhone<br></p><p>&gt; On 18 Feb 2016, at 15:02, plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think something like this making it into Swift at some point would be great, even if it‚Äôs just the `@requiresSuper` form; the positional variants would be even better.<br>&gt; <br>&gt; However, I think any proposal like this will be *unusable* unless it *also* includes some way of explicitly marking a specific super-call as ‚ÄúOK, despite how it looks!‚Äù‚Ä¶and this is true even if you spec the feature out to only produce warnings, b/c even then you may want to silence those warnings at specific, ‚Äúknown-no-problem‚Äù call sites.<br>&gt; <br>&gt; Here are two concrete examples:<br>&gt; <br>&gt; // suppose `updateConstraints` has `@super(end)` applied to it:<br>&gt; override func updateConstraints() {<br>&gt;   // figure out where a bug is coming from:<br>&gt;   debugLog(‚Äú&lt;ISSUE 124&gt;#before constraints.horizontal: \(self.constraintsAffectingLayoutForAxis(.Horizontal))‚Äù)<br>&gt;   debugLog(‚Äú&lt;ISSUE 124&gt;#before constraints.vertical: \(self.constraintsAffectingLayoutForAxis(.Vertical))‚Äù)<br>&gt;   self.updateMyLocalConstraints()<br>&gt;   debugLog(‚Äú&lt;ISSUE 124&gt;#after constraints.horizontal: \(self.constraintsAffectingLayoutForAxis(.Horizontal))‚Äù)<br>&gt;   debugLog(‚Äú&lt;ISSUE 124&gt;#after constraints.vertical: \(self.constraintsAffectingLayoutForAxis(.Vertical))‚Äù)<br>&gt;   super.updateConstraints() // &lt;- not last call, but actually ok<br>&gt;   debugLog(‚Äú&lt;ISSUE 124&gt;#final constraints.horizontal: \(self.constraintsAffectingLayoutForAxis(.Horizontal))‚Äù)<br>&gt;   debugLog(‚Äú&lt;ISSUE 124&gt;#final constraints.vertical: \(self.constraintsAffectingLayoutForAxis(.Vertical))‚Äù)<br>&gt; }<br>&gt; <br>&gt; // suppose `layoutSubviews` has `@super(begin)` applied to it:<br>&gt; override func layoutSubviews() {<br>&gt;   // capture timing info in debug runs:<br>&gt;   #if DEBUG<br>&gt;   self.performTimedBlock(‚ÄúupdateConstraints‚Äù) {<br>&gt;     super.layoutSubviews() // &lt;- not ‚Äúfirst call‚Äù, but actually ok<br>&gt;     self.layoutMyCustomSubviews()<br>&gt;   }<br>&gt;   #else<br>&gt;   super.layoutSubviews()<br>&gt;   self.layoutMyCustomSubviews()<br>&gt;   #endif<br>&gt; }<br>&gt; <br>&gt; ‚Ä¶and I picked these because they‚Äôre examples where we are actually obeying the ‚Äúspirit&quot; of the @super annotation.<br>&gt; <br>&gt; Such an annotation could either be applied to the method (something like: `@force(@super(end):true)`?), or perhaps an annotation applied to the specific call-site‚Ä¶but right now, I don‚Äôt think Swift has anything at all that uses a &quot;call-site‚Äù attribute. <br>&gt; <br>&gt; Are there any?<br>&gt; <br>&gt;&gt; On Feb 17, 2016, at 12:02 PM, Kyle Sherman via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I just saw that there was a discussion started about this topic just recently while I was developing this idea with my colleague Peter Livesey. So, I figured I would submit this proposal for discussion.<br>&gt;&gt; <br>&gt;&gt; The link to the original discussion is here: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160215/010310.html<br>&gt;&gt; <br>&gt;&gt; The subject was: ‚ÄúReplace the override keyword by ‚Äòextend‚Äô and ‚Äòreplace‚Äô or add an annotation like @SuppressSuperCall‚Äù<br>&gt;&gt; <br>&gt;&gt; -Kyle<br>&gt;&gt; <br>&gt;&gt; # Enforcing Calling Super<br>&gt;&gt; <br>&gt;&gt; * Proposal: [SE-NNNN](https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md)<br>&gt;&gt; * Author(s): [Swift Developer](https://github.com/swiftdev)<br>&gt;&gt; * Status: **Awaiting review**<br>&gt;&gt; * Review manager: TBD<br>&gt;&gt; <br>&gt;&gt; ## Introduction<br>&gt;&gt; <br>&gt;&gt; Many times when creating a subclass the superclass has reasons for certain overridden methods to call the superclass‚Äôs version of the method. This change would enforce that the subclass called the superclass&#39;s method in its overridden version at compile time. Also, it would optionally enforce that the superclass&#39;s version would be called before any other implementation in the method (similar to initialization rules). <br>&gt;&gt; <br>&gt;&gt; Swift-evolution thread: [link to the discussion thread for that proposal](https://lists.swift.org/pipermail/swift-evolution)<br>&gt;&gt; <br>&gt;&gt; ## Motivation<br>&gt;&gt; <br>&gt;&gt; A concrete example of the type of problem this solves can be taken from simple iOS code. When creating a subclass of UIViewController, you often need to override methods like viewDidLoad or viewWillAppear. You are supposed to call super.viewDidLoad or super.viewWillAppear, respectively, in your overridden implementation. If you don&#39;t, you will have undefined behavior and run into issues. Of course, this type of situation can be extrapolated to any class created in Swift. <br>&gt;&gt; <br>&gt;&gt; Currently, the only way this can be enforced is by commenting the superclass&#39;s code and making a note in the documentation. Quite obviously this can cause many issues as mistakes can be made by new developers quite easily who didn&#39;t look at the documentation for the method or even seasoned developers who simply overlooked this small detail. <br>&gt;&gt; <br>&gt;&gt; ## Proposed solution<br>&gt;&gt; <br>&gt;&gt; The solution proposed here would be to use an annotation similar to @available and @noescape in order to convey this information. Optionally, the developer can also choose to specify that the super method must be called as the first line or last line of the overridden method. <br>&gt;&gt; <br>&gt;&gt; The compiler would use the information from the annotation to ensure that any overridden version of the method must call super at the appropriate time according to the information given in the annotation. The compiler would also need to ensure that any method that was going to use this annotation had the same access control level as the class that contains it.<br>&gt;&gt; <br>&gt;&gt; This solution will be much safer than what is currently available, because there is currently no way to enforce super being called in an overridden method. This bug happens constantly for iOS developers.<br>&gt;&gt; <br>&gt;&gt; ## Detailed design<br>&gt;&gt; <br>&gt;&gt; A possible implementation of this may look like this:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; class MyClass {<br>&gt;&gt;     @requiredSuper func foo1() { }<br>&gt;&gt; <br>&gt;&gt;     @requiredSuper(start) func foo2() { }<br>&gt;&gt; <br>&gt;&gt;     @requiredSuper(end) func foo3() { }<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; Now, if the developer were to create a subclass and not call the super method, the compiler should display an error. The errors that should be displayed should be similar to: <br>&gt;&gt; Overridden method must call the superclass‚Äôs implementation<br>&gt;&gt; Overridden method must call the superclass‚Äôs implementation as the first line of the method.<br>&gt;&gt; Overridden method must call the superclass‚Äôs implementation as the last line of the method.<br>&gt;&gt; for the cases of `@requiredSuper`, `@requiredSuper(start)`, and `@requiredSuper(end)` respectively.<br>&gt;&gt; <br>&gt;&gt; The compiler would also need to display an error in this case where the access control of the method is stricter than that of the class:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; public class MyClass {<br>&gt;&gt;     @requiredSuper func foo() { }<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; The compiler should show an error, such as ‚ÄúA method using @requiredSuper must have access control set to be at least as accessible as the class that contains it‚Äù.<br>&gt;&gt; <br>&gt;&gt; ## Impact on existing code<br>&gt;&gt; <br>&gt;&gt; Implementation of this feature by the developer is completely optional. Therefore, existing code will be unaffected and no migration of code will be necessary. However, when APIs are updated to use this new feature, some code will not compile if the developer did not use the APIs correctly. This should be a welcomed compilation error as it will result in less buggy code at runtime. The impact of this change is similar to adding nullability annotations to Objective-C.<br>&gt;&gt; <br>&gt;&gt; It will be impossible to migrate code automatically, because this information cannot be derived in any way aside from reading comments if and only if the API author documented it.<br>&gt;&gt; <br>&gt;&gt; ## Alternatives considered<br>&gt;&gt; <br>&gt;&gt; The alternative would simply be to not implement this feature.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160218/7f93fcc3/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Discussion] Enforcing Calling Super</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>March  1, 2016 at 01:00:00pm</p></header><div class="content"><p>I&#39;m quite late at this party, but I always thought that it is a pity that NS_REQUIRES_SUPER hasn&#39;t been utilized more in Cocoa (all those view-controller methods‚Ä¶), and that it would be a valuable addition to Swift.<br>In the final-by-default discussion, I even proposed to make this behavior the default, and there haven&#39;t been any real arguments why final would be the better choice.<br></p><p>But I think the naming is really poor...<br>To express the meaning, it should be &quot;superNeedsToBeCalledOnOverride&quot; ‚Äî that is, of course, a terrible name for an attribute, but &quot;requiresSuper&quot; is just wrong:<br>You declare something and say &quot;this requires super&quot;, but then ignore that requirement, because in the implementation, there is no &quot;super&quot; (at this point, it&#39;s actually self instead of super‚Ä¶ I&#39;m not that happy with my explanation, but I hope you understand it anyways).<br></p><p>Maybe a native speaker could come up with better words, but so far, I like &quot;compulsive&quot; the most (&quot;mandatory&quot; would be possible as well‚Ä¶ and maybe there is a special word for inheritance of duties).<br></p><p>Tino<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/698e94ec61aae18a4cae067ad645b3fb?s=50"></div><header><strong>[Discussion] Enforcing Calling Super</strong> from <string>Jeremy W. Sherman</string> &lt;jeremyw.sherman at gmail.com&gt;<p>March  1, 2016 at 08:00:00pm</p></header><div class="content"><p>Does this handle the case of required super only since a version?<br></p><p>I recall NSView or something like that gaining an awakeFromNib<br>implementation late, say 10.5 or so, so that one had to conditionalize<br>calls to [super awakeFromNib] based on whether or not the superclass&#39;s<br>instances responded to that selector. If your code was running on 10.4,<br>calling super would crash with unrecognized selector; if on 10.5, you were<br>always supposed to call super.<br></p><p>This suggests some interaction between requiring calls to super and<br>availability annotations at the least.<br></p><p>El Wednesday, February 17, 2016, Kyle Sherman via swift-evolution &lt;<br>swift-evolution at swift.org&gt; escribi√≥:<br></p><p>&gt; I just saw that there was a discussion started about this topic just<br>&gt; recently while I was developing this idea with my colleague Peter Livesey.<br>&gt; So, I figured I would submit this proposal for discussion.<br>&gt;<br>&gt; The link to the original discussion is here:<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160215/010310.html<br>&gt;<br>&gt; The subject was: ‚ÄúReplace the override keyword by ‚Äòextend‚Äô and ‚Äòreplace‚Äô<br>&gt; or add an annotation like @SuppressSuperCall‚Äù<br>&gt;<br>&gt; -Kyle<br>&gt;<br>&gt; # Enforcing Calling Super<br>&gt;<br>&gt; * Proposal: [SE-NNNN](<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md<br>&gt; )<br>&gt; * Author(s): [Swift Developer](https://github.com/swiftdev)<br>&gt; * Status: **Awaiting review**<br>&gt; * Review manager: TBD<br>&gt;<br>&gt; ## Introduction<br>&gt;<br>&gt; Many times when creating a subclass the superclass has reasons for certain<br>&gt; overridden methods to call the superclass‚Äôs version of the method. This<br>&gt; change would enforce that the subclass called the superclass&#39;s method in<br>&gt; its overridden version at compile time. Also, it would optionally enforce<br>&gt; that the superclass&#39;s version would be called before any other<br>&gt; implementation in the method (similar to initialization rules).<br>&gt;<br>&gt; Swift-evolution thread: [link to the discussion thread for that proposal](<br>&gt; https://lists.swift.org/pipermail/swift-evolution)<br>&gt;<br>&gt; ## Motivation<br>&gt;<br>&gt; A concrete example of the type of problem this solves can be taken from<br>&gt; simple iOS code. When creating a subclass of UIViewController, you often<br>&gt; need to override methods like viewDidLoad or viewWillAppear. You are<br>&gt; supposed to call super.viewDidLoad or super.viewWillAppear, respectively,<br>&gt; in your overridden implementation. If you don&#39;t, you will have undefined<br>&gt; behavior and run into issues. Of course, this type of situation can be<br>&gt; extrapolated to any class created in Swift.<br>&gt;<br>&gt; Currently, the only way this can be enforced is by commenting the<br>&gt; superclass&#39;s code and making a note in the documentation. Quite obviously<br>&gt; this can cause many issues as mistakes can be made by new developers quite<br>&gt; easily who didn&#39;t look at the documentation for the method or even seasoned<br>&gt; developers who simply overlooked this small detail.<br>&gt;<br>&gt; ## Proposed solution<br>&gt;<br>&gt; The solution proposed here would be to use an annotation similar to<br>&gt; @available and @noescape in order to convey this information. Optionally,<br>&gt; the developer can also choose to specify that the super method must be<br>&gt; called as the first line or last line of the overridden method.<br>&gt;<br>&gt; The compiler would use the information from the annotation to ensure that<br>&gt; any overridden version of the method must call super at the appropriate<br>&gt; time according to the information given in the annotation. The compiler<br>&gt; would also need to ensure that any method that was going to use this<br>&gt; annotation had the same access control level as the class that contains it.<br>&gt;<br>&gt; This solution will be much safer than what is currently available, because<br>&gt; there is currently no way to enforce super being called in an overridden<br>&gt; method. This bug happens constantly for iOS developers.<br>&gt;<br>&gt; ## Detailed design<br>&gt;<br>&gt; A possible implementation of this may look like this:<br>&gt;<br>&gt; ```<br>&gt; class MyClass {<br>&gt;    @requiredSuper func foo1() { }<br>&gt;<br>&gt;    @requiredSuper(start) func foo2() { }<br>&gt;<br>&gt;    @requiredSuper(end) func foo3() { }<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; Now, if the developer were to create a subclass and not call the super<br>&gt; method, the compiler should display an error. The errors that should be<br>&gt; displayed should be similar to:<br>&gt;<br>&gt;    1. Overridden method must call the superclass‚Äôs implementation<br>&gt;    2. Overridden method must call the superclass‚Äôs implementation as the<br>&gt;    first line of the method.<br>&gt;    3. Overridden method must call the superclass‚Äôs implementation as the<br>&gt;    last line of the method.<br>&gt;<br>&gt; for the cases of `@requiredSuper`, `@requiredSuper(start)`, and<br>&gt; `@requiredSuper(end)` respectively.<br>&gt;<br>&gt; The compiler would also need to display an error in this case where the<br>&gt; access control of the method is stricter than that of the class:<br>&gt;<br>&gt; ```<br>&gt; public class MyClass {<br>&gt;    @requiredSuper func foo() { }<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; The compiler should show an error, such as ‚ÄúA method using @requiredSuper<br>&gt; must have access control set to be at least as accessible as the class that<br>&gt; contains it‚Äù.<br>&gt;<br>&gt; ## Impact on existing code<br>&gt;<br>&gt; Implementation of this feature by the developer is completely optional.<br>&gt; Therefore, existing code will be unaffected and no migration of code will<br>&gt; be necessary. However, when APIs are updated to use this new feature, some<br>&gt; code will not compile if the developer did not use the APIs correctly. This<br>&gt; should be a welcomed compilation error as it will result in less buggy code<br>&gt; at runtime. The impact of this change is similar to adding nullability<br>&gt; annotations to Objective-C.<br>&gt;<br>&gt; It will be impossible to migrate code automatically, because this<br>&gt; information cannot be derived in any way aside from reading comments if and<br>&gt; only if the API author documented it.<br>&gt;<br>&gt; ## Alternatives considered<br>&gt;<br>&gt; The alternative would simply be to not implement this feature.<br>&gt;<br>&gt;<br>&gt;<br></p><p>-- <br>--<br>Jeremy W. Sherman<br>https://jeremywsherman.com/<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160301/14a0620d/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
