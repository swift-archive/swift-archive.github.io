<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June 10, 2016 at 05:00:00pm</p></header><div class="content"><p>on Thu Jun 09 2016, Matthew Johnson &lt;swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org&gt; wrote:<br></p><p>&gt;&gt; On Jun 9, 2016, at 3:05 PM, Dave Abrahams &lt;dabrahams-2kanFRK1NckAvxtiuMwx3w at public.gmane.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Thu Jun 09 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;&gt;&gt; On Jun 9, 2016, at 11:42 AM, Dave Abrahams &lt;dabrahams-2kanFRK1NckAvxtiuMwx3w at public.gmane.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Thu Jun 09 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 9, 2016, at 9:55 AM, Dave Abrahams<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;dabrahams at apple.com<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:dabrahams at apple.com&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; on Wed Jun 08 2016, Matthew Johnson &lt;matthew-AT-anandabits.com<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 8, 2016, at 1:33 PM, Dave Abrahams<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;dabrahams at apple.com<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:dabrahams at apple.com&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 9:15 PM, Dave Abrahams<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;dabrahams at apple.com<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:dabrahams at apple.com&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 4:13 PM, Dave Abrahams via<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution &lt;swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; , but haven&#39;t realized<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that if you step around the type relationships encoded in Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; requirements and associated types you end up with types that appear to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; interoperate but in fact trap at runtime unless used in exactly the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; right way.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Trap at runtime?  How so?  Generalized existentials should still be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; type-safe.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There are two choices when you erase static type relationships:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1. Acheive type-safety by trapping at runtime<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; FloatingPoint(3.0 as Float) + FloatingPoint(3.0 as Double) // trap<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2. Don&#39;t expose protocol requirements that involve these relationships,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; which would prevent the code above from compiling and prevent<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; FloatingPoint from conforming to itself.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Or are you talking about the hypothetical types / behaviors people<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; think they want when they don’t fully understand what is happening...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t know what you mean here.  I think generalized existentials will<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; be nice to have, but I think most people will want them to do something<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; they can&#39;t possibly do.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Exactly.  What I meant is that people think they want that expression<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to compile because they don’t understand that the only thing it can do<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; is trap.  I said “hypothetical” because producing a compile time error<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; rather than a runtime trap is the only sane thing to do.  Your comment<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; surprised me because I can’t imagine we would move forward in Swift<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; with the approach of trapping.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I would very much like to be able to create instances of “Collection<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; where Element == Int” so we can throw away the wrappers in the stdlib.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That will require some type mismatches to be caught at runtime via<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; trapping.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; For invalid index because the existential accepts a type erased index?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Exactly.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; How do you decide where to draw the line here?  It feels like a very<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; slippery slope for a language where safety is a stated priority to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; start adopting a strategy of runtime trapping for something as<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; fundamental as how you expose members on an existential.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If you don&#39;t do this, the alternative is that “Collection where Element<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; == Int” does not conform to Collection.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This isn’t directly related to having self or associated type<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; requirements.  It is true of all existentials.  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; That is just an implementation limitation today, IIUC.  What I&#39;m talking<br>&gt;&gt;&gt;&gt;&gt;&gt; about here would make it impossible for some to do that.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If it is just an implementation limitation I am happy to hear that.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; If that changes for simple existentials and generalized existentials<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; expose all members (as in the latest draft of the proposal) maybe it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; will be possible for all existentials to conform to their protocol.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Not without introducing runtime traps.  See my “subscript function”<br>&gt;&gt;&gt;&gt;&gt;&gt; example.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That&#39;s weird and not very<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; useful.  You could expose all the methods that were on protocol<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; extensions of Collection on this existential, unless they used<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; associated types other than the element type.  But you couldn&#39;t pass the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; existential to a generic function like<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func scrambled&lt;C: Collection&gt;(_ c: C) -&gt; [C.Element]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; IMO you should *have* to introduce unsafe behavior like that manually.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Collection where Element == Int &amp; Index == *<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I didn’t mean directly through the type of the existential.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; My question is, why not?  That is still explicit.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It’s not explicit in the sense that nobody wrote `fatalError` or<br>&gt;&gt;&gt;&gt;&gt; similar in their code.  It’s too easy to write something like that<br>&gt;&gt;&gt;&gt;&gt; without realizing that it introduces the possibility of a crash.  If<br>&gt;&gt;&gt;&gt;&gt; we adopt syntax like that to introduce an existential that introduces<br>&gt;&gt;&gt;&gt;&gt; traps we should at least require members that can be trap to be<br>&gt;&gt;&gt;&gt;&gt; invoked using a `!` suffix or something like that to make it clear to<br>&gt;&gt;&gt;&gt;&gt; users that a trap will happen if they are not extremely careful when<br>&gt;&gt;&gt;&gt;&gt; using that member.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; More generally though, I don’t want the rules of the language to be<br>&gt;&gt;&gt;&gt;&gt; written in a way that causes the compiler to synthesize traps in such<br>&gt;&gt;&gt;&gt;&gt; a general way.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The existential should not introduce a precondition that isn’t already<br>&gt;&gt;&gt;&gt;&gt; present in the semantics of the protocol itself.  If the semantics of<br>&gt;&gt;&gt;&gt;&gt; the protocol do not place preconditions on arguments beyond their type<br>&gt;&gt;&gt;&gt;&gt; (such as “must be a valid index into this specific instance”) the<br>&gt;&gt;&gt;&gt;&gt; compiler should not allow the existential to conform if a trap is<br>&gt;&gt;&gt;&gt;&gt; required in some circumstances.  That is a new precondition and<br>&gt;&gt;&gt;&gt;&gt; therefore the existential does not actually fulfill the requirements<br>&gt;&gt;&gt;&gt;&gt; of the protocol.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I could *maybe* live with a solution where protocol requirements are<br>&gt;&gt;&gt;&gt;&gt; marked as trapping, etc depending on the specific argument received at<br>&gt;&gt;&gt;&gt;&gt; runtime.  This is a total straw man syntax, but maybe `IndexableBase`<br>&gt;&gt;&gt;&gt;&gt; would declare the subscript `@trapping` (probably something different<br>&gt;&gt;&gt;&gt;&gt; but I hope this communicates the idea).  This alerts users to the fact<br>&gt;&gt;&gt;&gt;&gt; that they need to be extra careful - not any value of `Self.Index` is<br>&gt;&gt;&gt;&gt;&gt; valid and you can get a crash if you’re not careful.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Having this semantic explicit in the definition of the protocol opens<br>&gt;&gt;&gt;&gt;&gt; the door to maybe considering an existential synthesized by the<br>&gt;&gt;&gt;&gt;&gt; compiler that traps because it doesn’t introduce a new precondition<br>&gt;&gt;&gt;&gt;&gt; that wasn’t already present in the protocol.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I would want to give consideration to specific details of a proposal<br>&gt;&gt;&gt;&gt;&gt; along these lines before deciding how I feel about it, but I have a<br>&gt;&gt;&gt;&gt;&gt; more open mind to this approach than introducing traps not present in<br>&gt;&gt;&gt;&gt;&gt; the preconditions of the protocol.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; /// You can subscript a collection with any valid index other than the<br>&gt;&gt;&gt;&gt;&gt; /// collection&#39;s end index. The end index refers to the position one past<br>&gt;&gt;&gt;&gt;&gt; /// the last element of a collection, so it doesn&#39;t correspond with an<br>&gt;&gt;&gt;&gt;&gt; /// element.<br>&gt;&gt;&gt;&gt;&gt; ///<br>&gt;&gt;&gt;&gt;&gt; /// - Parameter position: The position of the element to access. `position`<br>&gt;&gt;&gt;&gt;&gt; ///   must be a valid index of the collection that is not equal to the<br>&gt;&gt;&gt;&gt;&gt; ///   `endIndex` property.<br>&gt;&gt;&gt;&gt;&gt; @trapping public subscript(position: Self.Index) -&gt; Self._Element { get }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; One obvious mechanism for introducing unsafe behavior is to write<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; manual type erasure wrappers like we do today.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Another possibility would be to allow extending the existential type<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; (not the protocol).  This would allow you to write overloads on the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Collection existential that takes some kind of type erased index if<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; that is what you want and either trap if you receive an invalid index<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; or better (IMO) return an `Element?`.  I’m not sure how extensions on<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; existentials might be implemented, but this is an example of the kind<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; of operation you might want available on it that you wouldn’t want<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; available on all Collection types.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Collection indices are already something that isn’t fully statically<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; safe so I understand why you might want to allow this.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; By the same measure, so are Ints :-)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The fact that a type&#39;s methods have preconditions does *not* make it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; “statically unsafe.”<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; That depends on what you mean by safe.  Sure, those methods aren’t<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; going corrupt memory, but they *are* going to explicitly and<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; intentionally crash for some inputs.  That doesn’t qualify as “fully<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; safe” IMO.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Please pick a term other than “unsafe” here; it&#39;s not unsafe in the<br>&gt;&gt;&gt;&gt;&gt;&gt; sense we mean the word in Swift.  It&#39;s safe in exactly the same way that<br>&gt;&gt;&gt;&gt;&gt;&gt; array indexes and integers are.  When you violate a precondition, it<br>&gt;&gt;&gt;&gt;&gt;&gt; traps.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I am happy to use any word you like here.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Can you clarify what you mean by the word safe in Swift?  It doesn’t<br>&gt;&gt;&gt;&gt;&gt; appear to be limited to memory safety in the public about page<br>&gt;&gt;&gt;&gt;&gt; https://swift.org/about/ &lt;https://swift.org/about/&gt; &lt;https://swift.org/about/ &lt;https://swift.org/about/&gt;&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I mean memory- and type-safe.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Safe. The most obvious way to write code should also behave in a safe<br>&gt;&gt;&gt;&gt;&gt; manner. Undefined behavior is the enemy of safety, and developer<br>&gt;&gt;&gt;&gt;&gt; mistakes should be caught before software is in production. Opting for<br>&gt;&gt;&gt;&gt;&gt; safety sometimes means Swift will feel strict, but we believe that<br>&gt;&gt;&gt;&gt;&gt; clarity saves time in the long run.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Safety<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Swift was designed from the outset to be safer than C-based languages,<br>&gt;&gt;&gt;&gt;&gt; and eliminates entire classes of unsafe code. Variables are always<br>&gt;&gt;&gt;&gt;&gt; initialized before use, arrays and integers are checked for overflow,<br>&gt;&gt;&gt;&gt;&gt; and memory is managed automatically. Syntax is tuned to make it easy<br>&gt;&gt;&gt;&gt;&gt; to define your intent — for example, simple three-character keywords<br>&gt;&gt;&gt;&gt;&gt; define a variable (var) or constant (let).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Another safety feature is that by default Swift objects can never be<br>&gt;&gt;&gt;&gt;&gt; nil, and trying to make or use a nil object will results in a<br>&gt;&gt;&gt;&gt;&gt; compile-time error. This makes writing code much cleaner and safer,<br>&gt;&gt;&gt;&gt;&gt; and prevents a common cause of runtime crashes. However, there are<br>&gt;&gt;&gt;&gt;&gt; cases where nil is appropriate, and for these situations Swift has an<br>&gt;&gt;&gt;&gt;&gt; innovative feature known as optionals. An optional may contain nil,<br>&gt;&gt;&gt;&gt;&gt; but Swift syntax forces you to safely deal with it using ? to indicate<br>&gt;&gt;&gt;&gt;&gt; to the compiler you understand the behavior and will handle it safely.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This positioning statement makes it appear as if preventing common<br>&gt;&gt;&gt;&gt;&gt; causes of crashes falls within the meaning of safe that Swift is<br>&gt;&gt;&gt;&gt;&gt; using.  Having existentials introduce new preconditions and traps when<br>&gt;&gt;&gt;&gt;&gt; they are not met does not seem aligned with that goal IMO.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Static typing “increases safety,” in the casual sense.  That doesn&#39;t<br>&gt;&gt;&gt;&gt; mean that an operation that traps on a failed precondition check is<br>&gt;&gt;&gt;&gt; “unsafe.”<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The user doesn&#39;t do anything “manual” to introduce that trapping<br>&gt;&gt;&gt;&gt;&gt;&gt; behavior for integers.  Preconditions are a natural part of most types.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The user doesn’t, but isn’t the overflow trap implemented in the<br>&gt;&gt;&gt;&gt;&gt; standard library?  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Whether it is or is not is an implementation detail.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Regardless, this is a specific case that has been given explicit<br>&gt;&gt;&gt;&gt;&gt; design attention by humans.  The precondition is designed, not<br>&gt;&gt;&gt;&gt;&gt; introduced by compiler rules that haven’t considered the specific case<br>&gt;&gt;&gt;&gt;&gt; in question.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; But I don’t think having the language&#39;s existentials do this<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; automatically is the right approach.  Maybe there is another<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; approach that could be used in targeted use cases where the less<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; safe behavior makes sense and is carefully designed.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Whether it makes sense or not really depends on the use-cases.  There&#39;s<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; little point in generalizing existentials if the result isn&#39;t very useful.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Usefulness depends on your perspective.  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Of course.  As I&#39;ve said, let&#39;s look at the use cases.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Agree.  We can consider those in depth when the time comes to ramp up<br>&gt;&gt;&gt;&gt;&gt; discussion of Austin’s proposal.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I have run into several scenarios where they would be very useful<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; without needing to be prone to crashes when used incorrectly.  One<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; obvious basic use case is storing things in a heterogenous collection<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; where you bind .<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; bind what?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sorry, I must have gotten distracted and not finished that paragraph.<br>&gt;&gt;&gt;&gt;&gt; I meant to say bind the associated types that are necessary for your<br>&gt;&gt;&gt;&gt;&gt; use case.  Sometimes you bind *all* of the associated types to<br>&gt;&gt;&gt;&gt;&gt; concrete types and the protocol has no `Self` requirements.  In that<br>&gt;&gt;&gt;&gt;&gt; case there is no trouble at all in conforming the type-erased<br>&gt;&gt;&gt;&gt;&gt; “existential&quot; to the protocol itself.  Austin’s proposal would<br>&gt;&gt;&gt;&gt;&gt; eliminate the need to manually write these “existentials” manually.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The way to find out is to take a look at the examples we currently have<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of protocols with associated types or Self requirements and consider<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; what you&#39;d be able to do with their existentials if type relationships<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; couldn&#39;t be erased.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; We have known use-cases, currently emulated in the standard library, for<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; existentials with erased type relationships.  *If* these represent the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; predominant use cases for something like generalized existentials, it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; seems to me that the language feature should support that.  Note: I have<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; not seen anyone build an emulation of the other kind of generalized<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; existential.  My theory: there&#39;s a good reason for that :-).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; AFAIK (and I could be wrong) the only rules in the language that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; require the compiler to synthesize a trap except using a nil IUO, `!`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; on a nil Optional, and an invalid `as` cast .  These are all<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; syntactically explicit unsafe / dangerous operations.  All other traps<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; are in the standard library (array index, overflow, etc).  Most<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; important about all of these cases is that they have received direct<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; human consideration.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; There is no distinction in the user model between what might be<br>&gt;&gt;&gt;&gt;&gt;&gt; synthesized by the language and what appears on standard library types.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Maybe I shouldn’t have made that distinction.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The point I am trying to emphasize is that each of these are special<br>&gt;&gt;&gt;&gt;&gt; cases that have received direct human consideration.  The potential<br>&gt;&gt;&gt;&gt;&gt; for a trap is not introduced by language rules that apply to<br>&gt;&gt;&gt;&gt;&gt; user-defined constructs in without consideration of the specific<br>&gt;&gt;&gt;&gt;&gt; details of that construct.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Introducing a language (not library) mechanism that exposes members on<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; generalized existentials in a way that relies on runtime traps for<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; type safety feels to me like a pretty dramatic turn agains the stated<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; priority of safety.  It will mean you must understand exactly what is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; going on and be extremely careful to use generalized existentials<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; without causing crashes.  This will either make Swift code much more<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; crashy or will scare people away from using generalized existentials<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; (and maybe both).  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t accept either of those statements without seeing some analysis<br>&gt;&gt;&gt;&gt;&gt;&gt; of the use-cases.  For example, I don&#39;t believe that AnyCollection et al<br>&gt;&gt;&gt;&gt;&gt;&gt; are particularly crash-prone.  The likelihood that you&#39;ll use the wrong<br>&gt;&gt;&gt;&gt;&gt;&gt; index type with a collection is very, very low.  I&#39;m less certain of<br>&gt;&gt;&gt;&gt;&gt;&gt; what happens with Self requirements in real cases.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; But again, I believe this is an exceptional case as the precondition<br>&gt;&gt;&gt;&gt;&gt; is explicitly stated in the semantics of the protocol.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; IIUC, it has been cited by Doug as the exemplar of the<br>&gt;&gt;&gt;&gt; predominantly-requested case by a 10:1 ratio!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In terms of forming the existential, storing it in variables,<br>&gt;&gt;&gt; accepting arguments of that type, etc yes.  I don’t know how many of<br>&gt;&gt;&gt; those requests expect it to conform to the protocol and expect to be<br>&gt;&gt;&gt; able to use it in generic code constrained to the protocol.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; IMO the burden of proof should be on the side that proposes a<br>&gt;&gt;&gt;&gt;&gt; mechanism to introduce traps, not the side that proposes avoiding<br>&gt;&gt;&gt;&gt;&gt; them.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If you really want to make this about sides and burdens, the burden of<br>&gt;&gt;&gt;&gt; proof always rests with the side proposing to extend the language.  We<br>&gt;&gt;&gt;&gt; shouldn&#39;t be making changes without understanding how they will play out<br>&gt;&gt;&gt;&gt; in real use-cases.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree with this.  But if we are discussing two different options for<br>&gt;&gt;&gt; extending the language I think the option that doesn’t introduce<br>&gt;&gt;&gt; crashes should be preferred without pretty compelling reasons to<br>&gt;&gt;&gt; choose the option that can introduce crashes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Neither of those outcomes is good.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Collection indices are a somewhat special case as there is already a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; strong precondition that people are familiar with because it would be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; too costly to performance and arguably too annoying to deal with an<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Optional result in every array lookup.  IMO that is why the library is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; able to get away with it in the current type erased AnyCollection.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; But this is not a good model for exposing any members on an<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; existential that do not already have a strong precondition that causes<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; a trap when violated.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think a big reason why you maybe haven’t seen a lot of examples of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; people writing type erased “existentials&quot; is because it is a huge pain<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; in the neck to write this stuff manually today.  People may be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; designing around the need for them.  I haven’t seen a huge sampling of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; type erased “existentials&quot; other people are writing but I haven’t<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; written any that introduce a trap like this.  The only traps are in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; the “abstract&quot; base class whose methods will never be called (and<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; wouldn’t even be implemented if they could be marked abstract).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; What specific things do you think we need to be able to do that rely<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; on the compiler synthesizing a trap in the way it exposes the members<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; of the existential?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t know.  I&#39;m saying, I don&#39;t think we understand the use-cases<br>&gt;&gt;&gt;&gt;&gt;&gt; well enough to make a determination.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That’s fair.  I agree that use cases should be carefully considered.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Here are a few examples from Austin’s proposal that safely use<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; existential collections.  I don’t understand why you think this<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; approach is insufficient.  Maybe you could supply a concrete example<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; of a use case that can’t be written with the mechanism in Austin’s<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure&gt; &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure&gt;&gt; &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure&gt;&lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let a : Any&lt;Collection&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // A variable whose type is the Index associated type of the underlying<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // concrete type of &#39;a&#39;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let theIndex : a.Index = ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // A variable whose type is the Element associated type of the underlying<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // concrete type of &#39;a&#39;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let theElement : a.Element = ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Given a mutable collection, swap its first and last items.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Not a generic function. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; func swapFirstAndLast(inout collection: Any&lt;BidirectionalMutableCollection&gt;) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // firstIndex and lastIndex both have type &quot;collection.Index&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  guard let firstIndex = collection.startIndex,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;      lastIndex = collection.endIndex?.predecessor(collection) where lastIndex != firstIndex else {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;          print(&quot;Nothing to do&quot;)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;          return<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // oldFirstItem has type &quot;collection.Element&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  let oldFirstItem = collection[firstIndex]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  collection[firstIndex] = collection[lastIndex]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  collection[lastIndex] = oldFirstItem<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; var a : Any&lt;BidirectionalMutableCollection where .Element == String&gt; = ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let input = &quot;West Meoley&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Not actually necessary, since the compiler knows &quot;a.Element&quot; is String.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // A fully constrained anonymous associated type is synonymous with the concrete<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // type it&#39;s forced to take on, and the two are interchangeable.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // However, &#39;as&#39; casting is still available if desired.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let anonymousInput = input as a.Element<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; a[a.startIndex] = anonymousInput<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // as mentioned, this also works:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; a[a.startIndex] = input<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // If the collection allows it, set the first element in the collection to a given string.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; func setFirstElementIn(inout collection: Any&lt;Collection&gt; toString string: String) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  if let element = string as? collection.Element {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;      // At this point, &#39;element&#39; is of type &quot;collection.Element&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;      collection[collection.startIndex] = element<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Neither of these look like they actually make *use* of the fact that<br>&gt;&gt;&gt;&gt;&gt;&gt; there&#39;s type erasure involved (and therefore should probably be written<br>&gt;&gt;&gt;&gt;&gt;&gt; as generics?).  The interesting cases with Any&lt;Collection...&gt;, for the<br>&gt;&gt;&gt;&gt;&gt;&gt; purposes of this discussion, arise when you have multiple instances of<br>&gt;&gt;&gt;&gt;&gt;&gt; the same existential type that wrap different concrete types.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; One use case I have found is to work around the lack of higher-kinder<br>&gt;&gt;&gt;&gt;&gt; types.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Really, now: a use-case for feature A that is a workaround for the lack<br>&gt;&gt;&gt;&gt; of feature B hardly justifies adding feature A!  We do want to add<br>&gt;&gt;&gt;&gt; higher-kinded types eventually.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Good to know.  I thought higher-kinder types were on the “maybe if<br>&gt;&gt;&gt; someone shows a compelling enough use case” list.  AFAIK this is the<br>&gt;&gt;&gt; first time a member of the core team has stated the intent to add<br>&gt;&gt;&gt; them.  <br>&gt;&gt; <br>&gt;&gt; Well, please don&#39;t take this as a formal statement on behalf of the<br>&gt;&gt; team.  IIUC, the team is generally interested in having this feature.<br>&gt;<br>&gt; Of course not.  The only official plan of record for Swift is approved<br>&gt; proposals.  But it’s always interesting to know the opinions of the<br>&gt; core team about potential features.  Previously my impression had been<br>&gt; that the general leaning was towards skepticism that the practical<br>&gt; benefits of HKT would pay for the complexity.  <br></p><p>That&#39;s certainly a valid question.  I have been very vocally skeptical<br>that HKTs like Monad belong in the standard library, but I am not<br>opposed to having the language feature if it supports important use<br>cases.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 11, 2016 at 08:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jun 10, 2016, at 7:46 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Thu Jun 09 2016, Matthew Johnson &lt;swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jun 9, 2016, at 3:05 PM, Dave Abrahams &lt;dabrahams-2kanFRK1NckAvxtiuMwx3w at public.gmane.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Thu Jun 09 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 9, 2016, at 11:42 AM, Dave Abrahams &lt;dabrahams-2kanFRK1NckAvxtiuMwx3w at public.gmane.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Thu Jun 09 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 9, 2016, at 9:55 AM, Dave Abrahams<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;dabrahams at apple.com<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:dabrahams at apple.com&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Wed Jun 08 2016, Matthew Johnson &lt;matthew-AT-anandabits.com<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 8, 2016, at 1:33 PM, Dave Abrahams<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;dabrahams at apple.com<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:dabrahams at apple.com&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 9:15 PM, Dave Abrahams<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;dabrahams at apple.com<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:dabrahams at apple.com&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 4:13 PM, Dave Abrahams via<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution &lt;swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; , but haven&#39;t realized<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that if you step around the type relationships encoded in Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; requirements and associated types you end up with types that appear to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; interoperate but in fact trap at runtime unless used in exactly the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; right way.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Trap at runtime?  How so?  Generalized existentials should still be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; type-safe.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There are two choices when you erase static type relationships:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1. Acheive type-safety by trapping at runtime<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; FloatingPoint(3.0 as Float) + FloatingPoint(3.0 as Double) // trap<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2. Don&#39;t expose protocol requirements that involve these relationships,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; which would prevent the code above from compiling and prevent<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; FloatingPoint from conforming to itself.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Or are you talking about the hypothetical types / behaviors people<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; think they want when they don’t fully understand what is happening...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t know what you mean here.  I think generalized existentials will<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; be nice to have, but I think most people will want them to do something<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; they can&#39;t possibly do.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Exactly.  What I meant is that people think they want that expression<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to compile because they don’t understand that the only thing it can do<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; is trap.  I said “hypothetical” because producing a compile time error<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; rather than a runtime trap is the only sane thing to do.  Your comment<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; surprised me because I can’t imagine we would move forward in Swift<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; with the approach of trapping.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I would very much like to be able to create instances of “Collection<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; where Element == Int” so we can throw away the wrappers in the stdlib.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That will require some type mismatches to be caught at runtime via<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; trapping.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; For invalid index because the existential accepts a type erased index?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Exactly.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; How do you decide where to draw the line here?  It feels like a very<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; slippery slope for a language where safety is a stated priority to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; start adopting a strategy of runtime trapping for something as<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; fundamental as how you expose members on an existential.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If you don&#39;t do this, the alternative is that “Collection where Element<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; == Int” does not conform to Collection.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This isn’t directly related to having self or associated type<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; requirements.  It is true of all existentials.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; That is just an implementation limitation today, IIUC.  What I&#39;m talking<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; about here would make it impossible for some to do that.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If it is just an implementation limitation I am happy to hear that.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If that changes for simple existentials and generalized existentials<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; expose all members (as in the latest draft of the proposal) maybe it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; will be possible for all existentials to conform to their protocol.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Not without introducing runtime traps.  See my “subscript function”<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; example.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That&#39;s weird and not very<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; useful.  You could expose all the methods that were on protocol<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; extensions of Collection on this existential, unless they used<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; associated types other than the element type.  But you couldn&#39;t pass the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; existential to a generic function like<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func scrambled&lt;C: Collection&gt;(_ c: C) -&gt; [C.Element]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; IMO you should *have* to introduce unsafe behavior like that manually.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Collection where Element == Int &amp; Index == *<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I didn’t mean directly through the type of the existential.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; My question is, why not?  That is still explicit.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It’s not explicit in the sense that nobody wrote `fatalError` or<br>&gt;&gt;&gt;&gt;&gt;&gt; similar in their code.  It’s too easy to write something like that<br>&gt;&gt;&gt;&gt;&gt;&gt; without realizing that it introduces the possibility of a crash.  If<br>&gt;&gt;&gt;&gt;&gt;&gt; we adopt syntax like that to introduce an existential that introduces<br>&gt;&gt;&gt;&gt;&gt;&gt; traps we should at least require members that can be trap to be<br>&gt;&gt;&gt;&gt;&gt;&gt; invoked using a `!` suffix or something like that to make it clear to<br>&gt;&gt;&gt;&gt;&gt;&gt; users that a trap will happen if they are not extremely careful when<br>&gt;&gt;&gt;&gt;&gt;&gt; using that member.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; More generally though, I don’t want the rules of the language to be<br>&gt;&gt;&gt;&gt;&gt;&gt; written in a way that causes the compiler to synthesize traps in such<br>&gt;&gt;&gt;&gt;&gt;&gt; a general way.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The existential should not introduce a precondition that isn’t already<br>&gt;&gt;&gt;&gt;&gt;&gt; present in the semantics of the protocol itself.  If the semantics of<br>&gt;&gt;&gt;&gt;&gt;&gt; the protocol do not place preconditions on arguments beyond their type<br>&gt;&gt;&gt;&gt;&gt;&gt; (such as “must be a valid index into this specific instance”) the<br>&gt;&gt;&gt;&gt;&gt;&gt; compiler should not allow the existential to conform if a trap is<br>&gt;&gt;&gt;&gt;&gt;&gt; required in some circumstances.  That is a new precondition and<br>&gt;&gt;&gt;&gt;&gt;&gt; therefore the existential does not actually fulfill the requirements<br>&gt;&gt;&gt;&gt;&gt;&gt; of the protocol.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I could *maybe* live with a solution where protocol requirements are<br>&gt;&gt;&gt;&gt;&gt;&gt; marked as trapping, etc depending on the specific argument received at<br>&gt;&gt;&gt;&gt;&gt;&gt; runtime.  This is a total straw man syntax, but maybe `IndexableBase`<br>&gt;&gt;&gt;&gt;&gt;&gt; would declare the subscript `@trapping` (probably something different<br>&gt;&gt;&gt;&gt;&gt;&gt; but I hope this communicates the idea).  This alerts users to the fact<br>&gt;&gt;&gt;&gt;&gt;&gt; that they need to be extra careful - not any value of `Self.Index` is<br>&gt;&gt;&gt;&gt;&gt;&gt; valid and you can get a crash if you’re not careful.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Having this semantic explicit in the definition of the protocol opens<br>&gt;&gt;&gt;&gt;&gt;&gt; the door to maybe considering an existential synthesized by the<br>&gt;&gt;&gt;&gt;&gt;&gt; compiler that traps because it doesn’t introduce a new precondition<br>&gt;&gt;&gt;&gt;&gt;&gt; that wasn’t already present in the protocol.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I would want to give consideration to specific details of a proposal<br>&gt;&gt;&gt;&gt;&gt;&gt; along these lines before deciding how I feel about it, but I have a<br>&gt;&gt;&gt;&gt;&gt;&gt; more open mind to this approach than introducing traps not present in<br>&gt;&gt;&gt;&gt;&gt;&gt; the preconditions of the protocol.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; /// You can subscript a collection with any valid index other than the<br>&gt;&gt;&gt;&gt;&gt;&gt; /// collection&#39;s end index. The end index refers to the position one past<br>&gt;&gt;&gt;&gt;&gt;&gt; /// the last element of a collection, so it doesn&#39;t correspond with an<br>&gt;&gt;&gt;&gt;&gt;&gt; /// element.<br>&gt;&gt;&gt;&gt;&gt;&gt; ///<br>&gt;&gt;&gt;&gt;&gt;&gt; /// - Parameter position: The position of the element to access. `position`<br>&gt;&gt;&gt;&gt;&gt;&gt; ///   must be a valid index of the collection that is not equal to the<br>&gt;&gt;&gt;&gt;&gt;&gt; ///   `endIndex` property.<br>&gt;&gt;&gt;&gt;&gt;&gt; @trapping public subscript(position: Self.Index) -&gt; Self._Element { get }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; One obvious mechanism for introducing unsafe behavior is to write<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; manual type erasure wrappers like we do today.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Another possibility would be to allow extending the existential type<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; (not the protocol).  This would allow you to write overloads on the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Collection existential that takes some kind of type erased index if<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that is what you want and either trap if you receive an invalid index<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; or better (IMO) return an `Element?`.  I’m not sure how extensions on<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; existentials might be implemented, but this is an example of the kind<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of operation you might want available on it that you wouldn’t want<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; available on all Collection types.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Collection indices are already something that isn’t fully statically<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; safe so I understand why you might want to allow this.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; By the same measure, so are Ints :-)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The fact that a type&#39;s methods have preconditions does *not* make it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; “statically unsafe.”<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That depends on what you mean by safe.  Sure, those methods aren’t<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; going corrupt memory, but they *are* going to explicitly and<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; intentionally crash for some inputs.  That doesn’t qualify as “fully<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; safe” IMO.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Please pick a term other than “unsafe” here; it&#39;s not unsafe in the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; sense we mean the word in Swift.  It&#39;s safe in exactly the same way that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; array indexes and integers are.  When you violate a precondition, it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; traps.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I am happy to use any word you like here.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Can you clarify what you mean by the word safe in Swift?  It doesn’t<br>&gt;&gt;&gt;&gt;&gt;&gt; appear to be limited to memory safety in the public about page<br>&gt;&gt;&gt;&gt;&gt;&gt; https://swift.org/about/ &lt;https://swift.org/about/&gt; &lt;https://swift.org/about/ &lt;https://swift.org/about/&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I mean memory- and type-safe.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Safe. The most obvious way to write code should also behave in a safe<br>&gt;&gt;&gt;&gt;&gt;&gt; manner. Undefined behavior is the enemy of safety, and developer<br>&gt;&gt;&gt;&gt;&gt;&gt; mistakes should be caught before software is in production. Opting for<br>&gt;&gt;&gt;&gt;&gt;&gt; safety sometimes means Swift will feel strict, but we believe that<br>&gt;&gt;&gt;&gt;&gt;&gt; clarity saves time in the long run.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Safety<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Swift was designed from the outset to be safer than C-based languages,<br>&gt;&gt;&gt;&gt;&gt;&gt; and eliminates entire classes of unsafe code. Variables are always<br>&gt;&gt;&gt;&gt;&gt;&gt; initialized before use, arrays and integers are checked for overflow,<br>&gt;&gt;&gt;&gt;&gt;&gt; and memory is managed automatically. Syntax is tuned to make it easy<br>&gt;&gt;&gt;&gt;&gt;&gt; to define your intent — for example, simple three-character keywords<br>&gt;&gt;&gt;&gt;&gt;&gt; define a variable (var) or constant (let).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Another safety feature is that by default Swift objects can never be<br>&gt;&gt;&gt;&gt;&gt;&gt; nil, and trying to make or use a nil object will results in a<br>&gt;&gt;&gt;&gt;&gt;&gt; compile-time error. This makes writing code much cleaner and safer,<br>&gt;&gt;&gt;&gt;&gt;&gt; and prevents a common cause of runtime crashes. However, there are<br>&gt;&gt;&gt;&gt;&gt;&gt; cases where nil is appropriate, and for these situations Swift has an<br>&gt;&gt;&gt;&gt;&gt;&gt; innovative feature known as optionals. An optional may contain nil,<br>&gt;&gt;&gt;&gt;&gt;&gt; but Swift syntax forces you to safely deal with it using ? to indicate<br>&gt;&gt;&gt;&gt;&gt;&gt; to the compiler you understand the behavior and will handle it safely.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This positioning statement makes it appear as if preventing common<br>&gt;&gt;&gt;&gt;&gt;&gt; causes of crashes falls within the meaning of safe that Swift is<br>&gt;&gt;&gt;&gt;&gt;&gt; using.  Having existentials introduce new preconditions and traps when<br>&gt;&gt;&gt;&gt;&gt;&gt; they are not met does not seem aligned with that goal IMO.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Static typing “increases safety,” in the casual sense.  That doesn&#39;t<br>&gt;&gt;&gt;&gt;&gt; mean that an operation that traps on a failed precondition check is<br>&gt;&gt;&gt;&gt;&gt; “unsafe.”<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The user doesn&#39;t do anything “manual” to introduce that trapping<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; behavior for integers.  Preconditions are a natural part of most types.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The user doesn’t, but isn’t the overflow trap implemented in the<br>&gt;&gt;&gt;&gt;&gt;&gt; standard library?  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Whether it is or is not is an implementation detail.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Regardless, this is a specific case that has been given explicit<br>&gt;&gt;&gt;&gt;&gt;&gt; design attention by humans.  The precondition is designed, not<br>&gt;&gt;&gt;&gt;&gt;&gt; introduced by compiler rules that haven’t considered the specific case<br>&gt;&gt;&gt;&gt;&gt;&gt; in question.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; But I don’t think having the language&#39;s existentials do this<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; automatically is the right approach.  Maybe there is another<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; approach that could be used in targeted use cases where the less<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; safe behavior makes sense and is carefully designed.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Whether it makes sense or not really depends on the use-cases.  There&#39;s<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; little point in generalizing existentials if the result isn&#39;t very useful.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Usefulness depends on your perspective.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Of course.  As I&#39;ve said, let&#39;s look at the use cases.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Agree.  We can consider those in depth when the time comes to ramp up<br>&gt;&gt;&gt;&gt;&gt;&gt; discussion of Austin’s proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I have run into several scenarios where they would be very useful<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; without needing to be prone to crashes when used incorrectly.  One<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; obvious basic use case is storing things in a heterogenous collection<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; where you bind .<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; bind what?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Sorry, I must have gotten distracted and not finished that paragraph.<br>&gt;&gt;&gt;&gt;&gt;&gt; I meant to say bind the associated types that are necessary for your<br>&gt;&gt;&gt;&gt;&gt;&gt; use case.  Sometimes you bind *all* of the associated types to<br>&gt;&gt;&gt;&gt;&gt;&gt; concrete types and the protocol has no `Self` requirements.  In that<br>&gt;&gt;&gt;&gt;&gt;&gt; case there is no trouble at all in conforming the type-erased<br>&gt;&gt;&gt;&gt;&gt;&gt; “existential&quot; to the protocol itself.  Austin’s proposal would<br>&gt;&gt;&gt;&gt;&gt;&gt; eliminate the need to manually write these “existentials” manually.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The way to find out is to take a look at the examples we currently have<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of protocols with associated types or Self requirements and consider<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; what you&#39;d be able to do with their existentials if type relationships<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; couldn&#39;t be erased.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; We have known use-cases, currently emulated in the standard library, for<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; existentials with erased type relationships.  *If* these represent the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; predominant use cases for something like generalized existentials, it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; seems to me that the language feature should support that.  Note: I have<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; not seen anyone build an emulation of the other kind of generalized<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; existential.  My theory: there&#39;s a good reason for that :-).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; AFAIK (and I could be wrong) the only rules in the language that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; require the compiler to synthesize a trap except using a nil IUO, `!`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on a nil Optional, and an invalid `as` cast .  These are all<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; syntactically explicit unsafe / dangerous operations.  All other traps<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; are in the standard library (array index, overflow, etc).  Most<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; important about all of these cases is that they have received direct<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; human consideration.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; There is no distinction in the user model between what might be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; synthesized by the language and what appears on standard library types.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Maybe I shouldn’t have made that distinction.  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The point I am trying to emphasize is that each of these are special<br>&gt;&gt;&gt;&gt;&gt;&gt; cases that have received direct human consideration.  The potential<br>&gt;&gt;&gt;&gt;&gt;&gt; for a trap is not introduced by language rules that apply to<br>&gt;&gt;&gt;&gt;&gt;&gt; user-defined constructs in without consideration of the specific<br>&gt;&gt;&gt;&gt;&gt;&gt; details of that construct.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Introducing a language (not library) mechanism that exposes members on<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; generalized existentials in a way that relies on runtime traps for<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; type safety feels to me like a pretty dramatic turn agains the stated<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; priority of safety.  It will mean you must understand exactly what is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; going on and be extremely careful to use generalized existentials<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; without causing crashes.  This will either make Swift code much more<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; crashy or will scare people away from using generalized existentials<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; (and maybe both).  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t accept either of those statements without seeing some analysis<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; of the use-cases.  For example, I don&#39;t believe that AnyCollection et al<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; are particularly crash-prone.  The likelihood that you&#39;ll use the wrong<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; index type with a collection is very, very low.  I&#39;m less certain of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; what happens with Self requirements in real cases.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; But again, I believe this is an exceptional case as the precondition<br>&gt;&gt;&gt;&gt;&gt;&gt; is explicitly stated in the semantics of the protocol.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; IIUC, it has been cited by Doug as the exemplar of the<br>&gt;&gt;&gt;&gt;&gt; predominantly-requested case by a 10:1 ratio!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In terms of forming the existential, storing it in variables,<br>&gt;&gt;&gt;&gt; accepting arguments of that type, etc yes.  I don’t know how many of<br>&gt;&gt;&gt;&gt; those requests expect it to conform to the protocol and expect to be<br>&gt;&gt;&gt;&gt; able to use it in generic code constrained to the protocol.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; IMO the burden of proof should be on the side that proposes a<br>&gt;&gt;&gt;&gt;&gt;&gt; mechanism to introduce traps, not the side that proposes avoiding<br>&gt;&gt;&gt;&gt;&gt;&gt; them.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If you really want to make this about sides and burdens, the burden of<br>&gt;&gt;&gt;&gt;&gt; proof always rests with the side proposing to extend the language.  We<br>&gt;&gt;&gt;&gt;&gt; shouldn&#39;t be making changes without understanding how they will play out<br>&gt;&gt;&gt;&gt;&gt; in real use-cases.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I agree with this.  But if we are discussing two different options for<br>&gt;&gt;&gt;&gt; extending the language I think the option that doesn’t introduce<br>&gt;&gt;&gt;&gt; crashes should be preferred without pretty compelling reasons to<br>&gt;&gt;&gt;&gt; choose the option that can introduce crashes.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Neither of those outcomes is good.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Collection indices are a somewhat special case as there is already a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; strong precondition that people are familiar with because it would be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; too costly to performance and arguably too annoying to deal with an<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Optional result in every array lookup.  IMO that is why the library is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; able to get away with it in the current type erased AnyCollection.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; But this is not a good model for exposing any members on an<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; existential that do not already have a strong precondition that causes<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; a trap when violated.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think a big reason why you maybe haven’t seen a lot of examples of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; people writing type erased “existentials&quot; is because it is a huge pain<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; in the neck to write this stuff manually today.  People may be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; designing around the need for them.  I haven’t seen a huge sampling of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; type erased “existentials&quot; other people are writing but I haven’t<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; written any that introduce a trap like this.  The only traps are in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the “abstract&quot; base class whose methods will never be called (and<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wouldn’t even be implemented if they could be marked abstract).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; What specific things do you think we need to be able to do that rely<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on the compiler synthesizing a trap in the way it exposes the members<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of the existential?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t know.  I&#39;m saying, I don&#39;t think we understand the use-cases<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; well enough to make a determination.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; That’s fair.  I agree that use cases should be carefully considered.  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Here are a few examples from Austin’s proposal that safely use<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; existential collections.  I don’t understand why you think this<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; approach is insufficient.  Maybe you could supply a concrete example<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of a use case that can’t be written with the mechanism in Austin’s<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure&gt; &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure&gt;&gt; &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure&gt;&lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let a : Any&lt;Collection&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // A variable whose type is the Index associated type of the underlying<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // concrete type of &#39;a&#39;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let theIndex : a.Index = ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // A variable whose type is the Element associated type of the underlying<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // concrete type of &#39;a&#39;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let theElement : a.Element = ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Given a mutable collection, swap its first and last items.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Not a generic function. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func swapFirstAndLast(inout collection: Any&lt;BidirectionalMutableCollection&gt;) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // firstIndex and lastIndex both have type &quot;collection.Index&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; guard let firstIndex = collection.startIndex,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     lastIndex = collection.endIndex?.predecessor(collection) where lastIndex != firstIndex else {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         print(&quot;Nothing to do&quot;)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         return<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // oldFirstItem has type &quot;collection.Element&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let oldFirstItem = collection[firstIndex]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; collection[firstIndex] = collection[lastIndex]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; collection[lastIndex] = oldFirstItem<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; var a : Any&lt;BidirectionalMutableCollection where .Element == String&gt; = ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let input = &quot;West Meoley&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Not actually necessary, since the compiler knows &quot;a.Element&quot; is String.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // A fully constrained anonymous associated type is synonymous with the concrete<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // type it&#39;s forced to take on, and the two are interchangeable.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // However, &#39;as&#39; casting is still available if desired.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let anonymousInput = input as a.Element<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; a[a.startIndex] = anonymousInput<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // as mentioned, this also works:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; a[a.startIndex] = input<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // If the collection allows it, set the first element in the collection to a given string.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func setFirstElementIn(inout collection: Any&lt;Collection&gt; toString string: String) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; if let element = string as? collection.Element {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     // At this point, &#39;element&#39; is of type &quot;collection.Element&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     collection[collection.startIndex] = element<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Neither of these look like they actually make *use* of the fact that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; there&#39;s type erasure involved (and therefore should probably be written<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; as generics?).  The interesting cases with Any&lt;Collection...&gt;, for the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; purposes of this discussion, arise when you have multiple instances of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; the same existential type that wrap different concrete types.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; One use case I have found is to work around the lack of higher-kinder<br>&gt;&gt;&gt;&gt;&gt;&gt; types.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Really, now: a use-case for feature A that is a workaround for the lack<br>&gt;&gt;&gt;&gt;&gt; of feature B hardly justifies adding feature A!  We do want to add<br>&gt;&gt;&gt;&gt;&gt; higher-kinded types eventually.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Good to know.  I thought higher-kinder types were on the “maybe if<br>&gt;&gt;&gt;&gt; someone shows a compelling enough use case” list.  AFAIK this is the<br>&gt;&gt;&gt;&gt; first time a member of the core team has stated the intent to add<br>&gt;&gt;&gt;&gt; them.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Well, please don&#39;t take this as a formal statement on behalf of the<br>&gt;&gt;&gt; team.  IIUC, the team is generally interested in having this feature.<br>&gt;&gt; <br>&gt;&gt; Of course not.  The only official plan of record for Swift is approved<br>&gt;&gt; proposals.  But it’s always interesting to know the opinions of the<br>&gt;&gt; core team about potential features.  Previously my impression had been<br>&gt;&gt; that the general leaning was towards skepticism that the practical<br>&gt;&gt; benefits of HKT would pay for the complexity.  <br>&gt; <br>&gt; That&#39;s certainly a valid question.  I have been very vocally skeptical<br>&gt; that HKTs like Monad belong in the standard library, but I am not<br>&gt; opposed to having the language feature if it supports important use<br>&gt; cases.<br></p><p>That makes sense.  Language support is where we get expressive power.  I think you are right to challenge placing specific protocols in the standard library.  <br></p><p>In the case of Monad in particular, Swift has a much different design direction and feature set than languages where it plays a central role.  I have an open mind on this but the case for putting it in the standard library definitely isn&#39;t obvious.  Concrete, practical and useful examples of generic code that would be written in terms of Monad are required.  And they should make it clear why this is a good approach in Swift.  It is not hard to show this for concrete monads, but pretty difficult to do so for generic code that only depends on the Monad abstraction.<br></p><p>I haven&#39;t come across any good examples yet so I share your skepticism on this until I see them.<br></p><p>&gt; <br>&gt; -- <br>&gt; Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June 11, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jun 11, 2016, at 3:03 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt;&gt; On Jun 10, 2016, at 7:46 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Thu Jun 09 2016, Matthew Johnson &lt;swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 9, 2016, at 3:05 PM, Dave Abrahams &lt;dabrahams-2kanFRK1NckAvxtiuMwx3w at public.gmane.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Thu Jun 09 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 9, 2016, at 11:42 AM, Dave Abrahams &lt;dabrahams-2kanFRK1NckAvxtiuMwx3w at public.gmane.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; on Thu Jun 09 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 9, 2016, at 9:55 AM, Dave Abrahams<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;dabrahams at apple.com<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:dabrahams at apple.com&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Wed Jun 08 2016, Matthew Johnson &lt;matthew-AT-anandabits.com<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 8, 2016, at 1:33 PM, Dave Abrahams<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;dabrahams at apple.com<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:dabrahams at apple.com&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 9:15 PM, Dave Abrahams<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;dabrahams at apple.com<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:dabrahams at apple.com&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 4:13 PM, Dave Abrahams via<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution &lt;swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; , but haven&#39;t realized<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that if you step around the type relationships encoded in Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; requirements and associated types you end up with types that appear to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; interoperate but in fact trap at runtime unless used in exactly the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; right way.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Trap at runtime?  How so?  Generalized existentials should still be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; type-safe.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There are two choices when you erase static type relationships:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1. Acheive type-safety by trapping at runtime<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; FloatingPoint(3.0 as Float) + FloatingPoint(3.0 as Double) // trap<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2. Don&#39;t expose protocol requirements that involve these relationships,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; which would prevent the code above from compiling and prevent<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; FloatingPoint from conforming to itself.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Or are you talking about the hypothetical types / behaviors people<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; think they want when they don’t fully understand what is happening...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t know what you mean here.  I think generalized existentials will<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; be nice to have, but I think most people will want them to do something<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; they can&#39;t possibly do.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Exactly.  What I meant is that people think they want that expression<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to compile because they don’t understand that the only thing it can do<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; is trap.  I said “hypothetical” because producing a compile time error<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; rather than a runtime trap is the only sane thing to do.  Your comment<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; surprised me because I can’t imagine we would move forward in Swift<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; with the approach of trapping.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I would very much like to be able to create instances of “Collection<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; where Element == Int” so we can throw away the wrappers in the stdlib.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That will require some type mismatches to be caught at runtime via<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; trapping.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; For invalid index because the existential accepts a type erased index?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Exactly.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; How do you decide where to draw the line here?  It feels like a very<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; slippery slope for a language where safety is a stated priority to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; start adopting a strategy of runtime trapping for something as<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; fundamental as how you expose members on an existential.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If you don&#39;t do this, the alternative is that “Collection where Element<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; == Int” does not conform to Collection.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This isn’t directly related to having self or associated type<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; requirements.  It is true of all existentials.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That is just an implementation limitation today, IIUC.  What I&#39;m talking<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; about here would make it impossible for some to do that.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; If it is just an implementation limitation I am happy to hear that.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If that changes for simple existentials and generalized existentials<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; expose all members (as in the latest draft of the proposal) maybe it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; will be possible for all existentials to conform to their protocol.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Not without introducing runtime traps.  See my “subscript function”<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; example.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That&#39;s weird and not very<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; useful.  You could expose all the methods that were on protocol<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; extensions of Collection on this existential, unless they used<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; associated types other than the element type.  But you couldn&#39;t pass the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; existential to a generic function like<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func scrambled&lt;C: Collection&gt;(_ c: C) -&gt; [C.Element]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; IMO you should *have* to introduce unsafe behavior like that manually.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Collection where Element == Int &amp; Index == *<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I didn’t mean directly through the type of the existential.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; My question is, why not?  That is still explicit.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It’s not explicit in the sense that nobody wrote `fatalError` or<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; similar in their code.  It’s too easy to write something like that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; without realizing that it introduces the possibility of a crash.  If<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; we adopt syntax like that to introduce an existential that introduces<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; traps we should at least require members that can be trap to be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; invoked using a `!` suffix or something like that to make it clear to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; users that a trap will happen if they are not extremely careful when<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; using that member.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; More generally though, I don’t want the rules of the language to be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; written in a way that causes the compiler to synthesize traps in such<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; a general way.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The existential should not introduce a precondition that isn’t already<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; present in the semantics of the protocol itself.  If the semantics of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; the protocol do not place preconditions on arguments beyond their type<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; (such as “must be a valid index into this specific instance”) the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; compiler should not allow the existential to conform if a trap is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; required in some circumstances.  That is a new precondition and<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; therefore the existential does not actually fulfill the requirements<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; of the protocol.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I could *maybe* live with a solution where protocol requirements are<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; marked as trapping, etc depending on the specific argument received at<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; runtime.  This is a total straw man syntax, but maybe `IndexableBase`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; would declare the subscript `@trapping` (probably something different<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; but I hope this communicates the idea).  This alerts users to the fact<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; that they need to be extra careful - not any value of `Self.Index` is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; valid and you can get a crash if you’re not careful.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Having this semantic explicit in the definition of the protocol opens<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; the door to maybe considering an existential synthesized by the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; compiler that traps because it doesn’t introduce a new precondition<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; that wasn’t already present in the protocol.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I would want to give consideration to specific details of a proposal<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; along these lines before deciding how I feel about it, but I have a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; more open mind to this approach than introducing traps not present in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; the preconditions of the protocol.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; /// You can subscript a collection with any valid index other than the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; /// collection&#39;s end index. The end index refers to the position one past<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; /// the last element of a collection, so it doesn&#39;t correspond with an<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; /// element.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ///<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; /// - Parameter position: The position of the element to access. `position`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ///   must be a valid index of the collection that is not equal to the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ///   `endIndex` property.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; @trapping public subscript(position: Self.Index) -&gt; Self._Element { get }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; One obvious mechanism for introducing unsafe behavior is to write<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; manual type erasure wrappers like we do today.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Another possibility would be to allow extending the existential type<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; (not the protocol).  This would allow you to write overloads on the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Collection existential that takes some kind of type erased index if<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that is what you want and either trap if you receive an invalid index<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; or better (IMO) return an `Element?`.  I’m not sure how extensions on<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; existentials might be implemented, but this is an example of the kind<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of operation you might want available on it that you wouldn’t want<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; available on all Collection types.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Collection indices are already something that isn’t fully statically<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; safe so I understand why you might want to allow this.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; By the same measure, so are Ints :-)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The fact that a type&#39;s methods have preconditions does *not* make it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; “statically unsafe.”<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That depends on what you mean by safe.  Sure, those methods aren’t<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; going corrupt memory, but they *are* going to explicitly and<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; intentionally crash for some inputs.  That doesn’t qualify as “fully<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; safe” IMO.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Please pick a term other than “unsafe” here; it&#39;s not unsafe in the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; sense we mean the word in Swift.  It&#39;s safe in exactly the same way that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; array indexes and integers are.  When you violate a precondition, it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; traps.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I am happy to use any word you like here.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Can you clarify what you mean by the word safe in Swift?  It doesn’t<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; appear to be limited to memory safety in the public about page<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://swift.org/about/ &lt;https://swift.org/about/&gt; &lt;https://swift.org/about/ &lt;https://swift.org/about/&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I mean memory- and type-safe.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Safe. The most obvious way to write code should also behave in a safe<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; manner. Undefined behavior is the enemy of safety, and developer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; mistakes should be caught before software is in production. Opting for<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; safety sometimes means Swift will feel strict, but we believe that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; clarity saves time in the long run.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Safety<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift was designed from the outset to be safer than C-based languages,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; and eliminates entire classes of unsafe code. Variables are always<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; initialized before use, arrays and integers are checked for overflow,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; and memory is managed automatically. Syntax is tuned to make it easy<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; to define your intent — for example, simple three-character keywords<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; define a variable (var) or constant (let).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Another safety feature is that by default Swift objects can never be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; nil, and trying to make or use a nil object will results in a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; compile-time error. This makes writing code much cleaner and safer,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; and prevents a common cause of runtime crashes. However, there are<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; cases where nil is appropriate, and for these situations Swift has an<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; innovative feature known as optionals. An optional may contain nil,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; but Swift syntax forces you to safely deal with it using ? to indicate<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; to the compiler you understand the behavior and will handle it safely.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This positioning statement makes it appear as if preventing common<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; causes of crashes falls within the meaning of safe that Swift is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; using.  Having existentials introduce new preconditions and traps when<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; they are not met does not seem aligned with that goal IMO.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Static typing “increases safety,” in the casual sense.  That doesn&#39;t<br>&gt;&gt;&gt;&gt;&gt;&gt; mean that an operation that traps on a failed precondition check is<br>&gt;&gt;&gt;&gt;&gt;&gt; “unsafe.”<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The user doesn&#39;t do anything “manual” to introduce that trapping<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; behavior for integers.  Preconditions are a natural part of most types.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The user doesn’t, but isn’t the overflow trap implemented in the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; standard library?  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Whether it is or is not is an implementation detail.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Regardless, this is a specific case that has been given explicit<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; design attention by humans.  The precondition is designed, not<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; introduced by compiler rules that haven’t considered the specific case<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; in question.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; But I don’t think having the language&#39;s existentials do this<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; automatically is the right approach.  Maybe there is another<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; approach that could be used in targeted use cases where the less<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; safe behavior makes sense and is carefully designed.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Whether it makes sense or not really depends on the use-cases.  There&#39;s<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; little point in generalizing existentials if the result isn&#39;t very useful.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Usefulness depends on your perspective.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Of course.  As I&#39;ve said, let&#39;s look at the use cases.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Agree.  We can consider those in depth when the time comes to ramp up<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; discussion of Austin’s proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I have run into several scenarios where they would be very useful<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; without needing to be prone to crashes when used incorrectly.  One<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; obvious basic use case is storing things in a heterogenous collection<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; where you bind .<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; bind what?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sorry, I must have gotten distracted and not finished that paragraph.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I meant to say bind the associated types that are necessary for your<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; use case.  Sometimes you bind *all* of the associated types to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; concrete types and the protocol has no `Self` requirements.  In that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; case there is no trouble at all in conforming the type-erased<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; “existential&quot; to the protocol itself.  Austin’s proposal would<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; eliminate the need to manually write these “existentials” manually.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The way to find out is to take a look at the examples we currently have<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of protocols with associated types or Self requirements and consider<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; what you&#39;d be able to do with their existentials if type relationships<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; couldn&#39;t be erased.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; We have known use-cases, currently emulated in the standard library, for<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; existentials with erased type relationships.  *If* these represent the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; predominant use cases for something like generalized existentials, it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; seems to me that the language feature should support that.  Note: I have<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; not seen anyone build an emulation of the other kind of generalized<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; existential.  My theory: there&#39;s a good reason for that :-).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; AFAIK (and I could be wrong) the only rules in the language that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; require the compiler to synthesize a trap except using a nil IUO, `!`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on a nil Optional, and an invalid `as` cast .  These are all<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; syntactically explicit unsafe / dangerous operations.  All other traps<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; are in the standard library (array index, overflow, etc).  Most<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; important about all of these cases is that they have received direct<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; human consideration.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There is no distinction in the user model between what might be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; synthesized by the language and what appears on standard library types.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Maybe I shouldn’t have made that distinction.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The point I am trying to emphasize is that each of these are special<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; cases that have received direct human consideration.  The potential<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; for a trap is not introduced by language rules that apply to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; user-defined constructs in without consideration of the specific<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; details of that construct.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Introducing a language (not library) mechanism that exposes members on<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; generalized existentials in a way that relies on runtime traps for<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; type safety feels to me like a pretty dramatic turn agains the stated<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; priority of safety.  It will mean you must understand exactly what is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; going on and be extremely careful to use generalized existentials<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; without causing crashes.  This will either make Swift code much more<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; crashy or will scare people away from using generalized existentials<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; (and maybe both).  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t accept either of those statements without seeing some analysis<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of the use-cases.  For example, I don&#39;t believe that AnyCollection et al<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; are particularly crash-prone.  The likelihood that you&#39;ll use the wrong<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; index type with a collection is very, very low.  I&#39;m less certain of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; what happens with Self requirements in real cases.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; But again, I believe this is an exceptional case as the precondition<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; is explicitly stated in the semantics of the protocol.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; IIUC, it has been cited by Doug as the exemplar of the<br>&gt;&gt;&gt;&gt;&gt;&gt; predominantly-requested case by a 10:1 ratio!<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In terms of forming the existential, storing it in variables,<br>&gt;&gt;&gt;&gt;&gt; accepting arguments of that type, etc yes.  I don’t know how many of<br>&gt;&gt;&gt;&gt;&gt; those requests expect it to conform to the protocol and expect to be<br>&gt;&gt;&gt;&gt;&gt; able to use it in generic code constrained to the protocol.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; IMO the burden of proof should be on the side that proposes a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; mechanism to introduce traps, not the side that proposes avoiding<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; them.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If you really want to make this about sides and burdens, the burden of<br>&gt;&gt;&gt;&gt;&gt;&gt; proof always rests with the side proposing to extend the language.  We<br>&gt;&gt;&gt;&gt;&gt;&gt; shouldn&#39;t be making changes without understanding how they will play out<br>&gt;&gt;&gt;&gt;&gt;&gt; in real use-cases.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I agree with this.  But if we are discussing two different options for<br>&gt;&gt;&gt;&gt;&gt; extending the language I think the option that doesn’t introduce<br>&gt;&gt;&gt;&gt;&gt; crashes should be preferred without pretty compelling reasons to<br>&gt;&gt;&gt;&gt;&gt; choose the option that can introduce crashes.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Neither of those outcomes is good.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Collection indices are a somewhat special case as there is already a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; strong precondition that people are familiar with because it would be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; too costly to performance and arguably too annoying to deal with an<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Optional result in every array lookup.  IMO that is why the library is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; able to get away with it in the current type erased AnyCollection.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; But this is not a good model for exposing any members on an<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; existential that do not already have a strong precondition that causes<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; a trap when violated.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think a big reason why you maybe haven’t seen a lot of examples of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; people writing type erased “existentials&quot; is because it is a huge pain<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; in the neck to write this stuff manually today.  People may be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; designing around the need for them.  I haven’t seen a huge sampling of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; type erased “existentials&quot; other people are writing but I haven’t<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; written any that introduce a trap like this.  The only traps are in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the “abstract&quot; base class whose methods will never be called (and<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wouldn’t even be implemented if they could be marked abstract).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; What specific things do you think we need to be able to do that rely<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on the compiler synthesizing a trap in the way it exposes the members<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of the existential?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t know.  I&#39;m saying, I don&#39;t think we understand the use-cases<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; well enough to make a determination.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; That’s fair.  I agree that use cases should be carefully considered.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Here are a few examples from Austin’s proposal that safely use<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; existential collections.  I don’t understand why you think this<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; approach is insufficient.  Maybe you could supply a concrete example<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of a use case that can’t be written with the mechanism in Austin’s<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure&gt; &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure&gt;&gt; &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure&gt;&lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let a : Any&lt;Collection&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // A variable whose type is the Index associated type of the underlying<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // concrete type of &#39;a&#39;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let theIndex : a.Index = ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // A variable whose type is the Element associated type of the underlying<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // concrete type of &#39;a&#39;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let theElement : a.Element = ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Given a mutable collection, swap its first and last items.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Not a generic function. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func swapFirstAndLast(inout collection: Any&lt;BidirectionalMutableCollection&gt;) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // firstIndex and lastIndex both have type &quot;collection.Index&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; guard let firstIndex = collection.startIndex,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    lastIndex = collection.endIndex?.predecessor(collection) where lastIndex != firstIndex else {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;        print(&quot;Nothing to do&quot;)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;        return<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // oldFirstItem has type &quot;collection.Element&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let oldFirstItem = collection[firstIndex]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; collection[firstIndex] = collection[lastIndex]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; collection[lastIndex] = oldFirstItem<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; var a : Any&lt;BidirectionalMutableCollection where .Element == String&gt; = ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let input = &quot;West Meoley&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Not actually necessary, since the compiler knows &quot;a.Element&quot; is String.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // A fully constrained anonymous associated type is synonymous with the concrete<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // type it&#39;s forced to take on, and the two are interchangeable.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // However, &#39;as&#39; casting is still available if desired.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let anonymousInput = input as a.Element<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; a[a.startIndex] = anonymousInput<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // as mentioned, this also works:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; a[a.startIndex] = input<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // If the collection allows it, set the first element in the collection to a given string.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func setFirstElementIn(inout collection: Any&lt;Collection&gt; toString string: String) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; if let element = string as? collection.Element {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    // At this point, &#39;element&#39; is of type &quot;collection.Element&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    collection[collection.startIndex] = element<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Neither of these look like they actually make *use* of the fact that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; there&#39;s type erasure involved (and therefore should probably be written<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; as generics?).  The interesting cases with Any&lt;Collection...&gt;, for the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; purposes of this discussion, arise when you have multiple instances of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the same existential type that wrap different concrete types.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; One use case I have found is to work around the lack of higher-kinder<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; types.  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Really, now: a use-case for feature A that is a workaround for the lack<br>&gt;&gt;&gt;&gt;&gt;&gt; of feature B hardly justifies adding feature A!  We do want to add<br>&gt;&gt;&gt;&gt;&gt;&gt; higher-kinded types eventually.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Good to know.  I thought higher-kinder types were on the “maybe if<br>&gt;&gt;&gt;&gt;&gt; someone shows a compelling enough use case” list.  AFAIK this is the<br>&gt;&gt;&gt;&gt;&gt; first time a member of the core team has stated the intent to add<br>&gt;&gt;&gt;&gt;&gt; them.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Well, please don&#39;t take this as a formal statement on behalf of the<br>&gt;&gt;&gt;&gt; team.  IIUC, the team is generally interested in having this feature.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Of course not.  The only official plan of record for Swift is approved<br>&gt;&gt;&gt; proposals.  But it’s always interesting to know the opinions of the<br>&gt;&gt;&gt; core team about potential features.  Previously my impression had been<br>&gt;&gt;&gt; that the general leaning was towards skepticism that the practical<br>&gt;&gt;&gt; benefits of HKT would pay for the complexity.  <br>&gt;&gt; <br>&gt;&gt; That&#39;s certainly a valid question.  I have been very vocally skeptical<br>&gt;&gt; that HKTs like Monad belong in the standard library, but I am not<br>&gt;&gt; opposed to having the language feature if it supports important use<br>&gt;&gt; cases.<br>&gt; <br>&gt; That makes sense.  Language support is where we get expressive power.  I think you are right to challenge placing specific protocols in the standard library.  <br>&gt; <br>&gt; In the case of Monad in particular, Swift has a much different design direction and feature set than languages where it plays a central role.  I have an open mind on this but the case for putting it in the standard library definitely isn&#39;t obvious.  Concrete, practical and useful examples of generic code that would be written in terms of Monad are required.  And they should make it clear why this is a good approach in Swift.  It is not hard to show this for concrete monads, but pretty difficult to do so for generic code that only depends on the Monad abstraction.<br>&gt; <br>&gt; I haven&#39;t come across any good examples yet so I share your skepticism on this until I see them.<br>&gt; <br></p><p>Before getting to monads in the std lib, it would be nice if the generics and existential system were powerfull and complementary enough that the stdlib would not have to contain so much generated code for collections. I am not saying that generated code should be eliminated, but it should be the result of a performance optimization choice, not the only way to do it.<br></p><p>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June 11, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt;&gt; <br>&gt;&gt; Of course not.  The only official plan of record for Swift is approved<br>&gt;&gt; proposals.  But it’s always interesting to know the opinions of the<br>&gt;&gt; core team about potential features.  Previously my impression had been<br>&gt;&gt; that the general leaning was towards skepticism that the practical<br>&gt;&gt; benefits of HKT would pay for the complexity.  <br>&gt; <br>&gt; That&#39;s certainly a valid question.  I have been very vocally skeptical<br>&gt; that HKTs like Monad belong in the standard library, but I am not<br>&gt; opposed to having the language feature if it supports important use<br>&gt; cases.<br></p><p>It is surprising to see people debating the place of monads in Swift when nobody seems to speak about the elephant in the middle of the room: the language has a real engineering defisciency if it is possible for people to think that there is no better way to use it than to do   &quot;we have around 50+ packages. This list grows very fast&quot; (http://docs.zewo.io - many more swift github projects are equally struggling to get the code organized).<br>At the moment the only thing preventing the situation from getting more out of hands is that the import mechanism currently gets in the way, but the only opinions I read so far all focussed on making it even easier to slap things together ala zewo rather than address the engineering issue.<br></p><p>&gt; <br>&gt; -- <br>&gt; Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June 11, 2016 at 11:00:00am</p></header><div class="content"><p>&gt;&gt; That&#39;s certainly a valid question.  I have been very vocally skeptical<br>&gt;&gt; that HKTs like Monad belong in the standard library, but I am not<br>&gt;&gt; opposed to having the language feature if it supports important use<br>&gt;&gt; cases.<br>&gt; <br>&gt; It is surprising to see people debating the place of monads in Swift when nobody seems to speak about the elephant in the middle of the room: the language has a real engineering defisciency if it is possible for people to think that there is no better way to use it than to do   &quot;we have around 50+ packages. This list grows very fast&quot; (http://docs.zewo.io - many more swift github projects are equally struggling to get the code organized).<br>&gt; At the moment the only thing preventing the situation from getting more out of hands is that the import mechanism currently gets in the way, but the only opinions I read so far all focussed on making it even easier to slap things together ala zewo rather than address the engineering issue.<br></p><p>It would be helpful if you could do two things:<br></p><p>1. Be clear about exactly what you think is wrong and, preferably, how you think we might be able to solve it, or at least what sorts of problems you want the solution to address. Reading this post, I&#39;m not sure what you find objectionable about this project containing 50 packages or what &quot;situation&quot; you think is getting out of hand. Even if you have a good point, you&#39;re not making it very well.<br></p><p>2. Post about your issue in a new thread rather than trying to derail something *entirely* unrelated to it. I&#39;m not sure exactly what your complaint is, but I gather it has something to do with package management, modules, or imports. None of these have anything to do with higher-kinded types, the type system, or (as far as I can tell) anything that has ever been discussed in this thread. The result is rather like interrupting a charity drive for the local children&#39;s hospital to tell people that actually, they really *ought* to be donating to your mosquito-net charity instead. Even if you&#39;re correct that your cause is more important, it&#39;s inappropriate, unwelcome, and frankly just rude.<br></p><p>In short: Please don&#39;t do this. It does not help your case.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June 11, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jun 11, 2016, at 8:46 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; That&#39;s certainly a valid question.  I have been very vocally skeptical<br>&gt;&gt;&gt; that HKTs like Monad belong in the standard library, but I am not<br>&gt;&gt;&gt; opposed to having the language feature if it supports important use<br>&gt;&gt;&gt; cases.<br>&gt;&gt; <br>&gt;&gt; It is surprising to see people debating the place of monads in Swift when nobody seems to speak about the elephant in the middle of the room: the language has a real engineering defisciency if it is possible for people to think that there is no better way to use it than to do   &quot;we have around 50+ packages. This list grows very fast&quot; (http://docs.zewo.io - many more swift github projects are equally struggling to get the code organized).<br>&gt;&gt; At the moment the only thing preventing the situation from getting more out of hands is that the import mechanism currently gets in the way, but the only opinions I read so far all focussed on making it even easier to slap things together ala zewo rather than address the engineering issue.<br>&gt; <br>&gt; It would be helpful if you could do two things:<br>&gt; <br>&gt; 1. Be clear about exactly what you think is wrong and, preferably, how you think we might be able to solve it, or at least what sorts of problems you want the solution to address. Reading this post, I&#39;m not sure what you find objectionable about this project containing 50 packages or what &quot;situation&quot; you think is getting out of hand. Even if you have a good point, you&#39;re not making it very well.<br></p><p>I am assuming that you have been doing professional software development for a long time, worked with 10s of developers in dozens of teams, using objc, swift, and many more languages. I think it is safe to assume you spent a great deal of time reading the compiler (and llvm&#39;s) source code since it became open source, and considering how regularly you refer to what others need or use, I also took for granted that you have read the code for a great deal of open-source projects in all sorts of languages. Having assumed this as your background, you might appreciate why I thought we might be able to skip of few steps.<br></p><p>&gt; <br>&gt; 2. Post about your issue in a new thread rather than trying to derail something *entirely* unrelated to it. I&#39;m not sure exactly what your complaint is, but I gather it has something to do with package management, modules, or imports. None of these have anything to do with higher-kinded types, the type system, or (as far as I can tell) anything that has ever been discussed in this thread. The result is rather like interrupting a charity drive for the local children&#39;s hospital to tell people that actually, they really *ought* to be donating to your mosquito-net charity instead. Even if you&#39;re correct that your cause is more important, it&#39;s inappropriate, unwelcome, and frankly just rude.<br></p><p>I can appreciate your view. And maybe you can equally appreciate how plain surreal parts of this thread and a few others might appear when put in perspective with some of what I, undoubtedly<br>wrongly, perceive as elephants in the room.<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
