<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1164c6dc99e3ea586eaaeb50289bd95c?s=50"></div><header><strong>Swift-Native Alternative to KVO</strong> from <string>Jared Sinclair</string> &lt;desk at jaredsinclair.com&gt;<p>January  1, 2016 at 08:00:00pm</p></header><div class="content"><p>The one-to-many observer pattern could really use a first-party, native Swift solution. The day-to-day practice of writing iOS / OS X applications needs it, and we end up falling back on antiquated APIs like KVO or NSNotificationCenter, or short-lived third-party libraries. This is an essential need that deserves a fresh approach.<br></p><p>What follows is a rough proposal for a Swift-native “KVO alternative”. <br></p><p><br>What Usage Would Look Like:<br></p><p>let tweet = Tweet(text: “Hi.”)<br>tweet.observables.isLiked.addObserver { (oldValue, newValue) -&gt; Void in<br>    // this is otherwise just a standard closure, with identical<br>    // memory management rules and variable scope semantics.<br>    print(“Value changed.”)<br>}<br>tweet.isLiked = true // Console would log “Value changed.”<br></p><p>Behind the Scenes:<br></p><p>- When compiling a Swift class “Foo&quot;, the compiler would also generate a companion “Foo_SwiftObservables” class.<br></p><p>- When initializing an instance of a Swift class, an instance of the companion “ Foo_SwiftObservables” class would be initialized and set as the value of a reserved member name like “observables”. This member would be implicit, like `self`.<br></p><p>- The auto-generated “ Foo_SwiftObservables” class would have a corresponding property for every observable property of the target class, with an identical name.<br></p><p>- Each property of the auto-generated “ Foo_SwiftObservables” class would be an instance of a generic `Observable&lt;T&gt;` class, where `T` would be assigned to the value of the associated property of the target class.<br></p><p>- The `Observable&lt;T&gt;` class would have two public functions: addObserver() and removeObserver(). <br></p><p>- The addObserver() function would take a single closure argument. This closure would have a signature like: (oldValue: T?, newValue: T?) -&gt; Void. <br></p><p>- Observer closures would have the same memory management and variable scope rules as any other closure. Callers would not be obligated to remove their observer closures. Doing so would be a non-mandatory best practice.<br></p><p><br>Rough Code Examples<br></p><p>Consider a class for a Twitter client like:<br></p><p>class Tweet {<br>    var isLiked: Bool = false<br>    let text: String<br>     <br>    init(text: String) {<br>        self.text = text<br>    }<br>}<br>The compiler would generate a companion observables class:<br></p><p>class Tweet_SwiftObservables {<br>    let isLiked = Observable&lt;Bool&gt;()<br>}<br>Notice that only the `isLiked` property is carried over, since the `text` property of `Tweet` is a let, not a var.<br></p><p>The generic Observable class would be something like (pseudo-codish):<br></p><p>class Observable&lt;T&gt; {<br>    typealias Observer = (oldValue: T?, newValue: T?) -&gt; Void<br>    private var observers = [UInt: Observer]()<br>     <br>    func addObserver(observer: Observer) -&gt; Uint {<br>        let token: Uint = 0 // generate some unique token<br>        self.observers[token] = observer<br>        return token<br>    }<br>     <br>    func removeObserverForToken(token: Uint) {<br>        self.observers[token] = nil<br>    }<br>}<br></p><p>Benefits of This Approach<br></p><p>It’s familiar. It resembles the core mechanic of KVO without the hassle. It uses existing memory management rules. Everything you already understand about closures applies here.<br></p><p>It’s type-safe. The Observable&lt;T&gt; generic class ensures at compile-time that your observers don’t receive an incorrect type.<br></p><p>It’s readable. The syntax is brief without being unclear. Implementing the observation closure at the same call site as addObserver() keeps cause and effect as close together as possible.<br></p><p>It’s easy. It abandons a stringly-typed API in favor of a compile-time API. Since the Foo_SwiftObservables classes would be auto-generated by the compiler, there’s no need for busywork tasks like keeping redundant manual protocols or keyword constants up to date with the target classes.<br></p><p><br>Thanks for reading,<br></p><p><br>-- <br>Jared Sinclair<br>@jaredsinclair<br>jaredsinclair.com<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160101/017e50e4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Swift-Native Alternative to KVO</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>January  1, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jan 1, 2016, at 7:00 PM, Jared Sinclair via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The one-to-many observer pattern could really use a first-party, native Swift solution. The day-to-day practice of writing iOS / OS X applications needs it, and we end up falling back on antiquated APIs like KVO or NSNotificationCenter, or short-lived third-party libraries. This is an essential need that deserves a fresh approach.<br>&gt; <br>&gt; What follows is a rough proposal for a Swift-native “KVO alternative”. <br>&gt; <br>&gt; <br>&gt; What Usage Would Look Like:<br>&gt; <br>&gt; let tweet = Tweet(text: “Hi.”)<br>&gt; tweet.observables.isLiked.addObserver { (oldValue, newValue) -&gt; Void in<br>&gt;     // this is otherwise just a standard closure, with identical<br>&gt;     // memory management rules and variable scope semantics.<br>&gt;     print(“Value changed.”)<br>&gt; }<br>&gt; tweet.isLiked = true // Console would log “Value changed.”<br>&gt; <br>&gt; Behind the Scenes:<br>&gt; <br>&gt; - When compiling a Swift class “Foo&quot;, the compiler would also generate a companion “Foo_SwiftObservables” class.<br>&gt; <br>&gt; - When initializing an instance of a Swift class, an instance of the companion “ Foo_SwiftObservables” class would be initialized and set as the value of a reserved member name like “observables”. This member would be implicit, like `self`.<br>&gt; <br>&gt; - The auto-generated “ Foo_SwiftObservables” class would have a corresponding property for every observable property of the target class, with an identical name.<br>&gt; <br>&gt; - Each property of the auto-generated “ Foo_SwiftObservables” class would be an instance of a generic `Observable&lt;T&gt;` class, where `T` would be assigned to the value of the associated property of the target class.<br>&gt; <br>&gt; - The `Observable&lt;T&gt;` class would have two public functions: addObserver() and removeObserver(). <br>&gt; <br>&gt; - The addObserver() function would take a single closure argument. This closure would have a signature like: (oldValue: T?, newValue: T?) -&gt; Void. <br>&gt; <br>&gt; - Observer closures would have the same memory management and variable scope rules as any other closure. Callers would not be obligated to remove their observer closures. Doing so would be a non-mandatory best practice.<br>&gt; <br>&gt; <br>&gt; Rough Code Examples<br>&gt; <br>&gt; Consider a class for a Twitter client like:<br>&gt; <br>&gt; class Tweet {<br>&gt;     var isLiked: Bool = false<br>&gt;     let text: String<br>&gt;      <br>&gt;     init(text: String) {<br>&gt;         self.text = text<br>&gt;     }<br>&gt; }<br>&gt; The compiler would generate a companion observables class:<br>&gt; <br>&gt; class Tweet_SwiftObservables {<br>&gt;     let isLiked = Observable&lt;Bool&gt;()<br>&gt; }<br>&gt; Notice that only the `isLiked` property is carried over, since the `text` property of `Tweet` is a let, not a var.<br>&gt; <br>&gt; The generic Observable class would be something like (pseudo-codish):<br>&gt; <br>&gt; class Observable&lt;T&gt; {<br>&gt;     typealias Observer = (oldValue: T?, newValue: T?) -&gt; Void<br>&gt;     private var observers = [UInt: Observer]()<br>&gt;      <br>&gt;     func addObserver(observer: Observer) -&gt; Uint {<br>&gt;         let token: Uint = 0 // generate some unique token<br>&gt;         self.observers[token] = observer<br>&gt;         return token<br>&gt;     }<br>&gt;      <br>&gt;     func removeObserverForToken(token: Uint) {<br>&gt;         self.observers[token] = nil<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Benefits of This Approach<br>&gt; <br>&gt; It’s familiar. It resembles the core mechanic of KVO without the hassle. It uses existing memory management rules. Everything you already understand about closures applies here.<br>&gt; <br>&gt; It’s type-safe. The Observable&lt;T&gt; generic class ensures at compile-time that your observers don’t receive an incorrect type.<br>&gt; <br>&gt; It’s readable. The syntax is brief without being unclear. Implementing the observation closure at the same call site as addObserver() keeps cause and effect as close together as possible.<br>&gt; <br>&gt; It’s easy. It abandons a stringly-typed API in favor of a compile-time API. Since the Foo_SwiftObservables classes would be auto-generated by the compiler, there’s no need for busywork tasks like keeping redundant manual protocols or keyword constants up to date with the target classes.<br>&gt; <br>&gt; <br>&gt; Thanks for reading,<br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Jared Sinclair<br>&gt; @jaredsinclair<br>&gt; jaredsinclair.com &lt;http://jaredsinclair.com/&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>I’ve been thinking about this for a while, as well. I think the problem would be better served by a simpler approach. Generating entire new classes is the way the existing KVO mechanism works, but I don’t really see the necessity in it.<br></p><p>Here’s my counter-pitch: add an “observable&quot; keyword on property declarations, so your “isLIked” property would look like this:<br></p><p>class Tweet {<br>	observable var isLiked: Bool = false<br>	let text: String<br></p><p>	init(text: String) {<br>		self.text = text<br>	}<br>}<br></p><p>My first instinct is to make observations based on strings, as KVO does, as this is easier to integrate with XIB-based user interface elements, as well as making it possible for it to interact with the legacy KVO system. Using strings also makes it possible to bind to key paths, which can be useful. However, if one wanted to make the observations based on pointers rather than strings, for type safety, that would also be possible.<br></p><p>The strings would be provided by a parameter on the “observable” attribute (i.e. observable(“foo”)); if no parameter is provided, Swift would automatically insert the property name as the key.<br></p><p>When a property is marked “observable”, the Swift compiler rewrites the class to something resembling the following pseudocode:<br></p><p>class Tweet {<br>	var isLiked_Observers: [(oldValue: Bool, newValue: Bool) -&gt; ()]? = nil<br></p><p>	var isLiked: Bool {<br>		didSet(oldValue) {<br>			// optional for performance reasons; in the common case where there are no observers,<br>			// checking an optional has less of a performance penalty than checking whether an array is empty.		<br>			if let observers = self.isLiked_Observers {<br>				for eachObserver in observers {<br>					eachObserver(oldValue: oldValue, newValue: self.isLiked)<br>				}<br>			}<br>		}<br>	}<br>	let text: String<br></p><p>	init(text: String) {<br>		self.text = text<br>	}<br>}<br></p><p>If there are no observers, the only cost added to the setter would be that of setting an optional.<br></p><p>What usage would look like:<br></p><p>let tweet = Tweet(text: “Hi.”)<br></p><p>tweet.addObserverFor(“isLiked&quot;) { oldValue, newValue in<br>    print(“Value changed.”)<br>}<br></p><p>tweet.isLiked = true // Console would log “Value changed.”<br></p><p>If isLiked later becomes a calculated property, it would add a “depedencies” attribute, which would return a set of other observable properties, like so:<br></p><p>class Tweet {<br>	observable var numberOfLikes: Int = 0<br>	observable var isLiked: Bool {<br>		dependencies { return [&quot;numberOfLikes&quot;] }<br>		get { return !self.numberOfLikes.isEmpty }<br>		set(isLiked) {<br>			if isLiked {<br>				self.numberOfLikes += 1<br>			} else {<br>				self.numberOfLikes = 0 // or something; it’s just an example<br>			}<br>		}<br>	}<br>	let text: String<br></p><p>	init(text: String) {<br>		self.text = text<br>	}<br>}<br></p><p>In this example, the “isLiked” property would generate an observation on “numberOfLikes” that would look something like the following. For this example, we introduce a cached version of the previous value of “isLiked&quot; so that we have a copy of the old value in the case that the dependency changes (and isLiked’s willSet and didSet thus won’t fire). An alternative solution would be to run observation closures before *and* after setting each property, as KVO does; however, this would not perform as well, and would be more difficult to manage in multithreaded situations.<br></p><p>// generated by the compiler and added to initialization<br>self.addObserverFor(“numberOfLikes”) { [weak self] _, _ in<br>	if let observers = self.observers {<br>		for eachObserver in observers {<br>			eachObserver(oldValue: isLiked_Cached, newValue: self.isLiked)<br>		}<br>	}<br></p><p>	isLiked_Cached = self.isLiked<br>}<br></p><p>This would cause our notifications to be fired even for computed properties when one of the dependencies changes.<br></p><p>One final little perk would allow us to specify a dispatch queue upon which observations should be fired:<br></p><p>class Tweet {<br>	observable var isLiked: Bool = false {<br>		dispatchQueue { return dispatch_get_main_queue() }<br>	}<br>	let text: String<br></p><p>	init(text: String) {<br>		self.text = text<br>	}<br>}<br></p><p>The benefits of this should not need explanation.<br></p><p>Benefits of this approach:<br></p><p>- It’s relatively simple and lightweight, with no additional classes being created, and the common case adding only the cost of an optional check to property setters.<br></p><p>- It’s easy to understand and to use.<br></p><p>- All observable properties are marked “observable” in the UI. As an example of why this is desirable, consider that you had been observing the “isLiked” property from the first example, and then the implementation of the Tweet class changed to the “numberOfLikes” implementation without the author considering KVO. Your observer code would break, and you would no longer get notifications for “isLiked” if “numberOfLikes” changed. Having an “observable” keyword communicates a contract to the user that this property will remain observable, and any changes will be made in a way that won’t break observability. Such contract is important to have if your client code is relying on the observation working properly.<br></p><p>- An additional benefit to only adding the observation code for properties that are explicitly marked “observable” is that the optional-check performance costs, as well as the memory allocation for the array of closures, can be skipped for properties that don’t need to be observable.<br></p><p>Alternatives Considered:<br></p><p>One could possibly base the observation around actual pointers, rather than strings. This would preclude any future extension to make this system interact with the existing KVO system, as well as necessitate some sort of rethinking about how bindings would be set up in XIB files, but it would add greater type safety (particularly, the compiler could enforce that observations could only be done on properties that were actually declared as observable).<br></p><p>One could introduce *two* arrays of observation closures, one to be fired before the setter runs and one afterward. This would work more similarly to how KVO works, but would introduce an extra performance cost, as each set would have to check *two* optionals rather than just one, and since the setter would have to wait for the “willSet” closure to finish before setting the property, which could slow down worker code. This would, however, eliminate the need for keeping a cached value for observable computed properties.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160101/3eef09cd/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Swift-Native Alternative to KVO</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January  1, 2016 at 08:00:00pm</p></header><div class="content"><p>On Jan 1, 2016, at 5:00 PM, Jared Sinclair via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; The one-to-many observer pattern could really use a first-party, native Swift solution. The day-to-day practice of writing iOS / OS X applications needs it, and we end up falling back on antiquated APIs like KVO or NSNotificationCenter, or short-lived third-party libraries. This is an essential need that deserves a fresh approach.<br></p><p>Hi Jared,<br></p><p>I agree with your motivation, but I can’t see us having time to take this on in the Swift 3 timeframe.  There is a huge potential design space here, and KVO has some significant sub-optimalities in its design - only one of which is that notifications often get delivered on the “wrong” thread.<br></p><p>It is pretty likely that we’ll get property behaviors in the Swift 3 timeframe, and that may enable some KVO like systems to be built.  However, I doubt we would standardize and include a KVO system in the Swift 3 timeframe because of the short timeframes involved.  Also, I’m very hopeful that we’ll be able to tackle concurrency in Swift 4, and making these two features mesh well seems really important.<br></p><p>That said, feel free to start hacking on the compiler to prototype your ideas!<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160101/e94ec371/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72853d2b57e37aab89afe61af4f74c62?s=50"></div><header><strong>Better syntax for deferred?</strong> from <string>Maury Markowitz</string> &lt;maury.markowitz at gmail.com&gt;<p>January  2, 2016 at 09:00:00am</p></header><div class="content"><p>I&#39;m confused about &#39;defer&#39;. Not the purpose, the chosen syntax. <br></p><p>func confusing() {<br>    print(&quot;1&quot;)<br>    defer { print(&quot;2&quot;) }<br>    print(&quot;3&quot;)<br>}<br></p><p>Produces 1,3,2. Trying to describe what is happening here is non-trivial... it runs line 1, then we put line 2 on a stack, then line three runs, then we pop the stack... what?! And stepping through it in the debugger... ugh.<br></p><p>Unless I missed something obvious, wouldn&#39;t placing &quot;code that always has to run at the end&quot; actually *at the end* not make more sense? Like this...<br></p><p>func clear() {<br>    print(&quot;1&quot;)<br>    print(&quot;3&quot;)<br></p><p>    always { print(&quot;2&quot;) }<br>}<br></p><p>Not only is the code clearly expressing its intent, the actual execution is following the source.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Better syntax for deferred?</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>January  2, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; Unless I missed something obvious, wouldn&#39;t placing &quot;code that always has to run at the end&quot; actually *at the end* not make more sense? Like this…<br>In most cases, you use defer for cleanup tasks - so it make more sense to keep it at the source of the &quot;problem&quot;:<br></p><p>file.open(); defer { file.close() }<br>…<br></p><p>Tino<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Better syntax for deferred?</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>January  2, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jan 2, 2016, at 8:37 AM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Unless I missed something obvious, wouldn&#39;t placing &quot;code that always has to run at the end&quot; actually *at the end* not make more sense? Like this…<br>&gt; In most cases, you use defer for cleanup tasks - so it make more sense to keep it at the source of the &quot;problem&quot;:<br>&gt; <br>&gt; file.open(); defer { file.close() }<br>&gt; …<br>&gt; <br>&gt; Tino<br></p><p>This. It’s way easier to remember to do necessary cleanup tasks if you add the cleanup call right after the call that requires the cleanup. It’s also much easier to catch cases where someone has forgotten to do so. Separating the init and cleanup by large distances as in the old try/catch/finally mechanism makes it easier for things to get out of sync as the code evolves.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160102/5dadd157/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/265868676ac8f12472cc3cc0fc59d827?s=50"></div><header><strong>Better syntax for deferred?</strong> from <string>Nicky Gerritsen</string> &lt;nickygerritsen at me.com&gt;<p>January  2, 2016 at 03:00:00pm</p></header><div class="content"><p>Defer is used to make code *always* run, even if the function terminates early. Imagine:<br></p><p>func doSomethingWith(x: Int) {<br>	print(“1”)<br>	defer { print(“2&quot;) }<br>	if x &gt; 3 { defer { print(“yay”); return }<br>	print(“3”)<br>}<br></p><p>Now print(“2”) will always happen, even if the if is true. Placing it at the end this will not be the case. The “yay” will only be printed in the case of the if.<br>In general we can not place the defer at the end, because it only should run if the code “comes by” the call.<br></p><p>Regards,<br></p><p>Nicky<br></p><p>&gt; On 2 jan. 2016, at 15:25, Maury Markowitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;m confused about &#39;defer&#39;. Not the purpose, the chosen syntax.<br>&gt; <br>&gt; func confusing() {<br>&gt;    print(&quot;1&quot;)<br>&gt;    defer { print(&quot;2&quot;) }<br>&gt;    print(&quot;3&quot;)<br>&gt; }<br>&gt; <br>&gt; Produces 1,3,2. Trying to describe what is happening here is non-trivial... it runs line 1, then we put line 2 on a stack, then line three runs, then we pop the stack... what?! And stepping through it in the debugger... ugh.<br>&gt; <br>&gt; Unless I missed something obvious, wouldn&#39;t placing &quot;code that always has to run at the end&quot; actually *at the end* not make more sense? Like this...<br>&gt; <br>&gt; func clear() {<br>&gt;    print(&quot;1&quot;)<br>&gt;    print(&quot;3&quot;)<br>&gt; <br>&gt;    always { print(&quot;2&quot;) }<br>&gt; }<br>&gt; <br>&gt; Not only is the code clearly expressing its intent, the actual execution is following the source.<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 842 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160102/b49a3f8d/attachment.sig&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72853d2b57e37aab89afe61af4f74c62?s=50"></div><header><strong>Better syntax for deferred?</strong> from <string>Maury Markowitz</string> &lt;maury.markowitz at gmail.com&gt;<p>January  2, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 2, 2016, at 9:38 AM, Nicky Gerritsen &lt;nickygerritsen at me.com&gt; wrote:<br>&gt; <br>&gt; Defer is used to make code *always* run, even if the function terminates early. Imagine:<br></p><p>Which is precisely why I called it &#39;always&#39;. So in your example:<br></p><p>    func doSomethingWith(x: Int) {<br>	print(“1”)<br>	defer { print(“2&quot;) }<br>	if x &gt; 3 { defer { print(“yay”); return }<br>	print(“3”)<br>    }<br></p><p>I would say:<br></p><p>    func doSomethingWith(x: Int) {<br>	print(“1”)<br>	print(“3”)<br>        always {<br>            print(“2&quot;)<br>            if x &gt; 3 { print(“yay”) }<br>        }<br>    }<br></p><p>This is functionally identical, but both the syntax and program flow are greatly improved.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be09ed656d5d90501c958b001261f218?s=50"></div><header><strong>Better syntax for deferred?</strong> from <string>Jeremy Pereira</string> &lt;jeremy.j.pereira at googlemail.com&gt;<p>January  4, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On 2 Jan 2016, at 16:49, Maury Markowitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 2, 2016, at 9:38 AM, Nicky Gerritsen &lt;nickygerritsen at me.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Defer is used to make code *always* run, even if the function terminates early. Imagine:<br>&gt; <br>&gt; Which is precisely why I called it &#39;always&#39;. So in your example:<br>&gt; <br>&gt;    func doSomethingWith(x: Int) {<br>&gt; 	print(“1”)<br>&gt; 	defer { print(“2&quot;) }<br>&gt; 	if x &gt; 3 { defer { print(“yay”); return }<br>&gt; 	print(“3”)<br>&gt;    }<br>&gt; <br>&gt; I would say:<br>&gt; <br>&gt;    func doSomethingWith(x: Int) {<br>&gt; 	print(“1”)<br>&gt; 	print(“3”)<br>&gt;        always {<br>&gt;            print(“2&quot;)<br>&gt;            if x &gt; 3 { print(“yay”) }<br>&gt;        }<br>&gt;    }<br>&gt; <br>&gt; This is functionally identical, but both the syntax and program flow are greatly improved.<br></p><p>No your example is not functionally identical to Nicky’s (notwithstanding the missing closing brace in the original). “defer&quot; defers the closure to the end of the current scope. In this instance , that is the end of the if block. The “yay” must come before the “2” because the if scope exits before the function scope. Also, in the following:<br></p><p> func doSomethingWith(x: Int) {<br>    print(&quot;1&quot;)<br>    defer { print(&quot;2&quot;) }<br>    if x &gt; 3 { defer { print(&quot;yay&quot;) } }<br>    print(&quot;3&quot;)<br> }<br></p><p>doSomethingWith(4)<br></p><p>“yay” comes before “3” for the same reason.<br></p><p><br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Better syntax for deferred?</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January  5, 2016 at 07:00:00am</p></header><div class="content"><p>I don’t think it is worth changing from defer to the more traditional try finally block, both have pros and cons. Just work with what we have. You can always, as a matter of style, put a single defer block at the end of scope instead of multiple defers throughout the block.<br></p><p><br>&gt; On 5 Jan 2016, at 1:17 AM, Jeremy Pereira via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On 2 Jan 2016, at 16:49, Maury Markowitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 2, 2016, at 9:38 AM, Nicky Gerritsen &lt;nickygerritsen at me.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Defer is used to make code *always* run, even if the function terminates early. Imagine:<br>&gt;&gt; <br>&gt;&gt; Which is precisely why I called it &#39;always&#39;. So in your example:<br>&gt;&gt; <br>&gt;&gt;   func doSomethingWith(x: Int) {<br>&gt;&gt; 	print(“1”)<br>&gt;&gt; 	defer { print(“2&quot;) }<br>&gt;&gt; 	if x &gt; 3 { defer { print(“yay”); return }<br>&gt;&gt; 	print(“3”)<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; I would say:<br>&gt;&gt; <br>&gt;&gt;   func doSomethingWith(x: Int) {<br>&gt;&gt; 	print(“1”)<br>&gt;&gt; 	print(“3”)<br>&gt;&gt;       always {<br>&gt;&gt;           print(“2&quot;)<br>&gt;&gt;           if x &gt; 3 { print(“yay”) }<br>&gt;&gt;       }<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; This is functionally identical, but both the syntax and program flow are greatly improved.<br>&gt; <br>&gt; No your example is not functionally identical to Nicky’s (notwithstanding the missing closing brace in the original). “defer&quot; defers the closure to the end of the current scope. In this instance , that is the end of the if block. The “yay” must come before the “2” because the if scope exits before the function scope. Also, in the following:<br>&gt; <br>&gt; func doSomethingWith(x: Int) {<br>&gt;    print(&quot;1&quot;)<br>&gt;    defer { print(&quot;2&quot;) }<br>&gt;    if x &gt; 3 { defer { print(&quot;yay&quot;) } }<br>&gt;    print(&quot;3&quot;)<br>&gt; }<br>&gt; <br>&gt; doSomethingWith(4)<br>&gt; <br>&gt; “yay” comes before “3” for the same reason.<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/dff094f1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Better syntax for deferred?</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>January  4, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jan 4, 2016, at 12:41 PM, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; I don’t think it is worth changing from defer to the more traditional try finally block, both have pros and cons. Just work with what we have. You can always, as a matter of style, put a single defer block at the end of scope instead of multiple defers throughout the block.<br></p><p>For what it’s worth, the error-handling rationale discusses the trade-offs of the defer syntax.  I think we’re very happy with the current syntax.<br></p><p>John.<br></p><p>&gt; <br>&gt; <br>&gt;&gt; On 5 Jan 2016, at 1:17 AM, Jeremy Pereira via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 2 Jan 2016, at 16:49, Maury Markowitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 2, 2016, at 9:38 AM, Nicky Gerritsen &lt;nickygerritsen at me.com &lt;mailto:nickygerritsen at me.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Defer is used to make code *always* run, even if the function terminates early. Imagine:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Which is precisely why I called it &#39;always&#39;. So in your example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   func doSomethingWith(x: Int) {<br>&gt;&gt;&gt; 	print(“1”)<br>&gt;&gt;&gt; 	defer { print(“2&quot;) }<br>&gt;&gt;&gt; 	if x &gt; 3 { defer { print(“yay”); return }<br>&gt;&gt;&gt; 	print(“3”)<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would say:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   func doSomethingWith(x: Int) {<br>&gt;&gt;&gt; 	print(“1”)<br>&gt;&gt;&gt; 	print(“3”)<br>&gt;&gt;&gt;       always {<br>&gt;&gt;&gt;           print(“2&quot;)<br>&gt;&gt;&gt;           if x &gt; 3 { print(“yay”) }<br>&gt;&gt;&gt;       }<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is functionally identical, but both the syntax and program flow are greatly improved.<br>&gt;&gt; <br>&gt;&gt; No your example is not functionally identical to Nicky’s (notwithstanding the missing closing brace in the original). “defer&quot; defers the closure to the end of the current scope. In this instance , that is the end of the if block. The “yay” must come before the “2” because the if scope exits before the function scope. Also, in the following:<br>&gt;&gt; <br>&gt;&gt; func doSomethingWith(x: Int) {<br>&gt;&gt;    print(&quot;1&quot;)<br>&gt;&gt;    defer { print(&quot;2&quot;) }<br>&gt;&gt;    if x &gt; 3 { defer { print(&quot;yay&quot;) } }<br>&gt;&gt;    print(&quot;3&quot;)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; doSomethingWith(4)<br>&gt;&gt; <br>&gt;&gt; “yay” comes before “3” for the same reason.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160104/c5b802ab/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f1dbb31fde56cc18dd95d0faaeeb4614?s=50"></div><header><strong>Better syntax for deferred?</strong> from <string>Sebastian Mecklenburg</string> &lt;mecklenburg at rechenmaschinist.de&gt;<p>January  2, 2016 at 05:00:00pm</p></header><div class="content"><p>I don’t think it’s confusing, I read ‘defer’ a ‘do it later’ and that’s just what it does. And the deferred calls are not always necessary so they can’t always be placed at the end.<br></p><p>The only thing to be aware of is that the order is reversed (or not determined), so<br></p><p>func testDefer() {<br>    defer {print(&quot;deferred call1&quot;)}<br>    defer {print(&quot;deferred call2&quot;)}<br>}<br></p><p>prints<br></p><p>deferred call2<br>deferred call1<br></p><p>But I think that is the logical consequence of the way how defer is supposed to work, so that’s OK too. One just has to be aware of it.<br></p><p>&gt; On 02 Jan 2016, at 15:25, Maury Markowitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;m confused about &#39;defer&#39;. Not the purpose, the chosen syntax. <br>&gt; <br>&gt; func confusing() {<br>&gt;    print(&quot;1&quot;)<br>&gt;    defer { print(&quot;2&quot;) }<br>&gt;    print(&quot;3&quot;)<br>&gt; }<br>&gt; <br>&gt; Produces 1,3,2. Trying to describe what is happening here is non-trivial... it runs line 1, then we put line 2 on a stack, then line three runs, then we pop the stack... what?! And stepping through it in the debugger... ugh.<br>&gt; <br>&gt; Unless I missed something obvious, wouldn&#39;t placing &quot;code that always has to run at the end&quot; actually *at the end* not make more sense? Like this...<br>&gt; <br>&gt; func clear() {<br>&gt;    print(&quot;1&quot;)<br>&gt;    print(&quot;3&quot;)<br>&gt; <br>&gt;    always { print(&quot;2&quot;) }<br>&gt; }<br>&gt; <br>&gt; Not only is the code clearly expressing its intent, the actual execution is following the source.<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72853d2b57e37aab89afe61af4f74c62?s=50"></div><header><strong>Better syntax for deferred?</strong> from <string>Maury Markowitz</string> &lt;maury.markowitz at gmail.com&gt;<p>January  2, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jan 2, 2016, at 11:48 AM, Sebastian Mecklenburg via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I don’t think it’s confusing, I read ‘defer’ a ‘do it later’ and that’s just what it does. And the deferred calls are not always necessary so they can’t always be placed at the end.<br></p><p>Can you be more specific about &quot;deferred calls are not always necessary&quot;? Do you mean that you could, for instance, place an if in front of the defer? If so one could do the same with always, of course. I&#39;ll use your example, slightly expanded, to illustrate<br></p><p>&gt; func testDefer(x: Int) {<br>&gt;    defer {print(&quot;deferred call1&quot;)}<br>&gt;    if x &gt; 1 { defer {print(&quot;deferred call2&quot;)} }<br>    print(&quot;non-deferred call&quot;)<br>&gt; }<br></p><p>I would rewrite this as:<br></p><p>    func testAlways(x: Int) {<br>        print(&quot;non-deferred call&quot;)<br>        always {<br>	    print(&quot;deferred call1&quot;)<br>            if x &gt; 1 print(&quot;deferred call2&quot;)<br>        }<br>    }<br></p><p>Which is 100% equivalent to your example, but works precisely as you would expect without needing to &quot;be aware&quot; of any &quot;logical consequence&quot;s. The code runs exactly as it appears.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c965d88fab90b7e85514d0e3011c3caf?s=50"></div><header><strong>Better syntax for deferred?</strong> from <string>Tim Hawkins</string> &lt;tim.thawkins at gmail.com&gt;<p>January  3, 2016 at 01:00:00am</p></header><div class="content"><p>Again my 2 cents<br></p><p>Other languages use &quot;deffer&quot;, and have very simular semantics, there is no<br>benifit gained from being different, and it makes peoples task of<br>transfering from other systems easier.<br></p><p>The percieved &quot;simplicity&quot; of the alternative semanatics and naming is<br>subjective. What is there works just fine and achives the result it was<br>designed to do. Why do we need to change it?<br>On Jan 3, 2016 1:47 AM, &quot;Maury Markowitz via swift-evolution&quot; &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Jan 2, 2016, at 11:48 AM, Sebastian Mecklenburg via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I don’t think it’s confusing, I read ‘defer’ a ‘do it later’ and that’s<br>&gt; just what it does. And the deferred calls are not always necessary so they<br>&gt; can’t always be placed at the end.<br>&gt;<br>&gt; Can you be more specific about &quot;deferred calls are not always necessary&quot;?<br>&gt; Do you mean that you could, for instance, place an if in front of the<br>&gt; defer? If so one could do the same with always, of course. I&#39;ll use your<br>&gt; example, slightly expanded, to illustrate<br>&gt;<br>&gt; &gt; func testDefer(x: Int) {<br>&gt; &gt;    defer {print(&quot;deferred call1&quot;)}<br>&gt; &gt;    if x &gt; 1 { defer {print(&quot;deferred call2&quot;)} }<br>&gt;     print(&quot;non-deferred call&quot;)<br>&gt; &gt; }<br>&gt;<br>&gt; I would rewrite this as:<br>&gt;<br>&gt;     func testAlways(x: Int) {<br>&gt;         print(&quot;non-deferred call&quot;)<br>&gt;         always {<br>&gt;             print(&quot;deferred call1&quot;)<br>&gt;             if x &gt; 1 print(&quot;deferred call2&quot;)<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt; Which is 100% equivalent to your example, but works precisely as you would<br>&gt; expect without needing to &quot;be aware&quot; of any &quot;logical consequence&quot;s. The<br>&gt; code runs exactly as it appears.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160103/fca25a12/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c0eafab7106ab63b8db4025e57c1a8d2?s=50"></div><header><strong>Better syntax for deferred?</strong> from <string>Javier Soto</string> &lt;javier.api at gmail.com&gt;<p>January  2, 2016 at 06:00:00pm</p></header><div class="content"><p>How would always behave if the function has an early return? Like so:<br></p><p>func testAlways(x: Int) {<br>print(&quot;non-deferred call&quot;)<br>return<br>let a = 3<br>always {<br>print(&quot;deferred call: \(a)&quot;)<br>}<br>}<br>On Sat, Jan 2, 2016 at 9:56 AM Tim Hawkins via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Again my 2 cents<br>&gt;<br>&gt; Other languages use &quot;deffer&quot;, and have very simular semantics, there is no<br>&gt; benifit gained from being different, and it makes peoples task of<br>&gt; transfering from other systems easier.<br>&gt;<br>&gt; The percieved &quot;simplicity&quot; of the alternative semanatics and naming is<br>&gt; subjective. What is there works just fine and achives the result it was<br>&gt; designed to do. Why do we need to change it?<br>&gt; On Jan 3, 2016 1:47 AM, &quot;Maury Markowitz via swift-evolution&quot; &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; On Jan 2, 2016, at 11:48 AM, Sebastian Mecklenburg via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I don’t think it’s confusing, I read ‘defer’ a ‘do it later’ and that’s<br>&gt;&gt; just what it does. And the deferred calls are not always necessary so they<br>&gt;&gt; can’t always be placed at the end.<br>&gt;&gt;<br>&gt;&gt; Can you be more specific about &quot;deferred calls are not always necessary&quot;?<br>&gt;&gt; Do you mean that you could, for instance, place an if in front of the<br>&gt;&gt; defer? If so one could do the same with always, of course. I&#39;ll use your<br>&gt;&gt; example, slightly expanded, to illustrate<br>&gt;&gt;<br>&gt;&gt; &gt; func testDefer(x: Int) {<br>&gt;&gt; &gt;    defer {print(&quot;deferred call1&quot;)}<br>&gt;&gt; &gt;    if x &gt; 1 { defer {print(&quot;deferred call2&quot;)} }<br>&gt;&gt;     print(&quot;non-deferred call&quot;)<br>&gt;&gt; &gt; }<br>&gt;&gt;<br>&gt;&gt; I would rewrite this as:<br>&gt;&gt;<br>&gt;&gt;     func testAlways(x: Int) {<br>&gt;&gt;         print(&quot;non-deferred call&quot;)<br>&gt;&gt;         always {<br>&gt;&gt;             print(&quot;deferred call1&quot;)<br>&gt;&gt;             if x &gt; 1 print(&quot;deferred call2&quot;)<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt; Which is 100% equivalent to your example, but works precisely as you<br>&gt;&gt; would expect without needing to &quot;be aware&quot; of any &quot;logical consequence&quot;s.<br>&gt;&gt; The code runs exactly as it appears.<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-- <br>Javier Soto<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160102/eb020e88/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72853d2b57e37aab89afe61af4f74c62?s=50"></div><header><strong>Better syntax for deferred?</strong> from <string>Maury Markowitz</string> &lt;maury.markowitz at gmail.com&gt;<p>January  2, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jan 2, 2016, at 1:26 PM, Javier Soto &lt;javier.api at gmail.com&gt; wrote:<br>&gt; <br>&gt; How would always behave if the function has an early return?<br></p><p>Exactly the same way as &#39;defer&#39; would behave if the function has an early return.<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72853d2b57e37aab89afe61af4f74c62?s=50"></div><header><strong>Better syntax for deferred?</strong> from <string>Maury Markowitz</string> &lt;maury.markowitz at gmail.com&gt;<p>January  2, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jan 2, 2016, at 12:56 PM, Tim Hawkins &lt;tim.thawkins at gmail.com&gt; wrote:<br>&gt; <br>&gt; Again my 2 cents<br>&gt; <br>&gt; Other languages use &quot;deffer&quot;, and have very simular semantics<br></p><p>No, they don&#39;t. With the exception of &quot;Go&quot;, I&#39;m unfamiliar with any other language that implements this feature *in this fashion*.<br></p><p>&gt; there is no benifit gained from being different, and it makes peoples task of transfering from other systems easier.<br></p><p>Precisely why I make this suggestion. Swift is the oddball here, using something that is decidedly non-standard as well as confusing. Why not use a solution that is widely used and better?<br></p><p>&gt; What is there works just fine and achives the result it was designed to do. Why do we need to change it?<br></p><p>The same could be said for Obj-C, yet here we are.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>Better syntax for deferred?</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>January  2, 2016 at 01:00:00pm</p></header><div class="content"><p>Le 2 janv. 2016 à 13:29, Maury Markowitz via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br></p><p>&gt; No, they don&#39;t. With the exception of &quot;Go&quot;, I&#39;m unfamiliar with any other language that implements this feature *in this fashion*.<br></p><p>D has `scope (exit)`, which is exactly the same as `defer` in Swift.<br></p><p>It&#39;s also common to see C++ code using scope guards (implemented as a library feature). As far as I&#39;m aware, this is where the pattern emerged first.<br></p><p>-- <br>Michel Fortin<br>https://michelf.ca<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Better syntax for deferred?</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>January  2, 2016 at 07:00:00pm</p></header><div class="content"><p>I have the terrible feeling something is wrong with my posts so that they get caught by spamfilters or similar…<br></p><p>But as others stated as well:<br>defer has a use case that is a little bit different from what you want to archive.<br></p><p>&gt; Why not use a solution that is widely used and better?<br>I&#39;m curious:<br>Which languages have this &quot;always&quot; construct?<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4de621aec7ff90a03f5b9b21e790bc66?s=50"></div><header><strong>Better syntax for deferred?</strong> from <string>Dennis Lysenko</string> &lt;dennis.s.lysenko at gmail.com&gt;<p>January  2, 2016 at 08:00:00pm</p></header><div class="content"><p>Deferring at the end of the function removes the ability to defer actions<br>on variables introduced in an inner scope.<br></p><p>On Sat, Jan 2, 2016, 1:57 PM Tino Heth via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I have the terrible feeling something is wrong with my posts so that they<br>&gt; get caught by spamfilters or similar…<br>&gt;<br>&gt; But as others stated as well:<br>&gt; defer has a use case that is a little bit different from what you want to<br>&gt; archive.<br>&gt;<br>&gt; &gt; Why not use a solution that is widely used and better?<br>&gt; I&#39;m curious:<br>&gt; Which languages have this &quot;always&quot; construct?<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160102/ab96da06/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f233ac53bacbea93245b63865b3f66fc?s=50"></div><header><strong>Better syntax for deferred?</strong> from <string>Robert S Mozayeni</string> &lt;dev at mzy.me&gt;<p>January  2, 2016 at 05:00:00pm</p></header><div class="content"><p>(Sorry if you get this email twice, I realized I first sent it from an email address that is not the one I used to subscribe to this list)<br></p><p>Not only that, but placing defer at the end of a scope, where any other code may never get executed if there’s an early return, kind of violates the whole concept of control flow.<br></p><p>func f() throws {<br>    let o = file(path: &quot;&quot;)<br>    o.openFile()<br>    do {<br>        try o.write(self.data)<br>    }<br></p><p>    print(&quot;success&quot;)<br>    always { o.close() }<br>}<br></p><p>What happens if o.write fails? Going with always would imply that we either…<br></p><p>A) put the `always` in every possible place the scope might exit, defeating the whole purpose of defer/always. Maury, I’m assuming you’re not actually suggesting that, which would leave: B) if the main scope of the function exits at any point, drop down to the `always` at the end of the scope and execute it. But then, what about the surrounding code at the end of the main scope? Like I said, I think this would violate the whole concept of control flow by cherry-picking a specific type of command that is always executed within a scope, even if that command is in some place the control flow doesn’t reach.<br></p><p>Unless I’m misinterpreting something (let me know if I am) this seems less intuitive than `defer` was to begin with.<br></p><p>-Robert<br></p><p>&gt; On Jan 2, 2016, at 3:17 PM, Dennis Lysenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Deferring at the end of the function removes the ability to defer actions on variables introduced in an inner scope.<br>&gt; <br>&gt; <br>&gt; On Sat, Jan 2, 2016, 1:57 PM Tino Heth via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; I have the terrible feeling something is wrong with my posts so that they get caught by spamfilters or similar…<br>&gt; <br>&gt; But as others stated as well:<br>&gt; defer has a use case that is a little bit different from what you want to archive.<br>&gt; <br>&gt; &gt; Why not use a solution that is widely used and better?<br>&gt; I&#39;m curious:<br>&gt; Which languages have this &quot;always&quot; construct?<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160102/c531cf94/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/388e62373f2bcb0ef212df56de255497?s=50"></div><header><strong>Better syntax for deferred?</strong> from <string>Robert S Mozayeni</string> &lt;r at mzy.me&gt;<p>January  2, 2016 at 05:00:00pm</p></header><div class="content"><p>Not only that, but placing defer at the end of a scope, where any other code may never get executed if there’s an early return, kind of violates the whole concept of control flow.<br></p><p>func f() throws {<br>    let o = file(path: &quot;&quot;)<br>    o.openFile()<br>    do {<br>        try o.write(self.data)<br>    }<br></p><p>    print(&quot;success&quot;)<br>    always { o.close() }<br>}<br></p><p>What happens if o.write fails? Going with always would imply that we either…<br></p><p>A) put the `always` in every possible place the scope might exit, defeating the whole purpose of defer/always. Maury, I’m assuming you’re not actually suggesting that, which would leave: B) if the main scope of the function exits at any point, drop down to the `always` at the end of the scope and execute it. But then, what about the surrounding code at the end of the main scope? Like I said, I think this would violate the whole concept of control flow by cherry-picking a specific type of command that is always executed within a scope, even if that command is in some place the control flow doesn’t reach.<br></p><p>Unless I’m misinterpreting something (let me know if I am) this seems less intuitive than `defer` was to begin with.<br></p><p>-Robert<br></p><p><br>&gt; On Jan 2, 2016, at 3:17 PM, Dennis Lysenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Deferring at the end of the function removes the ability to defer actions on variables introduced in an inner scope.<br>&gt; <br>&gt; <br>&gt; On Sat, Jan 2, 2016, 1:57 PM Tino Heth via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; I have the terrible feeling something is wrong with my posts so that they get caught by spamfilters or similar…<br>&gt; <br>&gt; But as others stated as well:<br>&gt; defer has a use case that is a little bit different from what you want to archive.<br>&gt; <br>&gt; &gt; Why not use a solution that is widely used and better?<br>&gt; I&#39;m curious:<br>&gt; Which languages have this &quot;always&quot; construct?<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160102/b8318eb3/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>Better syntax for deferred?</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>January  2, 2016 at 01:00:00pm</p></header><div class="content"><p>Le 2 janv. 2016 à 9:25, Maury Markowitz via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br></p><p>&gt; I&#39;m confused about &#39;defer&#39;. Not the purpose, the chosen syntax. <br>&gt; <br>&gt; func confusing() {<br>&gt;    print(&quot;1&quot;)<br>&gt;    defer { print(&quot;2&quot;) }<br>&gt;    print(&quot;3&quot;)<br>&gt; }<br>&gt; <br>&gt; Produces 1,3,2. Trying to describe what is happening here is non-trivial... it runs line 1, then we put line 2 on a stack, then line three runs, then we pop the stack... what?! And stepping through it in the debugger... ugh.<br>&gt; <br>&gt; Unless I missed something obvious, wouldn&#39;t placing &quot;code that always has to run at the end&quot; actually *at the end* not make more sense? Like this...<br>&gt; <br>&gt; func clear() {<br>&gt;    print(&quot;1&quot;)<br>&gt;    print(&quot;3&quot;)<br>&gt; <br>&gt;    always { print(&quot;2&quot;) }<br>&gt; }<br>&gt; <br>&gt; Not only is the code clearly expressing its intent, the actual execution is following the source.<br></p><p>With your proposal, code like this:<br></p><p>func test() throws -&gt; T {<br>	let a = try makeSomething()<br>	defer { a.cleanup() }<br></p><p>	let b = try makeSomething()<br>	defer { b.cleanup() }<br></p><p>	return try compute(a, b)<br>}<br></p><p>would have to be rewritten somewhat like this:<br></p><p>func test() throws -&gt; T {<br>	let a = try makeSomething()<br>	do {<br>		let b = try makeSomething()<br>		do {<br>			return try compute(a, b)<br>			always { b.cleanup() }<br>		}<br>		always { a.cleanup() }<br>	}<br>}<br></p><p>which is a bit inconvenient. One important thing with `defer` is that where you put it in the function impacts at which point it gets pushed on the &quot;cleanup stack&quot;, something that gets lost with `always` and which I need to add back through `do {}` blocks here.<br></p><p>I think what you are looking for is a `do {} finally {}` block, which you should feel free to propose if you think it&#39;s worth it. I personally don&#39;t think it makes the above example better, but it certainly has the benefit of always running things in source order.<br></p><p>func test() throws -&gt; T {<br>	let a = try makeSomething()<br>	do {<br>		let b = try makeSomething()<br>		do {<br>			return try compute(a, b)<br>		} finally {<br>			b.cleanup()<br>		}<br>	} finally {<br>		a.cleanup()<br>	}<br>}<br></p><p>-- <br>Michel Fortin<br>https://michelf.ca<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>Better syntax for deferred?</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>January  2, 2016 at 03:00:00pm</p></header><div class="content"><p>-1. `defer` doesn’t exist just to execute code at the end of blocks, it exists to allow resource cleanup when you have a function with multiple return points or non-trivial scoping.  For example, let’s add an if statement to your code:<br></p><p><br>func clear() {<br>   print(&quot;1&quot;)<br>   print(&quot;3&quot;)<br>   if (theBusiness) {<br>       print(“4”)<br>       return<br>   }<br>   always { print(&quot;2&quot;) }<br>}<br></p><p>Now `always` does not, in fact, model the flow of control through this function and I’m confused about where that finalizer is going to run.  I mean, because it is declared below the if, will it never execute?  Will it always execute as the name implies?  But couldn’t control flow branch before that statement is hit?  It’s a context switch I don’t have to make with `defer` as it currently stands.<br></p><p>&gt; On Jan 2, 2016, at 7:25 AM, Maury Markowitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;m confused about &#39;defer&#39;. Not the purpose, the chosen syntax. <br>&gt; <br>&gt; func confusing() {<br>&gt;    print(&quot;1&quot;)<br>&gt;    defer { print(&quot;2&quot;) }<br>&gt;    print(&quot;3&quot;)<br>&gt; }<br>&gt; <br>&gt; Produces 1,3,2. Trying to describe what is happening here is non-trivial... it runs line 1, then we put line 2 on a stack, then line three runs, then we pop the stack... what?! And stepping through it in the debugger... ugh.<br>&gt; <br>&gt; Unless I missed something obvious, wouldn&#39;t placing &quot;code that always has to run at the end&quot; actually *at the end* not make more sense? Like this...<br>&gt; <br>&gt; func clear() {<br>&gt;    print(&quot;1&quot;)<br>&gt;    print(&quot;3&quot;)<br>&gt; <br>&gt;    always { print(&quot;2&quot;) }<br>&gt; }<br>&gt; <br>&gt; Not only is the code clearly expressing its intent, the actual execution is following the source.<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
