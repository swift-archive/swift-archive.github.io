<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>union types</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>December 11, 2015 at 05:00:00pm</p></header><div class="content"><p>This is not really a well-thought-out proposal, but more of a brainstorm about if there is a good language-level solution.<br></p><p>A problem I frequently run into in Swift is the inability to use generic types as first-class &quot;complete&quot; types.<br></p><p>Let&#39;s say that I have a protocol (with an associated types) and some structs that implement it (with different associated types).<br></p><p>//all good feature requests involve factories<br></p><p>protocol Factory {<br>    typealias Product<br>    func make() -&gt; Product<br>    var description : String { get }<br>}<br></p><p>struct IntFactory : Factory {<br>    typealias product = Int<br>    func make() -&gt; Int { return 0 }<br>    var description : String { get { return &quot;IntFactory&quot; } }<br>}<br></p><p>struct StringFactory : Factory {<br>    typealias product = String<br>    func make() -&gt; String { return &quot;Hello world&quot; }<br>    var description : String { get { return &quot;StringFactory&quot; } }<br>}<br></p><p>Now it is easy to work on the underlying IntFactory and StringFactory:<br></p><p>IntFactory().make() //static dispatch<br>StringFactory().make() //static dispatch<br></p><p>...but how do I write a function that works on either Factory?  <br></p><p>func foo(a: Factory) {<br>    a.make() //dynamic dispatch<br>}  <br>error: protocol &#39;Factory&#39; can only be used as a generic constraint because it has Self or associated type requirements<br></p><p>I could use generics:<br></p><p>func foo&lt;A: Factory&gt;(a: A) {}<br></p><p>but now I need to bubble up generics all over the stack frame:<br></p><p>func baz&lt;A: Factory&gt;(a: A){bar(a)}<br>func bar&lt;A: Factory&gt;(a: A){foo(a)}<br>func foo&lt;A: Factory&gt;(a: A) {a.make()}<br></p><p>class WhyIsthisGeneric&lt;A: Factory&gt; {<br>    var a: A //because of an implementation detail of Factory, of course<br>}<br></p><p>I submit that this couples the implementation details of Factory too tightly to unrelated functions and methods (and perhaps entire classes that now become generic so I can create ivars).<br></p><p>Here&#39;s what I think is an elegant solution:<br></p><p>typealias EitherFactory = union(Factory, [IntFactory, StringFactory])<br>let a : EitherFactory = IntFactory()<br>func baz(a: EitherFactory){bar(a)}<br>func bar(a: EitherFactory){foo(a)}<br>func foo(a: EitherFactory){a.make()}<br></p><p>The union function being a new builtin, that causes the compiler to automatically write this type behind the scenes:<br></p><p>enum EitherFactory {<br>    case intFactory(IntFactory)<br>    case stringFactory(StringFactory)<br>    <br>    func make() -&gt; Any {<br>        switch(self) {<br>        case .intFactory(let f):<br>            return f.make()<br>        case .stringFactory(let f):<br>            return f.make()<br>        }<br>    }<br>    <br>    var description : String {<br>        get {<br>            switch(self) {<br>            case .intFactory(let f):<br>                return f.description<br>            case .stringFactory(let f):<br>                return f.description<br>            }<br>        }<br>    }<br></p><p>    var intFactory? : IntFactory {<br>        switch(self) {<br>            case .intFactory(let f):<br>            return f<br>            default:<br>            return nil<br>        }<br>    }<br>    var stringFactory? : StringFactory {<br>        switch(self) {<br>            case .StringFactory(let f):<br>            return f<br>            default:<br>            return nil<br>        }<br>    }<br>}<br></p><p>This generated type is fully-specified, and so it may be used in any place a first-class type is allowed.<br></p><p>Arguments in favor of this proposal:<br></p><p>1.  It allows protocols with Self or associated type constraints to be promoted to &quot;full&quot; types in many practical usecases, (specifically, when the list of types can be enumerated, and this is always the case for protocols with private or internal visibility).  <br>2.  It allows the user to opt into the simplicity of dynamic dispatch with their generic types<br>3.  Since the boilerplate is automatically generated, it updates automatically for new functions and methods added to the protocol, whereas my current solution is tedious, manual, and error-prone<br>4.  The semantics allow for a (future) optimizer to optimize away the boilerplate.  For example, if we write<br></p><p>let a: EitherFactory = IntFactory()<br>func foo(a: EitherFactory){a.make()}<br>foo(a)<br></p><p>     Our optimizer may emit a specialization &quot;as if&quot; I had bubbled generics:<br></p><p>let a: IntFactory = IntFactory()<br>func foo_specialized_intFactory (a: IntFactory){a.make()}<br>foo_specialized_intFactory(a)<br></p><p><br>    Under this optimization the switch statement and the dynamic dispatch are eliminated.  So the semantics allow &quot;at least&quot; dynamic dispatch performance, and &quot;up to&quot; static dispatch performance, given a strong optimizer<br></p><p>Motivating case:<br></p><p>This proposal arises (most recently) from the problem of trying to write code that is generic across IPv4 and IPv6.  For example<br></p><p>final class Socket {<br>    func getsockname() -&gt; ???<br>}<br></p><p>In the IPv4 case this function should return `sockaddr_in`, but in the v6 case it should return `sockaddr_in6`.  So this socket can only be represented as a protocol with associated type requirements, and so it cannot be trivially used e.g. as a function parameter, as an ivar, etc.  This significantly complicates the implementation.<br></p><p>Incompleteness:<br></p><p>The full semantics of the union builtin are underspecified.  <br></p><p>1.  In the example, `make() -&gt; Int` and `make() -&gt; String` unify to `make() -&gt; Any`, but would `sequence() -&gt; CollectionType` and `sequence() -&gt; SequenceType` unify to  `sequence() -&gt; Any`?  Perhaps not.<br>2.  What is the behavior if the arguments/return values of a function are themselves unions?<br></p><p>And finally, would it be a better idea merely to promote generics to &quot;full&quot; types, without the use of an explicit union builtin?  The approach here is more narrowly tailored, but that is not necessarily the right language design.<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/3c09c37d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>union types</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December 11, 2015 at 03:00:00pm</p></header><div class="content"><p>On Fri, Dec 11, 2015 at 3:22 PM, Drew Crawford via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;     func make() -&gt; Any {<br>&gt;<br>&gt;<br>What about parameter types that you erase, would you downcast and trap in<br>case of mismatch?<br></p><p>Did you look at AnySequence and other related types that implement a<br>similar pattern manually?<br></p><p>How do you expect people will use the result of such an operation in<br>practice?  The type being &#39;Any&#39; makes it completely opaque.<br></p><p>Motivating case:<br>&gt;<br>&gt; This proposal arises (most recently) from the problem of trying to write<br>&gt; code that is generic across IPv4 and IPv6.  For example<br>&gt;<br>&gt; final class Socket {<br>&gt;     func getsockname() -&gt; ???<br>&gt; }<br>&gt;<br>&gt;<br>&gt; In the IPv4 case this function should return `sockaddr_in`, but in the v6<br>&gt; case it should return `sockaddr_in6`.  So this socket can only be<br>&gt; represented as a protocol with associated type requirements, and so it<br>&gt; cannot be trivially used e.g. as a function parameter, as an ivar, etc.<br>&gt; This significantly complicates the implementation.<br>&gt;<br></p><p>If your library is a high-level one, I definitely wouldn&#39;t want to see it<br>return &#39;Any&#39; from Socket methods.  Instead, a library should erase the<br>differences between transport mechanisms in the high-level API, while still<br>providing a low-level API for those who need it, as well as for the<br>implementation of the high-level API.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/86a6da1d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>union types</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>December 11, 2015 at 06:00:00pm</p></header><div class="content"><p>&gt; How do you expect people will use the result of such an operation in practice?  The type being &#39;Any&#39; makes it completely opaque.<br></p><p>&gt; If your library is a high-level one, I definitely wouldn&#39;t want to see it return &#39;Any&#39; from Socket methods.  Instead, a library should erase the differences between transport mechanisms in the high-level API, while still providing a low-level API for those who need it, as well as for the implementation of the high-level API.<br></p><p>Perhaps it would be better to recursively unify parameters/returns into their own unions, such that<br></p><p>final class Socket {<br>    func getsockname() -&gt; union(Any, [sockaddr_in, sockaddr_in6])<br>}<br></p><p>&gt; Did you look at AnySequence and other related types that implement a similar pattern manually?<br></p><p><br>AnySequence has a different motivation.  In AnySequence, the underlying type is fully erased, or alternately, the underlying type is an element from an open set.  This is appropriate for a public API where the user may create their own types unknown to the library author which need to be erased.<br></p><p>In a union, the underlying type is only partially erased, or alternately, the underlying type is an element from a closed enumeration.  This is appropriate for a private/internal API where the types are known at compile time.<br></p><p>I suspect it would be difficult to automatically unify an *open* set of types, which is why AnySequence et al are manually maintained.  But unifying a *closed* set of types can be implemented in a preprocessor.  So unification is much more appropriate in this case.<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/82d9d812/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>union types</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 11, 2015 at 07:00:00pm</p></header><div class="content"><p>&gt; On Dec 11, 2015, at 3:22 PM, Drew Crawford via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This is not really a well-thought-out proposal, but more of a brainstorm about if there is a good language-level solution.<br>&gt; <br>&gt; A problem I frequently run into in Swift is the inability to use generic types as first-class &quot;complete&quot; types.<br>&gt; <br>&gt; Let&#39;s say that I have a protocol (with an associated types) and some structs that implement it (with different associated types).<br>&gt; <br>&gt; //all good feature requests involve factories<br>&gt; <br>&gt; protocol Factory {<br>&gt;     typealias Product<br>&gt;     func make() -&gt; Product<br>&gt;     var description : String { get }<br>&gt; }<br>&gt; <br>&gt; struct IntFactory : Factory {<br>&gt;     typealias product = Int<br>&gt;     func make() -&gt; Int { return 0 }<br>&gt;     var description : String { get { return &quot;IntFactory&quot; } }<br>&gt; }<br>&gt; <br>&gt; struct StringFactory : Factory {<br>&gt;     typealias product = String<br>&gt;     func make() -&gt; String { return &quot;Hello world&quot; }<br>&gt;     var description : String { get { return &quot;StringFactory&quot; } }<br>&gt; }<br></p><p>This seems like it would be addressed just by allowing Factory to be used as a dynamic type, with its Product type generalized to Any. We&#39;ll be set up to support that with some runtime work to store associated types in protocol witness tables (which is also necessary to fix cyclic conformances, one of our Swift 3 goals).<br></p><p>-Joe<br></p><p>&gt; Now it is easy to work on the underlying IntFactory and StringFactory:<br>&gt; <br>&gt; IntFactory().make() //static dispatch<br>&gt; StringFactory().make() //static dispatch<br>&gt; <br>&gt; ...but how do I write a function that works on either Factory?  <br>&gt; <br>&gt; func foo(a: Factory) {<br>&gt;     a.make() //dynamic dispatch<br>&gt; }  <br>&gt; error: protocol &#39;Factory&#39; can only be used as a generic constraint because it has Self or associated type requirements<br>&gt; <br>&gt; I could use generics:<br>&gt; <br>&gt; func foo&lt;A: Factory&gt;(a: A) {}<br>&gt; <br>&gt; but now I need to bubble up generics all over the stack frame:<br>&gt; <br>&gt; func baz&lt;A: Factory&gt;(a: A){bar(a)}<br>&gt; func bar&lt;A: Factory&gt;(a: A){foo(a)}<br>&gt; func foo&lt;A: Factory&gt;(a: A) {a.make()}<br>&gt; <br>&gt; class WhyIsthisGeneric&lt;A: Factory&gt; {<br>&gt;     var a: A //because of an implementation detail of Factory, of course<br>&gt; }<br>&gt; <br>&gt; I submit that this couples the implementation details of Factory too tightly to unrelated functions and methods (and perhaps entire classes that now become generic so I can create ivars).<br>&gt; <br>&gt; Here&#39;s what I think is an elegant solution:<br>&gt; <br>&gt; typealias EitherFactory = union(Factory, [IntFactory, StringFactory])<br>&gt; let a : EitherFactory = IntFactory()<br>&gt; func baz(a: EitherFactory){bar(a)}<br>&gt; func bar(a: EitherFactory){foo(a)}<br>&gt; func foo(a: EitherFactory){a.make()}<br>&gt; <br>&gt; The union function being a new builtin, that causes the compiler to automatically write this type behind the scenes:<br>&gt; <br>&gt; enum EitherFactory {<br>&gt;     case intFactory(IntFactory)<br>&gt;     case stringFactory(StringFactory)<br>&gt;     <br>&gt;     func make() -&gt; Any {<br>&gt;         switch(self) {<br>&gt;         case .intFactory(let f):<br>&gt;             return f.make()<br>&gt;         case .stringFactory(let f):<br>&gt;             return f.make()<br>&gt;         }<br>&gt;     }<br>&gt;     <br>&gt;     var description : String {<br>&gt;         get {<br>&gt;             switch(self) {<br>&gt;             case .intFactory(let f):<br>&gt;                 return f.description<br>&gt;             case .stringFactory(let f):<br>&gt;                 return f.description<br>&gt;             }<br>&gt;         }<br>&gt;     }<br>&gt; <br>&gt;     var intFactory? : IntFactory {<br>&gt;         switch(self) {<br>&gt;             case .intFactory(let f):<br>&gt;             return f<br>&gt;             default:<br>&gt;             return nil<br>&gt;         }<br>&gt;     }<br>&gt;     var stringFactory? : StringFactory {<br>&gt;         switch(self) {<br>&gt;             case .StringFactory(let f):<br>&gt;             return f<br>&gt;             default:<br>&gt;             return nil<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; This generated type is fully-specified, and so it may be used in any place a first-class type is allowed.<br>&gt; <br>&gt; Arguments in favor of this proposal:<br>&gt; <br>&gt; 1.  It allows protocols with Self or associated type constraints to be promoted to &quot;full&quot; types in many practical usecases, (specifically, when the list of types can be enumerated, and this is always the case for protocols with private or internal visibility).  <br>&gt; 2.  It allows the user to opt into the simplicity of dynamic dispatch with their generic types<br>&gt; 3.  Since the boilerplate is automatically generated, it updates automatically for new functions and methods added to the protocol, whereas my current solution is tedious, manual, and error-prone<br>&gt; 4.  The semantics allow for a (future) optimizer to optimize away the boilerplate.  For example, if we write<br>&gt; <br>&gt; let a: EitherFactory = IntFactory()<br>&gt; func foo(a: EitherFactory){a.make()}<br>&gt; foo(a)<br>&gt; <br>&gt;      Our optimizer may emit a specialization &quot;as if&quot; I had bubbled generics:<br>&gt; <br>&gt; let a: IntFactory = IntFactory()<br>&gt; func foo_specialized_intFactory (a: IntFactory){a.make()}<br>&gt; foo_specialized_intFactory(a)<br>&gt; <br>&gt; <br>&gt;     Under this optimization the switch statement and the dynamic dispatch are eliminated.  So the semantics allow &quot;at least&quot; dynamic dispatch performance, and &quot;up to&quot; static dispatch performance, given a strong optimizer<br>&gt; <br>&gt; Motivating case:<br>&gt; <br>&gt; This proposal arises (most recently) from the problem of trying to write code that is generic across IPv4 and IPv6.  For example<br>&gt; <br>&gt; final class Socket {<br>&gt;     func getsockname() -&gt; ???<br>&gt; }<br>&gt; <br>&gt; In the IPv4 case this function should return `sockaddr_in`, but in the v6 case it should return `sockaddr_in6`.  So this socket can only be represented as a protocol with associated type requirements, and so it cannot be trivially used e.g. as a function parameter, as an ivar, etc.  This significantly complicates the implementation.<br>&gt; <br>&gt; Incompleteness:<br>&gt; <br>&gt; The full semantics of the union builtin are underspecified.  <br>&gt; <br>&gt; 1.  In the example, `make() -&gt; Int` and `make() -&gt; String` unify to `make() -&gt; Any`, but would `sequence() -&gt; CollectionType` and `sequence() -&gt; SequenceType` unify to  `sequence() -&gt; Any`?  Perhaps not.<br>&gt; 2.  What is the behavior if the arguments/return values of a function are themselves unions?<br>&gt; <br>&gt; And finally, would it be a better idea merely to promote generics to &quot;full&quot; types, without the use of an explicit union builtin?  The approach here is more narrowly tailored, but that is not necessarily the right language design.<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/a39c9aa7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>union types</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>December 11, 2015 at 09:00:00pm</p></header><div class="content"><p>&gt; On Dec 11, 2015, at 9:01 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; with its Product type generalized to Any. <br></p><p><br>In the alternate example<br></p><p>protocol Factory {<br>    typealias Product: ProductProtocol<br>    func make() -&gt; Product<br>    var description : String { get }<br>}<br></p><p>would it generalize to ProductProtocol (e.g. not Any)?<br></p><p>That is potentially a good solution, especially if compatible with existing Swift 3 work.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/becf92db/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>union types</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 11, 2015 at 07:00:00pm</p></header><div class="content"><p>&gt; On Dec 11, 2015, at 7:48 PM, Drew Crawford &lt;drew at sealedabstract.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 11, 2015, at 9:01 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; with its Product type generalized to Any. <br>&gt; <br>&gt; <br>&gt; In the alternate example<br>&gt; <br>&gt; protocol Factory {<br>&gt;     typealias Product: ProductProtocol<br>&gt;     func make() -&gt; Product<br>&gt;     var description : String { get }<br>&gt; }<br>&gt; <br>&gt; would it generalize to ProductProtocol (e.g. not Any)?<br></p><p>Yeah, when generalizing a protocol type, we ought to be able to either generalize the associated types to their upper bounds, for use cases like yours, or constrain them to specific types, for the AnyGenerator&lt;T&gt; kind of case.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/11a4adaa/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>union types</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>December 12, 2015 at 02:00:00pm</p></header><div class="content"><p>Type-erasure to the rescue? Links back to our twitter discussions Joe.<br>David.<br></p><p>&gt; On 12 Dec 2015, at 04:53, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 11, 2015, at 7:48 PM, Drew Crawford &lt;drew at sealedabstract.com &lt;mailto:drew at sealedabstract.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 11, 2015, at 9:01 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; with its Product type generalized to Any. <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; In the alternate example<br>&gt;&gt; <br>&gt;&gt; protocol Factory {<br>&gt;&gt;     typealias Product: ProductProtocol<br>&gt;&gt;     func make() -&gt; Product<br>&gt;&gt;     var description : String { get }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; would it generalize to ProductProtocol (e.g. not Any)?<br>&gt; <br>&gt; Yeah, when generalizing a protocol type, we ought to be able to either generalize the associated types to their upper bounds, for use cases like yours, or constrain them to specific types, for the AnyGenerator&lt;T&gt; kind of case.<br>&gt; <br>&gt; -Joe<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151212/de1cd806/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>union types</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 12, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; Yeah, when generalizing a protocol type, we ought to be able to either generalize the associated types to their upper bounds, for use cases like yours, or constrain them to specific types, for the AnyGenerator&lt;T&gt; kind of case.<br></p><p>I&#39;m really glad to see that this is planned as part of the Swift 3 generics work.<br></p><p>Will you also be able to support constraints relating more than one associated type?  Something like protocol&lt;P where P.Associated == P.Other.Associated&gt;?  And a further generalization to protocol&lt;P, Q where P.Associated == Q.Associated&gt;?  <br></p><p>Will you also support protocol types that are partially bound allowing use of members that do not reference the unbound associated types?<br></p><p>Matthew<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
