<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>Renaming for Protocol Conformance</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>August 22, 2016 at 09:00:00pm</p></header><div class="content"><p>Hi everyone,<br></p><p>We talked about this before when we were discussing mixins, and there seemed to be generally positive feelings towards it as a feature for the future.  I am fairly certain this affects the ABI though, so I thought I would bring it up now.<br></p><p>If two protocols have methods/properties with the same name, but different signatures, we need a way to distinguish between them when attempting to conform to both.<br></p><p>	protocol A {<br>		var x:Int {get set}<br>	}<br></p><p>	protocol B {<br>		var x:Double {get set}<br>	}<br></p><p>One possibility is to allow a struct/class/enum to conform to the protocol while renaming one (or both) of the clashing methods:<br></p><p>	struct C: A,B {<br>		var x:Int<br>		var y:Double implements B.x<br>	}<br></p><p>The conforming method/property would still have to have the same signature, but could have a different name (and parameter labels).  It would also allow protocol methods which have identical signatures and semantics, but different names to be implemented using the same method (i.e ‘implements D.z &amp; E.w’).<br></p><p>When something is cast to the protocol (say ‘as B’), then calling the property (e.g. ‘x’) would end up calling the implementation of the renamed property ( ‘y’ in this example) on the conforming type.<br></p><p>I think we would also want a way to retroactively conform using existing properties/methods in an extension declaring conformance.  Not sure what the best syntax for that would be.  Off the top of my head (though I would love to have something with less cruft):<br></p><p>	extension D:B {<br>		@conform(to: B.x, with: D.y)<br>	}<br></p><p>or maybe just:<br>	<br>	extension D:B {<br>		D.y implements B.x<br>	}<br>	<br></p><p>All of this is merely to start the discussion, so feel free to propose better syntax or a more elegant solution...<br></p><p>Thoughts?<br></p><p>Thanks,<br>Jon<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Renaming for Protocol Conformance</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>August 23, 2016 at 12:00:00am</p></header><div class="content"><p>I was just thinking about proposing something like this.<br></p><p>+1.<br></p><p>Charles<br></p><p>&gt; On Aug 22, 2016, at 11:59 PM, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi everyone,<br>&gt; <br>&gt; We talked about this before when we were discussing mixins, and there seemed to be generally positive feelings towards it as a feature for the future.  I am fairly certain this affects the ABI though, so I thought I would bring it up now.<br>&gt; <br>&gt; If two protocols have methods/properties with the same name, but different signatures, we need a way to distinguish between them when attempting to conform to both.<br>&gt; <br>&gt; 	protocol A {<br>&gt; 		var x:Int {get set}<br>&gt; 	}<br>&gt; <br>&gt; 	protocol B {<br>&gt; 		var x:Double {get set}<br>&gt; 	}<br>&gt; <br>&gt; One possibility is to allow a struct/class/enum to conform to the protocol while renaming one (or both) of the clashing methods:<br>&gt; <br>&gt; 	struct C: A,B {<br>&gt; 		var x:Int<br>&gt; 		var y:Double implements B.x<br>&gt; 	}<br>&gt; <br>&gt; The conforming method/property would still have to have the same signature, but could have a different name (and parameter labels).  It would also allow protocol methods which have identical signatures and semantics, but different names to be implemented using the same method (i.e ‘implements D.z &amp; E.w’).<br>&gt; <br>&gt; When something is cast to the protocol (say ‘as B’), then calling the property (e.g. ‘x’) would end up calling the implementation of the renamed property ( ‘y’ in this example) on the conforming type.<br>&gt; <br>&gt; I think we would also want a way to retroactively conform using existing properties/methods in an extension declaring conformance.  Not sure what the best syntax for that would be.  Off the top of my head (though I would love to have something with less cruft):<br>&gt; <br>&gt; 	extension D:B {<br>&gt; 		@conform(to: B.x, with: D.y)<br>&gt; 	}<br>&gt; <br>&gt; or maybe just:<br>&gt; 	<br>&gt; 	extension D:B {<br>&gt; 		D.y implements B.x<br>&gt; 	}<br>&gt; 	<br>&gt; <br>&gt; All of this is merely to start the discussion, so feel free to propose better syntax or a more elegant solution...<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; Thanks,<br>&gt; Jon<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>Renaming for Protocol Conformance</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>August 23, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; On 23 Aug 2016, at 06:59, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi everyone,<br>&gt; <br>&gt; We talked about this before when we were discussing mixins, and there seemed to be generally positive feelings towards it as a feature for the future.  I am fairly certain this affects the ABI though, so I thought I would bring it up now.<br>&gt; <br>&gt; If two protocols have methods/properties with the same name, but different signatures, we need a way to distinguish between them when attempting to conform to both.<br>&gt; <br>&gt; 	protocol A {<br>&gt; 		var x:Int {get set}<br>&gt; 	}<br>&gt; <br>&gt; 	protocol B {<br>&gt; 		var x:Double {get set}<br>&gt; 	}<br>&gt; <br>&gt; One possibility is to allow a struct/class/enum to conform to the protocol while renaming one (or both) of the clashing methods:<br>&gt; <br>&gt; 	struct C: A,B {<br>&gt; 		var x:Int<br>&gt; 		var y:Double implements B.x<br>&gt; 	}<br>&gt; <br>&gt; The conforming method/property would still have to have the same signature, but could have a different name (and parameter labels).  It would also allow protocol methods which have identical signatures and semantics, but different names to be implemented using the same method (i.e ‘implements D.z &amp; E.w’).<br>&gt; <br>&gt; When something is cast to the protocol (say ‘as B’), then calling the property (e.g. ‘x’) would end up calling the implementation of the renamed property ( ‘y’ in this example) on the conforming type.<br>&gt; <br>&gt; I think we would also want a way to retroactively conform using existing properties/methods in an extension declaring conformance.  Not sure what the best syntax for that would be.  Off the top of my head (though I would love to have something with less cruft):<br>&gt; <br>&gt; 	extension D:B {<br>&gt; 		@conform(to: B.x, with: D.y)<br>&gt; 	}<br>&gt; <br>&gt; or maybe just:<br>&gt; 	<br>&gt; 	extension D:B {<br>&gt; 		D.y implements B.x<br>&gt; 	}<br>&gt; 	<br>&gt; <br>&gt; All of this is merely to start the discussion, so feel free to propose better syntax or a more elegant solution...<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; Thanks,<br>&gt; Jon<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>What about if we synthesised members on the conforming type? So I’m thinking<br></p><p>  protocol MyProtoOne {<br>  	func doSomething()<br>  }<br></p><p>  protocol MyProtoTwo {<br>  	func doSomething()<br>  }<br></p><p>  struct ImplementsOne : MyProtoOne {<br>  	func doSomething() {<br>  		// Unambiguous. Satisfies MyProtoOne.<br>  	}<br>  }<br></p><p>  struct ImplementsBoth : MyProtoOne, MyProtoTwo {<br>  	<br>  	func MyProtoOne.doSomething() {<br>  		// Or some other declaration modifier to say this for MyProtoOne<br>  	}<br></p><p>  	func MyProtoTwo.doSomething() {<br>  		// ...<br>  	}<br>  }<br></p><p>ImplementsOne().doSomething() // unambiguous intention at call-site<br>ImplementsBoth().MyProtoOne.doSomething() // intention at call-site must be explicit. What kind of thing do you want to look at ImplementsBoth() as?<br>ImplementsBoth().MyProtoTwo.doSomething()<br></p><p>I think this would be relatively simple to implement. We just disambiguate at declaration site, and the synthesised members ImplementsBoth().MyProto{One/Two} are the protocol-witness tables to disambiguate at the call-site.<br></p><p>The thing is that we would need to mangle those names differently, and for ABI resilience (the ability to add a protocol with a conflicting name later) that would mean also mangling the protocol name in to the non-conflicting cases (ImplementsOne.MyProtoOne.doSomething). That means if you had ImplementsOne.doSomething in v1 and added the MyProtoOne protocol in v1.1, you would need to add a plain doSomething() method which doesn’t belong to a protocol.<br></p><p>That’s the thing — members would kind of “belong” to the protocol conformance on the type, rather than being plain top-level members on the type itself (although as long as there are no conflicts, you could use them as such and the compiler would know which members you mean). That may be beneficial for mixins.<br></p><p>Karl<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>Renaming for Protocol Conformance</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>August 23, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; On 23 Aug 2016, at 07:39, Karl &lt;raziel.im+swift-evo at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 23 Aug 2016, at 06:59, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi everyone,<br>&gt;&gt; <br>&gt;&gt; We talked about this before when we were discussing mixins, and there seemed to be generally positive feelings towards it as a feature for the future.  I am fairly certain this affects the ABI though, so I thought I would bring it up now.<br>&gt;&gt; <br>&gt;&gt; If two protocols have methods/properties with the same name, but different signatures, we need a way to distinguish between them when attempting to conform to both.<br>&gt;&gt; <br>&gt;&gt; 	protocol A {<br>&gt;&gt; 		var x:Int {get set}<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; 	protocol B {<br>&gt;&gt; 		var x:Double {get set}<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; One possibility is to allow a struct/class/enum to conform to the protocol while renaming one (or both) of the clashing methods:<br>&gt;&gt; <br>&gt;&gt; 	struct C: A,B {<br>&gt;&gt; 		var x:Int<br>&gt;&gt; 		var y:Double implements B.x<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; The conforming method/property would still have to have the same signature, but could have a different name (and parameter labels).  It would also allow protocol methods which have identical signatures and semantics, but different names to be implemented using the same method (i.e ‘implements D.z &amp; E.w’).<br>&gt;&gt; <br>&gt;&gt; When something is cast to the protocol (say ‘as B’), then calling the property (e.g. ‘x’) would end up calling the implementation of the renamed property ( ‘y’ in this example) on the conforming type.<br>&gt;&gt; <br>&gt;&gt; I think we would also want a way to retroactively conform using existing properties/methods in an extension declaring conformance.  Not sure what the best syntax for that would be.  Off the top of my head (though I would love to have something with less cruft):<br>&gt;&gt; <br>&gt;&gt; 	extension D:B {<br>&gt;&gt; 		@conform(to: B.x, with: D.y)<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; or maybe just:<br>&gt;&gt; 	<br>&gt;&gt; 	extension D:B {<br>&gt;&gt; 		D.y implements B.x<br>&gt;&gt; 	}<br>&gt;&gt; 	<br>&gt;&gt; <br>&gt;&gt; All of this is merely to start the discussion, so feel free to propose better syntax or a more elegant solution...<br>&gt;&gt; <br>&gt;&gt; Thoughts?<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; Jon<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; What about if we synthesised members on the conforming type? So I’m thinking<br>&gt; <br>&gt;  protocol MyProtoOne {<br>&gt;  	func doSomething()<br>&gt;  }<br>&gt; <br>&gt;  protocol MyProtoTwo {<br>&gt;  	func doSomething()<br>&gt;  }<br>&gt; <br>&gt;  struct ImplementsOne : MyProtoOne {<br>&gt;  	func doSomething() {<br>&gt;  		// Unambiguous. Satisfies MyProtoOne.<br>&gt;  	}<br>&gt;  }<br>&gt; <br>&gt;  struct ImplementsBoth : MyProtoOne, MyProtoTwo {<br>&gt;  	<br>&gt;  	func MyProtoOne.doSomething() {<br>&gt;  		// Or some other declaration modifier to say this for MyProtoOne<br>&gt;  	}<br>&gt; <br>&gt;  	func MyProtoTwo.doSomething() {<br>&gt;  		// ...<br>&gt;  	}<br>&gt;  }<br>&gt; <br>&gt; ImplementsOne().doSomething() // unambiguous intention at call-site<br>&gt; ImplementsBoth().MyProtoOne.doSomething() // intention at call-site must be explicit. What kind of thing do you want to look at ImplementsBoth() as?<br>&gt; ImplementsBoth().MyProtoTwo.doSomething()<br>&gt; <br>&gt; I think this would be relatively simple to implement. We just disambiguate at declaration site, and the synthesised members ImplementsBoth().MyProto{One/Two} are the protocol-witness tables to disambiguate at the call-site.<br>&gt; <br></p><p><br>&gt; The thing is that we would need to mangle those names differently, and for ABI resilience (the ability to add a protocol with a conflicting name later) that would mean also mangling the protocol name in to the non-conflicting cases (ImplementsOne.MyProtoOne.doSomething). That means if you had ImplementsOne.doSomething in v1 and added the MyProtoOne protocol in v1.1, you would need to add a plain doSomething() method which doesn’t belong to a protocol.<br>&gt; <br>&gt; That’s the thing — members would kind of “belong” to the protocol conformance on the type, rather than being plain top-level members on the type itself (although as long as there are no conflicts, you could use them as such and the compiler would know which members you mean). That may be beneficial for mixins.<br>&gt; <br>&gt; Karl<br>&gt; <br></p><p>Actually, reading the next thread: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160822/026524.html<br></p><p>This could even be a feature.<br></p><p>Karl<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Renaming for Protocol Conformance</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>August 23, 2016 at 11:00:00am</p></header><div class="content"><p>C# does something similar to this - you can implement an interface without having the implementation methods published on the object. You must cast/box to the interface in order to access those methods.<br></p><p>This is used for instance to support both the generic and non-generic interfaces for dictionaries in the same class.<br></p><p>I don’t know if an object should expose either method with the same name as the parent protocols if they conflict - I would imagine someone being burned by getting incorrect behavior, and I’m trying to think if there would be interesting semantics with generic code.<br></p><p>-DW<br></p><p>&gt; On Aug 22, 2016, at 11:39 PM, Karl via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 23 Aug 2016, at 06:59, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi everyone,<br>&gt;&gt; <br>&gt;&gt; We talked about this before when we were discussing mixins, and there seemed to be generally positive feelings towards it as a feature for the future.  I am fairly certain this affects the ABI though, so I thought I would bring it up now.<br>&gt;&gt; <br>&gt;&gt; If two protocols have methods/properties with the same name, but different signatures, we need a way to distinguish between them when attempting to conform to both.<br>&gt;&gt; <br>&gt;&gt; 	protocol A {<br>&gt;&gt; 		var x:Int {get set}<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; 	protocol B {<br>&gt;&gt; 		var x:Double {get set}<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; One possibility is to allow a struct/class/enum to conform to the protocol while renaming one (or both) of the clashing methods:<br>&gt;&gt; <br>&gt;&gt; 	struct C: A,B {<br>&gt;&gt; 		var x:Int<br>&gt;&gt; 		var y:Double implements B.x<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; The conforming method/property would still have to have the same signature, but could have a different name (and parameter labels).  It would also allow protocol methods which have identical signatures and semantics, but different names to be implemented using the same method (i.e ‘implements D.z &amp; E.w’).<br>&gt;&gt; <br>&gt;&gt; When something is cast to the protocol (say ‘as B’), then calling the property (e.g. ‘x’) would end up calling the implementation of the renamed property ( ‘y’ in this example) on the conforming type.<br>&gt;&gt; <br>&gt;&gt; I think we would also want a way to retroactively conform using existing properties/methods in an extension declaring conformance.  Not sure what the best syntax for that would be.  Off the top of my head (though I would love to have something with less cruft):<br>&gt;&gt; <br>&gt;&gt; 	extension D:B {<br>&gt;&gt; 		@conform(to: B.x, with: D.y)<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; or maybe just:<br>&gt;&gt; 	<br>&gt;&gt; 	extension D:B {<br>&gt;&gt; 		D.y implements B.x<br>&gt;&gt; 	}<br>&gt;&gt; 	<br>&gt;&gt; <br>&gt;&gt; All of this is merely to start the discussion, so feel free to propose better syntax or a more elegant solution...<br>&gt;&gt; <br>&gt;&gt; Thoughts?<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; Jon<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; What about if we synthesised members on the conforming type? So I’m thinking<br>&gt; <br>&gt;  protocol MyProtoOne {<br>&gt;  	func doSomething()<br>&gt;  }<br>&gt; <br>&gt;  protocol MyProtoTwo {<br>&gt;  	func doSomething()<br>&gt;  }<br>&gt; <br>&gt;  struct ImplementsOne : MyProtoOne {<br>&gt;  	func doSomething() {<br>&gt;  		// Unambiguous. Satisfies MyProtoOne.<br>&gt;  	}<br>&gt;  }<br>&gt; <br>&gt;  struct ImplementsBoth : MyProtoOne, MyProtoTwo {<br>&gt;  	<br>&gt;  	func MyProtoOne.doSomething() {<br>&gt;  		// Or some other declaration modifier to say this for MyProtoOne<br>&gt;  	}<br>&gt; <br>&gt;  	func MyProtoTwo.doSomething() {<br>&gt;  		// ...<br>&gt;  	}<br>&gt;  }<br>&gt; <br>&gt; ImplementsOne().doSomething() // unambiguous intention at call-site<br>&gt; ImplementsBoth().MyProtoOne.doSomething() // intention at call-site must be explicit. What kind of thing do you want to look at ImplementsBoth() as?<br>&gt; ImplementsBoth().MyProtoTwo.doSomething()<br>&gt; <br>&gt; I think this would be relatively simple to implement. We just disambiguate at declaration site, and the synthesised members ImplementsBoth().MyProto{One/Two} are the protocol-witness tables to disambiguate at the call-site.<br>&gt; <br>&gt; The thing is that we would need to mangle those names differently, and for ABI resilience (the ability to add a protocol with a conflicting name later) that would mean also mangling the protocol name in to the non-conflicting cases (ImplementsOne.MyProtoOne.doSomething). That means if you had ImplementsOne.doSomething in v1 and added the MyProtoOne protocol in v1.1, you would need to add a plain doSomething() method which doesn’t belong to a protocol.<br>&gt; <br>&gt; That’s the thing — members would kind of “belong” to the protocol conformance on the type, rather than being plain top-level members on the type itself (although as long as there are no conflicts, you could use them as such and the compiler would know which members you mean). That may be beneficial for mixins.<br>&gt; <br>&gt; Karl<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Renaming for Protocol Conformance</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 23, 2016 at 01:00:00am</p></header><div class="content"><p>On Mon, Aug 22, 2016 at 11:59 PM, Jonathan Hull via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi everyone,<br>&gt;<br>&gt; We talked about this before when we were discussing mixins, and there<br>&gt; seemed to be generally positive feelings towards it as a feature for the<br>&gt; future.<br></p><p><br>It&#39;s been some time now since the original discussion, so perhaps you could<br>refresh our collective memory (or at least, mine): although it *seems* like<br>this feature might be useful, I can&#39;t recall a concrete use case where I&#39;ve<br>felt like I needed this feature--do you have some examples?<br></p><p><br>&gt;   I am fairly certain this affects the ABI though, so I thought I would<br>&gt; bring it up now.<br>&gt;<br>&gt; If two protocols have methods/properties with the same name, but different<br>&gt; signatures, we need a way to distinguish between them when attempting to<br>&gt; conform to both.<br>&gt;<br>&gt;         protocol A {<br>&gt;                 var x:Int {get set}<br>&gt;         }<br>&gt;<br>&gt;         protocol B {<br>&gt;                 var x:Double {get set}<br>&gt;         }<br>&gt;<br></p><p>Methods can be overloaded that differ in arguments or return type, so it<br>seems like this problem mainly exists with *properties* that differ in<br>type--am I wrong?<br></p><p><br>&gt; One possibility is to allow a struct/class/enum to conform to the protocol<br>&gt; while renaming one (or both) of the clashing methods:<br>&gt;<br>&gt;         struct C: A,B {<br>&gt;                 var x:Int<br>&gt;                 var y:Double implements B.x<br>&gt;         }<br>&gt;<br>&gt; The conforming method/property would still have to have the same<br>&gt; signature, but could have a different name (and parameter labels).  It<br>&gt; would also allow protocol methods which have identical signatures and<br>&gt; semantics, but different names to be implemented using the same method (i.e<br>&gt; ‘implements D.z &amp; E.w’).<br>&gt;<br>&gt; When something is cast to the protocol (say ‘as B’), then calling the<br>&gt; property (e.g. ‘x’) would end up calling the implementation of the renamed<br>&gt; property ( ‘y’ in this example) on the conforming type.<br>&gt;<br></p><p>Reflecting on this proposed change, it occurs to me that something of value<br>would be lost, and I think that this something is actually rather valuable:<br></p><p>Today, when I see that a type conforms to (for example) Sequence, I know<br>that certain methods and/or properties exist on that type. Protocol<br>conformance guarantees a certain API, not just certain semantics.<br></p><p>Perhaps one way to mitigate this loss would be to have any renamed members<br>listed *in the declaration of conformance*, something like this (with some<br>additional bikeshedding):<br></p><p>```<br>struct MyGreatType : Sequence (count =&gt; length) {<br>  // MyGreatType conforms to Sequence but renames `count` to `length`<br>}<br>```<br></p><p>I think we would also want a way to retroactively conform using existing<br>&gt; properties/methods in an extension declaring conformance.  Not sure what<br>&gt; the best syntax for that would be.  Off the top of my head (though I would<br>&gt; love to have something with less cruft):<br>&gt;<br>&gt;         extension D:B {<br>&gt;                 @conform(to: B.x, with: D.y)<br>&gt;         }<br>&gt;<br>&gt; or maybe just:<br>&gt;<br>&gt;         extension D:B {<br>&gt;                 D.y implements B.x<br>&gt;         }<br>&gt;<br></p><p>If renamed members are declared along with protocol conformance, then the<br>syntax for retroactive modeling follows naturally:<br></p><p>```<br>extension D : B (x =&gt; y) { }<br>// again, the actual notation here is ugly<br>// but the underlying idea, I think, is worth considering<br>```<br></p><p>All of this is merely to start the discussion, so feel free to propose<br>&gt; better syntax or a more elegant solution...<br>&gt;<br>&gt; Thoughts?<br>&gt;<br>&gt; Thanks,<br>&gt; Jon<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160823/076d8ed2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>Renaming for Protocol Conformance</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>August 23, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; On Aug 22, 2016, at 11:32 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Mon, Aug 22, 2016 at 11:59 PM, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Hi everyone,<br>&gt; <br>&gt; We talked about this before when we were discussing mixins, and there seemed to be generally positive feelings towards it as a feature for the future.<br>&gt; <br>&gt; It&#39;s been some time now since the original discussion, so perhaps you could refresh our collective memory (or at least, mine): although it *seems* like this feature might be useful, I can&#39;t recall a concrete use case where I&#39;ve felt like I needed this feature--do you have some examples?<br></p><p>Ideally, the biggest use is that it helps to (partially) solve the diamond problem (and similar issues) by forcing/allowing disambiguation when there are multiple protocols being conformed to.  This will become more of an issue if we allow protocols or extensions to add storage.  Your proposed syntax actually does a better job of it than mine because mine was always shown as attached to some sort of implementation, whereas yours could potentially allow access to a default implementation under a new name.<br></p><p>Other than that, it generally allows us to bypass/mitigate conflicts between protocols.  In the current version, you are unable to conform to both protocols (either because it won’t compile or because you can’t satisfy the semantics of both protocols) without designing the protocols together to avoid conflicts.  (I have definitely had to go back and rename/refactor properties on a protocol for this reason… which I couldn’t have done if I didn’t control both protocols).<br></p><p>Take a look at Eiffel’s ‘rename’ &amp; ’select’ features for similar functionality and use-cases.<br></p><p>Ultimately, this is a step in the direction of having true mixins.<br></p><p><br>&gt;    I am fairly certain this affects the ABI though, so I thought I would bring it up now.<br>&gt; <br>&gt; If two protocols have methods/properties with the same name, but different signatures, we need a way to distinguish between them when attempting to conform to both.<br>&gt; <br>&gt;         protocol A {<br>&gt;                 var x:Int {get set}<br>&gt;         }<br>&gt; <br>&gt;         protocol B {<br>&gt;                 var x:Double {get set}<br>&gt;         }<br>&gt; <br>&gt; Methods can be overloaded that differ in arguments or return type, so it seems like this problem mainly exists with *properties* that differ in type--am I wrong?<br></p><p>There is also the case of functions with the same name and signature, but different semantics.  There may be no single implementation which simultaneously satisfies the semantics for both protocols. By renaming one of the functions, we are able to provide separate implementations for each requirement (which allows both protocols to function as intended).<br></p><p>There may also be functions in different protocols with different names but the same semantics and signature.  This will allow a single implementation to satisfy both protocols without duplication.<br></p><p>Finally, we may want to rename an inherited default implementation to avoid conflicting with another protocol&#39;s default implementation in cases where we don’t want to override it.<br></p><p>&gt;  One possibility is to allow a struct/class/enum to conform to the protocol while renaming one (or both) of the clashing methods:<br>&gt; <br>&gt;         struct C: A,B {<br>&gt;                 var x:Int<br>&gt;                 var y:Double implements B.x<br>&gt;         }<br>&gt; <br>&gt; The conforming method/property would still have to have the same signature, but could have a different name (and parameter labels).  It would also allow protocol methods which have identical signatures and semantics, but different names to be implemented using the same method (i.e ‘implements D.z &amp; E.w’).<br>&gt; <br>&gt; When something is cast to the protocol (say ‘as B’), then calling the property (e.g. ‘x’) would end up calling the implementation of the renamed property ( ‘y’ in this example) on the conforming type.<br>&gt; <br>&gt; Reflecting on this proposed change, it occurs to me that something of value would be lost, and I think that this something is actually rather valuable:<br>&gt; <br>&gt; Today, when I see that a type conforms to (for example) Sequence, I know that certain methods and/or properties exist on that type. Protocol conformance guarantees a certain API, not just certain semantics.<br></p><p>It isn’t actually lost, however.  When working with it as a Sequence (for example), that API would be intact using the original names.  It is only when working with it as its own type that the renaming would have an effect.<br></p><p><br>&gt; Perhaps one way to mitigate this loss would be to have any renamed members listed *in the declaration of conformance*, something like this (with some additional bikeshedding):<br>&gt; <br>&gt; ```<br>&gt; struct MyGreatType : Sequence (count =&gt; length) {<br>&gt;   // MyGreatType conforms to Sequence but renames `count` to `length`<br>&gt; }<br>&gt; ```<br></p><p>Yes, putting it in the conformance declaration is a definite possibility we should consider.<br></p><p>&gt; <br>&gt; I think we would also want a way to retroactively conform using existing properties/methods in an extension declaring conformance.  Not sure what the best syntax for that would be.  Off the top of my head (though I would love to have something with less cruft):<br>&gt; <br>&gt;         extension D:B {<br>&gt;                 @conform(to: B.x, with: D.y)<br>&gt;         }<br>&gt; <br>&gt; or maybe just:<br>&gt; <br>&gt;         extension D:B {<br>&gt;                 D.y implements B.x<br>&gt;         }<br>&gt; <br>&gt; If renamed members are declared along with protocol conformance, then the syntax for retroactive modeling follows naturally:<br>&gt; <br>&gt; ```<br>&gt; extension D : B (x =&gt; y) { }<br>&gt; // again, the actual notation here is ugly<br>&gt; // but the underlying idea, I think, is worth considering<br>&gt; ```<br></p><p>Yup<br></p><p>One thing I like about this is that it helps to solve the diamond problem.  ‘x’ could be a default implementation in B which D does not override.  I think this is an important case which my original proposal didn’t address fully.<br></p><p>We should keep bikeshedding the syntax though...<br></p><p>Thanks,<br>Jon<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160823/e6a0d82c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Renaming for Protocol Conformance</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 23, 2016 at 10:00:00am</p></header><div class="content"><p>On Tue, Aug 23, 2016 at 3:02 AM, Jonathan Hull &lt;jhull at gbis.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Aug 22, 2016, at 11:32 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Mon, Aug 22, 2016 at 11:59 PM, Jonathan Hull via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Hi everyone,<br>&gt;&gt;<br>&gt;&gt; We talked about this before when we were discussing mixins, and there<br>&gt;&gt; seemed to be generally positive feelings towards it as a feature for the<br>&gt;&gt; future.<br>&gt;<br>&gt;<br>&gt; It&#39;s been some time now since the original discussion, so perhaps you<br>&gt; could refresh our collective memory (or at least, mine): although it<br>&gt; *seems* like this feature might be useful, I can&#39;t recall a concrete use<br>&gt; case where I&#39;ve felt like I needed this feature--do you have some examples?<br>&gt;<br>&gt;<br>&gt; Ideally, the biggest use is that it helps to (partially) solve the diamond<br>&gt; problem (and similar issues) by forcing/allowing disambiguation when there<br>&gt; are multiple protocols being conformed to.  This will become more of an<br>&gt; issue if we allow protocols or extensions to add storage.  Your proposed<br>&gt; syntax actually does a better job of it than mine because mine was always<br>&gt; shown as attached to some sort of implementation, whereas yours could<br>&gt; potentially allow access to a default implementation under a new name.<br>&gt;<br>&gt; Other than that, it generally allows us to bypass/mitigate conflicts<br>&gt; between protocols.  In the current version, you are unable to conform to<br>&gt; both protocols (either because it won’t compile or because you can’t<br>&gt; satisfy the semantics of both protocols) without designing the protocols<br>&gt; together to avoid conflicts.  (I have definitely had to go back and<br>&gt; rename/refactor properties on a protocol for this reason… which I couldn’t<br>&gt; have done if I didn’t control both protocols).<br>&gt;<br></p><p>I understand something of the difficulty of confronting the diamond<br>problem. As I wrote above, I&#39;m inclined to believe that this proposed<br>feature would help solve a real issue. However, the point I&#39;m trying to<br>make is that, on reflection, I have never actually been hampered by the<br>lack of this feature, and so I&#39;d like to continue the discussion to get a<br>fuller sense of just how impactful this proposal would be, both positive<br>and negative.<br></p><p>It&#39;s true, of course, that if you control at least one of two protocols<br>(you don&#39;t need to control both protocols), it is trivially easy to cause<br>this problem to occur, but as you point out it is also possible to resolve<br>the problem by re-designing the protocol you control. I&#39;m inclined to think<br>(without evidence, admittedly) that re-designing to remove the conflict,<br>where possible, would actually be the superior option in most cases.<br></p><p>My question was: have you actually run into a scenario that necessitates<br>the feature you propose because you controlled neither conflicting<br>protocol? I think it would strengthen the proposal greatly to have a<br>concrete, uncontrived example.<br></p><p>Take a look at Eiffel’s ‘rename’ &amp; ’select’ features for similar<br>&gt; functionality and use-cases.<br>&gt;<br>&gt; Ultimately, this is a step in the direction of having true mixins.<br>&gt;<br>&gt;<br>Sure, maybe. I couldn&#39;t evaluate that claim. I&#39;m inclined to favor the<br>proposal, but it&#39;d have to stand on its own merits, not as a step to an<br>as-yet undesigned feature.<br></p><p>   I am fairly certain this affects the ABI though, so I thought I would<br>&gt; bring it up now.<br>&gt;<br>&gt;&gt;<br>&gt;&gt; If two protocols have methods/properties with the same name, but<br>&gt;&gt; different signatures, we need a way to distinguish between them when<br>&gt;&gt; attempting to conform to both.<br>&gt;&gt;<br>&gt;&gt;         protocol A {<br>&gt;&gt;                 var x:Int {get set}<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;         protocol B {<br>&gt;&gt;                 var x:Double {get set}<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;<br>&gt; Methods can be overloaded that differ in arguments or return type, so it<br>&gt; seems like this problem mainly exists with *properties* that differ in<br>&gt; type--am I wrong?<br>&gt;<br>&gt;<br>&gt; There is also the case of functions with the same name and signature, but<br>&gt; different semantics.  There may be no single implementation which<br>&gt; simultaneously satisfies the semantics for both protocols. By renaming one<br>&gt; of the functions, we are able to provide separate implementations for each<br>&gt; requirement (which allows both protocols to function as intended).<br>&gt;<br></p><p>True. However, putting on my critical hat, this seems like we&#39;re stretching<br>to provide support for an anti-pattern. It&#39;d be nice to have an example<br>where one runs into the motivating problem *and* where the proposed feature<br>promotes a _better_ design than is currently possible, rather than making a<br>bad design compile.<br></p><p>At this point, I&#39;m imagining scenarios where a user is trying to conform a<br>type MyAnimal to both Biped and Quadruped, then worrying that `walk()` has<br>two semantics: something has already gone deeply wrong IMO.<br></p><p>[Yes, I know there are animals that can sometimes walk on two or four legs.<br>The point here is that the protocols were clearly designed to model animals<br>at a certain level of detail, while it appears that the user writing<br>`MyAnimal` wants to model the animal at a different level of detail than<br>either protocol was designed to handle. You might have specific qualms<br>about this particular hypothetical, but I think you can pick out the<br>general point that there is a much larger problem inherent in the design<br>than the specific problem regarding two colliding method signatures.]<br></p><p>There may also be functions in different protocols with different names but<br>&gt; the same semantics and signature.  This will allow a single implementation<br>&gt; to satisfy both protocols without duplication.<br>&gt;<br></p><p>This is a poor argument IMO. You can already implement foo() and then have<br>bar() forward to foo() with trivial effort and really minimal boilerplate.<br>It&#39;s an existing solution, and a more general solution because it doesn&#39;t<br>require matching signatures. Also, it&#39;s a better solution IMO because it<br>preserves the notion that a type T : Fooable, Barrable provides the full<br>API guaranteed by Fooable and Barrable.<br></p><p>Finally, we may want to rename an inherited default implementation to avoid<br>&gt; conflicting with another protocol&#39;s default implementation in cases where<br>&gt; we don’t want to override it.<br>&gt;<br></p><p>Yes, I think this would be handy. I can&#39;t think of an existing way to do<br>this, and I expect it might make a big difference in designing good<br>protocols. So here, I think we have a strong argument.<br></p><p>Again, though, could we find a concrete example of how this feature would<br>promoter a better design of an actual type and/or protocol?<br></p><p> One possibility is to allow a struct/class/enum to conform to the protocol<br>&gt; while renaming one (or both) of the clashing methods:<br>&gt;<br>&gt;&gt;<br>&gt;&gt;         struct C: A,B {<br>&gt;&gt;                 var x:Int<br>&gt;&gt;                 var y:Double implements B.x<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt; The conforming method/property would still have to have the same<br>&gt;&gt; signature, but could have a different name (and parameter labels).  It<br>&gt;&gt; would also allow protocol methods which have identical signatures and<br>&gt;&gt; semantics, but different names to be implemented using the same method (i.e<br>&gt;&gt; ‘implements D.z &amp; E.w’).<br>&gt;&gt;<br>&gt;&gt; When something is cast to the protocol (say ‘as B’), then calling the<br>&gt;&gt; property (e.g. ‘x’) would end up calling the implementation of the renamed<br>&gt;&gt; property ( ‘y’ in this example) on the conforming type.<br>&gt;&gt;<br>&gt;<br>&gt; Reflecting on this proposed change, it occurs to me that something of<br>&gt; value would be lost, and I think that this something is actually rather<br>&gt; valuable:<br>&gt;<br>&gt; Today, when I see that a type conforms to (for example) Sequence, I know<br>&gt; that certain methods and/or properties exist on that type. Protocol<br>&gt; conformance guarantees a certain API, not just certain semantics.<br>&gt;<br>&gt;<br>&gt; It isn’t actually lost, however.  When working with it as a Sequence (for<br>&gt; example), that API would be intact using the original names.  It is only<br>&gt; when working with it as its own type that the renaming would have an effect.<br>&gt;<br></p><p>That is not my point. With this proposal, knowing that MyGreatType conforms<br>to Sequence would no longer yield any information as to the MyGreatType<br>API. That is definitely something lost and we should acknowledge that.<br></p><p>Also, recall that Sequence has Self or associated type requirements. So:<br></p><p>```<br>let m = MyGreatType()<br>// There is nothing I can write here to use the Sequence API with `m`, IIUC;<br>// however, depending on how this feature is designed, I *might* be able to<br>// call a generic function that operates on a type `T : Sequence` and work<br>// with `m` that way.<br>```<br></p><p>Perhaps one way to mitigate this loss would be to have any renamed members<br>&gt; listed *in the declaration of conformance*, something like this (with some<br>&gt; additional bikeshedding):<br>&gt;<br>&gt; ```<br>&gt; struct MyGreatType : Sequence (count =&gt; length) {<br>&gt;   // MyGreatType conforms to Sequence but renames `count` to `length`<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt;<br>&gt; Yes, putting it in the conformance declaration is a definite possibility<br>&gt; we should consider.<br>&gt;<br>&gt;<br>&gt; I think we would also want a way to retroactively conform using existing<br>&gt;&gt; properties/methods in an extension declaring conformance.  Not sure what<br>&gt;&gt; the best syntax for that would be.  Off the top of my head (though I would<br>&gt;&gt; love to have something with less cruft):<br>&gt;&gt;<br>&gt;&gt;         extension D:B {<br>&gt;&gt;                 @conform(to: B.x, with: D.y)<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt; or maybe just:<br>&gt;&gt;<br>&gt;&gt;         extension D:B {<br>&gt;&gt;                 D.y implements B.x<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;<br>&gt; If renamed members are declared along with protocol conformance, then the<br>&gt; syntax for retroactive modeling follows naturally:<br>&gt;<br>&gt; ```<br>&gt; extension D : B (x =&gt; y) { }<br>&gt; // again, the actual notation here is ugly<br>&gt; // but the underlying idea, I think, is worth considering<br>&gt; ```<br>&gt;<br>&gt;<br>&gt; Yup<br>&gt;<br>&gt; One thing I like about this is that it helps to solve the diamond problem.<br>&gt;  ‘x’ could be a default implementation in B which D does not override.  I<br>&gt; think this is an important case which my original proposal didn’t address<br>&gt; fully.<br>&gt;<br>&gt; We should keep bikeshedding the syntax though...<br>&gt;<br>&gt; Thanks,<br>&gt; Jon<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160823/a105cad6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0411520c60ef1131670f84bb42dc8949?s=50"></div><header><strong>Renaming for Protocol Conformance</strong> from <string>Swift)</string> &lt;swift-callionica at callionica.com (Callionica&gt;<p>August 23, 2016 at 03:00:00pm</p></header><div class="content"><p>C# has this feature (called &quot;explicit interface implementation&quot; or<br>&quot;explicit interface method implementation&quot;). It&#39;s useful for implementing<br>multiple data-like interfaces that have common names like Name, ID, Title,<br>and Description. It&#39;s useful for keeping public interfaces clean. It&#39;s<br>useful for API evolution: sometimes you need to implement both IVersion1<br>and IVersion2 interfaces that have (as you would expect) similar method<br>names and semantics, but differences that still require different<br>implementations.<br></p><p>There&#39;s a stack overflow topic which has various perspectives on it:<br>http://stackoverflow.com/questions/143405/c-sharp-interfaces-implicit-implementation-versus-explicit-implementation<br></p><p>On Tue, Aug 23, 2016 at 8:35 AM, Xiaodi Wu via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Tue, Aug 23, 2016 at 3:02 AM, Jonathan Hull &lt;jhull at gbis.com&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Aug 22, 2016, at 11:32 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Mon, Aug 22, 2016 at 11:59 PM, Jonathan Hull via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Hi everyone,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; We talked about this before when we were discussing mixins, and there<br>&gt;&gt;&gt; seemed to be generally positive feelings towards it as a feature for the<br>&gt;&gt;&gt; future.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; It&#39;s been some time now since the original discussion, so perhaps you<br>&gt;&gt; could refresh our collective memory (or at least, mine): although it<br>&gt;&gt; *seems* like this feature might be useful, I can&#39;t recall a concrete use<br>&gt;&gt; case where I&#39;ve felt like I needed this feature--do you have some examples?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Ideally, the biggest use is that it helps to (partially) solve the<br>&gt;&gt; diamond problem (and similar issues) by forcing/allowing disambiguation<br>&gt;&gt; when there are multiple protocols being conformed to.  This will become<br>&gt;&gt; more of an issue if we allow protocols or extensions to add storage.  Your<br>&gt;&gt; proposed syntax actually does a better job of it than mine because mine was<br>&gt;&gt; always shown as attached to some sort of implementation, whereas yours<br>&gt;&gt; could potentially allow access to a default implementation under a new name.<br>&gt;&gt;<br>&gt;&gt; Other than that, it generally allows us to bypass/mitigate conflicts<br>&gt;&gt; between protocols.  In the current version, you are unable to conform to<br>&gt;&gt; both protocols (either because it won’t compile or because you can’t<br>&gt;&gt; satisfy the semantics of both protocols) without designing the protocols<br>&gt;&gt; together to avoid conflicts.  (I have definitely had to go back and<br>&gt;&gt; rename/refactor properties on a protocol for this reason… which I couldn’t<br>&gt;&gt; have done if I didn’t control both protocols).<br>&gt;&gt;<br>&gt;<br>&gt; I understand something of the difficulty of confronting the diamond<br>&gt; problem. As I wrote above, I&#39;m inclined to believe that this proposed<br>&gt; feature would help solve a real issue. However, the point I&#39;m trying to<br>&gt; make is that, on reflection, I have never actually been hampered by the<br>&gt; lack of this feature, and so I&#39;d like to continue the discussion to get a<br>&gt; fuller sense of just how impactful this proposal would be, both positive<br>&gt; and negative.<br>&gt;<br>&gt; It&#39;s true, of course, that if you control at least one of two protocols<br>&gt; (you don&#39;t need to control both protocols), it is trivially easy to cause<br>&gt; this problem to occur, but as you point out it is also possible to resolve<br>&gt; the problem by re-designing the protocol you control. I&#39;m inclined to think<br>&gt; (without evidence, admittedly) that re-designing to remove the conflict,<br>&gt; where possible, would actually be the superior option in most cases.<br>&gt;<br>&gt; My question was: have you actually run into a scenario that necessitates<br>&gt; the feature you propose because you controlled neither conflicting<br>&gt; protocol? I think it would strengthen the proposal greatly to have a<br>&gt; concrete, uncontrived example.<br>&gt;<br>&gt; Take a look at Eiffel’s ‘rename’ &amp; ’select’ features for similar<br>&gt;&gt; functionality and use-cases.<br>&gt;&gt;<br>&gt;&gt; Ultimately, this is a step in the direction of having true mixins.<br>&gt;&gt;<br>&gt;&gt;<br>&gt; Sure, maybe. I couldn&#39;t evaluate that claim. I&#39;m inclined to favor the<br>&gt; proposal, but it&#39;d have to stand on its own merits, not as a step to an<br>&gt; as-yet undesigned feature.<br>&gt;<br>&gt;    I am fairly certain this affects the ABI though, so I thought I would<br>&gt;&gt; bring it up now.<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If two protocols have methods/properties with the same name, but<br>&gt;&gt;&gt; different signatures, we need a way to distinguish between them when<br>&gt;&gt;&gt; attempting to conform to both.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         protocol A {<br>&gt;&gt;&gt;                 var x:Int {get set}<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         protocol B {<br>&gt;&gt;&gt;                 var x:Double {get set}<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Methods can be overloaded that differ in arguments or return type, so it<br>&gt;&gt; seems like this problem mainly exists with *properties* that differ in<br>&gt;&gt; type--am I wrong?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; There is also the case of functions with the same name and signature, but<br>&gt;&gt; different semantics.  There may be no single implementation which<br>&gt;&gt; simultaneously satisfies the semantics for both protocols. By renaming one<br>&gt;&gt; of the functions, we are able to provide separate implementations for each<br>&gt;&gt; requirement (which allows both protocols to function as intended).<br>&gt;&gt;<br>&gt;<br>&gt; True. However, putting on my critical hat, this seems like we&#39;re<br>&gt; stretching to provide support for an anti-pattern. It&#39;d be nice to have an<br>&gt; example where one runs into the motivating problem *and* where the proposed<br>&gt; feature promotes a _better_ design than is currently possible, rather than<br>&gt; making a bad design compile.<br>&gt;<br>&gt; At this point, I&#39;m imagining scenarios where a user is trying to conform a<br>&gt; type MyAnimal to both Biped and Quadruped, then worrying that `walk()` has<br>&gt; two semantics: something has already gone deeply wrong IMO.<br>&gt;<br>&gt; [Yes, I know there are animals that can sometimes walk on two or four<br>&gt; legs. The point here is that the protocols were clearly designed to model<br>&gt; animals at a certain level of detail, while it appears that the user<br>&gt; writing `MyAnimal` wants to model the animal at a different level of detail<br>&gt; than either protocol was designed to handle. You might have specific qualms<br>&gt; about this particular hypothetical, but I think you can pick out the<br>&gt; general point that there is a much larger problem inherent in the design<br>&gt; than the specific problem regarding two colliding method signatures.]<br>&gt;<br>&gt; There may also be functions in different protocols with different names<br>&gt;&gt; but the same semantics and signature.  This will allow a single<br>&gt;&gt; implementation to satisfy both protocols without duplication.<br>&gt;&gt;<br>&gt;<br>&gt; This is a poor argument IMO. You can already implement foo() and then have<br>&gt; bar() forward to foo() with trivial effort and really minimal boilerplate.<br>&gt; It&#39;s an existing solution, and a more general solution because it doesn&#39;t<br>&gt; require matching signatures. Also, it&#39;s a better solution IMO because it<br>&gt; preserves the notion that a type T : Fooable, Barrable provides the full<br>&gt; API guaranteed by Fooable and Barrable.<br>&gt;<br>&gt; Finally, we may want to rename an inherited default implementation to<br>&gt;&gt; avoid conflicting with another protocol&#39;s default implementation in cases<br>&gt;&gt; where we don’t want to override it.<br>&gt;&gt;<br>&gt;<br>&gt; Yes, I think this would be handy. I can&#39;t think of an existing way to do<br>&gt; this, and I expect it might make a big difference in designing good<br>&gt; protocols. So here, I think we have a strong argument.<br>&gt;<br>&gt; Again, though, could we find a concrete example of how this feature would<br>&gt; promoter a better design of an actual type and/or protocol?<br>&gt;<br>&gt;  One possibility is to allow a struct/class/enum to conform to the<br>&gt;&gt; protocol while renaming one (or both) of the clashing methods:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         struct C: A,B {<br>&gt;&gt;&gt;                 var x:Int<br>&gt;&gt;&gt;                 var y:Double implements B.x<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The conforming method/property would still have to have the same<br>&gt;&gt;&gt; signature, but could have a different name (and parameter labels).  It<br>&gt;&gt;&gt; would also allow protocol methods which have identical signatures and<br>&gt;&gt;&gt; semantics, but different names to be implemented using the same method (i.e<br>&gt;&gt;&gt; ‘implements D.z &amp; E.w’).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; When something is cast to the protocol (say ‘as B’), then calling the<br>&gt;&gt;&gt; property (e.g. ‘x’) would end up calling the implementation of the renamed<br>&gt;&gt;&gt; property ( ‘y’ in this example) on the conforming type.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Reflecting on this proposed change, it occurs to me that something of<br>&gt;&gt; value would be lost, and I think that this something is actually rather<br>&gt;&gt; valuable:<br>&gt;&gt;<br>&gt;&gt; Today, when I see that a type conforms to (for example) Sequence, I know<br>&gt;&gt; that certain methods and/or properties exist on that type. Protocol<br>&gt;&gt; conformance guarantees a certain API, not just certain semantics.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; It isn’t actually lost, however.  When working with it as a Sequence (for<br>&gt;&gt; example), that API would be intact using the original names.  It is only<br>&gt;&gt; when working with it as its own type that the renaming would have an effect.<br>&gt;&gt;<br>&gt;<br>&gt; That is not my point. With this proposal, knowing that MyGreatType<br>&gt; conforms to Sequence would no longer yield any information as to the<br>&gt; MyGreatType API. That is definitely something lost and we should<br>&gt; acknowledge that.<br>&gt;<br>&gt; Also, recall that Sequence has Self or associated type requirements. So:<br>&gt;<br>&gt; ```<br>&gt; let m = MyGreatType()<br>&gt; // There is nothing I can write here to use the Sequence API with `m`,<br>&gt; IIUC;<br>&gt; // however, depending on how this feature is designed, I *might* be able to<br>&gt; // call a generic function that operates on a type `T : Sequence` and work<br>&gt; // with `m` that way.<br>&gt; ```<br>&gt;<br>&gt; Perhaps one way to mitigate this loss would be to have any renamed members<br>&gt;&gt; listed *in the declaration of conformance*, something like this (with some<br>&gt;&gt; additional bikeshedding):<br>&gt;&gt;<br>&gt;&gt; ```<br>&gt;&gt; struct MyGreatType : Sequence (count =&gt; length) {<br>&gt;&gt;   // MyGreatType conforms to Sequence but renames `count` to `length`<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Yes, putting it in the conformance declaration is a definite possibility<br>&gt;&gt; we should consider.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I think we would also want a way to retroactively conform using existing<br>&gt;&gt;&gt; properties/methods in an extension declaring conformance.  Not sure what<br>&gt;&gt;&gt; the best syntax for that would be.  Off the top of my head (though I would<br>&gt;&gt;&gt; love to have something with less cruft):<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         extension D:B {<br>&gt;&gt;&gt;                 @conform(to: B.x, with: D.y)<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; or maybe just:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         extension D:B {<br>&gt;&gt;&gt;                 D.y implements B.x<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; If renamed members are declared along with protocol conformance, then the<br>&gt;&gt; syntax for retroactive modeling follows naturally:<br>&gt;&gt;<br>&gt;&gt; ```<br>&gt;&gt; extension D : B (x =&gt; y) { }<br>&gt;&gt; // again, the actual notation here is ugly<br>&gt;&gt; // but the underlying idea, I think, is worth considering<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Yup<br>&gt;&gt;<br>&gt;&gt; One thing I like about this is that it helps to solve the diamond<br>&gt;&gt; problem.  ‘x’ could be a default implementation in B which D does not<br>&gt;&gt; override.  I think this is an important case which my original proposal<br>&gt;&gt; didn’t address fully.<br>&gt;&gt;<br>&gt;&gt; We should keep bikeshedding the syntax though...<br>&gt;&gt;<br>&gt;&gt; Thanks,<br>&gt;&gt; Jon<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160823/5f92113d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Renaming for Protocol Conformance</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 23, 2016 at 06:00:00pm</p></header><div class="content"><p>On Tue, Aug 23, 2016 at 5:51 PM, Callionica (Swift) &lt;<br>swift-callionica at callionica.com&gt; wrote:<br></p><p>&gt; C# has this feature (called &quot;explicit interface implementation&quot; or<br>&gt; &quot;explicit interface method implementation&quot;). It&#39;s useful for implementing<br>&gt; multiple data-like interfaces that have common names like Name, ID, Title,<br>&gt; and Description. It&#39;s useful for keeping public interfaces clean. It&#39;s<br>&gt; useful for API evolution: sometimes you need to implement both IVersion1<br>&gt; and IVersion2 interfaces that have (as you would expect) similar method<br>&gt; names and semantics, but differences that still require different<br>&gt; implementations.<br>&gt;<br>&gt; There&#39;s a stack overflow topic which has various perspectives on it:<br>&gt; http://stackoverflow.com/questions/143405/c-sharp-interfaces-implicit-<br>&gt; implementation-versus-explicit-implementation<br>&gt;<br></p><p>This is very interesting information. The OP there, dating from &#39;08,<br>states: &quot;Microsoft&#39;s official guidelines (from first edition Framework<br>Design Guidelines) states that using explicit implementations are not<br>recommended.&quot; Is that, to your knowledge, still the consensus opinion from<br>Microsoft? If the language designers of C# were to do it all over again,<br>would this feature have been added at all?<br></p><p>Two notable considerations. In this proposal, Jonathan is suggesting that<br>we _rename_ protocol requirements; I don&#39;t think C# EIMI has that feature,<br>so it would remain to be determined whether this new twist could be an<br>improvement or a regression as compared to EIMI.<br></p><p>Second, invoking an EIMI member requires creating an interface instance. In<br>Swift, however, protocols that have Self or associated type requirements<br>can only be used as generic constraints. It is unclear to me if or how the<br>Swift type system would represent something analogous to an interface<br>instance.<br></p><p><br>On Tue, Aug 23, 2016 at 8:35 AM, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; On Tue, Aug 23, 2016 at 3:02 AM, Jonathan Hull &lt;jhull at gbis.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Aug 22, 2016, at 11:32 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Mon, Aug 22, 2016 at 11:59 PM, Jonathan Hull via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Hi everyone,<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; We talked about this before when we were discussing mixins, and there<br>&gt;&gt;&gt;&gt; seemed to be generally positive feelings towards it as a feature for the<br>&gt;&gt;&gt;&gt; future.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It&#39;s been some time now since the original discussion, so perhaps you<br>&gt;&gt;&gt; could refresh our collective memory (or at least, mine): although it<br>&gt;&gt;&gt; *seems* like this feature might be useful, I can&#39;t recall a concrete use<br>&gt;&gt;&gt; case where I&#39;ve felt like I needed this feature--do you have some examples?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Ideally, the biggest use is that it helps to (partially) solve the<br>&gt;&gt;&gt; diamond problem (and similar issues) by forcing/allowing disambiguation<br>&gt;&gt;&gt; when there are multiple protocols being conformed to.  This will become<br>&gt;&gt;&gt; more of an issue if we allow protocols or extensions to add storage.  Your<br>&gt;&gt;&gt; proposed syntax actually does a better job of it than mine because mine was<br>&gt;&gt;&gt; always shown as attached to some sort of implementation, whereas yours<br>&gt;&gt;&gt; could potentially allow access to a default implementation under a new name.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Other than that, it generally allows us to bypass/mitigate conflicts<br>&gt;&gt;&gt; between protocols.  In the current version, you are unable to conform to<br>&gt;&gt;&gt; both protocols (either because it won’t compile or because you can’t<br>&gt;&gt;&gt; satisfy the semantics of both protocols) without designing the protocols<br>&gt;&gt;&gt; together to avoid conflicts.  (I have definitely had to go back and<br>&gt;&gt;&gt; rename/refactor properties on a protocol for this reason… which I couldn’t<br>&gt;&gt;&gt; have done if I didn’t control both protocols).<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I understand something of the difficulty of confronting the diamond<br>&gt;&gt; problem. As I wrote above, I&#39;m inclined to believe that this proposed<br>&gt;&gt; feature would help solve a real issue. However, the point I&#39;m trying to<br>&gt;&gt; make is that, on reflection, I have never actually been hampered by the<br>&gt;&gt; lack of this feature, and so I&#39;d like to continue the discussion to get a<br>&gt;&gt; fuller sense of just how impactful this proposal would be, both positive<br>&gt;&gt; and negative.<br>&gt;&gt;<br>&gt;&gt; It&#39;s true, of course, that if you control at least one of two protocols<br>&gt;&gt; (you don&#39;t need to control both protocols), it is trivially easy to cause<br>&gt;&gt; this problem to occur, but as you point out it is also possible to resolve<br>&gt;&gt; the problem by re-designing the protocol you control. I&#39;m inclined to think<br>&gt;&gt; (without evidence, admittedly) that re-designing to remove the conflict,<br>&gt;&gt; where possible, would actually be the superior option in most cases.<br>&gt;&gt;<br>&gt;&gt; My question was: have you actually run into a scenario that necessitates<br>&gt;&gt; the feature you propose because you controlled neither conflicting<br>&gt;&gt; protocol? I think it would strengthen the proposal greatly to have a<br>&gt;&gt; concrete, uncontrived example.<br>&gt;&gt;<br>&gt;&gt; Take a look at Eiffel’s ‘rename’ &amp; ’select’ features for similar<br>&gt;&gt;&gt; functionality and use-cases.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Ultimately, this is a step in the direction of having true mixins.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; Sure, maybe. I couldn&#39;t evaluate that claim. I&#39;m inclined to favor the<br>&gt;&gt; proposal, but it&#39;d have to stand on its own merits, not as a step to an<br>&gt;&gt; as-yet undesigned feature.<br>&gt;&gt;<br>&gt;&gt;    I am fairly certain this affects the ABI though, so I thought I would<br>&gt;&gt;&gt; bring it up now.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; If two protocols have methods/properties with the same name, but<br>&gt;&gt;&gt;&gt; different signatures, we need a way to distinguish between them when<br>&gt;&gt;&gt;&gt; attempting to conform to both.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         protocol A {<br>&gt;&gt;&gt;&gt;                 var x:Int {get set}<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         protocol B {<br>&gt;&gt;&gt;&gt;                 var x:Double {get set}<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Methods can be overloaded that differ in arguments or return type, so it<br>&gt;&gt;&gt; seems like this problem mainly exists with *properties* that differ in<br>&gt;&gt;&gt; type--am I wrong?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; There is also the case of functions with the same name and signature,<br>&gt;&gt;&gt; but different semantics.  There may be no single implementation which<br>&gt;&gt;&gt; simultaneously satisfies the semantics for both protocols. By renaming one<br>&gt;&gt;&gt; of the functions, we are able to provide separate implementations for each<br>&gt;&gt;&gt; requirement (which allows both protocols to function as intended).<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; True. However, putting on my critical hat, this seems like we&#39;re<br>&gt;&gt; stretching to provide support for an anti-pattern. It&#39;d be nice to have an<br>&gt;&gt; example where one runs into the motivating problem *and* where the proposed<br>&gt;&gt; feature promotes a _better_ design than is currently possible, rather than<br>&gt;&gt; making a bad design compile.<br>&gt;&gt;<br>&gt;&gt; At this point, I&#39;m imagining scenarios where a user is trying to conform<br>&gt;&gt; a type MyAnimal to both Biped and Quadruped, then worrying that `walk()`<br>&gt;&gt; has two semantics: something has already gone deeply wrong IMO.<br>&gt;&gt;<br>&gt;&gt; [Yes, I know there are animals that can sometimes walk on two or four<br>&gt;&gt; legs. The point here is that the protocols were clearly designed to model<br>&gt;&gt; animals at a certain level of detail, while it appears that the user<br>&gt;&gt; writing `MyAnimal` wants to model the animal at a different level of detail<br>&gt;&gt; than either protocol was designed to handle. You might have specific qualms<br>&gt;&gt; about this particular hypothetical, but I think you can pick out the<br>&gt;&gt; general point that there is a much larger problem inherent in the design<br>&gt;&gt; than the specific problem regarding two colliding method signatures.]<br>&gt;&gt;<br>&gt;&gt; There may also be functions in different protocols with different names<br>&gt;&gt;&gt; but the same semantics and signature.  This will allow a single<br>&gt;&gt;&gt; implementation to satisfy both protocols without duplication.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; This is a poor argument IMO. You can already implement foo() and then<br>&gt;&gt; have bar() forward to foo() with trivial effort and really minimal<br>&gt;&gt; boilerplate. It&#39;s an existing solution, and a more general solution because<br>&gt;&gt; it doesn&#39;t require matching signatures. Also, it&#39;s a better solution IMO<br>&gt;&gt; because it preserves the notion that a type T : Fooable, Barrable provides<br>&gt;&gt; the full API guaranteed by Fooable and Barrable.<br>&gt;&gt;<br>&gt;&gt; Finally, we may want to rename an inherited default implementation to<br>&gt;&gt;&gt; avoid conflicting with another protocol&#39;s default implementation in cases<br>&gt;&gt;&gt; where we don’t want to override it.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Yes, I think this would be handy. I can&#39;t think of an existing way to do<br>&gt;&gt; this, and I expect it might make a big difference in designing good<br>&gt;&gt; protocols. So here, I think we have a strong argument.<br>&gt;&gt;<br>&gt;&gt; Again, though, could we find a concrete example of how this feature would<br>&gt;&gt; promoter a better design of an actual type and/or protocol?<br>&gt;&gt;<br>&gt;&gt;  One possibility is to allow a struct/class/enum to conform to the<br>&gt;&gt;&gt; protocol while renaming one (or both) of the clashing methods:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         struct C: A,B {<br>&gt;&gt;&gt;&gt;                 var x:Int<br>&gt;&gt;&gt;&gt;                 var y:Double implements B.x<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The conforming method/property would still have to have the same<br>&gt;&gt;&gt;&gt; signature, but could have a different name (and parameter labels).  It<br>&gt;&gt;&gt;&gt; would also allow protocol methods which have identical signatures and<br>&gt;&gt;&gt;&gt; semantics, but different names to be implemented using the same method (i.e<br>&gt;&gt;&gt;&gt; ‘implements D.z &amp; E.w’).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; When something is cast to the protocol (say ‘as B’), then calling the<br>&gt;&gt;&gt;&gt; property (e.g. ‘x’) would end up calling the implementation of the renamed<br>&gt;&gt;&gt;&gt; property ( ‘y’ in this example) on the conforming type.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Reflecting on this proposed change, it occurs to me that something of<br>&gt;&gt;&gt; value would be lost, and I think that this something is actually rather<br>&gt;&gt;&gt; valuable:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Today, when I see that a type conforms to (for example) Sequence, I know<br>&gt;&gt;&gt; that certain methods and/or properties exist on that type. Protocol<br>&gt;&gt;&gt; conformance guarantees a certain API, not just certain semantics.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It isn’t actually lost, however.  When working with it as a Sequence<br>&gt;&gt;&gt; (for example), that API would be intact using the original names.  It is<br>&gt;&gt;&gt; only when working with it as its own type that the renaming would have an<br>&gt;&gt;&gt; effect.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; That is not my point. With this proposal, knowing that MyGreatType<br>&gt;&gt; conforms to Sequence would no longer yield any information as to the<br>&gt;&gt; MyGreatType API. That is definitely something lost and we should<br>&gt;&gt; acknowledge that.<br>&gt;&gt;<br>&gt;&gt; Also, recall that Sequence has Self or associated type requirements. So:<br>&gt;&gt;<br>&gt;&gt; ```<br>&gt;&gt; let m = MyGreatType()<br>&gt;&gt; // There is nothing I can write here to use the Sequence API with `m`,<br>&gt;&gt; IIUC;<br>&gt;&gt; // however, depending on how this feature is designed, I *might* be able<br>&gt;&gt; to<br>&gt;&gt; // call a generic function that operates on a type `T : Sequence` and work<br>&gt;&gt; // with `m` that way.<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt; Perhaps one way to mitigate this loss would be to have any renamed<br>&gt;&gt;&gt; members listed *in the declaration of conformance*, something like this<br>&gt;&gt;&gt; (with some additional bikeshedding):<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; struct MyGreatType : Sequence (count =&gt; length) {<br>&gt;&gt;&gt;   // MyGreatType conforms to Sequence but renames `count` to `length`<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Yes, putting it in the conformance declaration is a definite possibility<br>&gt;&gt;&gt; we should consider.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I think we would also want a way to retroactively conform using existing<br>&gt;&gt;&gt;&gt; properties/methods in an extension declaring conformance.  Not sure what<br>&gt;&gt;&gt;&gt; the best syntax for that would be.  Off the top of my head (though I would<br>&gt;&gt;&gt;&gt; love to have something with less cruft):<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         extension D:B {<br>&gt;&gt;&gt;&gt;                 @conform(to: B.x, with: D.y)<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; or maybe just:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         extension D:B {<br>&gt;&gt;&gt;&gt;                 D.y implements B.x<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If renamed members are declared along with protocol conformance, then<br>&gt;&gt;&gt; the syntax for retroactive modeling follows naturally:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; extension D : B (x =&gt; y) { }<br>&gt;&gt;&gt; // again, the actual notation here is ugly<br>&gt;&gt;&gt; // but the underlying idea, I think, is worth considering<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Yup<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; One thing I like about this is that it helps to solve the diamond<br>&gt;&gt;&gt; problem.  ‘x’ could be a default implementation in B which D does not<br>&gt;&gt;&gt; override.  I think this is an important case which my original proposal<br>&gt;&gt;&gt; didn’t address fully.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; We should keep bikeshedding the syntax though...<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160823/0c999bcb/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0411520c60ef1131670f84bb42dc8949?s=50"></div><header><strong>Renaming for Protocol Conformance</strong> from <string>Swift)</string> &lt;swift-callionica at callionica.com (Callionica&gt;<p>August 23, 2016 at 04:00:00pm</p></header><div class="content"><p>The framework design guidelines were for ensuring code consistency and<br>necessarily included stylistic decisions. There was no ban on using<br>explicit interface implementation, just reasonable caution to the end goal<br>of consistency. This is what the framework design guidelines said in 2010:<br>https://msdn.microsoft.com/en-us/library/ms229034(v=vs.100).aspx<br>A web search suggests that the current version of the guidelines contains<br>no guidance on explicit interface implementation, but could be that I just<br>couldn&#39;t find it.<br>Explicit implementations were essential for moving collection interfaces<br>and others to generic versions - there&#39;s plenty of uses in the Microsoft<br>.Net framework implementation - so I would be surprised if there was a<br>feeling that the feature was a mistake, but you&#39;d have to ask Anders and<br>others. (I don&#39;t know if TypeScript has a similar feature, but if not,<br>there are alternative explanations for it&#39;s absence than thinking it was a<br>mistake for C#).<br></p><p>You&#39;re correct that C# doesn&#39;t allow renaming: it requires the interface<br>name to be prefixed to the method name at the point of definition.<br></p><p>On Tue, Aug 23, 2016 at 4:03 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br></p><p>&gt; On Tue, Aug 23, 2016 at 5:51 PM, Callionica (Swift) &lt;<br>&gt; swift-callionica at callionica.com&gt; wrote:<br>&gt;<br>&gt;&gt; C# has this feature (called &quot;explicit interface implementation&quot; or<br>&gt;&gt; &quot;explicit interface method implementation&quot;). It&#39;s useful for implementing<br>&gt;&gt; multiple data-like interfaces that have common names like Name, ID, Title,<br>&gt;&gt; and Description. It&#39;s useful for keeping public interfaces clean. It&#39;s<br>&gt;&gt; useful for API evolution: sometimes you need to implement both IVersion1<br>&gt;&gt; and IVersion2 interfaces that have (as you would expect) similar method<br>&gt;&gt; names and semantics, but differences that still require different<br>&gt;&gt; implementations.<br>&gt;&gt;<br>&gt;&gt; There&#39;s a stack overflow topic which has various perspectives on it:<br>&gt;&gt; http://stackoverflow.com/questions/143405/c-sharp-interf<br>&gt;&gt; aces-implicit-implementation-versus-explicit-implementation<br>&gt;&gt;<br>&gt;<br>&gt; This is very interesting information. The OP there, dating from &#39;08,<br>&gt; states: &quot;Microsoft&#39;s official guidelines (from first edition Framework<br>&gt; Design Guidelines) states that using explicit implementations are not<br>&gt; recommended.&quot; Is that, to your knowledge, still the consensus opinion from<br>&gt; Microsoft? If the language designers of C# were to do it all over again,<br>&gt; would this feature have been added at all?<br>&gt;<br>&gt; Two notable considerations. In this proposal, Jonathan is suggesting that<br>&gt; we _rename_ protocol requirements; I don&#39;t think C# EIMI has that feature,<br>&gt; so it would remain to be determined whether this new twist could be an<br>&gt; improvement or a regression as compared to EIMI.<br>&gt;<br>&gt; Second, invoking an EIMI member requires creating an interface instance.<br>&gt; In Swift, however, protocols that have Self or associated type requirements<br>&gt; can only be used as generic constraints. It is unclear to me if or how the<br>&gt; Swift type system would represent something analogous to an interface<br>&gt; instance.<br>&gt;<br>&gt;<br>&gt; On Tue, Aug 23, 2016 at 8:35 AM, Xiaodi Wu via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; On Tue, Aug 23, 2016 at 3:02 AM, Jonathan Hull &lt;jhull at gbis.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Aug 22, 2016, at 11:32 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Mon, Aug 22, 2016 at 11:59 PM, Jonathan Hull via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Hi everyone,<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; We talked about this before when we were discussing mixins, and there<br>&gt;&gt;&gt;&gt;&gt; seemed to be generally positive feelings towards it as a feature for the<br>&gt;&gt;&gt;&gt;&gt; future.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; It&#39;s been some time now since the original discussion, so perhaps you<br>&gt;&gt;&gt;&gt; could refresh our collective memory (or at least, mine): although it<br>&gt;&gt;&gt;&gt; *seems* like this feature might be useful, I can&#39;t recall a concrete use<br>&gt;&gt;&gt;&gt; case where I&#39;ve felt like I needed this feature--do you have some examples?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Ideally, the biggest use is that it helps to (partially) solve the<br>&gt;&gt;&gt;&gt; diamond problem (and similar issues) by forcing/allowing disambiguation<br>&gt;&gt;&gt;&gt; when there are multiple protocols being conformed to.  This will become<br>&gt;&gt;&gt;&gt; more of an issue if we allow protocols or extensions to add storage.  Your<br>&gt;&gt;&gt;&gt; proposed syntax actually does a better job of it than mine because mine was<br>&gt;&gt;&gt;&gt; always shown as attached to some sort of implementation, whereas yours<br>&gt;&gt;&gt;&gt; could potentially allow access to a default implementation under a new name.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Other than that, it generally allows us to bypass/mitigate conflicts<br>&gt;&gt;&gt;&gt; between protocols.  In the current version, you are unable to conform to<br>&gt;&gt;&gt;&gt; both protocols (either because it won’t compile or because you can’t<br>&gt;&gt;&gt;&gt; satisfy the semantics of both protocols) without designing the protocols<br>&gt;&gt;&gt;&gt; together to avoid conflicts.  (I have definitely had to go back and<br>&gt;&gt;&gt;&gt; rename/refactor properties on a protocol for this reason… which I couldn’t<br>&gt;&gt;&gt;&gt; have done if I didn’t control both protocols).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I understand something of the difficulty of confronting the diamond<br>&gt;&gt;&gt; problem. As I wrote above, I&#39;m inclined to believe that this proposed<br>&gt;&gt;&gt; feature would help solve a real issue. However, the point I&#39;m trying to<br>&gt;&gt;&gt; make is that, on reflection, I have never actually been hampered by the<br>&gt;&gt;&gt; lack of this feature, and so I&#39;d like to continue the discussion to get a<br>&gt;&gt;&gt; fuller sense of just how impactful this proposal would be, both positive<br>&gt;&gt;&gt; and negative.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It&#39;s true, of course, that if you control at least one of two protocols<br>&gt;&gt;&gt; (you don&#39;t need to control both protocols), it is trivially easy to cause<br>&gt;&gt;&gt; this problem to occur, but as you point out it is also possible to resolve<br>&gt;&gt;&gt; the problem by re-designing the protocol you control. I&#39;m inclined to think<br>&gt;&gt;&gt; (without evidence, admittedly) that re-designing to remove the conflict,<br>&gt;&gt;&gt; where possible, would actually be the superior option in most cases.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; My question was: have you actually run into a scenario that necessitates<br>&gt;&gt;&gt; the feature you propose because you controlled neither conflicting<br>&gt;&gt;&gt; protocol? I think it would strengthen the proposal greatly to have a<br>&gt;&gt;&gt; concrete, uncontrived example.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Take a look at Eiffel’s ‘rename’ &amp; ’select’ features for similar<br>&gt;&gt;&gt;&gt; functionality and use-cases.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Ultimately, this is a step in the direction of having true mixins.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; Sure, maybe. I couldn&#39;t evaluate that claim. I&#39;m inclined to favor the<br>&gt;&gt;&gt; proposal, but it&#39;d have to stand on its own merits, not as a step to an<br>&gt;&gt;&gt; as-yet undesigned feature.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    I am fairly certain this affects the ABI though, so I thought I would<br>&gt;&gt;&gt;&gt; bring it up now.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; If two protocols have methods/properties with the same name, but<br>&gt;&gt;&gt;&gt;&gt; different signatures, we need a way to distinguish between them when<br>&gt;&gt;&gt;&gt;&gt; attempting to conform to both.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;         protocol A {<br>&gt;&gt;&gt;&gt;&gt;                 var x:Int {get set}<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;         protocol B {<br>&gt;&gt;&gt;&gt;&gt;                 var x:Double {get set}<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Methods can be overloaded that differ in arguments or return type, so<br>&gt;&gt;&gt;&gt; it seems like this problem mainly exists with *properties* that differ in<br>&gt;&gt;&gt;&gt; type--am I wrong?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; There is also the case of functions with the same name and signature,<br>&gt;&gt;&gt;&gt; but different semantics.  There may be no single implementation which<br>&gt;&gt;&gt;&gt; simultaneously satisfies the semantics for both protocols. By renaming one<br>&gt;&gt;&gt;&gt; of the functions, we are able to provide separate implementations for each<br>&gt;&gt;&gt;&gt; requirement (which allows both protocols to function as intended).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; True. However, putting on my critical hat, this seems like we&#39;re<br>&gt;&gt;&gt; stretching to provide support for an anti-pattern. It&#39;d be nice to have an<br>&gt;&gt;&gt; example where one runs into the motivating problem *and* where the proposed<br>&gt;&gt;&gt; feature promotes a _better_ design than is currently possible, rather than<br>&gt;&gt;&gt; making a bad design compile.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; At this point, I&#39;m imagining scenarios where a user is trying to conform<br>&gt;&gt;&gt; a type MyAnimal to both Biped and Quadruped, then worrying that `walk()`<br>&gt;&gt;&gt; has two semantics: something has already gone deeply wrong IMO.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; [Yes, I know there are animals that can sometimes walk on two or four<br>&gt;&gt;&gt; legs. The point here is that the protocols were clearly designed to model<br>&gt;&gt;&gt; animals at a certain level of detail, while it appears that the user<br>&gt;&gt;&gt; writing `MyAnimal` wants to model the animal at a different level of detail<br>&gt;&gt;&gt; than either protocol was designed to handle. You might have specific qualms<br>&gt;&gt;&gt; about this particular hypothetical, but I think you can pick out the<br>&gt;&gt;&gt; general point that there is a much larger problem inherent in the design<br>&gt;&gt;&gt; than the specific problem regarding two colliding method signatures.]<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; There may also be functions in different protocols with different names<br>&gt;&gt;&gt;&gt; but the same semantics and signature.  This will allow a single<br>&gt;&gt;&gt;&gt; implementation to satisfy both protocols without duplication.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This is a poor argument IMO. You can already implement foo() and then<br>&gt;&gt;&gt; have bar() forward to foo() with trivial effort and really minimal<br>&gt;&gt;&gt; boilerplate. It&#39;s an existing solution, and a more general solution because<br>&gt;&gt;&gt; it doesn&#39;t require matching signatures. Also, it&#39;s a better solution IMO<br>&gt;&gt;&gt; because it preserves the notion that a type T : Fooable, Barrable provides<br>&gt;&gt;&gt; the full API guaranteed by Fooable and Barrable.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Finally, we may want to rename an inherited default implementation to<br>&gt;&gt;&gt;&gt; avoid conflicting with another protocol&#39;s default implementation in cases<br>&gt;&gt;&gt;&gt; where we don’t want to override it.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Yes, I think this would be handy. I can&#39;t think of an existing way to do<br>&gt;&gt;&gt; this, and I expect it might make a big difference in designing good<br>&gt;&gt;&gt; protocols. So here, I think we have a strong argument.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Again, though, could we find a concrete example of how this feature<br>&gt;&gt;&gt; would promoter a better design of an actual type and/or protocol?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;  One possibility is to allow a struct/class/enum to conform to the<br>&gt;&gt;&gt;&gt; protocol while renaming one (or both) of the clashing methods:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;         struct C: A,B {<br>&gt;&gt;&gt;&gt;&gt;                 var x:Int<br>&gt;&gt;&gt;&gt;&gt;                 var y:Double implements B.x<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; The conforming method/property would still have to have the same<br>&gt;&gt;&gt;&gt;&gt; signature, but could have a different name (and parameter labels).  It<br>&gt;&gt;&gt;&gt;&gt; would also allow protocol methods which have identical signatures and<br>&gt;&gt;&gt;&gt;&gt; semantics, but different names to be implemented using the same method (i.e<br>&gt;&gt;&gt;&gt;&gt; ‘implements D.z &amp; E.w’).<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; When something is cast to the protocol (say ‘as B’), then calling the<br>&gt;&gt;&gt;&gt;&gt; property (e.g. ‘x’) would end up calling the implementation of the renamed<br>&gt;&gt;&gt;&gt;&gt; property ( ‘y’ in this example) on the conforming type.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Reflecting on this proposed change, it occurs to me that something of<br>&gt;&gt;&gt;&gt; value would be lost, and I think that this something is actually rather<br>&gt;&gt;&gt;&gt; valuable:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Today, when I see that a type conforms to (for example) Sequence, I<br>&gt;&gt;&gt;&gt; know that certain methods and/or properties exist on that type. Protocol<br>&gt;&gt;&gt;&gt; conformance guarantees a certain API, not just certain semantics.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; It isn’t actually lost, however.  When working with it as a Sequence<br>&gt;&gt;&gt;&gt; (for example), that API would be intact using the original names.  It is<br>&gt;&gt;&gt;&gt; only when working with it as its own type that the renaming would have an<br>&gt;&gt;&gt;&gt; effect.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; That is not my point. With this proposal, knowing that MyGreatType<br>&gt;&gt;&gt; conforms to Sequence would no longer yield any information as to the<br>&gt;&gt;&gt; MyGreatType API. That is definitely something lost and we should<br>&gt;&gt;&gt; acknowledge that.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Also, recall that Sequence has Self or associated type requirements. So:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; let m = MyGreatType()<br>&gt;&gt;&gt; // There is nothing I can write here to use the Sequence API with `m`,<br>&gt;&gt;&gt; IIUC;<br>&gt;&gt;&gt; // however, depending on how this feature is designed, I *might* be able<br>&gt;&gt;&gt; to<br>&gt;&gt;&gt; // call a generic function that operates on a type `T : Sequence` and<br>&gt;&gt;&gt; work<br>&gt;&gt;&gt; // with `m` that way.<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Perhaps one way to mitigate this loss would be to have any renamed<br>&gt;&gt;&gt;&gt; members listed *in the declaration of conformance*, something like this<br>&gt;&gt;&gt;&gt; (with some additional bikeshedding):<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; struct MyGreatType : Sequence (count =&gt; length) {<br>&gt;&gt;&gt;&gt;   // MyGreatType conforms to Sequence but renames `count` to `length`<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Yes, putting it in the conformance declaration is a definite<br>&gt;&gt;&gt;&gt; possibility we should consider.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I think we would also want a way to retroactively conform using<br>&gt;&gt;&gt;&gt;&gt; existing properties/methods in an extension declaring conformance.  Not<br>&gt;&gt;&gt;&gt;&gt; sure what the best syntax for that would be.  Off the top of my head<br>&gt;&gt;&gt;&gt;&gt; (though I would love to have something with less cruft):<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;         extension D:B {<br>&gt;&gt;&gt;&gt;&gt;                 @conform(to: B.x, with: D.y)<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; or maybe just:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;         extension D:B {<br>&gt;&gt;&gt;&gt;&gt;                 D.y implements B.x<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; If renamed members are declared along with protocol conformance, then<br>&gt;&gt;&gt;&gt; the syntax for retroactive modeling follows naturally:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; extension D : B (x =&gt; y) { }<br>&gt;&gt;&gt;&gt; // again, the actual notation here is ugly<br>&gt;&gt;&gt;&gt; // but the underlying idea, I think, is worth considering<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Yup<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; One thing I like about this is that it helps to solve the diamond<br>&gt;&gt;&gt;&gt; problem.  ‘x’ could be a default implementation in B which D does not<br>&gt;&gt;&gt;&gt; override.  I think this is an important case which my original proposal<br>&gt;&gt;&gt;&gt; didn’t address fully.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; We should keep bikeshedding the syntax though...<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160823/e32ed689/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>Renaming for Protocol Conformance</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>August 24, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; On Aug 23, 2016, at 8:35 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Tue, Aug 23, 2016 at 3:02 AM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Aug 22, 2016, at 11:32 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Mon, Aug 22, 2016 at 11:59 PM, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Hi everyone,<br>&gt;&gt; <br>&gt;&gt; We talked about this before when we were discussing mixins, and there seemed to be generally positive feelings towards it as a feature for the future.<br>&gt;&gt; <br>&gt;&gt; It&#39;s been some time now since the original discussion, so perhaps you could refresh our collective memory (or at least, mine): although it *seems* like this feature might be useful, I can&#39;t recall a concrete use case where I&#39;ve felt like I needed this feature--do you have some examples?<br>&gt; <br>&gt; Ideally, the biggest use is that it helps to (partially) solve the diamond problem (and similar issues) by forcing/allowing disambiguation when there are multiple protocols being conformed to.  This will become more of an issue if we allow protocols or extensions to add storage.  Your proposed syntax actually does a better job of it than mine because mine was always shown as attached to some sort of implementation, whereas yours could potentially allow access to a default implementation under a new name.<br>&gt; <br>&gt; Other than that, it generally allows us to bypass/mitigate conflicts between protocols.  In the current version, you are unable to conform to both protocols (either because it won’t compile or because you can’t satisfy the semantics of both protocols) without designing the protocols together to avoid conflicts.  (I have definitely had to go back and rename/refactor properties on a protocol for this reason… which I couldn’t have done if I didn’t control both protocols).<br>&gt; <br>&gt; I understand something of the difficulty of confronting the diamond problem. As I wrote above, I&#39;m inclined to believe that this proposed feature would help solve a real issue. However, the point I&#39;m trying to make is that, on reflection, I have never actually been hampered by the lack of this feature, and so I&#39;d like to continue the discussion to get a fuller sense of just how impactful this proposal would be, both positive and negative.<br>&gt; <br>&gt; It&#39;s true, of course, that if you control at least one of two protocols (you don&#39;t need to control both protocols), it is trivially easy to cause this problem to occur, but as you point out it is also possible to resolve the problem by re-designing the protocol you control. I&#39;m inclined to think (without evidence, admittedly) that re-designing to remove the conflict, where possible, would actually be the superior option in most cases.<br>&gt; <br>&gt; My question was: have you actually run into a scenario that necessitates the feature you propose because you controlled neither conflicting protocol? I think it would strengthen the proposal greatly to have a concrete, uncontrived example.<br></p><p>Right now I commonly have to hand-namespace protocol methods/properties to avoid conflicts.  So instead of having ‘var image:UIImage’ (which is the name which makes the most sense in the protocol’s context), I have ‘var protocolNameImage:UIImage’.  There are lots of things which have common properties like ‘count’ which have to be called ‘somethingCount’ or ‘countOfSomething’.  In the context of the protocol, these names are full of redundant words (especially when measured against the new naming guidelines).  We are all used to doing this for Objective C, but it feels out of place in Swift.<br></p><p>This will become a much more serious issue as the third-party code ecosystem grows.  Without some capability like this, you will have frameworks which can’t be used together (or at least with the same object).  I would hate to see a ‘best practice’ emerge of adding 3 letter prefixes to all protocol methods to get around compatibility issues.<br></p><p><br>&gt; Take a look at Eiffel’s ‘rename’ &amp; ’select’ features for similar functionality and use-cases.<br>&gt; <br>&gt; Ultimately, this is a step in the direction of having true mixins.<br>&gt; <br>&gt; <br>&gt; Sure, maybe. I couldn&#39;t evaluate that claim. I&#39;m inclined to favor the proposal, but it&#39;d have to stand on its own merits, not as a step to an as-yet undesigned feature.<br></p><p>This would be part of that design.  We have to start somewhere.  A journey of 1000 miles begins with a single step.<br></p><p><br></p><p>&gt;&gt;    I am fairly certain this affects the ABI though, so I thought I would bring it up now.<br>&gt;&gt; <br>&gt;&gt; If two protocols have methods/properties with the same name, but different signatures, we need a way to distinguish between them when attempting to conform to both.<br>&gt;&gt; <br>&gt;&gt;         protocol A {<br>&gt;&gt;                 var x:Int {get set}<br>&gt;&gt;         }<br>&gt;&gt; <br>&gt;&gt;         protocol B {<br>&gt;&gt;                 var x:Double {get set}<br>&gt;&gt;         }<br>&gt;&gt; <br>&gt;&gt; Methods can be overloaded that differ in arguments or return type, so it seems like this problem mainly exists with *properties* that differ in type--am I wrong?<br>&gt; <br>&gt; There is also the case of functions with the same name and signature, but different semantics.  There may be no single implementation which simultaneously satisfies the semantics for both protocols. By renaming one of the functions, we are able to provide separate implementations for each requirement (which allows both protocols to function as intended).<br>&gt; <br>&gt; True. However, putting on my critical hat, this seems like we&#39;re stretching to provide support for an anti-pattern. It&#39;d be nice to have an example where one runs into the motivating problem *and* where the proposed feature promotes a _better_ design than is currently possible, rather than making a bad design compile.<br>&gt; <br>&gt; At this point, I&#39;m imagining scenarios where a user is trying to conform a type MyAnimal to both Biped and Quadruped, then worrying that `walk()` has two semantics: something has already gone deeply wrong IMO.<br>&gt; <br>&gt; [Yes, I know there are animals that can sometimes walk on two or four legs. The point here is that the protocols were clearly designed to model animals at a certain level of detail, while it appears that the user writing `MyAnimal` wants to model the animal at a different level of detail than either protocol was designed to handle. You might have specific qualms about this particular hypothetical, but I think you can pick out the general point that there is a much larger problem inherent in the design than the specific problem regarding two colliding method signatures.]<br></p><p>To take your example of walk().  Perhaps we have a protocol ‘Walkable’ which refers to any data structure where the nodes can be walked using the ‘walk()’ function.  It is easy to imagine two different protocols A &amp; B which specialize on this in different ways (say LinearWalkable &amp; RandomWalkable), and both add some methods/properties and use those to provide efficient default implementations.  At some point, you may run into a data structure which could easily be walked in both ways.<br></p><p>As things are right now, you couldn’t inherit from both protocols.  While you could add new ‘linearWalk()’ &amp; ‘randomWalk()’ to the protocols respectively (cluttering their interface), there is still the issue of what to do when &#39;walk()’ is called.  You can’t rename walk() in the originating protocols because it comes from their common ancestor.  Much better to force one (or both) of the methods to be renamed on the conforming data structure.  That keeps the interfaces of the protocols clean and makes the options available on the data structure clearer (e.g. ‘walk()’ &amp; ‘randomWalk()’ )<br></p><p>What I have had to do in the current version is inherit from the original protocol and then copy and paste the default implementations from the specialized versions.  Now my code has been duplicated and is harder to maintain.  We can do better.<br></p><p><br></p><p>&gt; There may also be functions in different protocols with different names but the same semantics and signature.  This will allow a single implementation to satisfy both protocols without duplication.<br>&gt; <br>&gt; This is a poor argument IMO. You can already implement foo() and then have bar() forward to foo() with trivial effort and really minimal boilerplate. It&#39;s an existing solution, and a more general solution because it doesn&#39;t require matching signatures. Also, it&#39;s a better solution IMO because it preserves the notion that a type T : Fooable, Barrable provides the full API guaranteed by Fooable and Barrable.<br>&gt; <br>&gt; Finally, we may want to rename an inherited default implementation to avoid conflicting with another protocol&#39;s default implementation in cases where we don’t want to override it.<br>&gt; <br>&gt; Yes, I think this would be handy. I can&#39;t think of an existing way to do this, and I expect it might make a big difference in designing good protocols. So here, I think we have a strong argument.<br>&gt; <br>&gt; Again, though, could we find a concrete example of how this feature would promoter a better design of an actual type and/or protocol?<br>&gt; <br>&gt;&gt;  One possibility is to allow a struct/class/enum to conform to the protocol while renaming one (or both) of the clashing methods:<br>&gt;&gt; <br>&gt;&gt;         struct C: A,B {<br>&gt;&gt;                 var x:Int<br>&gt;&gt;                 var y:Double implements B.x<br>&gt;&gt;         }<br>&gt;&gt; <br>&gt;&gt; The conforming method/property would still have to have the same signature, but could have a different name (and parameter labels).  It would also allow protocol methods which have identical signatures and semantics, but different names to be implemented using the same method (i.e ‘implements D.z &amp; E.w’).<br>&gt;&gt; <br>&gt;&gt; When something is cast to the protocol (say ‘as B’), then calling the property (e.g. ‘x’) would end up calling the implementation of the renamed property ( ‘y’ in this example) on the conforming type.<br>&gt;&gt; <br>&gt;&gt; Reflecting on this proposed change, it occurs to me that something of value would be lost, and I think that this something is actually rather valuable:<br>&gt;&gt; <br>&gt;&gt; Today, when I see that a type conforms to (for example) Sequence, I know that certain methods and/or properties exist on that type. Protocol conformance guarantees a certain API, not just certain semantics.<br>&gt; <br>&gt; It isn’t actually lost, however.  When working with it as a Sequence (for example), that API would be intact using the original names.  It is only when working with it as its own type that the renaming would have an effect.<br>&gt; <br>&gt; That is not my point. With this proposal, knowing that MyGreatType conforms to Sequence would no longer yield any information as to the MyGreatType API. That is definitely something lost and we should acknowledge that.<br>&gt; <br>&gt; Also, recall that Sequence has Self or associated type requirements. So:<br>&gt; <br>&gt; ```<br>&gt; let m = MyGreatType()<br>&gt; // There is nothing I can write here to use the Sequence API with `m`, IIUC;<br>&gt; // however, depending on how this feature is designed, I *might* be able to<br>&gt; // call a generic function that operates on a type `T : Sequence` and work<br>&gt; // with `m` that way.<br>&gt; ```<br></p><p>I get what you are saying, but this is really asking for an Xcode feature to better show the generated interfaces.  Code completion will still work properly.<br></p><p><br></p><p>&gt; <br>&gt;&gt; Perhaps one way to mitigate this loss would be to have any renamed members listed *in the declaration of conformance*, something like this (with some additional bikeshedding):<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; struct MyGreatType : Sequence (count =&gt; length) {<br>&gt;&gt;   // MyGreatType conforms to Sequence but renames `count` to `length`<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt; <br>&gt; Yes, putting it in the conformance declaration is a definite possibility we should consider.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; I think we would also want a way to retroactively conform using existing properties/methods in an extension declaring conformance.  Not sure what the best syntax for that would be.  Off the top of my head (though I would love to have something with less cruft):<br>&gt;&gt; <br>&gt;&gt;         extension D:B {<br>&gt;&gt;                 @conform(to: B.x, with: D.y)<br>&gt;&gt;         }<br>&gt;&gt; <br>&gt;&gt; or maybe just:<br>&gt;&gt; <br>&gt;&gt;         extension D:B {<br>&gt;&gt;                 D.y implements B.x<br>&gt;&gt;         }<br>&gt;&gt; <br>&gt;&gt; If renamed members are declared along with protocol conformance, then the syntax for retroactive modeling follows naturally:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; extension D : B (x =&gt; y) { }<br>&gt;&gt; // again, the actual notation here is ugly<br>&gt;&gt; // but the underlying idea, I think, is worth considering<br>&gt;&gt; ```<br>&gt; <br>&gt; Yup<br>&gt; <br>&gt; One thing I like about this is that it helps to solve the diamond problem.  ‘x’ could be a default implementation in B which D does not override.  I think this is an important case which my original proposal didn’t address fully.<br>&gt; <br>&gt; We should keep bikeshedding the syntax though...<br>&gt; <br>&gt; Thanks,<br>&gt; Jon<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160824/2e48ffce/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Renaming for Protocol Conformance</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>August 24, 2016 at 03:00:00am</p></header><div class="content"><p>&gt; On Aug 24, 2016, at 3:39 AM, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; To take your example of walk().  Perhaps we have a protocol ‘Walkable’ which refers to any data structure where the nodes can be walked using the ‘walk()’ function.  It is easy to imagine two different protocols A &amp; B which specialize on this in different ways (say LinearWalkable &amp; RandomWalkable), and both add some methods/properties and use those to provide efficient default implementations.  At some point, you may run into a data structure which could easily be walked in both ways.<br>&gt; <br>&gt; As things are right now, you couldn’t inherit from both protocols.  While you could add new ‘linearWalk()’ &amp; ‘randomWalk()’ to the protocols respectively (cluttering their interface), there is still the issue of what to do when &#39;walk()’ is called.  You can’t rename walk() in the originating protocols because it comes from their common ancestor.  Much better to force one (or both) of the methods to be renamed on the conforming data structure.  That keeps the interfaces of the protocols clean and makes the options available on the data structure clearer (e.g. ‘walk()’ &amp; ‘randomWalk()’ )<br>&gt; <br>&gt; What I have had to do in the current version is inherit from the original protocol and then copy and paste the default implementations from the specialized versions.  Now my code has been duplicated and is harder to maintain.  We can do better.<br></p><p>I had a very similar situation, in fact. I solved it like this (using your protocol names for the purpose of making it easily contrastable):<br></p><p>protocol Walkable {<br>	func walk()<br>}<br></p><p>protocol LinearWalkable: Walkable {<br>	func linearWalk()	<br>}<br></p><p>extension LinearWalkable {<br>	func linearWalk { … }<br></p><p>	func walk() { self.linearWalk() }<br>}<br></p><p>protocol RandomWalkable {<br>	func randomWalk()<br>}<br></p><p>extension RandomWalkable {<br>	func randomWalk() { … }<br></p><p>	func walk() { self.randomWalk() }<br>}<br></p><p>struct S: LinearWalkable, RandomWalkable {<br>	func walk() { self.linearWalk() }<br>}<br></p><p>Thus a type that implements one or the other of the protocols gets walk() automatically doing the right thing, and a type that implements both has to explicitly choose. This way at least avoids the duplication of code; however, it is quite ugly to have to systematically duplicate essentially every method in the protocols (and there turned out to be quite a few of these).<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160824/c1926cae/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Renaming for Protocol Conformance</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 24, 2016 at 09:00:00am</p></header><div class="content"><p>On Wed, Aug 24, 2016 at 3:39 AM, Jonathan Hull &lt;jhull at gbis.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Aug 23, 2016, at 8:35 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Tue, Aug 23, 2016 at 3:02 AM, Jonathan Hull &lt;jhull at gbis.com&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Aug 22, 2016, at 11:32 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Mon, Aug 22, 2016 at 11:59 PM, Jonathan Hull via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Hi everyone,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; We talked about this before when we were discussing mixins, and there<br>&gt;&gt;&gt; seemed to be generally positive feelings towards it as a feature for the<br>&gt;&gt;&gt; future.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; It&#39;s been some time now since the original discussion, so perhaps you<br>&gt;&gt; could refresh our collective memory (or at least, mine): although it<br>&gt;&gt; *seems* like this feature might be useful, I can&#39;t recall a concrete use<br>&gt;&gt; case where I&#39;ve felt like I needed this feature--do you have some examples?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Ideally, the biggest use is that it helps to (partially) solve the<br>&gt;&gt; diamond problem (and similar issues) by forcing/allowing disambiguation<br>&gt;&gt; when there are multiple protocols being conformed to.  This will become<br>&gt;&gt; more of an issue if we allow protocols or extensions to add storage.  Your<br>&gt;&gt; proposed syntax actually does a better job of it than mine because mine was<br>&gt;&gt; always shown as attached to some sort of implementation, whereas yours<br>&gt;&gt; could potentially allow access to a default implementation under a new name.<br>&gt;&gt;<br>&gt;&gt; Other than that, it generally allows us to bypass/mitigate conflicts<br>&gt;&gt; between protocols.  In the current version, you are unable to conform to<br>&gt;&gt; both protocols (either because it won’t compile or because you can’t<br>&gt;&gt; satisfy the semantics of both protocols) without designing the protocols<br>&gt;&gt; together to avoid conflicts.  (I have definitely had to go back and<br>&gt;&gt; rename/refactor properties on a protocol for this reason… which I couldn’t<br>&gt;&gt; have done if I didn’t control both protocols).<br>&gt;&gt;<br>&gt;<br>&gt; I understand something of the difficulty of confronting the diamond<br>&gt; problem. As I wrote above, I&#39;m inclined to believe that this proposed<br>&gt; feature would help solve a real issue. However, the point I&#39;m trying to<br>&gt; make is that, on reflection, I have never actually been hampered by the<br>&gt; lack of this feature, and so I&#39;d like to continue the discussion to get a<br>&gt; fuller sense of just how impactful this proposal would be, both positive<br>&gt; and negative.<br>&gt;<br>&gt; It&#39;s true, of course, that if you control at least one of two protocols<br>&gt; (you don&#39;t need to control both protocols), it is trivially easy to cause<br>&gt; this problem to occur, but as you point out it is also possible to resolve<br>&gt; the problem by re-designing the protocol you control. I&#39;m inclined to think<br>&gt; (without evidence, admittedly) that re-designing to remove the conflict,<br>&gt; where possible, would actually be the superior option in most cases.<br>&gt;<br>&gt; My question was: have you actually run into a scenario that necessitates<br>&gt; the feature you propose because you controlled neither conflicting<br>&gt; protocol? I think it would strengthen the proposal greatly to have a<br>&gt; concrete, uncontrived example.<br>&gt;<br>&gt;<br>&gt; Right now I commonly have to hand-namespace protocol methods/properties to<br>&gt; avoid conflicts.  So instead of having ‘var image:UIImage’ (which is the<br>&gt; name which makes the most sense in the protocol’s context), I have ‘var<br>&gt; protocolNameImage:UIImage’.  There are lots of things which have common<br>&gt; properties like ‘count’ which have to be called ‘somethingCount’ or<br>&gt; ‘countOfSomething’.  In the context of the protocol, these names are full<br>&gt; of redundant words (especially when measured against the new naming<br>&gt; guidelines).  We are all used to doing this for Objective C, but it feels<br>&gt; out of place in Swift.<br>&gt;<br>&gt; This will become a much more serious issue as the third-party code<br>&gt; ecosystem grows.  Without some capability like this, you will have<br>&gt; frameworks which can’t be used together (or at least with the same<br>&gt; object).  I would hate to see a ‘best practice’ emerge of adding 3 letter<br>&gt; prefixes to all protocol methods to get around compatibility issues.<br>&gt;<br></p><p>Ah, well this isn&#39;t exactly the diamond problem you&#39;re talking about here.<br>Instead, I think, we have a fundamental disagreement. I think I&#39;ve been<br>told that this opinion of mine is &#39;insane&#39;--but I hold to it:<br></p><p>Protocols are not merely a vehicle for delivering a reusable bag of code.<br>One of its most essential purposes is to constrain the shape or API of its<br>conforming types. Therefore, it is a feature, not a bug, that with every<br>choice of name in a protocol you foreclose the possibility of composing<br>that protocol with others that might have colliding names.<br></p><p>Currently, if you the protocol vendor have made the decision that `image`<br>&quot;makes the most sense in the protocol&#39;s context&quot;, you must have considered<br>whether it would be absurd for a conforming type to have another use for<br>`image`. If it would be absurd, then `image` is the appropriate name for<br>your protocol requirement and any other word would truly be redundant. But,<br>if this is only one of many plausible images, then `somethingImage` or<br>`imageOfSomething` *is* the appropriate name, and trying to shorten the<br>name isn&#39;t at all consistent with Swift guidelines but rather an incorrect<br>attempt to prioritize brevity over clarity.<br></p><p>What you&#39;re arguing is that protocol designers should be able to design<br>protocols without regard for how they will compose with others in<br>conforming types, relying on a new member-renaming feature instead. But, as<br>you point out, you can already use a protocol as a mere bag of code by<br>naming all members with unique, prefixed names, then have conforming types<br>forward their own choice of names to these.<br></p><p>This member-renaming feature you propose would enhance the aesthetic<br>pleasure of the protocol designer, allowing simple names that don&#39;t ever<br>have to appear in the public API of a concrete type to be used for a<br>protocol member without placing any restrictions on the API of conforming<br>types. However, I don&#39;t see anything wrong with the current hand-prefixing<br>method being enshrined as &quot;best practice&quot; for the bag-of-code approach to<br>protocols. If, as you predict, a growing third-party code ecosystem makes<br>name collisions worse, then in fact having uniquely distinguishable<br>prefixed members would be less confusing than having conforming types<br>renaming protocol members as a matter of course.<br></p><p>Take a look at Eiffel’s ‘rename’ &amp; ’select’ features for similar<br>&gt;&gt; functionality and use-cases.<br>&gt;&gt;<br>&gt;&gt; Ultimately, this is a step in the direction of having true mixins.<br>&gt;&gt;<br>&gt;&gt;<br>&gt; Sure, maybe. I couldn&#39;t evaluate that claim. I&#39;m inclined to favor the<br>&gt; proposal, but it&#39;d have to stand on its own merits, not as a step to an<br>&gt; as-yet undesigned feature.<br>&gt;<br>&gt;<br>&gt; This would be part of that design.  We have to start somewhere.  A journey<br>&gt; of 1000 miles begins with a single step.<br>&gt;<br>&gt;<br>&gt;<br>&gt;    I am fairly certain this affects the ABI though, so I thought I would<br>&gt;&gt; bring it up now.<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If two protocols have methods/properties with the same name, but<br>&gt;&gt;&gt; different signatures, we need a way to distinguish between them when<br>&gt;&gt;&gt; attempting to conform to both.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         protocol A {<br>&gt;&gt;&gt;                 var x:Int {get set}<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         protocol B {<br>&gt;&gt;&gt;                 var x:Double {get set}<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Methods can be overloaded that differ in arguments or return type, so it<br>&gt;&gt; seems like this problem mainly exists with *properties* that differ in<br>&gt;&gt; type--am I wrong?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; There is also the case of functions with the same name and signature, but<br>&gt;&gt; different semantics.  There may be no single implementation which<br>&gt;&gt; simultaneously satisfies the semantics for both protocols. By renaming one<br>&gt;&gt; of the functions, we are able to provide separate implementations for each<br>&gt;&gt; requirement (which allows both protocols to function as intended).<br>&gt;&gt;<br>&gt;<br>&gt; True. However, putting on my critical hat, this seems like we&#39;re<br>&gt; stretching to provide support for an anti-pattern. It&#39;d be nice to have an<br>&gt; example where one runs into the motivating problem *and* where the proposed<br>&gt; feature promotes a _better_ design than is currently possible, rather than<br>&gt; making a bad design compile.<br>&gt;<br>&gt; At this point, I&#39;m imagining scenarios where a user is trying to conform a<br>&gt; type MyAnimal to both Biped and Quadruped, then worrying that `walk()` has<br>&gt; two semantics: something has already gone deeply wrong IMO.<br>&gt;<br>&gt; [Yes, I know there are animals that can sometimes walk on two or four<br>&gt; legs. The point here is that the protocols were clearly designed to model<br>&gt; animals at a certain level of detail, while it appears that the user<br>&gt; writing `MyAnimal` wants to model the animal at a different level of detail<br>&gt; than either protocol was designed to handle. You might have specific qualms<br>&gt; about this particular hypothetical, but I think you can pick out the<br>&gt; general point that there is a much larger problem inherent in the design<br>&gt; than the specific problem regarding two colliding method signatures.]<br>&gt;<br>&gt;<br>&gt; To take your example of walk().  Perhaps we have a protocol ‘Walkable’<br>&gt; which refers to any data structure where the nodes can be walked using the<br>&gt; ‘walk()’ function.  It is easy to imagine two different protocols A &amp; B<br>&gt; which specialize on this in different ways (say LinearWalkable &amp;<br>&gt; RandomWalkable), and both add some methods/properties and use those to<br>&gt; provide efficient default implementations.  At some point, you may run into<br>&gt; a data structure which could easily be walked in both ways.<br>&gt;<br>&gt; As things are right now, you couldn’t inherit from both protocols.  While<br>&gt; you could add new ‘linearWalk()’ &amp; ‘randomWalk()’ to the protocols<br>&gt; respectively (cluttering their interface), there is still the issue of what<br>&gt; to do when &#39;walk()’ is called.  You can’t rename walk() in the originating<br>&gt; protocols because it comes from their common ancestor.  Much better to<br>&gt; force one (or both) of the methods to be renamed on the conforming data<br>&gt; structure.  That keeps the interfaces of the protocols clean and makes the<br>&gt; options available on the data structure clearer (e.g. ‘walk()’ &amp;<br>&gt; ‘randomWalk()’ )<br>&gt;<br>&gt; What I have had to do in the current version is inherit from the original<br>&gt; protocol and then copy and paste the default implementations from the<br>&gt; specialized versions.  Now my code has been duplicated and is harder to<br>&gt; maintain.  We can do better.<br>&gt;<br>&gt;<br>I think Charles&#39;s solution is pretty nice, but he&#39;s right that the API<br>surface area will have to grow. I don&#39;t know his original use case, so I<br>don&#39;t know how ugly I&#39;d find the final solution to be in that scenario. In<br>this particular example, I&#39;d say that having `linearWalk()` and<br>`randomWalk()` distinguished seems pretty sensible and an overall win for<br>clarity. If the same vendor controlled all three protocols, then `Walkable`<br>could have the `walk()` requirement removed altogether for even more<br>clarity.<br></p><p>Also, just a hunch, but I suspect your hypothetical would never hold. Could<br>you envision how the requirements for RandomWalkable might be such that<br>it&#39;s possible to implement an efficient _default_ implementation of a<br>random walk for any of several conforming data structures, but only one of<br>these data structures is LinearWalkable, _and_ such a linear walk is<br>efficient using another _default_implementation for an overlapping but not<br>identical set of data structures? It&#39;s not mere trivia here, because the<br>crux of your argument is that there exist default implementations that<br>require copying and pasting into conforming types (and sufficiently<br>efficient default implementations so that copying and pasting is<br>appropriate rather than implementing a more efficient version). More likely<br>in diamond problem scenarios, I think, colliding members are going to be<br>properties or methods either without default implementations or than need<br>to supply more efficient versions of default implementations anyway.<br></p><p>There may also be functions in different protocols with different names but<br>&gt;&gt; the same semantics and signature.  This will allow a single implementation<br>&gt;&gt; to satisfy both protocols without duplication.<br>&gt;&gt;<br>&gt;<br>&gt; This is a poor argument IMO. You can already implement foo() and then have<br>&gt; bar() forward to foo() with trivial effort and really minimal boilerplate.<br>&gt; It&#39;s an existing solution, and a more general solution because it doesn&#39;t<br>&gt; require matching signatures. Also, it&#39;s a better solution IMO because it<br>&gt; preserves the notion that a type T : Fooable, Barrable provides the full<br>&gt; API guaranteed by Fooable and Barrable.<br>&gt;<br>&gt; Finally, we may want to rename an inherited default implementation to<br>&gt;&gt; avoid conflicting with another protocol&#39;s default implementation in cases<br>&gt;&gt; where we don’t want to override it.<br>&gt;&gt;<br>&gt;<br>&gt; Yes, I think this would be handy. I can&#39;t think of an existing way to do<br>&gt; this, and I expect it might make a big difference in designing good<br>&gt; protocols. So here, I think we have a strong argument.<br>&gt;<br>&gt; Again, though, could we find a concrete example of how this feature would<br>&gt; promoter a better design of an actual type and/or protocol?<br>&gt;<br>&gt;  One possibility is to allow a struct/class/enum to conform to the<br>&gt;&gt; protocol while renaming one (or both) of the clashing methods:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         struct C: A,B {<br>&gt;&gt;&gt;                 var x:Int<br>&gt;&gt;&gt;                 var y:Double implements B.x<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The conforming method/property would still have to have the same<br>&gt;&gt;&gt; signature, but could have a different name (and parameter labels).  It<br>&gt;&gt;&gt; would also allow protocol methods which have identical signatures and<br>&gt;&gt;&gt; semantics, but different names to be implemented using the same method (i.e<br>&gt;&gt;&gt; ‘implements D.z &amp; E.w’).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; When something is cast to the protocol (say ‘as B’), then calling the<br>&gt;&gt;&gt; property (e.g. ‘x’) would end up calling the implementation of the renamed<br>&gt;&gt;&gt; property ( ‘y’ in this example) on the conforming type.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Reflecting on this proposed change, it occurs to me that something of<br>&gt;&gt; value would be lost, and I think that this something is actually rather<br>&gt;&gt; valuable:<br>&gt;&gt;<br>&gt;&gt; Today, when I see that a type conforms to (for example) Sequence, I know<br>&gt;&gt; that certain methods and/or properties exist on that type. Protocol<br>&gt;&gt; conformance guarantees a certain API, not just certain semantics.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; It isn’t actually lost, however.  When working with it as a Sequence (for<br>&gt;&gt; example), that API would be intact using the original names.  It is only<br>&gt;&gt; when working with it as its own type that the renaming would have an effect.<br>&gt;&gt;<br>&gt;<br>&gt; That is not my point. With this proposal, knowing that MyGreatType<br>&gt; conforms to Sequence would no longer yield any information as to the<br>&gt; MyGreatType API. That is definitely something lost and we should<br>&gt; acknowledge that.<br>&gt;<br>&gt; Also, recall that Sequence has Self or associated type requirements. So:<br>&gt;<br>&gt; ```<br>&gt; let m = MyGreatType()<br>&gt; // There is nothing I can write here to use the Sequence API with `m`,<br>&gt; IIUC;<br>&gt; // however, depending on how this feature is designed, I *might* be able to<br>&gt; // call a generic function that operates on a type `T : Sequence` and work<br>&gt; // with `m` that way.<br>&gt; ```<br>&gt;<br>&gt;<br>&gt; I get what you are saying, but this is really asking for an Xcode feature<br>&gt; to better show the generated interfaces.  Code completion will still work<br>&gt; properly.<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; Perhaps one way to mitigate this loss would be to have any renamed members<br>&gt;&gt; listed *in the declaration of conformance*, something like this (with some<br>&gt;&gt; additional bikeshedding):<br>&gt;&gt;<br>&gt;&gt; ```<br>&gt;&gt; struct MyGreatType : Sequence (count =&gt; length) {<br>&gt;&gt;   // MyGreatType conforms to Sequence but renames `count` to `length`<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Yes, putting it in the conformance declaration is a definite possibility<br>&gt;&gt; we should consider.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I think we would also want a way to retroactively conform using existing<br>&gt;&gt;&gt; properties/methods in an extension declaring conformance.  Not sure what<br>&gt;&gt;&gt; the best syntax for that would be.  Off the top of my head (though I would<br>&gt;&gt;&gt; love to have something with less cruft):<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         extension D:B {<br>&gt;&gt;&gt;                 @conform(to: B.x, with: D.y)<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; or maybe just:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         extension D:B {<br>&gt;&gt;&gt;                 D.y implements B.x<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; If renamed members are declared along with protocol conformance, then the<br>&gt;&gt; syntax for retroactive modeling follows naturally:<br>&gt;&gt;<br>&gt;&gt; ```<br>&gt;&gt; extension D : B (x =&gt; y) { }<br>&gt;&gt; // again, the actual notation here is ugly<br>&gt;&gt; // but the underlying idea, I think, is worth considering<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Yup<br>&gt;&gt;<br>&gt;&gt; One thing I like about this is that it helps to solve the diamond<br>&gt;&gt; problem.  ‘x’ could be a default implementation in B which D does not<br>&gt;&gt; override.  I think this is an important case which my original proposal<br>&gt;&gt; didn’t address fully.<br>&gt;&gt;<br>&gt;&gt; We should keep bikeshedding the syntax though...<br>&gt;&gt;<br>&gt;&gt; Thanks,<br>&gt;&gt; Jon<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160824/aaab6c74/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>Renaming for Protocol Conformance</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>August 24, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Aug 24, 2016, at 7:48 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Wed, Aug 24, 2016 at 3:39 AM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Aug 23, 2016, at 8:35 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Tue, Aug 23, 2016 at 3:02 AM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Aug 22, 2016, at 11:32 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Mon, Aug 22, 2016 at 11:59 PM, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; Hi everyone,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We talked about this before when we were discussing mixins, and there seemed to be generally positive feelings towards it as a feature for the future.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s been some time now since the original discussion, so perhaps you could refresh our collective memory (or at least, mine): although it *seems* like this feature might be useful, I can&#39;t recall a concrete use case where I&#39;ve felt like I needed this feature--do you have some examples?<br>&gt;&gt; <br>&gt;&gt; Ideally, the biggest use is that it helps to (partially) solve the diamond problem (and similar issues) by forcing/allowing disambiguation when there are multiple protocols being conformed to.  This will become more of an issue if we allow protocols or extensions to add storage.  Your proposed syntax actually does a better job of it than mine because mine was always shown as attached to some sort of implementation, whereas yours could potentially allow access to a default implementation under a new name.<br>&gt;&gt; <br>&gt;&gt; Other than that, it generally allows us to bypass/mitigate conflicts between protocols.  In the current version, you are unable to conform to both protocols (either because it won’t compile or because you can’t satisfy the semantics of both protocols) without designing the protocols together to avoid conflicts.  (I have definitely had to go back and rename/refactor properties on a protocol for this reason… which I couldn’t have done if I didn’t control both protocols).<br>&gt;&gt; <br>&gt;&gt; I understand something of the difficulty of confronting the diamond problem. As I wrote above, I&#39;m inclined to believe that this proposed feature would help solve a real issue. However, the point I&#39;m trying to make is that, on reflection, I have never actually been hampered by the lack of this feature, and so I&#39;d like to continue the discussion to get a fuller sense of just how impactful this proposal would be, both positive and negative.<br>&gt;&gt; <br>&gt;&gt; It&#39;s true, of course, that if you control at least one of two protocols (you don&#39;t need to control both protocols), it is trivially easy to cause this problem to occur, but as you point out it is also possible to resolve the problem by re-designing the protocol you control. I&#39;m inclined to think (without evidence, admittedly) that re-designing to remove the conflict, where possible, would actually be the superior option in most cases.<br>&gt;&gt; <br>&gt;&gt; My question was: have you actually run into a scenario that necessitates the feature you propose because you controlled neither conflicting protocol? I think it would strengthen the proposal greatly to have a concrete, uncontrived example.<br>&gt; <br>&gt; Right now I commonly have to hand-namespace protocol methods/properties to avoid conflicts.  So instead of having ‘var image:UIImage’ (which is the name which makes the most sense in the protocol’s context), I have ‘var protocolNameImage:UIImage’.  There are lots of things which have common properties like ‘count’ which have to be called ‘somethingCount’ or ‘countOfSomething’.  In the context of the protocol, these names are full of redundant words (especially when measured against the new naming guidelines).  We are all used to doing this for Objective C, but it feels out of place in Swift.<br>&gt; <br>&gt; This will become a much more serious issue as the third-party code ecosystem grows.  Without some capability like this, you will have frameworks which can’t be used together (or at least with the same object).  I would hate to see a ‘best practice’ emerge of adding 3 letter prefixes to all protocol methods to get around compatibility issues.<br>&gt; <br>&gt; Ah, well this isn&#39;t exactly the diamond problem you&#39;re talking about here. Instead, I think, we have a fundamental disagreement. I think I&#39;ve been told that this opinion of mine is &#39;insane&#39;--but I hold to it:<br></p><p>Well you asked for an additional example besides the diamond problem… so no it isn’t.  I did include a diamond problem example further down though…<br></p><p><br>&gt; Protocols are not merely a vehicle for delivering a reusable bag of code. One of its most essential purposes is to constrain the shape or API of its conforming types. Therefore, it is a feature, not a bug, that with every choice of name in a protocol you foreclose the possibility of composing that protocol with others that might have colliding names.<br>&gt; <br>&gt; Currently, if you the protocol vendor have made the decision that `image` &quot;makes the most sense in the protocol&#39;s context&quot;, you must have considered whether it would be absurd for a conforming type to have another use for `image`. If it would be absurd, then `image` is the appropriate name for your protocol requirement and any other word would truly be redundant. But, if this is only one of many plausible images, then `somethingImage` or `imageOfSomething` *is* the appropriate name, and trying to shorten the name isn&#39;t at all consistent with Swift guidelines but rather an incorrect attempt to prioritize brevity over clarity.<br></p><p>Most things that conform would have ‘image’, and it would have exactly the same semantics as my protocol. Thus their ‘image’ would provide conformance without additional work.  But I have to worry about name collisions, so now I have to defensively call it ‘imageOfSomething&#39;, which they now have to implement to call their ‘image’ method.<br></p><p><br>&gt; What you&#39;re arguing is that protocol designers should be able to design protocols without regard for how they will compose with others in conforming types, relying on a new member-renaming feature instead. But, as you point out, you can already use a protocol as a mere bag of code by naming all members with unique, prefixed names, then have conforming types forward their own choice of names to these.<br></p><p>No, I am arguing that protocol authors should design protocols in the way which makes the behavior/semantics of the protocol the most obvious to the caller.  95% of the time there won’t be collisions, but occasionally there will be and we have to have a plan for that.<br></p><p><br>&gt; This member-renaming feature you propose would enhance the aesthetic pleasure of the protocol designer, allowing simple names that don&#39;t ever have to appear in the public API of a concrete type to be used for a protocol member without placing any restrictions on the API of conforming types. However, I don&#39;t see anything wrong with the current hand-prefixing method being enshrined as &quot;best practice&quot; for the bag-of-code approach to protocols. If, as you predict, a growing third-party code ecosystem makes name collisions worse, then in fact having uniquely distinguishable prefixed members would be less confusing than having conforming types renaming protocol members as a matter of course.<br></p><p>You are arguing that namespace collisions are a feature instead of a bug?  Did you feel that way about ObjectiveC’s lack of name spacing?<br></p><p>I don’t think it is anywhere near as confusing as you suggest. As I mentioned before, if you cast it to the protocol, then the original names will still work.  If you are trying to type the original name on the typed conformer, then showing the renamed version (with an indication of the renaming) in autocomplete should teach the change and clear up any confusion.<br></p><p><br></p><p>&gt; To take your example of walk().  Perhaps we have a protocol ‘Walkable’ which refers to any data structure where the nodes can be walked using the ‘walk()’ function.  It is easy to imagine two different protocols A &amp; B which specialize on this in different ways (say LinearWalkable &amp; RandomWalkable), and both add some methods/properties and use those to provide efficient default implementations.  At some point, you may run into a data structure which could easily be walked in both ways.<br>&gt; <br>&gt; As things are right now, you couldn’t inherit from both protocols.  While you could add new ‘linearWalk()’ &amp; ‘randomWalk()’ to the protocols respectively (cluttering their interface), there is still the issue of what to do when &#39;walk()’ is called.  You can’t rename walk() in the originating protocols because it comes from their common ancestor.  Much better to force one (or both) of the methods to be renamed on the conforming data structure.  That keeps the interfaces of the protocols clean and makes the options available on the data structure clearer (e.g. ‘walk()’ &amp; ‘randomWalk()’ )<br>&gt; <br>&gt; What I have had to do in the current version is inherit from the original protocol and then copy and paste the default implementations from the specialized versions.  Now my code has been duplicated and is harder to maintain.  We can do better.<br>&gt; <br>&gt; <br>&gt; I think Charles&#39;s solution is pretty nice, but he&#39;s right that the API surface area will have to grow. I don&#39;t know his original use case, so I don&#39;t know how ugly I&#39;d find the final solution to be in that scenario. In this particular example, I&#39;d say that having `linearWalk()` and `randomWalk()` distinguished seems pretty sensible and an overall win for clarity. If the same vendor controlled all three protocols, then `Walkable` could have the `walk()` requirement removed altogether for even more clarity.<br></p><p>So you would remove &#39;walk()&#39; from Walkable to avoid the name collision in this one case, when ‘walk()’ is Walkable’s entire reason for being?  Also, you would lose polymorphism.<br></p><p><br></p><p>&gt; Also, just a hunch, but I suspect your hypothetical would never hold. Could you envision how the requirements for RandomWalkable might be such that it&#39;s possible to implement an efficient _default_ implementation of a random walk for any of several conforming data structures, but only one of these data structures is LinearWalkable, _and_ such a linear walk is efficient using another _default_implementation for an overlapping but not identical set of data structures? It&#39;s not mere trivia here, because the crux of your argument is that there exist default implementations that require copying and pasting into conforming types (and sufficiently efficient default implementations so that copying and pasting is appropriate rather than implementing a more efficient version). More likely in diamond problem scenarios, I think, colliding members are going to be properties or methods either without default implementations or than need to supply more efficient versions of default implementations anyway.<br></p><p>Based on what?  There is a reason the diamond problem has a name (and a wikipedia entry).  Charles just said he ran into a problem like this.  I have run into it in the past as well.<br></p><p><br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160824/79079982/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Renaming for Protocol Conformance</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 24, 2016 at 02:00:00pm</p></header><div class="content"><p>On Wed, Aug 24, 2016 at 1:59 PM, Jonathan Hull &lt;jhull at gbis.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Aug 24, 2016, at 7:48 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Wed, Aug 24, 2016 at 3:39 AM, Jonathan Hull &lt;jhull at gbis.com&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Aug 23, 2016, at 8:35 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Tue, Aug 23, 2016 at 3:02 AM, Jonathan Hull &lt;jhull at gbis.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Aug 22, 2016, at 11:32 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Mon, Aug 22, 2016 at 11:59 PM, Jonathan Hull via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Hi everyone,<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; We talked about this before when we were discussing mixins, and there<br>&gt;&gt;&gt;&gt; seemed to be generally positive feelings towards it as a feature for the<br>&gt;&gt;&gt;&gt; future.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It&#39;s been some time now since the original discussion, so perhaps you<br>&gt;&gt;&gt; could refresh our collective memory (or at least, mine): although it<br>&gt;&gt;&gt; *seems* like this feature might be useful, I can&#39;t recall a concrete use<br>&gt;&gt;&gt; case where I&#39;ve felt like I needed this feature--do you have some examples?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Ideally, the biggest use is that it helps to (partially) solve the<br>&gt;&gt;&gt; diamond problem (and similar issues) by forcing/allowing disambiguation<br>&gt;&gt;&gt; when there are multiple protocols being conformed to.  This will become<br>&gt;&gt;&gt; more of an issue if we allow protocols or extensions to add storage.  Your<br>&gt;&gt;&gt; proposed syntax actually does a better job of it than mine because mine was<br>&gt;&gt;&gt; always shown as attached to some sort of implementation, whereas yours<br>&gt;&gt;&gt; could potentially allow access to a default implementation under a new name.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Other than that, it generally allows us to bypass/mitigate conflicts<br>&gt;&gt;&gt; between protocols.  In the current version, you are unable to conform to<br>&gt;&gt;&gt; both protocols (either because it won’t compile or because you can’t<br>&gt;&gt;&gt; satisfy the semantics of both protocols) without designing the protocols<br>&gt;&gt;&gt; together to avoid conflicts.  (I have definitely had to go back and<br>&gt;&gt;&gt; rename/refactor properties on a protocol for this reason… which I couldn’t<br>&gt;&gt;&gt; have done if I didn’t control both protocols).<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I understand something of the difficulty of confronting the diamond<br>&gt;&gt; problem. As I wrote above, I&#39;m inclined to believe that this proposed<br>&gt;&gt; feature would help solve a real issue. However, the point I&#39;m trying to<br>&gt;&gt; make is that, on reflection, I have never actually been hampered by the<br>&gt;&gt; lack of this feature, and so I&#39;d like to continue the discussion to get a<br>&gt;&gt; fuller sense of just how impactful this proposal would be, both positive<br>&gt;&gt; and negative.<br>&gt;&gt;<br>&gt;&gt; It&#39;s true, of course, that if you control at least one of two protocols<br>&gt;&gt; (you don&#39;t need to control both protocols), it is trivially easy to cause<br>&gt;&gt; this problem to occur, but as you point out it is also possible to resolve<br>&gt;&gt; the problem by re-designing the protocol you control. I&#39;m inclined to think<br>&gt;&gt; (without evidence, admittedly) that re-designing to remove the conflict,<br>&gt;&gt; where possible, would actually be the superior option in most cases.<br>&gt;&gt;<br>&gt;&gt; My question was: have you actually run into a scenario that necessitates<br>&gt;&gt; the feature you propose because you controlled neither conflicting<br>&gt;&gt; protocol? I think it would strengthen the proposal greatly to have a<br>&gt;&gt; concrete, uncontrived example.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Right now I commonly have to hand-namespace protocol methods/properties<br>&gt;&gt; to avoid conflicts.  So instead of having ‘var image:UIImage’ (which is the<br>&gt;&gt; name which makes the most sense in the protocol’s context), I have ‘var<br>&gt;&gt; protocolNameImage:UIImage’.  There are lots of things which have common<br>&gt;&gt; properties like ‘count’ which have to be called ‘somethingCount’ or<br>&gt;&gt; ‘countOfSomething’.  In the context of the protocol, these names are full<br>&gt;&gt; of redundant words (especially when measured against the new naming<br>&gt;&gt; guidelines).  We are all used to doing this for Objective C, but it feels<br>&gt;&gt; out of place in Swift.<br>&gt;&gt;<br>&gt;&gt; This will become a much more serious issue as the third-party code<br>&gt;&gt; ecosystem grows.  Without some capability like this, you will have<br>&gt;&gt; frameworks which can’t be used together (or at least with the same<br>&gt;&gt; object).  I would hate to see a ‘best practice’ emerge of adding 3 letter<br>&gt;&gt; prefixes to all protocol methods to get around compatibility issues.<br>&gt;&gt;<br>&gt;<br>&gt; Ah, well this isn&#39;t exactly the diamond problem you&#39;re talking about here.<br>&gt; Instead, I think, we have a fundamental disagreement. I think I&#39;ve been<br>&gt; told that this opinion of mine is &#39;insane&#39;--but I hold to it:<br>&gt;<br>&gt;<br>&gt; Well you asked for an additional example besides the diamond problem… so<br>&gt; no it isn’t.  I did include a diamond problem example further down though…<br>&gt;<br></p><p>Sorry, I wasn&#39;t asking for an example _besides_ the diamond problem. I was<br>asking for more information about a concrete scenario, diamond problem or<br>not, where an existing technique could not resolve the conflict (for<br>instance, a scenario when you controlled neither of two conflicting<br>protocols, and where no satisfactory alternative design existed that could<br>avoid conforming a single type to both protocols).<br></p><p><br>&gt; Protocols are not merely a vehicle for delivering a reusable bag of code.<br>&gt; One of its most essential purposes is to constrain the shape or API of its<br>&gt; conforming types. Therefore, it is a feature, not a bug, that with every<br>&gt; choice of name in a protocol you foreclose the possibility of composing<br>&gt; that protocol with others that might have colliding names.<br>&gt;<br>&gt; Currently, if you the protocol vendor have made the decision that `image`<br>&gt; &quot;makes the most sense in the protocol&#39;s context&quot;, you must have considered<br>&gt; whether it would be absurd for a conforming type to have another use for<br>&gt; `image`. If it would be absurd, then `image` is the appropriate name for<br>&gt; your protocol requirement and any other word would truly be redundant. But,<br>&gt; if this is only one of many plausible images, then `somethingImage` or<br>&gt; `imageOfSomething` *is* the appropriate name, and trying to shorten the<br>&gt; name isn&#39;t at all consistent with Swift guidelines but rather an incorrect<br>&gt; attempt to prioritize brevity over clarity.<br>&gt;<br>&gt;<br>&gt; Most things that conform would have ‘image’, and it would have exactly the<br>&gt; same semantics as my protocol. Thus their ‘image’ would provide conformance<br>&gt; without additional work.  But I have to worry about name collisions, so now<br>&gt; I have to defensively call it ‘imageOfSomething&#39;, which they now have to<br>&gt; implement to call their ‘image’ method.<br>&gt;<br>&gt;<br>&gt; What you&#39;re arguing is that protocol designers should be able to design<br>&gt; protocols without regard for how they will compose with others in<br>&gt; conforming types, relying on a new member-renaming feature instead. But, as<br>&gt; you point out, you can already use a protocol as a mere bag of code by<br>&gt; naming all members with unique, prefixed names, then have conforming types<br>&gt; forward their own choice of names to these.<br>&gt;<br>&gt;<br>&gt; No, I am arguing that protocol authors should design protocols in the way<br>&gt; which makes the behavior/semantics of the protocol the most obvious to the<br>&gt; caller.  95% of the time there won’t be collisions, but occasionally there<br>&gt; will be and we have to have a plan for that.<br>&gt;<br>&gt;<br>&gt; This member-renaming feature you propose would enhance the aesthetic<br>&gt; pleasure of the protocol designer, allowing simple names that don&#39;t ever<br>&gt; have to appear in the public API of a concrete type to be used for a<br>&gt; protocol member without placing any restrictions on the API of conforming<br>&gt; types. However, I don&#39;t see anything wrong with the current hand-prefixing<br>&gt; method being enshrined as &quot;best practice&quot; for the bag-of-code approach to<br>&gt; protocols. If, as you predict, a growing third-party code ecosystem makes<br>&gt; name collisions worse, then in fact having uniquely distinguishable<br>&gt; prefixed members would be less confusing than having conforming types<br>&gt; renaming protocol members as a matter of course.<br>&gt;<br>&gt;<br>&gt; You are arguing that namespace collisions are a feature instead of a bug?<br>&gt; Did you feel that way about ObjectiveC’s lack of name spacing?<br>&gt;<br></p><p>My argument is about protocols specifically: I understand that a major<br>feature of protocols is that they make guarantees regarding the API of<br>conforming types. In rare cases, two guarantees may conflict, but I do not<br>consider that conflict to be a bug per se, as it is the inevitable result<br>of what it means to have guarantees, i.e. it is part and parcel of the<br>feature. In order to provide a way of resolving conflicting requirements in<br>protocols, your solution eliminates the API-guaranteeing feature of<br>protocols altogether.<br></p><p>I can&#39;t comment about Objective-C, because I&#39;ve never written a single line<br>of it.<br></p><p><br>&gt; I don’t think it is anywhere near as confusing as you suggest. As I<br>&gt; mentioned before, if you cast it to the protocol, then the original names<br>&gt; will still work.<br>&gt;<br></p><p>Except when you can&#39;t cast to a protocol existential, as is the case with<br>any protocol with Self or associated type requirements.<br></p><p><br>&gt; If you are trying to type the original name on the typed conformer, then<br>&gt; showing the renamed version (with an indication of the renaming) in<br>&gt; autocomplete should teach the change and clear up any confusion.<br>&gt;<br></p><p>Mine isn&#39;t an argument about usability or learnability. It&#39;s a<br>philosophical/design point: what are protocols for? My answer: among other<br>uses, for constraining the API of conforming types. Perhaps this view is<br>incompatible with the view that protocols should support additional<br>mixin-like features.<br></p><p>To take your example of walk().  Perhaps we have a protocol ‘Walkable’<br>&gt;&gt; which refers to any data structure where the nodes can be walked using the<br>&gt;&gt; ‘walk()’ function.  It is easy to imagine two different protocols A &amp; B<br>&gt;&gt; which specialize on this in different ways (say LinearWalkable &amp;<br>&gt;&gt; RandomWalkable), and both add some methods/properties and use those to<br>&gt;&gt; provide efficient default implementations.  At some point, you may run into<br>&gt;&gt; a data structure which could easily be walked in both ways.<br>&gt;&gt;<br>&gt;&gt; As things are right now, you couldn’t inherit from both protocols.  While<br>&gt;&gt; you could add new ‘linearWalk()’ &amp; ‘randomWalk()’ to the protocols<br>&gt;&gt; respectively (cluttering their interface), there is still the issue of what<br>&gt;&gt; to do when &#39;walk()’ is called.  You can’t rename walk() in the originating<br>&gt;&gt; protocols because it comes from their common ancestor.  Much better to<br>&gt;&gt; force one (or both) of the methods to be renamed on the conforming data<br>&gt;&gt; structure.  That keeps the interfaces of the protocols clean and makes the<br>&gt;&gt; options available on the data structure clearer (e.g. ‘walk()’ &amp;<br>&gt;&gt; ‘randomWalk()’ )<br>&gt;&gt;<br>&gt;&gt; What I have had to do in the current version is inherit from the original<br>&gt;&gt; protocol and then copy and paste the default implementations from the<br>&gt;&gt; specialized versions.  Now my code has been duplicated and is harder to<br>&gt;&gt; maintain.  We can do better.<br>&gt;&gt;<br>&gt;&gt;<br>&gt; I think Charles&#39;s solution is pretty nice, but he&#39;s right that the API<br>&gt; surface area will have to grow. I don&#39;t know his original use case, so I<br>&gt; don&#39;t know how ugly I&#39;d find the final solution to be in that scenario. In<br>&gt; this particular example, I&#39;d say that having `linearWalk()` and<br>&gt; `randomWalk()` distinguished seems pretty sensible and an overall win for<br>&gt; clarity. If the same vendor controlled all three protocols, then `Walkable`<br>&gt; could have the `walk()` requirement removed altogether for even more<br>&gt; clarity.<br>&gt;<br>&gt;<br>&gt; So you would remove &#39;walk()&#39; from Walkable to avoid the name collision in<br>&gt; this one case, when ‘walk()’ is Walkable’s entire reason for being?<br>&gt;<br></p><p>No, `walk()` is not Walkable&#39;s entire reason for being. Protocols guarantee<br>semantics also. A `Walkable` protocol without any required members would<br>still have a reason for being: conforming types are walkable.<br></p><p>On the other hand, given that Walkable certainly would have associated type<br>requriements, if you considered that `walk()` _was_ Walkable&#39;s entire<br>reason for being *and* you could rename `walk()` in any conforming type,<br>how is that different from not having a `walk()` requirement at all?<br></p><p>Also, you would lose polymorphism.<br>&gt;<br>&gt;<br>&gt;<br>&gt; Also, just a hunch, but I suspect your hypothetical would never hold.<br>&gt; Could you envision how the requirements for RandomWalkable might be such<br>&gt; that it&#39;s possible to implement an efficient _default_ implementation of a<br>&gt; random walk for any of several conforming data structures, but only one of<br>&gt; these data structures is LinearWalkable, _and_ such a linear walk is<br>&gt; efficient using another _default_implementation for an overlapping but not<br>&gt; identical set of data structures? It&#39;s not mere trivia here, because the<br>&gt; crux of your argument is that there exist default implementations that<br>&gt; require copying and pasting into conforming types (and sufficiently<br>&gt; efficient default implementations so that copying and pasting is<br>&gt; appropriate rather than implementing a more efficient version). More likely<br>&gt; in diamond problem scenarios, I think, colliding members are going to be<br>&gt; properties or methods either without default implementations or than need<br>&gt; to supply more efficient versions of default implementations anyway.<br>&gt;<br>&gt;<br>&gt; Based on what?  There is a reason the diamond problem has a name (and a<br>&gt; wikipedia entry).  Charles just said he ran into a problem like this.  I<br>&gt; have run into it in the past as well.<br>&gt;<br></p><p>Sure, and returning to my question above: could you share details about<br>where you&#39;ve run into this?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160824/d9432d6b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Renaming for Protocol Conformance</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>September  2, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; Am 24.08.2016 um 21:35 schrieb Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt;&gt; On Wed, Aug 24, 2016 at 1:59 PM, Jonathan Hull &lt;jhull at gbis.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Aug 24, 2016, at 7:48 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Wed, Aug 24, 2016 at 3:39 AM, Jonathan Hull &lt;jhull at gbis.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Aug 23, 2016, at 8:35 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Tue, Aug 23, 2016 at 3:02 AM, Jonathan Hull &lt;jhull at gbis.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Aug 22, 2016, at 11:32 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mon, Aug 22, 2016 at 11:59 PM, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi everyone,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; We talked about this before when we were discussing mixins, and there seemed to be generally positive feelings towards it as a feature for the future.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It&#39;s been some time now since the original discussion, so perhaps you could refresh our collective memory (or at least, mine): although it *seems* like this feature might be useful, I can&#39;t recall a concrete use case where I&#39;ve felt like I needed this feature--do you have some examples?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Ideally, the biggest use is that it helps to (partially) solve the diamond problem (and similar issues) by forcing/allowing disambiguation when there are multiple protocols being conformed to.  This will become more of an issue if we allow protocols or extensions to add storage.  Your proposed syntax actually does a better job of it than mine because mine was always shown as attached to some sort of implementation, whereas yours could potentially allow access to a default implementation under a new name.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Other than that, it generally allows us to bypass/mitigate conflicts between protocols.  In the current version, you are unable to conform to both protocols (either because it won’t compile or because you can’t satisfy the semantics of both protocols) without designing the protocols together to avoid conflicts.  (I have definitely had to go back and rename/refactor properties on a protocol for this reason… which I couldn’t have done if I didn’t control both protocols).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I understand something of the difficulty of confronting the diamond problem. As I wrote above, I&#39;m inclined to believe that this proposed feature would help solve a real issue. However, the point I&#39;m trying to make is that, on reflection, I have never actually been hampered by the lack of this feature, and so I&#39;d like to continue the discussion to get a fuller sense of just how impactful this proposal would be, both positive and negative.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It&#39;s true, of course, that if you control at least one of two protocols (you don&#39;t need to control both protocols), it is trivially easy to cause this problem to occur, but as you point out it is also possible to resolve the problem by re-designing the protocol you control. I&#39;m inclined to think (without evidence, admittedly) that re-designing to remove the conflict, where possible, would actually be the superior option in most cases.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; My question was: have you actually run into a scenario that necessitates the feature you propose because you controlled neither conflicting protocol? I think it would strengthen the proposal greatly to have a concrete, uncontrived example.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Right now I commonly have to hand-namespace protocol methods/properties to avoid conflicts.  So instead of having ‘var image:UIImage’ (which is the name which makes the most sense in the protocol’s context), I have ‘var protocolNameImage:UIImage’.  There are lots of things which have common properties like ‘count’ which have to be called ‘somethingCount’ or ‘countOfSomething’.  In the context of the protocol, these names are full of redundant words (especially when measured against the new naming guidelines).  We are all used to doing this for Objective C, but it feels out of place in Swift.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This will become a much more serious issue as the third-party code ecosystem grows.  Without some capability like this, you will have frameworks which can’t be used together (or at least with the same object).  I would hate to see a ‘best practice’ emerge of adding 3 letter prefixes to all protocol methods to get around compatibility issues.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Ah, well this isn&#39;t exactly the diamond problem you&#39;re talking about here. Instead, I think, we have a fundamental disagreement. I think I&#39;ve been told that this opinion of mine is &#39;insane&#39;--but I hold to it:<br>&gt;&gt; <br>&gt;&gt; Well you asked for an additional example besides the diamond problem… so no it isn’t.  I did include a diamond problem example further down though…<br>&gt;  <br>&gt; Sorry, I wasn&#39;t asking for an example _besides_ the diamond problem. I was asking for more information about a concrete scenario, diamond problem or not, where an existing technique could not resolve the conflict (for instance, a scenario when you controlled neither of two conflicting protocols, and where no satisfactory alternative design existed that could avoid conforming a single type to both protocols).<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Protocols are not merely a vehicle for delivering a reusable bag of code. One of its most essential purposes is to constrain the shape or API of its conforming types. Therefore, it is a feature, not a bug, that with every choice of name in a protocol you foreclose the possibility of composing that protocol with others that might have colliding names.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Currently, if you the protocol vendor have made the decision that `image` &quot;makes the most sense in the protocol&#39;s context&quot;, you must have considered whether it would be absurd for a conforming type to have another use for `image`. If it would be absurd, then `image`<br></p><p>I find it a little bit strange to require from a protocol designer to foresee all future uses of a protocol. IMO protocols are not bags of code but encapsulate a certain (typically fine grained) semantic. How this semantic will be coupled with other semantics (i.e. protocols) is widely open.<br></p><p><br>&gt;&gt;&gt; is the appropriate name for your protocol requirement and any other word would truly be redundant. But, if this is only one of many plausible images, then `somethingImage` or `imageOfSomething` *is* the appropriate name, and trying to shorten the name isn&#39;t at all consistent with Swift guidelines but rather an incorrect attempt to prioritize brevity over clarity.<br>&gt;&gt; <br>&gt;&gt; Most things that conform would have ‘image’, and it would have exactly the same semantics as my protocol. Thus their ‘image’ would provide conformance without additional work.  But I have to worry about name collisions, so now I have to defensively call it ‘imageOfSomething&#39;, which they now have to implement to call their ‘image’ method.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; What you&#39;re arguing is that protocol designers should be able to design protocols without regard for how they will compose with others in conforming types, relying on a new member-renaming feature instead. But, as you point out, you can already use a protocol as a mere bag of code by naming all members with unique, prefixed names, then have conforming types forward their own choice of names to these.<br>&gt;&gt; <br>&gt;&gt; No, I am arguing that protocol authors should design protocols in the way which makes the behavior/semantics of the protocol the most obvious to the caller.  95% of the time there won’t be collisions, but occasionally there will be and we have to have a plan for that.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; This member-renaming feature you propose would enhance the aesthetic pleasure of the protocol designer, allowing simple names that don&#39;t ever have to appear in the public API of a concrete type to be used for a protocol member without placing any restrictions on the API of conforming types. However, I don&#39;t see anything wrong with the current hand-prefixing method being enshrined as &quot;best practice&quot; for the bag-of-code approach to protocols. If, as you predict, a growing third-party code ecosystem makes name collisions worse, then in fact having uniquely distinguishable prefixed members would be less confusing than having conforming types renaming protocol members as a matter of course.<br>&gt;&gt; <br>&gt;&gt; You are arguing that namespace collisions are a feature instead of a bug?  Did you feel that way about ObjectiveC’s lack of name spacing?<br>&gt; <br>&gt; My argument is about protocols specifically: I understand that a major feature of protocols is that they make guarantees regarding the API of conforming types. In rare cases, two guarantees may conflict, but I do not consider that conflict to be a bug per se, as it is the inevitable result of what it means to have guarantees, i.e. it is part and parcel of the feature. In order to provide a way of resolving conflicting requirements in protocols, your solution eliminates the API-guaranteeing feature of protocols altogether.<br>&gt; <br>&gt; I can&#39;t comment about Objective-C, because I&#39;ve never written a single line of it.<br>&gt;  <br>&gt;&gt; I don’t think it is anywhere near as confusing as you suggest. As I mentioned before, if you cast it to the protocol, then the original names will still work.<br>&gt; <br>&gt; Except when you can&#39;t cast to a protocol existential, as is the case with any protocol with Self or associated type requirements.<br></p><p>This is a separate problem which will be solved once we have existential types.<br>Furhermore the argument still holds when the protocol is being used as type constrained.<br></p><p><br>&gt;  <br>&gt;&gt; If you are trying to type the original name on the typed conformer, then showing the renamed version (with an indication of the renaming) in autocomplete should teach the change and clear up any confusion.<br>&gt; <br>&gt; Mine isn&#39;t an argument about usability or learnability. It&#39;s a philosophical/design point: what are protocols for? My answer: among other uses, for constraining the API of conforming types. Perhaps this view is incompatible with the view that protocols should support additional mixin-like features.<br></p><p>I don&#39;t think this has anything to do with mixins. It is just the general problem of being able to combine protocols which have been designed independently from each other.<br></p><p><br>&gt; <br>&gt;&gt;&gt;&gt; To take your example of walk().  Perhaps we have a protocol ‘Walkable’ which refers to any data structure where the nodes can be walked using the ‘walk()’ function.  It is easy to imagine two different protocols A &amp; B which specialize on this in different ways (say LinearWalkable &amp; RandomWalkable), and both add some methods/properties and use those to provide efficient default implementations.  At some point, you may run into a data structure which could easily be walked in both ways.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As things are right now, you couldn’t inherit from both protocols.  While you could add new ‘linearWalk()’ &amp; ‘randomWalk()’ to the protocols respectively (cluttering their interface), there is still the issue of what to do when &#39;walk()’ is called.  You can’t rename walk() in the originating protocols because it comes from their common ancestor.  Much better to force one (or both) of the methods to be renamed on the conforming data structure.  That keeps the interfaces of the protocols clean and makes the options available on the data structure clearer (e.g. ‘walk()’ &amp; ‘randomWalk()’ )<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What I have had to do in the current version is inherit from the original protocol and then copy and paste the default implementations from the specialized versions.  Now my code has been duplicated and is harder to maintain.  We can do better.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think Charles&#39;s solution is pretty nice, but he&#39;s right that the API surface area will have to grow. I don&#39;t know his original use case, so I don&#39;t know how ugly I&#39;d find the final solution to be in that scenario. In this particular example, I&#39;d say that having `linearWalk()` and `randomWalk()` distinguished seems pretty sensible and an overall win for clarity. If the same vendor controlled all three protocols, then `Walkable` could have the `walk()` requirement removed altogether for even more clarity.<br>&gt;&gt; <br>&gt;&gt; So you would remove &#39;walk()&#39; from Walkable to avoid the name collision in this one case, when ‘walk()’ is Walkable’s entire reason for being?<br>&gt; <br>&gt; No, `walk()` is not Walkable&#39;s entire reason for being. Protocols guarantee semantics also. A `Walkable` protocol without any required members would still have a reason for being: conforming types are walkable.<br>&gt; <br>&gt; On the other hand, given that Walkable certainly would have associated type requriements, if you considered that `walk()` _was_ Walkable&#39;s entire reason for being *and* you could rename `walk()` in any conforming type, how is that different from not having a `walk()` requirement at all?<br></p><p>Generic methods using a type constrained by Walkable can call `walk()` on it. The same will be possible for variables declared with existential types in the future and it already applies for protocols without associated type or Self requirements.<br></p><p>-Thorsten <br></p><p><br>&gt; <br>&gt;&gt; Also, you would lose polymorphism.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Also, just a hunch, but I suspect your hypothetical would never hold. Could you envision how the requirements for RandomWalkable might be such that it&#39;s possible to implement an efficient _default_ implementation of a random walk for any of several conforming data structures, but only one of these data structures is LinearWalkable, _and_ such a linear walk is efficient using another _default_implementation for an overlapping but not identical set of data structures? It&#39;s not mere trivia here, because the crux of your argument is that there exist default implementations that require copying and pasting into conforming types (and sufficiently efficient default implementations so that copying and pasting is appropriate rather than implementing a more efficient version). More likely in diamond problem scenarios, I think, colliding members are going to be properties or methods either without default implementations or than need to supply more efficient versions of default implementations anyway.<br>&gt;&gt; <br>&gt;&gt; Based on what?  There is a reason the diamond problem has a name (and a wikipedia entry).  Charles just said he ran into a problem like this.  I have run into it in the past as well.<br>&gt; <br>&gt; Sure, and returning to my question above: could you share details about where you&#39;ve run into this?<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160902/9e6d3ac4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/067cee1a86dbe57d6de692dd39c6791b?s=50"></div><header><strong>Renaming for Protocol Conformance</strong> from <string>Johannes Neubauer</string> &lt;neubauer at kingsware.de&gt;<p>September  2, 2016 at 07:00:00pm</p></header><div class="content"><p>Von meinem iPhone gesendet<br>&gt; Am 02.09.2016 um 17:56 schrieb Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt;&gt; Am 24.08.2016 um 21:35 schrieb Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; On Wed, Aug 24, 2016 at 1:59 PM, Jonathan Hull &lt;jhull at gbis.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Aug 24, 2016, at 7:48 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Wed, Aug 24, 2016 at 3:39 AM, Jonathan Hull &lt;jhull at gbis.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Aug 23, 2016, at 8:35 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Tue, Aug 23, 2016 at 3:02 AM, Jonathan Hull &lt;jhull at gbis.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Aug 22, 2016, at 11:32 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mon, Aug 22, 2016 at 11:59 PM, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Protocols are not merely a vehicle for delivering a reusable bag of code. One of its most essential purposes is to constrain the shape or API of its conforming types. Therefore, it is a feature, not a bug, that with every choice of name in a protocol you foreclose the possibility of composing that protocol with others that might have colliding names.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Currently, if you the protocol vendor have made the decision that `image` &quot;makes the most sense in the protocol&#39;s context&quot;, you must have considered whether it would be absurd for a conforming type to have another use for `image`.<br>&gt; <br>&gt; I find it a little bit strange to require from a protocol designer to foresee all future uses of a protocol. IMO protocols are not bags of code but encapsulate a certain (typically fine grained) semantic. How this semantic will be coupled with other semantics (i.e. protocols) is widely open.<br></p><p>I agree. Why should a language that supports:<br></p><p>1. type aliases and retroactive modeling (even adding protocol conformance to existing types to the extent that basic types implement user library protocols) and<br>2. discuss to add type aliases for generic types and existentials as well as <br>3. something like *new type* for type aliases with nominal typing...<br></p><p>not allow to rename methods? The argument that protocols have to be designed by the &quot;protocol vendor&quot; foreseeing all its usages does not hold for every case. A language with type aliases and retroactive modeling allows for domain specificity via context dependent changes to a and renaming of a type. This can be used for internal DSLs (domain specific languages) and the like. <br></p><p>I know that my point here is orthogonal to the original problem of renaming because of name clashes between protocols, but I address the more general question whether renaming of associated types, methods and the like wouldn&#39;t be a good (and consequent) thing.<br></p><p>All the best<br>Johannes<br></p><p>Von meinem iPhone gesendet<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160902/cd1664ed/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Renaming for Protocol Conformance</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>September  2, 2016 at 06:00:00pm</p></header><div class="content"><p>I think we agree on a lot of premises but come to opposite conclusions. I<br>would not phrase it precisely how you did, that protocol designers are<br>currently required &#39;to foresee all uses.&#39; Rather, I see an analogy with<br>these scenarios:<br></p><p>a) Many functions in the standard library have preconditions for their<br>arguments. When those preconditions are violated, execution is halted. The<br>designer of the function writes a precondition to indicate the inputs for<br>which he or she believes the method produces a meaningful result. If the<br>preconditions are set too restrictively, then the caller of that function<br>will be frustrated to find crashing code.<br></p><p>But is this a feature or a bug? Well, it is a bug that the designer set<br>inappropriate preconditions. But the bug is in deficient *reasoning* by the<br>designer; the precondition accurately reflects a failure of the designer to<br>reason about a sensible use of the function. However, given that there has<br>been a defect in reasoning by the designer, is it a bug or a feature that<br>Swift refuses to execute code that hasn&#39;t been reasoned through? It is a<br>feature.<br></p><p>b) Classes now cannot be subclassed outside their modules by default. This<br>decision has been controversial, but it follows the same reasoning. The<br>designer of the function, if he or she has reasoned through the effects of<br>subclassing, can indicate that by making the class open. It may be the case<br>that a designer has not put in the thought work necessary and a class is<br>unnecessarily sealed. This would no doubt be frustrating.<br></p><p>Is that a bug or a feature? Again, it is a bug on the part of the designer,<br>for not having done the necessary thought work. But is it a bug or a<br>feature for Swift to refuse to compile code that hasn&#39;t been reasoned<br>through? I think it has been made clear that, as an opinionated language,<br>Swift makes the argument that this is a deliberate feature.<br></p><p>I argue the same thing applies here. Currently, protocols constrain the API<br>of conforming types. If a designer has reasoned through their design<br>correctly, then all is well. If a designer has made bad design choices,<br>then conforming types are constrained to have bad API design. Is that a bug<br>or a feature? It is of course a bug on the part of the designer for having<br>designed a bad protocol. But I think it is arguably a feature on the part<br>of Swift for refusing to allow code to circumvent the protocol&#39;s design,<br>because a protocol that is out of the end user&#39;s control is also likely a<br>protocol for which the default implementations are opaque to that user and<br>can&#39;t be reasoned through by that user.<br></p><p>I&#39;m not entirely sure on my position, though. To be convinced otherwise,<br>I&#39;d need to see a compelling real-world use case that demonstrates all of<br>the following:<br></p><p>- Safety: perhaps, with protocols, unlike class inheritance, it is almost<br>always safe to make these kinds of changes unanticipated by the original<br>author--it would be good to see evidence either way<br></p><p>- Necessity: earlier, examples were cited where at least one of two<br>conflicting protocols were under the user&#39;s control; in that case, this<br>feature isn&#39;t needed, because that protocol&#39;s requirements can be trivially<br>renamed<br></p><p>- Good design: show me that the design patterns enabled by the feature are<br>better than what is possible with workarounds; if a renaming or hiding<br>feature is expedient, but an alternative approach would promote less<br>fragile or more Swifty design, then we should be exploring ways to simplify<br>or promote an alternative approach; one consideration, for example, is that<br>naming of anything is hard, and the current fact that protocols *need* to<br>have well-chosen member names encourages designers to think hard--but if<br>renaming becomes possible, could we simply be enabling less thoughtful<br>protocol design with little benefit (to evaluate this, we would need some<br>sense of the answer to the necessity question above)?<br></p><p>On Fri, Sep 2, 2016 at 10:56 Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br></p><p>&gt;<br>&gt;<br>&gt; Am 24.08.2016 um 21:35 schrieb Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt;<br>&gt; On Wed, Aug 24, 2016 at 1:59 PM, Jonathan Hull &lt;jhull at gbis.com&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Aug 24, 2016, at 7:48 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Wed, Aug 24, 2016 at 3:39 AM, Jonathan Hull &lt;jhull at gbis.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Aug 23, 2016, at 8:35 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Tue, Aug 23, 2016 at 3:02 AM, Jonathan Hull &lt;jhull at gbis.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Aug 22, 2016, at 11:32 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Mon, Aug 22, 2016 at 11:59 PM, Jonathan Hull via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Hi everyone,<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; We talked about this before when we were discussing mixins, and there<br>&gt;&gt;&gt;&gt;&gt; seemed to be generally positive feelings towards it as a feature for the<br>&gt;&gt;&gt;&gt;&gt; future.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; It&#39;s been some time now since the original discussion, so perhaps you<br>&gt;&gt;&gt;&gt; could refresh our collective memory (or at least, mine): although it<br>&gt;&gt;&gt;&gt; *seems* like this feature might be useful, I can&#39;t recall a concrete use<br>&gt;&gt;&gt;&gt; case where I&#39;ve felt like I needed this feature--do you have some examples?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Ideally, the biggest use is that it helps to (partially) solve the<br>&gt;&gt;&gt;&gt; diamond problem (and similar issues) by forcing/allowing disambiguation<br>&gt;&gt;&gt;&gt; when there are multiple protocols being conformed to.  This will become<br>&gt;&gt;&gt;&gt; more of an issue if we allow protocols or extensions to add storage.  Your<br>&gt;&gt;&gt;&gt; proposed syntax actually does a better job of it than mine because mine was<br>&gt;&gt;&gt;&gt; always shown as attached to some sort of implementation, whereas yours<br>&gt;&gt;&gt;&gt; could potentially allow access to a default implementation under a new name.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Other than that, it generally allows us to bypass/mitigate conflicts<br>&gt;&gt;&gt;&gt; between protocols.  In the current version, you are unable to conform to<br>&gt;&gt;&gt;&gt; both protocols (either because it won’t compile or because you can’t<br>&gt;&gt;&gt;&gt; satisfy the semantics of both protocols) without designing the protocols<br>&gt;&gt;&gt;&gt; together to avoid conflicts.  (I have definitely had to go back and<br>&gt;&gt;&gt;&gt; rename/refactor properties on a protocol for this reason… which I couldn’t<br>&gt;&gt;&gt;&gt; have done if I didn’t control both protocols).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I understand something of the difficulty of confronting the diamond<br>&gt;&gt;&gt; problem. As I wrote above, I&#39;m inclined to believe that this proposed<br>&gt;&gt;&gt; feature would help solve a real issue. However, the point I&#39;m trying to<br>&gt;&gt;&gt; make is that, on reflection, I have never actually been hampered by the<br>&gt;&gt;&gt; lack of this feature, and so I&#39;d like to continue the discussion to get a<br>&gt;&gt;&gt; fuller sense of just how impactful this proposal would be, both positive<br>&gt;&gt;&gt; and negative.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It&#39;s true, of course, that if you control at least one of two protocols<br>&gt;&gt;&gt; (you don&#39;t need to control both protocols), it is trivially easy to cause<br>&gt;&gt;&gt; this problem to occur, but as you point out it is also possible to resolve<br>&gt;&gt;&gt; the problem by re-designing the protocol you control. I&#39;m inclined to think<br>&gt;&gt;&gt; (without evidence, admittedly) that re-designing to remove the conflict,<br>&gt;&gt;&gt; where possible, would actually be the superior option in most cases.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; My question was: have you actually run into a scenario that necessitates<br>&gt;&gt;&gt; the feature you propose because you controlled neither conflicting<br>&gt;&gt;&gt; protocol? I think it would strengthen the proposal greatly to have a<br>&gt;&gt;&gt; concrete, uncontrived example.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Right now I commonly have to hand-namespace protocol methods/properties<br>&gt;&gt;&gt; to avoid conflicts.  So instead of having ‘var image:UIImage’ (which is the<br>&gt;&gt;&gt; name which makes the most sense in the protocol’s context), I have ‘var<br>&gt;&gt;&gt; protocolNameImage:UIImage’.  There are lots of things which have common<br>&gt;&gt;&gt; properties like ‘count’ which have to be called ‘somethingCount’ or<br>&gt;&gt;&gt; ‘countOfSomething’.  In the context of the protocol, these names are full<br>&gt;&gt;&gt; of redundant words (especially when measured against the new naming<br>&gt;&gt;&gt; guidelines).  We are all used to doing this for Objective C, but it feels<br>&gt;&gt;&gt; out of place in Swift.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This will become a much more serious issue as the third-party code<br>&gt;&gt;&gt; ecosystem grows.  Without some capability like this, you will have<br>&gt;&gt;&gt; frameworks which can’t be used together (or at least with the same<br>&gt;&gt;&gt; object).  I would hate to see a ‘best practice’ emerge of adding 3 letter<br>&gt;&gt;&gt; prefixes to all protocol methods to get around compatibility issues.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Ah, well this isn&#39;t exactly the diamond problem you&#39;re talking about<br>&gt;&gt; here. Instead, I think, we have a fundamental disagreement. I think I&#39;ve<br>&gt;&gt; been told that this opinion of mine is &#39;insane&#39;--but I hold to it:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Well you asked for an additional example besides the diamond problem… so<br>&gt;&gt; no it isn’t.  I did include a diamond problem example further down though…<br>&gt;&gt;<br>&gt;<br>&gt; Sorry, I wasn&#39;t asking for an example _besides_ the diamond problem. I was<br>&gt; asking for more information about a concrete scenario, diamond problem or<br>&gt; not, where an existing technique could not resolve the conflict (for<br>&gt; instance, a scenario when you controlled neither of two conflicting<br>&gt; protocols, and where no satisfactory alternative design existed that could<br>&gt; avoid conforming a single type to both protocols).<br>&gt;<br>&gt;<br>&gt;&gt; Protocols are not merely a vehicle for delivering a reusable bag of code.<br>&gt;&gt; One of its most essential purposes is to constrain the shape or API of its<br>&gt;&gt; conforming types. Therefore, it is a feature, not a bug, that with every<br>&gt;&gt; choice of name in a protocol you foreclose the possibility of composing<br>&gt;&gt; that protocol with others that might have colliding names.<br>&gt;&gt;<br>&gt;&gt; Currently, if you the protocol vendor have made the decision that `image`<br>&gt;&gt; &quot;makes the most sense in the protocol&#39;s context&quot;, you must have considered<br>&gt;&gt; whether it would be absurd for a conforming type to have another use for<br>&gt;&gt; `image`. If it would be absurd, then `image`<br>&gt;&gt;<br>&gt;&gt;<br>&gt; I find it a little bit strange to require from a protocol designer to<br>&gt; foresee all future uses of a protocol. IMO protocols are not bags of code<br>&gt; but encapsulate a certain (typically fine grained) semantic. How this<br>&gt; semantic will be coupled with other semantics (i.e. protocols) is widely<br>&gt; open.<br>&gt;<br>&gt;<br>&gt; is the appropriate name for your protocol requirement and any other word<br>&gt;&gt; would truly be redundant. But, if this is only one of many plausible<br>&gt;&gt; images, then `somethingImage` or `imageOfSomething` *is* the appropriate<br>&gt;&gt; name, and trying to shorten the name isn&#39;t at all consistent with Swift<br>&gt;&gt; guidelines but rather an incorrect attempt to prioritize brevity over<br>&gt;&gt; clarity.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Most things that conform would have ‘image’, and it would have exactly<br>&gt;&gt; the same semantics as my protocol. Thus their ‘image’ would provide<br>&gt;&gt; conformance without additional work.  But I have to worry about name<br>&gt;&gt; collisions, so now I have to defensively call it ‘imageOfSomething&#39;, which<br>&gt;&gt; they now have to implement to call their ‘image’ method.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; What you&#39;re arguing is that protocol designers should be able to design<br>&gt;&gt; protocols without regard for how they will compose with others in<br>&gt;&gt; conforming types, relying on a new member-renaming feature instead. But, as<br>&gt;&gt; you point out, you can already use a protocol as a mere bag of code by<br>&gt;&gt; naming all members with unique, prefixed names, then have conforming types<br>&gt;&gt; forward their own choice of names to these.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; No, I am arguing that protocol authors should design protocols in the way<br>&gt;&gt; which makes the behavior/semantics of the protocol the most obvious to the<br>&gt;&gt; caller.  95% of the time there won’t be collisions, but occasionally there<br>&gt;&gt; will be and we have to have a plan for that.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; This member-renaming feature you propose would enhance the aesthetic<br>&gt;&gt; pleasure of the protocol designer, allowing simple names that don&#39;t ever<br>&gt;&gt; have to appear in the public API of a concrete type to be used for a<br>&gt;&gt; protocol member without placing any restrictions on the API of conforming<br>&gt;&gt; types. However, I don&#39;t see anything wrong with the current hand-prefixing<br>&gt;&gt; method being enshrined as &quot;best practice&quot; for the bag-of-code approach to<br>&gt;&gt; protocols. If, as you predict, a growing third-party code ecosystem makes<br>&gt;&gt; name collisions worse, then in fact having uniquely distinguishable<br>&gt;&gt; prefixed members would be less confusing than having conforming types<br>&gt;&gt; renaming protocol members as a matter of course.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; You are arguing that namespace collisions are a feature instead of a<br>&gt;&gt; bug?  Did you feel that way about ObjectiveC’s lack of name spacing?<br>&gt;&gt;<br>&gt;<br>&gt; My argument is about protocols specifically: I understand that a major<br>&gt; feature of protocols is that they make guarantees regarding the API of<br>&gt; conforming types. In rare cases, two guarantees may conflict, but I do not<br>&gt; consider that conflict to be a bug per se, as it is the inevitable result<br>&gt; of what it means to have guarantees, i.e. it is part and parcel of the<br>&gt; feature. In order to provide a way of resolving conflicting requirements in<br>&gt; protocols, your solution eliminates the API-guaranteeing feature of<br>&gt; protocols altogether.<br>&gt;<br>&gt; I can&#39;t comment about Objective-C, because I&#39;ve never written a single<br>&gt; line of it.<br>&gt;<br>&gt;<br>&gt;&gt; I don’t think it is anywhere near as confusing as you suggest. As I<br>&gt;&gt; mentioned before, if you cast it to the protocol, then the original names<br>&gt;&gt; will still work.<br>&gt;&gt;<br>&gt;<br>&gt; Except when you can&#39;t cast to a protocol existential, as is the case with<br>&gt; any protocol with Self or associated type requirements.<br>&gt;<br>&gt;<br>&gt; This is a separate problem which will be solved once we have existential<br>&gt; types.<br>&gt; Furhermore the argument still holds when the protocol is being used as<br>&gt; type constrained.<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt; If you are trying to type the original name on the typed conformer, then<br>&gt;&gt; showing the renamed version (with an indication of the renaming) in<br>&gt;&gt; autocomplete should teach the change and clear up any confusion.<br>&gt;&gt;<br>&gt;<br>&gt; Mine isn&#39;t an argument about usability or learnability. It&#39;s a<br>&gt; philosophical/design point: what are protocols for? My answer: among other<br>&gt; uses, for constraining the API of conforming types. Perhaps this view is<br>&gt; incompatible with the view that protocols should support additional<br>&gt; mixin-like features.<br>&gt;<br>&gt;<br>&gt; I don&#39;t think this has anything to do with mixins. It is just the general<br>&gt; problem of being able to combine protocols which have been designed<br>&gt; independently from each other.<br>&gt;<br>&gt;<br>&gt;<br>&gt; To take your example of walk().  Perhaps we have a protocol ‘Walkable’<br>&gt;&gt;&gt; which refers to any data structure where the nodes can be walked using the<br>&gt;&gt;&gt; ‘walk()’ function.  It is easy to imagine two different protocols A &amp; B<br>&gt;&gt;&gt; which specialize on this in different ways (say LinearWalkable &amp;<br>&gt;&gt;&gt; RandomWalkable), and both add some methods/properties and use those to<br>&gt;&gt;&gt; provide efficient default implementations.  At some point, you may run into<br>&gt;&gt;&gt; a data structure which could easily be walked in both ways.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; As things are right now, you couldn’t inherit from both protocols.<br>&gt;&gt;&gt; While you could add new ‘linearWalk()’ &amp; ‘randomWalk()’ to the protocols<br>&gt;&gt;&gt; respectively (cluttering their interface), there is still the issue of what<br>&gt;&gt;&gt; to do when &#39;walk()’ is called.  You can’t rename walk() in the originating<br>&gt;&gt;&gt; protocols because it comes from their common ancestor.  Much better to<br>&gt;&gt;&gt; force one (or both) of the methods to be renamed on the conforming data<br>&gt;&gt;&gt; structure.  That keeps the interfaces of the protocols clean and makes the<br>&gt;&gt;&gt; options available on the data structure clearer (e.g. ‘walk()’ &amp;<br>&gt;&gt;&gt; ‘randomWalk()’ )<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; What I have had to do in the current version is inherit from the<br>&gt;&gt;&gt; original protocol and then copy and paste the default implementations from<br>&gt;&gt;&gt; the specialized versions.  Now my code has been duplicated and is harder to<br>&gt;&gt;&gt; maintain.  We can do better.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; I think Charles&#39;s solution is pretty nice, but he&#39;s right that the API<br>&gt;&gt; surface area will have to grow. I don&#39;t know his original use case, so I<br>&gt;&gt; don&#39;t know how ugly I&#39;d find the final solution to be in that scenario. In<br>&gt;&gt; this particular example, I&#39;d say that having `linearWalk()` and<br>&gt;&gt; `randomWalk()` distinguished seems pretty sensible and an overall win for<br>&gt;&gt; clarity. If the same vendor controlled all three protocols, then `Walkable`<br>&gt;&gt; could have the `walk()` requirement removed altogether for even more<br>&gt;&gt; clarity.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; So you would remove &#39;walk()&#39; from Walkable to avoid the name collision in<br>&gt;&gt; this one case, when ‘walk()’ is Walkable’s entire reason for being?<br>&gt;&gt;<br>&gt;<br>&gt; No, `walk()` is not Walkable&#39;s entire reason for being. Protocols<br>&gt; guarantee semantics also. A `Walkable` protocol without any required<br>&gt; members would still have a reason for being: conforming types are walkable.<br>&gt;<br>&gt; On the other hand, given that Walkable certainly would have associated<br>&gt; type requriements, if you considered that `walk()` _was_ Walkable&#39;s entire<br>&gt; reason for being *and* you could rename `walk()` in any conforming type,<br>&gt; how is that different from not having a `walk()` requirement at all?<br>&gt;<br>&gt;<br>&gt; Generic methods using a type constrained by Walkable can call `walk()` on<br>&gt; it. The same will be possible for variables declared with existential types<br>&gt; in the future and it already applies for protocols without associated type<br>&gt; or Self requirements.<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt;<br>&gt;<br>&gt; Also, you would lose polymorphism.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Also, just a hunch, but I suspect your hypothetical would never hold.<br>&gt;&gt; Could you envision how the requirements for RandomWalkable might be such<br>&gt;&gt; that it&#39;s possible to implement an efficient _default_ implementation of a<br>&gt;&gt; random walk for any of several conforming data structures, but only one of<br>&gt;&gt; these data structures is LinearWalkable, _and_ such a linear walk is<br>&gt;&gt; efficient using another _default_implementation for an overlapping but not<br>&gt;&gt; identical set of data structures? It&#39;s not mere trivia here, because the<br>&gt;&gt; crux of your argument is that there exist default implementations that<br>&gt;&gt; require copying and pasting into conforming types (and sufficiently<br>&gt;&gt; efficient default implementations so that copying and pasting is<br>&gt;&gt; appropriate rather than implementing a more efficient version). More likely<br>&gt;&gt; in diamond problem scenarios, I think, colliding members are going to be<br>&gt;&gt; properties or methods either without default implementations or than need<br>&gt;&gt; to supply more efficient versions of default implementations anyway.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Based on what?  There is a reason the diamond problem has a name (and a<br>&gt;&gt; wikipedia entry).  Charles just said he ran into a problem like this.  I<br>&gt;&gt; have run into it in the past as well.<br>&gt;&gt;<br>&gt;<br>&gt; Sure, and returning to my question above: could you share details about<br>&gt; where you&#39;ve run into this?<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160902/91ebefdf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>Renaming for Protocol Conformance</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>September  6, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; I argue the same thing applies here. Currently, protocols constrain the API of conforming types. If a designer has reasoned through their design correctly, then all is well. If a designer has made bad design choices, then conforming types are constrained to have bad API design. Is that a bug or a feature? It is of course a bug on the part of the designer for having designed a bad protocol. But I think it is arguably a feature on the part of Swift for refusing to allow code to circumvent the protocol&#39;s design, because a protocol that is out of the end user&#39;s control is also likely a protocol for which the default implementations are opaque to that user and can&#39;t be reasoned through by that user.<br></p><p>There seem to be two schools of thought in this community:  Those that want to empower good design, and those that want to prevent/punish bad design.<br></p><p>They often look similar, but they are subtly different.  One treats the programmer as an intelligent adult, who may make mistakes, and would appreciate reminders about the possibility of problems.  The other treats the programmer as a child who must be protected from themselves.  I am strongly in the first camp.  We should provide warnings and force conflicts to be resolved in some way, but ultimately we need to trust the programmer to do the right thing. Also, as people kept saying during the &#39;closed by default&#39; discussion, if they screw up and rename something in a confusing way, then other people will complain to them and they will change it.<br></p><p><br>&gt; I&#39;m not entirely sure on my position, though. To be convinced otherwise, I&#39;d need to see a compelling real-world use case that demonstrates all of the following:<br>&gt; <br>&gt; - Safety: perhaps, with protocols, unlike class inheritance, it is almost always safe to make these kinds of changes unanticipated by the original author--it would be good to see evidence either way<br></p><p>You may find this paper interesting:<br>http://scg.unibe.ch/archive/papers/Scha02bTraits.pdf &lt;http://scg.unibe.ch/archive/papers/Scha02bTraits.pdf&gt;<br></p><p>It discusses traits, which are basically Swift’s protocols, plus the ability to handle conflicts.  It discusses at length the issues that arise with other systems.<br></p><p>This is a very common problem that only a few programming languages have found successful solutions to.  I would also point you to Eiffel’s model for multiple inheritance (select, rename, undefine, export).  I think if we keep working on it, we can find a uniquely swift-feeling solution which solves the issue :-)<br></p><p><br>&gt; - Necessity: earlier, examples were cited where at least one of two conflicting protocols were under the user&#39;s control; in that case, this feature isn&#39;t needed, because that protocol&#39;s requirements can be trivially renamed<br></p><p>I ran into a case of the diamond problem with protocols again today in a real world project.  Both classes were under my control, but I wasn’t able to avoid the name conflict because they had a common ancestor.  I was able to solve it by copy/pasting the winning method definition, but this is definitely not ideal, since I must now maintain code in two places which makes upkeep/changes more difficult.<br></p><p>What I want here is the ability to notate the winner in my inheriting protocol.<br></p><p><br>&gt; - Good design: show me that the design patterns enabled by the feature are better than what is possible with workarounds; if a renaming or hiding feature is expedient, but an alternative approach would promote less fragile or more Swifty design, then we should be exploring ways to simplify or promote an alternative approach; one consideration, for example, is that naming of anything is hard, and the current fact that protocols *need* to have well-chosen member names encourages designers to think hard--but if renaming becomes possible, could we simply be enabling less thoughtful protocol design with little benefit (to evaluate this, we would need some sense of the answer to the necessity question above)?<br></p><p>Your suggestion that the framework designers should have to go back and refactor their code because of another framework is an indication of coupled design and bad code smell.  Suddenly my protocols have to know about all of the other protocols being used (or which could theoretically be used) and I have to design around them.  This is problematic.  Ideally, I should be able to design each protocol in a way which makes the most sense semantically for the use of that protocol.  Any contortions I have to make to the design away from the ideal are something to be avoided where possible.  I know we are used to making these contortions, but is it really the best design (or is it a form of Stockholm syndrome)?<br></p><p>Here is an article on Eiffel’s multiple inheritance system which makes the point well:<br>https://archive.eiffel.com/doc/manuals/technology/bmarticles/joop/multiple.html &lt;https://archive.eiffel.com/doc/manuals/technology/bmarticles/joop/multiple.html&gt;<br></p><p>Some selected passages:<br>&gt; One of the differences is particularly important if you take a software engineering viewpoint and consider these solutions in relation with the software development lifecycle. If the developers first implement simple menus only, and only then realize the need for walking menus, using tree solution means that they must go back to the initial definition of class MENU and rework it extensively. This brings disorder into the development process.<br>&gt; <br>&gt; With the multiple inheritance solution, things are quite different. When the developers realize that a new kind of menu is needed, they simply define it by inheritance from MENU and ENTRY. The changes to existing software are minimal. This is an example of one of the key benefits of the object-oriented method, which would have to be renounced in the absence of multiple inheritance.<br>&gt; <br></p><p>(emphasis mine)<br>&gt; Assume you are in the inheritance-based reusability business and combine classes from two software suppliers, say one in New York and one in London. Sure enough, one day you are going to run into the problem of combining two classes that both have a feature called foo, to use as example one of these nice evocative names that programmers are fond of.<br>&gt; <br>&gt; But this is not a conceptual problem! It merely results from an unfortunate choice of names. If the parent programmers had chosen other names, differing by just one letter -- influenced perhaps by local conditions, they might have used zoo in New York and fog in London --, the problem would never have arisen.<br>&gt; <br>&gt; This suggests the two key observations on this problem:<br>&gt; <br>&gt; First, it is purely a syntactical problem, due to conflicting name choices. It has nothing to do with the fundamental properties of the classes involved.<br>&gt; Second, nothing is wrong with the parents; each is perfectly consistent as it stands. The &quot;culprit&quot; is the common heir, which tries to combine two classes that are incompatible as they stand. So the heir should also be responsible for the solution.<br></p><p><br>It also includes an example of how renaming can make a design more consistent.  You can use a protocol for it’s functionality (Tree-based calculation) while providing an end-user interface that makes sense to your domain. <br>&gt; Although purely syntactical, renaming is not limited in its applications to the resolution of name clashes. Among its other uses, one deserves a particular mention because it sheds more light into the meaning and power of inheritance. This is renaming used to define consistent class interfaces.<br>&gt; <br>&gt; The following example is typical. Again, it will illustrate techniques used in the Eiffel Graphical Library. Assume we want to describe rectangular windows that can be arbitrarily nested. The corresponding class, say WINDOW, will have a large number of features, which can be grouped into two categories:<br>&gt; <br>&gt; Graphical features: height, width, position, move, scale and the like.<br>&gt; Hierarchical features, having to do with the tree structure of nested windows: add_subwindow, remove_subwindow, superwindow and the like.<br>[…]<br>&gt;  Features inherited from TREE, in particular, will bear their tree names: insert_node, remove_node, parent_node and so on. This is not acceptable to a client programmer like Ed who wants good, concrete window terminology.<br>&gt; <br>&gt; With renaming, the solution is straightforward. Wendy ought to spend ten more minutes polishing the interface, so that clients of class WINDOW won&#39;t need to be aware of its tree ancestry:<br>&gt; <br>&gt; <br>&gt; 	class WINDOW inherit<br>&gt; <br>&gt; 		RECT_SHAPE<br>&gt; 			rename ...<br>&gt; <br>&gt; 		TREE<br>&gt; 			rename<br>&gt; 				insert_node as add_subwindow,<br>&gt; 				remove_node as delete_subwindow,<br>&gt; 				parent_node as superwindow,<br>&gt; 				...<br>&gt; 	feature<br>&gt; <br>&gt; 		...<br>&gt; <br>&gt; 	end -- class WINDOW<br></p><p>I think we have an opportunity here to actually solve this problem by looking at the solutions which came before and then creating something uniquely swift.<br></p><p>Thanks,<br>Jon<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160906/f53fb312/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Renaming for Protocol Conformance</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>September  6, 2016 at 11:00:00pm</p></header><div class="content"><p>On Tue, Sep 6, 2016 at 8:06 PM, Jonathan Hull &lt;jhull at gbis.com&gt; wrote:<br></p><p>&gt;<br>&gt; I argue the same thing applies here. Currently, protocols constrain the<br>&gt; API of conforming types. If a designer has reasoned through their design<br>&gt; correctly, then all is well. If a designer has made bad design choices,<br>&gt; then conforming types are constrained to have bad API design. Is that a bug<br>&gt; or a feature? It is of course a bug on the part of the designer for having<br>&gt; designed a bad protocol. But I think it is arguably a feature on the part<br>&gt; of Swift for refusing to allow code to circumvent the protocol&#39;s design,<br>&gt; because a protocol that is out of the end user&#39;s control is also likely a<br>&gt; protocol for which the default implementations are opaque to that user and<br>&gt; can&#39;t be reasoned through by that user.<br>&gt;<br>&gt;<br>&gt; There seem to be two schools of thought in this community:  Those that<br>&gt; want to empower good design, and those that want to prevent/punish bad<br>&gt; design.<br>&gt;<br>&gt; They often look similar, but they are subtly different.  One treats the<br>&gt; programmer as an intelligent adult, who may make mistakes, and would<br>&gt; appreciate reminders about the possibility of problems.  The other treats<br>&gt; the programmer as a child who must be protected from themselves.  I am<br>&gt; strongly in the first camp.<br>&gt;<br></p><p>I think this is quite an unfair characterization. When a programming<br>language can guarantee that certain things won&#39;t occur, it isn&#39;t about<br>punishing anyone; rather, those who have to read the code and reason about<br>its behavior gain tangible benefits from such constraints.<br></p><p><br>&gt; We should provide warnings and force conflicts to be resolved in some way,<br>&gt; but ultimately we need to trust the programmer to do the right thing. Also,<br>&gt; as people kept saying during the &#39;closed by default&#39; discussion, if they<br>&gt; screw up and rename something in a confusing way, then other people will<br>&gt; complain to them and they will change it.<br>&gt;<br>&gt;<br>&gt; I&#39;m not entirely sure on my position, though. To be convinced otherwise,<br>&gt; I&#39;d need to see a compelling real-world use case that demonstrates all of<br>&gt; the following:<br>&gt;<br>&gt; - Safety: perhaps, with protocols, unlike class inheritance, it is almost<br>&gt; always safe to make these kinds of changes unanticipated by the original<br>&gt; author--it would be good to see evidence either way<br>&gt;<br>&gt;<br>&gt; You may find this paper interesting:<br>&gt; http://scg.unibe.ch/archive/papers/Scha02bTraits.pdf<br>&gt;<br>&gt; It discusses traits, which are basically Swift’s protocols, plus the<br>&gt; ability to handle conflicts.  It discusses at length the issues that arise<br>&gt; with other systems.<br>&gt;<br></p><p>Thanks for the link. I&#39;ll need to study this further. For the moment, one<br>initial thought: one key point in this paper is that conflict resolution<br>for traits hinges on the fact that they do not access state, and so the<br>diamond problem does not occur.<br></p><p><br>&gt; This is a very common problem that only a few programming languages have<br>&gt; found successful solutions to.  I would also point you to Eiffel’s model<br>&gt; for multiple inheritance (select, rename, undefine, export).  I think if we<br>&gt; keep working on it, we can find a uniquely swift-feeling solution which<br>&gt; solves the issue :-)<br>&gt;<br>&gt;<br>&gt; - Necessity: earlier, examples were cited where at least one of two<br>&gt; conflicting protocols were under the user&#39;s control; in that case, this<br>&gt; feature isn&#39;t needed, because that protocol&#39;s requirements can be trivially<br>&gt; renamed<br>&gt;<br>&gt;<br>&gt; I ran into a case of the diamond problem with protocols again today in a<br>&gt; real world project.  Both classes were under my control, but I wasn’t able<br>&gt; to avoid the name conflict because they had a common ancestor.<br>&gt;<br></p><p>Can you explain this in more detail? Were you working with protocols or<br>classes?<br></p><p>If a protocol inherits from two protocols with a common ancestor, the<br>protocol requirements from that ancestor cannot possibly conflict with<br>themselves. Are you talking about default implementations? If so, there&#39;s<br>another thread (recent, but dormant now) suggesting new syntax to call a<br>named default implementation from an implementation in a conforming type<br>(and by extension (har har), from a default implementation in an inheriting<br>protocol). I believe that the suggestion had a pretty positive reception,<br>and unless I&#39;m mistaken, it would address this particular issue (which I<br>agree is currently problematic).<br></p><p><br>&gt; I was able to solve it by copy/pasting the winning method definition, but<br>&gt; this is definitely not ideal, since I must now maintain code in two places<br>&gt; which makes upkeep/changes more difficult.<br>&gt;<br>&gt; What I want here is the ability to notate the winner in my inheriting<br>&gt; protocol.<br>&gt;<br>&gt;<br>&gt; - Good design: show me that the design patterns enabled by the feature are<br>&gt; better than what is possible with workarounds; if a renaming or hiding<br>&gt; feature is expedient, but an alternative approach would promote less<br>&gt; fragile or more Swifty design, then we should be exploring ways to simplify<br>&gt; or promote an alternative approach; one consideration, for example, is that<br>&gt; naming of anything is hard, and the current fact that protocols *need* to<br>&gt; have well-chosen member names encourages designers to think hard--but if<br>&gt; renaming becomes possible, could we simply be enabling less thoughtful<br>&gt; protocol design with little benefit (to evaluate this, we would need some<br>&gt; sense of the answer to the necessity question above)?<br>&gt;<br>&gt;<br>&gt; Your suggestion that the framework designers should have to go back and<br>&gt; refactor their code because of another framework is an indication of<br>&gt; coupled design and bad code smell.  Suddenly my protocols have to know<br>&gt; about all of the other protocols being used (or which could theoretically<br>&gt; be used) and I have to design around them.  This is problematic.  Ideally,<br>&gt; I should be able to design each protocol in a way which makes the most<br>&gt; sense semantically for the use of that protocol.  Any contortions I have to<br>&gt; make to the design away from the ideal are something to be avoided where<br>&gt; possible.  I know we are used to making these contortions, but is it really<br>&gt; the best design (or is it a form of Stockholm syndrome)?<br>&gt;<br></p><p>I see this differently. Are you arguing that protocols should be designed<br>*without* consideration of how they compose with other protocols? By the<br>same token, should types be designed *without* consideration of how they<br>are used? If users of my library (which might be just myself, dogfooding)<br>find that the API is cumbersome, are you arguing that I *shouldn&#39;t* go back<br>and redesign the API for the next major version, because I&#39;d be coupling<br>the design of my API to the needs of my end users?<br></p><p>To use your analogy, what you characterize as grotesque contortions are<br>what I&#39;m arguing is a graceful dance.<br></p><p><br>&gt; Here is an article on Eiffel’s multiple inheritance system which makes the<br>&gt; point well:<br>&gt; https://archive.eiffel.com/doc/manuals/technology/<br>&gt; bmarticles/joop/multiple.html<br>&gt;<br>&gt; Some selected passages:<br>&gt;<br>&gt; One of the differences is particularly important if you take a software<br>&gt; engineering viewpoint and consider these solutions in relation with the<br>&gt; software development lifecycle. If the developers first implement simple<br>&gt; menus only, and only then realize the need for walking menus, using tree<br>&gt; solution means that they must go back to the initial definition of class<br>&gt; *MENU* and rework it extensively. This brings disorder into the<br>&gt; development process.<br>&gt;<br>&gt; With the multiple inheritance solution, things are quite different. When<br>&gt; the developers realize that a new kind of menu is needed, they simply<br>&gt; define it by inheritance from *MENU* and *ENTRY*. The changes to existing<br>&gt; software are minimal. This is an example of one of the key benefits of the<br>&gt; object-oriented method, which would have to be renounced in the absence of<br>&gt; multiple inheritance.<br>&gt;<br>&gt; (emphasis mine)<br>&gt;<br>&gt; Assume you are in the inheritance-based reusability business and combine<br>&gt; classes from two software suppliers, say one in New York and one in London.<br>&gt; Sure enough, one day you are going to run into the problem of combining two<br>&gt; classes that both have a feature called *foo*, to use as example one of<br>&gt; these nice evocative names that programmers are fond of.<br>&gt;<br>&gt; But this is not a conceptual problem! It merely results from an<br>&gt; unfortunate choice of names. If the parent programmers had chosen other<br>&gt; names, differing by just one letter -- influenced perhaps by local<br>&gt; conditions, they might have used *zoo* in New York and *fog* in London<br>&gt; --, the problem would never have arisen.<br>&gt;<br>&gt; This suggests the two key observations on this problem:<br>&gt;<br>&gt;    - First, it is purely a *syntactical* problem, due to conflicting name<br>&gt;    choices. It has nothing to do with the fundamental properties of the<br>&gt;    classes involved.<br>&gt;    - Second, *nothing is wrong with the parents*; each is perfectly<br>&gt;    consistent as it stands. The &quot;culprit&quot; is the common heir, which tries to<br>&gt;    combine two classes that are incompatible as they stand. So *the heir<br>&gt;    should also be responsible for the solution*.<br>&gt;<br>&gt;<br>Unless I&#39;m mistaken, the generally accepted wisdom that&#39;s emerged since the<br>publication of that article in 1988 is that multiple inheritance is perhaps<br>not the wisest choice. Today, Swift supports OOP but eschews multiple<br>inheritance. To the extent that we extend Swift&#39;s support of POP, it should<br>not be to restore the same pitfalls of multiple inheritance under the guise<br>of a different paradigm.<br></p><p><br>&gt; It also includes an example of how renaming can make a design more<br>&gt; consistent.  You can use a protocol for it’s functionality (Tree-based<br>&gt; calculation) while providing an end-user interface that makes sense to your<br>&gt; domain.<br>&gt;<br></p><p>Again, I understand the motivation. My point is, currently, conformance to<br>a protocol guarantees a certain interface for the conforming type. Adding<br>the ability to use a protocol for its functionality *without* being<br>constrained to provide an interface *necessarily entails the loss* of a<br>certain feature of protocol conformance today: namely, the guarantee of<br>that interface on the concrete type.<br></p><p>&gt; Although purely syntactical, renaming is not limited in its applications<br>&gt; to the resolution of name clashes. Among its other uses, one deserves a<br>&gt; particular mention because it sheds more light into the meaning and power<br>&gt; of inheritance. This is renaming used to define consistent class interfaces.<br>&gt;<br>&gt; The following example is typical. Again, it will illustrate techniques<br>&gt; used in the Eiffel Graphical Library. Assume we want to describe<br>&gt; rectangular windows that can be arbitrarily nested. The corresponding<br>&gt; class, say *WINDOW*, will have a large number of features, which can be<br>&gt; grouped into two categories:<br>&gt;<br>&gt;    - Graphical features: *height, width, position, move, scale* and the<br>&gt;    like.<br>&gt;    - Hierarchical features, having to do with the tree structure of<br>&gt;    nested windows: *add_subwindow, remove_subwindow, superwindow* and the<br>&gt;    like.<br>&gt;<br>&gt; […]<br>&gt;<br>&gt;  Features inherited from *TREE*, in particular, will bear their tree<br>&gt; names: *insert_node, remove_node, parent_node* and so on. This is not<br>&gt; acceptable to a client programmer like Ed who wants good, concrete window<br>&gt; terminology.<br>&gt;<br>&gt; With renaming, the solution is straightforward. Wendy ought to spend ten<br>&gt; more minutes polishing the interface, so that clients of class *WINDOW* won&#39;t<br>&gt; need to be aware of its tree ancestry:<br>&gt;<br>&gt;<br>&gt; 	*class** WINDOW* *inherit*<br>&gt;<br>&gt; 		*RECT_SHAPE*<br>&gt; 			*rename* ...<br>&gt;<br>&gt; 		*TREE*<br>&gt; 			*rename**<br>&gt; 				insert_node as add_subwindow,<br>&gt; 				remove_node as delete_subwindow,<br>&gt; 				parent_node as superwindow,<br>&gt; 				...<br>&gt; 	**feature*<br>&gt;<br>&gt; 		...<br>&gt;<br>&gt; 	*end* -- class *WINDOW*<br>&gt;<br>&gt;<br>&gt; I think we have an opportunity here to actually solve this problem by<br>&gt; looking at the solutions which came before and then creating something<br>&gt; uniquely swift.<br>&gt;<br></p><p>Doesn&#39;t the same quotation argue for multiple inheritance of classes and<br>renaming of class members in subclasses, neither of which are supported in<br>Swift? Are you proposing to have those features too?<br></p><p>In this example, Wendy renames members on WINDOW for the express purpose of<br>obscuring its ancestry. This makes Ed happy because he likes particular<br>names for methods on WINDOW. However, it certainly makes it more difficult<br>to reason about what&#39;s actually going on when you call these methods. Where<br>is add_subwindow implemented? You won&#39;t find it anywhere in the code. This<br>is not an unmitigated win. It&#39;s a mixed bag at best; IMO, we&#39;re better off<br>without such a feature.<br></p><p>Thanks,<br>&gt; Jon<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160906/5807a3c4/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Renaming for Protocol Conformance</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>September  6, 2016 at 10:00:00pm</p></header><div class="content"><p>On Sep 6, 2016, at 6:06 PM, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; I&#39;m not entirely sure on my position, though. To be convinced otherwise, I&#39;d need to see a compelling real-world use case that demonstrates all of the following:<br>&gt;&gt; <br>&gt;&gt; - Safety: perhaps, with protocols, unlike class inheritance, it is almost always safe to make these kinds of changes unanticipated by the original author--it would be good to see evidence either way<br>&gt; <br>&gt; You may find this paper interesting:<br>&gt; http://scg.unibe.ch/archive/papers/Scha02bTraits.pdf &lt;http://scg.unibe.ch/archive/papers/Scha02bTraits.pdf&gt;<br>&gt; <br>&gt; It discusses traits, which are basically Swift’s protocols, plus the ability to handle conflicts.  It discusses at length the issues that arise with other systems.<br>&gt; <br>&gt; This is a very common problem that only a few programming languages have found successful solutions to.  I would also point you to Eiffel’s model for multiple inheritance (select, rename, undefine, export).  I think if we keep working on it, we can find a uniquely swift-feeling solution which solves the issue :-)<br></p><p>Here’s another obscure paper coming from the world of C++, see section 3.5/4.1:<br>http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.48.129<br></p><p>Not a syntax that we would want to emulate, but it’s the same idea in different clothes.  The Swift implementation model should support implementing something along these lines, but it would be a purely additive feature.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160906/67b0c625/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Renaming for Protocol Conformance</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>August 24, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Aug 22, 2016, at 9:59 PM, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi everyone,<br>&gt; <br>&gt; We talked about this before when we were discussing mixins, and there seemed to be generally positive feelings towards it as a feature for the future.  I am fairly certain this affects the ABI though, so I thought I would bring it up now.<br>&gt; <br>&gt; If two protocols have methods/properties with the same name, but different signatures, we need a way to distinguish between them when attempting to conform to both.<br>&gt; <br>&gt; 	protocol A {<br>&gt; 		var x:Int {get set}<br>&gt; 	}<br>&gt; <br>&gt; 	protocol B {<br>&gt; 		var x:Double {get set}<br>&gt; 	}<br></p><p>I believe that this can happen, and it is unfortunate that Swift has no mechanism for dealing with it today. However, I agree with Xiaodi that your proposal would be much stronger with real-world examples rather than theoretical ones.<br></p><p>&gt; One possibility is to allow a struct/class/enum to conform to the protocol while renaming one (or both) of the clashing methods:<br>&gt; <br>&gt; 	struct C: A,B {<br>&gt; 		var x:Int<br>&gt; 		var y:Double implements B.x<br>&gt; 	}<br>&gt; <br>&gt; The conforming method/property would still have to have the same signature, but could have a different name (and parameter labels).  It would also allow protocol methods which have identical signatures and semantics, but different names to be implemented using the same method (i.e ‘implements D.z &amp; E.w’).<br>&gt; <br>&gt; When something is cast to the protocol (say ‘as B’), then calling the property (e.g. ‘x’) would end up calling the implementation of the renamed property ( ‘y’ in this example) on the conforming type.<br></p><p>Sure. Calling through the protocol type will get whatever method/property satisfied the protocol requirement. Yes, there are limits here due to protocols with associated types and Self requirements, but I fully expect those to go away at some point with generalized existentials.<br></p><p>&gt; I think we would also want a way to retroactively conform using existing properties/methods in an extension declaring conformance.  Not sure what the best syntax for that would be.  Off the top of my head (though I would love to have something with less cruft):<br>&gt; <br>&gt; 	extension D:B {<br>&gt; 		@conform(to: B.x, with: D.y)<br>&gt; 	}<br>&gt; <br>&gt; or maybe just:<br>&gt; 	<br>&gt; 	extension D:B {<br>&gt; 		D.y implements B.x<br>&gt; 	}<br>&gt; 	<br>&gt; <br>&gt; All of this is merely to start the discussion, so feel free to propose better syntax or a more elegant solution...<br></p><p><br>C# has a much narrower solution that lets you qualify the method declaration (rather than doing a full rename), e.g.,<br></p><p>	struct C : A {<br>	  var x: Int<br>	  var y: Double<br>	}<br></p><p>	extension C : B {<br>	  var B.x: Double {<br>	    get { return y }<br>	    set { y = newValue }<br>	  }<br>	}<br></p><p>They have some examples at:<br></p><p>	https://msdn.microsoft.com/en-us/library/aa288461(v=vs.71).aspx &lt;https://msdn.microsoft.com/en-us/library/aa288461(v=vs.71).aspx&gt;<br></p><p>One would have to figure out what the name-lookup rules are, of course, but this might allow us to solve the problem without introducing a generalized renaming mechanism.<br></p><p>	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160824/d30c1f5a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>Renaming for Protocol Conformance</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>August 24, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Aug 24, 2016, at 11:38 AM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Aug 22, 2016, at 9:59 PM, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi everyone,<br>&gt;&gt; <br>&gt;&gt; We talked about this before when we were discussing mixins, and there seemed to be generally positive feelings towards it as a feature for the future.  I am fairly certain this affects the ABI though, so I thought I would bring it up now.<br>&gt;&gt; <br>&gt;&gt; If two protocols have methods/properties with the same name, but different signatures, we need a way to distinguish between them when attempting to conform to both.<br>&gt;&gt; <br>&gt;&gt; 	protocol A {<br>&gt;&gt; 		var x:Int {get set}<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; 	protocol B {<br>&gt;&gt; 		var x:Double {get set}<br>&gt;&gt; 	}<br>&gt; <br>&gt; I believe that this can happen, and it is unfortunate that Swift has no mechanism for dealing with it today. However, I agree with Xiaodi that your proposal would be much stronger with real-world examples rather than theoretical ones.<br></p><p>Agreed. Unfortunately, everything is NDA’d at the moment.  <br></p><p>Also, the problem (not the solution) is so obvious to me that I guess I am having trouble explaining it.  I never expected to have to argue that namespace collisions can cause problems… I thought everyone had had that experience (especially coming from ObjC).<br></p><p>I am not tied to this proposal, so much as I wanted to start a discussion exploring the possible solution space.  The explicit interface idea is a solid option.  I like that you wouldn’t necessarily have to expose a protocol’s members without qualification. I should also be able to effectively rename a member by calling the unexposed protocol implementation from a method with my desired name.<br></p><p>tl;dr:  I would like people to provide options/syntax for solving this problem (even if they are a bit wild), so that we can cherry pick the best stuff and put together an elegant solution…<br></p><p>Thanks,<br>Jon<br></p><p><br>&gt; <br>&gt;&gt; One possibility is to allow a struct/class/enum to conform to the protocol while renaming one (or both) of the clashing methods:<br>&gt;&gt; <br>&gt;&gt; 	struct C: A,B {<br>&gt;&gt; 		var x:Int<br>&gt;&gt; 		var y:Double implements B.x<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; The conforming method/property would still have to have the same signature, but could have a different name (and parameter labels).  It would also allow protocol methods which have identical signatures and semantics, but different names to be implemented using the same method (i.e ‘implements D.z &amp; E.w’).<br>&gt;&gt; <br>&gt;&gt; When something is cast to the protocol (say ‘as B’), then calling the property (e.g. ‘x’) would end up calling the implementation of the renamed property ( ‘y’ in this example) on the conforming type.<br>&gt; <br>&gt; Sure. Calling through the protocol type will get whatever method/property satisfied the protocol requirement. Yes, there are limits here due to protocols with associated types and Self requirements, but I fully expect those to go away at some point with generalized existentials.<br>&gt; <br>&gt;&gt; I think we would also want a way to retroactively conform using existing properties/methods in an extension declaring conformance.  Not sure what the best syntax for that would be.  Off the top of my head (though I would love to have something with less cruft):<br>&gt;&gt; <br>&gt;&gt; 	extension D:B {<br>&gt;&gt; 		@conform(to: B.x, with: D.y)<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; or maybe just:<br>&gt;&gt; 	<br>&gt;&gt; 	extension D:B {<br>&gt;&gt; 		D.y implements B.x<br>&gt;&gt; 	}<br>&gt;&gt; 	<br>&gt;&gt; <br>&gt;&gt; All of this is merely to start the discussion, so feel free to propose better syntax or a more elegant solution...<br>&gt; <br>&gt; <br>&gt; C# has a much narrower solution that lets you qualify the method declaration (rather than doing a full rename), e.g.,<br>&gt; <br>&gt; 	struct C : A {<br>&gt; 	  var x: Int<br>&gt; 	  var y: Double<br>&gt; 	}<br>&gt; <br>&gt; 	extension C : B {<br>&gt; 	  var B.x: Double {<br>&gt; 	    get { return y }<br>&gt; 	    set { y = newValue }<br>&gt; 	  }<br>&gt; 	}<br>&gt; <br>&gt; They have some examples at:<br>&gt; <br>&gt; 	https://msdn.microsoft.com/en-us/library/aa288461(v=vs.71).aspx &lt;https://msdn.microsoft.com/en-us/library/aa288461(v=vs.71).aspx&gt;<br>&gt; <br>&gt; One would have to figure out what the name-lookup rules are, of course, but this might allow us to solve the problem without introducing a generalized renaming mechanism.<br>&gt; <br>&gt; 	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160824/215b22c8/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>Renaming for Protocol Conformance</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>August 24, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On 24 Aug 2016, at 20:38, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Aug 22, 2016, at 9:59 PM, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi everyone,<br>&gt;&gt; <br>&gt;&gt; We talked about this before when we were discussing mixins, and there seemed to be generally positive feelings towards it as a feature for the future.  I am fairly certain this affects the ABI though, so I thought I would bring it up now.<br>&gt;&gt; <br>&gt;&gt; If two protocols have methods/properties with the same name, but different signatures, we need a way to distinguish between them when attempting to conform to both.<br>&gt;&gt; <br>&gt;&gt; 	protocol A {<br>&gt;&gt; 		var x:Int {get set}<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; 	protocol B {<br>&gt;&gt; 		var x:Double {get set}<br>&gt;&gt; 	}<br>&gt; <br>&gt; I believe that this can happen, and it is unfortunate that Swift has no mechanism for dealing with it today. However, I agree with Xiaodi that your proposal would be much stronger with real-world examples rather than theoretical ones.<br>&gt; <br>&gt;&gt; One possibility is to allow a struct/class/enum to conform to the protocol while renaming one (or both) of the clashing methods:<br>&gt;&gt; <br>&gt;&gt; 	struct C: A,B {<br>&gt;&gt; 		var x:Int<br>&gt;&gt; 		var y:Double implements B.x<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; The conforming method/property would still have to have the same signature, but could have a different name (and parameter labels).  It would also allow protocol methods which have identical signatures and semantics, but different names to be implemented using the same method (i.e ‘implements D.z &amp; E.w’).<br>&gt;&gt; <br>&gt;&gt; When something is cast to the protocol (say ‘as B’), then calling the property (e.g. ‘x’) would end up calling the implementation of the renamed property ( ‘y’ in this example) on the conforming type.<br>&gt; <br>&gt; Sure. Calling through the protocol type will get whatever method/property satisfied the protocol requirement. Yes, there are limits here due to protocols with associated types and Self requirements, but I fully expect those to go away at some point with generalized existentials.<br>&gt; <br>&gt;&gt; I think we would also want a way to retroactively conform using existing properties/methods in an extension declaring conformance.  Not sure what the best syntax for that would be.  Off the top of my head (though I would love to have something with less cruft):<br>&gt;&gt; <br>&gt;&gt; 	extension D:B {<br>&gt;&gt; 		@conform(to: B.x, with: D.y)<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; or maybe just:<br>&gt;&gt; 	<br>&gt;&gt; 	extension D:B {<br>&gt;&gt; 		D.y implements B.x<br>&gt;&gt; 	}<br>&gt;&gt; 	<br>&gt;&gt; <br>&gt;&gt; All of this is merely to start the discussion, so feel free to propose better syntax or a more elegant solution...<br>&gt; <br>&gt; <br>&gt; C# has a much narrower solution that lets you qualify the method declaration (rather than doing a full rename), e.g.,<br>&gt; <br>&gt; 	struct C : A {<br>&gt; 	  var x: Int<br>&gt; 	  var y: Double<br>&gt; 	}<br>&gt; <br>&gt; 	extension C : B {<br>&gt; 	  var B.x: Double {<br>&gt; 	    get { return y }<br>&gt; 	    set { y = newValue }<br>&gt; 	  }<br>&gt; 	}<br>&gt; <br>&gt; They have some examples at:<br>&gt; <br>&gt; 	https://msdn.microsoft.com/en-us/library/aa288461(v=vs.71).aspx &lt;https://msdn.microsoft.com/en-us/library/aa288461(v=vs.71).aspx&gt;<br>&gt; <br>&gt; One would have to figure out what the name-lookup rules are, of course, but this might allow us to solve the problem without introducing a generalized renaming mechanism.<br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>+1 to the C# mechanism (I think it’s basically what I proposed earlier). Resolving protocol conformance by name is soooo Objective-C. Swift has a much stronger protocol system, and members which belong to a protocol should **belong** to that protocol (have it mangled in to the name, MyType__MyProtocol__MyMember, etc. As a shorthand, when the corresponding protocol is unambiguous you can declare or use it directly (MyType.MyMember).<br></p><p>I’m very much against renaming. It’s a hack; we want a solution. That applies to all instances of renaming - here, in protocol conformances, and in general with imported types (there was a proposal some months ago which involved renaming members when importing).<br></p><p>The two most important things for programmers are how well they know the language, and how well they know the libraries they are using. Renaming makes the latter basically useless. Somebody doesn’t like the long names in Apple’s SDK, and suddenly UITableView becomes Table or even just an emoji (why not?). The code you know and patterns you expect become a bunch of alien hieroglyphics which looked neat and terse to the person writing it but requires extensive study by anybody else.<br></p><p>Renaming is just bad, bad, bad. I’ll argue strongly against adding any kind of symbol renaming to Swift whatsoever for as long as I’m active in the community (except across language barriers, like with @objc(&lt;name&gt;), because the symbols don’t match up anyway so there’s no prior knowledge to break — in fact it’s usually used to retain older APIs and make transitions *less* breaking).<br></p><p>Karl<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160824/d87f349c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Renaming for Protocol Conformance</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 26, 2016 at 01:00:00am</p></header><div class="content"><p>On Wed, Aug 24, 2016 at 3:28 PM, Karl via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On 24 Aug 2016, at 20:38, Douglas Gregor via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Aug 22, 2016, at 9:59 PM, Jonathan Hull via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Hi everyone,<br>&gt;<br>&gt; We talked about this before when we were discussing mixins, and there<br>&gt; seemed to be generally positive feelings towards it as a feature for the<br>&gt; future.  I am fairly certain this affects the ABI though, so I thought I<br>&gt; would bring it up now.<br>&gt;<br>&gt; If two protocols have methods/properties with the same name, but different<br>&gt; signatures, we need a way to distinguish between them when attempting to<br>&gt; conform to both.<br>&gt;<br>&gt; protocol A {<br>&gt; var x:Int {get set}<br>&gt; }<br>&gt;<br>&gt; protocol B {<br>&gt; var x:Double {get set}<br>&gt; }<br>&gt;<br>&gt;<br>&gt; I believe that this can happen, and it is unfortunate that Swift has no<br>&gt; mechanism for dealing with it today. However, I agree with Xiaodi that your<br>&gt; proposal would be much stronger with real-world examples rather than<br>&gt; theoretical ones.<br>&gt;<br>&gt; One possibility is to allow a struct/class/enum to conform to the protocol<br>&gt; while renaming one (or both) of the clashing methods:<br>&gt;<br>&gt; struct C: A,B {<br>&gt; var x:Int<br>&gt; var y:Double implements B.x<br>&gt; }<br>&gt;<br>&gt; The conforming method/property would still have to have the same<br>&gt; signature, but could have a different name (and parameter labels).  It<br>&gt; would also allow protocol methods which have identical signatures and<br>&gt; semantics, but different names to be implemented using the same method (i.e<br>&gt; ‘implements D.z &amp; E.w’).<br>&gt;<br>&gt; When something is cast to the protocol (say ‘as B’), then calling the<br>&gt; property (e.g. ‘x’) would end up calling the implementation of the renamed<br>&gt; property ( ‘y’ in this example) on the conforming type.<br>&gt;<br>&gt;<br>&gt; Sure. Calling through the protocol type will get whatever method/property<br>&gt; satisfied the protocol requirement. Yes, there are limits here due to<br>&gt; protocols with associated types and Self requirements, but I fully expect<br>&gt; those to go away at some point with generalized existentials.<br>&gt;<br>&gt; I think we would also want a way to retroactively conform using existing<br>&gt; properties/methods in an extension declaring conformance.  Not sure what<br>&gt; the best syntax for that would be.  Off the top of my head (though I would<br>&gt; love to have something with less cruft):<br>&gt;<br>&gt; extension D:B {<br>&gt; @conform(to: B.x, with: D.y)<br>&gt; }<br>&gt;<br>&gt; or maybe just:<br>&gt;<br>&gt; extension D:B {<br>&gt; D.y implements B.x<br>&gt; }<br>&gt;<br>&gt;<br>&gt; All of this is merely to start the discussion, so feel free to propose<br>&gt; better syntax or a more elegant solution...<br>&gt;<br>&gt;<br>&gt; C# has a much narrower solution that lets you qualify the method<br>&gt; declaration (rather than doing a full rename), e.g.,<br>&gt;<br>&gt; struct C : A {<br>&gt;   var x: Int<br>&gt;   var y: Double<br>&gt; }<br>&gt;<br>&gt; extension C : B {<br>&gt;   var B.x: Double {<br>&gt;     get { return y }<br>&gt;     set { y = newValue }<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; They have some examples at:<br>&gt;<br>&gt; https://msdn.microsoft.com/en-us/library/aa288461(v=vs.71).aspx<br>&gt;<br>&gt; One would have to figure out what the name-lookup rules are, of course,<br>&gt; but this might allow us to solve the problem without introducing a<br>&gt; generalized renaming mechanism.<br>&gt;<br>&gt; - Doug<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; +1 to the C# mechanism (I think it’s basically what I proposed earlier).<br>&gt; Resolving protocol conformance by name is soooo Objective-C. Swift has a<br>&gt; much stronger protocol system, and members which belong to a protocol<br>&gt; should **belong** to that protocol (have it mangled in to the name,<br>&gt; MyType__MyProtocol__MyMember, etc. As a shorthand, when the corresponding<br>&gt; protocol is unambiguous you can declare or use it directly<br>&gt; (MyType.MyMember).<br>&gt;<br>&gt; I’m very much against renaming. It’s a hack; we want a solution. That<br>&gt; applies to all instances of renaming - here, in protocol conformances, and<br>&gt; in general with imported types (there was a proposal some months ago which<br>&gt; involved renaming members when importing).<br>&gt;<br>&gt; The two most important things for programmers are how well they know the<br>&gt; language, and how well they know the libraries they are using. Renaming<br>&gt; makes the latter basically useless. Somebody doesn’t like the long names in<br>&gt; Apple’s SDK, and suddenly UITableView becomes Table or even just an emoji<br>&gt; (why not?). The code you know and patterns you expect become a bunch of<br>&gt; alien hieroglyphics which looked neat and terse to the person writing it<br>&gt; but requires extensive study by anybody else.<br>&gt;<br>&gt; Renaming is just bad, bad, bad. I’ll argue strongly against adding any<br>&gt; kind of symbol renaming to Swift whatsoever for as long as I’m active in<br>&gt; the community (except across language barriers, like with @objc(&lt;name&gt;),<br>&gt; because the symbols don’t match up anyway so there’s no prior knowledge to<br>&gt; break — in fact it’s usually used to retain older APIs and make transitions<br>&gt; *less* breaking).<br>&gt;<br></p><p>After some reflection, I think I largely agree with Karl on this point. A<br>C#-like explicit implementation mechanism might be the way to go; it solves<br>the issue of colliding names without introducing the difficulties that<br>arise from arbitrary renaming.<br></p><p>Where I would disagree with Karl would be on mangling the protocol names<br>into member names; as I wrote above, I strongly hold to the view that it&#39;s<br>important that protocols guarantee the API of conforming types, so I think<br>that protocol requirements should be in the same namespace as all other<br>type members *unless* something else is explicitly necessary due to a<br>collision. However, in the end, the disagreement here is more conceptual<br>than practical, as everyday use of the feature would be largely similar in<br>any case.<br></p><p>Based on that view, however, I&#39;d go a step further in<br>simplifying/rationalizing the C#-like mechanism, like so:<br></p><p>* I&#39;d propose that conformance to a protocol can be either as it is in<br>Swift 3 (let&#39;s call it &quot;direct&quot;) or it can be what C# would call explicit<br>(let&#39;s call it &quot;indirect&quot;, just for good measure); unlike C#, this choice<br>would refer to conformance as a whole, not to implementation of specific<br>members (although this is more of a notional difference from C#, since as<br>proposed below, specific members may or may not be accessible directly<br>without casting).<br></p><p>* Members declared directly on the type that match the requirements of an<br>&quot;indirectly conformed&quot; protocol will satisfy those requirements, but any<br>remaining requirements not satisfied in that manner (for instance, due to<br>colliding names) must be implemented in an extension that explicitly<br>declares indirect conformance. For example:<br></p><p>```<br>protocol A {<br>  var x: Int { get }<br>  var y: Int { get }<br>}<br></p><p>protocol B {<br>  var x: Double { get }<br>  var y: Int { get }<br>}<br></p><p>struct S : A {<br>  var x: Int { return 42 }<br>  var y: Int { return 43 }<br>  // we cannot have S conform to B just yet<br>  // because we can&#39;t re-declare `x` as a property of type Double<br>}<br></p><p>extension S : indirect B {<br>  var x: Double { return -42 }<br>  // note that `y` is satisfied by the implementation above<br>}<br>```<br></p><p>* Members declared in an extension adding an &quot;indirect&quot; conformance to a<br>protocol can only be accessed after the type is cast to the corresponding<br>existential type. In the example above, `S.x` is an Int (and is the same as<br>`(S as A).x`) and has value 42, but `(S as B).x` is a Double and has value<br>-42.0. Meanwhile, `S.y` can be accessed directly or indirectly as either<br>`(S as A).y` or `(S as B).y` and has value 43.<br></p><p>* Until generics are completed, only protocols without Self or associated<br>type requirements can be used as an existential, so for now let&#39;s limit<br>indirect conformances to protocols without Self or associated type<br>requirements; this limit should be relaxed in tandem with the<br>implementation of generalized existentials.<br></p><p>Would this simplified scheme go far enough in addressing the original issue?<br></p><p><br>Karl<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160826/ff0ba8a7/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
