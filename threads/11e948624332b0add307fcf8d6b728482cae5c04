<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3e73e82f91d76f370364ce25f0430c17?s=50"></div><header><strong>Keeping unused values around until containing scope exits?</strong> from <string>Ollie Wagner</string> &lt;olliewagner at mac.com&gt;<p>December 30, 2015 at 11:00:00am</p></header><div class="content"><p>I&#39;m using the lifetime of a variable to push and pop a context in an animation system that I&#39;m writing. I&#39;m interested in using a pattern like:<br></p><p>func doAnimations() {<br>    AnimationContext(speed: 1.0, bounciness: 1.0)<br>    // do some animations using these options<br>}<br></p><p>But today, the value returned by AnimationContext(speed:bounciness:) gets deinitted immediately.<br></p><p>I&#39;ve come to desire using such a pattern after living with this for a while:<br></p><p>AnimationContext(speed: 1.0, bounciness: 1.0) {<br>    // do some animations using these options	<br>}<br></p><p>But I don&#39;t like it because it contributes heavily to rightward drift (a user of this API might want to change the options multiple times), and gets hard to parse when nested in the many other language constructs that create a scope using brackets.<br></p><p>So — would it be reasonable to suggest that we have some keyword(s) preceeding an initializer that allows a value to stay alive and/or not warn if it winds up going unused? The current behavior in Swift has obviously been considered, so please feel free to tell me if this is a Very Bad Idea. I&#39;m still learning!<br></p><p>- Ollie<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/11e95c04/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Keeping unused values around until containing scope exits?</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 30, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 30, 2015, at 10:10 AM, Ollie Wagner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;m using the lifetime of a variable to push and pop a context in an animation system that I&#39;m writing. I&#39;m interested in using a pattern like:<br>&gt; <br>&gt; func doAnimations() {<br>&gt;     AnimationContext(speed: 1.0, bounciness: 1.0)<br>&gt;     // do some animations using these options<br>&gt; }<br>&gt; <br>&gt; But today, the value returned by AnimationContext(speed:bounciness:) gets deinitted immediately.<br>&gt; <br>&gt; I&#39;ve come to desire using such a pattern after living with this for a while:<br>&gt; <br>&gt; AnimationContext(speed: 1.0, bounciness: 1.0) {<br>&gt;     // do some animations using these options	<br>&gt; }<br>&gt; <br>&gt; But I don&#39;t like it because it contributes heavily to rightward drift (a user of this API might want to change the options multiple times), and gets hard to parse when nested in the many other language constructs that create a scope using brackets.<br></p><p>There&#39;s a standard function withExtendedLifetime which you can use for this already:<br></p><p>withExtendedLifetime(AnimationContext(...)) {<br>   // AnimationContext is guaranteed to be alive in this block<br>}<br></p><p>though that doesn&#39;t solve the rightward drift problem. You can alternately defer { } an artificial use of the object:<br></p><p>@inline(never) func use(x: Any) { }<br></p><p>let x = AnimationContext(...); defer { use(x) }<br></p><p>As discussed in the &quot;scoped resources&quot; thread, we might also benefit from something like ObjC ARC&#39;s scoped lifetime attribute.<br></p><p>&gt; So — would it be reasonable to suggest that we have some keyword(s) preceeding an initializer that allows a value to stay alive and/or not warn if it winds up going unused? The current behavior in Swift has obviously been considered, so please feel free to tell me if this is a Very Bad Idea. I&#39;m still learning!<br></p><p>The vast majority of objects only own resources that are only necessary for that object&#39;s own operation, and most of Swift&#39;s target platforms are resource-constrained, so it&#39;s a valuable optimization to be able to deallocate objects ASAP. We think it&#39;s a reasonable tradeoff for objects which do require fixed scopes to require a bit of additional annotation.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/24d09a36/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Keeping unused values around until containing scope exits?</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 30, 2015 at 04:00:00pm</p></header><div class="content"><p>I strongly recommend either making the context get explicitly used in the subsequent animations (e.g. `context.animation(...)` instead of just `animation(...)`) or giving it an explicit scope (e.g. `withAnimationContext(speed: 1.0, bounciness: 1.0) { ... }`). Having the presence of a stack value influence behavior is a great way to cause maintenance issues later on.<br></p><p>-Kevin Ballard<br></p><p>On Wed, Dec 30, 2015, at 10:10 AM, Ollie Wagner via swift-evolution wrote:<br>&gt; I&#39;m using the lifetime of a variable to push and pop a context in<br>&gt; an animation system that I&#39;m writing. I&#39;m interested in using a<br>&gt; pattern like:<br>&gt;<br>&gt; func doAnimations() {    AnimationContext(speed: 1.0, bounciness: 1.0)<br>&gt; // do some animations using these options }<br>&gt;<br>&gt; But today, the value returned by AnimationContext(speed:bounciness:)<br>&gt; gets deinitted immediately.<br>&gt;<br>&gt; I&#39;ve come to desire using such a pattern after living with this for<br>&gt; a while:<br>&gt;<br>&gt; AnimationContext(speed: 1.0, bounciness: 1.0) {    // do some<br>&gt; animations using these options }<br>&gt;<br>&gt; But I don&#39;t like it because it contributes heavily to rightward drift<br>&gt; (a user of this API might want to change the options multiple times),<br>&gt; and gets hard to parse when nested in the many other language<br>&gt; constructs that create a scope using brackets.<br>&gt;<br>&gt; So — would it be reasonable to suggest that we have some keyword(s)<br>&gt; preceeding an initializer that allows a value to stay alive and/or not<br>&gt; warn if it winds up going unused? The current behavior in Swift has<br>&gt; obviously been considered, so please feel free to tell me if this is a<br>&gt; Very Bad Idea. I&#39;m still learning!<br>&gt;<br>&gt; - Ollie<br>&gt;<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/d012af7a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a59b0df1d55761e4d340da93232790ea?s=50"></div><header><strong>Keeping unused values around until containing scope exits?</strong> from <string>Kevin Wooten</string> &lt;kdubb at me.com&gt;<p>December 30, 2015 at 07:00:00pm</p></header><div class="content"><p>&gt; On Dec 30, 2015, at 5:38 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I strongly recommend either making the context get explicitly used in the subsequent animations (e.g. `context.animation(...)` instead of just `animation(...)`) or giving it an explicit scope (e.g. `withAnimationContext(speed: 1.0, bounciness: 1.0) { ... }`). Having the presence of a stack value influence behavior is a great way to cause maintenance issues later on.<br>&gt;  <br>&gt; -Kevin Ballard<br>&gt;  <br>&gt; On Wed, Dec 30, 2015, at 10:10 AM, Ollie Wagner via swift-evolution wrote:<br>&gt;&gt; I&#39;m using the lifetime of a variable to push and pop a context in an animation system that I&#39;m writing. I&#39;m interested in using a pattern like:<br>&gt;&gt;  <br>&gt;&gt; func doAnimations() {<br>&gt;&gt;     AnimationContext(speed: 1.0, bounciness: 1.0)<br>&gt;&gt;     // do some animations using these options<br>&gt;&gt; }<br>&gt;&gt;  <br>&gt;&gt; But today, the value returned by AnimationContext(speed:bounciness:) gets deinitted immediately.<br>&gt;&gt;  <br>&gt;&gt; I&#39;ve come to desire using such a pattern after living with this for a while:<br>&gt;&gt;  <br>&gt;&gt; AnimationContext(speed: 1.0, bounciness: 1.0) {<br>&gt;&gt;     // do some animations using these options<br>&gt;&gt; }<br>&gt;&gt;  <br>&gt;&gt; But I don&#39;t like it because it contributes heavily to rightward drift (a user of this API might want to change the options multiple times), and gets hard to parse when nested in the many other language constructs that create a scope using brackets.<br></p><p>Not sure how contrived your code example is but in the given example wouldn’t just chaining off of AnimationContext solve rightward drift?<br></p><p>AnimationContext(speed: 1, bounciness: 1) {<br>  ...<br>}.changeSpeed(to: 2) {<br>  ...<br>}<br></p><p><br>&gt;&gt;  <br>&gt;&gt; So — would it be reasonable to suggest that we have some keyword(s) preceeding an initializer that allows a value to stay alive and/or not warn if it winds up going unused? The current behavior in Swift has obviously been considered, so please feel free to tell me if this is a Very Bad Idea. I&#39;m still learning!<br>&gt;&gt;  <br>&gt;&gt; - Ollie<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/780cca48/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
