<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Discussion] Modernizing Attribute Case and Attribute Argument Naming</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February 17, 2016 at 11:00:00am</p></header><div class="content"><p>For your consideration: Attribute Ophidiophobia. Feedback and suggestions welcome. -- Erica<br></p><p>Modernizing Attribute Case and Attribute Argument Naming<br></p><p>Proposal: TBD<br>Author(s): Erica Sadun &lt;http://github.com/erica&gt;<br>Status: TBD<br>Review manager: TBD<br></p><p> &lt;https://gist.github.com/erica/29c1a7fb7f49324d572f#introduction&gt;Introduction<br></p><p>Two isolated instances of snake case remain in the Swift attribute grammar. This proposal updates those elements to bring them into compliance with modern Swift language standards. <br></p><p>The Swift-Evolution discussion of this topic took place in the &quot;[Discussion] Modernizing Attribute Case and Attribute Argument Naming&quot; thread. Hat tip to Michael Wells<br></p><p><br> &lt;https://gist.github.com/erica/29c1a7fb7f49324d572f#motivation-and-detail-design&gt;Motivation and Detail Design<br></p><p>Parts of the Swift attribute grammar retain lower snake case patterns that no longer match modern conventions:<br></p><p>The warn_unused_result attribute should use lowercase and be renamed warnunusedresult. The lower case pattern matches other compound attribute examples: autoclosure, objc, noescape, nonobjc, and noreturn.<br>The mutable_variant attribute argument should use lower camel case as is standard for native Swift argument labels and be renamed to mutableVariant.<br>Some non-native Swift attributes use a distinct pattern that does not apply to this proposal, specificallyUIApplicationMain, NSManaged, NSCopying, NSApplicationMain and do not fall under the scope of the native Swift lowercase convention.<br></p><p><br> &lt;https://gist.github.com/erica/29c1a7fb7f49324d572f#alternatives-considered&gt;Alternatives Considered<br></p><p>There are no alternatives for this proposal.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160217/9947edd6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Discussion] Modernizing Attribute Case and Attribute Argument Naming</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>February 17, 2016 at 10:00:00am</p></header><div class="content"><p>On Wed, Feb 17, 2016 at 10:18 AM, Erica Sadun via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; For your consideration: Attribute Ophidiophobia. Feedback and suggestions<br>&gt; welcome. -- Erica<br>&gt;<br>&gt; Modernizing Attribute Case and Attribute Argument Naming<br>&gt;<br>&gt; Proposal: TBD<br>&gt; Author(s): Erica Sadun<br>&gt; Status: TBD<br>&gt; Review manager: TBD<br>&gt;<br>&gt; Introduction<br>&gt;<br>&gt; Two isolated instances of snake case remain in the Swift attribute grammar.<br>&gt; This proposal updates those elements to bring them into compliance with<br>&gt; modern Swift language standards.<br>&gt;<br>&gt; The Swift-Evolution discussion of this topic took place in the &quot;[Discussion]<br>&gt; Modernizing Attribute Case and Attribute Argument Naming&quot; thread. Hat tip to<br>&gt; Michael Wells<br>&gt;<br>&gt; Motivation and Detail Design<br>&gt;<br>&gt; Parts of the Swift attribute grammar retain lower snake case patterns that<br>&gt; no longer match modern conventions:<br>&gt;<br>&gt; The warn_unused_result attribute should use lowercase and be renamed<br>&gt; warnunusedresult.<br></p><p>Hi Erica,<br></p><p>Maybe it is just me, but I find @warnunusedresult to be unreadable --<br>it looks like a continuous string of lowercase characters at a glance.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Discussion] Modernizing Attribute Case and Attribute Argument Naming</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February 17, 2016 at 11:00:00am</p></header><div class="content"><p>Do you have an alternative suggestion? I can add the following to the Alternatives Considered:<br></p><p>Using lowercase for attributes names becomes confusing with longer compound examples. For example `warnunusedresult`<br>looks a lot like a continuous string of lowercase characters. I recommend the Swift team consider introducing upper camel case<br>for attributes to match the Cocoa members (UIApplicationMain, NSManaged, NSCopying, NSApplicationMain, IBAction, IBDesignable, IBInspectable, IBOutlet) or lower<br>camel case to avoid this issue:<br></p><p>@AutoClosure, @Available, @ObjC, @NoEscape, @NonObjC, @NoReturn, @Testable, @WarnUnusedResult, @Convention, @NoReturn<br></p><p>or<br></p><p>@autoClosure, @available, @objC, @noEscape, @nonObjC, @noReturn, @testable, @warnUnusedResult, @convention, @noReturn<br></p><p>-- E<br></p><p><br>&gt; On Feb 17, 2016, at 11:36 AM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Wed, Feb 17, 2016 at 10:18 AM, Erica Sadun via swift-evolution<br>&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; For your consideration: Attribute Ophidiophobia. Feedback and suggestions<br>&gt;&gt; welcome. -- Erica<br>&gt;&gt; <br>&gt;&gt; Modernizing Attribute Case and Attribute Argument Naming<br>&gt;&gt; <br>&gt;&gt; Proposal: TBD<br>&gt;&gt; Author(s): Erica Sadun<br>&gt;&gt; Status: TBD<br>&gt;&gt; Review manager: TBD<br>&gt;&gt; <br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; Two isolated instances of snake case remain in the Swift attribute grammar.<br>&gt;&gt; This proposal updates those elements to bring them into compliance with<br>&gt;&gt; modern Swift language standards.<br>&gt;&gt; <br>&gt;&gt; The Swift-Evolution discussion of this topic took place in the &quot;[Discussion]<br>&gt;&gt; Modernizing Attribute Case and Attribute Argument Naming&quot; thread. Hat tip to<br>&gt;&gt; Michael Wells<br>&gt;&gt; <br>&gt;&gt; Motivation and Detail Design<br>&gt;&gt; <br>&gt;&gt; Parts of the Swift attribute grammar retain lower snake case patterns that<br>&gt;&gt; no longer match modern conventions:<br>&gt;&gt; <br>&gt;&gt; The warn_unused_result attribute should use lowercase and be renamed<br>&gt;&gt; warnunusedresult.<br>&gt; <br>&gt; Hi Erica,<br>&gt; <br>&gt; Maybe it is just me, but I find @warnunusedresult to be unreadable --<br>&gt; it looks like a continuous string of lowercase characters at a glance.<br>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt;*/<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160217/071c25fd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c40db4457ab2c91a0d8006da31b177c6?s=50"></div><header><strong>[Discussion] Modernizing Attribute Case and Attribute Argument Naming</strong> from <string>Trent Nadeau</string> &lt;tanadeau at gmail.com&gt;<p>February 17, 2016 at 01:00:00pm</p></header><div class="content"><p>I think both of the camel-case conventions are much easier to read, and<br>both are fine with me. I slightly prefer the former (UpperCamelCase), but<br>that just might be because the only languages I&#39;ve used with annotations<br>that also have camel-case conventions (Java and C#) both use UpperCamelCase.<br></p><p>On Wed, Feb 17, 2016 at 1:43 PM, Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Do you have an alternative suggestion? I can add the following to the<br>&gt; Alternatives Considered:<br>&gt;<br>&gt; Using lowercase for attributes names becomes confusing with longer<br>&gt; compound examples. For example `warnunusedresult`<br>&gt; looks a lot like a continuous string of lowercase characters. I recommend<br>&gt; the Swift team consider introducing upper camel case<br>&gt; for attributes to match the Cocoa members (UIApplicationMain, NSManaged,<br>&gt; NSCopying, NSApplicationMain, IBAction, IBDesignable, IBInspectable,<br>&gt; IBOutlet) or lower<br>&gt; camel case to avoid this issue:<br>&gt;<br>&gt; @AutoClosure, @Available, @ObjC, @NoEscape, @NonObjC, @NoReturn,<br>&gt; @Testable, @WarnUnusedResult, @Convention, @NoReturn<br>&gt;<br>&gt; or<br>&gt;<br>&gt; @autoClosure, @available, @objC, @noEscape, @nonObjC, @noReturn,<br>&gt; @testable, @warnUnusedResult, @convention, @noReturn<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt;<br>&gt; On Feb 17, 2016, at 11:36 AM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Wed, Feb 17, 2016 at 10:18 AM, Erica Sadun via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; For your consideration: Attribute Ophidiophobia. Feedback and suggestions<br>&gt; welcome. -- Erica<br>&gt;<br>&gt; Modernizing Attribute Case and Attribute Argument Naming<br>&gt;<br>&gt; Proposal: TBD<br>&gt; Author(s): Erica Sadun<br>&gt; Status: TBD<br>&gt; Review manager: TBD<br>&gt;<br>&gt; Introduction<br>&gt;<br>&gt; Two isolated instances of snake case remain in the Swift attribute grammar.<br>&gt; This proposal updates those elements to bring them into compliance with<br>&gt; modern Swift language standards.<br>&gt;<br>&gt; The Swift-Evolution discussion of this topic took place in the<br>&gt; &quot;[Discussion]<br>&gt; Modernizing Attribute Case and Attribute Argument Naming&quot; thread. Hat tip<br>&gt; to<br>&gt; Michael Wells<br>&gt;<br>&gt; Motivation and Detail Design<br>&gt;<br>&gt; Parts of the Swift attribute grammar retain lower snake case patterns that<br>&gt; no longer match modern conventions:<br>&gt;<br>&gt; The warn_unused_result attribute should use lowercase and be renamed<br>&gt; warnunusedresult.<br>&gt;<br>&gt;<br>&gt; Hi Erica,<br>&gt;<br>&gt; Maybe it is just me, but I find @warnunusedresult to be unreadable --<br>&gt; it looks like a continuous string of lowercase characters at a glance.<br>&gt;<br>&gt; Dmitri<br>&gt;<br>&gt; --<br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p><p><br>-- <br>Trent Nadeau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160217/99474b6a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Discussion] Modernizing Attribute Case and Attribute Argument Naming</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February 17, 2016 at 11:00:00am</p></header><div class="content"><p>I think you guys have convinced me.<br></p><p>Re-jiggering.<br></p><p>-- E, who will be back with an updated version in a few minutes<br></p><p>&gt; On Feb 17, 2016, at 11:47 AM, Trent Nadeau &lt;tanadeau at gmail.com&gt; wrote:<br>&gt; <br>&gt; I think both of the camel-case conventions are much easier to read, and both are fine with me. I slightly prefer the former (UpperCamelCase), but that just might be because the only languages I&#39;ve used with annotations that also have camel-case conventions (Java and C#) both use UpperCamelCase.<br>&gt; <br>&gt; On Wed, Feb 17, 2016 at 1:43 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Do you have an alternative suggestion? I can add the following to the Alternatives Considered:<br>&gt; <br>&gt; Using lowercase for attributes names becomes confusing with longer compound examples. For example `warnunusedresult`<br>&gt; looks a lot like a continuous string of lowercase characters. I recommend the Swift team consider introducing upper camel case<br>&gt; for attributes to match the Cocoa members (UIApplicationMain, NSManaged, NSCopying, NSApplicationMain, IBAction, IBDesignable, IBInspectable, IBOutlet) or lower<br>&gt; camel case to avoid this issue:<br>&gt; <br>&gt; @AutoClosure, @Available, @ObjC, @NoEscape, @NonObjC, @NoReturn, @Testable, @WarnUnusedResult, @Convention, @NoReturn<br>&gt; <br>&gt; or<br>&gt; <br>&gt; @autoClosure, @available, @objC, @noEscape, @nonObjC, @noReturn, @testable, @warnUnusedResult, @convention, @noReturn<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 17, 2016, at 11:36 AM, Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Wed, Feb 17, 2016 at 10:18 AM, Erica Sadun via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; For your consideration: Attribute Ophidiophobia. Feedback and suggestions<br>&gt;&gt;&gt; welcome. -- Erica<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Modernizing Attribute Case and Attribute Argument Naming<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposal: TBD<br>&gt;&gt;&gt; Author(s): Erica Sadun<br>&gt;&gt;&gt; Status: TBD<br>&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Two isolated instances of snake case remain in the Swift attribute grammar.<br>&gt;&gt;&gt; This proposal updates those elements to bring them into compliance with<br>&gt;&gt;&gt; modern Swift language standards.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The Swift-Evolution discussion of this topic took place in the &quot;[Discussion]<br>&gt;&gt;&gt; Modernizing Attribute Case and Attribute Argument Naming&quot; thread. Hat tip to<br>&gt;&gt;&gt; Michael Wells<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Motivation and Detail Design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Parts of the Swift attribute grammar retain lower snake case patterns that<br>&gt;&gt;&gt; no longer match modern conventions:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The warn_unused_result attribute should use lowercase and be renamed<br>&gt;&gt;&gt; warnunusedresult.<br>&gt;&gt; <br>&gt;&gt; Hi Erica,<br>&gt;&gt; <br>&gt;&gt; Maybe it is just me, but I find @warnunusedresult to be unreadable --<br>&gt;&gt; it looks like a continuous string of lowercase characters at a glance.<br>&gt;&gt; <br>&gt;&gt; Dmitri<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt;*/<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Trent Nadeau<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160217/70b3cf01/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>[Discussion] Modernizing Attribute Case and Attribute Argument Naming</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>February 17, 2016 at 06:00:00pm</p></header><div class="content"><p>&quot;@AutoClosure, @Available, @ObjC, @NoEscape, @NonObjC, @NoReturn,<br>@Testable, @WarnUnusedResult, @Convention, @NoReturn&quot;<br></p><p>The above are much more readable to me and I believe most other humans :)<br></p><p>I favor the UpperCamelCase style over the lowerCamelCase style for these.<br></p><p>-Shawn<br></p><p>On Wed, Feb 17, 2016 at 10:43 AM Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Do you have an alternative suggestion? I can add the following to the<br>&gt; Alternatives Considered:<br>&gt;<br>&gt; Using lowercase for attributes names becomes confusing with longer<br>&gt; compound examples. For example `warnunusedresult`<br>&gt; looks a lot like a continuous string of lowercase characters. I recommend<br>&gt; the Swift team consider introducing upper camel case<br>&gt; for attributes to match the Cocoa members (UIApplicationMain, NSManaged,<br>&gt; NSCopying, NSApplicationMain, IBAction, IBDesignable, IBInspectable,<br>&gt; IBOutlet) or lower<br>&gt; camel case to avoid this issue:<br>&gt;<br>&gt; @AutoClosure, @Available, @ObjC, @NoEscape, @NonObjC, @NoReturn,<br>&gt; @Testable, @WarnUnusedResult, @Convention, @NoReturn<br>&gt;<br>&gt; or<br>&gt;<br>&gt; @autoClosure, @available, @objC, @noEscape, @nonObjC, @noReturn,<br>&gt; @testable, @warnUnusedResult, @convention, @noReturn<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt;<br>&gt; On Feb 17, 2016, at 11:36 AM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Wed, Feb 17, 2016 at 10:18 AM, Erica Sadun via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; For your consideration: Attribute Ophidiophobia. Feedback and suggestions<br>&gt; welcome. -- Erica<br>&gt;<br>&gt; Modernizing Attribute Case and Attribute Argument Naming<br>&gt;<br>&gt; Proposal: TBD<br>&gt; Author(s): Erica Sadun<br>&gt; Status: TBD<br>&gt; Review manager: TBD<br>&gt;<br>&gt; Introduction<br>&gt;<br>&gt; Two isolated instances of snake case remain in the Swift attribute grammar.<br>&gt; This proposal updates those elements to bring them into compliance with<br>&gt; modern Swift language standards.<br>&gt;<br>&gt; The Swift-Evolution discussion of this topic took place in the<br>&gt; &quot;[Discussion]<br>&gt; Modernizing Attribute Case and Attribute Argument Naming&quot; thread. Hat tip<br>&gt; to<br>&gt; Michael Wells<br>&gt;<br>&gt; Motivation and Detail Design<br>&gt;<br>&gt; Parts of the Swift attribute grammar retain lower snake case patterns that<br>&gt; no longer match modern conventions:<br>&gt;<br>&gt; The warn_unused_result attribute should use lowercase and be renamed<br>&gt; warnunusedresult.<br>&gt;<br>&gt;<br>&gt; Hi Erica,<br>&gt;<br>&gt; Maybe it is just me, but I find @warnunusedresult to be unreadable --<br>&gt; it looks like a continuous string of lowercase characters at a glance.<br>&gt;<br>&gt; Dmitri<br>&gt;<br>&gt; --<br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160217/99ad9ecc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Discussion] Modernizing Attribute Case and Attribute Argument Naming</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February 17, 2016 at 12:00:00pm</p></header><div class="content"><p>Updated: https://gist.github.com/erica/29c1a7fb7f49324d572f &lt;https://gist.github.com/erica/29c1a7fb7f49324d572f&gt;<br></p><p>Modernizing Attribute Case and Attribute Argument Naming<br></p><p>Proposal: TBD<br>Author(s): Erica Sadun &lt;http://github.com/erica&gt;<br>Status: TBD<br>Review manager: TBD<br> &lt;https://gist.github.com/erica/29c1a7fb7f49324d572f#introduction&gt;Introduction<br></p><p>Two isolated instances of snake case &lt;https://en.wikipedia.org/wiki/Snake_case&gt; remain in the Swift attribute grammar. This proposal updates those elements to bring them into compliance with modern Swift language standards and applies a new case pattern to existing attributes.<br></p><p>The Swift-Evolution discussion of this topic took place in the &quot;[Discussion] Modernizing Attribute Case and Attribute Argument Naming&quot; thread. Hat tip to Michael Wells and Dmitri Gribenko<br></p><p> &lt;https://gist.github.com/erica/29c1a7fb7f49324d572f#motivation-and-detail-design&gt;Motivation and Detail Design<br></p><p>Parts of the Swift attribute grammar retain lower snake case patterns that no longer match modern conventions, specifically the warn_unused_result attribute and the mutable_variant argument. <br></p><p>Updating the argument is easy. The mutable_variant attribute argument should use lower camel case as is standard for native Swift argument labels and be renamed mutableVariant. <br></p><p>If the warn_unused_result attribute is adjusted to the current lowercase convention, its renamed version becomes warnunusedresult. While this lower case pattern matches other compound attribute examples: objc, noescape, nonobjc, and noreturn, the re-engineered version of warnunusedresult looks like a continuous string of lowercase characters instead of punching clear, identifiable semantic elements. Using lowercase for complex attributes names, including future names yet to be introduced into the language becomes confusing when used with longer compound examples.<br></p><p>For this reason, I recommend the Swift team adopt an upper camel case convention for attributes to match the Cocoa members (UIApplicationMain, NSManaged, NSCopying, NSApplicationMain, IBAction, IBDesignable, IBInspectable, IBOutlet). This approach avoids the otherwise confusing long name issue and affects existing attributes as follows:<br></p><p>@Autoclosure // was @autoclosure<br>@Available // was @available<br>@ObjC // was @objc<br>@NoEscape // was @noescape<br>@NonObjC // was @nonobjc<br>@NoReturn // was @noreturn<br>@Testable // was @testable<br>@WarnUnusedResult // was @warn-unused-result<br>@Convention  // was @convention<br>@NoReturn // was @noreturn<br>In the revised design, the following example for Swift 2.2<br></p><p>@warn_unused_result(mutable_variant=&quot;sortInPlace&quot;)<br>public func sort() -&gt; [Self.Generator.Element]<br>becomes<br></p><p>@WarnUnusedResult(mutableVariant: &quot;sortInPlace&quot;)<br>public func sort() -&gt; [Self.Generator.Element]<br>This revised example uses an argument colon (as proposed in &quot;Replacing Equal Signs with Colons For Attribute Arguments&quot;) rather than the equal sign currently specified in Swift 2.2<br></p><p> &lt;https://gist.github.com/erica/29c1a7fb7f49324d572f#alternatives-considered&gt;Alternatives Considered<br></p><p>The team might prefer using lower camel case @autoClosure, @available, @objC, @noEscape, @nonObjC, @noReturn, @testable, @warnUnusedResult, @convention, @noReturn but this would be out of step with non-native Swift attributes, specifically UIApplicationMain, NSManaged, NSCopying, NSApplicationMain, IBAction, IBDesignable, IBInspectable, and IBOutlet<br></p><p>&gt; On Feb 17, 2016, at 11:50 AM, Shawn Erickson &lt;shawnce at gmail.com&gt; wrote:<br>&gt; <br>&gt; &quot;@AutoClosure, @Available, @ObjC, @NoEscape, @NonObjC, @NoReturn, @Testable, @WarnUnusedResult, @Convention, @NoReturn&quot;<br>&gt; <br>&gt; The above are much more readable to me and I believe most other humans :)<br>&gt; <br>&gt; I favor the UpperCamelCase style over the lowerCamelCase style for these.<br>&gt; <br>&gt; -Shawn<br>&gt; <br>&gt; On Wed, Feb 17, 2016 at 10:43 AM Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Do you have an alternative suggestion? I can add the following to the Alternatives Considered:<br>&gt; <br>&gt; Using lowercase for attributes names becomes confusing with longer compound examples. For example `warnunusedresult`<br>&gt; looks a lot like a continuous string of lowercase characters. I recommend the Swift team consider introducing upper camel case<br>&gt; for attributes to match the Cocoa members (UIApplicationMain, NSManaged, NSCopying, NSApplicationMain, IBAction, IBDesignable, IBInspectable, IBOutlet) or lower<br>&gt; camel case to avoid this issue:<br>&gt; <br>&gt; @AutoClosure, @Available, @ObjC, @NoEscape, @NonObjC, @NoReturn, @Testable, @WarnUnusedResult, @Convention, @NoReturn<br>&gt; <br>&gt; or<br>&gt; <br>&gt; @autoClosure, @available, @objC, @noEscape, @nonObjC, @noReturn, @testable, @warnUnusedResult, @convention, @noReturn<br>&gt; <br>&gt; -- E<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160217/a2e2a6f9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Discussion] Modernizing Attribute Case and Attribute Argument Naming</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 17, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; @Autoclosure // was @autoclosure<br>&gt; @Available // was @available<br>&gt; @ObjC // was @objc<br>&gt; @NoEscape // was @noescape<br>&gt; @NonObjC // was @nonobjc<br>&gt; @NoReturn // was @noreturn<br>&gt; @Testable // was @testable<br>&gt; @WarnUnusedResult // was @warn-unused-result<br>&gt; @Convention  // was @convention<br>&gt; @NoReturn // was @noreturn<br>&gt; <br>&gt; In the revised design, the following example for Swift 2.2<br>&gt; <br>&gt; @warn_unused_result(mutable_variant=&quot;sortInPlace&quot;)<br>&gt; public func sort() -&gt; [Self.Generator.Element]<br>&gt; <br>&gt; becomes<br>&gt; <br>&gt; @WarnUnusedResult(mutableVariant: &quot;sortInPlace&quot;)<br>&gt; public func sort() -&gt; [Self.Generator.Element]<br></p><p>Wow, I&#39;m surprised by how much I hate this. Currently, all Swift keywords are entirely lowercase (ignoring things like `Type`, `Protocol`, and `dynamicType` which come after a dot). I think I&#39;ve learned to half-ignore things that look like that, but capitalizing suddenly pulls the spotlight onto these keywords. I&#39;m just not a fan.<br></p><p>I think we&#39;re better off renaming or redesigning `warn_unused_result` so that it&#39;s readable when it&#39;s all-lowercase with no underscores. Some ideas:<br></p><p>	@onlyreturns func sorted() -&gt; [Self.Generator.Element]<br>	func sorted() -&gt; @important [Self.Generator.Element]<br></p><p>Alternatively, we could reverse the semantic and make all all non-Void functions warn unless they have an attribute saying not to.<br></p><p>	@ignoreresult mutating func updateValue(value: Value, forKey key: Key) -&gt; Value?<br>	mutating func updateValue(value: Value, forKey key: Key) -&gt; @ignorable Value?<br>	mutating func updateValue(value: Value, forKey key: Key) -&gt; @convenience Value?<br></p><p>If we do that, we&#39;ll likely still want to be able to annotate non-mutating methods with their mutating variants (well, unless we think the compiler can guess based on the API Guidelines.)<br></p><p>	@variant(mutating: &quot;sort&quot;) func sorted() -&gt; [Self.Generator.Element]<br>	@alternative(mutating: &quot;sort&quot;) func sorted() -&gt; [Self.Generator.Element]<br></p><p>That opens the possibility of using `@variant(nonmutating:)` on mutating functions, too.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Discussion] Modernizing Attribute Case and Attribute Argument Naming</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February 17, 2016 at 10:00:00pm</p></header><div class="content"><p>How would you re-design the existing upper camel attributes then?<br></p><p>They are: @UIApplicationMain, @NSManaged, @NSCopying, @NSApplicationMain, @IBAction, @IBDesignable, @IBInspectable, and @IBOutlet<br></p><p>-- E<br></p><p><br>&gt; On Feb 17, 2016, at 10:29 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; @Autoclosure // was @autoclosure<br>&gt;&gt; @Available // was @available<br>&gt;&gt; @ObjC // was @objc<br>&gt;&gt; @NoEscape // was @noescape<br>&gt;&gt; @NonObjC // was @nonobjc<br>&gt;&gt; @NoReturn // was @noreturn<br>&gt;&gt; @Testable // was @testable<br>&gt;&gt; @WarnUnusedResult // was @warn-unused-result<br>&gt;&gt; @Convention  // was @convention<br>&gt;&gt; @NoReturn // was @noreturn<br>&gt;&gt; <br>&gt;&gt; In the revised design, the following example for Swift 2.2<br>&gt;&gt; <br>&gt;&gt; @warn_unused_result(mutable_variant=&quot;sortInPlace&quot;)<br>&gt;&gt; public func sort() -&gt; [Self.Generator.Element]<br>&gt;&gt; <br>&gt;&gt; becomes<br>&gt;&gt; <br>&gt;&gt; @WarnUnusedResult(mutableVariant: &quot;sortInPlace&quot;)<br>&gt;&gt; public func sort() -&gt; [Self.Generator.Element]<br>&gt; <br>&gt; Wow, I&#39;m surprised by how much I hate this. Currently, all Swift keywords are entirely lowercase (ignoring things like `Type`, `Protocol`, and `dynamicType` which come after a dot). I think I&#39;ve learned to half-ignore things that look like that, but capitalizing suddenly pulls the spotlight onto these keywords. I&#39;m just not a fan.<br>&gt; <br>&gt; I think we&#39;re better off renaming or redesigning `warn_unused_result` so that it&#39;s readable when it&#39;s all-lowercase with no underscores. Some ideas:<br>&gt; <br>&gt; 	@onlyreturns func sorted() -&gt; [Self.Generator.Element]<br>&gt; 	func sorted() -&gt; @important [Self.Generator.Element]<br>&gt; <br>&gt; Alternatively, we could reverse the semantic and make all all non-Void functions warn unless they have an attribute saying not to.<br>&gt; <br>&gt; 	@ignoreresult mutating func updateValue(value: Value, forKey key: Key) -&gt; Value?<br>&gt; 	mutating func updateValue(value: Value, forKey key: Key) -&gt; @ignorable Value?<br>&gt; 	mutating func updateValue(value: Value, forKey key: Key) -&gt; @convenience Value?<br>&gt; <br>&gt; If we do that, we&#39;ll likely still want to be able to annotate non-mutating methods with their mutating variants (well, unless we think the compiler can guess based on the API Guidelines.)<br>&gt; <br>&gt; 	@variant(mutating: &quot;sort&quot;) func sorted() -&gt; [Self.Generator.Element]<br>&gt; 	@alternative(mutating: &quot;sort&quot;) func sorted() -&gt; [Self.Generator.Element]<br>&gt; <br>&gt; That opens the possibility of using `@variant(nonmutating:)` on mutating functions, too.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6c95cd06f79f91eaf9f58e4f1c50a25a?s=50"></div><header><strong>[Discussion] Modernizing Attribute Case and Attribute Argument Naming</strong> from <string>Ondrej Barina</string> &lt;obarina at gmail.com&gt;<p>February 18, 2016 at 08:00:00am</p></header><div class="content"><p>+1 for first upper letter.<br>O.<br>On Feb 18, 2016 6:43 AM, &quot;Erica Sadun via swift-evolution&quot; &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; How would you re-design the existing upper camel attributes then?<br>&gt;<br>&gt; They are: @UIApplicationMain, @NSManaged, @NSCopying, @NSApplicationMain,<br>&gt; @IBAction, @IBDesignable, @IBInspectable, and @IBOutlet<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt;<br>&gt; &gt; On Feb 17, 2016, at 10:29 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; @Autoclosure // was @autoclosure<br>&gt; &gt;&gt; @Available // was @available<br>&gt; &gt;&gt; @ObjC // was @objc<br>&gt; &gt;&gt; @NoEscape // was @noescape<br>&gt; &gt;&gt; @NonObjC // was @nonobjc<br>&gt; &gt;&gt; @NoReturn // was @noreturn<br>&gt; &gt;&gt; @Testable // was @testable<br>&gt; &gt;&gt; @WarnUnusedResult // was @warn-unused-result<br>&gt; &gt;&gt; @Convention  // was @convention<br>&gt; &gt;&gt; @NoReturn // was @noreturn<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; In the revised design, the following example for Swift 2.2<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; @warn_unused_result(mutable_variant=&quot;sortInPlace&quot;)<br>&gt; &gt;&gt; public func sort() -&gt; [Self.Generator.Element]<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; becomes<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; @WarnUnusedResult(mutableVariant: &quot;sortInPlace&quot;)<br>&gt; &gt;&gt; public func sort() -&gt; [Self.Generator.Element]<br>&gt; &gt;<br>&gt; &gt; Wow, I&#39;m surprised by how much I hate this. Currently, all Swift<br>&gt; keywords are entirely lowercase (ignoring things like `Type`, `Protocol`,<br>&gt; and `dynamicType` which come after a dot). I think I&#39;ve learned to<br>&gt; half-ignore things that look like that, but capitalizing suddenly pulls the<br>&gt; spotlight onto these keywords. I&#39;m just not a fan.<br>&gt; &gt;<br>&gt; &gt; I think we&#39;re better off renaming or redesigning `warn_unused_result` so<br>&gt; that it&#39;s readable when it&#39;s all-lowercase with no underscores. Some ideas:<br>&gt; &gt;<br>&gt; &gt;       @onlyreturns func sorted() -&gt; [Self.Generator.Element]<br>&gt; &gt;       func sorted() -&gt; @important [Self.Generator.Element]<br>&gt; &gt;<br>&gt; &gt; Alternatively, we could reverse the semantic and make all all non-Void<br>&gt; functions warn unless they have an attribute saying not to.<br>&gt; &gt;<br>&gt; &gt;       @ignoreresult mutating func updateValue(value: Value, forKey key:<br>&gt; Key) -&gt; Value?<br>&gt; &gt;       mutating func updateValue(value: Value, forKey key: Key) -&gt;<br>&gt; @ignorable Value?<br>&gt; &gt;       mutating func updateValue(value: Value, forKey key: Key) -&gt;<br>&gt; @convenience Value?<br>&gt; &gt;<br>&gt; &gt; If we do that, we&#39;ll likely still want to be able to annotate<br>&gt; non-mutating methods with their mutating variants (well, unless we think<br>&gt; the compiler can guess based on the API Guidelines.)<br>&gt; &gt;<br>&gt; &gt;       @variant(mutating: &quot;sort&quot;) func sorted() -&gt;<br>&gt; [Self.Generator.Element]<br>&gt; &gt;       @alternative(mutating: &quot;sort&quot;) func sorted() -&gt;<br>&gt; [Self.Generator.Element]<br>&gt; &gt;<br>&gt; &gt; That opens the possibility of using `@variant(nonmutating:)` on mutating<br>&gt; functions, too.<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Brent Royal-Gordon<br>&gt; &gt; Architechies<br>&gt; &gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160218/6e2eda43/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>[Discussion] Modernizing Attribute Case and Attribute Argument Naming</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>February 17, 2016 at 11:00:00pm</p></header><div class="content"><p>Arguably, these are all framework/IDE-specific functionality, a.k.a.<br>&quot;custom attributes&quot;, which should have an entirely different syntax.<br></p><p>On Wed, Feb 17, 2016 at 9:43 PM, Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; How would you re-design the existing upper camel attributes then?<br>&gt;<br>&gt; They are: @UIApplicationMain, @NSManaged, @NSCopying, @NSApplicationMain,<br>&gt; @IBAction, @IBDesignable, @IBInspectable, and @IBOutlet<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt;<br>&gt; &gt; On Feb 17, 2016, at 10:29 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; @Autoclosure // was @autoclosure<br>&gt; &gt;&gt; @Available // was @available<br>&gt; &gt;&gt; @ObjC // was @objc<br>&gt; &gt;&gt; @NoEscape // was @noescape<br>&gt; &gt;&gt; @NonObjC // was @nonobjc<br>&gt; &gt;&gt; @NoReturn // was @noreturn<br>&gt; &gt;&gt; @Testable // was @testable<br>&gt; &gt;&gt; @WarnUnusedResult // was @warn-unused-result<br>&gt; &gt;&gt; @Convention  // was @convention<br>&gt; &gt;&gt; @NoReturn // was @noreturn<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; In the revised design, the following example for Swift 2.2<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; @warn_unused_result(mutable_variant=&quot;sortInPlace&quot;)<br>&gt; &gt;&gt; public func sort() -&gt; [Self.Generator.Element]<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; becomes<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; @WarnUnusedResult(mutableVariant: &quot;sortInPlace&quot;)<br>&gt; &gt;&gt; public func sort() -&gt; [Self.Generator.Element]<br>&gt; &gt;<br>&gt; &gt; Wow, I&#39;m surprised by how much I hate this. Currently, all Swift<br>&gt; keywords are entirely lowercase (ignoring things like `Type`, `Protocol`,<br>&gt; and `dynamicType` which come after a dot). I think I&#39;ve learned to<br>&gt; half-ignore things that look like that, but capitalizing suddenly pulls the<br>&gt; spotlight onto these keywords. I&#39;m just not a fan.<br>&gt; &gt;<br>&gt; &gt; I think we&#39;re better off renaming or redesigning `warn_unused_result` so<br>&gt; that it&#39;s readable when it&#39;s all-lowercase with no underscores. Some ideas:<br>&gt; &gt;<br>&gt; &gt;       @onlyreturns func sorted() -&gt; [Self.Generator.Element]<br>&gt; &gt;       func sorted() -&gt; @important [Self.Generator.Element]<br>&gt; &gt;<br>&gt; &gt; Alternatively, we could reverse the semantic and make all all non-Void<br>&gt; functions warn unless they have an attribute saying not to.<br>&gt; &gt;<br>&gt; &gt;       @ignoreresult mutating func updateValue(value: Value, forKey key:<br>&gt; Key) -&gt; Value?<br>&gt; &gt;       mutating func updateValue(value: Value, forKey key: Key) -&gt;<br>&gt; @ignorable Value?<br>&gt; &gt;       mutating func updateValue(value: Value, forKey key: Key) -&gt;<br>&gt; @convenience Value?<br>&gt; &gt;<br>&gt; &gt; If we do that, we&#39;ll likely still want to be able to annotate<br>&gt; non-mutating methods with their mutating variants (well, unless we think<br>&gt; the compiler can guess based on the API Guidelines.)<br>&gt; &gt;<br>&gt; &gt;       @variant(mutating: &quot;sort&quot;) func sorted() -&gt;<br>&gt; [Self.Generator.Element]<br>&gt; &gt;       @alternative(mutating: &quot;sort&quot;) func sorted() -&gt;<br>&gt; [Self.Generator.Element]<br>&gt; &gt;<br>&gt; &gt; That opens the possibility of using `@variant(nonmutating:)` on mutating<br>&gt; functions, too.<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Brent Royal-Gordon<br>&gt; &gt; Architechies<br>&gt; &gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160217/4f6e4732/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8b9f0c10986385f3c7f50615d6176be3?s=50"></div><header><strong>[Discussion] Modernizing Attribute Case and Attribute Argument Naming</strong> from <string>Pierre Monod-Broca</string> &lt;pierre at monod-broca.fr&gt;<p>February 23, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; Le 18 févr. 2016 à 08:29, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Arguably, these are all framework/IDE-specific functionality, a.k.a. &quot;custom attributes&quot;, which should have an entirely different syntax.<br></p><p>+1<br></p><p><br>&gt; <br>&gt; On Wed, Feb 17, 2016 at 9:43 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; How would you re-design the existing upper camel attributes then?<br>&gt; <br>&gt; They are: @UIApplicationMain, @NSManaged, @NSCopying, @NSApplicationMain, @IBAction, @IBDesignable, @IBInspectable, and @IBOutlet<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt; &gt; On Feb 17, 2016, at 10:29 PM, Brent Royal-Gordon &lt;brent at architechies.com &lt;mailto:brent at architechies.com&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; @Autoclosure // was @autoclosure<br>&gt; &gt;&gt; @Available // was @available<br>&gt; &gt;&gt; @ObjC // was @objc<br>&gt; &gt;&gt; @NoEscape // was @noescape<br>&gt; &gt;&gt; @NonObjC // was @nonobjc<br>&gt; &gt;&gt; @NoReturn // was @noreturn<br>&gt; &gt;&gt; @Testable // was @testable<br>&gt; &gt;&gt; @WarnUnusedResult // was @warn-unused-result<br>&gt; &gt;&gt; @Convention  // was @convention<br>&gt; &gt;&gt; @NoReturn // was @noreturn<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; In the revised design, the following example for Swift 2.2<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; @warn_unused_result(mutable_variant=&quot;sortInPlace&quot;)<br>&gt; &gt;&gt; public func sort() -&gt; [Self.Generator.Element]<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; becomes<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; @WarnUnusedResult(mutableVariant: &quot;sortInPlace&quot;)<br>&gt; &gt;&gt; public func sort() -&gt; [Self.Generator.Element]<br>&gt; &gt;<br>&gt; &gt; Wow, I&#39;m surprised by how much I hate this. Currently, all Swift keywords are entirely lowercase (ignoring things like `Type`, `Protocol`, and `dynamicType` which come after a dot). I think I&#39;ve learned to half-ignore things that look like that, but capitalizing suddenly pulls the spotlight onto these keywords. I&#39;m just not a fan.<br>&gt; &gt;<br>&gt; &gt; I think we&#39;re better off renaming or redesigning `warn_unused_result` so that it&#39;s readable when it&#39;s all-lowercase with no underscores. Some ideas:<br>&gt; &gt;<br>&gt; &gt;       @onlyreturns func sorted() -&gt; [Self.Generator.Element]<br>&gt; &gt;       func sorted() -&gt; @important [Self.Generator.Element]<br>&gt; &gt;<br>&gt; &gt; Alternatively, we could reverse the semantic and make all all non-Void functions warn unless they have an attribute saying not to.<br>&gt; &gt;<br>&gt; &gt;       @ignoreresult mutating func updateValue(value: Value, forKey key: Key) -&gt; Value?<br>&gt; &gt;       mutating func updateValue(value: Value, forKey key: Key) -&gt; @ignorable Value?<br>&gt; &gt;       mutating func updateValue(value: Value, forKey key: Key) -&gt; @convenience Value?<br>&gt; &gt;<br>&gt; &gt; If we do that, we&#39;ll likely still want to be able to annotate non-mutating methods with their mutating variants (well, unless we think the compiler can guess based on the API Guidelines.)<br>&gt; &gt;<br>&gt; &gt;       @variant(mutating: &quot;sort&quot;) func sorted() -&gt; [Self.Generator.Element]<br>&gt; &gt;       @alternative(mutating: &quot;sort&quot;) func sorted() -&gt; [Self.Generator.Element]<br>&gt; &gt;<br>&gt; &gt; That opens the possibility of using `@variant(nonmutating:)` on mutating functions, too.<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Brent Royal-Gordon<br>&gt; &gt; Architechies<br>&gt; &gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160223/e03fea87/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6a925eec074f3a4a853412a55bbc543e?s=50"></div><header><strong>[Discussion] Modernizing Attribute Case and Attribute Argument Naming</strong> from <string>Joshua Kopin</string> &lt;jkopin at apple.com&gt;<p>February 24, 2016 at 04:00:00pm</p></header><div class="content"><p>+1<br></p><p>Jacob, I think your proposal is on point. Although I know this is <br>probably outside the scope of what Erica would like to propose, I think <br>it&#39;s important to point out that the custom attributes you called out <br>arguably are so different semantically from the other attributes that <br>they deserve their own syntactic treatment. Since the following analysis <br>might affect the naming discussion, I&#39;ll put this out there now and see <br>how it lands.<br></p><p>It seems to me that there are two broad categories of attributes, each <br>of which wants its own level of syntactic optimization:<br></p><p>- General Swift Attributes - use should be optimized<br>    - Semantic Modifiers<br>       - **@autoclosure** / **@autoclosure(escaping)** - modifies <br>expression semantics at call site<br>       - **@convention(**...**)** - modifies declared function&#39;s calling <br>convention<br>       - **@testable** - modifies declaration&#39;s visibility<br>       - **@noescape** - modifies closure capture semantics, closure <br>declaration syntax, escape analysis<br>       - **@noreturn** - modifies control flow analysis<br>       - **@objc** / **@objc(**...**)** / **@nonobjc** - modifies <br>calling convention, class synthesis<br>       - **@NSCopying** - modifies property storage and semantics<br>   - Warning and Error Generation Modifiers<br>       - **@available(**&lt;expression in the availability DSL&gt;**)**<br>       - **@warn_unused_result**<br>       - **@warn_unused_result(message=**...**)**<br>       - **@warn_unused_result(mutable_variant=**...**)**<br></p><p>- Specific Attributes - use should not be optimized<br>    - Semantic Modifiers<br>       - **@UIApplicationMain** / **@NSApplicationMain** - specific to <br>UIKit/AppKit<br>       - **@NSManaged** - specific to CoreData<br>    - Xcode Semantic Modifiers<br>       - **@IBAction**<br>       - **@IBDesignable**<br>       - **@IBInspectable**<br>       - **@IBOutlet**<br></p><p>(To be fair, @objc, @nonobjc, and @NSCopying are all tied to the <br>Objective-C runtime and/or Foundation pretty closely and could arguably <br>be considered framework-specific.)<br></p><p>As a first stab, how about something along the lines of the following?<br></p><p>- General Swift Attributes<br>    - Semantic Modifiers<br>       - **@autoclosure** / **@autoclosure(escaping)**<br>       - **@convention(**...**)**<br>       - **@testable**<br>       - **@noescape**<br>       - **@noreturn**<br>       - **@objc** / **@objc(**...**)** / **@nonbjc**<br>       - **@copy**<br>   - Warning and Error Generation Modifiers<br>       - **@available(**&lt;expression in the availability DSL&gt;**)**<br>       - **@warning(**&lt;expression in a new warning DSL&gt;**)**<br>          - **@warning(unusedResult)**<br>          - **@warning(unusedResult, message=**...**)**<br>          - **@warning(unusedResult, mutableVariant=**...**)**<br></p><p>- Specific Attributes (syntax subject to bikeshedding)<br>    - **@modifyingCustomSemanticAttribute(**&lt;expression in semantic <br>attribute modifier DSL&gt;**)**<br>	   - **@modifyingCustomSemanticAttribute(Cocoa, applicationMain)**<br>	   - **@modifyingCustomSemanticAttribute(CoreData, managed)**<br>	   - **@modifyingCustomSemanticAttribute(InterfaceBuilder, action)**<br>	   - **@modifyingCustomSemanticAttribute(InterfaceBuilder, <br>designable)**<br>	   - **@modifyingCustomSemanticAttribute(InterfaceBuilder, <br>inspectable)**<br>	   - **@modifyingCustomSemanticAttribute(InterfaceBuilder, outlet)**<br></p><p><br>On 17 Feb 2016, at 23:29, Jacob Bandes-Storch via swift-evolution wrote:<br></p><p>&gt; Arguably, these are all framework/IDE-specific functionality, a.k.a.<br>&gt; &quot;custom attributes&quot;, which should have an entirely different syntax.<br>&gt;<br>&gt; On Wed, Feb 17, 2016 at 9:43 PM, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; How would you re-design the existing upper camel attributes then?<br>&gt;&gt;<br>&gt;&gt; They are: @UIApplicationMain, @NSManaged, @NSCopying, <br>&gt;&gt; @NSApplicationMain,<br>&gt;&gt; @IBAction, @IBDesignable, @IBInspectable, and @IBOutlet<br>&gt;&gt;<br>&gt;&gt; -- E<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; On Feb 17, 2016, at 10:29 PM, Brent Royal-Gordon <br>&gt;&gt;&gt; &lt;brent at architechies.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; @Autoclosure // was @autoclosure<br>&gt;&gt;&gt;&gt; @Available // was @available<br>&gt;&gt;&gt;&gt; @ObjC // was @objc<br>&gt;&gt;&gt;&gt; @NoEscape // was @noescape<br>&gt;&gt;&gt;&gt; @NonObjC // was @nonobjc<br>&gt;&gt;&gt;&gt; @NoReturn // was @noreturn<br>&gt;&gt;&gt;&gt; @Testable // was @testable<br>&gt;&gt;&gt;&gt; @WarnUnusedResult // was @warn-unused-result<br>&gt;&gt;&gt;&gt; @Convention  // was @convention<br>&gt;&gt;&gt;&gt; @NoReturn // was @noreturn<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; In the revised design, the following example for Swift 2.2<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; @warn_unused_result(mutable_variant=&quot;sortInPlace&quot;)<br>&gt;&gt;&gt;&gt; public func sort() -&gt; [Self.Generator.Element]<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; becomes<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; @WarnUnusedResult(mutableVariant: &quot;sortInPlace&quot;)<br>&gt;&gt;&gt;&gt; public func sort() -&gt; [Self.Generator.Element]<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Wow, I&#39;m surprised by how much I hate this. Currently, all Swift<br>&gt;&gt; keywords are entirely lowercase (ignoring things like `Type`, <br>&gt;&gt; `Protocol`,<br>&gt;&gt; and `dynamicType` which come after a dot). I think I&#39;ve learned to<br>&gt;&gt; half-ignore things that look like that, but capitalizing suddenly <br>&gt;&gt; pulls the<br>&gt;&gt; spotlight onto these keywords. I&#39;m just not a fan.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I think we&#39;re better off renaming or redesigning <br>&gt;&gt;&gt; `warn_unused_result` so<br>&gt;&gt; that it&#39;s readable when it&#39;s all-lowercase with no underscores. Some <br>&gt;&gt; ideas:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;       @onlyreturns func sorted() -&gt; [Self.Generator.Element]<br>&gt;&gt;&gt;       func sorted() -&gt; @important [Self.Generator.Element]<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Alternatively, we could reverse the semantic and make all all <br>&gt;&gt;&gt; non-Void<br>&gt;&gt; functions warn unless they have an attribute saying not to.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;       @ignoreresult mutating func updateValue(value: Value, forKey <br>&gt;&gt;&gt; key:<br>&gt;&gt; Key) -&gt; Value?<br>&gt;&gt;&gt;       mutating func updateValue(value: Value, forKey key: Key) -&gt;<br>&gt;&gt; @ignorable Value?<br>&gt;&gt;&gt;       mutating func updateValue(value: Value, forKey key: Key) -&gt;<br>&gt;&gt; @convenience Value?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If we do that, we&#39;ll likely still want to be able to annotate<br>&gt;&gt; non-mutating methods with their mutating variants (well, unless we <br>&gt;&gt; think<br>&gt;&gt; the compiler can guess based on the API Guidelines.)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;       @variant(mutating: &quot;sort&quot;) func sorted() -&gt;<br>&gt;&gt; [Self.Generator.Element]<br>&gt;&gt;&gt;       @alternative(mutating: &quot;sort&quot;) func sorted() -&gt;<br>&gt;&gt; [Self.Generator.Element]<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; That opens the possibility of using `@variant(nonmutating:)` on <br>&gt;&gt;&gt; mutating<br>&gt;&gt; functions, too.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160224/41e017c8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Discussion] Modernizing Attribute Case and Attribute Argument Naming</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February 24, 2016 at 05:00:00pm</p></header><div class="content"><p>Joshua,<br></p><p>Could you please peek at the latest version here: https://gist.github.com/erica/29c1a7fb7f49324d572f  Also, the [Further Discussion] Naming Attributes thread has subsumed this one.<br></p><p>Thanks, -- Erica<br></p><p><br>&gt; On Feb 24, 2016, at 5:26 PM, Joshua Kopin via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1<br>&gt; <br>&gt; Jacob, I think your proposal is on point. Although I know this is probably outside the scope of what Erica would like to propose, I think it&#39;s important to point out that the custom attributes you called out arguably are so different semantically from the other attributes that they deserve their own syntactic treatment. Since the following analysis might affect the naming discussion, I&#39;ll put this out there now and see how it lands.<br>&gt; <br>&gt; It seems to me that there are two broad categories of attributes, each of which wants its own level of syntactic optimization:<br>&gt; <br>&gt; General Swift Attributes - use should be optimized<br>&gt; <br>&gt; Semantic Modifiers<br>&gt; @autoclosure / @autoclosure(escaping) - modifies expression semantics at call site<br>&gt; @convention(...) - modifies declared function&#39;s calling convention<br>&gt; @testable - modifies declaration&#39;s visibility<br>&gt; @noescape - modifies closure capture semantics, closure declaration syntax, escape analysis<br>&gt; @noreturn - modifies control flow analysis<br>&gt; @objc / @objc(...) / @nonobjc - modifies calling convention, class synthesis<br>&gt; @NSCopying - modifies property storage and semantics<br>&gt; Warning and Error Generation Modifiers<br>&gt; @available(&lt;expression in the availability DSL&gt;)<br>&gt; @warn_unused_result<br>&gt; @warn_unused_result(message=...)<br>&gt; @warn_unused_result(mutable_variant=...)<br>&gt; Specific Attributes - use should not be optimized<br>&gt; <br>&gt; Semantic Modifiers<br>&gt; @UIApplicationMain / @NSApplicationMain - specific to UIKit/AppKit<br>&gt; @NSManaged - specific to CoreData<br>&gt; Xcode Semantic Modifiers<br>&gt; @IBAction<br>&gt; @IBDesignable<br>&gt; @IBInspectable<br>&gt; @IBOutlet<br>&gt; (To be fair, @objc, @nonobjc, and @NSCopying are all tied to the Objective-C runtime and/or Foundation pretty closely and could arguably be considered framework-specific.)<br>&gt; <br>&gt; As a first stab, how about something along the lines of the following?<br>&gt; <br>&gt; General Swift Attributes<br>&gt; <br>&gt; Semantic Modifiers<br>&gt; @autoclosure / @autoclosure(escaping)<br>&gt; @convention(...)<br>&gt; @testable<br>&gt; @noescape<br>&gt; @noreturn<br>&gt; @objc / @objc(...) / @nonbjc<br>&gt; @copy<br>&gt; Warning and Error Generation Modifiers<br>&gt; @available(&lt;expression in the availability DSL&gt;)<br>&gt; @warning(&lt;expression in a new warning DSL&gt;)<br>&gt; @warning(unusedResult)<br>&gt; @warning(unusedResult, message=...)<br>&gt; @warning(unusedResult, mutableVariant=...)<br>&gt; Specific Attributes (syntax subject to bikeshedding)<br>&gt; <br>&gt; @modifyingCustomSemanticAttribute(&lt;expression in semantic attribute modifier DSL&gt;)<br>&gt; @modifyingCustomSemanticAttribute(Cocoa, applicationMain)<br>&gt; @modifyingCustomSemanticAttribute(CoreData, managed)<br>&gt; @modifyingCustomSemanticAttribute(InterfaceBuilder, action)<br>&gt; @modifyingCustomSemanticAttribute(InterfaceBuilder, designable)<br>&gt; @modifyingCustomSemanticAttribute(InterfaceBuilder, inspectable)<br>&gt; @modifyingCustomSemanticAttribute(InterfaceBuilder, outlet)<br>&gt; On 17 Feb 2016, at 23:29, Jacob Bandes-Storch via swift-evolution wrote:<br>&gt; <br>&gt; Arguably, these are all framework/IDE-specific functionality, a.k.a.<br>&gt; &quot;custom attributes&quot;, which should have an entirely different syntax.<br>&gt; <br>&gt; On Wed, Feb 17, 2016 at 9:43 PM, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; How would you re-design the existing upper camel attributes then?<br>&gt; <br>&gt; They are: @UIApplicationMain, @NSManaged, @NSCopying, @NSApplicationMain,<br>&gt; @IBAction, @IBDesignable, @IBInspectable, and @IBOutlet<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; On Feb 17, 2016, at 10:29 PM, Brent Royal-Gordon brent at architechies.com &lt;mailto:brent at architechies.com&gt;<br>&gt; wrote:<br>&gt; <br>&gt; @Autoclosure // was @autoclosure<br>&gt; @Available // was @available<br>&gt; @ObjC // was @objc<br>&gt; @NoEscape // was @noescape<br>&gt; @NonObjC // was @nonobjc<br>&gt; @NoReturn // was @noreturn<br>&gt; @Testable // was @testable<br>&gt; @WarnUnusedResult // was @warn-unused-result<br>&gt; @Convention // was @convention<br>&gt; @NoReturn // was @noreturn<br>&gt; <br>&gt; In the revised design, the following example for Swift 2.2<br>&gt; <br>&gt; @warn_unused_result(mutable_variant=&quot;sortInPlace&quot;)<br>&gt; public func sort() -&gt; [Self.Generator.Element]<br>&gt; <br>&gt; becomes<br>&gt; <br>&gt; @WarnUnusedResult(mutableVariant: &quot;sortInPlace&quot;)<br>&gt; public func sort() -&gt; [Self.Generator.Element]<br>&gt; <br>&gt; Wow, I&#39;m surprised by how much I hate this. Currently, all Swift<br>&gt; <br>&gt; keywords are entirely lowercase (ignoring things like Type, Protocol,<br>&gt; and dynamicType which come after a dot). I think I&#39;ve learned to<br>&gt; half-ignore things that look like that, but capitalizing suddenly pulls the<br>&gt; spotlight onto these keywords. I&#39;m just not a fan.<br>&gt; <br>&gt; I think we&#39;re better off renaming or redesigning warn_unused_result so<br>&gt; <br>&gt; that it&#39;s readable when it&#39;s all-lowercase with no underscores. Some ideas:<br>&gt; <br>&gt;   @onlyreturns func sorted() -&gt; [Self.Generator.Element]<br>&gt;   func sorted() -&gt; @important [Self.Generator.Element]<br>&gt; Alternatively, we could reverse the semantic and make all all non-Void<br>&gt; <br>&gt; functions warn unless they have an attribute saying not to.<br>&gt; <br>&gt;   @ignoreresult mutating func updateValue(value: Value, forKey key:<br>&gt; Key) -&gt; Value?<br>&gt; <br>&gt;   mutating func updateValue(value: Value, forKey key: Key) -&gt;<br>&gt; @ignorable Value?<br>&gt; <br>&gt;   mutating func updateValue(value: Value, forKey key: Key) -&gt;<br>&gt; @convenience Value?<br>&gt; <br>&gt; If we do that, we&#39;ll likely still want to be able to annotate<br>&gt; <br>&gt; non-mutating methods with their mutating variants (well, unless we think<br>&gt; the compiler can guess based on the API Guidelines.)<br>&gt; <br>&gt;   @variant(mutating: &quot;sort&quot;) func sorted() -&gt;<br>&gt; [Self.Generator.Element]<br>&gt; <br>&gt;   @alternative(mutating: &quot;sort&quot;) func sorted() -&gt;<br>&gt; [Self.Generator.Element]<br>&gt; <br>&gt; That opens the possibility of using @variant(nonmutating:) on mutating<br>&gt; <br>&gt; functions, too.<br>&gt; <br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;_______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160224/4304392f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Discussion] Modernizing Attribute Case and Attribute Argument Naming</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>March  1, 2016 at 08:00:00pm</p></header><div class="content"><p>Hi Erica,<br></p><p>I’m sorry I’m late to the discussion (and I admit that I haven’t had time to follow it closely), but I have some concerns with your proposal in PR183.<br></p><p>Specifically, I think that working around a presumed attribute syntax for behaviors isn’t something worth worrying about at this point.  Behaviors could go that way, or could go with a more behavior-specific syntax on the declaration site.<br></p><p>That said, user-defined attributes *are* something to anticipate.  Here is a pile of assumptions which may or may not hold to be true, but I think are likely:  I’d suspect that user defined attributes will be upper case (which fits better given that at least some of them will have to be explicitly module qualified).  If we do this, we will rebrand the existing UIFoo and NSFoo ones as though they are user defined attributes, reverse justifying their uppercaseness.  With this approach, the upper case namespace is for user defined stuff and the lower case namespace is for system stuff.<br></p><p>That style of approach would allow us to keep @autoclosure, @objc, @noreturn, @UIApplicationMain etc, while allowing users to define other new declaration attributes in the upper case namespace.<br></p><p>I agree that that leaves us with @warnunusedresult as an awkward suspect, but it is rarely used, and “when” we fix it to invert its polarity, it will hopefully be completely replaced.<br></p><p>-Chris<br></p><p>&gt; On Feb 24, 2016, at 4:39 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Joshua,<br>&gt; <br>&gt; Could you please peek at the latest version here: https://gist.github.com/erica/29c1a7fb7f49324d572f &lt;https://gist.github.com/erica/29c1a7fb7f49324d572f&gt;  Also, the [Further Discussion] Naming Attributes thread has subsumed this one.<br>&gt; <br>&gt; Thanks, -- Erica<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 24, 2016, at 5:26 PM, Joshua Kopin via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; +1<br>&gt;&gt; <br>&gt;&gt; Jacob, I think your proposal is on point. Although I know this is probably outside the scope of what Erica would like to propose, I think it&#39;s important to point out that the custom attributes you called out arguably are so different semantically from the other attributes that they deserve their own syntactic treatment. Since the following analysis might affect the naming discussion, I&#39;ll put this out there now and see how it lands.<br>&gt;&gt; <br>&gt;&gt; It seems to me that there are two broad categories of attributes, each of which wants its own level of syntactic optimization:<br>&gt;&gt; <br>&gt;&gt; General Swift Attributes - use should be optimized<br>&gt;&gt; <br>&gt;&gt; Semantic Modifiers<br>&gt;&gt; @autoclosure / @autoclosure(escaping) - modifies expression semantics at call site<br>&gt;&gt; @convention(...) - modifies declared function&#39;s calling convention<br>&gt;&gt; @testable - modifies declaration&#39;s visibility<br>&gt;&gt; @noescape - modifies closure capture semantics, closure declaration syntax, escape analysis<br>&gt;&gt; @noreturn - modifies control flow analysis<br>&gt;&gt; @objc / @objc(...) / @nonobjc - modifies calling convention, class synthesis<br>&gt;&gt; @NSCopying - modifies property storage and semantics<br>&gt;&gt; Warning and Error Generation Modifiers<br>&gt;&gt; @available(&lt;expression in the availability DSL&gt;)<br>&gt;&gt; @warn_unused_result<br>&gt;&gt; @warn_unused_result(message=...)<br>&gt;&gt; @warn_unused_result(mutable_variant=...)<br>&gt;&gt; Specific Attributes - use should not be optimized<br>&gt;&gt; <br>&gt;&gt; Semantic Modifiers<br>&gt;&gt; @UIApplicationMain / @NSApplicationMain - specific to UIKit/AppKit<br>&gt;&gt; @NSManaged - specific to CoreData<br>&gt;&gt; Xcode Semantic Modifiers<br>&gt;&gt; @IBAction<br>&gt;&gt; @IBDesignable<br>&gt;&gt; @IBInspectable<br>&gt;&gt; @IBOutlet<br>&gt;&gt; (To be fair, @objc, @nonobjc, and @NSCopying are all tied to the Objective-C runtime and/or Foundation pretty closely and could arguably be considered framework-specific.)<br>&gt;&gt; <br>&gt;&gt; As a first stab, how about something along the lines of the following?<br>&gt;&gt; <br>&gt;&gt; General Swift Attributes<br>&gt;&gt; <br>&gt;&gt; Semantic Modifiers<br>&gt;&gt; @autoclosure / @autoclosure(escaping)<br>&gt;&gt; @convention(...)<br>&gt;&gt; @testable<br>&gt;&gt; @noescape<br>&gt;&gt; @noreturn<br>&gt;&gt; @objc / @objc(...) / @nonbjc<br>&gt;&gt; @copy<br>&gt;&gt; Warning and Error Generation Modifiers<br>&gt;&gt; @available(&lt;expression in the availability DSL&gt;)<br>&gt;&gt; @warning(&lt;expression in a new warning DSL&gt;)<br>&gt;&gt; @warning(unusedResult)<br>&gt;&gt; @warning(unusedResult, message=...)<br>&gt;&gt; @warning(unusedResult, mutableVariant=...)<br>&gt;&gt; Specific Attributes (syntax subject to bikeshedding)<br>&gt;&gt; <br>&gt;&gt; @modifyingCustomSemanticAttribute(&lt;expression in semantic attribute modifier DSL&gt;)<br>&gt;&gt; @modifyingCustomSemanticAttribute(Cocoa, applicationMain)<br>&gt;&gt; @modifyingCustomSemanticAttribute(CoreData, managed)<br>&gt;&gt; @modifyingCustomSemanticAttribute(InterfaceBuilder, action)<br>&gt;&gt; @modifyingCustomSemanticAttribute(InterfaceBuilder, designable)<br>&gt;&gt; @modifyingCustomSemanticAttribute(InterfaceBuilder, inspectable)<br>&gt;&gt; @modifyingCustomSemanticAttribute(InterfaceBuilder, outlet)<br>&gt;&gt; On 17 Feb 2016, at 23:29, Jacob Bandes-Storch via swift-evolution wrote:<br>&gt;&gt; <br>&gt;&gt; Arguably, these are all framework/IDE-specific functionality, a.k.a.<br>&gt;&gt; &quot;custom attributes&quot;, which should have an entirely different syntax.<br>&gt;&gt; <br>&gt;&gt; On Wed, Feb 17, 2016 at 9:43 PM, Erica Sadun via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; How would you re-design the existing upper camel attributes then?<br>&gt;&gt; <br>&gt;&gt; They are: @UIApplicationMain, @NSManaged, @NSCopying, @NSApplicationMain,<br>&gt;&gt; @IBAction, @IBDesignable, @IBInspectable, and @IBOutlet<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt; On Feb 17, 2016, at 10:29 PM, Brent Royal-Gordon brent at architechies.com &lt;mailto:brent at architechies.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; @Autoclosure // was @autoclosure<br>&gt;&gt; @Available // was @available<br>&gt;&gt; @ObjC // was @objc<br>&gt;&gt; @NoEscape // was @noescape<br>&gt;&gt; @NonObjC // was @nonobjc<br>&gt;&gt; @NoReturn // was @noreturn<br>&gt;&gt; @Testable // was @testable<br>&gt;&gt; @WarnUnusedResult // was @warn-unused-result<br>&gt;&gt; @Convention // was @convention<br>&gt;&gt; @NoReturn // was @noreturn<br>&gt;&gt; <br>&gt;&gt; In the revised design, the following example for Swift 2.2<br>&gt;&gt; <br>&gt;&gt; @warn_unused_result(mutable_variant=&quot;sortInPlace&quot;)<br>&gt;&gt; public func sort() -&gt; [Self.Generator.Element]<br>&gt;&gt; <br>&gt;&gt; becomes<br>&gt;&gt; <br>&gt;&gt; @WarnUnusedResult(mutableVariant: &quot;sortInPlace&quot;)<br>&gt;&gt; public func sort() -&gt; [Self.Generator.Element]<br>&gt;&gt; <br>&gt;&gt; Wow, I&#39;m surprised by how much I hate this. Currently, all Swift<br>&gt;&gt; <br>&gt;&gt; keywords are entirely lowercase (ignoring things like Type, Protocol,<br>&gt;&gt; and dynamicType which come after a dot). I think I&#39;ve learned to<br>&gt;&gt; half-ignore things that look like that, but capitalizing suddenly pulls the<br>&gt;&gt; spotlight onto these keywords. I&#39;m just not a fan.<br>&gt;&gt; <br>&gt;&gt; I think we&#39;re better off renaming or redesigning warn_unused_result so<br>&gt;&gt; <br>&gt;&gt; that it&#39;s readable when it&#39;s all-lowercase with no underscores. Some ideas:<br>&gt;&gt; <br>&gt;&gt;   @onlyreturns func sorted() -&gt; [Self.Generator.Element]<br>&gt;&gt;   func sorted() -&gt; @important [Self.Generator.Element]<br>&gt;&gt; Alternatively, we could reverse the semantic and make all all non-Void<br>&gt;&gt; <br>&gt;&gt; functions warn unless they have an attribute saying not to.<br>&gt;&gt; <br>&gt;&gt;   @ignoreresult mutating func updateValue(value: Value, forKey key:<br>&gt;&gt; Key) -&gt; Value?<br>&gt;&gt; <br>&gt;&gt;   mutating func updateValue(value: Value, forKey key: Key) -&gt;<br>&gt;&gt; @ignorable Value?<br>&gt;&gt; <br>&gt;&gt;   mutating func updateValue(value: Value, forKey key: Key) -&gt;<br>&gt;&gt; @convenience Value?<br>&gt;&gt; <br>&gt;&gt; If we do that, we&#39;ll likely still want to be able to annotate<br>&gt;&gt; <br>&gt;&gt; non-mutating methods with their mutating variants (well, unless we think<br>&gt;&gt; the compiler can guess based on the API Guidelines.)<br>&gt;&gt; <br>&gt;&gt;   @variant(mutating: &quot;sort&quot;) func sorted() -&gt;<br>&gt;&gt; [Self.Generator.Element]<br>&gt;&gt; <br>&gt;&gt;   @alternative(mutating: &quot;sort&quot;) func sorted() -&gt;<br>&gt;&gt; [Self.Generator.Element]<br>&gt;&gt; <br>&gt;&gt; That opens the possibility of using @variant(nonmutating:) on mutating<br>&gt;&gt; <br>&gt;&gt; functions, too.<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;_______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160301/40370b43/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Discussion] Modernizing Attribute Case and Attribute Argument Naming</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March  1, 2016 at 10:00:00pm</p></header><div class="content"><p>Here are the choices:<br></p><p>* I can leave it as is.<br>* I can revise to recommend all lowercase with the understanding that this proposal will have a very short life effect but it will close some annoying gaps for the time being and will rename the argument label<br>* You can close the PR and we can let this go.<br></p><p>Some notes:<br></p><p>* I&#39;d like warnunusedresult to have a short life in any case.<br>* supresswarnunused better represents where I would like the language to be<br>* better even that that is an attribute that indicates a return type of -&gt; T can be treated as Void without warning<br></p><p>func foo() -&gt; @discretionary T {}<br></p><p>(or some reasonable synonym thereof, such as elective or voluntary)<br></p><p>Pick and I&#39;ll adjust.<br></p><p>-- E<br></p><p><br></p><p>&gt; On Mar 1, 2016, at 9:04 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; Hi Erica,<br>&gt; <br>&gt; I’m sorry I’m late to the discussion (and I admit that I haven’t had time to follow it closely), but I have some concerns with your proposal in PR183.<br>&gt; <br>&gt; Specifically, I think that working around a presumed attribute syntax for behaviors isn’t something worth worrying about at this point.  Behaviors could go that way, or could go with a more behavior-specific syntax on the declaration site.<br>&gt; <br>&gt; That said, user-defined attributes *are* something to anticipate.  Here is a pile of assumptions which may or may not hold to be true, but I think are likely:  I’d suspect that user defined attributes will be upper case (which fits better given that at least some of them will have to be explicitly module qualified).  If we do this, we will rebrand the existing UIFoo and NSFoo ones as though they are user defined attributes, reverse justifying their uppercaseness.  With this approach, the upper case namespace is for user defined stuff and the lower case namespace is for system stuff.<br>&gt; <br>&gt; That style of approach would allow us to keep @autoclosure, @objc, @noreturn, @UIApplicationMain etc, while allowing users to define other new declaration attributes in the upper case namespace.<br>&gt; <br>&gt; I agree that that leaves us with @warnunusedresult as an awkward suspect, but it is rarely used, and “when” we fix it to invert its polarity, it will hopefully be completely replaced.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt;&gt; On Feb 24, 2016, at 4:39 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Joshua,<br>&gt;&gt; <br>&gt;&gt; Could you please peek at the latest version here: https://gist.github.com/erica/29c1a7fb7f49324d572f &lt;https://gist.github.com/erica/29c1a7fb7f49324d572f&gt;  Also, the [Further Discussion] Naming Attributes thread has subsumed this one.<br>&gt;&gt; <br>&gt;&gt; Thanks, -- Erica<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 24, 2016, at 5:26 PM, Joshua Kopin via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +1<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jacob, I think your proposal is on point. Although I know this is probably outside the scope of what Erica would like to propose, I think it&#39;s important to point out that the custom attributes you called out arguably are so different semantically from the other attributes that they deserve their own syntactic treatment. Since the following analysis might affect the naming discussion, I&#39;ll put this out there now and see how it lands.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It seems to me that there are two broad categories of attributes, each of which wants its own level of syntactic optimization:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; General Swift Attributes - use should be optimized<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Semantic Modifiers<br>&gt;&gt;&gt; @autoclosure / @autoclosure(escaping) - modifies expression semantics at call site<br>&gt;&gt;&gt; @convention(...) - modifies declared function&#39;s calling convention<br>&gt;&gt;&gt; @testable - modifies declaration&#39;s visibility<br>&gt;&gt;&gt; @noescape - modifies closure capture semantics, closure declaration syntax, escape analysis<br>&gt;&gt;&gt; @noreturn - modifies control flow analysis<br>&gt;&gt;&gt; @objc / @objc(...) / @nonobjc - modifies calling convention, class synthesis<br>&gt;&gt;&gt; @NSCopying - modifies property storage and semantics<br>&gt;&gt;&gt; Warning and Error Generation Modifiers<br>&gt;&gt;&gt; @available(&lt;expression in the availability DSL&gt;)<br>&gt;&gt;&gt; @warn_unused_result<br>&gt;&gt;&gt; @warn_unused_result(message=...)<br>&gt;&gt;&gt; @warn_unused_result(mutable_variant=...)<br>&gt;&gt;&gt; Specific Attributes - use should not be optimized<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Semantic Modifiers<br>&gt;&gt;&gt; @UIApplicationMain / @NSApplicationMain - specific to UIKit/AppKit<br>&gt;&gt;&gt; @NSManaged - specific to CoreData<br>&gt;&gt;&gt; Xcode Semantic Modifiers<br>&gt;&gt;&gt; @IBAction<br>&gt;&gt;&gt; @IBDesignable<br>&gt;&gt;&gt; @IBInspectable<br>&gt;&gt;&gt; @IBOutlet<br>&gt;&gt;&gt; (To be fair, @objc, @nonobjc, and @NSCopying are all tied to the Objective-C runtime and/or Foundation pretty closely and could arguably be considered framework-specific.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As a first stab, how about something along the lines of the following?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; General Swift Attributes<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Semantic Modifiers<br>&gt;&gt;&gt; @autoclosure / @autoclosure(escaping)<br>&gt;&gt;&gt; @convention(...)<br>&gt;&gt;&gt; @testable<br>&gt;&gt;&gt; @noescape<br>&gt;&gt;&gt; @noreturn<br>&gt;&gt;&gt; @objc / @objc(...) / @nonbjc<br>&gt;&gt;&gt; @copy<br>&gt;&gt;&gt; Warning and Error Generation Modifiers<br>&gt;&gt;&gt; @available(&lt;expression in the availability DSL&gt;)<br>&gt;&gt;&gt; @warning(&lt;expression in a new warning DSL&gt;)<br>&gt;&gt;&gt; @warning(unusedResult)<br>&gt;&gt;&gt; @warning(unusedResult, message=...)<br>&gt;&gt;&gt; @warning(unusedResult, mutableVariant=...)<br>&gt;&gt;&gt; Specific Attributes (syntax subject to bikeshedding)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; @modifyingCustomSemanticAttribute(&lt;expression in semantic attribute modifier DSL&gt;)<br>&gt;&gt;&gt; @modifyingCustomSemanticAttribute(Cocoa, applicationMain)<br>&gt;&gt;&gt; @modifyingCustomSemanticAttribute(CoreData, managed)<br>&gt;&gt;&gt; @modifyingCustomSemanticAttribute(InterfaceBuilder, action)<br>&gt;&gt;&gt; @modifyingCustomSemanticAttribute(InterfaceBuilder, designable)<br>&gt;&gt;&gt; @modifyingCustomSemanticAttribute(InterfaceBuilder, inspectable)<br>&gt;&gt;&gt; @modifyingCustomSemanticAttribute(InterfaceBuilder, outlet)<br>&gt;&gt;&gt; On 17 Feb 2016, at 23:29, Jacob Bandes-Storch via swift-evolution wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Arguably, these are all framework/IDE-specific functionality, a.k.a.<br>&gt;&gt;&gt; &quot;custom attributes&quot;, which should have an entirely different syntax.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Wed, Feb 17, 2016 at 9:43 PM, Erica Sadun via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; How would you re-design the existing upper camel attributes then?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; They are: @UIApplicationMain, @NSManaged, @NSCopying, @NSApplicationMain,<br>&gt;&gt;&gt; @IBAction, @IBDesignable, @IBInspectable, and @IBOutlet<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- E<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Feb 17, 2016, at 10:29 PM, Brent Royal-Gordon brent at architechies.com &lt;mailto:brent at architechies.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; @Autoclosure // was @autoclosure<br>&gt;&gt;&gt; @Available // was @available<br>&gt;&gt;&gt; @ObjC // was @objc<br>&gt;&gt;&gt; @NoEscape // was @noescape<br>&gt;&gt;&gt; @NonObjC // was @nonobjc<br>&gt;&gt;&gt; @NoReturn // was @noreturn<br>&gt;&gt;&gt; @Testable // was @testable<br>&gt;&gt;&gt; @WarnUnusedResult // was @warn-unused-result<br>&gt;&gt;&gt; @Convention // was @convention<br>&gt;&gt;&gt; @NoReturn // was @noreturn<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In the revised design, the following example for Swift 2.2<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; @warn_unused_result(mutable_variant=&quot;sortInPlace&quot;)<br>&gt;&gt;&gt; public func sort() -&gt; [Self.Generator.Element]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; becomes<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; @WarnUnusedResult(mutableVariant: &quot;sortInPlace&quot;)<br>&gt;&gt;&gt; public func sort() -&gt; [Self.Generator.Element]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Wow, I&#39;m surprised by how much I hate this. Currently, all Swift<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; keywords are entirely lowercase (ignoring things like Type, Protocol,<br>&gt;&gt;&gt; and dynamicType which come after a dot). I think I&#39;ve learned to<br>&gt;&gt;&gt; half-ignore things that look like that, but capitalizing suddenly pulls the<br>&gt;&gt;&gt; spotlight onto these keywords. I&#39;m just not a fan.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think we&#39;re better off renaming or redesigning warn_unused_result so<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; that it&#39;s readable when it&#39;s all-lowercase with no underscores. Some ideas:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   @onlyreturns func sorted() -&gt; [Self.Generator.Element]<br>&gt;&gt;&gt;   func sorted() -&gt; @important [Self.Generator.Element]<br>&gt;&gt;&gt; Alternatively, we could reverse the semantic and make all all non-Void<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; functions warn unless they have an attribute saying not to.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   @ignoreresult mutating func updateValue(value: Value, forKey key:<br>&gt;&gt;&gt; Key) -&gt; Value?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   mutating func updateValue(value: Value, forKey key: Key) -&gt;<br>&gt;&gt;&gt; @ignorable Value?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   mutating func updateValue(value: Value, forKey key: Key) -&gt;<br>&gt;&gt;&gt; @convenience Value?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If we do that, we&#39;ll likely still want to be able to annotate<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; non-mutating methods with their mutating variants (well, unless we think<br>&gt;&gt;&gt; the compiler can guess based on the API Guidelines.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   @variant(mutating: &quot;sort&quot;) func sorted() -&gt;<br>&gt;&gt;&gt; [Self.Generator.Element]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   @alternative(mutating: &quot;sort&quot;) func sorted() -&gt;<br>&gt;&gt;&gt; [Self.Generator.Element]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That opens the possibility of using @variant(nonmutating:) on mutating<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; functions, too.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;_______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160301/a04a28c9/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/47e3aeeaf151d4f51ee15fc7871bf584?s=50"></div><header><strong>[Discussion] Modernizing Attribute Case and Attribute Argument Naming</strong> from <string>Rudolf Adamkovič</string> &lt;salutis at me.com&gt;<p>February 23, 2016 at 12:00:00am</p></header><div class="content"><p>+1 for UpperCamelAttributes<br></p><p>R+<br></p><p>Sent from my iPhone<br></p><p>&gt; On 18 Feb 2016, at 06:43, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; How would you re-design the existing upper camel attributes then?<br>&gt; <br>&gt; They are: @UIApplicationMain, @NSManaged, @NSCopying, @NSApplicationMain, @IBAction, @IBDesignable, @IBInspectable, and @IBOutlet<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Feb 17, 2016, at 10:29 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; @Autoclosure // was @autoclosure<br>&gt;&gt;&gt; @Available // was @available<br>&gt;&gt;&gt; @ObjC // was @objc<br>&gt;&gt;&gt; @NoEscape // was @noescape<br>&gt;&gt;&gt; @NonObjC // was @nonobjc<br>&gt;&gt;&gt; @NoReturn // was @noreturn<br>&gt;&gt;&gt; @Testable // was @testable<br>&gt;&gt;&gt; @WarnUnusedResult // was @warn-unused-result<br>&gt;&gt;&gt; @Convention  // was @convention<br>&gt;&gt;&gt; @NoReturn // was @noreturn<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In the revised design, the following example for Swift 2.2<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; @warn_unused_result(mutable_variant=&quot;sortInPlace&quot;)<br>&gt;&gt;&gt; public func sort() -&gt; [Self.Generator.Element]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; becomes<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; @WarnUnusedResult(mutableVariant: &quot;sortInPlace&quot;)<br>&gt;&gt;&gt; public func sort() -&gt; [Self.Generator.Element]<br>&gt;&gt; <br>&gt;&gt; Wow, I&#39;m surprised by how much I hate this. Currently, all Swift keywords are entirely lowercase (ignoring things like `Type`, `Protocol`, and `dynamicType` which come after a dot). I think I&#39;ve learned to half-ignore things that look like that, but capitalizing suddenly pulls the spotlight onto these keywords. I&#39;m just not a fan.<br>&gt;&gt; <br>&gt;&gt; I think we&#39;re better off renaming or redesigning `warn_unused_result` so that it&#39;s readable when it&#39;s all-lowercase with no underscores. Some ideas:<br>&gt;&gt; <br>&gt;&gt;    @onlyreturns func sorted() -&gt; [Self.Generator.Element]<br>&gt;&gt;    func sorted() -&gt; @important [Self.Generator.Element]<br>&gt;&gt; <br>&gt;&gt; Alternatively, we could reverse the semantic and make all all non-Void functions warn unless they have an attribute saying not to.<br>&gt;&gt; <br>&gt;&gt;    @ignoreresult mutating func updateValue(value: Value, forKey key: Key) -&gt; Value?<br>&gt;&gt;    mutating func updateValue(value: Value, forKey key: Key) -&gt; @ignorable Value?<br>&gt;&gt;    mutating func updateValue(value: Value, forKey key: Key) -&gt; @convenience Value?<br>&gt;&gt; <br>&gt;&gt; If we do that, we&#39;ll likely still want to be able to annotate non-mutating methods with their mutating variants (well, unless we think the compiler can guess based on the API Guidelines.)<br>&gt;&gt; <br>&gt;&gt;    @variant(mutating: &quot;sort&quot;) func sorted() -&gt; [Self.Generator.Element]<br>&gt;&gt;    @alternative(mutating: &quot;sort&quot;) func sorted() -&gt; [Self.Generator.Element]<br>&gt;&gt; <br>&gt;&gt; That opens the possibility of using `@variant(nonmutating:)` on mutating functions, too.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Discussion] Modernizing Attribute Case and Attribute Argument Naming</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>February 17, 2016 at 10:00:00am</p></header><div class="content"><p>On Wed, Feb 17, 2016 at 10:43 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; Do you have an alternative suggestion?<br></p><p>I don&#39;t personally see an issue with using snake case for attributes<br>(they have a distinct namespace, so they can have their own naming<br>convention), but if the naming convention has to change, your<br>suggestions (quoted below) totally make sense to me.<br></p><p>Dmitri<br></p><p>&gt; I can add the following to the<br>&gt; Alternatives Considered:<br>&gt;<br>&gt; Using lowercase for attributes names becomes confusing with longer compound<br>&gt; examples. For example `warnunusedresult`<br>&gt; looks a lot like a continuous string of lowercase characters. I recommend<br>&gt; the Swift team consider introducing upper camel case<br>&gt; for attributes to match the Cocoa members (UIApplicationMain, NSManaged,<br>&gt; NSCopying, NSApplicationMain, IBAction, IBDesignable, IBInspectable,<br>&gt; IBOutlet) or lower<br>&gt; camel case to avoid this issue:<br>&gt;<br>&gt; @AutoClosure, @Available, @ObjC, @NoEscape, @NonObjC, @NoReturn, @Testable,<br>&gt; @WarnUnusedResult, @Convention, @NoReturn<br>&gt;<br>&gt; or<br>&gt;<br>&gt; @autoClosure, @available, @objC, @noEscape, @nonObjC, @noReturn, @testable,<br>&gt; @warnUnusedResult, @convention, @noReturn<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt;<br>&gt; On Feb 17, 2016, at 11:36 AM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Wed, Feb 17, 2016 at 10:18 AM, Erica Sadun via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; For your consideration: Attribute Ophidiophobia. Feedback and suggestions<br>&gt; welcome. -- Erica<br>&gt;<br>&gt; Modernizing Attribute Case and Attribute Argument Naming<br>&gt;<br>&gt; Proposal: TBD<br>&gt; Author(s): Erica Sadun<br>&gt; Status: TBD<br>&gt; Review manager: TBD<br>&gt;<br>&gt; Introduction<br>&gt;<br>&gt; Two isolated instances of snake case remain in the Swift attribute grammar.<br>&gt; This proposal updates those elements to bring them into compliance with<br>&gt; modern Swift language standards.<br>&gt;<br>&gt; The Swift-Evolution discussion of this topic took place in the &quot;[Discussion]<br>&gt; Modernizing Attribute Case and Attribute Argument Naming&quot; thread. Hat tip to<br>&gt; Michael Wells<br>&gt;<br>&gt; Motivation and Detail Design<br>&gt;<br>&gt; Parts of the Swift attribute grammar retain lower snake case patterns that<br>&gt; no longer match modern conventions:<br>&gt;<br>&gt; The warn_unused_result attribute should use lowercase and be renamed<br>&gt; warnunusedresult.<br>&gt;<br>&gt;<br>&gt; Hi Erica,<br>&gt;<br>&gt; Maybe it is just me, but I find @warnunusedresult to be unreadable --<br>&gt; it looks like a continuous string of lowercase characters at a glance.<br>&gt;<br>&gt; Dmitri<br>&gt;<br>&gt; --<br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;<br>&gt;<br></p><p><br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[Discussion] Modernizing Attribute Case and Attribute Argument Naming</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>February 17, 2016 at 12:00:00pm</p></header><div class="content"><p>If you are taking votes, I would say lower camel case (since the attribute names are not types).<br></p><p>Visually I dislike @objC and @nonObjC, but there’s already a discussion ongoing about how to deal with abbreviations in names.<br></p><p>-DW<br></p><p>&gt; On Feb 17, 2016, at 11:43 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Do you have an alternative suggestion? I can add the following to the Alternatives Considered:<br>&gt; <br>&gt; Using lowercase for attributes names becomes confusing with longer compound examples. For example `warnunusedresult`<br>&gt; looks a lot like a continuous string of lowercase characters. I recommend the Swift team consider introducing upper camel case<br>&gt; for attributes to match the Cocoa members (UIApplicationMain, NSManaged, NSCopying, NSApplicationMain, IBAction, IBDesignable, IBInspectable, IBOutlet) or lower<br>&gt; camel case to avoid this issue:<br>&gt; <br>&gt; @AutoClosure, @Available, @ObjC, @NoEscape, @NonObjC, @NoReturn, @Testable, @WarnUnusedResult, @Convention, @NoReturn<br>&gt; <br>&gt; or<br>&gt; <br>&gt; @autoClosure, @available, @objC, @noEscape, @nonObjC, @noReturn, @testable, @warnUnusedResult, @convention, @noReturn<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 17, 2016, at 11:36 AM, Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Wed, Feb 17, 2016 at 10:18 AM, Erica Sadun via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; For your consideration: Attribute Ophidiophobia. Feedback and suggestions<br>&gt;&gt;&gt; welcome. -- Erica<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Modernizing Attribute Case and Attribute Argument Naming<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposal: TBD<br>&gt;&gt;&gt; Author(s): Erica Sadun<br>&gt;&gt;&gt; Status: TBD<br>&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Two isolated instances of snake case remain in the Swift attribute grammar.<br>&gt;&gt;&gt; This proposal updates those elements to bring them into compliance with<br>&gt;&gt;&gt; modern Swift language standards.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The Swift-Evolution discussion of this topic took place in the &quot;[Discussion]<br>&gt;&gt;&gt; Modernizing Attribute Case and Attribute Argument Naming&quot; thread. Hat tip to<br>&gt;&gt;&gt; Michael Wells<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Motivation and Detail Design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Parts of the Swift attribute grammar retain lower snake case patterns that<br>&gt;&gt;&gt; no longer match modern conventions:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The warn_unused_result attribute should use lowercase and be renamed<br>&gt;&gt;&gt; warnunusedresult.<br>&gt;&gt; <br>&gt;&gt; Hi Erica,<br>&gt;&gt; <br>&gt;&gt; Maybe it is just me, but I find @warnunusedresult to be unreadable --<br>&gt;&gt; it looks like a continuous string of lowercase characters at a glance.<br>&gt;&gt; <br>&gt;&gt; Dmitri<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt;*/<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160217/69e18e81/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 496 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160217/69e18e81/attachment.sig&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Discussion] Modernizing Attribute Case and Attribute Argument Naming</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February 17, 2016 at 06:00:00pm</p></header><div class="content"><p>Agreed that Attribute names are not types but they have a precedent (as you see in the proposal here: https://gist.github.com/erica/29c1a7fb7f49324d572f) of upper camel among their items.<br></p><p>-- E<br></p><p><br>&gt; On Feb 17, 2016, at 12:35 PM, David Waite &lt;david at alkaline-solutions.com&gt; wrote:<br>&gt; <br>&gt; If you are taking votes, I would say lower camel case (since the attribute names are not types).<br>&gt; <br>&gt; Visually I dislike @objC and @nonObjC, but there’s already a discussion ongoing about how to deal with abbreviations in names.<br>&gt; <br>&gt; -DW<br>&gt; <br>&gt;&gt; On Feb 17, 2016, at 11:43 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Do you have an alternative suggestion? I can add the following to the Alternatives Considered:<br>&gt;&gt; <br>&gt;&gt; Using lowercase for attributes names becomes confusing with longer compound examples. For example `warnunusedresult`<br>&gt;&gt; looks a lot like a continuous string of lowercase characters. I recommend the Swift team consider introducing upper camel case<br>&gt;&gt; for attributes to match the Cocoa members (UIApplicationMain, NSManaged, NSCopying, NSApplicationMain, IBAction, IBDesignable, IBInspectable, IBOutlet) or lower<br>&gt;&gt; camel case to avoid this issue:<br>&gt;&gt; <br>&gt;&gt; @AutoClosure, @Available, @ObjC, @NoEscape, @NonObjC, @NoReturn, @Testable, @WarnUnusedResult, @Convention, @NoReturn<br>&gt;&gt; <br>&gt;&gt; or<br>&gt;&gt; <br>&gt;&gt; @autoClosure, @available, @objC, @noEscape, @nonObjC, @noReturn, @testable, @warnUnusedResult, @convention, @noReturn<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 17, 2016, at 11:36 AM, Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Wed, Feb 17, 2016 at 10:18 AM, Erica Sadun via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; For your consideration: Attribute Ophidiophobia. Feedback and suggestions<br>&gt;&gt;&gt;&gt; welcome. -- Erica<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Modernizing Attribute Case and Attribute Argument Naming<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Proposal: TBD<br>&gt;&gt;&gt;&gt; Author(s): Erica Sadun<br>&gt;&gt;&gt;&gt; Status: TBD<br>&gt;&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Two isolated instances of snake case remain in the Swift attribute grammar.<br>&gt;&gt;&gt;&gt; This proposal updates those elements to bring them into compliance with<br>&gt;&gt;&gt;&gt; modern Swift language standards.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The Swift-Evolution discussion of this topic took place in the &quot;[Discussion]<br>&gt;&gt;&gt;&gt; Modernizing Attribute Case and Attribute Argument Naming&quot; thread. Hat tip to<br>&gt;&gt;&gt;&gt; Michael Wells<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Motivation and Detail Design<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Parts of the Swift attribute grammar retain lower snake case patterns that<br>&gt;&gt;&gt;&gt; no longer match modern conventions:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The warn_unused_result attribute should use lowercase and be renamed<br>&gt;&gt;&gt;&gt; warnunusedresult.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi Erica,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Maybe it is just me, but I find @warnunusedresult to be unreadable --<br>&gt;&gt;&gt; it looks like a continuous string of lowercase characters at a glance.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Dmitri<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt;*/<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160217/d9b4cfcf/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ab486d7597af4cfe0be33a762150848?s=50"></div><header><strong>[Discussion] Modernizing Attribute Case and Attribute Argument Naming</strong> from <string>Dany St-Amant</string> &lt;dsa.mls at icloud.com&gt;<p>February 17, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; Le 17 févr. 2016 à 13:43, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Do you have an alternative suggestion? I can add the following to the Alternatives Considered:<br>&gt; <br>&gt; Using lowercase for attributes names becomes confusing with longer compound examples. For example `warnunusedresult`<br>&gt; looks a lot like a continuous string of lowercase characters. I recommend the Swift team consider introducing upper camel case<br>&gt; for attributes to match the Cocoa members (UIApplicationMain, NSManaged, NSCopying, NSApplicationMain, IBAction, IBDesignable, IBInspectable, IBOutlet) or lower<br>&gt; camel case to avoid this issue:<br>&gt; <br>&gt; @AutoClosure, @Available, @ObjC, @NoEscape, @NonObjC, @NoReturn, @Testable, @WarnUnusedResult, @Convention, @NoReturn<br>&gt; <br>&gt; or<br>&gt; <br>&gt; @autoClosure, @available, @objC, @noEscape, @nonObjC, @noReturn, @testable, @warnUnusedResult, @convention, @noReturn<br>&gt; <br></p><p>With a sticky-shift key/slow pinky, @UpperCaseCamel is easier to type than @lowerCaseCamel on many keyboards; but using any casing for these attributes give them higher visibility than what I think they might deserve. Those are only annotations and IMHO should not bring undue attention to themselves; writing them in all lowercase does achieve this goal. In a way, these can also be seen a little bit as the main language keywords, which are currently all lowercases (not sure if any multi-word keyword currently exist)<br></p><p>Yes, @warnunusedresult is a bit hard to read, but @noreturn is much more elegant than either @noReturn or @NoReturn. Even though, I suffer from slow pinky, I think I still prefer the all lowercase.<br></p><p>Since the only hard one to read in all lowercase is warnunusedresult, maybe this particular one could be renamed; @unusedresult(warn), still hard to read… @warn(unusedResult), this one look promising, but not sure how to cleanly combine with mutableVariant.<br></p><p>AFAIK, the @attibute will remain in full control of the compile, and never be open to user provided syntax. So (crazy thought), in a bold move (maybe a not so Swift like one) cases could be ignored, making everybody writing code happy, and everyone reading code of others unhappy.<br></p><p>Dany<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160217/2d4cb0e3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Discussion] Modernizing Attribute Case and Attribute Argument Naming</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February 17, 2016 at 08:00:00pm</p></header><div class="content"><p>I expect the core team to choose the approach they prefer. There is already precedent for upper camel, and no precedent for lower camel.<br></p><p>-- E<br></p><p>&gt; On Feb 17, 2016, at 8:27 PM, Dany St-Amant via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Le 17 févr. 2016 à 13:43, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; Do you have an alternative suggestion? I can add the following to the Alternatives Considered:<br>&gt;&gt; <br>&gt;&gt; Using lowercase for attributes names becomes confusing with longer compound examples. For example `warnunusedresult`<br>&gt;&gt; looks a lot like a continuous string of lowercase characters. I recommend the Swift team consider introducing upper camel case<br>&gt;&gt; for attributes to match the Cocoa members (UIApplicationMain, NSManaged, NSCopying, NSApplicationMain, IBAction, IBDesignable, IBInspectable, IBOutlet) or lower<br>&gt;&gt; camel case to avoid this issue:<br>&gt;&gt; <br>&gt;&gt; @AutoClosure, @Available, @ObjC, @NoEscape, @NonObjC, @NoReturn, @Testable, @WarnUnusedResult, @Convention, @NoReturn<br>&gt;&gt; <br>&gt;&gt; or<br>&gt;&gt; <br>&gt;&gt; @autoClosure, @available, @objC, @noEscape, @nonObjC, @noReturn, @testable, @warnUnusedResult, @convention, @noReturn<br>&gt;&gt; <br>&gt; <br>&gt; With a sticky-shift key/slow pinky, @UpperCaseCamel is easier to type than @lowerCaseCamel on many keyboards; but using any casing for these attributes give them higher visibility than what I think they might deserve. Those are only annotations and IMHO should not bring undue attention to themselves; writing them in all lowercase does achieve this goal. In a way, these can also be seen a little bit as the main language keywords, which are currently all lowercases (not sure if any multi-word keyword currently exist)<br>&gt; <br>&gt; Yes, @warnunusedresult is a bit hard to read, but @noreturn is much more elegant than either @noReturn or @NoReturn. Even though, I suffer from slow pinky, I think I still prefer the all lowercase.<br>&gt; <br>&gt; Since the only hard one to read in all lowercase is warnunusedresult, maybe this particular one could be renamed; @unusedresult(warn), still hard to read… @warn(unusedResult), this one look promising, but not sure how to cleanly combine with mutableVariant.<br>&gt; <br>&gt; AFAIK, the @attibute will remain in full control of the compile, and never be open to user provided syntax. So (crazy thought), in a bold move (maybe a not so Swift like one) cases could be ignored, making everybody writing code happy, and everyone reading code of others unhappy.<br>&gt; <br>&gt; Dany<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160217/6fe30704/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
