<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>April 10, 2016 at 02:00:00pm</p></header><div class="content"><p>Hello Swift community,<br></p><p>The review of &quot;A New Model for Collections and Indices&quot; begins now and runs through April 18th. The proposal is available here:<br></p><p>	https://github.com/apple/swift-evolution/blob/master/proposals/0065-collections-move-indices.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0055-optional-unsafe-pointers.md&gt;<br></p><p>Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at:<br>	https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>or, if you would like to keep your feedback private, directly to the review manager.<br></p><p><br>What goes into a review?<br></p><p>The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br></p><p>	* What is your evaluation of the proposal?<br>	* Is the problem being addressed significant enough to warrant a change to Swift?<br>	* Does this proposal fit well with the feel and direction of Swift?<br>	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>More information about the Swift evolution process is available at<br></p><p>	https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br></p><p>Thank you,<br></p><p>-Chris Lattner<br>Review Manager<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution-announce/attachments/20160410/8cbe355b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>April 10, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Apr 10, 2016, at 2:41 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;A New Model for Collections and Indices&quot; begins now and runs through April 18th. The proposal is available here:<br></p><p>The correct link is:<br>https://github.com/apple/swift-evolution/blob/master/proposals/0065-collections-move-indices.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0065-collections-move-indices.md&gt;<br></p><p>-Chris<br></p><p>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at:<br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution-announce/attachments/20160410/8356470a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>April 10, 2016 at 04:00:00pm</p></header><div class="content"><p>Minor questions after initial read-through:<br></p><p>- Should the comment on {index,formIndex}(_:stepsFrom:) say what happens if<br>the resulting index would be out of bounds? Can these functions return<br>Optional values, or can they be `throws`?<br></p><p>- Can {index,formIndex}(_:stepsFrom:) be combined with the limitedBy:<br>versions, such that the limit is an *optional parameter* with default value<br>nil? For example:<br></p><p>    public func index(n: IndexDistance, stepsFrom i: Index, *limitedBy<br>limit: Index? = nil*)<br></p><p>Jacob<br></p><p>On Sun, Apr 10, 2016 at 2:45 PM, Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Apr 10, 2016, at 2:41 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;<br>&gt; Hello Swift community,<br>&gt;<br>&gt; The review of &quot;A New Model for Collections and Indices&quot; begins now and<br>&gt; runs through April 18th. The proposal is available here:<br>&gt;<br>&gt;<br>&gt; The correct link is:<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0065-collections-move-indices.md<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt; should be sent to the swift-evolution mailing list at:<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; or, if you would like to keep your feedback private, directly to the<br>&gt; review manager.<br>&gt;<br>&gt;<br>&gt; What goes into a review?<br>&gt;<br>&gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and, eventually, determine the direction of<br>&gt; Swift. When writing your review, here are some questions you might want to<br>&gt; answer in your review:<br>&gt;<br>&gt; * What is your evaluation of the proposal?<br>&gt; * Is the problem being addressed significant enough to warrant a change to<br>&gt; Swift?<br>&gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt; * If you have you used other languages or libraries with a similar<br>&gt; feature, how do you feel that this proposal compares to those?<br>&gt; * How much effort did you put into your review? A glance, a quick reading,<br>&gt; or an in-depth study?<br>&gt;<br>&gt; More information about the Swift evolution process is available at<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;<br>&gt; Thank you,<br>&gt;<br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160410/3d76291c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>April 10, 2016 at 07:00:00pm</p></header><div class="content"><p>On Sun, Apr 10, 2016 at 4:16 PM, Jacob Bandes-Storch via<br>swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Minor questions after initial read-through:<br>&gt;<br>&gt; - Should the comment on {index,formIndex}(_:stepsFrom:) say what happens if<br>&gt; the resulting index would be out of bounds?<br></p><p>Yes, we should make that clear.  The answer is that you get<br>unspecified memory-safe behavior.  We encourage implementations to<br>trap, but it is allowed to return an index that is invalid, and some<br>later use of it will trap, or return a valid index (say, equivalent to<br>startIndex).<br></p><p>&gt; Can these functions return<br>&gt; Optional values, or can they be `throws`?<br></p><p>Detecting such misuse can be too expensive, so it is not possible to<br>require these functions return a guaranteed indicator of failure.<br>Also, in most cases, producing an out-of-bounds index is a program<br>error, and it is not possible to recover from it.  (Imagine that you<br>are writing sort(), and you need to split the collection in two halves<br>-- what would you do if index() returns nil?)<br></p><p>&gt; - Can {index,formIndex}(_:stepsFrom:) be combined with the limitedBy:<br>&gt; versions, such that the limit is an optional parameter with default value<br>&gt; nil? For example:<br>&gt;<br>&gt;     public func index(n: IndexDistance, stepsFrom i: Index, limitedBy limit:<br>&gt; Index? = nil)<br></p><p>We considered it, but decided against it.  This function is a<br>requirement of RandomAccessCollection.  The two-argument form is<br>usually trivial to implement.  The three-argument form is very tricky<br>to implement correctly for all edge cases.  So we require the<br>two-argument form, and provide a default implementation for the<br>three-argument one.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0065 A New Model for Collections and Indices</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>April 10, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Apr 10, 2016, at 2:41 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; The review of &quot;A New Model for Collections and Indices&quot; begins now and runs through April 18th. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0065-collections-move-indices.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0055-optional-unsafe-pointers.md&gt;<br></p><p>That link actually goes to an earlier proposal, 0055, although the visible text forms the correct URL. Try this link &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0065-collections-move-indices.md&gt; instead. :)<br></p><p>—Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160410/168ad9e8/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April 10, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0065-collections-move-indices.md<br></p><p>Some questions and comments:<br></p><p>&gt; 		• Two for ranges that additionally conform to RandomAccessCollection (requiring bounds that are Strideablewith Stride conforming to Integer): CountableRange&lt;T&gt; and CountableClosedRange&lt;T&gt;. These types can be folded into Range and ClosedRange when Swift acquires conditional conformance capability.<br></p><p><br>Does this mean that once we have conditional conformances, HalfOpenRangeProtocol and ClosedRangeProtocol will most likely go away?<br></p><p>&gt; We also introduce three new protocols:<br>&gt; <br>&gt; 	• RangeProtocol<br>&gt; 	• HalfOpenRangeProtocol<br>&gt; 	• ClosedRangeProtocol<br>&gt; <br>&gt; These protocols mostly exist facilitate implementation-sharing among the range types, and would seldom need to be implemented outside the standard library.<br></p><p><br>If these types are for implementation sharing, should they be underscored to discourage their use? Or is the position they occupy in the type hierarchy important because Range and ClosedRange will eventually occupy them?<br></p><p>It seems to me that RangeProtocol is unlike the other two in that it&#39;s a sensible thing to constrain a parameter to. Does the &quot;implementation-sharing&quot; comment not really apply to it? On the other hand, it&#39;s not like the SubSequence subscript now takes a RangeProtocol. Should it?<br></p><p>(Has any thought been given to allowing you to close protocols to outside conformances the way that resilience seems to suggest we&#39;ll eventually allow you to close classes?)<br></p><p>&gt; • Two for general ranges (whose bounds are Comparable): Range&lt;T&gt; and ClosedRange&lt;T&gt;. Having a separate ClosedRange type allows us to address the vexing inability of the old Range to represent a range containing the maximal value of its bound.<br></p><p>I notice that ClosedRange uses a ClosedRangeIndex to, essentially, add one extra value for &quot;larger than all values of this type&quot;. Could this solution be applied to Range to allow us to unify Range and ClosedRange, or are there other obstacles to that?<br></p><p>(There likely are. I just wanted to make sure the idea wasn&#39;t left unexplored.)<br></p><p>&gt; func successor(of i: Index) -&gt; Index<br></p><p><br>Two things:<br></p><p>1. I would really like a version of this which returns Optional and is guaranteed to go `nil` once it hits `endIndex`. There can be a non-optional version too, or it might even be a feature of the `index` family of methods instead of `successor` itself, but I think it would be valuable to let the collection worry about the bounds check. It seems silly to check the index before calling `successor(of:)` when `successor(of:)` is going to immediately perform the same check again as a precondition.<br></p><p>(Actually, in general, I&#39;m a little bit dismayed that the collection API does so little to help you include bounds checks in your code. Especially when iterating through a collection, bounds checks are absolutely mandatory, and the collection API&#39;s solution to the problem is &quot;eh, just use `&lt;`, it&#39;s not like you might mess something like that up&quot;.)<br></p><p>2. There is a very strong parallel between this method and a generator&#39;s `next()` method—the generator&#39;s `next()` calls `successor(of:)` to get the index it should use—which makes me wonder if this method should also be called `next(_:)` instead of `successor(of:)`. On the other hand, I have no good suggestion for a <br></p><p>&gt; func index(n: IndexDistance, stepsFrom i: Index) -&gt; Index<br></p><p><br>Oof, I am really not a fan of this name. `steps` is sort-of a label on the `n` parameter, but it&#39;s attached to `i`. Other collection APIs use `distance`, not `steps` (although &quot;steps&quot; does appear in the documentation of the `Distance` associated type). `index` puts it in a method family with `index(predicate:)` and `index(of:)`, but those two are user-facing while this one is part of the collection API. Even the word `index` itself is redundant with the method return type.<br></p><p>I do understand how this is kind of parallel to `index(of:)` and `index(predicate:)`, in that they all return an index calculated from the parameters, but I think these methods are more different than they are similar.<br></p><p>Compared to this:<br></p><p>	collection.index(5, stepsFrom: i)<br></p><p>I would prefer any of these (ordered from least favorite to most):<br></p><p>	collection.index(distance: 5, from: i)<br>	collection.index(5, from: i)<br>	collection.traveling(5, from: i)<br>	collection.striding(5, from: i)<br>	collection.advancing(i, by: 5)<br></p><p>A word on `striding(_:from:)` appearing in that list: Although redesigning Strideable is not directly in scope for this proposal, I&#39;ve noticed that our discussions on modernizing Strideable seem to be trending towards the idea that it operates on collections (or rather, on an as-yet-unnamed supertype of `BidirectionalCollection` or `RandomAccessCollection`) and strides by repeatedly calling a method with the same semantics as this one. Thus, there seems to be an intimate connection between this operation and Strideable. I think we ought to choose a method name which suits that, and I don&#39;t think `index` is it.<br></p><p>&gt; func index(n: IndexDistance, stepsFrom i: Index, limitedBy limit: Index) -&gt; Index<br></p><p><br>I have a few issues with this API.<br></p><p>1. As aforementioned, I&#39;m not a big fan of using `index` as the base method name.<br></p><p>2. This method can move the index either forwards or backwards, but only one limit is specified. Would we be better off having the `limit` be a range?<br></p><p>3. What is the use case for returning the `limit` instead of returning the fact that we crossed it? I have a hard time thinking of a case where I would want to just bump up against the limit and use it rather than *detect* that I&#39;ve hit the limit (which would probably call for a return type of `Index?`). Are there common needs that I&#39;m just not thinking of? Should we offer both?<br></p><p>&gt; 	* What is your evaluation of the proposal?<br></p><p>Despite my criticisms, this is fundamentally a very good design. It will not only improve the language, it will also open the door to further improvements.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes. I believe this change is complicating in the short run but actually simplifying in the long run, eliminating concepts like the Index protocols which represented several overlapping semantics.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes.<br></p><p>&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>Nothing with a collection design as rich as Swift&#39;s.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>Somewhere between the latter two. I wouldn&#39;t call it in-depth when it&#39;s such a big change, but I feel like I have too much background to say it&#39;s a quick reading, either.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>April 11, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; 	* What is your evaluation of the proposal?<br></p><p>+1. I think it makes the collection model more simple and more flexible at the same time. By coupling index to a specific collection, rather then treating it as a separate, independent entity, we can more easily implement alternative collections. For instance, I have recently needed a collection that wraps around the end of a sequence, e.g. <br></p><p>[1, 2, 3, 4, 5].[wrappingFrom: 3, end: 2] == [4, 5, 1, 2]<br></p><p>With the current model, implementing indexes that do this kind of wrapping is quite messy, because a lot of collection-specific state needs to be stored within the index. With the new model, it becomes much simpler. <br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>I think so. The model where index has its own, independent properties is too rigid. It might be possible to work around the limitations of that model with using more advanced generics(e.g. where type information depends on values such as dimensionality etc.), but the proposed new model is much simpler and potentially allows better performing code. <br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p><br>Followed the thread, experimented with implementing various non-trivial collections myself (in Swift and outside Swift)<br></p><p>&gt; On 10 Apr 2016, at 23:41, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;A New Model for Collections and Indices&quot; begins now and runs through April 18th. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0065-collections-move-indices.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0055-optional-unsafe-pointers.md&gt;<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at:<br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160411/e9654511/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>April 11, 2016 at 06:00:00pm</p></header><div class="content"><p>Hello,<br></p><p>I have a user question regarding the proposed range types that replace the old range/interval.<br></p><p>The old hierachy allowed me to turn ranges to SQL expressions through the following mapping (see https://github.com/groue/GRDB.swift/blob/v0.57.0/GRDB/FetchRequest/SQLOperator.swift#L335-L365)<br></p><p>	1. Range&lt;BidirectionalIndexType&gt;<br>	expr BETWEEN self.startIndex AND self.endIndex.predecessor()<br></p><p>	2. ClosedInterval<br>	expr BETWEEN self.start AND self.end<br></p><p>	3. HalfOpenInterval<br>	expr &gt;= start AND x &lt; end<br></p><p>This would let me generate SQL for 0..&lt;18 and &quot;A&quot;..&lt;&quot;B&quot;, as below:<br></p><p>	// SELECT * FROM &quot;persons&quot; WHERE (&quot;age&quot; BETWEEN 0 AND 17)<br>	Person.filter((0..&lt;18).contains(Col.age))<br></p><p>	// SELECT * FROM &quot;persons&quot; WHERE (&quot;age&quot; BETWEEN 0 AND 17)<br>	Person.filter((0...17).contains(Col.age))<br></p><p>	// SELECT * FROM &quot;persons&quot; WHERE (&quot;name&quot; BETWEEN &#39;A&#39; AND &#39;z&#39;)<br>	Person.filter((&quot;A&quot;...&quot;z&quot;).contains(Col.name))<br></p><p>	// SELECT * FROM &quot;persons&quot; WHERE ((&quot;name&quot; &gt;= &#39;A&#39;) AND (&quot;name&quot; &lt; &#39;z&#39;))<br>	Person.filter((&quot;A&quot;..&lt;&quot;z&quot;).contains(Col.name))<br></p><p>Will it still be possible with the new protocol and types? Especially, how to I generate &quot;BETWEEN 0 AND 17&quot; from 0..&lt;18 without a supporting collection that gives me the predecessor of 18?<br></p><p>Gwendal Roué<br></p><p>&gt; Le 10 avr. 2016 à 23:41, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;A New Model for Collections and Indices&quot; begins now and runs through April 18th. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0065-collections-move-indices.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at:<br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>April 11, 2016 at 09:00:00am</p></header><div class="content"><p>Hi,<br></p><p>On Mon, Apr 11, 2016 at 9:16 AM, Gwendal Roué &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Will it still be possible with the new protocol and types? Especially, how to I generate &quot;BETWEEN 0 AND 17&quot; from 0..&lt;18 without a supporting collection that gives me the predecessor of 18?<br></p><p>You would either design your API to accept a CountableRange, or a<br>Range where Bound conforms to Strideable.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>April 11, 2016 at 09:00:00am</p></header><div class="content"><p>On Mon, Apr 11, 2016 at 9:20 AM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; Hi,<br>&gt;<br>&gt; On Mon, Apr 11, 2016 at 9:16 AM, Gwendal Roué &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Will it still be possible with the new protocol and types? Especially, how to I generate &quot;BETWEEN 0 AND 17&quot; from 0..&lt;18 without a supporting collection that gives me the predecessor of 18?<br>&gt;<br>&gt; You would either design your API to accept a CountableRange, or a<br>&gt; Range where Bound conforms to Strideable.<br></p><p>You could also make your API generic over RangeProtocol where Bound<br>conforms to Strideable, check if the end point is contained in the<br>range (detecting closed ranges), and if it is not, perform the<br>adjustment.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>April 11, 2016 at 06:00:00pm</p></header><div class="content"><p>Thank you Dmitri!<br></p><p>&gt; Le 11 avr. 2016 à 18:22, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; a écrit :<br>&gt; <br>&gt;&gt; On Mon, Apr 11, 2016 at 9:20 AM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;&gt; Hi,<br>&gt;&gt; <br>&gt;&gt;&gt; On Mon, Apr 11, 2016 at 9:16 AM, Gwendal Roué &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; Will it still be possible with the new protocol and types? Especially, how to I generate &quot;BETWEEN 0 AND 17&quot; from 0..&lt;18 without a supporting collection that gives me the predecessor of 18?<br>&gt;&gt; <br>&gt;&gt; You would either design your API to accept a CountableRange, or a<br>&gt;&gt; Range where Bound conforms to Strideable.<br>&gt; <br>&gt; You could also make your API generic over RangeProtocol where Bound<br>&gt; conforms to Strideable, check if the end point is contained in the<br>&gt; range (detecting closed ranges), and if it is not, perform the<br>&gt; adjustment.<br>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>April 11, 2016 at 09:00:00am</p></header><div class="content"><p>I love irregular plurals as much as the next grammar nerd, but I think it&#39;d be better to use the more regular, but still correct, plural &quot;indexes&quot; rather than &quot;indices&quot;.<br></p><p>-Joe<br></p><p>&gt; On Apr 10, 2016, at 2:41 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;A New Model for Collections and Indices&quot; begins now and runs through April 18th. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0065-collections-move-indices.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at:<br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c40db4457ab2c91a0d8006da31b177c6?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>Trent Nadeau</string> &lt;tanadeau at gmail.com&gt;<p>April 11, 2016 at 12:00:00pm</p></header><div class="content"><p>I disagree. According to both http://grammarist.com/usage/indexes-indices/<br>and http://www.worldwidewords.org/qa/qa-ind2.htm, &quot;indices&quot; is more common<br>in the English-speaking world (outside of parts of America and Canada) as<br>well as in technical contexts.<br></p><p>On Mon, Apr 11, 2016 at 12:29 PM, Joe Groff via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I love irregular plurals as much as the next grammar nerd, but I think<br>&gt; it&#39;d be better to use the more regular, but still correct, plural &quot;indexes&quot;<br>&gt; rather than &quot;indices&quot;.<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt; &gt; On Apr 10, 2016, at 2:41 PM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Hello Swift community,<br>&gt; &gt;<br>&gt; &gt; The review of &quot;A New Model for Collections and Indices&quot; begins now and<br>&gt; runs through April 18th. The proposal is available here:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0065-collections-move-indices.md<br>&gt; &gt;<br>&gt; &gt; Reviews are an important part of the Swift evolution process. All<br>&gt; reviews should be sent to the swift-evolution mailing list at:<br>&gt; &gt;       https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; or, if you would like to keep your feedback private, directly to the<br>&gt; review manager.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; What goes into a review?<br>&gt; &gt;<br>&gt; &gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and, eventually, determine the direction of<br>&gt; Swift. When writing your review, here are some questions you might want to<br>&gt; answer in your review:<br>&gt; &gt;<br>&gt; &gt;       * What is your evaluation of the proposal?<br>&gt; &gt;       * Is the problem being addressed significant enough to warrant a<br>&gt; change to Swift?<br>&gt; &gt;       * Does this proposal fit well with the feel and direction of Swift?<br>&gt; &gt;       * If you have you used other languages or libraries with a similar<br>&gt; feature, how do you feel that this proposal compares to those?<br>&gt; &gt;       * How much effort did you put into your review? A glance, a quick<br>&gt; reading, or an in-depth study?<br>&gt; &gt;<br>&gt; &gt; More information about the Swift evolution process is available at<br>&gt; &gt;<br>&gt; &gt;       https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; &gt;<br>&gt; &gt; Thank you,<br>&gt; &gt;<br>&gt; &gt; -Chris Lattner<br>&gt; &gt; Review Manager<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br></p><p>-- <br>Trent Nadeau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160411/1f43a238/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>April 11, 2016 at 09:00:00am</p></header><div class="content"><p>Joe’s isn’t saying that “Indexes” is more common, rather that it’s regular (i.e. follows the usual declension rule for plurals); there’s tradeoffs each way, but using the regular plural might make it more familiar for some non-native speakers/readers.<br></p><p>– Steve<br></p><p>&gt; On Apr 11, 2016, at 9:42 AM, Trent Nadeau via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I disagree. According to both http://grammarist.com/usage/indexes-indices/ &lt;http://grammarist.com/usage/indexes-indices/&gt; and http://www.worldwidewords.org/qa/qa-ind2.htm &lt;http://www.worldwidewords.org/qa/qa-ind2.htm&gt;, &quot;indices&quot; is more common in the English-speaking world (outside of parts of America and Canada) as well as in technical contexts.<br>&gt; <br>&gt; On Mon, Apr 11, 2016 at 12:29 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; I love irregular plurals as much as the next grammar nerd, but I think it&#39;d be better to use the more regular, but still correct, plural &quot;indexes&quot; rather than &quot;indices&quot;.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; &gt; On Apr 10, 2016, at 2:41 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Hello Swift community,<br>&gt; &gt;<br>&gt; &gt; The review of &quot;A New Model for Collections and Indices&quot; begins now and runs through April 18th. The proposal is available here:<br>&gt; &gt;<br>&gt; &gt;       https://github.com/apple/swift-evolution/blob/master/proposals/0065-collections-move-indices.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0065-collections-move-indices.md&gt;<br>&gt; &gt;<br>&gt; &gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at:<br>&gt; &gt;       https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; What goes into a review?<br>&gt; &gt;<br>&gt; &gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; &gt;<br>&gt; &gt;       * What is your evaluation of the proposal?<br>&gt; &gt;       * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; &gt;       * Does this proposal fit well with the feel and direction of Swift?<br>&gt; &gt;       * If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; &gt;       * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; &gt;<br>&gt; &gt; More information about the Swift evolution process is available at<br>&gt; &gt;<br>&gt; &gt;       https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt; &gt;<br>&gt; &gt; Thank you,<br>&gt; &gt;<br>&gt; &gt; -Chris Lattner<br>&gt; &gt; Review Manager<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Trent Nadeau<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160411/61c2da96/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>April 11, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Apr 11, 2016, at 9:48 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt; <br>&gt; Joe’s isn’t saying that “Indexes” is more common, rather that it’s regular (i.e. follows the usual declension rule for plurals); there’s tradeoffs each way, but using the regular plural might make it more familiar for some non-native speakers/readers.<br></p><p>Yeah. From personal experience I&#39;ve worked with many developers for whom &quot;indices&quot; was an unfamiliar term, whereas &quot;indexes&quot; was immediately obvious.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c40db4457ab2c91a0d8006da31b177c6?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>Trent Nadeau</string> &lt;tanadeau at gmail.com&gt;<p>April 11, 2016 at 12:00:00pm</p></header><div class="content"><p>At least in my experience, &quot;indices&quot; is used throughout technical<br>documentation and code, such as the official docs of Python, Java, and C#.<br></p><p>I&#39;m not strongly opposed to &quot;indexes&quot;, but I think there should be a<br>stronger reason to change it other than that it has easier discoverability<br>for non-English speakers (who can search for it in a few seconds). I think<br>of &quot;indices&quot; as a term of art or a word in a technical dialect of English.<br></p><p>On Mon, Apr 11, 2016 at 12:49 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Apr 11, 2016, at 9:48 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Joe’s isn’t saying that “Indexes” is more common, rather that it’s<br>&gt; regular (i.e. follows the usual declension rule for plurals); there’s<br>&gt; tradeoffs each way, but using the regular plural might make it more<br>&gt; familiar for some non-native speakers/readers.<br>&gt;<br>&gt; Yeah. From personal experience I&#39;ve worked with many developers for whom<br>&gt; &quot;indices&quot; was an unfamiliar term, whereas &quot;indexes&quot; was immediately obvious.<br>&gt;<br>&gt; -Joe<br></p><p><br></p><p><br>-- <br>Trent Nadeau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160411/1a0ede09/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>April 11, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; 	• Because Swift is unable to express conditional protocol conformances, implementing this change has required us to create a great deal of complexity in the standard library API. Aside from the two excess “Countable” range types, there are new overloads for slicing and twelve distinct slice types that capture all the combinations of traversal, mutability, and range-replaceability. While these costs are probably temporary, they are very real in the meantime.<br></p><p>Is there a migration strategy possible for when we do support conditional conformances? Would typealiasing the existing names to refinements of a more general Slice&lt;T&gt; type be sufficient?<br></p><p>-Joe<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>April 11, 2016 at 01:00:00pm</p></header><div class="content"><p>I won’t do a full review because I don’t think I have spent enough time reading through the discussion, but just reading the proposal I’d say I’m an huge proponent of this change. Irrespective of the performance benefits, I think it’s a massive win for an easily understandable mental model.<br></p><p>Tyler<br></p><p><br>&gt; On Apr 10, 2016, at 2:41 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;A New Model for Collections and Indices&quot; begins now and runs through April 18th. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0065-collections-move-indices.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0055-optional-unsafe-pointers.md&gt;<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at:<br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160411/e6de24b6/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be4c3c3b76631a155e1358db48066692?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>Tony Parker</string> &lt;anthony.parker at apple.com&gt;<p>April 11, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Apr 10, 2016, at 2:41 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;A New Model for Collections and Indices&quot; begins now and runs through April 18th. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0065-collections-move-indices.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at:<br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br></p><p>I agree with the general direction and scope of the proposal, but I think the names could use some changes. Specifically, I don’t think the fallback to ‘form’ is required. It would be a significant readability improvement to use a meaningful verb to describe the action of altering the argument. The methods that create new indices probably need a label on the first argument, because otherwise it looks as if the IndexDistance is what is described by ‘index’.<br></p><p>Proposed:<br></p><p>  func successor(of i: Index) -&gt; Index<br>  func formSuccessor(i: inout Index)<br></p><p>Instead, I suggest:<br></p><p>  func successor(of i : Index) -&gt; Index<br>  func advance(i: inout Index)<br></p><p>Proposed:<br></p><p>  func index(n: IndexDistance, stepsFrom i: Index) -&gt; Index<br>  func index(n: IndexDistance, stepsFrom i: Index, limitedBy limit: Index) -&gt; Index<br>  func formIndex(n: IndexDistance, stepsFrom i: inout Index)<br>  func formIndex(n: IndexDistance, stepsFrom i: inout Index, limitedBy limit: Index)<br></p><p>Suggested (taking into account Nate’s suggestion of reversing the order):<br></p><p>  func index(startingAt i: Index, movedBy n: IndexDistance) -&gt; Index<br>  func index(startingAt i: Index, movedBy n: IndexDistance, limitedBy limit: Index) -&gt; Index<br>  func move(i : inout Index, by n: IndexDistance)<br>  func move(i : inout Index, by n: IndexDistance, limitedBy limit: Index)<br></p><p>Proposed:<br></p><p>  func predecessor(of i: Index) -&gt; Index<br>  func formPredecessor(i: inout Index)<br></p><p>Suggested:<br></p><p>  func predecessor(of i: Index) -&gt; Index<br>  func reverse(i: inout Index)<br></p><p><br>I think reversing an index has some nice symmetry with reversing a sequence, but if it seems to confusing, then replace advance and reverse with ‘moveForward’ and ‘moveBackward’.<br></p><p>- Tony<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>April 12, 2016 at 11:00:00am</p></header><div class="content"><p>Aside: `indices` being irregular can be a benefit in the context of auto-complete.<br></p><p>&gt; 	* What is your evaluation of the proposal?<br></p><p>+1, very much.<br></p><p>As a change from the current model, it’s an across-the-board improvement for me, at least.<br></p><p>In a bigger-picture sense I think Swift would be better off by going *further* on certain aspects, but have said all that before.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>It is, again very much so.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Depends on the framing of the question.<br></p><p>Compared to the previous model, it’s an unqualified YES.<br></p><p>As a general proposition, I think this design is a local optimum for overall Swift-ness, but even so it’s creating a little un-Swifty pocket. It’s “un-Swifty” in at least two ways:<br></p><p># 1: Relatively Unsafe, Pointer-Like Semantics<br></p><p>Indices—unsurprisingly!—behave quite a bit like pointers, and similarly expose *numerous* crashing combinations of `(value,operation)`:<br></p><p>- self[endIndex]<br>- self[startIndex] // &lt;- when empty<br>- successor(of: endIndex)<br>- predecessor(of: startIndex)<br></p><p>…etc., which is *very much* reminiscent of the hazards of pointers. (Technically “undefined” not “crashing”, but being realistic “crashing&quot; is usually accurate).<br></p><p>Although Swift uses `Optional` to mitigate the hazards of `nil` pointers (etc.), you’re still left to your own devices for handling indices.<br></p><p>This isn’t news to anyone here, I’m sure, and may even be unavoidable; I’m just pointing it out as an uncharacteristically-unsafe area in Swift’s standard APIs, and closer to how `!` and IOUs behave than otherwise typical.<br></p><p>To help illustrate the claim, here’s a strawman “safe” API—for illustration only, not advocacy!—that would be safer and thus perhaps more “Swift-y”:<br></p><p>  protocol SafeCollection {<br></p><p>    /// `Index` by another name<br>    associatedtype Position: Equatable // , Comparable too if you want<br>  <br>    /// Returns `nil` when empty. A non-strawman version<br>    /// would return something better than a labeled tuple, here.<br>    var bounds: (first: Position, last: Position)? { get }<br>  <br>    /// Returns the first position, or `nil` when empty. <br>    /// Like `startIndex` but any non-nil value is safe to subscript.<br>    var firstPosition: Position? { get }<br></p><p>    /// Returns the last position, or `nil` when empty. <br>    /// Like `endIndex` but any non-nil value is safe to subscript.<br>    var lastPosition: Position? { get }<br>  <br>    /// No risk of trying to subscript `endIndex` here.<br>    subscript(position: Position) -&gt; Element<br>  <br>    /// Safe to call on any non-nil position from this collection;<br>    /// no risk of trying to advance the `endIndex` here.<br>    func successor(of p: Position) -&gt; Position?<br></p><p>    /// Safe to call on any non-nil position from this collection;<br>    /// no risk of trying to retreat-from the `startIndex` here.<br>    func predecessor(of p: Position) -&gt; Position?<br></p><p>    // and so on and so forth<br></p><p>  }<br></p><p>…which, again, I include for purpose of *comparison* only. I *believe* this illustration has more of the “index-safety” Brent is getting at, but I can’t speak for him.<br></p><p>Pros:<br>- safer, b/c there’s no `nil`-analog like `endIndex` that needs checking-for<br>- feels more Swift-like (safer, harder to mis-use)<br></p><p>Cons:<br>- likely less-efficient than current proposal<br>- wants you to use closed index ranges, not half-open<br>- doesn’t address index-invalidation (discussed immediately below)<br></p><p>So, again, I’m not advocating that “safer” design be Swift&#39;s basic building-block, but I think it illustrates why it’s fair to call the index system relatively “unsafe”: as proposed, indices have semantics that are lower-level than they seem, with a safety profile *closer to* IOU/`!` than most of Swift’s standard library. <br></p><p># 2: Index Invalidation Unrepresented In Type System <br></p><p>A related “un-Swift-y” aspect is that index-invalidation has no type-level representation whatsoever. Some operations on collections invalidate indices, but which operations? Which indices?<br></p><p>I don’t have a proposed *solution* I feel good about as to how to represent invalidation in the type system, but even so “values that become invalid for further use due to actions that happen elsewhere” is not very Swift-y.<br></p><p># Remarks<br></p><p>Don’t get me wrong, I still like this proposal, and am *very* skeptical that something like the “safer index” sketched above would be a net win; I just think it’s very fair to say that indices are a corner of the standard library that isn’t all that Swifty due to the lack of statically-enforced safety as per usual in the rest of the library.<br></p><p>&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>This is a tricky question in this context b/c pretty much every non-toy language with a non-toy standard library will have its own take on collections-and-iteration; it also makes it very hard to be concise, as the same terms mean slightly different things from language to language.<br></p><p>I think it’s fair to say that although *many* languages have something analogous to Swift’s `Generator` (soon: `Iterator`), *very few* languages have based their fundamental collections hierarchy/API around Swift-style indices.<br></p><p>Additionally, most languages I’m familiar with have a hierarchy that, in Swift terms, would look something like this:<br></p><p>- Sequence<br>  - Collection<br>    - ArrayCollection // or `ForwardCollection` in Swift, probably<br>    - DictionaryCollection // or AssociativeCollection, or MapCollection, etc.<br>    - SetCollection <br></p><p>…as opposed to Swift’s design (wherein `Collection` *is* essentially the nonexistent `ForwardCollection`, and all collections are thus `ForwardCollection`s).<br></p><p>I’m not sure Swift gains much from being this way; put differently, if Swift currently looked like this:<br></p><p>  protocol CloningIterator : Iterator {<br></p><p>    /// Returns a copy of `self` (at the current iteration state).<br>    func clone() -&gt; Self<br></p><p>  }<br></p><p>  protocol Collection : Sequence {<br>    // no `Index` here<br>    associatedtype Iterator: CloningIterator<br>    <br>    // minimal API here<br>    var isEmpty: Bool { get }<br>    var count: Int { get }<br>  }<br></p><p>  protocol ForwardCollection : Collection {<br> <br>    // exactly as-per proposal’s `Collection`:<br>    associatedtype Index <br>     <br>    // all Index-related methods exactly as-per proposal’s `Collection`<br></p><p>  }<br></p><p>  struct Array&lt;T&gt; : ForwardCollection {}<br>  struct Set&lt;T&gt; : Collection {}<br>  struct Dictionary&lt;K,V&gt; : Collection {}<br></p><p>…then I’d still want `ForwardCollection` to have an API like the proposal (wherein collections-move-indices), but I’d personally see no real value gained by “promoting&quot; `Set` and `Dictionary` to be `ForwardCollection`.<br></p><p>But, I’ve made that case before.<br></p><p>I want to reiterate that I think this proposal is more-or-less the best possible design for what it is—collections *should* move indices, when they have them!<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I’ve groused unproductively about aspects of iteration-and-collection design in numerous previous discussions; I’ve written some custom collections and some collection-combinators and in so doing encountered many issues with the previous design.<br></p><p>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160412/c80ca658/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>April 13, 2016 at 12:00:00am</p></header><div class="content"><p>I’m a +1 for the proposal (but as I’ve implemented a bunch of collections recently I’m not sure I’m looking forward to having to update my code to reflect the new pattern ;)<br></p><p>But I’m interested by these concerns:<br></p><p>&gt; On 12 Apr 2016, at 17:57, plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; # 1: Relatively Unsafe, Pointer-Like Semantics<br>&gt; # 2: Index Invalidation Unrepresented In Type System <br></p><p>It seems to me as though we could solve #1 by solving #2 actually; if we knew when indices were invalid, then unless we’re storing .endIndex or using .startIndex or .endIndex on an empty collection (rather than .first and .last) then there should no issues of the safety of these “pointers&quot; anymore.<br></p><p>The tricky thing is how to handle #2; we can do this at run-time by having indices include a reference to their parent (or some kind of ID class), plus a copy of a state variable which the collection will use to track invalidating changes. If an index is passed to the collection with an incorrect reference then it wasn’t for that collection, and if the states don’t match then the index was invalidated. But really it’d be better if we had some way to do this at compile-time which I think is what you meant; i.e- some way for the compiler to track when an index was invalidated between being stored and being used, so that passing it into the subscript or other methods will produce a warning.<br></p><p>I suppose this could be done using attributes on the return values for index generating properties/methods to assign some kind of tag which other methods can then mark as having been invalidated, so that anything assigned that tag can be considered invalid by the compiler if you try to use a value stored before the invalidation. This is something that could be done afterwards I think, so hopefully shouldn’t affect the proposal itself. There’ll be limits to how far the compiler can track this though, but it could help to avoid most of the simpler mistakes at least.<br></p><p>It’d be interesting if the compiler would also trace that an index belongs to a collection, to prevent you accidentally using compatible ones with the wrong collection when you have several; it’s good practice to check this with preconditions, or assertions for performance, but the compiler doing it could give more useful errors/advice.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160413/21b45989/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>April 12, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Apr 12, 2016, at 6:11 PM, Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br>&gt; <br>&gt; I’m a +1 for the proposal (but as I’ve implemented a bunch of collections recently I’m not sure I’m looking forward to having to update my code to reflect the new pattern ;)<br>&gt; <br>&gt; But I’m interested by these concerns:<br>&gt; <br>&gt;&gt; On 12 Apr 2016, at 17:57, plx via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; # 1: Relatively Unsafe, Pointer-Like Semantics<br>&gt;&gt; # 2: Index Invalidation Unrepresented In Type System <br>&gt; <br>&gt; It seems to me as though we could solve #1 by solving #2 actually; if we knew when indices were invalid, then unless we’re storing .endIndex or using .startIndex or .endIndex on an empty collection (rather than .first and .last) then there should no issues of the safety of these “pointers&quot; anymore.<br></p><p>FWIW I think “solving” invalidation in the sense of being able to detect invalidity is useful, but what I’d personally be more interested in is e.g. something like this:<br></p><p>  protocol Collection {<br></p><p>    // throw this into the definition:<br>    static var indexCharacteristics: IndexCharacteristics { get }<br></p><p>  }<br>  <br>  extension RangeReplaceableCollection {<br></p><p>    mutating func removeElementsFailing(@noescape predicate: (Element) -&gt; Bool) {<br>      if Self.indexCharacteristics.removalOnlyInvalidatesRightward() {<br>        // presumptive “fast path”, deleting “back-to-front” to <br>        // avoid making a copy. Just for sake of illustration!<br>        for index in self.indices.dropLast().reverse() where !predicate(self[index]) {<br>          self.removeAtIndex(index)<br>        }<br>      } else {<br>        // presumptive “slow path”, we rebuild ourself with the failing elements omitted<br>        self = Self(self.lazy.filter() { predicate($0) })<br>        // ^ assuming self-assignment allowed...<br>      }<br>    }<br>  <br>  }<br></p><p>…e.g. some way to get some kind of coarse-grained behavior-characterization of “what actions invalidate which indices”, thereby allowing one to know when various approaches will work.<br></p><p>Invalidation is hard and I wouldn’t want anything held up to try and find a solution first.<br></p><p>&gt; <br>&gt; The tricky thing is how to handle #2; we can do this at run-time by having indices include a reference to their parent (or some kind of ID class), plus a copy of a state variable which the collection will use to track invalidating changes. If an index is passed to the collection with an incorrect reference then it wasn’t for that collection, and if the states don’t match then the index was invalidated. But really it’d be better if we had some way to do this at compile-time which I think is what you meant; i.e- some way for the compiler to track when an index was invalidated between being stored and being used, so that passing it into the subscript or other methods will produce a warning.<br>&gt; <br>&gt; I suppose this could be done using attributes on the return values for index generating properties/methods to assign some kind of tag which other methods can then mark as having been invalidated, so that anything assigned that tag can be considered invalid by the compiler if you try to use a value stored before the invalidation. This is something that could be done afterwards I think, so hopefully shouldn’t affect the proposal itself. There’ll be limits to how far the compiler can track this though, but it could help to avoid most of the simpler mistakes at least.<br>&gt; <br>&gt; It’d be interesting if the compiler would also trace that an index belongs to a collection, to prevent you accidentally using compatible ones with the wrong collection when you have several; it’s good practice to check this with preconditions, or assertions for performance, but the compiler doing it could give more useful errors/advice.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160412/628fb610/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>April 12, 2016 at 08:00:00pm</p></header><div class="content"><p>On Tue, Apr 12, 2016 at 8:46 PM, plx via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Apr 12, 2016, at 6:11 PM, Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br>&gt;<br>&gt; I’m a +1 for the proposal (but as I’ve implemented a bunch of collections<br>&gt; recently I’m not sure I’m looking forward to having to update my code to<br>&gt; reflect the new pattern ;)<br>&gt;<br>&gt; But I’m interested by these concerns:<br>&gt;<br>&gt; On 12 Apr 2016, at 17:57, plx via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; # 1: Relatively Unsafe, Pointer-Like Semantics<br>&gt; # 2: Index Invalidation Unrepresented In Type System<br>&gt;<br>&gt;<br>&gt; It seems to me as though we could solve #1 by solving #2 actually; if we<br>&gt; knew when indices were invalid, then unless we’re storing .endIndex or using<br>&gt; .startIndex or .endIndex on an empty collection (rather than .first and<br>&gt; .last) then there should no issues of the safety of these “pointers&quot;<br>&gt; anymore.<br>&gt;<br>&gt;<br>&gt; FWIW I think “solving” invalidation in the sense of being able to detect<br>&gt; invalidity is useful, but what I’d personally be more interested in is e.g.<br>&gt; something like this:<br>&gt;<br>&gt;   protocol Collection {<br>&gt;<br>&gt;     // throw this into the definition:<br>&gt;     static var indexCharacteristics: IndexCharacteristics { get }<br>&gt;<br>&gt;   }<br>&gt;<br>&gt;   extension RangeReplaceableCollection {<br>&gt;<br>&gt;     mutating func removeElementsFailing(@noescape predicate: (Element) -&gt;<br>&gt; Bool) {<br>&gt;       if Self.indexCharacteristics.removalOnlyInvalidatesRightward() {<br>&gt;         // presumptive “fast path”, deleting “back-to-front” to<br>&gt;         // avoid making a copy. Just for sake of illustration!<br>&gt;         for index in self.indices.dropLast().reverse() where<br>&gt; !predicate(self[index]) {<br>&gt;           self.removeAtIndex(index)<br>&gt;         }<br>&gt;       } else {<br>&gt;         // presumptive “slow path”, we rebuild ourself with the failing<br>&gt; elements omitted<br>&gt;         self = Self(self.lazy.filter() { predicate($0) })<br>&gt;         // ^ assuming self-assignment allowed...<br>&gt;       }<br>&gt;     }<br>&gt;<br>&gt;   }<br></p><p>Hi plx,<br></p><p>In case of RangeReplaceableCollection, the index invalidation rules<br>that we currently have in mind (but haven&#39;t documented in public<br>documentation yet) imply that your fast path is always correct.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>April 12, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Apr 12, 2016, at 10:53 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Tue, Apr 12, 2016 at 8:46 PM, plx via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Apr 12, 2016, at 6:11 PM, Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I’m a +1 for the proposal (but as I’ve implemented a bunch of collections<br>&gt;&gt; recently I’m not sure I’m looking forward to having to update my code to<br>&gt;&gt; reflect the new pattern ;)<br>&gt;&gt; <br>&gt;&gt; But I’m interested by these concerns:<br>&gt;&gt; <br>&gt;&gt; On 12 Apr 2016, at 17:57, plx via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; # 1: Relatively Unsafe, Pointer-Like Semantics<br>&gt;&gt; # 2: Index Invalidation Unrepresented In Type System<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; It seems to me as though we could solve #1 by solving #2 actually; if we<br>&gt;&gt; knew when indices were invalid, then unless we’re storing .endIndex or using<br>&gt;&gt; .startIndex or .endIndex on an empty collection (rather than .first and<br>&gt;&gt; .last) then there should no issues of the safety of these “pointers&quot;<br>&gt;&gt; anymore.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; FWIW I think “solving” invalidation in the sense of being able to detect<br>&gt;&gt; invalidity is useful, but what I’d personally be more interested in is e.g.<br>&gt;&gt; something like this:<br>&gt;&gt; <br>&gt;&gt;  protocol Collection {<br>&gt;&gt; <br>&gt;&gt;    // throw this into the definition:<br>&gt;&gt;    static var indexCharacteristics: IndexCharacteristics { get }<br>&gt;&gt; <br>&gt;&gt;  }<br>&gt;&gt; <br>&gt;&gt;  extension RangeReplaceableCollection {<br>&gt;&gt; <br>&gt;&gt;    mutating func removeElementsFailing(@noescape predicate: (Element) -&gt;<br>&gt;&gt; Bool) {<br>&gt;&gt;      if Self.indexCharacteristics.removalOnlyInvalidatesRightward() {<br>&gt;&gt;        // presumptive “fast path”, deleting “back-to-front” to<br>&gt;&gt;        // avoid making a copy. Just for sake of illustration!<br>&gt;&gt;        for index in self.indices.dropLast().reverse() where<br>&gt;&gt; !predicate(self[index]) {<br>&gt;&gt;          self.removeAtIndex(index)<br>&gt;&gt;        }<br>&gt;&gt;      } else {<br>&gt;&gt;        // presumptive “slow path”, we rebuild ourself with the failing<br>&gt;&gt; elements omitted<br>&gt;&gt;        self = Self(self.lazy.filter() { predicate($0) })<br>&gt;&gt;        // ^ assuming self-assignment allowed...<br>&gt;&gt;      }<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;  }<br>&gt; <br>&gt; Hi plx,<br>&gt; <br>&gt; In case of RangeReplaceableCollection, the index invalidation rules<br>&gt; that we currently have in mind (but haven&#39;t documented in public<br>&gt; documentation yet) imply that your fast path is always correct.<br></p><p>That’s good news!<br></p><p>Fact is, I only went with that because I was actually fishing around for the weakest generic collection protocol that supported removal, and that seems to be it.<br></p><p>It’d be a more compelling motivating example if it used, e.g.:<br></p><p>  // “fictional”, not in stdlib:<br>  protocol IndexDeletingCollection : Collection {<br></p><p>    mutating func removeAtIndex(i: Index) -&gt; Generator.Element<br></p><p>  }<br></p><p>…since there’d then be a more realistic chance of having multiple “flavors” of invalidation to consider.<br></p><p>But I could certainly live with a setup wherein generally protocols typically required “compatible” invalidation semantics on their indices.<br></p><p>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>April 13, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On 13 Apr 2016, at 04:46, plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Invalidation is hard and I wouldn’t want anything held up to try and find a solution first.<br></p><p>Oh I agree, that was partly my point though; while this proposal may leave us with the &quot;un-Swifty&quot; issue of being unable to explicitly handle invalidation, it should be possible to solve that later, i.e- this proposal does’t make us any more vulnerable to that problem than we are now, but I definitely agree that we could do with some kind of invalidation mechanism in future that developers can actually implement or respond to. I guess I was more thinking out loud about whether the problem affects the proposal or not, but I don’t think that solving it will place any restrictions on the API as proposed, definitely deserves a proposal of its own once the new indexing system is in place though!<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>April 13, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Apr 13, 2016, at 5:34 AM, Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 13 Apr 2016, at 04:46, plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Invalidation is hard and I wouldn’t want anything held up to try and find a solution first.<br>&gt; <br>&gt; Oh I agree, that was partly my point though; while this proposal may leave us with the &quot;un-Swifty&quot; issue of being unable to explicitly handle invalidation, it should be possible to solve that later, i.e- this proposal does’t make us any more vulnerable to that problem than we are now, but I definitely agree that we could do with some kind of invalidation mechanism in future that developers can actually implement or respond to. I guess I was more thinking out loud about whether the problem affects the proposal or not, but I don’t think that solving it will place any restrictions on the API as proposed, definitely deserves a proposal of its own once the new indexing system is in place though!<br></p><p>There was a design document linked in one of the earlier discussions that IIRC suggested some collections would want to maintain a &quot;revision count” value, with their indices then holding a snapshot of that “revision count” at their time of creation.<br></p><p>For something like Array that’s a bit heavyweight.<br></p><p>“Invalidation&quot; is also IMHO a bit under-defined without an associated “for what?”:<br></p><p>  var letters = [“a”, “b”, “c”, “d”, “e”]<br></p><p>  // indexOfB == 1<br>  let indexOfB = letters.indexOf(“b”)<br></p><p>  letters.insert(“z”, atIndex: indexOfB)<br></p><p>…is `index` invalid or not? IMHO it would depend on what you want to do with it.<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>April 16, 2016 at 08:00:00am</p></header><div class="content"><p>Review of:<br>https://github.com/apple/swift-evolution/blob/master/proposals/0065-collections-move-indices.md<br></p><p>* What is your evaluation of the proposal?<br></p><p>I think it is a big improvement over the current collections API. However I<br>have a number of reservations, particularly:<br></p><p><br>   1. The motivation of improved performance smacks of &quot;premature<br>   optimisation&quot;. For particularly high performance collections a fast unsafe<br>   form could be provided, like UnsafePointer, e.g. UnsafeArray. For the rest<br>   I think it is better to have a clean API rather than skew the API for<br>   performance.<br>   2. The proposed iterator, `collection.next(&amp;iterator)`, is not as<br>   convenient to use as a classic external or internal iterator. It introduces<br>   the potential for errors where an iterator from one collection is used in<br>   another and where the collection and iterator are manipulated separately.<br>   What&#39;s the point of eliminating C for loops because of index problems and<br>   then introducing much the same? The new iterator cannot be type erased<br>   without also capturing the associated collection, defeating the point of<br>   the new iterators!<br>   3. The protocols are quite hierarchical; instead they could be a<br>   collection [sic] of small, top-level protocols that are plugged together. A<br>   useful division is one main method per protocol with &#39;good&#39;, default<br>   implementations provided for other methods. A &#39;good&#39; implementation of<br>   count would not be iterating through the collection counting!<br>   4. The members, e.g. map, filter, return specific implementations like<br>   Array. I find this restrictive. Would it be possible to return a protocol<br>   to allow other implementations more flexibility.<br>   5. There is an advantage in splitting lazy into a separate hierarchy,<br>   there is precedence for this in that both Java, Stream, and C#, LINQ, do<br>   this. The main differences are that you would expect a collection to be<br>   multiple iterable, e.g. inside a nested loop, and mutable, e.g.<br>   subscriptable, whereas a lazy can only be guaranteed to be iterable once<br>   and is purely functional. This splitting of lazy into a separate API would<br>   also lay the groundwork for a parallel-lazy version.<br>   6. The naming of the protocols would be better if they were Xxxable and<br>   that xxx referred to the main method in the protocol. For example instead<br>   of Sequence, Iterable because its key feature is iterate.<br>   7. I think Range would be better if it has an Int index of 0 to count -<br>   1 and a value of start + index * stride, where start and stride are of type<br>   Arithmetic, i.e. range[index] = start + index * stride.<br></p><p><br>* Is the problem being addressed significant enough to warrant a change to<br>Swift?<br></p><p>Yes the current collections API could be improved and it is an important<br>part of any programming language.<br></p><p>* Does this proposal fit well with the feel and direction of Swift?<br></p><p>In some ways yes, it captures more of your intention in the type system.<br>But in other ways no, it introduces an iterative paradigm that is<br>potentially more error prone that the existing one and step back towards<br>using subscripts and index for everything, ie. C for loop style.<br></p><p>* If you have you used other languages or libraries with a similar feature,<br>how do you feel that this proposal compares to those?<br></p><p>Obviously everyone uses collection API&#39;s in every language. I have used<br>collections in many diverse languages and also written custom collections,<br>e.g. a parallel collection API in Java before Java got a standard version.<br></p><p>* How much effort did you put into your review? A glance, a quick reading,<br>or an in-depth study?<br></p><p>Quite a bit, including fleshing out a minimal collection API that conforms<br>to the principles stated above and posted on swift-evolution under the new<br>iterator model discussions.<br></p><p>  -- Howard.<br></p><p>On 11 April 2016 at 07:41, Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hello Swift community,<br>&gt;<br>&gt; The review of &quot;A New Model for Collections and Indices&quot; begins now and<br>&gt; runs through April 18th. The proposal is available here:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0065-collections-move-indices.md<br>&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0055-optional-unsafe-pointers.md&gt;<br>&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt; should be sent to the swift-evolution mailing list at:<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; or, if you would like to keep your feedback private, directly to the<br>&gt; review manager.<br>&gt;<br>&gt;<br>&gt; What goes into a review?<br>&gt;<br>&gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and, eventually, determine the direction of<br>&gt; Swift. When writing your review, here are some questions you might want to<br>&gt; answer in your review:<br>&gt;<br>&gt; * What is your evaluation of the proposal?<br>&gt; * Is the problem being addressed significant enough to warrant a change to<br>&gt; Swift?<br>&gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt; * If you have you used other languages or libraries with a similar<br>&gt; feature, how do you feel that this proposal compares to those?<br>&gt; * How much effort did you put into your review? A glance, a quick reading,<br>&gt; or an in-depth study?<br>&gt;<br>&gt; More information about the Swift evolution process is available at<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;<br>&gt; Thank you,<br>&gt;<br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160416/36e6fa77/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05e222e6ef4d84013bb3baeb0e25c90b?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>Patrick Gili</string> &lt;gili.patrick.r at gili-labs.com&gt;<p>April 16, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br></p><p>1) I think eliminating intervals increases consistency and reduces confusion.<br></p><p>2) I really like the fact that this will make in-place index traversal methods public. It will reduce the amount of boilerplate for developers implementing new collections.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes.<br></p><p>&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>Most modern languages provide a sophisticated library supporting collections. I think this proposal is moving the Swift Foundation in the direction of the C++ STL and Boost libraries.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>In-depth.<br></p><p>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>April 20, 2016 at 04:00:00pm</p></header><div class="content"><p>On Apr 10, 2016, at 2:41 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;A New Model for Collections and Indices&quot; begins now and runs through April 18th. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0065-collections-move-indices.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0055-optional-unsafe-pointers.md&gt;<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at:<br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br></p><p>A quick update: the core team met to discuss this.  They agreed to accept it with some naming-related revisions to the proposal (in response to community feedback).  Dave is organizing this feedback, and I’ll send out the formal announcement when that is ready.<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160420/cde05741/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
