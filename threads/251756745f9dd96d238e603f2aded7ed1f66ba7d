<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July 22, 2016 at 03:00:00pm</p></header><div class="content"><p>on Fri Jul 22 2016, Daniel Duan &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On Jul 22, 2016, at 11:05 AM, Dave Abrahams via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Thu Jul 21 2016, Duan<br>&gt;<br>&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Great proposal. I want to second that areSame may mislead user to<br>&gt;&gt;&gt; think this is about identity.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I like areEquivalent() but there may be better names.<br>&gt;&gt; <br>&gt;&gt; It really *is* about identity as I posted in a previous message.  But<br>&gt;&gt; that doesn&#39;t change the fact that areEquivalent might be a better name.<br>&gt;&gt; It&#39;s one of the things we considered; it just seemed long for no real<br>&gt;&gt; benefit.<br>&gt;&gt; <br>&gt;<br>&gt; If the addresses of the arguments aren’t being used, then we don’t consider<br>&gt; them part of their *identity*. I can follow this logic. My fear is most users<br>&gt; won’t make this leap on their own and get the same initial impression as I did.<br>&gt; It&#39;s entirely possible this fear is unfounded. Some educated bikesheding<br>&gt; wouldn&#39;t hurt here IMO :)<br></p><p>Well, it&#39;s still a very real question whether we ought to have the<br>additional API surface implied by areSame, or wether we should collapse<br>it with ===.<br></p><p>&gt;<br>&gt;&gt;&gt; Daniel Duan<br>&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jul 21, 2016, at 6:32 PM, Robert Widmann via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jul 21, 2016, at 6:19 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is nice. Is `areSame()` being proposed because static `==` is<br>&gt;&gt;&gt;&gt;&gt; the status quo and you&#39;re trying to make the point that `==` in the<br>&gt;&gt;&gt;&gt;&gt; future need not guarantee the same semantics?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yep!  Equivalence and equality are strictly very different things.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Nit: I think the more common term in stdlib would be<br>&gt;&gt;&gt;&gt;&gt; `areEquivalent()`. Do you think `same` in that context (independent<br>&gt;&gt;&gt;&gt;&gt; of the word &quot;ordering&quot;) might erroneously suggest identity?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There is room for improvement here.  Keep ‘em coming.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Thu, Jul 21, 2016 at 8:11 PM, Robert Widmann via<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; Hello Swift Community,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Harlan Haskins, Jaden Geller, and I have been working on a<br>&gt;&gt;&gt;&gt;&gt;&gt; proposal to clean up the semantics of ordering relations in the<br>&gt;&gt;&gt;&gt;&gt;&gt; standard library.  We have a draft that you can get as a gist.<br>&gt;&gt;&gt;&gt;&gt;&gt; Any feedback you might have about this proposal helps - though<br>&gt;&gt;&gt;&gt;&gt;&gt; please keeps your comments on Swift-Evolution and not on the gist.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f6b7154fd1d6a470d0b521a2e484bffc?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Daniel Duan</string> &lt;daniel at duan.org&gt;<p>July 22, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jul 22, 2016, at 3:00 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Fri Jul 22 2016, Daniel Duan &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jul 22, 2016, at 11:05 AM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Thu Jul 21 2016, Duan<br>&gt;&gt; <br>&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Great proposal. I want to second that areSame may mislead user to<br>&gt;&gt;&gt;&gt; think this is about identity.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I like areEquivalent() but there may be better names.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It really *is* about identity as I posted in a previous message.  But<br>&gt;&gt;&gt; that doesn&#39;t change the fact that areEquivalent might be a better name.<br>&gt;&gt;&gt; It&#39;s one of the things we considered; it just seemed long for no real<br>&gt;&gt;&gt; benefit.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; If the addresses of the arguments aren’t being used, then we don’t consider<br>&gt;&gt; them part of their *identity*. I can follow this logic. My fear is most users<br>&gt;&gt; won’t make this leap on their own and get the same initial impression as I did.<br>&gt;&gt; It&#39;s entirely possible this fear is unfounded. Some educated bikesheding<br>&gt;&gt; wouldn&#39;t hurt here IMO :)<br>&gt; <br>&gt; Well, it&#39;s still a very real question whether we ought to have the<br>&gt; additional API surface implied by areSame, or wether we should collapse<br>&gt; it with ===.<br>&gt; <br></p><p>To spell this out (because I had to think about it for a second): === will be derived from<br>&lt;=&gt;, but also becomes default implementation for ==, which remains open for customization.<br></p><p>I like this idea. If we keep === as a separate thing, now users have 3 “opportunities” to define<br>equality. The must be few, if any, use cases for this.<br></p><p>Would love to see if anyone on the list can give us an example. Otherwise we should make<br>areSame === again™!<br></p><p>&gt;&gt; <br>&gt;&gt;&gt;&gt; Daniel Duan<br>&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jul 21, 2016, at 6:32 PM, Robert Widmann via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jul 21, 2016, at 6:19 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This is nice. Is `areSame()` being proposed because static `==` is<br>&gt;&gt;&gt;&gt;&gt;&gt; the status quo and you&#39;re trying to make the point that `==` in the<br>&gt;&gt;&gt;&gt;&gt;&gt; future need not guarantee the same semantics?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yep!  Equivalence and equality are strictly very different things.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Nit: I think the more common term in stdlib would be<br>&gt;&gt;&gt;&gt;&gt;&gt; `areEquivalent()`. Do you think `same` in that context (independent<br>&gt;&gt;&gt;&gt;&gt;&gt; of the word &quot;ordering&quot;) might erroneously suggest identity?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There is room for improvement here.  Keep ‘em coming.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Thu, Jul 21, 2016 at 8:11 PM, Robert Widmann via<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello Swift Community,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Harlan Haskins, Jaden Geller, and I have been working on a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; proposal to clean up the semantics of ordering relations in the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; standard library.  We have a draft that you can get as a gist.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Any feedback you might have about this proposal helps - though<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; please keeps your comments on Swift-Evolution and not on the gist.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br>&gt; -- <br>&gt; Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/7093b020/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 22, 2016 at 11:00:00pm</p></header><div class="content"><p>I&#39;m convinced. Let&#39;s make areSame === again!<br></p><p>On Fri, Jul 22, 2016 at 18:55 Daniel Duan via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Jul 22, 2016, at 3:00 PM, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; on Fri Jul 22 2016, Daniel Duan &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Jul 22, 2016, at 11:05 AM, Dave Abrahams via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; on Thu Jul 21 2016, Duan<br>&gt;<br>&gt;<br>&gt; &lt;swift-evolution at swift.org<br>&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;<br>&gt; wrote:<br>&gt;<br>&gt; Great proposal. I want to second that areSame may mislead user to<br>&gt; think this is about identity.<br>&gt;<br>&gt; I like areEquivalent() but there may be better names.<br>&gt;<br>&gt;<br>&gt; It really *is* about identity as I posted in a previous message.  But<br>&gt; that doesn&#39;t change the fact that areEquivalent might be a better name.<br>&gt; It&#39;s one of the things we considered; it just seemed long for no real<br>&gt; benefit.<br>&gt;<br>&gt;<br>&gt; If the addresses of the arguments aren’t being used, then we don’t consider<br>&gt; them part of their *identity*. I can follow this logic. My fear is most<br>&gt; users<br>&gt; won’t make this leap on their own and get the same initial impression as I<br>&gt; did.<br>&gt; It&#39;s entirely possible this fear is unfounded. Some educated bikesheding<br>&gt; wouldn&#39;t hurt here IMO :)<br>&gt;<br>&gt;<br>&gt; Well, it&#39;s still a very real question whether we ought to have the<br>&gt; additional API surface implied by areSame, or wether we should collapse<br>&gt; it with ===.<br>&gt;<br>&gt;<br>&gt; To spell this out (because I had to think about it for a second): === will<br>&gt; be derived from<br>&gt; &lt;=&gt;, but also becomes default implementation for ==, which remains open<br>&gt; for customization.<br>&gt;<br>&gt; I like this idea. If we keep === as a separate thing, now users have 3<br>&gt; “opportunities” to define<br>&gt; equality. The must be few, if any, use cases for this.<br>&gt;<br>&gt; Would love to see if anyone on the list can give us an example. Otherwise<br>&gt; we should make<br>&gt; areSame === again™!<br>&gt;<br>&gt;<br>&gt; Daniel Duan<br>&gt; Sent from my iPhone<br>&gt;<br>&gt; On Jul 21, 2016, at 6:32 PM, Robert Widmann via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Jul 21, 2016, at 6:19 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; This is nice. Is `areSame()` being proposed because static `==` is<br>&gt; the status quo and you&#39;re trying to make the point that `==` in the<br>&gt; future need not guarantee the same semantics?<br>&gt;<br>&gt;<br>&gt; Yep!  Equivalence and equality are strictly very different things.<br>&gt;<br>&gt;<br>&gt; Nit: I think the more common term in stdlib would be<br>&gt; `areEquivalent()`. Do you think `same` in that context (independent<br>&gt; of the word &quot;ordering&quot;) might erroneously suggest identity?<br>&gt;<br>&gt;<br>&gt; There is room for improvement here.  Keep ‘em coming.<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Thu, Jul 21, 2016 at 8:11 PM, Robert Widmann via<br>&gt; swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Hello Swift Community,<br>&gt;<br>&gt; Harlan Haskins, Jaden Geller, and I have been working on a<br>&gt; proposal to clean up the semantics of ordering relations in the<br>&gt; standard library.  We have a draft that you can get as a gist.<br>&gt; Any feedback you might have about this proposal helps - though<br>&gt; please keeps your comments on Swift-Evolution and not on the gist.<br>&gt;<br>&gt; Cheers,<br>&gt;<br>&gt; ~Robert Widmann<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/d5fa8676/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July 22, 2016 at 06:00:00pm</p></header><div class="content"><p>on Fri Jul 22 2016, Daniel Duan &lt;daniel-AT-duan.org&gt; wrote:<br></p><p>&gt;&gt; On Jul 22, 2016, at 3:00 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Fri Jul 22 2016, Daniel Duan &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;&gt;&gt; On Jul 22, 2016, at 11:05 AM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Thu Jul 21 2016, Duan<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Great proposal. I want to second that areSame may mislead user to<br>&gt;&gt;&gt;&gt;&gt; think this is about identity.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I like areEquivalent() but there may be better names.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It really *is* about identity as I posted in a previous message.  But<br>&gt;&gt;&gt;&gt; that doesn&#39;t change the fact that areEquivalent might be a better name.<br>&gt;&gt;&gt;&gt; It&#39;s one of the things we considered; it just seemed long for no real<br>&gt;&gt;&gt;&gt; benefit.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If the addresses of the arguments aren’t being used, then we don’t consider<br>&gt;&gt;&gt; them part of their *identity*. I can follow this logic. My fear is most users<br>&gt;&gt;&gt; won’t make this leap on their own and get the same initial impression as I did.<br>&gt;&gt;&gt; It&#39;s entirely possible this fear is unfounded. Some educated bikesheding<br>&gt;&gt;&gt; wouldn&#39;t hurt here IMO :)<br>&gt;&gt; <br>&gt;&gt; Well, it&#39;s still a very real question whether we ought to have the<br>&gt;&gt; additional API surface implied by areSame, or wether we should collapse<br>&gt;&gt; it with ===.<br>&gt;&gt; <br>&gt;<br>&gt; To spell this out (because I had to think about it for a second): === will be derived from<br>&gt; &lt;=&gt;, <br>&gt; but also becomes default implementation for ==, which remains open for<br>&gt; customization.<br></p><p>I was imagining roughly this (untested):<br></p><p>  /// Two references are identical if they refer to the same<br>  /// instance.<br>  ///<br>  /// - Note: Classes with a more-refined notion of “identical” <br>  ///   should conform to `Identifiable` and implement `===`.<br>  func ===(lhs: AnyObject, rhs: AnyObject) -&gt; Bool {<br>    ObjectIdentifier(lhs) == ObjectIdentifier(rhs)<br>  }<br></p><p>  /// Supports testing that two values of `Self` are identical<br>  ///<br>  /// If `a` and `b` are of type `Self`, `a === b` means that<br>  /// `a` and `b` are interchangeable in most code.  A conforming <br>  /// type can document that specific observable characteristics<br>  /// (such as the `capacity` of an `Array`) are inessential and <br>  /// thus not to be considered as part of the interchangeability <br>  /// guarantee.<br>  ///<br>  /// - Requires: `===` induces an equivalence relation over<br>  ///   instances.<br>  /// - Note: conforming types will gain an `==` operator that <br>  ///   forwards to `===`.  <br>  /// - Note: Types that require domain-specific `==` <br>  ///   implementations with different semantics (e.g. floating <br>  ///   point) should define a more-specific overload of `==`, <br>  ///   which will be used in contexts where the static type is<br>  ///   known to the compiler.<br>  /// - Note: Generic code should usually use `==` to compare <br>  ///   conforming instances; that will always dispatch to `===` <br>  ///   and will be unaffected by more specific overloads of<br>  ///   `==`.<br>  protocol Identifiable { // née Equatable name is negotiable<br>    func ===(_: Self, _: aSelf) -&gt; Bool<br>  }<br></p><p>  /// Default definition of `==` for Identifiable types.<br>  func ==&lt;T: Identifiable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>    return lhs === rhs<br>  }<br></p><p>  /// Conforming types have a default total ordering.<br>  /// <br>  /// If `a` and `b` are of type `Self`, `a &lt;=&gt; b` means that<br>  /// `a` and `b` are interchangeable in most code.  A conforming <br>  /// type can document that specific observable characteristics<br>  /// (such as the `capacity` of an `Array`) are inessential and <br>  /// thus not to be considered as part of the interchangeability <br>  /// guarantee.<br>  ///<br>  /// - Requires: `&lt;=&gt;` induces a total ordering over<br>  ///   instances.<br>  /// - Requires: the semantics of `&lt;=&gt;` are  consistent with<br>  ///   those of `===`.  That is, `(a &lt;=&gt; b) == .equivalent` <br>  ///   iff `a === b`.<br>  /// - Note: conforming types will gain `&lt;`, `&lt;=`, `&gt;`, and `&gt;=` <br>  ///   operators defined in terms of `&lt;=&gt;`.  <br>  /// - Note: Types that require domain-specific `&lt;`, etc.<br>  ///   implementations with different semantics (e.g. floating <br>  ///   point) should define more-specific overloads of those <br>  ///   operators, which will be used in contexts where the <br>  ///   static type is known to the compiler.<br>  /// - Note: Generic code can freely use `&lt;=&gt;` or the traditional<br>  ///   comparison operators to compare conforming instances; <br>  ///   the result will always be supplied by `&lt;=&gt;` <br>  ///   and will be unaffected by more specific overloads of<br>  ///   the other operators.<br>  protocol Comparable : Identifiable {<br>    func &lt;=&gt; (lhs: Self, rhs: Self) -&gt; Ordering<br>  }<br></p><p>  /// Default implementations of `&lt;`, `&lt;=`, `&gt;`, and `&gt;=`.<br>  extension Comparable {<br>    static func &lt;(lhs: Self, rhs: Self) -&gt; Bool {<br>      return (lhs &lt;=&gt; rhs) == .ascending<br>    }<br>    static func &lt;=(lhs: Self, rhs: Self) -&gt; Bool {<br>      return (rhs &lt;=&gt; lhs) != .ascending<br>    }<br>    static func &gt;(lhs: Self, rhs: Self) -&gt; Bool {<br>      return (lhs &lt;=&gt; rhs) == .descending<br>    }<br>    static func &gt;=(lhs: Self, rhs: Self) -&gt; Bool {<br>      return (rhs &lt;=&gt; lhs) != .descending<br>    }<br>  }<br></p><p>&gt; I like this idea. If we keep === as a separate thing, now users have 3 “opportunities” to define<br>&gt; equality. The must be few, if any, use cases for this.<br>&gt;<br>&gt; Would love to see if anyone on the list can give us an example. Otherwise we should make<br>&gt; areSame === again™!<br>&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Daniel Duan<br>&gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jul 21, 2016, at 6:32 PM, Robert Widmann via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jul 21, 2016, at 6:19 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This is nice. Is `areSame()` being proposed because static `==` is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; the status quo and you&#39;re trying to make the point that `==` in the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; future need not guarantee the same semantics?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Yep!  Equivalence and equality are strictly very different things.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Nit: I think the more common term in stdlib would be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; `areEquivalent()`. Do you think `same` in that context (independent<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; of the word &quot;ordering&quot;) might erroneously suggest identity?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; There is room for improvement here.  Keep ‘em coming.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Thu, Jul 21, 2016 at 8:11 PM, Robert Widmann via<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello Swift Community,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Harlan Haskins, Jaden Geller, and I have been working on a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; proposal to clean up the semantics of ordering relations in the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; standard library.  We have a draft that you can get as a gist.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Any feedback you might have about this proposal helps - though<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; please keeps your comments on Swift-Evolution and not on the gist.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; Dave<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e95942f1fe843f007ef5430b9acff78b?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Jaden Geller</string> &lt;jaden.geller at gmail.com&gt;<p>July 22, 2016 at 06:00:00pm</p></header><div class="content"><p>I really like this idea. I was initially opposed to changing the behavior of `===`, but I think I&#39;m for it now. Though there have been quite a few situations where I specifically want reference identity, in these situations I would not override the `===` operator anyway; these objects were identified by their reference.<br></p><p>I think this refinement of the proposal makes the semantics easier to reason about, and nicely repurposes the `===` operator instead of introducing a new 3rd notion of equality. If users explicitly want to compare references, it isn&#39;t difficult to create an `ObjectIdentifier`, and it probably leads to clearer code in cases where the object identity isn&#39;t defined by it&#39;s reference.<br></p><p>Could types that conform to `Comparable` not get a default implementation of `===`?<br></p><p>&gt; On Jul 22, 2016, at 6:20 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Fri Jul 22 2016, Daniel Duan &lt;daniel-AT-duan.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jul 22, 2016, at 3:00 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Fri Jul 22 2016, Daniel Duan &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jul 22, 2016, at 11:05 AM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Thu Jul 21 2016, Duan<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Great proposal. I want to second that areSame may mislead user to<br>&gt;&gt;&gt;&gt;&gt;&gt; think this is about identity.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I like areEquivalent() but there may be better names.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It really *is* about identity as I posted in a previous message.  But<br>&gt;&gt;&gt;&gt;&gt; that doesn&#39;t change the fact that areEquivalent might be a better name.<br>&gt;&gt;&gt;&gt;&gt; It&#39;s one of the things we considered; it just seemed long for no real<br>&gt;&gt;&gt;&gt;&gt; benefit.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If the addresses of the arguments aren’t being used, then we don’t consider<br>&gt;&gt;&gt;&gt; them part of their *identity*. I can follow this logic. My fear is most users<br>&gt;&gt;&gt;&gt; won’t make this leap on their own and get the same initial impression as I did.<br>&gt;&gt;&gt;&gt; It&#39;s entirely possible this fear is unfounded. Some educated bikesheding<br>&gt;&gt;&gt;&gt; wouldn&#39;t hurt here IMO :)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Well, it&#39;s still a very real question whether we ought to have the<br>&gt;&gt;&gt; additional API surface implied by areSame, or wether we should collapse<br>&gt;&gt;&gt; it with ===.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; To spell this out (because I had to think about it for a second): === will be derived from<br>&gt;&gt; &lt;=&gt;, <br>&gt;&gt; but also becomes default implementation for ==, which remains open for<br>&gt;&gt; customization.<br>&gt; <br>&gt; I was imagining roughly this (untested):<br>&gt; <br>&gt;  /// Two references are identical if they refer to the same<br>&gt;  /// instance.<br>&gt;  ///<br>&gt;  /// - Note: Classes with a more-refined notion of “identical” <br>&gt;  ///   should conform to `Identifiable` and implement `===`.<br>&gt;  func ===(lhs: AnyObject, rhs: AnyObject) -&gt; Bool {<br>&gt;    ObjectIdentifier(lhs) == ObjectIdentifier(rhs)<br>&gt;  }<br>&gt; <br>&gt;  /// Supports testing that two values of `Self` are identical<br>&gt;  ///<br>&gt;  /// If `a` and `b` are of type `Self`, `a === b` means that<br>&gt;  /// `a` and `b` are interchangeable in most code.  A conforming <br>&gt;  /// type can document that specific observable characteristics<br>&gt;  /// (such as the `capacity` of an `Array`) are inessential and <br>&gt;  /// thus not to be considered as part of the interchangeability <br>&gt;  /// guarantee.<br>&gt;  ///<br>&gt;  /// - Requires: `===` induces an equivalence relation over<br>&gt;  ///   instances.<br>&gt;  /// - Note: conforming types will gain an `==` operator that <br>&gt;  ///   forwards to `===`.  <br>&gt;  /// - Note: Types that require domain-specific `==` <br>&gt;  ///   implementations with different semantics (e.g. floating <br>&gt;  ///   point) should define a more-specific overload of `==`, <br>&gt;  ///   which will be used in contexts where the static type is<br>&gt;  ///   known to the compiler.<br>&gt;  /// - Note: Generic code should usually use `==` to compare <br>&gt;  ///   conforming instances; that will always dispatch to `===` <br>&gt;  ///   and will be unaffected by more specific overloads of<br>&gt;  ///   `==`.<br>&gt;  protocol Identifiable { // née Equatable name is negotiable<br>&gt;    func ===(_: Self, _: aSelf) -&gt; Bool<br>&gt;  }<br>&gt; <br>&gt;  /// Default definition of `==` for Identifiable types.<br>&gt;  func ==&lt;T: Identifiable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;    return lhs === rhs<br>&gt;  }<br>&gt; <br>&gt;  /// Conforming types have a default total ordering.<br>&gt;  /// <br>&gt;  /// If `a` and `b` are of type `Self`, `a &lt;=&gt; b` means that<br>&gt;  /// `a` and `b` are interchangeable in most code.  A conforming <br>&gt;  /// type can document that specific observable characteristics<br>&gt;  /// (such as the `capacity` of an `Array`) are inessential and <br>&gt;  /// thus not to be considered as part of the interchangeability <br>&gt;  /// guarantee.<br>&gt;  ///<br>&gt;  /// - Requires: `&lt;=&gt;` induces a total ordering over<br>&gt;  ///   instances.<br>&gt;  /// - Requires: the semantics of `&lt;=&gt;` are  consistent with<br>&gt;  ///   those of `===`.  That is, `(a &lt;=&gt; b) == .equivalent` <br>&gt;  ///   iff `a === b`.<br>&gt;  /// - Note: conforming types will gain `&lt;`, `&lt;=`, `&gt;`, and `&gt;=` <br>&gt;  ///   operators defined in terms of `&lt;=&gt;`.  <br>&gt;  /// - Note: Types that require domain-specific `&lt;`, etc.<br>&gt;  ///   implementations with different semantics (e.g. floating <br>&gt;  ///   point) should define more-specific overloads of those <br>&gt;  ///   operators, which will be used in contexts where the <br>&gt;  ///   static type is known to the compiler.<br>&gt;  /// - Note: Generic code can freely use `&lt;=&gt;` or the traditional<br>&gt;  ///   comparison operators to compare conforming instances; <br>&gt;  ///   the result will always be supplied by `&lt;=&gt;` <br>&gt;  ///   and will be unaffected by more specific overloads of<br>&gt;  ///   the other operators.<br>&gt;  protocol Comparable : Identifiable {<br>&gt;    func &lt;=&gt; (lhs: Self, rhs: Self) -&gt; Ordering<br>&gt;  }<br>&gt; <br>&gt;  /// Default implementations of `&lt;`, `&lt;=`, `&gt;`, and `&gt;=`.<br>&gt;  extension Comparable {<br>&gt;    static func &lt;(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;      return (lhs &lt;=&gt; rhs) == .ascending<br>&gt;    }<br>&gt;    static func &lt;=(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;      return (rhs &lt;=&gt; lhs) != .ascending<br>&gt;    }<br>&gt;    static func &gt;(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;      return (lhs &lt;=&gt; rhs) == .descending<br>&gt;    }<br>&gt;    static func &gt;=(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;      return (rhs &lt;=&gt; lhs) != .descending<br>&gt;    }<br>&gt;  }<br>&gt; <br>&gt;&gt; I like this idea. If we keep === as a separate thing, now users have 3 “opportunities” to define<br>&gt;&gt; equality. The must be few, if any, use cases for this.<br>&gt;&gt; <br>&gt;&gt; Would love to see if anyone on the list can give us an example. Otherwise we should make<br>&gt;&gt; areSame === again™!<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Daniel Duan<br>&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jul 21, 2016, at 6:32 PM, Robert Widmann via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jul 21, 2016, at 6:19 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This is nice. Is `areSame()` being proposed because static `==` is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the status quo and you&#39;re trying to make the point that `==` in the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; future need not guarantee the same semantics?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yep!  Equivalence and equality are strictly very different things.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Nit: I think the more common term in stdlib would be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; `areEquivalent()`. Do you think `same` in that context (independent<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of the word &quot;ordering&quot;) might erroneously suggest identity?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; There is room for improvement here.  Keep ‘em coming.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Thu, Jul 21, 2016 at 8:11 PM, Robert Widmann via<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello Swift Community,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Harlan Haskins, Jaden Geller, and I have been working on a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; proposal to clean up the semantics of ordering relations in the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; standard library.  We have a draft that you can get as a gist.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Any feedback you might have about this proposal helps - though<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; please keeps your comments on Swift-Evolution and not on the gist.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt; Dave<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; -- <br>&gt; Dave<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July 22, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jul 22, 2016, at 8:34 PM, Jaden Geller via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I really like this idea. I was initially opposed to changing the behavior of `===`, but I think I&#39;m for it now. Though there have been quite a few situations where I specifically want reference identity, in these situations I would not override the `===` operator anyway; these objects were identified by their reference.<br>&gt; <br>&gt; I think this refinement of the proposal makes the semantics easier to reason about, and nicely repurposes the `===` operator instead of introducing a new 3rd notion of equality. If users explicitly want to compare references, it isn&#39;t difficult to create an `ObjectIdentifier`, and it probably leads to clearer code in cases where the object identity isn&#39;t defined by it&#39;s reference.<br>&gt; <br>&gt; Could types that conform to `Comparable` not get a default implementation of `===`?<br></p><p>+1.  This seems like the best direction to go given that we can’t change `==` for floating point.<br></p><p>&gt; <br>&gt;&gt; On Jul 22, 2016, at 6:20 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Fri Jul 22 2016, Daniel Duan &lt;daniel-AT-duan.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jul 22, 2016, at 3:00 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Fri Jul 22 2016, Daniel Duan &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jul 22, 2016, at 11:05 AM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; on Thu Jul 21 2016, Duan<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Great proposal. I want to second that areSame may mislead user to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; think this is about identity.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I like areEquivalent() but there may be better names.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It really *is* about identity as I posted in a previous message.  But<br>&gt;&gt;&gt;&gt;&gt;&gt; that doesn&#39;t change the fact that areEquivalent might be a better name.<br>&gt;&gt;&gt;&gt;&gt;&gt; It&#39;s one of the things we considered; it just seemed long for no real<br>&gt;&gt;&gt;&gt;&gt;&gt; benefit.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If the addresses of the arguments aren’t being used, then we don’t consider<br>&gt;&gt;&gt;&gt;&gt; them part of their *identity*. I can follow this logic. My fear is most users<br>&gt;&gt;&gt;&gt;&gt; won’t make this leap on their own and get the same initial impression as I did.<br>&gt;&gt;&gt;&gt;&gt; It&#39;s entirely possible this fear is unfounded. Some educated bikesheding<br>&gt;&gt;&gt;&gt;&gt; wouldn&#39;t hurt here IMO :)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Well, it&#39;s still a very real question whether we ought to have the<br>&gt;&gt;&gt;&gt; additional API surface implied by areSame, or wether we should collapse<br>&gt;&gt;&gt;&gt; it with ===.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To spell this out (because I had to think about it for a second): === will be derived from<br>&gt;&gt;&gt; &lt;=&gt;, <br>&gt;&gt;&gt; but also becomes default implementation for ==, which remains open for<br>&gt;&gt;&gt; customization.<br>&gt;&gt; <br>&gt;&gt; I was imagining roughly this (untested):<br>&gt;&gt; <br>&gt;&gt; /// Two references are identical if they refer to the same<br>&gt;&gt; /// instance.<br>&gt;&gt; ///<br>&gt;&gt; /// - Note: Classes with a more-refined notion of “identical” <br>&gt;&gt; ///   should conform to `Identifiable` and implement `===`.<br>&gt;&gt; func ===(lhs: AnyObject, rhs: AnyObject) -&gt; Bool {<br>&gt;&gt;   ObjectIdentifier(lhs) == ObjectIdentifier(rhs)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; /// Supports testing that two values of `Self` are identical<br>&gt;&gt; ///<br>&gt;&gt; /// If `a` and `b` are of type `Self`, `a === b` means that<br>&gt;&gt; /// `a` and `b` are interchangeable in most code.  A conforming <br>&gt;&gt; /// type can document that specific observable characteristics<br>&gt;&gt; /// (such as the `capacity` of an `Array`) are inessential and <br>&gt;&gt; /// thus not to be considered as part of the interchangeability <br>&gt;&gt; /// guarantee.<br>&gt;&gt; ///<br>&gt;&gt; /// - Requires: `===` induces an equivalence relation over<br>&gt;&gt; ///   instances.<br>&gt;&gt; /// - Note: conforming types will gain an `==` operator that <br>&gt;&gt; ///   forwards to `===`.  <br>&gt;&gt; /// - Note: Types that require domain-specific `==` <br>&gt;&gt; ///   implementations with different semantics (e.g. floating <br>&gt;&gt; ///   point) should define a more-specific overload of `==`, <br>&gt;&gt; ///   which will be used in contexts where the static type is<br>&gt;&gt; ///   known to the compiler.<br>&gt;&gt; /// - Note: Generic code should usually use `==` to compare <br>&gt;&gt; ///   conforming instances; that will always dispatch to `===` <br>&gt;&gt; ///   and will be unaffected by more specific overloads of<br>&gt;&gt; ///   `==`.<br>&gt;&gt; protocol Identifiable { // née Equatable name is negotiable<br>&gt;&gt;   func ===(_: Self, _: aSelf) -&gt; Bool<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; /// Default definition of `==` for Identifiable types.<br>&gt;&gt; func ==&lt;T: Identifiable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;&gt;   return lhs === rhs<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; /// Conforming types have a default total ordering.<br>&gt;&gt; /// <br>&gt;&gt; /// If `a` and `b` are of type `Self`, `a &lt;=&gt; b` means that<br>&gt;&gt; /// `a` and `b` are interchangeable in most code.  A conforming <br>&gt;&gt; /// type can document that specific observable characteristics<br>&gt;&gt; /// (such as the `capacity` of an `Array`) are inessential and <br>&gt;&gt; /// thus not to be considered as part of the interchangeability <br>&gt;&gt; /// guarantee.<br>&gt;&gt; ///<br>&gt;&gt; /// - Requires: `&lt;=&gt;` induces a total ordering over<br>&gt;&gt; ///   instances.<br>&gt;&gt; /// - Requires: the semantics of `&lt;=&gt;` are  consistent with<br>&gt;&gt; ///   those of `===`.  That is, `(a &lt;=&gt; b) == .equivalent` <br>&gt;&gt; ///   iff `a === b`.<br>&gt;&gt; /// - Note: conforming types will gain `&lt;`, `&lt;=`, `&gt;`, and `&gt;=` <br>&gt;&gt; ///   operators defined in terms of `&lt;=&gt;`.  <br>&gt;&gt; /// - Note: Types that require domain-specific `&lt;`, etc.<br>&gt;&gt; ///   implementations with different semantics (e.g. floating <br>&gt;&gt; ///   point) should define more-specific overloads of those <br>&gt;&gt; ///   operators, which will be used in contexts where the <br>&gt;&gt; ///   static type is known to the compiler.<br>&gt;&gt; /// - Note: Generic code can freely use `&lt;=&gt;` or the traditional<br>&gt;&gt; ///   comparison operators to compare conforming instances; <br>&gt;&gt; ///   the result will always be supplied by `&lt;=&gt;` <br>&gt;&gt; ///   and will be unaffected by more specific overloads of<br>&gt;&gt; ///   the other operators.<br>&gt;&gt; protocol Comparable : Identifiable {<br>&gt;&gt;   func &lt;=&gt; (lhs: Self, rhs: Self) -&gt; Ordering<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; /// Default implementations of `&lt;`, `&lt;=`, `&gt;`, and `&gt;=`.<br>&gt;&gt; extension Comparable {<br>&gt;&gt;   static func &lt;(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;     return (lhs &lt;=&gt; rhs) == .ascending<br>&gt;&gt;   }<br>&gt;&gt;   static func &lt;=(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;     return (rhs &lt;=&gt; lhs) != .ascending<br>&gt;&gt;   }<br>&gt;&gt;   static func &gt;(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;     return (lhs &lt;=&gt; rhs) == .descending<br>&gt;&gt;   }<br>&gt;&gt;   static func &gt;=(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;     return (rhs &lt;=&gt; lhs) != .descending<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt;&gt; I like this idea. If we keep === as a separate thing, now users have 3 “opportunities” to define<br>&gt;&gt;&gt; equality. The must be few, if any, use cases for this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Would love to see if anyone on the list can give us an example. Otherwise we should make<br>&gt;&gt;&gt; areSame === again™!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Daniel Duan<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jul 21, 2016, at 6:32 PM, Robert Widmann via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jul 21, 2016, at 6:19 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This is nice. Is `areSame()` being proposed because static `==` is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the status quo and you&#39;re trying to make the point that `==` in the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; future need not guarantee the same semantics?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yep!  Equivalence and equality are strictly very different things.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Nit: I think the more common term in stdlib would be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; `areEquivalent()`. Do you think `same` in that context (independent<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of the word &quot;ordering&quot;) might erroneously suggest identity?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There is room for improvement here.  Keep ‘em coming.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Thu, Jul 21, 2016 at 8:11 PM, Robert Widmann via<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello Swift Community,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Harlan Haskins, Jaden Geller, and I have been working on a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; proposal to clean up the semantics of ordering relations in the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; standard library.  We have a draft that you can get as a gist.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Any feedback you might have about this proposal helps - though<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; please keeps your comments on Swift-Evolution and not on the gist.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt;&gt; Dave<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; Dave<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Dave<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July 22, 2016 at 06:00:00pm</p></header><div class="content"><p>on Fri Jul 22 2016, Jaden Geller &lt;jaden.geller-AT-gmail.com&gt; wrote:<br></p><p>&gt; I really like this idea. I was initially opposed to changing the<br>&gt; behavior of `===`, but I think I&#39;m for it now. Though there have been<br>&gt; quite a few situations where I specifically want reference identity,<br>&gt; in these situations I would not override the `===` operator anyway;<br>&gt; these objects were identified by their reference.<br>&gt;<br>&gt; I think this refinement of the proposal makes the semantics easier to<br>&gt; reason about, and nicely repurposes the `===` operator instead of<br>&gt; introducing a new 3rd notion of equality. If users explicitly want to<br>&gt; compare references, it isn&#39;t difficult to create an<br>&gt; `ObjectIdentifier`, and it probably leads to clearer code in cases<br>&gt; where the object identity isn&#39;t defined by it&#39;s reference.<br>&gt;<br>&gt; Could types that conform to `Comparable` not get a default implementation of `===`?<br></p><p>Yes they could.  In fact I meant to write it and left it out.  And the<br>docs should say don&#39;t provide your own definition of `===` for a<br>Comparable type unless its semantics match the default.<br></p><p>&gt;&gt; On Jul 22, 2016, at 6:20 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Fri Jul 22 2016, Daniel Duan &lt;daniel-AT-duan.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jul 22, 2016, at 3:00 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Fri Jul 22 2016, Daniel Duan &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jul 22, 2016, at 11:05 AM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; on Thu Jul 21 2016, Duan<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Great proposal. I want to second that areSame may mislead user to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; think this is about identity.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I like areEquivalent() but there may be better names.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It really *is* about identity as I posted in a previous message.  But<br>&gt;&gt;&gt;&gt;&gt;&gt; that doesn&#39;t change the fact that areEquivalent might be a better name.<br>&gt;&gt;&gt;&gt;&gt;&gt; It&#39;s one of the things we considered; it just seemed long for no real<br>&gt;&gt;&gt;&gt;&gt;&gt; benefit.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If the addresses of the arguments aren’t being used, then we don’t consider<br>&gt;&gt;&gt;&gt;&gt; them part of their *identity*. I can follow this logic. My fear is most users<br>&gt;&gt;&gt;&gt;&gt; won’t make this leap on their own and get the same initial impression as I did.<br>&gt;&gt;&gt;&gt;&gt; It&#39;s entirely possible this fear is unfounded. Some educated bikesheding<br>&gt;&gt;&gt;&gt;&gt; wouldn&#39;t hurt here IMO :)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Well, it&#39;s still a very real question whether we ought to have the<br>&gt;&gt;&gt;&gt; additional API surface implied by areSame, or wether we should collapse<br>&gt;&gt;&gt;&gt; it with ===.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To spell this out (because I had to think about it for a second): === will be derived from<br>&gt;&gt;&gt; &lt;=&gt;, <br>&gt;&gt;&gt; but also becomes default implementation for ==, which remains open for<br>&gt;&gt;&gt; customization.<br>&gt;&gt; <br>&gt;&gt; I was imagining roughly this (untested):<br>&gt;&gt; <br>&gt;&gt;  /// Two references are identical if they refer to the same<br>&gt;&gt;  /// instance.<br>&gt;&gt;  ///<br>&gt;&gt;  /// - Note: Classes with a more-refined notion of “identical” <br>&gt;&gt;  ///   should conform to `Identifiable` and implement `===`.<br>&gt;&gt;  func ===(lhs: AnyObject, rhs: AnyObject) -&gt; Bool {<br>&gt;&gt;    ObjectIdentifier(lhs) == ObjectIdentifier(rhs)<br>&gt;&gt;  }<br>&gt;&gt; <br>&gt;&gt;  /// Supports testing that two values of `Self` are identical<br>&gt;&gt;  ///<br>&gt;&gt;  /// If `a` and `b` are of type `Self`, `a === b` means that<br>&gt;&gt;  /// `a` and `b` are interchangeable in most code.  A conforming <br>&gt;&gt;  /// type can document that specific observable characteristics<br>&gt;&gt;  /// (such as the `capacity` of an `Array`) are inessential and <br>&gt;&gt;  /// thus not to be considered as part of the interchangeability <br>&gt;&gt;  /// guarantee.<br>&gt;&gt;  ///<br>&gt;&gt;  /// - Requires: `===` induces an equivalence relation over<br>&gt;&gt;  ///   instances.<br>&gt;&gt;  /// - Note: conforming types will gain an `==` operator that <br>&gt;&gt;  ///   forwards to `===`.  <br>&gt;&gt;  /// - Note: Types that require domain-specific `==` <br>&gt;&gt;  ///   implementations with different semantics (e.g. floating <br>&gt;&gt;  ///   point) should define a more-specific overload of `==`, <br>&gt;&gt;  ///   which will be used in contexts where the static type is<br>&gt;&gt;  ///   known to the compiler.<br>&gt;&gt;  /// - Note: Generic code should usually use `==` to compare <br>&gt;&gt;  ///   conforming instances; that will always dispatch to `===` <br>&gt;&gt;  ///   and will be unaffected by more specific overloads of<br>&gt;&gt;  ///   `==`.<br>&gt;&gt;  protocol Identifiable { // née Equatable name is negotiable<br>&gt;&gt;    func ===(_: Self, _: aSelf) -&gt; Bool<br>&gt;&gt;  }<br>&gt;&gt; <br>&gt;&gt;  /// Default definition of `==` for Identifiable types.<br>&gt;&gt;  func ==&lt;T: Identifiable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;&gt;    return lhs === rhs<br>&gt;&gt;  }<br>&gt;&gt; <br>&gt;&gt;  /// Conforming types have a default total ordering.<br>&gt;&gt;  /// <br>&gt;&gt;  /// If `a` and `b` are of type `Self`, `a &lt;=&gt; b` means that<br>&gt;&gt;  /// `a` and `b` are interchangeable in most code.  A conforming <br>&gt;&gt;  /// type can document that specific observable characteristics<br>&gt;&gt;  /// (such as the `capacity` of an `Array`) are inessential and <br>&gt;&gt;  /// thus not to be considered as part of the interchangeability <br>&gt;&gt;  /// guarantee.<br>&gt;&gt;  ///<br>&gt;&gt;  /// - Requires: `&lt;=&gt;` induces a total ordering over<br>&gt;&gt;  ///   instances.<br>&gt;&gt;  /// - Requires: the semantics of `&lt;=&gt;` are  consistent with<br>&gt;&gt;  ///   those of `===`.  That is, `(a &lt;=&gt; b) == .equivalent` <br>&gt;&gt;  ///   iff `a === b`.<br>&gt;&gt;  /// - Note: conforming types will gain `&lt;`, `&lt;=`, `&gt;`, and `&gt;=` <br>&gt;&gt;  ///   operators defined in terms of `&lt;=&gt;`.  <br>&gt;&gt;  /// - Note: Types that require domain-specific `&lt;`, etc.<br>&gt;&gt;  ///   implementations with different semantics (e.g. floating <br>&gt;&gt;  ///   point) should define more-specific overloads of those <br>&gt;&gt;  ///   operators, which will be used in contexts where the <br>&gt;&gt;  ///   static type is known to the compiler.<br>&gt;&gt;  /// - Note: Generic code can freely use `&lt;=&gt;` or the traditional<br>&gt;&gt;  ///   comparison operators to compare conforming instances; <br>&gt;&gt;  ///   the result will always be supplied by `&lt;=&gt;` <br>&gt;&gt;  ///   and will be unaffected by more specific overloads of<br>&gt;&gt;  ///   the other operators.<br>&gt;&gt;  protocol Comparable : Identifiable {<br>&gt;&gt;    func &lt;=&gt; (lhs: Self, rhs: Self) -&gt; Ordering<br>&gt;&gt;  }<br>&gt;&gt; <br>&gt;&gt;  /// Default implementations of `&lt;`, `&lt;=`, `&gt;`, and `&gt;=`.<br>&gt;&gt;  extension Comparable {<br>&gt;&gt;    static func &lt;(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;      return (lhs &lt;=&gt; rhs) == .ascending<br>&gt;&gt;    }<br>&gt;&gt;    static func &lt;=(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;      return (rhs &lt;=&gt; lhs) != .ascending<br>&gt;&gt;    }<br>&gt;&gt;    static func &gt;(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;      return (lhs &lt;=&gt; rhs) == .descending<br>&gt;&gt;    }<br>&gt;&gt;    static func &gt;=(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;      return (rhs &lt;=&gt; lhs) != .descending<br>&gt;&gt;    }<br>&gt;&gt;  }<br>&gt;&gt; <br>&gt;&gt;&gt; I like this idea. If we keep === as a separate thing, now users have 3 “opportunities” to define<br>&gt;&gt;&gt; equality. The must be few, if any, use cases for this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Would love to see if anyone on the list can give us an example. Otherwise we should make<br>&gt;&gt;&gt; areSame === again™!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Daniel Duan<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jul 21, 2016, at 6:32 PM, Robert Widmann via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jul 21, 2016, at 6:19 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This is nice. Is `areSame()` being proposed because static `==` is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the status quo and you&#39;re trying to make the point that `==` in the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; future need not guarantee the same semantics?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yep!  Equivalence and equality are strictly very different things.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Nit: I think the more common term in stdlib would be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; `areEquivalent()`. Do you think `same` in that context (independent<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of the word &quot;ordering&quot;) might erroneously suggest identity?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There is room for improvement here.  Keep ‘em coming.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Thu, Jul 21, 2016 at 8:11 PM, Robert Widmann via<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello Swift Community,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Harlan Haskins, Jaden Geller, and I have been working on a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; proposal to clean up the semantics of ordering relations in the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; standard library.  We have a draft that you can get as a gist.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Any feedback you might have about this proposal helps - though<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; please keeps your comments on Swift-Evolution and not on the gist.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt;&gt; Dave<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; Dave<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Dave<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>Dave<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 22, 2016 at 08:00:00pm</p></header><div class="content"><p>On Fri, Jul 22, 2016 at 8:20 PM, Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; on Fri Jul 22 2016, Daniel Duan &lt;daniel-AT-duan.org&gt; wrote:<br>&gt;<br>&gt; &gt;&gt; On Jul 22, 2016, at 3:00 PM, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; on Fri Jul 22 2016, Daniel Duan &lt;swift-evolution at swift.org &lt;mailto:<br>&gt; swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;<br>&gt; &gt;&gt;&gt;&gt; On Jul 22, 2016, at 11:05 AM, Dave Abrahams via swift-evolution<br>&gt; &gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; on Thu Jul 21 2016, Duan<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Great proposal. I want to second that areSame may mislead user to<br>&gt; &gt;&gt;&gt;&gt;&gt; think this is about identity.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; I like areEquivalent() but there may be better names.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; It really *is* about identity as I posted in a previous message.  But<br>&gt; &gt;&gt;&gt;&gt; that doesn&#39;t change the fact that areEquivalent might be a better<br>&gt; name.<br>&gt; &gt;&gt;&gt;&gt; It&#39;s one of the things we considered; it just seemed long for no real<br>&gt; &gt;&gt;&gt;&gt; benefit.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; If the addresses of the arguments aren’t being used, then we don’t<br>&gt; consider<br>&gt; &gt;&gt;&gt; them part of their *identity*. I can follow this logic. My fear is<br>&gt; most users<br>&gt; &gt;&gt;&gt; won’t make this leap on their own and get the same initial impression<br>&gt; as I did.<br>&gt; &gt;&gt;&gt; It&#39;s entirely possible this fear is unfounded. Some educated<br>&gt; bikesheding<br>&gt; &gt;&gt;&gt; wouldn&#39;t hurt here IMO :)<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Well, it&#39;s still a very real question whether we ought to have the<br>&gt; &gt;&gt; additional API surface implied by areSame, or wether we should collapse<br>&gt; &gt;&gt; it with ===.<br>&gt; &gt;&gt;<br>&gt; &gt;<br>&gt; &gt; To spell this out (because I had to think about it for a second): ===<br>&gt; will be derived from<br>&gt; &gt; &lt;=&gt;,<br>&gt; &gt; but also becomes default implementation for ==, which remains open for<br>&gt; &gt; customization.<br>&gt;<br>&gt; I was imagining roughly this (untested):<br>&gt;<br>&gt;   /// Two references are identical if they refer to the same<br>&gt;   /// instance.<br>&gt;   ///<br>&gt;   /// - Note: Classes with a more-refined notion of “identical”<br>&gt;   ///   should conform to `Identifiable` and implement `===`.<br>&gt;   func ===(lhs: AnyObject, rhs: AnyObject) -&gt; Bool {<br>&gt;     ObjectIdentifier(lhs) == ObjectIdentifier(rhs)<br>&gt;   }<br>&gt;<br>&gt;   /// Supports testing that two values of `Self` are identical<br>&gt;   ///<br>&gt;   /// If `a` and `b` are of type `Self`, `a === b` means that<br>&gt;   /// `a` and `b` are interchangeable in most code.  A conforming<br>&gt;   /// type can document that specific observable characteristics<br>&gt;   /// (such as the `capacity` of an `Array`) are inessential and<br>&gt;   /// thus not to be considered as part of the interchangeability<br>&gt;   /// guarantee.<br>&gt;   ///<br>&gt;   /// - Requires: `===` induces an equivalence relation over<br>&gt;   ///   instances.<br>&gt;   /// - Note: conforming types will gain an `==` operator that<br>&gt;   ///   forwards to `===`.<br>&gt;   /// - Note: Types that require domain-specific `==`<br>&gt;   ///   implementations with different semantics (e.g. floating<br>&gt;   ///   point) should define a more-specific overload of `==`,<br>&gt;   ///   which will be used in contexts where the static type is<br>&gt;   ///   known to the compiler.<br>&gt;   /// - Note: Generic code should usually use `==` to compare<br>&gt;   ///   conforming instances; that will always dispatch to `===`<br>&gt;   ///   and will be unaffected by more specific overloads of<br>&gt;   ///   `==`.<br>&gt;   protocol Identifiable { // née Equatable name is negotiable<br>&gt;     func ===(_: Self, _: aSelf) -&gt; Bool<br>&gt;   }<br>&gt;<br>&gt;   /// Default definition of `==` for Identifiable types.<br>&gt;   func ==&lt;T: Identifiable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;     return lhs === rhs<br>&gt;   }<br>&gt;<br>&gt;   /// Conforming types have a default total ordering.<br>&gt;   ///<br>&gt;   /// If `a` and `b` are of type `Self`, `a &lt;=&gt; b` means that<br>&gt;   /// `a` and `b` are interchangeable in most code.  A conforming<br>&gt;   /// type can document that specific observable characteristics<br>&gt;   /// (such as the `capacity` of an `Array`) are inessential and<br>&gt;   /// thus not to be considered as part of the interchangeability<br>&gt;   /// guarantee.<br>&gt;   ///<br>&gt;   /// - Requires: `&lt;=&gt;` induces a total ordering over<br>&gt;   ///   instances.<br>&gt;   /// - Requires: the semantics of `&lt;=&gt;` are  consistent with<br>&gt;   ///   those of `===`.  That is, `(a &lt;=&gt; b) == .equivalent`<br>&gt;   ///   iff `a === b`.<br>&gt;<br></p><p>For floating point, I&#39;d hope that `a === b` if `(a &lt;=&gt; b) == .same` *but<br>not iff*. This is to satisfy IEEE 754: &quot;Comparisons shall ignore the sign<br>of zero (so +0 = −0)&quot;.<br></p><p><br>&gt;   /// - Note: conforming types will gain `&lt;`, `&lt;=`, `&gt;`, and `&gt;=`<br>&gt;   ///   operators defined in terms of `&lt;=&gt;`.<br>&gt;   /// - Note: Types that require domain-specific `&lt;`, etc.<br>&gt;   ///   implementations with different semantics (e.g. floating<br>&gt;   ///   point) should define more-specific overloads of those<br>&gt;   ///   operators, which will be used in contexts where the<br>&gt;   ///   static type is known to the compiler.<br>&gt;   /// - Note: Generic code can freely use `&lt;=&gt;` or the traditional<br>&gt;   ///   comparison operators to compare conforming instances;<br>&gt;   ///   the result will always be supplied by `&lt;=&gt;`<br>&gt;   ///   and will be unaffected by more specific overloads of<br>&gt;   ///   the other operators.<br>&gt;   protocol Comparable : Identifiable {<br>&gt;     func &lt;=&gt; (lhs: Self, rhs: Self) -&gt; Ordering<br>&gt;   }<br>&gt;<br>&gt;   /// Default implementations of `&lt;`, `&lt;=`, `&gt;`, and `&gt;=`.<br>&gt;   extension Comparable {<br>&gt;     static func &lt;(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;       return (lhs &lt;=&gt; rhs) == .ascending<br>&gt;     }<br>&gt;     static func &lt;=(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;       return (rhs &lt;=&gt; lhs) != .ascending<br>&gt;     }<br>&gt;     static func &gt;(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;       return (lhs &lt;=&gt; rhs) == .descending<br>&gt;     }<br>&gt;     static func &gt;=(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;       return (rhs &lt;=&gt; lhs) != .descending<br>&gt;     }<br>&gt;   }<br>&gt;<br>&gt; &gt; I like this idea. If we keep === as a separate thing, now users have 3<br>&gt; “opportunities” to define<br>&gt; &gt; equality. The must be few, if any, use cases for this.<br>&gt; &gt;<br>&gt; &gt; Would love to see if anyone on the list can give us an example.<br>&gt; Otherwise we should make<br>&gt; &gt; areSame === again™!<br>&gt; &gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Daniel Duan<br>&gt; &gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; On Jul 21, 2016, at 6:32 PM, Robert Widmann via swift-evolution<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jul 21, 2016, at 6:19 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt;<br>&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; This is nice. Is `areSame()` being proposed because static `==` is<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; the status quo and you&#39;re trying to make the point that `==` in the<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; future need not guarantee the same semantics?<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; Yep!  Equivalence and equality are strictly very different things.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; Nit: I think the more common term in stdlib would be<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; `areEquivalent()`. Do you think `same` in that context (independent<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; of the word &quot;ordering&quot;) might erroneously suggest identity?<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; There is room for improvement here.  Keep ‘em coming.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Thu, Jul 21, 2016 at 8:11 PM, Robert Widmann via<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello Swift Community,<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Harlan Haskins, Jaden Geller, and I have been working on a<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; proposal to clean up the semantics of ordering relations in the<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; standard library.  We have a draft that you can get as a gist.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Any feedback you might have about this proposal helps - though<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; please keeps your comments on Swift-Evolution and not on the gist.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; --<br>&gt; &gt;&gt;&gt;&gt; Dave<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt; &gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; --<br>&gt; &gt;&gt; Dave<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;<br>&gt; --<br>&gt; Dave<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/c0032854/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e95942f1fe843f007ef5430b9acff78b?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Jaden Geller</string> &lt;jaden.geller at gmail.com&gt;<p>July 22, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; For floating point, I&#39;d hope that `a === b` if `(a &lt;=&gt; b) == .same` *but not iff*. This is to satisfy IEEE 754: &quot;Comparisons shall ignore the sign of zero (so +0 = −0)&quot;.<br></p><p>I don&#39;t see why both `(+0) === (-0)` and `(+0) &lt;=&gt; (-0)` can&#39;t return `true` and `.same`, respectively. This doesn&#39;t break the total ordering of values. `===` doesn&#39;t do raw memory comparison. They&#39;re &quot;identical&quot;, so it ought to return `true`.<br></p><p>&gt; On Jul 22, 2016, at 6:37 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Fri, Jul 22, 2016 at 8:20 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; on Fri Jul 22 2016, Daniel Duan &lt;daniel-AT-duan.org&gt; wrote:<br>&gt; <br>&gt; &gt;&gt; On Jul 22, 2016, at 3:00 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; on Fri Jul 22 2016, Daniel Duan &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;<br>&gt; &gt;&gt;&gt;&gt; On Jul 22, 2016, at 11:05 AM, Dave Abrahams via swift-evolution<br>&gt; &gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; on Thu Jul 21 2016, Duan<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Great proposal. I want to second that areSame may mislead user to<br>&gt; &gt;&gt;&gt;&gt;&gt; think this is about identity.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; I like areEquivalent() but there may be better names.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; It really *is* about identity as I posted in a previous message.  But<br>&gt; &gt;&gt;&gt;&gt; that doesn&#39;t change the fact that areEquivalent might be a better name.<br>&gt; &gt;&gt;&gt;&gt; It&#39;s one of the things we considered; it just seemed long for no real<br>&gt; &gt;&gt;&gt;&gt; benefit.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; If the addresses of the arguments aren’t being used, then we don’t consider<br>&gt; &gt;&gt;&gt; them part of their *identity*. I can follow this logic. My fear is most users<br>&gt; &gt;&gt;&gt; won’t make this leap on their own and get the same initial impression as I did.<br>&gt; &gt;&gt;&gt; It&#39;s entirely possible this fear is unfounded. Some educated bikesheding<br>&gt; &gt;&gt;&gt; wouldn&#39;t hurt here IMO :)<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Well, it&#39;s still a very real question whether we ought to have the<br>&gt; &gt;&gt; additional API surface implied by areSame, or wether we should collapse<br>&gt; &gt;&gt; it with ===.<br>&gt; &gt;&gt;<br>&gt; &gt;<br>&gt; &gt; To spell this out (because I had to think about it for a second): === will be derived from<br>&gt; &gt; &lt;=&gt;,<br>&gt; &gt; but also becomes default implementation for ==, which remains open for<br>&gt; &gt; customization.<br>&gt; <br>&gt; I was imagining roughly this (untested):<br>&gt; <br>&gt;   /// Two references are identical if they refer to the same<br>&gt;   /// instance.<br>&gt;   ///<br>&gt;   /// - Note: Classes with a more-refined notion of “identical”<br>&gt;   ///   should conform to `Identifiable` and implement `===`.<br>&gt;   func ===(lhs: AnyObject, rhs: AnyObject) -&gt; Bool {<br>&gt;     ObjectIdentifier(lhs) == ObjectIdentifier(rhs)<br>&gt;   }<br>&gt; <br>&gt;   /// Supports testing that two values of `Self` are identical<br>&gt;   ///<br>&gt;   /// If `a` and `b` are of type `Self`, `a === b` means that<br>&gt;   /// `a` and `b` are interchangeable in most code.  A conforming<br>&gt;   /// type can document that specific observable characteristics<br>&gt;   /// (such as the `capacity` of an `Array`) are inessential and<br>&gt;   /// thus not to be considered as part of the interchangeability<br>&gt;   /// guarantee.<br>&gt;   ///<br>&gt;   /// - Requires: `===` induces an equivalence relation over<br>&gt;   ///   instances.<br>&gt;   /// - Note: conforming types will gain an `==` operator that<br>&gt;   ///   forwards to `===`.<br>&gt;   /// - Note: Types that require domain-specific `==`<br>&gt;   ///   implementations with different semantics (e.g. floating<br>&gt;   ///   point) should define a more-specific overload of `==`,<br>&gt;   ///   which will be used in contexts where the static type is<br>&gt;   ///   known to the compiler.<br>&gt;   /// - Note: Generic code should usually use `==` to compare<br>&gt;   ///   conforming instances; that will always dispatch to `===`<br>&gt;   ///   and will be unaffected by more specific overloads of<br>&gt;   ///   `==`.<br>&gt;   protocol Identifiable { // née Equatable name is negotiable<br>&gt;     func ===(_: Self, _: aSelf) -&gt; Bool<br>&gt;   }<br>&gt; <br>&gt;   /// Default definition of `==` for Identifiable types.<br>&gt;   func ==&lt;T: Identifiable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;     return lhs === rhs<br>&gt;   }<br>&gt; <br>&gt;   /// Conforming types have a default total ordering.<br>&gt;   ///<br>&gt;   /// If `a` and `b` are of type `Self`, `a &lt;=&gt; b` means that<br>&gt;   /// `a` and `b` are interchangeable in most code.  A conforming<br>&gt;   /// type can document that specific observable characteristics<br>&gt;   /// (such as the `capacity` of an `Array`) are inessential and<br>&gt;   /// thus not to be considered as part of the interchangeability<br>&gt;   /// guarantee.<br>&gt;   ///<br>&gt;   /// - Requires: `&lt;=&gt;` induces a total ordering over<br>&gt;   ///   instances.<br>&gt;   /// - Requires: the semantics of `&lt;=&gt;` are  consistent with<br>&gt;   ///   those of `===`.  That is, `(a &lt;=&gt; b) == .equivalent`<br>&gt;   ///   iff `a === b`.<br>&gt; <br>&gt; For floating point, I&#39;d hope that `a === b` if `(a &lt;=&gt; b) == .same` *but not iff*. This is to satisfy IEEE 754: &quot;Comparisons shall ignore the sign of zero (so +0 = −0)&quot;.<br>&gt;  <br>&gt;   /// - Note: conforming types will gain `&lt;`, `&lt;=`, `&gt;`, and `&gt;=`<br>&gt;   ///   operators defined in terms of `&lt;=&gt;`.<br>&gt;   /// - Note: Types that require domain-specific `&lt;`, etc.<br>&gt;   ///   implementations with different semantics (e.g. floating<br>&gt;   ///   point) should define more-specific overloads of those<br>&gt;   ///   operators, which will be used in contexts where the<br>&gt;   ///   static type is known to the compiler.<br>&gt;   /// - Note: Generic code can freely use `&lt;=&gt;` or the traditional<br>&gt;   ///   comparison operators to compare conforming instances;<br>&gt;   ///   the result will always be supplied by `&lt;=&gt;`<br>&gt;   ///   and will be unaffected by more specific overloads of<br>&gt;   ///   the other operators.<br>&gt;   protocol Comparable : Identifiable {<br>&gt;     func &lt;=&gt; (lhs: Self, rhs: Self) -&gt; Ordering<br>&gt;   }<br>&gt; <br>&gt;   /// Default implementations of `&lt;`, `&lt;=`, `&gt;`, and `&gt;=`.<br>&gt;   extension Comparable {<br>&gt;     static func &lt;(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;       return (lhs &lt;=&gt; rhs) == .ascending<br>&gt;     }<br>&gt;     static func &lt;=(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;       return (rhs &lt;=&gt; lhs) != .ascending<br>&gt;     }<br>&gt;     static func &gt;(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;       return (lhs &lt;=&gt; rhs) == .descending<br>&gt;     }<br>&gt;     static func &gt;=(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;       return (rhs &lt;=&gt; lhs) != .descending<br>&gt;     }<br>&gt;   }<br>&gt; <br>&gt; &gt; I like this idea. If we keep === as a separate thing, now users have 3 “opportunities” to define<br>&gt; &gt; equality. The must be few, if any, use cases for this.<br>&gt; &gt;<br>&gt; &gt; Would love to see if anyone on the list can give us an example. Otherwise we should make<br>&gt; &gt; areSame === again™!<br>&gt; &gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Daniel Duan<br>&gt; &gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; On Jul 21, 2016, at 6:32 PM, Robert Widmann via swift-evolution<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jul 21, 2016, at 6:19 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; This is nice. Is `areSame()` being proposed because static `==` is<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; the status quo and you&#39;re trying to make the point that `==` in the<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; future need not guarantee the same semantics?<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; Yep!  Equivalence and equality are strictly very different things.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; Nit: I think the more common term in stdlib would be<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; `areEquivalent()`. Do you think `same` in that context (independent<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; of the word &quot;ordering&quot;) might erroneously suggest identity?<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; There is room for improvement here.  Keep ‘em coming.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Thu, Jul 21, 2016 at 8:11 PM, Robert Widmann via<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello Swift Community,<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Harlan Haskins, Jaden Geller, and I have been working on a<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; proposal to clean up the semantics of ordering relations in the<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; standard library.  We have a draft that you can get as a gist.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Any feedback you might have about this proposal helps - though<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; please keeps your comments on Swift-Evolution and not on the gist.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; --<br>&gt; &gt;&gt;&gt;&gt; Dave<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; --<br>&gt; &gt;&gt; Dave<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt; <br>&gt; --<br>&gt; Dave<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/5e1b669d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 22, 2016 at 08:00:00pm</p></header><div class="content"><p>On Fri, Jul 22, 2016 at 8:42 PM, Jaden Geller &lt;jaden.geller at gmail.com&gt;<br>wrote:<br></p><p>&gt; For floating point, I&#39;d hope that `a === b` if `(a &lt;=&gt; b) == .same` *but<br>&gt; not iff*. This is to satisfy IEEE 754: &quot;Comparisons shall ignore the sign<br>&gt; of zero (so +0 = −0)&quot;.<br>&gt;<br>&gt;<br>&gt; I don&#39;t see why both `(+0) === (-0)` and `(+0) &lt;=&gt; (-0)` can&#39;t return<br>&gt; `true` and `.same`, respectively.<br>&gt;<br></p><p>IEEE 754 also demands that the total ordering place -0 below +0.<br></p><p><br>&gt; This doesn&#39;t break the total ordering of values. `===` doesn&#39;t do raw<br>&gt; memory comparison. They&#39;re &quot;identical&quot;, so it ought to return `true`.<br>&gt;<br>&gt;<br>&gt; On Jul 22, 2016, at 6:37 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Fri, Jul 22, 2016 at 8:20 PM, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; on Fri Jul 22 2016, Daniel Duan &lt;daniel-AT-duan.org<br>&gt;&gt; &lt;http://daniel-at-duan.org&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; &gt;&gt; On Jul 22, 2016, at 3:00 PM, Dave Abrahams via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; on Fri Jul 22 2016, Daniel Duan &lt;swift-evolution at swift.org &lt;mailto:<br>&gt;&gt; swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; On Jul 22, 2016, at 11:05 AM, Dave Abrahams via swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; on Thu Jul 21 2016, Duan<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; Great proposal. I want to second that areSame may mislead user to<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; think this is about identity.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; I like areEquivalent() but there may be better names.<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; It really *is* about identity as I posted in a previous message.  But<br>&gt;&gt; &gt;&gt;&gt;&gt; that doesn&#39;t change the fact that areEquivalent might be a better<br>&gt;&gt; name.<br>&gt;&gt; &gt;&gt;&gt;&gt; It&#39;s one of the things we considered; it just seemed long for no real<br>&gt;&gt; &gt;&gt;&gt;&gt; benefit.<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; If the addresses of the arguments aren’t being used, then we don’t<br>&gt;&gt; consider<br>&gt;&gt; &gt;&gt;&gt; them part of their *identity*. I can follow this logic. My fear is<br>&gt;&gt; most users<br>&gt;&gt; &gt;&gt;&gt; won’t make this leap on their own and get the same initial impression<br>&gt;&gt; as I did.<br>&gt;&gt; &gt;&gt;&gt; It&#39;s entirely possible this fear is unfounded. Some educated<br>&gt;&gt; bikesheding<br>&gt;&gt; &gt;&gt;&gt; wouldn&#39;t hurt here IMO :)<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Well, it&#39;s still a very real question whether we ought to have the<br>&gt;&gt; &gt;&gt; additional API surface implied by areSame, or wether we should collapse<br>&gt;&gt; &gt;&gt; it with ===.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; To spell this out (because I had to think about it for a second): ===<br>&gt;&gt; will be derived from<br>&gt;&gt; &gt; &lt;=&gt;,<br>&gt;&gt; &gt; but also becomes default implementation for ==, which remains open for<br>&gt;&gt; &gt; customization.<br>&gt;&gt;<br>&gt;&gt; I was imagining roughly this (untested):<br>&gt;&gt;<br>&gt;&gt;   /// Two references are identical if they refer to the same<br>&gt;&gt;   /// instance.<br>&gt;&gt;   ///<br>&gt;&gt;   /// - Note: Classes with a more-refined notion of “identical”<br>&gt;&gt;   ///   should conform to `Identifiable` and implement `===`.<br>&gt;&gt;   func ===(lhs: AnyObject, rhs: AnyObject) -&gt; Bool {<br>&gt;&gt;     ObjectIdentifier(lhs) == ObjectIdentifier(rhs)<br>&gt;&gt;   }<br>&gt;&gt;<br>&gt;&gt;   /// Supports testing that two values of `Self` are identical<br>&gt;&gt;   ///<br>&gt;&gt;   /// If `a` and `b` are of type `Self`, `a === b` means that<br>&gt;&gt;   /// `a` and `b` are interchangeable in most code.  A conforming<br>&gt;&gt;   /// type can document that specific observable characteristics<br>&gt;&gt;   /// (such as the `capacity` of an `Array`) are inessential and<br>&gt;&gt;   /// thus not to be considered as part of the interchangeability<br>&gt;&gt;   /// guarantee.<br>&gt;&gt;   ///<br>&gt;&gt;   /// - Requires: `===` induces an equivalence relation over<br>&gt;&gt;   ///   instances.<br>&gt;&gt;   /// - Note: conforming types will gain an `==` operator that<br>&gt;&gt;   ///   forwards to `===`.<br>&gt;&gt;   /// - Note: Types that require domain-specific `==`<br>&gt;&gt;   ///   implementations with different semantics (e.g. floating<br>&gt;&gt;   ///   point) should define a more-specific overload of `==`,<br>&gt;&gt;   ///   which will be used in contexts where the static type is<br>&gt;&gt;   ///   known to the compiler.<br>&gt;&gt;   /// - Note: Generic code should usually use `==` to compare<br>&gt;&gt;   ///   conforming instances; that will always dispatch to `===`<br>&gt;&gt;   ///   and will be unaffected by more specific overloads of<br>&gt;&gt;   ///   `==`.<br>&gt;&gt;   protocol Identifiable { // née Equatable name is negotiable<br>&gt;&gt;     func ===(_: Self, _: aSelf) -&gt; Bool<br>&gt;&gt;   }<br>&gt;&gt;<br>&gt;&gt;   /// Default definition of `==` for Identifiable types.<br>&gt;&gt;   func ==&lt;T: Identifiable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;&gt;     return lhs === rhs<br>&gt;&gt;   }<br>&gt;&gt;<br>&gt;&gt;   /// Conforming types have a default total ordering.<br>&gt;&gt;   ///<br>&gt;&gt;   /// If `a` and `b` are of type `Self`, `a &lt;=&gt; b` means that<br>&gt;&gt;   /// `a` and `b` are interchangeable in most code.  A conforming<br>&gt;&gt;   /// type can document that specific observable characteristics<br>&gt;&gt;   /// (such as the `capacity` of an `Array`) are inessential and<br>&gt;&gt;   /// thus not to be considered as part of the interchangeability<br>&gt;&gt;   /// guarantee.<br>&gt;&gt;   ///<br>&gt;&gt;   /// - Requires: `&lt;=&gt;` induces a total ordering over<br>&gt;&gt;   ///   instances.<br>&gt;&gt;   /// - Requires: the semantics of `&lt;=&gt;` are  consistent with<br>&gt;&gt;   ///   those of `===`.  That is, `(a &lt;=&gt; b) == .equivalent`<br>&gt;&gt;   ///   iff `a === b`.<br>&gt;&gt;<br>&gt;<br>&gt; For floating point, I&#39;d hope that `a === b` if `(a &lt;=&gt; b) == .same` *but<br>&gt; not iff*. This is to satisfy IEEE 754: &quot;Comparisons shall ignore the sign<br>&gt; of zero (so +0 = −0)&quot;.<br>&gt;<br>&gt;<br>&gt;&gt;   /// - Note: conforming types will gain `&lt;`, `&lt;=`, `&gt;`, and `&gt;=`<br>&gt;&gt;   ///   operators defined in terms of `&lt;=&gt;`.<br>&gt;&gt;   /// - Note: Types that require domain-specific `&lt;`, etc.<br>&gt;&gt;   ///   implementations with different semantics (e.g. floating<br>&gt;&gt;   ///   point) should define more-specific overloads of those<br>&gt;&gt;   ///   operators, which will be used in contexts where the<br>&gt;&gt;   ///   static type is known to the compiler.<br>&gt;&gt;   /// - Note: Generic code can freely use `&lt;=&gt;` or the traditional<br>&gt;&gt;   ///   comparison operators to compare conforming instances;<br>&gt;&gt;   ///   the result will always be supplied by `&lt;=&gt;`<br>&gt;&gt;   ///   and will be unaffected by more specific overloads of<br>&gt;&gt;   ///   the other operators.<br>&gt;&gt;   protocol Comparable : Identifiable {<br>&gt;&gt;     func &lt;=&gt; (lhs: Self, rhs: Self) -&gt; Ordering<br>&gt;&gt;   }<br>&gt;&gt;<br>&gt;&gt;   /// Default implementations of `&lt;`, `&lt;=`, `&gt;`, and `&gt;=`.<br>&gt;&gt;   extension Comparable {<br>&gt;&gt;     static func &lt;(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;       return (lhs &lt;=&gt; rhs) == .ascending<br>&gt;&gt;     }<br>&gt;&gt;     static func &lt;=(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;       return (rhs &lt;=&gt; lhs) != .ascending<br>&gt;&gt;     }<br>&gt;&gt;     static func &gt;(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;       return (lhs &lt;=&gt; rhs) == .descending<br>&gt;&gt;     }<br>&gt;&gt;     static func &gt;=(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;       return (rhs &lt;=&gt; lhs) != .descending<br>&gt;&gt;     }<br>&gt;&gt;   }<br>&gt;&gt;<br>&gt;&gt; &gt; I like this idea. If we keep === as a separate thing, now users have 3<br>&gt;&gt; “opportunities” to define<br>&gt;&gt; &gt; equality. The must be few, if any, use cases for this.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Would love to see if anyone on the list can give us an example.<br>&gt;&gt; Otherwise we should make<br>&gt;&gt; &gt; areSame === again™!<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; Daniel Duan<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; On Jul 21, 2016, at 6:32 PM, Robert Widmann via swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jul 21, 2016, at 6:19 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; This is nice. Is `areSame()` being proposed because static `==` is<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; the status quo and you&#39;re trying to make the point that `==` in<br>&gt;&gt; the<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; future need not guarantee the same semantics?<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; Yep!  Equivalence and equality are strictly very different things.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; Nit: I think the more common term in stdlib would be<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; `areEquivalent()`. Do you think `same` in that context<br>&gt;&gt; (independent<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; of the word &quot;ordering&quot;) might erroneously suggest identity?<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; There is room for improvement here.  Keep ‘em coming.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Thu, Jul 21, 2016 at 8:11 PM, Robert Widmann via<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello Swift Community,<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Harlan Haskins, Jaden Geller, and I have been working on a<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; proposal to clean up the semantics of ordering relations in the<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; standard library.  We have a draft that you can get as a gist.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Any feedback you might have about this proposal helps - though<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; please keeps your comments on Swift-Evolution and not on the<br>&gt;&gt; gist.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; --<br>&gt;&gt; &gt;&gt;&gt;&gt; Dave<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; --<br>&gt;&gt; &gt;&gt; Dave<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Dave<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/08160270/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July 22, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jul 22, 2016, at 8:43 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Fri, Jul 22, 2016 at 8:42 PM, Jaden Geller &lt;jaden.geller at gmail.com &lt;mailto:jaden.geller at gmail.com&gt;&gt; wrote:<br>&gt;&gt; For floating point, I&#39;d hope that `a === b` if `(a &lt;=&gt; b) == .same` *but not iff*. This is to satisfy IEEE 754: &quot;Comparisons shall ignore the sign of zero (so +0 = −0)&quot;.<br>&gt; <br>&gt; I don&#39;t see why both `(+0) === (-0)` and `(+0) &lt;=&gt; (-0)` can&#39;t return `true` and `.same`, respectively.<br>&gt; <br>&gt; IEEE 754 also demands that the total ordering place -0 below +0.<br></p><p>Is this the proposed total ordering for floats in Swift (sorry, I haven’t followed the details of that)?  If so then it appears they must have separate identity and thus `===` would consider the sign value.  You would need to use `==` if you want IEEE 754 domain specific comparison.<br></p><p>&gt;  <br>&gt; This doesn&#39;t break the total ordering of values. `===` doesn&#39;t do raw memory comparison. They&#39;re &quot;identical&quot;, so it ought to return `true`.<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 22, 2016, at 6:37 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Fri, Jul 22, 2016 at 8:20 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; on Fri Jul 22 2016, Daniel Duan &lt;daniel-AT-duan.org &lt;http://daniel-at-duan.org/&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt;&gt; On Jul 22, 2016, at 3:00 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; on Fri Jul 22 2016, Daniel Duan &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; On Jul 22, 2016, at 11:05 AM, Dave Abrahams via swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; on Thu Jul 21 2016, Duan<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; Great proposal. I want to second that areSame may mislead user to<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; think this is about identity.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; I like areEquivalent() but there may be better names.<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; It really *is* about identity as I posted in a previous message.  But<br>&gt;&gt; &gt;&gt;&gt;&gt; that doesn&#39;t change the fact that areEquivalent might be a better name.<br>&gt;&gt; &gt;&gt;&gt;&gt; It&#39;s one of the things we considered; it just seemed long for no real<br>&gt;&gt; &gt;&gt;&gt;&gt; benefit.<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; If the addresses of the arguments aren’t being used, then we don’t consider<br>&gt;&gt; &gt;&gt;&gt; them part of their *identity*. I can follow this logic. My fear is most users<br>&gt;&gt; &gt;&gt;&gt; won’t make this leap on their own and get the same initial impression as I did.<br>&gt;&gt; &gt;&gt;&gt; It&#39;s entirely possible this fear is unfounded. Some educated bikesheding<br>&gt;&gt; &gt;&gt;&gt; wouldn&#39;t hurt here IMO :)<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Well, it&#39;s still a very real question whether we ought to have the<br>&gt;&gt; &gt;&gt; additional API surface implied by areSame, or wether we should collapse<br>&gt;&gt; &gt;&gt; it with ===.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; To spell this out (because I had to think about it for a second): === will be derived from<br>&gt;&gt; &gt; &lt;=&gt;,<br>&gt;&gt; &gt; but also becomes default implementation for ==, which remains open for<br>&gt;&gt; &gt; customization.<br>&gt;&gt; <br>&gt;&gt; I was imagining roughly this (untested):<br>&gt;&gt; <br>&gt;&gt;   /// Two references are identical if they refer to the same<br>&gt;&gt;   /// instance.<br>&gt;&gt;   ///<br>&gt;&gt;   /// - Note: Classes with a more-refined notion of “identical”<br>&gt;&gt;   ///   should conform to `Identifiable` and implement `===`.<br>&gt;&gt;   func ===(lhs: AnyObject, rhs: AnyObject) -&gt; Bool {<br>&gt;&gt;     ObjectIdentifier(lhs) == ObjectIdentifier(rhs)<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   /// Supports testing that two values of `Self` are identical<br>&gt;&gt;   ///<br>&gt;&gt;   /// If `a` and `b` are of type `Self`, `a === b` means that<br>&gt;&gt;   /// `a` and `b` are interchangeable in most code.  A conforming<br>&gt;&gt;   /// type can document that specific observable characteristics<br>&gt;&gt;   /// (such as the `capacity` of an `Array`) are inessential and<br>&gt;&gt;   /// thus not to be considered as part of the interchangeability<br>&gt;&gt;   /// guarantee.<br>&gt;&gt;   ///<br>&gt;&gt;   /// - Requires: `===` induces an equivalence relation over<br>&gt;&gt;   ///   instances.<br>&gt;&gt;   /// - Note: conforming types will gain an `==` operator that<br>&gt;&gt;   ///   forwards to `===`.<br>&gt;&gt;   /// - Note: Types that require domain-specific `==`<br>&gt;&gt;   ///   implementations with different semantics (e.g. floating<br>&gt;&gt;   ///   point) should define a more-specific overload of `==`,<br>&gt;&gt;   ///   which will be used in contexts where the static type is<br>&gt;&gt;   ///   known to the compiler.<br>&gt;&gt;   /// - Note: Generic code should usually use `==` to compare<br>&gt;&gt;   ///   conforming instances; that will always dispatch to `===`<br>&gt;&gt;   ///   and will be unaffected by more specific overloads of<br>&gt;&gt;   ///   `==`.<br>&gt;&gt;   protocol Identifiable { // née Equatable name is negotiable<br>&gt;&gt;     func ===(_: Self, _: aSelf) -&gt; Bool<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   /// Default definition of `==` for Identifiable types.<br>&gt;&gt;   func ==&lt;T: Identifiable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;&gt;     return lhs === rhs<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   /// Conforming types have a default total ordering.<br>&gt;&gt;   ///<br>&gt;&gt;   /// If `a` and `b` are of type `Self`, `a &lt;=&gt; b` means that<br>&gt;&gt;   /// `a` and `b` are interchangeable in most code.  A conforming<br>&gt;&gt;   /// type can document that specific observable characteristics<br>&gt;&gt;   /// (such as the `capacity` of an `Array`) are inessential and<br>&gt;&gt;   /// thus not to be considered as part of the interchangeability<br>&gt;&gt;   /// guarantee.<br>&gt;&gt;   ///<br>&gt;&gt;   /// - Requires: `&lt;=&gt;` induces a total ordering over<br>&gt;&gt;   ///   instances.<br>&gt;&gt;   /// - Requires: the semantics of `&lt;=&gt;` are  consistent with<br>&gt;&gt;   ///   those of `===`.  That is, `(a &lt;=&gt; b) == .equivalent`<br>&gt;&gt;   ///   iff `a === b`.<br>&gt;&gt; <br>&gt;&gt; For floating point, I&#39;d hope that `a === b` if `(a &lt;=&gt; b) == .same` *but not iff*. This is to satisfy IEEE 754: &quot;Comparisons shall ignore the sign of zero (so +0 = −0)&quot;.<br>&gt;&gt;  <br>&gt;&gt;   /// - Note: conforming types will gain `&lt;`, `&lt;=`, `&gt;`, and `&gt;=`<br>&gt;&gt;   ///   operators defined in terms of `&lt;=&gt;`.<br>&gt;&gt;   /// - Note: Types that require domain-specific `&lt;`, etc.<br>&gt;&gt;   ///   implementations with different semantics (e.g. floating<br>&gt;&gt;   ///   point) should define more-specific overloads of those<br>&gt;&gt;   ///   operators, which will be used in contexts where the<br>&gt;&gt;   ///   static type is known to the compiler.<br>&gt;&gt;   /// - Note: Generic code can freely use `&lt;=&gt;` or the traditional<br>&gt;&gt;   ///   comparison operators to compare conforming instances;<br>&gt;&gt;   ///   the result will always be supplied by `&lt;=&gt;`<br>&gt;&gt;   ///   and will be unaffected by more specific overloads of<br>&gt;&gt;   ///   the other operators.<br>&gt;&gt;   protocol Comparable : Identifiable {<br>&gt;&gt;     func &lt;=&gt; (lhs: Self, rhs: Self) -&gt; Ordering<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   /// Default implementations of `&lt;`, `&lt;=`, `&gt;`, and `&gt;=`.<br>&gt;&gt;   extension Comparable {<br>&gt;&gt;     static func &lt;(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;       return (lhs &lt;=&gt; rhs) == .ascending<br>&gt;&gt;     }<br>&gt;&gt;     static func &lt;=(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;       return (rhs &lt;=&gt; lhs) != .ascending<br>&gt;&gt;     }<br>&gt;&gt;     static func &gt;(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;       return (lhs &lt;=&gt; rhs) == .descending<br>&gt;&gt;     }<br>&gt;&gt;     static func &gt;=(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;       return (rhs &lt;=&gt; lhs) != .descending<br>&gt;&gt;     }<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; &gt; I like this idea. If we keep === as a separate thing, now users have 3 “opportunities” to define<br>&gt;&gt; &gt; equality. The must be few, if any, use cases for this.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Would love to see if anyone on the list can give us an example. Otherwise we should make<br>&gt;&gt; &gt; areSame === again™!<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; Daniel Duan<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; On Jul 21, 2016, at 6:32 PM, Robert Widmann via swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jul 21, 2016, at 6:19 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; This is nice. Is `areSame()` being proposed because static `==` is<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; the status quo and you&#39;re trying to make the point that `==` in the<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; future need not guarantee the same semantics?<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; Yep!  Equivalence and equality are strictly very different things.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; Nit: I think the more common term in stdlib would be<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; `areEquivalent()`. Do you think `same` in that context (independent<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; of the word &quot;ordering&quot;) might erroneously suggest identity?<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; There is room for improvement here.  Keep ‘em coming.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Thu, Jul 21, 2016 at 8:11 PM, Robert Widmann via<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello Swift Community,<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Harlan Haskins, Jaden Geller, and I have been working on a<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; proposal to clean up the semantics of ordering relations in the<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; standard library.  We have a draft that you can get as a gist.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Any feedback you might have about this proposal helps - though<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; please keeps your comments on Swift-Evolution and not on the gist.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; --<br>&gt;&gt; &gt;&gt;&gt;&gt; Dave<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; --<br>&gt;&gt; &gt;&gt; Dave<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; Dave<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/8497ab97/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 22, 2016 at 08:00:00pm</p></header><div class="content"><p>On Fri, Jul 22, 2016 at 8:46 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; On Jul 22, 2016, at 8:43 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Fri, Jul 22, 2016 at 8:42 PM, Jaden Geller &lt;jaden.geller at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; For floating point, I&#39;d hope that `a === b` if `(a &lt;=&gt; b) == .same` *but<br>&gt;&gt; not iff*. This is to satisfy IEEE 754: &quot;Comparisons shall ignore the sign<br>&gt;&gt; of zero (so +0 = −0)&quot;.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I don&#39;t see why both `(+0) === (-0)` and `(+0) &lt;=&gt; (-0)` can&#39;t return<br>&gt;&gt; `true` and `.same`, respectively.<br>&gt;&gt;<br>&gt;<br>&gt; IEEE 754 also demands that the total ordering place -0 below +0.<br>&gt;<br>&gt;<br>&gt; Is this the proposed total ordering for floats in Swift (sorry, I haven’t<br>&gt; followed the details of that)?<br>&gt;<br></p><p>Yes, to the extent I understood the proposal.<br></p><p><br>&gt; If so then it appears they must have separate identity and thus `===`<br>&gt; would consider the sign value.  You would need to use `==` if you want IEEE<br>&gt; 754 domain specific comparison.<br>&gt;<br></p><p>That is one answer. It leads to Pyry&#39;s surprising result above though.<br></p><p><br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt; This doesn&#39;t break the total ordering of values. `===` doesn&#39;t do raw<br>&gt;&gt; memory comparison. They&#39;re &quot;identical&quot;, so it ought to return `true`.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Jul 22, 2016, at 6:37 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Fri, Jul 22, 2016 at 8:20 PM, Dave Abrahams via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; on Fri Jul 22 2016, Daniel Duan &lt;daniel-AT-duan.org<br>&gt;&gt;&gt; &lt;http://daniel-at-duan.org/&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; On Jul 22, 2016, at 3:00 PM, Dave Abrahams via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; on Fri Jul 22 2016, Daniel Duan &lt;swift-evolution at swift.org &lt;mailto:<br>&gt;&gt;&gt; swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; On Jul 22, 2016, at 11:05 AM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; on Thu Jul 21 2016, Duan<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; Great proposal. I want to second that areSame may mislead user to<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; think this is about identity.<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; I like areEquivalent() but there may be better names.<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; It really *is* about identity as I posted in a previous message.<br>&gt;&gt;&gt; But<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; that doesn&#39;t change the fact that areEquivalent might be a better<br>&gt;&gt;&gt; name.<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; It&#39;s one of the things we considered; it just seemed long for no<br>&gt;&gt;&gt; real<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; benefit.<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; If the addresses of the arguments aren’t being used, then we don’t<br>&gt;&gt;&gt; consider<br>&gt;&gt;&gt; &gt;&gt;&gt; them part of their *identity*. I can follow this logic. My fear is<br>&gt;&gt;&gt; most users<br>&gt;&gt;&gt; &gt;&gt;&gt; won’t make this leap on their own and get the same initial<br>&gt;&gt;&gt; impression as I did.<br>&gt;&gt;&gt; &gt;&gt;&gt; It&#39;s entirely possible this fear is unfounded. Some educated<br>&gt;&gt;&gt; bikesheding<br>&gt;&gt;&gt; &gt;&gt;&gt; wouldn&#39;t hurt here IMO :)<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; Well, it&#39;s still a very real question whether we ought to have the<br>&gt;&gt;&gt; &gt;&gt; additional API surface implied by areSame, or wether we should<br>&gt;&gt;&gt; collapse<br>&gt;&gt;&gt; &gt;&gt; it with ===.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; To spell this out (because I had to think about it for a second): ===<br>&gt;&gt;&gt; will be derived from<br>&gt;&gt;&gt; &gt; &lt;=&gt;,<br>&gt;&gt;&gt; &gt; but also becomes default implementation for ==, which remains open for<br>&gt;&gt;&gt; &gt; customization.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I was imagining roughly this (untested):<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   /// Two references are identical if they refer to the same<br>&gt;&gt;&gt;   /// instance.<br>&gt;&gt;&gt;   ///<br>&gt;&gt;&gt;   /// - Note: Classes with a more-refined notion of “identical”<br>&gt;&gt;&gt;   ///   should conform to `Identifiable` and implement `===`.<br>&gt;&gt;&gt;   func ===(lhs: AnyObject, rhs: AnyObject) -&gt; Bool {<br>&gt;&gt;&gt;     ObjectIdentifier(lhs) == ObjectIdentifier(rhs)<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   /// Supports testing that two values of `Self` are identical<br>&gt;&gt;&gt;   ///<br>&gt;&gt;&gt;   /// If `a` and `b` are of type `Self`, `a === b` means that<br>&gt;&gt;&gt;   /// `a` and `b` are interchangeable in most code.  A conforming<br>&gt;&gt;&gt;   /// type can document that specific observable characteristics<br>&gt;&gt;&gt;   /// (such as the `capacity` of an `Array`) are inessential and<br>&gt;&gt;&gt;   /// thus not to be considered as part of the interchangeability<br>&gt;&gt;&gt;   /// guarantee.<br>&gt;&gt;&gt;   ///<br>&gt;&gt;&gt;   /// - Requires: `===` induces an equivalence relation over<br>&gt;&gt;&gt;   ///   instances.<br>&gt;&gt;&gt;   /// - Note: conforming types will gain an `==` operator that<br>&gt;&gt;&gt;   ///   forwards to `===`.<br>&gt;&gt;&gt;   /// - Note: Types that require domain-specific `==`<br>&gt;&gt;&gt;   ///   implementations with different semantics (e.g. floating<br>&gt;&gt;&gt;   ///   point) should define a more-specific overload of `==`,<br>&gt;&gt;&gt;   ///   which will be used in contexts where the static type is<br>&gt;&gt;&gt;   ///   known to the compiler.<br>&gt;&gt;&gt;   /// - Note: Generic code should usually use `==` to compare<br>&gt;&gt;&gt;   ///   conforming instances; that will always dispatch to `===`<br>&gt;&gt;&gt;   ///   and will be unaffected by more specific overloads of<br>&gt;&gt;&gt;   ///   `==`.<br>&gt;&gt;&gt;   protocol Identifiable { // née Equatable name is negotiable<br>&gt;&gt;&gt;     func ===(_: Self, _: aSelf) -&gt; Bool<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   /// Default definition of `==` for Identifiable types.<br>&gt;&gt;&gt;   func ==&lt;T: Identifiable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;&gt;&gt;     return lhs === rhs<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   /// Conforming types have a default total ordering.<br>&gt;&gt;&gt;   ///<br>&gt;&gt;&gt;   /// If `a` and `b` are of type `Self`, `a &lt;=&gt; b` means that<br>&gt;&gt;&gt;   /// `a` and `b` are interchangeable in most code.  A conforming<br>&gt;&gt;&gt;   /// type can document that specific observable characteristics<br>&gt;&gt;&gt;   /// (such as the `capacity` of an `Array`) are inessential and<br>&gt;&gt;&gt;   /// thus not to be considered as part of the interchangeability<br>&gt;&gt;&gt;   /// guarantee.<br>&gt;&gt;&gt;   ///<br>&gt;&gt;&gt;   /// - Requires: `&lt;=&gt;` induces a total ordering over<br>&gt;&gt;&gt;   ///   instances.<br>&gt;&gt;&gt;   /// - Requires: the semantics of `&lt;=&gt;` are  consistent with<br>&gt;&gt;&gt;   ///   those of `===`.  That is, `(a &lt;=&gt; b) == .equivalent`<br>&gt;&gt;&gt;   ///   iff `a === b`.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; For floating point, I&#39;d hope that `a === b` if `(a &lt;=&gt; b) == .same` *but<br>&gt;&gt; not iff*. This is to satisfy IEEE 754: &quot;Comparisons shall ignore the sign<br>&gt;&gt; of zero (so +0 = −0)&quot;.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;   /// - Note: conforming types will gain `&lt;`, `&lt;=`, `&gt;`, and `&gt;=`<br>&gt;&gt;&gt;   ///   operators defined in terms of `&lt;=&gt;`.<br>&gt;&gt;&gt;   /// - Note: Types that require domain-specific `&lt;`, etc.<br>&gt;&gt;&gt;   ///   implementations with different semantics (e.g. floating<br>&gt;&gt;&gt;   ///   point) should define more-specific overloads of those<br>&gt;&gt;&gt;   ///   operators, which will be used in contexts where the<br>&gt;&gt;&gt;   ///   static type is known to the compiler.<br>&gt;&gt;&gt;   /// - Note: Generic code can freely use `&lt;=&gt;` or the traditional<br>&gt;&gt;&gt;   ///   comparison operators to compare conforming instances;<br>&gt;&gt;&gt;   ///   the result will always be supplied by `&lt;=&gt;`<br>&gt;&gt;&gt;   ///   and will be unaffected by more specific overloads of<br>&gt;&gt;&gt;   ///   the other operators.<br>&gt;&gt;&gt;   protocol Comparable : Identifiable {<br>&gt;&gt;&gt;     func &lt;=&gt; (lhs: Self, rhs: Self) -&gt; Ordering<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   /// Default implementations of `&lt;`, `&lt;=`, `&gt;`, and `&gt;=`.<br>&gt;&gt;&gt;   extension Comparable {<br>&gt;&gt;&gt;     static func &lt;(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;&gt;       return (lhs &lt;=&gt; rhs) == .ascending<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     static func &lt;=(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;&gt;       return (rhs &lt;=&gt; lhs) != .ascending<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     static func &gt;(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;&gt;       return (lhs &lt;=&gt; rhs) == .descending<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     static func &gt;=(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;&gt;       return (rhs &lt;=&gt; lhs) != .descending<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; I like this idea. If we keep === as a separate thing, now users have 3<br>&gt;&gt;&gt; “opportunities” to define<br>&gt;&gt;&gt; &gt; equality. The must be few, if any, use cases for this.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Would love to see if anyone on the list can give us an example.<br>&gt;&gt;&gt; Otherwise we should make<br>&gt;&gt;&gt; &gt; areSame === again™!<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; Daniel Duan<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; On Jul 21, 2016, at 6:32 PM, Robert Widmann via swift-evolution<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jul 21, 2016, at 6:19 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; This is nice. Is `areSame()` being proposed because static `==`<br>&gt;&gt;&gt; is<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; the status quo and you&#39;re trying to make the point that `==` in<br>&gt;&gt;&gt; the<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; future need not guarantee the same semantics?<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; Yep!  Equivalence and equality are strictly very different things.<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; Nit: I think the more common term in stdlib would be<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; `areEquivalent()`. Do you think `same` in that context<br>&gt;&gt;&gt; (independent<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; of the word &quot;ordering&quot;) might erroneously suggest identity?<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; There is room for improvement here.  Keep ‘em coming.<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Thu, Jul 21, 2016 at 8:11 PM, Robert Widmann via<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello Swift Community,<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Harlan Haskins, Jaden Geller, and I have been working on a<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; proposal to clean up the semantics of ordering relations in the<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; standard library.  We have a draft that you can get as a gist.<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Any feedback you might have about this proposal helps - though<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; please keeps your comments on Swift-Evolution and not on the<br>&gt;&gt;&gt; gist.<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; Dave<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; &gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; --<br>&gt;&gt;&gt; &gt;&gt; Dave<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; &gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Dave<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/fcabac89/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July 22, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jul 22, 2016, at 8:37 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Fri, Jul 22, 2016 at 8:20 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; on Fri Jul 22 2016, Daniel Duan &lt;daniel-AT-duan.org&gt; wrote:<br>&gt; <br>&gt; &gt;&gt; On Jul 22, 2016, at 3:00 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; on Fri Jul 22 2016, Daniel Duan &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;<br>&gt; &gt;&gt;&gt;&gt; On Jul 22, 2016, at 11:05 AM, Dave Abrahams via swift-evolution<br>&gt; &gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; on Thu Jul 21 2016, Duan<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Great proposal. I want to second that areSame may mislead user to<br>&gt; &gt;&gt;&gt;&gt;&gt; think this is about identity.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; I like areEquivalent() but there may be better names.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; It really *is* about identity as I posted in a previous message.  But<br>&gt; &gt;&gt;&gt;&gt; that doesn&#39;t change the fact that areEquivalent might be a better name.<br>&gt; &gt;&gt;&gt;&gt; It&#39;s one of the things we considered; it just seemed long for no real<br>&gt; &gt;&gt;&gt;&gt; benefit.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; If the addresses of the arguments aren’t being used, then we don’t consider<br>&gt; &gt;&gt;&gt; them part of their *identity*. I can follow this logic. My fear is most users<br>&gt; &gt;&gt;&gt; won’t make this leap on their own and get the same initial impression as I did.<br>&gt; &gt;&gt;&gt; It&#39;s entirely possible this fear is unfounded. Some educated bikesheding<br>&gt; &gt;&gt;&gt; wouldn&#39;t hurt here IMO :)<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Well, it&#39;s still a very real question whether we ought to have the<br>&gt; &gt;&gt; additional API surface implied by areSame, or wether we should collapse<br>&gt; &gt;&gt; it with ===.<br>&gt; &gt;&gt;<br>&gt; &gt;<br>&gt; &gt; To spell this out (because I had to think about it for a second): === will be derived from<br>&gt; &gt; &lt;=&gt;,<br>&gt; &gt; but also becomes default implementation for ==, which remains open for<br>&gt; &gt; customization.<br>&gt; <br>&gt; I was imagining roughly this (untested):<br>&gt; <br>&gt;   /// Two references are identical if they refer to the same<br>&gt;   /// instance.<br>&gt;   ///<br>&gt;   /// - Note: Classes with a more-refined notion of “identical”<br>&gt;   ///   should conform to `Identifiable` and implement `===`.<br>&gt;   func ===(lhs: AnyObject, rhs: AnyObject) -&gt; Bool {<br>&gt;     ObjectIdentifier(lhs) == ObjectIdentifier(rhs)<br>&gt;   }<br>&gt; <br>&gt;   /// Supports testing that two values of `Self` are identical<br>&gt;   ///<br>&gt;   /// If `a` and `b` are of type `Self`, `a === b` means that<br>&gt;   /// `a` and `b` are interchangeable in most code.  A conforming<br>&gt;   /// type can document that specific observable characteristics<br>&gt;   /// (such as the `capacity` of an `Array`) are inessential and<br>&gt;   /// thus not to be considered as part of the interchangeability<br>&gt;   /// guarantee.<br>&gt;   ///<br>&gt;   /// - Requires: `===` induces an equivalence relation over<br>&gt;   ///   instances.<br>&gt;   /// - Note: conforming types will gain an `==` operator that<br>&gt;   ///   forwards to `===`.<br>&gt;   /// - Note: Types that require domain-specific `==`<br>&gt;   ///   implementations with different semantics (e.g. floating<br>&gt;   ///   point) should define a more-specific overload of `==`,<br>&gt;   ///   which will be used in contexts where the static type is<br>&gt;   ///   known to the compiler.<br>&gt;   /// - Note: Generic code should usually use `==` to compare<br>&gt;   ///   conforming instances; that will always dispatch to `===`<br>&gt;   ///   and will be unaffected by more specific overloads of<br>&gt;   ///   `==`.<br>&gt;   protocol Identifiable { // née Equatable name is negotiable<br>&gt;     func ===(_: Self, _: aSelf) -&gt; Bool<br>&gt;   }<br>&gt; <br>&gt;   /// Default definition of `==` for Identifiable types.<br>&gt;   func ==&lt;T: Identifiable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;     return lhs === rhs<br>&gt;   }<br>&gt; <br>&gt;   /// Conforming types have a default total ordering.<br>&gt;   ///<br>&gt;   /// If `a` and `b` are of type `Self`, `a &lt;=&gt; b` means that<br>&gt;   /// `a` and `b` are interchangeable in most code.  A conforming<br>&gt;   /// type can document that specific observable characteristics<br>&gt;   /// (such as the `capacity` of an `Array`) are inessential and<br>&gt;   /// thus not to be considered as part of the interchangeability<br>&gt;   /// guarantee.<br>&gt;   ///<br>&gt;   /// - Requires: `&lt;=&gt;` induces a total ordering over<br>&gt;   ///   instances.<br>&gt;   /// - Requires: the semantics of `&lt;=&gt;` are  consistent with<br>&gt;   ///   those of `===`.  That is, `(a &lt;=&gt; b) == .equivalent`<br>&gt;   ///   iff `a === b`.<br>&gt; <br>&gt; For floating point, I&#39;d hope that `a === b` if `(a &lt;=&gt; b) == .same` *but not iff*. This is to satisfy IEEE 754: &quot;Comparisons shall ignore the sign of zero (so +0 = −0)”.<br></p><p>The point of this design is that `===` means identity and that `.same ` also means identity.<br></p><p>Since this is new territory I suppose we get to decide what identity means for floating point.  Should +0 and -0 have the same identity or not?  I’ll leave the answer to folks more knowledgable about numerics than I.<br></p><p>&gt;  <br>&gt;   /// - Note: conforming types will gain `&lt;`, `&lt;=`, `&gt;`, and `&gt;=`<br>&gt;   ///   operators defined in terms of `&lt;=&gt;`.<br>&gt;   /// - Note: Types that require domain-specific `&lt;`, etc.<br>&gt;   ///   implementations with different semantics (e.g. floating<br>&gt;   ///   point) should define more-specific overloads of those<br>&gt;   ///   operators, which will be used in contexts where the<br>&gt;   ///   static type is known to the compiler.<br>&gt;   /// - Note: Generic code can freely use `&lt;=&gt;` or the traditional<br>&gt;   ///   comparison operators to compare conforming instances;<br>&gt;   ///   the result will always be supplied by `&lt;=&gt;`<br>&gt;   ///   and will be unaffected by more specific overloads of<br>&gt;   ///   the other operators.<br>&gt;   protocol Comparable : Identifiable {<br>&gt;     func &lt;=&gt; (lhs: Self, rhs: Self) -&gt; Ordering<br>&gt;   }<br>&gt; <br>&gt;   /// Default implementations of `&lt;`, `&lt;=`, `&gt;`, and `&gt;=`.<br>&gt;   extension Comparable {<br>&gt;     static func &lt;(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;       return (lhs &lt;=&gt; rhs) == .ascending<br>&gt;     }<br>&gt;     static func &lt;=(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;       return (rhs &lt;=&gt; lhs) != .ascending<br>&gt;     }<br>&gt;     static func &gt;(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;       return (lhs &lt;=&gt; rhs) == .descending<br>&gt;     }<br>&gt;     static func &gt;=(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;       return (rhs &lt;=&gt; lhs) != .descending<br>&gt;     }<br>&gt;   }<br>&gt; <br>&gt; &gt; I like this idea. If we keep === as a separate thing, now users have 3 “opportunities” to define<br>&gt; &gt; equality. The must be few, if any, use cases for this.<br>&gt; &gt;<br>&gt; &gt; Would love to see if anyone on the list can give us an example. Otherwise we should make<br>&gt; &gt; areSame === again™!<br>&gt; &gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Daniel Duan<br>&gt; &gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; On Jul 21, 2016, at 6:32 PM, Robert Widmann via swift-evolution<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jul 21, 2016, at 6:19 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; This is nice. Is `areSame()` being proposed because static `==` is<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; the status quo and you&#39;re trying to make the point that `==` in the<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; future need not guarantee the same semantics?<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; Yep!  Equivalence and equality are strictly very different things.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; Nit: I think the more common term in stdlib would be<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; `areEquivalent()`. Do you think `same` in that context (independent<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; of the word &quot;ordering&quot;) might erroneously suggest identity?<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; There is room for improvement here.  Keep ‘em coming.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Thu, Jul 21, 2016 at 8:11 PM, Robert Widmann via<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello Swift Community,<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Harlan Haskins, Jaden Geller, and I have been working on a<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; proposal to clean up the semantics of ordering relations in the<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; standard library.  We have a draft that you can get as a gist.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Any feedback you might have about this proposal helps - though<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; please keeps your comments on Swift-Evolution and not on the gist.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; --<br>&gt; &gt;&gt;&gt;&gt; Dave<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; --<br>&gt; &gt;&gt; Dave<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt; <br>&gt; --<br>&gt; Dave<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/cea7d25b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 22, 2016 at 08:00:00pm</p></header><div class="content"><p>On Fri, Jul 22, 2016 at 8:44 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; On Jul 22, 2016, at 8:37 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Fri, Jul 22, 2016 at 8:20 PM, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; on Fri Jul 22 2016, Daniel Duan &lt;daniel-AT-duan.org<br>&gt;&gt; &lt;http://daniel-at-duan.org&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; &gt;&gt; On Jul 22, 2016, at 3:00 PM, Dave Abrahams via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; on Fri Jul 22 2016, Daniel Duan &lt;swift-evolution at swift.org &lt;mailto:<br>&gt;&gt; swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; On Jul 22, 2016, at 11:05 AM, Dave Abrahams via swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; on Thu Jul 21 2016, Duan<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; Great proposal. I want to second that areSame may mislead user to<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; think this is about identity.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; I like areEquivalent() but there may be better names.<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; It really *is* about identity as I posted in a previous message.  But<br>&gt;&gt; &gt;&gt;&gt;&gt; that doesn&#39;t change the fact that areEquivalent might be a better<br>&gt;&gt; name.<br>&gt;&gt; &gt;&gt;&gt;&gt; It&#39;s one of the things we considered; it just seemed long for no real<br>&gt;&gt; &gt;&gt;&gt;&gt; benefit.<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; If the addresses of the arguments aren’t being used, then we don’t<br>&gt;&gt; consider<br>&gt;&gt; &gt;&gt;&gt; them part of their *identity*. I can follow this logic. My fear is<br>&gt;&gt; most users<br>&gt;&gt; &gt;&gt;&gt; won’t make this leap on their own and get the same initial impression<br>&gt;&gt; as I did.<br>&gt;&gt; &gt;&gt;&gt; It&#39;s entirely possible this fear is unfounded. Some educated<br>&gt;&gt; bikesheding<br>&gt;&gt; &gt;&gt;&gt; wouldn&#39;t hurt here IMO :)<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Well, it&#39;s still a very real question whether we ought to have the<br>&gt;&gt; &gt;&gt; additional API surface implied by areSame, or wether we should collapse<br>&gt;&gt; &gt;&gt; it with ===.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; To spell this out (because I had to think about it for a second): ===<br>&gt;&gt; will be derived from<br>&gt;&gt; &gt; &lt;=&gt;,<br>&gt;&gt; &gt; but also becomes default implementation for ==, which remains open for<br>&gt;&gt; &gt; customization.<br>&gt;&gt;<br>&gt;&gt; I was imagining roughly this (untested):<br>&gt;&gt;<br>&gt;&gt;   /// Two references are identical if they refer to the same<br>&gt;&gt;   /// instance.<br>&gt;&gt;   ///<br>&gt;&gt;   /// - Note: Classes with a more-refined notion of “identical”<br>&gt;&gt;   ///   should conform to `Identifiable` and implement `===`.<br>&gt;&gt;   func ===(lhs: AnyObject, rhs: AnyObject) -&gt; Bool {<br>&gt;&gt;     ObjectIdentifier(lhs) == ObjectIdentifier(rhs)<br>&gt;&gt;   }<br>&gt;&gt;<br>&gt;&gt;   /// Supports testing that two values of `Self` are identical<br>&gt;&gt;   ///<br>&gt;&gt;   /// If `a` and `b` are of type `Self`, `a === b` means that<br>&gt;&gt;   /// `a` and `b` are interchangeable in most code.  A conforming<br>&gt;&gt;   /// type can document that specific observable characteristics<br>&gt;&gt;   /// (such as the `capacity` of an `Array`) are inessential and<br>&gt;&gt;   /// thus not to be considered as part of the interchangeability<br>&gt;&gt;   /// guarantee.<br>&gt;&gt;   ///<br>&gt;&gt;   /// - Requires: `===` induces an equivalence relation over<br>&gt;&gt;   ///   instances.<br>&gt;&gt;   /// - Note: conforming types will gain an `==` operator that<br>&gt;&gt;   ///   forwards to `===`.<br>&gt;&gt;   /// - Note: Types that require domain-specific `==`<br>&gt;&gt;   ///   implementations with different semantics (e.g. floating<br>&gt;&gt;   ///   point) should define a more-specific overload of `==`,<br>&gt;&gt;   ///   which will be used in contexts where the static type is<br>&gt;&gt;   ///   known to the compiler.<br>&gt;&gt;   /// - Note: Generic code should usually use `==` to compare<br>&gt;&gt;   ///   conforming instances; that will always dispatch to `===`<br>&gt;&gt;   ///   and will be unaffected by more specific overloads of<br>&gt;&gt;   ///   `==`.<br>&gt;&gt;   protocol Identifiable { // née Equatable name is negotiable<br>&gt;&gt;     func ===(_: Self, _: aSelf) -&gt; Bool<br>&gt;&gt;   }<br>&gt;&gt;<br>&gt;&gt;   /// Default definition of `==` for Identifiable types.<br>&gt;&gt;   func ==&lt;T: Identifiable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;&gt;     return lhs === rhs<br>&gt;&gt;   }<br>&gt;&gt;<br>&gt;&gt;   /// Conforming types have a default total ordering.<br>&gt;&gt;   ///<br>&gt;&gt;   /// If `a` and `b` are of type `Self`, `a &lt;=&gt; b` means that<br>&gt;&gt;   /// `a` and `b` are interchangeable in most code.  A conforming<br>&gt;&gt;   /// type can document that specific observable characteristics<br>&gt;&gt;   /// (such as the `capacity` of an `Array`) are inessential and<br>&gt;&gt;   /// thus not to be considered as part of the interchangeability<br>&gt;&gt;   /// guarantee.<br>&gt;&gt;   ///<br>&gt;&gt;   /// - Requires: `&lt;=&gt;` induces a total ordering over<br>&gt;&gt;   ///   instances.<br>&gt;&gt;   /// - Requires: the semantics of `&lt;=&gt;` are  consistent with<br>&gt;&gt;   ///   those of `===`.  That is, `(a &lt;=&gt; b) == .equivalent`<br>&gt;&gt;   ///   iff `a === b`.<br>&gt;&gt;<br>&gt;<br>&gt; For floating point, I&#39;d hope that `a === b` if `(a &lt;=&gt; b) == .same` *but<br>&gt; not iff*. This is to satisfy IEEE 754: &quot;Comparisons shall ignore the sign<br>&gt; of zero (so +0 = −0)”.<br>&gt;<br>&gt;<br>&gt; The point of this design is that `===` means identity and that `.same `<br>&gt; also means identity.<br>&gt;<br>&gt; Since this is new territory I suppose we get to decide what identity means<br>&gt; for floating point.  Should +0 and -0 have the same identity or not?  I’ll<br>&gt; leave the answer to folks more knowledgable about numerics than I.<br>&gt;<br></p><p>Sure. The extent of my understanding is that IEEE 754 now has a total order<br>predicate, which places -0 below +0, but also demands that for all<br>comparisons +0 shall equal -0.<br></p><p><br>&gt;   /// - Note: conforming types will gain `&lt;`, `&lt;=`, `&gt;`, and `&gt;=`<br>&gt;&gt;   ///   operators defined in terms of `&lt;=&gt;`.<br>&gt;&gt;   /// - Note: Types that require domain-specific `&lt;`, etc.<br>&gt;&gt;   ///   implementations with different semantics (e.g. floating<br>&gt;&gt;   ///   point) should define more-specific overloads of those<br>&gt;&gt;   ///   operators, which will be used in contexts where the<br>&gt;&gt;   ///   static type is known to the compiler.<br>&gt;&gt;   /// - Note: Generic code can freely use `&lt;=&gt;` or the traditional<br>&gt;&gt;   ///   comparison operators to compare conforming instances;<br>&gt;&gt;   ///   the result will always be supplied by `&lt;=&gt;`<br>&gt;&gt;   ///   and will be unaffected by more specific overloads of<br>&gt;&gt;   ///   the other operators.<br>&gt;&gt;   protocol Comparable : Identifiable {<br>&gt;&gt;     func &lt;=&gt; (lhs: Self, rhs: Self) -&gt; Ordering<br>&gt;&gt;   }<br>&gt;&gt;<br>&gt;&gt;   /// Default implementations of `&lt;`, `&lt;=`, `&gt;`, and `&gt;=`.<br>&gt;&gt;   extension Comparable {<br>&gt;&gt;     static func &lt;(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;       return (lhs &lt;=&gt; rhs) == .ascending<br>&gt;&gt;     }<br>&gt;&gt;     static func &lt;=(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;       return (rhs &lt;=&gt; lhs) != .ascending<br>&gt;&gt;     }<br>&gt;&gt;     static func &gt;(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;       return (lhs &lt;=&gt; rhs) == .descending<br>&gt;&gt;     }<br>&gt;&gt;     static func &gt;=(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;       return (rhs &lt;=&gt; lhs) != .descending<br>&gt;&gt;     }<br>&gt;&gt;   }<br>&gt;&gt;<br>&gt;&gt; &gt; I like this idea. If we keep === as a separate thing, now users have 3<br>&gt;&gt; “opportunities” to define<br>&gt;&gt; &gt; equality. The must be few, if any, use cases for this.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Would love to see if anyone on the list can give us an example.<br>&gt;&gt; Otherwise we should make<br>&gt;&gt; &gt; areSame === again™!<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; Daniel Duan<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; On Jul 21, 2016, at 6:32 PM, Robert Widmann via swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jul 21, 2016, at 6:19 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; This is nice. Is `areSame()` being proposed because static `==` is<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; the status quo and you&#39;re trying to make the point that `==` in<br>&gt;&gt; the<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; future need not guarantee the same semantics?<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; Yep!  Equivalence and equality are strictly very different things.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; Nit: I think the more common term in stdlib would be<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; `areEquivalent()`. Do you think `same` in that context<br>&gt;&gt; (independent<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; of the word &quot;ordering&quot;) might erroneously suggest identity?<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; There is room for improvement here.  Keep ‘em coming.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Thu, Jul 21, 2016 at 8:11 PM, Robert Widmann via<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello Swift Community,<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Harlan Haskins, Jaden Geller, and I have been working on a<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; proposal to clean up the semantics of ordering relations in the<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; standard library.  We have a draft that you can get as a gist.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Any feedback you might have about this proposal helps - though<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; please keeps your comments on Swift-Evolution and not on the<br>&gt;&gt; gist.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; --<br>&gt;&gt; &gt;&gt;&gt;&gt; Dave<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; --<br>&gt;&gt; &gt;&gt; Dave<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Dave<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/5972a487/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July 22, 2016 at 06:00:00pm</p></header><div class="content"><p>on Fri Jul 22 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br></p><p>&gt; On Fri, Jul 22, 2016 at 8:20 PM, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; on Fri Jul 22 2016, Daniel Duan &lt;daniel-AT-duan.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; &gt;&gt; On Jul 22, 2016, at 3:00 PM, Dave Abrahams via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; on Fri Jul 22 2016, Daniel Duan &lt;swift-evolution at swift.org &lt;mailto:<br>&gt;&gt; swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; On Jul 22, 2016, at 11:05 AM, Dave Abrahams via swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; on Thu Jul 21 2016, Duan<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; Great proposal. I want to second that areSame may mislead user to<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; think this is about identity.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; I like areEquivalent() but there may be better names.<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; It really *is* about identity as I posted in a previous message.  But<br>&gt;&gt; &gt;&gt;&gt;&gt; that doesn&#39;t change the fact that areEquivalent might be a better<br>&gt;&gt; name.<br>&gt;&gt; &gt;&gt;&gt;&gt; It&#39;s one of the things we considered; it just seemed long for no real<br>&gt;&gt; &gt;&gt;&gt;&gt; benefit.<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; If the addresses of the arguments aren’t being used, then we don’t<br>&gt;&gt; consider<br>&gt;&gt; &gt;&gt;&gt; them part of their *identity*. I can follow this logic. My fear is<br>&gt;&gt; most users<br>&gt;&gt; &gt;&gt;&gt; won’t make this leap on their own and get the same initial impression<br>&gt;&gt; as I did.<br>&gt;&gt; &gt;&gt;&gt; It&#39;s entirely possible this fear is unfounded. Some educated<br>&gt;&gt; bikesheding<br>&gt;&gt; &gt;&gt;&gt; wouldn&#39;t hurt here IMO :)<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Well, it&#39;s still a very real question whether we ought to have the<br>&gt;&gt; &gt;&gt; additional API surface implied by areSame, or wether we should collapse<br>&gt;&gt; &gt;&gt; it with ===.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; To spell this out (because I had to think about it for a second): ===<br>&gt;&gt; will be derived from<br>&gt;&gt; &gt; &lt;=&gt;,<br>&gt;&gt; &gt; but also becomes default implementation for ==, which remains open for<br>&gt;&gt; &gt; customization.<br>&gt;&gt;<br>&gt;&gt; I was imagining roughly this (untested):<br>&gt;&gt;<br>&gt;&gt;   /// Two references are identical if they refer to the same<br>&gt;&gt;   /// instance.<br>&gt;&gt;   ///<br>&gt;&gt;   /// - Note: Classes with a more-refined notion of “identical”<br>&gt;&gt;   ///   should conform to `Identifiable` and implement `===`.<br>&gt;&gt;   func ===(lhs: AnyObject, rhs: AnyObject) -&gt; Bool {<br>&gt;&gt;     ObjectIdentifier(lhs) == ObjectIdentifier(rhs)<br>&gt;&gt;   }<br>&gt;&gt;<br>&gt;&gt;   /// Supports testing that two values of `Self` are identical<br>&gt;&gt;   ///<br>&gt;&gt;   /// If `a` and `b` are of type `Self`, `a === b` means that<br>&gt;&gt;   /// `a` and `b` are interchangeable in most code.  A conforming<br>&gt;&gt;   /// type can document that specific observable characteristics<br>&gt;&gt;   /// (such as the `capacity` of an `Array`) are inessential and<br>&gt;&gt;   /// thus not to be considered as part of the interchangeability<br>&gt;&gt;   /// guarantee.<br>&gt;&gt;   ///<br>&gt;&gt;   /// - Requires: `===` induces an equivalence relation over<br>&gt;&gt;   ///   instances.<br>&gt;&gt;   /// - Note: conforming types will gain an `==` operator that<br>&gt;&gt;   ///   forwards to `===`.<br>&gt;&gt;   /// - Note: Types that require domain-specific `==`<br>&gt;&gt;   ///   implementations with different semantics (e.g. floating<br>&gt;&gt;   ///   point) should define a more-specific overload of `==`,<br>&gt;&gt;   ///   which will be used in contexts where the static type is<br>&gt;&gt;   ///   known to the compiler.<br>&gt;&gt;   /// - Note: Generic code should usually use `==` to compare<br>&gt;&gt;   ///   conforming instances; that will always dispatch to `===`<br>&gt;&gt;   ///   and will be unaffected by more specific overloads of<br>&gt;&gt;   ///   `==`.<br>&gt;&gt;   protocol Identifiable { // née Equatable name is negotiable<br>&gt;&gt;     func ===(_: Self, _: aSelf) -&gt; Bool<br>&gt;&gt;   }<br>&gt;&gt;<br>&gt;&gt;   /// Default definition of `==` for Identifiable types.<br>&gt;&gt;   func ==&lt;T: Identifiable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;&gt;     return lhs === rhs<br>&gt;&gt;   }<br>&gt;&gt;<br>&gt;&gt;   /// Conforming types have a default total ordering.<br>&gt;&gt;   ///<br>&gt;&gt;   /// If `a` and `b` are of type `Self`, `a &lt;=&gt; b` means that<br>&gt;&gt;   /// `a` and `b` are interchangeable in most code.  A conforming<br>&gt;&gt;   /// type can document that specific observable characteristics<br>&gt;&gt;   /// (such as the `capacity` of an `Array`) are inessential and<br>&gt;&gt;   /// thus not to be considered as part of the interchangeability<br>&gt;&gt;   /// guarantee.<br>&gt;&gt;   ///<br>&gt;&gt;   /// - Requires: `&lt;=&gt;` induces a total ordering over<br>&gt;&gt;   ///   instances.<br>&gt;&gt;   /// - Requires: the semantics of `&lt;=&gt;` are  consistent with<br>&gt;&gt;   ///   those of `===`.  That is, `(a &lt;=&gt; b) == .equivalent`<br>&gt;&gt;   ///   iff `a === b`.<br>&gt;&gt;<br>&gt;<br>&gt; For floating point, I&#39;d hope that `a === b` if `(a &lt;=&gt; b) == .same` *but<br>&gt; not iff*. This is to satisfy IEEE 754: &quot;Comparisons shall ignore the sign<br>&gt; of zero (so +0 = −0)&quot;.<br></p><p>By “comparisons” they mean the traditional comparison operators, not all<br>possible comparisons you might want to do.<br></p><p>That single equal sign in their text corresponds to == in the world<br>being proposed, so that&#39;s fine.<br></p><p>&gt;<br>&gt;<br>&gt;&gt;   /// - Note: conforming types will gain `&lt;`, `&lt;=`, `&gt;`, and `&gt;=`<br>&gt;&gt;   ///   operators defined in terms of `&lt;=&gt;`.<br>&gt;&gt;   /// - Note: Types that require domain-specific `&lt;`, etc.<br>&gt;&gt;   ///   implementations with different semantics (e.g. floating<br>&gt;&gt;   ///   point) should define more-specific overloads of those<br>&gt;&gt;   ///   operators, which will be used in contexts where the<br>&gt;&gt;   ///   static type is known to the compiler.<br>&gt;&gt;   /// - Note: Generic code can freely use `&lt;=&gt;` or the traditional<br>&gt;&gt;   ///   comparison operators to compare conforming instances;<br>&gt;&gt;   ///   the result will always be supplied by `&lt;=&gt;`<br>&gt;&gt;   ///   and will be unaffected by more specific overloads of<br>&gt;&gt;   ///   the other operators.<br>&gt;&gt;   protocol Comparable : Identifiable {<br>&gt;&gt;     func &lt;=&gt; (lhs: Self, rhs: Self) -&gt; Ordering<br>&gt;&gt;   }<br>&gt;&gt;<br>&gt;&gt;   /// Default implementations of `&lt;`, `&lt;=`, `&gt;`, and `&gt;=`.<br>&gt;&gt;   extension Comparable {<br>&gt;&gt;     static func &lt;(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;       return (lhs &lt;=&gt; rhs) == .ascending<br>&gt;&gt;     }<br>&gt;&gt;     static func &lt;=(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;       return (rhs &lt;=&gt; lhs) != .ascending<br>&gt;&gt;     }<br>&gt;&gt;     static func &gt;(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;       return (lhs &lt;=&gt; rhs) == .descending<br>&gt;&gt;     }<br>&gt;&gt;     static func &gt;=(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;       return (rhs &lt;=&gt; lhs) != .descending<br>&gt;&gt;     }<br>&gt;&gt;   }<br>&gt;&gt;<br>&gt;&gt; &gt; I like this idea. If we keep === as a separate thing, now users have 3<br>&gt;&gt; “opportunities” to define<br>&gt;&gt; &gt; equality. The must be few, if any, use cases for this.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Would love to see if anyone on the list can give us an example.<br>&gt;&gt; Otherwise we should make<br>&gt;&gt; &gt; areSame === again™!<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; Daniel Duan<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; On Jul 21, 2016, at 6:32 PM, Robert Widmann via swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jul 21, 2016, at 6:19 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; This is nice. Is `areSame()` being proposed because static `==` is<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; the status quo and you&#39;re trying to make the point that `==` in the<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; future need not guarantee the same semantics?<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; Yep!  Equivalence and equality are strictly very different things.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; Nit: I think the more common term in stdlib would be<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; `areEquivalent()`. Do you think `same` in that context (independent<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; of the word &quot;ordering&quot;) might erroneously suggest identity?<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; There is room for improvement here.  Keep ‘em coming.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Thu, Jul 21, 2016 at 8:11 PM, Robert Widmann via<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello Swift Community,<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Harlan Haskins, Jaden Geller, and I have been working on a<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; proposal to clean up the semantics of ordering relations in the<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; standard library.  We have a draft that you can get as a gist.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Any feedback you might have about this proposal helps - though<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; please keeps your comments on Swift-Evolution and not on the gist.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; --<br>&gt;&gt; &gt;&gt;&gt;&gt; Dave<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; --<br>&gt;&gt; &gt;&gt; Dave<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Dave<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 22, 2016 at 08:00:00pm</p></header><div class="content"><p>On Fri, Jul 22, 2016 at 8:45 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; on Fri Jul 22 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt;<br>&gt; &gt; On Fri, Jul 22, 2016 at 8:20 PM, Dave Abrahams via swift-evolution &lt;<br>&gt; &gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; on Fri Jul 22 2016, Daniel Duan &lt;daniel-AT-duan.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; On Jul 22, 2016, at 3:00 PM, Dave Abrahams via swift-evolution &lt;<br>&gt; &gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; on Fri Jul 22 2016, Daniel Duan &lt;swift-evolution at swift.org &lt;mailto:<br>&gt; &gt;&gt; swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt; On Jul 22, 2016, at 11:05 AM, Dave Abrahams via swift-evolution<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt; wrote:<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt; on Thu Jul 21 2016, Duan<br>&gt; &gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:<br>&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt; wrote:<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt; Great proposal. I want to second that areSame may mislead user to<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt; think this is about identity.<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt; I like areEquivalent() but there may be better names.<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt; It really *is* about identity as I posted in a previous message.<br>&gt; But<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt; that doesn&#39;t change the fact that areEquivalent might be a better<br>&gt; &gt;&gt; name.<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt; It&#39;s one of the things we considered; it just seemed long for no<br>&gt; real<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt; benefit.<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt; If the addresses of the arguments aren’t being used, then we don’t<br>&gt; &gt;&gt; consider<br>&gt; &gt;&gt; &gt;&gt;&gt; them part of their *identity*. I can follow this logic. My fear is<br>&gt; &gt;&gt; most users<br>&gt; &gt;&gt; &gt;&gt;&gt; won’t make this leap on their own and get the same initial<br>&gt; impression<br>&gt; &gt;&gt; as I did.<br>&gt; &gt;&gt; &gt;&gt;&gt; It&#39;s entirely possible this fear is unfounded. Some educated<br>&gt; &gt;&gt; bikesheding<br>&gt; &gt;&gt; &gt;&gt;&gt; wouldn&#39;t hurt here IMO :)<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; Well, it&#39;s still a very real question whether we ought to have the<br>&gt; &gt;&gt; &gt;&gt; additional API surface implied by areSame, or wether we should<br>&gt; collapse<br>&gt; &gt;&gt; &gt;&gt; it with ===.<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; To spell this out (because I had to think about it for a second): ===<br>&gt; &gt;&gt; will be derived from<br>&gt; &gt;&gt; &gt; &lt;=&gt;,<br>&gt; &gt;&gt; &gt; but also becomes default implementation for ==, which remains open for<br>&gt; &gt;&gt; &gt; customization.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I was imagining roughly this (untested):<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;   /// Two references are identical if they refer to the same<br>&gt; &gt;&gt;   /// instance.<br>&gt; &gt;&gt;   ///<br>&gt; &gt;&gt;   /// - Note: Classes with a more-refined notion of “identical”<br>&gt; &gt;&gt;   ///   should conform to `Identifiable` and implement `===`.<br>&gt; &gt;&gt;   func ===(lhs: AnyObject, rhs: AnyObject) -&gt; Bool {<br>&gt; &gt;&gt;     ObjectIdentifier(lhs) == ObjectIdentifier(rhs)<br>&gt; &gt;&gt;   }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;   /// Supports testing that two values of `Self` are identical<br>&gt; &gt;&gt;   ///<br>&gt; &gt;&gt;   /// If `a` and `b` are of type `Self`, `a === b` means that<br>&gt; &gt;&gt;   /// `a` and `b` are interchangeable in most code.  A conforming<br>&gt; &gt;&gt;   /// type can document that specific observable characteristics<br>&gt; &gt;&gt;   /// (such as the `capacity` of an `Array`) are inessential and<br>&gt; &gt;&gt;   /// thus not to be considered as part of the interchangeability<br>&gt; &gt;&gt;   /// guarantee.<br>&gt; &gt;&gt;   ///<br>&gt; &gt;&gt;   /// - Requires: `===` induces an equivalence relation over<br>&gt; &gt;&gt;   ///   instances.<br>&gt; &gt;&gt;   /// - Note: conforming types will gain an `==` operator that<br>&gt; &gt;&gt;   ///   forwards to `===`.<br>&gt; &gt;&gt;   /// - Note: Types that require domain-specific `==`<br>&gt; &gt;&gt;   ///   implementations with different semantics (e.g. floating<br>&gt; &gt;&gt;   ///   point) should define a more-specific overload of `==`,<br>&gt; &gt;&gt;   ///   which will be used in contexts where the static type is<br>&gt; &gt;&gt;   ///   known to the compiler.<br>&gt; &gt;&gt;   /// - Note: Generic code should usually use `==` to compare<br>&gt; &gt;&gt;   ///   conforming instances; that will always dispatch to `===`<br>&gt; &gt;&gt;   ///   and will be unaffected by more specific overloads of<br>&gt; &gt;&gt;   ///   `==`.<br>&gt; &gt;&gt;   protocol Identifiable { // née Equatable name is negotiable<br>&gt; &gt;&gt;     func ===(_: Self, _: aSelf) -&gt; Bool<br>&gt; &gt;&gt;   }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;   /// Default definition of `==` for Identifiable types.<br>&gt; &gt;&gt;   func ==&lt;T: Identifiable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt; &gt;&gt;     return lhs === rhs<br>&gt; &gt;&gt;   }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;   /// Conforming types have a default total ordering.<br>&gt; &gt;&gt;   ///<br>&gt; &gt;&gt;   /// If `a` and `b` are of type `Self`, `a &lt;=&gt; b` means that<br>&gt; &gt;&gt;   /// `a` and `b` are interchangeable in most code.  A conforming<br>&gt; &gt;&gt;   /// type can document that specific observable characteristics<br>&gt; &gt;&gt;   /// (such as the `capacity` of an `Array`) are inessential and<br>&gt; &gt;&gt;   /// thus not to be considered as part of the interchangeability<br>&gt; &gt;&gt;   /// guarantee.<br>&gt; &gt;&gt;   ///<br>&gt; &gt;&gt;   /// - Requires: `&lt;=&gt;` induces a total ordering over<br>&gt; &gt;&gt;   ///   instances.<br>&gt; &gt;&gt;   /// - Requires: the semantics of `&lt;=&gt;` are  consistent with<br>&gt; &gt;&gt;   ///   those of `===`.  That is, `(a &lt;=&gt; b) == .equivalent`<br>&gt; &gt;&gt;   ///   iff `a === b`.<br>&gt; &gt;&gt;<br>&gt; &gt;<br>&gt; &gt; For floating point, I&#39;d hope that `a === b` if `(a &lt;=&gt; b) == .same` *but<br>&gt; &gt; not iff*. This is to satisfy IEEE 754: &quot;Comparisons shall ignore the sign<br>&gt; &gt; of zero (so +0 = −0)&quot;.<br>&gt;<br>&gt; By “comparisons” they mean the traditional comparison operators, not all<br>&gt; possible comparisons you might want to do.<br>&gt;<br></p><p>I don&#39;t believe so, but I could be corrected by Steve. They list 26<br>comparison relations and don&#39;t go into what they call `=` until later, so I<br>take than as an example.<br></p><p><br>&gt;<br>&gt; That single equal sign in their text corresponds to == in the world<br>&gt; being proposed, so that&#39;s fine.<br>&gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt;   /// - Note: conforming types will gain `&lt;`, `&lt;=`, `&gt;`, and `&gt;=`<br>&gt; &gt;&gt;   ///   operators defined in terms of `&lt;=&gt;`.<br>&gt; &gt;&gt;   /// - Note: Types that require domain-specific `&lt;`, etc.<br>&gt; &gt;&gt;   ///   implementations with different semantics (e.g. floating<br>&gt; &gt;&gt;   ///   point) should define more-specific overloads of those<br>&gt; &gt;&gt;   ///   operators, which will be used in contexts where the<br>&gt; &gt;&gt;   ///   static type is known to the compiler.<br>&gt; &gt;&gt;   /// - Note: Generic code can freely use `&lt;=&gt;` or the traditional<br>&gt; &gt;&gt;   ///   comparison operators to compare conforming instances;<br>&gt; &gt;&gt;   ///   the result will always be supplied by `&lt;=&gt;`<br>&gt; &gt;&gt;   ///   and will be unaffected by more specific overloads of<br>&gt; &gt;&gt;   ///   the other operators.<br>&gt; &gt;&gt;   protocol Comparable : Identifiable {<br>&gt; &gt;&gt;     func &lt;=&gt; (lhs: Self, rhs: Self) -&gt; Ordering<br>&gt; &gt;&gt;   }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;   /// Default implementations of `&lt;`, `&lt;=`, `&gt;`, and `&gt;=`.<br>&gt; &gt;&gt;   extension Comparable {<br>&gt; &gt;&gt;     static func &lt;(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt; &gt;&gt;       return (lhs &lt;=&gt; rhs) == .ascending<br>&gt; &gt;&gt;     }<br>&gt; &gt;&gt;     static func &lt;=(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt; &gt;&gt;       return (rhs &lt;=&gt; lhs) != .ascending<br>&gt; &gt;&gt;     }<br>&gt; &gt;&gt;     static func &gt;(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt; &gt;&gt;       return (lhs &lt;=&gt; rhs) == .descending<br>&gt; &gt;&gt;     }<br>&gt; &gt;&gt;     static func &gt;=(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt; &gt;&gt;       return (rhs &lt;=&gt; lhs) != .descending<br>&gt; &gt;&gt;     }<br>&gt; &gt;&gt;   }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt; I like this idea. If we keep === as a separate thing, now users have 3<br>&gt; &gt;&gt; “opportunities” to define<br>&gt; &gt;&gt; &gt; equality. The must be few, if any, use cases for this.<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; Would love to see if anyone on the list can give us an example.<br>&gt; &gt;&gt; Otherwise we should make<br>&gt; &gt;&gt; &gt; areSame === again™!<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt; Daniel Duan<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; On Jul 21, 2016, at 6:32 PM, Robert Widmann via swift-evolution<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jul 21, 2016, at 6:19 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt;<br>&gt; &gt;&gt; wrote:<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; This is nice. Is `areSame()` being proposed because static `==`<br>&gt; is<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; the status quo and you&#39;re trying to make the point that `==` in<br>&gt; the<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; future need not guarantee the same semantics?<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; Yep!  Equivalence and equality are strictly very different<br>&gt; things.<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; Nit: I think the more common term in stdlib would be<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; `areEquivalent()`. Do you think `same` in that context<br>&gt; (independent<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; of the word &quot;ordering&quot;) might erroneously suggest identity?<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; There is room for improvement here.  Keep ‘em coming.<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Thu, Jul 21, 2016 at 8:11 PM, Robert Widmann via<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello Swift Community,<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Harlan Haskins, Jaden Geller, and I have been working on a<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; proposal to clean up the semantics of ordering relations in the<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; standard library.  We have a draft that you can get as a gist.<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Any feedback you might have about this proposal helps - though<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; please keeps your comments on Swift-Evolution and not on the<br>&gt; gist.<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt; --<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt; Dave<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:<br>&gt; swift-evolution at swift.org&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; &gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt; &gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; --<br>&gt; &gt;&gt; &gt;&gt; Dave<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt; &gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; --<br>&gt; &gt;&gt; Dave<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;<br>&gt;<br>&gt; --<br>&gt; Dave<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/0b578514/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>July 22, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Jul 22, 2016, at 4:55 PM, Daniel Duan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Well, it&#39;s still a very real question whether we ought to have the<br>&gt;&gt; additional API surface implied by areSame, or wether we should collapse<br>&gt;&gt; it with ===.<br>&gt;&gt; <br>&gt; <br>&gt; To spell this out (because I had to think about it for a second): === will be derived from<br>&gt; &lt;=&gt;, but also becomes default implementation for ==, which remains open for customization.<br>&gt; <br>&gt; I like this idea. If we keep === as a separate thing, now users have 3 “opportunities” to define<br>&gt; equality. The must be few, if any, use cases for this.<br>&gt; <br>&gt; Would love to see if anyone on the list can give us an example. Otherwise we should make<br>&gt; areSame === again™!<br></p><p>If `===` is the new `areSame`, and `Hashable` is based on `===`, wouldn&#39;t that mean that objects could only be hashed (and thus, be looked up in Dictionary and Set) by identity? So, for instance, code like this:<br></p><p>	var set = Set&lt;NSString&gt;()<br>	<br>	set.insert(&quot;test&quot;)<br>	set.insert(&quot;test&quot;)<br>	<br>	print(set.count)<br></p><p>Would print &quot;2&quot;? Or worse, might print &quot;1&quot; or &quot;2&quot; depending on the details of how Swift generates literals and Foundation implements short strings?<br></p><p>Am I the only one who thinks that&#39;s a problem?<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e95942f1fe843f007ef5430b9acff78b?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Jaden Geller</string> &lt;jaden.geller at gmail.com&gt;<p>July 22, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; If `===` is the new `areSame`, and `Hashable` is based on `===`, wouldn&#39;t that mean that objects could only be hashed (and thus, be looked up in Dictionary and Set) by identity? So, for instance, code like this:<br>&gt; <br>&gt; 	var set = Set&lt;NSString&gt;()<br>&gt; 	<br>&gt; 	set.insert(&quot;test&quot;)<br>&gt; 	set.insert(&quot;test&quot;)<br>&gt; 	<br>&gt; 	print(set.count)<br>&gt; <br>&gt; Would print &quot;2&quot;? Or worse, might print &quot;1&quot; or &quot;2&quot; depending on the details of how Swift generates literals and Foundation implements short strings?<br>&gt; <br>&gt; Am I the only one who thinks that&#39;s a problem?<br></p><p>I was under the impression that the identity of an `NSObject` would use the existing `isEqual:` method. That is, identity doesn&#39;t necessarily mean reference identity anymore.<br></p><p>&gt; On Jul 22, 2016, at 7:00 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Jul 22, 2016, at 4:55 PM, Daniel Duan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Well, it&#39;s still a very real question whether we ought to have the<br>&gt;&gt;&gt; additional API surface implied by areSame, or wether we should collapse<br>&gt;&gt;&gt; it with ===.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; To spell this out (because I had to think about it for a second): === will be derived from<br>&gt;&gt; &lt;=&gt;, but also becomes default implementation for ==, which remains open for customization.<br>&gt;&gt; <br>&gt;&gt; I like this idea. If we keep === as a separate thing, now users have 3 “opportunities” to define<br>&gt;&gt; equality. The must be few, if any, use cases for this.<br>&gt;&gt; <br>&gt;&gt; Would love to see if anyone on the list can give us an example. Otherwise we should make<br>&gt;&gt; areSame === again™!<br>&gt; <br>&gt; If `===` is the new `areSame`, and `Hashable` is based on `===`, wouldn&#39;t that mean that objects could only be hashed (and thus, be looked up in Dictionary and Set) by identity? So, for instance, code like this:<br>&gt; <br>&gt; 	var set = Set&lt;NSString&gt;()<br>&gt; 	<br>&gt; 	set.insert(&quot;test&quot;)<br>&gt; 	set.insert(&quot;test&quot;)<br>&gt; 	<br>&gt; 	print(set.count)<br>&gt; <br>&gt; Would print &quot;2&quot;? Or worse, might print &quot;1&quot; or &quot;2&quot; depending on the details of how Swift generates literals and Foundation implements short strings?<br>&gt; <br>&gt; Am I the only one who thinks that&#39;s a problem?<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July 22, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jul 22, 2016, at 9:00 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Jul 22, 2016, at 4:55 PM, Daniel Duan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Well, it&#39;s still a very real question whether we ought to have the<br>&gt;&gt;&gt; additional API surface implied by areSame, or wether we should collapse<br>&gt;&gt;&gt; it with ===.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; To spell this out (because I had to think about it for a second): === will be derived from<br>&gt;&gt; &lt;=&gt;, but also becomes default implementation for ==, which remains open for customization.<br>&gt;&gt; <br>&gt;&gt; I like this idea. If we keep === as a separate thing, now users have 3 “opportunities” to define<br>&gt;&gt; equality. The must be few, if any, use cases for this.<br>&gt;&gt; <br>&gt;&gt; Would love to see if anyone on the list can give us an example. Otherwise we should make<br>&gt;&gt; areSame === again™!<br>&gt; <br>&gt; If `===` is the new `areSame`, and `Hashable` is based on `===`, wouldn&#39;t that mean that objects could only be hashed (and thus, be looked up in Dictionary and Set) by identity? So, for instance, code like this:<br>&gt; <br>&gt; 	var set = Set&lt;NSString&gt;()<br>&gt; 	<br>&gt; 	set.insert(&quot;test&quot;)<br>&gt; 	set.insert(&quot;test&quot;)<br>&gt; 	<br>&gt; 	print(set.count)<br>&gt; <br>&gt; Would print &quot;2&quot;? Or worse, might print &quot;1&quot; or &quot;2&quot; depending on the details of how Swift generates literals and Foundation implements short strings?<br>&gt; <br>&gt; Am I the only one who thinks that&#39;s a problem?<br></p><p>This is super unfortunate.  The question is how hard we’re willing to push the need to implement types representing conceptual values as value types.  It seems like the right thing to do for the long run.  A “workaround” would be to use NSSet if you have to use Objective-C types that represent conceptual values.<br></p><p><br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July 22, 2016 at 07:00:00pm</p></header><div class="content"><p>on Fri Jul 22 2016, Brent Royal-Gordon &lt;brent-AT-architechies.com&gt; wrote:<br></p><p>&gt;&gt; On Jul 22, 2016, at 4:55 PM, Daniel Duan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Well, it&#39;s still a very real question whether we ought to have the<br>&gt;&gt;&gt; additional API surface implied by areSame, or wether we should collapse<br>&gt;&gt;&gt; it with ===.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; To spell this out (because I had to think about it for a second): === will be derived from<br>&gt;&gt; &lt;=&gt;, but also becomes default implementation for ==, which remains open for customization.<br>&gt;&gt; <br>&gt;&gt; I like this idea. If we keep === as a separate thing, now users have 3 “opportunities” to define<br>&gt;&gt; equality. The must be few, if any, use cases for this.<br>&gt;&gt; <br>&gt;&gt; Would love to see if anyone on the list can give us an example. Otherwise we should make<br>&gt;&gt; areSame === again™!<br>&gt;<br>&gt; If `===` is the new `areSame`, and `Hashable` is based on `===`,<br>&gt; wouldn&#39;t that mean that objects could only be hashed (and thus, be<br>&gt; looked up in Dictionary and Set) by identity? So, for instance, code<br>&gt; like this:<br>&gt;<br>&gt; 	var set = Set&lt;NSString&gt;()<br>&gt;<br>&gt; 	set.insert(&quot;test&quot;)<br>&gt; 	set.insert(&quot;test&quot;)<br>&gt;<br>&gt; 	print(set.count)<br>&gt;<br>&gt; Would print &quot;2&quot;? Or worse, might print &quot;1&quot; or &quot;2&quot; depending on the<br>&gt; details of how Swift generates literals and Foundation implements<br>&gt; short strings?<br>&gt;<br>&gt; Am I the only one who thinks that&#39;s a problem?<br></p><p>No, NSString&#39;s conformance to Identifiable (probably NSObject&#39;s,<br>actually) would define `===` in terms of `isEqual()`.  That&#39;s saying<br>identity for these types is determined by `isEqual()`.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>July 22, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Jul 22, 2016, at 7:23 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; No, NSString&#39;s conformance to Identifiable (probably NSObject&#39;s,<br>&gt; actually) would define `===` in terms of `isEqual()`.  That&#39;s saying<br>&gt; identity for these types is determined by `isEqual()`.<br></p><p>So `===` no longer tests if both instances are the same? What&#39;s the way to do that now—`ObjectIdentifier(lhs) == ObjectIdentifier(rhs)`? (Should it still be called &quot;Identifier&quot; if we&#39;re taking the term &quot;identifiable&quot; for something else? Do we need to change the general term &quot;identity&quot;, as in &quot;instances of reference types have an identity&quot;?)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July 22, 2016 at 07:00:00pm</p></header><div class="content"><p>on Fri Jul 22 2016, Brent Royal-Gordon &lt;brent-AT-architechies.com&gt; wrote:<br></p><p>&gt;&gt; On Jul 22, 2016, at 7:23 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; No, NSString&#39;s conformance to Identifiable (probably NSObject&#39;s,<br>&gt;&gt; actually) would define `===` in terms of `isEqual()`.  That&#39;s saying<br>&gt;&gt; identity for these types is determined by `isEqual()`.<br>&gt;<br>&gt; So `===` no longer tests if both instances are the same? <br></p><p>In a very real sense, it does test exactly that.  It no longer tests if<br>there&#39;s only one instance behind the two references.<br></p><p>&gt; What&#39;s the way to do that now—`ObjectIdentifier(lhs) ==<br>&gt; ObjectIdentifier(rhs)`?  <br></p><p>That&#39;s how you test if there&#39;s really only one instance.<br></p><p>&gt; (Should it still be called &quot;Identifier&quot; if we&#39;re taking the term<br>&gt; &quot;identifiable&quot; for something else? <br>&gt; Do we need to change the general term &quot;identity&quot;, as in &quot;instances of<br>&gt; reference types have an identity&quot;?)<br></p><p>Good questions; we should keep them in mind as we figure out the naming.<br></p><p><br>-- <br>Dave<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
