<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[proposal] Move @noescape and @autoclosure to type attributes</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>March  9, 2016 at 09:00:00pm</p></header><div class="content"><p>Introduction<br></p><p>This proposal suggests moving the existing @noescape and @autoclosure attributes from being declaration attributes on a parameter to being type attributes.  This improves consistency and reduces redundancy within the language, e.g. aligning with the previous Swift 3 decision to move “inout”, and making declaration and type syntax more consistent. <br></p><p>Swift-evolution thread: &lt;you are here&gt;<br></p><p>Motivation<br></p><p>Chris Eidhof noticed an emergent result of removing our currying syntax: it broke some useful code using @noescape, because we only allowed it on parameter declarations, not on general things-of-function-type.  This meant that manually curried code like this:<br></p><p>func curriedFlatMap&lt;A, B&gt;(x: [A]) -&gt; (@noescape A -&gt; [B]) -&gt; [B] {<br>   return { f in<br>       x.flatMap(f)<br>   }<br>}<br></p><p>Was rejected.  Fixing this was straight-forward (https://github.com/apple/swift/commit/c3c6beac72bc0368030f06d52c46b6444fc48dbd &lt;https://github.com/apple/swift/commit/c3c6beac72bc0368030f06d52c46b6444fc48dbd&gt;), but required @noescape being allowed on arbitrary function types.  Now that we have that, these two declarations are equivalent:<br></p><p>	func f(@noescape fn : () -&gt; ()) {}  // declaration attribute<br>	func f(fn : @noescape () -&gt; ()) {}  // type attribute.<br></p><p>Further evaluation of the situation found that @autoclosure (while less pressing) has the exact same problem.  That said, it is currently in a worse place than @noescape because you cannot actually spell the type of a function that involves it.   Consider an autoclosure-taking function like this:<br></p><p>	func f2(@autoclosure a : () -&gt; ()) {}<br></p><p>You can use it as you’d expect, e.g.:<br></p><p>	f2(print(&quot;hello”))<br></p><p>Of course, f2 is a first class value, so you can assign it:<br></p><p>	let x = f2<br>	x(print(&quot;hello&quot;))<br></p><p>This works, because x has type &quot;(@autoclosure () -&gt; ()) -&gt; ()”.  You can see this if you force a type error:<br></p><p>	let y : Int = x // error: cannot convert value of type &#39;(@autoclosure () -&gt; ()) -&gt; ()&#39; to specified type &#39;Int&#39;<br></p><p>However, you can’t write this out explicitly:<br></p><p>	let x2 : (@autoclosure () -&gt; ()) -&gt; () = f2<br>	// error: attribute can only be applied to declarations, not types<br></p><p>This is unfortunate because it is an arbitrary inconsistency in the language, and seems silly that you can use type inference but not manual specification for the declaration of x2.<br></p><p>Proposed solution<br></p><p>The solution solution is straight-forward: disallow @noescape and @autoclosure on declarations, and instead require them on the types.  This means that only the type-attribute syntax is supported:<br></p><p>	func f(fn : @noescape () -&gt; ()) {}      // type attribute.<br>	func f2(a : @autoclosure () -&gt; ()) {}  // type attribute.<br></p><p>This aligns with the syntax used for types, since the type of “f” is “(_: @noescape () -&gt; ()) -&gt; ()”, and the type of “f2” is “(_ : @autoclosure () -&gt; ()) -&gt; ()”.  This fixes the problem with x2, and eliminates the redundancy between the @noescape forms.<br></p><p>Impact on existing code<br></p><p>This breaks existing code that uses these in the old position, so it would be great to roll this out with the other disruptive changes happening in Swift 3.  The Swift 3 migrator should move these over, and has the information it needs to do a perfect migration in this case.<br></p><p>For the compiler behavior, given that Swift 2.2 code will be source incompatible with Swift 3 code in general, it seems best to make these a hard error in the final Swift 3 release.  It would make sense to have a deprecation warning period for swift.org projects like corelibs and swiftpm, and other open source users tracking the public releases though.<br></p><p>-Chris<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160309/a5ce9552/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4002684831b0a89736f4837d2e60f66a?s=50"></div><header><strong>[proposal] Move @noescape and @autoclosure to type attributes</strong> from <string>Pierre Monod-Broca</string> &lt;pierremonodbroca at gmail.com&gt;<p>March 14, 2016 at 02:00:00pm</p></header><div class="content"><p>It makes sense, and worth the change, IMHO. <br></p><p>Pierre<br></p><p>&gt; Le 10 mars 2016 à 06:38, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Introduction<br>&gt; <br>&gt; This proposal suggests moving the existing @noescape and @autoclosure attributes from being declaration attributes on a parameter to being type attributes.  This improves consistency and reduces redundancy within the language, e.g. aligning with the previous Swift 3 decision to move “inout”, and making declaration and type syntax more consistent. <br>&gt; <br>&gt; Swift-evolution thread: &lt;you are here&gt;<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; Chris Eidhof noticed an emergent result of removing our currying syntax: it broke some useful code using @noescape, because we only allowed it on parameter declarations, not on general things-of-function-type.  This meant that manually curried code like this:<br>&gt; <br>&gt; func curriedFlatMap&lt;A, B&gt;(x: [A]) -&gt; (@noescape A -&gt; [B]) -&gt; [B] {<br>&gt;    return { f in<br>&gt;        x.flatMap(f)<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; Was rejected.  Fixing this was straight-forward (https://github.com/apple/swift/commit/c3c6beac72bc0368030f06d52c46b6444fc48dbd), but required @noescape being allowed on arbitrary function types.  Now that we have that, these two declarations are equivalent:<br>&gt; <br>&gt; 	func f(@noescape fn : () -&gt; ()) {}  // declaration attribute<br>&gt; 	func f(fn : @noescape () -&gt; ()) {}  // type attribute.<br>&gt; <br>&gt; Further evaluation of the situation found that @autoclosure (while less pressing) has the exact same problem.  That said, it is currently in a worse place than @noescape because you cannot actually spell the type of a function that involves it.   Consider an autoclosure-taking function like this:<br>&gt; <br>&gt; 	func f2(@autoclosure a : () -&gt; ()) {}<br>&gt; <br>&gt; You can use it as you’d expect, e.g.:<br>&gt; <br>&gt; 	f2(print(&quot;hello”))<br>&gt; <br>&gt; Of course, f2 is a first class value, so you can assign it:<br>&gt; <br>&gt; 	let x = f2<br>&gt; 	x(print(&quot;hello&quot;))<br>&gt; <br>&gt; This works, because x has type &quot;(@autoclosure () -&gt; ()) -&gt; ()”.  You can see this if you force a type error:<br>&gt; <br>&gt; 	let y : Int = x // error: cannot convert value of type &#39;(@autoclosure () -&gt; ()) -&gt; ()&#39; to specified type &#39;Int&#39;<br>&gt; <br>&gt; However, you can’t write this out explicitly:<br>&gt; <br>&gt; 	let x2 : (@autoclosure () -&gt; ()) -&gt; () = f2<br>&gt; 	// error: attribute can only be applied to declarations, not types<br>&gt; <br>&gt; This is unfortunate because it is an arbitrary inconsistency in the language, and seems silly that you can use type inference but not manual specification for the declaration of x2.<br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; The solution solution is straight-forward: disallow @noescape and @autoclosure on declarations, and instead require them on the types.  This means that only the type-attribute syntax is supported:<br>&gt; <br>&gt; 	func f(fn : @noescape () -&gt; ()) {}      // type attribute.<br>&gt; 	func f2(a : @autoclosure () -&gt; ()) {}  // type attribute.<br>&gt; <br>&gt; This aligns with the syntax used for types, since the type of “f” is “(_: @noescape () -&gt; ()) -&gt; ()”, and the type of “f2” is “(_ : @autoclosure () -&gt; ()) -&gt; ()”.  This fixes the problem with x2, and eliminates the redundancy between the @noescape forms.<br>&gt; <br>&gt; Impact on existing code<br>&gt; <br>&gt; This breaks existing code that uses these in the old position, so it would be great to roll this out with the other disruptive changes happening in Swift 3.  The Swift 3 migrator should move these over, and has the information it needs to do a perfect migration in this case.<br>&gt; <br>&gt; For the compiler behavior, given that Swift 2.2 code will be source incompatible with Swift 3 code in general, it seems best to make these a hard error in the final Swift 3 release.  It would make sense to have a deprecation warning period for swift.org projects like corelibs and swiftpm, and other open source users tracking the public releases though.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160314/65821189/attachment-0001.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d30e546d655d1c7ece0464791a9a90d5?s=50"></div><header><strong>[proposal] Move @noescape and @autoclosure to type attributes</strong> from <string>Adrian Kashivskyy</string> &lt;adrian.kashivskyy at me.com&gt;<p>March 15, 2016 at 11:00:00am</p></header><div class="content"><p>+1. In my opinion it fits well with recent changes.<br></p><p><br>Pozdrawiam – Regards,<br>Adrian Kashivskyy<br></p><p>&gt; Wiadomość napisana przez Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; w dniu 10.03.2016, o godz. 06:38:<br>&gt; <br>&gt; Introduction<br>&gt; <br>&gt; This proposal suggests moving the existing @noescape and @autoclosure attributes from being declaration attributes on a parameter to being type attributes.  This improves consistency and reduces redundancy within the language, e.g. aligning with the previous Swift 3 decision to move “inout”, and making declaration and type syntax more consistent. <br>&gt; <br>&gt; Swift-evolution thread: &lt;you are here&gt;<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; Chris Eidhof noticed an emergent result of removing our currying syntax: it broke some useful code using @noescape, because we only allowed it on parameter declarations, not on general things-of-function-type.  This meant that manually curried code like this:<br>&gt; <br>&gt; func curriedFlatMap&lt;A, B&gt;(x: [A]) -&gt; (@noescape A -&gt; [B]) -&gt; [B] {<br>&gt;    return { f in<br>&gt;        x.flatMap(f)<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; Was rejected.  Fixing this was straight-forward (https://github.com/apple/swift/commit/c3c6beac72bc0368030f06d52c46b6444fc48dbd &lt;https://github.com/apple/swift/commit/c3c6beac72bc0368030f06d52c46b6444fc48dbd&gt;), but required @noescape being allowed on arbitrary function types.  Now that we have that, these two declarations are equivalent:<br>&gt; <br>&gt; 	func f(@noescape fn : () -&gt; ()) {}  // declaration attribute<br>&gt; 	func f(fn : @noescape () -&gt; ()) {}  // type attribute.<br>&gt; <br>&gt; Further evaluation of the situation found that @autoclosure (while less pressing) has the exact same problem.  That said, it is currently in a worse place than @noescape because you cannot actually spell the type of a function that involves it.   Consider an autoclosure-taking function like this:<br>&gt; <br>&gt; 	func f2(@autoclosure a : () -&gt; ()) {}<br>&gt; <br>&gt; You can use it as you’d expect, e.g.:<br>&gt; <br>&gt; 	f2(print(&quot;hello”))<br>&gt; <br>&gt; Of course, f2 is a first class value, so you can assign it:<br>&gt; <br>&gt; 	let x = f2<br>&gt; 	x(print(&quot;hello&quot;))<br>&gt; <br>&gt; This works, because x has type &quot;(@autoclosure () -&gt; ()) -&gt; ()”.  You can see this if you force a type error:<br>&gt; <br>&gt; 	let y : Int = x // error: cannot convert value of type &#39;(@autoclosure () -&gt; ()) -&gt; ()&#39; to specified type &#39;Int&#39;<br>&gt; <br>&gt; However, you can’t write this out explicitly:<br>&gt; <br>&gt; 	let x2 : (@autoclosure () -&gt; ()) -&gt; () = f2<br>&gt; 	// error: attribute can only be applied to declarations, not types<br>&gt; <br>&gt; This is unfortunate because it is an arbitrary inconsistency in the language, and seems silly that you can use type inference but not manual specification for the declaration of x2.<br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; The solution solution is straight-forward: disallow @noescape and @autoclosure on declarations, and instead require them on the types.  This means that only the type-attribute syntax is supported:<br>&gt; <br>&gt; 	func f(fn : @noescape () -&gt; ()) {}      // type attribute.<br>&gt; 	func f2(a : @autoclosure () -&gt; ()) {}  // type attribute.<br>&gt; <br>&gt; This aligns with the syntax used for types, since the type of “f” is “(_: @noescape () -&gt; ()) -&gt; ()”, and the type of “f2” is “(_ : @autoclosure () -&gt; ()) -&gt; ()”.  This fixes the problem with x2, and eliminates the redundancy between the @noescape forms.<br>&gt; <br>&gt; Impact on existing code<br>&gt; <br>&gt; This breaks existing code that uses these in the old position, so it would be great to roll this out with the other disruptive changes happening in Swift 3.  The Swift 3 migrator should move these over, and has the information it needs to do a perfect migration in this case.<br>&gt; <br>&gt; For the compiler behavior, given that Swift 2.2 code will be source incompatible with Swift 3 code in general, it seems best to make these a hard error in the final Swift 3 release.  It would make sense to have a deprecation warning period for swift.org &lt;http://swift.org/&gt; projects like corelibs and swiftpm, and other open source users tracking the public releases though.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160315/15599161/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ea125c5cd93ba84769387c17c973e2b3?s=50"></div><header><strong>[proposal] Move @noescape and @autoclosure to type attributes</strong> from <string>rintaro ishizaki</string> &lt;fs.output at gmail.com&gt;<p>March 28, 2016 at 02:00:00pm</p></header><div class="content"><p>After this proposal [SE-0049] is accepted:<br></p><p>Is the following code valid?<br></p><p>func foo(arg: @autoclosure () -&gt; Bool) { }<br>let value: @autoclosure () -&gt; Bool = false<br>foo(value)<br></p><p>If so, I feel `@autoclosure T` is more natural than `@autoclosure () -&gt; T`<br></p><p>let value: @autoclosure Bool = false<br>func foo(arg: @autoclosure Bool) {<br>   if arg() { ... }<br>}<br>foo(x)<br></p><p><br></p><p>2016-03-10 14:38 GMT+09:00 Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt;:<br></p><p>&gt;<br>&gt; *Introduction*<br>&gt; This proposal suggests moving the existing @noescape and @autoclosure<br>&gt; attributes from being declaration attributes on a parameter to being type<br>&gt; attributes.  This improves consistency and reduces redundancy within the<br>&gt; language, e.g. aligning with the previous Swift 3 decision to move “inout”,<br>&gt; and making declaration and type syntax more consistent.<br>&gt;<br>&gt; Swift-evolution thread: &lt;you are here&gt;<br>&gt;<br>&gt;<br>&gt; *Motivation*<br>&gt; Chris Eidhof noticed an emergent result of removing our currying syntax:<br>&gt; it broke some useful code using @noescape, because we only allowed it on<br>&gt; parameter declarations, not on general things-of-function-type.  This meant<br>&gt; that manually curried code like this:<br>&gt;<br>&gt; func curriedFlatMap&lt;A, B&gt;(x: [A]) -&gt; (@noescape A -&gt; [B]) -&gt; [B] {<br>&gt;    return { f in<br>&gt;        x.flatMap(f)<br>&gt;    }<br>&gt; }<br>&gt;<br>&gt; Was rejected.  Fixing this was straight-forward (<br>&gt; https://github.com/apple/swift/commit/c3c6beac72bc0368030f06d52c46b6444fc48dbd),<br>&gt; but required @noescape being allowed on arbitrary function types.  Now that<br>&gt; we have that, these two declarations are equivalent:<br>&gt;<br>&gt; func f(@noescape fn : () -&gt; ()) {}  // declaration attribute<br>&gt; func f(fn : @noescape () -&gt; ()) {}  // type attribute.<br>&gt;<br>&gt; Further evaluation of the situation found that @autoclosure (while less<br>&gt; pressing) has the exact same problem.  That said, it is currently in a<br>&gt; worse place than @noescape because you cannot actually spell the type of a<br>&gt; function that involves it.   Consider an autoclosure-taking function like<br>&gt; this:<br>&gt;<br>&gt; func f2(@autoclosure a : () -&gt; ()) {}<br>&gt;<br>&gt; You can use it as you’d expect, e.g.:<br>&gt;<br>&gt; f2(print(&quot;hello”))<br>&gt;<br>&gt; Of course, f2 is a first class value, so you can assign it:<br>&gt;<br>&gt; let x = f2<br>&gt; x(print(&quot;hello&quot;))<br>&gt;<br>&gt; This works, because x has type &quot;(@autoclosure () -&gt; ()) -&gt; ()”.  You can<br>&gt; see this if you force a type error:<br>&gt;<br>&gt; let y : Int = x // error: cannot convert value of type &#39;(@autoclosure ()<br>&gt; -&gt; ()) -&gt; ()&#39; to specified type &#39;Int&#39;<br>&gt;<br>&gt; However, you can’t write this out explicitly:<br>&gt;<br>&gt; let x2 : (@autoclosure () -&gt; ()) -&gt; () = f2<br>&gt; // error: attribute can only be applied to declarations, not types<br>&gt;<br>&gt; This is unfortunate because it is an arbitrary inconsistency in the<br>&gt; language, and seems silly that you can use type inference but not manual<br>&gt; specification for the declaration of x2.<br>&gt;<br>&gt;<br>&gt; *Proposed solution*<br>&gt; The solution solution is straight-forward: disallow @noescape and<br>&gt; @autoclosure on declarations, and instead require them on the types.  This<br>&gt; means that only the type-attribute syntax is supported:<br>&gt;<br>&gt; func f(fn : @noescape () -&gt; ()) {}      // type attribute.<br>&gt; func f2(a : @autoclosure () -&gt; ()) {}  // type attribute.<br>&gt;<br>&gt; This aligns with the syntax used for types, since the type of “f” is<br>&gt; “(_: @noescape () -&gt; ()) -&gt; ()”, and the type of “f2” is “(_ : @autoclosure<br>&gt; () -&gt; ()) -&gt; ()”.  This fixes the problem with x2, and eliminates the<br>&gt; redundancy between the @noescape forms.<br>&gt;<br>&gt;<br>&gt; *Impact on existing code*<br>&gt; This breaks existing code that uses these in the old position, so it would<br>&gt; be great to roll this out with the other disruptive changes happening in<br>&gt; Swift 3.  The Swift 3 migrator should move these over, and has the<br>&gt; information it needs to do a perfect migration in this case.<br>&gt;<br>&gt; For the compiler behavior, given that Swift 2.2 code will be source<br>&gt; incompatible with Swift 3 code in general, it seems best to make these a<br>&gt; hard error in the final Swift 3 release.  It would make sense to have a<br>&gt; deprecation warning period for swift.org projects like corelibs and<br>&gt; swiftpm, and other open source users tracking the public releases though.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160328/b0ae5c1a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[proposal] Move @noescape and @autoclosure to type attributes</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>March 27, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Mar 27, 2016, at 10:24 PM, rintaro ishizaki &lt;fs.output at gmail.com&gt; wrote:<br>&gt; <br>&gt; After this proposal [SE-0049] is accepted:<br>&gt; <br>&gt; Is the following code valid?<br>&gt; <br>&gt; func foo(arg: @autoclosure () -&gt; Bool) { }<br>&gt; let value: @autoclosure () -&gt; Bool = false<br>&gt; foo(value)<br></p><p>No, autoclosures may still only be used as parameters to functions.<br></p><p>-Chris<br></p><p>&gt; <br>&gt; If so, I feel `@autoclosure T` is more natural than `@autoclosure () -&gt; T`<br>&gt; <br>&gt; let value: @autoclosure Bool = false<br>&gt; func foo(arg: @autoclosure Bool) {<br>&gt;    if arg() { ... }<br>&gt; }<br>&gt; foo(x)<br>&gt; <br>&gt; <br>&gt; <br>&gt; 2016-03-10 14:38 GMT+09:00 Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; Introduction<br>&gt; <br>&gt; This proposal suggests moving the existing @noescape and @autoclosure attributes from being declaration attributes on a parameter to being type attributes.  This improves consistency and reduces redundancy within the language, e.g. aligning with the previous Swift 3 decision to move “inout”, and making declaration and type syntax more consistent. <br>&gt; <br>&gt; Swift-evolution thread: &lt;you are here&gt;<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; Chris Eidhof noticed an emergent result of removing our currying syntax: it broke some useful code using @noescape, because we only allowed it on parameter declarations, not on general things-of-function-type.  This meant that manually curried code like this:<br>&gt; <br>&gt; func curriedFlatMap&lt;A, B&gt;(x: [A]) -&gt; (@noescape A -&gt; [B]) -&gt; [B] {<br>&gt;    return { f in<br>&gt;        x.flatMap(f)<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; Was rejected.  Fixing this was straight-forward (https://github.com/apple/swift/commit/c3c6beac72bc0368030f06d52c46b6444fc48dbd &lt;https://github.com/apple/swift/commit/c3c6beac72bc0368030f06d52c46b6444fc48dbd&gt;), but required @noescape being allowed on arbitrary function types.  Now that we have that, these two declarations are equivalent:<br>&gt; <br>&gt; 	func f(@noescape fn : () -&gt; ()) {}  // declaration attribute<br>&gt; 	func f(fn : @noescape () -&gt; ()) {}  // type attribute.<br>&gt; <br>&gt; Further evaluation of the situation found that @autoclosure (while less pressing) has the exact same problem.  That said, it is currently in a worse place than @noescape because you cannot actually spell the type of a function that involves it.   Consider an autoclosure-taking function like this:<br>&gt; <br>&gt; 	func f2(@autoclosure a : () -&gt; ()) {}<br>&gt; <br>&gt; You can use it as you’d expect, e.g.:<br>&gt; <br>&gt; 	f2(print(&quot;hello”))<br>&gt; <br>&gt; Of course, f2 is a first class value, so you can assign it:<br>&gt; <br>&gt; 	let x = f2<br>&gt; 	x(print(&quot;hello&quot;))<br>&gt; <br>&gt; This works, because x has type &quot;(@autoclosure () -&gt; ()) -&gt; ()”.  You can see this if you force a type error:<br>&gt; <br>&gt; 	let y : Int = x // error: cannot convert value of type &#39;(@autoclosure () -&gt; ()) -&gt; ()&#39; to specified type &#39;Int&#39;<br>&gt; <br>&gt; However, you can’t write this out explicitly:<br>&gt; <br>&gt; 	let x2 : (@autoclosure () -&gt; ()) -&gt; () = f2<br>&gt; 	// error: attribute can only be applied to declarations, not types<br>&gt; <br>&gt; This is unfortunate because it is an arbitrary inconsistency in the language, and seems silly that you can use type inference but not manual specification for the declaration of x2.<br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; The solution solution is straight-forward: disallow @noescape and @autoclosure on declarations, and instead require them on the types.  This means that only the type-attribute syntax is supported:<br>&gt; <br>&gt; 	func f(fn : @noescape () -&gt; ()) {}      // type attribute.<br>&gt; 	func f2(a : @autoclosure () -&gt; ()) {}  // type attribute.<br>&gt; <br>&gt; This aligns with the syntax used for types, since the type of “f” is “(_: @noescape () -&gt; ()) -&gt; ()”, and the type of “f2” is “(_ : @autoclosure () -&gt; ()) -&gt; ()”.  This fixes the problem with x2, and eliminates the redundancy between the @noescape forms.<br>&gt; <br>&gt; Impact on existing code<br>&gt; <br>&gt; This breaks existing code that uses these in the old position, so it would be great to roll this out with the other disruptive changes happening in Swift 3.  The Swift 3 migrator should move these over, and has the information it needs to do a perfect migration in this case.<br>&gt; <br>&gt; For the compiler behavior, given that Swift 2.2 code will be source incompatible with Swift 3 code in general, it seems best to make these a hard error in the final Swift 3 release.  It would make sense to have a deprecation warning period for swift.org &lt;http://swift.org/&gt; projects like corelibs and swiftpm, and other open source users tracking the public releases though.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160327/65af97c8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[proposal] Move @noescape and @autoclosure to type attributes</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>March 28, 2016 at 07:00:00pm</p></header><div class="content"><p>+1<br></p><p>On Monday, 28 March 2016, Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Mar 27, 2016, at 10:24 PM, rintaro ishizaki &lt;fs.output at gmail.com<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;fs.output at gmail.com&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt; After this proposal [SE-0049] is accepted:<br>&gt;<br>&gt; Is the following code valid?<br>&gt;<br>&gt; func foo(arg: @autoclosure () -&gt; Bool) { }<br>&gt; let value: @autoclosure () -&gt; Bool = false<br>&gt; foo(value)<br>&gt;<br>&gt;<br>&gt; No, autoclosures may still only be used as parameters to functions.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>&gt; If so, I feel `@autoclosure T` is more natural than `@autoclosure () -&gt; T`<br>&gt;<br>&gt; let value: @autoclosure Bool = false<br>&gt; func foo(arg: @autoclosure Bool) {<br>&gt;    if arg() { ... }<br>&gt; }<br>&gt; foo(x)<br>&gt;<br>&gt;<br>&gt;<br>&gt; 2016-03-10 14:38 GMT+09:00 Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt;:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; *Introduction*<br>&gt;&gt; This proposal suggests moving the existing @noescape and @autoclosure<br>&gt;&gt; attributes from being declaration attributes on a parameter to being type<br>&gt;&gt; attributes.  This improves consistency and reduces redundancy within the<br>&gt;&gt; language, e.g. aligning with the previous Swift 3 decision to move “inout”,<br>&gt;&gt; and making declaration and type syntax more consistent.<br>&gt;&gt;<br>&gt;&gt; Swift-evolution thread: &lt;you are here&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *Motivation*<br>&gt;&gt; Chris Eidhof noticed an emergent result of removing our currying syntax:<br>&gt;&gt; it broke some useful code using @noescape, because we only allowed it on<br>&gt;&gt; parameter declarations, not on general things-of-function-type.  This meant<br>&gt;&gt; that manually curried code like this:<br>&gt;&gt;<br>&gt;&gt; func curriedFlatMap&lt;A, B&gt;(x: [A]) -&gt; (@noescape A -&gt; [B]) -&gt; [B] {<br>&gt;&gt;    return { f in<br>&gt;&gt;        x.flatMap(f)<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Was rejected.  Fixing this was straight-forward (<br>&gt;&gt; https://github.com/apple/swift/commit/c3c6beac72bc0368030f06d52c46b6444fc48dbd),<br>&gt;&gt; but required @noescape being allowed on arbitrary function types.  Now that<br>&gt;&gt; we have that, these two declarations are equivalent:<br>&gt;&gt;<br>&gt;&gt; func f(@noescape fn : () -&gt; ()) {}  // declaration attribute<br>&gt;&gt; func f(fn : @noescape () -&gt; ()) {}  // type attribute.<br>&gt;&gt;<br>&gt;&gt; Further evaluation of the situation found that @autoclosure (while less<br>&gt;&gt; pressing) has the exact same problem.  That said, it is currently in a<br>&gt;&gt; worse place than @noescape because you cannot actually spell the type of a<br>&gt;&gt; function that involves it.   Consider an autoclosure-taking function like<br>&gt;&gt; this:<br>&gt;&gt;<br>&gt;&gt; func f2(@autoclosure a : () -&gt; ()) {}<br>&gt;&gt;<br>&gt;&gt; You can use it as you’d expect, e.g.:<br>&gt;&gt;<br>&gt;&gt; f2(print(&quot;hello”))<br>&gt;&gt;<br>&gt;&gt; Of course, f2 is a first class value, so you can assign it:<br>&gt;&gt;<br>&gt;&gt; let x = f2<br>&gt;&gt; x(print(&quot;hello&quot;))<br>&gt;&gt;<br>&gt;&gt; This works, because x has type &quot;(@autoclosure () -&gt; ()) -&gt; ()”.  You can<br>&gt;&gt; see this if you force a type error:<br>&gt;&gt;<br>&gt;&gt; let y : Int = x // error: cannot convert value of type &#39;(@autoclosure ()<br>&gt;&gt; -&gt; ()) -&gt; ()&#39; to specified type &#39;Int&#39;<br>&gt;&gt;<br>&gt;&gt; However, you can’t write this out explicitly:<br>&gt;&gt;<br>&gt;&gt; let x2 : (@autoclosure () -&gt; ()) -&gt; () = f2<br>&gt;&gt; // error: attribute can only be applied to declarations, not types<br>&gt;&gt;<br>&gt;&gt; This is unfortunate because it is an arbitrary inconsistency in the<br>&gt;&gt; language, and seems silly that you can use type inference but not manual<br>&gt;&gt; specification for the declaration of x2.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *Proposed solution*<br>&gt;&gt; The solution solution is straight-forward: disallow @noescape and<br>&gt;&gt; @autoclosure on declarations, and instead require them on the types.  This<br>&gt;&gt; means that only the type-attribute syntax is supported:<br>&gt;&gt;<br>&gt;&gt; func f(fn : @noescape () -&gt; ()) {}      // type attribute.<br>&gt;&gt; func f2(a : @autoclosure () -&gt; ()) {}  // type attribute.<br>&gt;&gt;<br>&gt;&gt; This aligns with the syntax used for types, since the type of “f” is<br>&gt;&gt; “(_: @noescape () -&gt; ()) -&gt; ()”, and the type of “f2” is “(_ : @autoclosure<br>&gt;&gt; () -&gt; ()) -&gt; ()”.  This fixes the problem with x2, and eliminates the<br>&gt;&gt; redundancy between the @noescape forms.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *Impact on existing code*<br>&gt;&gt; This breaks existing code that uses these in the old position, so it<br>&gt;&gt; would be great to roll this out with the other disruptive changes happening<br>&gt;&gt; in Swift 3.  The Swift 3 migrator should move these over, and has the<br>&gt;&gt; information it needs to do a perfect migration in this case.<br>&gt;&gt;<br>&gt;&gt; For the compiler behavior, given that Swift 2.2 code will be source<br>&gt;&gt; incompatible with Swift 3 code in general, it seems best to make these a<br>&gt;&gt; hard error in the final Swift 3 release.  It would make sense to have a<br>&gt;&gt; deprecation warning period for swift.org projects like corelibs and<br>&gt;&gt; swiftpm, and other open source users tracking the public releases though.<br>&gt;&gt;<br>&gt;&gt; -Chris<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br></p><p>-- <br>-- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160328/6ca3c7a6/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
