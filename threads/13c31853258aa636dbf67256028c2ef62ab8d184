<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Mini-proposal] Require @nonobjc on members of @objc protocol extensions</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January  4, 2016 at 08:00:00pm</p></header><div class="content"><p>Hi all,<br></p><p>We currently have a bit of a surprise when one extends an @objc protocol:<br></p><p>@objc protocol P { }<br></p><p>extension P {<br>  func bar() { }<br>}<br></p><p>class C : NSObject { }<br></p><p>let c = C()<br>print(c.respondsToSelector(&quot;bar&quot;)) // prints &quot;false&quot;<br></p><p>because the members of the extension are not exposed to the Objective-C runtime. <br></p><p>There is no direct way to implement Objective-C entry points for protocol extensions. One would effectively have to install a category on every Objective-C root class [*] with the default implementation or somehow intercept all of the operations that might involve that selector. <br></p><p>Alternately, and more simply, we could require @nonobjc on members of @objc protocol extensions, as an explicit indicator that the member is not exposed to Objective-C. It’ll eliminate surprise and, should we ever find both the mechanism and motivation to make default implementations of @objc protocol extension members work, we could easily remove the restriction at that time.<br></p><p>	- Doug<br></p><p>[*] Assuming you can enumerate them, although NSObject and the hidden SwiftObject cover the 99%. Even so, that it’s correct either, because the root class itself might default such a method, and the category version would conflict with it, so...<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160104/13c3d184/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Mini-proposal] Require @nonobjc on members of @objc protocol extensions</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January  4, 2016 at 11:00:00pm</p></header><div class="content"><p>For the folks who don&#39;t mix Swift and Objective-C that much, extensions on @objc classes are exposed to the Objective-C runtime, so there is a discrepancy here. I&#39;m not passionate about the outcome, just dropping the info.<br></p><p>Félix<br></p><p>&gt; Le 4 janv. 2016 à 23:32:25, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; We currently have a bit of a surprise when one extends an @objc protocol:<br>&gt; <br>&gt; @objc protocol P { }<br>&gt; <br>&gt; extension P {<br>&gt;   func bar() { }<br>&gt; }<br>&gt; <br>&gt; class C : NSObject { }<br>&gt; <br>&gt; let c = C()<br>&gt; print(c.respondsToSelector(&quot;bar&quot;)) // prints &quot;false&quot;<br>&gt; <br>&gt; because the members of the extension are not exposed to the Objective-C runtime. <br>&gt; <br>&gt; There is no direct way to implement Objective-C entry points for protocol extensions. One would effectively have to install a category on every Objective-C root class [*] with the default implementation or somehow intercept all of the operations that might involve that selector. <br>&gt; <br>&gt; Alternately, and more simply, we could require @nonobjc on members of @objc protocol extensions, as an explicit indicator that the member is not exposed to Objective-C. It’ll eliminate surprise and, should we ever find both the mechanism and motivation to make default implementations of @objc protocol extension members work, we could easily remove the restriction at that time.<br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; [*] Assuming you can enumerate them, although NSObject and the hidden SwiftObject cover the 99%. Even so, that it’s correct either, because the root class itself might default such a method, and the category version would conflict with it, so...<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160104/8e885168/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Mini-proposal] Require @nonobjc on members of @objc protocol extensions</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January  4, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jan 4, 2016, at 8:49 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; <br>&gt; For the folks who don&#39;t mix Swift and Objective-C that much, extensions on @objc classes are exposed to the Objective-C runtime, so there is a discrepancy here. I&#39;m not passionate about the outcome, just dropping the info.<br></p><p>Right. I think this is the reason that developers expect members of @objc protocol extensions to show up in Objective-C, because it automatically happens for extensions of @objc classes. (We’ve received a number of bug reports about this)<br></p><p>	- Doug<br></p><p>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 4 janv. 2016 à 23:32:25, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; We currently have a bit of a surprise when one extends an @objc protocol:<br>&gt;&gt; <br>&gt;&gt; @objc protocol P { }<br>&gt;&gt; <br>&gt;&gt; extension P {<br>&gt;&gt;   func bar() { }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class C : NSObject { }<br>&gt;&gt; <br>&gt;&gt; let c = C()<br>&gt;&gt; print(c.respondsToSelector(&quot;bar&quot;)) // prints &quot;false&quot;<br>&gt;&gt; <br>&gt;&gt; because the members of the extension are not exposed to the Objective-C runtime. <br>&gt;&gt; <br>&gt;&gt; There is no direct way to implement Objective-C entry points for protocol extensions. One would effectively have to install a category on every Objective-C root class [*] with the default implementation or somehow intercept all of the operations that might involve that selector. <br>&gt;&gt; <br>&gt;&gt; Alternately, and more simply, we could require @nonobjc on members of @objc protocol extensions, as an explicit indicator that the member is not exposed to Objective-C. It’ll eliminate surprise and, should we ever find both the mechanism and motivation to make default implementations of @objc protocol extension members work, we could easily remove the restriction at that time.<br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt; [*] Assuming you can enumerate them, although NSObject and the hidden SwiftObject cover the 99%. Even so, that it’s correct either, because the root class itself might default such a method, and the category version would conflict with it, so...<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160104/3d10eece/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bab03b11d4cd60804cf4a6ba68589430?s=50"></div><header><strong>[Mini-proposal] Require @nonobjc on members of @objc protocol extensions</strong> from <string>Kevin Lundberg</string> &lt;kevin at klundberg.com&gt;<p>January  4, 2016 at 11:00:00pm</p></header><div class="content"><p>I like this idea, but I would imagine that for an extension with many functions in it, requiring @nonobjc on each one would get tedious very fast. Could it be required (or at least allowed in addition to per-method annotations) at the extension level?:<br>	<br>	@objc protocol P {}<br>	<br>	@nonobjc extension P {<br>		func foo() { }<br>		func bar() { }<br>		func baz() { }<br>		func blah() { }		<br>		// etc...<br>	}<br></p><p>I don’t know if this would have specific implementation ramifications over only doing this on each method, if extensions cannot already be modified with attributes. I can’t think of a case where I’ve seen annotations added to protocol extensions, or any other extensions for that matter.<br></p><p><br>&gt; On Jan 4, 2016, at 11:32 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; We currently have a bit of a surprise when one extends an @objc protocol:<br>&gt; <br>&gt; @objc protocol P { }<br>&gt; <br>&gt; extension P {<br>&gt;   func bar() { }<br>&gt; }<br>&gt; <br>&gt; class C : NSObject { }<br>&gt; <br>&gt; let c = C()<br>&gt; print(c.respondsToSelector(&quot;bar&quot;)) // prints &quot;false&quot;<br>&gt; <br>&gt; because the members of the extension are not exposed to the Objective-C runtime. <br>&gt; <br>&gt; There is no direct way to implement Objective-C entry points for protocol extensions. One would effectively have to install a category on every Objective-C root class [*] with the default implementation or somehow intercept all of the operations that might involve that selector. <br>&gt; <br>&gt; Alternately, and more simply, we could require @nonobjc on members of @objc protocol extensions, as an explicit indicator that the member is not exposed to Objective-C. It’ll eliminate surprise and, should we ever find both the mechanism and motivation to make default implementations of @objc protocol extension members work, we could easily remove the restriction at that time.<br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; [*] Assuming you can enumerate them, although NSObject and the hidden SwiftObject cover the 99%. Even so, that it’s correct either, because the root class itself might default such a method, and the category version would conflict with it, so...<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160104/47282998/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8993e184f091e98f018c07d96ac4731f?s=50"></div><header><strong>[Mini-proposal] Require @nonobjc on members of @objc protocol extensions</strong> from <string>John Joyce</string> &lt;uchuugaka at icloud.com&gt;<p>January  5, 2016 at 01:00:00pm</p></header><div class="content"><p>Would it not be possible to do the relative analog of Objective-C nullability macro sandwiches in Swift?<br>And then allowing exceptions within the file to be called out explicitly with @nonobjc or @objc ?<br>@begin_assume_nonobjc<br>@end_assume_nonobjc<br>@begin_assume_objc<br>@begin_assume_objc<br>&gt; On Jan 5, 2016, at 1:54 PM, Kevin Lundberg via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I like this idea, but I would imagine that for an extension with many functions in it, requiring @nonobjc on each one would get tedious very fast. Could it be required (or at least allowed in addition to per-method annotations) at the extension level?:<br>&gt; 	<br>&gt; 	@objc protocol P {}<br>&gt; 	<br>&gt; 	@nonobjc extension P {<br>&gt; 		func foo() { }<br>&gt; 		func bar() { }<br>&gt; 		func baz() { }<br>&gt; 		func blah() { }		<br>&gt; 		// etc...<br>&gt; 	}<br>&gt; <br>&gt; I don’t know if this would have specific implementation ramifications over only doing this on each method, if extensions cannot already be modified with attributes. I can’t think of a case where I’ve seen annotations added to protocol extensions, or any other extensions for that matter.<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 4, 2016, at 11:32 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; We currently have a bit of a surprise when one extends an @objc protocol:<br>&gt;&gt; <br>&gt;&gt; @objc protocol P { }<br>&gt;&gt; <br>&gt;&gt; extension P {<br>&gt;&gt;   func bar() { }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class C : NSObject { }<br>&gt;&gt; <br>&gt;&gt; let c = C()<br>&gt;&gt; print(c.respondsToSelector(&quot;bar&quot;)) // prints &quot;false&quot;<br>&gt;&gt; <br>&gt;&gt; because the members of the extension are not exposed to the Objective-C runtime. <br>&gt;&gt; <br>&gt;&gt; There is no direct way to implement Objective-C entry points for protocol extensions. One would effectively have to install a category on every Objective-C root class [*] with the default implementation or somehow intercept all of the operations that might involve that selector. <br>&gt;&gt; <br>&gt;&gt; Alternately, and more simply, we could require @nonobjc on members of @objc protocol extensions, as an explicit indicator that the member is not exposed to Objective-C. It’ll eliminate surprise and, should we ever find both the mechanism and motivation to make default implementations of @objc protocol extension members work, we could easily remove the restriction at that time.<br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt; [*] Assuming you can enumerate them, although NSObject and the hidden SwiftObject cover the 99%. Even so, that it’s correct either, because the root class itself might default such a method, and the category version would conflict with it, so...<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/d238bdac/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Mini-proposal] Require @nonobjc on members of @objc protocol extensions</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January  4, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jan 4, 2016, at 8:58 PM, John Joyce &lt;uchuugaka at icloud.com&gt; wrote:<br>&gt; <br>&gt; Would it not be possible to do the relative analog of Objective-C nullability macro sandwiches in Swift?<br>&gt; And then allowing exceptions within the file to be called out explicitly with @nonobjc or @objc ?<br>&gt; @begin_assume_nonobjc<br>&gt; @end_assume_nonobjc<br>&gt; @begin_assume_objc<br>&gt; @begin_assume_objc<br></p><p>Ick :)<br></p><p>If we need to annotate several things at once, doing it an extension granularity is good enough, because there’s essentially no cost to merging or breaking apart extensions as needed.<br></p><p>	- Doug<br></p><p>&gt;&gt; On Jan 5, 2016, at 1:54 PM, Kevin Lundberg via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I like this idea, but I would imagine that for an extension with many functions in it, requiring @nonobjc on each one would get tedious very fast. Could it be required (or at least allowed in addition to per-method annotations) at the extension level?:<br>&gt;&gt; 	<br>&gt;&gt; 	@objc protocol P {}<br>&gt;&gt; 	<br>&gt;&gt; 	@nonobjc extension P {<br>&gt;&gt; 		func foo() { }<br>&gt;&gt; 		func bar() { }<br>&gt;&gt; 		func baz() { }<br>&gt;&gt; 		func blah() { }		<br>&gt;&gt; 		// etc...<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; I don’t know if this would have specific implementation ramifications over only doing this on each method, if extensions cannot already be modified with attributes. I can’t think of a case where I’ve seen annotations added to protocol extensions, or any other extensions for that matter.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 4, 2016, at 11:32 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We currently have a bit of a surprise when one extends an @objc protocol:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; @objc protocol P { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension P {<br>&gt;&gt;&gt;   func bar() { }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class C : NSObject { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let c = C()<br>&gt;&gt;&gt; print(c.respondsToSelector(&quot;bar&quot;)) // prints &quot;false&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; because the members of the extension are not exposed to the Objective-C runtime. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There is no direct way to implement Objective-C entry points for protocol extensions. One would effectively have to install a category on every Objective-C root class [*] with the default implementation or somehow intercept all of the operations that might involve that selector. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternately, and more simply, we could require @nonobjc on members of @objc protocol extensions, as an explicit indicator that the member is not exposed to Objective-C. It’ll eliminate surprise and, should we ever find both the mechanism and motivation to make default implementations of @objc protocol extension members work, we could easily remove the restriction at that time.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; [*] Assuming you can enumerate them, although NSObject and the hidden SwiftObject cover the 99%. Even so, that it’s correct either, because the root class itself might default such a method, and the category version would conflict with it, so...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160104/717f1a4b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>[Mini-proposal] Require @nonobjc on members of @objc protocol extensions</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>January  5, 2016 at 10:00:00pm</p></header><div class="content"><p>I&#39;m on the fence here, I think it&#39;s a good solution if a project has<br>ongoing objc dependencies.<br></p><p>However I have a few issues/suggestions:<br></p><p>1) If a project is iteratively migrating from objc to swift, as I&#39;m sure<br>many are (a large project I&#39;m working on included), then it would make that<br>job much more tedious and increase the objc footprint in the swift code.<br></p><p>2) A linter could help me slowly remove unnecessary side-effects of this<br>proposal, but it&#39;s not ideal, and it does not solve the large amounts of<br>annotations needed to do so.<br></p><p>3) If this proposal went ahead would existing code be migrated to add the<br>annotation everywhere? (to retain equivalence)<br></p><p>4) Have you explored any alternatives?<br> * instead of defaulting to @objc require an explicit @objc or @nonobjc,<br>otherwise have a compile-time warning; default to @nonobjc still (for<br>consistency).<br> * @objc(inherit=false)<br></p><p>when put on the protocol it disables what you propose, inherit is true by<br>default.<br></p><p> * compile time feedback:<br>    + An objc compile time warning/error suggesting you add @objc if<br>there&#39;s no matching selector, but there is a swift method.<br></p><p>This may only work in whole module optimisation, also the dynamic nature of<br>objc may prevent it from being deterministic.<br></p><p>    + A swift compile time warning/error suggesting you add @objc if<br>there&#39;s an objc protocol and an unannotated swift implementation.<br></p><p>If I remember correctly something like this may already exist.<br></p><p><br></p><p><br>On Tue, Jan 5, 2016 at 4:02 PM, Douglas Gregor via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Jan 4, 2016, at 8:58 PM, John Joyce &lt;uchuugaka at icloud.com&gt; wrote:<br>&gt;<br>&gt; Would it not be possible to do the relative analog of Objective-C<br>&gt; nullability macro sandwiches in Swift?<br>&gt; And then allowing exceptions within the file to be called out explicitly<br>&gt; with @nonobjc or @objc ?<br>&gt; @begin_assume_nonobjc<br>&gt; @end_assume_nonobjc<br>&gt; @begin_assume_objc<br>&gt; @begin_assume_objc<br>&gt;<br>&gt;<br>&gt; Ick :)<br>&gt;<br>&gt; If we need to annotate several things at once, doing it an extension<br>&gt; granularity is good enough, because there’s essentially no cost to merging<br>&gt; or breaking apart extensions as needed.<br>&gt;<br>&gt; - Doug<br>&gt;<br>&gt; On Jan 5, 2016, at 1:54 PM, Kevin Lundberg via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I like this idea, but I would imagine that for an extension with many<br>&gt; functions in it, requiring @nonobjc on each one would get tedious very<br>&gt; fast. Could it be required (or at least allowed in addition to per-method<br>&gt; annotations) at the extension level?:<br>&gt; @objc protocol P {}<br>&gt; @nonobjc extension P {<br>&gt; func foo() { }<br>&gt; func bar() { }<br>&gt; func baz() { }<br>&gt; func blah() { }<br>&gt; // etc...<br>&gt; }<br>&gt;<br>&gt; I don’t know if this would have specific implementation ramifications over<br>&gt; only doing this on each method, if extensions cannot already be modified<br>&gt; with attributes. I can’t think of a case where I’ve seen annotations added<br>&gt; to protocol extensions, or any other extensions for that matter.<br>&gt;<br>&gt;<br>&gt; On Jan 4, 2016, at 11:32 PM, Douglas Gregor via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Hi all,<br>&gt;<br>&gt; We currently have a bit of a surprise when one extends an @objc protocol:<br>&gt;<br>&gt; @objc protocol P { }<br>&gt;<br>&gt; extension P {<br>&gt;   func bar() { }<br>&gt; }<br>&gt;<br>&gt; class C : NSObject { }<br>&gt;<br>&gt; let c = C()<br>&gt; print(c.respondsToSelector(&quot;bar&quot;)) // prints &quot;false&quot;<br>&gt;<br>&gt;<br>&gt; because the members of the extension are not exposed to the Objective-C<br>&gt; runtime.<br>&gt;<br>&gt; There is no direct way to implement Objective-C entry points for protocol<br>&gt; extensions. One would effectively have to install a category on every<br>&gt; Objective-C root class [*] with the default implementation or somehow<br>&gt; intercept all of the operations that might involve that selector.<br>&gt;<br>&gt; Alternately, and more simply, we could require @nonobjc on members of<br>&gt; @objc protocol extensions, as an explicit indicator that the member is not<br>&gt; exposed to Objective-C. It’ll eliminate surprise and, should we ever find<br>&gt; both the mechanism and motivation to make default implementations of @objc<br>&gt; protocol extension members work, we could easily remove the restriction at<br>&gt; that time.<br>&gt;<br>&gt; - Doug<br>&gt;<br>&gt; [*] Assuming you can enumerate them, although NSObject and the hidden<br>&gt; SwiftObject cover the 99%. Even so, that it’s correct either, because the<br>&gt; root class itself might default such a method, and the category version<br>&gt; would conflict with it, so...<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/ac25e523/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Mini-proposal] Require @nonobjc on members of @objc protocol extensions</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January  5, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jan 5, 2016, at 3:40 AM, Andrew Bennett &lt;cacoyi at gmail.com&gt; wrote:<br>&gt; <br>&gt; I&#39;m on the fence here, I think it&#39;s a good solution if a project has ongoing objc dependencies.<br></p><p>If the Objective-C runtime is there, you have ongoing Objective-C dependencies: we call them Cocoa and Cocoa Touch ;)<br></p><p>&gt; <br>&gt; However I have a few issues/suggestions:<br>&gt; <br>&gt; 1) If a project is iteratively migrating from objc to swift, as I&#39;m sure many are (a large project I&#39;m working on included), then it would make that job much more tedious and increase the objc footprint in the swift code.<br></p><p>I don’t know what you mean by this. Your Objective-C code doesn’t contain protocol extensions, and the incremental cost to writing @nonobjc for members of extensions of @objc protocols (or accepting the Fix-It) is trivial.<br></p><p>&gt; <br>&gt; 2) A linter could help me slowly remove unnecessary side-effects of this proposal, but it&#39;s not ideal, and it does not solve the large amounts of annotations needed to do so.<br></p><p>You’re worried about migrating an @objc protocol to a non- at objc protocol, and it has so many protocol extensions that the cost of removing the @nonobjc (or accept the Fix-It) is prohibitive? That seems very, very unlikely to me.<br></p><p>&gt; <br>&gt; 3) If this proposal went ahead would existing code be migrated to add the annotation everywhere? (to retain equivalence)<br></p><p>Yes, where “everywhere” == “extensions of @objc protocols”.<br></p><p>&gt; <br>&gt; 4) Have you explored any alternatives?<br>&gt;  * instead of defaulting to @objc require an explicit @objc or @nonobjc, otherwise have a compile-time warning; default to @nonobjc still (for consistency).<br>&gt;  * @objc(inherit=false)<br>&gt; when put on the protocol it disables what you propose, inherit is true by default.<br>&gt;  * compile time feedback:<br>&gt;     + An objc compile time warning/error suggesting you add @objc if there&#39;s no matching selector, but there is a swift method.<br>&gt; This may only work in whole module optimisation, also the dynamic nature of objc may prevent it from being deterministic.<br>&gt;     + A swift compile time warning/error suggesting you add @objc if there&#39;s an objc protocol and an unannotated swift implementation.<br>&gt; If I remember correctly something like this may already exist.<br></p><p>The idea of eliminating the blanket @objc default in subclasses of Objective-C-defined classes has come up. It would require us to infer ‘@objc’ in more places (and you noted), and would obviate the need for my proposal because the expectation of @objc-by-default would go away. That is a *much* larger and more interesting discussion.<br></p><p>	- Doug<br></p><p>&gt; <br>&gt; <br>&gt; <br>&gt; On Tue, Jan 5, 2016 at 4:02 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 4, 2016, at 8:58 PM, John Joyce &lt;uchuugaka at icloud.com &lt;mailto:uchuugaka at icloud.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Would it not be possible to do the relative analog of Objective-C nullability macro sandwiches in Swift?<br>&gt;&gt; And then allowing exceptions within the file to be called out explicitly with @nonobjc or @objc ?<br>&gt;&gt; @begin_assume_nonobjc<br>&gt;&gt; @end_assume_nonobjc<br>&gt;&gt; @begin_assume_objc<br>&gt;&gt; @begin_assume_objc<br>&gt; <br>&gt; Ick :)<br>&gt; <br>&gt; If we need to annotate several things at once, doing it an extension granularity is good enough, because there’s essentially no cost to merging or breaking apart extensions as needed.<br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt;&gt;&gt; On Jan 5, 2016, at 1:54 PM, Kevin Lundberg via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I like this idea, but I would imagine that for an extension with many functions in it, requiring @nonobjc on each one would get tedious very fast. Could it be required (or at least allowed in addition to per-method annotations) at the extension level?:<br>&gt;&gt;&gt; 	<br>&gt;&gt;&gt; 	@objc protocol P {}<br>&gt;&gt;&gt; 	<br>&gt;&gt;&gt; 	@nonobjc extension P {<br>&gt;&gt;&gt; 		func foo() { }<br>&gt;&gt;&gt; 		func bar() { }<br>&gt;&gt;&gt; 		func baz() { }<br>&gt;&gt;&gt; 		func blah() { }		<br>&gt;&gt;&gt; 		// etc...<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t know if this would have specific implementation ramifications over only doing this on each method, if extensions cannot already be modified with attributes. I can’t think of a case where I’ve seen annotations added to protocol extensions, or any other extensions for that matter.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 4, 2016, at 11:32 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We currently have a bit of a surprise when one extends an @objc protocol:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; @objc protocol P { }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension P {<br>&gt;&gt;&gt;&gt;   func bar() { }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class C : NSObject { }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let c = C()<br>&gt;&gt;&gt;&gt; print(c.respondsToSelector(&quot;bar&quot;)) // prints &quot;false&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; because the members of the extension are not exposed to the Objective-C runtime. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There is no direct way to implement Objective-C entry points for protocol extensions. One would effectively have to install a category on every Objective-C root class [*] with the default implementation or somehow intercept all of the operations that might involve that selector. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Alternately, and more simply, we could require @nonobjc on members of @objc protocol extensions, as an explicit indicator that the member is not exposed to Objective-C. It’ll eliminate surprise and, should we ever find both the mechanism and motivation to make default implementations of @objc protocol extension members work, we could easily remove the restriction at that time.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; [*] Assuming you can enumerate them, although NSObject and the hidden SwiftObject cover the 99%. Even so, that it’s correct either, because the root class itself might default such a method, and the category version would conflict with it, so...<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/6dcfdef5/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Mini-proposal] Require @nonobjc on members of @objc protocol extensions</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January  4, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jan 4, 2016, at 8:54 PM, Kevin Lundberg &lt;kevin at klundberg.com&gt; wrote:<br>&gt; <br>&gt; I like this idea, but I would imagine that for an extension with many functions in it, requiring @nonobjc on each one would get tedious very fast. Could it be required (or at least allowed in addition to per-method annotations) at the extension level?:<br>&gt; 	<br>&gt; 	@objc protocol P {}<br>&gt; 	<br>&gt; 	@nonobjc extension P {<br>&gt; 		func foo() { }<br>&gt; 		func bar() { }<br>&gt; 		func baz() { }<br>&gt; 		func blah() { }		<br>&gt; 		// etc...<br>&gt; 	}<br>&gt; <br>&gt; I don’t know if this would have specific implementation ramifications over only doing this on each method, if extensions cannot already be modified with attributes. I can’t think of a case where I’ve seen annotations added to protocol extensions, or any other extensions for that matter.<br></p><p>We have some declaration modifiers (e.g., access-control modifiers) and attributes (e.g., availability) that distribute in this manner from the extension to its members. My only hesitation here is that @objc itself doesn’t distribute in this way, and I’d rather they not be inconsistent.<br></p><p>	- Doug<br></p><p>&gt; <br>&gt;&gt; On Jan 4, 2016, at 11:32 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; We currently have a bit of a surprise when one extends an @objc protocol:<br>&gt;&gt; <br>&gt;&gt; @objc protocol P { }<br>&gt;&gt; <br>&gt;&gt; extension P {<br>&gt;&gt;   func bar() { }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class C : NSObject { }<br>&gt;&gt; <br>&gt;&gt; let c = C()<br>&gt;&gt; print(c.respondsToSelector(&quot;bar&quot;)) // prints &quot;false&quot;<br>&gt;&gt; <br>&gt;&gt; because the members of the extension are not exposed to the Objective-C runtime. <br>&gt;&gt; <br>&gt;&gt; There is no direct way to implement Objective-C entry points for protocol extensions. One would effectively have to install a category on every Objective-C root class [*] with the default implementation or somehow intercept all of the operations that might involve that selector. <br>&gt;&gt; <br>&gt;&gt; Alternately, and more simply, we could require @nonobjc on members of @objc protocol extensions, as an explicit indicator that the member is not exposed to Objective-C. It’ll eliminate surprise and, should we ever find both the mechanism and motivation to make default implementations of @objc protocol extension members work, we could easily remove the restriction at that time.<br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt; [*] Assuming you can enumerate them, although NSObject and the hidden SwiftObject cover the 99%. Even so, that it’s correct either, because the root class itself might default such a method, and the category version would conflict with it, so...<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160104/ee4748ca/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Mini-proposal] Require @nonobjc on members of @objc protocol extensions</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>January  5, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jan 4, 2016, at 20:59, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 4, 2016, at 8:54 PM, Kevin Lundberg &lt;kevin at klundberg.com &lt;mailto:kevin at klundberg.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I like this idea, but I would imagine that for an extension with many functions in it, requiring @nonobjc on each one would get tedious very fast. Could it be required (or at least allowed in addition to per-method annotations) at the extension level?:<br>&gt;&gt; 	<br>&gt;&gt; 	@objc protocol P {}<br>&gt;&gt; 	<br>&gt;&gt; 	@nonobjc extension P {<br>&gt;&gt; 		func foo() { }<br>&gt;&gt; 		func bar() { }<br>&gt;&gt; 		func baz() { }<br>&gt;&gt; 		func blah() { }		<br>&gt;&gt; 		// etc...<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; I don’t know if this would have specific implementation ramifications over only doing this on each method, if extensions cannot already be modified with attributes. I can’t think of a case where I’ve seen annotations added to protocol extensions, or any other extensions for that matter.<br>&gt; <br>&gt; We have some declaration modifiers (e.g., access-control modifiers) and attributes (e.g., availability) that distribute in this manner from the extension to its members. My only hesitation here is that @objc itself doesn’t distribute in this way, and I’d rather they not be inconsistent.<br></p><p>I&#39;d be much happier with this if we could do &quot;@nonobjc extension&quot;, and I have no problems with &quot;@objc extension&quot; (even if it&#39;s rare). I suppose that would be a separate proposal.<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/52f95b87/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Mini-proposal] Require @nonobjc on members of @objc protocol extensions</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January  6, 2016 at 10:00:00am</p></header><div class="content"><p>On Jan 5, 2016, at 4:09 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; We have some declaration modifiers (e.g., access-control modifiers) and attributes (e.g., availability) that distribute in this manner from the extension to its members. My only hesitation here is that @objc itself doesn’t distribute in this way, and I’d rather they not be inconsistent.<br>&gt; <br>&gt; I&#39;d be much happier with this if we could do &quot;@nonobjc extension&quot;, and I have no problems with &quot;@objc extension&quot; (even if it&#39;s rare). I suppose that would be a separate proposal.<br></p><p>I agree with Jordan on both points: would be useful, but should be a separate proposal.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160106/1212b647/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>[Mini-proposal] Require @nonobjc on members of @objc protocol extensions</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>January  5, 2016 at 06:00:00pm</p></header><div class="content"><p>I&#39;m against this, because I often write extensions on Apple classes (like, say, UIColor) that are only intended to be used from Swift, in a pure-Swift project, and I need no stinking&#39; @nonobjc in there.<br></p><p>How much of a problem can this surprise be? You call a method, the compiler tells you it&#39;s not there, you look up the reason, no harm done.<br></p><p>A.<br></p><p><br></p><p>&gt; On Jan 5, 2016, at 11:32 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; We currently have a bit of a surprise when one extends an @objc protocol:<br>&gt; <br>&gt; @objc protocol P { }<br>&gt; <br>&gt; extension P {<br>&gt;   func bar() { }<br>&gt; }<br>&gt; <br>&gt; class C : NSObject { }<br>&gt; <br>&gt; let c = C()<br>&gt; print(c.respondsToSelector(&quot;bar&quot;)) // prints &quot;false&quot;<br>&gt; <br>&gt; because the members of the extension are not exposed to the Objective-C runtime. <br>&gt; <br>&gt; There is no direct way to implement Objective-C entry points for protocol extensions. One would effectively have to install a category on every Objective-C root class [*] with the default implementation or somehow intercept all of the operations that might involve that selector. <br>&gt; <br>&gt; Alternately, and more simply, we could require @nonobjc on members of @objc protocol extensions, as an explicit indicator that the member is not exposed to Objective-C. It’ll eliminate surprise and, should we ever find both the mechanism and motivation to make default implementations of @objc protocol extension members work, we could easily remove the restriction at that time.<br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; [*] Assuming you can enumerate them, although NSObject and the hidden SwiftObject cover the 99%. Even so, that it’s correct either, because the root class itself might default such a method, and the category version would conflict with it, so...<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/b3d864d5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Mini-proposal] Require @nonobjc on members of @objc protocol extensions</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January  5, 2016 at 12:00:00pm</p></header><div class="content"><p>Extensions on classes already work and I can&#39;t see them requiring @objc or @nonobjc. It&#39;s extensions on protocols that don&#39;t work from Objective-C. The way I understand it, Doug suggests a warning/error for extensions on @objc protocols, and a @nonobjc attribute to shut it up.<br></p><p>Your point may still stand if you use @objc protocols in your code.<br></p><p>Félix<br></p><p>&gt; Le 5 janv. 2016 à 06:51:27, Andrey Tarantsov via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; I&#39;m against this, because I often write extensions on Apple classes (like, say, UIColor) that are only intended to be used from Swift, in a pure-Swift project, and I need no stinking&#39; @nonobjc in there.<br>&gt; <br>&gt; How much of a problem can this surprise be? You call a method, the compiler tells you it&#39;s not there, you look up the reason, no harm done.<br>&gt; <br>&gt; A.<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Jan 5, 2016, at 11:32 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; We currently have a bit of a surprise when one extends an @objc protocol:<br>&gt;&gt; <br>&gt;&gt; @objc protocol P { }<br>&gt;&gt; <br>&gt;&gt; extension P {<br>&gt;&gt;   func bar() { }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class C : NSObject { }<br>&gt;&gt; <br>&gt;&gt; let c = C()<br>&gt;&gt; print(c.respondsToSelector(&quot;bar&quot;)) // prints &quot;false&quot;<br>&gt;&gt; <br>&gt;&gt; because the members of the extension are not exposed to the Objective-C runtime. <br>&gt;&gt; <br>&gt;&gt; There is no direct way to implement Objective-C entry points for protocol extensions. One would effectively have to install a category on every Objective-C root class [*] with the default implementation or somehow intercept all of the operations that might involve that selector. <br>&gt;&gt; <br>&gt;&gt; Alternately, and more simply, we could require @nonobjc on members of @objc protocol extensions, as an explicit indicator that the member is not exposed to Objective-C. It’ll eliminate surprise and, should we ever find both the mechanism and motivation to make default implementations of @objc protocol extension members work, we could easily remove the restriction at that time.<br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt; [*] Assuming you can enumerate them, although NSObject and the hidden SwiftObject cover the 99%. Even so, that it’s correct either, because the root class itself might default such a method, and the category version would conflict with it, so...<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/9c0c884d/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Mini-proposal] Require @nonobjc on members of @objc protocol extensions</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January  5, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jan 5, 2016, at 3:51 AM, Andrey Tarantsov &lt;andrey at tarantsov.com&gt; wrote:<br>&gt; <br>&gt; I&#39;m against this, because I often write extensions on Apple classes (like, say, UIColor) that are only intended to be used from Swift, in a pure-Swift project, and I need no stinking&#39; @nonobjc in there.<br></p><p>You are misreading my proposal. I’m not proposing to change anything about how extensions of classes work. Your extensions of UIColor and other Objective-C classes remain unchanged.<br></p><p>How many Apple *protocols*, such as delegates, have you extended? I expect it’s not that many.<br></p><p>&gt; <br>&gt; How much of a problem can this surprise be? You call a method, the compiler tells you it&#39;s not there, you look up the reason, no harm done.<br></p><p>I’ve seen enough bugs filed and general confusion about this that the answer is “it’s quite a bit of a surprise”. The common case seems to be that people write a protocol extension of a delegate that implements some of its optional members. The only calls to that method occur in some framework code written in Objective-C, so there place for the compiler to tell you it’s not there.<br></p><p>	- Doug<br></p><p>&gt; <br>&gt; A.<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Jan 5, 2016, at 11:32 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; We currently have a bit of a surprise when one extends an @objc protocol:<br>&gt;&gt; <br>&gt;&gt; @objc protocol P { }<br>&gt;&gt; <br>&gt;&gt; extension P {<br>&gt;&gt;   func bar() { }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class C : NSObject { }<br>&gt;&gt; <br>&gt;&gt; let c = C()<br>&gt;&gt; print(c.respondsToSelector(&quot;bar&quot;)) // prints &quot;false&quot;<br>&gt;&gt; <br>&gt;&gt; because the members of the extension are not exposed to the Objective-C runtime. <br>&gt;&gt; <br>&gt;&gt; There is no direct way to implement Objective-C entry points for protocol extensions. One would effectively have to install a category on every Objective-C root class [*] with the default implementation or somehow intercept all of the operations that might involve that selector. <br>&gt;&gt; <br>&gt;&gt; Alternately, and more simply, we could require @nonobjc on members of @objc protocol extensions, as an explicit indicator that the member is not exposed to Objective-C. It’ll eliminate surprise and, should we ever find both the mechanism and motivation to make default implementations of @objc protocol extension members work, we could easily remove the restriction at that time.<br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt; [*] Assuming you can enumerate them, although NSObject and the hidden SwiftObject cover the 99%. Even so, that it’s correct either, because the root class itself might default such a method, and the category version would conflict with it, so...<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/b0d41b77/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Mini-proposal] Require @nonobjc on members of @objc protocol extensions</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>January  5, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; On Jan 4, 2016, at 10:32 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; There is no direct way to implement Objective-C entry points for protocol extensions. One would effectively have to install a category on every Objective-C root class [*] with the default implementation or somehow intercept all of the operations that might involve that selector. <br></p><p>I can almost do it right now, just hacking with the Objective-C runtime functions, so I’d think that if you were actually working with the compiler sources, it should be doable. The trouble is on the Swift side; currently there aren’t any reflection features that I can find that work on Swift protocols.<br></p><p>If I have a protocol and class, like so:<br></p><p>import Foundation<br></p><p>@objc protocol HasSwiftExtension {}<br></p><p>@objc protocol P: HasSwiftExtension {<br>    optional func foo()<br>}<br></p><p>extension P {<br>    func foo() { print(&quot;foo&quot;) }<br>}<br></p><p>class C: NSObject, P {}<br></p><p>(the optional is there because without it, adding the method in an extension causes the compiler to crash on my machine)<br></p><p>And then I have this in Objective-C:<br></p><p>@implementation NSObject (Swizzle)<br>+ (void)load {<br>    CFAbsoluteTime startTime = CFAbsoluteTimeGetCurrent();<br>    <br>    unsigned int classCount = 0;<br>    Class *classes = objc_copyClassList(&amp;classCount);<br>    <br>    Protocol *proto = @protocol(HasSwiftExtension);<br>    <br>    for (unsigned int i = 0; i &lt; classCount; i++) {<br>        Class eachClass = classes[i];<br>        <br>        if (class_conformsToProtocol(eachClass, proto)) {<br>            unsigned int protoCount = 0;<br>            Protocol * __unsafe_unretained *protocols = class_copyProtocolList(eachClass, &amp;protoCount);<br>            <br>            for (unsigned int j = 0; j &lt; protoCount; j++) {<br>                Protocol *eachProto = protocols[j];<br>                <br>                if (protocol_conformsToProtocol(eachProto, proto)) {<br>                    unsigned int methodCount = 0;<br>                    // what we would want would be to pass YES for isRequiredMethod; unfortunately,<br>                    // adding optional methods to an @objc protocol in an extension currently just<br>                    // crashes the compiler when I try it. So pass NO, for the demonstration.<br>                    struct objc_method_description *methods = protocol_copyMethodDescriptionList(eachProto, NO, YES, &amp;methodCount);<br>                    <br>                    for (unsigned int k = 0; k &lt; methodCount; k++) {<br>                        struct objc_method_description method = methods[k];<br>                        <br>                        if (!class_respondsToSelector(eachClass, method.name)) {<br>                            [SwizzleWrapper swizzleClass:[eachClass class] protocol:eachProto method:method];<br>                        }<br>                    }<br>                    <br>                    free(methods);<br>                }<br>            }<br>            <br>            free(protocols);<br>        }<br>    }<br>    <br>    free(classes);<br>    <br>    NSLog(@&quot;took %f seconds&quot;, CFAbsoluteTimeGetCurrent() - startTime);<br>}<br>@end<br></p><p>The swizzleClass:protocol:method: method will get called for each missing method, assuming I’ve marked the protocols having an extension by making them conform to my HasSwiftExtension protocol, which the compiler could add automatically. (For the record, the time taken was 0.001501 seconds in my testing, while linking against both Foundation and AppKit).<br></p><p>Unfortunately there’s currently no way to go any further, since AFAIK there’s no way to reflect on a protocol to get a mapping from selector name to method. For this to work, you’d have to store the method names for methods added by extensions to @objc protocols as strings somewhere, and then have a reflection API to access them. However, if you added that, you could just:<br></p><p>class SwizzleWrapper: NSObject {<br>    class func swizzleClass(aClass: AnyClass, `protocol` aProto: Protocol, method: objc_method_description) {<br>        let imp: IMP<br>        <br>        // now, just add some reflection for protocols to the language so we can<br>        // figure out what method to call and set imp accordingly, and:<br>        <br>        class_addMethod(aClass, method.name, imp, method.types) // ta da!<br>    }<br>}<br></p><p>The other obvious disclaimer, of course, is that +load is probably not the right place to do this; you’d need to set things up such that they would run sometime after the Swift runtime has had a chance to finish initializing; the code as above probably isn’t safe if the Swift method being called actually does anything. But with access to the compiler source, you could make sure to get the SetUpStuff() method to run at the appropriate time, so that it could call into Swift and do its setup.<br></p><p>(For the record, I’m not advocating actually using the swizzling method described above; just pointing out that intercepting the selector is possible. Working with the compiler sources, I’d expect more elegant solutions would be possible.)<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/faf41d11/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Mini-proposal] Require @nonobjc on members of @objc protocol extensions</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January  5, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jan 5, 2016, at 5:41 AM, Charles Srstka &lt;cocoadev at charlessoft.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 4, 2016, at 10:32 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; There is no direct way to implement Objective-C entry points for protocol extensions. One would effectively have to install a category on every Objective-C root class [*] with the default implementation or somehow intercept all of the operations that might involve that selector. <br>&gt; <br>&gt; I can almost do it right now, just hacking with the Objective-C runtime functions, so I’d think that if you were actually working with the compiler sources, it should be doable. The trouble is on the Swift side; currently there aren’t any reflection features that I can find that work on Swift protocols.<br></p><p>The compiler isn’t the limitation here, it’s the Objective-C runtime. That’s somewhat malleable, but making changes there to support a Swift feature affects backward deployment.<br></p><p>&gt; @implementation NSObject (Swizzle)<br></p><p>Note that all approaches based on adding categories to a root class require you to enumerate root classes, as I noted in my original message. That’s unfortunate and requires more trickery.<br></p><p>&gt; + (void)load {<br>&gt;     CFAbsoluteTime startTime = CFAbsoluteTimeGetCurrent();<br>&gt;     <br>&gt;     unsigned int classCount = 0;<br>&gt;     Class *classes = objc_copyClassList(&amp;classCount);<br></p><p>Doing it this way won’t handle protocol conformances or classes loaded later via a dlopen’d dylib.<br></p><p>&gt;     <br>&gt;     Protocol *proto = @protocol(HasSwiftExtension);<br>&gt;     <br>&gt;     for (unsigned int i = 0; i &lt; classCount; i++) {<br>&gt;         Class eachClass = classes[i];<br>&gt;         <br>&gt;         if (class_conformsToProtocol(eachClass, proto)) {<br>&gt;             unsigned int protoCount = 0;<br>&gt;             Protocol * __unsafe_unretained *protocols = class_copyProtocolList(eachClass, &amp;protoCount);<br>&gt;             <br>&gt;             for (unsigned int j = 0; j &lt; protoCount; j++) {<br>&gt;                 Protocol *eachProto = protocols[j];<br>&gt;                 <br>&gt;                 if (protocol_conformsToProtocol(eachProto, proto)) {<br>&gt;                     unsigned int methodCount = 0;<br>&gt;                     // what we would want would be to pass YES for isRequiredMethod; unfortunately,<br>&gt;                     // adding optional methods to an @objc protocol in an extension currently just<br>&gt;                     // crashes the compiler when I try it. So pass NO, for the demonstration.<br></p><p>The crash is a bug; please file it.<br></p><p>&gt;                     struct objc_method_description *methods = protocol_copyMethodDescriptionList(eachProto, NO, YES, &amp;methodCount);<br>&gt;                     <br>&gt;                     for (unsigned int k = 0; k &lt; methodCount; k++) {<br>&gt;                         struct objc_method_description method = methods[k];<br>&gt;                         <br>&gt;                         if (!class_respondsToSelector(eachClass, method.name)) {<br>&gt;                             [SwizzleWrapper swizzleClass:[eachClass class] protocol:eachProto method:method];<br>&gt;                         }<br>&gt;                     }<br>&gt;                     <br>&gt;                     free(methods);<br>&gt;                 }<br>&gt;             }<br>&gt;             <br>&gt;             free(protocols);<br>&gt;         }<br>&gt;     }<br>&gt;     <br>&gt;     free(classes);<br>&gt;     <br>&gt;     NSLog(@&quot;took %f seconds&quot;, CFAbsoluteTimeGetCurrent() - startTime);<br>&gt; }<br>&gt; @end<br>&gt; <br></p><p>[snip]<br></p><p>&gt; (For the record, I’m not advocating actually using the swizzling method described above; just pointing out that intercepting the selector is possible. Working with the compiler sources, I’d expect more elegant solutions would be possible.)<br></p><p><br>There are better mechanisms for this than +load. But one would have to deal with the dylib loading issue and the need to enumerate root classes to get to a complete implementation. Frankly, I don’t think this level of Objective-C runtime hackery is worth the effort, hence my suggestion to make the existing behavior explicit.<br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/58d99c24/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Mini-proposal] Require @nonobjc on members of @objc protocol extensions</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>January  5, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jan 5, 2016, at 11:52 AM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; There are better mechanisms for this than +load. But one would have to deal with the dylib loading issue and the need to enumerate root classes to get to a complete implementation. Frankly, I don’t think this level of Objective-C runtime hackery is worth the effort, hence my suggestion to make the existing behavior explicit.<br></p><p>Yeah, +load was just to throw together a quick-and-dirty demonstration, and not what you’d actually use. You have a point about libraries and bundles; you’d have to hook into that and rescan each time new code was dynamically loaded. However, the enumeration of classes only seems to take around 0.001 seconds, so I don’t think it’s terrible.<br></p><p>Although what might be easier would be just to include this in NSObject’s default implementation of +resolveInstanceMethod: (I don’t think you’d need to do it for every root class, since NSObjects are almost always what you’re dealing with in cases where you’d want this, and I don’t think Swift allows you to create non-NSObject @objc classes anymore anyway). This would lazily create the Objective-C selectors as they are needed, so there would be no need for iterating through classes. You could either do this with the disclaimer that the functionality required some OS X 10.x, or if you wanted it to be backward compatible you could always swizzle it in on older OS X versions (or do what KVO does and stick a dynamically-created subclass in NSObject’s place).<br></p><p>The thing that makes it a shame that this doesn’t work currently (and, indeed, crashing the compiler if the function isn’t optional) is that Swift’s protocol-oriented-programming concept is very appealing and could solve a lot of problems, but especially when you’re dealing with UI programming, you’re often working with code that will only take NSObjects. So if your model objects are going into something like a view-based NSTableView, which is pretty awkward to use without using bindings, using composition to build the model classes doesn’t work very well.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/90a7cefb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>[Mini-proposal] Require @nonobjc on members of @objc protocol extensions</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>January  5, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jan 5, 2016, at 3:37 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 5, 2016, at 11:52 AM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; There are better mechanisms for this than +load. But one would have to deal with the dylib loading issue and the need to enumerate root classes to get to a complete implementation. Frankly, I don’t think this level of Objective-C runtime hackery is worth the effort, hence my suggestion to make the existing behavior explicit.<br>&gt; <br>&gt; Yeah, +load was just to throw together a quick-and-dirty demonstration, and not what you’d actually use. You have a point about libraries and bundles; you’d have to hook into that and rescan each time new code was dynamically loaded. However, the enumeration of classes only seems to take around 0.001 seconds, so I don’t think it’s terrible.<br></p><p>Enumeration of classes is terrible: it forces the runtime to perform lots of work that it tries very hard to perform lazily otherwise. I would expect your measured cost to be much higher if you had linked to more high-level libraries (UIKit, MapKit, etc).<br></p><p><br>-- <br>Greg Parker     gparker at apple.com     Runtime Wrangler<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/6999243a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Mini-proposal] Require @nonobjc on members of @objc protocol extensions</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>January  5, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jan 5, 2016, at 8:29 PM, Greg Parker &lt;gparker at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 5, 2016, at 3:37 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 5, 2016, at 11:52 AM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are better mechanisms for this than +load. But one would have to deal with the dylib loading issue and the need to enumerate root classes to get to a complete implementation. Frankly, I don’t think this level of Objective-C runtime hackery is worth the effort, hence my suggestion to make the existing behavior explicit.<br>&gt;&gt; <br>&gt;&gt; Yeah, +load was just to throw together a quick-and-dirty demonstration, and not what you’d actually use. You have a point about libraries and bundles; you’d have to hook into that and rescan each time new code was dynamically loaded. However, the enumeration of classes only seems to take around 0.001 seconds, so I don’t think it’s terrible.<br>&gt; <br>&gt; Enumeration of classes is terrible: it forces the runtime to perform lots of work that it tries very hard to perform lazily otherwise. I would expect your measured cost to be much higher if you had linked to more high-level libraries (UIKit, MapKit, etc).<br></p><p>That was my gut reaction to the idea also, when I had it, but it seems to run pretty fast no matter what I do. I just tried dragging every framework from /System/Library/Frameworks into the project, removing only the Java frameworks, Kernel.framework, Message.framework, and vecLib.framework. Time taken was 0.004260 seconds.<br></p><p>It is, of course, ugly and hacky as hell, and that might make a pretty good reason not to do it. :-/ What do you think about the other idea, of adding to NSObject’s default implementation of +resolveInstanceMethod:? That *would* be done lazily, and would avoid all the problems involving dynamically loaded code.<br></p><p>Charles<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/d537aea2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Mini-proposal] Require @nonobjc on members of @objc protocol extensions</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January  5, 2016 at 10:00:00pm</p></header><div class="content"><p>The linker is smart enough to get rid of frameworks that you don&#39;t actually use.<br></p><p>Félix<br></p><p>&gt; Le 5 janv. 2016 à 21:55:17, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt;&gt; On Jan 5, 2016, at 8:29 PM, Greg Parker &lt;gparker at apple.com &lt;mailto:gparker at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 5, 2016, at 3:37 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 5, 2016, at 11:52 AM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are better mechanisms for this than +load. But one would have to deal with the dylib loading issue and the need to enumerate root classes to get to a complete implementation. Frankly, I don’t think this level of Objective-C runtime hackery is worth the effort, hence my suggestion to make the existing behavior explicit.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yeah, +load was just to throw together a quick-and-dirty demonstration, and not what you’d actually use. You have a point about libraries and bundles; you’d have to hook into that and rescan each time new code was dynamically loaded. However, the enumeration of classes only seems to take around 0.001 seconds, so I don’t think it’s terrible.<br>&gt;&gt; <br>&gt;&gt; Enumeration of classes is terrible: it forces the runtime to perform lots of work that it tries very hard to perform lazily otherwise. I would expect your measured cost to be much higher if you had linked to more high-level libraries (UIKit, MapKit, etc).<br>&gt; <br>&gt; That was my gut reaction to the idea also, when I had it, but it seems to run pretty fast no matter what I do. I just tried dragging every framework from /System/Library/Frameworks into the project, removing only the Java frameworks, Kernel.framework, Message.framework, and vecLib.framework. Time taken was 0.004260 seconds.<br>&gt; <br>&gt; It is, of course, ugly and hacky as hell, and that might make a pretty good reason not to do it. :-/ What do you think about the other idea, of adding to NSObject’s default implementation of +resolveInstanceMethod:? That *would* be done lazily, and would avoid all the problems involving dynamically loaded code.<br>&gt; <br>&gt; Charles<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/ed07b89a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Mini-proposal] Require @nonobjc on members of @objc protocol extensions</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>January  5, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jan 5, 2016, at 9:06 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; <br>&gt; The linker is smart enough to get rid of frameworks that you don&#39;t actually use.<br>&gt; <br>&gt; Félix<br></p><p><br>objc_copyClassList leaves a value of 14694 in classCount. When I just link against Foundation it only gives 1581.<br></p><p>otool says:<br></p><p>$ otool -L test<br>test:<br>	/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 120.1.0)<br>	/System/Library/Frameworks/Foundation.framework/Versions/C/Foundation (compatibility version 300.0.0, current version 1256.1.0)<br>	/System/Library/Frameworks/CFNetwork.framework/Versions/A/CFNetwork (compatibility version 1.0.0, current version 760.2.5)<br>	/System/Library/Frameworks/Metal.framework/Versions/A/Metal (compatibility version 1.0.0, current version 1.0.0)<br>	/System/Library/Frameworks/Contacts.framework/Versions/A/Contacts (compatibility version 0.0.0, current version 0.0.0)<br>	/System/Library/Frameworks/GSS.framework/Versions/A/GSS (compatibility version 1.0.0, current version 1.0.0)<br>	/System/Library/Frameworks/CoreMIDIServer.framework/Versions/A/CoreMIDIServer (compatibility version 1.0.0, current version 73.0.0)<br>	/System/Library/Frameworks/Python.framework/Versions/2.7/Python (compatibility version 2.7.0, current version 2.7.10)<br>	/System/Library/Frameworks/CoreLocation.framework/Versions/A/CoreLocation (compatibility version 1.0.0, current version 1615.38.0)<br>	/System/Library/Frameworks/GLKit.framework/Versions/A/GLKit (compatibility version 1.0.0, current version 20.0.0)<br>	/System/Library/Frameworks/MapKit.framework/Versions/A/MapKit (compatibility version 1.0.0, current version 0.0.0)<br>	/System/Library/Frameworks/ServiceManagement.framework/Versions/A/ServiceManagement (compatibility version 1.0.0, current version 756.20.4)<br>	/System/Library/Frameworks/CoreTelephony.framework/Versions/A/CoreTelephony (compatibility version 1.0.0, current version 0.0.0)<br>	/System/Library/Frameworks/CloudKit.framework/Versions/A/CloudKit (compatibility version 1.0.0, current version 481.8.0)<br>	/System/Library/Frameworks/ImageIO.framework/Versions/A/ImageIO (compatibility version 1.0.0, current version 1.0.0)<br>	/System/Library/Frameworks/CoreText.framework/Versions/A/CoreText (compatibility version 1.0.0, current version 1.0.0)<br>	/System/Library/Frameworks/Collaboration.framework/Versions/A/Collaboration (compatibility version 1.0.0, current version 75.0.0)<br>	/System/Library/Frameworks/LDAP.framework/Versions/A/LDAP (compatibility version 1.0.0, current version 2.4.0)<br>	/System/Library/Frameworks/AddressBook.framework/Versions/A/AddressBook (compatibility version 1.0.0, current version 1679.3.0)<br>	/System/Library/Frameworks/QuickLook.framework/Versions/A/QuickLook (compatibility version 1.0.0, current version 0.0.0)<br>	/System/Library/Frameworks/DiskArbitration.framework/Versions/A/DiskArbitration (compatibility version 1.0.0, current version 1.0.0)<br>	/System/Library/Frameworks/Tcl.framework/Versions/8.5/Tcl (compatibility version 8.5.0, current version 8.5.9)<br>	/System/Library/Frameworks/DiscRecording.framework/Versions/A/DiscRecording (compatibility version 1.0.0, current version 1.0.0)<br>	/System/Library/Frameworks/InputMethodKit.framework/Versions/A/InputMethodKit (compatibility version 1.0.0, current version 1.0.0)<br>	/System/Library/Frameworks/OpenCL.framework/Versions/A/OpenCL (compatibility version 1.0.0, current version 1.0.0)<br>	/System/Library/Frameworks/Photos.framework/Versions/A/Photos (compatibility version 1.0.0, current version 350.22.0)<br>	/System/Library/Frameworks/OSAKit.framework/Versions/A/OSAKit (compatibility version 1.0.0, current version 104.0.0)<br>	/System/Library/Frameworks/MediaAccessibility.framework/Versions/A/MediaAccessibility (compatibility version 1.0.0, current version 62.0.0)<br>	/System/Library/Frameworks/ContactsUI.framework/Versions/A/ContactsUI (compatibility version 1.0.0, current version 1679.3.0)<br>	/System/Library/Frameworks/DirectoryService.framework/Versions/A/DirectoryService (compatibility version 1.0.0, current version 1.0.0)<br>	/System/Library/Frameworks/AGL.framework/Versions/A/AGL (compatibility version 1.0.0, current version 1.0.0)<br>	/System/Library/Frameworks/StoreKit.framework/Versions/A/StoreKit (compatibility version 1.0.0, current version 379.0.0)<br>	/System/Library/Frameworks/OpenDirectory.framework/Versions/A/OpenDirectory (compatibility version 1.0.0, current version 1.0.0)<br>	/System/Library/Frameworks/PreferencePanes.framework/Versions/A/PreferencePanes (compatibility version 1.0.0, current version 1.0.0)<br>	/System/Library/Frameworks/GameplayKit.framework/Versions/A/GameplayKit (compatibility version 1.0.0, current version 1.0.0)<br>	/System/Library/Frameworks/SyncServices.framework/Versions/A/SyncServices (compatibility version 48.0.0, current version 724.0.0)<br>	/System/Library/Frameworks/AVKit.framework/Versions/A/AVKit (compatibility version 1.0.0, current version 1.0.0)<br>	/System/Library/Frameworks/GLUT.framework/Versions/A/GLUT (compatibility version 1.0.0, current version 1.0.0)<br>	/System/Library/Frameworks/ModelIO.framework/Versions/A/ModelIO (compatibility version 1.0.0, current version 1.0.0)<br>	/System/Library/Frameworks/GameController.framework/Versions/A/GameController (compatibility version 1.0.0, current version 1.0.0)<br>	/System/Library/Frameworks/Tk.framework/Versions/8.5/Tk (compatibility version 8.5.0, current version 8.5.9)<br>	/System/Library/Frameworks/AppleScriptObjC.framework/Versions/A/AppleScriptObjC (compatibility version 1.0.0, current version 32.0.0)<br>	/System/Library/Frameworks/AppKit.framework/Versions/C/AppKit (compatibility version 45.0.0, current version 1404.32.0)<br>	/System/Library/Frameworks/InstallerPlugins.framework/Versions/A/InstallerPlugins (compatibility version 1.0.0, current version 815.0.0)<br>	/System/Library/Frameworks/SecurityFoundation.framework/Versions/A/SecurityFoundation (compatibility version 1.0.0, current version 55126.0.0)<br>	/System/Library/Frameworks/ImageCaptureCore.framework/Versions/A/ImageCaptureCore (compatibility version 1.0.0, current version 1.0.0)<br>	/System/Library/Frameworks/VideoDecodeAcceleration.framework/Versions/A/VideoDecodeAcceleration (compatibility version 1.0.0, current version 1.0.0)<br>	/System/Library/Frameworks/CoreGraphics.framework/Versions/A/CoreGraphics (compatibility version 64.0.0, current version 600.0.0)<br>	/System/Library/Frameworks/Kerberos.framework/Versions/A/Kerberos (compatibility version 5.0.0, current version 6.0.0)<br>	/System/Library/Frameworks/vmnet.framework/Versions/A/vmnet (compatibility version 1.0.0, current version 1.0.0)<br>	/System/Library/Frameworks/Quartz.framework/Versions/A/Quartz (compatibility version 1.0.0, current version 1.0.0)<br>	/System/Library/Frameworks/CoreData.framework/Versions/A/CoreData (compatibility version 1.0.0, current version 641.3.0)<br>	/System/Library/Frameworks/IMServicePlugIn.framework/Versions/A/IMServicePlugIn (compatibility version 1.0.0, current version 1000.0.0)<br>	/System/Library/Frameworks/JavaScriptCore.framework/Versions/A/JavaScriptCore (compatibility version 1.0.0, current version 601.3.7)<br>	/System/Library/Frameworks/NotificationCenter.framework/Versions/A/NotificationCenter (compatibility version 1.0.0, current version 1.0.0)<br>	/System/Library/Frameworks/LocalAuthentication.framework/Versions/A/LocalAuthentication (compatibility version 1.0.0, current version 1.0.0)<br>	/System/Library/Frameworks/GameKit.framework/Versions/A/GameKit (compatibility version 1.0.0, current version 365.103.0)<br>	/System/Library/Frameworks/PubSub.framework/Versions/A/PubSub (compatibility version 1.0.0, current version 1.0.0)<br>	/System/Library/Frameworks/CoreMediaIO.framework/Versions/A/CoreMediaIO (compatibility version 1.0.0, current version 1.0.0)<br>	/System/Library/Frameworks/Social.framework/Versions/A/Social (compatibility version 1.0.0, current version 538.0.0)<br>	/System/Library/Frameworks/MultipeerConnectivity.framework/Versions/A/MultipeerConnectivity (compatibility version 1.0.0, current version 1.0.0)<br>	/System/Library/Frameworks/CoreVideo.framework/Versions/A/CoreVideo (compatibility version 1.2.0, current version 1.5.0)<br>	/System/Library/Frameworks/IOKit.framework/Versions/A/IOKit (compatibility version 1.0.0, current version 275.0.0)<br>	/System/Library/Frameworks/QTKit.framework/Versions/A/QTKit (compatibility version 1.0.0, current version 1.0.0)<br>	/System/Library/Frameworks/ApplicationServices.framework/Versions/A/ApplicationServices (compatibility version 1.0.0, current version 48.0.0)<br>	/System/Library/Frameworks/NetworkExtension.framework/Versions/A/NetworkExtension (compatibility version 1.0.0, current version 1.0.0)<br>	/System/Library/Frameworks/PCSC.framework/Versions/A/PCSC (compatibility version 1.0.0, current version 1.0.0)<br>	/System/Library/Frameworks/ExceptionHandling.framework/Versions/A/ExceptionHandling (compatibility version 1.0.0, current version 11.0.0)<br>	/System/Library/Frameworks/Carbon.framework/Versions/A/Carbon (compatibility version 2.0.0, current version 157.0.0)<br>	/System/Library/Frameworks/Security.framework/Versions/A/Security (compatibility version 1.0.0, current version 57337.20.43)<br>	/System/Library/Frameworks/AppleScriptKit.framework/Versions/A/AppleScriptKit (compatibility version 1.0.0, current version 83.0.0)<br>	/System/Library/Frameworks/LatentSemanticMapping.framework/Versions/A/LatentSemanticMapping (compatibility version 1.0.0, current version 1.0.0)<br>	/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/libruby.2.0.0.dylib (compatibility version 2.0.0, current version 2.0.0)<br>	/System/Library/Frameworks/InstantMessage.framework/Versions/A/InstantMessage (compatibility version 1.0.0, current version 800.0.0)<br>	/System/Library/Frameworks/AudioVideoBridging.framework/Versions/A/AudioVideoBridging (compatibility version 1.0.0, current version 1.0.0)<br>	/System/Library/Frameworks/CoreImage.framework/Versions/A/CoreImage (compatibility version 1.0.1, current version 2.0.0)<br>	/System/Library/Frameworks/Automator.framework/Versions/A/Automator (compatibility version 1.0.0, current version 0.0.0)<br>	/System/Library/Frameworks/MetalKit.framework/Versions/A/MetalKit (compatibility version 1.0.0, current version 1.0.0)<br>	/System/Library/Frameworks/Hypervisor.framework/Versions/A/Hypervisor (compatibility version 1.0.0, current version 1.0.0)<br>	/System/Library/Frameworks/SceneKit.framework/Versions/A/SceneKit (compatibility version 1.0.0, current version 186.0.0)<br>	/System/Library/Frameworks/OpenAL.framework/Versions/A/OpenAL (compatibility version 1.0.0, current version 1.0.0)<br>	/System/Library/Frameworks/EventKit.framework/Versions/A/EventKit (compatibility version 1.0.0, current version 487.3.0)<br>	/System/Library/Frameworks/CoreBluetooth.framework/Versions/A/CoreBluetooth (compatibility version 1.0.0, current version 1.0.0)<br>	/System/Library/Frameworks/IOBluetoothUI.framework/Versions/A/IOBluetoothUI (compatibility version 1.0.0, current version 1.0.0)<br>	/System/Library/Frameworks/CalendarStore.framework/Versions/A/CalendarStore (compatibility version 1.0.0, current version 1501.0.0)<br>	/System/Library/Frameworks/SpriteKit.framework/Versions/A/SpriteKit (compatibility version 1.0.0, current version 2.0.0)<br>	/System/Library/Frameworks/VideoToolbox.framework/Versions/A/VideoToolbox (compatibility version 1.0.0, current version 1.0.0)<br>	/System/Library/Frameworks/AudioToolbox.framework/Versions/A/AudioToolbox (compatibility version 1.0.0, current version 492.0.0)<br>	/System/Library/Frameworks/ForceFeedback.framework/Versions/A/ForceFeedback (compatibility version 1.0.0, current version 1.0.2)<br>	/System/Library/Frameworks/NetFS.framework/Versions/A/NetFS (compatibility version 1.0.0, current version 1.0.0)<br>	@rpath/FinderSync.framework/Versions/A/FinderSync (compatibility version 1.0.0, current version 960.2.6)<br>	/System/Library/Frameworks/WebKit.framework/Versions/A/WebKit (compatibility version 1.0.0, current version 601.3.9)<br>	/System/Library/Frameworks/TWAIN.framework/Versions/A/TWAIN (compatibility version 1.0.0, current version 1.0.0)<br>	/System/Library/Frameworks/CoreAudio.framework/Versions/A/CoreAudio (compatibility version 1.0.0, current version 1.0.0)<br>	/System/Library/Frameworks/SecurityInterface.framework/Versions/A/SecurityInterface (compatibility version 1.0.0, current version 55065.20.1)<br>	/System/Library/Frameworks/CoreMedia.framework/Versions/A/CoreMedia (compatibility version 1.0.0, current version 1.0.0)<br>	/System/Library/Frameworks/CoreMIDI.framework/Versions/A/CoreMIDI (compatibility version 1.0.0, current version 73.0.0)<br>	/System/Library/Frameworks/ICADevices.framework/Versions/A/ICADevices (compatibility version 1.0.0, current version 1.0.0)<br>	/System/Library/Frameworks/MediaToolbox.framework/Versions/A/MediaToolbox (compatibility version 1.0.0, current version 1.0.0)<br>	/System/Library/Frameworks/CoreAudioKit.framework/Versions/A/CoreAudioKit (compatibility version 1.0.0, current version 1.0.0)<br>	/System/Library/Frameworks/Accounts.framework/Versions/A/Accounts (compatibility version 1.0.0, current version 0.0.0)<br>	/System/Library/Frameworks/PhotosUI.framework/Versions/A/PhotosUI (compatibility version 1.0.0, current version 350.22.0)<br>	/System/Library/Frameworks/DVDPlayback.framework/Versions/A/DVDPlayback (compatibility version 5000.0.0, current version 5950.0.0)<br>	/System/Library/Frameworks/DiscRecordingUI.framework/Versions/A/DiscRecordingUI (compatibility version 1.0.0, current version 1.0.0)<br>	/usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1226.10.1)<br>	/System/Library/Frameworks/ScriptingBridge.framework/Versions/A/ScriptingBridge (compatibility version 1.0.0, current version 1.0.0)<br>	/System/Library/Frameworks/CoreWLAN.framework/Versions/A/CoreWLAN (compatibility version 1.0.0, current version 1.0.0)<br>	/System/Library/Frameworks/CryptoTokenKit.framework/Versions/A/CryptoTokenKit (compatibility version 1.0.0, current version 1.0.0)<br>	/System/Library/Frameworks/ScreenSaver.framework/Versions/A/ScreenSaver (compatibility version 1.0.0, current version 1.0.0)<br>	/System/Library/Frameworks/Cocoa.framework/Versions/A/Cocoa (compatibility version 1.0.0, current version 22.0.0)<br>	/System/Library/Frameworks/QuartzCore.framework/Versions/A/QuartzCore (compatibility version 1.2.0, current version 1.11.0)<br>	/System/Library/Frameworks/OpenGL.framework/Versions/A/OpenGL (compatibility version 1.0.0, current version 1.0.0)<br>	/System/Library/Frameworks/CoreServices.framework/Versions/A/CoreServices (compatibility version 1.0.0, current version 728.6.0)<br>	/System/Library/Frameworks/MediaLibrary.framework/Versions/A/MediaLibrary (compatibility version 1.0.0, current version 721.0.0)<br>	/System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation (compatibility version 150.0.0, current version 1256.14.0)<br>	/System/Library/Frameworks/Accelerate.framework/Versions/A/Accelerate (compatibility version 1.0.0, current version 4.0.0)<br>	/System/Library/Frameworks/AVFoundation.framework/Versions/A/AVFoundation (compatibility version 1.0.0, current version 2.0.0)<br>	/System/Library/Frameworks/FWAUserLib.framework/Versions/A/FWAUserLib (compatibility version 1.0.0, current version 1.0.0)<br>	/System/Library/Frameworks/AudioUnit.framework/Versions/A/AudioUnit (compatibility version 1.0.0, current version 1.0.0)<br>	/System/Library/Frameworks/IOSurface.framework/Versions/A/IOSurface (compatibility version 1.0.0, current version 1.0.0)<br>	/System/Library/Frameworks/SystemConfiguration.framework/Versions/A/SystemConfiguration (compatibility version 1.0.0, current version 802.20.7)<br>	/System/Library/Frameworks/IOBluetooth.framework/Versions/A/IOBluetooth (compatibility version 1.0.0, current version 1.0.0)<br>	/usr/lib/libobjc.A.dylib (compatibility version 1.0.0, current version 228.0.0)<br></p><p>I don&#39;t think the optimization you describe is possible with Objective-C due to the dynamic nature of the runtime. The linker has no way of knowing that a class won’t be accessed via NSClassFromString(), or from a nib file or something.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/18137403/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Mini-proposal] Require @nonobjc on members of @objc protocol extensions</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January  5, 2016 at 10:00:00pm</p></header><div class="content"><p>I stand corrected.<br></p><p>Félix<br></p><p>&gt; Le 5 janv. 2016 à 22:19:28, Charles Srstka &lt;cocoadev at charlessoft.com&gt; a écrit :<br>&gt; <br>&gt;&gt; On Jan 5, 2016, at 9:06 PM, Félix Cloutier &lt;felixcca at yahoo.ca &lt;mailto:felixcca at yahoo.ca&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The linker is smart enough to get rid of frameworks that you don&#39;t actually use.<br>&gt;&gt; <br>&gt;&gt; Félix<br>&gt; <br>&gt; <br>&gt; objc_copyClassList leaves a value of 14694 in classCount. When I just link against Foundation it only gives 1581.<br>&gt; <br>&gt; otool says:<br>&gt; <br>&gt; $ otool -L test<br>&gt; test:<br>&gt; 	/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 120.1.0)<br>&gt; 	/System/Library/Frameworks/Foundation.framework/Versions/C/Foundation (compatibility version 300.0.0, current version 1256.1.0)<br>&gt; 	/System/Library/Frameworks/CFNetwork.framework/Versions/A/CFNetwork (compatibility version 1.0.0, current version 760.2.5)<br>&gt; 	/System/Library/Frameworks/Metal.framework/Versions/A/Metal (compatibility version 1.0.0, current version 1.0.0)<br>&gt; 	/System/Library/Frameworks/Contacts.framework/Versions/A/Contacts (compatibility version 0.0.0, current version 0.0.0)<br>&gt; 	/System/Library/Frameworks/GSS.framework/Versions/A/GSS (compatibility version 1.0.0, current version 1.0.0)<br>&gt; 	/System/Library/Frameworks/CoreMIDIServer.framework/Versions/A/CoreMIDIServer (compatibility version 1.0.0, current version 73.0.0)<br>&gt; 	/System/Library/Frameworks/Python.framework/Versions/2.7/Python (compatibility version 2.7.0, current version 2.7.10)<br>&gt; 	/System/Library/Frameworks/CoreLocation.framework/Versions/A/CoreLocation (compatibility version 1.0.0, current version 1615.38.0)<br>&gt; 	/System/Library/Frameworks/GLKit.framework/Versions/A/GLKit (compatibility version 1.0.0, current version 20.0.0)<br>&gt; 	/System/Library/Frameworks/MapKit.framework/Versions/A/MapKit (compatibility version 1.0.0, current version 0.0.0)<br>&gt; 	/System/Library/Frameworks/ServiceManagement.framework/Versions/A/ServiceManagement (compatibility version 1.0.0, current version 756.20.4)<br>&gt; 	/System/Library/Frameworks/CoreTelephony.framework/Versions/A/CoreTelephony (compatibility version 1.0.0, current version 0.0.0)<br>&gt; 	/System/Library/Frameworks/CloudKit.framework/Versions/A/CloudKit (compatibility version 1.0.0, current version 481.8.0)<br>&gt; 	/System/Library/Frameworks/ImageIO.framework/Versions/A/ImageIO (compatibility version 1.0.0, current version 1.0.0)<br>&gt; 	/System/Library/Frameworks/CoreText.framework/Versions/A/CoreText (compatibility version 1.0.0, current version 1.0.0)<br>&gt; 	/System/Library/Frameworks/Collaboration.framework/Versions/A/Collaboration (compatibility version 1.0.0, current version 75.0.0)<br>&gt; 	/System/Library/Frameworks/LDAP.framework/Versions/A/LDAP (compatibility version 1.0.0, current version 2.4.0)<br>&gt; 	/System/Library/Frameworks/AddressBook.framework/Versions/A/AddressBook (compatibility version 1.0.0, current version 1679.3.0)<br>&gt; 	/System/Library/Frameworks/QuickLook.framework/Versions/A/QuickLook (compatibility version 1.0.0, current version 0.0.0)<br>&gt; 	/System/Library/Frameworks/DiskArbitration.framework/Versions/A/DiskArbitration (compatibility version 1.0.0, current version 1.0.0)<br>&gt; 	/System/Library/Frameworks/Tcl.framework/Versions/8.5/Tcl (compatibility version 8.5.0, current version 8.5.9)<br>&gt; 	/System/Library/Frameworks/DiscRecording.framework/Versions/A/DiscRecording (compatibility version 1.0.0, current version 1.0.0)<br>&gt; 	/System/Library/Frameworks/InputMethodKit.framework/Versions/A/InputMethodKit (compatibility version 1.0.0, current version 1.0.0)<br>&gt; 	/System/Library/Frameworks/OpenCL.framework/Versions/A/OpenCL (compatibility version 1.0.0, current version 1.0.0)<br>&gt; 	/System/Library/Frameworks/Photos.framework/Versions/A/Photos (compatibility version 1.0.0, current version 350.22.0)<br>&gt; 	/System/Library/Frameworks/OSAKit.framework/Versions/A/OSAKit (compatibility version 1.0.0, current version 104.0.0)<br>&gt; 	/System/Library/Frameworks/MediaAccessibility.framework/Versions/A/MediaAccessibility (compatibility version 1.0.0, current version 62.0.0)<br>&gt; 	/System/Library/Frameworks/ContactsUI.framework/Versions/A/ContactsUI (compatibility version 1.0.0, current version 1679.3.0)<br>&gt; 	/System/Library/Frameworks/DirectoryService.framework/Versions/A/DirectoryService (compatibility version 1.0.0, current version 1.0.0)<br>&gt; 	/System/Library/Frameworks/AGL.framework/Versions/A/AGL (compatibility version 1.0.0, current version 1.0.0)<br>&gt; 	/System/Library/Frameworks/StoreKit.framework/Versions/A/StoreKit (compatibility version 1.0.0, current version 379.0.0)<br>&gt; 	/System/Library/Frameworks/OpenDirectory.framework/Versions/A/OpenDirectory (compatibility version 1.0.0, current version 1.0.0)<br>&gt; 	/System/Library/Frameworks/PreferencePanes.framework/Versions/A/PreferencePanes (compatibility version 1.0.0, current version 1.0.0)<br>&gt; 	/System/Library/Frameworks/GameplayKit.framework/Versions/A/GameplayKit (compatibility version 1.0.0, current version 1.0.0)<br>&gt; 	/System/Library/Frameworks/SyncServices.framework/Versions/A/SyncServices (compatibility version 48.0.0, current version 724.0.0)<br>&gt; 	/System/Library/Frameworks/AVKit.framework/Versions/A/AVKit (compatibility version 1.0.0, current version 1.0.0)<br>&gt; 	/System/Library/Frameworks/GLUT.framework/Versions/A/GLUT (compatibility version 1.0.0, current version 1.0.0)<br>&gt; 	/System/Library/Frameworks/ModelIO.framework/Versions/A/ModelIO (compatibility version 1.0.0, current version 1.0.0)<br>&gt; 	/System/Library/Frameworks/GameController.framework/Versions/A/GameController (compatibility version 1.0.0, current version 1.0.0)<br>&gt; 	/System/Library/Frameworks/Tk.framework/Versions/8.5/Tk (compatibility version 8.5.0, current version 8.5.9)<br>&gt; 	/System/Library/Frameworks/AppleScriptObjC.framework/Versions/A/AppleScriptObjC (compatibility version 1.0.0, current version 32.0.0)<br>&gt; 	/System/Library/Frameworks/AppKit.framework/Versions/C/AppKit (compatibility version 45.0.0, current version 1404.32.0)<br>&gt; 	/System/Library/Frameworks/InstallerPlugins.framework/Versions/A/InstallerPlugins (compatibility version 1.0.0, current version 815.0.0)<br>&gt; 	/System/Library/Frameworks/SecurityFoundation.framework/Versions/A/SecurityFoundation (compatibility version 1.0.0, current version 55126.0.0)<br>&gt; 	/System/Library/Frameworks/ImageCaptureCore.framework/Versions/A/ImageCaptureCore (compatibility version 1.0.0, current version 1.0.0)<br>&gt; 	/System/Library/Frameworks/VideoDecodeAcceleration.framework/Versions/A/VideoDecodeAcceleration (compatibility version 1.0.0, current version 1.0.0)<br>&gt; 	/System/Library/Frameworks/CoreGraphics.framework/Versions/A/CoreGraphics (compatibility version 64.0.0, current version 600.0.0)<br>&gt; 	/System/Library/Frameworks/Kerberos.framework/Versions/A/Kerberos (compatibility version 5.0.0, current version 6.0.0)<br>&gt; 	/System/Library/Frameworks/vmnet.framework/Versions/A/vmnet (compatibility version 1.0.0, current version 1.0.0)<br>&gt; 	/System/Library/Frameworks/Quartz.framework/Versions/A/Quartz (compatibility version 1.0.0, current version 1.0.0)<br>&gt; 	/System/Library/Frameworks/CoreData.framework/Versions/A/CoreData (compatibility version 1.0.0, current version 641.3.0)<br>&gt; 	/System/Library/Frameworks/IMServicePlugIn.framework/Versions/A/IMServicePlugIn (compatibility version 1.0.0, current version 1000.0.0)<br>&gt; 	/System/Library/Frameworks/JavaScriptCore.framework/Versions/A/JavaScriptCore (compatibility version 1.0.0, current version 601.3.7)<br>&gt; 	/System/Library/Frameworks/NotificationCenter.framework/Versions/A/NotificationCenter (compatibility version 1.0.0, current version 1.0.0)<br>&gt; 	/System/Library/Frameworks/LocalAuthentication.framework/Versions/A/LocalAuthentication (compatibility version 1.0.0, current version 1.0.0)<br>&gt; 	/System/Library/Frameworks/GameKit.framework/Versions/A/GameKit (compatibility version 1.0.0, current version 365.103.0)<br>&gt; 	/System/Library/Frameworks/PubSub.framework/Versions/A/PubSub (compatibility version 1.0.0, current version 1.0.0)<br>&gt; 	/System/Library/Frameworks/CoreMediaIO.framework/Versions/A/CoreMediaIO (compatibility version 1.0.0, current version 1.0.0)<br>&gt; 	/System/Library/Frameworks/Social.framework/Versions/A/Social (compatibility version 1.0.0, current version 538.0.0)<br>&gt; 	/System/Library/Frameworks/MultipeerConnectivity.framework/Versions/A/MultipeerConnectivity (compatibility version 1.0.0, current version 1.0.0)<br>&gt; 	/System/Library/Frameworks/CoreVideo.framework/Versions/A/CoreVideo (compatibility version 1.2.0, current version 1.5.0)<br>&gt; 	/System/Library/Frameworks/IOKit.framework/Versions/A/IOKit (compatibility version 1.0.0, current version 275.0.0)<br>&gt; 	/System/Library/Frameworks/QTKit.framework/Versions/A/QTKit (compatibility version 1.0.0, current version 1.0.0)<br>&gt; 	/System/Library/Frameworks/ApplicationServices.framework/Versions/A/ApplicationServices (compatibility version 1.0.0, current version 48.0.0)<br>&gt; 	/System/Library/Frameworks/NetworkExtension.framework/Versions/A/NetworkExtension (compatibility version 1.0.0, current version 1.0.0)<br>&gt; 	/System/Library/Frameworks/PCSC.framework/Versions/A/PCSC (compatibility version 1.0.0, current version 1.0.0)<br>&gt; 	/System/Library/Frameworks/ExceptionHandling.framework/Versions/A/ExceptionHandling (compatibility version 1.0.0, current version 11.0.0)<br>&gt; 	/System/Library/Frameworks/Carbon.framework/Versions/A/Carbon (compatibility version 2.0.0, current version 157.0.0)<br>&gt; 	/System/Library/Frameworks/Security.framework/Versions/A/Security (compatibility version 1.0.0, current version 57337.20.43)<br>&gt; 	/System/Library/Frameworks/AppleScriptKit.framework/Versions/A/AppleScriptKit (compatibility version 1.0.0, current version 83.0.0)<br>&gt; 	/System/Library/Frameworks/LatentSemanticMapping.framework/Versions/A/LatentSemanticMapping (compatibility version 1.0.0, current version 1.0.0)<br>&gt; 	/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/libruby.2.0.0.dylib (compatibility version 2.0.0, current version 2.0.0)<br>&gt; 	/System/Library/Frameworks/InstantMessage.framework/Versions/A/InstantMessage (compatibility version 1.0.0, current version 800.0.0)<br>&gt; 	/System/Library/Frameworks/AudioVideoBridging.framework/Versions/A/AudioVideoBridging (compatibility version 1.0.0, current version 1.0.0)<br>&gt; 	/System/Library/Frameworks/CoreImage.framework/Versions/A/CoreImage (compatibility version 1.0.1, current version 2.0.0)<br>&gt; 	/System/Library/Frameworks/Automator.framework/Versions/A/Automator (compatibility version 1.0.0, current version 0.0.0)<br>&gt; 	/System/Library/Frameworks/MetalKit.framework/Versions/A/MetalKit (compatibility version 1.0.0, current version 1.0.0)<br>&gt; 	/System/Library/Frameworks/Hypervisor.framework/Versions/A/Hypervisor (compatibility version 1.0.0, current version 1.0.0)<br>&gt; 	/System/Library/Frameworks/SceneKit.framework/Versions/A/SceneKit (compatibility version 1.0.0, current version 186.0.0)<br>&gt; 	/System/Library/Frameworks/OpenAL.framework/Versions/A/OpenAL (compatibility version 1.0.0, current version 1.0.0)<br>&gt; 	/System/Library/Frameworks/EventKit.framework/Versions/A/EventKit (compatibility version 1.0.0, current version 487.3.0)<br>&gt; 	/System/Library/Frameworks/CoreBluetooth.framework/Versions/A/CoreBluetooth (compatibility version 1.0.0, current version 1.0.0)<br>&gt; 	/System/Library/Frameworks/IOBluetoothUI.framework/Versions/A/IOBluetoothUI (compatibility version 1.0.0, current version 1.0.0)<br>&gt; 	/System/Library/Frameworks/CalendarStore.framework/Versions/A/CalendarStore (compatibility version 1.0.0, current version 1501.0.0)<br>&gt; 	/System/Library/Frameworks/SpriteKit.framework/Versions/A/SpriteKit (compatibility version 1.0.0, current version 2.0.0)<br>&gt; 	/System/Library/Frameworks/VideoToolbox.framework/Versions/A/VideoToolbox (compatibility version 1.0.0, current version 1.0.0)<br>&gt; 	/System/Library/Frameworks/AudioToolbox.framework/Versions/A/AudioToolbox (compatibility version 1.0.0, current version 492.0.0)<br>&gt; 	/System/Library/Frameworks/ForceFeedback.framework/Versions/A/ForceFeedback (compatibility version 1.0.0, current version 1.0.2)<br>&gt; 	/System/Library/Frameworks/NetFS.framework/Versions/A/NetFS (compatibility version 1.0.0, current version 1.0.0)<br>&gt; 	@rpath/FinderSync.framework/Versions/A/FinderSync (compatibility version 1.0.0, current version 960.2.6)<br>&gt; 	/System/Library/Frameworks/WebKit.framework/Versions/A/WebKit (compatibility version 1.0.0, current version 601.3.9)<br>&gt; 	/System/Library/Frameworks/TWAIN.framework/Versions/A/TWAIN (compatibility version 1.0.0, current version 1.0.0)<br>&gt; 	/System/Library/Frameworks/CoreAudio.framework/Versions/A/CoreAudio (compatibility version 1.0.0, current version 1.0.0)<br>&gt; 	/System/Library/Frameworks/SecurityInterface.framework/Versions/A/SecurityInterface (compatibility version 1.0.0, current version 55065.20.1)<br>&gt; 	/System/Library/Frameworks/CoreMedia.framework/Versions/A/CoreMedia (compatibility version 1.0.0, current version 1.0.0)<br>&gt; 	/System/Library/Frameworks/CoreMIDI.framework/Versions/A/CoreMIDI (compatibility version 1.0.0, current version 73.0.0)<br>&gt; 	/System/Library/Frameworks/ICADevices.framework/Versions/A/ICADevices (compatibility version 1.0.0, current version 1.0.0)<br>&gt; 	/System/Library/Frameworks/MediaToolbox.framework/Versions/A/MediaToolbox (compatibility version 1.0.0, current version 1.0.0)<br>&gt; 	/System/Library/Frameworks/CoreAudioKit.framework/Versions/A/CoreAudioKit (compatibility version 1.0.0, current version 1.0.0)<br>&gt; 	/System/Library/Frameworks/Accounts.framework/Versions/A/Accounts (compatibility version 1.0.0, current version 0.0.0)<br>&gt; 	/System/Library/Frameworks/PhotosUI.framework/Versions/A/PhotosUI (compatibility version 1.0.0, current version 350.22.0)<br>&gt; 	/System/Library/Frameworks/DVDPlayback.framework/Versions/A/DVDPlayback (compatibility version 5000.0.0, current version 5950.0.0)<br>&gt; 	/System/Library/Frameworks/DiscRecordingUI.framework/Versions/A/DiscRecordingUI (compatibility version 1.0.0, current version 1.0.0)<br>&gt; 	/usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1226.10.1)<br>&gt; 	/System/Library/Frameworks/ScriptingBridge.framework/Versions/A/ScriptingBridge (compatibility version 1.0.0, current version 1.0.0)<br>&gt; 	/System/Library/Frameworks/CoreWLAN.framework/Versions/A/CoreWLAN (compatibility version 1.0.0, current version 1.0.0)<br>&gt; 	/System/Library/Frameworks/CryptoTokenKit.framework/Versions/A/CryptoTokenKit (compatibility version 1.0.0, current version 1.0.0)<br>&gt; 	/System/Library/Frameworks/ScreenSaver.framework/Versions/A/ScreenSaver (compatibility version 1.0.0, current version 1.0.0)<br>&gt; 	/System/Library/Frameworks/Cocoa.framework/Versions/A/Cocoa (compatibility version 1.0.0, current version 22.0.0)<br>&gt; 	/System/Library/Frameworks/QuartzCore.framework/Versions/A/QuartzCore (compatibility version 1.2.0, current version 1.11.0)<br>&gt; 	/System/Library/Frameworks/OpenGL.framework/Versions/A/OpenGL (compatibility version 1.0.0, current version 1.0.0)<br>&gt; 	/System/Library/Frameworks/CoreServices.framework/Versions/A/CoreServices (compatibility version 1.0.0, current version 728.6.0)<br>&gt; 	/System/Library/Frameworks/MediaLibrary.framework/Versions/A/MediaLibrary (compatibility version 1.0.0, current version 721.0.0)<br>&gt; 	/System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation (compatibility version 150.0.0, current version 1256.14.0)<br>&gt; 	/System/Library/Frameworks/Accelerate.framework/Versions/A/Accelerate (compatibility version 1.0.0, current version 4.0.0)<br>&gt; 	/System/Library/Frameworks/AVFoundation.framework/Versions/A/AVFoundation (compatibility version 1.0.0, current version 2.0.0)<br>&gt; 	/System/Library/Frameworks/FWAUserLib.framework/Versions/A/FWAUserLib (compatibility version 1.0.0, current version 1.0.0)<br>&gt; 	/System/Library/Frameworks/AudioUnit.framework/Versions/A/AudioUnit (compatibility version 1.0.0, current version 1.0.0)<br>&gt; 	/System/Library/Frameworks/IOSurface.framework/Versions/A/IOSurface (compatibility version 1.0.0, current version 1.0.0)<br>&gt; 	/System/Library/Frameworks/SystemConfiguration.framework/Versions/A/SystemConfiguration (compatibility version 1.0.0, current version 802.20.7)<br>&gt; 	/System/Library/Frameworks/IOBluetooth.framework/Versions/A/IOBluetooth (compatibility version 1.0.0, current version 1.0.0)<br>&gt; 	/usr/lib/libobjc.A.dylib (compatibility version 1.0.0, current version 228.0.0)<br>&gt; <br>&gt; I don&#39;t think the optimization you describe is possible with Objective-C due to the dynamic nature of the runtime. The linker has no way of knowing that a class won’t be accessed via NSClassFromString(), or from a nib file or something.<br>&gt; <br>&gt; Charles<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/d77d18c1/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Mini-proposal] Require @nonobjc on members of @objc protocol extensions</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>January  6, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jan 5, 2016, at 8:55 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 5, 2016, at 8:29 PM, Greg Parker &lt;gparker at apple.com &lt;mailto:gparker at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 5, 2016, at 3:37 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 5, 2016, at 11:52 AM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are better mechanisms for this than +load. But one would have to deal with the dylib loading issue and the need to enumerate root classes to get to a complete implementation. Frankly, I don’t think this level of Objective-C runtime hackery is worth the effort, hence my suggestion to make the existing behavior explicit.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yeah, +load was just to throw together a quick-and-dirty demonstration, and not what you’d actually use. You have a point about libraries and bundles; you’d have to hook into that and rescan each time new code was dynamically loaded. However, the enumeration of classes only seems to take around 0.001 seconds, so I don’t think it’s terrible.<br>&gt;&gt; <br>&gt;&gt; Enumeration of classes is terrible: it forces the runtime to perform lots of work that it tries very hard to perform lazily otherwise. I would expect your measured cost to be much higher if you had linked to more high-level libraries (UIKit, MapKit, etc).<br>&gt; <br>&gt; That was my gut reaction to the idea also, when I had it, but it seems to run pretty fast no matter what I do. I just tried dragging every framework from /System/Library/Frameworks into the project, removing only the Java frameworks, Kernel.framework, Message.framework, and vecLib.framework. Time taken was 0.004260 seconds.<br>&gt; <br>&gt; It is, of course, ugly and hacky as hell, and that might make a pretty good reason not to do it. :-/ What do you think about the other idea, of adding to NSObject’s default implementation of +resolveInstanceMethod:? That *would* be done lazily, and would avoid all the problems involving dynamically loaded code.<br></p><p>Okay, here’s a more serious, less devil’s-advocatey sketch. It would require one tweak to the compiler to allow the swiftImplementationForSelector() method to be vtable dispatched. Otherwise, it pretty much works:<br></p><p>The basic protocol:<br></p><p>@objc protocol HasSwiftExtension {}<br></p><p>extension HasSwiftExtension {<br>    // Problem: This method won&#39;t correctly be dispatched, and instead this implementation will always be called.<br>    // The method cannot be declared in the protocol, because then Swift would try to use the Objective-C runtime<br>    // to find it (and fail). Some way to declare methods in extensions that are dispatched via the vtable would<br>    // need to be added for this to work properly.<br>    func swiftImplementationForSelector(selector: Selector) -&gt; (implementation: IMP, types: String)? {<br>        return nil<br>    }<br>}<br></p><p>extension NSObject {<br>    class func somePrefixHere_SwizzledResolveInstanceMethod(selector: Selector) -&gt; Bool {<br>        // Doesn&#39;t work as written because of the lack of vtable dispatch.<br>        // However, if you change &quot;as? HasSwiftExtension&quot; to &quot;as? P&quot; below, it will work in the case of P.<br>        if let swiftySelf = self as? HasSwiftExtension {<br>            // Yes, here we are calling an instance method from a class object.<br>            // It works because the NSObject class is technically also an instance of NSObject.<br>            // It would be better to use a class method, but Swift doesn&#39;t allow declaring those<br>            // in protocols or extensions.<br>            if let (implementation: imp, types: types) = swiftySelf.swiftImplementationForSelector(selector) {<br>                class_addMethod(self, selector, imp, types)<br>                return true<br>            }<br>        }<br>        <br>        return somePrefixHere_SwizzledResolveInstanceMethod(selector)<br>    }<br>}<br></p><p>The Objective-C shim to do the swizzling:<br></p><p>@interface NSObject(Swizzle)<br>@end<br></p><p>@implementation NSObject(Swizzle)<br></p><p>+ (void)load {<br>    Method m1 = class_getClassMethod(self, @selector(resolveInstanceMethod:));<br>    Method m2 = class_getClassMethod(self, @selector(somePrefixHere_SwizzledResolveInstanceMethod:));<br>    <br>    method_exchangeImplementations(m1, m2);<br>}<br></p><p>@end<br></p><p>Sample protocol and class conforming to this:<br></p><p>// HasSwiftExtension conformance would be added automatically by the compiler.<br>@objc protocol P: HasSwiftExtension {<br>    optional func foo() // optional only to avoid that compiler crash<br>}<br></p><p>class C: NSObject, P {}<br></p><p>extension P {<br>    // This method would be added automatically by the compiler.<br>    func swiftImplementationForSelector(selector: Selector) -&gt; (implementation: IMP, types: String)? {<br>        switch selector {<br>        case &quot;foo&quot;:<br>            let block: @convention(block) (P) -&gt; () = { $0.foo() }<br>            let imp = imp_implementationWithBlock(unsafeBitCast(block, AnyObject.self))<br>            <br>            return (implementation: imp, types: &quot;v@:&quot;)<br>        default:<br>            return nil<br>        }<br>    }<br>    <br>    func foo() { print(&quot;foo was called&quot;) }<br>}<br></p><p>Changing “as? HasSwiftExtension” to “as? P” in somePrefixHere_SwizzledResolveInstanceMethod(), and then calling this in main:<br></p><p>let c = C()<br></p><p>c.performSelector(&quot;foo&quot;)<br></p><p>outputs:<br></p><p>foo was called<br>Program ended with exit code: 0<br></p><p>I think it could be doable.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160106/a8aa71f4/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
