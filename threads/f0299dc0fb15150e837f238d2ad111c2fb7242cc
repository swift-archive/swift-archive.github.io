<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Changes to RangeReplaceableCollectionType</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>February 28, 2016 at 05:00:00pm</p></header><div class="content"><p>So today I’ve been trying to put together an implementation of an ordered collection, and I noticed that a lot of important mutating methods are actually grouped together under RangeReplaceableCollectionType, which is actually kind of weird, and has led me to create some more specialised protocols of my own as I actually can’t implement RangeReplaceableCollectionType as it for a number of reasons, which I’ll discuss here:<br></p><p>Remove initialisers<br></p><p>I’m not actually sure why RangeReplaceableCollectionType has required initialisers, since it shouldn’t really matter how you create it since you can reserve capacity separately if you have to, prior to dumping elements into it. However, having these initialiser requirements actually makes it impossible to conform to this protocol if you require other data in order to initialise your type.<br></p><p>For example, my type requires a closure, and I can’t provide a default closure (since the whole point of it is so I can support elements of any type). I can’t think of any reason why these initialiser requirements should be necessary, so hopefully they can just be removed.<br></p><p>Separate out the append(), appendContentsOf() and reserveCapacity() methods:<br></p><p>These methods don’t seem to me to be specific to RangeReplaceableCollectionType, and it seems like they should be separated into an AppendableCollectionType or ExpandableCollectionType or similar. While .replaceRange() could technically be used to fulfil .append() and .appendContentsOf(), it’s not actually replacing anything so it isn’t directly related IMO.<br></p><p>Indeed, it’s conceivable that a type might want to declare the ability to append elements separately from declaring means of removing them arbitrarily (which is what RangeReplaceableCollectionType does), as they may want stricter requirements on removal; for example a queue where elements can only be removed via a removeHead() method or similar.<br></p><p>Separate removal and insertion:<br></p><p>Another case where RangeReplaceableCollectionType forces potentially incompatible actions is that it requires both the ability to remove and to insert arbitrarily into a collection. This is fine if the collection has no form of sort order, however, if the collection is sorted, then insertion operations actually make no sense, requiring the type to ignore the provided indices and just position elements where it decides is best regardless. Removals from a sorted collection don’t have this issue however (if you remove a chunk from them then the remaining elements should still be in the correct order).<br></p><p><br>Essentially this is a bunch of issues I ran into while attempting to implement an ordered collection with as many of the same capabilities of an Array as possible; while I realise that separation will result in two new CollectionType protocols, I think that it could be beneficial for flexibility when defining our own custom types.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160228/f02942cc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>Changes to RangeReplaceableCollectionType</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>February 28, 2016 at 01:00:00pm</p></header><div class="content"><p>On the one hand, I agree with your assessment (I’ve also done various order-maintaining collections, and based on that I think you’ll find *neither* `RangeReplaceableCollectionType` nor `MutableCollectionType` are actually adoptable for your type; the “weaker&quot; `MutableCollectionType` isn’t even adoptable by `Set` and `Dictionary` as it requires ordered, freely-reorderable storage).<br></p><p>But, on the other hand, I’m not sure there’s actually a meaningful version of `RangeReplaceableCollectionType` that’d make sense for an order-maintaining collection, anyways, for the reasons you outlined in “Separate removal and insertion”; the API seems entirely inappropriate outside of the `remove*` functions, as you noted (FWIW it seems *mostly* meant to support things like ropes and other, similar data structures).<br></p><p>I’d expect a generic ordered-collection protocol to have methods more like this:<br></p><p>// some example removal methods:<br>mutating func removeElementsWithin(interval: ClosedInterval&lt;Element&gt;)  // &lt;- requires `Element:Comparable`<br>mutating func removeElementsBefore(element: Element) <br>mutating func removeElementsAfter(element: Element) <br></p><p>…(e.g., functions that actually reference/take advantage of the ordering), and there’s actually rather a lot of methods that would *potentially* be useful things to have and override.<br></p><p>I’m a bit curious if anything other than (perhaps?) “Collections move Indices” is on tap for standard-library updates on this topic (e.g. any plans for a baked-in “OrderedCollection” protocol, or for tree-shaped collections, etc.?).<br></p><p>PS: FWIW, I’ve found the best way to handle “ordered collections” at present is to make it so it “has-a” (read-only) collection, but is *not* itself a collection…for read-only use this doesn’t change much, and as already noted the mutable-collection protocols are rather troublesome here.<br></p><p>&gt; On Feb 28, 2016, at 11:47 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; So today I’ve been trying to put together an implementation of an ordered collection, and I noticed that a lot of important mutating methods are actually grouped together under RangeReplaceableCollectionType, which is actually kind of weird, and has led me to create some more specialised protocols of my own as I actually can’t implement RangeReplaceableCollectionType as it for a number of reasons, which I’ll discuss here:<br>&gt; <br>&gt; Remove initialisers<br>&gt; <br>&gt; I’m not actually sure why RangeReplaceableCollectionType has required initialisers, since it shouldn’t really matter how you create it since you can reserve capacity separately if you have to, prior to dumping elements into it. However, having these initialiser requirements actually makes it impossible to conform to this protocol if you require other data in order to initialise your type.<br>&gt; <br>&gt; For example, my type requires a closure, and I can’t provide a default closure (since the whole point of it is so I can support elements of any type). I can’t think of any reason why these initialiser requirements should be necessary, so hopefully they can just be removed.<br>&gt; <br>&gt; Separate out the append(), appendContentsOf() and reserveCapacity() methods:<br>&gt; <br>&gt; These methods don’t seem to me to be specific to RangeReplaceableCollectionType, and it seems like they should be separated into an AppendableCollectionType or ExpandableCollectionType or similar. While .replaceRange() could technically be used to fulfil .append() and .appendContentsOf(), it’s not actually replacing anything so it isn’t directly related IMO.<br>&gt; <br>&gt; Indeed, it’s conceivable that a type might want to declare the ability to append elements separately from declaring means of removing them arbitrarily (which is what RangeReplaceableCollectionType does), as they may want stricter requirements on removal; for example a queue where elements can only be removed via a removeHead() method or similar.<br>&gt; <br>&gt; Separate removal and insertion:<br>&gt; <br>&gt; Another case where RangeReplaceableCollectionType forces potentially incompatible actions is that it requires both the ability to remove and to insert arbitrarily into a collection. This is fine if the collection has no form of sort order, however, if the collection is sorted, then insertion operations actually make no sense, requiring the type to ignore the provided indices and just position elements where it decides is best regardless. Removals from a sorted collection don’t have this issue however (if you remove a chunk from them then the remaining elements should still be in the correct order).<br>&gt; <br>&gt; <br>&gt; Essentially this is a bunch of issues I ran into while attempting to implement an ordered collection with as many of the same capabilities of an Array as possible; while I realise that separation will result in two new CollectionType protocols, I think that it could be beneficial for flexibility when defining our own custom types.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160228/728a5c10/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Changes to RangeReplaceableCollectionType</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>February 29, 2016 at 02:00:00am</p></header><div class="content"><p>On Sun, Feb 28, 2016 at 9:47 AM, Haravikk via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; So today I’ve been trying to put together an implementation of an ordered<br>&gt; collection, and I noticed that a lot of important mutating methods are<br>&gt; actually grouped together under RangeReplaceableCollectionType, which is<br>&gt; actually kind of weird, and has led me to create some more specialised<br>&gt; protocols of my own as I actually can’t implement<br>&gt; RangeReplaceableCollectionType as it for a number of reasons, which I’ll<br>&gt; discuss here:<br>&gt;<br>&gt; Remove initialisers<br>&gt;<br>&gt; I’m not actually sure why RangeReplaceableCollectionType has required<br>&gt; initialisers, since it shouldn’t really matter how you create it since you<br>&gt; can reserve capacity separately if you have to, prior to dumping elements<br>&gt; into it. However, having these initialiser requirements actually makes it<br>&gt; impossible to conform to this protocol if you require other data in order to<br>&gt; initialise your type.<br></p><p>If your type absolutely requires non-zero data elements for an<br>instance to exist, how would it implement removeAll()?<br></p><p>&gt; For example, my type requires a closure, and I can’t provide a default<br>&gt; closure (since the whole point of it is so I can support elements of any<br>&gt; type). I can’t think of any reason why these initialiser requirements should<br>&gt; be necessary, so hopefully they can just be removed.<br></p><p>Could you provide more information about your type?  If the closure is<br>a crucial part of the value, how do you implement collection equality?<br></p><p>&gt; Separate out the append(), appendContentsOf() and reserveCapacity() methods:<br>&gt;<br>&gt; These methods don’t seem to me to be specific to<br>&gt; RangeReplaceableCollectionType, and it seems like they should be separated<br>&gt; into an AppendableCollectionType or ExpandableCollectionType or similar.<br>&gt; While .replaceRange() could technically be used to fulfil .append() and<br>&gt; .appendContentsOf(), it’s not actually replacing anything so it isn’t<br>&gt; directly related IMO.<br></p><p>We had ExtensibleCollection before, but we dropped it.  The rationale<br>is that if you can create an empty collection, and can append, then<br>you can implement replaceRange() with just that.  Thus,<br>ExtensibleCollection and RangeReplaceableCollection are the same type.<br></p><p>&gt; Indeed, it’s conceivable that a type might want to declare the ability to<br>&gt; append elements separately from declaring means of removing them arbitrarily<br>&gt; (which is what RangeReplaceableCollectionType does), as they may want<br>&gt; stricter requirements on removal; for example a queue where elements can<br>&gt; only be removed via a removeHead() method or similar.<br></p><p>Then your type is not a RangeReplaceableCollection, it is a Queue, or<br>something else that we don&#39;t have.<br></p><p>&gt; Separate removal and insertion:<br>&gt;<br>&gt; Another case where RangeReplaceableCollectionType forces potentially<br>&gt; incompatible actions is that it requires both the ability to remove and to<br>&gt; insert arbitrarily into a collection. This is fine if the collection has no<br>&gt; form of sort order, however, if the collection is sorted, then insertion<br>&gt; operations actually make no sense, requiring the type to ignore the provided<br>&gt; indices and just position elements where it decides is best regardless.<br>&gt; Removals from a sorted collection don’t have this issue however (if you<br>&gt; remove a chunk from them then the remaining elements should still be in the<br>&gt; correct order).<br>&gt;<br>&gt;<br>&gt; Essentially this is a bunch of issues I ran into while attempting to<br>&gt; implement an ordered collection with as many of the same capabilities of an<br>&gt; Array as possible; while I realise that separation will result in two new<br>&gt; CollectionType protocols, I think that it could be beneficial for<br>&gt; flexibility when defining our own custom types.<br></p><p>Could you provide more information about the semantics of your<br>collection, and supported operations?<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Changes to RangeReplaceableCollectionType</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>February 29, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On 29 Feb 2016, at 10:17, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Sun, Feb 28, 2016 at 9:47 AM, Haravikk via swift-evolution<br>&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; So today I’ve been trying to put together an implementation of an ordered<br>&gt;&gt; collection, and I noticed that a lot of important mutating methods are<br>&gt;&gt; actually grouped together under RangeReplaceableCollectionType, which is<br>&gt;&gt; actually kind of weird, and has led me to create some more specialised<br>&gt;&gt; protocols of my own as I actually can’t implement<br>&gt;&gt; RangeReplaceableCollectionType as it for a number of reasons, which I’ll<br>&gt;&gt; discuss here:<br>&gt;&gt; <br>&gt;&gt; Remove initialisers<br>&gt;&gt; <br>&gt;&gt; I’m not actually sure why RangeReplaceableCollectionType has required<br>&gt;&gt; initialisers, since it shouldn’t really matter how you create it since you<br>&gt;&gt; can reserve capacity separately if you have to, prior to dumping elements<br>&gt;&gt; into it. However, having these initialiser requirements actually makes it<br>&gt;&gt; impossible to conform to this protocol if you require other data in order to<br>&gt;&gt; initialise your type.<br>&gt; <br>&gt; If your type absolutely requires non-zero data elements for an<br>&gt; instance to exist, how would it implement removeAll()?<br></p><p>I’m not sure if I’m misunderstanding you, or you’ve misunderstood me, but I’m not talking about requiring one or more elements, I’m talking about requiring other data. For example:<br></p><p>	struct SortedType&lt;Element&gt; {<br>		init(isOrderedBefore:(Element, Element) -&gt; Bool, initialElements:Element…) { … }<br>	}<br></p><p>i.e- it can have zero elements, that’s not the issue, but my initialiser *must* have an isOrderedBefore closure in order to be able to sort elements of arbitrary type, which I can’t do if I’m requiring to include an initialiser with no arguments at all.<br></p><p>Unless your meaning is that I should implement removeAll() by returning SortedType(), but I don’t believe that that should be a necessary requirement as it’s a bit of a fudge as a default means of implementing keepCapacity false; for example, if I were using an unsafe pointer then I could just discard the allocated memory and open a new pointer into a new, default-size, memory chunk. Plus keepCapacity is actually non-binding (I don’t actually have to respect it).<br></p><p>&gt; For example, my type requires a closure, and I can’t provide a default<br>&gt;&gt; <br>&gt;&gt; closure (since the whole point of it is so I can support elements of any<br>&gt;&gt; type). I can’t think of any reason why these initialiser requirements should<br>&gt;&gt; be necessary, so hopefully they can just be removed.<br>&gt; <br>&gt; Could you provide more information about your type?  If the closure is<br>&gt; a crucial part of the value, how do you implement collection equality?<br></p><p>I haven’t done that yet, but testing that the elements are the same should still satisfy it, as they’ll either be sorted into the same order or not. If the collection has one or less elements then I guess it’s not as clear what should be done, but I’d say that at that point the two collections are still equal, regardless of their sort order, i.e- they can’t become unequal until some sorting has occurred.<br></p><p>&gt; Separate out the append(), appendContentsOf() and reserveCapacity() methods:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; These methods don’t seem to me to be specific to<br>&gt;&gt; RangeReplaceableCollectionType, and it seems like they should be separated<br>&gt;&gt; into an AppendableCollectionType or ExpandableCollectionType or similar.<br>&gt;&gt; While .replaceRange() could technically be used to fulfil .append() and<br>&gt;&gt; .appendContentsOf(), it’s not actually replacing anything so it isn’t<br>&gt;&gt; directly related IMO.<br>&gt; <br>&gt; We had ExtensibleCollection before, but we dropped it.  The rationale<br>&gt; is that if you can create an empty collection, and can append, then<br>&gt; you can implement replaceRange() with just that.  Thus,<br>&gt; ExtensibleCollection and RangeReplaceableCollection are the same type.<br></p><p>I suppose I didn’t consider that append() implies that the element is always added to the end though, I suppose another add() method that makes no assumptions about where the element ends up would make more sense.<br></p><p>&gt;&gt; Indeed, it’s conceivable that a type might want to declare the ability to<br>&gt;&gt; append elements separately from declaring means of removing them arbitrarily<br>&gt;&gt; (which is what RangeReplaceableCollectionType does), as they may want<br>&gt;&gt; stricter requirements on removal; for example a queue where elements can<br>&gt;&gt; only be removed via a removeHead() method or similar.<br>&gt; <br>&gt; Then your type is not a RangeReplaceableCollection, it is a Queue, or<br>&gt; something else that we don&#39;t have.<br></p><p>But a RangeReplaceCollection could be used to satisfy its requirements, which is why it seems like at least some part of the protocol should be able to be implemented separately, i.e- it seems like I should be able to implement a pure queue and have it be interchangeable with an Array, but there is currently no protocol that supports this, even though adding and consuming elements of a collection are a fairly common concept that doesn’t necessarily need to be tied together with insertion as well.<br></p><p>&gt;&gt; Separate removal and insertion:<br>&gt;&gt; <br>&gt;&gt; Another case where RangeReplaceableCollectionType forces potentially<br>&gt;&gt; incompatible actions is that it requires both the ability to remove and to<br>&gt;&gt; insert arbitrarily into a collection. This is fine if the collection has no<br>&gt;&gt; form of sort order, however, if the collection is sorted, then insertion<br>&gt;&gt; operations actually make no sense, requiring the type to ignore the provided<br>&gt;&gt; indices and just position elements where it decides is best regardless.<br>&gt;&gt; Removals from a sorted collection don’t have this issue however (if you<br>&gt;&gt; remove a chunk from them then the remaining elements should still be in the<br>&gt;&gt; correct order).<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Essentially this is a bunch of issues I ran into while attempting to<br>&gt;&gt; implement an ordered collection with as many of the same capabilities of an<br>&gt;&gt; Array as possible; while I realise that separation will result in two new<br>&gt;&gt; CollectionType protocols, I think that it could be beneficial for<br>&gt;&gt; flexibility when defining our own custom types.<br>&gt; <br>&gt; Could you provide more information about the semantics of your<br>&gt; collection, and supported operations?<br></p><p>At its most basic its a fully conforming CollectionType that requires as an isOrderedBefore closure to sort elements, and can have new elements added to it. Effectively in addition to the CollectionType requires it only really needs an add() operation, but at the same time methods like reserveCapacity(), removeFirst(), removeRange() and removeLast() also make sense, but are currently limited to RangeReplaceableCollectionType.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160229/adb83240/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Changes to RangeReplaceableCollectionType</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>February 29, 2016 at 03:00:00am</p></header><div class="content"><p>On Mon, Feb 29, 2016 at 2:54 AM, Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br>&gt;<br>&gt; On 29 Feb 2016, at 10:17, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Sun, Feb 28, 2016 at 9:47 AM, Haravikk via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; So today I’ve been trying to put together an implementation of an ordered<br>&gt; collection, and I noticed that a lot of important mutating methods are<br>&gt; actually grouped together under RangeReplaceableCollectionType, which is<br>&gt; actually kind of weird, and has led me to create some more specialised<br>&gt; protocols of my own as I actually can’t implement<br>&gt; RangeReplaceableCollectionType as it for a number of reasons, which I’ll<br>&gt; discuss here:<br>&gt;<br>&gt; Remove initialisers<br>&gt;<br>&gt; I’m not actually sure why RangeReplaceableCollectionType has required<br>&gt; initialisers, since it shouldn’t really matter how you create it since you<br>&gt; can reserve capacity separately if you have to, prior to dumping elements<br>&gt; into it. However, having these initialiser requirements actually makes it<br>&gt; impossible to conform to this protocol if you require other data in order to<br>&gt; initialise your type.<br>&gt;<br>&gt;<br>&gt; If your type absolutely requires non-zero data elements for an<br>&gt; instance to exist, how would it implement removeAll()?<br>&gt;<br>&gt;<br>&gt; I’m not sure if I’m misunderstanding you, or you’ve misunderstood me, but<br>&gt; I’m not talking about requiring one or more elements, I’m talking about<br>&gt; requiring other data. For example:<br>&gt;<br>&gt; struct SortedType&lt;Element&gt; {<br>&gt; init(isOrderedBefore:(Element, Element) -&gt; Bool, initialElements:Element…) {<br>&gt; … }<br>&gt; }<br>&gt;<br>&gt; i.e- it can have zero elements, that’s not the issue, but my initialiser<br>&gt; *must* have an isOrderedBefore closure in order to be able to sort elements<br>&gt; of arbitrary type, which I can’t do if I’m requiring to include an<br>&gt; initialiser with no arguments at all.<br></p><p>Understood.<br></p><p>&gt; Could you provide more information about your type?  If the closure is<br>&gt; a crucial part of the value, how do you implement collection equality?<br>&gt;<br>&gt;<br>&gt; I haven’t done that yet, but testing that the elements are the same should<br>&gt; still satisfy it, as they’ll either be sorted into the same order or not. If<br>&gt; the collection has one or less elements then I guess it’s not as clear what<br>&gt; should be done, but I’d say that at that point the two collections are still<br>&gt; equal, regardless of their sort order, i.e- they can’t become unequal until<br>&gt; some sorting has occurred.<br></p><p>How would you decide equality?  You would have two collections, one on<br>the left, and one on the right, and each of those has a different<br>concept of equality via the stored &#39;isOrderedBefore&#39; closure.<br></p><p>&gt; Separate out the append(), appendContentsOf() and reserveCapacity() methods:<br>&gt;<br>&gt;<br>&gt; These methods don’t seem to me to be specific to<br>&gt; RangeReplaceableCollectionType, and it seems like they should be separated<br>&gt; into an AppendableCollectionType or ExpandableCollectionType or similar.<br>&gt; While .replaceRange() could technically be used to fulfil .append() and<br>&gt; .appendContentsOf(), it’s not actually replacing anything so it isn’t<br>&gt; directly related IMO.<br>&gt;<br>&gt;<br>&gt; We had ExtensibleCollection before, but we dropped it.  The rationale<br>&gt; is that if you can create an empty collection, and can append, then<br>&gt; you can implement replaceRange() with just that.  Thus,<br>&gt; ExtensibleCollection and RangeReplaceableCollection are the same type.<br>&gt;<br>&gt;<br>&gt; I suppose I didn’t consider that append() implies that the element is always<br>&gt; added to the end though, I suppose another add() method that makes no<br>&gt; assumptions about where the element ends up would make more sense.<br></p><p>Well, it is a different method then, with different semantics, and<br>different guarantees :)<br></p><p>&gt; Indeed, it’s conceivable that a type might want to declare the ability to<br>&gt; append elements separately from declaring means of removing them arbitrarily<br>&gt; (which is what RangeReplaceableCollectionType does), as they may want<br>&gt; stricter requirements on removal; for example a queue where elements can<br>&gt; only be removed via a removeHead() method or similar.<br>&gt;<br>&gt;<br>&gt; Then your type is not a RangeReplaceableCollection, it is a Queue, or<br>&gt; something else that we don&#39;t have.<br>&gt;<br>&gt;<br>&gt; But a RangeReplaceCollection could be used to satisfy its requirements,<br></p><p>Why?  Protocols are not just bags of syntax, they represent classes of<br>entities with semantics.<br></p><p>&gt; which is why it seems like at least some part of the protocol should be able<br>&gt; to be implemented separately, i.e- it seems like I should be able to<br>&gt; implement a pure queue and have it be interchangeable with an Array, but<br>&gt; there is currently no protocol that supports this, even though adding and<br>&gt; consuming elements of a collection are a fairly common concept that doesn’t<br>&gt; necessarily need to be tied together with insertion as well.<br></p><p>I&#39;m not opposed to adding a new protocol.  What seems strange to me is<br>that you are describing various collections that clearly can&#39;t<br>implement RangeReplaceableCollection, and trying to weaken protocol&#39;s<br>guarantees so that they can.<br></p><p>&gt; Separate removal and insertion:<br>&gt;<br>&gt; Another case where RangeReplaceableCollectionType forces potentially<br>&gt; incompatible actions is that it requires both the ability to remove and to<br>&gt; insert arbitrarily into a collection. This is fine if the collection has no<br>&gt; form of sort order, however, if the collection is sorted, then insertion<br>&gt; operations actually make no sense, requiring the type to ignore the provided<br>&gt; indices and just position elements where it decides is best regardless.<br>&gt; Removals from a sorted collection don’t have this issue however (if you<br>&gt; remove a chunk from them then the remaining elements should still be in the<br>&gt; correct order).<br>&gt;<br>&gt;<br>&gt; Essentially this is a bunch of issues I ran into while attempting to<br>&gt; implement an ordered collection with as many of the same capabilities of an<br>&gt; Array as possible; while I realise that separation will result in two new<br>&gt; CollectionType protocols, I think that it could be beneficial for<br>&gt; flexibility when defining our own custom types.<br>&gt;<br>&gt;<br>&gt; Could you provide more information about the semantics of your<br>&gt; collection, and supported operations?<br>&gt;<br>&gt;<br>&gt; At its most basic its a fully conforming CollectionType that requires as an<br>&gt; isOrderedBefore closure to sort elements, and can have new elements added to<br>&gt; it. Effectively in addition to the CollectionType requires it only really<br>&gt; needs an add() operation, but at the same time methods like<br>&gt; reserveCapacity(), removeFirst(), removeRange() and removeLast() also make<br>&gt; sense, but are currently limited to RangeReplaceableCollectionType.<br></p><p>These methods are not &quot;limited&quot; to RangeReplaceableCollectionType.  We<br>can define a different protocol that suits your collection, we just<br>need to figure out what your collection does, and what does it<br>generalize to, what other (non-Array-based) implementations are<br>possible etc.<br></p><p>What you&#39;re describing seems like a priority queue, which is typically<br>implemented using heaps, which don&#39;t maintain all elements sorted.  If<br>you want to always maintain sorted order, you could use an array, or<br>better, a tree.<br></p><p>We need to figure out which basic operations make sense on such data<br>structures, what are their semantics and performance guarantees, and<br>then, what generic algorithms would make sense.  (If we can&#39;t find a<br>useful generic algorithm that operates through a protocol, then the<br>protocol is not useful.)<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Changes to RangeReplaceableCollectionType</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>February 29, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On 29 Feb 2016, at 11:11, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Mon, Feb 29, 2016 at 2:54 AM, Haravikk &lt;swift-evolution at haravikk.me &lt;mailto:swift-evolution at haravikk.me&gt;&gt; wrote:<br>&gt; <br>&gt; How would you decide equality?  You would have two collections, one on<br>&gt; the left, and one on the right, and each of those has a different<br>&gt; concept of equality via the stored &#39;isOrderedBefore&#39; closure.<br></p><p>To me two collections are equal so long as their contents are the same, and in the same order. In other words the actual closure isn’t necessary to the comparison, though obviously it will affect it, since elements stored in ascending numeric order clearly won’t match the same elements in descending numeric order.<br></p><p>&gt; I&#39;m not opposed to adding a new protocol.  What seems strange to me is<br>&gt; that you are describing various collections that clearly can&#39;t<br>&gt; implement RangeReplaceableCollection, and trying to weaken protocol&#39;s<br>&gt; guarantees so that they can.<br></p><p>I’m not trying to weaken its guarantees; the only thing directly affecting RangeReplaceableCollectionType would be removing the initialisers, as I don’t think they’re necessary to implementing that type (though of course I welcome any description as to why they may be necessary).<br></p><p>Otherwise a new protocol is exactly what I’m interested in; you mentioned an ExpandableCollectionType, which I think is a start, though it should probably have add() and addContentsOf() methods rather than appends (this way they place no guarantees on where elements will go, only that they are added). While the add() method would be a synonym of append() for arrays, it would be useful for aligning with Set I think.<br></p><p>Moving the removeRange() and related methods (removeAtIndex etc.) would take them away from RangeReplaceableCollectionType (it should extend whatever new protocol is added), but the idea is to separate the concept of removing things by index, and replacing them/performing insertions.<br></p><p>Basically I’d like to tweak the protocols such that a generic collection can be expanded, and its elements accessed in an order, but that order may be defined by the type itself; to me, inserting a value directly at a specific index is a more specialist type.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160229/ae3d4838/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Changes to RangeReplaceableCollectionType</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>February 29, 2016 at 01:00:00pm</p></header><div class="content"><p>On Mon, Feb 29, 2016 at 1:13 PM, Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br>&gt;<br>&gt; On 29 Feb 2016, at 11:11, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Mon, Feb 29, 2016 at 2:54 AM, Haravikk &lt;swift-evolution at haravikk.me&gt;<br>&gt; wrote:<br>&gt;<br>&gt; How would you decide equality?  You would have two collections, one on<br>&gt; the left, and one on the right, and each of those has a different<br>&gt; concept of equality via the stored &#39;isOrderedBefore&#39; closure.<br>&gt;<br>&gt;<br>&gt; To me two collections are equal so long as their contents are the same, and<br>&gt; in the same order. In other words the actual closure isn’t necessary to the<br>&gt; comparison, though obviously it will affect it, since elements stored in<br>&gt; ascending numeric order clearly won’t match the same elements in descending<br>&gt; numeric order.<br>&gt;<br>&gt; I&#39;m not opposed to adding a new protocol.  What seems strange to me is<br>&gt; that you are describing various collections that clearly can&#39;t<br>&gt; implement RangeReplaceableCollection, and trying to weaken protocol&#39;s<br>&gt; guarantees so that they can.<br>&gt;<br>&gt;<br>&gt; I’m not trying to weaken its guarantees; the only thing directly affecting<br>&gt; RangeReplaceableCollectionType would be removing the initialisers, as I<br>&gt; don’t think they’re necessary to implementing that type (though of course I<br>&gt; welcome any description as to why they may be necessary).<br>&gt;<br>&gt; Otherwise a new protocol is exactly what I’m interested in; you mentioned an<br>&gt; ExpandableCollectionType, which I think is a start, though it should<br>&gt; probably have add() and addContentsOf()<br></p><p>Set calls this operation &#39;insert&#39;.<br></p><p>&gt; methods rather than appends (this<br>&gt; way they place no guarantees on where elements will go, only that they are<br>&gt; added). While the add() method would be a synonym of append() for arrays, it<br>&gt; would be useful for aligning with Set I think.<br>&gt;<br>&gt; Moving the removeRange() and related methods (removeAtIndex etc.) would take<br>&gt; them away from RangeReplaceableCollectionType (it should extend whatever new<br>&gt; protocol is added), but the idea is to separate the concept of removing<br>&gt; things by index, and replacing them/performing insertions.<br>&gt;<br>&gt; Basically I’d like to tweak the protocols such that a generic collection can<br>&gt; be expanded, and its elements accessed in an order, but that order may be<br>&gt; defined by the type itself; to me, inserting a value directly at a specific<br>&gt; index is a more specialist type.<br></p><p>Sound like a plan.  Please make sure to design the protocol in such a<br>way that there are useful generic algorithms that can be written over<br>such a protocol.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Changes to RangeReplaceableCollectionType</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>March  3, 2016 at 08:00:00pm</p></header><div class="content"><p>Okay so I’ve been tweaking the protocols that I’m using. For my own use I’ve ended up with two protocols:<br></p><p>ExtendableCollectionType: Which implements .insert() and .insertContentsOf() methods, as well as a non-binding concept of capacity.<br>RangeRemoveableCollectionType: Which implements most basic removal methods that don’t involve replacing anything (i.e- they don’t include insertions at specific indices). This is therefore safe for self-ordering collections as while insertion can’t support an index (can’t guarantee item will end up where it’s placed), removing them should have no such restrictions that I can see.<br></p><p>This effectively leaves RangeReplaceCollectionType with index based insertions, append (insert at end) and range replacement methods. Other proposed changes include removing the initialisers (since these restrict implementations), and possibly changing the .replaceRange() method to accept a sequence rather than a collection as I don’t believe a collection should be required?<br></p><p>Here’s a quick, simplified, example of how everything would look:<br></p><p>// Extension of a collection by adding new contents<br>protocol ExtendableCollectionType : CollectionType {<br>    var capacity:Index.Distance { get }<br></p><p>    mutating func insert(element:Self.Generator.Element)<br>    mutating func insertContentsOf&lt;S:SequenceType where S.Generator.Element == Self.Generator.Element&gt;(elements:S)<br></p><p>    mutating func reserveCapacity(minimumCapacity:Bool)<br>}<br></p><p>extension ExtendableCollectionType {<br>    var capacity:Index.Distance { return self.count }<br>    mutating func insertContentsOf&lt;S:SequenceType where S.Generator.Element == Self.Generator.Element&gt;(elements:S) {<br>        for element in elements { self.insert(element) }<br>    }<br>}<br></p><p>extension ExtendableCollectionType where Self:RangeReplaceableCollectionType {<br>    mutating func insert(element:Self.Generator.Element) { self.append(element) }<br>    mutating func insertContentsOf&lt;S:SequenceType where S.Generator.Element == Self.Generator.Element&gt;(elements:S) { self.appendContentsOf(elements) }<br>}<br></p><p>// Removal of specific indices<br>protocol RangeRemoveableCollectionType : ExtendableCollectionType {<br>    mutating func removeAll(keepCapacity keepCapacity:Bool)<br>    mutating func removeAtIndex(index:Index) -&gt; Self.Generator.Element<br>    mutating func removeRange(subRange:Range&lt;Index&gt;)<br>}<br></p><p>extension RangeRemoveableCollectionType {<br>    mutating func removeAll(keepCapacity keepCapacity:Bool) { self.removeRange(self.startIndex ..&lt; self.endIndex) }<br>    mutating func removeFirst() -&gt; Self.Generator.Element? { … }<br>    mutating func removeFirst(n:Index.Distance) { self.removeRange(self.startIndex ..&lt; self.startIndex.advancedBy(n)) }<br>}<br></p><p>extension RangeRemoveableCollectionType where Self.Index:BidirectionalIndexType {<br>    mutating func removeLast() -&gt; Self.Generator.Element? { … }<br>    mutating func removeLast(n:Index.Distance) { self.removeRange(self.endIndex.advancedBy(-n) ..&lt; self.endIndex) }<br>}<br></p><p>// Insertion/replacement at specific indices<br>protocol RangeReplaceableCollectionType : RangeRemoveableCollectionType {<br>    mutating func append(element:Self.Generator.Element)<br>    mutating func appendContentsOf&lt;S:SequenceType where S.Generator.Element == Self.Generator.Element&gt;(elements:S)<br>    mutating func insert(element:Self.Generator.Element, atIndex:Index)<br>    mutating func insertContentsOf&lt;S:SequenceType where S.Generator.Element == Self.Generator.Element&gt;(elements:S, atIndex:Index)<br>    mutating func replaceRange&lt;S:SequenceType where S.Generator.Element == Self.Generator.Element&gt;(subRange:Range&lt;Index&gt;, with elements:S)<br>}<br></p><p>This is just to give an idea, there may be some accidental omissions and some stuff is simplified or omitted on purpose, but it hopefully shows the separation and structure that I’m aiming for.<br></p><p>I was originally going to put all of the RangeRemovableCollectionType methods into ExtendableCollectionType, however that would mean tying the ability to add and to remove together, which may still be limiting; a collection could for example be designed to be consumed internally, or even to just expire its own contents (e.g- a cache type) so may not wish to externally expose methods that would remove elements.<br></p><p>Also, naming is absolutely up for debate too, all feedback appreciated!<br></p><p>P.S- I know that naming conventions are currently up for debate, so I’m just sticking with the way things are right now for simplicity, obviously everything would be tweaked to match whatever decision is made for whichever version this ends up in =)<br></p><p>&gt; On 29 Feb 2016, at 21:16, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Mon, Feb 29, 2016 at 1:13 PM, Haravikk &lt;swift-evolution at haravikk.me &lt;mailto:swift-evolution at haravikk.me&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On 29 Feb 2016, at 11:11, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Mon, Feb 29, 2016 at 2:54 AM, Haravikk &lt;swift-evolution at haravikk.me&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; How would you decide equality?  You would have two collections, one on<br>&gt;&gt; the left, and one on the right, and each of those has a different<br>&gt;&gt; concept of equality via the stored &#39;isOrderedBefore&#39; closure.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; To me two collections are equal so long as their contents are the same, and<br>&gt;&gt; in the same order. In other words the actual closure isn’t necessary to the<br>&gt;&gt; comparison, though obviously it will affect it, since elements stored in<br>&gt;&gt; ascending numeric order clearly won’t match the same elements in descending<br>&gt;&gt; numeric order.<br>&gt;&gt; <br>&gt;&gt; I&#39;m not opposed to adding a new protocol.  What seems strange to me is<br>&gt;&gt; that you are describing various collections that clearly can&#39;t<br>&gt;&gt; implement RangeReplaceableCollection, and trying to weaken protocol&#39;s<br>&gt;&gt; guarantees so that they can.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I’m not trying to weaken its guarantees; the only thing directly affecting<br>&gt;&gt; RangeReplaceableCollectionType would be removing the initialisers, as I<br>&gt;&gt; don’t think they’re necessary to implementing that type (though of course I<br>&gt;&gt; welcome any description as to why they may be necessary).<br>&gt;&gt; <br>&gt;&gt; Otherwise a new protocol is exactly what I’m interested in; you mentioned an<br>&gt;&gt; ExpandableCollectionType, which I think is a start, though it should<br>&gt;&gt; probably have add() and addContentsOf()<br>&gt; <br>&gt; Set calls this operation &#39;insert&#39;.<br>&gt; <br>&gt;&gt; methods rather than appends (this<br>&gt;&gt; way they place no guarantees on where elements will go, only that they are<br>&gt;&gt; added). While the add() method would be a synonym of append() for arrays, it<br>&gt;&gt; would be useful for aligning with Set I think.<br>&gt;&gt; <br>&gt;&gt; Moving the removeRange() and related methods (removeAtIndex etc.) would take<br>&gt;&gt; them away from RangeReplaceableCollectionType (it should extend whatever new<br>&gt;&gt; protocol is added), but the idea is to separate the concept of removing<br>&gt;&gt; things by index, and replacing them/performing insertions.<br>&gt;&gt; <br>&gt;&gt; Basically I’d like to tweak the protocols such that a generic collection can<br>&gt;&gt; be expanded, and its elements accessed in an order, but that order may be<br>&gt;&gt; defined by the type itself; to me, inserting a value directly at a specific<br>&gt;&gt; index is a more specialist type.<br>&gt; <br>&gt; Sound like a plan.  Please make sure to design the protocol in such a<br>&gt; way that there are useful generic algorithms that can be written over<br>&gt; such a protocol.<br>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt;*/<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160303/e6d19fa2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Changes to RangeReplaceableCollectionType</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>March  3, 2016 at 12:00:00pm</p></header><div class="content"><p>On Thu, Mar 3, 2016 at 12:29 PM, Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br>&gt; Okay so I’ve been tweaking the protocols that I’m using. For my own use I’ve<br>&gt; ended up with two protocols:<br>&gt;<br>&gt; ExtendableCollectionType: Which implements .insert() and .insertContentsOf()<br>&gt; methods, as well as a non-binding concept of capacity.<br></p><p>Hi,<br></p><p>Thank you for preparing these APIs.  Could you explain what the<br>semantics of these new APIs are (in doc comments, for example), and<br>provide examples of generic algorithms that work on any collection<br>that implements the desired semantics in the minimal way?<br></p><p>Dmitri<br></p><p>&gt; RangeRemoveableCollectionType: Which implements most basic removal methods<br>&gt; that don’t involve replacing anything (i.e- they don’t include insertions at<br>&gt; specific indices). This is therefore safe for self-ordering collections as<br>&gt; while insertion can’t support an index (can’t guarantee item will end up<br>&gt; where it’s placed), removing them should have no such restrictions that I<br>&gt; can see.<br>&gt;<br>&gt;<br>&gt; This effectively leaves RangeReplaceCollectionType with index based<br>&gt; insertions, append (insert at end) and range replacement methods. Other<br>&gt; proposed changes include removing the initialisers (since these restrict<br>&gt; implementations), and possibly changing the .replaceRange() method to accept<br>&gt; a sequence rather than a collection as I don’t believe a collection should<br>&gt; be required?<br>&gt;<br>&gt; Here’s a quick, simplified, example of how everything would look:<br>&gt;<br>&gt; // Extension of a collection by adding new contents<br>&gt; protocol ExtendableCollectionType : CollectionType {<br>&gt;     var capacity:Index.Distance { get }<br>&gt;<br>&gt;     mutating func insert(element:Self.Generator.Element)<br>&gt;     mutating func insertContentsOf&lt;S:SequenceType where S.Generator.Element<br>&gt; == Self.Generator.Element&gt;(elements:S)<br>&gt;<br>&gt;     mutating func reserveCapacity(minimumCapacity:Bool)<br>&gt; }<br>&gt;<br>&gt; extension ExtendableCollectionType {<br>&gt;     var capacity:Index.Distance { return self.count }<br>&gt;     mutating func insertContentsOf&lt;S:SequenceType where S.Generator.Element<br>&gt; == Self.Generator.Element&gt;(elements:S) {<br>&gt;         for element in elements { self.insert(element) }<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; extension ExtendableCollectionType where Self:RangeReplaceableCollectionType<br>&gt; {<br>&gt;     mutating func insert(element:Self.Generator.Element) {<br>&gt; self.append(element) }<br>&gt;     mutating func insertContentsOf&lt;S:SequenceType where S.Generator.Element<br>&gt; == Self.Generator.Element&gt;(elements:S) { self.appendContentsOf(elements) }<br>&gt; }<br>&gt;<br>&gt; // Removal of specific indices<br>&gt; protocol RangeRemoveableCollectionType : ExtendableCollectionType {<br>&gt;     mutating func removeAll(keepCapacity keepCapacity:Bool)<br>&gt;     mutating func removeAtIndex(index:Index) -&gt; Self.Generator.Element<br>&gt;     mutating func removeRange(subRange:Range&lt;Index&gt;)<br>&gt; }<br>&gt;<br>&gt; extension RangeRemoveableCollectionType {<br>&gt;     mutating func removeAll(keepCapacity keepCapacity:Bool) {<br>&gt; self.removeRange(self.startIndex ..&lt; self.endIndex) }<br>&gt;     mutating func removeFirst() -&gt; Self.Generator.Element? { … }<br>&gt;     mutating func removeFirst(n:Index.Distance) {<br>&gt; self.removeRange(self.startIndex ..&lt; self.startIndex.advancedBy(n)) }<br>&gt; }<br>&gt;<br>&gt; extension RangeRemoveableCollectionType where<br>&gt; Self.Index:BidirectionalIndexType {<br>&gt;     mutating func removeLast() -&gt; Self.Generator.Element? { … }<br>&gt;     mutating func removeLast(n:Index.Distance) {<br>&gt; self.removeRange(self.endIndex.advancedBy(-n) ..&lt; self.endIndex) }<br>&gt; }<br>&gt;<br>&gt; // Insertion/replacement at specific indices<br>&gt; protocol RangeReplaceableCollectionType : RangeRemoveableCollectionType {<br>&gt;     mutating func append(element:Self.Generator.Element)<br>&gt;     mutating func appendContentsOf&lt;S:SequenceType where S.Generator.Element<br>&gt; == Self.Generator.Element&gt;(elements:S)<br>&gt;     mutating func insert(element:Self.Generator.Element, atIndex:Index)<br>&gt;     mutating func insertContentsOf&lt;S:SequenceType where S.Generator.Element<br>&gt; == Self.Generator.Element&gt;(elements:S, atIndex:Index)<br>&gt;     mutating func replaceRange&lt;S:SequenceType where S.Generator.Element ==<br>&gt; Self.Generator.Element&gt;(subRange:Range&lt;Index&gt;, with elements:S)<br>&gt; }<br>&gt;<br>&gt; This is just to give an idea, there may be some accidental omissions and<br>&gt; some stuff is simplified or omitted on purpose, but it hopefully shows the<br>&gt; separation and structure that I’m aiming for.<br>&gt;<br>&gt; I was originally going to put all of the RangeRemovableCollectionType<br>&gt; methods into ExtendableCollectionType, however that would mean tying the<br>&gt; ability to add and to remove together, which may still be limiting; a<br>&gt; collection could for example be designed to be consumed internally, or even<br>&gt; to just expire its own contents (e.g- a cache type) so may not wish to<br>&gt; externally expose methods that would remove elements.<br>&gt;<br>&gt; Also, naming is absolutely up for debate too, all feedback appreciated!<br>&gt;<br>&gt; P.S- I know that naming conventions are currently up for debate, so I’m just<br>&gt; sticking with the way things are right now for simplicity, obviously<br>&gt; everything would be tweaked to match whatever decision is made for whichever<br>&gt; version this ends up in =)<br>&gt;<br>&gt; On 29 Feb 2016, at 21:16, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Mon, Feb 29, 2016 at 1:13 PM, Haravikk &lt;swift-evolution at haravikk.me&gt;<br>&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On 29 Feb 2016, at 11:11, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Mon, Feb 29, 2016 at 2:54 AM, Haravikk &lt;swift-evolution at haravikk.me&gt;<br>&gt; wrote:<br>&gt;<br>&gt; How would you decide equality?  You would have two collections, one on<br>&gt; the left, and one on the right, and each of those has a different<br>&gt; concept of equality via the stored &#39;isOrderedBefore&#39; closure.<br>&gt;<br>&gt;<br>&gt; To me two collections are equal so long as their contents are the same, and<br>&gt; in the same order. In other words the actual closure isn’t necessary to the<br>&gt; comparison, though obviously it will affect it, since elements stored in<br>&gt; ascending numeric order clearly won’t match the same elements in descending<br>&gt; numeric order.<br>&gt;<br>&gt; I&#39;m not opposed to adding a new protocol.  What seems strange to me is<br>&gt; that you are describing various collections that clearly can&#39;t<br>&gt; implement RangeReplaceableCollection, and trying to weaken protocol&#39;s<br>&gt; guarantees so that they can.<br>&gt;<br>&gt;<br>&gt; I’m not trying to weaken its guarantees; the only thing directly affecting<br>&gt; RangeReplaceableCollectionType would be removing the initialisers, as I<br>&gt; don’t think they’re necessary to implementing that type (though of course I<br>&gt; welcome any description as to why they may be necessary).<br>&gt;<br>&gt; Otherwise a new protocol is exactly what I’m interested in; you mentioned an<br>&gt; ExpandableCollectionType, which I think is a start, though it should<br>&gt; probably have add() and addContentsOf()<br>&gt;<br>&gt;<br>&gt; Set calls this operation &#39;insert&#39;.<br>&gt;<br>&gt; methods rather than appends (this<br>&gt; way they place no guarantees on where elements will go, only that they are<br>&gt; added). While the add() method would be a synonym of append() for arrays, it<br>&gt; would be useful for aligning with Set I think.<br>&gt;<br>&gt; Moving the removeRange() and related methods (removeAtIndex etc.) would take<br>&gt; them away from RangeReplaceableCollectionType (it should extend whatever new<br>&gt; protocol is added), but the idea is to separate the concept of removing<br>&gt; things by index, and replacing them/performing insertions.<br>&gt;<br>&gt; Basically I’d like to tweak the protocols such that a generic collection can<br>&gt; be expanded, and its elements accessed in an order, but that order may be<br>&gt; defined by the type itself; to me, inserting a value directly at a specific<br>&gt; index is a more specialist type.<br>&gt;<br>&gt;<br>&gt; Sound like a plan.  Please make sure to design the protocol in such a<br>&gt; way that there are useful generic algorithms that can be written over<br>&gt; such a protocol.<br>&gt;<br>&gt; Dmitri<br>&gt;<br>&gt; --<br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;<br>&gt;<br></p><p><br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
