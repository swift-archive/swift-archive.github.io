<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c031541ed3d92869414857dfef853de?s=50"></div><header><strong>Enable omitting `let` for constant declarations</strong> from <string>Yuta Koshizawa</string> &lt;koher at koherent.org&gt;<p>April  1, 2016 at 08:00:00pm</p></header><div class="content"><p>I think it would be good if the following three declarations were equivalent<br></p><p>let a: Int = 42<br>a: Int = 42<br>a := 42<br></p><p>and also the following two were.<br></p><p>let a: Int<br>a: Int<br></p><p>Then constant declarations become shorter than variable declarations.<br>It encourages people to use constants in preference to variables.<br></p><p>It also prevents repeating `let` for property declarations and makes<br>type declarations simpler.<br></p><p>struct Person {<br>    firstName: String<br>    lastName: String<br>    age: Int<br>}<br></p><p>Omitting `let` is consistent with that we don&#39;t write `let` for<br>arguments of functions and iterated values in for-in loops.<br></p><p>Not `=` but `:=` for type inferences because `=` cannot distinguish<br>whether it means a constant declaration or an assignment to a variable<br>declared in an outer scope. I think `:=` is a natural notation for<br>type inferences because omitting the type from `a: Int = 42` makes<br>`a:= 42`. Because I have not strictly checked if it can be parsed in<br>Swift properly, it may have some other parsing issues.<br></p><p>What do you think about it?<br></p><p>-- Yuta<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/aeab22e60ba7b7e2bd445775850448d1?s=50"></div><header><strong>Enable omitting `let` for constant declarations</strong> from <string>Radosław Pietruszewski</string> &lt;radexpl at gmail.com&gt;<p>April  1, 2016 at 04:00:00pm</p></header><div class="content"><p>I can’t easily find it, but there’s been at least one thread proposing this exact thing, and there was very little interest in the proposal.<br></p><p>TL;DR is that Swift *by design* wants to make the difference between these three concepts:<br></p><p>- assignment<br>- declaration of a constant<br>- declaration of a mutable variable<br></p><p>as explicit and obvious as possible.<br></p><p>— Radek<br></p><p>&gt; On 01 Apr 2016, at 13:58, Yuta Koshizawa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think it would be good if the following three declarations were equivalent<br>&gt; <br>&gt; let a: Int = 42<br>&gt; a: Int = 42<br>&gt; a := 42<br>&gt; <br>&gt; and also the following two were.<br>&gt; <br>&gt; let a: Int<br>&gt; a: Int<br>&gt; <br>&gt; Then constant declarations become shorter than variable declarations.<br>&gt; It encourages people to use constants in preference to variables.<br>&gt; <br>&gt; It also prevents repeating `let` for property declarations and makes<br>&gt; type declarations simpler.<br>&gt; <br>&gt; struct Person {<br>&gt;    firstName: String<br>&gt;    lastName: String<br>&gt;    age: Int<br>&gt; }<br>&gt; <br>&gt; Omitting `let` is consistent with that we don&#39;t write `let` for<br>&gt; arguments of functions and iterated values in for-in loops.<br>&gt; <br>&gt; Not `=` but `:=` for type inferences because `=` cannot distinguish<br>&gt; whether it means a constant declaration or an assignment to a variable<br>&gt; declared in an outer scope. I think `:=` is a natural notation for<br>&gt; type inferences because omitting the type from `a: Int = 42` makes<br>&gt; `a:= 42`. Because I have not strictly checked if it can be parsed in<br>&gt; Swift properly, it may have some other parsing issues.<br>&gt; <br>&gt; What do you think about it?<br>&gt; <br>&gt; -- Yuta<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c031541ed3d92869414857dfef853de?s=50"></div><header><strong>Enable omitting `let` for constant declarations</strong> from <string>Yuta Koshizawa</string> &lt;koher at koherent.org&gt;<p>April  2, 2016 at 03:00:00am</p></header><div class="content"><p>Did you mean the thread &quot;Mutability inference&quot;? What I talked about is<br>different from it. I am against the idea of &quot;Mutability inference&quot;.<br></p><p>What I talked about is just enabling to omit `let` for constant<br>declarations. It distinguishes the following three explicitly.<br></p><p>&gt; - assignment<br>&gt; - declaration of a constant<br>&gt; - declaration of a mutable variable<br></p><p>`:=` makes it possible to distinguish assignments and constant declarations.<br></p><p>-- Yuta<br></p><p><br>2016-04-01 23:55 GMT+09:00 Radosław Pietruszewski &lt;radexpl at gmail.com&gt;:<br>&gt; I can’t easily find it, but there’s been at least one thread proposing this exact thing, and there was very little interest in the proposal.<br>&gt;<br>&gt; TL;DR is that Swift *by design* wants to make the difference between these three concepts:<br>&gt;<br>&gt; - assignment<br>&gt; - declaration of a constant<br>&gt; - declaration of a mutable variable<br>&gt;<br>&gt; as explicit and obvious as possible.<br>&gt;<br>&gt; — Radek<br>&gt;<br>&gt;&gt; On 01 Apr 2016, at 13:58, Yuta Koshizawa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I think it would be good if the following three declarations were equivalent<br>&gt;&gt;<br>&gt;&gt; let a: Int = 42<br>&gt;&gt; a: Int = 42<br>&gt;&gt; a := 42<br>&gt;&gt;<br>&gt;&gt; and also the following two were.<br>&gt;&gt;<br>&gt;&gt; let a: Int<br>&gt;&gt; a: Int<br>&gt;&gt;<br>&gt;&gt; Then constant declarations become shorter than variable declarations.<br>&gt;&gt; It encourages people to use constants in preference to variables.<br>&gt;&gt;<br>&gt;&gt; It also prevents repeating `let` for property declarations and makes<br>&gt;&gt; type declarations simpler.<br>&gt;&gt;<br>&gt;&gt; struct Person {<br>&gt;&gt;    firstName: String<br>&gt;&gt;    lastName: String<br>&gt;&gt;    age: Int<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Omitting `let` is consistent with that we don&#39;t write `let` for<br>&gt;&gt; arguments of functions and iterated values in for-in loops.<br>&gt;&gt;<br>&gt;&gt; Not `=` but `:=` for type inferences because `=` cannot distinguish<br>&gt;&gt; whether it means a constant declaration or an assignment to a variable<br>&gt;&gt; declared in an outer scope. I think `:=` is a natural notation for<br>&gt;&gt; type inferences because omitting the type from `a: Int = 42` makes<br>&gt;&gt; `a:= 42`. Because I have not strictly checked if it can be parsed in<br>&gt;&gt; Swift properly, it may have some other parsing issues.<br>&gt;&gt;<br>&gt;&gt; What do you think about it?<br>&gt;&gt;<br>&gt;&gt; -- Yuta<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
