<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d042be5dcfe90e649f760303af3e429?s=50"></div><header><strong>Can anyone please explain this behavior?</strong> from <string>Jens Persson</string> &lt;jens at bitcycle.com&gt;<p>September 21, 2016 at 11:00:00pm</p></header><div class="content"><p>// This little Swift program compiles (and runs) fine:<br></p><p>func foo() -&gt; Int { return a }<br>let a = 1<br>let b = 2<br>print(foo())<br></p><p>But if `foo()` returns `b` instead of `a`, I get this compile time error:<br>&quot;Use of unresolved identifier `b`&quot;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160921/aa148727/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc8eae356a7d359691154094ae6d56a7?s=50"></div><header><strong>Can anyone please explain this behavior?</strong> from <string>Marco S Hyman</string> &lt;marc at snafu.org&gt;<p>September 21, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Sep 21, 2016, at 2:22 PM, Jens Persson via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; // This little Swift program compiles (and runs) fine:<br>&gt; <br>&gt; func foo() -&gt; Int { return a }<br>&gt; let a = 1<br>&gt; let b = 2<br>&gt; print(foo())<br>&gt; <br>&gt; But if `foo()` returns `b` instead of `a`, I get this compile time error:<br>&gt; &quot;Use of unresolved identifier `b`”<br></p><p>Interesting.  Seems to have something to do with ordering as if you code it this way:<br></p><p>let a = 1<br>let b = 2<br>func foo() -&gt; Int { return b }<br>print(foo())<br></p><p>it works fine (Xcode 8 playground).<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/957b675456a66c394945a7361aedd51d?s=50"></div><header><strong>Can anyone please explain this behavior?</strong> from <string>Zhao Xin</string> &lt;owenzx at gmail.com&gt;<p>September 22, 2016 at 06:00:00am</p></header><div class="content"><p>I suggest you defining the variables before using them like Marco does.<br>Although from the global variable point of view, both way should be fine.<br>But the glitch does exist, especially in playground.<br></p><p>Zhaoxin<br></p><p>On Thu, Sep 22, 2016 at 5:59 AM, Marco S Hyman via swift-users &lt;<br>swift-users at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Sep 21, 2016, at 2:22 PM, Jens Persson via swift-users &lt;<br>&gt; swift-users at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; // This little Swift program compiles (and runs) fine:<br>&gt; &gt;<br>&gt; &gt; func foo() -&gt; Int { return a }<br>&gt; &gt; let a = 1<br>&gt; &gt; let b = 2<br>&gt; &gt; print(foo())<br>&gt; &gt;<br>&gt; &gt; But if `foo()` returns `b` instead of `a`, I get this compile time error:<br>&gt; &gt; &quot;Use of unresolved identifier `b`”<br>&gt;<br>&gt; Interesting.  Seems to have something to do with ordering as if you code<br>&gt; it this way:<br>&gt;<br>&gt; let a = 1<br>&gt; let b = 2<br>&gt; func foo() -&gt; Int { return b }<br>&gt; print(foo())<br>&gt;<br>&gt; it works fine (Xcode 8 playground).<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160922/cf8e4bc5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d042be5dcfe90e649f760303af3e429?s=50"></div><header><strong>Can anyone please explain this behavior?</strong> from <string>Jens Persson</string> &lt;jens at bitcycle.com&gt;<p>September 22, 2016 at 01:00:00am</p></header><div class="content"><p>I asked the same question on twitter, and it resulted in some interesting<br>finds:<br>https://twitter.com/bitCycle/status/778697998893142016<br></p><p>On Thu, Sep 22, 2016 at 12:41 AM, Zhao Xin &lt;owenzx at gmail.com&gt; wrote:<br></p><p>&gt; I suggest you defining the variables before using them like Marco does.<br>&gt; Although from the global variable point of view, both way should be fine.<br>&gt; But the glitch does exist, especially in playground.<br>&gt;<br>&gt; Zhaoxin<br>&gt;<br>&gt; On Thu, Sep 22, 2016 at 5:59 AM, Marco S Hyman via swift-users &lt;<br>&gt; swift-users at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; On Sep 21, 2016, at 2:22 PM, Jens Persson via swift-users &lt;<br>&gt;&gt; swift-users at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; // This little Swift program compiles (and runs) fine:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; func foo() -&gt; Int { return a }<br>&gt;&gt; &gt; let a = 1<br>&gt;&gt; &gt; let b = 2<br>&gt;&gt; &gt; print(foo())<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; But if `foo()` returns `b` instead of `a`, I get this compile time<br>&gt;&gt; error:<br>&gt;&gt; &gt; &quot;Use of unresolved identifier `b`”<br>&gt;&gt;<br>&gt;&gt; Interesting.  Seems to have something to do with ordering as if you code<br>&gt;&gt; it this way:<br>&gt;&gt;<br>&gt;&gt; let a = 1<br>&gt;&gt; let b = 2<br>&gt;&gt; func foo() -&gt; Int { return b }<br>&gt;&gt; print(foo())<br>&gt;&gt;<br>&gt;&gt; it works fine (Xcode 8 playground).<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160922/3bd3d3c6/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Can anyone please explain this behavior?</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>September 21, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Sep 21, 2016, at 2:22 PM, Jens Persson via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; // This little Swift program compiles (and runs) fine:<br>&gt; <br>&gt; func foo() -&gt; Int { return a }<br>&gt; let a = 1<br>&gt; let b = 2<br>&gt; print(foo())<br>&gt; <br>&gt; But if `foo()` returns `b` instead of `a`, I get this compile time error:<br>&gt; &quot;Use of unresolved identifier `b`&quot;<br></p><p>This looks like a bug to me (cc-ing Jordan, who&#39;s thought about global scoping issues more than me). In &quot;script mode&quot;, it shouldn&#39;t be possible to refer to a variable before its initialization is executed. However, the way this is currently modeled is…problematic, to say the least, among other reasons because script globals are still visible to &quot;library&quot; files in the same module.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d042be5dcfe90e649f760303af3e429?s=50"></div><header><strong>Can anyone please explain this behavior?</strong> from <string>Jens Persson</string> &lt;jens at bitcycle.com&gt;<p>September 22, 2016 at 08:00:00am</p></header><div class="content"><p>Did you see the other code examples that came up in that twitter<br>conversations?<br>For example:<br></p><p>This worrying little program compiles:<br>func f() -&gt; Int {<br>    return a<br>}<br>let a = f()<br></p><p><br>It also compiles if you print(a) at the end, and it will print 0.<br></p><p>If we replace Int with [Int] it will still compile but crash when run.<br></p><p>And also this:<br></p><p>AnotherFile.swift containing:<br>func f() -&gt; Int {<br>    return a<br>}<br>let a = f()<br></p><p>main.swift containing<br>print(a)<br></p><p>Compile, run (for eternity, at 0% CPU).<br></p><p>/Jens<br></p><p><br>On Thu, Sep 22, 2016 at 3:13 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Sep 21, 2016, at 2:22 PM, Jens Persson via swift-users &lt;<br>&gt; swift-users at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; // This little Swift program compiles (and runs) fine:<br>&gt; &gt;<br>&gt; &gt; func foo() -&gt; Int { return a }<br>&gt; &gt; let a = 1<br>&gt; &gt; let b = 2<br>&gt; &gt; print(foo())<br>&gt; &gt;<br>&gt; &gt; But if `foo()` returns `b` instead of `a`, I get this compile time error:<br>&gt; &gt; &quot;Use of unresolved identifier `b`&quot;<br>&gt;<br>&gt; This looks like a bug to me (cc-ing Jordan, who&#39;s thought about global<br>&gt; scoping issues more than me). In &quot;script mode&quot;, it shouldn&#39;t be possible to<br>&gt; refer to a variable before its initialization is executed. However, the way<br>&gt; this is currently modeled is…problematic, to say the least, among other<br>&gt; reasons because script globals are still visible to &quot;library&quot; files in the<br>&gt; same module.<br>&gt;<br>&gt; -Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160922/75421bcb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Can anyone please explain this behavior?</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>September 22, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Sep 21, 2016, at 11:04 PM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt; <br>&gt; Did you see the other code examples that came up in that twitter conversations?<br></p><p>These all look like the same problem. Whatever you&#39;re seeing is an accident of undefined behavior due to the hole in our semantic checking.<br></p><p>-Joe<br></p><p>&gt; For example:<br>&gt; <br>&gt; This worrying little program compiles:<br>&gt; func f() -&gt; Int {<br>&gt;     return a<br>&gt; }<br>&gt; let a = f()<br>&gt; <br>&gt; <br>&gt; It also compiles if you print(a) at the end, and it will print 0.<br>&gt; <br>&gt; If we replace Int with [Int] it will still compile but crash when run.<br>&gt; <br>&gt; And also this:<br>&gt; <br>&gt; AnotherFile.swift containing:<br>&gt; func f() -&gt; Int {<br>&gt;     return a<br>&gt; }<br>&gt; let a = f()<br>&gt; <br>&gt; main.swift containing<br>&gt; print(a)<br>&gt; <br>&gt; Compile, run (for eternity, at 0% CPU).<br>&gt; <br>&gt; /Jens<br>&gt; <br>&gt; <br>&gt; On Thu, Sep 22, 2016 at 3:13 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; &gt; On Sep 21, 2016, at 2:22 PM, Jens Persson via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; // This little Swift program compiles (and runs) fine:<br>&gt; &gt;<br>&gt; &gt; func foo() -&gt; Int { return a }<br>&gt; &gt; let a = 1<br>&gt; &gt; let b = 2<br>&gt; &gt; print(foo())<br>&gt; &gt;<br>&gt; &gt; But if `foo()` returns `b` instead of `a`, I get this compile time error:<br>&gt; &gt; &quot;Use of unresolved identifier `b`&quot;<br>&gt; <br>&gt; This looks like a bug to me (cc-ing Jordan, who&#39;s thought about global scoping issues more than me). In &quot;script mode&quot;, it shouldn&#39;t be possible to refer to a variable before its initialization is executed. However, the way this is currently modeled is…problematic, to say the least, among other reasons because script globals are still visible to &quot;library&quot; files in the same module.<br>&gt; <br>&gt; -Joe<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Can anyone please explain this behavior?</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>September 22, 2016 at 10:00:00am</p></header><div class="content"><p>Yep, it really is a long-standing bug. Script-mode top-level locals are treated as globals (module-scope bindings) by the compiler, but their initial bindings are evaluated eagerly instead of lazily (as you’d want in a script). Taken together, this means that you can get this completely unsafe behavior.<br></p><p>So, why is ‘a’ accepted but ‘b’ not in your original example?<br></p><p>&gt; func foo() -&gt; Int { return b }<br>&gt; let a = 1<br>&gt; let b = 2<br>&gt; print(foo())<br></p><p>The secret to the current behavior is that script mode is executed interactively, instead of parsing it all up front. To make things a little better, it actually parses any number of declarations until it sees something it actually needs to execute—a statement or a declaration with an initial value expression. This allows for recursive functions while still being “live”.<br></p><p>The consequence here is that one top-level binding after a series of functions may be visible. This is obviously not optimal.<br></p><p>To fix this, we should:<br></p><p>- Distinguish between script-mode top-level locals and module-scope variables that happen to be declared. My personal preference is to treat anything with explicit access control as a normal lazy global and anything without access as a top-level local.<br></p><p>- Consider parsing everything up front, even if we don’t type-check it, so that we can say “use of ‘b’ before it’s initialized” instead of “undeclared name ‘b’”<br></p><p>Note that we do need to be conservative here. This code should continue to be rejected, even though ‘f’ doesn’t refer to ‘local’ directly, because calling ‘f&#39; would be dangerous before the initialization of ‘local&#39;:<br></p><p>internal func f() -&gt; Int {<br>  return g()<br>}<br>// more code here<br></p><p>let local = 42<br>private func g() -&gt; Int {<br>  return local<br>}<br></p><p>Thanks for bringing this up, if only so I have an opportunity to write out the issue. :-)<br>Jordan<br></p><p><br>&gt; On Sep 21, 2016, at 23:04, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt; <br>&gt; Did you see the other code examples that came up in that twitter conversations?<br>&gt; For example:<br>&gt; <br>&gt; This worrying little program compiles:<br>&gt; func f() -&gt; Int {<br>&gt;     return a<br>&gt; }<br>&gt; let a = f()<br>&gt; <br>&gt; <br>&gt; It also compiles if you print(a) at the end, and it will print 0.<br>&gt; <br>&gt; If we replace Int with [Int] it will still compile but crash when run.<br>&gt; <br>&gt; And also this:<br>&gt; <br>&gt; AnotherFile.swift containing:<br>&gt; func f() -&gt; Int {<br>&gt;     return a<br>&gt; }<br>&gt; let a = f()<br>&gt; <br>&gt; main.swift containing<br>&gt; print(a)<br>&gt; <br>&gt; Compile, run (for eternity, at 0% CPU).<br>&gt; <br>&gt; /Jens<br>&gt; <br>&gt; <br>&gt; On Thu, Sep 22, 2016 at 3:13 AM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt; &gt; On Sep 21, 2016, at 2:22 PM, Jens Persson via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; // This little Swift program compiles (and runs) fine:<br>&gt; &gt;<br>&gt; &gt; func foo() -&gt; Int { return a }<br>&gt; &gt; let a = 1<br>&gt; &gt; let b = 2<br>&gt; &gt; print(foo())<br>&gt; &gt;<br>&gt; &gt; But if `foo()` returns `b` instead of `a`, I get this compile time error:<br>&gt; &gt; &quot;Use of unresolved identifier `b`&quot;<br>&gt; <br>&gt; This looks like a bug to me (cc-ing Jordan, who&#39;s thought about global scoping issues more than me). In &quot;script mode&quot;, it shouldn&#39;t be possible to refer to a variable before its initialization is executed. However, the way this is currently modeled is…problematic, to say the least, among other reasons because script globals are still visible to &quot;library&quot; files in the same module.<br>&gt; <br>&gt; -Joe<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160922/861661ab/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d042be5dcfe90e649f760303af3e429?s=50"></div><header><strong>Can anyone please explain this behavior?</strong> from <string>Jens Persson</string> &lt;jens at bitcycle.com&gt;<p>September 22, 2016 at 08:00:00pm</p></header><div class="content"><p>Thank you for the thorough explanation!<br>/Jens<br></p><p>On Thu, Sep 22, 2016 at 7:28 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br></p><p>&gt; Yep, it really is a long-standing bug. Script-mode top-level locals are<br>&gt; treated as globals (module-scope bindings) by the compiler, but their<br>&gt; initial bindings are evaluated eagerly instead of lazily (as you’d want in<br>&gt; a script). Taken together, this means that you can get this completely<br>&gt; unsafe behavior.<br>&gt;<br>&gt; So, why is ‘a’ accepted but ‘b’ not in your original example?<br>&gt;<br>&gt; func foo() -&gt; Int { return b }<br>&gt; let a = 1<br>&gt; let b = 2<br>&gt; print(foo())<br>&gt;<br>&gt;<br>&gt; The secret to the current behavior is that script mode is executed<br>&gt; interactively, instead of parsing it all up front. To make things a little<br>&gt; better, it *actually* parses any number of declarations until it sees<br>&gt; something it actually needs to execute—a statement or a declaration with an<br>&gt; initial value expression. This allows for recursive functions while still<br>&gt; being “live”.<br>&gt;<br>&gt; The consequence here is that *one* top-level binding after a series of<br>&gt; functions may be visible. This is obviously not optimal.<br>&gt;<br>&gt; To fix this, we should:<br>&gt;<br>&gt; - Distinguish between script-mode top-level locals and module-scope<br>&gt; variables that happen to be declared. My personal preference is to treat<br>&gt; anything with explicit access control as a normal lazy global and anything<br>&gt; without access as a top-level local.<br>&gt;<br>&gt; - Consider parsing everything up front, even if we don’t type-check it, so<br>&gt; that we can say “use of ‘b’ before it’s initialized” instead of “undeclared<br>&gt; name ‘b’”<br>&gt;<br>&gt; Note that we *do* need to be conservative here. This code should continue<br>&gt; to be rejected, even though ‘f’ doesn’t refer to ‘local’ directly, because<br>&gt; *calling* ‘f&#39; would be dangerous before the initialization of ‘local&#39;:<br>&gt;<br>&gt; internal func f() -&gt; Int {<br>&gt;   return g()<br>&gt; }<br>&gt; *// more code here*<br>&gt;<br>&gt; let local = 42<br>&gt; private func g() -&gt; Int {<br>&gt;   return local<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Thanks for bringing this up, if only so I have an opportunity to write out<br>&gt; the issue. :-)<br>&gt; Jordan<br>&gt;<br>&gt;<br>&gt; On Sep 21, 2016, at 23:04, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;<br>&gt; Did you see the other code examples that came up in that twitter<br>&gt; conversations?<br>&gt; For example:<br>&gt;<br>&gt; This worrying little program compiles:<br>&gt; func f() -&gt; Int {<br>&gt;     return a<br>&gt; }<br>&gt; let a = f()<br>&gt;<br>&gt;<br>&gt; It also compiles if you print(a) at the end, and it will print 0.<br>&gt;<br>&gt; If we replace Int with [Int] it will still compile but crash when run.<br>&gt;<br>&gt; And also this:<br>&gt;<br>&gt; AnotherFile.swift containing:<br>&gt; func f() -&gt; Int {<br>&gt;     return a<br>&gt; }<br>&gt; let a = f()<br>&gt;<br>&gt; main.swift containing<br>&gt; print(a)<br>&gt;<br>&gt; Compile, run (for eternity, at 0% CPU).<br>&gt;<br>&gt; /Jens<br>&gt;<br>&gt;<br>&gt; On Thu, Sep 22, 2016 at 3:13 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; On Sep 21, 2016, at 2:22 PM, Jens Persson via swift-users &lt;<br>&gt;&gt; swift-users at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; // This little Swift program compiles (and runs) fine:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; func foo() -&gt; Int { return a }<br>&gt;&gt; &gt; let a = 1<br>&gt;&gt; &gt; let b = 2<br>&gt;&gt; &gt; print(foo())<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; But if `foo()` returns `b` instead of `a`, I get this compile time<br>&gt;&gt; error:<br>&gt;&gt; &gt; &quot;Use of unresolved identifier `b`&quot;<br>&gt;&gt;<br>&gt;&gt; This looks like a bug to me (cc-ing Jordan, who&#39;s thought about global<br>&gt;&gt; scoping issues more than me). In &quot;script mode&quot;, it shouldn&#39;t be possible to<br>&gt;&gt; refer to a variable before its initialization is executed. However, the way<br>&gt;&gt; this is currently modeled is…problematic, to say the least, among other<br>&gt;&gt; reasons because script globals are still visible to &quot;library&quot; files in the<br>&gt;&gt; same module.<br>&gt;&gt;<br>&gt;&gt; -Joe<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160922/11a259f4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d042be5dcfe90e649f760303af3e429?s=50"></div><header><strong>Can anyone please explain this behavior?</strong> from <string>Jens Persson</string> &lt;jens at bitcycle.com&gt;<p>September 22, 2016 at 08:00:00pm</p></header><div class="content"><p>Oh, but how can the following (earlier mentioned) example have anything to<br>do with Script-mode top-level locals being treated as globals?<br></p><p>Create &quot;AnotherFile.swift&quot; containing:<br>func f() -&gt; Int { return a }<br>let a = f()<br></p><p>Create &quot;main.swift&quot; containing:<br>print(a)<br></p><p>Compile. Run. For ever. At zero % CPU.<br></p><p>/Jens<br></p><p><br></p><p>On Thu, Sep 22, 2016 at 8:03 PM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br></p><p>&gt; Thank you for the thorough explanation!<br>&gt; /Jens<br>&gt;<br>&gt; On Thu, Sep 22, 2016 at 7:28 PM, Jordan Rose &lt;jordan_rose at apple.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; Yep, it really is a long-standing bug. Script-mode top-level locals are<br>&gt;&gt; treated as globals (module-scope bindings) by the compiler, but their<br>&gt;&gt; initial bindings are evaluated eagerly instead of lazily (as you’d want in<br>&gt;&gt; a script). Taken together, this means that you can get this completely<br>&gt;&gt; unsafe behavior.<br>&gt;&gt;<br>&gt;&gt; So, why is ‘a’ accepted but ‘b’ not in your original example?<br>&gt;&gt;<br>&gt;&gt; func foo() -&gt; Int { return b }<br>&gt;&gt; let a = 1<br>&gt;&gt; let b = 2<br>&gt;&gt; print(foo())<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; The secret to the current behavior is that script mode is executed<br>&gt;&gt; interactively, instead of parsing it all up front. To make things a little<br>&gt;&gt; better, it *actually* parses any number of declarations until it sees<br>&gt;&gt; something it actually needs to execute—a statement or a declaration with an<br>&gt;&gt; initial value expression. This allows for recursive functions while still<br>&gt;&gt; being “live”.<br>&gt;&gt;<br>&gt;&gt; The consequence here is that *one* top-level binding after a series of<br>&gt;&gt; functions may be visible. This is obviously not optimal.<br>&gt;&gt;<br>&gt;&gt; To fix this, we should:<br>&gt;&gt;<br>&gt;&gt; - Distinguish between script-mode top-level locals and module-scope<br>&gt;&gt; variables that happen to be declared. My personal preference is to treat<br>&gt;&gt; anything with explicit access control as a normal lazy global and anything<br>&gt;&gt; without access as a top-level local.<br>&gt;&gt;<br>&gt;&gt; - Consider parsing everything up front, even if we don’t type-check it,<br>&gt;&gt; so that we can say “use of ‘b’ before it’s initialized” instead of<br>&gt;&gt; “undeclared name ‘b’”<br>&gt;&gt;<br>&gt;&gt; Note that we *do* need to be conservative here. This code should<br>&gt;&gt; continue to be rejected, even though ‘f’ doesn’t refer to ‘local’ directly,<br>&gt;&gt; because *calling* ‘f&#39; would be dangerous before the initialization of<br>&gt;&gt; ‘local&#39;:<br>&gt;&gt;<br>&gt;&gt; internal func f() -&gt; Int {<br>&gt;&gt;   return g()<br>&gt;&gt; }<br>&gt;&gt; *// more code here*<br>&gt;&gt;<br>&gt;&gt; let local = 42<br>&gt;&gt; private func g() -&gt; Int {<br>&gt;&gt;   return local<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Thanks for bringing this up, if only so I have an opportunity to write<br>&gt;&gt; out the issue. :-)<br>&gt;&gt; Jordan<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Sep 21, 2016, at 23:04, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Did you see the other code examples that came up in that twitter<br>&gt;&gt; conversations?<br>&gt;&gt; For example:<br>&gt;&gt;<br>&gt;&gt; This worrying little program compiles:<br>&gt;&gt; func f() -&gt; Int {<br>&gt;&gt;     return a<br>&gt;&gt; }<br>&gt;&gt; let a = f()<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; It also compiles if you print(a) at the end, and it will print 0.<br>&gt;&gt;<br>&gt;&gt; If we replace Int with [Int] it will still compile but crash when run.<br>&gt;&gt;<br>&gt;&gt; And also this:<br>&gt;&gt;<br>&gt;&gt; AnotherFile.swift containing:<br>&gt;&gt; func f() -&gt; Int {<br>&gt;&gt;     return a<br>&gt;&gt; }<br>&gt;&gt; let a = f()<br>&gt;&gt;<br>&gt;&gt; main.swift containing<br>&gt;&gt; print(a)<br>&gt;&gt;<br>&gt;&gt; Compile, run (for eternity, at 0% CPU).<br>&gt;&gt;<br>&gt;&gt; /Jens<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Thu, Sep 22, 2016 at 3:13 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; On Sep 21, 2016, at 2:22 PM, Jens Persson via swift-users &lt;<br>&gt;&gt;&gt; swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; // This little Swift program compiles (and runs) fine:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; func foo() -&gt; Int { return a }<br>&gt;&gt;&gt; &gt; let a = 1<br>&gt;&gt;&gt; &gt; let b = 2<br>&gt;&gt;&gt; &gt; print(foo())<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; But if `foo()` returns `b` instead of `a`, I get this compile time<br>&gt;&gt;&gt; error:<br>&gt;&gt;&gt; &gt; &quot;Use of unresolved identifier `b`&quot;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This looks like a bug to me (cc-ing Jordan, who&#39;s thought about global<br>&gt;&gt;&gt; scoping issues more than me). In &quot;script mode&quot;, it shouldn&#39;t be possible to<br>&gt;&gt;&gt; refer to a variable before its initialization is executed. However, the way<br>&gt;&gt;&gt; this is currently modeled is…problematic, to say the least, among other<br>&gt;&gt;&gt; reasons because script globals are still visible to &quot;library&quot; files in the<br>&gt;&gt;&gt; same module.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -Joe<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160922/f1b390c6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Can anyone please explain this behavior?</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>September 22, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Sep 22, 2016, at 11:23 AM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt; <br>&gt; Oh, but how can the following (earlier mentioned) example have anything to do with Script-mode top-level locals being treated as globals?<br>&gt; <br>&gt; Create &quot;AnotherFile.swift&quot; containing:<br>&gt; func f() -&gt; Int { return a }<br>&gt; let a = f()<br></p><p>In this case, you have a deadlock, since the initialization of `a` depends on its own initialization.<br></p><p>-Joe<br></p><p>&gt; Create &quot;main.swift&quot; containing:<br>&gt; print(a)<br>&gt; <br>&gt; Compile. Run. For ever. At zero % CPU.<br>&gt; <br>&gt; /Jens<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Thu, Sep 22, 2016 at 8:03 PM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt; Thank you for the thorough explanation!<br>&gt; /Jens<br>&gt; <br>&gt; On Thu, Sep 22, 2016 at 7:28 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; Yep, it really is a long-standing bug. Script-mode top-level locals are treated as globals (module-scope bindings) by the compiler, but their initial bindings are evaluated eagerly instead of lazily (as you’d want in a script). Taken together, this means that you can get this completely unsafe behavior.<br>&gt; <br>&gt; So, why is ‘a’ accepted but ‘b’ not in your original example?<br>&gt; <br>&gt;&gt; func foo() -&gt; Int { return b }<br>&gt;&gt; let a = 1<br>&gt;&gt; let b = 2<br>&gt;&gt; print(foo())<br>&gt; <br>&gt; The secret to the current behavior is that script mode is executed interactively, instead of parsing it all up front. To make things a little better, it actually parses any number of declarations until it sees something it actually needs to execute—a statement or a declaration with an initial value expression. This allows for recursive functions while still being “live”.<br>&gt; <br>&gt; The consequence here is that one top-level binding after a series of functions may be visible. This is obviously not optimal.<br>&gt; <br>&gt; To fix this, we should:<br>&gt; <br>&gt; - Distinguish between script-mode top-level locals and module-scope variables that happen to be declared. My personal preference is to treat anything with explicit access control as a normal lazy global and anything without access as a top-level local.<br>&gt; <br>&gt; - Consider parsing everything up front, even if we don’t type-check it, so that we can say “use of ‘b’ before it’s initialized” instead of “undeclared name ‘b’”<br>&gt; <br>&gt; Note that we do need to be conservative here. This code should continue to be rejected, even though ‘f’ doesn’t refer to ‘local’ directly, because calling ‘f&#39; would be dangerous before the initialization of ‘local&#39;:<br>&gt; <br>&gt; internal func f() -&gt; Int {<br>&gt;   return g()<br>&gt; }<br>&gt; // more code here<br>&gt; <br>&gt; let local = 42<br>&gt; private func g() -&gt; Int {<br>&gt;   return local<br>&gt; }<br>&gt; <br>&gt; Thanks for bringing this up, if only so I have an opportunity to write out the issue. :-)<br>&gt; Jordan<br>&gt; <br>&gt; <br>&gt;&gt; On Sep 21, 2016, at 23:04, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Did you see the other code examples that came up in that twitter conversations?<br>&gt;&gt; For example:<br>&gt;&gt; <br>&gt;&gt; This worrying little program compiles:<br>&gt;&gt; func f() -&gt; Int {<br>&gt;&gt;     return a<br>&gt;&gt; }<br>&gt;&gt; let a = f()<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; It also compiles if you print(a) at the end, and it will print 0.<br>&gt;&gt; <br>&gt;&gt; If we replace Int with [Int] it will still compile but crash when run.<br>&gt;&gt; <br>&gt;&gt; And also this:<br>&gt;&gt; <br>&gt;&gt; AnotherFile.swift containing:<br>&gt;&gt; func f() -&gt; Int {<br>&gt;&gt;     return a<br>&gt;&gt; }<br>&gt;&gt; let a = f()<br>&gt;&gt; <br>&gt;&gt; main.swift containing<br>&gt;&gt; print(a)<br>&gt;&gt; <br>&gt;&gt; Compile, run (for eternity, at 0% CPU).<br>&gt;&gt; <br>&gt;&gt; /Jens<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Thu, Sep 22, 2016 at 3:13 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt; On Sep 21, 2016, at 2:22 PM, Jens Persson via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; // This little Swift program compiles (and runs) fine:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; func foo() -&gt; Int { return a }<br>&gt;&gt; &gt; let a = 1<br>&gt;&gt; &gt; let b = 2<br>&gt;&gt; &gt; print(foo())<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; But if `foo()` returns `b` instead of `a`, I get this compile time error:<br>&gt;&gt; &gt; &quot;Use of unresolved identifier `b`&quot;<br>&gt;&gt; <br>&gt;&gt; This looks like a bug to me (cc-ing Jordan, who&#39;s thought about global scoping issues more than me). In &quot;script mode&quot;, it shouldn&#39;t be possible to refer to a variable before its initialization is executed. However, the way this is currently modeled is…problematic, to say the least, among other reasons because script globals are still visible to &quot;library&quot; files in the same module.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d042be5dcfe90e649f760303af3e429?s=50"></div><header><strong>Can anyone please explain this behavior?</strong> from <string>Jens Persson</string> &lt;jens at bitcycle.com&gt;<p>September 22, 2016 at 08:00:00pm</p></header><div class="content"><p>Yes, but should the compiler silently accept that? And is this issue really<br>related to the other issue?<br>/Jens<br></p><p>On Thu, Sep 22, 2016 at 8:23 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Sep 22, 2016, at 11:23 AM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Oh, but how can the following (earlier mentioned) example have anything<br>&gt; to do with Script-mode top-level locals being treated as globals?<br>&gt; &gt;<br>&gt; &gt; Create &quot;AnotherFile.swift&quot; containing:<br>&gt; &gt; func f() -&gt; Int { return a }<br>&gt; &gt; let a = f()<br>&gt;<br>&gt; In this case, you have a deadlock, since the initialization of `a` depends<br>&gt; on its own initialization.<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt; &gt; Create &quot;main.swift&quot; containing:<br>&gt; &gt; print(a)<br>&gt; &gt;<br>&gt; &gt; Compile. Run. For ever. At zero % CPU.<br>&gt; &gt;<br>&gt; &gt; /Jens<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; On Thu, Sep 22, 2016 at 8:03 PM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt; &gt; Thank you for the thorough explanation!<br>&gt; &gt; /Jens<br>&gt; &gt;<br>&gt; &gt; On Thu, Sep 22, 2016 at 7:28 PM, Jordan Rose &lt;jordan_rose at apple.com&gt;<br>&gt; wrote:<br>&gt; &gt; Yep, it really is a long-standing bug. Script-mode top-level locals are<br>&gt; treated as globals (module-scope bindings) by the compiler, but their<br>&gt; initial bindings are evaluated eagerly instead of lazily (as you’d want in<br>&gt; a script). Taken together, this means that you can get this completely<br>&gt; unsafe behavior.<br>&gt; &gt;<br>&gt; &gt; So, why is ‘a’ accepted but ‘b’ not in your original example?<br>&gt; &gt;<br>&gt; &gt;&gt; func foo() -&gt; Int { return b }<br>&gt; &gt;&gt; let a = 1<br>&gt; &gt;&gt; let b = 2<br>&gt; &gt;&gt; print(foo())<br>&gt; &gt;<br>&gt; &gt; The secret to the current behavior is that script mode is executed<br>&gt; interactively, instead of parsing it all up front. To make things a little<br>&gt; better, it actually parses any number of declarations until it sees<br>&gt; something it actually needs to execute—a statement or a declaration with an<br>&gt; initial value expression. This allows for recursive functions while still<br>&gt; being “live”.<br>&gt; &gt;<br>&gt; &gt; The consequence here is that one top-level binding after a series of<br>&gt; functions may be visible. This is obviously not optimal.<br>&gt; &gt;<br>&gt; &gt; To fix this, we should:<br>&gt; &gt;<br>&gt; &gt; - Distinguish between script-mode top-level locals and module-scope<br>&gt; variables that happen to be declared. My personal preference is to treat<br>&gt; anything with explicit access control as a normal lazy global and anything<br>&gt; without access as a top-level local.<br>&gt; &gt;<br>&gt; &gt; - Consider parsing everything up front, even if we don’t type-check it,<br>&gt; so that we can say “use of ‘b’ before it’s initialized” instead of<br>&gt; “undeclared name ‘b’”<br>&gt; &gt;<br>&gt; &gt; Note that we do need to be conservative here. This code should continue<br>&gt; to be rejected, even though ‘f’ doesn’t refer to ‘local’ directly, because<br>&gt; calling ‘f&#39; would be dangerous before the initialization of ‘local&#39;:<br>&gt; &gt;<br>&gt; &gt; internal func f() -&gt; Int {<br>&gt; &gt;   return g()<br>&gt; &gt; }<br>&gt; &gt; // more code here<br>&gt; &gt;<br>&gt; &gt; let local = 42<br>&gt; &gt; private func g() -&gt; Int {<br>&gt; &gt;   return local<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; Thanks for bringing this up, if only so I have an opportunity to write<br>&gt; out the issue. :-)<br>&gt; &gt; Jordan<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On Sep 21, 2016, at 23:04, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Did you see the other code examples that came up in that twitter<br>&gt; conversations?<br>&gt; &gt;&gt; For example:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; This worrying little program compiles:<br>&gt; &gt;&gt; func f() -&gt; Int {<br>&gt; &gt;&gt;     return a<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; let a = f()<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; It also compiles if you print(a) at the end, and it will print 0.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; If we replace Int with [Int] it will still compile but crash when run.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; And also this:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; AnotherFile.swift containing:<br>&gt; &gt;&gt; func f() -&gt; Int {<br>&gt; &gt;&gt;     return a<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; let a = f()<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; main.swift containing<br>&gt; &gt;&gt; print(a)<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Compile, run (for eternity, at 0% CPU).<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; /Jens<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; On Thu, Sep 22, 2016 at 3:13 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt; On Sep 21, 2016, at 2:22 PM, Jens Persson via swift-users &lt;<br>&gt; swift-users at swift.org&gt; wrote:<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; // This little Swift program compiles (and runs) fine:<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; func foo() -&gt; Int { return a }<br>&gt; &gt;&gt; &gt; let a = 1<br>&gt; &gt;&gt; &gt; let b = 2<br>&gt; &gt;&gt; &gt; print(foo())<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; But if `foo()` returns `b` instead of `a`, I get this compile time<br>&gt; error:<br>&gt; &gt;&gt; &gt; &quot;Use of unresolved identifier `b`&quot;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; This looks like a bug to me (cc-ing Jordan, who&#39;s thought about global<br>&gt; scoping issues more than me). In &quot;script mode&quot;, it shouldn&#39;t be possible to<br>&gt; refer to a variable before its initialization is executed. However, the way<br>&gt; this is currently modeled is…problematic, to say the least, among other<br>&gt; reasons because script globals are still visible to &quot;library&quot; files in the<br>&gt; same module.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; -Joe<br>&gt; &gt;&gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160922/220b94c4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Can anyone please explain this behavior?</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>September 22, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Sep 22, 2016, at 11:28 AM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt; <br>&gt; Yes, but should the compiler silently accept that? And is this issue really related to the other issue?<br></p><p>No, this is a separate issue. The compiler might be able to catch some obvious cases, but it&#39;d be impossible to statically prevent all circularities. The runtime could probably do a better job detecting this situation, though, and give a runtime error instead of just letting the deadlock happen.<br></p><p>-Joe<br></p><p>&gt; /Jens<br>&gt; <br>&gt; On Thu, Sep 22, 2016 at 8:23 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; &gt; On Sep 22, 2016, at 11:23 AM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Oh, but how can the following (earlier mentioned) example have anything to do with Script-mode top-level locals being treated as globals?<br>&gt; &gt;<br>&gt; &gt; Create &quot;AnotherFile.swift&quot; containing:<br>&gt; &gt; func f() -&gt; Int { return a }<br>&gt; &gt; let a = f()<br>&gt; <br>&gt; In this case, you have a deadlock, since the initialization of `a` depends on its own initialization.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; &gt; Create &quot;main.swift&quot; containing:<br>&gt; &gt; print(a)<br>&gt; &gt;<br>&gt; &gt; Compile. Run. For ever. At zero % CPU.<br>&gt; &gt;<br>&gt; &gt; /Jens<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; On Thu, Sep 22, 2016 at 8:03 PM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt; &gt; Thank you for the thorough explanation!<br>&gt; &gt; /Jens<br>&gt; &gt;<br>&gt; &gt; On Thu, Sep 22, 2016 at 7:28 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; &gt; Yep, it really is a long-standing bug. Script-mode top-level locals are treated as globals (module-scope bindings) by the compiler, but their initial bindings are evaluated eagerly instead of lazily (as you’d want in a script). Taken together, this means that you can get this completely unsafe behavior.<br>&gt; &gt;<br>&gt; &gt; So, why is ‘a’ accepted but ‘b’ not in your original example?<br>&gt; &gt;<br>&gt; &gt;&gt; func foo() -&gt; Int { return b }<br>&gt; &gt;&gt; let a = 1<br>&gt; &gt;&gt; let b = 2<br>&gt; &gt;&gt; print(foo())<br>&gt; &gt;<br>&gt; &gt; The secret to the current behavior is that script mode is executed interactively, instead of parsing it all up front. To make things a little better, it actually parses any number of declarations until it sees something it actually needs to execute—a statement or a declaration with an initial value expression. This allows for recursive functions while still being “live”.<br>&gt; &gt;<br>&gt; &gt; The consequence here is that one top-level binding after a series of functions may be visible. This is obviously not optimal.<br>&gt; &gt;<br>&gt; &gt; To fix this, we should:<br>&gt; &gt;<br>&gt; &gt; - Distinguish between script-mode top-level locals and module-scope variables that happen to be declared. My personal preference is to treat anything with explicit access control as a normal lazy global and anything without access as a top-level local.<br>&gt; &gt;<br>&gt; &gt; - Consider parsing everything up front, even if we don’t type-check it, so that we can say “use of ‘b’ before it’s initialized” instead of “undeclared name ‘b’”<br>&gt; &gt;<br>&gt; &gt; Note that we do need to be conservative here. This code should continue to be rejected, even though ‘f’ doesn’t refer to ‘local’ directly, because calling ‘f&#39; would be dangerous before the initialization of ‘local&#39;:<br>&gt; &gt;<br>&gt; &gt; internal func f() -&gt; Int {<br>&gt; &gt;   return g()<br>&gt; &gt; }<br>&gt; &gt; // more code here<br>&gt; &gt;<br>&gt; &gt; let local = 42<br>&gt; &gt; private func g() -&gt; Int {<br>&gt; &gt;   return local<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; Thanks for bringing this up, if only so I have an opportunity to write out the issue. :-)<br>&gt; &gt; Jordan<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On Sep 21, 2016, at 23:04, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Did you see the other code examples that came up in that twitter conversations?<br>&gt; &gt;&gt; For example:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; This worrying little program compiles:<br>&gt; &gt;&gt; func f() -&gt; Int {<br>&gt; &gt;&gt;     return a<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; let a = f()<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; It also compiles if you print(a) at the end, and it will print 0.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; If we replace Int with [Int] it will still compile but crash when run.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; And also this:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; AnotherFile.swift containing:<br>&gt; &gt;&gt; func f() -&gt; Int {<br>&gt; &gt;&gt;     return a<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; let a = f()<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; main.swift containing<br>&gt; &gt;&gt; print(a)<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Compile, run (for eternity, at 0% CPU).<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; /Jens<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; On Thu, Sep 22, 2016 at 3:13 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt; On Sep 21, 2016, at 2:22 PM, Jens Persson via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; // This little Swift program compiles (and runs) fine:<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; func foo() -&gt; Int { return a }<br>&gt; &gt;&gt; &gt; let a = 1<br>&gt; &gt;&gt; &gt; let b = 2<br>&gt; &gt;&gt; &gt; print(foo())<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; But if `foo()` returns `b` instead of `a`, I get this compile time error:<br>&gt; &gt;&gt; &gt; &quot;Use of unresolved identifier `b`&quot;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; This looks like a bug to me (cc-ing Jordan, who&#39;s thought about global scoping issues more than me). In &quot;script mode&quot;, it shouldn&#39;t be possible to refer to a variable before its initialization is executed. However, the way this is currently modeled is…problematic, to say the least, among other reasons because script globals are still visible to &quot;library&quot; files in the same module.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; -Joe<br>&gt; &gt;&gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d042be5dcfe90e649f760303af3e429?s=50"></div><header><strong>Can anyone please explain this behavior?</strong> from <string>Jens Persson</string> &lt;jens at bitcycle.com&gt;<p>September 22, 2016 at 08:00:00pm</p></header><div class="content"><p>Ah, yes. Thanks.<br></p><p>On Thu, Sep 22, 2016 at 8:29 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Sep 22, 2016, at 11:28 AM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Yes, but should the compiler silently accept that? And is this issue<br>&gt; really related to the other issue?<br>&gt;<br>&gt; No, this is a separate issue. The compiler might be able to catch some<br>&gt; obvious cases, but it&#39;d be impossible to statically prevent all<br>&gt; circularities. The runtime could probably do a better job detecting this<br>&gt; situation, though, and give a runtime error instead of just letting the<br>&gt; deadlock happen.<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt; &gt; /Jens<br>&gt; &gt;<br>&gt; &gt; On Thu, Sep 22, 2016 at 8:23 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; &gt; On Sep 22, 2016, at 11:23 AM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Oh, but how can the following (earlier mentioned) example have<br>&gt; anything to do with Script-mode top-level locals being treated as globals?<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Create &quot;AnotherFile.swift&quot; containing:<br>&gt; &gt; &gt; func f() -&gt; Int { return a }<br>&gt; &gt; &gt; let a = f()<br>&gt; &gt;<br>&gt; &gt; In this case, you have a deadlock, since the initialization of `a`<br>&gt; depends on its own initialization.<br>&gt; &gt;<br>&gt; &gt; -Joe<br>&gt; &gt;<br>&gt; &gt; &gt; Create &quot;main.swift&quot; containing:<br>&gt; &gt; &gt; print(a)<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Compile. Run. For ever. At zero % CPU.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; /Jens<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; On Thu, Sep 22, 2016 at 8:03 PM, Jens Persson &lt;jens at bitcycle.com&gt;<br>&gt; wrote:<br>&gt; &gt; &gt; Thank you for the thorough explanation!<br>&gt; &gt; &gt; /Jens<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; On Thu, Sep 22, 2016 at 7:28 PM, Jordan Rose &lt;jordan_rose at apple.com&gt;<br>&gt; wrote:<br>&gt; &gt; &gt; Yep, it really is a long-standing bug. Script-mode top-level locals<br>&gt; are treated as globals (module-scope bindings) by the compiler, but their<br>&gt; initial bindings are evaluated eagerly instead of lazily (as you’d want in<br>&gt; a script). Taken together, this means that you can get this completely<br>&gt; unsafe behavior.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; So, why is ‘a’ accepted but ‘b’ not in your original example?<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;&gt; func foo() -&gt; Int { return b }<br>&gt; &gt; &gt;&gt; let a = 1<br>&gt; &gt; &gt;&gt; let b = 2<br>&gt; &gt; &gt;&gt; print(foo())<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; The secret to the current behavior is that script mode is executed<br>&gt; interactively, instead of parsing it all up front. To make things a little<br>&gt; better, it actually parses any number of declarations until it sees<br>&gt; something it actually needs to execute—a statement or a declaration with an<br>&gt; initial value expression. This allows for recursive functions while still<br>&gt; being “live”.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; The consequence here is that one top-level binding after a series of<br>&gt; functions may be visible. This is obviously not optimal.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; To fix this, we should:<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; - Distinguish between script-mode top-level locals and module-scope<br>&gt; variables that happen to be declared. My personal preference is to treat<br>&gt; anything with explicit access control as a normal lazy global and anything<br>&gt; without access as a top-level local.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; - Consider parsing everything up front, even if we don’t type-check<br>&gt; it, so that we can say “use of ‘b’ before it’s initialized” instead of<br>&gt; “undeclared name ‘b’”<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Note that we do need to be conservative here. This code should<br>&gt; continue to be rejected, even though ‘f’ doesn’t refer to ‘local’ directly,<br>&gt; because calling ‘f&#39; would be dangerous before the initialization of ‘local&#39;:<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; internal func f() -&gt; Int {<br>&gt; &gt; &gt;   return g()<br>&gt; &gt; &gt; }<br>&gt; &gt; &gt; // more code here<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; let local = 42<br>&gt; &gt; &gt; private func g() -&gt; Int {<br>&gt; &gt; &gt;   return local<br>&gt; &gt; &gt; }<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Thanks for bringing this up, if only so I have an opportunity to write<br>&gt; out the issue. :-)<br>&gt; &gt; &gt; Jordan<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;&gt; On Sep 21, 2016, at 23:04, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; Did you see the other code examples that came up in that twitter<br>&gt; conversations?<br>&gt; &gt; &gt;&gt; For example:<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; This worrying little program compiles:<br>&gt; &gt; &gt;&gt; func f() -&gt; Int {<br>&gt; &gt; &gt;&gt;     return a<br>&gt; &gt; &gt;&gt; }<br>&gt; &gt; &gt;&gt; let a = f()<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; It also compiles if you print(a) at the end, and it will print 0.<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; If we replace Int with [Int] it will still compile but crash when run.<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; And also this:<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; AnotherFile.swift containing:<br>&gt; &gt; &gt;&gt; func f() -&gt; Int {<br>&gt; &gt; &gt;&gt;     return a<br>&gt; &gt; &gt;&gt; }<br>&gt; &gt; &gt;&gt; let a = f()<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; main.swift containing<br>&gt; &gt; &gt;&gt; print(a)<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; Compile, run (for eternity, at 0% CPU).<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; /Jens<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; On Thu, Sep 22, 2016 at 3:13 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; &gt; On Sep 21, 2016, at 2:22 PM, Jens Persson via swift-users &lt;<br>&gt; swift-users at swift.org&gt; wrote:<br>&gt; &gt; &gt;&gt; &gt;<br>&gt; &gt; &gt;&gt; &gt; // This little Swift program compiles (and runs) fine:<br>&gt; &gt; &gt;&gt; &gt;<br>&gt; &gt; &gt;&gt; &gt; func foo() -&gt; Int { return a }<br>&gt; &gt; &gt;&gt; &gt; let a = 1<br>&gt; &gt; &gt;&gt; &gt; let b = 2<br>&gt; &gt; &gt;&gt; &gt; print(foo())<br>&gt; &gt; &gt;&gt; &gt;<br>&gt; &gt; &gt;&gt; &gt; But if `foo()` returns `b` instead of `a`, I get this compile time<br>&gt; error:<br>&gt; &gt; &gt;&gt; &gt; &quot;Use of unresolved identifier `b`&quot;<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; This looks like a bug to me (cc-ing Jordan, who&#39;s thought about<br>&gt; global scoping issues more than me). In &quot;script mode&quot;, it shouldn&#39;t be<br>&gt; possible to refer to a variable before its initialization is executed.<br>&gt; However, the way this is currently modeled is…problematic, to say the<br>&gt; least, among other reasons because script globals are still visible to<br>&gt; &quot;library&quot; files in the same module.<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; -Joe<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160922/d1f806cc/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
