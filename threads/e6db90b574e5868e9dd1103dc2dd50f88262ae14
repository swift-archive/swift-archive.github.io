<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/067cee1a86dbe57d6de692dd39c6791b?s=50"></div><header><strong>Implementation of swift&#39;s value types</strong> from <string>Johannes Neubauer</string> &lt;neubauer at kingsware.de&gt;<p>July 14, 2016 at 09:00:00pm</p></header><div class="content"><p>Dear Devs,<br></p><p>I saw the WWDC 2016 video [Understanding Swift Performance][0] as well as some others regarding value types in swift of WWDC2015. I think there are a few ambiguities which make it hard both to decide which weapon to choose and to give proposition how to evolve this implementations to the better (swift-evolution).<br></p><p>Is there a place, where low-level decisions in the language are documented? Is there an adequate place/forum where we can ask questions regarding low-level implementations? It would be great if you add a (moderated) comment section to each of the WWDC videos, so that we can discuss the contents (with transcript-like links) as well as an errata section containing a list of Apple-Approved mistakes/ambiguities in a given video/talk.<br></p><p># So, here come my questions<br></p><p>In the talk [Understanding Swift Performance][0] Kyle says, that value types are put stored in the stack and copied. He uses a point and a line which are both copied. Lateron Arnold uses a similar example with protocols. Then the Existential Container is used, which either uses the value buffer (for small values like `Point`) or allocates some memory on the heap and adds a pointer to this value (e.g. for a `Line`):<br></p><p>1. If I have an object (instance of a class) in a variable (or a container like an array) of a protocol type, will it be stored into an Existential Container, too? Or are reference types always stored as a reference (storing it in an Existential Container makes more sense to me).<br>2. If I use a variable of the concrete type (although it implements a protocol), will it always be copied (no matter its size) or does the compiler choose an existential container if it is greater than some given size (or perhaps even always, because it gives a good tradeoff?)<br>3. Then Arnold says that four existential containers pointing to the same value (greater than the value buffer) use 4 heap allocations. He proposes copy-on-write (using a local storage class), but **does he mean this should be implemented by hand or is this an optimization that the swift compiler does on its own?** The issue here is, that the switch between &quot;swift subscript&quot; for showing an abstraction of internals and real swift code that one should write is sometimes not clear. Doing this by hand has some clear disadvantages as this would add a reference to each usage of `Line` (and reference counting) even in the first examples of Kyle. Doing this as a compiler optimization would allow to use a struct in different scenarios and always the best tradeoff is used. Otherwise, I would perhaps even need to create two different types for different situations and choose it wisely. This would add a big burden on the developer.<br>4. If Arnold really means *manually* (see *3.*) and reference types are not stored in existential containers (see *1.*) the slides are wrong, because there a existential container is still used and the instance on the heap is named `Line` instead of `Line._storage`. So what is the case?<br>5. The implementations of `String` and `Array` seem to follow the copy-on-write strategy &quot;manually&quot;, but I think they do that because this behavior is wanted even if the values would be copied automatically (if this is true, the answer for *3.* would be *manually*). Or am I wrong here?<br>6. Is the Value-Witness-Table a (kind of) dictionary for all values of a given value type (bigger than the value buffer), so that you do not store any value twice on the heap, but share the reference? If this is the case the answer of *3.* should be *automatically*. But then again, the &quot;manual&quot; implementation of `String` and `Array` (see *4.*) make no sense anymore, does it? Or are `Array` and `String` implemented only on the lower-level and the copy-on-write implementation is not visible in their Swift implementation?<br>7. If you want to have a reference-type (like `NSData`) with value semantics, then I need to implement my own copy-on-write of course, but if I want to have it only on the swift-value-type level the compiler should be able to do it all by itself, shouldn&#39;t it?<br></p><p>I read some [posts like this one][1] describing how Swift implements value types in a manner, that is conflicting with some of the things Kyle and Arnold said on WWDC 2016 (see above). Did Swift’s implementation change here between v2 and v3 or what do you think? The articles interpretation of the changes of the memory address (and the padding ints for the address struct; see the post) suggest, that always an existential container is used for structs (see *2.*) and copy-on-write is done automatically (see *3.*)…<br></p><p>It would be great, if someone could give me the answers to these questions :). Thanks in advance.<br></p><p>All the best<br>Johannes<br></p><p>[0]: https://developer.apple.com/videos/play/wwdc2016/416/<br>[1]: https://www.raywenderlich.com/112029/reference-value-types-in-swift-part-2<br></p><p>--<br>Dr. Johannes Neubauer<br>E-Mail: neubauer at kingsware.de<br>WWW   : http://www.kingsware.de<br></p><p>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 496 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160714/e6dbae14/attachment.sig&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fbb2eb7db6aecac77ec563869540a874?s=50"></div><header><strong>Implementation of swift&#39;s value types</strong> from <string>Arnold</string> &lt;aschwaighofer at apple.com&gt;<p>July 14, 2016 at 02:00:00pm</p></header><div class="content"><p>Hi Johannes,<br></p><p>thank you for your questions. Answers inline.<br></p><p><br>&gt; On Jul 14, 2016, at 12:39 PM, Johannes Neubauer via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Dear Devs,<br>&gt; <br>&gt; I saw the WWDC 2016 video [Understanding Swift Performance][0] as well as some others regarding value types in swift of WWDC2015. I think there are a few ambiguities which make it hard both to decide which weapon to choose and to give proposition how to evolve this implementations to the better (swift-evolution).<br>&gt; <br>&gt; Is there a place, where low-level decisions in the language are documented? Is there an adequate place/forum where we can ask questions regarding low-level implementations?<br></p><p>I think here is a good place to ask such questions.<br></p><p>&gt; It would be great if you add a (moderated) comment section to each of the WWDC videos, so that we can discuss the contents (with transcript-like links) as well as an errata section containing a list of Apple-Approved mistakes/ambiguities in a given video/talk.<br>&gt; <br>&gt; # So, here come my questions<br>&gt; <br>&gt; In the talk [Understanding Swift Performance][0] Kyle says, that value types are put stored in the stack and copied. He uses a point and a line which are both copied. Lateron Arnold uses a similar example with protocols. Then the Existential Container is used, which either uses the value buffer (for small values like `Point`) or allocates some memory on the heap and adds a pointer to this value (e.g. for a `Line`):<br>&gt; <br>&gt; 1. If I have an object (instance of a class) in a variable (or a container like an array) of a protocol type, will it be stored into an Existential Container, too? Or are reference types always stored as a reference (storing it in an Existential Container makes more sense to me).<br></p><p>Yes, the reference to the instance is stored inside the existential container. It fits into the three word value buffer and not out of line allocation for the existential container’s value buffer is necessary.<br></p><p><br>&gt; 2. If I use a variable of the concrete type (although it implements a protocol), will it always be copied (no matter its size) or does the compiler choose an existential container if it is greater than some given size (or perhaps even always, because it gives a good tradeoff?)<br></p><p>Assuming you talk about value types like “struct Line”. Yes it will be copied. If you want to make the storage of a struct type indirect you have to wrap it in a class (similar to the IndirectStorage example).<br></p><p>&gt; 3. Then Arnold says that four existential containers pointing to the same value (greater than the value buffer) use 4 heap allocations. He proposes copy-on-write (using a local storage class), but **does he mean this should be implemented by hand or is this an optimization that the swift compiler does on its own?**<br></p><p>No the swift compiler does not do this on its own.<br></p><p>&gt; The issue here is, that the switch between &quot;swift subscript&quot; for showing an abstraction of internals and real swift code that one should write is sometimes not clear.<br></p><p>Sorry about this.<br></p><p>&gt; Doing this by hand has some clear disadvantages as this would add a reference to each usage of `Line` (and reference counting) even in the first examples of Kyle.<br></p><p>Yes, it is a tradeoff. Either, in the type erased context (as an instance of protocol value) copies are expensive for large value types and in the non generic/existential concrete context it is fast. Or you make the type have indirect storage with copy on write to preserve value semantics and then you have an overhead for reference counting.<br></p><p>You can get the best of both worlds if you write a wrapper.<br></p><p>All of this comes at the cost of a lot of boiler plate code and discussions are taking place how-to improve this situation.<br></p><p><br>&gt; Doing this as a compiler optimization would allow to use a struct in different scenarios and always the best tradeoff is used. Otherwise, I would perhaps even need to create two different types for different situations and choose it wisely. This would add a big burden on the developer.<br></p><p>There are things that we can do in the compiler (change the representation of generics and protocol values) that will improve the situation.<br></p><p>These would be future changes ...<br></p><p>&gt; 4. If Arnold really means *manually* (see *3.*) and reference types are not stored in existential containers (see *1.*) the slides are wrong, because there a existential container is still used and the instance on the heap is named `Line` instead of `Line._storage`. So what is the case?<br></p><p>Yes the suggestion was do manually do this. Reference types are stored in existential container.<br></p><p>&gt; 5. The implementations of `String` and `Array` seem to follow the copy-on-write strategy &quot;manually&quot;, but I think they do that because this behavior is wanted even if the values would be copied automatically (if this is true, the answer for *3.* would be *manually*). Or am I wrong here?<br></p><p>The answer to 3. is manually.<br></p><p>&gt; 6. Is the Value-Witness-Table a (kind of) dictionary for all values of a given value type (bigger than the value buffer), so that you do not store any value twice on the heap, but share the reference? If this is the case the answer of *3.* should be *automatically*. But then again, the &quot;manual&quot; implementation of `String` and `Array` (see *4.*) make no sense anymore, does it? Or are `Array` and `String` implemented only on the lower-level and the copy-on-write implementation is not visible in their Swift implementation?<br></p><p><br>I don’t full understand the question.<br></p><p>The value-witness-table exists per type and contains functions that describe how to copy, allocate, and deallocate values of that type.<br></p><p><br>The copy-on-write implementation is visible in standard library code for Array and String: array really calls isUniquelyReference for example before it does a subscript set.<br></p><p><br>&gt; 7. If you want to have a reference-type (like `NSData`) with value semantics, then I need to implement my own copy-on-write of course, but if I want to have it only on the swift-value-type level the compiler should be able to do it all by itself, shouldn&#39;t it?<br>&gt; <br>&gt; I read some [posts like this one][1] describing how Swift implements value types in a manner, that is conflicting with some of the things Kyle and Arnold said on WWDC 2016 (see above). Did Swift’s implementation change here between v2 and v3 or what do you think? The articles interpretation of the changes of the memory address (and the padding ints for the address struct; see the post) suggest, that always an existential container is used for structs (see *2.*) and copy-on-write is done automatically (see *3.*)…<br>&gt; <br>&gt; It would be great, if someone could give me the answers to these questions :). Thanks in advance.<br>&gt; <br></p><p><br>This blog post draws the wrong conclusion from what it observes. Plain struct types are not copy on write. But really create a copy.<br></p><p>The test case in the blog post really shows that the string stored in the variable “streetAddress” changes. He overlays the memory of “struct Address” with “struct AddressBits”. If you read &quot;bits1.underlyingPtr” you get whatever is the first 4/8bytes (32bit/64bit pointer platform) of the String struct instance stored  in Address.streetAddress. If you dig deep enough into the implementation of Swift’s string https://github.com/apple/swift/blob/master/stdlib/public/core/StringCore.swift. You will see that this is a variable that holds a pointer (the pointer to the String’s storage).<br></p><p>Best,<br>Arnold<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/067cee1a86dbe57d6de692dd39c6791b?s=50"></div><header><strong>Implementation of swift&#39;s value types</strong> from <string>Johannes Neubauer</string> &lt;neubauer at kingsware.de&gt;<p>July 15, 2016 at 01:00:00am</p></header><div class="content"><p>Hi Arnold,<br></p><p>Thank you and atrick at apple.com very much for your answers. That helps already a lot. Are you Arnold from the WWDC Video? I removed all the answers that are clear and have some follow-up questions inline.<br></p><p>&gt; Am 14.07.2016 um 23:02 schrieb Arnold Schwaighofer &lt;aschwaighofer at apple.com&gt;:<br>&gt; <br>&gt;&gt; 3. Then Arnold says that four existential containers pointing to the same value (greater than the value buffer) use 4 heap allocations. He proposes copy-on-write (using a local storage class), but **does he mean this should be implemented by hand or is this an optimization that the swift compiler does on its own?**<br>&gt; <br>&gt; No the swift compiler does not do this on its own.<br></p><p>Are there corresponding plans? Storing „big“ values (using some statistics to evaluate where the break-even is) as reference types always, storing them in a big table per type (each value occurs only once) should be possible, right? Is this something I should post on the swift-evolution mailing list?<br></p><p>&gt; <br>&gt;&gt; The issue here is, that the switch between &quot;swift subscript&quot; for showing an abstraction of internals and real swift code that one should write is sometimes not clear.<br>&gt; <br>&gt; Sorry about this.<br></p><p>This was meant as positive criticism. I really like the video!<br></p><p>&gt; <br>&gt;&gt; Doing this by hand has some clear disadvantages as this would add a reference to each usage of `Line` (and reference counting) even in the first examples of Kyle.<br>&gt; <br>&gt; Yes, it is a tradeoff. Either, in the type erased context (as an instance of protocol value) copies are expensive for large value types and in the non generic/existential concrete context it is fast.<br></p><p>Is it really fast in the latter context for „big“ values? All collection types use copy-on-write. Especially if you have a lot of reference type properties copying seems to be slow even in the latter context. And since all collection types (including String) are backed by a reference type, even properties of these type incur additional reference counting.<br></p><p>&gt; Or you make the type have indirect storage with copy on write to preserve value semantics and then you have an overhead for reference counting.<br>&gt; <br>&gt; You can get the best of both worlds if you write a wrapper.<br>&gt; <br>&gt; All of this comes at the cost of a lot of boiler plate code and discussions are taking place how-to improve this situation.<br></p><p>Are there already proposals available or is it still in early discussions? Can you give me a hint where to find more about it?<br></p><p>&gt; <br>&gt;&gt; 6. Is the Value-Witness-Table a (kind of) dictionary for all values of a given value type (bigger than the value buffer), so that you do not store any value twice on the heap, but share the reference? If this is the case the answer of *3.* should be *automatically*. But then again, the &quot;manual&quot; implementation of `String` and `Array` (see *4.*) make no sense anymore, does it? Or are `Array` and `String` implemented only on the lower-level and the copy-on-write implementation is not visible in their Swift implementation?<br>&gt; <br>&gt; <br>&gt; I don’t full understand the question.<br>&gt; <br>&gt; The value-witness-table exists per type and contains functions that describe how to copy, allocate, and deallocate values of that type.<br></p><p>OK. I am still a little bit unsure what it is now. Andrew Trick says:<br></p><p>&gt; A value witness table is a dictionary for all values of a type regardless of whether it fits in a buffer.<br>&gt; The keys are operations that can be done to any value (copy/destroy), the implementation for<br>&gt; that type knows where the value is stored.<br></p><p>In the example Arnold (you?) used the value witness table to copy the value (see slide 171 last line of code):<br></p><p>```swift<br>pwt.draw(vwt.projectBuffer(&amp;local))<br>```<br></p><p>Since I didn’t know that the „storage“-trick is done manually, I thought there is a (hash)table/dictionary of all values of a „big“ value type where each value is uniquely stored (constant time access). For „small“ values it would just point, to the concrete value of this very value. As mentioned above: should I post this on the swift-evolution mailing list?<br></p><p>All the best<br>Johannes<br></p><p>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 496 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160715/27d8ce03/attachment.sig&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fbb2eb7db6aecac77ec563869540a874?s=50"></div><header><strong>Implementation of swift&#39;s value types</strong> from <string>Arnold</string> &lt;aschwaighofer at apple.com&gt;<p>July 14, 2016 at 05:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On Jul 14, 2016, at 4:04 PM, Johannes Neubauer &lt;neubauer at kingsware.de&gt; wrote:<br>&gt; <br>&gt; Hi Arnold,<br>&gt; <br>&gt; Thank you and atrick at apple.com very much for your answers. That helps already a lot. Are you Arnold from the WWDC Video?<br></p><p>Yes.<br></p><p>&gt; I removed all the answers that are clear and have some follow-up questions inline.<br>&gt; <br>&gt;&gt;&gt; Am 14.07.2016 um 23:02 schrieb Arnold Schwaighofer &lt;aschwaighofer at apple.com&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 3. Then Arnold says that four existential containers pointing to the same value (greater than the value buffer) use 4 heap allocations. He proposes copy-on-write (using a local storage class), but **does he mean this should be implemented by hand or is this an optimization that the swift compiler does on its own?**<br>&gt;&gt; <br>&gt;&gt; No the swift compiler does not do this on its own.<br>&gt; <br>&gt; Are there corresponding plans? Storing „big“ values (using some statistics to evaluate where the break-even is) as reference types always, storing them in a big table per type (each value occurs only once) should be possible, right? Is this something I should post on the swift-evolution mailing list?<br></p><p>No hashed out plans only discussions on hallways. The swift team  focuses on finishing up swift 3.<br></p><p>But yes, similar ideas are being discussed.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; The issue here is, that the switch between &quot;swift subscript&quot; for showing an abstraction of internals and real swift code that one should write is sometimes not clear.<br>&gt;&gt; <br>&gt;&gt; Sorry about this.<br>&gt; <br>&gt; This was meant as positive criticism. I really like the video!<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Doing this by hand has some clear disadvantages as this would add a reference to each usage of `Line` (and reference counting) even in the first examples of Kyle.<br>&gt;&gt; <br>&gt;&gt; Yes, it is a tradeoff. Either, in the type erased context (as an instance of protocol value) copies are expensive for large value types and in the non generic/existential concrete context it is fast.<br>&gt; <br>&gt; Is it really fast in the latter context for „big“ values?<br></p><p><br>I was being imprecise. I meant big plain POD types - a struct that contains only non-reference counted values.<br></p><p>As soon as you have more than one reference in your struct indirection will typically be cheaper - just looking at reference counting.<br></p><p>This a simplification that might overlook specific cases where this is not necessarily true. (The swift compiler can flatten structs to its individual member properties -- scalarize the struct -- and that can lead to better optimization ...)<br></p><p><br>&gt; All collection types use copy-on-write. Especially if you have a lot of reference type properties copying seems to be slow even in the latter context. And since all collection types (including String) are backed by a reference type, even properties of these type incur additional reference counting.<br></p><p>Yes. Correct.<br>&gt; <br>&gt;&gt; Or you make the type have indirect storage with copy on write to preserve value semantics and then you have an overhead for reference counting.<br>&gt;&gt; <br>&gt;&gt; You can get the best of both worlds if you write a wrapper.<br>&gt;&gt; <br>&gt;&gt; All of this comes at the cost of a lot of boiler plate code and discussions are taking place how-to improve this situation.<br>&gt; <br>&gt; Are there already proposals available or is it still in early discussions? Can you give me a hint where to find more about it?<br></p><p>No proposals at the moment.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; 6. Is the Value-Witness-Table a (kind of) dictionary for all values of a given value type (bigger than the value buffer), so that you do not store any value twice on the heap, but share the reference? If this is the case the answer of *3.* should be *automatically*. But then again, the &quot;manual&quot; implementation of `String` and `Array` (see *4.*) make no sense anymore, does it? Or are `Array` and `String` implemented only on the lower-level and the copy-on-write implementation is not visible in their Swift implementation?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I don’t full understand the question.<br>&gt;&gt; <br>&gt;&gt; The value-witness-table exists per type and contains functions that describe how to copy, allocate, and deallocate values of that type.<br>&gt; <br>&gt; OK. I am still a little bit unsure what it is now. Andrew Trick says:<br>&gt; <br>&gt;&gt; A value witness table is a dictionary for all values of a type regardless of whether it fits in a buffer.<br>&gt;&gt; The keys are operations that can be done to any value (copy/destroy), the implementation for<br>&gt;&gt; that type knows where the value is stored.<br>&gt; <br></p><p>This is an abstract description that does not contradict mine.<br>Conceptually the value witness table is a dictionary (value witness&#39;s function kind to implementation). It is implemented as a block of memory (a table) that contains pointers to functions. At offset 2 (made up I would have to lookup what the offset is) say you will find the function that knows how to allocate memory for that type.<br>For an Int this function will just return a pointer into the inline value buffer.<br></p><p>For a struct of 4 integers this function will malloc memory on the heap store the pointer into the online value buffer and will return that pointer.<br></p><p><br>&gt; In the example Arnold (you?) used the value witness table to copy the value (see slide 171 last line of code):<br>&gt; <br>&gt; ```swift<br>&gt; pwt.draw(vwt.projectBuffer(&amp;local))<br>&gt; ```<br>&gt; <br>&gt; Since I didn’t know that the „storage“-trick is done manually, I thought there is a (hash)table/dictionary of all values of a „big“ value type where each value is uniquely stored (constant time access).<br></p><p>No this is not how it works.<br></p><p>Buffers for big values are created when we create a protocol value. This code is not clever. It allocates memory on the heap and copies the value&#39;s storage to that heap memory.<br></p><p>&gt; For „small“ values it would just point, to the concrete value of this very value. As mentioned above: should I post this on the swift-evolution mailing list?<br>&gt; <br>&gt; All the best<br>&gt; Johannes<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/067cee1a86dbe57d6de692dd39c6791b?s=50"></div><header><strong>Implementation of swift&#39;s value types</strong> from <string>Johannes Neubauer</string> &lt;neubauer at kingsware.de&gt;<p>July 15, 2016 at 06:00:00pm</p></header><div class="content"><p>Hi Arnold,<br></p><p>&gt; Am 15.07.2016 um 02:17 schrieb Arnold &lt;aschwaighofer at apple.com&gt;:<br>&gt; <br>&gt;&gt; On Jul 14, 2016, at 4:04 PM, Johannes Neubauer &lt;neubauer at kingsware.de&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi Arnold,<br>&gt;&gt; <br>&gt;&gt; Thank you and atrick at apple.com very much for your answers. That helps already a lot. Are you Arnold from the WWDC Video?<br>&gt; <br>&gt; Yes.<br></p><p>Cool. Thank you for the great answers. Last words to this topic inline:<br></p><p>&gt;&gt; Are there corresponding plans? Storing „big“ values (using some statistics to evaluate where the break-even is) as reference types always, storing them in a big table per type (each value occurs only once) should be possible, right? Is this something I should post on the swift-evolution mailing list?<br>&gt; <br>&gt; No hashed out plans only discussions on hallways. The swift team  focuses on finishing up swift 3.<br>&gt; <br>&gt; But yes, similar ideas are being discussed.<br></p><p>AFAIK the JVM does such things for Strings (they call it a pool not a table) and they use a pool of values as reference types for inboxing/outboxing of primitive types to their Wrapper class counterparts (in order to speed this process up). So if you put an `int` into a method that expects an `Integer` they lookup the corresponding instance of the Wrapper type and return it.<br></p><p>&gt; This a simplification that might overlook specific cases where this is not necessarily true. (The swift compiler can flatten structs to its individual member properties -- scalarize the struct -- and that can lead to better optimization …)<br></p><p>OK. Good to know.<br></p><p>&gt;&gt; Are there already proposals available or is it still in early discussions? Can you give me a hint where to find more about it?<br>&gt; <br>&gt; No proposals at the moment.<br></p><p>Is there some documentation of the current implementation of Existential Container, Protocol Witness Table, and co.? Where do I find it?<br></p><p>&gt; <br>&gt; This is an abstract description that does not contradict mine.<br>&gt; Conceptually the value witness table is a dictionary (value witness&#39;s function kind to implementation). It is implemented as a block of memory (a table) that contains pointers to functions. At offset 2 (made up I would have to lookup what the offset is) say you will find the function that knows how to allocate memory for that type.<br>&gt; For an Int this function will just return a pointer into the inline value buffer.<br>&gt; <br>&gt; For a struct of 4 integers this function will malloc memory on the heap store the pointer into the online value buffer and will return that pointer.<br></p><p>OK, so this table contains 4 entries alloc/dealloc, copy, and destroy and is not a table of all values. I got it.<br></p><p>&gt; Buffers for big values are created when we create a protocol value. This code is not clever. It allocates memory on the heap and copies the value&#39;s storage to that heap memory.<br></p><p>OK. Thanks.<br></p><p>All the best<br>Johannes<br></p><p>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 496 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160715/9b429391/attachment.sig&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>Implementation of swift&#39;s value types</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>July 15, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jul 15, 2016, at 9:25 AM, Johannes Neubauer via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Is there some documentation of the current implementation of Existential Container, Protocol Witness Table, and co.? Where do I find it?<br></p><p>Arnold’s slides are the best I’ve seen!<br></p><p>There are some internal details here:<br>https://github.com/apple/swift/blob/master/docs/SIL.rst<br>https://github.com/apple/swift/blob/master/docs/ABI.rst &lt;https://github.com/apple/swift/blob/master/docs/ABI.rst&gt;<br></p><p>-Andy<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160715/a9eee4ad/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>Implementation of swift&#39;s value types</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>July 14, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jul 14, 2016, at 12:39 PM, Johannes Neubauer via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Dear Devs,<br>&gt; <br>&gt; I saw the WWDC 2016 video [Understanding Swift Performance][0] as well as some others regarding value types in swift of WWDC2015. I think there are a few ambiguities which make it hard both to decide which weapon to choose and to give proposition how to evolve this implementations to the better (swift-evolution).<br>&gt; <br>&gt; Is there a place, where low-level decisions in the language are documented? Is there an adequate place/forum where we can ask questions regarding low-level implementations? It would be great if you add a (moderated) comment section to each of the WWDC videos, so that we can discuss the contents (with transcript-like links) as well as an errata section containing a list of Apple-Approved mistakes/ambiguities in a given video/talk.<br>&gt; <br>&gt; # So, here come my questions<br>&gt; <br>&gt; In the talk [Understanding Swift Performance][0] Kyle says, that value types are put stored in the stack and copied. He uses a point and a line which are both copied. Lateron Arnold uses a similar example with protocols. Then the Existential Container is used, which either uses the value buffer (for small values like `Point`) or allocates some memory on the heap and adds a pointer to this value (e.g. for a `Line`):<br>&gt; <br>&gt; 1. If I have an object (instance of a class) in a variable (or a container like an array) of a protocol type, will it be stored into an Existential Container, too? Or are reference types always stored as a reference (storing it in an Existential Container makes more sense to me).<br></p><p>In that case the value stored in the existential container is just the reference. There’s no additional heap allocation.<br></p><p>Promoting objects to the stack is a separate thing that I think will only happen if the existential container is already optimized away.<br></p><p>&gt; 2. If I use a variable of the concrete type (although it implements a protocol), will it always be copied (no matter its size) or does the compiler choose an existential container if it is greater than some given size (or perhaps even always, because it gives a good tradeoff?)<br></p><p>A value&#39;s representation starts off as the representation for whatever type is in the declaration. For something declared as a struct, it’s irrelevant whether the type also conforms to a protocol. We don’t yet provide a language feature or optimization for indirect copy-on-write struct storage.<br></p><p>&gt; 3. Then Arnold says that four existential containers pointing to the same value (greater than the value buffer) use 4 heap allocations. He proposes copy-on-write (using a local storage class), but **does he mean this should be implemented by hand or is this an optimization that the swift compiler does on its own?** The issue here is, that the switch between &quot;swift subscript&quot; for showing an abstraction of internals and real swift code that one should write is sometimes not clear. Doing this by hand has some clear disadvantages as this would add a reference to each usage of `Line` (and reference counting) even in the first examples of Kyle. Doing this as a compiler optimization would allow to use a struct in different scenarios and always the best tradeoff is used. Otherwise, I would perhaps even need to create two different types for different situations and choose it wisely. This would add a big burden on the developer.<br></p><p>It needs be done by hand because the compiler doesn’t do it. The compiler *should* do it in the sense that it would make the world a better place.<br></p><p>&gt; 4. If Arnold really means *manually* (see *3.*) and reference types are not stored in existential containers (see *1.*) the slides are wrong, because there a existential container is still used and the instance on the heap is named `Line` instead of `Line._storage`. So what is the case?<br></p><p>I don’t have the slides in front of me, but the instance is always on the heap (modulo stack promotion, which doesn’t happen for existentials). The reference to the instance is in the container.<br></p><p>&gt; 5. The implementations of `String` and `Array` seem to follow the copy-on-write strategy &quot;manually&quot;, but I think they do that because this behavior is wanted even if the values would be copied automatically (if this is true, the answer for *3.* would be *manually*). Or am I wrong here?<br></p><p>There’s no observable behavior to copy-on-write other than the program running much faster.<br></p><p>&gt; 6. Is the Value-Witness-Table a (kind of) dictionary for all values of a given value type (bigger than the value buffer), so that you do not store any value twice on the heap, but share the reference? If this is the case the answer of *3.* should be *automatically*. But then again, the &quot;manual&quot; implementation of `String` and `Array` (see *4.*) make no sense anymore, does it? Or are `Array` and `String` implemented only on the lower-level and the copy-on-write implementation is not visible in their Swift implementation?<br></p><p>A value witness table is a dictionary for all values of a type regardless of whether it fits in a buffer. The keys are operations that can be done to any value (copy/destroy), the implementation for that type knows where the value is stored.<br></p><p>&gt; 7. If you want to have a reference-type (like `NSData`) with value semantics, then I need to implement my own copy-on-write of course, but if I want to have it only on the swift-value-type level the compiler should be able to do it all by itself, shouldn&#39;t it?<br></p><p>Someone else can provide a better answer. I’ll say that the compiler *should* be able to do it in the sense that the world would be better off for it…<br></p><p>-Andy<br></p><p>&gt; I read some [posts like this one][1] describing how Swift implements value types in a manner, that is conflicting with some of the things Kyle and Arnold said on WWDC 2016 (see above). Did Swift’s implementation change here between v2 and v3 or what do you think? The articles interpretation of the changes of the memory address (and the padding ints for the address struct; see the post) suggest, that always an existential container is used for structs (see *2.*) and copy-on-write is done automatically (see *3.*)…<br>&gt; <br>&gt; It would be great, if someone could give me the answers to these questions :). Thanks in advance.<br>&gt; <br>&gt; All the best<br>&gt; Johannes<br>&gt; <br>&gt; [0]: https://developer.apple.com/videos/play/wwdc2016/416/<br>&gt; [1]: https://www.raywenderlich.com/112029/reference-value-types-in-swift-part-2<br>&gt; <br>&gt; --<br>&gt; Dr. Johannes Neubauer<br>&gt; E-Mail: neubauer at kingsware.de<br>&gt; WWW   : http://www.kingsware.de<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
