<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Proposal draft] Conditional conformances</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>September 30, 2016 at 08:00:00pm</p></header><div class="content"><p>on Fri Sep 30 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; It’s a valid concern, and I’m sure it does come up in practice. Let’s create a small, self-contained example:<br>&gt;&gt; <br>&gt;&gt; protocol P {<br>&gt;&gt;   func f()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; protocol Q: P { }<br>&gt;&gt; <br>&gt;&gt; struct X&lt;T&gt; { let t: T}<br>&gt;&gt; <br>&gt;&gt; extension X: P where T: P {<br>&gt;&gt;   func f() {<br>&gt;&gt;     /* general but slow */<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension X where T: Q {<br>&gt;&gt;   func f() {<br>&gt;&gt;     /* fast because it takes advantage of T: Q */<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct IsQ : Q { }<br>&gt;&gt; <br>&gt;&gt; func generic&lt;U: P&gt;(_ value: u) {<br>&gt;&gt;   value.f()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; generic(X&lt;IsQ&gt;())<br>&gt;&gt; <br>&gt;&gt; We’d like for the call to “value.f()” to get the fast version of f()<br>&gt;&gt; from the second extension, but the proposal doesn’t do that: the<br>&gt;&gt; conformance to P is “locked in” to the first extension.<br></p><p>I suppose that&#39;s true even if the second extension introduces X : Q?<br></p><p>&gt;&gt; If we assume that we can see all of the potential implementations of<br>&gt;&gt; “f” to which we might want to dispatch, we could implement some<br>&gt;&gt; dynamic scheme that tries to pick the most specialized one. Of<br>&gt;&gt; course, as with overlapping conformances in general, this selection<br>&gt;&gt; process could result in ambiguities.<br>&gt;<br>&gt; This is what I suspected.  I’ll defer to Dave A on how big a concern<br>&gt; this is, but it seems to me like a bit of a slippery slope towards<br>&gt; sub-optimal performance.<br></p><p>Well, it&#39;s unfortunate.  We have a similar problem today due to the lack<br>of conditional conformance, and we deal with it by injecting an<br>underscored requirement where it doesn&#39;t belong, then dispatch through<br>that.  I wonder if the workaround for this limitation is like that, or<br>something completely different.<br></p><p>Does this work?  If not, why not?  If so, what makes it fundamentally<br>different, since it is trying to express the same thing through<br>different means?<br></p><p>-----<br></p><p>public protocol P {<br>  func f()<br>}<br></p><p>public protocol Q: P { }<br></p><p>public struct X&lt;T&gt; { let t: T}<br></p><p>internal protocol XFImpl {<br>  associatedtype TT: P<br>  static func f(X&lt;T&gt;)<br>}<br></p><p>extension XFImpl {<br> static func f(X&lt;TT&gt;) { /* general but slow */ }<br>}<br></p><p>extension XFImpl where TT: Q {<br>  static func f(X&lt;TT&gt;) { /* fast because it takes advantage of T: Q */ }<br>}<br></p><p>extension X: P where T: P {<br>  struct FImpl : XFImpl {<br>    typealias TT = T<br>  }<br></p><p>  func f() {<br>    FImpl.f(self)<br>  }<br>}<br></p><p>struct IsQ : Q { }<br></p><p>func generic&lt;U: P&gt;(_ value: u) {<br>  value.f()<br>}<br></p><p>generic(X&lt;IsQ&gt;())<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6b81089e81d6bb1e14b5adb746725de1?s=50"></div><header><strong>[Proposal draft] Conditional conformances</strong> from <string>Alexis</string> &lt;abeingessner at apple.com&gt;<p>October  3, 2016 at 03:00:00pm</p></header><div class="content"><p>Below I’ve provided a more fleshed out version of what Dave is suggesting, for anyone who had trouble parsing the very hypothetical example. It reflects the kind of implementation specialization I would expect to see in the standard library. In fact we have exactly this concern baked into value witness tables today by differentiating the various *Buffer methods so that they can be no-ops or memcpys for trivial values (rather than requiring code to loop over all the elements and call potentially-no-op methods on each element).<br></p><p>But the value witness table’s approach to this problem suggests some healthier solutions to the problem (for Swift’s particular set of constraints):<br></p><p>1) Add default-implemented fullAlgorithm() methods to the protocol. Anyone who can beat the default algorithm provides their own implementation. Consumers of the protocol then dispatch to fullAlgorithm(), rather than the lower-level primitives.<br></p><p>2) Add “let hasInterestingProperty: bool” flags to the protocol. Consumers of the protocol can then branch on these flags to choose a “slow generic” or “fast specific” implementation. (this is, after all, exactly what we’re asking the runtime to do for us!)<br></p><p>Of course, (1) and (2) aren’t always applicable solutions. Both only really apply if you’re the original creator of the protocol; otherwise no one will know about fullAlgorithm or hasInterestingProperty and be able to modify the default. It can also be really tedious to provide your own implementation of fullAlgorithm(), especially if everyone overloads it in the same way. These are, however, perfectly reasonable approaches if you’re just trying to specialize for a small, closed, set of types. Something like:<br></p><p>genericImpl()<br>stringImpl()<br>intImpl()<br></p><p>You can handle that pretty easily with extensions or super-protocols, I think.<br></p><p>I’m cautiously optimistic we can get pretty far before we really feel the need to introduce specialization like this. Although I’m used to handling this issue in a world of monomorphic generics; so I’m not sure if the performance characteristics of polymorphic generics will shift the balance to making specialization more urgent. Or perhaps the opposite — the runtime impact of specialization could be too high!<br></p><p><br>// Some kind of &quot;super copy&quot; operation<br>public protocol Clone {<br>  func clone() -&gt; Self<br>}<br></p><p>// Can just memcpy instead of calling Clone<br>public protocol TrivialClone: Clone { }<br></p><p>// A terrible data structure<br>public struct FakeArray&lt;T&gt; { let vals: (T, T, T) }<br></p><p><br></p><p>// --------------------------------------------------<br>// A dirty hack to get overlapping impls (specifically specialization)<br>// through overlapping extensions.<br></p><p>internal protocol CloneImpl {<br>  associatedtype TT: Clone<br>}<br></p><p>extension CloneImpl {<br>  static func clone(input: FakeArray&lt;TT&gt;) -&gt; FakeArray&lt;TT&gt; {<br>    // Have to manually invoke generic `clone` on each element<br>    FakeArray(vals: (input.vals.0.clone(),<br>                     input.vals.1.clone(),<br>                     input.vals.2.clone()))<br>  }<br>}<br></p><p>extension CloneImpl where TT: TrivialClone {<br>  static func clone(input: FakeArray&lt;TT&gt;) -&gt; FakeArray&lt;TT&gt; {<br>    // Can just copy the whole buffer at once (ideally a memcpy)<br>    FakeArray(vals: input.vals)<br>  }<br>}<br></p><p><br>// Inject our specialized Clone impl<br>// (doesn&#39;t compile today because this is a conditional conformance)<br>extension FakeArray: Clone where T: Clone {<br>  // A dummy to get our overlapping extensions<br>  // (doesn&#39;t compile today because we can&#39;t nest types in a generic type)<br>  struct CloneImplProvider : CloneImpl {<br>    typealias TT = T<br>  }<br>  <br>  func clone() -&gt; FakeArray {<br>    CloneImplProvider.clone(input: self)<br>  }<br>}<br></p><p>// -------------------------------------------------<br>// Using Clone and the specialization<br></p><p>// Some plain-old-data<br>struct POD : TrivialClone {<br>  func clone() -&gt; POD { return self }<br>}<br></p><p>// Works with any Clone type<br>func generic&lt;T: Clone&gt;(_ value: T) -&gt; T {<br>  return value.clone()<br>}<br></p><p>// Pass in a FakeArray that should use the fast specialization for Clone<br>generic(FakeArray(vals: (POD(), POD(), POD())))<br></p><p><br></p><p><br>&gt; On Sep 30, 2016, at 11:18 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Fri Sep 30 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; It’s a valid concern, and I’m sure it does come up in practice. Let’s create a small, self-contained example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;  func f()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol Q: P { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct X&lt;T&gt; { let t: T}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension X: P where T: P {<br>&gt;&gt;&gt;  func f() {<br>&gt;&gt;&gt;    /* general but slow */<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension X where T: Q {<br>&gt;&gt;&gt;  func f() {<br>&gt;&gt;&gt;    /* fast because it takes advantage of T: Q */<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct IsQ : Q { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func generic&lt;U: P&gt;(_ value: u) {<br>&gt;&gt;&gt;  value.f()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; generic(X&lt;IsQ&gt;())<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We’d like for the call to “value.f()” to get the fast version of f()<br>&gt;&gt;&gt; from the second extension, but the proposal doesn’t do that: the<br>&gt;&gt;&gt; conformance to P is “locked in” to the first extension.<br>&gt; <br>&gt; I suppose that&#39;s true even if the second extension introduces X : Q?<br>&gt; <br>&gt;&gt;&gt; If we assume that we can see all of the potential implementations of<br>&gt;&gt;&gt; “f” to which we might want to dispatch, we could implement some<br>&gt;&gt;&gt; dynamic scheme that tries to pick the most specialized one. Of<br>&gt;&gt;&gt; course, as with overlapping conformances in general, this selection<br>&gt;&gt;&gt; process could result in ambiguities.<br>&gt;&gt; <br>&gt;&gt; This is what I suspected.  I’ll defer to Dave A on how big a concern<br>&gt;&gt; this is, but it seems to me like a bit of a slippery slope towards<br>&gt;&gt; sub-optimal performance.<br>&gt; <br>&gt; Well, it&#39;s unfortunate.  We have a similar problem today due to the lack<br>&gt; of conditional conformance, and we deal with it by injecting an<br>&gt; underscored requirement where it doesn&#39;t belong, then dispatch through<br>&gt; that.  I wonder if the workaround for this limitation is like that, or<br>&gt; something completely different.<br>&gt; <br>&gt; Does this work?  If not, why not?  If so, what makes it fundamentally<br>&gt; different, since it is trying to express the same thing through<br>&gt; different means?<br>&gt; <br>&gt; -----<br>&gt; <br>&gt; public protocol P {<br>&gt;  func f()<br>&gt; }<br>&gt; <br>&gt; public protocol Q: P { }<br>&gt; <br>&gt; public struct X&lt;T&gt; { let t: T}<br>&gt; <br>&gt; internal protocol XFImpl {<br>&gt;  associatedtype TT: P<br>&gt;  static func f(X&lt;T&gt;)<br>&gt; }<br>&gt; <br>&gt; extension XFImpl {<br>&gt; static func f(X&lt;TT&gt;) { /* general but slow */ }<br>&gt; }<br>&gt; <br>&gt; extension XFImpl where TT: Q {<br>&gt;  static func f(X&lt;TT&gt;) { /* fast because it takes advantage of T: Q */ }<br>&gt; }<br>&gt; <br>&gt; extension X: P where T: P {<br>&gt;  struct FImpl : XFImpl {<br>&gt;    typealias TT = T<br>&gt;  }<br>&gt; <br>&gt;  func f() {<br>&gt;    FImpl.f(self)<br>&gt;  }<br>&gt; }<br>&gt; <br>&gt; struct IsQ : Q { }<br>&gt; <br>&gt; func generic&lt;U: P&gt;(_ value: u) {<br>&gt;  value.f()<br>&gt; }<br>&gt; <br>&gt; generic(X&lt;IsQ&gt;())<br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161003/980414db/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Proposal draft] Conditional conformances</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>October  3, 2016 at 12:00:00pm</p></header><div class="content"><p>on Mon Oct 03 2016, Alexis &lt;abeingessner-AT-apple.com&gt; wrote:<br></p><p>&gt; Below I’ve provided a more fleshed out version of what Dave is<br>&gt; suggesting, for anyone who had trouble parsing the very hypothetical<br>&gt; example. It reflects the kind of implementation specialization I would<br>&gt; expect to see in the standard library. <br></p><p>Thanks, Alexis.<br></p><p>Doug and I talked this morning and fortunately I think we came up with<br>something rational that will support the kind of specialization we want<br>without any hoop-jumping.  It basically involves precomputing the<br>overload lattice and filling witness tables dynamically based on the<br>conformances that are statically visible at the moment they are<br>instantiated.  We&#39;ll post more detail soon.<br></p><p>-- <br>-Dave<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
