<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5f8978dbb959b069613e2d027420615f?s=50"></div><header><strong>SIL proposal: remove multiple results from SILValue</strong> from <string>Erik Eckstein</string> &lt;eeckstein at apple.com&gt;<p>December  4, 2015 at 09:00:00am</p></header><div class="content"><p>Hi,<br></p><p>currently some instructions, like alloc_stack and alloc_box (I think they are the only ones) return 2 values. For this we have the &quot;result number&quot; in SILValue, e.g. %3#0, %3#1<br></p><p>We could represent the same by using a projection instruction, e.g.<br></p><p> %3 = alloc_stack $Type  // == the old %3#0<br> %4 = project_stack %1   // == the old %3#1<br></p><p>And actually we already have the project_box instruction.<br></p><p>This would simplify SILValues and many places in optimization passes/analysis. Yesterday I spent several hours to debug a problem where in some pass the wrong result number was used.<br></p><p>What do you think?<br></p><p>Erik<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>SIL proposal: remove multiple results from SILValue</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December  4, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 4, 2015, at 9:06 AM, Erik Eckstein &lt;eeckstein at apple.com&gt; wrote:<br>&gt; Hi,<br>&gt; <br>&gt; currently some instructions, like alloc_stack and alloc_box (I think they are the only ones) return 2 values. For this we have the &quot;result number&quot; in SILValue, e.g. %3#0, %3#1<br>&gt; <br>&gt; We could represent the same by using a projection instruction, e.g.<br>&gt; <br>&gt; %3 = alloc_stack $Type  // == the old %3#0<br>&gt; %4 = project_stack %1   // == the old %3#1<br>&gt; <br>&gt; And actually we already have the project_box instruction.<br>&gt; <br>&gt; This would simplify SILValues and many places in optimization passes/analysis. Yesterday I spent several hours to debug a problem where in some pass the wrong result number was used.<br>&gt; <br>&gt; What do you think?<br></p><p>This would mean generating a lot of extra instructions for a lot of very common cases, like alloc_stack.<br></p><p>Was your bug related to the implicit conversion of a SILInstruction* -&gt; SILValue that silently uses result 0?  I?ve been thinking for a while that we should make that conditional on the SILInstruction having exactly one result.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5f8978dbb959b069613e2d027420615f?s=50"></div><header><strong>SIL proposal: remove multiple results from SILValue</strong> from <string>Erik Eckstein</string> &lt;eeckstein at apple.com&gt;<p>December  4, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 4, 2015, at 9:34 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 4, 2015, at 9:06 AM, Erik Eckstein &lt;eeckstein at apple.com&gt; wrote:<br>&gt;&gt; Hi,<br>&gt;&gt; <br>&gt;&gt; currently some instructions, like alloc_stack and alloc_box (I think they are the only ones) return 2 values. For this we have the &quot;result number&quot; in SILValue, e.g. %3#0, %3#1<br>&gt;&gt; <br>&gt;&gt; We could represent the same by using a projection instruction, e.g.<br>&gt;&gt; <br>&gt;&gt; %3 = alloc_stack $Type  // == the old %3#0<br>&gt;&gt; %4 = project_stack %1   // == the old %3#1<br>&gt;&gt; <br>&gt;&gt; And actually we already have the project_box instruction.<br>&gt;&gt; <br>&gt;&gt; This would simplify SILValues and many places in optimization passes/analysis. Yesterday I spent several hours to debug a problem where in some pass the wrong result number was used.<br>&gt;&gt; <br>&gt;&gt; What do you think?<br>&gt; <br>&gt; This would mean generating a lot of extra instructions for a lot of very common cases, like alloc_stack.<br></p><p>A quick grep on the optimized stdlib sil shows that we would need only about 5% more instructions. And probably a smaller fraction of more instruction-related memory, because the project_* instructions are small.<br>About compile time, I&#39;m not sure. On the one hand we will have more instructions, on the other hand we would not have to mask out the ValueDef/ResultNumbers from SILValue every time we use it.<br>IMO this is a reasonable tradeoff for making the SIL simpler.<br></p><p>&gt; <br>&gt; Was your bug related to the implicit conversion of a SILInstruction* -&gt; SILValue that silently uses result 0?  I?ve been thinking for a while that we should make that conditional on the SILInstruction having exactly one result.<br></p><p>Some sort of: it was a value.getDef() which should just be the value.<br></p><p><br>&gt; <br>&gt; John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>SIL proposal: remove multiple results from SILValue</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December  4, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 4, 2015, at 9:51 AM, Erik Eckstein &lt;eeckstein at apple.com&gt; wrote:<br>&gt;&gt; On Dec 4, 2015, at 9:34 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 4, 2015, at 9:06 AM, Erik Eckstein &lt;eeckstein at apple.com&gt; wrote:<br>&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; currently some instructions, like alloc_stack and alloc_box (I think they are the only ones) return 2 values. For this we have the &quot;result number&quot; in SILValue, e.g. %3#0, %3#1<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We could represent the same by using a projection instruction, e.g.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; %3 = alloc_stack $Type  // == the old %3#0<br>&gt;&gt;&gt; %4 = project_stack %1   // == the old %3#1<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And actually we already have the project_box instruction.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This would simplify SILValues and many places in optimization passes/analysis. Yesterday I spent several hours to debug a problem where in some pass the wrong result number was used.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What do you think?<br>&gt;&gt; <br>&gt;&gt; This would mean generating a lot of extra instructions for a lot of very common cases, like alloc_stack.<br>&gt; <br>&gt; A quick grep on the optimized stdlib sil shows that we would need only about 5% more instructions.<br></p><p>I have no idea what that?s supposed to tell us, though, because that?s purely the end result of an optimization pipeline that?s heavily focused on removing alloc_stack, alloc_box, etc.<br></p><p>&gt; About compile time, I&#39;m not sure. On the one hand we will have more instructions, on the other hand we would not have to mask out the ValueDef/ResultNumbers from SILValue every time we use it.<br></p><p>If that?s important (and masking is really cheap, but maybe it?s important), there are other representational differences we could make that would optimize that.  For example, we could split the use lists, so that each result stores its type and use list (meaning that instructions without results don?t need use lists at all).<br></p><p>&gt; IMO this is a reasonable tradeoff for making the SIL simpler.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Was your bug related to the implicit conversion of a SILInstruction* -&gt; SILValue that silently uses result 0?  I?ve been thinking for a while that we should make that conditional on the SILInstruction having exactly one result.<br>&gt; <br>&gt; Some sort of: it was a value.getDef() which should just be the value.<br></p><p>Okay, but that?s what I mean: we should go through and make sure that its generally not possible to accidentally use a SILInstruction with multiple (or zero) results in any position where you really need a specific SILValue.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5f8978dbb959b069613e2d027420615f?s=50"></div><header><strong>SIL proposal: remove multiple results from SILValue</strong> from <string>Erik Eckstein</string> &lt;eeckstein at apple.com&gt;<p>December  4, 2015 at 10:00:00am</p></header><div class="content"><p>ad alloc_box:<br></p><p>We have the project_box instruction (which is needed for Joe&#39;s upcoming change).<br>So it&#39;s actually a redundancy in SIL that we can obtain the same &quot;value&quot; in 2 completely different ways:<br></p><p>%1 = alloc_box<br>%2 = project_box %1#0<br>// %2 == %1#1<br></p><p>ad alloc_stack:<br></p><p>We need the 2 result values only because of dealloc_stack.<br>AFAIK we don&#39;t use dealloc_stack currently anywhere in SIL and also not in IRGen.<br>We verify that the dealloc_stacks are on the right place, i.e. are properly nested, so we could also dynamically compute this information.<br>So let me ask this question: do we really need dealloc_stack?<br>If no, we also don&#39;t need a project_stack for alloc_stack.<br></p><p><br>&gt; On Dec 4, 2015, at 10:26 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 4, 2015, at 9:51 AM, Erik Eckstein &lt;eeckstein at apple.com&gt; wrote:<br>&gt;&gt;&gt; On Dec 4, 2015, at 9:34 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 4, 2015, at 9:06 AM, Erik Eckstein &lt;eeckstein at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; currently some instructions, like alloc_stack and alloc_box (I think they are the only ones) return 2 values. For this we have the &quot;result number&quot; in SILValue, e.g. %3#0, %3#1<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We could represent the same by using a projection instruction, e.g.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; %3 = alloc_stack $Type  // == the old %3#0<br>&gt;&gt;&gt;&gt; %4 = project_stack %1   // == the old %3#1<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And actually we already have the project_box instruction.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This would simplify SILValues and many places in optimization passes/analysis. Yesterday I spent several hours to debug a problem where in some pass the wrong result number was used.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What do you think?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This would mean generating a lot of extra instructions for a lot of very common cases, like alloc_stack.<br>&gt;&gt; <br>&gt;&gt; A quick grep on the optimized stdlib sil shows that we would need only about 5% more instructions.<br>&gt; <br>&gt; I have no idea what that?s supposed to tell us, though, because that?s purely the end result of an optimization pipeline that?s heavily focused on removing alloc_stack, alloc_box, etc.<br></p><p>The optimized SIL is much larger than the SILGen&#39;d SIL, so it&#39;s more relevant for memory consumption. But yes, it does not tell us what&#39;s the status in between.<br></p><p>&gt; <br>&gt;&gt; About compile time, I&#39;m not sure. On the one hand we will have more instructions, on the other hand we would not have to mask out the ValueDef/ResultNumbers from SILValue every time we use it.<br>&gt; <br>&gt; If that?s important (and masking is really cheap, but maybe it?s important), there are other representational differences we could make that would optimize that.  For example, we could split the use lists, so that each result stores its type and use list (meaning that instructions without results don?t need use lists at all).<br>&gt; <br>&gt;&gt; IMO this is a reasonable tradeoff for making the SIL simpler.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Was your bug related to the implicit conversion of a SILInstruction* -&gt; SILValue that silently uses result 0?  I?ve been thinking for a while that we should make that conditional on the SILInstruction having exactly one result.<br>&gt;&gt; <br>&gt;&gt; Some sort of: it was a value.getDef() which should just be the value.<br>&gt; <br>&gt; Okay, but that?s what I mean: we should go through and make sure that its generally not possible to accidentally use a SILInstruction with multiple (or zero) results in any position where you really need a specific SILValue.<br>&gt; <br>&gt; John.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20151204/77e799f2/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>SIL proposal: remove multiple results from SILValue</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December  4, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 4, 2015, at 10:58 AM, Erik Eckstein &lt;eeckstein at apple.com&gt; wrote:<br>&gt; ad alloc_box:<br>&gt; <br>&gt; We have the project_box instruction (which is needed for Joe&#39;s upcoming change).<br>&gt; So it&#39;s actually a redundancy in SIL that we can obtain the same &quot;value&quot; in 2 completely different ways:<br>&gt; <br>&gt; %1 = alloc_box<br>&gt; %2 = project_box %1#0<br>&gt; // %2 == %1#1<br>&gt; <br>&gt; ad alloc_stack:<br>&gt; <br>&gt; We need the 2 result values only because of dealloc_stack.<br>&gt; AFAIK we don&#39;t use dealloc_stack currently anywhere in SIL and also not in IRGen.<br></p><p>dealloc_stack actually expands to code when the variable is dynamically-sized, and it will also be used for lifetime markers when somebody gets around to it.  Lifetime markers are a surprisingly important optimization.<br></p><p>&gt; We verify that the dealloc_stacks are on the right place, i.e. are properly nested, so we could also dynamically compute this information.<br></p><p>Er, no, if we removed all the dealloc_stacks, there wouldn?t be anything that allowed us to recreate that short of dominance frontiers.<br></p><p>&gt; So let me ask this question: do we really need dealloc_stack?<br>&gt; If no, we also don&#39;t need a project_stack for alloc_stack.<br></p><p>It is certainly true that we could implement a project_stack operation.<br></p><p>Please take the idea about giving each result an independent use list seriously, though.  How many of these problems would that address?<br></p><p>John.<br></p><p>&gt; <br>&gt; <br>&gt;&gt; On Dec 4, 2015, at 10:26 AM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 4, 2015, at 9:51 AM, Erik Eckstein &lt;eeckstein at apple.com &lt;mailto:eeckstein at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; On Dec 4, 2015, at 9:34 AM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 9:06 AM, Erik Eckstein &lt;eeckstein at apple.com &lt;mailto:eeckstein at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; currently some instructions, like alloc_stack and alloc_box (I think they are the only ones) return 2 values. For this we have the &quot;result number&quot; in SILValue, e.g. %3#0, %3#1<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We could represent the same by using a projection instruction, e.g.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; %3 = alloc_stack $Type  // == the old %3#0<br>&gt;&gt;&gt;&gt;&gt; %4 = project_stack %1   // == the old %3#1<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; And actually we already have the project_box instruction.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This would simplify SILValues and many places in optimization passes/analysis. Yesterday I spent several hours to debug a problem where in some pass the wrong result number was used.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; What do you think?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This would mean generating a lot of extra instructions for a lot of very common cases, like alloc_stack.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A quick grep on the optimized stdlib sil shows that we would need only about 5% more instructions.<br>&gt;&gt; <br>&gt;&gt; I have no idea what that?s supposed to tell us, though, because that?s purely the end result of an optimization pipeline that?s heavily focused on removing alloc_stack, alloc_box, etc.<br>&gt; <br>&gt; The optimized SIL is much larger than the SILGen&#39;d SIL, so it&#39;s more relevant for memory consumption. But yes, it does not tell us what&#39;s the status in between.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; About compile time, I&#39;m not sure. On the one hand we will have more instructions, on the other hand we would not have to mask out the ValueDef/ResultNumbers from SILValue every time we use it.<br>&gt;&gt; <br>&gt;&gt; If that?s important (and masking is really cheap, but maybe it?s important), there are other representational differences we could make that would optimize that.  For example, we could split the use lists, so that each result stores its type and use list (meaning that instructions without results don?t need use lists at all).<br>&gt;&gt; <br>&gt;&gt;&gt; IMO this is a reasonable tradeoff for making the SIL simpler.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Was your bug related to the implicit conversion of a SILInstruction* -&gt; SILValue that silently uses result 0?  I?ve been thinking for a while that we should make that conditional on the SILInstruction having exactly one result.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Some sort of: it was a value.getDef() which should just be the value.<br>&gt;&gt; <br>&gt;&gt; Okay, but that?s what I mean: we should go through and make sure that its generally not possible to accidentally use a SILInstruction with multiple (or zero) results in any position where you really need a specific SILValue.<br>&gt;&gt; <br>&gt;&gt; John.<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20151204/c4185e1c/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>SIL proposal: remove multiple results from SILValue</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December  4, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 4, 2015, at 9:06 AM, Erik Eckstein &lt;eeckstein at apple.com&gt; wrote:<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; currently some instructions, like alloc_stack and alloc_box (I think they are the only ones) return 2 values. For this we have the &quot;result number&quot; in SILValue, e.g. %3#0, %3#1<br>&gt; <br>&gt; We could represent the same by using a projection instruction, e.g.<br>&gt; <br>&gt; %3 = alloc_stack $Type  // == the old %3#0<br>&gt; %4 = project_stack %1   // == the old %3#1<br>&gt; <br>&gt; And actually we already have the project_box instruction.<br>&gt; <br>&gt; This would simplify SILValues and many places in optimization passes/analysis. Yesterday I spent several hours to debug a problem where in some pass the wrong result number was used.<br>&gt; <br>&gt; What do you think?<br></p><p>Like John said, this would cause us to generate a lot more SIL IR, and potentially more LLVM IR as well, since the projected address is produced as part of the lowering of alloc_stack and alloc_box. Multiple values are handy for things like alloc_stack and alloc_box where both values are immediately used in the common case. Looking forward, I think we&#39;d also like function applications to be able to produce arbitrarily many values at the SIL level, which would save a bunch of tuple imploding and exploding that&#39;s currently necessary.<br></p><p>-Joe<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
