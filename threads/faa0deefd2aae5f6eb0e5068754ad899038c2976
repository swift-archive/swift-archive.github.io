<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal draft] Make Optional Requirements Objective-C-only</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>April 22, 2016 at 05:00:00pm</p></header><div class="content"><p>Proposal link: https://github.com/DougGregor/swift-evolution/blob/objc-optional/proposals/NNNN-optional-requirements.md<br></p><p>After a whole lot of discussion and thrashing on optional requirements, I have a draft for a modest proposal: change the ‘optional’ keyword to something that indicates that this feature is only for compatibility with Objective-C and will not be supported on Swift protocols. Comments welcome!<br></p><p>	- Doug<br></p><p>Make Optional Requirements Objective-C-only<br></p><p>Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-optional-requirements.md&gt;<br>Author(s): Doug Gregor &lt;https://github.com/DougGregor&gt;<br>Status: Awaiting review<br>Review manager: TBD<br> &lt;https://github.com/DougGregor/swift-evolution/blob/objc-optional/proposals/NNNN-optional-requirements.md#introduction&gt;Introduction<br></p><p>Swift currently has support for &quot;optional&quot; requirements in Objective-C protocols, to match with the corresponding feature of Objective-C. We don&#39;t want to make optional requirements a feature of Swift protocols (for reasons described below), nor can we completely eliminate the notion of the language (for different reasons also described below). Therefore, to prevent confusion about our direction, this proposal changes the optional keyword objcoptional to indicate that this is an Objective-C compatibility feature.<br></p><p>Swift-evolution threads: eliminate optional requirements &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/14046&gt;, make Swift protocols support optional requirements &lt;http://thread.gmane.org/gmane.comp.lang.swift.devel/1316&gt; and make optional protocol requirements first class citizens &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/13347&gt;.<br></p><p> &lt;https://github.com/DougGregor/swift-evolution/blob/objc-optional/proposals/NNNN-optional-requirements.md#motivation&gt;Motivation<br></p><p>Having optional only work for Objective-C requirements is very weird: it feels like a general feature with a compiler bug that prevents it from working generally. However, we don&#39;t want to make it a feature of Swift protocols and we can&#39;t eliminate it (see alternatives considered &lt;https://github.com/DougGregor/swift-evolution/blob/objc-optional/proposals/NNNN-optional-requirements.md#alternatives-considered&gt;), so we propose to rename the keyword to make it clear that this feature is intended only for compatibility with Objective-C.<br></p><p> &lt;https://github.com/DougGregor/swift-evolution/blob/objc-optional/proposals/NNNN-optional-requirements.md#proposed-solution&gt;Proposed solution<br></p><p>Rename the optional contextual keyword to objcoptional. Note that:<br></p><p>It would read better as objc_optional or objcOptional, but keywords in Swift run the words together, and<br></p><p>It should not be an attribute @objcOptional because it changes the effective type of the declaration. Referencing an optional requirement wraps the result in one more level of optional, which is used to test whether the requirement was implemented.<br></p><p>This means that:<br></p><p>@objc protocol NSTableViewDelegate {<br>  optional func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView?<br>  optional func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat<br>}<br>becomes:<br></p><p>@objc protocol NSTableViewDelegate {<br>  objcoptional func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView?<br>  objcoptional func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat<br>}<br> &lt;https://github.com/DougGregor/swift-evolution/blob/objc-optional/proposals/NNNN-optional-requirements.md#impact-on-existing-code&gt;Impact on existing code<br></p><p>Any code that declares @objc protocols with optional requirements will need to be changed to use the objcoptionalkeyword. However, it is trivial for the migrator to update the code and for the compiler to provide Fix-Its, so the actual impact on users should be small.<br></p><p> &lt;https://github.com/DougGregor/swift-evolution/blob/objc-optional/proposals/NNNN-optional-requirements.md#alternatives-considered&gt;Alternatives considered<br></p><p>It&#39;s a fairly common request to make optional requirements work in Swift protocols (as in the aforementioned threads, here &lt;http://thread.gmane.org/gmane.comp.lang.swift.devel/1316&gt;and here &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/13347&gt;). However, such proposals have generally met with resistance because optional requirements have significant overlap with other protocol features: &quot;default&quot; implementations via protocol extensions and protocol inheritance. For the former case, the author of the protocol can provide a &quot;default&quot; implementation via a protocol extension that encodes the default case (rather than putting it at the call site). In the latter case, the protocol author can separate the optional requirements into a different protocol that a type can adopt to opt-in to whatever behavior they customize. While not exactlythe same as optional requirements, which allow one to perform per-requirement checking to determine whether the type implemented that requirement, the gist of the threads is that doing so is generally considered an anti-pattern: one would be better off factoring the protocol in a different way. Therefore, we do not propose to make optional requirements work for Swift protocols.<br></p><p>The second alternative would be to eliminate optional requirements entirely from the language. The primary challenge here is Cocoa interoperability, because Cocoa&#39;s protocols (primarily delegates and data sources) have a large number of optional requirements that would have to be handled somehow in Swift. These optional requirements would have to be mapped to some other construct in Swift, but the code generation model must remain the same because the Cocoa frameworks rely on the ability to ask the question &quot;was this requirement implemented by the type?&quot; in Objective-C code at run time.<br></p><p>The most popular approach to try to map optional requirements into existing Swift constructs is to turn an optional method requirement into a property of optional closure type. For example, this Objective-C protocol:<br></p><p>@protocol NSTableViewDelegate<br>@optional<br>- (nullable NSView *)tableView:(NSTableView *)tableView viewForTableColumn:(NSTableColumn *)tableColumn row:(NSInteger)row;<br>- (CGFloat)tableView:(NSTableView *)tableView heightOfRow:(NSInteger)row;<br>@end<br>which currently imports into Swift as:<br></p><p>@objc protocol NSTableViewDelegate {<br>  optional func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView?<br>  optional func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat<br>}<br>would become, e.g.,<br></p><p>@objc protocol NSTableViewDelegate {<br>  var tableView: ((NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView?)? { get }<br>  var tableView: ((NSTableView, heightOfRow: Int) -&gt; CGFloat)? { get }<br>}<br>Unfortunately, this introduces an overloaded property named tableView. To really make this work, we would need to introduce the ability for a property to have a compound name, which would also let us take the labels out of the function type:<br></p><p>@objc protocol NSTableViewDelegate {<br>  var tableView(_:viewFor:row:): ((NSTableView, NSTableColumn, Int) -&gt; NSView?)? { get }<br>  var tableView(_:heightOfRow:): ((NSTableView, Int) -&gt; CGFloat)? { get }<br>}<br>By itself, that is a good feature. However, we&#39;re not dont, because we would need yet another extension to the language: one would want to be able to provide a method in a class that is used to conform to a property in the protocol, e.g.,<br></p><p>class MyDelegate : NSObject, NSTableViewDelegate {<br>  func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView? { ... }<br>  func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat { ... }<br>}<br>Indeed, the Objective-C implementation model effectively requires us to satisfy these property-of-optional-closure requirements with methods so that Objective-C clients can use -respondsToSelector:. In other words, one would not be able to implement these requirements in by copy-pasting from the protocol to the implementing class:<br></p><p>class MyDelegate : NSObject, NSTableViewDelegate {<br>  // Note: The Objective-C entry points for these would return blocks, which is incorrect<br>  var tableView(_:viewFor:row:): ((NSTableView, NSTableColumn, Int) -&gt; NSView?)? { return ...   }<br>  var tableView(_:heightOfRow:): ((NSTableView, Int) -&gt; CGFloat)? { return ... }<br>}<br>That is both a strange technical restriction that would be limited to Objective-C protocols and a serious usability problem: the easiest way to stub out the contents of your type when it conforms to a given protocol is to copy the declarations from the protocol into your type, then fill in the details. This change would break that usage scenario badly.<br></p><p>There have been other ideas to eliminate optional requirements. For example, Objective-C protocols could be annotated with attributes that say what the default implementation for each optional requirement is (to be used only in Swift), but such a massive auditing effort is impractical. There is a related notion of caller-site default implementations &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/14046&gt; that was not well-received due to its complexity.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160422/faa02976/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Proposal draft] Make Optional Requirements Objective-C-only</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April 22, 2016 at 07:00:00pm</p></header><div class="content"><p>Not an expert on Obj-C compatibility in Swift by any means, but this<br>reads like it&#39;s largely a change of nomenclature. To me, though,<br>`objcoptional` reads exceedingly poorly. Why not emphasize the Obj-C<br>compatibility angle by requiring the `@objc` attribute to precede each<br>use of `optional`? (In other words, effectively rename `optional` to<br>`@objc optional`.)<br></p><p><br>On Fri, Apr 22, 2016 at 7:35 PM, Douglas Gregor via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Proposal link:<br>&gt; https://github.com/DougGregor/swift-evolution/blob/objc-optional/proposals/NNNN-optional-requirements.md<br>&gt;<br>&gt; After a whole lot of discussion and thrashing on optional requirements, I<br>&gt; have a draft for a modest proposal: change the ‘optional’ keyword to<br>&gt; something that indicates that this feature is only for compatibility with<br>&gt; Objective-C and will not be supported on Swift protocols. Comments welcome!<br>&gt;<br>&gt; - Doug<br>&gt;<br>&gt; Make Optional Requirements Objective-C-only<br>&gt;<br>&gt; Proposal: SE-NNNN<br>&gt; Author(s): Doug Gregor<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt;<br>&gt; Introduction<br>&gt;<br>&gt; Swift currently has support for &quot;optional&quot; requirements in Objective-C<br>&gt; protocols, to match with the corresponding feature of Objective-C. We don&#39;t<br>&gt; want to make optional requirements a feature of Swift protocols (for reasons<br>&gt; described below), nor can we completely eliminate the notion of the language<br>&gt; (for different reasons also described below). Therefore, to prevent<br>&gt; confusion about our direction, this proposal changes the optional keyword<br>&gt; objcoptional to indicate that this is an Objective-C compatibility feature.<br>&gt;<br>&gt; Swift-evolution threads: eliminate optional requirements, make Swift<br>&gt; protocols support optional requirements and make optional protocol<br>&gt; requirements first class citizens.<br>&gt;<br>&gt; Motivation<br>&gt;<br>&gt; Having optional only work for Objective-C requirements is very weird: it<br>&gt; feels like a general feature with a compiler bug that prevents it from<br>&gt; working generally. However, we don&#39;t want to make it a feature of Swift<br>&gt; protocols and we can&#39;t eliminate it (see alternatives considered), so we<br>&gt; propose to rename the keyword to make it clear that this feature is intended<br>&gt; only for compatibility with Objective-C.<br>&gt;<br>&gt; Proposed solution<br>&gt;<br>&gt; Rename the optional contextual keyword to objcoptional. Note that:<br>&gt;<br>&gt; It would read better as objc_optional or objcOptional, but keywords in Swift<br>&gt; run the words together, and<br>&gt;<br>&gt; It should not be an attribute @objcOptional because it changes the effective<br>&gt; type of the declaration. Referencing an optional requirement wraps the<br>&gt; result in one more level of optional, which is used to test whether the<br>&gt; requirement was implemented.<br>&gt;<br>&gt; This means that:<br>&gt;<br>&gt; @objc protocol NSTableViewDelegate {<br>&gt;   optional func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int)<br>&gt; -&gt; NSView?<br>&gt;   optional func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat<br>&gt; }<br>&gt;<br>&gt; becomes:<br>&gt;<br>&gt; @objc protocol NSTableViewDelegate {<br>&gt;   objcoptional func tableView(_: NSTableView, viewFor: NSTableColumn, row:<br>&gt; Int) -&gt; NSView?<br>&gt;   objcoptional func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat<br>&gt; }<br>&gt;<br>&gt; Impact on existing code<br>&gt;<br>&gt; Any code that declares @objc protocols with optional requirements will need<br>&gt; to be changed to use the objcoptionalkeyword. However, it is trivial for the<br>&gt; migrator to update the code and for the compiler to provide Fix-Its, so the<br>&gt; actual impact on users should be small.<br>&gt;<br>&gt; Alternatives considered<br>&gt;<br>&gt; It&#39;s a fairly common request to make optional requirements work in Swift<br>&gt; protocols (as in the aforementioned threads, hereand here). However, such<br>&gt; proposals have generally met with resistance because optional requirements<br>&gt; have significant overlap with other protocol features: &quot;default&quot;<br>&gt; implementations via protocol extensions and protocol inheritance. For the<br>&gt; former case, the author of the protocol can provide a &quot;default&quot;<br>&gt; implementation via a protocol extension that encodes the default case<br>&gt; (rather than putting it at the call site). In the latter case, the protocol<br>&gt; author can separate the optional requirements into a different protocol that<br>&gt; a type can adopt to opt-in to whatever behavior they customize. While not<br>&gt; exactlythe same as optional requirements, which allow one to perform<br>&gt; per-requirement checking to determine whether the type implemented that<br>&gt; requirement, the gist of the threads is that doing so is generally<br>&gt; considered an anti-pattern: one would be better off factoring the protocol<br>&gt; in a different way. Therefore, we do not propose to make optional<br>&gt; requirements work for Swift protocols.<br>&gt;<br>&gt; The second alternative would be to eliminate optional requirements entirely<br>&gt; from the language. The primary challenge here is Cocoa interoperability,<br>&gt; because Cocoa&#39;s protocols (primarily delegates and data sources) have a<br>&gt; large number of optional requirements that would have to be handled somehow<br>&gt; in Swift. These optional requirements would have to be mapped to some other<br>&gt; construct in Swift, but the code generation model must remain the same<br>&gt; because the Cocoa frameworks rely on the ability to ask the question &quot;was<br>&gt; this requirement implemented by the type?&quot; in Objective-C code at run time.<br>&gt;<br>&gt; The most popular approach to try to map optional requirements into existing<br>&gt; Swift constructs is to turn an optional method requirement into a property<br>&gt; of optional closure type. For example, this Objective-C protocol:<br>&gt;<br>&gt; @protocol NSTableViewDelegate<br>&gt; @optional<br>&gt; - (nullable NSView *)tableView:(NSTableView *)tableView<br>&gt; viewForTableColumn:(NSTableColumn *)tableColumn row:(NSInteger)row;<br>&gt; - (CGFloat)tableView:(NSTableView *)tableView heightOfRow:(NSInteger)row;<br>&gt; @end<br>&gt;<br>&gt; which currently imports into Swift as:<br>&gt;<br>&gt; @objc protocol NSTableViewDelegate {<br>&gt;   optional func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int)<br>&gt; -&gt; NSView?<br>&gt;   optional func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat<br>&gt; }<br>&gt;<br>&gt; would become, e.g.,<br>&gt;<br>&gt; @objc protocol NSTableViewDelegate {<br>&gt;   var tableView: ((NSTableView, viewFor: NSTableColumn, row: Int) -&gt;<br>&gt; NSView?)? { get }<br>&gt;   var tableView: ((NSTableView, heightOfRow: Int) -&gt; CGFloat)? { get }<br>&gt; }<br>&gt;<br>&gt; Unfortunately, this introduces an overloaded property named tableView. To<br>&gt; really make this work, we would need to introduce the ability for a property<br>&gt; to have a compound name, which would also let us take the labels out of the<br>&gt; function type:<br>&gt;<br>&gt; @objc protocol NSTableViewDelegate {<br>&gt;   var tableView(_:viewFor:row:): ((NSTableView, NSTableColumn, Int) -&gt;<br>&gt; NSView?)? { get }<br>&gt;   var tableView(_:heightOfRow:): ((NSTableView, Int) -&gt; CGFloat)? { get }<br>&gt; }<br>&gt;<br>&gt; By itself, that is a good feature. However, we&#39;re not dont, because we would<br>&gt; need yet another extension to the language: one would want to be able to<br>&gt; provide a method in a class that is used to conform to a property in the<br>&gt; protocol, e.g.,<br>&gt;<br>&gt; class MyDelegate : NSObject, NSTableViewDelegate {<br>&gt;   func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt;<br>&gt; NSView? { ... }<br>&gt;   func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat { ... }<br>&gt; }<br>&gt;<br>&gt; Indeed, the Objective-C implementation model effectively requires us to<br>&gt; satisfy these property-of-optional-closure requirements with methods so that<br>&gt; Objective-C clients can use -respondsToSelector:. In other words, one would<br>&gt; not be able to implement these requirements in by copy-pasting from the<br>&gt; protocol to the implementing class:<br>&gt;<br>&gt; class MyDelegate : NSObject, NSTableViewDelegate {<br>&gt;   // Note: The Objective-C entry points for these would return blocks, which<br>&gt; is incorrect<br>&gt;   var tableView(_:viewFor:row:): ((NSTableView, NSTableColumn, Int) -&gt;<br>&gt; NSView?)? { return ...   }<br>&gt;   var tableView(_:heightOfRow:): ((NSTableView, Int) -&gt; CGFloat)? { return<br>&gt; ... }<br>&gt; }<br>&gt;<br>&gt; That is both a strange technical restriction that would be limited to<br>&gt; Objective-C protocols and a serious usability problem: the easiest way to<br>&gt; stub out the contents of your type when it conforms to a given protocol is<br>&gt; to copy the declarations from the protocol into your type, then fill in the<br>&gt; details. This change would break that usage scenario badly.<br>&gt;<br>&gt; There have been other ideas to eliminate optional requirements. For example,<br>&gt; Objective-C protocols could be annotated with attributes that say what the<br>&gt; default implementation for each optional requirement is (to be used only in<br>&gt; Swift), but such a massive auditing effort is impractical. There is a<br>&gt; related notion of caller-site default implementations that was not<br>&gt; well-received due to its complexity.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Proposal draft] Make Optional Requirements Objective-C-only</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April 22, 2016 at 08:00:00pm</p></header><div class="content"><p>...assuming, of course, that you&#39;re putting forward a draft proposal about<br>Swift that happens to be modest in scope, and not a Swiftian modest proposal<br>&lt;https://en.wikipedia.org/wiki/A_Modest_Proposal&gt;.<br></p><p><br>On Fri, Apr 22, 2016 at 7:56 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; Not an expert on Obj-C compatibility in Swift by any means, but this<br>&gt; reads like it&#39;s largely a change of nomenclature. To me, though,<br>&gt; `objcoptional` reads exceedingly poorly. Why not emphasize the Obj-C<br>&gt; compatibility angle by requiring the `@objc` attribute to precede each<br>&gt; use of `optional`? (In other words, effectively rename `optional` to<br>&gt; `@objc optional`.)<br>&gt;<br>&gt;<br>&gt; On Fri, Apr 22, 2016 at 7:35 PM, Douglas Gregor via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Proposal link:<br>&gt;&gt;<br>https://github.com/DougGregor/swift-evolution/blob/objc-optional/proposals/NNNN-optional-requirements.md<br>&gt;&gt;<br>&gt;&gt; After a whole lot of discussion and thrashing on optional requirements, I<br>&gt;&gt; have a draft for a modest proposal: change the ‘optional’ keyword to<br>&gt;&gt; something that indicates that this feature is only for compatibility with<br>&gt;&gt; Objective-C and will not be supported on Swift protocols. Comments<br>welcome!<br>&gt;&gt;<br>&gt;&gt; - Doug<br>&gt;&gt;<br>&gt;&gt; Make Optional Requirements Objective-C-only<br>&gt;&gt;<br>&gt;&gt; Proposal: SE-NNNN<br>&gt;&gt; Author(s): Doug Gregor<br>&gt;&gt; Status: Awaiting review<br>&gt;&gt; Review manager: TBD<br>&gt;&gt;<br>&gt;&gt; Introduction<br>&gt;&gt;<br>&gt;&gt; Swift currently has support for &quot;optional&quot; requirements in Objective-C<br>&gt;&gt; protocols, to match with the corresponding feature of Objective-C. We<br>don&#39;t<br>&gt;&gt; want to make optional requirements a feature of Swift protocols (for<br>reasons<br>&gt;&gt; described below), nor can we completely eliminate the notion of the<br>language<br>&gt;&gt; (for different reasons also described below). Therefore, to prevent<br>&gt;&gt; confusion about our direction, this proposal changes the optional keyword<br>&gt;&gt; objcoptional to indicate that this is an Objective-C compatibility<br>feature.<br>&gt;&gt;<br>&gt;&gt; Swift-evolution threads: eliminate optional requirements, make Swift<br>&gt;&gt; protocols support optional requirements and make optional protocol<br>&gt;&gt; requirements first class citizens.<br>&gt;&gt;<br>&gt;&gt; Motivation<br>&gt;&gt;<br>&gt;&gt; Having optional only work for Objective-C requirements is very weird: it<br>&gt;&gt; feels like a general feature with a compiler bug that prevents it from<br>&gt;&gt; working generally. However, we don&#39;t want to make it a feature of Swift<br>&gt;&gt; protocols and we can&#39;t eliminate it (see alternatives considered), so we<br>&gt;&gt; propose to rename the keyword to make it clear that this feature is<br>intended<br>&gt;&gt; only for compatibility with Objective-C.<br>&gt;&gt;<br>&gt;&gt; Proposed solution<br>&gt;&gt;<br>&gt;&gt; Rename the optional contextual keyword to objcoptional. Note that:<br>&gt;&gt;<br>&gt;&gt; It would read better as objc_optional or objcOptional, but keywords in<br>Swift<br>&gt;&gt; run the words together, and<br>&gt;&gt;<br>&gt;&gt; It should not be an attribute @objcOptional because it changes the<br>effective<br>&gt;&gt; type of the declaration. Referencing an optional requirement wraps the<br>&gt;&gt; result in one more level of optional, which is used to test whether the<br>&gt;&gt; requirement was implemented.<br>&gt;&gt;<br>&gt;&gt; This means that:<br>&gt;&gt;<br>&gt;&gt; @objc protocol NSTableViewDelegate {<br>&gt;&gt;   optional func tableView(_: NSTableView, viewFor: NSTableColumn, row:<br>Int)<br>&gt;&gt; -&gt; NSView?<br>&gt;&gt;   optional func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; becomes:<br>&gt;&gt;<br>&gt;&gt; @objc protocol NSTableViewDelegate {<br>&gt;&gt;   objcoptional func tableView(_: NSTableView, viewFor: NSTableColumn,<br>row:<br>&gt;&gt; Int) -&gt; NSView?<br>&gt;&gt;   objcoptional func tableView(_: NSTableView, heightOfRow: Int) -&gt;<br>CGFloat<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Impact on existing code<br>&gt;&gt;<br>&gt;&gt; Any code that declares @objc protocols with optional requirements will<br>need<br>&gt;&gt; to be changed to use the objcoptionalkeyword. However, it is trivial for<br>the<br>&gt;&gt; migrator to update the code and for the compiler to provide Fix-Its, so<br>the<br>&gt;&gt; actual impact on users should be small.<br>&gt;&gt;<br>&gt;&gt; Alternatives considered<br>&gt;&gt;<br>&gt;&gt; It&#39;s a fairly common request to make optional requirements work in Swift<br>&gt;&gt; protocols (as in the aforementioned threads, hereand here). However, such<br>&gt;&gt; proposals have generally met with resistance because optional<br>requirements<br>&gt;&gt; have significant overlap with other protocol features: &quot;default&quot;<br>&gt;&gt; implementations via protocol extensions and protocol inheritance. For the<br>&gt;&gt; former case, the author of the protocol can provide a &quot;default&quot;<br>&gt;&gt; implementation via a protocol extension that encodes the default case<br>&gt;&gt; (rather than putting it at the call site). In the latter case, the<br>protocol<br>&gt;&gt; author can separate the optional requirements into a different protocol<br>that<br>&gt;&gt; a type can adopt to opt-in to whatever behavior they customize. While not<br>&gt;&gt; exactlythe same as optional requirements, which allow one to perform<br>&gt;&gt; per-requirement checking to determine whether the type implemented that<br>&gt;&gt; requirement, the gist of the threads is that doing so is generally<br>&gt;&gt; considered an anti-pattern: one would be better off factoring the<br>protocol<br>&gt;&gt; in a different way. Therefore, we do not propose to make optional<br>&gt;&gt; requirements work for Swift protocols.<br>&gt;&gt;<br>&gt;&gt; The second alternative would be to eliminate optional requirements<br>entirely<br>&gt;&gt; from the language. The primary challenge here is Cocoa interoperability,<br>&gt;&gt; because Cocoa&#39;s protocols (primarily delegates and data sources) have a<br>&gt;&gt; large number of optional requirements that would have to be handled<br>somehow<br>&gt;&gt; in Swift. These optional requirements would have to be mapped to some<br>other<br>&gt;&gt; construct in Swift, but the code generation model must remain the same<br>&gt;&gt; because the Cocoa frameworks rely on the ability to ask the question &quot;was<br>&gt;&gt; this requirement implemented by the type?&quot; in Objective-C code at run<br>time.<br>&gt;&gt;<br>&gt;&gt; The most popular approach to try to map optional requirements into<br>existing<br>&gt;&gt; Swift constructs is to turn an optional method requirement into a<br>property<br>&gt;&gt; of optional closure type. For example, this Objective-C protocol:<br>&gt;&gt;<br>&gt;&gt; @protocol NSTableViewDelegate<br>&gt;&gt; @optional<br>&gt;&gt; - (nullable NSView *)tableView:(NSTableView *)tableView<br>&gt;&gt; viewForTableColumn:(NSTableColumn *)tableColumn row:(NSInteger)row;<br>&gt;&gt; - (CGFloat)tableView:(NSTableView *)tableView heightOfRow:(NSInteger)row;<br>&gt;&gt; @end<br>&gt;&gt;<br>&gt;&gt; which currently imports into Swift as:<br>&gt;&gt;<br>&gt;&gt; @objc protocol NSTableViewDelegate {<br>&gt;&gt;   optional func tableView(_: NSTableView, viewFor: NSTableColumn, row:<br>Int)<br>&gt;&gt; -&gt; NSView?<br>&gt;&gt;   optional func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; would become, e.g.,<br>&gt;&gt;<br>&gt;&gt; @objc protocol NSTableViewDelegate {<br>&gt;&gt;   var tableView: ((NSTableView, viewFor: NSTableColumn, row: Int) -&gt;<br>&gt;&gt; NSView?)? { get }<br>&gt;&gt;   var tableView: ((NSTableView, heightOfRow: Int) -&gt; CGFloat)? { get }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Unfortunately, this introduces an overloaded property named tableView. To<br>&gt;&gt; really make this work, we would need to introduce the ability for a<br>property<br>&gt;&gt; to have a compound name, which would also let us take the labels out of<br>the<br>&gt;&gt; function type:<br>&gt;&gt;<br>&gt;&gt; @objc protocol NSTableViewDelegate {<br>&gt;&gt;   var tableView(_:viewFor:row:): ((NSTableView, NSTableColumn, Int) -&gt;<br>&gt;&gt; NSView?)? { get }<br>&gt;&gt;   var tableView(_:heightOfRow:): ((NSTableView, Int) -&gt; CGFloat)? { get }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; By itself, that is a good feature. However, we&#39;re not dont, because we<br>would<br>&gt;&gt; need yet another extension to the language: one would want to be able to<br>&gt;&gt; provide a method in a class that is used to conform to a property in the<br>&gt;&gt; protocol, e.g.,<br>&gt;&gt;<br>&gt;&gt; class MyDelegate : NSObject, NSTableViewDelegate {<br>&gt;&gt;   func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt;<br>&gt;&gt; NSView? { ... }<br>&gt;&gt;   func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat { ... }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Indeed, the Objective-C implementation model effectively requires us to<br>&gt;&gt; satisfy these property-of-optional-closure requirements with methods so<br>that<br>&gt;&gt; Objective-C clients can use -respondsToSelector:. In other words, one<br>would<br>&gt;&gt; not be able to implement these requirements in by copy-pasting from the<br>&gt;&gt; protocol to the implementing class:<br>&gt;&gt;<br>&gt;&gt; class MyDelegate : NSObject, NSTableViewDelegate {<br>&gt;&gt;   // Note: The Objective-C entry points for these would return blocks,<br>which<br>&gt;&gt; is incorrect<br>&gt;&gt;   var tableView(_:viewFor:row:): ((NSTableView, NSTableColumn, Int) -&gt;<br>&gt;&gt; NSView?)? { return ...   }<br>&gt;&gt;   var tableView(_:heightOfRow:): ((NSTableView, Int) -&gt; CGFloat)? {<br>return<br>&gt;&gt; ... }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; That is both a strange technical restriction that would be limited to<br>&gt;&gt; Objective-C protocols and a serious usability problem: the easiest way to<br>&gt;&gt; stub out the contents of your type when it conforms to a given protocol<br>is<br>&gt;&gt; to copy the declarations from the protocol into your type, then fill in<br>the<br>&gt;&gt; details. This change would break that usage scenario badly.<br>&gt;&gt;<br>&gt;&gt; There have been other ideas to eliminate optional requirements. For<br>example,<br>&gt;&gt; Objective-C protocols could be annotated with attributes that say what<br>the<br>&gt;&gt; default implementation for each optional requirement is (to be used only<br>in<br>&gt;&gt; Swift), but such a massive auditing effort is impractical. There is a<br>&gt;&gt; related notion of caller-site default implementations that was not<br>&gt;&gt; well-received due to its complexity.<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160422/a7ecf5f8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>[Proposal draft] Make Optional Requirements Objective-C-only</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>April 23, 2016 at 11:00:00am</p></header><div class="content"><p>In my opinion, requiring something is almost never something that I would describe as a &quot;feature&quot;. I don&#39;t really care if the keyword is called &quot;optional&quot; or &quot;objcoptional&quot;, I think both are fine, but I wouldn&#39;t want it to read &quot;@objc optional&quot;. The &quot;@objc&quot; in &quot;@objc optional&quot; should be optional. Also, &quot;@objc optional&quot; seems to imply that there is something like &quot;optional&quot; without &quot;@objc&quot; as well. Maybe I go to a coffee house and order a coffee. After 15 minutes I ask when it will come. The waiter says that it will not come because I should have ordered a coffee &quot;with caffeine&quot;. I complain: &quot;but you didn&#39;t bring me any coffee at all&quot;. He said: &quot;Yes, because we don&#39;t sell coffee without caffeine&quot;. &quot;You should have said that&quot;, I replied angrily. So he explained it: &quot;Our house is called &#39;real coffee contains caffeine&#39;, so I thought you&#39;d know that&quot; - &quot;I understand.&quot; ;)<br></p><p>To me, it&#39;s like a restaurant owner who complains that some customers say &quot;please&quot; while other customers don&#39;t. For better consistency, he now forces each customer to say &quot;please&quot; as well and to be polite. He also tried the opposite approach, by forbidding the word &quot;please&quot; in his rooms. But some polite customers became very unfriendly when he told them in a harsh tone to not use the &quot;P-Word&quot; here. So much for the Swiftian modest proposal ;)<br></p><p>-Michael<br></p><p>&gt; Am 23.04.2016 um 03:02 schrieb Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; ...assuming, of course, that you&#39;re putting forward a draft proposal about Swift that happens to be modest in scope, and not a Swiftian modest proposal.<br>&gt; <br>&gt; <br>&gt; On Fri, Apr 22, 2016 at 7:56 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; &gt; Not an expert on Obj-C compatibility in Swift by any means, but this<br>&gt; &gt; reads like it&#39;s largely a change of nomenclature. To me, though,<br>&gt; &gt; `objcoptional` reads exceedingly poorly. Why not emphasize the Obj-C<br>&gt; &gt; compatibility angle by requiring the `@objc` attribute to precede each<br>&gt; &gt; use of `optional`? (In other words, effectively rename `optional` to<br>&gt; &gt; `@objc optional`.)<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; On Fri, Apr 22, 2016 at 7:35 PM, Douglas Gregor via swift-evolution<br>&gt; &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt; Proposal link:<br>&gt; &gt;&gt; https://github.com/DougGregor/swift-evolution/blob/objc-optional/proposals/NNNN-optional-requirements.md<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; After a whole lot of discussion and thrashing on optional requirements, I<br>&gt; &gt;&gt; have a draft for a modest proposal: change the ‘optional’ keyword to<br>&gt; &gt;&gt; something that indicates that this feature is only for compatibility with<br>&gt; &gt;&gt; Objective-C and will not be supported on Swift protocols. Comments welcome!<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; - Doug<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Make Optional Requirements Objective-C-only<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Proposal: SE-NNNN<br>&gt; &gt;&gt; Author(s): Doug Gregor<br>&gt; &gt;&gt; Status: Awaiting review<br>&gt; &gt;&gt; Review manager: TBD<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Introduction<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Swift currently has support for &quot;optional&quot; requirements in Objective-C<br>&gt; &gt;&gt; protocols, to match with the corresponding feature of Objective-C. We don&#39;t<br>&gt; &gt;&gt; want to make optional requirements a feature of Swift protocols (for reasons<br>&gt; &gt;&gt; described below), nor can we completely eliminate the notion of the language<br>&gt; &gt;&gt; (for different reasons also described below). Therefore, to prevent<br>&gt; &gt;&gt; confusion about our direction, this proposal changes the optional keyword<br>&gt; &gt;&gt; objcoptional to indicate that this is an Objective-C compatibility feature.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Swift-evolution threads: eliminate optional requirements, make Swift<br>&gt; &gt;&gt; protocols support optional requirements and make optional protocol<br>&gt; &gt;&gt; requirements first class citizens.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Motivation<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Having optional only work for Objective-C requirements is very weird: it<br>&gt; &gt;&gt; feels like a general feature with a compiler bug that prevents it from<br>&gt; &gt;&gt; working generally. However, we don&#39;t want to make it a feature of Swift<br>&gt; &gt;&gt; protocols and we can&#39;t eliminate it (see alternatives considered), so we<br>&gt; &gt;&gt; propose to rename the keyword to make it clear that this feature is intended<br>&gt; &gt;&gt; only for compatibility with Objective-C.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Proposed solution<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Rename the optional contextual keyword to objcoptional. Note that:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; It would read better as objc_optional or objcOptional, but keywords in Swift<br>&gt; &gt;&gt; run the words together, and<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; It should not be an attribute @objcOptional because it changes the effective<br>&gt; &gt;&gt; type of the declaration. Referencing an optional requirement wraps the<br>&gt; &gt;&gt; result in one more level of optional, which is used to test whether the<br>&gt; &gt;&gt; requirement was implemented.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; This means that:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; @objc protocol NSTableViewDelegate {<br>&gt; &gt;&gt;   optional func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int)<br>&gt; &gt;&gt; -&gt; NSView?<br>&gt; &gt;&gt;   optional func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; becomes:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; @objc protocol NSTableViewDelegate {<br>&gt; &gt;&gt;   objcoptional func tableView(_: NSTableView, viewFor: NSTableColumn, row:<br>&gt; &gt;&gt; Int) -&gt; NSView?<br>&gt; &gt;&gt;   objcoptional func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Impact on existing code<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Any code that declares @objc protocols with optional requirements will need<br>&gt; &gt;&gt; to be changed to use the objcoptionalkeyword. However, it is trivial for the<br>&gt; &gt;&gt; migrator to update the code and for the compiler to provide Fix-Its, so the<br>&gt; &gt;&gt; actual impact on users should be small.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Alternatives considered<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; It&#39;s a fairly common request to make optional requirements work in Swift<br>&gt; &gt;&gt; protocols (as in the aforementioned threads, hereand here). However, such<br>&gt; &gt;&gt; proposals have generally met with resistance because optional requirements<br>&gt; &gt;&gt; have significant overlap with other protocol features: &quot;default&quot;<br>&gt; &gt;&gt; implementations via protocol extensions and protocol inheritance. For the<br>&gt; &gt;&gt; former case, the author of the protocol can provide a &quot;default&quot;<br>&gt; &gt;&gt; implementation via a protocol extension that encodes the default case<br>&gt; &gt;&gt; (rather than putting it at the call site). In the latter case, the protocol<br>&gt; &gt;&gt; author can separate the optional requirements into a different protocol that<br>&gt; &gt;&gt; a type can adopt to opt-in to whatever behavior they customize. While not<br>&gt; &gt;&gt; exactlythe same as optional requirements, which allow one to perform<br>&gt; &gt;&gt; per-requirement checking to determine whether the type implemented that<br>&gt; &gt;&gt; requirement, the gist of the threads is that doing so is generally<br>&gt; &gt;&gt; considered an anti-pattern: one would be better off factoring the protocol<br>&gt; &gt;&gt; in a different way. Therefore, we do not propose to make optional<br>&gt; &gt;&gt; requirements work for Swift protocols.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; The second alternative would be to eliminate optional requirements entirely<br>&gt; &gt;&gt; from the language. The primary challenge here is Cocoa interoperability,<br>&gt; &gt;&gt; because Cocoa&#39;s protocols (primarily delegates and data sources) have a<br>&gt; &gt;&gt; large number of optional requirements that would have to be handled somehow<br>&gt; &gt;&gt; in Swift. These optional requirements would have to be mapped to some other<br>&gt; &gt;&gt; construct in Swift, but the code generation model must remain the same<br>&gt; &gt;&gt; because the Cocoa frameworks rely on the ability to ask the question &quot;was<br>&gt; &gt;&gt; this requirement implemented by the type?&quot; in Objective-C code at run time.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; The most popular approach to try to map optional requirements into existing<br>&gt; &gt;&gt; Swift constructs is to turn an optional method requirement into a property<br>&gt; &gt;&gt; of optional closure type. For example, this Objective-C protocol:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; @protocol NSTableViewDelegate<br>&gt; &gt;&gt; @optional<br>&gt; &gt;&gt; - (nullable NSView *)tableView:(NSTableView *)tableView<br>&gt; &gt;&gt; viewForTableColumn:(NSTableColumn *)tableColumn row:(NSInteger)row;<br>&gt; &gt;&gt; - (CGFloat)tableView:(NSTableView *)tableView heightOfRow:(NSInteger)row;<br>&gt; &gt;&gt; @end<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; which currently imports into Swift as:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; @objc protocol NSTableViewDelegate {<br>&gt; &gt;&gt;   optional func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int)<br>&gt; &gt;&gt; -&gt; NSView?<br>&gt; &gt;&gt;   optional func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; would become, e.g.,<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; @objc protocol NSTableViewDelegate {<br>&gt; &gt;&gt;   var tableView: ((NSTableView, viewFor: NSTableColumn, row: Int) -&gt;<br>&gt; &gt;&gt; NSView?)? { get }<br>&gt; &gt;&gt;   var tableView: ((NSTableView, heightOfRow: Int) -&gt; CGFloat)? { get }<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Unfortunately, this introduces an overloaded property named tableView. To<br>&gt; &gt;&gt; really make this work, we would need to introduce the ability for a property<br>&gt; &gt;&gt; to have a compound name, which would also let us take the labels out of the<br>&gt; &gt;&gt; function type:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; @objc protocol NSTableViewDelegate {<br>&gt; &gt;&gt;   var tableView(_:viewFor:row:): ((NSTableView, NSTableColumn, Int) -&gt;<br>&gt; &gt;&gt; NSView?)? { get }<br>&gt; &gt;&gt;   var tableView(_:heightOfRow:): ((NSTableView, Int) -&gt; CGFloat)? { get }<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; By itself, that is a good feature. However, we&#39;re not dont, because we would<br>&gt; &gt;&gt; need yet another extension to the language: one would want to be able to<br>&gt; &gt;&gt; provide a method in a class that is used to conform to a property in the<br>&gt; &gt;&gt; protocol, e.g.,<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; class MyDelegate : NSObject, NSTableViewDelegate {<br>&gt; &gt;&gt;   func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt;<br>&gt; &gt;&gt; NSView? { ... }<br>&gt; &gt;&gt;   func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat { ... }<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Indeed, the Objective-C implementation model effectively requires us to<br>&gt; &gt;&gt; satisfy these property-of-optional-closure requirements with methods so that<br>&gt; &gt;&gt; Objective-C clients can use -respondsToSelector:. In other words, one would<br>&gt; &gt;&gt; not be able to implement these requirements in by copy-pasting from the<br>&gt; &gt;&gt; protocol to the implementing class:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; class MyDelegate : NSObject, NSTableViewDelegate {<br>&gt; &gt;&gt;   // Note: The Objective-C entry points for these would return blocks, which<br>&gt; &gt;&gt; is incorrect<br>&gt; &gt;&gt;   var tableView(_:viewFor:row:): ((NSTableView, NSTableColumn, Int) -&gt;<br>&gt; &gt;&gt; NSView?)? { return ...   }<br>&gt; &gt;&gt;   var tableView(_:heightOfRow:): ((NSTableView, Int) -&gt; CGFloat)? { return<br>&gt; &gt;&gt; ... }<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; That is both a strange technical restriction that would be limited to<br>&gt; &gt;&gt; Objective-C protocols and a serious usability problem: the easiest way to<br>&gt; &gt;&gt; stub out the contents of your type when it conforms to a given protocol is<br>&gt; &gt;&gt; to copy the declarations from the protocol into your type, then fill in the<br>&gt; &gt;&gt; details. This change would break that usage scenario badly.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; There have been other ideas to eliminate optional requirements. For example,<br>&gt; &gt;&gt; Objective-C protocols could be annotated with attributes that say what the<br>&gt; &gt;&gt; default implementation for each optional requirement is (to be used only in<br>&gt; &gt;&gt; Swift), but such a massive auditing effort is impractical. There is a<br>&gt; &gt;&gt; related notion of caller-site default implementations that was not<br>&gt; &gt;&gt; well-received due to its complexity.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Proposal draft] Make Optional Requirements Objective-C-only</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April 23, 2016 at 11:00:00am</p></header><div class="content"><p>On Sat, Apr 23, 2016 at 4:51 AM, Michael Peternell &lt;michael.peternell at gmx.at<br>&gt; wrote:<br></p><p>&gt; In my opinion, requiring something is almost never something that I would<br>&gt; describe as a &quot;feature&quot;.<br></p><p><br>I agree with this completely.<br></p><p><br>&gt; I don&#39;t really care if the keyword is called &quot;optional&quot; or &quot;objcoptional&quot;,<br>&gt; I think both are fine, but I wouldn&#39;t want it to read &quot;@objc optional&quot;. The<br>&gt; &quot;@objc&quot; in &quot;@objc optional&quot; should be optional. Also, &quot;@objc optional&quot;<br>&gt; seems to imply that there is something like &quot;optional&quot; without &quot;@objc&quot; as<br>&gt; well.<br></p><p><br>Well, here is where I disagree. IMO, requiring this particular something<br>(i.e. @objc) is a feature, precisely because there *is* (conceptually)<br>optional without @objc. The point is to emphasize that it is a deliberate<br>choice not to support this possibility in Swift-only code.<br></p><p><br>&gt; Maybe I go to a coffee house and order a coffee. After 15 minutes I ask<br>&gt; when it will come. The waiter says that it will not come because I should<br>&gt; have ordered a coffee &quot;with caffeine&quot;. I complain: &quot;but you didn&#39;t bring me<br>&gt; any coffee at all&quot;. He said: &quot;Yes, because we don&#39;t sell coffee without<br>&gt; caffeine&quot;. &quot;You should have said that&quot;, I replied angrily. So he explained<br>&gt; it: &quot;Our house is called &#39;real coffee contains caffeine&#39;, so I thought<br>&gt; you&#39;d know that&quot; - &quot;I understand.&quot; ;)<br>&gt;<br></p><p>I think, rather, if we&#39;re going to use your analogy, that supporting<br>optional only in Obj-C is more like selling only coffee without caffeine.<br>And, it&#39;s been decided that it&#39;s not appropriate to sell coffee with<br>caffeine. Having a keyword named &quot;optional&quot; is like having a menu that<br>lists &quot;coffee, $2&quot; while only serving decaffeinated coffee. The problem<br>being addressed is that people read the menu outside the restaurant, enter<br>the restaurant because they want to drink coffee, then try to order coffee<br>only to learn from the waiter that it has no caffeine. Then people try to<br>propose that the restaurant sell coffee with caffeine, even though that has<br>already been proposed before and decided against. The proposal here is to<br>rewrite the menu so that it says &quot;notreallycoffee, $2&quot;, and what I&#39;m<br>suggesting is instead writing &quot;decaffeinated coffee, $2&quot; because it&#39;s<br>easier to read.<br></p><p><br>&gt; To me, it&#39;s like a restaurant owner who complains that some customers say<br>&gt; &quot;please&quot; while other customers don&#39;t. For better consistency, he now forces<br>&gt; each customer to say &quot;please&quot; as well and to be polite. He also tried the<br>&gt; opposite approach, by forbidding the word &quot;please&quot; in his rooms. But some<br>&gt; polite customers became very unfriendly when he told them in a harsh tone<br>&gt; to not use the &quot;P-Word&quot; here. So much for the Swiftian modest proposal ;)<br>&gt;<br>&gt; -Michael<br>&gt;<br>&gt; &gt; Am 23.04.2016 um 03:02 schrieb Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt; &gt;<br>&gt; &gt; ...assuming, of course, that you&#39;re putting forward a draft proposal<br>&gt; about Swift that happens to be modest in scope, and not a Swiftian modest<br>&gt; proposal.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; On Fri, Apr 22, 2016 at 7:56 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; &gt; &gt; Not an expert on Obj-C compatibility in Swift by any means, but this<br>&gt; &gt; &gt; reads like it&#39;s largely a change of nomenclature. To me, though,<br>&gt; &gt; &gt; `objcoptional` reads exceedingly poorly. Why not emphasize the Obj-C<br>&gt; &gt; &gt; compatibility angle by requiring the `@objc` attribute to precede each<br>&gt; &gt; &gt; use of `optional`? (In other words, effectively rename `optional` to<br>&gt; &gt; &gt; `@objc optional`.)<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; On Fri, Apr 22, 2016 at 7:35 PM, Douglas Gregor via swift-evolution<br>&gt; &gt; &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; &gt;&gt; Proposal link:<br>&gt; &gt; &gt;&gt;<br>&gt; https://github.com/DougGregor/swift-evolution/blob/objc-optional/proposals/NNNN-optional-requirements.md<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; After a whole lot of discussion and thrashing on optional<br>&gt; requirements, I<br>&gt; &gt; &gt;&gt; have a draft for a modest proposal: change the ‘optional’ keyword to<br>&gt; &gt; &gt;&gt; something that indicates that this feature is only for compatibility<br>&gt; with<br>&gt; &gt; &gt;&gt; Objective-C and will not be supported on Swift protocols. Comments<br>&gt; welcome!<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; - Doug<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; Make Optional Requirements Objective-C-only<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; Proposal: SE-NNNN<br>&gt; &gt; &gt;&gt; Author(s): Doug Gregor<br>&gt; &gt; &gt;&gt; Status: Awaiting review<br>&gt; &gt; &gt;&gt; Review manager: TBD<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; Introduction<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; Swift currently has support for &quot;optional&quot; requirements in Objective-C<br>&gt; &gt; &gt;&gt; protocols, to match with the corresponding feature of Objective-C. We<br>&gt; don&#39;t<br>&gt; &gt; &gt;&gt; want to make optional requirements a feature of Swift protocols (for<br>&gt; reasons<br>&gt; &gt; &gt;&gt; described below), nor can we completely eliminate the notion of the<br>&gt; language<br>&gt; &gt; &gt;&gt; (for different reasons also described below). Therefore, to prevent<br>&gt; &gt; &gt;&gt; confusion about our direction, this proposal changes the optional<br>&gt; keyword<br>&gt; &gt; &gt;&gt; objcoptional to indicate that this is an Objective-C compatibility<br>&gt; feature.<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; Swift-evolution threads: eliminate optional requirements, make Swift<br>&gt; &gt; &gt;&gt; protocols support optional requirements and make optional protocol<br>&gt; &gt; &gt;&gt; requirements first class citizens.<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; Motivation<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; Having optional only work for Objective-C requirements is very weird:<br>&gt; it<br>&gt; &gt; &gt;&gt; feels like a general feature with a compiler bug that prevents it from<br>&gt; &gt; &gt;&gt; working generally. However, we don&#39;t want to make it a feature of<br>&gt; Swift<br>&gt; &gt; &gt;&gt; protocols and we can&#39;t eliminate it (see alternatives considered), so<br>&gt; we<br>&gt; &gt; &gt;&gt; propose to rename the keyword to make it clear that this feature is<br>&gt; intended<br>&gt; &gt; &gt;&gt; only for compatibility with Objective-C.<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; Proposed solution<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; Rename the optional contextual keyword to objcoptional. Note that:<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; It would read better as objc_optional or objcOptional, but keywords<br>&gt; in Swift<br>&gt; &gt; &gt;&gt; run the words together, and<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; It should not be an attribute @objcOptional because it changes the<br>&gt; effective<br>&gt; &gt; &gt;&gt; type of the declaration. Referencing an optional requirement wraps the<br>&gt; &gt; &gt;&gt; result in one more level of optional, which is used to test whether<br>&gt; the<br>&gt; &gt; &gt;&gt; requirement was implemented.<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; This means that:<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; @objc protocol NSTableViewDelegate {<br>&gt; &gt; &gt;&gt;   optional func tableView(_: NSTableView, viewFor: NSTableColumn,<br>&gt; row: Int)<br>&gt; &gt; &gt;&gt; -&gt; NSView?<br>&gt; &gt; &gt;&gt;   optional func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat<br>&gt; &gt; &gt;&gt; }<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; becomes:<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; @objc protocol NSTableViewDelegate {<br>&gt; &gt; &gt;&gt;   objcoptional func tableView(_: NSTableView, viewFor: NSTableColumn,<br>&gt; row:<br>&gt; &gt; &gt;&gt; Int) -&gt; NSView?<br>&gt; &gt; &gt;&gt;   objcoptional func tableView(_: NSTableView, heightOfRow: Int) -&gt;<br>&gt; CGFloat<br>&gt; &gt; &gt;&gt; }<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; Impact on existing code<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; Any code that declares @objc protocols with optional requirements<br>&gt; will need<br>&gt; &gt; &gt;&gt; to be changed to use the objcoptionalkeyword. However, it is trivial<br>&gt; for the<br>&gt; &gt; &gt;&gt; migrator to update the code and for the compiler to provide Fix-Its,<br>&gt; so the<br>&gt; &gt; &gt;&gt; actual impact on users should be small.<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; Alternatives considered<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; It&#39;s a fairly common request to make optional requirements work in<br>&gt; Swift<br>&gt; &gt; &gt;&gt; protocols (as in the aforementioned threads, hereand here). However,<br>&gt; such<br>&gt; &gt; &gt;&gt; proposals have generally met with resistance because optional<br>&gt; requirements<br>&gt; &gt; &gt;&gt; have significant overlap with other protocol features: &quot;default&quot;<br>&gt; &gt; &gt;&gt; implementations via protocol extensions and protocol inheritance. For<br>&gt; the<br>&gt; &gt; &gt;&gt; former case, the author of the protocol can provide a &quot;default&quot;<br>&gt; &gt; &gt;&gt; implementation via a protocol extension that encodes the default case<br>&gt; &gt; &gt;&gt; (rather than putting it at the call site). In the latter case, the<br>&gt; protocol<br>&gt; &gt; &gt;&gt; author can separate the optional requirements into a different<br>&gt; protocol that<br>&gt; &gt; &gt;&gt; a type can adopt to opt-in to whatever behavior they customize. While<br>&gt; not<br>&gt; &gt; &gt;&gt; exactlythe same as optional requirements, which allow one to perform<br>&gt; &gt; &gt;&gt; per-requirement checking to determine whether the type implemented<br>&gt; that<br>&gt; &gt; &gt;&gt; requirement, the gist of the threads is that doing so is generally<br>&gt; &gt; &gt;&gt; considered an anti-pattern: one would be better off factoring the<br>&gt; protocol<br>&gt; &gt; &gt;&gt; in a different way. Therefore, we do not propose to make optional<br>&gt; &gt; &gt;&gt; requirements work for Swift protocols.<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; The second alternative would be to eliminate optional requirements<br>&gt; entirely<br>&gt; &gt; &gt;&gt; from the language. The primary challenge here is Cocoa<br>&gt; interoperability,<br>&gt; &gt; &gt;&gt; because Cocoa&#39;s protocols (primarily delegates and data sources) have<br>&gt; a<br>&gt; &gt; &gt;&gt; large number of optional requirements that would have to be handled<br>&gt; somehow<br>&gt; &gt; &gt;&gt; in Swift. These optional requirements would have to be mapped to some<br>&gt; other<br>&gt; &gt; &gt;&gt; construct in Swift, but the code generation model must remain the same<br>&gt; &gt; &gt;&gt; because the Cocoa frameworks rely on the ability to ask the question<br>&gt; &quot;was<br>&gt; &gt; &gt;&gt; this requirement implemented by the type?&quot; in Objective-C code at run<br>&gt; time.<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; The most popular approach to try to map optional requirements into<br>&gt; existing<br>&gt; &gt; &gt;&gt; Swift constructs is to turn an optional method requirement into a<br>&gt; property<br>&gt; &gt; &gt;&gt; of optional closure type. For example, this Objective-C protocol:<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; @protocol NSTableViewDelegate<br>&gt; &gt; &gt;&gt; @optional<br>&gt; &gt; &gt;&gt; - (nullable NSView *)tableView:(NSTableView *)tableView<br>&gt; &gt; &gt;&gt; viewForTableColumn:(NSTableColumn *)tableColumn row:(NSInteger)row;<br>&gt; &gt; &gt;&gt; - (CGFloat)tableView:(NSTableView *)tableView<br>&gt; heightOfRow:(NSInteger)row;<br>&gt; &gt; &gt;&gt; @end<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; which currently imports into Swift as:<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; @objc protocol NSTableViewDelegate {<br>&gt; &gt; &gt;&gt;   optional func tableView(_: NSTableView, viewFor: NSTableColumn,<br>&gt; row: Int)<br>&gt; &gt; &gt;&gt; -&gt; NSView?<br>&gt; &gt; &gt;&gt;   optional func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat<br>&gt; &gt; &gt;&gt; }<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; would become, e.g.,<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; @objc protocol NSTableViewDelegate {<br>&gt; &gt; &gt;&gt;   var tableView: ((NSTableView, viewFor: NSTableColumn, row: Int) -&gt;<br>&gt; &gt; &gt;&gt; NSView?)? { get }<br>&gt; &gt; &gt;&gt;   var tableView: ((NSTableView, heightOfRow: Int) -&gt; CGFloat)? { get }<br>&gt; &gt; &gt;&gt; }<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; Unfortunately, this introduces an overloaded property named<br>&gt; tableView. To<br>&gt; &gt; &gt;&gt; really make this work, we would need to introduce the ability for a<br>&gt; property<br>&gt; &gt; &gt;&gt; to have a compound name, which would also let us take the labels out<br>&gt; of the<br>&gt; &gt; &gt;&gt; function type:<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; @objc protocol NSTableViewDelegate {<br>&gt; &gt; &gt;&gt;   var tableView(_:viewFor:row:): ((NSTableView, NSTableColumn, Int) -&gt;<br>&gt; &gt; &gt;&gt; NSView?)? { get }<br>&gt; &gt; &gt;&gt;   var tableView(_:heightOfRow:): ((NSTableView, Int) -&gt; CGFloat)? {<br>&gt; get }<br>&gt; &gt; &gt;&gt; }<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; By itself, that is a good feature. However, we&#39;re not dont, because<br>&gt; we would<br>&gt; &gt; &gt;&gt; need yet another extension to the language: one would want to be able<br>&gt; to<br>&gt; &gt; &gt;&gt; provide a method in a class that is used to conform to a property in<br>&gt; the<br>&gt; &gt; &gt;&gt; protocol, e.g.,<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; class MyDelegate : NSObject, NSTableViewDelegate {<br>&gt; &gt; &gt;&gt;   func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt;<br>&gt; &gt; &gt;&gt; NSView? { ... }<br>&gt; &gt; &gt;&gt;   func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat { ... }<br>&gt; &gt; &gt;&gt; }<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; Indeed, the Objective-C implementation model effectively requires us<br>&gt; to<br>&gt; &gt; &gt;&gt; satisfy these property-of-optional-closure requirements with methods<br>&gt; so that<br>&gt; &gt; &gt;&gt; Objective-C clients can use -respondsToSelector:. In other words, one<br>&gt; would<br>&gt; &gt; &gt;&gt; not be able to implement these requirements in by copy-pasting from<br>&gt; the<br>&gt; &gt; &gt;&gt; protocol to the implementing class:<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; class MyDelegate : NSObject, NSTableViewDelegate {<br>&gt; &gt; &gt;&gt;   // Note: The Objective-C entry points for these would return<br>&gt; blocks, which<br>&gt; &gt; &gt;&gt; is incorrect<br>&gt; &gt; &gt;&gt;   var tableView(_:viewFor:row:): ((NSTableView, NSTableColumn, Int) -&gt;<br>&gt; &gt; &gt;&gt; NSView?)? { return ...   }<br>&gt; &gt; &gt;&gt;   var tableView(_:heightOfRow:): ((NSTableView, Int) -&gt; CGFloat)? {<br>&gt; return<br>&gt; &gt; &gt;&gt; ... }<br>&gt; &gt; &gt;&gt; }<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; That is both a strange technical restriction that would be limited to<br>&gt; &gt; &gt;&gt; Objective-C protocols and a serious usability problem: the easiest<br>&gt; way to<br>&gt; &gt; &gt;&gt; stub out the contents of your type when it conforms to a given<br>&gt; protocol is<br>&gt; &gt; &gt;&gt; to copy the declarations from the protocol into your type, then fill<br>&gt; in the<br>&gt; &gt; &gt;&gt; details. This change would break that usage scenario badly.<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; There have been other ideas to eliminate optional requirements. For<br>&gt; example,<br>&gt; &gt; &gt;&gt; Objective-C protocols could be annotated with attributes that say<br>&gt; what the<br>&gt; &gt; &gt;&gt; default implementation for each optional requirement is (to be used<br>&gt; only in<br>&gt; &gt; &gt;&gt; Swift), but such a massive auditing effort is impractical. There is a<br>&gt; &gt; &gt;&gt; related notion of caller-site default implementations that was not<br>&gt; &gt; &gt;&gt; well-received due to its complexity.<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; _______________________________________________<br>&gt; &gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; &gt;&gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160423/926a261e/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f6b7154fd1d6a470d0b521a2e484bffc?s=50"></div><header><strong>[Proposal draft] Make Optional Requirements Objective-C-only</strong> from <string>Daniel Duan</string> &lt;daniel at duan.org&gt;<p>April 22, 2016 at 07:00:00pm</p></header><div class="content"><p>I think this change actually *increases* readability since it made the intend of the keyword clearer. <br></p><p>+1<br></p><p>Daniel Duan<br>Sent from my iPhone<br></p><p>&gt; On Apr 22, 2016, at 5:56 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Not an expert on Obj-C compatibility in Swift by any means, but this<br>&gt; reads like it&#39;s largely a change of nomenclature. To me, though,<br>&gt; `objcoptional` reads exceedingly poorly. Why not emphasize the Obj-C<br>&gt; compatibility angle by requiring the `@objc` attribute to precede each<br>&gt; use of `optional`? (In other words, effectively rename `optional` to<br>&gt; `@objc optional`.)<br>&gt; <br>&gt; <br>&gt; On Fri, Apr 22, 2016 at 7:35 PM, Douglas Gregor via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Proposal link:<br>&gt;&gt; https://github.com/DougGregor/swift-evolution/blob/objc-optional/proposals/NNNN-optional-requirements.md<br>&gt;&gt; <br>&gt;&gt; After a whole lot of discussion and thrashing on optional requirements, I<br>&gt;&gt; have a draft for a modest proposal: change the ‘optional’ keyword to<br>&gt;&gt; something that indicates that this feature is only for compatibility with<br>&gt;&gt; Objective-C and will not be supported on Swift protocols. Comments welcome!<br>&gt;&gt; <br>&gt;&gt; - Doug<br>&gt;&gt; <br>&gt;&gt; Make Optional Requirements Objective-C-only<br>&gt;&gt; <br>&gt;&gt; Proposal: SE-NNNN<br>&gt;&gt; Author(s): Doug Gregor<br>&gt;&gt; Status: Awaiting review<br>&gt;&gt; Review manager: TBD<br>&gt;&gt; <br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; Swift currently has support for &quot;optional&quot; requirements in Objective-C<br>&gt;&gt; protocols, to match with the corresponding feature of Objective-C. We don&#39;t<br>&gt;&gt; want to make optional requirements a feature of Swift protocols (for reasons<br>&gt;&gt; described below), nor can we completely eliminate the notion of the language<br>&gt;&gt; (for different reasons also described below). Therefore, to prevent<br>&gt;&gt; confusion about our direction, this proposal changes the optional keyword<br>&gt;&gt; objcoptional to indicate that this is an Objective-C compatibility feature.<br>&gt;&gt; <br>&gt;&gt; Swift-evolution threads: eliminate optional requirements, make Swift<br>&gt;&gt; protocols support optional requirements and make optional protocol<br>&gt;&gt; requirements first class citizens.<br>&gt;&gt; <br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; Having optional only work for Objective-C requirements is very weird: it<br>&gt;&gt; feels like a general feature with a compiler bug that prevents it from<br>&gt;&gt; working generally. However, we don&#39;t want to make it a feature of Swift<br>&gt;&gt; protocols and we can&#39;t eliminate it (see alternatives considered), so we<br>&gt;&gt; propose to rename the keyword to make it clear that this feature is intended<br>&gt;&gt; only for compatibility with Objective-C.<br>&gt;&gt; <br>&gt;&gt; Proposed solution<br>&gt;&gt; <br>&gt;&gt; Rename the optional contextual keyword to objcoptional. Note that:<br>&gt;&gt; <br>&gt;&gt; It would read better as objc_optional or objcOptional, but keywords in Swift<br>&gt;&gt; run the words together, and<br>&gt;&gt; <br>&gt;&gt; It should not be an attribute @objcOptional because it changes the effective<br>&gt;&gt; type of the declaration. Referencing an optional requirement wraps the<br>&gt;&gt; result in one more level of optional, which is used to test whether the<br>&gt;&gt; requirement was implemented.<br>&gt;&gt; <br>&gt;&gt; This means that:<br>&gt;&gt; <br>&gt;&gt; @objc protocol NSTableViewDelegate {<br>&gt;&gt;  optional func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int)<br>&gt;&gt; -&gt; NSView?<br>&gt;&gt;  optional func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; becomes:<br>&gt;&gt; <br>&gt;&gt; @objc protocol NSTableViewDelegate {<br>&gt;&gt;  objcoptional func tableView(_: NSTableView, viewFor: NSTableColumn, row:<br>&gt;&gt; Int) -&gt; NSView?<br>&gt;&gt;  objcoptional func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Impact on existing code<br>&gt;&gt; <br>&gt;&gt; Any code that declares @objc protocols with optional requirements will need<br>&gt;&gt; to be changed to use the objcoptionalkeyword. However, it is trivial for the<br>&gt;&gt; migrator to update the code and for the compiler to provide Fix-Its, so the<br>&gt;&gt; actual impact on users should be small.<br>&gt;&gt; <br>&gt;&gt; Alternatives considered<br>&gt;&gt; <br>&gt;&gt; It&#39;s a fairly common request to make optional requirements work in Swift<br>&gt;&gt; protocols (as in the aforementioned threads, hereand here). However, such<br>&gt;&gt; proposals have generally met with resistance because optional requirements<br>&gt;&gt; have significant overlap with other protocol features: &quot;default&quot;<br>&gt;&gt; implementations via protocol extensions and protocol inheritance. For the<br>&gt;&gt; former case, the author of the protocol can provide a &quot;default&quot;<br>&gt;&gt; implementation via a protocol extension that encodes the default case<br>&gt;&gt; (rather than putting it at the call site). In the latter case, the protocol<br>&gt;&gt; author can separate the optional requirements into a different protocol that<br>&gt;&gt; a type can adopt to opt-in to whatever behavior they customize. While not<br>&gt;&gt; exactlythe same as optional requirements, which allow one to perform<br>&gt;&gt; per-requirement checking to determine whether the type implemented that<br>&gt;&gt; requirement, the gist of the threads is that doing so is generally<br>&gt;&gt; considered an anti-pattern: one would be better off factoring the protocol<br>&gt;&gt; in a different way. Therefore, we do not propose to make optional<br>&gt;&gt; requirements work for Swift protocols.<br>&gt;&gt; <br>&gt;&gt; The second alternative would be to eliminate optional requirements entirely<br>&gt;&gt; from the language. The primary challenge here is Cocoa interoperability,<br>&gt;&gt; because Cocoa&#39;s protocols (primarily delegates and data sources) have a<br>&gt;&gt; large number of optional requirements that would have to be handled somehow<br>&gt;&gt; in Swift. These optional requirements would have to be mapped to some other<br>&gt;&gt; construct in Swift, but the code generation model must remain the same<br>&gt;&gt; because the Cocoa frameworks rely on the ability to ask the question &quot;was<br>&gt;&gt; this requirement implemented by the type?&quot; in Objective-C code at run time.<br>&gt;&gt; <br>&gt;&gt; The most popular approach to try to map optional requirements into existing<br>&gt;&gt; Swift constructs is to turn an optional method requirement into a property<br>&gt;&gt; of optional closure type. For example, this Objective-C protocol:<br>&gt;&gt; <br>&gt;&gt; @protocol NSTableViewDelegate<br>&gt;&gt; @optional<br>&gt;&gt; - (nullable NSView *)tableView:(NSTableView *)tableView<br>&gt;&gt; viewForTableColumn:(NSTableColumn *)tableColumn row:(NSInteger)row;<br>&gt;&gt; - (CGFloat)tableView:(NSTableView *)tableView heightOfRow:(NSInteger)row;<br>&gt;&gt; @end<br>&gt;&gt; <br>&gt;&gt; which currently imports into Swift as:<br>&gt;&gt; <br>&gt;&gt; @objc protocol NSTableViewDelegate {<br>&gt;&gt;  optional func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int)<br>&gt;&gt; -&gt; NSView?<br>&gt;&gt;  optional func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; would become, e.g.,<br>&gt;&gt; <br>&gt;&gt; @objc protocol NSTableViewDelegate {<br>&gt;&gt;  var tableView: ((NSTableView, viewFor: NSTableColumn, row: Int) -&gt;<br>&gt;&gt; NSView?)? { get }<br>&gt;&gt;  var tableView: ((NSTableView, heightOfRow: Int) -&gt; CGFloat)? { get }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Unfortunately, this introduces an overloaded property named tableView. To<br>&gt;&gt; really make this work, we would need to introduce the ability for a property<br>&gt;&gt; to have a compound name, which would also let us take the labels out of the<br>&gt;&gt; function type:<br>&gt;&gt; <br>&gt;&gt; @objc protocol NSTableViewDelegate {<br>&gt;&gt;  var tableView(_:viewFor:row:): ((NSTableView, NSTableColumn, Int) -&gt;<br>&gt;&gt; NSView?)? { get }<br>&gt;&gt;  var tableView(_:heightOfRow:): ((NSTableView, Int) -&gt; CGFloat)? { get }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; By itself, that is a good feature. However, we&#39;re not dont, because we would<br>&gt;&gt; need yet another extension to the language: one would want to be able to<br>&gt;&gt; provide a method in a class that is used to conform to a property in the<br>&gt;&gt; protocol, e.g.,<br>&gt;&gt; <br>&gt;&gt; class MyDelegate : NSObject, NSTableViewDelegate {<br>&gt;&gt;  func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt;<br>&gt;&gt; NSView? { ... }<br>&gt;&gt;  func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat { ... }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Indeed, the Objective-C implementation model effectively requires us to<br>&gt;&gt; satisfy these property-of-optional-closure requirements with methods so that<br>&gt;&gt; Objective-C clients can use -respondsToSelector:. In other words, one would<br>&gt;&gt; not be able to implement these requirements in by copy-pasting from the<br>&gt;&gt; protocol to the implementing class:<br>&gt;&gt; <br>&gt;&gt; class MyDelegate : NSObject, NSTableViewDelegate {<br>&gt;&gt;  // Note: The Objective-C entry points for these would return blocks, which<br>&gt;&gt; is incorrect<br>&gt;&gt;  var tableView(_:viewFor:row:): ((NSTableView, NSTableColumn, Int) -&gt;<br>&gt;&gt; NSView?)? { return ...   }<br>&gt;&gt;  var tableView(_:heightOfRow:): ((NSTableView, Int) -&gt; CGFloat)? { return<br>&gt;&gt; ... }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; That is both a strange technical restriction that would be limited to<br>&gt;&gt; Objective-C protocols and a serious usability problem: the easiest way to<br>&gt;&gt; stub out the contents of your type when it conforms to a given protocol is<br>&gt;&gt; to copy the declarations from the protocol into your type, then fill in the<br>&gt;&gt; details. This change would break that usage scenario badly.<br>&gt;&gt; <br>&gt;&gt; There have been other ideas to eliminate optional requirements. For example,<br>&gt;&gt; Objective-C protocols could be annotated with attributes that say what the<br>&gt;&gt; default implementation for each optional requirement is (to be used only in<br>&gt;&gt; Swift), but such a massive auditing effort is impractical. There is a<br>&gt;&gt; related notion of caller-site default implementations that was not<br>&gt;&gt; well-received due to its complexity.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal draft] Make Optional Requirements Objective-C-only</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>April 22, 2016 at 08:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On Apr 22, 2016, at 5:56 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; Not an expert on Obj-C compatibility in Swift by any means, but this<br>&gt; reads like it&#39;s largely a change of nomenclature. To me, though,<br>&gt; `objcoptional` reads exceedingly poorly. Why not emphasize the Obj-C<br>&gt; compatibility angle by requiring the `@objc` attribute to precede each<br>&gt; use of `optional`? (In other words, effectively rename `optional` to<br>&gt; `@objc optional`.)<br></p><p>That is a great idea. <br>&gt; <br>&gt; <br>&gt; On Fri, Apr 22, 2016 at 7:35 PM, Douglas Gregor via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Proposal link:<br>&gt;&gt; https://github.com/DougGregor/swift-evolution/blob/objc-optional/proposals/NNNN-optional-requirements.md<br>&gt;&gt; <br>&gt;&gt; After a whole lot of discussion and thrashing on optional requirements, I<br>&gt;&gt; have a draft for a modest proposal: change the ‘optional’ keyword to<br>&gt;&gt; something that indicates that this feature is only for compatibility with<br>&gt;&gt; Objective-C and will not be supported on Swift protocols. Comments welcome!<br>&gt;&gt; <br>&gt;&gt; - Doug<br>&gt;&gt; <br>&gt;&gt; Make Optional Requirements Objective-C-only<br>&gt;&gt; <br>&gt;&gt; Proposal: SE-NNNN<br>&gt;&gt; Author(s): Doug Gregor<br>&gt;&gt; Status: Awaiting review<br>&gt;&gt; Review manager: TBD<br>&gt;&gt; <br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; Swift currently has support for &quot;optional&quot; requirements in Objective-C<br>&gt;&gt; protocols, to match with the corresponding feature of Objective-C. We don&#39;t<br>&gt;&gt; want to make optional requirements a feature of Swift protocols (for reasons<br>&gt;&gt; described below), nor can we completely eliminate the notion of the language<br>&gt;&gt; (for different reasons also described below). Therefore, to prevent<br>&gt;&gt; confusion about our direction, this proposal changes the optional keyword<br>&gt;&gt; objcoptional to indicate that this is an Objective-C compatibility feature.<br>&gt;&gt; <br>&gt;&gt; Swift-evolution threads: eliminate optional requirements, make Swift<br>&gt;&gt; protocols support optional requirements and make optional protocol<br>&gt;&gt; requirements first class citizens.<br>&gt;&gt; <br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; Having optional only work for Objective-C requirements is very weird: it<br>&gt;&gt; feels like a general feature with a compiler bug that prevents it from<br>&gt;&gt; working generally. However, we don&#39;t want to make it a feature of Swift<br>&gt;&gt; protocols and we can&#39;t eliminate it (see alternatives considered), so we<br>&gt;&gt; propose to rename the keyword to make it clear that this feature is intended<br>&gt;&gt; only for compatibility with Objective-C.<br>&gt;&gt; <br>&gt;&gt; Proposed solution<br>&gt;&gt; <br>&gt;&gt; Rename the optional contextual keyword to objcoptional. Note that:<br>&gt;&gt; <br>&gt;&gt; It would read better as objc_optional or objcOptional, but keywords in Swift<br>&gt;&gt; run the words together, and<br>&gt;&gt; <br>&gt;&gt; It should not be an attribute @objcOptional because it changes the effective<br>&gt;&gt; type of the declaration. Referencing an optional requirement wraps the<br>&gt;&gt; result in one more level of optional, which is used to test whether the<br>&gt;&gt; requirement was implemented.<br>&gt;&gt; <br>&gt;&gt; This means that:<br>&gt;&gt; <br>&gt;&gt; @objc protocol NSTableViewDelegate {<br>&gt;&gt;  optional func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int)<br>&gt;&gt; -&gt; NSView?<br>&gt;&gt;  optional func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; becomes:<br>&gt;&gt; <br>&gt;&gt; @objc protocol NSTableViewDelegate {<br>&gt;&gt;  objcoptional func tableView(_: NSTableView, viewFor: NSTableColumn, row:<br>&gt;&gt; Int) -&gt; NSView?<br>&gt;&gt;  objcoptional func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Impact on existing code<br>&gt;&gt; <br>&gt;&gt; Any code that declares @objc protocols with optional requirements will need<br>&gt;&gt; to be changed to use the objcoptionalkeyword. However, it is trivial for the<br>&gt;&gt; migrator to update the code and for the compiler to provide Fix-Its, so the<br>&gt;&gt; actual impact on users should be small.<br>&gt;&gt; <br>&gt;&gt; Alternatives considered<br>&gt;&gt; <br>&gt;&gt; It&#39;s a fairly common request to make optional requirements work in Swift<br>&gt;&gt; protocols (as in the aforementioned threads, hereand here). However, such<br>&gt;&gt; proposals have generally met with resistance because optional requirements<br>&gt;&gt; have significant overlap with other protocol features: &quot;default&quot;<br>&gt;&gt; implementations via protocol extensions and protocol inheritance. For the<br>&gt;&gt; former case, the author of the protocol can provide a &quot;default&quot;<br>&gt;&gt; implementation via a protocol extension that encodes the default case<br>&gt;&gt; (rather than putting it at the call site). In the latter case, the protocol<br>&gt;&gt; author can separate the optional requirements into a different protocol that<br>&gt;&gt; a type can adopt to opt-in to whatever behavior they customize. While not<br>&gt;&gt; exactlythe same as optional requirements, which allow one to perform<br>&gt;&gt; per-requirement checking to determine whether the type implemented that<br>&gt;&gt; requirement, the gist of the threads is that doing so is generally<br>&gt;&gt; considered an anti-pattern: one would be better off factoring the protocol<br>&gt;&gt; in a different way. Therefore, we do not propose to make optional<br>&gt;&gt; requirements work for Swift protocols.<br>&gt;&gt; <br>&gt;&gt; The second alternative would be to eliminate optional requirements entirely<br>&gt;&gt; from the language. The primary challenge here is Cocoa interoperability,<br>&gt;&gt; because Cocoa&#39;s protocols (primarily delegates and data sources) have a<br>&gt;&gt; large number of optional requirements that would have to be handled somehow<br>&gt;&gt; in Swift. These optional requirements would have to be mapped to some other<br>&gt;&gt; construct in Swift, but the code generation model must remain the same<br>&gt;&gt; because the Cocoa frameworks rely on the ability to ask the question &quot;was<br>&gt;&gt; this requirement implemented by the type?&quot; in Objective-C code at run time.<br>&gt;&gt; <br>&gt;&gt; The most popular approach to try to map optional requirements into existing<br>&gt;&gt; Swift constructs is to turn an optional method requirement into a property<br>&gt;&gt; of optional closure type. For example, this Objective-C protocol:<br>&gt;&gt; <br>&gt;&gt; @protocol NSTableViewDelegate<br>&gt;&gt; @optional<br>&gt;&gt; - (nullable NSView *)tableView:(NSTableView *)tableView<br>&gt;&gt; viewForTableColumn:(NSTableColumn *)tableColumn row:(NSInteger)row;<br>&gt;&gt; - (CGFloat)tableView:(NSTableView *)tableView heightOfRow:(NSInteger)row;<br>&gt;&gt; @end<br>&gt;&gt; <br>&gt;&gt; which currently imports into Swift as:<br>&gt;&gt; <br>&gt;&gt; @objc protocol NSTableViewDelegate {<br>&gt;&gt;  optional func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int)<br>&gt;&gt; -&gt; NSView?<br>&gt;&gt;  optional func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; would become, e.g.,<br>&gt;&gt; <br>&gt;&gt; @objc protocol NSTableViewDelegate {<br>&gt;&gt;  var tableView: ((NSTableView, viewFor: NSTableColumn, row: Int) -&gt;<br>&gt;&gt; NSView?)? { get }<br>&gt;&gt;  var tableView: ((NSTableView, heightOfRow: Int) -&gt; CGFloat)? { get }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Unfortunately, this introduces an overloaded property named tableView. To<br>&gt;&gt; really make this work, we would need to introduce the ability for a property<br>&gt;&gt; to have a compound name, which would also let us take the labels out of the<br>&gt;&gt; function type:<br>&gt;&gt; <br>&gt;&gt; @objc protocol NSTableViewDelegate {<br>&gt;&gt;  var tableView(_:viewFor:row:): ((NSTableView, NSTableColumn, Int) -&gt;<br>&gt;&gt; NSView?)? { get }<br>&gt;&gt;  var tableView(_:heightOfRow:): ((NSTableView, Int) -&gt; CGFloat)? { get }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; By itself, that is a good feature. However, we&#39;re not dont, because we would<br>&gt;&gt; need yet another extension to the language: one would want to be able to<br>&gt;&gt; provide a method in a class that is used to conform to a property in the<br>&gt;&gt; protocol, e.g.,<br>&gt;&gt; <br>&gt;&gt; class MyDelegate : NSObject, NSTableViewDelegate {<br>&gt;&gt;  func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt;<br>&gt;&gt; NSView? { ... }<br>&gt;&gt;  func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat { ... }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Indeed, the Objective-C implementation model effectively requires us to<br>&gt;&gt; satisfy these property-of-optional-closure requirements with methods so that<br>&gt;&gt; Objective-C clients can use -respondsToSelector:. In other words, one would<br>&gt;&gt; not be able to implement these requirements in by copy-pasting from the<br>&gt;&gt; protocol to the implementing class:<br>&gt;&gt; <br>&gt;&gt; class MyDelegate : NSObject, NSTableViewDelegate {<br>&gt;&gt;  // Note: The Objective-C entry points for these would return blocks, which<br>&gt;&gt; is incorrect<br>&gt;&gt;  var tableView(_:viewFor:row:): ((NSTableView, NSTableColumn, Int) -&gt;<br>&gt;&gt; NSView?)? { return ...   }<br>&gt;&gt;  var tableView(_:heightOfRow:): ((NSTableView, Int) -&gt; CGFloat)? { return<br>&gt;&gt; ... }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; That is both a strange technical restriction that would be limited to<br>&gt;&gt; Objective-C protocols and a serious usability problem: the easiest way to<br>&gt;&gt; stub out the contents of your type when it conforms to a given protocol is<br>&gt;&gt; to copy the declarations from the protocol into your type, then fill in the<br>&gt;&gt; details. This change would break that usage scenario badly.<br>&gt;&gt; <br>&gt;&gt; There have been other ideas to eliminate optional requirements. For example,<br>&gt;&gt; Objective-C protocols could be annotated with attributes that say what the<br>&gt;&gt; default implementation for each optional requirement is (to be used only in<br>&gt;&gt; Swift), but such a massive auditing effort is impractical. There is a<br>&gt;&gt; related notion of caller-site default implementations that was not<br>&gt;&gt; well-received due to its complexity.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal draft] Make Optional Requirements Objective-C-only</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>April 24, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Apr 22, 2016, at 8:02 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt;&gt; On Apr 22, 2016, at 5:56 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Not an expert on Obj-C compatibility in Swift by any means, but this<br>&gt;&gt; reads like it&#39;s largely a change of nomenclature. To me, though,<br>&gt;&gt; `objcoptional` reads exceedingly poorly. Why not emphasize the Obj-C<br>&gt;&gt; compatibility angle by requiring the `@objc` attribute to precede each<br>&gt;&gt; use of `optional`? (In other words, effectively rename `optional` to<br>&gt;&gt; `@objc optional`.)<br>&gt; <br>&gt; That is a great idea. <br></p><p>Doesn’t this have the same problem as the current (Swift 1/2) implementation?  People will continue to believe that it is a bug that you must specify @objc.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Proposal draft] Make Optional Requirements Objective-C-only</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April 24, 2016 at 05:00:00pm</p></header><div class="content"><p>On Sun, Apr 24, 2016 at 4:28 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Apr 22, 2016, at 8:02 PM, Douglas Gregor via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Sent from my iPhone<br>&gt; &gt;<br>&gt; &gt;&gt; On Apr 22, 2016, at 5:56 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Not an expert on Obj-C compatibility in Swift by any means, but this<br>&gt; &gt;&gt; reads like it&#39;s largely a change of nomenclature. To me, though,<br>&gt; &gt;&gt; `objcoptional` reads exceedingly poorly. Why not emphasize the Obj-C<br>&gt; &gt;&gt; compatibility angle by requiring the `@objc` attribute to precede each<br>&gt; &gt;&gt; use of `optional`? (In other words, effectively rename `optional` to<br>&gt; &gt;&gt; `@objc optional`.)<br>&gt; &gt;<br>&gt; &gt; That is a great idea.<br>&gt;<br>&gt; Doesn’t this have the same problem as the current (Swift 1/2)<br>&gt; implementation?  People will continue to believe that it is a bug that you<br>&gt; must specify @objc.<br>&gt;<br></p><p>Perhaps they will, but IMO it&#39;s an improvement. In the current<br>implementation, `optional func` is spatially divorced from the `@objc`<br>annotation on the containing protocol. There&#39;s nothing in the code that<br>helps you to deduce that the two are tied to each other in some way. With<br>an immediate juxtaposition, it&#39;s much more explicable that optional<br>functions must be @objc functions. To my mind, it reads similarly to how<br>throwing functions must be called with some sort of `try`.<br></p><p>(FWIW, my hunch is that if the keyword were named `objcoptional` to begin<br>with, you&#39;d still have people proposing to extend optional requirements to<br>pure-Swift protocols and renaming the keyword `optional`.)<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160424/23113ec6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal draft] Make Optional Requirements Objective-C-only</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>April 24, 2016 at 07:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On Apr 24, 2016, at 3:24 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Sun, Apr 24, 2016 at 4:28 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt; On Apr 22, 2016, at 8:02 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Sent from my iPhone<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; On Apr 22, 2016, at 5:56 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Not an expert on Obj-C compatibility in Swift by any means, but this<br>&gt;&gt; &gt;&gt; reads like it&#39;s largely a change of nomenclature. To me, though,<br>&gt;&gt; &gt;&gt; `objcoptional` reads exceedingly poorly. Why not emphasize the Obj-C<br>&gt;&gt; &gt;&gt; compatibility angle by requiring the `@objc` attribute to precede each<br>&gt;&gt; &gt;&gt; use of `optional`? (In other words, effectively rename `optional` to<br>&gt;&gt; &gt;&gt; `@objc optional`.)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; That is a great idea.<br>&gt;&gt; <br>&gt;&gt; Doesn’t this have the same problem as the current (Swift 1/2) implementation?  People will continue to believe that it is a bug that you must specify @objc.<br>&gt; <br>&gt; Perhaps they will, but IMO it&#39;s an improvement. In the current implementation, `optional func` is spatially divorced from the `@objc` annotation on the containing protocol. There&#39;s nothing in the code that helps you to deduce that the two are tied to each other in some way. With an immediate juxtaposition, it&#39;s much more explicable that optional functions must be @objc functions.<br></p><p>Yeah. I also think the diagnostic will be part of the messaging. If you leave off the @objc, the compiler can have an error along the lines of &quot;optional requirements are an Objective-C compatibility feature; add &#39;@objc&#39;<br></p><p>&gt; To my mind, it reads similarly to how throwing functions must be called with some sort of `try`.<br>&gt; <br>&gt; (FWIW, my hunch is that if the keyword were named `objcoptional` to begin with, you&#39;d still have people proposing to extend optional requirements to pure-Swift protocols and renaming the keyword `optional`.)<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160424/008183a1/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal draft] Make Optional Requirements Objective-C-only</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April 24, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Apr 24, 2016, at 3:28 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 22, 2016, at 8:02 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt;&gt; On Apr 22, 2016, at 5:56 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Not an expert on Obj-C compatibility in Swift by any means, but this<br>&gt;&gt;&gt; reads like it&#39;s largely a change of nomenclature. To me, though,<br>&gt;&gt;&gt; `objcoptional` reads exceedingly poorly. Why not emphasize the Obj-C<br>&gt;&gt;&gt; compatibility angle by requiring the `@objc` attribute to precede each<br>&gt;&gt;&gt; use of `optional`? (In other words, effectively rename `optional` to<br>&gt;&gt;&gt; `@objc optional`.)<br>&gt;&gt; <br>&gt;&gt; That is a great idea. <br>&gt; <br>&gt; Doesn’t this have the same problem as the current (Swift 1/2) implementation?  People will continue to believe that it is a bug that you must specify @objc.<br>&gt; <br>&gt; -Chris<br></p><p>I thought I&#39;d throw a few ideas into the mix. I&#39;m arriving late to the discussion. (I didn&#39;t expect the conversation to last this long.) I did take a quick look back through the thread but I may have missed some bits along the way. Apologies in advance for any redundancy:<br></p><p>* Optional requirement is an oxymoron. (This is a redux of my previous contribution to this topic but it&#39;s a good starting point.)<br></p><p>* Swift&#39;s &quot;optional&quot; protocol implementations are no such thing. They are default implementations that can be overridden. (Tangentially, why not introduce a required &quot;override&quot; keyword for conforming types that implement a version of a member introduced in protocol extensions? This would match the class approach and enhance safety and intent.)<br></p><p>* Swift already has an `Optional` type. Importing ObjC &quot;optional&quot; protocol requirements is therefore semantically problematic from a Swift development POV. I don&#39;t like either the &quot;@objcoptional&quot; or &quot;@objc optional&quot; solutions mentioned upthread. They overload &quot;optional&quot; syntactically and confuse semantics. I think the key words that better describe what&#39;s happening in, for example, a `UITableViewDelegate`, are &quot;discretionary&quot; or &quot;elective&quot; implementations.  Swift has renamed lots of Objective C things (waves hi to SE-0005 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md&gt;). Why not &quot;optional&quot;?<br></p><p>* I do *support* retaining `@objc` in some form and I believe it can be addressed in a way that does not appear to be a bug. &quot;Optional protocol conformance&quot; is a behavior that is external to the language. I do not believe would be voluntarily added to Swift should the topic arise. Therefore I find it insufficient to introduce attributes like `@elective` or `@discretionary` in order to satisfy non-native requirements. I would prefer to see the @objc attribute be extended to support these and any future Objective-C-specific behaviors: @objc(elective), @objc(importedProtocolSupport: elective), or whatever. While these are wordy, I assume like any other Swift attributes they can be placed on a line before the function declaration, and it would be instantly clear why they&#39;ve been placed there, and they would not overlap with Swift semantics *or* expectations. I leave the color of the bikeshed as an exercise for the reader.<br></p><p>-- Erica<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160424/f3b178a0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Proposal draft] Make Optional Requirements Objective-C-only</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April 25, 2016 at 03:00:00am</p></header><div class="content"><p>I think there are some good points here. As a riff, though, I&#39;d argue that<br>Obj-C optional should *not* be renamed to elective or something else.<br>Renaming, so far, has been for the purpose of providing first-class Swifty<br>idioms for existing things. It makes moving between Swift-native code and<br>legacy code more seamless and encourages increased use of what&#39;s being<br>renamed. However, here we have something that we all agree isn&#39;t and cannot<br>be a Swift idiom. Yes, it&#39;s true that the name clashes with Swift optional,<br>but the very thing itself also clashes with how protocols requirements are<br>intended to work in Swift. It *shouldn&#39;t* look like a first-class Swift<br>concept.<br></p><p>On Sun, Apr 24, 2016 at 9:07 PM Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Apr 24, 2016, at 3:28 PM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Apr 22, 2016, at 8:02 PM, Douglas Gregor via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt;<br>&gt; Sent from my iPhone<br>&gt;<br>&gt; On Apr 22, 2016, at 5:56 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; Not an expert on Obj-C compatibility in Swift by any means, but this<br>&gt; reads like it&#39;s largely a change of nomenclature. To me, though,<br>&gt; `objcoptional` reads exceedingly poorly. Why not emphasize the Obj-C<br>&gt; compatibility angle by requiring the `@objc` attribute to precede each<br>&gt; use of `optional`? (In other words, effectively rename `optional` to<br>&gt; `@objc optional`.)<br>&gt;<br>&gt;<br>&gt; That is a great idea.<br>&gt;<br>&gt;<br>&gt; Doesn’t this have the same problem as the current (Swift 1/2)<br>&gt; implementation?  People will continue to believe that it is a bug that you<br>&gt; must specify @objc.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>&gt; I thought I&#39;d throw a few ideas into the mix. I&#39;m arriving late to the<br>&gt; discussion. (I didn&#39;t expect the conversation to last this long.) I did<br>&gt; take a quick look back through the thread but I may have missed some bits<br>&gt; along the way. Apologies in advance for any redundancy:<br>&gt;<br>&gt; * Optional requirement is an oxymoron. (This is a redux of my previous<br>&gt; contribution to this topic but it&#39;s a good starting point.)<br>&gt;<br>&gt; * Swift&#39;s &quot;optional&quot; protocol implementations are no such thing. They are<br>&gt; default implementations that can be overridden. (Tangentially, why not<br>&gt; introduce a required &quot;override&quot; keyword for conforming types that implement<br>&gt; a version of a member introduced in protocol extensions? This would match<br>&gt; the class approach and enhance safety and intent.)<br>&gt;<br>&gt; * Swift already has an `Optional` type. Importing ObjC &quot;optional&quot; protocol<br>&gt; requirements is therefore semantically problematic from a Swift development<br>&gt; POV. I don&#39;t like either the &quot;@objcoptional&quot; or &quot;@objc optional&quot; solutions<br>&gt; mentioned upthread. They overload &quot;optional&quot; syntactically and confuse<br>&gt; semantics. I think the key words that better describe what&#39;s happening in,<br>&gt; for example, a `UITableViewDelegate`, are &quot;*discretionary*&quot; or &quot;*elective*&quot;<br>&gt; implementations.  Swift has renamed lots of Objective C things (waves hi to<br>&gt; SE-0005<br>&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md&gt;).<br>&gt; Why not &quot;optional&quot;?<br>&gt;<br>&gt; * I do *support* retaining `@objc` in some form and I believe it can be<br>&gt; addressed in a way that does not appear to be a bug. &quot;Optional protocol<br>&gt; conformance&quot; is a behavior that is external to the language. I do not<br>&gt; believe would be voluntarily added to Swift should the topic arise.<br>&gt; Therefore I find it insufficient to introduce attributes like `@elective`<br>&gt; or `@discretionary` in order to satisfy non-native requirements. I would<br>&gt; prefer to see the @objc attribute be extended to support these and any<br>&gt; future Objective-C-specific behaviors: @objc(elective),<br>&gt; @objc(importedProtocolSupport: elective), or whatever. While these are<br>&gt; wordy, I assume like any other Swift attributes they can be placed on a<br>&gt; line before the function declaration, and it would be instantly clear why<br>&gt; they&#39;ve been placed there, and they would not overlap with Swift semantics<br>&gt; *or* expectations. I leave the color of the bikeshed as an exercise for the<br>&gt; reader.<br>&gt;<br>&gt; -- Erica<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160425/b68e1c77/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal draft] Make Optional Requirements Objective-C-only</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>April 25, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Apr 24, 2016, at 7:02 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 24, 2016, at 3:28 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Apr 22, 2016, at 8:02 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Apr 22, 2016, at 5:56 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Not an expert on Obj-C compatibility in Swift by any means, but this<br>&gt;&gt;&gt;&gt; reads like it&#39;s largely a change of nomenclature. To me, though,<br>&gt;&gt;&gt;&gt; `objcoptional` reads exceedingly poorly. Why not emphasize the Obj-C<br>&gt;&gt;&gt;&gt; compatibility angle by requiring the `@objc` attribute to precede each<br>&gt;&gt;&gt;&gt; use of `optional`? (In other words, effectively rename `optional` to<br>&gt;&gt;&gt;&gt; `@objc optional`.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That is a great idea. <br>&gt;&gt; <br>&gt;&gt; Doesn’t this have the same problem as the current (Swift 1/2) implementation?  People will continue to believe that it is a bug that you must specify @objc.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt; <br>&gt; I thought I&#39;d throw a few ideas into the mix. I&#39;m arriving late to the discussion. (I didn&#39;t expect the conversation to last this long.) I did take a quick look back through the thread but I may have missed some bits along the way. Apologies in advance for any redundancy:<br></p><p>&gt; * Swift&#39;s &quot;optional&quot; protocol implementations are no such thing. They are default implementations that can be overridden.<br></p><p>(Pulling this one out first). When I read “a default implementation that can be overridden”, I think of the conforming type *or a subclass thereof* providing a different implementation from the default. “Optional” requirements are things that the conforming type does not have to provide…. and a user of the protocol must cope with conforming types that don’t provide them.<br></p><p>&gt; (Tangentially, why not introduce a required &quot;override&quot; keyword for conforming types that implement a version of a member introduced in protocol extensions? This would match the class approach and enhance safety and intent.)<br></p><p>This is a commonly-requested feature that I don’t think we need. The TL;DR version is that I feel like specifying the conformance explicitly (my type Foo conforms to protocol P) already expresses intent, and the compiler should help with the rest. I’ve recently been working on providing better warnings for cases where one has tried to implement an optional requirement for a protocol (but got the declaration wrong), and I think we can turn it on for cases where one got a default implementation instead:<br></p><p>	http://thread.gmane.org/gmane.comp.lang.swift.devel/1799<br></p><p>&gt; <br>&gt; * Optional requirement is an oxymoron. (This is a redux of my previous contribution to this topic but it&#39;s a good starting point.)<br>&gt; <br>&gt; * Swift already has an `Optional` type. Importing ObjC &quot;optional&quot; protocol requirements is therefore semantically problematic from a Swift development POV. I don&#39;t like either the &quot;@objcoptional&quot; or &quot;@objc optional&quot; solutions mentioned upthread. They overload &quot;optional&quot; syntactically and confuse semantics. I think the key words that better describe what&#39;s happening in, for example, a `UITableViewDelegate`, are &quot;discretionary&quot; or &quot;elective&quot; implementations.  Swift has renamed lots of Objective C things (waves hi to SE-0005 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md&gt;). Why not &quot;optional”?<br></p><p>If we were adding optional requirements to Swift protocols, I would agree that it makes sense to change the nomenclature to avoid the oxymoron and the confusion with optionals. However, since this is now moving into the realm of “Objective-C compatibility feature”, I think it’s reasonable to retain the existing, Objective-C terminology.<br></p><p>Also, there is a link between the Optional type and optional requirements: when you reference an optional requirement, you get back an Optional.<br></p><p>&gt; * I do *support* retaining `@objc` in some form and I believe it can be addressed in a way that does not appear to be a bug. &quot;Optional protocol conformance&quot; is a behavior that is external to the language. I do not believe would be voluntarily added to Swift should the topic arise.<br></p><p>It’s a feature that exists to support compatibility with another language; we would not add it if it not for Objective-C. However, it is a real language feature with different semantics from other language features.<br></p><p>&gt; Therefore I find it insufficient to introduce attributes like `@elective` or `@discretionary` in order to satisfy non-native requirements. I would prefer to see the @objc attribute be extended to support these and any future Objective-C-specific behaviors: @objc(elective), @objc(importedProtocolSupport: elective), or whatever. While these are wordy, I assume like any other Swift attributes they can be placed on a line before the function declaration, and it would be instantly clear why they&#39;ve been placed there, and they would not overlap with Swift semantics *or* expectations. I leave the color of the bikeshed as an exercise for the reader.<br></p><p>Do remember that @objc(something) already has a meaning: it gives the Objective-C name “something” to the entity that the @objc(something) describes.<br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160425/2a09e16c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal draft] Make Optional Requirements Objective-C-only</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April 25, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Apr 25, 2016, at 10:49 AM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt; * Swift already has an `Optional` type. Importing ObjC &quot;optional&quot; protocol requirements is therefore semantically problematic from a Swift development POV. I don&#39;t like either the &quot;@objcoptional&quot; or &quot;@objc optional&quot; solutions mentioned upthread. They overload &quot;optional&quot; syntactically and confuse semantics. I think the key words that better describe what&#39;s happening in, for example, a `UITableViewDelegate`, are &quot;discretionary&quot; or &quot;elective&quot; implementations.  Swift has renamed lots of Objective C things (waves hi to SE-0005 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md&gt;). Why not &quot;optional”?<br>&gt; <br>&gt; If we were adding optional requirements to Swift protocols, I would agree that it makes sense to change the nomenclature to avoid the oxymoron and the confusion with optionals. However, since this is now moving into the realm of “Objective-C compatibility feature”, I think it’s reasonable to retain the existing, Objective-C terminology.<br>&gt; <br>&gt; Also, there is a link between the Optional type and optional requirements: when you reference an optional requirement, you get back an Optional.<br></p><p>Fair enough point but one that doesn&#39;t really sway me enough to include a native keyword for an ObjC compatibility feature.<br></p><p>&gt;&gt; * I do *support* retaining `@objc` in some form and I believe it can be addressed in a way that does not appear to be a bug. &quot;Optional protocol conformance&quot; is a behavior that is external to the language. I do not believe would be voluntarily added to Swift should the topic arise. <br>&gt; <br>&gt; It’s a feature that exists to support compatibility with another language; we would not add it if it not for Objective-C. However, it is a real language feature with different semantics from other language features.<br></p><p>Sounds like we&#39;re agreed on this point.<br></p><p>&gt;&gt; Therefore I find it insufficient to introduce attributes like `@elective` or `@discretionary` in order to satisfy non-native requirements. I would prefer to see the @objc attribute be extended to support these and any future Objective-C-specific behaviors: @objc(elective), @objc(importedProtocolSupport: elective), or whatever. While these are wordy, I assume like any other Swift attributes they can be placed on a line before the function declaration, and it would be instantly clear why they&#39;ve been placed there, and they would not overlap with Swift semantics *or* expectations. I leave the color of the bikeshed as an exercise for the reader.<br>&gt; <br>&gt; Do remember that @objc(something) already has a meaning: it gives the Objective-C name “something” to the entity that the @objc(something) describes.<br></p><p>And this is something I *did* overlook. Is there leeway to add labeled items `@objc(x: y)`?  If so, `@objc(something)` could transition to `@objc(somelabel: something)` and a separate label be used for this.<br></p><p>The key point I want to make is that something that is semantically and syntactically external to the language should enter through a well regulated gateway. That gateway should be marked in some fashion that contextualizes its use and understanding to the foreign source so it&#39;s immediately understood to be non-native. It doesn&#39;t have to be part of `@objc` but things that aren&#39;t Swift native should never have a first class presence in the language. The approach to supporting one non-native language should be extensible to supporting other non-native languages.<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160425/fb2f5953/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal draft] Make Optional Requirements Objective-C-only</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>April 25, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Apr 25, 2016, at 10:13 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 25, 2016, at 10:49 AM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; * Swift already has an `Optional` type. Importing ObjC &quot;optional&quot; protocol requirements is therefore semantically problematic from a Swift development POV. I don&#39;t like either the &quot;@objcoptional&quot; or &quot;@objc optional&quot; solutions mentioned upthread. They overload &quot;optional&quot; syntactically and confuse semantics. I think the key words that better describe what&#39;s happening in, for example, a `UITableViewDelegate`, are &quot;discretionary&quot; or &quot;elective&quot; implementations.  Swift has renamed lots of Objective C things (waves hi to SE-0005 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md&gt;). Why not &quot;optional”?<br>&gt;&gt; <br>&gt;&gt; If we were adding optional requirements to Swift protocols, I would agree that it makes sense to change the nomenclature to avoid the oxymoron and the confusion with optionals. However, since this is now moving into the realm of “Objective-C compatibility feature”, I think it’s reasonable to retain the existing, Objective-C terminology.<br>&gt;&gt; <br>&gt;&gt; Also, there is a link between the Optional type and optional requirements: when you reference an optional requirement, you get back an Optional.<br>&gt; <br>&gt; Fair enough point but one that doesn&#39;t really sway me enough to include a native keyword for an ObjC compatibility feature.<br></p><p>It’s a contextual keyword, so the impact is far less than a full-fledged keyword (but, point taken).<br></p><p>&gt; <br>&gt;&gt;&gt; Therefore I find it insufficient to introduce attributes like `@elective` or `@discretionary` in order to satisfy non-native requirements. I would prefer to see the @objc attribute be extended to support these and any future Objective-C-specific behaviors: @objc(elective), @objc(importedProtocolSupport: elective), or whatever. While these are wordy, I assume like any other Swift attributes they can be placed on a line before the function declaration, and it would be instantly clear why they&#39;ve been placed there, and they would not overlap with Swift semantics *or* expectations. I leave the color of the bikeshed as an exercise for the reader.<br>&gt;&gt; <br>&gt;&gt; Do remember that @objc(something) already has a meaning: it gives the Objective-C name “something” to the entity that the @objc(something) describes.<br>&gt; <br>&gt; And this is something I *did* overlook. Is there leeway to add labeled items `@objc(x: y)`?  If so, `@objc(something)` could transition to `@objc(somelabel: something)` and a separate label be used for this.<br></p><p>@objc(x: y) looks suspiciously like a typo for the selector @objc(x:y:).<br></p><p>&gt; <br>&gt; The key point I want to make is that something that is semantically and syntactically external to the language should enter through a well regulated gateway.<br></p><p>It’s not semantically and syntactically external. It is a real feature with specific, unique type-checking behavior. It is externally-motivated, and limited to interoperability with another language, but that doesn’t make it an external feature in the way that (say) some other tool that generates Swift code is external.<br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160425/0bf76956/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal draft] Make Optional Requirements Objective-C-only</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April 25, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Apr 25, 2016, at 11:49 AM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Apr 25, 2016, at 10:13 AM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Apr 25, 2016, at 10:49 AM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; * Swift already has an `Optional` type. Importing ObjC &quot;optional&quot; protocol requirements is therefore semantically problematic from a Swift development POV. I don&#39;t like either the &quot;@objcoptional&quot; or &quot;@objc optional&quot; solutions mentioned upthread. They overload &quot;optional&quot; syntactically and confuse semantics. I think the key words that better describe what&#39;s happening in, for example, a `UITableViewDelegate`, are &quot;discretionary&quot; or &quot;elective&quot; implementations.  Swift has renamed lots of Objective C things (waves hi to SE-0005 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md&gt;). Why not &quot;optional”?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If we were adding optional requirements to Swift protocols, I would agree that it makes sense to change the nomenclature to avoid the oxymoron and the confusion with optionals. However, since this is now moving into the realm of “Objective-C compatibility feature”, I think it’s reasonable to retain the existing, Objective-C terminology.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Also, there is a link between the Optional type and optional requirements: when you reference an optional requirement, you get back an Optional.<br>&gt;&gt; <br>&gt;&gt; Fair enough point but one that doesn&#39;t really sway me enough to include a native keyword for an ObjC compatibility feature.<br>&gt; <br>&gt; It’s a contextual keyword, so the impact is far less than a full-fledged keyword (but, point taken).<br></p><p>Ah, right. <br></p><p>&gt;&gt;&gt;&gt; Therefore I find it insufficient to introduce attributes like `@elective` or `@discretionary` in order to satisfy non-native requirements. I would prefer to see the @objc attribute be extended to support these and any future Objective-C-specific behaviors: @objc(elective), @objc(importedProtocolSupport: elective), or whatever. While these are wordy, I assume like any other Swift attributes they can be placed on a line before the function declaration, and it would be instantly clear why they&#39;ve been placed there, and they would not overlap with Swift semantics *or* expectations. I leave the color of the bikeshed as an exercise for the reader.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Do remember that @objc(something) already has a meaning: it gives the Objective-C name “something” to the entity that the @objc(something) describes.<br>&gt;&gt; <br>&gt;&gt; And this is something I *did* overlook. Is there leeway to add labeled items `@objc(x: y)`?  If so, `@objc(something)` could transition to `@objc(somelabel: something)` and a separate label be used for this.<br>&gt; <br>&gt; @objc(x: y) looks suspiciously like a typo for the selector @objc(x:y:).<br></p><p>Oh lord yes. Yes, it does. *headdesk*.<br></p><p>&gt;&gt; The key point I want to make is that something that is semantically and syntactically external to the language should enter through a well regulated gateway.<br>&gt; <br>&gt; It’s not semantically and syntactically external. It is a real feature with specific, unique type-checking behavior. It is externally-motivated, and limited to interoperability with another language, but that doesn’t make it an external feature in the way that (say) some other tool that generates Swift code is external.<br></p><p>I think I made my points at least in terms of objc optional requirements though: <br></p><p>1. I think it&#39;s a very good thing. <br>2. I wish there were a better way to express it.<br></p><p>-- E, cc&#39;ing in Chris who I believe *is* the review manager for SE-0070<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160425/193e427d/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5af07e950f10c7c1df1c44bed055c1eb?s=50"></div><header><strong>[Proposal draft] Make Optional Requirements Objective-C-only</strong> from <string>Daniel Steinberg</string> &lt;daniel at dimsumthinking.com&gt;<p>April 26, 2016 at 07:00:00am</p></header><div class="content"><p>I am very glad to see that Swift protocols will not support optional requirements.<br></p><p>I wonder, however, if @objc is the wrong label. The requirement is less because of Objective-C and more because of Cocoa/Cocoa Touch APIs. I wonder if it’s useful to separate which things are being implemented because of differences between Swift and Objective-C and which things are being implemented for compatibility with Cocoa APIs which happen to be written in Objective-C.<br></p><p>A second example might be IBOutlets which are vars and have types such as UILabel! because of how storyboards and nibs come to life. Perhaps an @cocoa decoration there might allow them to be let and type UILabel to imply that they should be initialized once and before they are used - a runtime crash at development time in the case of an unconnected outlet would be expected.<br></p><p>In any case, I am generally for the proposal but wondering if an @cocoa tag might be more descriptive than @objc.<br></p><p>Best,<br></p><p>Daniel<br></p><p><br></p><p>&gt; On Apr 25, 2016, at 7:13 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 25, 2016, at 10:49 AM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; * Swift already has an `Optional` type. Importing ObjC &quot;optional&quot; protocol requirements is therefore semantically problematic from a Swift development POV. I don&#39;t like either the &quot;@objcoptional&quot; or &quot;@objc optional&quot; solutions mentioned upthread. They overload &quot;optional&quot; syntactically and confuse semantics. I think the key words that better describe what&#39;s happening in, for example, a `UITableViewDelegate`, are &quot;discretionary&quot; or &quot;elective&quot; implementations.  Swift has renamed lots of Objective C things (waves hi to SE-0005 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md&gt;). Why not &quot;optional”?<br>&gt;&gt; <br>&gt;&gt; If we were adding optional requirements to Swift protocols, I would agree that it makes sense to change the nomenclature to avoid the oxymoron and the confusion with optionals. However, since this is now moving into the realm of “Objective-C compatibility feature”, I think it’s reasonable to retain the existing, Objective-C terminology.<br>&gt;&gt; <br>&gt;&gt; Also, there is a link between the Optional type and optional requirements: when you reference an optional requirement, you get back an Optional.<br>&gt; <br>&gt; Fair enough point but one that doesn&#39;t really sway me enough to include a native keyword for an ObjC compatibility feature.<br>&gt; <br>&gt;&gt;&gt; * I do *support* retaining `@objc` in some form and I believe it can be addressed in a way that does not appear to be a bug. &quot;Optional protocol conformance&quot; is a behavior that is external to the language. I do not believe would be voluntarily added to Swift should the topic arise. <br>&gt;&gt; <br>&gt;&gt; It’s a feature that exists to support compatibility with another language; we would not add it if it not for Objective-C. However, it is a real language feature with different semantics from other language features.<br>&gt; <br>&gt; Sounds like we&#39;re agreed on this point.<br>&gt; <br>&gt;&gt;&gt; Therefore I find it insufficient to introduce attributes like `@elective` or `@discretionary` in order to satisfy non-native requirements. I would prefer to see the @objc attribute be extended to support these and any future Objective-C-specific behaviors: @objc(elective), @objc(importedProtocolSupport: elective), or whatever. While these are wordy, I assume like any other Swift attributes they can be placed on a line before the function declaration, and it would be instantly clear why they&#39;ve been placed there, and they would not overlap with Swift semantics *or* expectations. I leave the color of the bikeshed as an exercise for the reader.<br>&gt;&gt; <br>&gt;&gt; Do remember that @objc(something) already has a meaning: it gives the Objective-C name “something” to the entity that the @objc(something) describes.<br>&gt; <br>&gt; And this is something I *did* overlook. Is there leeway to add labeled items `@objc(x: y)`?  If so, `@objc(something)` could transition to `@objc(somelabel: something)` and a separate label be used for this.<br>&gt; <br>&gt; The key point I want to make is that something that is semantically and syntactically external to the language should enter through a well regulated gateway. That gateway should be marked in some fashion that contextualizes its use and understanding to the foreign source so it&#39;s immediately understood to be non-native. It doesn&#39;t have to be part of `@objc` but things that aren&#39;t Swift native should never have a first class presence in the language. The approach to supporting one non-native language should be extensible to supporting other non-native languages.<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160426/23207cad/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>[Proposal draft] Make Optional Requirements Objective-C-only</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>April 26, 2016 at 03:00:00pm</p></header><div class="content"><p>Note much more then just Apple&#39;s frameworks leverage the optional protocol<br>feature of Objective-C. It really is tied to a feature of objective-c and<br>its dynamic runtime.<br></p><p>On Mon, Apr 25, 2016 at 10:30 PM Daniel Steinberg via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I am very glad to see that Swift protocols will not support optional<br>&gt; requirements.<br>&gt;<br>&gt; I wonder, however, if @objc is the wrong label. The requirement is less<br>&gt; because of Objective-C and more because of Cocoa/Cocoa Touch APIs. I wonder<br>&gt; if it’s useful to separate which things are being implemented because of<br>&gt; differences between Swift and Objective-C and which things are being<br>&gt; implemented for compatibility with Cocoa APIs which happen to be written in<br>&gt; Objective-C.<br>&gt;<br>&gt; A second example might be IBOutlets which are vars and have types such as<br>&gt; UILabel! because of how storyboards and nibs come to life. Perhaps an<br>&gt; @cocoa decoration there might allow them to be let and type UILabel to<br>&gt; imply that they should be initialized once and before they are used - a<br>&gt; runtime crash at development time in the case of an unconnected outlet<br>&gt; would be expected.<br>&gt;<br>&gt; In any case, I am generally for the proposal but wondering if an @cocoa<br>&gt; tag might be more descriptive than @objc.<br>&gt;<br>&gt; Best,<br>&gt;<br>&gt; Daniel<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Apr 25, 2016, at 7:13 PM, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Apr 25, 2016, at 10:49 AM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;<br>&gt; * Swift already has an `Optional` type. Importing ObjC &quot;optional&quot; protocol<br>&gt; requirements is therefore semantically problematic from a Swift development<br>&gt; POV. I don&#39;t like either the &quot;@objcoptional&quot; or &quot;@objc optional&quot; solutions<br>&gt; mentioned upthread. They overload &quot;optional&quot; syntactically and confuse<br>&gt; semantics. I think the key words that better describe what&#39;s happening in,<br>&gt; for example, a `UITableViewDelegate`, are &quot;*discretionary*&quot; or &quot;*elective*&quot;<br>&gt; implementations.  Swift has renamed lots of Objective C things (waves hi to<br>&gt; SE-0005<br>&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md&gt;).<br>&gt; Why not &quot;optional”?<br>&gt;<br>&gt;<br>&gt; If we were adding optional requirements to Swift protocols, I would agree<br>&gt; that it makes sense to change the nomenclature to avoid the oxymoron and<br>&gt; the confusion with optionals. However, since this is now moving into the<br>&gt; realm of “Objective-C compatibility feature”, I think it’s reasonable to<br>&gt; retain the existing, Objective-C terminology.<br>&gt;<br>&gt; Also, there is a link between the Optional type and optional requirements:<br>&gt; when you reference an optional requirement, you get back an Optional.<br>&gt;<br>&gt;<br>&gt; Fair enough point but one that doesn&#39;t really sway me enough to include a<br>&gt; native keyword for an ObjC compatibility feature.<br>&gt;<br>&gt; * I do *support* retaining `@objc` in some form and I believe it can be<br>&gt; addressed in a way that does not appear to be a bug. &quot;Optional protocol<br>&gt; conformance&quot; is a behavior that is external to the language. I do not<br>&gt; believe would be voluntarily added to Swift should the topic arise.<br>&gt;<br>&gt;<br>&gt; It’s a feature that exists to support compatibility with another language;<br>&gt; we would not add it if it not for Objective-C. However, it is a real<br>&gt; language feature with different semantics from other language features.<br>&gt;<br>&gt;<br>&gt; Sounds like we&#39;re agreed on this point.<br>&gt;<br>&gt; Therefore I find it insufficient to introduce attributes like `@elective`<br>&gt; or `@discretionary` in order to satisfy non-native requirements. I would<br>&gt; prefer to see the @objc attribute be extended to support these and any<br>&gt; future Objective-C-specific behaviors: @objc(elective),<br>&gt; @objc(importedProtocolSupport: elective), or whatever. While these are<br>&gt; wordy, I assume like any other Swift attributes they can be placed on a<br>&gt; line before the function declaration, and it would be instantly clear why<br>&gt; they&#39;ve been placed there, and they would not overlap with Swift semantics<br>&gt; *or* expectations. I leave the color of the bikeshed as an exercise for the<br>&gt; reader.<br>&gt;<br>&gt;<br>&gt; Do remember that @objc(something) already has a meaning: it gives the<br>&gt; Objective-C name “something” to the entity that the @objc(something)<br>&gt; describes.<br>&gt;<br>&gt;<br>&gt; And this is something I *did* overlook. Is there leeway to add labeled<br>&gt; items `@objc(x: y)`?  If so, `@objc(something)` could transition to<br>&gt; `@objc(somelabel: something)` and a separate label be used for this.<br>&gt;<br>&gt; The key point I want to make is that something that is semantically and<br>&gt; syntactically external to the language should enter through a well<br>&gt; regulated gateway. That gateway should be marked in some fashion that<br>&gt; contextualizes its use and understanding to the foreign source so it&#39;s<br>&gt; immediately understood to be non-native. It doesn&#39;t have to be part of<br>&gt; `@objc` but things that aren&#39;t Swift native should never have a first class<br>&gt; presence in the language. The approach to supporting one non-native<br>&gt; language should be extensible to supporting other non-native languages.<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160426/fea7906d/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Proposal draft] Make Optional Requirements Objective-C-only</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>April 25, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Apr 25, 2016, at 11:49 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; (Tangentially, why not introduce a required &quot;override&quot; keyword for conforming types that implement a version of a member introduced in protocol extensions? This would match the class approach and enhance safety and intent.)<br>&gt; <br>&gt; This is a commonly-requested feature that I don’t think we need. The TL;DR version is that I feel like specifying the conformance explicitly (my type Foo conforms to protocol P) already expresses intent, and the compiler should help with the rest. I’ve recently been working on providing better warnings for cases where one has tried to implement an optional requirement for a protocol (but got the declaration wrong), and I think we can turn it on for cases where one got a default implementation instead:<br></p><p>The trouble with this is that it can be quite non-obvious whether a method in a protocol is required or not. If you have this:<br></p><p>protocol Foo {<br>    func bar()<br>    func baz ()<br>}<br></p><p>extension Foo {<br>    func bar() {}<br>}<br></p><p>it will generate this interface:<br></p><p>internal protocol Foo {<br>    internal func bar()<br>    internal func baz()<br>}<br></p><p>extension Foo {<br>    internal func bar()<br>}<br></p><p>There’s no way to tell which method you actually have to implement, simply from looking at the protocol. When there are only two methods, this isn’t hard to figure out, but what if there are 25 methods, each with extensive header docs in front of the declaration, and only two of them are required? The only way to find the required ones would be to first completely search through the entire library and/or framework for extensions on this type. Then, you&#39;d look at the first method in the protocol, scroll down to the extension, scour the extension for that method name, then scour any *other* extensions you’ve found for the method name, then scroll back up to the protocol, look at the next method. Now, repeat the whole thing until you’ve done it 25 times, and hope you haven’t failed to spot a method name in an extension somewhere.<br></p><p>The upshot of all this is that it’s pretty easy to accidentally implement a method on a protocol because you thought you had to, when actually you didn’t. Requiring “override” would at least prevent that, although IMO it would be best if there were some kind of annotation on the protocol’s interface letting you know if there were already a default implementation for that method, similar to Objective-C’s good old optional keyword.<br></p><p>Charles<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
