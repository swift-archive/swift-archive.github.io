<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e5bef3c5aff006b706278c43654a8ed7?s=50"></div><header><strong>Optimising Set&lt;String&gt; comparisons</strong> from <string>Nial Giacomelli</string> &lt;measuredweighed at gmail.com&gt;<p>November 14, 2016 at 09:00:00pm</p></header><div class="content"><p>Many thanks to Tim for suggesting isSubset, which I had somehow missed<br>while browsing the documentation.<br></p><p>To answer Dave&#39;s questions: unfortunately the Set comparisons aren&#39;t an<br>ideal candidate for asynchronous work. The comparisons take place as part<br>of a CSS-like styling phase, whereby a number of Sets (the stylesheet<br>definitions) are compared against many thousands of other Sets (the class<br>lists for each styleable object). While I believe the Int comparisons would<br>undoubtedly be faster, I&#39;m likely to lose even more time calculating the<br>hashValues for each Set.<br></p><p>I believe the use of isSubset as well as some result caching (storing<br>matches for subsequent queries including identical class lists) is likely<br>to result in a decent speed improvement. Thank you both for taking the time<br>to respond.<br></p><p>And if anyone has any suggestions for alternative approaches I&#39;m all ears<br>:-)<br></p><p>On Sun, Nov 13, 2016 at 11:49 PM, David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Nov 13, 2016, at 1:58 PM, Nial Giacomelli via swift-users &lt;<br>&gt; swift-users at swift.org&gt; wrote:<br>&gt;<br>&gt; Using Swift 3 I have a function that&#39;s called extremely frequently and is<br>&gt; appearing regularly in Profiler runs. The function takes two Set&lt;String&gt;<br>&gt; instances and simply attempts to determine whether all items from Set A are<br>&gt; present in Set B (it&#39;s important to note that Set B may well contain<br>&gt; additional items).<br>&gt;<br>&gt; I&#39;ve attempted to approach the problem in two ways:<br>&gt;<br>&gt; let diff = a.subtracting(b)<br>&gt; guard diff.count == 0 else { return false }<br>&gt;<br>&gt; And also by simply iterating over the contents of Set A, like so:<br>&gt;<br>&gt; for item in a {<br>&gt; if !b.contains(item) {<br>&gt; return false<br>&gt; }<br>&gt; }<br>&gt;<br>&gt; Both ultimately end up spending the majority of their time in String._<br>&gt; compareDeterministicUnicodeCollaton(String) -&gt; Int. Which makes sense,<br>&gt; given what I&#39;m doing - but ideally I&#39;d like to come up with a more<br>&gt; efficient way of performing the above check. Swift&#39;s String representation<br>&gt; is incredibly robust, but for my needs the strings could be adequately<br>&gt; represented in ASCII encoding. I&#39;ve also considered storing and comparing<br>&gt; the hashValue of the strings, to speed up comparisons...<br>&gt;<br>&gt; Hopefully this is an acceptable question for this mailing list. I&#39;m aware<br>&gt; that this may not be a Swift-specific question and could well be solved<br>&gt; with a more efficient data structure or approach, but I&#39;d really appreciate<br>&gt; some input from more experienced Swift developers :-)<br>&gt;<br>&gt;<br>&gt; How often do the sets change? And where do you get them from? I’m<br>&gt; wondering, if there’s enough time between when you get the strings and when<br>&gt; you need to know if setA is a subset of setB, could you somehow compute the<br>&gt; answer asynchronously in a background thread or something? Strictly<br>&gt; speaking it wouldn&#39;t be any less work, but if you can move it to where<br>&gt; you’re waiting for user input or something you’ll probably get your answer<br>&gt; sooner.<br>&gt;<br>&gt; Regarding how to get the answer using less work in the first place, I<br>&gt; think you’re doing a tiny bit of extra work — just some allocation<br>&gt; overhead, really — by calculating the set difference and checking that its<br>&gt; count == 0, rather than just checking if a.isSubset(of: b). Beyond that,<br>&gt; I’m not really sure… You might be able to do something with the strings’<br>&gt; hash values. I mean, I don’t know if they really “work like that” (I’m<br>&gt; quite foggy on how hash values are calculated and exactly what they’re<br>&gt; suitable for… this might be a horrible idea), but if they do, comparing<br>&gt; hash values (Ints) will definitely be faster than comparing Strings. I did<br>&gt; some quick’n’dirty testing on my machine with some code very much like:<br>&gt;<br>&gt; let setA: Set&lt;String&gt; = [&quot;some&quot;, &quot;set&quot;, &quot;of&quot;, &quot;random&quot;, &quot;strings&quot;]<br>&gt; let setB: Set&lt;String&gt; = [&quot;some&quot;, &quot;other&quot;, &quot;set&quot;, &quot;of&quot;, &quot;strings&quot;]<br>&gt; let hashedA = Set(setA.map{$0.hashValue})<br>&gt; let hashedB = Set(setB.map{$0.hashValue})<br>&gt; setA.isSubset(of: setB)<br>&gt; hashedA.isSubset(of: hashedB)<br>&gt;<br>&gt;<br>&gt; The actual execution of hashedA.isSubset(of: hashedB) seems to be very<br>&gt; roughly 2x faster than setA.isSubset(of: setB). However, if you include<br>&gt; the overhead of calculating them, using hash values drops to about 5x<br>&gt; *slower*. So unless you’d be reusing the hashed values a lot or<br>&gt; something, I think you’re already doing about the least amount of work I<br>&gt; can think of.<br>&gt;<br>&gt; - Dave Sweeris<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20161114/02a25645/attachment.html&gt;<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
