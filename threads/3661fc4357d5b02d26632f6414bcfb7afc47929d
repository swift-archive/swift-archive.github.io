<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2679e7a28cb46e207a562ad4e7fc45fc?s=50"></div><header><strong>[Pitch] Reference equivalent to value-type &#39;enum&#39;</strong> from <string>James F</string> &lt;conductator at ntlworld.com&gt;<p>May  5, 2016 at 09:00:00am</p></header><div class="content"><p>I haven&#39;t tried any languages which have anything like this, but I support the idea of bringing real properties and single-case functions to enums in this way. Using properties rather than parameterised values will prevent pattern matching in switch statements to get those properties, but the idea of generic parameters being able to hold values gets thrown about a lot, which could eventually provide that functionality to enum classes, making pure enums a subset of their functionality.<br></p><p>If there&#39;s one fault I can see with this proposal, it&#39;s that it&#39;s lacking a value-type equivalent, an ‘enum struct’. ;)<br></p><p>------------ Begin Message ------------ <br>Group: gmane.comp.lang.swift.evolution <br>MsgID: &lt;CANGnqV2O8eEo=Kw+fd9phpE_KT0NyvstrgNSHBBtTrj6gnpH7Q at mail.gmail.com&gt; <br></p><p>Hello swift-evolution:<br></p><p>Based on recent conversations on the list, I&#39;d like to float a trial<br>balloon: an &quot;enum class&quot; kind which is analogous to classes in the same way<br>existing enums are to structs. This is a data type which allows the user to<br>define a number of cases, like enums, and can participate in pattern<br>matching and exhaustivity analysis. Instances of an enum class are<br>reference types, which enables (for example) graph nodes with a built-in<br>concept of identity.<br></p><p>To be slightly more fanciful, perhaps such a kind could be treated as an<br>&#39;almost-final&#39; class, with each case being a nested type which is defined<br>as a final subclass of the enum class. Cases could then define their own<br>behavior:<br></p><p>enum class GraphNode {<br>  case Node(left: GraphNode, right: GraphNode) {<br>    override func foo() { ... }<br>    func nodeSpecificMethod() { ... }<br>  }<br></p><p>  case Leaf {<br>    override func foo() { ... }<br>    func leafSpecificMethod() { ... }<br>  }<br></p><p>  func foo() { ... }<br>}<br></p><p>let x : GraphNode = GraphNode.newEmptyTree()<br>let y : GraphNode = GraphNode.Node(l, r)<br>let z : GraphNode = GraphNode.Leaf()<br>let a : GraphNode.Leaf = GraphNode.Leaf()<br></p><p>Enum classes would not be subclassible, and extensions would not be able to<br>define new cases (as is the case with normal enums at the present time).<br></p><p>My superficial analysis seems to suggest that this would solve two issues:<br>providing a reference-semantics type with all the pattern matching<br>functionality of current enums, and providing a construct for modeling<br>case-class style ADTs where each case should be treated as a subtype (as<br>has been occasionally proposed).<br></p><p>I would like feedback as to:<br>- Whether this is something that would be useful enough to justify<br>additional language features<br>- Whether this is something that would be theoretically well-founded and<br>elegant<br></p><p>Thanks for your time, and have a great day!<br></p><p>Austin<br></p><p><br></p><p>------------- End Message ------------- <br></p><p><br></p><p>From James F<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Pitch] Reference equivalent to value-type &#39;enum&#39;</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May  5, 2016 at 02:00:00am</p></header><div class="content"><p>Thanks!<br></p><p>I&#39;m sadly not very coherent at this hour, but I just wanted to make a few small notes:<br></p><p>- I&#39;m neutral as to whether stored properties should be allowed in the design. The value type memory layout issues which prohibit stored properties in normal enums won&#39;t apply to &#39;enum classes&#39;. However, there may be other reasons to prohibit them.<br></p><p>- If enum classes&#39; cases should be allowed to define per-case methods and stored properties (as opposed to just overriding those from the base class), two modes of interaction naturally fall out of the existing semantics. The user can either pattern match against the case itself (case .Node(let left, right)), which emphasizes the shared behavior, or they can use the downcast pattern match (case let myLeaf as Graph.Leaf), which emphasizes the per-case behavior.<br></p><p>- The &quot;should enum cases be distinct but related types&quot; question has been debated occasionally on the list. I think the proposed design has a duality where reference enums provide opt-in distinct type behavior naturally through subclassing, while value enums continue behaving the way they do currently. Value type inheritance has been mentioned, but if it goes in at all it will probably resemble implicit conversions far more than &#39;traditional&#39; OO inheritance. This proposal tries to incrementally extend existing class/struct semantics to produce something that (hopefully) won&#39;t surprise developers who try using it.<br></p><p>Austin<br></p><p>&gt; On May 5, 2016, at 1:25 AM, James Froggatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I haven&#39;t tried any languages which have anything like this, but I support the idea of bringing real properties and single-case functions to enums in this way. Using properties rather than parameterised values will prevent pattern matching in switch statements to get those properties, but the idea of generic parameters being able to hold values gets thrown about a lot, which could eventually provide that functionality to enum classes, making pure enums a subset of their functionality.<br>&gt; <br>&gt; If there&#39;s one fault I can see with this proposal, it&#39;s that it&#39;s lacking a value-type equivalent, an ‘enum struct’. ;)<br>&gt; <br>&gt; ------------ Begin Message ------------ <br>&gt; Group: gmane.comp.lang.swift.evolution <br>&gt; MsgID: &lt;CANGnqV2O8eEo=Kw+fd9phpE_KT0NyvstrgNSHBBtTrj6gnpH7Q at mail.gmail.com&gt; <br>&gt; <br>&gt; Hello swift-evolution:<br>&gt; <br>&gt; Based on recent conversations on the list, I&#39;d like to float a trial<br>&gt; balloon: an &quot;enum class&quot; kind which is analogous to classes in the same way<br>&gt; existing enums are to structs. This is a data type which allows the user to<br>&gt; define a number of cases, like enums, and can participate in pattern<br>&gt; matching and exhaustivity analysis. Instances of an enum class are<br>&gt; reference types, which enables (for example) graph nodes with a built-in<br>&gt; concept of identity.<br>&gt; <br>&gt; To be slightly more fanciful, perhaps such a kind could be treated as an<br>&gt; &#39;almost-final&#39; class, with each case being a nested type which is defined<br>&gt; as a final subclass of the enum class. Cases could then define their own<br>&gt; behavior:<br>&gt; <br>&gt; enum class GraphNode {<br>&gt;  case Node(left: GraphNode, right: GraphNode) {<br>&gt;    override func foo() { ... }<br>&gt;    func nodeSpecificMethod() { ... }<br>&gt;  }<br>&gt; <br>&gt;  case Leaf {<br>&gt;    override func foo() { ... }<br>&gt;    func leafSpecificMethod() { ... }<br>&gt;  }<br>&gt; <br>&gt;  func foo() { ... }<br>&gt; }<br>&gt; <br>&gt; let x : GraphNode = GraphNode.newEmptyTree()<br>&gt; let y : GraphNode = GraphNode.Node(l, r)<br>&gt; let z : GraphNode = GraphNode.Leaf()<br>&gt; let a : GraphNode.Leaf = GraphNode.Leaf()<br>&gt; <br>&gt; Enum classes would not be subclassible, and extensions would not be able to<br>&gt; define new cases (as is the case with normal enums at the present time).<br>&gt; <br>&gt; My superficial analysis seems to suggest that this would solve two issues:<br>&gt; providing a reference-semantics type with all the pattern matching<br>&gt; functionality of current enums, and providing a construct for modeling<br>&gt; case-class style ADTs where each case should be treated as a subtype (as<br>&gt; has been occasionally proposed).<br>&gt; <br>&gt; I would like feedback as to:<br>&gt; - Whether this is something that would be useful enough to justify<br>&gt; additional language features<br>&gt; - Whether this is something that would be theoretically well-founded and<br>&gt; elegant<br>&gt; <br>&gt; Thanks for your time, and have a great day!<br>&gt; <br>&gt; Austin<br>&gt; <br>&gt; <br>&gt; <br>&gt; ------------- End Message ------------- <br>&gt; <br>&gt; <br>&gt; <br>&gt; From James F<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
