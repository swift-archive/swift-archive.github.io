<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Reimagining guard case/if case</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>October 24, 2016 at 10:00:00am</p></header><div class="content"><p>Pitch: I&#39;d like to simplify `if case`/`guard case` to drop `case` and replace the equal sign with the pattern matching (`~=`) operator. I think it&#39;s simpler, reads better, and emphasizes &quot;this is pattern matching&quot; in a way the current grammar does not.<br></p><p>gist: https://gist.github.com/erica/1a5ce8a5157158c6400efb550778cead &lt;https://gist.github.com/erica/1a5ce8a5157158c6400efb550778cead&gt;<br></p><p>Simplifying guard case/if case syntax<br></p><p>Proposal: TBD<br>Author: Erica Sadun &lt;https://github.com/erica&gt;<br>Status: TBD<br>Review manager: TBD<br></p><p> &lt;https://gist.github.com/erica/1a5ce8a5157158c6400efb550778cead#introduction&gt;Introduction<br></p><p>This proposal simplifies guard case and if case grammar. It drops the case keyword and replaces the assignment sign with the pattern matching (~=) operator. The results are simpler, they reads better, and it transfers the responsibility of saying &quot;this is pattern matching&quot; from case to ~=.<br></p><p>Swift-evolution thread: [Pitch] Reimagining guard case/if case &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20161024/tbd.html&gt;<br> &lt;https://gist.github.com/erica/1a5ce8a5157158c6400efb550778cead#motivation&gt;Motivation<br></p><p>Swift&#39;s guard case and if case statements stand out for their unintuitive approach. They look like assignment statements but they are not assignment statements. They present difficulties for new language adopters because they combine several concepts in a confusing form. They are arguably underutilized by language experts.<br></p><p>Both guard case and `if case statements perform simultaneous pattern matching and conditional binding. Here are examples demonstrating their use in current Swift:<br></p><p>enum Result&lt;T&gt; { case success(T), error(Error) }<br></p><p>// valid Swift<br>guard case let .success(value) = result<br>    else { ... }<br></p><p>// valid Swift<br>guard case .success(let value) = result<br>    else { ... }<br>The status quo is iteratively built up in this fashion:<br></p><p>= performs assignment<br>let x = performs binding<br>if let x = performs conditional binding<br>if case .foo(let x) = performs conditional binding and pattern matching<br>When using if case/guard case in the absense of conditional binding, it duplicates basic pattern matching but uses less obvious semantics. These two statements are functionally identical:<br></p><p>if range ~= myValue { ... } // simpler<br>if case range = myValue { ... } // confusing<br>The problems with guard case and if case include:<br></p><p>The = operator looks like assignment and not like pattern matching (~=). <br>The case layout is both too close to a switch&#39;s case but doesn&#39;t follow its syntax. In switch, a case is followed by a colon, not an equal sign.<br>Using the case syntax is unneccessarily wordy. It incorporates case, =, and optionally let/var assignments.<br></p><p> &lt;https://gist.github.com/erica/1a5ce8a5157158c6400efb550778cead#detailed-design&gt;Detailed Design<br></p><p>This proposal replaces the current syntax with a simpler grammar that prioritizes pattern matching but mirrors basic conditional binding. The new syntax drops the case keyword and replaces = with ~=. The results look like this:<br></p><p>guard let .success(value) ~= result { ... }<br>guard .success(let value) ~= result { ... }<br>if let .success(value) ~= result { ... }<br>if .success(let value) ~= result { ... }<br>guard let x? ~= anOptional { ... }<br>if let x? ~= anOptional { ... }<br>In this update:<br></p><p>The case keyword is subsumed into the (existing) pattern matching operator<br>The statements adopt the existing if-let and guard-let syntax, including Optional syntactic sugar.<br>if let x = anOptional { ... } // current<br>if case let x? = anOptional { ... } // current, would be removed<br></p><p>if let x? ~= anOptional { ... } // proposed replacement for `if case`<br>On adopting this syntax, the two identical range tests naturally unify to this single version:<br></p><p>if range ~= myValue { ... } // before<br>if case range = myValue { ... } // before<br></p><p>if range ~= myValue { ... } // after<br>Using pattern matching without conditional binding naturally simplifies to a standalone Boolean condition clause.<br></p><p><br> &lt;https://gist.github.com/erica/1a5ce8a5157158c6400efb550778cead#impact-on-existing-code&gt;Impact on Existing Code<br></p><p>This proposal is breaking and would require migration.<br></p><p><br> &lt;https://gist.github.com/erica/1a5ce8a5157158c6400efb550778cead#alternatives-considered&gt;Alternatives Considered<br></p><p>Leaving the grammar as-is, albeit confusing<br>Retaining case and replacing the equal sign with ~= (pattern matching) or : (to match the switch statement).<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161024/2ae7d764/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14f382feb5f0dd3d3700edf8d6156aa9?s=50"></div><header><strong>[Pitch] Reimagining guard case/if case</strong> from <string>Jay Abbott</string> &lt;jay at abbott.me.uk&gt;<p>October 24, 2016 at 04:00:00pm</p></header><div class="content"><p>Hey Erica,<br></p><p>It&#39;s not clear in the examples, but are you proposing to drop the &#39;else&#39;<br>from guard too?<br></p><p>I hope not, because &#39;guard&#39; as a keyword is slightly confusing as it is,<br>the &#39;else&#39; is the only part of it that makes it clear.<br></p><p>In English you generally want to guard &quot;against&quot; something, so guard reads<br>a bit like:<br>guard [against] x == 0 else {do this}<br>Which doesn&#39;t make sense, what it really means is:<br>guard [that] x == 0, else {do this}<br></p><p>I think that &quot;ensure&quot; would have been a better word:<br>ensure [that] x == 0 else {do this}<br></p><p>Anyway - hopefully this is just an oversight.<br></p><p><br>On Mon, 24 Oct 2016 at 17:25 Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Pitch: I&#39;d like to simplify `if case`/`guard case` to drop `case` and<br>&gt; replace the equal sign with the pattern matching (`~=`) operator. I think<br>&gt; it&#39;s simpler, reads better, and emphasizes &quot;this is pattern matching&quot; in a<br>&gt; way the current grammar does not.<br>&gt;<br>&gt; gist: https://gist.github.com/erica/1a5ce8a5157158c6400efb550778cead<br>&gt;<br>&gt; Simplifying guard case/if case syntax<br>&gt;<br>&gt;    - Proposal: TBD<br>&gt;    - Author: Erica Sadun &lt;https://github.com/erica&gt;<br>&gt;    - Status: TBD<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/1a5ce8a5157158c6400efb550778cead#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; This proposal simplifies guard case and if case grammar. It drops the case keyword<br>&gt; and replaces the assignment sign with the pattern matching (~=) operator.<br>&gt; The results are simpler, they reads better, and it transfers the<br>&gt; responsibility of saying &quot;this is pattern matching&quot; from case to ~=.<br>&gt;<br>&gt; Swift-evolution thread: [Pitch] Reimagining guard case/if case<br>&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20161024/tbd.html&gt;<br>&gt; &lt;https://gist.github.com/erica/1a5ce8a5157158c6400efb550778cead#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; Swift&#39;s guard case and if case statements stand out for their unintuitive<br>&gt; approach. They look like assignment statements but they are not assignment<br>&gt; statements. They present difficulties for new language adopters because<br>&gt; they combine several concepts in a confusing form. They are arguably<br>&gt; underutilized by language experts.<br>&gt;<br>&gt; Both guard case and `if case statements perform simultaneous pattern<br>&gt; matching and conditional binding. Here are examples demonstrating their use<br>&gt; in current Swift:<br>&gt;<br>&gt; enum Result&lt;T&gt; { case success(T), error(Error) }<br>&gt;<br>&gt; // valid Swift<br>&gt; guard case let .success(value) = result<br>&gt;     else { ... }<br>&gt;<br>&gt; // valid Swift<br>&gt; guard case .success(let value) = result<br>&gt;     else { ... }<br>&gt;<br>&gt; The status quo is iteratively built up in this fashion:<br>&gt;<br>&gt;    - = performs assignment<br>&gt;    - let x = performs binding<br>&gt;    - if let x = performs conditional binding<br>&gt;    - if case .foo(let x) = performs conditional binding *and* pattern<br>&gt;    matching<br>&gt;<br>&gt; When using if case/guard case in the absense of conditional binding, it<br>&gt; duplicates basic pattern matching but uses less obvious semantics. These<br>&gt; two statements are functionally identical:<br>&gt;<br>&gt; if range ~= myValue { ... } // simpler<br>&gt; if case range = myValue { ... } // confusing<br>&gt;<br>&gt; The problems with guard case and if case include:<br>&gt;<br>&gt;    - The = operator looks like assignment and not like pattern matching (<br>&gt;    ~=).<br>&gt;    - The case layout is both too close to a switch&#39;s case but doesn&#39;t<br>&gt;    follow its syntax. In switch, a case is followed by a colon, not an<br>&gt;    equal sign.<br>&gt;    - Using the case syntax is unneccessarily wordy. It incorporates case,<br>&gt;    =, and optionally let/var assignments.<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/1a5ce8a5157158c6400efb550778cead#detailed-design&gt;Detailed<br>&gt; Design<br>&gt;<br>&gt; This proposal replaces the current syntax with a simpler grammar that<br>&gt; prioritizes pattern matching but mirrors basic conditional binding. The new<br>&gt; syntax drops the case keyword and replaces = with ~=. The results look<br>&gt; like this:<br>&gt;<br>&gt; guard let .success(value) ~= result { ... }<br>&gt; guard .success(let value) ~= result { ... }<br>&gt; if let .success(value) ~= result { ... }<br>&gt; if .success(let value) ~= result { ... }<br>&gt; guard let x? ~= anOptional { ... }<br>&gt; if let x? ~= anOptional { ... }<br>&gt;<br>&gt; In this update:<br>&gt;<br>&gt;    - The case keyword is subsumed into the (existing) pattern matching<br>&gt;    operator<br>&gt;    - The statements adopt the existing if-let and guard-let syntax,<br>&gt;    including Optional syntactic sugar.<br>&gt;<br>&gt; if let x = anOptional { ... } // current<br>&gt; if case let x? = anOptional { ... } // current, would be removed<br>&gt;<br>&gt; if let x? ~= anOptional { ... } // proposed replacement for `if case`<br>&gt;<br>&gt; On adopting this syntax, the two identical range tests naturally unify to<br>&gt; this single version:<br>&gt;<br>&gt; if range ~= myValue { ... } // before<br>&gt; if case range = myValue { ... } // before<br>&gt;<br>&gt; if range ~= myValue { ... } // after<br>&gt;<br>&gt; Using pattern matching without conditional binding naturally simplifies to<br>&gt; a standalone Boolean condition clause.<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/1a5ce8a5157158c6400efb550778cead#impact-on-existing-code&gt;Impact<br>&gt; on Existing Code<br>&gt;<br>&gt; This proposal is breaking and would require migration.<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/1a5ce8a5157158c6400efb550778cead#alternatives-considered&gt;Alternatives<br>&gt; Considered<br>&gt;<br>&gt;    - Leaving the grammar as-is, albeit confusing<br>&gt;    - Retaining case and replacing the equal sign with ~= (pattern<br>&gt;    matching) or : (to match the switch statement).<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161024/d675764c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14f382feb5f0dd3d3700edf8d6156aa9?s=50"></div><header><strong>[Pitch] Reimagining guard case/if case</strong> from <string>Jay Abbott</string> &lt;jay at abbott.me.uk&gt;<p>October 24, 2016 at 04:00:00pm</p></header><div class="content"><p>Oh... and yeah I like the idea of dropping the &#39;case&#39; word in this context,<br>it makes sense.<br></p><p>On Mon, 24 Oct 2016 at 17:44 Jay Abbott &lt;jay at abbott.me.uk&gt; wrote:<br></p><p>&gt; Hey Erica,<br>&gt;<br>&gt; It&#39;s not clear in the examples, but are you proposing to drop the &#39;else&#39;<br>&gt; from guard too?<br>&gt;<br>&gt; I hope not, because &#39;guard&#39; as a keyword is slightly confusing as it is,<br>&gt; the &#39;else&#39; is the only part of it that makes it clear.<br>&gt;<br>&gt; In English you generally want to guard &quot;against&quot; something, so guard reads<br>&gt; a bit like:<br>&gt; guard [against] x == 0 else {do this}<br>&gt; Which doesn&#39;t make sense, what it really means is:<br>&gt; guard [that] x == 0, else {do this}<br>&gt;<br>&gt; I think that &quot;ensure&quot; would have been a better word:<br>&gt; ensure [that] x == 0 else {do this}<br>&gt;<br>&gt; Anyway - hopefully this is just an oversight.<br>&gt;<br>&gt;<br>&gt; On Mon, 24 Oct 2016 at 17:25 Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Pitch: I&#39;d like to simplify `if case`/`guard case` to drop `case` and<br>&gt; replace the equal sign with the pattern matching (`~=`) operator. I think<br>&gt; it&#39;s simpler, reads better, and emphasizes &quot;this is pattern matching&quot; in a<br>&gt; way the current grammar does not.<br>&gt;<br>&gt; gist: https://gist.github.com/erica/1a5ce8a5157158c6400efb550778cead<br>&gt;<br>&gt; Simplifying guard case/if case syntax<br>&gt;<br>&gt;    - Proposal: TBD<br>&gt;    - Author: Erica Sadun &lt;https://github.com/erica&gt;<br>&gt;    - Status: TBD<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/1a5ce8a5157158c6400efb550778cead#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; This proposal simplifies guard case and if case grammar. It drops the case keyword<br>&gt; and replaces the assignment sign with the pattern matching (~=) operator.<br>&gt; The results are simpler, they reads better, and it transfers the<br>&gt; responsibility of saying &quot;this is pattern matching&quot; from case to ~=.<br>&gt;<br>&gt; Swift-evolution thread: [Pitch] Reimagining guard case/if case<br>&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20161024/tbd.html&gt;<br>&gt; &lt;https://gist.github.com/erica/1a5ce8a5157158c6400efb550778cead#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; Swift&#39;s guard case and if case statements stand out for their unintuitive<br>&gt; approach. They look like assignment statements but they are not assignment<br>&gt; statements. They present difficulties for new language adopters because<br>&gt; they combine several concepts in a confusing form. They are arguably<br>&gt; underutilized by language experts.<br>&gt;<br>&gt; Both guard case and `if case statements perform simultaneous pattern<br>&gt; matching and conditional binding. Here are examples demonstrating their use<br>&gt; in current Swift:<br>&gt;<br>&gt; enum Result&lt;T&gt; { case success(T), error(Error) }<br>&gt;<br>&gt; // valid Swift<br>&gt; guard case let .success(value) = result<br>&gt;     else { ... }<br>&gt;<br>&gt; // valid Swift<br>&gt; guard case .success(let value) = result<br>&gt;     else { ... }<br>&gt;<br>&gt; The status quo is iteratively built up in this fashion:<br>&gt;<br>&gt;    - = performs assignment<br>&gt;    - let x = performs binding<br>&gt;    - if let x = performs conditional binding<br>&gt;    - if case .foo(let x) = performs conditional binding *and* pattern<br>&gt;    matching<br>&gt;<br>&gt; When using if case/guard case in the absense of conditional binding, it<br>&gt; duplicates basic pattern matching but uses less obvious semantics. These<br>&gt; two statements are functionally identical:<br>&gt;<br>&gt; if range ~= myValue { ... } // simpler<br>&gt; if case range = myValue { ... } // confusing<br>&gt;<br>&gt; The problems with guard case and if case include:<br>&gt;<br>&gt;    - The = operator looks like assignment and not like pattern matching (<br>&gt;    ~=).<br>&gt;    - The case layout is both too close to a switch&#39;s case but doesn&#39;t<br>&gt;    follow its syntax. In switch, a case is followed by a colon, not an<br>&gt;    equal sign.<br>&gt;    - Using the case syntax is unneccessarily wordy. It incorporates case,<br>&gt;    =, and optionally let/var assignments.<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/1a5ce8a5157158c6400efb550778cead#detailed-design&gt;Detailed<br>&gt; Design<br>&gt;<br>&gt; This proposal replaces the current syntax with a simpler grammar that<br>&gt; prioritizes pattern matching but mirrors basic conditional binding. The new<br>&gt; syntax drops the case keyword and replaces = with ~=. The results look<br>&gt; like this:<br>&gt;<br>&gt; guard let .success(value) ~= result { ... }<br>&gt; guard .success(let value) ~= result { ... }<br>&gt; if let .success(value) ~= result { ... }<br>&gt; if .success(let value) ~= result { ... }<br>&gt; guard let x? ~= anOptional { ... }<br>&gt; if let x? ~= anOptional { ... }<br>&gt;<br>&gt; In this update:<br>&gt;<br>&gt;    - The case keyword is subsumed into the (existing) pattern matching<br>&gt;    operator<br>&gt;    - The statements adopt the existing if-let and guard-let syntax,<br>&gt;    including Optional syntactic sugar.<br>&gt;<br>&gt; if let x = anOptional { ... } // current<br>&gt; if case let x? = anOptional { ... } // current, would be removed<br>&gt;<br>&gt; if let x? ~= anOptional { ... } // proposed replacement for `if case`<br>&gt;<br>&gt; On adopting this syntax, the two identical range tests naturally unify to<br>&gt; this single version:<br>&gt;<br>&gt; if range ~= myValue { ... } // before<br>&gt; if case range = myValue { ... } // before<br>&gt;<br>&gt; if range ~= myValue { ... } // after<br>&gt;<br>&gt; Using pattern matching without conditional binding naturally simplifies to<br>&gt; a standalone Boolean condition clause.<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/1a5ce8a5157158c6400efb550778cead#impact-on-existing-code&gt;Impact<br>&gt; on Existing Code<br>&gt;<br>&gt; This proposal is breaking and would require migration.<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/1a5ce8a5157158c6400efb550778cead#alternatives-considered&gt;Alternatives<br>&gt; Considered<br>&gt;<br>&gt;    - Leaving the grammar as-is, albeit confusing<br>&gt;    - Retaining case and replacing the equal sign with ~= (pattern<br>&gt;    matching) or : (to match the switch statement).<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161024/65da7867/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Reimagining guard case/if case</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>October 24, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Oct 24, 2016, at 10:44 AM, Jay Abbott &lt;jay at abbott.me.uk&gt; wrote:<br>&gt; <br>&gt; Hey Erica,<br>&gt; <br>&gt; It&#39;s not clear in the examples, but are you proposing to drop the &#39;else&#39; from guard too?<br></p><p>No I am not. That&#39;s a copy/paste error. I have fixed that in the gist. Thank you for the catch.<br></p><p>-- E<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[Pitch] Reimagining guard case/if case</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>October 24, 2016 at 07:00:00pm</p></header><div class="content"><p>Love it Erica :)!!!!<br></p><p>Sent from my iPhone<br></p><p>&gt; On 24 Oct 2016, at 18:55, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 24, 2016, at 10:44 AM, Jay Abbott &lt;jay at abbott.me.uk&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hey Erica,<br>&gt;&gt; <br>&gt;&gt; It&#39;s not clear in the examples, but are you proposing to drop the &#39;else&#39; from guard too?<br>&gt; <br>&gt; No I am not. That&#39;s a copy/paste error. I have fixed that in the gist. Thank you for the catch.<br>&gt; <br>&gt; -- E<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eb0d0358af1f99d8dc5970844e5b8180?s=50"></div><header><strong>[Pitch] Reimagining guard case/if case</strong> from <string>Martin Waitz</string> &lt;tali at admingilde.org&gt;<p>October 24, 2016 at 10:00:00pm</p></header><div class="content"><p>Hi,<br></p><p>When using a pattern match operator, I’d prefer to reverse its arguments:<br></p><p>    if value matches pattern …<br></p><p>    if result =~ .success(let x) { use(x) }<br></p><p>Being used to pattern matching in functional languages, I also do like our current syntax.<br>Using ~= together with `let` on the left looks very strange to me.<br></p><p>— Martin<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Pitch] Reimagining guard case/if case</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>October 24, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On 24 Oct 2016, at 21:38, Martin Waitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; When using a pattern match operator, I’d prefer to reverse its arguments:<br>&gt; <br>&gt;    if value matches pattern …<br>&gt; <br>&gt;    if result =~ .success(let x) { use(x) }<br>&gt; <br>&gt; Being used to pattern matching in functional languages, I also do like our current syntax.<br>&gt; Using ~= together with `let` on the left looks very strange to me.<br></p><p>That&#39;s interesting point, it does kind of make more sense that way round, but I wonder if we were to d that a keyword might be even better than an operate, like:<br></p><p>	if result matches .success(let x) { use(x) }<br>	if result matches let x? { use(x) }<br></p><p>And so-on? Maybe matches isn&#39;t the right keyword; we could even re-use the is keyword for something shorter (and just think of a type as a form of pattern)? I could like the idea of doing:<br></p><p>	if result is let x? { use(x) }<br></p><p>My reasoning being that a keyword makes it much more obvious what&#39;s going on as it can read like natural language to convey that it&#39;s a form of matching, wheres ~= as an operator still requires some learning if you&#39;ve not seen something similar in another language.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161024/720895a3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b8fbb69a582e03b56bd4c125aef9e3f?s=50"></div><header><strong>[Pitch] Reimagining guard case/if case</strong> from <string>Haravikk</string> &lt;e-mail at haravikk.me&gt;<p>October 24, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On 24 Oct 2016, at 21:55, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 24 Oct 2016, at 21:38, Martin Waitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi,<br>&gt;&gt; <br>&gt;&gt; When using a pattern match operator, I’d prefer to reverse its arguments:<br>&gt;&gt; <br>&gt;&gt;    if value matches pattern …<br>&gt;&gt; <br>&gt;&gt;    if result =~ .success(let x) { use(x) }<br>&gt;&gt; <br>&gt;&gt; Being used to pattern matching in functional languages, I also do like our current syntax.<br>&gt;&gt; Using ~= together with `let` on the left looks very strange to me.<br>&gt; <br>&gt; That&#39;s interesting point, it does kind of make more sense that way round, but I wonder if we were to d that a keyword might be even better than an operate, like:<br></p><p>Should read as; &quot;that&#39;s an interesting point, it does kind of make more sense that way round, but I wonder if were to do that if a keyword might be even better than an operator&quot;<br>i.e- like a sane person who proof-reads e-mails might have written it.<br></p><p>&gt; 	if result matches .success(let x) { use(x) }<br>&gt; 	if result matches let x? { use(x) }<br>&gt; <br>&gt; And so-on? Maybe matches isn&#39;t the right keyword; we could even re-use the is keyword for something shorter (and just think of a type as a form of pattern)? I could like the idea of doing:<br>&gt; <br>&gt; 	if result is let x? { use(x) }<br>&gt; <br>&gt; My reasoning being that a keyword makes it much more obvious what&#39;s going on as it can read like natural language to convey that it&#39;s a form of matching, wheres ~= as an operator still requires some learning if you&#39;ve not seen something similar in another language.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161024/086a7d9f/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: smime.p7s<br>Type: application/pkcs7-signature<br>Size: 4634 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161024/086a7d9f/attachment.p7s&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Pitch] Reimagining guard case/if case</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>October 25, 2016 at 03:00:00pm</p></header><div class="content"><p>-1. I&#39;m not enthusiastic about using ~=. IMO it&#39;s only a small improvement over the &quot;if case let...&quot; hieroglyphics and still too cryptic.<br>  <br></p><p>  <br>Like the others, I really like &quot;matches&quot; or some other, more explicit, keyword.<br>  <br></p><p>  <br>Anything more general around pattern-matching should probably wait until we start adding language support for regexes and other complex patterns. Then we can make something that is more logically consistent.<br>  <br></p><p>    <br>  <br>  <br>  <br></p><p>  <br>  <br>  <br>  <br></p><p>  <br>  <br>&gt;   <br>&gt; On Oct 24, 2016 at 10:55 pm,  &lt;Haravikk via swift-evolution (mailto:swift-evolution at swift.org)&gt;  wrote:<br>&gt;   <br>&gt;   <br>&gt;   <br>&gt;   <br>&gt;   <br>&gt; &gt;   <br>&gt; &gt; On 24 Oct 2016, at 21:38, Martin Waitz via swift-evolution  &lt;swift-evolution at swift.org (mailto:swift-evolution at swift.org)&gt;  wrote:<br>&gt; &gt;   <br>&gt; &gt;   <br>&gt; &gt;   <br>&gt; &gt; Hi,<br>&gt; &gt;   <br>&gt; &gt;  When using a pattern match operator, I’d prefer to reverse its arguments:<br>&gt; &gt;   <br>&gt; &gt;         if value matches pattern …<br>&gt; &gt;   <br>&gt; &gt;         if result =~ .success(let x) { use(x) }<br>&gt; &gt;   <br>&gt; &gt;  Being used to pattern matching in functional languages, I also do like our current syntax.<br>&gt; &gt;  Using ~= together with `let` on the left looks very strange to me.       <br>&gt;   <br>&gt; That&#39;s interesting point, it does kind of make more sense that way round, but I wonder if we were to d that a keyword might be even better than an operate, like:<br>&gt;   <br>&gt;<br>&gt;   <br>&gt; if result matches .success(let x) { use(x) }<br>&gt;   <br>&gt; if result matches let x? { use(x) }<br>&gt;   <br>&gt;<br>&gt;   <br>&gt; And so-on? Maybe matches isn&#39;t the right keyword; we could even re-use the is keyword for something shorter (and just think of a type as a form of pattern)? I could like the idea of doing:<br>&gt;   <br>&gt;<br>&gt;   <br>&gt; if result is let x? { use(x) }<br>&gt;   <br>&gt;<br>&gt;   <br>&gt; My reasoning being that a keyword makes it much more obvious what&#39;s going on as it can read like natural language to convey that it&#39;s a form of matching, wheres ~= as an operator still requires some learning if you&#39;ve not seen something similar in another language.<br>&gt;  _______________________________________________ swift-evolution mailing list  swift-evolution at swift.org (mailto:swift-evolution at swift.org)   https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;   <br>  <br>  <br> <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161025/d8b0bc1a/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eddffe5cd2c817d61892d77edf66b6b2?s=50"></div><header><strong>[Pitch] Reimagining guard case/if case</strong> from <string>Rien</string> &lt;Rien at Balancingrock.nl&gt;<p>October 25, 2016 at 09:00:00am</p></header><div class="content"><p>I have tried to like this because at first it seems like a good idea.<br>But having let it shimmer for a while, I simply cannot muster the enthusiasm for it. Using “~=“ does not ‘feel’ right to me. Especially for a code breaking change at this stage. There are probably already a number of user defined functions out there that overload “~=“.<br>-1. Sorry. <br></p><p>If possible, I think it would be nice to make the “case” after the “if” or “guard” optional. But that would be enough imo.<br>Alternatively replacing the “~=“ with a different keyword (and dropping the “case”) could also do trick, as Haravikk suggested (I do like the “matches”).<br></p><p>Regards,<br>Rien<br></p><p>Site: http://balancingrock.nl<br>Blog: http://swiftrien.blogspot.com<br>Github: http://github.com/Swiftrien<br>Project: http://swiftfire.nl<br></p><p><br></p><p><br>&gt; On 24 Oct 2016, at 18:24, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Pitch: I&#39;d like to simplify `if case`/`guard case` to drop `case` and replace the equal sign with the pattern matching (`~=`) operator. I think it&#39;s simpler, reads better, and emphasizes &quot;this is pattern matching&quot; in a way the current grammar does not.<br>&gt; <br>&gt; gist: https://gist.github.com/erica/1a5ce8a5157158c6400efb550778cead<br>&gt; <br>&gt; Simplifying guard case/if case syntax<br>&gt; <br>&gt; 	• Proposal: TBD<br>&gt; 	• Author: Erica Sadun<br>&gt; 	• Status: TBD<br>&gt; 	• Review manager: TBD<br>&gt; <br>&gt; Introduction<br>&gt; <br>&gt; This proposal simplifies guard case and if case grammar. It drops the case keyword and replaces the assignment sign with the pattern matching (~=) operator. The results are simpler, they reads better, and it transfers the responsibility of saying &quot;this is pattern matching&quot; from case to ~=.<br>&gt; <br>&gt; Swift-evolution thread: [Pitch] Reimagining guard case/if case<br>&gt; <br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; Swift&#39;s guard case and if case statements stand out for their unintuitive approach. They look like assignment statements but they are not assignment statements. They present difficulties for new language adopters because they combine several concepts in a confusing form. They are arguably underutilized by language experts.<br>&gt; <br>&gt; Both guard case and `if case statements perform simultaneous pattern matching and conditional binding. Here are examples demonstrating their use in current Swift:<br>&gt; <br>&gt; enum Result&lt;T&gt; { case success(T), error(Error) }<br>&gt; <br>&gt; // valid Swift<br>&gt; guard case let .success(value) = result<br>&gt;     else { ... }<br>&gt; <br>&gt; // valid Swift<br>&gt; guard case .success(let value) = result<br>&gt;     else { ... }<br>&gt; <br>&gt; The status quo is iteratively built up in this fashion:<br>&gt; <br>&gt; 	• = performs assignment<br>&gt; 	• let x = performs binding<br>&gt; 	• if let x = performs conditional binding<br>&gt; 	• if case .foo(let x) = performs conditional binding and pattern matching<br>&gt; When using if case/guard case in the absense of conditional binding, it duplicates basic pattern matching but uses less obvious semantics. These two statements are functionally identical:<br>&gt; <br>&gt; if range ~= myValue { ... } // simpler<br>&gt; if case range = myValue { ... } // confusing<br>&gt; <br>&gt; The problems with guard case and if case include:<br>&gt; <br>&gt; 	• The = operator looks like assignment and not like pattern matching (~=). <br>&gt; 	• The case layout is both too close to a switch&#39;s case but doesn&#39;t follow its syntax. In switch, a case is followed by a colon, not an equal sign.<br>&gt; 	• Using the case syntax is unneccessarily wordy. It incorporates case, =, and optionally let/var assignments.<br>&gt; <br>&gt; Detailed Design<br>&gt; <br>&gt; This proposal replaces the current syntax with a simpler grammar that prioritizes pattern matching but mirrors basic conditional binding. The new syntax drops the case keyword and replaces = with ~=. The results look like this:<br>&gt; <br>&gt; guard let .success(value) ~= result { ... }<br>&gt; guard .success(let value) ~= result { ... }<br>&gt; if let .success(value) ~= result { ... }<br>&gt; if .success(let value) ~= result { ... }<br>&gt; guard let x? ~= anOptional { ... }<br>&gt; if let x? ~= anOptional { ... }<br>&gt; <br>&gt; In this update:<br>&gt; <br>&gt; 	• The case keyword is subsumed into the (existing) pattern matching operator<br>&gt; 	• The statements adopt the existing if-let and guard-let syntax, including Optional syntactic sugar.<br>&gt; if let x = anOptional { ... } // current<br>&gt; if case let x? = anOptional { ... } // current, would be removed<br>&gt; <br>&gt; if let x? ~= anOptional { ... } // proposed replacement for `if case`<br>&gt; <br>&gt; On adopting this syntax, the two identical range tests naturally unify to this single version:<br>&gt; <br>&gt; if range ~= myValue { ... } // before<br>&gt; if case range = myValue { ... } // before<br>&gt; <br>&gt; if range ~= myValue { ... } // after<br>&gt; <br>&gt; Using pattern matching without conditional binding naturally simplifies to a standalone Boolean condition clause.<br>&gt; <br>&gt; <br>&gt; Impact on Existing Code<br>&gt; <br>&gt; This proposal is breaking and would require migration.<br>&gt; <br>&gt; <br>&gt; Alternatives Considered<br>&gt; <br>&gt; 	• Leaving the grammar as-is, albeit confusing<br>&gt; 	• Retaining case and replacing the equal sign with ~= (pattern matching) or : (to match the switch statement).<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be09ed656d5d90501c958b001261f218?s=50"></div><header><strong>[Pitch] Reimagining guard case/if case</strong> from <string>Jeremy Pereira</string> &lt;jeremy.j.pereira at googlemail.com&gt;<p>October 25, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On 25 Oct 2016, at 08:13, Rien via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I have tried to like this because at first it seems like a good idea.<br>&gt; But having let it shimmer for a while, I simply cannot muster the enthusiasm for it. Using “~=“ does not ‘feel’ right to me. Especially for a code breaking change at this stage. There are probably already a number of user defined functions out there that overload “~=“.<br>&gt; -1. Sorry. <br></p><p>Erica chose ~= because it is already the pattern matching operator in Swift. I think it would be just fine.<br></p><p><br>&gt; <br>&gt; If possible, I think it would be nice to make the “case” after the “if” or “guard” optional. But that would be enough imo.<br>&gt; Alternatively replacing the “~=“ with a different keyword (and dropping the “case”) could also do trick, as Haravikk suggested (I do like the “matches”).<br></p><p>I don’t like Haravikk’s suggestion because although he calls it a keyword, &quot;matches” would clearly be an operator and in many discussions the idea of using words as operators has been rejected for practical compilation reasons and readability reasons. The idea of using matches because it reads better in English is bogus because, once an operator becomes widely accepted, people read it as what it is. If you see `a || b`, you don’t read &quot;a pipe pipe b&quot;, you read &quot;a or b”. I admit I do read &quot;a == b&quot; as &quot;a equals equals b” but that seems completely natural to me.<br></p><p>Also, reading things in English is not necessarily natural to a lot of programmers.<br></p><p>I am +1 for Erica’s idea, although I also like the =~ modification to turn the value and the pattern around.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Pitch] Reimagining guard case/if case</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>October 25, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On 25 Oct 2016, at 12:44, Jeremy Pereira via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; If possible, I think it would be nice to make the “case” after the “if” or “guard” optional. But that would be enough imo.<br>&gt;&gt; Alternatively replacing the “~=“ with a different keyword (and dropping the “case”) could also do trick, as Haravikk suggested (I do like the “matches”).<br>&gt; <br>&gt; I don’t like Haravikk’s suggestion because although he calls it a keyword, &quot;matches” would clearly be an operator and in many discussions the idea of using words as operators has been rejected for practical compilation reasons and readability reasons. The idea of using matches because it reads better in English is bogus because, once an operator becomes widely accepted, people read it as what it is. If you see `a || b`, you don’t read &quot;a pipe pipe b&quot;, you read &quot;a or b”. I admit I do read &quot;a == b&quot; as &quot;a equals equals b” but that seems completely natural to me.<br></p><p>I&#39;m inclined to disagree; the keyword wouldn&#39;t be much different from the use of the is keyword to test a type (I even suggested using it since it&#39;s shorter than matches and wouldn&#39;t require a new term), both are run-time operations except where they can be optimised away so there is some precedent for this.<br></p><p>On the issue of a || b that&#39;s a little different; while personally I would actually like &quot;and&quot; and &quot;or&quot; to be keywords, the operators for these are very common (practically universal), but many languages lack a pattern matching operator, and I don&#39;t recall using one that functions quite like Swift&#39;s does. Also, I haven&#39;t delved into the implementation but is it even really an operator? It doesn&#39;t seem like something I could implement myself as I can&#39;t define a mechanism for conditional binding etc., so it doesn&#39;t really seem like an operator in the traditional sense anyway.<br></p><p>Lastly, on it being more readable the issue isn&#39;t general readability but rather discoverability. If you see &quot;if x matches .some(let y)&quot; or &quot;if x is let y?&quot; then there&#39;s some immediate context for what&#39;s going on the first time you see it. An =~ or ~= operator is less clear as it looks like a weird assignment operator (like +=), doesn&#39;t mean the same thing as the tilde operator on its own; the only clue to it being a comparison is that it&#39;s used in an if condition.<br></p><p>I dunno, although I&#39;ve started using the pattern matching operator, I just don&#39;t like it.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eddffe5cd2c817d61892d77edf66b6b2?s=50"></div><header><strong>[Pitch] Reimagining guard case/if case</strong> from <string>Rien</string> &lt;Rien at Balancingrock.nl&gt;<p>October 25, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On 25 Oct 2016, at 14:15, Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br>&gt; <br>&gt; Lastly, on it being more readable the issue isn&#39;t general readability but rather discoverability. If you see &quot;if x matches .some(let y)&quot; or &quot;if x is let y?&quot; then there&#39;s some immediate context for what&#39;s going on the first time you see it. An =~ or ~= operator is less clear as it looks like a weird assignment operator (like +=), doesn&#39;t mean the same thing as the tilde operator on its own; the only clue to it being a comparison is that it&#39;s used in an if condition.<br></p><p><br>Bingo!, you just formulated what I felt but could not put in words just yet.<br></p><p>Regards,<br>Rien<br></p><p>Site: http://balancingrock.nl<br>Blog: http://swiftrien.blogspot.com<br>Github: http://github.com/Swiftrien<br>Project: http://swiftfire.nl<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c2db2957c0fdbc692f530b5454530b3d?s=50"></div><header><strong>[Pitch] Reimagining guard case/if case</strong> from <string>Marco Pace</string> &lt;drive at marcopace.it&gt;<p>October 25, 2016 at 03:00:00pm</p></header><div class="content"><p>Hi,<br>I agree removing the &quot;case&quot; word after the &quot;if&quot; / &quot;guard&quot;, but I prefer <br>removing it completely rather then make it optional to limit the number <br>of different implementation.<br></p><p>Regarding the operator, I agree that it can be improved because we <br>should find something that contains two different operations:<br>   - check against the pattern<br>   - assign the value<br></p><p>For me both &quot;is&quot; and &quot;match&quot; miss one of the two part: the &quot;is&quot; keyword <br>doesn&#39;t feel like a check against the pattern to me, while the &quot;match&quot; <br>keyboard doesn&#39;t contain information regarding the assignation.<br></p><p>+1 for Erika proposal, I like the idea of using &quot;~=&quot;, it explicits both <br>operations and it is an operator already used in Swift for a similar <br>use-case.<br></p><p>Marco<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Pitch] Reimagining guard case/if case</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>October 25, 2016 at 10:00:00pm</p></header><div class="content"><p>Haravikk, I fully agree with you; before I read your post I thought I’d<br>write exactly that.<br>if &lt;expression&gt; matches &lt;pattern&gt;<br></p><p>1.<br>Another “ideological” reason:<br>= is just an operator, so lhs = rhs should be an expression, but meaning of<br>= is overloaded in this context. On the other hand, when you see a keyword,<br>you can’t mistake if lhs matches rhs for an expression. Analogy with for-in<br>plays here.<br></p><p>2.<br>Does this change simplify the syntax enough that we can remove optional<br>binding?<br>Is if x matches y? short/simple enough by comparison to if let x = y?<br>I think yes, because matches is so much clearer.<br></p><p>3.<br>We can do the same change for for case pattern in, plus eliminate where<br>clause? How about this:<br>for x in y, x matches z?, condition, w matches x<br></p><p>let results: [Either&lt;Double, String&gt;]<br>for item in results, item matches .left(let num), num &gt;= 0 {<br>    print(num)<br>}<br></p><p>Looks like it’s closer to logical sequence of actions, than what we<br>currently have. Now we have “select .left elements, while iterating through<br>results, and only select those which are &gt;= 0“.<br></p><p>P.S. We can leave where, or even if in this form of for-in.<br>​<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161025/d75a8814/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d30e546d655d1c7ece0464791a9a90d5?s=50"></div><header><strong>[Pitch] Reimagining guard case/if case</strong> from <string>Adrian Kashivskyy</string> &lt;adrian.kashivskyy at me.com&gt;<p>October 26, 2016 at 10:00:00am</p></header><div class="content"><p>I’m -1 as it’s currently written, for the following reasons:<br></p><p>1. Differences are introduced to pattern matching in different parts of the language (`switch` vs `if`/`guard` vs `for`).<br></p><p>2. Exclusion of `for` in the proposal is either deliberate (which relates to point 1.) or done as a result of a rush, which is not good either. This proposal should include a resolution for `for case let where` clauses.<br></p><p>3. Syntatic sugar of optional matching `let x? ~= maybeX` feels completely out of place and looks nothing like standard optional bindings. I will remain strongly against this change.<br></p><p>– Adrian<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161026/156fd05c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Reimagining guard case/if case</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>October 26, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Oct 26, 2016, at 2:32 AM, Adrian Kashivskyy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I’m -1 as it’s currently written, for the following reasons:<br>&gt; <br>&gt; 1. Differences are introduced to pattern matching in different parts of the language (`switch` vs `if`/`guard` vs `for`).<br></p><p>Pattern matching in Swift includes:<br></p><p>`switch case` and `for case`: The argument is pulled in indirectly:<br>    `switch value....case pattern:` and `for case pattern in sequence of values`<br></p><p>`guard case` and `if case`: The argument is expressed with an equal sign:<br>   `guard case pattern = value` and `if case pattern = value`<br></p><p>Operator use, excluding conditional binding: `pattern ~= value`.<br></p><p>I argue that the second group is closer to the third than the first because the value must be provided to the statement for `guard case`, `if case`, and the ~= operator.<br></p><p><br>&gt; 2. Exclusion of `for` in the proposal is either deliberate (which relates to point 1.) or done as a result of a rush, which is not good either. This proposal should include a resolution for `for case let where` clauses.<br></p><p>Both `if case` and `guard case` don&#39;t use implied arguments, making them fundamentally a different type of check. If you insist that the keyword &quot;case&quot; be used for pattern matching, then under your argument it should appear in other parts of the language where pattern matching occurs. <br></p><p>Since it doesn&#39;t, and you can check membership in a range with &quot;range ~= value&quot;, why shouldn&#39;t the grammar for these two items be moved from the &quot;passive implied arguments&quot; group to the &quot;explicit arguments&quot; group, given that they use explicit arguments?<br></p><p>&gt; 3. Syntatic sugar of optional matching `let x? ~= maybeX` feels completely out of place and looks nothing like standard optional bindings. I will remain strongly against this change.<br></p><p>I&#39;d suggest that&#39;s a subjective issue with the sugar, not with the use of ~=. <br></p><p>-- E<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be09ed656d5d90501c958b001261f218?s=50"></div><header><strong>[Pitch] Reimagining guard case/if case</strong> from <string>Jeremy Pereira</string> &lt;jeremy.j.pereira at googlemail.com&gt;<p>October 28, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On 25 Oct 2016, at 13:15, Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br>&gt; <br>&gt; <br>&gt; I&#39;m inclined to disagree; the keyword wouldn&#39;t be much different from the use of the is keyword to test a type (I even suggested using it since it&#39;s shorter than matches and wouldn&#39;t require a new term), both are run-time operations except where they can be optimised away so there is some precedent for this.<br></p><p>That’s more an argument for changing the syntax of `is` and `as`, perhaps giving them a function like syntax like `type(of:)` not an argument for introducing more operators that break the rules. It’s all very well following precedent, but when precedent is wrong, let’s not.<br></p><p>&gt; <br>&gt; Lastly, on it being more readable the issue isn&#39;t general readability but rather discoverability. If you see &quot;if x matches .some(let y)&quot; or &quot;if x is let y?&quot; then there&#39;s some immediate context for what&#39;s going on the first time you see it. An =~ or ~= operator is less clear as it looks like a weird assignment operator (like +=), doesn&#39;t mean the same thing as the tilde operator on its own; the only clue to it being a comparison is that it&#39;s used in an if condition.<br></p><p>I’m not sure I like compromising readability just so that people who have no Swift experience can understand things a bit more easily.<br></p><p>&gt; <br>&gt; I dunno, although I&#39;ve started using the pattern matching operator, I just don&#39;t like it.<br></p><p>It’s a bit similar to Perl’s string pattern matching operator (=~), so to me it seems fine and it’s already part of the language.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Pitch] Reimagining guard case/if case</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>October 28, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On 28 Oct 2016, at 10:00, Jeremy Pereira &lt;jeremy.j.pereira at googlemail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 25 Oct 2016, at 13:15, Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I&#39;m inclined to disagree; the keyword wouldn&#39;t be much different from the use of the is keyword to test a type (I even suggested using it since it&#39;s shorter than matches and wouldn&#39;t require a new term), both are run-time operations except where they can be optimised away so there is some precedent for this.<br>&gt; <br>&gt; That’s more an argument for changing the syntax of `is` and `as`, perhaps giving them a function like syntax like `type(of:)` not an argument for introducing more operators that break the rules. It’s all very well following precedent, but when precedent is wrong, let’s not.<br></p><p>Who&#39;s to say that the precedent is wrong? is and as are very convenient keywords, far more so than having to learn a symbolic operator that might not be obvious, or digging around for a function, especially when said function would really need to be on the type, thus causing it to read in reverse of what you&#39;d expect.<br></p><p>Keywords have their place, you can&#39;t just declare them wrong. Plus as I said, unless there&#39;s some hidden magic I&#39;m unaware of pattern matching isn&#39;t actually a true operator anyway, it&#39;s syntactic sugar that looks like one, so why not a keyword? I think a case has to be made for this to be an operator every bit as much as the case for using a keyword.<br></p><p>&gt;&gt; Lastly, on it being more readable the issue isn&#39;t general readability but rather discoverability. If you see &quot;if x matches .some(let y)&quot; or &quot;if x is let y?&quot; then there&#39;s some immediate context for what&#39;s going on the first time you see it. An =~ or ~= operator is less clear as it looks like a weird assignment operator (like +=), doesn&#39;t mean the same thing as the tilde operator on its own; the only clue to it being a comparison is that it&#39;s used in an if condition.<br>&gt; <br>&gt; I’m not sure I like compromising readability just so that people who have no Swift experience can understand things a bit more easily.<br></p><p>Compromising readability how? And it&#39;s not *just* so that people with no experience can learn; I don&#39;t find =~ or ~= that appealing as I don&#39;t feel they really communicate their purpose at all, it&#39;s just a matter of learning it by rote, which I&#39;d prefer to avoid.<br></p><p>&gt; It’s a bit similar to Perl’s string pattern matching operator (=~), so to me it seems fine and it’s already part of the language.<br></p><p>That&#39;s missing the point; I don&#39;t think I&#39;ve used Perl once since university, and I can&#39;t think of any language I&#39;ve used in the past five years that has an operator like this. Obviously other people&#39;s experience will differ, but the point is that I don&#39;t think it&#39;s common enough to consider a term of art, and on its own it doesn&#39;t convey any meaning. Like I said, tilde already has a meaning for bit-flipping, which this doesn&#39;t do, so it&#39;s something that must be purely learned, unlike say += which is intuitive if you know what both = and + do.<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Pitch] Reimagining guard case/if case</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>October 26, 2016 at 03:00:00am</p></header><div class="content"><p>&gt; This proposal replaces the current syntax with a simpler grammar that prioritizes pattern matching but mirrors basic conditional binding. The new syntax drops the case keyword and replaces = with ~=. The results look like this:<br>&gt; <br>&gt; guard let .success(value) ~= result { ... }<br>&gt; guard .success(let value) ~= result { ... }<br>&gt; if let .success(value) ~= result { ... }<br>&gt; if .success(let value) ~= result { ... }<br>&gt; guard let x? ~= anOptional { ... }<br>&gt; if let x? ~= anOptional { ... }<br></p><p>I don&#39;t mind this syntax, but I&#39;m not convinced this is worth doing if it&#39;s merely a syntax change. (It goes without saying that this is not phase 1.) But if it were motivated by a broader change, I think I could get behind it.<br></p><p>Suppose we introduced this concept:<br></p><p>	protocol Pattern {<br>		associatedtype Target<br>		associatedtype Bindings<br>		<br>		static func ~= (pattern: Self, target: Target) -&gt; Bindings?<br>	}<br>	<br>	// Sometimes you just want the pattern on the other side.<br>	func =~ &lt;PatternType: Pattern&gt;(target: PatternType.Target, pattern: PatternType) -&gt; PatternType.Bindings? {<br>		return pattern ~= target<br>	}<br></p><p>And further suppose that conditionals were altered to support `~=` and `=~` instead of `case =`. That is, a conditional with a pattern match in it would take the &quot;then&quot; branch if the `~=` returned `.some`, and would bind the variables in the returned tuple. In essence, this:<br></p><p>	if pattern ~= target { … }<br></p><p>Would be rewritten to:<br></p><p>	if let ([variables from pattern]) = (pattern ~= target) { … }<br></p><p>(One way to do this would be to support *any* Optional as a conditional, not just the results of a pattern match; this would essentially make `nil` into a false-ish value. But we tried that in the Swift 1 betas and didn&#39;t seem too happy with it.)<br></p><p>Enum cases would then have a dual nature; they could construct values, but they could also construct `Case` instances:<br></p><p>	let value = Foo?.some(Foo())<br>	// value: Foo?<br>	<br>	let pattern1 = Foo?.some(let value) as Case<br>	// pattern1: Case&lt;Foo?, (value: Foo)&gt;<br>	<br>	let pattern2 = Foo?.some(_) as Case<br>	// pattern2: Case&lt;Foo?, (Foo)&gt;<br>	<br>	let pattern3 = Foo?.some as Case<br>	// pattern3: Case&lt;Foo?, (Foo)&gt;<br>	<br>	let aFoo = Foo()<br>	let pattern4 = Foo?.some(aFoo) as Case<br>	// pattern4: Case&lt;Foo?, (Foo)&gt;<br></p><p>Note that all four patterns are some variant of `Case&lt;Foo?, (Foo)&gt;`; it&#39;s just a matter of re-labeling the second parameter. Hopefully you could do that with a cast:<br></p><p>	if (pattern as Case&lt;Foo?, (foo: Foo)&gt;) ~= optionalFoo {<br>		// use `foo` here<br>	}<br>	<br>	// Or with more powerful existentials:<br>	if (pattern as Pattern where Bindings == (foo: Foo)) ~= fooTarget {<br>		// use `foo` here<br>	}<br>	<br>	// Perhaps some sugar:<br>	if fooTarget =~ pattern as let value {<br>		// use `foo` here<br>	}<br></p><p>Elements with a label are bound to a variable by that name; elements with no label are not bound to any variable. <br></p><p>`Case` would look something like this, with the actual implementation of `~=` being compiler magic:<br></p><p>	class Case&lt;Enum, Associated&gt;: Pattern {<br>		typealias Target = Enum<br>		typealias Bindings = Associated<br>		<br>		static func ~= (pattern: Case, target: Target) -&gt; Bindings? { … }<br>	}<br></p><p>(I suppose it might instead be `Enum.Case&lt;Associated&gt;`—just depends on whether we want it to be magic or standard library-ish.)<br></p><p>So, what other patterns could we implement? Well, most notably, regular expressions:<br></p><p>	class Regex&lt;Captures&gt;: Pattern {<br>		typealias Target = String<br>		typealias Bindings = #concatenateTuples(($0: String), Captures)<br>		<br>		static func ~= (pattern: RegularExpression, target: String) -&gt; Bindings? { … }<br>	}<br></p><p> You would use them like this:<br></p><p>	if /ab(.(.)?)c/ ~= myString {<br>		// That&#39;s a Regex&lt;($1: String, $2: String?)&gt;.<br>		// A named capture syntax would allow you to rename $1 and up, or you could cast <br>		// a regex you had received.<br>		// If string slicing is corrected so that substrings share indices with their parent string, <br>		// you would not need a separate &quot;get range of match&quot; feature.<br>	}<br></p><p>But here&#39;s another neat use case:<br></p><p>	let gregorian = Calendar(identifier: .gregorian)<br>	if myDate =~ DateComponents(calendar: gregorian, month: 10, day: 31) {<br>		print(&quot;👻🎃🕷⚰🍫&quot;)<br>	}<br>	<br>	extension DateComponents {<br>		typealias Target = Date<br>		typealias Bindings = (DateComponents)	// Optionally bindable<br>		<br>		static func ~= (pattern: DateComponents, target: Target) -&gt; Bindings? {<br>			let calendar = self.calendar ?? Calendar.current<br>			let timeZone = pattern.timeZone ?? TimeZone.current<br>			<br>			guard calendar.date(target, matchesComponents: pattern) else {<br>				return nil<br>			}<br>			<br>			return calendar.dateComponents(in: timeZone, from: date)<br>		}<br>	}<br></p><p>Anyway, just a related thought I had. Sorry for hijacking.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Pitch] Reimagining guard case/if case</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>October 29, 2016 at 07:00:00pm</p></header><div class="content"><p>I&#39;d like to write a proposal for &quot;matches&quot; and wonder if it is in Swift 4<br>Phase 1 scope? It&#39;s purely syntactic, and won&#39;t affect ABI.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161029/a16bb3d4/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
