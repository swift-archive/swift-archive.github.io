<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[Draft] UnsafeRawPointer API</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>June 23, 2016 at 06:00:00pm</p></header><div class="content"><p>I sent two RFC&#39;s for this proposal over the past couple months (see Early swift-evolution threads). High-level feedback was fairly light. This version is a final draft, as I expect it to go through the review process next week. There is a lot more explanation and detail in this proposal now, and the memory model has been simplified and clarified.<br></p><p>https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsaferawpointer.md<br></p><p>If you have opinions or suggestions on API syntax, please make yourself heard. You can jump straight to the naming discussion here:<br></p><p>https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsaferawpointer.md#variations-under-consideration<br></p><p>Of particular interest may be the API names for:<br></p><p>- Memory allocation/deallocation: fairly fundamental to the language.<br></p><p>- Unsafe casting from raw pointers to typed pointers. This is going to impact a lot of code that needs C interoperability.<br></p><p>Keep in mind that we will make additive API improvements later for convenience. We want the fundamentals to be clear, explicit, and reasonably safe.<br></p><p>-Andy<br></p><p>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: XXXX-unsaferawpointer.md<br>Type: text/markdown<br>Size: 57494 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/566fd2b3/attachment.bin&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Draft] UnsafeRawPointer API</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June 24, 2016 at 07:00:00am</p></header><div class="content"><p>Very cool...<br></p><p>Couple thoughts<br></p><p>UnsafeMutableRawPointer:<br>func store&lt;T&gt;(, WITH: T)<br>does not flow very well<br>Fill:with: seems nicer or write(, from:T) which means changing &#39;load&#39; into &#39;read&#39;<br>func read&lt;T&gt;(_ : T.Type) -&gt; T<br>func write&lt;T&gt;(_: T.T.Type, from: T) (write even match the method doc)<br></p><p>UnsafeRawPointer.toType():<br>Should it nit be something like typed(as:) instead <br></p><p>Regards<br>LM<br>(From mobile)<br></p><p>&gt; On Jun 24, 2016, at 3:40 AM, Andrew Trick via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I sent two RFC&#39;s for this proposal over the past couple months (see Early swift-evolution threads). High-level feedback was fairly light. This version is a final draft, as I expect it to go through the review process next week. There is a lot more explanation and detail in this proposal now, and the memory model has been simplified and clarified.<br>&gt; <br>&gt; https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsaferawpointer.md<br>&gt; <br>&gt; If you have opinions or suggestions on API syntax, please make yourself heard. You can jump straight to the naming discussion here:<br>&gt; <br>&gt; https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsaferawpointer.md#variations-under-consideration<br>&gt; <br>&gt; Of particular interest may be the API names for:<br>&gt; <br>&gt; - Memory allocation/deallocation: fairly fundamental to the language.<br>&gt; <br>&gt; - Unsafe casting from raw pointers to typed pointers. This is going to impact a lot of code that needs C interoperability.<br>&gt; <br>&gt; Keep in mind that we will make additive API improvements later for convenience. We want the fundamentals to be clear, explicit, and reasonably safe.<br>&gt; <br>&gt; -Andy<br>&gt; <br>&gt; &lt;XXXX-unsaferawpointer.md&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[Draft] UnsafeRawPointer API</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>June 24, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jun 23, 2016, at 10:10 PM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt; <br>&gt; Very cool...<br>&gt; <br>&gt; Couple thoughts<br>&gt; <br>&gt; UnsafeMutableRawPointer:<br>&gt; func store&lt;T&gt;(, WITH: T)<br>&gt; does not flow very well<br>&gt; Fill:with: seems nicer or write(, from:T) which means changing &#39;load&#39; into &#39;read&#39;<br>&gt; func read&lt;T&gt;(_ : T.Type) -&gt; T<br>&gt; func write&lt;T&gt;(_: T.T.Type, from: T) (write even match the method doc)<br></p><p>Yes but...<br></p><p>- I was parrotting the current initialize(_: T.Type, with: T) style.<br></p><p>- I was trying to establish consistency that `from` is used to copy from a pointer which points to a range of elements.<br></p><p>- Doesn&#39;t `fill` imply assigning a range of elements? That would make sense for `storeRaw(contiguous:)` but not the others.<br></p><p>- `store` by itself may imply assignment. Any previous value will not be destroyed (we don&#39;t even know its type). The user needs to be aware of this, at the expense of awkward naming. Safety is more important than convenience here. Hence we need `storeRaw` or `storeBits`. There is a deliberate assymetry between store and load because `load` will initialize its returned value. `store` will not initialize the stored value. `initialize` should be used for that.<br></p><p>- `writeRaw` sounds a little weird. `writeBits` sounds better.<br></p><p>&gt; UnsafeRawPointer.toType():<br>&gt; Should it nit be something like typed(as:) instead <br></p><p>I like &quot;typed(as:)&quot; better than toType(_). I&#39;m debating whether it should be:<br>&quot;unsafeCast(toType:)&quot;. It&#39;s a clarity/safety vs. verbosity tradeoff.<br></p><p>-Andy<br></p><p>&gt; Regards<br>&gt; LM<br>&gt; (From mobile)<br>&gt; <br>&gt;&gt; On Jun 24, 2016, at 3:40 AM, Andrew Trick via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I sent two RFC&#39;s for this proposal over the past couple months (see Early swift-evolution threads). High-level feedback was fairly light. This version is a final draft, as I expect it to go through the review process next week. There is a lot more explanation and detail in this proposal now, and the memory model has been simplified and clarified.<br>&gt;&gt; <br>&gt;&gt; https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsaferawpointer.md<br>&gt;&gt; <br>&gt;&gt; If you have opinions or suggestions on API syntax, please make yourself heard. You can jump straight to the naming discussion here:<br>&gt;&gt; <br>&gt;&gt; https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsaferawpointer.md#variations-under-consideration<br>&gt;&gt; <br>&gt;&gt; Of particular interest may be the API names for:<br>&gt;&gt; <br>&gt;&gt; - Memory allocation/deallocation: fairly fundamental to the language.<br>&gt;&gt; <br>&gt;&gt; - Unsafe casting from raw pointers to typed pointers. This is going to impact a lot of code that needs C interoperability.<br>&gt;&gt; <br>&gt;&gt; Keep in mind that we will make additive API improvements later for convenience. We want the fundamentals to be clear, explicit, and reasonably safe.<br>&gt;&gt; <br>&gt;&gt; -Andy<br>&gt;&gt; <br>&gt;&gt; &lt;XXXX-unsaferawpointer.md&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Draft] UnsafeRawPointer API</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June 24, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jun 24, 2016, at 7:43 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 23, 2016, at 10:10 PM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Very cool...<br>&gt;&gt; <br>&gt;&gt; Couple thoughts<br>&gt;&gt; <br>&gt;&gt; UnsafeMutableRawPointer:<br>&gt;&gt; func store&lt;T&gt;(, WITH: T)<br>&gt;&gt; does not flow very well<br>&gt;&gt; Fill:with: seems nicer or write(, from:T) which means changing &#39;load&#39; into &#39;read&#39;<br>&gt;&gt; func read&lt;T&gt;(_ : T.Type) -&gt; T<br>&gt;&gt; func write&lt;T&gt;(_: T.T.Type, from: T) (write even match the method doc)<br>&gt; <br>&gt; Yes but...<br>&gt; <br>&gt; - I was parrotting the current initialize(_: T.Type, with: T) style.<br>&gt; <br>&gt; - I was trying to establish consistency that `from` is used to copy from a pointer which points to a range of elements.<br>&gt; <br>&gt; - Doesn&#39;t `fill` imply assigning a range of elements? That would make sense for `storeRaw(contiguous:)` but not the others.<br>&gt; <br>&gt; - `store` by itself may imply assignment. Any previous value will not be destroyed (we don&#39;t even know its type). The user needs to be aware of this, at the expense of awkward naming. Safety is more important than convenience here. Hence we need `storeRaw` or `storeBits`. There is a deliberate assymetry between store and load because `load` will initialize its returned value. `store` will not initialize the stored value. `initialize` should be used for that.<br>&gt; <br>&gt; - `writeRaw` sounds a little weird. `writeBits` sounds better.<br></p><p>all makes sense.<br></p><p>&gt;&gt; UnsafeRawPointer.toType():<br>&gt;&gt; Should it nit be something like typed(as:) instead<br>&gt; <br>&gt; I like &quot;typed(as:)&quot; better than toType(_). I&#39;m debating whether it should be:<br>&gt; &quot;unsafeCast(toType:)&quot;. It&#39;s a clarity/safety vs. verbosity tradeoff.<br></p><p>I like the watch-what-you-wish-for warning of unsafeCast.<br></p><p>I think it was really brilliant to introduce the extra step... basically echos the alloc/init dichotomy of objc, so it should feel familiar to people with this bkgnd<br></p><p>&gt; -Andy<br>&gt; <br>&gt;&gt; Regards<br>&gt;&gt; LM<br>&gt;&gt; (From mobile)<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 24, 2016, at 3:40 AM, Andrew Trick via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I sent two RFC&#39;s for this proposal over the past couple months (see Early swift-evolution threads). High-level feedback was fairly light. This version is a final draft, as I expect it to go through the review process next week. There is a lot more explanation and detail in this proposal now, and the memory model has been simplified and clarified.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsaferawpointer.md<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you have opinions or suggestions on API syntax, please make yourself heard. You can jump straight to the naming discussion here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsaferawpointer.md#variations-under-consideration<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Of particular interest may be the API names for:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Memory allocation/deallocation: fairly fundamental to the language.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Unsafe casting from raw pointers to typed pointers. This is going to impact a lot of code that needs C interoperability.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Keep in mind that we will make additive API improvements later for convenience. We want the fundamentals to be clear, explicit, and reasonably safe.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Andy<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &lt;XXXX-unsaferawpointer.md&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[Draft] UnsafeRawPointer API</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>June 24, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jun 24, 2016, at 11:17 AM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt; <br>&gt; I like the watch-what-you-wish-for warning of unsafeCast.<br></p><p>I’ll try porting stdlib to the “UnsafeRawPointer.unsafeCast(to: T.Type)” syntax and see how bad it is.<br></p><p>&gt; I think it was really brilliant to introduce the extra step... basically echos the alloc/init dichotomy of objc, so it should feel familiar to people with this <br></p><p>Dave Abrahams advocated for this and it ended up making the memory model easier to explain in simple terms that correspond to the API.<br></p><p>-Andy<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160624/b8a870fa/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[Draft] UnsafeRawPointer API</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>June 24, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Jun 24, 2016, at 11:22 AM, Andrew Trick via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Jun 24, 2016, at 11:17 AM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com &lt;mailto:laurent.mihalkovic at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I like the watch-what-you-wish-for warning of unsafeCast.<br>&gt; <br>&gt; I’ll try porting stdlib to the “UnsafeRawPointer.unsafeCast(to: T.Type)” syntax and see how bad it is.<br></p><p><br>I don&#39;t think there&#39;s a clear winner here. Let me enumerate some<br>options.<br></p><p>Option (1) UnsafePointer&lt;T&gt;(cast: UnsafeRawPointer)<br></p><p>Option (2) UnsafePointer&lt;T&gt;(_: UnsafeRawPointer, to: T.self)<br></p><p>Option (3) UnsafeRawPointer.unsafeCast&lt;T&gt;(to: T.Type) -&gt; UnsafePointer&lt;T&gt;<br></p><p>Option (4) unsafeCast(rawPointer: UnsafeRawPointer, to: T.self) -&gt; UnsafePointer&lt;T&gt;<br></p><p>---<br>Option (3) is the most explicit and searchable, and forces<br>UnsafeRawPointer to be spelled out in the conversion (unless you<br>already have a raw pointer). I like this because conceptually, you<br>need to cast to a raw pointer before casting to a new pointee<br>type, and casting a raw pointer to a typed pointer carries important<br>semantics beyond simply converting to a typed pointer. The main problem<br>with Option (3) is that optional raw pointers can&#39;t be converted<br>naturally (without using `map`).<br></p><p>Another thing I&#39;m a little nervous about is confusing a cast of the<br>pointer value with a cast of the pointee type:<br></p><p>  `unsafeBitCast(rawPtr, to: Int.self)`<br></p><p>is very different from<br></p><p>  `rawPtr.unsafeCast(to: Int.self)`<br></p><p>Does this need to be clarified? If so, we can go back to the<br>`toPointee` label that I proposed earlier.<br></p><p>With that in mind, Option(4) is starting to look pretty good.<br></p><p>Examples:<br></p><p>---<br>Case 1: casting a raw pointer as an argument<br></p><p>func foo(_: UnsafePointer&lt;A&gt;)<br></p><p>let rawPtr = UnsafeRawPointer(...)<br></p><p>(1) foo(UnsafePointer(cast: rawPtr))<br></p><p>(2) foo(UnsafePointer(rawPtr, to: A.self))<br></p><p>(3) foo(rawPtr.unsafeCast(to: A.self))<br></p><p>(4) foo(unsafeCast(rawPointer: rawPtr, to: A.self))<br></p><p>---<br>Case 2: &quot;recasting&quot; a typed pointer argument<br></p><p>Note that typed pointer arguments are implicitly cast to raw pointer<br>arguments, so the conversion from PtrB to raw is implicit.<br></p><p>func foo(_: UnsafePointer&lt;A&gt;)<br></p><p>let ptrB = UnsafePointer&lt;B&gt;(...)<br></p><p>(1) foo(UnsafePointer(cast: ptrB))<br></p><p>(2) foo(UnsafePointer(ptrB, to: A.self))<br></p><p>(3) foo(UnsafeRawPointer(ptrB).unsafeCast(to: A.self))<br></p><p>(4) foo(unsafeCast(rawPointer: ptrB, to: A.self))<br></p><p>---<br>Case 3: Optional argument (only Option 3 is affected)<br></p><p>func nullableFoo(_: UnsafePointer&lt;Int&gt;?)<br></p><p>let ptrB: UnsafePointer&lt;UInt&gt;? = ...<br></p><p>(1) nullableFoo(UnsafePointer(cast: ptrB))<br></p><p>(2) nullableFoo(UnsafePointer(ptrB, to: A.self))<br></p><p>(3) nullableFoo(UnsafeRawPointer(ptrB).map { $0.unsafeCast(to: A.self) })<br></p><p>(4) nullableFoo(unsafeCast(rawPointer: ptrB, to: A.self))<br></p><p>---<br>Case 4: Return values<br></p><p>func foo() -&gt; UnsafePointer&lt;A&gt;<br></p><p>func caller() -&gt; UnsafePointer&lt;B&gt; { ...<br></p><p>(1) return UnsafePointer(cast: foo())<br></p><p>(2) return UnsafePointer(foo(), to: B.self)<br></p><p>(3) let rawPtr = UnsafeRawPointer(foo())<br>    return rawPtr.unsafeCast(to: B.self)<br></p><p>(4) return unsafeCast(rawPointer: foo(), to: B.self)<br></p><p>-Andy<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160624/fbd47f36/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Draft] UnsafeRawPointer API</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June 26, 2016 at 11:00:00pm</p></header><div class="content"><p>on Fri Jun 24 2016, Andrew Trick &lt;atrick-AT-apple.com&gt; wrote:<br></p><p>&gt;&gt; On Jun 24, 2016, at 11:22 AM, Andrew Trick via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 24, 2016, at 11:17 AM, L. Mihalkovic<br>&gt;&gt;&gt; &lt;laurent.mihalkovic at gmail.com<br>&gt;&gt;&gt; &lt;mailto:laurent.mihalkovic at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I like the watch-what-you-wish-for warning of unsafeCast.<br>&gt;&gt; <br>&gt;&gt; I’ll try porting stdlib to the “UnsafeRawPointer.unsafeCast(to:<br>&gt;&gt; T.Type)” syntax and see how bad it is.<br>&gt;<br>&gt; I don&#39;t think there&#39;s a clear winner here. Let me enumerate some<br>&gt; options.<br>&gt;<br>&gt; Option (1) UnsafePointer&lt;T&gt;(cast: UnsafeRawPointer)<br></p><p>The problem with this one is that T can be deduced based on type<br>context.  I think we ought to move away from that for operations like<br>this one.<br></p><p>&gt; Option (2) UnsafePointer&lt;T&gt;(_: UnsafeRawPointer, to: T.self)<br></p><p>I think you mean T.Type, not T.self, because this looks like a declaration.<br></p><p>To evaluate, you have to look at the use-site:<br></p><p>    let p = UnsafePointer(r, to: Int.self)<br></p><p>I don&#39;t find “to” to be descriptive enough.  Maybe<br></p><p>    let p = UnsafePointer(r, pointee: Int.self)<br></p><p>is better.  But I hate that the language doesn&#39;t give us a way to say<br>“don&#39;t deduce generic parameters here.”  This is the only syntax that<br>feels right, IMO:<br></p><p>    let p = UnsafePointer&lt;Int&gt;(r)<br></p><p>&gt; Option (3) UnsafeRawPointer.unsafeCast&lt;T&gt;(to: T.Type) -&gt;<br>&gt; UnsafePointer&lt;T&gt;<br></p><p>    r.unsafeCast(to: Int.self)<br></p><p>I don&#39;t see adding “unsafe” to the name of the operation as adding<br>anything.  It isn&#39;t any more unsafe than other UnsafeRawPointer<br>operations.  Also, it reads like we&#39;re casting the raw pointer to an<br>Int, rather than to an UnsafePointer&lt;Int&gt;.  Also, how do you get an<br>UnsafeMutablePointer?<br></p><p>&gt; Option (4) unsafeCast(rawPointer: UnsafeRawPointer, to: T.self) -&gt;<br>&gt; UnsafePointer&lt;T&gt;<br></p><p>This one won&#39;t read correctly for the same reasons as #3.<br></p><p>    r.cast(to: UnsafePointer&lt;Int&gt;.self)<br></p><p>works better for me than any of the alternatives given our inability to<br>get the One True Syntax.<br></p><p>&gt; ---<br>&gt; Option (3) is the most explicit and searchable, and forces<br>&gt; UnsafeRawPointer to be spelled out in the conversion (unless you<br>&gt; already have a raw pointer). <br></p><p>Huh?  I&#39;m confused here.  What you wrote looks like it&#39;s intended to be<br>a regular method, in which case of course invoking it would require a raw<br>pointer and wouldn&#39;t force you to write UnsafeRawPointer out anywhere.<br></p><p>The only way it could force you to write UnsafeRawPointer would be if it<br>was a static method, but in that case it has too few arguments.<br></p><p>&gt; I like this because conceptually, you need to cast to a raw pointer<br>&gt; before casting to a new pointee type, and casting a raw pointer to a<br>&gt; typed pointer carries important semantics beyond simply converting to<br>&gt; a typed pointer. The main problem with Option (3) is that optional raw<br>&gt; pointers can&#39;t be converted naturally (without using `map`).<br></p><p>  r ?? someExpressionUsing(r!)<br></p><p>best I can do.<br></p><p>&gt; Another thing I&#39;m a little nervous about is confusing a cast of the<br>&gt; pointer value with a cast of the pointee type:<br>&gt;<br>&gt;   `unsafeBitCast(rawPtr, to: Int.self)`<br>&gt;<br>&gt; is very different from<br>&gt;<br>&gt;   `rawPtr.unsafeCast(to: Int.self)`<br>&gt;<br>&gt; Does this need to be clarified? <br></p><p>Yes!<br></p><p>&gt; If so, we can go back to the `toPointee` label that I proposed<br>&gt; earlier.<br>&gt;<br>&gt; With that in mind, Option(4) is starting to look pretty good.<br>&gt;<br>&gt; Examples:<br>&gt;<br>&gt; ---<br>&gt; Case 1: casting a raw pointer as an argument<br></p><p>Use sites! (yay)...<br></p><p>&gt; func foo(_: UnsafePointer&lt;A&gt;)<br>&gt;<br>&gt; let rawPtr = UnsafeRawPointer(...)<br>&gt;<br>&gt; (1) foo(UnsafePointer(cast: rawPtr))<br>&gt;<br>&gt; (2) foo(UnsafePointer(rawPtr, to: A.self))<br>&gt;<br>&gt; (3) foo(rawPtr.unsafeCast(to: A.self))<br>&gt;<br>&gt; (4) foo(unsafeCast(rawPointer: rawPtr, to: A.self))<br></p><p><br>foo(rawPtr.cast(to: UnsafePointer&lt;A&gt;.self))<br></p><p>&gt; ---<br>&gt; Case 2: &quot;recasting&quot; a typed pointer argument<br>&gt;<br>&gt; Note that typed pointer arguments are implicitly cast to raw pointer<br>&gt; arguments, so the conversion from PtrB to raw is implicit.<br>&gt;<br>&gt; func foo(_: UnsafePointer&lt;A&gt;)<br>&gt;<br>&gt; let ptrB = UnsafePointer&lt;B&gt;(...)<br>&gt;<br>&gt; (1) foo(UnsafePointer(cast: ptrB))<br>&gt;<br>&gt; (2) foo(UnsafePointer(ptrB, to: A.self))<br>&gt;<br>&gt; (3) foo(UnsafeRawPointer(ptrB).unsafeCast(to: A.self))<br>&gt;<br>&gt; (4) foo(unsafeCast(rawPointer: ptrB, to: A.self))<br></p><p>foo(UnsafeRawPointer(ptrB).cast(to: UnsafePointer&lt;A&gt;.self))<br></p><p>I don&#39;t believe in making these “double-hops” concise.<br></p><p>&gt; ---<br>&gt; Case 3: Optional argument (only Option 3 is affected)<br>&gt;<br>&gt; func nullableFoo(_: UnsafePointer&lt;Int&gt;?)<br>&gt;<br>&gt; let ptrB: UnsafePointer&lt;UInt&gt;? = ...<br>&gt;<br>&gt; (1) nullableFoo(UnsafePointer(cast: ptrB))<br>&gt;<br>&gt; (2) nullableFoo(UnsafePointer(ptrB, to: A.self))<br>&gt;<br>&gt; (3) nullableFoo(UnsafeRawPointer(ptrB).map { $0.unsafeCast(to: A.self) })<br>&gt;<br>&gt; (4) nullableFoo(unsafeCast(rawPointer: ptrB, to: A.self))<br></p><p>nullableFoo(UnsafeRawPointer(ptrB)?.cast(to: UnsafePointer&lt;A&gt;.self))<br></p><p>You do the above with a failable init on UnsafeRawPointer that takes an<br>optional UnsafePointer.<br></p><p>&gt; ---<br>&gt; Case 4: Return values<br>&gt;<br>&gt; func foo() -&gt; UnsafePointer&lt;A&gt;<br>&gt;<br>&gt; func caller() -&gt; UnsafePointer&lt;B&gt; { ...<br>&gt;<br>&gt; (1) return UnsafePointer(cast: foo())<br>&gt;<br>&gt; (2) return UnsafePointer(foo(), to: B.self)<br>&gt;<br>&gt; (3) let rawPtr = UnsafeRawPointer(foo())<br>&gt;     return rawPtr.unsafeCast(to: B.self)<br>&gt;<br>&gt; (4) return unsafeCast(rawPointer: foo(), to: B.self)<br></p><p>return UnsafeRawPointer(foo()).cast(to: UnsafePointer&lt;B&gt;.self)<br></p><p>IMO-ly y&#39;rs,<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Draft] UnsafeRawPointer API</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June 27, 2016 at 10:00:00pm</p></header><div class="content"><p>Regards<br>(From mobile)<br></p><p>&gt; On Jun 27, 2016, at 8:39 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Fri Jun 24 2016, Andrew Trick &lt;atrick-AT-apple.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jun 24, 2016, at 11:22 AM, Andrew Trick via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 24, 2016, at 11:17 AM, L. Mihalkovic<br>&gt;&gt;&gt;&gt; &lt;laurent.mihalkovic at gmail.com<br>&gt;&gt;&gt;&gt; &lt;mailto:laurent.mihalkovic at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I like the watch-what-you-wish-for warning of unsafeCast.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’ll try porting stdlib to the “UnsafeRawPointer.unsafeCast(to:<br>&gt;&gt;&gt; T.Type)” syntax and see how bad it is.<br>&gt;&gt; <br>&gt;&gt; I don&#39;t think there&#39;s a clear winner here. Let me enumerate some<br>&gt;&gt; options.<br>&gt;&gt; <br>&gt;&gt; Option (1) UnsafePointer&lt;T&gt;(cast: UnsafeRawPointer)<br>&gt; <br>&gt; The problem with this one is that T can be deduced based on type<br>&gt; context.  I think we ought to move away from that for operations like<br>&gt; this one.<br>&gt; <br>&gt;&gt; Option (2) UnsafePointer&lt;T&gt;(_: UnsafeRawPointer, to: T.self)<br>&gt; <br>&gt; I think you mean T.Type, not T.self, because this looks like a declaration.<br>&gt; <br>&gt; To evaluate, you have to look at the use-site:<br>&gt; <br>&gt;    let p = UnsafePointer(r, to: Int.self)<br>&gt; <br>&gt; I don&#39;t find “to” to be descriptive enough.  Maybe<br></p><p>toType<br></p><p>&gt; <br>&gt;    let p = UnsafePointer(r, pointee: Int.self)<br></p><p>I find pointee a total aberation :)<br></p><p>&gt; <br>&gt; is better.  But I hate that the language doesn&#39;t give us a way to say<br>&gt; “don&#39;t deduce generic parameters here.”  This is the only syntax that<br>&gt; feels right, IMO:<br>&gt; <br>&gt;    let p = UnsafePointer&lt;Int&gt;(r)<br>&gt; <br>&gt;&gt; Option (3) UnsafeRawPointer.unsafeCast&lt;T&gt;(to: T.Type) -&gt;<br>&gt;&gt; UnsafePointer&lt;T&gt;<br>&gt; <br>&gt;    r.unsafeCast(to: Int.self)<br>&gt; <br>&gt; I don&#39;t see adding “unsafe” to the name of the operation as adding<br>&gt; anything.  It isn&#39;t any more unsafe than other UnsafeRawPointer<br>&gt; operations.  <br></p><p>It is unsafe in the sense that there are no guarantees that it is a sensible thing to do. I guess that means it is more &#39;noguaranteeexplicitorimpliedapplied&#39; in the sense that it will like mechanically work, even if it produce an aberation as a result<br></p><p>&gt; Also, it reads like we&#39;re casting the raw pointer to an<br>&gt; Int, rather than to an UnsafePointer&lt;Int&gt;.<br></p><p>Really good one... But then instead of &#39;to&#39; or &#39;pointee&#39;, something along the lines of &#39;wrappedType&#39;, which lookes a little less balerina-ish than pointee.....<br></p><p>&gt;  Also, how do you get an<br>&gt; UnsafeMutablePointer?<br>&gt; <br>&gt;&gt; Option (4) unsafeCast(rawPointer: UnsafeRawPointer, to: T.self) -&gt;<br>&gt;&gt; UnsafePointer&lt;T&gt;<br>&gt; <br>&gt; This one won&#39;t read correctly for the same reasons as #3.<br>&gt; <br>&gt;    r.cast(to: UnsafePointer&lt;Int&gt;.self)<br>&gt; <br>&gt; works better for me than any of the alternatives given our inability to<br>&gt; get the One True Syntax.<br>&gt; <br>&gt;&gt; ---<br>&gt;&gt; Option (3) is the most explicit and searchable, and forces<br>&gt;&gt; UnsafeRawPointer to be spelled out in the conversion (unless you<br>&gt;&gt; already have a raw pointer).<br>&gt; <br>&gt; Huh?  I&#39;m confused here.  What you wrote looks like it&#39;s intended to be<br>&gt; a regular method, in which case of course invoking it would require a raw<br>&gt; pointer and wouldn&#39;t force you to write UnsafeRawPointer out anywhere.<br>&gt; <br>&gt; The only way it could force you to write UnsafeRawPointer would be if it<br>&gt; was a static method, but in that case it has too few arguments.<br>&gt; <br>&gt;&gt; I like this because conceptually, you need to cast to a raw pointer<br>&gt;&gt; before casting to a new pointee type, and casting a raw pointer to a<br>&gt;&gt; typed pointer carries important semantics beyond simply converting to<br>&gt;&gt; a typed pointer. The main problem with Option (3) is that optional raw<br>&gt;&gt; pointers can&#39;t be converted naturally (without using `map`).<br>&gt; <br>&gt;  r ?? someExpressionUsing(r!)<br>&gt; <br>&gt; best I can do.<br>&gt; <br>&gt;&gt; Another thing I&#39;m a little nervous about is confusing a cast of the<br>&gt;&gt; pointer value with a cast of the pointee type:<br>&gt;&gt; <br>&gt;&gt;  `unsafeBitCast(rawPtr, to: Int.self)`<br>&gt;&gt; <br>&gt;&gt; is very different from<br>&gt;&gt; <br>&gt;&gt;  `rawPtr.unsafeCast(to: Int.self)`<br>&gt;&gt; <br>&gt;&gt; Does this need to be clarified?<br>&gt; <br>&gt; Yes!<br>&gt; <br>&gt;&gt; If so, we can go back to the `toPointee` label that I proposed<br>&gt;&gt; earlier.<br>&gt;&gt; <br>&gt;&gt; With that in mind, Option(4) is starting to look pretty good.<br>&gt;&gt; <br>&gt;&gt; Examples:<br>&gt;&gt; <br>&gt;&gt; ---<br>&gt;&gt; Case 1: casting a raw pointer as an argument<br>&gt; <br>&gt; Use sites! (yay)...<br>&gt; <br>&gt;&gt; func foo(_: UnsafePointer&lt;A&gt;)<br>&gt;&gt; <br>&gt;&gt; let rawPtr = UnsafeRawPointer(...)<br>&gt;&gt; <br>&gt;&gt; (1) foo(UnsafePointer(cast: rawPtr))<br>&gt;&gt; <br>&gt;&gt; (2) foo(UnsafePointer(rawPtr, to: A.self))<br>&gt;&gt; <br>&gt;&gt; (3) foo(rawPtr.unsafeCast(to: A.self))<br>&gt;&gt; <br>&gt;&gt; (4) foo(unsafeCast(rawPointer: rawPtr, to: A.self))<br>&gt; <br>&gt; <br>&gt; foo(rawPtr.cast(to: UnsafePointer&lt;A&gt;.self))<br>&gt; <br>&gt;&gt; ---<br>&gt;&gt; Case 2: &quot;recasting&quot; a typed pointer argument<br>&gt;&gt; <br>&gt;&gt; Note that typed pointer arguments are implicitly cast to raw pointer<br>&gt;&gt; arguments, so the conversion from PtrB to raw is implicit.<br>&gt;&gt; <br>&gt;&gt; func foo(_: UnsafePointer&lt;A&gt;)<br>&gt;&gt; <br>&gt;&gt; let ptrB = UnsafePointer&lt;B&gt;(...)<br>&gt;&gt; <br>&gt;&gt; (1) foo(UnsafePointer(cast: ptrB))<br>&gt;&gt; <br>&gt;&gt; (2) foo(UnsafePointer(ptrB, to: A.self))<br>&gt;&gt; <br>&gt;&gt; (3) foo(UnsafeRawPointer(ptrB).unsafeCast(to: A.self))<br>&gt;&gt; <br>&gt;&gt; (4) foo(unsafeCast(rawPointer: ptrB, to: A.self))<br>&gt; <br>&gt; foo(UnsafeRawPointer(ptrB).cast(to: UnsafePointer&lt;A&gt;.self))<br>&gt; <br>&gt; I don&#39;t believe in making these “double-hops” concise.<br>&gt; <br>&gt;&gt; ---<br>&gt;&gt; Case 3: Optional argument (only Option 3 is affected)<br>&gt;&gt; <br>&gt;&gt; func nullableFoo(_: UnsafePointer&lt;Int&gt;?)<br>&gt;&gt; <br>&gt;&gt; let ptrB: UnsafePointer&lt;UInt&gt;? = ...<br>&gt;&gt; <br>&gt;&gt; (1) nullableFoo(UnsafePointer(cast: ptrB))<br>&gt;&gt; <br>&gt;&gt; (2) nullableFoo(UnsafePointer(ptrB, to: A.self))<br>&gt;&gt; <br>&gt;&gt; (3) nullableFoo(UnsafeRawPointer(ptrB).map { $0.unsafeCast(to: A.self) })<br>&gt;&gt; <br>&gt;&gt; (4) nullableFoo(unsafeCast(rawPointer: ptrB, to: A.self))<br>&gt; <br>&gt; nullableFoo(UnsafeRawPointer(ptrB)?.cast(to: UnsafePointer&lt;A&gt;.self))<br>&gt; <br>&gt; You do the above with a failable init on UnsafeRawPointer that takes an<br>&gt; optional UnsafePointer.<br>&gt; <br>&gt;&gt; ---<br>&gt;&gt; Case 4: Return values<br>&gt;&gt; <br>&gt;&gt; func foo() -&gt; UnsafePointer&lt;A&gt;<br>&gt;&gt; <br>&gt;&gt; func caller() -&gt; UnsafePointer&lt;B&gt; { ...<br>&gt;&gt; <br>&gt;&gt; (1) return UnsafePointer(cast: foo())<br>&gt;&gt; <br>&gt;&gt; (2) return UnsafePointer(foo(), to: B.self)<br>&gt;&gt; <br>&gt;&gt; (3) let rawPtr = UnsafeRawPointer(foo())<br>&gt;&gt;    return rawPtr.unsafeCast(to: B.self)<br>&gt;&gt; <br>&gt;&gt; (4) return unsafeCast(rawPointer: foo(), to: B.self)<br>&gt; <br>&gt; return UnsafeRawPointer(foo()).cast(to: UnsafePointer&lt;B&gt;.self)<br>&gt; <br>&gt; IMO-ly y&#39;rs,<br>&gt; <br>&gt; -- <br>&gt; -Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[Draft] UnsafeRawPointer API</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>June 27, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jun 27, 2016, at 1:52 PM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt; <br>&gt;  think you mean T.Type, not T.self, because this looks like a declaration.<br>&gt;&gt; <br>&gt;&gt; To evaluate, you have to look at the use-site:<br>&gt;&gt; <br>&gt;&gt;   let p = UnsafePointer(r, to: Int.self)<br>&gt;&gt; <br>&gt;&gt; I don&#39;t find “to” to be descriptive enough.  Maybe<br>&gt; <br>&gt; toType<br>&gt; <br>&gt;&gt; <br>&gt;&gt;   let p = UnsafePointer(r, pointee: Int.self)<br>&gt; <br>&gt; I find pointee a total aberation :)<br>&gt; <br>&gt;&gt; <br>&gt;&gt; is better.  But I hate that the language doesn&#39;t give us a way to say<br>&gt;&gt; “don&#39;t deduce generic parameters here.”  This is the only syntax that<br>&gt;&gt; feels right, IMO:<br>&gt;&gt; <br>&gt;&gt;   let p = UnsafePointer&lt;Int&gt;(r)<br>&gt;&gt; <br>&gt;&gt;&gt; Option (3) UnsafeRawPointer.unsafeCast&lt;T&gt;(to: T.Type) -&gt;<br>&gt;&gt;&gt; UnsafePointer&lt;T&gt;<br>&gt;&gt; <br>&gt;&gt;   r.unsafeCast(to: Int.self)<br>&gt;&gt; <br>&gt;&gt; I don&#39;t see adding “unsafe” to the name of the operation as adding<br>&gt;&gt; anything.  It isn&#39;t any more unsafe than other UnsafeRawPointer<br>&gt;&gt; operations.  <br>&gt; <br>&gt; It is unsafe in the sense that there are no guarantees that it is a sensible thing to do. I guess that means it is more &#39;noguaranteeexplicitorimpliedapplied&#39; in the sense that it will like mechanically work, even if it produce an aberation as a result<br>&gt; <br>&gt;&gt; Also, it reads like we&#39;re casting the raw pointer to an<br>&gt;&gt; Int, rather than to an UnsafePointer&lt;Int&gt;.<br>&gt; <br>&gt; Really good one... But then instead of &#39;to&#39; or &#39;pointee&#39;, something along the lines of &#39;wrappedType&#39;, which lookes a little less balerina-ish than pointee.....<br>&gt; <br></p><p><br>Any gripes about this syntax?<br></p><p>let ptrB = UnsafeRawPointer(ptrA).cast(to: UnsafePointer&lt;B&gt;.Type)<br></p><p>It meets the goal of being perfectly explicit. We can add convenience APIs for certain cases later.<br></p><p>-Andy<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/9c02f493/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Draft] UnsafeRawPointer API</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June 27, 2016 at 03:00:00pm</p></header><div class="content"><p>on Mon Jun 27 2016, Andrew Trick &lt;atrick-AT-apple.com&gt; wrote:<br></p><p>&gt;&gt; On Jun 27, 2016, at 1:52 PM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;  think you mean T.Type, not T.self, because this looks like a declaration.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To evaluate, you have to look at the use-site:<br>&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   let p = UnsafePointer(r, to: Int.self)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t find “to” to be descriptive enough.  Maybe<br>&gt;&gt; <br>&gt;&gt; toType<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   let p = UnsafePointer(r, pointee: Int.self)<br>&gt;&gt; <br>&gt;&gt; I find pointee a total aberation :)<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; is better.  But I hate that the language doesn&#39;t give us a way to say<br>&gt;&gt;&gt; “don&#39;t deduce generic parameters here.”  This is the only syntax that<br>&gt;&gt;&gt; feels right, IMO:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   let p = UnsafePointer&lt;Int&gt;(r)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Option (3) UnsafeRawPointer.unsafeCast&lt;T&gt;(to: T.Type) -&gt;<br>&gt;&gt;&gt;&gt; UnsafePointer&lt;T&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   r.unsafeCast(to: Int.self)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t see adding “unsafe” to the name of the operation as adding<br>&gt;&gt;&gt; anything.  It isn&#39;t any more unsafe than other UnsafeRawPointer<br>&gt;&gt;&gt; operations.  <br>&gt;&gt; <br>&gt;&gt; It is unsafe in the sense that there are no guarantees that it is a<br>&gt;&gt; sensible thing to do. I guess that means it is more<br>&gt;&gt; &#39;noguaranteeexplicitorimpliedapplied&#39; in the sense that it will like<br>&gt;&gt; mechanically work, even if it produce an aberation as a result<br>&gt;&gt; <br>&gt;&gt;&gt; Also, it reads like we&#39;re casting the raw pointer to an<br>&gt;&gt;&gt; Int, rather than to an UnsafePointer&lt;Int&gt;.<br>&gt;&gt; <br>&gt;&gt; Really good one... But then instead of &#39;to&#39; or &#39;pointee&#39;, something<br>&gt;&gt; along the lines of &#39;wrappedType&#39;, which lookes a little less<br>&gt;&gt; balerina-ish than pointee.....<br>&gt;&gt; <br>&gt;<br>&gt; Any gripes about this syntax?<br>&gt;<br>&gt; let ptrB = UnsafeRawPointer(ptrA).cast(to: UnsafePointer&lt;B&gt;.Type)<br></p><p>Aside from the fact that it doesn&#39;t compile? (s/Type/self/) ;-)<br></p><p>No gripes.  I think I suggested it.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[Draft] UnsafeRawPointer API</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>June 27, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jun 27, 2016, at 3:27 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; Aside from the fact that it doesn&#39;t compile? (s/Type/self/) ;-)<br></p><p>Sorry, I keep converting between decl/use style and forgetting to update that.<br></p><p>&gt; No gripes.  I think I suggested it.<br></p><p>I was responding to LM, and the rest of the list…<br></p><p>Andy<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/42ecf3f7/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ff0be1c55a97b25454e7c5670403737e?s=50"></div><header><strong>[Draft] UnsafeRawPointer API</strong> from <string>Andrew Trick</string> &lt;andrew.trick at gmail.com&gt;<p>June 27, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jun 27, 2016, at 3:27 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Any gripes about this syntax?<br>&gt;&gt; <br>&gt;&gt; let ptrB = UnsafeRawPointer(ptrA).cast(to: UnsafePointer&lt;B&gt;.Type)<br>&gt; <br>&gt; Aside from the fact that it doesn&#39;t compile? (s/Type/self/) ;-)<br></p><p>Sorry, I keep converting between decl/use style and forgetting to update that.<br></p><p>&gt; No gripes.  I think I suggested it.<br></p><p>I was responding to LM, and the rest of the list…<br></p><p>Andy<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/ce1d6133/attachment-0001.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Draft] UnsafeRawPointer API</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June 28, 2016 at 07:00:00am</p></header><div class="content"><p>Regards<br>LM<br>(From mobile)<br></p><p>&gt; On Jun 28, 2016, at 12:18 AM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Jun 27, 2016, at 1:52 PM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  think you mean T.Type, not T.self, because this looks like a declaration.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To evaluate, you have to look at the use-site:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   let p = UnsafePointer(r, to: Int.self)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t find “to” to be descriptive enough.  Maybe<br>&gt;&gt; <br>&gt;&gt; toType<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   let p = UnsafePointer(r, pointee: Int.self)<br>&gt;&gt; <br>&gt;&gt; I find pointee a total aberation :)<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; is better.  But I hate that the language doesn&#39;t give us a way to say<br>&gt;&gt;&gt; “don&#39;t deduce generic parameters here.”  This is the only syntax that<br>&gt;&gt;&gt; feels right, IMO:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   let p = UnsafePointer&lt;Int&gt;(r)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Option (3) UnsafeRawPointer.unsafeCast&lt;T&gt;(to: T.Type) -&gt;<br>&gt;&gt;&gt;&gt; UnsafePointer&lt;T&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   r.unsafeCast(to: Int.self)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t see adding “unsafe” to the name of the operation as adding<br>&gt;&gt;&gt; anything.  It isn&#39;t any more unsafe than other UnsafeRawPointer<br>&gt;&gt;&gt; operations.  <br>&gt;&gt; <br>&gt;&gt; It is unsafe in the sense that there are no guarantees that it is a sensible thing to do. I guess that means it is more &#39;noguaranteeexplicitorimpliedapplied&#39; in the sense that it will like mechanically work, even if it produce an aberation as a result<br>&gt;&gt; <br>&gt;&gt;&gt; Also, it reads like we&#39;re casting the raw pointer to an<br>&gt;&gt;&gt; Int, rather than to an UnsafePointer&lt;Int&gt;.<br>&gt;&gt; <br>&gt;&gt; Really good one... But then instead of &#39;to&#39; or &#39;pointee&#39;, something along the lines of &#39;wrappedType&#39;, which lookes a little less balerina-ish than pointee.....<br>&gt; <br>&gt; <br>&gt; Any gripes about this syntax?<br>&gt; <br>&gt; let ptrB = UnsafeRawPointer(ptrA).cast(to: UnsafePointer&lt;B&gt;.Type)<br>&gt; <br>&gt; It meets the goal of being perfectly explicit. We can add convenience APIs for certain cases later.<br>&gt; <br>&gt; -Andy<br></p><p>I have to say, there are many situations when writing java code where i wished List&lt;Int&gt;.class existed.. instead I&#39;d resort to xxx(List.class, Int.class) or to generic reflection on a abstract type token. <br>So this DEFINITELY floats my boat!!!! As you say, it is the most accurate depiction of what truly happens.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/3c5f1d53/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Draft] UnsafeRawPointer API</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June 27, 2016 at 03:00:00pm</p></header><div class="content"><p>on Mon Jun 27 2016, &quot;L. Mihalkovic&quot; &lt;laurent.mihalkovic-AT-gmail.com&gt; wrote:<br></p><p>&gt; Regards<br>&gt; (From mobile)<br>&gt;<br>&gt;&gt; On Jun 27, 2016, at 8:39 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Fri Jun 24 2016, Andrew Trick &lt;atrick-AT-apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 24, 2016, at 11:22 AM, Andrew Trick via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 24, 2016, at 11:17 AM, L. Mihalkovic<br>&gt;&gt;&gt;&gt;&gt; &lt;laurent.mihalkovic at gmail.com<br>&gt;&gt;&gt;&gt;&gt; &lt;mailto:laurent.mihalkovic at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I like the watch-what-you-wish-for warning of unsafeCast.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’ll try porting stdlib to the “UnsafeRawPointer.unsafeCast(to:<br>&gt;&gt;&gt;&gt; T.Type)” syntax and see how bad it is.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t think there&#39;s a clear winner here. Let me enumerate some<br>&gt;&gt;&gt; options.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Option (1) UnsafePointer&lt;T&gt;(cast: UnsafeRawPointer)<br>&gt;&gt; <br>&gt;&gt; The problem with this one is that T can be deduced based on type<br>&gt;&gt; context.  I think we ought to move away from that for operations like<br>&gt;&gt; this one.<br>&gt;&gt; <br>&gt;&gt;&gt; Option (2) UnsafePointer&lt;T&gt;(_: UnsafeRawPointer, to: T.self)<br>&gt;&gt; <br>&gt;&gt; I think you mean T.Type, not T.self, because this looks like a declaration.<br>&gt;&gt; <br>&gt;&gt; To evaluate, you have to look at the use-site:<br>&gt;&gt; <br>&gt;&gt;    let p = UnsafePointer(r, to: Int.self)<br>&gt;&gt; <br>&gt;&gt; I don&#39;t find “to” to be descriptive enough.  Maybe<br>&gt;<br>&gt; toType<br>&gt;<br>&gt;&gt; <br>&gt;&gt;    let p = UnsafePointer(r, pointee: Int.self)<br>&gt;<br>&gt; I find pointee a total aberation :)<br>&gt;<br>&gt;&gt; <br>&gt;&gt; is better.  But I hate that the language doesn&#39;t give us a way to say<br>&gt;&gt; “don&#39;t deduce generic parameters here.”  This is the only syntax that<br>&gt;&gt; feels right, IMO:<br>&gt;&gt; <br>&gt;&gt;    let p = UnsafePointer&lt;Int&gt;(r)<br>&gt;&gt; <br>&gt;&gt;&gt; Option (3) UnsafeRawPointer.unsafeCast&lt;T&gt;(to: T.Type) -&gt;<br>&gt;&gt;&gt; UnsafePointer&lt;T&gt;<br>&gt;&gt; <br>&gt;&gt;    r.unsafeCast(to: Int.self)<br>&gt;&gt; <br>&gt;&gt; I don&#39;t see adding “unsafe” to the name of the operation as adding<br>&gt;&gt; anything.  It isn&#39;t any more unsafe than other UnsafeRawPointer<br>&gt;&gt; operations.  <br>&gt;<br>&gt; It is unsafe in the sense that there are no guarantees that it is a<br>&gt; sensible thing to do. <br></p><p>Just like most of the other operations on UnsafeRawPointer, which is my<br>point.<br></p><p>&gt; I guess that means it is more &#39;noguaranteeexplicitorimpliedapplied&#39; in<br>&gt; the sense that it will like mechanically work, even if it produce an<br>&gt; aberation as a result<br>&gt;<br>&gt;&gt; Also, it reads like we&#39;re casting the raw pointer to an<br>&gt;&gt; Int, rather than to an UnsafePointer&lt;Int&gt;.<br>&gt;<br>&gt; Really good one... But then instead of &#39;to&#39; or &#39;pointee&#39;, something<br>&gt; along the lines of &#39;wrappedType&#39;, which lookes a little less<br>&gt; balerina-ish than pointee.....<br></p><p>A pointer does not wrap its pointee.<br></p><p>&gt;&gt;  Also, how do you get an<br>&gt;&gt; UnsafeMutablePointer?<br>&gt;&gt; <br>&gt;&gt;&gt; Option (4) unsafeCast(rawPointer: UnsafeRawPointer, to: T.self) -&gt;<br>&gt;&gt;&gt; UnsafePointer&lt;T&gt;<br>&gt;&gt; <br>&gt;&gt; This one won&#39;t read correctly for the same reasons as #3.<br>&gt;&gt; <br>&gt;&gt;    r.cast(to: UnsafePointer&lt;Int&gt;.self)<br>&gt;&gt; <br>&gt;&gt; works better for me than any of the alternatives given our inability to<br>&gt;&gt; get the One True Syntax.<br>&gt;&gt; <br>&gt;&gt;&gt; ---<br>&gt;&gt;&gt; Option (3) is the most explicit and searchable, and forces<br>&gt;&gt;&gt; UnsafeRawPointer to be spelled out in the conversion (unless you<br>&gt;&gt;&gt; already have a raw pointer).<br>&gt;&gt; <br>&gt;&gt; Huh?  I&#39;m confused here.  What you wrote looks like it&#39;s intended to be<br>&gt;&gt; a regular method, in which case of course invoking it would require a raw<br>&gt;&gt; pointer and wouldn&#39;t force you to write UnsafeRawPointer out anywhere.<br>&gt;&gt; <br>&gt;&gt; The only way it could force you to write UnsafeRawPointer would be if it<br>&gt;&gt; was a static method, but in that case it has too few arguments.<br>&gt;&gt; <br>&gt;&gt;&gt; I like this because conceptually, you need to cast to a raw pointer<br>&gt;&gt;&gt; before casting to a new pointee type, and casting a raw pointer to a<br>&gt;&gt;&gt; typed pointer carries important semantics beyond simply converting to<br>&gt;&gt;&gt; a typed pointer. The main problem with Option (3) is that optional raw<br>&gt;&gt;&gt; pointers can&#39;t be converted naturally (without using `map`).<br>&gt;&gt; <br>&gt;&gt;  r ?? someExpressionUsing(r!)<br>&gt;&gt; <br>&gt;&gt; best I can do.<br>&gt;&gt; <br>&gt;&gt;&gt; Another thing I&#39;m a little nervous about is confusing a cast of the<br>&gt;&gt;&gt; pointer value with a cast of the pointee type:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  `unsafeBitCast(rawPtr, to: Int.self)`<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; is very different from<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  `rawPtr.unsafeCast(to: Int.self)`<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Does this need to be clarified?<br>&gt;&gt; <br>&gt;&gt; Yes!<br>&gt;&gt; <br>&gt;&gt;&gt; If so, we can go back to the `toPointee` label that I proposed<br>&gt;&gt;&gt; earlier.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With that in mind, Option(4) is starting to look pretty good.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Examples:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ---<br>&gt;&gt;&gt; Case 1: casting a raw pointer as an argument<br>&gt;&gt; <br>&gt;&gt; Use sites! (yay)...<br>&gt;&gt; <br>&gt;&gt;&gt; func foo(_: UnsafePointer&lt;A&gt;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let rawPtr = UnsafeRawPointer(...)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (1) foo(UnsafePointer(cast: rawPtr))<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (2) foo(UnsafePointer(rawPtr, to: A.self))<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (3) foo(rawPtr.unsafeCast(to: A.self))<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (4) foo(unsafeCast(rawPointer: rawPtr, to: A.self))<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; foo(rawPtr.cast(to: UnsafePointer&lt;A&gt;.self))<br>&gt;&gt; <br>&gt;&gt;&gt; ---<br>&gt;&gt;&gt; Case 2: &quot;recasting&quot; a typed pointer argument<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Note that typed pointer arguments are implicitly cast to raw pointer<br>&gt;&gt;&gt; arguments, so the conversion from PtrB to raw is implicit.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func foo(_: UnsafePointer&lt;A&gt;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let ptrB = UnsafePointer&lt;B&gt;(...)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (1) foo(UnsafePointer(cast: ptrB))<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (2) foo(UnsafePointer(ptrB, to: A.self))<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (3) foo(UnsafeRawPointer(ptrB).unsafeCast(to: A.self))<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (4) foo(unsafeCast(rawPointer: ptrB, to: A.self))<br>&gt;&gt; <br>&gt;&gt; foo(UnsafeRawPointer(ptrB).cast(to: UnsafePointer&lt;A&gt;.self))<br>&gt;&gt; <br>&gt;&gt; I don&#39;t believe in making these “double-hops” concise.<br>&gt;&gt; <br>&gt;&gt;&gt; ---<br>&gt;&gt;&gt; Case 3: Optional argument (only Option 3 is affected)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func nullableFoo(_: UnsafePointer&lt;Int&gt;?)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let ptrB: UnsafePointer&lt;UInt&gt;? = ...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (1) nullableFoo(UnsafePointer(cast: ptrB))<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (2) nullableFoo(UnsafePointer(ptrB, to: A.self))<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (3) nullableFoo(UnsafeRawPointer(ptrB).map { $0.unsafeCast(to: A.self) })<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (4) nullableFoo(unsafeCast(rawPointer: ptrB, to: A.self))<br>&gt;&gt; <br>&gt;&gt; nullableFoo(UnsafeRawPointer(ptrB)?.cast(to: UnsafePointer&lt;A&gt;.self))<br>&gt;&gt; <br>&gt;&gt; You do the above with a failable init on UnsafeRawPointer that takes an<br>&gt;&gt; optional UnsafePointer.<br>&gt;&gt; <br>&gt;&gt;&gt; ---<br>&gt;&gt;&gt; Case 4: Return values<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func foo() -&gt; UnsafePointer&lt;A&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func caller() -&gt; UnsafePointer&lt;B&gt; { ...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (1) return UnsafePointer(cast: foo())<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (2) return UnsafePointer(foo(), to: B.self)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (3) let rawPtr = UnsafeRawPointer(foo())<br>&gt;&gt;&gt;    return rawPtr.unsafeCast(to: B.self)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (4) return unsafeCast(rawPointer: foo(), to: B.self)<br>&gt;&gt; <br>&gt;&gt; return UnsafeRawPointer(foo()).cast(to: UnsafePointer&lt;B&gt;.self)<br>&gt;&gt; <br>&gt;&gt; IMO-ly y&#39;rs,<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Draft] UnsafeRawPointer API</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June 28, 2016 at 07:00:00am</p></header><div class="content"><p>Regards<br>LM<br>(From mobile)<br></p><p>&gt; On Jun 28, 2016, at 12:25 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; on Mon Jun 27 2016, &quot;L. Mihalkovic&quot; &lt;laurent.mihalkovic-AT-gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Regards<br>&gt;&gt; (From mobile)<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 27, 2016, at 8:39 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Fri Jun 24 2016, Andrew Trick &lt;atrick-AT-apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 24, 2016, at 11:22 AM, Andrew Trick via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 24, 2016, at 11:17 AM, L. Mihalkovic<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;laurent.mihalkovic at gmail.com<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:laurent.mihalkovic at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I like the watch-what-you-wish-for warning of unsafeCast.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’ll try porting stdlib to the “UnsafeRawPointer.unsafeCast(to:<br>&gt;&gt;&gt;&gt;&gt; T.Type)” syntax and see how bad it is.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don&#39;t think there&#39;s a clear winner here. Let me enumerate some<br>&gt;&gt;&gt;&gt; options.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Option (1) UnsafePointer&lt;T&gt;(cast: UnsafeRawPointer)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The problem with this one is that T can be deduced based on type<br>&gt;&gt;&gt; context.  I think we ought to move away from that for operations like<br>&gt;&gt;&gt; this one.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Option (2) UnsafePointer&lt;T&gt;(_: UnsafeRawPointer, to: T.self)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think you mean T.Type, not T.self, because this looks like a declaration.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To evaluate, you have to look at the use-site:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   let p = UnsafePointer(r, to: Int.self)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t find “to” to be descriptive enough.  Maybe<br>&gt;&gt; <br>&gt;&gt; toType<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   let p = UnsafePointer(r, pointee: Int.self)<br>&gt;&gt; <br>&gt;&gt; I find pointee a total aberation :)<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; is better.  But I hate that the language doesn&#39;t give us a way to say<br>&gt;&gt;&gt; “don&#39;t deduce generic parameters here.”  This is the only syntax that<br>&gt;&gt;&gt; feels right, IMO:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   let p = UnsafePointer&lt;Int&gt;(r)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Option (3) UnsafeRawPointer.unsafeCast&lt;T&gt;(to: T.Type) -&gt;<br>&gt;&gt;&gt;&gt; UnsafePointer&lt;T&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   r.unsafeCast(to: Int.self)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t see adding “unsafe” to the name of the operation as adding<br>&gt;&gt;&gt; anything.  It isn&#39;t any more unsafe than other UnsafeRawPointer<br>&gt;&gt;&gt; operations.  <br>&gt;&gt; <br>&gt;&gt; It is unsafe in the sense that there are no guarantees that it is a<br>&gt;&gt; sensible thing to do.<br>&gt; <br>&gt; Just like most of the other operations on UnsafeRawPointer, which is my<br>&gt; point.<br>&gt; <br>&gt;&gt; I guess that means it is more &#39;noguaranteeexplicitorimpliedapplied&#39; in<br>&gt;&gt; the sense that it will like mechanically work, even if it produce an<br>&gt;&gt; aberation as a result<br>&gt;&gt; <br>&gt;&gt;&gt; Also, it reads like we&#39;re casting the raw pointer to an<br>&gt;&gt;&gt; Int, rather than to an UnsafePointer&lt;Int&gt;.<br>&gt;&gt; <br>&gt;&gt; Really good one... But then instead of &#39;to&#39; or &#39;pointee&#39;, something<br>&gt;&gt; along the lines of &#39;wrappedType&#39;, which lookes a little less<br>&gt;&gt; balerina-ish than pointee.....<br>&gt; <br>&gt; A pointer does not wrap its pointee.<br></p><p>Mix a-&gt;b &amp; from b<br>  let p = UnsafePointer(r, pointee: Int.self)<br>  let p = UnsafePointer(r, wrappedType: Int.self)<br></p><p>Purely a-&gt;b <br>  let p = UnsafePointer(r, toObjectOfType: Int.self)<br>  let p = UnsafePointer(r, targetType: Int.self)<br>  let p = UnsafePointer(r, to: Int.self)<br>  let p = UnsafePointer(r, toType: Int.self)  <br>  let p = UnsafePointer(r, destinationType: Int.self)<br></p><p>You are of course absolutely right about wrappedType :)<br></p><p>I just think (for no other excuse than years of c) that when i think about a pointer i think of it directionally. And my unease comes from pointee suddenly shifting (for me) the view point: i suddenly have to shift to seeing the world from the other side. All the words i was trying (with the exception of wrappedType which i kept in the first group) share the  FromSourceToDestination connotation that i implicitly associate with pointers. But this is just me and this is purely subjective. Maybe it is time i break this mental model... I still find pointee a little too Bolshoi for my taste (nothing i wont get used to though).<br></p><p>&gt;&gt;&gt; Also, how do you get an<br>&gt;&gt;&gt; UnsafeMutablePointer?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Option (4) unsafeCast(rawPointer: UnsafeRawPointer, to: T.self) -&gt;<br>&gt;&gt;&gt;&gt; UnsafePointer&lt;T&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This one won&#39;t read correctly for the same reasons as #3.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   r.cast(to: UnsafePointer&lt;Int&gt;.self)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; works better for me than any of the alternatives given our inability to<br>&gt;&gt;&gt; get the One True Syntax.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ---<br>&gt;&gt;&gt;&gt; Option (3) is the most explicit and searchable, and forces<br>&gt;&gt;&gt;&gt; UnsafeRawPointer to be spelled out in the conversion (unless you<br>&gt;&gt;&gt;&gt; already have a raw pointer).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Huh?  I&#39;m confused here.  What you wrote looks like it&#39;s intended to be<br>&gt;&gt;&gt; a regular method, in which case of course invoking it would require a raw<br>&gt;&gt;&gt; pointer and wouldn&#39;t force you to write UnsafeRawPointer out anywhere.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The only way it could force you to write UnsafeRawPointer would be if it<br>&gt;&gt;&gt; was a static method, but in that case it has too few arguments.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I like this because conceptually, you need to cast to a raw pointer<br>&gt;&gt;&gt;&gt; before casting to a new pointee type, and casting a raw pointer to a<br>&gt;&gt;&gt;&gt; typed pointer carries important semantics beyond simply converting to<br>&gt;&gt;&gt;&gt; a typed pointer. The main problem with Option (3) is that optional raw<br>&gt;&gt;&gt;&gt; pointers can&#39;t be converted naturally (without using `map`).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; r ?? someExpressionUsing(r!)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; best I can do.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Another thing I&#39;m a little nervous about is confusing a cast of the<br>&gt;&gt;&gt;&gt; pointer value with a cast of the pointee type:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; `unsafeBitCast(rawPtr, to: Int.self)`<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; is very different from<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; `rawPtr.unsafeCast(to: Int.self)`<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Does this need to be clarified?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If so, we can go back to the `toPointee` label that I proposed<br>&gt;&gt;&gt;&gt; earlier.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; With that in mind, Option(4) is starting to look pretty good.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Examples:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ---<br>&gt;&gt;&gt;&gt; Case 1: casting a raw pointer as an argument<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Use sites! (yay)...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func foo(_: UnsafePointer&lt;A&gt;)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let rawPtr = UnsafeRawPointer(...)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (1) foo(UnsafePointer(cast: rawPtr))<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (2) foo(UnsafePointer(rawPtr, to: A.self))<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (3) foo(rawPtr.unsafeCast(to: A.self))<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (4) foo(unsafeCast(rawPointer: rawPtr, to: A.self))<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; foo(rawPtr.cast(to: UnsafePointer&lt;A&gt;.self))<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ---<br>&gt;&gt;&gt;&gt; Case 2: &quot;recasting&quot; a typed pointer argument<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Note that typed pointer arguments are implicitly cast to raw pointer<br>&gt;&gt;&gt;&gt; arguments, so the conversion from PtrB to raw is implicit.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func foo(_: UnsafePointer&lt;A&gt;)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let ptrB = UnsafePointer&lt;B&gt;(...)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (1) foo(UnsafePointer(cast: ptrB))<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (2) foo(UnsafePointer(ptrB, to: A.self))<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (3) foo(UnsafeRawPointer(ptrB).unsafeCast(to: A.self))<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (4) foo(unsafeCast(rawPointer: ptrB, to: A.self))<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; foo(UnsafeRawPointer(ptrB).cast(to: UnsafePointer&lt;A&gt;.self))<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t believe in making these “double-hops” concise.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ---<br>&gt;&gt;&gt;&gt; Case 3: Optional argument (only Option 3 is affected)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func nullableFoo(_: UnsafePointer&lt;Int&gt;?)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let ptrB: UnsafePointer&lt;UInt&gt;? = ...<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (1) nullableFoo(UnsafePointer(cast: ptrB))<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (2) nullableFoo(UnsafePointer(ptrB, to: A.self))<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (3) nullableFoo(UnsafeRawPointer(ptrB).map { $0.unsafeCast(to: A.self) })<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (4) nullableFoo(unsafeCast(rawPointer: ptrB, to: A.self))<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; nullableFoo(UnsafeRawPointer(ptrB)?.cast(to: UnsafePointer&lt;A&gt;.self))<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You do the above with a failable init on UnsafeRawPointer that takes an<br>&gt;&gt;&gt; optional UnsafePointer.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ---<br>&gt;&gt;&gt;&gt; Case 4: Return values<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func foo() -&gt; UnsafePointer&lt;A&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func caller() -&gt; UnsafePointer&lt;B&gt; { ...<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (1) return UnsafePointer(cast: foo())<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (2) return UnsafePointer(foo(), to: B.self)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (3) let rawPtr = UnsafeRawPointer(foo())<br>&gt;&gt;&gt;&gt;   return rawPtr.unsafeCast(to: B.self)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (4) return unsafeCast(rawPointer: foo(), to: B.self)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; return UnsafeRawPointer(foo()).cast(to: UnsafePointer&lt;B&gt;.self)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; IMO-ly y&#39;rs,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; -Dave<br>&gt; <br>&gt; -- <br>&gt; Dave<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[Draft] UnsafeRawPointer API</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>June 27, 2016 at 03:00:00pm</p></header><div class="content"><p>I agree, this syntax works best, all considered:<br></p><p>UnsafeRawPointer.cast(to: UnsafePointer&lt;B&gt;.Type)<br></p><p><br>&gt; On Jun 26, 2016, at 11:39 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; is better.  But I hate that the language doesn&#39;t give us a way to say<br>&gt; “don&#39;t deduce generic parameters here.”  This is the only syntax that<br>&gt; feels right, IMO:<br>&gt; <br>&gt;    let p = UnsafePointer&lt;Int&gt;(r)<br></p><p>FWIW: I prefer to avoid the angle brackets, but it&#39;s not a battle that needs to be fought over this feature. When experimenting with cast syntax, I found that passing type parameters as function arguments was much more readable than using generic type parameters, which I think obscure the signature. This will be especially true when &#39;.self&#39; goes away.<br></p><p>&gt;&gt; Option (3) UnsafeRawPointer.unsafeCast&lt;T&gt;(to: T.Type) -&gt;<br>&gt;&gt; UnsafePointer&lt;T&gt;<br>&gt; <br>&gt;    r.unsafeCast(to: Int.self)<br>&gt; <br>&gt; I don&#39;t see adding “unsafe” to the name of the operation as adding<br>&gt; anything.  It isn&#39;t any more unsafe than other UnsafeRawPointer<br>&gt; operations.  Also, it reads like we&#39;re casting the raw pointer to an<br>&gt; Int, rather than to an UnsafePointer&lt;Int&gt;.<br></p><p>Casting from a raw pointer to a typed pointer is only more dangerous<br>than other raw pointer operations because it is the first step in this<br>sequence of operations, which is undefined:<br></p><p>ptrA = rawPtr.cast(to: UnsafePointer&lt;A&gt;.self)<br>ptrA.initialize(with: A())<br>ptrA.deinitialize()<br></p><p>ptrB = rawPtr.cast(to: UnsafePointer&lt;B&gt;.self)<br>ptrB.initialize(with: B())<br></p><p>&gt;  Also, how do you get an<br>&gt; UnsafeMutablePointer?<br></p><p>UnsafeRawPointer casts to UnsafePointer&lt;T&gt;<br>UnsafeMutableRawPointer casts to UnsafeMutablePointer&lt;T&gt;<br></p><p>&gt;&gt; <br>&gt;&gt; Examples:<br>&gt;&gt; <br>&gt;&gt; ---<br>&gt;&gt; Case 1: casting a raw pointer as an argument<br>&gt; <br>&gt; <br>&gt; <br>&gt; foo(rawPtr.cast(to: UnsafePointer&lt;A&gt;.self))<br>&gt; <br>&gt;&gt; ---<br>&gt;&gt; Case 2: &quot;recasting&quot; a typed pointer argument<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; foo(UnsafeRawPointer(ptrB).cast(to: UnsafePointer&lt;A&gt;.self))<br>&gt; <br>&gt; I don&#39;t believe in making these “double-hops” concise.<br>&gt; <br>&gt;&gt; ---<br>&gt;&gt; Case 3: Optional argument (only Option 3 is affected)<br>&gt;&gt; <br>&gt; <br>&gt; nullableFoo(UnsafeRawPointer(ptrB)?.cast(to: UnsafePointer&lt;A&gt;.self))<br>&gt; <br>&gt; You do the above with a failable init on UnsafeRawPointer that takes an<br>&gt; optional UnsafePointer.<br>&gt; <br>&gt;&gt; ---<br>&gt;&gt; Case 4: Return values<br>&gt;&gt; <br>&gt; <br>&gt; return UnsafeRawPointer(foo()).cast(to: UnsafePointer&lt;B&gt;.self)<br>&gt; <br>&gt; -- <br>&gt; -Dave<br></p><p>Yes, that works.<br></p><p>-Andy<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Draft] UnsafeRawPointer API</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June 27, 2016 at 03:00:00pm</p></header><div class="content"><p>on Mon Jun 27 2016, Andrew Trick &lt;atrick-AT-apple.com&gt; wrote:<br></p><p>&gt; I agree, this syntax works best, all considered:<br>&gt;<br>&gt; UnsafeRawPointer.cast(to: UnsafePointer&lt;B&gt;.Type)<br>&gt;<br>&gt;&gt; On Jun 26, 2016, at 11:39 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; is better.  But I hate that the language doesn&#39;t give us a way to say<br>&gt;&gt; “don&#39;t deduce generic parameters here.”  This is the only syntax that<br>&gt;&gt; feels right, IMO:<br>&gt;&gt; <br>&gt;&gt;    let p = UnsafePointer&lt;Int&gt;(r)<br>&gt;<br>&gt; FWIW: I prefer to avoid the angle brackets, but it&#39;s not a battle that<br>&gt; needs to be fought over this feature. <br></p><p>Then you should lobby for removing them from the language :-).  <br></p><p>The way we do lossless conversions in Swift is with a label-less init<br>that takes a single parameter.  When you do that, you spell out the<br>target type and follow it with parens. It doesn&#39;t make sense that it<br>should work differently for UnsafePointer&lt;Int&gt; than it does for Int.<br></p><p>&gt; When experimenting with cast syntax, I found that passing type<br>&gt; parameters as function arguments was much more readable than using<br>&gt; generic type parameters, which I think obscure the signature. This<br>&gt; will be especially true when &#39;.self&#39; goes away.<br>&gt;<br>&gt;&gt;&gt; Option (3) UnsafeRawPointer.unsafeCast&lt;T&gt;(to: T.Type) -&gt;<br>&gt;&gt;&gt; UnsafePointer&lt;T&gt;<br>&gt;&gt; <br>&gt;&gt;    r.unsafeCast(to: Int.self)<br>&gt;&gt; <br>&gt;&gt; I don&#39;t see adding “unsafe” to the name of the operation as adding<br>&gt;&gt; anything.  It isn&#39;t any more unsafe than other UnsafeRawPointer<br>&gt;&gt; operations.  Also, it reads like we&#39;re casting the raw pointer to an<br>&gt;&gt; Int, rather than to an UnsafePointer&lt;Int&gt;.<br>&gt;<br>&gt; Casting from a raw pointer to a typed pointer is only more dangerous<br>&gt; than other raw pointer operations because it is the first step in this<br>&gt; sequence of operations, which is undefined:<br>&gt;<br>&gt; ptrA = rawPtr.cast(to: UnsafePointer&lt;A&gt;.self)<br>&gt; ptrA.initialize(with: A())<br>&gt; ptrA.deinitialize()<br>&gt;<br>&gt; ptrB = rawPtr.cast(to: UnsafePointer&lt;B&gt;.self)<br>&gt; ptrB.initialize(with: B())<br></p><p>But it&#39;s trivial to get undefined behavior without any of that.  Just:<br></p><p>  _ = rawPtr.load(UnsafePointer&lt;NonTrivialType&gt;.self)<br></p><p>boom.<br></p><p>&gt;&gt;  Also, how do you get an<br>&gt;&gt; UnsafeMutablePointer?<br>&gt;<br>&gt; UnsafeRawPointer casts to UnsafePointer&lt;T&gt;<br>&gt; UnsafeMutableRawPointer casts to UnsafeMutablePointer&lt;T&gt;<br></p><p>OK.<br></p><p>&gt;&gt;&gt; <br>&gt;&gt;&gt; Examples:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ---<br>&gt;&gt;&gt; Case 1: casting a raw pointer as an argument<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; foo(rawPtr.cast(to: UnsafePointer&lt;A&gt;.self))<br>&gt;&gt; <br>&gt;&gt;&gt; ---<br>&gt;&gt;&gt; Case 2: &quot;recasting&quot; a typed pointer argument<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; foo(UnsafeRawPointer(ptrB).cast(to: UnsafePointer&lt;A&gt;.self))<br>&gt;&gt; <br>&gt;&gt; I don&#39;t believe in making these “double-hops” concise.<br>&gt;&gt; <br>&gt;&gt;&gt; ---<br>&gt;&gt;&gt; Case 3: Optional argument (only Option 3 is affected)<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; nullableFoo(UnsafeRawPointer(ptrB)?.cast(to: UnsafePointer&lt;A&gt;.self))<br>&gt;&gt; <br>&gt;&gt; You do the above with a failable init on UnsafeRawPointer that takes an<br>&gt;&gt; optional UnsafePointer.<br>&gt;&gt; <br>&gt;&gt;&gt; ---<br>&gt;&gt;&gt; Case 4: Return values<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; return UnsafeRawPointer(foo()).cast(to: UnsafePointer&lt;B&gt;.self)<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave<br>&gt;<br>&gt; Yes, that works.<br>&gt;<br>&gt; -Andy<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[Draft] UnsafeRawPointer API</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>June 27, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jun 27, 2016, at 3:35 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; Casting from a raw pointer to a typed pointer is only more dangerous<br>&gt;&gt; than other raw pointer operations because it is the first step in this<br>&gt;&gt; sequence of operations, which is undefined:<br>&gt;&gt; <br>&gt;&gt; ptrA = rawPtr.cast(to: UnsafePointer&lt;A&gt;.self)<br>&gt;&gt; ptrA.initialize(with: A())<br>&gt;&gt; ptrA.deinitialize()<br>&gt;&gt; <br>&gt;&gt; ptrB = rawPtr.cast(to: UnsafePointer&lt;B&gt;.self)<br>&gt;&gt; ptrB.initialize(with: B())<br>&gt; <br>&gt; But it&#39;s trivial to get undefined behavior without any of that.  Just:<br>&gt; <br>&gt;  _ = rawPtr.load(UnsafePointer&lt;NonTrivialType&gt;.self)<br></p><p>That&#39;s another way to obtain a typed pointer, but by itself it is well defined.<br></p><p>This is an important point, so I want to make sure I’m getting it across.<br></p><p>The following code is well-defined:<br>```<br>ptrA = rawPtr.initialize(with: A())<br>ptrA.deinitialize()<br>ptrB = rawPtr.initialize(with: B())<br>```<br>The following code is undefined:<br>```<br>ptrA = rawPtr.cast(to: UnsafePointer&lt;A&gt;.self)<br>ptrA.initialize(with: A())<br>ptrA.deinitialize()<br>ptrB = rawPtr.cast(to: UnsafePointer&lt;B&gt;.self)<br>ptrB.initialize(with: B())<br>```<br>It is hard to spot the difference between the two styles without drawing attention to the unsafe cast.<br></p><p>I considered naming the cast `UnsafeRawPointer.bind&lt;T&gt;(to: T.Type)` to indicate that the allocated memory is being bound to a type for the entire duration of its allocation. But it&#39;s actually the call to `initialize` a typed pointer that binds the type.<br></p><p>-Andy<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/4cc963ec/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[Draft] UnsafeRawPointer API</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>June 27, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jun 27, 2016, at 4:27 PM, Andrew Trick via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 27, 2016, at 3:35 PM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Casting from a raw pointer to a typed pointer is only more dangerous<br>&gt;&gt;&gt; than other raw pointer operations because it is the first step in this<br>&gt;&gt;&gt; sequence of operations, which is undefined:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ptrA = rawPtr.cast(to: UnsafePointer&lt;A&gt;.self)<br>&gt;&gt;&gt; ptrA.initialize(with: A())<br>&gt;&gt;&gt; ptrA.deinitialize()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ptrB = rawPtr.cast(to: UnsafePointer&lt;B&gt;.self)<br>&gt;&gt;&gt; ptrB.initialize(with: B())<br>&gt;&gt; <br>&gt;&gt; But it&#39;s trivial to get undefined behavior without any of that.  Just:<br>&gt;&gt; <br>&gt;&gt;  _ = rawPtr.load(UnsafePointer&lt;NonTrivialType&gt;.self)<br>&gt; <br>&gt; That&#39;s another way to obtain a typed pointer, but by itself it is well defined.<br>&gt; <br>&gt; This is an important point, so I want to make sure I’m getting it across.<br>&gt; <br>&gt; The following code is well-defined:<br>&gt; ```<br>&gt; ptrA = rawPtr.initialize(with: A())<br>&gt; ptrA.deinitialize()<br>&gt; ptrB = rawPtr.initialize(with: B())<br>&gt; ```<br></p><p>And updated for the proposal&#39;s current syntax...<br></p><p>This is well-defined:<br>```<br>ptrA = rawPtr.initialize(A.self, with: A())<br>ptrA.deinitialize()<br>ptrB = rawPtr.initialize(B.self, with: B())<br>```<br></p><p>&gt; The following code is undefined:<br>&gt; ```<br>&gt; ptrA = rawPtr.cast(to: UnsafePointer&lt;A&gt;.self)<br>&gt; ptrA.initialize(with: A())<br>&gt; ptrA.deinitialize()<br>&gt; ptrB = rawPtr.cast(to: UnsafePointer&lt;B&gt;.self)<br>&gt; ptrB.initialize(with: B())<br>&gt; ```<br>&gt; It is hard to spot the difference between the two styles without drawing attention to the unsafe cast.<br>&gt; <br>&gt; I considered naming the cast `UnsafeRawPointer.bind&lt;T&gt;(to: T.Type)` to indicate that the allocated memory is being bound to a type for the entire duration of its allocation. But it&#39;s actually the call to `initialize` a typed pointer that binds the type.<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/bb330826/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Draft] UnsafeRawPointer API</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June 27, 2016 at 07:00:00pm</p></header><div class="content"><p>Sent from my moss-covered three-handled family gradunza<br></p><p>&gt; On Jun 27, 2016, at 4:50 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Jun 27, 2016, at 4:27 PM, Andrew Trick via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 27, 2016, at 3:35 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Casting from a raw pointer to a typed pointer is only more dangerous<br>&gt;&gt;&gt;&gt; than other raw pointer operations because it is the first step in this<br>&gt;&gt;&gt;&gt; sequence of operations, which is undefined:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ptrA = rawPtr.cast(to: UnsafePointer&lt;A&gt;.self)<br>&gt;&gt;&gt;&gt; ptrA.initialize(with: A())<br>&gt;&gt;&gt;&gt; ptrA.deinitialize()<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ptrB = rawPtr.cast(to: UnsafePointer&lt;B&gt;.self)<br>&gt;&gt;&gt;&gt; ptrB.initialize(with: B())<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But it&#39;s trivial to get undefined behavior without any of that.  Just:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  _ = rawPtr.load(UnsafePointer&lt;NonTrivialType&gt;.self)<br>&gt;&gt; <br>&gt;&gt; That&#39;s another way to obtain a typed pointer, but by itself it is well defined.<br>&gt;&gt; <br>&gt;&gt; This is an important point, so I want to make sure I’m getting it across.<br>&gt;&gt; <br>&gt;&gt; The following code is well-defined:<br>&gt;&gt; ```<br>&gt;&gt; ptrA = rawPtr.initialize(with: A())<br>&gt;&gt; ptrA.deinitialize()<br>&gt;&gt; ptrB = rawPtr.initialize(with: B())<br>&gt;&gt; ```<br>Doesn&#39;t that presume alignment?<br></p><p>&gt; And updated for the proposal&#39;s current syntax...<br>&gt; <br>&gt; This is well-defined:<br>&gt; ```<br>&gt; ptrA = rawPtr.initialize(A.self, with: A())<br>&gt; ptrA.deinitialize()<br>&gt; ptrB = rawPtr.initialize(B.self, with: B())<br>&gt; ```<br>&gt; <br>&gt;&gt; The following code is undefined:<br>&gt;&gt; ```<br>&gt;&gt; ptrA = rawPtr.cast(to: UnsafePointer&lt;A&gt;.self)<br>&gt;&gt; ptrA.initialize(with: A())<br>&gt;&gt; ptrA.deinitialize()<br>&gt;&gt; ptrB = rawPtr.cast(to: UnsafePointer&lt;B&gt;.self)<br>&gt;&gt; ptrB.initialize(with: B())<br>&gt;&gt; ```<br>&gt;&gt; It is hard to spot the difference between the two styles without drawing attention to the unsafe cast.<br>&gt;&gt; <br>&gt;&gt; I considered naming the cast `UnsafeRawPointer.bind&lt;T&gt;(to: T.Type)` to indicate that the allocated memory is being bound to a type for the entire duration of its allocation. But it&#39;s actually the call to `initialize` a typed pointer that binds the type.<br>&gt; <br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/ce11ce48/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Draft] UnsafeRawPointer API</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June 27, 2016 at 07:00:00pm</p></header><div class="content"><p>Sent from my moss-covered three-handled family gradunza<br></p><p>&gt; On Jun 27, 2016, at 4:27 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Jun 27, 2016, at 3:35 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Casting from a raw pointer to a typed pointer is only more dangerous<br>&gt;&gt;&gt; than other raw pointer operations because it is the first step in this<br>&gt;&gt;&gt; sequence of operations, which is undefined:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ptrA = rawPtr.cast(to: UnsafePointer&lt;A&gt;.self)<br>&gt;&gt;&gt; ptrA.initialize(with: A())<br>&gt;&gt;&gt; ptrA.deinitialize()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ptrB = rawPtr.cast(to: UnsafePointer&lt;B&gt;.self)<br>&gt;&gt;&gt; ptrB.initialize(with: B())<br>&gt;&gt; <br>&gt;&gt; But it&#39;s trivial to get undefined behavior without any of that.  Just:<br>&gt;&gt; <br>&gt;&gt;  _ = rawPtr.load(UnsafePointer&lt;NonTrivialType&gt;.self)<br>&gt; <br>&gt; That&#39;s another way to obtain a typed pointer, but by itself it is well defined.<br></p><p>Sorry, I meant to dereference that typed pointer as part of the expression. Now boom. <br></p><p>&gt; This is an important point, so I want to make sure I’m getting it across.<br>&gt; <br>&gt; The following code is well-defined:<br>&gt; ```<br>&gt; ptrA = rawPtr.initialize(with: A())<br>&gt; ptrA.deinitialize()<br>&gt; ptrB = rawPtr.initialize(with: B())<br>&gt; ```<br>&gt; The following code is undefined:<br>&gt; ```<br>&gt; ptrA = rawPtr.cast(to: UnsafePointer&lt;A&gt;.self)<br>&gt; ptrA.initialize(with: A())<br>&gt; ptrA.deinitialize()<br>&gt; ptrB = rawPtr.cast(to: UnsafePointer&lt;B&gt;.self)<br>&gt; ptrB.initialize(with: B())<br>&gt; ```<br>&gt; It is hard to spot the difference between the two styles without drawing attention to the unsafe cast.<br>How is that substantially different from my example?<br></p><p>&gt; I considered naming the cast `UnsafeRawPointer.bind&lt;T&gt;(to: T.Type)` to indicate that the allocated memory is being bound to a type for the entire duration of its allocation. But it&#39;s actually the call to `initialize` a typed pointer that binds the type.<br>&gt; <br>&gt; -Andy<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/3f4d4eee/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[Draft] UnsafeRawPointer API</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>June 27, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Jun 27, 2016, at 7:15 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my moss-covered three-handled family gradunza<br>&gt; <br>&gt; On Jun 27, 2016, at 4:27 PM, Andrew Trick &lt;atrick at apple.com &lt;mailto:atrick at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 27, 2016, at 3:35 PM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Casting from a raw pointer to a typed pointer is only more dangerous<br>&gt;&gt;&gt;&gt; than other raw pointer operations because it is the first step in this<br>&gt;&gt;&gt;&gt; sequence of operations, which is undefined:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ptrA = rawPtr.cast(to: UnsafePointer&lt;A&gt;.self)<br>&gt;&gt;&gt;&gt; ptrA.initialize(with: A())<br>&gt;&gt;&gt;&gt; ptrA.deinitialize()<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ptrB = rawPtr.cast(to: UnsafePointer&lt;B&gt;.self)<br>&gt;&gt;&gt;&gt; ptrB.initialize(with: B())<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But it&#39;s trivial to get undefined behavior without any of that.  Just:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  _ = rawPtr.load(UnsafePointer&lt;NonTrivialType&gt;.self)<br>&gt;&gt; <br>&gt;&gt; That&#39;s another way to obtain a typed pointer, but by itself it is well defined.<br>&gt; <br>&gt; Sorry, I meant to dereference that typed pointer as part of the expression. Now boom.<br></p><p>Loading an UnsafePointer&lt;T&gt; from the contents of the raw pointer’s memory is fine if that’s what the memory contains. Dereferencing the loaded typed pointer is fine if that memory has been previously initialized with value of NonTrivialType.<br></p><p>Also, loading NonTrivialType directly from a raw pointer is fine if the memory contains an initialized NonTrivialType. This is fine:<br></p><p>  let v = rawPtr.load(NonTrivialType.self)<br></p><p>It returns an initialized `v` (a proper copy of the value in memory).<br></p><p>&gt;&gt; This is an important point, so I want to make sure I’m getting it across.<br>&gt;&gt; <br>&gt;&gt; The following code is well-defined:<br>&gt;&gt; ```<br>&gt;&gt; ptrA = rawPtr.initialize(with: A())<br>&gt;&gt; ptrA.deinitialize()<br>&gt;&gt; ptrB = rawPtr.initialize(with: B())<br>&gt;&gt; ```<br>&gt;&gt; The following code is undefined:<br>&gt;&gt; ```<br>&gt;&gt; ptrA = rawPtr.cast(to: UnsafePointer&lt;A&gt;.self)<br>&gt;&gt; ptrA.initialize(with: A())<br>&gt;&gt; ptrA.deinitialize()<br>&gt;&gt; ptrB = rawPtr.cast(to: UnsafePointer&lt;B&gt;.self)<br>&gt;&gt; ptrB.initialize(with: B())<br>&gt;&gt; ```<br>&gt;&gt; It is hard to spot the difference between the two styles without drawing attention to the unsafe cast.<br>&gt; How is that substantially different from my example?<br></p><p>There are different sources of memory unsafety. One rule is that (roughly) when memory is dereferenced as a type it should contain an initialized value of that type (or related type). As long as users follow this very intuitive rule, and don’t force-cast into a typed pointer, then the raw pointer API is very safe!<br></p><p>Another source of memory unsafety is strict aliasing. This is not intuitive.<br></p><p>I am showing an example in which the memory location is never accessed using a type that is inconsistent with its initialized value. There is nothing wrong with the order and type of the initialization, access, deinitialization operations, so the user has followed the first, intuitive rule. The only thing wrong with my example is that the initialization uses a typed pointer. You can’t have two initializations of the same memory both using a typed pointer but with unrelated types.<br></p><p>All of this presumes that `A` and `B` are layout compatible (same alignment and size).<br></p><p>It’s true that the user could run into the same problem if they obtain a typed pointer via unsafeBitCast or rawPtr.load(UnsafePointer&lt;T&gt;). But we don’t want to provide an API explicitly for converting raw pointers into typed pointers without indicating that it opens up a new safety hole…<br></p><p>The *safe* way to get a typed pointer is this:<br>  let ptrA = rawPtr.initialize(A.self, with: A())<br></p><p>If you’re getting a typed pointer any other way then you need to be aware of the strict aliasing rules, which I suspect most users will not want to think about.<br></p><p>So, UnsafeRawPointer.cast(to: UnsafePointer&lt;T&gt;.Type) is *not* as safe as any other operation because it opens up a very subtle issue involving strict aliasing.<br></p><p>-Andy<br></p><p>&gt; <br>&gt;&gt; I considered naming the cast `UnsafeRawPointer.bind&lt;T&gt;(to: T.Type)` to indicate that the allocated memory is being bound to a type for the entire duration of its allocation. But it&#39;s actually the call to `initialize` a typed pointer that binds the type.<br>&gt;&gt; <br>&gt;&gt; -Andy<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/057c7f0c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Draft] UnsafeRawPointer API</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June 27, 2016 at 10:00:00pm</p></header><div class="content"><p>on Mon Jun 27 2016, Andrew Trick &lt;atrick-AT-apple.com&gt; wrote:<br></p><p>&gt;&gt; On Jun 27, 2016, at 7:15 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my moss-covered three-handled family gradunza<br>&gt;<br>&gt;&gt; <br>&gt;&gt; On Jun 27, 2016, at 4:27 PM, Andrew Trick &lt;atrick at apple.com &lt;mailto:atrick at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 27, 2016, at 3:35 PM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Casting from a raw pointer to a typed pointer is only more dangerous<br>&gt;&gt;&gt;&gt;&gt; than other raw pointer operations because it is the first step in this<br>&gt;&gt;&gt;&gt;&gt; sequence of operations, which is undefined:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ptrA = rawPtr.cast(to: UnsafePointer&lt;A&gt;.self)<br>&gt;&gt;&gt;&gt;&gt; ptrA.initialize(with: A())<br>&gt;&gt;&gt;&gt;&gt; ptrA.deinitialize()<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ptrB = rawPtr.cast(to: UnsafePointer&lt;B&gt;.self)<br>&gt;&gt;&gt;&gt;&gt; ptrB.initialize(with: B())<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But it&#39;s trivial to get undefined behavior without any of that.  Just:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  _ = rawPtr.load(UnsafePointer&lt;NonTrivialType&gt;.self)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That&#39;s another way to obtain a typed pointer, but by itself it is well defined.<br>&gt;&gt; <br>&gt;&gt; Sorry, I meant to dereference that typed pointer as part of the expression. Now boom.<br>&gt;<br>&gt; Loading an UnsafePointer&lt;T&gt; from the contents of the raw pointer’s<br>&gt; memory is fine if that’s what the memory contains. Dereferencing the<br>&gt; loaded typed pointer is fine if that memory has been previously<br>&gt; initialized with value of NonTrivialType.<br></p><p>Yes of course.  The point was that rawPtr points to uninitialized<br>memory.<br></p><p>&gt; Also, loading NonTrivialType directly from a raw pointer is fine if<br>&gt; the memory contains an initialized NonTrivialType. This is fine:<br>&gt;<br>&gt;   let v = rawPtr.load(NonTrivialType.self)<br>&gt;<br>&gt; It returns an initialized `v` (a proper copy of the value in memory).<br>&gt;<br>&gt;&gt;&gt; This is an important point, so I want to make sure I’m getting it across.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The following code is well-defined:<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; ptrA = rawPtr.initialize(with: A())<br>&gt;&gt;&gt; ptrA.deinitialize()<br>&gt;&gt;&gt; ptrB = rawPtr.initialize(with: B())<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; The following code is undefined:<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; ptrA = rawPtr.cast(to: UnsafePointer&lt;A&gt;.self)<br>&gt;&gt;&gt; ptrA.initialize(with: A())<br>&gt;&gt;&gt; ptrA.deinitialize()<br>&gt;&gt;&gt; ptrB = rawPtr.cast(to: UnsafePointer&lt;B&gt;.self)<br>&gt;&gt;&gt; ptrB.initialize(with: B())<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; It is hard to spot the difference between the two styles without<br>&gt;&gt;&gt; drawing attention to the unsafe cast.<br></p><p>&gt;&gt;&gt; <br>&gt;&gt; How is that substantially different from my example?<br>&gt;<br>&gt; There are different sources of memory unsafety. One rule is that<br>&gt; (roughly) when memory is dereferenced as a type it should contain an<br>&gt; initialized value of that type (or related type). As long as users<br>&gt; follow this very intuitive rule, and don’t force-cast into a typed<br>&gt; pointer, then the raw pointer API is very safe!<br></p><p>I still maintain that using cast to get an UnsafePointer that you&#39;ll<br>dereference is no less safe than using load to get an UnsafePointer that<br>you&#39;ll dereference.<br></p><p>&gt; Another source of memory unsafety is strict aliasing. This is not intuitive.<br>&gt;<br>&gt; I am showing an example in which the memory location is never accessed<br>&gt; using a type that is inconsistent with its initialized value. There is<br>&gt; nothing wrong with the order and type of the initialization, access,<br>&gt; deinitialization operations, so the user has followed the first,<br>&gt; intuitive rule. The only thing wrong with my example is that the<br>&gt; initialization uses a typed pointer. You can’t have two<br>&gt; initializations of the same memory both using a typed pointer but with<br>&gt; unrelated types.<br>&gt;<br>&gt; All of this presumes that `A` and `B` are layout compatible (same alignment and size).<br>&gt;<br>&gt; It’s true that the user could run into the same problem if they obtain<br>&gt; a typed pointer via unsafeBitCast or<br>&gt; rawPtr.load(UnsafePointer&lt;T&gt;). But we don’t want to provide an API<br>&gt; explicitly for converting raw pointers into typed pointers without<br>&gt; indicating that it opens up a new safety hole…<br>&gt;<br>&gt; The *safe* way to get a typed pointer is this:<br>&gt;   let ptrA = rawPtr.initialize(A.self, with: A())<br>&gt;<br>&gt; If you’re getting a typed pointer any other way then you need to be<br>&gt; aware of the strict aliasing rules, which I suspect most users will<br>&gt; not want to think about.<br>&gt;<br>&gt; So, UnsafeRawPointer.cast(to: UnsafePointer&lt;T&gt;.Type) is *not* as safe<br>&gt; as any other operation because it opens up a very subtle issue<br>&gt; involving strict aliasing.<br></p><p>IMO load is even worse, because there might not even be a valid pointer<br>of any kind in the address you&#39;re loading.  I just don&#39;t see a<br>fundamental distinction here.<br></p><p>-- <br>Dave<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Draft] UnsafeRawPointer API</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 24, 2016 at 10:00:00am</p></header><div class="content"><p>Andrew, thank you for working on this.  The latest draft is much improved!<br></p><p>I have a few questions.<br></p><p>Why do you require explicitly passing the type in these signatures?<br></p><p>func initialize&lt;T&gt;(_: T.Type, with: T, count: Int = 1) -&gt; UnsafeMutablePointer&lt;T&gt;<br>func initialize&lt;T&gt;(toContiguous: T.Type, atIndex: Int, with: T) -&gt; UnsafeMutablePointer&lt;T&gt;<br>func storeRaw&lt;T&gt;(_: T.Type, with: T)<br>func storeRaw&lt;T&gt;(toContiguous: T.Type, atIndex: Int, with: T)<br></p><p>There is probably a good reason, but it seems redundant at first glance and isn’t obvious from my reading of the proposal.  The alternatives would be something like this:<br></p><p>func initialize&lt;T&gt;(with: T, count: Int = 1) -&gt; UnsafeMutablePointer&lt;T&gt;<br></p><p><br></p><p>The parameter order in this signature is the opposite of the order in UnsafeMutablePointer.  Is that intentional?  If so, what is the rationale?  You might want to elaborate this in the proposal.<br></p><p>public func + (lhs: Int, rhs: UnsafeRawPointer) -&gt; UnsafeRawPointer<br></p><p><br></p><p>Shouldn’t the precondition be that memory for all elements is *uninitialized* / *deinitialized* in this example?<br></p><p>// - precondition: memory for all elements is initialized.<br>func freeCBuffer() {<br>  UnsafeRawPointer(ptrToA).deallocate(capacity: eltCount, of: A.self)<br>}<br></p><p><br></p><p><br>It looks like there is a type in this example:<br></p><p>var anyT = T(...)<br>takesTPtr(&amp;anyT)<br>takesVoidPtr(&amp;any)<br></p><p>Should the last line say `&amp;anyT`?<br></p><p><br></p><p>Other than these few questions all I can say is that this looks great!  I believe it will add important clarity to code that works with unsafe pointers.<br></p><p>-Matthew<br></p><p>&gt; On Jun 23, 2016, at 8:40 PM, Andrew Trick via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I sent two RFC&#39;s for this proposal over the past couple months (see Early swift-evolution threads). High-level feedback was fairly light. This version is a final draft, as I expect it to go through the review process next week. There is a lot more explanation and detail in this proposal now, and the memory model has been simplified and clarified.<br>&gt; <br>&gt; https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsaferawpointer.md<br>&gt; <br>&gt; If you have opinions or suggestions on API syntax, please make yourself heard. You can jump straight to the naming discussion here:<br>&gt; <br>&gt; https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsaferawpointer.md#variations-under-consideration<br>&gt; <br>&gt; Of particular interest may be the API names for:<br>&gt; <br>&gt; - Memory allocation/deallocation: fairly fundamental to the language.<br>&gt; <br>&gt; - Unsafe casting from raw pointers to typed pointers. This is going to impact a lot of code that needs C interoperability.<br>&gt; <br>&gt; Keep in mind that we will make additive API improvements later for convenience. We want the fundamentals to be clear, explicit, and reasonably safe.<br>&gt; <br>&gt; -Andy<br>&gt; <br>&gt; &lt;XXXX-unsaferawpointer.md&gt;_______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160624/e3404af9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[Draft] UnsafeRawPointer API</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>June 24, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jun 24, 2016, at 8:19 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; Andrew, thank you for working on this.  The latest draft is much improved!<br>&gt; <br>&gt; I have a few questions.<br>&gt; <br>&gt; Why do you require explicitly passing the type in these signatures?<br>&gt; <br>&gt; func initialize&lt;T&gt;(_: T.Type, with: T, count: Int = 1) -&gt; UnsafeMutablePointer&lt;T&gt;<br>&gt; func initialize&lt;T&gt;(toContiguous: T.Type, atIndex: Int, with: T) -&gt; UnsafeMutablePointer&lt;T&gt;<br>&gt; func storeRaw&lt;T&gt;(_: T.Type, with: T)<br>&gt; func storeRaw&lt;T&gt;(toContiguous: T.Type, atIndex: Int, with: T)<br>&gt; <br>&gt; There is probably a good reason, but it seems redundant at first glance and isn’t obvious from my reading of the proposal.  The alternatives would be something like this:<br>&gt; <br>&gt; func initialize&lt;T&gt;(with: T, count: Int = 1) -&gt; UnsafeMutablePointer&lt;T&gt;<br></p><p>Good question. It is deliberately, and unfortunately redundant. We&#39;re trading convenience for safety. I added this note to the proposal:<br></p><p>Note that the `T.Type` argument on `initialize` is redundant because<br>it may be inferred from the `with` argument. However, relying on type<br>inferrence at this point is dangerous. The user needs to ensure that<br>the raw pointer has the necessary size and alignment for the<br>initialized type. Explicitly spelling the type at initialization<br>prevents bugs in which the user has incorrectly guessed the inferred<br>type.<br></p><p>&gt; The parameter order in this signature is the opposite of the order in UnsafeMutablePointer.  Is that intentional?  If so, what is the rationale?  You might want to elaborate this in the proposal.<br>&gt; <br>&gt; public func + (lhs: Int, rhs: UnsafeRawPointer) -&gt; UnsafeRawPointer<br></p><p>Fixed.<br></p><p>&gt; Shouldn’t the precondition be that memory for all elements is *uninitialized* / *deinitialized* in this example?<br>&gt; <br>&gt; // - precondition: memory for all elements is initialized.<br>&gt; func freeCBuffer() {<br>&gt;   UnsafeRawPointer(ptrToA).deallocate(capacity: eltCount, of: A.self)<br>&gt; }<br>&gt; <br></p><p>Typo. Thanks!<br></p><p>&gt; It looks like there is a type in this example:<br>&gt; <br>&gt; var anyT = T(...)<br>&gt; takesTPtr(&amp;anyT)<br>&gt; takesVoidPtr(&amp;any)<br>&gt; <br>&gt; Should the last line say `&amp;anyT`?<br></p><p>Typo. Thanks!<br></p><p>-Andy<br></p><p>&gt; Other than these few questions all I can say is that this looks great!  I believe it will add important clarity to code that works with unsafe pointers.<br>&gt; <br>&gt; -Matthew<br>&gt; <br>&gt;&gt; On Jun 23, 2016, at 8:40 PM, Andrew Trick via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I sent two RFC&#39;s for this proposal over the past couple months (see Early swift-evolution threads). High-level feedback was fairly light. This version is a final draft, as I expect it to go through the review process next week. There is a lot more explanation and detail in this proposal now, and the memory model has been simplified and clarified.<br>&gt;&gt; <br>&gt;&gt; https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsaferawpointer.md &lt;https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsaferawpointer.md&gt;<br>&gt;&gt; <br>&gt;&gt; If you have opinions or suggestions on API syntax, please make yourself heard. You can jump straight to the naming discussion here:<br>&gt;&gt; <br>&gt;&gt; https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsaferawpointer.md#variations-under-consideration<br>&gt;&gt; <br>&gt;&gt; Of particular interest may be the API names for:<br>&gt;&gt; <br>&gt;&gt; - Memory allocation/deallocation: fairly fundamental to the language.<br>&gt;&gt; <br>&gt;&gt; - Unsafe casting from raw pointers to typed pointers. This is going to impact a lot of code that needs C interoperability.<br>&gt;&gt; <br>&gt;&gt; Keep in mind that we will make additive API improvements later for convenience. We want the fundamentals to be clear, explicit, and reasonably safe.<br>&gt;&gt; <br>&gt;&gt; -Andy<br>&gt;&gt; <br>&gt;&gt; &lt;XXXX-unsaferawpointer.md&gt;_______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160624/f208d1a9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Draft] UnsafeRawPointer API</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>June 24, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jun 24, 2016, at 10:58 AM, Andrew Trick via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; On Jun 24, 2016, at 8:19 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Andrew, thank you for working on this.  The latest draft is much improved!<br>&gt;&gt; <br>&gt;&gt; I have a few questions.<br>&gt;&gt; <br>&gt;&gt; Why do you require explicitly passing the type in these signatures?<br>&gt;&gt; <br>&gt;&gt; func initialize&lt;T&gt;(_: T.Type, with: T, count: Int = 1) -&gt; UnsafeMutablePointer&lt;T&gt;<br>&gt;&gt; func initialize&lt;T&gt;(toContiguous: T.Type, atIndex: Int, with: T) -&gt; UnsafeMutablePointer&lt;T&gt;<br>&gt;&gt; func storeRaw&lt;T&gt;(_: T.Type, with: T)<br>&gt;&gt; func storeRaw&lt;T&gt;(toContiguous: T.Type, atIndex: Int, with: T)<br>&gt;&gt; <br>&gt;&gt; There is probably a good reason, but it seems redundant at first glance and isn’t obvious from my reading of the proposal.  The alternatives would be something like this:<br>&gt;&gt; <br>&gt;&gt; func initialize&lt;T&gt;(with: T, count: Int = 1) -&gt; UnsafeMutablePointer&lt;T&gt;<br>&gt; <br>&gt; Good question. It is deliberately, and unfortunately redundant. We&#39;re trading convenience for safety. I added this note to the proposal:<br>&gt; <br>&gt; Note that the `T.Type` argument on `initialize` is redundant because<br>&gt; it may be inferred from the `with` argument. However, relying on type<br>&gt; inferrence at this point is dangerous. The user needs to ensure that<br>&gt; the raw pointer has the necessary size and alignment for the<br>&gt; initialized type. Explicitly spelling the type at initialization<br>&gt; prevents bugs in which the user has incorrectly guessed the inferred<br>&gt; type.<br></p><p>One major problematic case: the value could have a defaulted type, e.g.:<br>  pointer.initialize(with: 0, count: 1024)<br></p><p>John.<br></p><p>&gt; <br>&gt;&gt; The parameter order in this signature is the opposite of the order in UnsafeMutablePointer.  Is that intentional?  If so, what is the rationale?  You might want to elaborate this in the proposal.<br>&gt;&gt; <br>&gt;&gt; public func + (lhs: Int, rhs: UnsafeRawPointer) -&gt; UnsafeRawPointer<br>&gt; <br>&gt; Fixed.<br>&gt; <br>&gt;&gt; Shouldn’t the precondition be that memory for all elements is *uninitialized* / *deinitialized* in this example?<br>&gt;&gt; <br>&gt;&gt; // - precondition: memory for all elements is initialized.<br>&gt;&gt; func freeCBuffer() {<br>&gt;&gt;   UnsafeRawPointer(ptrToA).deallocate(capacity: eltCount, of: A.self)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt; <br>&gt; Typo. Thanks!<br>&gt; <br>&gt;&gt; It looks like there is a type in this example:<br>&gt;&gt; <br>&gt;&gt; var anyT = T(...)<br>&gt;&gt; takesTPtr(&amp;anyT)<br>&gt;&gt; takesVoidPtr(&amp;any)<br>&gt;&gt; <br>&gt;&gt; Should the last line say `&amp;anyT`?<br>&gt; <br>&gt; Typo. Thanks!<br>&gt; <br>&gt; -Andy<br>&gt; <br>&gt;&gt; Other than these few questions all I can say is that this looks great!  I believe it will add important clarity to code that works with unsafe pointers.<br>&gt;&gt; <br>&gt;&gt; -Matthew<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 23, 2016, at 8:40 PM, Andrew Trick via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I sent two RFC&#39;s for this proposal over the past couple months (see Early swift-evolution threads). High-level feedback was fairly light. This version is a final draft, as I expect it to go through the review process next week. There is a lot more explanation and detail in this proposal now, and the memory model has been simplified and clarified.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsaferawpointer.md &lt;https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsaferawpointer.md&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you have opinions or suggestions on API syntax, please make yourself heard. You can jump straight to the naming discussion here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsaferawpointer.md#variations-under-consideration &lt;https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsaferawpointer.md#variations-under-consideration&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Of particular interest may be the API names for:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Memory allocation/deallocation: fairly fundamental to the language.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Unsafe casting from raw pointers to typed pointers. This is going to impact a lot of code that needs C interoperability.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Keep in mind that we will make additive API improvements later for convenience. We want the fundamentals to be clear, explicit, and reasonably safe.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Andy<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &lt;XXXX-unsaferawpointer.md&gt;_______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160624/e36434d4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Draft] UnsafeRawPointer API</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 24, 2016 at 02:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jun 24, 2016, at 1:27 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jun 24, 2016, at 10:58 AM, Andrew Trick via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; On Jun 24, 2016, at 8:19 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Andrew, thank you for working on this.  The latest draft is much improved!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I have a few questions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Why do you require explicitly passing the type in these signatures?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func initialize&lt;T&gt;(_: T.Type, with: T, count: Int = 1) -&gt; UnsafeMutablePointer&lt;T&gt;<br>&gt;&gt;&gt; func initialize&lt;T&gt;(toContiguous: T.Type, atIndex: Int, with: T) -&gt; UnsafeMutablePointer&lt;T&gt;<br>&gt;&gt;&gt; func storeRaw&lt;T&gt;(_: T.Type, with: T)<br>&gt;&gt;&gt; func storeRaw&lt;T&gt;(toContiguous: T.Type, atIndex: Int, with: T)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There is probably a good reason, but it seems redundant at first glance and isn’t obvious from my reading of the proposal.  The alternatives would be something like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func initialize&lt;T&gt;(with: T, count: Int = 1) -&gt; UnsafeMutablePointer&lt;T&gt;<br>&gt;&gt; <br>&gt;&gt; Good question. It is deliberately, and unfortunately redundant. We&#39;re trading convenience for safety. I added this note to the proposal:<br>&gt;&gt; <br>&gt;&gt; Note that the `T.Type` argument on `initialize` is redundant because<br>&gt;&gt; it may be inferred from the `with` argument. However, relying on type<br>&gt;&gt; inferrence at this point is dangerous. The user needs to ensure that<br>&gt;&gt; the raw pointer has the necessary size and alignment for the<br>&gt;&gt; initialized type. Explicitly spelling the type at initialization<br>&gt;&gt; prevents bugs in which the user has incorrectly guessed the inferred<br>&gt;&gt; type.<br>&gt; <br>&gt; One major problematic case: the value could have a defaulted type, e.g.:<br>&gt;   pointer.initialize(with: 0, count: 1024)<br></p><p>Yes, this one crossed my mind.  :)  <br></p><p>It would be more convenient to not have to explicitly pass the type in every case even if we had to explicitly specify it here like &#39;pointer.initialize(with: Int(0), count: 1024)&#39; but there probably isn&#39;t a good way to require it only in cases like this.   And given the safety concerns I think the minor inconvenience is very warranted.  In any case, it&#39;s nice to have the rationale documented in the proposal.<br></p><p>&gt; <br>&gt; John.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; The parameter order in this signature is the opposite of the order in UnsafeMutablePointer.  Is that intentional?  If so, what is the rationale?  You might want to elaborate this in the proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public func + (lhs: Int, rhs: UnsafeRawPointer) -&gt; UnsafeRawPointer<br>&gt;&gt; <br>&gt;&gt; Fixed.<br>&gt;&gt; <br>&gt;&gt;&gt; Shouldn’t the precondition be that memory for all elements is *uninitialized* / *deinitialized* in this example?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // - precondition: memory for all elements is initialized.<br>&gt;&gt;&gt; func freeCBuffer() {<br>&gt;&gt;&gt;   UnsafeRawPointer(ptrToA).deallocate(capacity: eltCount, of: A.self)<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Typo. Thanks!<br>&gt;&gt; <br>&gt;&gt;&gt; It looks like there is a type in this example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var anyT = T(...)<br>&gt;&gt;&gt; takesTPtr(&amp;anyT)<br>&gt;&gt;&gt; takesVoidPtr(&amp;any)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Should the last line say `&amp;anyT`?<br>&gt;&gt; <br>&gt;&gt; Typo. Thanks!<br>&gt;&gt; <br>&gt;&gt; -Andy<br>&gt;&gt; <br>&gt;&gt;&gt; Other than these few questions all I can say is that this looks great!  I believe it will add important clarity to code that works with unsafe pointers.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 23, 2016, at 8:40 PM, Andrew Trick via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I sent two RFC&#39;s for this proposal over the past couple months (see Early swift-evolution threads). High-level feedback was fairly light. This version is a final draft, as I expect it to go through the review process next week. There is a lot more explanation and detail in this proposal now, and the memory model has been simplified and clarified.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsaferawpointer.md<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If you have opinions or suggestions on API syntax, please make yourself heard. You can jump straight to the naming discussion here:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsaferawpointer.md#variations-under-consideration<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Of particular interest may be the API names for:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Memory allocation/deallocation: fairly fundamental to the language.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Unsafe casting from raw pointers to typed pointers. This is going to impact a lot of code that needs C interoperability.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Keep in mind that we will make additive API improvements later for convenience. We want the fundamentals to be clear, explicit, and reasonably safe.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Andy<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &lt;XXXX-unsaferawpointer.md&gt;_______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160624/b7524aa2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/33536e304f2318595dbd6104fdb0bd4a?s=50"></div><header><strong>[Draft] UnsafeRawPointer API</strong> from <string>Alejandro Martinez</string> &lt;alexito4 at gmail.com&gt;<p>June 24, 2016 at 10:00:00pm</p></header><div class="content"><p>Awesome changes! Thanks for working on this.<br>The final section address all the concerns that I was having while<br>reading which is really interesting for a proposal of this kind.<br>I’m glad to see improvements on this part of the API.<br>I pointed out a minor typo on twitter, sorry didn’t saw this thread<br>before ;) https://twitter.com/alexito4/status/746420742661771265<br></p><p>Can’t wait to see be able to use this ;)<br>Cheers,<br></p><p><br>On Fri, Jun 24, 2016 at 8:38 PM, Matthew Johnson via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On Jun 24, 2016, at 1:27 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;<br>&gt; On Jun 24, 2016, at 10:58 AM, Andrew Trick via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Jun 24, 2016, at 8:19 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;<br>&gt; Andrew, thank you for working on this.  The latest draft is much improved!<br>&gt;<br>&gt; I have a few questions.<br>&gt;<br>&gt; Why do you require explicitly passing the type in these signatures?<br>&gt;<br>&gt; func initialize&lt;T&gt;(_: T.Type, with: T, count: Int = 1) -&gt;<br>&gt; UnsafeMutablePointer&lt;T&gt;<br>&gt; func initialize&lt;T&gt;(toContiguous: T.Type, atIndex: Int, with: T) -&gt;<br>&gt; UnsafeMutablePointer&lt;T&gt;<br>&gt; func storeRaw&lt;T&gt;(_: T.Type, with: T)<br>&gt; func storeRaw&lt;T&gt;(toContiguous: T.Type, atIndex: Int, with: T)<br>&gt;<br>&gt; There is probably a good reason, but it seems redundant at first glance and<br>&gt; isn’t obvious from my reading of the proposal.  The alternatives would be<br>&gt; something like this:<br>&gt;<br>&gt; func initialize&lt;T&gt;(with: T, count: Int = 1) -&gt; UnsafeMutablePointer&lt;T&gt;<br>&gt;<br>&gt;<br>&gt; Good question. It is deliberately, and unfortunately redundant. We&#39;re<br>&gt; trading convenience for safety. I added this note to the proposal:<br>&gt;<br>&gt; Note that the `T.Type` argument on `initialize` is redundant because<br>&gt; it may be inferred from the `with` argument. However, relying on type<br>&gt; inferrence at this point is dangerous. The user needs to ensure that<br>&gt; the raw pointer has the necessary size and alignment for the<br>&gt; initialized type. Explicitly spelling the type at initialization<br>&gt; prevents bugs in which the user has incorrectly guessed the inferred<br>&gt; type.<br>&gt;<br>&gt;<br>&gt; One major problematic case: the value could have a defaulted type, e.g.:<br>&gt;   pointer.initialize(with: 0, count: 1024)<br>&gt;<br>&gt;<br>&gt; Yes, this one crossed my mind.  :)<br>&gt;<br>&gt; It would be more convenient to not have to explicitly pass the type in every<br>&gt; case even if we had to explicitly specify it here like<br>&gt; &#39;pointer.initialize(with: Int(0), count: 1024)&#39; but there probably isn&#39;t a<br>&gt; good way to require it only in cases like this.   And given the safety<br>&gt; concerns I think the minor inconvenience is very warranted.  In any case,<br>&gt; it&#39;s nice to have the rationale documented in the proposal.<br>&gt;<br>&gt;<br>&gt; John.<br>&gt;<br>&gt;<br>&gt; The parameter order in this signature is the opposite of the order in<br>&gt; UnsafeMutablePointer.  Is that intentional?  If so, what is the rationale?<br>&gt; You might want to elaborate this in the proposal.<br>&gt;<br>&gt; public func + (lhs: Int, rhs: UnsafeRawPointer) -&gt; UnsafeRawPointer<br>&gt;<br>&gt;<br>&gt; Fixed.<br>&gt;<br>&gt; Shouldn’t the precondition be that memory for all elements is<br>&gt; *uninitialized* / *deinitialized* in this example?<br>&gt;<br>&gt; // - precondition: memory for all elements is initialized.<br>&gt; func freeCBuffer() {<br>&gt;   UnsafeRawPointer(ptrToA).deallocate(capacity: eltCount, of: A.self)<br>&gt; }<br>&gt;<br>&gt;<br>&gt;<br>&gt; Typo. Thanks!<br>&gt;<br>&gt; It looks like there is a type in this example:<br>&gt;<br>&gt; var anyT = T(...)<br>&gt; takesTPtr(&amp;anyT)<br>&gt; takesVoidPtr(&amp;any)<br>&gt;<br>&gt;<br>&gt; Should the last line say `&amp;anyT`?<br>&gt;<br>&gt;<br>&gt; Typo. Thanks!<br>&gt;<br>&gt; -Andy<br>&gt;<br>&gt; Other than these few questions all I can say is that this looks great!  I<br>&gt; believe it will add important clarity to code that works with unsafe<br>&gt; pointers.<br>&gt;<br>&gt; -Matthew<br>&gt;<br>&gt; On Jun 23, 2016, at 8:40 PM, Andrew Trick via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I sent two RFC&#39;s for this proposal over the past couple months (see Early<br>&gt; swift-evolution threads). High-level feedback was fairly light. This version<br>&gt; is a final draft, as I expect it to go through the review process next week.<br>&gt; There is a lot more explanation and detail in this proposal now, and the<br>&gt; memory model has been simplified and clarified.<br>&gt;<br>&gt; https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsaferawpointer.md<br>&gt;<br>&gt; If you have opinions or suggestions on API syntax, please make yourself<br>&gt; heard. You can jump straight to the naming discussion here:<br>&gt;<br>&gt; https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsaferawpointer.md#variations-under-consideration<br>&gt;<br>&gt; Of particular interest may be the API names for:<br>&gt;<br>&gt; - Memory allocation/deallocation: fairly fundamental to the language.<br>&gt;<br>&gt; - Unsafe casting from raw pointers to typed pointers. This is going to<br>&gt; impact a lot of code that needs C interoperability.<br>&gt;<br>&gt; Keep in mind that we will make additive API improvements later for<br>&gt; convenience. We want the fundamentals to be clear, explicit, and reasonably<br>&gt; safe.<br>&gt;<br>&gt; -Andy<br>&gt;<br>&gt; &lt;XXXX-unsaferawpointer.md&gt;_______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br></p><p>-- <br>Alejandro Martinez<br>http://alejandromp.com<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Draft] UnsafeRawPointer API</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 24, 2016 at 02:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jun 24, 2016, at 12:58 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 24, 2016, at 8:19 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Andrew, thank you for working on this.  The latest draft is much improved!<br>&gt;&gt; <br>&gt;&gt; I have a few questions.<br>&gt;&gt; <br>&gt;&gt; Why do you require explicitly passing the type in these signatures?<br>&gt;&gt; <br>&gt;&gt; func initialize&lt;T&gt;(_: T.Type, with: T, count: Int = 1) -&gt; UnsafeMutablePointer&lt;T&gt;<br>&gt;&gt; func initialize&lt;T&gt;(toContiguous: T.Type, atIndex: Int, with: T) -&gt; UnsafeMutablePointer&lt;T&gt;<br>&gt;&gt; func storeRaw&lt;T&gt;(_: T.Type, with: T)<br>&gt;&gt; func storeRaw&lt;T&gt;(toContiguous: T.Type, atIndex: Int, with: T)<br>&gt;&gt; <br>&gt;&gt; There is probably a good reason, but it seems redundant at first glance and isn’t obvious from my reading of the proposal.  The alternatives would be something like this:<br>&gt;&gt; <br>&gt;&gt; func initialize&lt;T&gt;(with: T, count: Int = 1) -&gt; UnsafeMutablePointer&lt;T&gt;<br>&gt; <br>&gt; Good question. It is deliberately, and unfortunately redundant. We&#39;re trading convenience for safety. I added this note to the proposal:<br>&gt; <br>&gt; Note that the `T.Type` argument on `initialize` is redundant because<br>&gt; it may be inferred from the `with` argument. However, relying on type<br>&gt; inferrence at this point is dangerous. The user needs to ensure that<br>&gt; the raw pointer has the necessary size and alignment for the<br>&gt; initialized type. Explicitly spelling the type at initialization<br>&gt; prevents bugs in which the user has incorrectly guessed the inferred<br>&gt; type.<br></p><p>I suspected it was something like this.  Thanks for explaining and updating the proposal!<br></p><p>&gt; <br>&gt;&gt; The parameter order in this signature is the opposite of the order in UnsafeMutablePointer.  Is that intentional?  If so, what is the rationale?  You might want to elaborate this in the proposal.<br>&gt;&gt; <br>&gt;&gt; public func + (lhs: Int, rhs: UnsafeRawPointer) -&gt; UnsafeRawPointer<br>&gt; <br>&gt; Fixed.<br>&gt; <br>&gt;&gt; Shouldn’t the precondition be that memory for all elements is *uninitialized* / *deinitialized* in this example?<br>&gt;&gt; <br>&gt;&gt; // - precondition: memory for all elements is initialized.<br>&gt;&gt; func freeCBuffer() {<br>&gt;&gt;   UnsafeRawPointer(ptrToA).deallocate(capacity: eltCount, of: A.self)<br>&gt;&gt; }<br>&gt; <br>&gt; Typo. Thanks!<br>&gt; <br>&gt;&gt; It looks like there is a type in this example:<br>&gt;&gt; <br>&gt;&gt; var anyT = T(...)<br>&gt;&gt; takesTPtr(&amp;anyT)<br>&gt;&gt; takesVoidPtr(&amp;any)<br>&gt;&gt; <br>&gt;&gt; Should the last line say `&amp;anyT`?<br>&gt; <br>&gt; Typo. Thanks!<br>&gt; <br>&gt; -Andy<br>&gt; <br>&gt;&gt; Other than these few questions all I can say is that this looks great!  I believe it will add important clarity to code that works with unsafe pointers.<br>&gt;&gt; <br>&gt;&gt; -Matthew<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 23, 2016, at 8:40 PM, Andrew Trick via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I sent two RFC&#39;s for this proposal over the past couple months (see Early swift-evolution threads). High-level feedback was fairly light. This version is a final draft, as I expect it to go through the review process next week. There is a lot more explanation and detail in this proposal now, and the memory model has been simplified and clarified.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsaferawpointer.md<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you have opinions or suggestions on API syntax, please make yourself heard. You can jump straight to the naming discussion here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsaferawpointer.md#variations-under-consideration<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Of particular interest may be the API names for:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Memory allocation/deallocation: fairly fundamental to the language.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Unsafe casting from raw pointers to typed pointers. This is going to impact a lot of code that needs C interoperability.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Keep in mind that we will make additive API improvements later for convenience. We want the fundamentals to be clear, explicit, and reasonably safe.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Andy<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &lt;XXXX-unsaferawpointer.md&gt;_______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160624/b87079fe/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>[Draft] UnsafeRawPointer API</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>June 26, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jun 23, 2016, at 6:40 PM, Andrew Trick via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I sent two RFC&#39;s for this proposal over the past couple months (see Early swift-evolution threads). High-level feedback was fairly light. This version is a final draft, as I expect it to go through the review process next week. There is a lot more explanation and detail in this proposal now, and the memory model has been simplified and clarified.<br>&gt; <br>&gt; https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsaferawpointer.md<br>&gt; <br>&gt; <br>&gt; -Andy<br>&gt; <br></p><p>I really like this proposal. I think it brings a lot of clarity. Nice work!<br></p><p>Russ<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[Draft] UnsafeRawPointer API</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>June 27, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jun 23, 2016, at 6:40 PM, Andrew Trick via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsaferawpointer.md<br></p><p>Would anyone like to bikeshed the allocation API? Here are two options with a slight stylistic difference:<br></p><p># Option 1:<br></p><p>extension UnsafeMutableRawPointer {<br>    init&lt;T&gt;(allocatingCapacity: Int, of: T.Type)<br></p><p>    func deallocate&lt;T&gt;(capacity: Int, of: T.Type)<br>}<br></p><p>let ptrToA = UnsafeMutableRawPointer(allocatingCapacity: 1, of: A.self)<br>  .initialize(A.self, with: A())<br>ptrToA.deinitialize(count: 1).deallocate(capacity: 1, of: A.self)<br></p><p># Option 2:<br></p><p>extension UnsafeMutableRawPointer {<br>    static allocate&lt;T&gt;(capacity: Int, of: T.Type) -&gt; UnsafeMutableRawPointer<br></p><p>    func deallocate&lt;T&gt;(capacity: Int, of: T.Type)<br>}<br></p><p>let ptrToA = UnsafeMutableRawPointer.allocate(capacity: 1, of: A.self)<br>  .initialize(A.self, with: A())<br>ptrToA.deinitialize(count: 1).deallocate(capacity: 1, of: A.self)<br></p><p>-Andy<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[Draft] UnsafeRawPointer API</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>June 29, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jun 27, 2016, at 4:53 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 23, 2016, at 6:40 PM, Andrew Trick via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsaferawpointer.md<br>&gt; <br>&gt; Would anyone like to bikeshed the allocation API? Here are two options with a slight stylistic difference:<br>&gt; <br>&gt; # Option 1:<br>&gt; <br>&gt; extension UnsafeMutableRawPointer {<br>&gt;    init&lt;T&gt;(allocatingCapacity: Int, of: T.Type)<br>&gt; <br>&gt;    func deallocate&lt;T&gt;(capacity: Int, of: T.Type)<br>&gt; }<br>&gt; <br>&gt; let ptrToA = UnsafeMutableRawPointer(allocatingCapacity: 1, of: A.self)<br>&gt;  .initialize(A.self, with: A())<br>&gt; ptrToA.deinitialize(count: 1).deallocate(capacity: 1, of: A.self)<br>&gt; <br>&gt; # Option 2:<br>&gt; <br>&gt; extension UnsafeMutableRawPointer {<br>&gt;    static allocate&lt;T&gt;(capacity: Int, of: T.Type) -&gt; UnsafeMutableRawPointer<br>&gt; <br>&gt;    func deallocate&lt;T&gt;(capacity: Int, of: T.Type)<br>&gt; }<br>&gt; <br>&gt; let ptrToA = UnsafeMutableRawPointer.allocate(capacity: 1, of: A.self)<br>&gt;  .initialize(A.self, with: A())<br>&gt; ptrToA.deinitialize(count: 1).deallocate(capacity: 1, of: A.self)<br></p><p>Since no one else has weighed in, and DaveA and I are in violent agreement, I&#39;m going to revise the proposal to change the allocation API from:<br></p><p>  let rawPtr = UnsafeRawPointer(allocatingCapacity: n, of: T.self)<br></p><p>to<br></p><p>  let rawPtr = UnsafeRawPointer.allocate(capacity: n, of: T.self)<br></p><p>The only reason I had proposed the former was to mimic the current<br>UnsafePointer API. However, an initializer&#39;s primary purpose should be to<br>construct an instance. This functions primary purpose is to allocate<br>memory, returning an new instance as a useful side effect. This also<br>provides natural symmetry with:<br></p><p>  rawPtr.deallocate(capacity: n, of: T.self)<br></p><p>-Andy<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Draft] UnsafeRawPointer API</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>June 27, 2016 at 10:00:00pm</p></header><div class="content"><p>Hi Andy,<br></p><p>Thank you for the proposal!  A few comments from me.<br></p><p>- In the &quot;Custom memory allocation section&quot; you write:<br></p><p>&gt; Note: The same allocated raw memory cannot be used both for this custom memory allocation case and for the C buffer case above because the C buffer requries that the allocated raw memory is always initialized to the same type.<br></p><p>Could you provide more explanation?  I&#39;m not quite getting it.  Is<br>this because of binding -- are you saying that there is no way to<br>un-bind the type?<br></p><p>- In the &quot;Accessing uninitialized memory with a typed pointer (binding<br>the type)&quot; section you write<br></p><p>&gt; This cast explicitly signals the intention to bind the raw memory to the destination type.<br></p><p>I think that &quot;signals the intention&quot; is not a strong enough wording,<br>it is open to interpretations.  Either it is a no-op &quot;intention&quot; (that<br>can be retracted) or it is the actual binding.  From other discussions<br>in this thread, I think you are proposing that the .toType() method<br>actually binds the memory to a type.  Is this right?  Here&#39;s what made<br>me think this way:<br></p><p>&gt; The following code is undefined:<br>&gt; ```<br>&gt; ptrA = rawPtr.cast(to: UnsafePointer&lt;A&gt;.self)<br>&gt; ptrA.initialize(with: A())<br>&gt; ptrA.deinitialize()<br>&gt; ptrB = rawPtr.cast(to: UnsafePointer&lt;B&gt;.self)<br>&gt; ptrB.initialize(with: B())<br>&gt; ```<br>&gt; It is hard to spot the difference between the two styles without drawing attention to the unsafe cast.<br></p><p>- In the same section, in the table, it is not clear whether the<br>&quot;tptr.deinitialize&quot; operation un-binds the memory type, or does not<br>have effect on it.  Which way is it?  Can I replace<br>&quot;tptr.initialize(t2: T)&quot; with &quot;tptr.initialize(u1: U)&quot;?<br></p><p>- Is it valid to access an ARC reference to a class MyClass that<br>conforms to MyProtocol with aliasing pointers,<br>UnsafeMutablePointer&lt;MyClass&gt;, UnsafeMutablePointer&lt;MyProtocol&gt;, and<br>&#39;UnsafeMutablePointer&lt;AnyObject&gt;&#39; ?  What about<br>&#39;UnsafeMutablePointer&lt;AnyObject?&gt;&#39; ?<br></p><p>- There&#39;s no API to convert from UnsafeMutableRawPointer to<br>UnsafeMutablePointer&lt;T&gt; without either doing an initialization, or<br>binding the type.  Is this on purpose?  The reason why I&#39;m asking is<br>that initialization does not seem to be binding the type (I couldn&#39;t<br>find that in the proposal), but still performs the conversion,<br>allowing further code to use typed memory access.  If this allows the<br>optimizer to get the desired guarantees about memory, why is binding<br>important?  (I&#39;m probably completely confused about this point.)<br></p><p>- Just wanted to mention that we&#39;d probably need &#39;raw&#39; variants of<br>atomic operations for stdlib-internal use, but you probably already<br>noticed that while working on the branch.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[Draft] UnsafeRawPointer API</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>June 28, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jun 27, 2016, at 10:18 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt; Hi Andy,<br>&gt; <br>&gt; Thank you for the proposal!  A few comments from me.<br></p><p>Thanks for the feedback (again)! I updated the language in the proposal (again).<br></p><p>&gt; - In the &quot;Custom memory allocation section&quot; you write:<br>&gt; <br>&gt;&gt; Note: The same allocated raw memory cannot be used both for this custom memory allocation case and for the C buffer case above because the C buffer requries that the allocated raw memory is always initialized to the same type.<br>&gt; <br>&gt; Could you provide more explanation?  I&#39;m not quite getting it.  Is<br>&gt; this because of binding -- are you saying that there is no way to<br>&gt; un-bind the type?<br></p><p>It now reads:<br></p><p>Note: The same allocated raw memory cannot be used both for this<br>custom memory allocation case and for the C buffer case above because<br>the C buffer binds the allocated memory to an element type. Binding<br>the type applies to the allocation lifetime and requries that the<br>allocated raw memory is always initialized to the same type.<br></p><p>This should make sense after reading the earlier section on initializing memory that I’ve updated as explained below...<br></p><p>&gt; - In the &quot;Accessing uninitialized memory with a typed pointer (binding<br>&gt; the type)&quot; section you write<br>&gt; <br>&gt;&gt; This cast explicitly signals the intention to bind the raw memory to the destination type.<br>&gt; <br>&gt; I think that &quot;signals the intention&quot; is not a strong enough wording,<br>&gt; it is open to interpretations.  Either it is a no-op &quot;intention&quot; (that<br>&gt; can be retracted) or it is the actual binding.  From other discussions<br>&gt; in this thread, I think you are proposing that the .toType() method<br>&gt; actually binds the memory to a type.  Is this right?  Here&#39;s what made<br>&gt; me think this way:<br>&gt; <br>&gt;&gt; The following code is undefined:<br>&gt;&gt; ```<br>&gt;&gt; ptrA = rawPtr.cast(to: UnsafePointer&lt;A&gt;.self)<br>&gt;&gt; ptrA.initialize(with: A())<br>&gt;&gt; ptrA.deinitialize()<br>&gt;&gt; ptrB = rawPtr.cast(to: UnsafePointer&lt;B&gt;.self)<br>&gt;&gt; ptrB.initialize(with: B())<br>&gt;&gt; ```<br>&gt;&gt; It is hard to spot the difference between the two styles without drawing attention to the unsafe cast.<br>&gt; <br>&gt; - In the same section, in the table, it is not clear whether the<br>&gt; &quot;tptr.deinitialize&quot; operation un-binds the memory type, or does not<br>&gt; have effect on it.  Which way is it?  Can I replace<br>&gt; &quot;tptr.initialize(t2: T)&quot; with &quot;tptr.initialize(u1: U)”?<br></p><p>I reworded this section:<br></p><p>https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsaferawpointer.md#initializing-memory-with-a-typed-pointer-binding-the-type<br></p><p>The simple rule is: if you use a typed pointer to initialize memory, that memory is bound for the duration of its lifetime. The semantics are not temporal.<br></p><p>I think that&#39;s very clear in the proposal now.<br></p><p>To fully answer your question “can memory be unbound&quot;, technically if you reinitialize the memory using a raw pointer, then accesses on either side of that initialization point are protected from strict aliasing guarantees. But that&#39;s just a confusing and mostly useless artifact of the implementation. That&#39;s not the memory model as it as specified in the proposal. So forget I said that.<br></p><p>&gt; - Is it valid to access an ARC reference to a class MyClass that<br>&gt; conforms to MyProtocol with aliasing pointers,<br>&gt; UnsafeMutablePointer&lt;MyClass&gt;, UnsafeMutablePointer&lt;MyProtocol&gt;, and<br>&gt; &#39;UnsafeMutablePointer&lt;AnyObject&gt;&#39; ?  What about<br>&gt; &#39;UnsafeMutablePointer&lt;AnyObject?&gt;’ ?<br></p><p>That&#39;s discussed in the &quot;Type Safe Memory Access&quot; documentation. I wrote this doc for the sake of discussion, but it’s a little out of date and needs to be updated before putting it up for review again:<br></p><p>https://github.com/atrick/swift/blob/type-safe-mem-docs/docs/TypeSafeMemory.rst<br></p><p>There are two aspects of the type to consider: whether they are related for the purpose of strict aliasing, and whether they are mutually layout compatible.<br></p><p>MyClass and MyProtocol are related, so there&#39;s no problem with aliasing. If MyProtocol is an AnyObject existential, then they also have the same representation (layout), so it&#39;s safe. If MyProtocol is not class constrained, then they are not layout compatible.<br></p><p>Regarding AnyObject and AnyObject?:<br></p><p>They are related because &quot;one type may be a tuple, enum, or struct that contains the other type as part of its own storage&quot;<br></p><p>They are mutually layout compatible because we know per the ABI that Optional class types have the same representation as class types. It&#39;s a bit of a special case. In general, fragile enums with single payloads have some layout guarantees. You can read the payload from the enum type, but can&#39;t read the enum from the payload type.<br></p><p>Layout compatible also pertains to the location of references within the type (they need to be ARC-compatible). I have not adequately explained that in the doc but have it on my TODO list.<br></p><p>&gt; - There&#39;s no API to convert from UnsafeMutableRawPointer to<br>&gt; UnsafeMutablePointer&lt;T&gt; without either doing an initialization, or<br>&gt; binding the type.  Is this on purpose?  The reason why I&#39;m asking is<br>&gt; that initialization does not seem to be binding the type (I couldn&#39;t<br>&gt; find that in the proposal), but still performs the conversion,<br>&gt; allowing further code to use typed memory access.  If this allows the<br>&gt; optimizer to get the desired guarantees about memory, why is binding<br>&gt; important?  (I&#39;m probably completely confused about this point.)<br></p><p>This is important. I think it is clear now in the proposal (if not, please suggest some better language to use):<br></p><p>https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsaferawpointer.md#initializing-memory-with-a-typed-pointer-binding-the-type<br></p><p>In short, initializing via a raw pointer has different semantics than initializing via a typed pointer (just like other operations on raw pointer have different semantics). Initializing via a raw pointer changes the memory state to &quot;initialized with some type&quot; for the lifetime of that value in memory. Deinitializing the memory then returns it to a pristine state. It does not impose any type on the allocated memory. I propose that this should be the normal, &quot;type safe&quot; way to work with unsafe pointers.<br></p><p>Initializing via a typed pointer, in addition to changing the temporal memory state, also imposes a type on the allocated memory for the entire lifetime of the memory itself, from allocation to deallocation. This is effectively a performance optimization and works well for an important use case (C buffer), but it is less safe, which is why casting a raw to a typed pointer needs to be an explicit cast.<br></p><p>As I keep saying, the type safe way to get a typed pointer is by initializing the raw pointer:<br></p><p>  let ptrToA = rawPtr.initialize(A.self, A())<br></p><p>Explicit pointer casts should only be used for optimizing certain data structures. Unfortunately, interoperability is another reason that developers will need to cast pointers in practice. Some reasoning about type safety is needed in those cases, but at least with this proposal it will be much easier to audit the risky pointer casts.<br></p><p>&gt; - Just wanted to mention that we&#39;d probably need &#39;raw&#39; variants of<br>&gt; atomic operations for stdlib-internal use, but you probably already<br>&gt; noticed that while working on the branch.<br></p><p>Yes, I saw that. Thanks.<br>-Andy<br></p><p>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Draft] UnsafeRawPointer API</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>June 28, 2016 at 01:00:00pm</p></header><div class="content"><p>Hi Andy,<br></p><p>Everything is clear now, thank you!<br></p><p>On Tue, Jun 28, 2016 at 1:02 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt; Initializing via a typed pointer, in addition to changing the temporal memory state, also imposes a type on the allocated memory for the entire lifetime of the memory itself, from allocation to deallocation.<br></p><p>I see.  Given that UnsafeMutablePoiner.initialize() has this very<br>important difference in semantics, did you consider reflecting it in<br>the name?  Something like &#39;.bindTypeAndInitialize()&#39; -- but I&#39;m sure a<br>better wording is possible.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[Draft] UnsafeRawPointer API</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>June 28, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jun 28, 2016, at 1:53 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt; Hi Andy,<br>&gt; <br>&gt; Everything is clear now, thank you!<br>&gt; <br>&gt; On Tue, Jun 28, 2016 at 1:02 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;&gt; Initializing via a typed pointer, in addition to changing the temporal memory state, also imposes a type on the allocated memory for the entire lifetime of the memory itself, from allocation to deallocation.<br>&gt; <br>&gt; I see.  Given that UnsafeMutablePoiner.initialize() has this very<br>&gt; important difference in semantics, did you consider reflecting it in<br>&gt; the name?  Something like &#39;.bindTypeAndInitialize()&#39; -- but I&#39;m sure a<br>&gt; better wording is possible.<br></p><p>Yes, I did consider that. I’m still open to it--maybe ‘.typedInitialize(with:). But...<br></p><p>(1) It’s awkward. The developer isn’t interested in binding the type at that point. It’s just a side effect of the way their unsafe pointer is being used.<br></p><p>(2) It would imply that the ‘.bindAndInitialize&#39; entry point is the only way to bind the type of allocated memory. But once you have a typed pointer, it’s easy to initialize memory via a simple assignment:<br>ptrToA[0] = A() // where A is trivial<br>If ptrToA was in an uninitialized state, then that also binds the type.<br></p><p>Instead, I tried to focus on discouraging the unsafe pointer cast that leads to this situation. The important thing is that we have an alternate “safe” API so that most developers just don’t need to think about it. <br></p><p>I think the best way to make this clear is through API comments and code examples. There are just a handful of UnsafePointer idioms that will be prevalent (Expected use cases) , and as long as people follow normal patterns with the proposed API, they’re unlikely to run afoul of the rules.<br></p><p>If the proposed API still isn’t safe enough, and developers are running into problems, then that calls for development of a pointer type safety sanitizer.<br></p><p>-Andy<br></p><p><br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Draft] UnsafeRawPointer API</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>June 28, 2016 at 06:00:00pm</p></header><div class="content"><p>On Tue, Jun 28, 2016 at 2:17 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt; On Jun 28, 2016, at 1:53 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Hi Andy,<br>&gt;&gt;<br>&gt;&gt; Everything is clear now, thank you!<br>&gt;&gt;<br>&gt;&gt; On Tue, Jun 28, 2016 at 1:02 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;&gt;&gt; Initializing via a typed pointer, in addition to changing the temporal memory state, also imposes a type on the allocated memory for the entire lifetime of the memory itself, from allocation to deallocation.<br>&gt;&gt;<br>&gt;&gt; I see.  Given that UnsafeMutablePoiner.initialize() has this very<br>&gt;&gt; important difference in semantics, did you consider reflecting it in<br>&gt;&gt; the name?  Something like &#39;.bindTypeAndInitialize()&#39; -- but I&#39;m sure a<br>&gt;&gt; better wording is possible.<br>&gt;<br>&gt; Yes, I did consider that. I’m still open to it--maybe ‘.typedInitialize(with:). But...<br>&gt;<br>&gt; (1) It’s awkward. The developer isn’t interested in binding the type at that point. It’s just a side effect of the way their unsafe pointer is being used.<br>&gt;<br>&gt; (2) It would imply that the ‘.bindAndInitialize&#39; entry point is the only way to bind the type of allocated memory. But once you have a typed pointer, it’s easy to initialize memory via a simple assignment:<br>&gt; ptrToA[0] = A() // where A is trivial<br>&gt; If ptrToA was in an uninitialized state, then that also binds the type.<br></p><p>It would be good to call this out in the proposal (I did not get this<br>part from the clarifications that you posted this morning.)  So the<br>rule is that every typed store binds the type?<br></p><p>&gt; Instead, I tried to focus on discouraging the unsafe pointer cast that leads to this situation. The important thing is that we have an alternate “safe” API so that most developers just don’t need to think about it.<br></p><p>That&#39;s a good goal.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[Draft] UnsafeRawPointer API</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>June 28, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Jun 28, 2016, at 6:54 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Tue, Jun 28, 2016 at 2:17 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 28, 2016, at 1:53 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi Andy,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Everything is clear now, thank you!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Tue, Jun 28, 2016 at 1:02 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; Initializing via a typed pointer, in addition to changing the temporal memory state, also imposes a type on the allocated memory for the entire lifetime of the memory itself, from allocation to deallocation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I see.  Given that UnsafeMutablePoiner.initialize() has this very<br>&gt;&gt;&gt; important difference in semantics, did you consider reflecting it in<br>&gt;&gt;&gt; the name?  Something like &#39;.bindTypeAndInitialize()&#39; -- but I&#39;m sure a<br>&gt;&gt;&gt; better wording is possible.<br>&gt;&gt; <br>&gt;&gt; Yes, I did consider that. I’m still open to it--maybe ‘.typedInitialize(with:). But...<br>&gt;&gt; <br>&gt;&gt; (1) It’s awkward. The developer isn’t interested in binding the type at that point. It’s just a side effect of the way their unsafe pointer is being used.<br>&gt;&gt; <br>&gt;&gt; (2) It would imply that the ‘.bindAndInitialize&#39; entry point is the only way to bind the type of allocated memory. But once you have a typed pointer, it’s easy to initialize memory via a simple assignment:<br>&gt;&gt; ptrToA[0] = A() // where A is trivial<br>&gt;&gt; If ptrToA was in an uninitialized state, then that also binds the type.<br>&gt; <br>&gt; It would be good to call this out in the proposal (I did not get this<br>&gt; part from the clarifications that you posted this morning.)  So the<br>&gt; rule is that every typed store binds the type?<br></p><p>Well, I’m focussing on the first initialization as a given type... I thought that explaining the rule in terms of binding allocated memory provided a simpler mental model, but it opens up questions once you try to pick it apart.<br></p><p>I changed the proposal so that &quot;binding&quot; a type is purely conceptual, not part of a formal memory model. I added the following formal rule to that section of the proposal instead:<br></p><p>A sequence of two memory operations to the same location violates strict aliasing under the following conditions:<br>- both operations access memory via a typed pointer<br>- the memory access types are unrelated<br>- at least one of the memory operations is a write<br>- there exists no intervening write to the same memory via a raw pointer<br></p><p>I updated the proposal under review with a related discussion and examples:<br></p><p>https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md#initializing-memory-with-a-typed-pointer<br></p><p>-Andy<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
