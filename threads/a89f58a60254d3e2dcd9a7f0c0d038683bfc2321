<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Partial initializers</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 14, 2016 at 10:00:00pm</p></header><div class="content"><p>I have completed the second draft of my partial initializers proposal (the first really complete draft). <br></p><p>This proposal also includes some discussion of memberwise initialization at John McCall’s request.  If anyone would like to continue discussing that topic informally I will be happy to do so, however any such discussion should happen on one of the existing memberwise initialization threads or on a new thread related to that topic.  Please do not let that section of the document be a distraction from the partial initializer proposal itself.<br></p><p>The new draft can be found here:<br></p><p>https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md &lt;https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md&gt;<br></p><p>I really appreciate any feedback you have!<br></p><p>-Matthew<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160114/a89f2321/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[Proposal] Partial initializers</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>January 15, 2016 at 08:00:00pm</p></header><div class="content"><p>I like the updates. I think the distinction between partial inits and init functions is extremely subtle. The only difference is that partial init can set `let` members, correct?<br></p><p>The only feedback I really have is that this makes the initialization rules even more complicated. I don&#39;t know how to address that though. =)<br></p><p>-David<br></p><p><br>&gt; On Jan 14, 2016, at 8:08 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I have completed the second draft of my partial initializers proposal (the first really complete draft). <br>&gt; <br>&gt; This proposal also includes some discussion of memberwise initialization at John McCall’s request.  If anyone would like to continue discussing that topic informally I will be happy to do so, however any such discussion should happen on one of the existing memberwise initialization threads or on a new thread related to that topic.  Please do not let that section of the document be a distraction from the partial initializer proposal itself.<br>&gt; <br>&gt; The new draft can be found here:<br>&gt; <br>&gt; https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md &lt;https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md&gt;<br>&gt; <br>&gt; I really appreciate any feedback you have!<br>&gt; <br>&gt; -Matthew<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160115/4eb86c11/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Partial initializers</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 18, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Jan 15, 2016, at 10:12 PM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt; <br>&gt; I like the updates. I think the distinction between partial inits and init functions is extremely subtle. The only difference is that partial init can set `let` members, correct?<br></p><p>Hi David, glad you like the changes.  <br></p><p>Yes, that is the only difference, aside from the declaration syntax.  It would be better if we didn’t need two separate forms but either one would sacrifice desirable functionality.  <br></p><p>Giving up the ability to initialize a `let` is unacceptable IMO.  Giving up the ability to share code that initializes `var` properties with post-initialization callers is also undesirable.  <br></p><p>I considered having only once concept and allowing it to be called post-initialization if it only initializes `var` properties but I don’t like that approach.  The compiler wouldn’t be able to check intent at the site of declaration (i.e. an init func that attempts to assign to a `let`) and it wouldn’t be clear to users which partial initializers could be called post-initialization and which cannot.  <br></p><p>That leaves us with the need for two very similar concepts.  The only reasonable alternative seems to be dropping `init func`.  I would do that it if it became a hurdle to accepting the proposal, but I think it will be a common use case and is worth including.<br></p><p>Do you have any further thoughts?  Do you agree with the decision I made here?<br></p><p><br>&gt; The only feedback I really have is that this makes the initialization rules even more complicated. I don&#39;t know how to address that though. =)<br></p><p>Agree, the rules are essential complexity if we want safe initialization.  <br></p><p>I think the small incremental increase in complexity is a worthwhile price to pay for the ability to factor initialization code.  This is especially true if we’re going to add stored properties in extensions.  I wouldn’t want to see a situation where we could have partial initializers, but only when we move some properties into an extension.<br></p><p>I hope you agree.<br></p><p>-Matthew<br></p><p>&gt; <br>&gt; -David<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 14, 2016, at 8:08 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I have completed the second draft of my partial initializers proposal (the first really complete draft). <br>&gt;&gt; <br>&gt;&gt; This proposal also includes some discussion of memberwise initialization at John McCall’s request.  If anyone would like to continue discussing that topic informally I will be happy to do so, however any such discussion should happen on one of the existing memberwise initialization threads or on a new thread related to that topic.  Please do not let that section of the document be a distraction from the partial initializer proposal itself.<br>&gt;&gt; <br>&gt;&gt; The new draft can be found here:<br>&gt;&gt; <br>&gt;&gt; https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md &lt;https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md&gt;<br>&gt;&gt; <br>&gt;&gt; I really appreciate any feedback you have!<br>&gt;&gt; <br>&gt;&gt; -Matthew<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160118/3ec7df7e/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal] Partial initializers</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January 19, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; The only difference is that partial init can set `let` members, correct?<br></p><p>The other difference (unless I&#39;m wrong) is that an init function can be called again after initialization is complete. In other words, an `init func` is an actual method that can also be called during initialization; an `init &lt;name&gt;` is a sort of pseudo-method that can *only* be called during initialization.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Partial initializers</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 20, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jan 19, 2016, at 11:05 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; The only difference is that partial init can set `let` members, correct?<br>&gt; <br>&gt; The other difference (unless I&#39;m wrong) is that an init function can be called again after initialization is complete. In other words, an `init func` is an actual method that can also be called during initialization; an `init &lt;name&gt;` is a sort of pseudo-method that can *only* be called during initialization.<br></p><p>This is correct pretty much correct.  I don’t really think of `init &lt;name&gt;` as a pseudo-method but you could look at it that way.  Regardless of how you think of it, the current proposal suggests using `name.init()` syntax when calling either form during initialization.<br></p><p>I know you want to be able to reference previously initialized members in a partial initializer.  I still have an open mind about this, but want to see more community and core team input before I consider it further.<br></p><p>Aside from that, how do you like the changes in this draft in general?  <br></p><p>Matthew<br></p><p>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal] Partial initializers</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January 20, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; Aside from that, how do you like the changes in this draft in general?  <br></p><p>(I&#39;m also going to address some of Jordan Rose&#39;s comments here.)<br></p><p>I&#39;m afraid I still have objections to the basic syntax:<br></p><p>- I&#39;m not a big fan of the calling syntax. The name on the left of the dot looks like it ought to be a type or maybe an object, but it&#39;s neither. It&#39;s also not parallel to the declaration—you declare `init foo()`, but you call `foo.init()`.<br>- I don&#39;t like the fact that partial inits are distinguished from regular ones solely by whether or not they have a name. This is just not an obvious affordance.<br></p><p>I really think that both of these problems can be avoided by reimagining this feature as a way to make methods that can be called during initialization. That is:<br></p><p>	class Foo {<br>		var a, b: Int<br>		let now: NSDate<br>		<br>		init func resetValues(i: Int) {<br>			a = i * 2<br>			b = i * 4<br>		}<br>		<br>		init(only) func captureMoment() {<br>			now = NSDate()<br>		}<br></p><p>		init(i: Int) {<br>			captureMoment()<br>			resetValues(i)<br>		}<br>	}<br></p><p>An `init(only)` method can initialize constants, but cannot be called after phase one. It would not be possible to make the partial initialization aspect of these calls public; `resetValues(_:)` would look like a normal method, and `captureMoment()` would not appear at all.<br></p><p>Alternatively, we could have the `init` keyword always take a list of the properties that will be initialized. This avoids the body-scanning that Jordan complained about, but it would not make explicit which init methods aren&#39;t available after initialization—you&#39;d have to examine the property list and figure out which ones were constants. On the other hand, it at least theoretically permits the initializer aspect of the method to be made public, since the properties it initializes will be explicitly declared in the interface.<br></p><p>	class Foo {<br>		var a, b: Int<br>		let now: NSDate<br>		<br>		init(a, b) func resetValues(i: Int) {<br>			a = i * 2<br>			b = i * 4<br>		}<br>		<br>		init(now) func captureMoment() {<br>			now = NSDate()<br>		}<br></p><p>		init(i: Int) {<br>			captureMoment()<br>			resetValues(i)<br>		}<br>	}<br></p><p>One annoying thing about this syntax is that the property list in `init(foo)` looks like the parameter list in an initializer definition, but it actually means something totally different.<br></p><p>A third option here is to have a separate `initonly` keyword *and* require a declaration of initialized properties. This gives us the explicitness of `init(only)` and the in-declaration property list, but it&#39;s a bit ugly.<br></p><p>	class Foo {<br>		var a, b: Int<br>		let now: NSDate<br>		<br>		init(a, b) func resetValues(i: Int) {<br>			a = i * 2<br>			b = i * 4<br>		}<br>		<br>		initonly(now) func captureMoment() {<br>			now = NSDate()<br>		}<br></p><p>		init(i: Int) {<br>			captureMoment()<br>			resetValues(i)<br>		}<br>	}<br></p><p>Presumably you could omit the list of properties to write a side-effect-free helper method. This would have the same capabilities as the current static method approach, but with a more convenient calling syntax.<br></p><p>	class Foo {<br>		var a, b: Int<br>		<br>		private init func double(i: Int) -&gt; Int {<br>			return i * 2<br>		}<br>		<br>		init(a, b) func resetValues(i: Int) {<br>			a = double(i)<br>			b = double(double(i))<br>		}<br>		<br>		...<br>	}<br></p><p>As Jordan mentioned, overridability is a problem. I see two choices here:<br></p><p>1. Allow overriding, but don&#39;t call the override during phase one initialization.<br>2. Make `init` imply `final`.<br></p><p>#1 is kind of weird; #2 is very limiting. If we go with #1, we also have to decide if we want to allow `super` calls and how they should be handled during initialization, since they can&#39;t actually be executed. Perhaps they would be implicitly ignored, or you would have to make sure they weren&#39;t called on initialization using a special syntax:<br></p><p>	class Bar: Foo {<br>		var c: Int<br>		<br>		override init(c) func resetValues(i: Int) {<br>			if !init {<br>				super.resetValues(i)<br>			}<br>			c = i * 8<br>		}<br>		<br>		override init(i: Int) {<br>			resetValues(i)<br>			super.init(i: i)<br>		}<br>	}<br></p><p>(On the other hand, perhaps #1 is an argument for your `foo.init()` syntax—it looks like a different kind of call, so you might expect it to have different semantics like not calling the override.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Partial initializers</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 21, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jan 20, 2016, at 10:57 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; Aside from that, how do you like the changes in this draft in general?  <br>&gt; <br>&gt; (I&#39;m also going to address some of Jordan Rose&#39;s comments here.)<br>&gt; <br>&gt; I&#39;m afraid I still have objections to the basic syntax:<br></p><p>How strong are your objections?  Would you vote against this because of the syntax or is it merely a preference for something different?<br></p><p>&gt; <br>&gt; - I&#39;m not a big fan of the calling syntax. The name on the left of the dot looks like it ought to be a type or maybe an object, but it&#39;s neither. It&#39;s also not parallel to the declaration—you declare `init foo()`, but you call `foo.init()`.<br></p><p>The thing I like about this syntax is that it emphasizes that initialization is happening and that you are not just making a normal method call.  <br></p><p>I do think a reasonable argument can be made to just use normal method syntax.  I mention this in the proposal and am willing to use the syntax that most people like best.<br></p><p>&gt; - I don&#39;t like the fact that partial inits are distinguished from regular ones solely by whether or not they have a name. This is just not an obvious affordance.<br></p><p>That’s a fair opinion.  I will re-introduce the `partial` keyword if most people prefer that.  <br></p><p>I don’t think using `func` to declare something that writes to `let` properties is a good idea.  I very much prefer `init &lt;name&gt;()` or `partial init &lt;name&gt;()`.  <br></p><p>&gt; <br>&gt; I really think that both of these problems can be avoided by reimagining this feature as a way to make methods that can be called during initialization. That is:<br>&gt; <br>&gt; 	class Foo {<br>&gt; 		var a, b: Int<br>&gt; 		let now: NSDate<br>&gt; 		<br>&gt; 		init func resetValues(i: Int) {<br>&gt; 			a = i * 2<br>&gt; 			b = i * 4<br>&gt; 		}<br>&gt; 		<br>&gt; 		init(only) func captureMoment() {<br>&gt; 			now = NSDate()<br>&gt; 		}<br>&gt; <br>&gt; 		init(i: Int) {<br>&gt; 			captureMoment()<br>&gt; 			resetValues(i)<br>&gt; 		}<br>&gt; 	}<br>&gt; <br>&gt; An `init(only)` method can initialize constants, but cannot be called after phase one. It would not be possible to make the partial initialization aspect of these calls public; `resetValues(_:)` would look like a normal method, and `captureMoment()` would not appear at all.<br>&gt; <br>&gt; Alternatively, we could have the `init` keyword always take a list of the properties that will be initialized. This avoids the body-scanning that Jordan complained about, but it would not make explicit which init methods aren&#39;t available after initialization—you&#39;d have to examine the property list and figure out which ones were constants. On the other hand, it at least theoretically permits the initializer aspect of the method to be made public, since the properties it initializes will be explicitly declared in the interface.<br>&gt; <br>&gt; 	class Foo {<br>&gt; 		var a, b: Int<br>&gt; 		let now: NSDate<br>&gt; 		<br>&gt; 		init(a, b) func resetValues(i: Int) {<br>&gt; 			a = i * 2<br>&gt; 			b = i * 4<br>&gt; 		}<br>&gt; 		<br>&gt; 		init(now) func captureMoment() {<br>&gt; 			now = NSDate()<br>&gt; 		}<br>&gt; <br>&gt; 		init(i: Int) {<br>&gt; 			captureMoment()<br>&gt; 			resetValues(i)<br>&gt; 		}<br>&gt; 	}<br>&gt; <br>&gt; One annoying thing about this syntax is that the property list in `init(foo)` looks like the parameter list in an initializer definition, but it actually means something totally different.<br>&gt; <br>&gt; A third option here is to have a separate `initonly` keyword *and* require a declaration of initialized properties. This gives us the explicitness of `init(only)` and the in-declaration property list, but it&#39;s a bit ugly.<br>&gt; <br>&gt; 	class Foo {<br>&gt; 		var a, b: Int<br>&gt; 		let now: NSDate<br>&gt; 		<br>&gt; 		init(a, b) func resetValues(i: Int) {<br>&gt; 			a = i * 2<br>&gt; 			b = i * 4<br>&gt; 		}<br>&gt; 		<br>&gt; 		initonly(now) func captureMoment() {<br>&gt; 			now = NSDate()<br>&gt; 		}<br>&gt; <br>&gt; 		init(i: Int) {<br>&gt; 			captureMoment()<br>&gt; 			resetValues(i)<br>&gt; 		}<br>&gt; 	}<br>&gt; <br>&gt; Presumably you could omit the list of properties to write a side-effect-free helper method. This would have the same capabilities as the current static method approach, but with a more convenient calling syntax.<br>&gt; <br>&gt; 	class Foo {<br>&gt; 		var a, b: Int<br>&gt; 		<br>&gt; 		private init func double(i: Int) -&gt; Int {<br>&gt; 			return i * 2<br>&gt; 		}<br>&gt; 		<br>&gt; 		init(a, b) func resetValues(i: Int) {<br>&gt; 			a = double(i)<br>&gt; 			b = double(double(i))<br>&gt; 		}<br>&gt; 		<br>&gt; 		...<br>&gt; 	}<br>&gt; <br>&gt; As Jordan mentioned, overridability is a problem. I see two choices here:<br>&gt; <br>&gt; 1. Allow overriding, but don&#39;t call the override during phase one initialization.<br>&gt; 2. Make `init` imply `final`.<br></p><p>I think `init` *has* to imply `final`.  We cannot call a subclass method during phase 1, period.<br></p><p>&gt; <br>&gt; #1 is kind of weird; #2 is very limiting. If we go with #1, we also have to decide if we want to allow `super` calls and how they should be handled during initialization, since they can&#39;t actually be executed. Perhaps they would be implicitly ignored, or you would have to make sure they weren&#39;t called on initialization using a special syntax:<br>&gt; <br>&gt; 	class Bar: Foo {<br>&gt; 		var c: Int<br>&gt; 		<br>&gt; 		override init(c) func resetValues(i: Int) {<br>&gt; 			if !init {<br>&gt; 				super.resetValues(i)<br>&gt; 			}<br>&gt; 			c = i * 8<br>&gt; 		}<br>&gt; 		<br>&gt; 		override init(i: Int) {<br>&gt; 			resetValues(i)<br>&gt; 			super.init(i: i)<br>&gt; 		}<br>&gt; 	}<br>&gt; <br>&gt; (On the other hand, perhaps #1 is an argument for your `foo.init()` syntax—it looks like a different kind of call, so you might expect it to have different semantics like not calling the override.)<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Proposal] Partial initializers</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>January 20, 2016 at 06:00:00pm</p></header><div class="content"><p>Hm. Some comments:<br></p><p>&gt; This proposal does not introduce extensions with stored properties, however partial initialization is closely related to that topic. Class extensions with stored properties would be required to have an extension initializer. That extension initializer would effectively be treated as a partial initializer by designated initializers of the class. <br></p><p>I feel like most &quot;extensions with stored properties&quot; proposals have to cover extensions from another module, but maybe those properties are required to be lazy or something.<br></p><p><br>&gt; 3. Partial initializers and initialization methods may include an access control modifier specifying their visibility.<br></p><p>I&#39;m a little concerned about exposing these things publicly: there&#39;s no point if the struct or class has non-public fields (because new non-delegating initializers can&#39;t initialize the non-public fields), and by default every struct and class is allowed to add non-public fields in new versions of a library. (See the LibraryEvolution.rst doc for more info.) I can kind of see making these private vs. internal, but that has other issues (see below).<br></p><p>Even in the case where all fields are public and the struct promises not to change any fields, you&#39;d also have to promise that the partial initializer never changes which properties it&#39;s initializing; that&#39;s now part of the binary interface of the file. That&#39;s unusual for something that behaves like a function; usually the body is not part of the ABI.<br></p><p>I&#39;d much rather just ban &#39;public&#39; and never have partial inits be part of a library&#39;s public interface. Public initializer methods would be presented as plain methods, with no hint of their initializer origins.<br></p><p><br>&gt; 9. The compiler keeps track of the properties initialized by a partial initializer or initialization method and uses that knowledge when enforcing initialization rules in phase one in the calling initializer.<br></p><p>If a struct partial initializer is defined in another file, this would require reading the body of the initializer to determine what variables it initializes. We currently don&#39;t type-check any bodies outside of the primary source file when doing a normal, multi-process compilation.<br></p><p>You&#39;re missing a DI condition here in the sub-bullets, which is that the partial initializer must initialize its subset of stored properties on all paths.<br></p><p>&gt; 9 iv. A partial initializer or initialization method can only write to a property once, including var properties.<br></p><p>I&#39;m not sure why John thinks this would make things easier but I&#39;ll believe him. Seems like it&#39;d be the same as doing it in phase 1 of an initializer.<br></p><p>---<br></p><p>Can an initializer method be overridden? If so, I assume that does not override the &quot;initializer&quot; part, just the &quot;method&quot; part? If not, can we require the &#39;final&#39; to be explicit?<br></p><p>Can the method be marked @objc? &#39;dynamic&#39;? I would assume &quot;yes&quot;, because it&#39;s not really different from any other method, but I think it ought to be called out.<br></p><p>I don&#39;t personally like the call syntax but I don&#39;t immediately have anything better to offer. I do think that part of this proposal should include naming guidelines for these things.<br></p><p>What happens when you call an init method from phase 2 of initialization? Is that just illegal?<br></p><p>I&#39;m ultimately still not convinced that this is the right way to reduce initializer boilerplate (phase 1 duplication between initializers, or shared code between initializers and methods). It again adds complexity to the language, and that added complexity may not be worth the payoff. I&#39;m thinking about someone coming across the construct for the first time: would they understand what it was doing? Would they understand the error messages they would get?<br></p><p>(Specifically on that note: &quot;init func&quot; is probably okay because it&#39;s a special kind of func, but I think I would personally prefer to keep the &#39;partial&#39; keyword for partial inits, even though it&#39;s technically unnecessary.)<br></p><p>Sorry for the somewhat scattered thoughts. Hope it&#39;s helpful.<br>Jordan<br></p><p><br>&gt; On Jan 14, 2016, at 20:08, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I have completed the second draft of my partial initializers proposal (the first really complete draft). <br>&gt; <br>&gt; This proposal also includes some discussion of memberwise initialization at John McCall’s request.  If anyone would like to continue discussing that topic informally I will be happy to do so, however any such discussion should happen on one of the existing memberwise initialization threads or on a new thread related to that topic.  Please do not let that section of the document be a distraction from the partial initializer proposal itself.<br>&gt; <br>&gt; The new draft can be found here:<br>&gt; <br>&gt; https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md &lt;https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md&gt;<br>&gt; <br>&gt; I really appreciate any feedback you have!<br>&gt; <br>&gt; -Matthew<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160120/fe65dada/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>[Proposal] Partial initializers</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>January 20, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jan 20, 2016, at 6:48 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; 3. Partial initializers and initialization methods may include an access control modifier specifying their visibility.<br>&gt; <br>&gt; I&#39;m a little concerned about exposing these things publicly: there&#39;s no point if the struct or class has non-public fields (because new non-delegating initializers can&#39;t initialize the non-public fields), and by default every struct and class is allowed to add non-public fields in new versions of a library. (See the LibraryEvolution.rst doc for more info.) I can kind of see making these private vs. internal, but that has other issues (see below).<br>&gt; <br>&gt; Even in the case where all fields are public and the struct promises not to change any fields, you&#39;d also have to promise that the partial initializer never changes which properties it&#39;s initializing; that&#39;s now part of the binary interface of the file. That&#39;s unusual for something that behaves like a function; usually the body is not part of the ABI.<br>&gt; <br>&gt; I&#39;d much rather just ban &#39;public&#39; and never have partial inits be part of a library&#39;s public interface. Public initializer methods would be presented as plain methods, with no hint of their initializer origins.<br>&gt; <br>&gt; <br>&gt;&gt; 9. The compiler keeps track of the properties initialized by a partial initializer or initialization method and uses that knowledge when enforcing initialization rules in phase one in the calling initializer.<br>&gt; <br>&gt; If a struct partial initializer is defined in another file, this would require reading the body of the initializer to determine what variables it initializes. We currently don&#39;t type-check any bodies outside of the primary source file when doing a normal, multi-process compilation.<br>&gt; <br>&gt; You&#39;re missing a DI condition here in the sub-bullets, which is that the partial initializer must initialize its subset of stored properties on all paths.<br></p><p>I believe you can already factor out common code in initializers by defining @_transparent functions. Would it be more worthwhile to improve @_transparent by fixing the known limitations instead?<br></p><p>&gt; <br>&gt; What happens when you call an init method from phase 2 of initialization? Is that just illegal?<br></p><p>Note that @_transparent functions can be called in phase 1 or phase 2 — DI figures out which sets are initialization stores, and which ones release the old value.<br></p><p>&gt; <br>&gt; I&#39;m ultimately still not convinced that this is the right way to reduce initializer boilerplate (phase 1 duplication between initializers, or shared code between initializers and methods). It again adds complexity to the language, and that added complexity may not be worth the payoff. I&#39;m thinking about someone coming across the construct for the first time: would they understand what it was doing? Would they understand the error messages they would get?<br>&gt; <br>&gt; (Specifically on that note: &quot;init func&quot; is probably okay because it&#39;s a special kind of func, but I think I would personally prefer to keep the &#39;partial&#39; keyword for partial inits, even though it&#39;s technically unnecessary.)<br>&gt; <br>&gt; Sorry for the somewhat scattered thoughts. Hope it&#39;s helpful.<br>&gt; Jordan<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 14, 2016, at 20:08, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I have completed the second draft of my partial initializers proposal (the first really complete draft). <br>&gt;&gt; <br>&gt;&gt; This proposal also includes some discussion of memberwise initialization at John McCall’s request.  If anyone would like to continue discussing that topic informally I will be happy to do so, however any such discussion should happen on one of the existing memberwise initialization threads or on a new thread related to that topic.  Please do not let that section of the document be a distraction from the partial initializer proposal itself.<br>&gt;&gt; <br>&gt;&gt; The new draft can be found here:<br>&gt;&gt; <br>&gt;&gt; https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md &lt;https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md&gt;<br>&gt;&gt; <br>&gt;&gt; I really appreciate any feedback you have!<br>&gt;&gt; <br>&gt;&gt; -Matthew<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160120/464ae550/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>[Proposal] Partial initializers</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>January 20, 2016 at 08:00:00pm</p></header><div class="content"><p>Adding more details…<br></p><p>&gt; On Jan 20, 2016, at 8:46 PM, Slava Pestov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; I&#39;m a little concerned about exposing these things publicly: there&#39;s no point if the struct or class has non-public fields (because new non-delegating initializers can&#39;t initialize the non-public fields), and by default every struct and class is allowed to add non-public fields in new versions of a library. (See the LibraryEvolution.rst doc for more info.) I can kind of see making these private vs. internal, but that has other issues (see below).<br>&gt;&gt; <br>&gt;&gt; Even in the case where all fields are public and the struct promises not to change any fields, you&#39;d also have to promise that the partial initializer never changes which properties it&#39;s initializing; that&#39;s now part of the binary interface of the file. That&#39;s unusual for something that behaves like a function; usually the body is not part of the ABI.<br>&gt;&gt; <br>&gt;&gt; I&#39;d much rather just ban &#39;public&#39; and never have partial inits be part of a library&#39;s public interface. Public initializer methods would be presented as plain methods, with no hint of their initializer origins.<br></p><p>If we just go with @_transparent functions for partial initialization, there are no new rules to add regarding ABI resilience. :-)<br></p><p>&gt;&gt; I&#39;m ultimately still not convinced that this is the right way to reduce initializer boilerplate (phase 1 duplication between initializers, or shared code between initializers and methods). It again adds complexity to the language, and that added complexity may not be worth the payoff.<br></p><p>This is really my main concern with the proposal.<br></p><p>Also I would suggest that the part regarding argument forwarding could probably be split off and discussed separately — I think this has applicability outside of initializers.<br></p><p>Slava<br></p><p>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 14, 2016, at 20:08, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I have completed the second draft of my partial initializers proposal (the first really complete draft). <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This proposal also includes some discussion of memberwise initialization at John McCall’s request.  If anyone would like to continue discussing that topic informally I will be happy to do so, however any such discussion should happen on one of the existing memberwise initialization threads or on a new thread related to that topic.  Please do not let that section of the document be a distraction from the partial initializer proposal itself.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The new draft can be found here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md &lt;https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I really appreciate any feedback you have!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160120/fa43b016/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal] Partial initializers</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 21, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jan 20, 2016, at 8:51 PM, Slava Pestov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Adding more details…<br>&gt; <br>&gt;&gt; On Jan 20, 2016, at 8:46 PM, Slava Pestov via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; I&#39;m a little concerned about exposing these things publicly: there&#39;s no point if the struct or class has non-public fields (because new non-delegating initializers can&#39;t initialize the non-public fields), and by default every struct and class is allowed to add non-public fields in new versions of a library. (See the LibraryEvolution.rst doc for more info.) I can kind of see making these private vs. internal, but that has other issues (see below).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Even in the case where all fields are public and the struct promises not to change any fields, you&#39;d also have to promise that the partial initializer never changes which properties it&#39;s initializing; that&#39;s now part of the binary interface of the file. That&#39;s unusual for something that behaves like a function; usually the body is not part of the ABI.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;d much rather just ban &#39;public&#39; and never have partial inits be part of a library&#39;s public interface. Public initializer methods would be presented as plain methods, with no hint of their initializer origins.<br>&gt; <br>&gt; If we just go with @_transparent functions for partial initialization, there are no new rules to add regarding ABI resilience. :-)<br></p><p>Ignoring the fact that @_transparent isn’t a user feature, I don’t see how this helps.  Mandatory inlining of @_transparent happens after DI runs.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160121/64ba1b67/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>[Proposal] Partial initializers</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>January 21, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jan 21, 2016, at 9:13 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 20, 2016, at 8:51 PM, Slava Pestov via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Adding more details…<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 20, 2016, at 8:46 PM, Slava Pestov via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m a little concerned about exposing these things publicly: there&#39;s no point if the struct or class has non-public fields (because new non-delegating initializers can&#39;t initialize the non-public fields), and by default every struct and class is allowed to add non-public fields in new versions of a library. (See the LibraryEvolution.rst doc for more info.) I can kind of see making these private vs. internal, but that has other issues (see below).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Even in the case where all fields are public and the struct promises not to change any fields, you&#39;d also have to promise that the partial initializer never changes which properties it&#39;s initializing; that&#39;s now part of the binary interface of the file. That&#39;s unusual for something that behaves like a function; usually the body is not part of the ABI.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;d much rather just ban &#39;public&#39; and never have partial inits be part of a library&#39;s public interface. Public initializer methods would be presented as plain methods, with no hint of their initializer origins.<br>&gt;&gt; <br>&gt;&gt; If we just go with @_transparent functions for partial initialization, there are no new rules to add regarding ABI resilience. :-)<br>&gt; <br>&gt; Ignoring the fact that @_transparent isn’t a user feature, I don’t see how this helps.  Mandatory inlining of @_transparent happens after DI runs.<br></p><p>I’m of the opinion that making it a user feature and running inlining before DI would solve the ‘partial initializers’ use-case. :-)<br></p><p>&gt; <br>&gt; -Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160121/c39ed7e8/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal] Partial initializers</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 21, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jan 21, 2016, at 9:13 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 20, 2016, at 8:51 PM, Slava Pestov via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Adding more details…<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 20, 2016, at 8:46 PM, Slava Pestov via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m a little concerned about exposing these things publicly: there&#39;s no point if the struct or class has non-public fields (because new non-delegating initializers can&#39;t initialize the non-public fields), and by default every struct and class is allowed to add non-public fields in new versions of a library. (See the LibraryEvolution.rst doc for more info.) I can kind of see making these private vs. internal, but that has other issues (see below).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Even in the case where all fields are public and the struct promises not to change any fields, you&#39;d also have to promise that the partial initializer never changes which properties it&#39;s initializing; that&#39;s now part of the binary interface of the file. That&#39;s unusual for something that behaves like a function; usually the body is not part of the ABI.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;d much rather just ban &#39;public&#39; and never have partial inits be part of a library&#39;s public interface. Public initializer methods would be presented as plain methods, with no hint of their initializer origins.<br>&gt;&gt; <br>&gt;&gt; If we just go with @_transparent functions for partial initialization, there are no new rules to add regarding ABI resilience. :-)<br>&gt; <br>&gt; Ignoring the fact that @_transparent isn’t a user feature, I don’t see how this helps.  Mandatory inlining of @_transparent happens after DI runs.<br></p><p>Sorry, I didn’t see that Jordan brought this up down-thread: He’s exactly right.  We don’t *want* mandatory inlining to run before DI (it used to, and it was a mess).  Doing that just makes the DI model more complex and less predictable for users.<br></p><p>I’m not sold on the notion of partial initializers in the first place, but if we were to go down this path, the approach of nailing down the exact initialization behavior and requirements of the partial initializer - and making it part of its explicitly declared interface - is the right way to go.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160121/21e841b3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>[Proposal] Partial initializers</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>January 21, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jan 21, 2016, at 9:16 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 21, 2016, at 9:13 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 20, 2016, at 8:51 PM, Slava Pestov via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Adding more details…<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 20, 2016, at 8:46 PM, Slava Pestov via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;m a little concerned about exposing these things publicly: there&#39;s no point if the struct or class has non-public fields (because new non-delegating initializers can&#39;t initialize the non-public fields), and by default every struct and class is allowed to add non-public fields in new versions of a library. (See the LibraryEvolution.rst doc for more info.) I can kind of see making these private vs. internal, but that has other issues (see below).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Even in the case where all fields are public and the struct promises not to change any fields, you&#39;d also have to promise that the partial initializer never changes which properties it&#39;s initializing; that&#39;s now part of the binary interface of the file. That&#39;s unusual for something that behaves like a function; usually the body is not part of the ABI.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;d much rather just ban &#39;public&#39; and never have partial inits be part of a library&#39;s public interface. Public initializer methods would be presented as plain methods, with no hint of their initializer origins.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If we just go with @_transparent functions for partial initialization, there are no new rules to add regarding ABI resilience. :-)<br>&gt;&gt; <br>&gt;&gt; Ignoring the fact that @_transparent isn’t a user feature, I don’t see how this helps.  Mandatory inlining of @_transparent happens after DI runs.<br>&gt; <br>&gt; Sorry, I didn’t see that Jordan brought this up down-thread: He’s exactly right.  We don’t *want* mandatory inlining to run before DI (it used to, and it was a mess).<br></p><p>Ah, I didn’t know that it was already tried and rejected. I guess @_transparent is the wrong thing to hang this off of, then.<br></p><p>&gt; I’m not sold on the notion of partial initializers in the first place, but if we were to go down this path, the approach of nailing down the exact initialization behavior and requirements of the partial initializer - and making it part of its explicitly declared interface - is the right way to go.<br></p><p>Fair enough. I’m also worried about the prospect of adding even more complexity — and syntax — to Swift’s initializer model. My hope is that we can map this to existing language features somehow, or combine this with some other simplification of the initializer model so that the net complexity gain is not too high. But since I don’t have any concrete suggestions at this point, I’ll stay quiet for a while ;-)<br></p><p>Slava<br></p><p><br>&gt; <br>&gt; -Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160121/1c98bec8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal] Partial initializers</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 21, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jan 21, 2016, at 9:20 PM, Slava Pestov &lt;spestov at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; I’m not sold on the notion of partial initializers in the first place, but if we were to go down this path, the approach of nailing down the exact initialization behavior and requirements of the partial initializer - and making it part of its explicitly declared interface - is the right way to go.<br>&gt; <br>&gt; Fair enough. I’m also worried about the prospect of adding even more complexity — and syntax — to Swift’s initializer model. My hope is that we can map this to existing language features somehow, or combine this with some other simplification of the initializer model so that the net complexity gain is not too high. But since I don’t have any concrete suggestions at this point, I’ll stay quiet for a while ;-)<br></p><p>Macro system? :-)<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160121/032dee08/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Proposal] Partial initializers</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>January 21, 2016 at 10:00:00pm</p></header><div class="content"><p>I feel like &quot;macro system&quot; is probably the right way to approach features<br>whose purpose is to help developers not write boilerplate.<br></p><p>I know we have a philosophy that warns us to not allow the idea of macro<br>system to become a crutch that precludes us designing features well. I<br>think the opposite also applies - if there&#39;s something that&#39;s a good fit<br>for a macro system, it probably makes sense to defer it rather than trying<br>to add it in as language syntax and features that can&#39;t pay for themselves<br>in terms of complexity.<br></p><p>Best,<br>Austin<br></p><p><br>On Thu, Jan 21, 2016 at 9:48 PM, Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Jan 21, 2016, at 9:20 PM, Slava Pestov &lt;spestov at apple.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; I’m not sold on the notion of partial initializers in the first place, but<br>&gt; if we were to go down this path, the approach of nailing down the exact<br>&gt; initialization behavior and requirements of the partial initializer - and<br>&gt; making it part of its explicitly declared interface - is the right way to<br>&gt; go.<br>&gt;<br>&gt;<br>&gt; Fair enough. I’m also worried about the prospect of adding even more<br>&gt; complexity — and syntax — to Swift’s initializer model. My hope is that we<br>&gt; can map this to existing language features somehow, or combine this with<br>&gt; some other simplification of the initializer model so that the net<br>&gt; complexity gain is not too high. But since I don’t have any concrete<br>&gt; suggestions at this point, I’ll stay quiet for a while ;-)<br>&gt;<br>&gt;<br>&gt; Macro system? :-)<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160121/4b80848d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>[Proposal] Partial initializers</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>January 28, 2016 at 08:00:00am</p></header><div class="content"><p>I love macro systems but I think most of the pain comes from poor compiler support.<br></p><p>Even if we had some sort of template system  like c++ baked into swift for doing this boiler plate I think it would be great<br></p><p>Sent from my iPhone<br></p><p>&gt; On 22 Jan 2016, at 06:01, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I feel like &quot;macro system&quot; is probably the right way to approach features whose purpose is to help developers not write boilerplate.<br>&gt; <br>&gt; I know we have a philosophy that warns us to not allow the idea of macro system to become a crutch that precludes us designing features well. I think the opposite also applies - if there&#39;s something that&#39;s a good fit for a macro system, it probably makes sense to defer it rather than trying to add it in as language syntax and features that can&#39;t pay for themselves in terms of complexity.<br>&gt; <br>&gt; Best,<br>&gt; Austin<br>&gt;  <br>&gt; <br>&gt;&gt; On Thu, Jan 21, 2016 at 9:48 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 21, 2016, at 9:20 PM, Slava Pestov &lt;spestov at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m not sold on the notion of partial initializers in the first place, but if we were to go down this path, the approach of nailing down the exact initialization behavior and requirements of the partial initializer - and making it part of its explicitly declared interface - is the right way to go.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Fair enough. I’m also worried about the prospect of adding even more complexity — and syntax — to Swift’s initializer model. My hope is that we can map this to existing language features somehow, or combine this with some other simplification of the initializer model so that the net complexity gain is not too high. But since I don’t have any concrete suggestions at this point, I’ll stay quiet for a while ;-)<br>&gt;&gt; <br>&gt;&gt; Macro system? :-)<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/f0bf8243/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Proposal] Partial initializers</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>January 20, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jan 20, 2016, at 20:46 , Slava Pestov &lt;spestov at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 20, 2016, at 6:48 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; 3. Partial initializers and initialization methods may include an access control modifier specifying their visibility.<br>&gt;&gt; <br>&gt;&gt; I&#39;m a little concerned about exposing these things publicly: there&#39;s no point if the struct or class has non-public fields (because new non-delegating initializers can&#39;t initialize the non-public fields), and by default every struct and class is allowed to add non-public fields in new versions of a library. (See the LibraryEvolution.rst doc for more info.) I can kind of see making these private vs. internal, but that has other issues (see below).<br>&gt;&gt; <br>&gt;&gt; Even in the case where all fields are public and the struct promises not to change any fields, you&#39;d also have to promise that the partial initializer never changes which properties it&#39;s initializing; that&#39;s now part of the binary interface of the file. That&#39;s unusual for something that behaves like a function; usually the body is not part of the ABI.<br>&gt;&gt; <br>&gt;&gt; I&#39;d much rather just ban &#39;public&#39; and never have partial inits be part of a library&#39;s public interface. Public initializer methods would be presented as plain methods, with no hint of their initializer origins.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; 9. The compiler keeps track of the properties initialized by a partial initializer or initialization method and uses that knowledge when enforcing initialization rules in phase one in the calling initializer.<br>&gt;&gt; <br>&gt;&gt; If a struct partial initializer is defined in another file, this would require reading the body of the initializer to determine what variables it initializes. We currently don&#39;t type-check any bodies outside of the primary source file when doing a normal, multi-process compilation.<br>&gt;&gt; <br>&gt;&gt; You&#39;re missing a DI condition here in the sub-bullets, which is that the partial initializer must initialize its subset of stored properties on all paths.<br>&gt; <br>&gt; I believe you can already factor out common code in initializers by defining @_transparent functions. Would it be more worthwhile to improve @_transparent by fixing the known limitations instead?<br></p><p>IIRC mandatory inlining runs after DI. I think Chris didn&#39;t want cases where the DI looked wrong but was correct because the called function happened to be inlined—there&#39;s no indication at the call site of this.<br></p><p>We also wouldn&#39;t want the other semantics of transparent &lt;https://github.com/apple/swift/blob/master/docs/TransparentAttr.rst&gt;: no debug info, and restrictions on what can be mentioned if it&#39;s marked public.<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160120/a2ea92c2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>[Proposal] Partial initializers</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>January 20, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jan 20, 2016, at 8:55 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br></p><p>&gt; IIRC mandatory inlining runs after DI. I think Chris didn&#39;t want cases where the DI looked wrong but was correct because the called function happened to be inlined—there&#39;s no indication at the call site of this.<br></p><p>I don’t think that’s a huge problem though. When we emit a diagnostic about an uninitialized value or use, we could also emit a series of ‘inlined from here’ notes.<br></p><p>&gt; <br>&gt; We also wouldn&#39;t want the other semantics of transparent &lt;https://github.com/apple/swift/blob/master/docs/TransparentAttr.rst&gt;: no debug info,<br></p><p>That sounds unfortunate. Why is debug info with transparent functions any more of an issue than debug info for stuff inlined by the optimizer passes? I’m assuming we emit debug info for the latter.<br></p><p>&gt; and restrictions on what can be mentioned if it&#39;s marked public.<br>&gt; <br></p><p>Arguably, public partial inits only make sense for @_fixed_layout structs anyway :-)<br></p><p>&gt; Jordan<br></p><p>Slava<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160120/df33f8cb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Proposal] Partial initializers</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>January 21, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Jan 20, 2016, at 21:10 , Slava Pestov &lt;spestov at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 20, 2016, at 8:55 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; IIRC mandatory inlining runs after DI. I think Chris didn&#39;t want cases where the DI looked wrong but was correct because the called function happened to be inlined—there&#39;s no indication at the call site of this.<br>&gt; <br>&gt; I don’t think that’s a huge problem though. When we emit a diagnostic about an uninitialized value or use, we could also emit a series of ‘inlined from here’ notes.<br></p><p>I think it&#39;s the other way around: when everything is correct, a new reader will look at the code and say &quot;wait, why are you allowed to pass this inout here?&quot; That applies less to partial initializers, though, which do have some syntax called out. We&#39;d have to check with Chris to be sure, though, since it was a deliberate change at some point in the project&#39;s life.<br></p><p>(It&#39;s also possible there&#39;s a pass ordering problem where we use DI to determine what can be promoted to the stack, or something like that. I&#39;m not too familiar with the mandatory passes.)<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; We also wouldn&#39;t want the other semantics of transparent &lt;https://github.com/apple/swift/blob/master/docs/TransparentAttr.rst&gt;: no debug info,<br>&gt; <br>&gt; That sounds unfortunate. Why is debug info with transparent functions any more of an issue than debug info for stuff inlined by the optimizer passes? I’m assuming we emit debug info for the latter.<br></p><p>No, you&#39;ve got it backwards. This is a feature of transparent. Nobody wants to step into +.<br></p><p>Now, we could break that feature out into a separate attribute, but then there&#39;s nothing &quot;transparent&quot; anymore. It&#39;s just &quot;inline very early while we still have source locations to do diagnostics&quot;.<br></p><p>Obviously, forced inlining can also hurt code size.<br></p><p><br>&gt; <br>&gt;&gt; and restrictions on what can be mentioned if it&#39;s marked public.<br>&gt;&gt; <br>&gt; <br>&gt; Arguably, public partial inits only make sense for @_fixed_layout structs anyway :-)<br></p><p>But it affects initializer methods, which are just normal methods otherwise.<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160121/29bf5be9/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Partial initializers</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 21, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jan 20, 2016, at 11:10 PM, Slava Pestov &lt;spestov at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 20, 2016, at 8:55 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; IIRC mandatory inlining runs after DI. I think Chris didn&#39;t want cases where the DI looked wrong but was correct because the called function happened to be inlined—there&#39;s no indication at the call site of this.<br>&gt; <br>&gt; I don’t think that’s a huge problem though. When we emit a diagnostic about an uninitialized value or use, we could also emit a series of ‘inlined from here’ notes.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; We also wouldn&#39;t want the other semantics of transparent &lt;https://github.com/apple/swift/blob/master/docs/TransparentAttr.rst&gt;: no debug info,<br>&gt; <br>&gt; That sounds unfortunate. Why is debug info with transparent functions any more of an issue than debug info for stuff inlined by the optimizer passes? I’m assuming we emit debug info for the latter.<br>&gt; <br>&gt;&gt; and restrictions on what can be mentioned if it&#39;s marked public.<br>&gt;&gt; <br>&gt; <br>&gt; Arguably, public partial inits only make sense for @_fixed_layout structs anyway :-)<br></p><p>I don’t understand that comment.  What is the argument that they only make sense for @_fixed_layout structs?  It feels like a generally useful feature to me.<br></p><p>&gt; <br>&gt;&gt; Jordan<br>&gt; <br>&gt; Slava<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160121/b012ff45/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>[Proposal] Partial initializers</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>January 21, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jan 21, 2016, at 11:44 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 20, 2016, at 11:10 PM, Slava Pestov &lt;spestov at apple.com &lt;mailto:spestov at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 20, 2016, at 8:55 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; IIRC mandatory inlining runs after DI. I think Chris didn&#39;t want cases where the DI looked wrong but was correct because the called function happened to be inlined—there&#39;s no indication at the call site of this.<br>&gt;&gt; <br>&gt;&gt; I don’t think that’s a huge problem though. When we emit a diagnostic about an uninitialized value or use, we could also emit a series of ‘inlined from here’ notes.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We also wouldn&#39;t want the other semantics of transparent &lt;https://github.com/apple/swift/blob/master/docs/TransparentAttr.rst&gt;: no debug info,<br>&gt;&gt; <br>&gt;&gt; That sounds unfortunate. Why is debug info with transparent functions any more of an issue than debug info for stuff inlined by the optimizer passes? I’m assuming we emit debug info for the latter.<br>&gt;&gt; <br>&gt;&gt;&gt; and restrictions on what can be mentioned if it&#39;s marked public.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Arguably, public partial inits only make sense for @_fixed_layout structs anyway :-)<br>&gt; <br>&gt; I don’t understand that comment.  What is the argument that they only make sense for @_fixed_layout structs?  It feels like a generally useful feature to me.<br></p><p>It seems partial initializers leak out what the stored properties of a type are to callers. Resiliently adding stored properties or changing stored properties into computed properties seems like it might cause difficulties for existing code that makes use of partial initializers. It is not clear to me what the guidelines would be for evolving partial initializers.<br></p><p>If this doesn’t make sense to you, take a look at Jordan’s docs/LibraryEvolution.rst — but also keep in mind that outside of system frameworks, all value types are implicitly @_fixed_layout.<br></p><p>Slava<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt; Slava<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160121/6e5e078b/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Partial initializers</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 21, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jan 20, 2016, at 8:48 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; Hm. Some comments:<br></p><p>Thanks for providing lots of feedback!<br></p><p>&gt; <br>&gt;&gt; This proposal does not introduce extensions with stored properties, however partial initialization is closely related to that topic. Class extensions with stored properties would be required to have an extension initializer. That extension initializer would effectively be treated as a partial initializer by designated initializers of the class. <br>&gt; <br>&gt; I feel like most &quot;extensions with stored properties&quot; proposals have to cover extensions from another module, but maybe those properties are required to be lazy or something.<br>&gt; <br>&gt; <br>&gt;&gt; 3. Partial initializers and initialization methods may include an access control modifier specifying their visibility.<br>&gt; <br>&gt; I&#39;m a little concerned about exposing these things publicly: there&#39;s no point if the struct or class has non-public fields (because new non-delegating initializers can&#39;t initialize the non-public fields), and by default every struct and class is allowed to add non-public fields in new versions of a library. (See the LibraryEvolution.rst doc for more info.) I can kind of see making these private vs. internal, but that has other issues (see below).<br>&gt; <br>&gt; Even in the case where all fields are public and the struct promises not to change any fields, you&#39;d also have to promise that the partial initializer never changes which properties it&#39;s initializing; that&#39;s now part of the binary interface of the file. That&#39;s unusual for something that behaves like a function; usually the body is not part of the ABI.<br>&gt; <br>&gt; I&#39;d much rather just ban &#39;public&#39; and never have partial inits be part of a library&#39;s public interface. Public initializer methods would be presented as plain methods, with no hint of their initializer origins.<br></p><p>I have no problem with banning `public`partial inits and only exposing the ordinary method aspect of `public` initializer methods.  Unless this is controversial on the core team I will make this change.<br></p><p>&gt; <br>&gt; <br>&gt;&gt; 9. The compiler keeps track of the properties initialized by a partial initializer or initialization method and uses that knowledge when enforcing initialization rules in phase one in the calling initializer.<br>&gt; <br>&gt; If a struct partial initializer is defined in another file, this would require reading the body of the initializer to determine what variables it initializes. We currently don&#39;t type-check any bodies outside of the primary source file when doing a normal, multi-process compilation.<br></p><p>Are you recommending a same-file requirement?  I wouldn’t have a problem with that.  I’m trying to keep this proposal as focused as possible and will make any changes necessary to address implementation considerations.<br></p><p>&gt; <br>&gt; You&#39;re missing a DI condition here in the sub-bullets, which is that the partial initializer must initialize its subset of stored properties on all paths.<br></p><p>Agree.  I left that implicit but will call it out explicitly.<br></p><p>&gt; <br>&gt;&gt; 9 iv. A partial initializer or initialization method can only write to a property once, including var properties.<br>&gt; <br>&gt; I&#39;m not sure why John thinks this would make things easier but I&#39;ll believe him. Seems like it&#39;d be the same as doing it in phase 1 of an initializer.<br></p><p>I may have misinterpreted John’s comment.  I’m guessing it had to do with releasing the old value if it was set prior to calling the partial init like you mentioned in the other thread.  Hopefully he can clarify.<br></p><p>&gt; <br>&gt; ---<br>&gt; <br>&gt; Can an initializer method be overridden? If so, I assume that does not override the &quot;initializer&quot; part, just the &quot;method&quot; part? If not, can we require the &#39;final&#39; to be explicit?<br></p><p>Good question.  I was thinking of them as implicitly `final` but didn’t call that out.  If you think they should be explicitly marked `final` I will make that change.<br></p><p>&gt; <br>&gt; Can the method be marked @objc? &#39;dynamic&#39;? I would assume &quot;yes&quot;, because it&#39;s not really different from any other method, but I think it ought to be called out.<br></p><p>I suppose so if that doesn’t create any implementation challenges around the initializer aspect.<br></p><p>&gt; <br>&gt; I don&#39;t personally like the call syntax but I don&#39;t immediately have anything better to offer. I do think that part of this proposal should include naming guidelines for these things.<br></p><p>I don’t love it but don’t have a better idea either.  It’s a good candidate for bike shedding and we might be able to find something better.<br></p><p>What do you have in mind in terms of naming guidelines?  I can imagine UI classes having partial inits like “appearanceProperties” and “animationProperties”, etc.  Those names wouldn’t be good for an initializer method though.<br></p><p>&gt; What happens when you call an init method from phase 2 of initialization? Is that just illegal?<br></p><p>Good question.  I should have addressed this.  Partial initializers should not be callable during phase 2.<br></p><p>It probably make senses to allow initializer methods to be called during phase 2 using the usual method syntax just like any other method.  What do others think?<br></p><p>&gt; <br>&gt; I&#39;m ultimately still not convinced that this is the right way to reduce initializer boilerplate (phase 1 duplication between initializers, or shared code between initializers and methods). It again adds complexity to the language, and that added complexity may not be worth the payoff. I&#39;m thinking about someone coming across the construct for the first time: would they understand what it was doing? Would they understand the error messages they would get?<br></p><p>What I like about this approach is that it is a general tool for factoring initialization code using techniques similar to those we use in other code.  Lots of people do similar things in Objective-C, but in an obviously unsafe way.  This would help ease their migration to Swift while helping them do this safely.<br></p><p>I think the best way to think about the added complexity is to consider the *incremental* complexity and benefit over Swift’s initialization model.  I think it is a pretty modest change to understand for those who already understand the existing rules while providing substantial benefit in some cases.<br></p><p>&gt; <br>&gt; (Specifically on that note: &quot;init func&quot; is probably okay because it&#39;s a special kind of func, but I think I would personally prefer to keep the &#39;partial&#39; keyword for partial inits, even though it&#39;s technically unnecessary.)<br></p><p>I would be happy with whatever syntax the core team thinks is best.  I like keeping it more concise but don’t mind `partial` if others like that better.<br></p><p>It’s just hard to tell what that is with several people involved.  Any recommendations on how to handle this when writing a proposal? <br></p><p>&gt; <br>&gt; Sorry for the somewhat scattered thoughts. Hope it&#39;s helpful.<br></p><p>Absolutely.  I really appreciate your feedback!<br></p><p>-Matthew<br></p><p>&gt; Jordan<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 14, 2016, at 20:08, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I have completed the second draft of my partial initializers proposal (the first really complete draft). <br>&gt;&gt; <br>&gt;&gt; This proposal also includes some discussion of memberwise initialization at John McCall’s request.  If anyone would like to continue discussing that topic informally I will be happy to do so, however any such discussion should happen on one of the existing memberwise initialization threads or on a new thread related to that topic.  Please do not let that section of the document be a distraction from the partial initializer proposal itself.<br>&gt;&gt; <br>&gt;&gt; The new draft can be found here:<br>&gt;&gt; <br>&gt;&gt; https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md &lt;https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md&gt;<br>&gt;&gt; <br>&gt;&gt; I really appreciate any feedback you have!<br>&gt;&gt; <br>&gt;&gt; -Matthew<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160121/d1c0fad6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Proposal] Partial initializers</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>January 22, 2016 at 11:00:00am</p></header><div class="content"><p>&gt;&gt;&gt; 9. The compiler keeps track of the properties initialized by a partial initializer or initialization method and uses that knowledge when enforcing initialization rules in phase one in the calling initializer.<br>&gt;&gt; <br>&gt;&gt; If a struct partial initializer is defined in another file, this would require reading the body of the initializer to determine what variables it initializes. We currently don&#39;t type-check any bodies outside of the primary source file when doing a normal, multi-process compilation.<br>&gt; <br>&gt; Are you recommending a same-file requirement?  I wouldn’t have a problem with that.  I’m trying to keep this proposal as focused as possible and will make any changes necessary to address implementation considerations.<br></p><p>That would be one way to solve this, but that&#39;s kind of at odds with your direction of &quot;partial initializers for stored properties in extensions&quot;. There&#39;s also a circularity problem, where type-checking one partial init requires looking at the body of another, which mistakenly calls the first, but we can probably handle that error.<br></p><p>The other way that comes to mind would be to explicitly declare what&#39;s being initialized, as Brent (and others?) mentioned. That&#39;s certainly not as concise but it does fix the problem. I don&#39;t think it counts as a leak of information about stored properties as long as partial inits are never exposed publicly.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; Can an initializer method be overridden? If so, I assume that does not override the &quot;initializer&quot; part, just the &quot;method&quot; part? If not, can we require the &#39;final&#39; to be explicit?<br>&gt; <br>&gt; Good question.  I was thinking of them as implicitly `final` but didn’t call that out.  If you think they should be explicitly marked `final` I will make that change.<br></p><p>Well, I think it&#39;s a good idea. Others may disagree. It could also be required only for public init methods, because private and internal ones don&#39;t make an API contract.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; Can the method be marked @objc? &#39;dynamic&#39;? I would assume &quot;yes&quot;, because it&#39;s not really different from any other method, but I think it ought to be called out.<br>&gt; <br>&gt; I suppose so if that doesn’t create any implementation challenges around the initializer aspect.<br></p><p>Yeah, they wouldn&#39;t apply to the initializer, only the method. I don&#39;t know if that&#39;s weird enough to forbid &#39;dynamic&#39;, but it seems benign for &#39;@objc&#39;. (AFAICT the effects of &#39;@objc&#39; are only observable after phase 1 completes anyway.)<br></p><p>&gt;&gt; <br>&gt;&gt; I don&#39;t personally like the call syntax but I don&#39;t immediately have anything better to offer. I do think that part of this proposal should include naming guidelines for these things.<br>&gt; <br>&gt; I don’t love it but don’t have a better idea either.  It’s a good candidate for bike shedding and we might be able to find something better.<br>&gt; <br>&gt; What do you have in mind in terms of naming guidelines?  I can imagine UI classes having partial inits like “appearanceProperties” and “animationProperties”, etc.  Those names wouldn’t be good for an initializer method though.<br></p><p>I think that does give us a place to start: initializer methods are named like methods but invoked in some special way. Maybe partial inits are named as methods as well. (Maybe we just drop partial inits to make everything simpler, and only have init methods. They can get dead-code-stripped if they&#39;re only used as partial inits.)<br></p><p><br>&gt; <br>&gt;&gt; What happens when you call an init method from phase 2 of initialization? Is that just illegal?<br>&gt; <br>&gt; Good question.  I should have addressed this.  Partial initializers should not be callable during phase 2.<br>&gt; <br>&gt; It probably make senses to allow initializer methods to be called during phase 2 using the usual method syntax just like any other method.  What do others think?<br></p><p>I&#39;m inclined to agree.<br></p><p><br>&gt; <br>&gt;&gt; <br>&gt;&gt; I&#39;m ultimately still not convinced that this is the right way to reduce initializer boilerplate (phase 1 duplication between initializers, or shared code between initializers and methods). It again adds complexity to the language, and that added complexity may not be worth the payoff. I&#39;m thinking about someone coming across the construct for the first time: would they understand what it was doing? Would they understand the error messages they would get?<br>&gt; <br>&gt; What I like about this approach is that it is a general tool for factoring initialization code using techniques similar to those we use in other code.  Lots of people do similar things in Objective-C, but in an obviously unsafe way.  This would help ease their migration to Swift while helping them do this safely.<br></p><p>I do like the idea of &quot;you can factor out code to helper methods, but initialization code is special, so you factor it out to special kinds of methods&quot;.<br></p><p><br>&gt; <br>&gt; I think the best way to think about the added complexity is to consider the *incremental* complexity and benefit over Swift’s initialization model.  I think it is a pretty modest change to understand for those who already understand the existing rules while providing substantial benefit in some cases.<br></p><p>Heh. I don&#39;t think Swift&#39;s initialization model is exactly the part of the language we want to strive to emulate (even if all its corners are necessary in some sense). This feature doesn&#39;t interact much with most of the complexity there except the phase 1 / phase 2 part.<br></p><p><br>&gt; <br>&gt;&gt; <br>&gt;&gt; (Specifically on that note: &quot;init func&quot; is probably okay because it&#39;s a special kind of func, but I think I would personally prefer to keep the &#39;partial&#39; keyword for partial inits, even though it&#39;s technically unnecessary.)<br>&gt; <br>&gt; I would be happy with whatever syntax the core team thinks is best.  I like keeping it more concise but don’t mind `partial` if others like that better.<br>&gt; <br>&gt; It’s just hard to tell what that is with several people involved.  Any recommendations on how to handle this when writing a proposal? <br></p><p>I don&#39;t think you&#39;d know for real until it got to review. This list is high enough traffic that there are probably a lot of people who don&#39;t read the drafts, including members of the core team. :-/<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/e7e8713e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Partial initializers</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 25, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jan 22, 2016, at 1:12 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt;&gt; 9. The compiler keeps track of the properties initialized by a partial initializer or initialization method and uses that knowledge when enforcing initialization rules in phase one in the calling initializer.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If a struct partial initializer is defined in another file, this would require reading the body of the initializer to determine what variables it initializes. We currently don&#39;t type-check any bodies outside of the primary source file when doing a normal, multi-process compilation.<br>&gt;&gt; <br>&gt;&gt; Are you recommending a same-file requirement?  I wouldn’t have a problem with that.  I’m trying to keep this proposal as focused as possible and will make any changes necessary to address implementation considerations.<br>&gt; <br>&gt; That would be one way to solve this, but that&#39;s kind of at odds with your direction of &quot;partial initializers for stored properties in extensions”.<br></p><p>I included that discussion at John’s request.  He also mentioned that they wouldn’t necessarily share the same implementation even though they are conceptually similar.  I don’t think it needs to influence this proposal to the degree that we would exclude that option.  <br></p><p>I think a same-file requirement would be a reasonable place to start if the alternative is explicit declaration.<br></p><p>&gt; There&#39;s also a circularity problem, where type-checking one partial init requires looking at the body of another, which mistakenly calls the first, but we can probably handle that error.<br></p><p>If partial inits calling other partial inits significantly increases complexity I could remove that from the initial proposal.  I don’t think it’s an essential feature.<br></p><p>&gt; <br>&gt; The other way that comes to mind would be to explicitly declare what&#39;s being initialized, as Brent (and others?) mentioned. That&#39;s certainly not as concise but it does fix the problem.<br></p><p>I don’t like the idea of requiring this to be declared too much.  If we had “self.x” syntax and any “self.x” parameters implicitly declared the initialization of their corresponding property maybe it would be tolerable as would only need to explicitly declare properties set manually.<br></p><p>&gt; I don&#39;t think it counts as a leak of information about stored properties as long as partial inits are never exposed publicly.<br></p><p>Agree. <br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Can an initializer method be overridden? If so, I assume that does not override the &quot;initializer&quot; part, just the &quot;method&quot; part? If not, can we require the &#39;final&#39; to be explicit?<br>&gt;&gt; <br>&gt;&gt; Good question.  I was thinking of them as implicitly `final` but didn’t call that out.  If you think they should be explicitly marked `final` I will make that change.<br>&gt; <br>&gt; Well, I think it&#39;s a good idea. Others may disagree. It could also be required only for public init methods, because private and internal ones don&#39;t make an API contract.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Can the method be marked @objc? &#39;dynamic&#39;? I would assume &quot;yes&quot;, because it&#39;s not really different from any other method, but I think it ought to be called out.<br>&gt;&gt; <br>&gt;&gt; I suppose so if that doesn’t create any implementation challenges around the initializer aspect.<br>&gt; <br>&gt; Yeah, they wouldn&#39;t apply to the initializer, only the method. I don&#39;t know if that&#39;s weird enough to forbid &#39;dynamic&#39;, but it seems benign for &#39;@objc&#39;. (AFAICT the effects of &#39;@objc&#39; are only observable after phase 1 completes anyway.)<br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t personally like the call syntax but I don&#39;t immediately have anything better to offer. I do think that part of this proposal should include naming guidelines for these things.<br>&gt;&gt; <br>&gt;&gt; I don’t love it but don’t have a better idea either.  It’s a good candidate for bike shedding and we might be able to find something better.<br>&gt;&gt; <br>&gt;&gt; What do you have in mind in terms of naming guidelines?  I can imagine UI classes having partial inits like “appearanceProperties” and “animationProperties”, etc.  Those names wouldn’t be good for an initializer method though.<br>&gt; <br>&gt; I think that does give us a place to start: initializer methods are named like methods but invoked in some special way. Maybe partial inits are named as methods as well. (Maybe we just drop partial inits to make everything simpler, and only have init methods. They can get dead-code-stripped if they&#39;re only used as partial inits.)<br></p><p>If we drop partial inits how would you recommend factoring out initialization logic that touches `let` properties?  It seems wrong to allow that in an init method.  The only way to support both `let` initialization *and* post-initialization calls is with two kinds of constructs.  They could share the same syntax, but that seems confusing to me.  That is why I included both of them in the proposal. <br></p><p>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; What happens when you call an init method from phase 2 of initialization? Is that just illegal?<br>&gt;&gt; <br>&gt;&gt; Good question.  I should have addressed this.  Partial initializers should not be callable during phase 2.<br>&gt;&gt; <br>&gt;&gt; It probably make senses to allow initializer methods to be called during phase 2 using the usual method syntax just like any other method.  What do others think?<br>&gt; <br>&gt; I&#39;m inclined to agree.<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m ultimately still not convinced that this is the right way to reduce initializer boilerplate (phase 1 duplication between initializers, or shared code between initializers and methods). It again adds complexity to the language, and that added complexity may not be worth the payoff. I&#39;m thinking about someone coming across the construct for the first time: would they understand what it was doing? Would they understand the error messages they would get?<br>&gt;&gt; <br>&gt;&gt; What I like about this approach is that it is a general tool for factoring initialization code using techniques similar to those we use in other code.  Lots of people do similar things in Objective-C, but in an obviously unsafe way.  This would help ease their migration to Swift while helping them do this safely.<br>&gt; <br>&gt; I do like the idea of &quot;you can factor out code to helper methods, but initialization code is special, so you factor it out to special kinds of methods&quot;.<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; I think the best way to think about the added complexity is to consider the *incremental* complexity and benefit over Swift’s initialization model.  I think it is a pretty modest change to understand for those who already understand the existing rules while providing substantial benefit in some cases.<br>&gt; <br>&gt; Heh. I don&#39;t think Swift&#39;s initialization model is exactly the part of the language we want to strive to emulate (even if all its corners are necessary in some sense). This feature doesn&#39;t interact much with most of the complexity there except the phase 1 / phase 2 part.<br></p><p>I didn’t meant this in terms of striving to emulate the initialization model.  Just that the feature is intricately related to DI and is wouldn’t be necessary without the phase 1 restrictions.  I think of it as a small enhancement to the init capabilities that provides a lot more benefit than it introduces complexity, especially considering how complex the init model already is.<br></p><p>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (Specifically on that note: &quot;init func&quot; is probably okay because it&#39;s a special kind of func, but I think I would personally prefer to keep the &#39;partial&#39; keyword for partial inits, even though it&#39;s technically unnecessary.)<br>&gt;&gt; <br>&gt;&gt; I would be happy with whatever syntax the core team thinks is best.  I like keeping it more concise but don’t mind `partial` if others like that better.<br>&gt;&gt; <br>&gt;&gt; It’s just hard to tell what that is with several people involved.  Any recommendations on how to handle this when writing a proposal? <br>&gt; <br>&gt; I don&#39;t think you&#39;d know for real until it got to review. This list is high enough traffic that there are probably a lot of people who don&#39;t read the drafts, including members of the core team. :-/<br></p><p>Sure.  But it might be nice to be able to write a proposal “modulo syntax”.  We need placeholder syntax of course, but in many cases it might be best to allow that to be hashed out during review with the core team deciding on the final details if the proposal is accepted.  There have been several cases where this seems like an appropriate way to handle things.  What do you think?<br></p><p>-Matthew<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160125/3d477195/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Proposal] Partial initializers</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>January 27, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt;&gt;&gt; It’s just hard to tell what that is with several people involved.  Any recommendations on how to handle this when writing a proposal? <br>&gt;&gt; <br>&gt;&gt; I don&#39;t think you&#39;d know for real until it got to review. This list is high enough traffic that there are probably a lot of people who don&#39;t read the drafts, including members of the core team. :-/<br>&gt; <br>&gt; Sure.  But it might be nice to be able to write a proposal “modulo syntax”.  We need placeholder syntax of course, but in many cases it might be best to allow that to be hashed out during review with the core team deciding on the final details if the proposal is accepted.  There have been several cases where this seems like an appropriate way to handle things.  What do you think?<br></p><p>I like to use the worst syntax I can think of that&#39;s still immediately clear: ☃ for operators, @precise_ugly_name for attributes, etc. :-)<br></p><p>Jordan<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
