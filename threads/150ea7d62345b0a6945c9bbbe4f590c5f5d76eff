<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9247a8ae6f8e90514ede1df8a837307b?s=50"></div><header><strong>Advanced type system for preventing data races.</strong> from <string>Nickolas Pohilets</string> &lt;pohilets at gmail.com&gt;<p>December 26, 2015 at 01:00:00am</p></header><div class="content"><p>Hello, swift-evolution<br></p><p>This is a big feature, and I don&#39;t expect it to get into Swift 3.0, even<br>though it may require ABI changes. But still, I find it important enough to<br>put it on the table for discussion.<br></p><p>Code examples below are quite sketchy - just some Swift-like pseudocode to<br>express the idea, rather then an actual proposal of changes to the language<br>syntax.<br></p><p>Basic idea is to associate each variable with a lock that guards it though<br>a mechanism of lock names. Variable can be read only if associated lock is<br>held for reading or writing. Variable can be written only if associated<br>lock is held for writing. Locks are mutexes, read-write locks and also<br>special locks that cover cases of thread-contained variables and immutable<br>data.<br></p><p>class Foo&lt;Lk : LockName&gt; {<br>    var bar under Lk : Int = 0<br>}<br></p><p>func add&lt;DstLk : LockName, SrcLk : LockName&gt;(dst : Foo&lt;DstLk&gt;, src :<br>Foo&lt;SrcLk&gt;, srcMutex : ReadWriteLock&lt;SrcLk&gt;) write DstLk {<br>    // Held locks: [(write DstLk)]<br>    dst.bar += src.bar // Error: cannot read src.bar because SrcLk is not<br>held<br>    sync read srcMutex {<br>        // Held locks: [(write DstLk), (read SrcLk)]<br>        dst.bar += src.bar // Ok<br>    }<br>    // Held locks: [(write DstLk)]<br>}<br></p><p>Lock names are generic parameters of classes and functions and kinds are<br>used to distinguish between type parameters and lock name parameters.<br>Ideally lock names should not require witness tables or any other runtime<br>otherhead, but there are few open questions related to dynamic downcasting.<br></p><p>Function signature includes lock requirements - in the example above,<br>function add() can be called only if lock DstLk is known to be held for<br>writing at the call site.<br>For every statement inside the function, compiler tracks a set of locks<br>currently being held. Initially this set is initialized with lock<br>requirements, and sync statement adds one more lock to this set for the<br>scope of it&#39;s body.<br></p><p>Constructing new locks returns a dependent tuple:<br></p><p>func newMutex() -&gt; (L : LockName, Mutex&lt;L&gt;)<br></p><p>Unpacking that tuple allows to create objects protected by newly created<br>mutex:<br></p><p>let (Lk, m) = newMutex()<br>let f = Foo&lt;Lk&gt;()<br></p><p>Lock names can be assigned only to constants. Each call of the newMutex()<br>returns distinct lock name. If two generic types contain lock names and<br>compiler cannot prove that these lock names are equal, then such types are<br>considered to be distinct:<br></p><p>let (Lk1, m1) = newMutex()<br>let f1 = Foo&lt;Lk1&gt;()<br>let (Lk2, m2) = newMutex()<br>let f2 = Foo&lt;Lk2&gt;()<br>let Lk3 : LockName = Lk1<br>var f3 : Foo&lt;Lk3&gt; = f1 // Ok, Lk3 == Lk1 =&gt; Foo&lt;Lk3&gt; == Foo&lt;Lk1&gt;<br>f3 = f2 // Error, Lk3 != Lk2 =&gt; Foo&lt;Lk3&gt; != Foo&lt;Lk2&gt;<br></p><p>Fields of structs and enums are always protected by the same lock that<br>protects the entire struct/enum and that lock is not a part of a variable<br>type, but rather an attribute of a variable itself. Classes may use<br>different locks to protect their fields.<br></p><p>There is a special kind of lock names - ThreadName, a subkind of LockName.<br>Each function has at least one lock name of kind ThreadName for which it<br>requires write access. This is a special lock name used for<br>thread-contained objects. There is no mutex and any other real lock<br>associated with this name, but write access is granted at thread entry<br>point. Function main() has signature:<br></p><p>func main&lt;ThreadLk : LockName&gt;() write ThreadLk<br></p><p>And API for creating a new thread takes a first-class generic function of<br>type:<br></p><p>typealias ThreadFunc = &lt;ThreadLk : LockName&gt;() write ThreadLk -&gt; Void<br></p><p>If there is no explicit lock name of this kind for which write access is<br>requested, that implicit generic argument called ThisThread is added to the<br>function:<br></p><p>func main() ==&gt; func main&lt;ThisThread : ThreadName&gt;() write ThreadName<br></p><p>If there is one, then ThisThread is defined as an alias to that argument.<br></p><p>func main&lt;ThreadLk : LockName&gt;() write ThreadLk { ... }<br>==&gt;<br>func main&lt;ThreadLk : LockName&gt;() write ThreadLk {<br>let ThisThread = ThreadLk<br>    ...<br>}<br></p><p>If there are multiple such locks, then all them are considered equal.<br></p><p>Inside the closure, there is also a ThisThread lock name, which shadows the<br>definition of the ThisThread from the parent scope. These ThisThread&#39;s are<br>not equal.<br></p><p>A small demo of the described above:<br></p><p>class RunLoop&lt;Lk : ThreadLock&gt; {<br>    typealias BlockType = () write Lk -&gt; Void<br>    let MutexLock : LockName<br>    let mutex : Mutex&lt;MutexLock&gt;<br>    let cond : WaitCondition&lt;MutexLock&gt;<br>    var queue under MutexLock : [BlockType]<br>    var stopped under MutexLock : Bool = false<br></p><p>    init() {<br>        // Lock is not required to be held to initialize a variable<br>        (MutexLock, mutex) = newMutex()<br>        cond = WaitCondition&lt;MutexLock&gt;()<br>    }<br></p><p>    func run() write Lk {<br>        while let block = takeBlock() {<br>            block();<br>        }<br>    }<br></p><p>    func stop() {<br>        sync write mutex {<br>            stopped = true<br>        }<br>    }<br></p><p>    func enqueue(block : BlockType) { // No lock requirements - can be<br>called from any thread<br>        sync write mutex {<br>            queue += [block]<br>            cond.signal()<br>        }<br>    }<br></p><p>    func takeBlock() -&gt; BlockType? {<br>        sync write mutex {<br>            while (queue.isEmpty) {<br>                if stopped {<br>                    return nil<br>                }<br>                cond.wait()<br>            }<br>            let retVal = queue[0]<br>            queue.removeAtIndex(0)<br>            return retVal<br>        }<br>    }<br>}<br></p><p><br>/// Thread-local variable<br>thread var _currentRunLoop : RunLoop&lt;ThisThread&gt;? = nil<br></p><p>func currentRunLoop() -&gt; RunLoop&lt;ThisThread&gt; {<br>    if let loop = _currentRunLoop {<br>        return loop<br>    } else {<br>        let loop = RunLoop&lt;ThisThread&gt;()<br>        _currentRunLoop = loop<br>        return loop<br>    }<br>}<br></p><p>struct Rect {<br>    var x : Int<br>    var y : Int<br>    var width : Int<br>    var height : Int<br>}<br></p><p>class View&lt;Lk : LockName&gt; {<br>    var frame under Lk : Rect<br>    var subviews under Lk : [View&lt;Lk&gt;]<br>}<br></p><p>func foo(subviews : [View&lt;ThisThread&gt;]) {}<br></p><p>func main() -&gt; Void {<br>    let loop = currentRunLoop()<br>    let view = View&lt;ThisThread&gt;()<br>    let Lk : ThreadName = ThisThread<br>    spawn({ // Starts new thread<br>        var sum = 0<br>        for x in 1..&lt;1000 {<br>            sum += x<br>        }<br>        loop.enqueue({<br>            () write Lk in<br>            view.frame.x = sum<br>            foo(view.subviews)<br>        })<br>    })<br>    loop.run()<br>}<br></p><p>Immutable variables can be protected by the special lock name constant -<br>Immutable. Read lock for this lock name is always implicitly assumed to be<br>held. But write lock cannot be acquired, because it is not possible to<br>create a mutex or read-write lock associated with this name.<br></p><p>Atomic types are classes whose methods don&#39;t have any lock requirements,<br>and thus can be called from any thread. They are reference types, because<br>identity is important for atomic variables.<br></p><p>Described type system is based on this paper -<br>https://homes.cs.washington.edu/~djg/papers/cycthreads.pdf, with some<br>modifications:<br>* Lock name for the current thread is not a constant, but an argument to<br>every function. So, sharabilities are not needed. Also sharabilities<br>prevent passing references to thread-local objects to other threads without<br>dereferencing them - this is a very common thing for callbacks accessing UI<br>objects.<br>* Read and Write locks are distinguished, and Immutable lock is added<br></p><p>There are some known limitations:<br>1. Lock-less migration between threads is not supported<br></p><p>class Foo {<br>    var x : Int = 0<br>    fun inc() { x += 1 }<br>}<br></p><p>func main() {<br>    let f = Foo()<br>    f.inc()<br>    let t = spawn({<br>       f.inc()<br>    })<br>    t.join()<br>    f.inc()<br>}<br></p><p>Either lock needs to be added, or deep copy should be made.<br></p><p>2. Mutation after initialization is not supported:<br></p><p>class Foo&lt;L : LockName&gt; {<br>    var bar under L : Int<br></p><p>    init(x : Int) {<br>        self.bar = x<br>        self.bar += 1 &lt;— ERROR<br>    }<br>}<br></p><p>Either calculations need to be done in local variables before<br>initialization, or lock requirement needs to be added.<br></p><p>3. And the most disturbing one - is subclass has lock names not mentioned<br>into base class or protocol, then dynamic downcast is a problem:<br></p><p>class Foo&lt;A : LockName&gt; {<br>}<br></p><p>class Bar&lt;A : LockName, B : LockName&gt; : Foo&lt;A&gt; {<br>    func update() write B { … }<br>}<br></p><p>func process&lt;Lk : LockName&gt;(foo : Foo&lt;Lk&gt;) {<br>    if let bar = foo as? Bar&lt;Lk, ThisThread&gt; {<br>        bar.update()<br>    }<br>}<br></p><p>This can be implemented by storing lock names in runtime and actually<br>checking them during the cast, but this seems to me to be too expensive.<br></p><p>Alternatives are:<br>- Forbidding such downcasts<br>- using existential subcasting:<br></p><p>class Foo&lt;A : LockName&gt; {<br>}<br></p><p>class Bar&lt;A : LockName, B : LockName&gt; : Foo&lt;A&gt; {<br>    func update() write A { … }<br>}<br></p><p>func process&lt;Lk : LockName&gt;(foo : Foo&lt;Lk&gt;) {<br>    if let (bar, B_Lk) = foo as? Bar&lt;Lk, _&gt; {<br>        bar.update() &lt;— ERROR<br>    }<br>}<br></p><p>But usefulness of obtained lock name is doubtful - it can be used only if<br>associated lock is stored inside the object itself.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151226/150e6eff/attachment.html&gt;<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
