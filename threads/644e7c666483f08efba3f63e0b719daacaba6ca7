<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Pitch] Making some RawRepresentable things bridge to ObjC as their raw value</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>September 29, 2016 at 10:00:00am</p></header><div class="content"><p>In the discussion around SE-0139 (bridging NSNumber and NSValue), many people pointed out that it&#39;s common in ObjC to use NSNumbers holding enum constants in Cocoa containers. Many ObjC interfaces look something like this:<br></p><p>	/// A washing machine.<br>	@interface QXWashingMachine<br></p><p>	/// Wash cycles supported by the washing machine.<br>	typedef NS_ENUM(NSInteger, QXWashCycle) {<br>	  QXWashNormal,<br>	  QXWashDelicates,<br>	  QXWashLinens,<br>	};<br></p><p>	/// Perform a sequence of wash cycles. Takes an NSArray of QXWashCycle constants passed<br>	/// as NSNumbers.<br>	- (void)performWashCycles:(NSArray *)cycles;<br></p><p>	@end<br></p><p>In ObjC, you can call this API like this:<br></p><p>	[washingMachine performWashCycles:@[<br>	  @(QXWashLinens),<br>	  @(QXWashDelicates),<br>	]];<br></p><p>In Swift 3, the equivalent code will compile, but fail at runtime, because the enum type falls back to opaque object bridging instead of using NSNumbers:<br></p><p>	// Fails at runtime, because WashCycle constants don&#39;t implicitly bridge to NSNumber<br>	washingMachine.perform(washCycles: [WashCycle.linens, WashCycle.delicates])<br></p><p>so you have to know to get the `rawValue`s out first:<br></p><p>	// Fails at runtime, because WashCycle constants don&#39;t implicitly bridge to NSNumber<br>	washingMachine.perform(washCycles: [WashCycle.linens.rawValue, WashCycle.delicates.rawValue])<br></p><p>We encountered similar problems last year as we developed the `swift_newtype` ObjC feature last year, which enabled us to import some stringly-typed ObjC APIs with stronger types in Swift. A type like `Notification.Name`, which represents a set of NSString constants, is imported to be RawRepresentable as String and also to bridge to Objective-C as one, by having the compiler implicitly generate a conformance to the internal _ObjectiveCBridgeable protocol for it. We could conceivably do one of the following things:<br></p><p>- Have the compiler generate a bridging conformance for imported NS_ENUM and NS_OPTIONS types, and perhaps also for @objc enums defined in Swift, like we do for newtypes.<br>- Alternatively, we could say that *anything* with a RawRepresentable conformance bridges to ObjC as its rawValue.<br></p><p>The second one is conceptually appealing to me, since RawRepresentable is already something newtypes, enums, and option sets have in common in Swift, but I think it may be too lax—it would effectively make RawRepresentable the user interface to Objective-C bridging, which I&#39;m not sure is something we want. Limiting the bridging behavior to @objc enums and imported option sets limits the impact, though there are still tradeoffs to consider:<br></p><p>- Adding any new bridging behavior has the potential to break existing code that relies on the current opaque object bridging. We tell people not to do that, of course, but that&#39;s no guarantee that people don&#39;t.<br>- As with newtypes, the bridged Objective-C representation loses type information from Swift, meaning that dynamic casts potentially need to become &quot;slushier&quot;. Swift maintains the distinction between Notification.Name and String, for example, but once a value of either type has been bridged to NSString, the distinction is lost, so we have to allow casts from NSString back to either String or Notification.Name. If we bridge enums and option sets, we would similarly lose type information once we go to NSNumber. We can in some cases mitigate this for class clusters like NSString or NSNumber by using our own subclasses that preserve type info, which can at least preserve type info for Swift-bridged objects, though we can&#39;t do this universally for all Cocoa-sourced objects.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76eb9711d45c1c9a71c0f24004072a22?s=50"></div><header><strong>[Pitch] Making some RawRepresentable things bridge to ObjC as their raw value</strong> from <string>Zach Waldowski</string> &lt;zach at waldowski.me&gt;<p>September 29, 2016 at 11:00:00am</p></header><div class="content"><p>I think limiting to types that are both @objc and RawRepresentable is a<br>nice compromise; that limits the type preservation needed to work around<br>&quot;slushiness&quot; to NSString, NSNumber (already done), and NSError.<br></p><p>I know your pitch doesn&#39;t cover this problem, but I would also note that<br>C varargs suffer from the same &quot;needing to know to get the rawValue&quot;<br>problem.<br></p><p>Sincerely,<br>  Zachary Waldowski<br>  zach at waldowski.me<br></p><p>On Thu, Sep 29, 2016, at 10:16 AM, Joe Groff via swift-evolution wrote:<br>&gt; In the discussion around SE-0139 (bridging NSNumber and NSValue), many<br>&gt; people pointed out that it&#39;s common in ObjC to use NSNumbers holding enum<br>&gt; constants in Cocoa containers. Many ObjC interfaces look something like<br>&gt; this:<br>&gt; <br>&gt; 	/// A washing machine.<br>&gt; 	@interface QXWashingMachine<br>&gt; <br>&gt; 	/// Wash cycles supported by the washing machine.<br>&gt; 	typedef NS_ENUM(NSInteger, QXWashCycle) {<br>&gt; 	  QXWashNormal,<br>&gt; 	  QXWashDelicates,<br>&gt; 	  QXWashLinens,<br>&gt; 	};<br>&gt; <br>&gt; 	/// Perform a sequence of wash cycles. Takes an NSArray of QXWashCycle constants passed<br>&gt; 	/// as NSNumbers.<br>&gt; 	- (void)performWashCycles:(NSArray *)cycles;<br>&gt; <br>&gt; 	@end<br>&gt; <br>&gt; In ObjC, you can call this API like this:<br>&gt; <br>&gt; 	[washingMachine performWashCycles:@[<br>&gt; 	  @(QXWashLinens),<br>&gt; 	  @(QXWashDelicates),<br>&gt; 	]];<br>&gt; <br>&gt; In Swift 3, the equivalent code will compile, but fail at runtime,<br>&gt; because the enum type falls back to opaque object bridging instead of<br>&gt; using NSNumbers:<br>&gt; <br>&gt; 	// Fails at runtime, because WashCycle constants don&#39;t implicitly bridge to NSNumber<br>&gt; 	washingMachine.perform(washCycles: [WashCycle.linens, WashCycle.delicates])<br>&gt; <br>&gt; so you have to know to get the `rawValue`s out first:<br>&gt; <br>&gt; 	// Fails at runtime, because WashCycle constants don&#39;t implicitly bridge to NSNumber<br>&gt; 	washingMachine.perform(washCycles: [WashCycle.linens.rawValue, WashCycle.delicates.rawValue])<br>&gt; <br>&gt; We encountered similar problems last year as we developed the<br>&gt; `swift_newtype` ObjC feature last year, which enabled us to import some<br>&gt; stringly-typed ObjC APIs with stronger types in Swift. A type like<br>&gt; `Notification.Name`, which represents a set of NSString constants, is<br>&gt; imported to be RawRepresentable as String and also to bridge to<br>&gt; Objective-C as one, by having the compiler implicitly generate a<br>&gt; conformance to the internal _ObjectiveCBridgeable protocol for it. We<br>&gt; could conceivably do one of the following things:<br>&gt; <br>&gt; - Have the compiler generate a bridging conformance for imported NS_ENUM<br>&gt; and NS_OPTIONS types, and perhaps also for @objc enums defined in Swift,<br>&gt; like we do for newtypes.<br>&gt; - Alternatively, we could say that *anything* with a RawRepresentable<br>&gt; conformance bridges to ObjC as its rawValue.<br>&gt; <br>&gt; The second one is conceptually appealing to me, since RawRepresentable is<br>&gt; already something newtypes, enums, and option sets have in common in<br>&gt; Swift, but I think it may be too lax—it would effectively make<br>&gt; RawRepresentable the user interface to Objective-C bridging, which I&#39;m<br>&gt; not sure is something we want. Limiting the bridging behavior to @objc<br>&gt; enums and imported option sets limits the impact, though there are still<br>&gt; tradeoffs to consider:<br>&gt; <br>&gt; - Adding any new bridging behavior has the potential to break existing<br>&gt; code that relies on the current opaque object bridging. We tell people<br>&gt; not to do that, of course, but that&#39;s no guarantee that people don&#39;t.<br>&gt; - As with newtypes, the bridged Objective-C representation loses type<br>&gt; information from Swift, meaning that dynamic casts potentially need to<br>&gt; become &quot;slushier&quot;. Swift maintains the distinction between<br>&gt; Notification.Name and String, for example, but once a value of either<br>&gt; type has been bridged to NSString, the distinction is lost, so we have to<br>&gt; allow casts from NSString back to either String or Notification.Name. If<br>&gt; we bridge enums and option sets, we would similarly lose type information<br>&gt; once we go to NSNumber. We can in some cases mitigate this for class<br>&gt; clusters like NSString or NSNumber by using our own subclasses that<br>&gt; preserve type info, which can at least preserve type info for<br>&gt; Swift-bridged objects, though we can&#39;t do this universally for all<br>&gt; Cocoa-sourced objects.<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Pitch] Making some RawRepresentable things bridge to ObjC as their raw value</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>September 29, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Sep 29, 2016, at 10:16 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; In the discussion around SE-0139 (bridging NSNumber and NSValue), many people pointed out that it&#39;s common in ObjC to use NSNumbers holding enum constants in Cocoa containers. Many ObjC interfaces look something like this:<br>&gt; <br>&gt; 	/// A washing machine.<br>&gt; 	@interface QXWashingMachine<br>&gt; <br>&gt; 	/// Wash cycles supported by the washing machine.<br>&gt; 	typedef NS_ENUM(NSInteger, QXWashCycle) {<br>&gt; 	  QXWashNormal,<br>&gt; 	  QXWashDelicates,<br>&gt; 	  QXWashLinens,<br>&gt; 	};<br>&gt; <br>&gt; 	/// Perform a sequence of wash cycles. Takes an NSArray of QXWashCycle constants passed<br>&gt; 	/// as NSNumbers.<br>&gt; 	- (void)performWashCycles:(NSArray *)cycles;<br>&gt; <br>&gt; 	@end<br>&gt; <br>&gt; In ObjC, you can call this API like this:<br>&gt; <br>&gt; 	[washingMachine performWashCycles:@[<br>&gt; 	  @(QXWashLinens),<br>&gt; 	  @(QXWashDelicates),<br>&gt; 	]];<br>&gt; <br>&gt; In Swift 3, the equivalent code will compile, but fail at runtime, because the enum type falls back to opaque object bridging instead of using NSNumbers:<br>&gt; <br>&gt; 	// Fails at runtime, because WashCycle constants don&#39;t implicitly bridge to NSNumber<br>&gt; 	washingMachine.perform(washCycles: [WashCycle.linens, WashCycle.delicates])<br>&gt; <br>&gt; so you have to know to get the `rawValue`s out first:<br>&gt; <br>&gt; 	// Fails at runtime, because WashCycle constants don&#39;t implicitly bridge to NSNumber<br>&gt; 	washingMachine.perform(washCycles: [WashCycle.linens.rawValue, WashCycle.delicates.rawValue])<br>&gt; <br>&gt; We encountered similar problems last year as we developed the `swift_newtype` ObjC feature last year, which enabled us to import some stringly-typed ObjC APIs with stronger types in Swift. A type like `Notification.Name`, which represents a set of NSString constants, is imported to be RawRepresentable as String and also to bridge to Objective-C as one, by having the compiler implicitly generate a conformance to the internal _ObjectiveCBridgeable protocol for it. We could conceivably do one of the following things:<br>&gt; <br>&gt; - Have the compiler generate a bridging conformance for imported NS_ENUM and NS_OPTIONS types, and perhaps also for @objc enums defined in Swift, like we do for newtypes.<br>&gt; - Alternatively, we could say that *anything* with a RawRepresentable conformance bridges to ObjC as its rawValue.<br>&gt; <br>&gt; The second one is conceptually appealing to me, since RawRepresentable is already something newtypes, enums, and option sets have in common in Swift, but I think it may be too lax—it would effectively make RawRepresentable the user interface to Objective-C bridging, which I&#39;m not sure is something we want. Limiting the bridging behavior to @objc enums and imported option sets limits the impact, though there are still tradeoffs to consider:<br>&gt; <br>&gt; - Adding any new bridging behavior has the potential to break existing code that relies on the current opaque object bridging. We tell people not to do that, of course, but that&#39;s no guarantee that people don&#39;t.<br>&gt; - As with newtypes, the bridged Objective-C representation loses type information from Swift, meaning that dynamic casts potentially need to become &quot;slushier&quot;. Swift maintains the distinction between Notification.Name and String, for example, but once a value of either type has been bridged to NSString, the distinction is lost, so we have to allow casts from NSString back to either String or Notification.Name. If we bridge enums and option sets, we would similarly lose type information once we go to NSNumber. We can in some cases mitigate this for class clusters like NSString or NSNumber by using our own subclasses that preserve type info, which can at least preserve type info for Swift-bridged objects, though we can&#39;t do this universally for all Cocoa-sourced objects.<br></p><p><br>Personally, I consider the first one to be a fairly-low-risk extension to SE-0139 that’s borderline bug-fix. We already know that those types have weak numeric representations in Objective-C because they come from Objective-C, so losing some of the type info by bridging to Objective-C is (IMO) falls out of having strong types in Swift for weaker types in Objective-C.<br></p><p>The second one makes me a little nervous, I think because it weakens typing for types defined in Swift. These types don’t naturally have Objective-C counterparts, so if we’re going to weaken the types, it feels like we should only do so via some explicit conformance (e.g., to a publicly-available form of _ObjectiveCBridgeable).<br></p><p>	- Doug<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>[Pitch] Making some RawRepresentable things bridge to ObjC as their raw value</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>September 30, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Sep 29, 2016, at 11:45 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; Personally, I consider the first one to be a fairly-low-risk extension to SE-0139 that’s borderline bug-fix. We already know that those types have weak numeric representations in Objective-C because they come from Objective-C, so losing some of the type info by bridging to Objective-C is (IMO) falls out of having strong types in Swift for weaker types in Objective-C.<br>&gt; <br>&gt; The second one makes me a little nervous, I think because it weakens typing for types defined in Swift. These types don’t naturally have Objective-C counterparts, so if we’re going to weaken the types, it feels like we should only do so via some explicit conformance (e.g., to a publicly-available form of _ObjectiveCBridgeable).<br>&gt; <br>&gt; 	- Doug<br>&gt; <br></p><p>I’m up for reviving the ObjectiveCBridgeable proposal :)<br></p><p><br>Russ<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160930/e0f40578/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Pitch] Making some RawRepresentable things bridge to ObjC as their raw value</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>October  3, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Sep 30, 2016, at 10:48 PM, Russ Bishop &lt;xenadu at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Sep 29, 2016, at 11:45 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Personally, I consider the first one to be a fairly-low-risk extension to SE-0139 that’s borderline bug-fix. We already know that those types have weak numeric representations in Objective-C because they come from Objective-C, so losing some of the type info by bridging to Objective-C is (IMO) falls out of having strong types in Swift for weaker types in Objective-C.<br>&gt;&gt; <br>&gt;&gt; The second one makes me a little nervous, I think because it weakens typing for types defined in Swift. These types don’t naturally have Objective-C counterparts, so if we’re going to weaken the types, it feels like we should only do so via some explicit conformance (e.g., to a publicly-available form of _ObjectiveCBridgeable).<br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt; <br>&gt; I’m up for reviving the ObjectiveCBridgeable proposal :)<br></p><p>I kind of hope id-as-Any leads us in a direction where ObjectiveCBridgeable isn&#39;t necessary to expose for most user types. If we at some point allow Swift value types to conform to ObjC protocols, expose @objc methods, and opt in to being representable in ObjC as classes, then most of the work of building an ObjC class to bridge to could potentially be handled by the compiler.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>[Pitch] Making some RawRepresentable things bridge to ObjC as their raw value</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>October  7, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Oct 3, 2016, at 9:23 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Sep 30, 2016, at 10:48 PM, Russ Bishop &lt;xenadu at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Sep 29, 2016, at 11:45 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Personally, I consider the first one to be a fairly-low-risk extension to SE-0139 that’s borderline bug-fix. We already know that those types have weak numeric representations in Objective-C because they come from Objective-C, so losing some of the type info by bridging to Objective-C is (IMO) falls out of having strong types in Swift for weaker types in Objective-C.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The second one makes me a little nervous, I think because it weakens typing for types defined in Swift. These types don’t naturally have Objective-C counterparts, so if we’re going to weaken the types, it feels like we should only do so via some explicit conformance (e.g., to a publicly-available form of _ObjectiveCBridgeable).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I’m up for reviving the ObjectiveCBridgeable proposal :)<br>&gt; <br>&gt; I kind of hope id-as-Any leads us in a direction where ObjectiveCBridgeable isn&#39;t necessary to expose for most user types. If we at some point allow Swift value types to conform to ObjC protocols, expose @objc methods, and opt in to being representable in ObjC as classes, then most of the work of building an ObjC class to bridge to could potentially be handled by the compiler.<br>&gt; <br>&gt; -Joe<br></p><p>How would we square that with enum { case foo(StructX&lt;Y&gt;) } ? If we can automatically bridge arbitrary enums and generic types then I’m all for it.<br></p><p>Russ<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161007/465c0880/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
