<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c14b8de3a00d0b57e1372600c83120cd?s=50"></div><header><strong>[Pitch] Brace omission for single-statement n-ary closures</strong> from <string>Marc Prud&#39;hommeaux</string> &lt;marc at glimpse.io&gt;<p>May 24, 2016 at 03:00:00pm</p></header><div class="content"><p>Everyone loves this syntax:<br></p><p>  let pos = [1, -2, 3].map(abs)<br></p><p>This syntax not so much:<br></p><p>  let neg = [1, -2, 3].map({ -abs($0) })<br></p><p>For single-statement closures, ordered parameters could be referenced in an autoclosure-like way using a placeholder for the parameter:<br></p><p>  let neg = [1, -2, 3].map(-abs(_))<br></p><p>The behavior would be the same as the current $0, $1, ... shorthand argument names to inline closures except that parameter re-ordering wouldn&#39;t be allowed (the first instance of _ would be $0, the second would be $1, etc). So the following three lines would all be compiled the same:<br></p><p>  let reversed = words.sort( { $0 &gt; $1 } )<br>  let reversed = words.sort(_ &gt; _)<br>  let reversed = words.sort(&gt;)<br></p><p>As with autoclosures, noescape rules would be enforced since there wouldn&#39;t be any way to specify that self is weak or unowned. So while the following requires use of self to make capture semantics explicit:<br></p><p>  words.lazy.filter({ $0.hashValue == self.hashValue })<br></p><p>These would both raise errors:<br></p><p>  words.lazy.filter(_.hashValue == hashValue)<br>  words.lazy.filter(_.hashValue == self.hashValue)<br></p><p>Nested closures would also behave the same as with dollar-shorthand:<br></p><p>  let words = [&quot;abc&quot;, &quot;def&quot;, &quot;hij&quot;]<br>  let ascii = words.flatMap({ $0.unicodeScalars.filter({ $0.isASCII }) })<br>  let ascii = words.flatMap(_.unicodeScalars.filter(_.isASCII))<br></p><p>Another example:<br></p><p>  let words: [String?] = [&quot;Hey&quot;, &quot;you&quot;, nil, &quot;guys&quot;]<br>  let exclaim = words.flatMap({ $0 }).map({ $0.uppercaseString }).reduce(&quot;&quot;, combine: { $0+&quot;! &quot;+$1 })<br>  let exclaim = words.flatMap(_).map(_.uppercaseString).reduce(&quot;&quot;, combine: _+&quot;! &quot;+_)<br></p><p><br>Why underscore and not another character like a lone &quot;$&quot; or &quot;.&quot;? The meaning of the underscore character as an anonymous ordered placeholder would be consistent with other usages throughout the Swift language. Examples:<br></p><p>  let (_, two, _) = (1, 2.0, &quot;Three&quot;) // anonymous tuple property<br>  words.reduce(&quot;&quot;, combine: { (x, _) in x }) // anonymous closure parameter<br>  let advancer = Int.advancedBy(_:limit:) // anonymous function argument<br>  switch &quot;X&quot; as String? {<br>  case .Some(_): print(&quot;something&quot;) // anonymous enum value<br>  case .None: print(&quot;nothing&quot;)<br>  }<br></p><p>And since underscore currently isn&#39;t allowed on the right-hand side of an expression, this syntax enhancement shouldn&#39;t break any existing code. Lastly, this same syntax for anonymous arguments is used in Scala, so it would already be familiar to a large developer base.<br></p><p>Any yeas or nays?<br></p><p>	-Marc<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160524/6fb17391/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[Pitch] Brace omission for single-statement n-ary closures</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May 26, 2016 at 02:00:00am</p></header><div class="content"><p>I know there was more to what you were suggesting, but can I suggest removing the parentheses:<br></p><p>  let neg = [1, -2, 3].map{ -abs($0) }<br></p><p>  let ascii = words.flatMap{ $0.unicodeScalars.filter{ $0.isASCII } }<br></p><p><br>Patrick<br></p><p>&gt; On 25 May 2016, at 5:46 AM, Marc Prud&#39;hommeaux via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Everyone loves this syntax:<br>&gt; <br>&gt;   let pos = [1, -2, 3].map(abs)<br>&gt; <br>&gt; This syntax not so much:<br>&gt; <br>&gt;   let neg = [1, -2, 3].map({ -abs($0) })<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/b6ea34b0/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Pitch] Brace omission for single-statement n-ary closures</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 25, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; For single-statement closures, ordered parameters could be referenced in an autoclosure-like way using a placeholder for the parameter:<br>&gt; <br>&gt;   let neg = [1, -2, 3].map(-abs(_))<br></p><p>I&#39;m a big fan of this, or something like this, but the core team has rejected proposals like this before. They apparently believe that it would be difficult to tell how much of the expression you intended to make a closure of:<br></p><p>	let neg = [1, -2, 3].map(-{ abs($0) })<br>	let neg = [1, -2, 3].map({ -abs($0) })<br>	let neg = { [1, -2, 3].map(-abs($0)) }<br></p><p>And believe that this syntax is limited in important ways, like being unable to reorder parameters. They think that closures with $N are more explicit and flexible while only requiring a little bit more code.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Pitch] Brace omission for single-statement n-ary closures</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>May 26, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; I&#39;m a big fan of this, or something like this, but the core team has rejected proposals like this before. They apparently believe that it would be difficult to tell how much of the expression you intended to make a closure of:<br>&gt; <br>&gt; 	let neg = [1, -2, 3].map(-{ abs($0) })<br>&gt; 	let neg = [1, -2, 3].map({ -abs($0) })<br>&gt; 	let neg = { [1, -2, 3].map(-abs($0)) }<br></p><p>I believe that in Scala (which has this feature), the entire content of the parenthesis is the statement and you need to use the placeholder (_ in Scala, $0 in Swift) to indicate it&#39;s a closure and not something else.<br></p><p>I&#39;ve never been a fan of this as I don&#39;t think it improves readability, mostly when you start nesting stuff like:<br></p><p>array.map($0.tranform($0.uppercaseString))<br></p><p>which seems incredibly confusing.<br></p><p>&gt; And believe that this syntax is limited in important ways, like being unable to reorder parameters. They think that closures with $N are more explicit and flexible while only requiring a little bit more code.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
