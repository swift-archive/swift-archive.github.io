<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>June 23, 2016 at 12:00:00am</p></header><div class="content"><p>What are the actual use-cases where people have needed destructive iterators?  Every time I have thought I wanted it, I ended up wanting multi-pass later.  For example, I had a sequence of random numbers, but ended up having to build a random hash instead so I could reliably re-create that sequence.  The other use-cases I can think of (e.g. markov-chains) would probably end up needing repeatability at some point as well.<br></p><p>The only thing I can think of without an eventual multi-pass requirement would be reading in an input or signal of some sort.<br></p><p><br></p><p>The most troubling thing to me is having the value type be destructive in such a weird way.  <br></p><p>I would like to see Iterator take a more functional approach.  In addition to the mutating next()-&gt;T? function, it would be nice to have a non-mutating nextIterator() -&gt; (T, Iterator&lt;T&gt;)?, which non-destructively returns a tuple of the next value and an iterator set to the next step.  This would be nondestructive, so it would probably require pre-calculating the next value early for destructive sequences.  The end result would be that next value is guaranteed to be the same whenever it is called from the non-mutated iterator, but future values may quickly diverge (from separate copies of the value type).<br></p><p>The other alternative would be to make Iterator a reference type.  <br></p><p>I would be ok with either solution.  I would be most in favor of whichever version allows us to build some sort of yielding iterator construct later.  I.e.  I am going to run through this iterator until a condition is met… then later I will pick up where I left off.  This is a useful pattern, especially for things which get destructively consumed.<br></p><p><br></p><p>I would like sequences to always be nondestructive / multi-pass, and gain everything from collectionType except those things which require an end index (e.g. count).  Sequences could be infinite.  Sequences could/would still vend destructively consumed iterators… they would just be required to vend the exact same iterator (which generates the same sequence of values) each time you ask for it.<br></p><p>Then we have collectionType (which should be renamed FiniteSequence), which re-gains count, dropLast, etc….  Basically the same as collectionType today.<br></p><p>What I like about splitting finite and potentially infinite sequences:<br>1) It allows compiler warnings for .forEach and for-in without break<br>2) You could build interesting infinite sequences, and then create a finite sequence by adding limits/predicates (e.g.  all prime numbers where x &lt; 250)<br></p><p>FiniteSequence(from: infSequence, boundedBy: 0…100)<br>FiniteSequence(from: infSequence, stoppingWhen: {$0 % 2 == 0})<br>FiniteSequence(from: infSequence, maxCount: 1000) //The above may need a maxCount parameter as well (which defaults to Int.max)<br></p><p><br>Top of my list for interesting infinite sequences would be RandomSequence, which inits with a seed (defaulting to a random seed), and produces a reproducible sequence of random T.<br></p><p><br>Thanks,<br>Jon<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>June 26, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jun 23, 2016, at 12:26 AM, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; What are the actual use-cases where people have needed destructive iterators?  Every time I have thought I wanted it, I ended up wanting multi-pass later.  For example, I had a sequence of random numbers, but ended up having to build a random hash instead so I could reliably re-create that sequence.  The other use-cases I can think of (e.g. markov-chains) would probably end up needing repeatability at some point as well.<br>&gt; <br>&gt; The only thing I can think of without an eventual multi-pass requirement would be reading in an input or signal of some sort.<br>&gt; <br>&gt; Thanks,<br>&gt; Jon<br></p><p>I use it in a LazyRowSequence&lt;T: SqlModelConvertible&gt; where querying Sqlite in WAL mode allows multiple concurrent readers to get point-in-time snapshots of the database. The query can’t be replayed without buffering all the rows in memory because Sqlite’s step functions are not bi-directional. In some cases we are talking about tens of thousands of rows (or even hundreds of thousands) and the ability to avoid buffering them is a feature, not a bug.<br></p><p>Sequence is the stream of things you can iterate over; that’s the only real promise it makes. If you want repeated iteration use a Collection.<br></p><p>I’m sure someone has a use for a stream of values that can’t be buffered but can be iterated over multiple times, but is that common enough to warrant redesigning the entire sequence/collection/iterator hierarchy?<br></p><p><br>Russ<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>June 26, 2016 at 08:00:00pm</p></header><div class="content"><p>Good use case!<br></p><p>Would being handed an Iterator work for you in this case?  Are there methods on Sequence that you need which aren’t on (or couldn’t be added to) Iterator?<br></p><p>The main issue for me is that Iterators, by the definition of their API are destructive (you can only use them once), but the ability of a sequence to vend a brand new Iterator implies multi-pass.  I am not saying we get rid of single-pass ability, so much as we should use Iterators for that purpose, and Sequences (which vend Iterators) should be multi-pass because they kind of pretend to be already…<br></p><p>Thanks<br>Jon<br></p><p>&gt; On Jun 26, 2016, at 3:41 PM, Russ Bishop &lt;xenadu at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 23, 2016, at 12:26 AM, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; What are the actual use-cases where people have needed destructive iterators?  Every time I have thought I wanted it, I ended up wanting multi-pass later.  For example, I had a sequence of random numbers, but ended up having to build a random hash instead so I could reliably re-create that sequence.  The other use-cases I can think of (e.g. markov-chains) would probably end up needing repeatability at some point as well.<br>&gt;&gt; <br>&gt;&gt; The only thing I can think of without an eventual multi-pass requirement would be reading in an input or signal of some sort.<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; Jon<br>&gt; <br>&gt; I use it in a LazyRowSequence&lt;T: SqlModelConvertible&gt; where querying Sqlite in WAL mode allows multiple concurrent readers to get point-in-time snapshots of the database. The query can’t be replayed without buffering all the rows in memory because Sqlite’s step functions are not bi-directional. In some cases we are talking about tens of thousands of rows (or even hundreds of thousands) and the ability to avoid buffering them is a feature, not a bug.<br>&gt; <br>&gt; Sequence is the stream of things you can iterate over; that’s the only real promise it makes. If you want repeated iteration use a Collection.<br>&gt; <br>&gt; I’m sure someone has a use for a stream of values that can’t be buffered but can be iterated over multiple times, but is that common enough to warrant redesigning the entire sequence/collection/iterator hierarchy?<br>&gt; <br>&gt; <br>&gt; Russ<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
