<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Review #2] SE-0091: Improving operator requirements in protocols</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July  7, 2016 at 10:00:00am</p></header><div class="content"><p>Hello Swift community,<br></p><p>The second review of &quot;SE-0091: Improving operator requirements in protocols&quot; begins now and runs through July 12. The proposal is available here:<br></p><p>	https://github.com/apple/swift-evolution/blob/master/proposals/0091-improving-operators-in-protocols.md<br></p><p>Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at:<br></p><p>	https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>or, if you would like to keep your feedback private, directly to the review manager.<br></p><p>What goes into a review?<br></p><p>The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br></p><p>	* What is your evaluation of the proposal?<br>	* Is the problem being addressed significant enough to warrant a change to Swift?<br>	* Does this proposal fit well with the feel and direction of Swift?<br>	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>More information about the Swift evolution process is available at<br></p><p>	https://github.com/apple/swift-evolution/blob/master/process.md<br></p><p>Thank you,<br></p><p>-Chris Lattner<br>Review Manager<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d972db2b6ee8b77746ce7122663eb4f8?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0091: Improving operator requirements in protocols</strong> from <string>Robert Widmann</string> &lt;rwidmann at apple.com&gt;<p>July  7, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; 	* What is your evaluation of the proposal?<br></p><p>+1.  Improved type checker performance for operator overloads alone is enough for me.  Improved locality of implementation is the cherry on top.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Absolutely.  This means protocols can be reorganized around operators without cluttering the global space space.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes.<br></p><p>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>The only other language I can think of that does this is C++.  <br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>Talked to Doug about it this morning.<br></p><p>&gt; On Jul 7, 2016, at 10:54 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The second review of &quot;SE-0091: Improving operator requirements in protocols&quot; begins now and runs through July 12. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0091-improving-operators-in-protocols.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at:<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution-announce mailing list<br>&gt; swift-evolution-announce at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution-announce<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/36f3ec204630839e54fb68c6979e5f78?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0091: Improving operator requirements in protocols</strong> from <string>Daniel Resnick</string> &lt;danielzresnick at gmail.com&gt;<p>July  7, 2016 at 11:00:00am</p></header><div class="content"><p>&gt;<br>&gt; What is your evaluation of the proposal?<br>&gt;<br>+1<br></p><p><br>&gt; Is the problem being addressed significant enough to warrant a change to<br>&gt; Swift?<br>&gt;<br>Yes, the current situation of defining a protocol required operator<br>function globally is potentially confusing and feels inconsistent.<br></p><p><br>&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt;<br>Yup.<br></p><p>How much effort did you put into your review? A glance, a quick reading, or<br>&gt; an in-depth study?<br></p><p>A reading.<br></p><p>One thing that&#39;s not completely clear to me: if you implement the operator<br>function as a class method and override it in a subclass, in what situation<br>would the overridden version be called?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160707/373703fa/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0091: Improving operator requirements in protocols</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>July  7, 2016 at 06:00:00pm</p></header><div class="content"><p>On Thu, Jul 7, 2016 at 11:37 AM Daniel Resnick via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; What is your evaluation of the proposal?<br>&gt;&gt;<br>&gt; +1<br>&gt;<br>&gt;<br>&gt;&gt; Is the problem being addressed significant enough to warrant a change to<br>&gt;&gt; Swift?<br>&gt;&gt;<br>&gt; Yes, the current situation of defining a protocol required operator<br>&gt; function globally is potentially confusing and feels inconsistent.<br>&gt;<br>&gt;<br>&gt;&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;<br>&gt; Yup.<br>&gt;<br>&gt; How much effort did you put into your review? A glance, a quick reading,<br>&gt;&gt; or an in-depth study?<br>&gt;<br>&gt; A reading.<br>&gt;<br>&gt; One thing that&#39;s not completely clear to me: if you implement the operator<br>&gt; function as a class method and override it in a subclass, in what situation<br>&gt; would the overridden version be called?<br>&gt;<br></p><p>(Using a binary operator as an example) Since the signature of the operator<br>is (Self, Self), you would have a situation like the following:<br></p><p>protocol Equatable {<br>  static func ==(lhs: Self, rhs: Self) -&gt; Bool<br>}<br></p><p>class A: Equatable {<br>  class func ==(lhs: A, rhs: A) -&gt; Bool { ... }<br>}<br></p><p>class B: A {<br>  class func ==(lhs: B, rhs: B) -&gt; Bool { ... }<br>}<br></p><p>There is actually no overriding happening here, because the argument types<br>are different.<br></p><p>So,<br></p><p>    let a = A()<br>    let b = B()<br>    let b_as_a: A = B()<br></p><p>    b == B()  // should call B.==<br>    a == B()  // should call A.==, because the only match is by upcasting B<br>to A<br>    b == b_as_a  // should call A.==, because the dispatch is done<br>statically<br></p><p>The latter of those may seem surprising, but it&#39;s not a regression—the<br>current global operators would do the same (and Swift would need<br>multiple-dispatch to solve this).<br></p><p>That being said, it&#39;s likely that you would want to be able to call A&#39;s ==<br>implementation as part of B&#39;s. And it just occurs to me that we don&#39;t need<br>to support &quot;super&quot; to do this—the solution is rather elegant:<br></p><p>    class func ==(lhs: B, rhs: B) -&gt; Bool {<br>      guard lhs as A == rhs as A else {<br>        return false<br>      }<br>      return lhs.someOtherProperty == rhs.someOtherProperty<br>    }<br></p><p>By explicitly casting the arguments to their superclass, the operator type<br>dispatch (which is based on the static types of the arguments) will call<br>the correct implementation.<br></p><p><br></p><p>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160707/cd49a43b/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Review #2] SE-0091: Improving operator requirements in protocols</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>July  7, 2016 at 03:00:00pm</p></header><div class="content"><p>* What is your evaluation of the proposal?<br>+1<br>        * Is the problem being addressed significant enough to warrant a<br>change to Swift?<br>Yes<br>        * Does this proposal fit well with the feel and direction of Swift?<br>Yes<br>        * If you have used other languages or libraries with a similar<br>feature, how do you feel that this proposal compares to those?<br>Not exactly, no.<br>        * How much effort did you put into your review? A glance, a quick<br>reading, or an in-depth study?<br>I&#39;ve followed the various pitches and read this proposal through.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160707/31f654bc/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0091: Improving operator requirements in protocols</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>July  7, 2016 at 04:00:00pm</p></header><div class="content"><p>A few questions:<br></p><p>1. What is universal lookup? How is this different than the compiler having to search a crowded namespace? I&#39;m really trying to understand how this is making it easier for the type checker. <br></p><p>2. If operators are a special case, why not replace static/class func with an &quot;operator&quot; keyword? Requiring static/class seems like an implementation detail to get this universal lookup. <br></p><p>3. Will the static vs class distinction ever be fixed or cleaned up? Isn&#39;t there a way to share one keyword for this same feature across all types?<br></p><p>Regardless, I&#39;m still giving this a +1. <br></p><p>I&#39;m just hoping we can:<br>- reduce some cognitive burden<br>- add a little character <br></p><p>Brandon <br></p><p>&gt; On Jul 7, 2016, at 1:54 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The second review of &quot;SE-0091: Improving operator requirements in protocols&quot; begins now and runs through July 12. The proposal is available here:<br>&gt; <br>&gt;    https://github.com/apple/swift-evolution/blob/master/proposals/0091-improving-operators-in-protocols.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at:<br>&gt; <br>&gt;    https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt;    * What is your evaluation of the proposal?<br>&gt;    * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;    * Does this proposal fit well with the feel and direction of Swift?<br>&gt;    * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;    * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt;    https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution-announce mailing list<br>&gt; swift-evolution-announce at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution-announce<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review #2] SE-0091: Improving operator requirements in protocols</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July  7, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; 	* What is your evaluation of the proposal?<br></p><p>+1.  This proposal improves clarity by allowing operator implementations to be declared inside the relevant type (or an extension of it).  It also improves implementation as outlined in the proposal.  Both are significant steps forward.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes.  I always thought it was unfortunate that operators have to be global functions.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Very much so.<br></p><p>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>The closest is C++.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>In depth study with the earlier proposal, discussion and review.  Quick reading this time around.  The new proposal is much better and resolves the things I did not like about the original version.<br></p><p>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0091: Improving operator requirements in protocols</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>July 12, 2016 at 10:00:00am</p></header><div class="content"><p>[Proposal: https://github.com/apple/swift-evolution/blob/master/proposals/0091-improving-operators-in-protocols.md ]<br></p><p>I definitely think this is an improvement over the last version! Nice work, Tony and Doug.<br></p><p>I am a little confused about the implementation, though. The proposal says this:<br></p><p>&gt; Instead, Swift should always perform operator lookup universally such that it sees all operators defined at either module scope or within a type/extension of a type. This gives us the syntactic improvements immediately and the natural Swift thing of defining your functionality within the type or an extension thereof just works.<br></p><p>and then later says<br></p><p>&gt; Therefore, we can achieve the performance improvements by making that insight part of the semantic model: when we find all operators, we also find the operators in the protocols themselves. The operators in the protocols are naturally generic.<br></p><p>&gt; Then, we say that we do not consider an operator function if it implements a protocol requirement, because the requirement is a generalization of all of the operator functions that satisfy that requirement. With this rule, we’re effectively getting the same effects as if users had declared trampoline operators, but it&#39;s automatic.<br></p><p>How do we know if an operator function implements a protocol requirement? What happens when an operator function implements a protocol requirement, but is also more general than that? And if we do find the implementation in the protocol, what conformance do we use to invoke the function when the types involved aren’t all &#39;Self&#39;?<br></p><p>I still prefer the rule that says we perform lookup into the left type and the right type, then fall back to top-level scope for backwards compatibility.<br></p><p><br>Separately from the lookup rules, I’m still unhappy with the class problem. The proposal states this:<br></p><p>&gt; We expect classes to implement the static operators in the protocol using `class` methods instead of `static` methods, which allows subclases to override them.<br></p><p>However, if lookup only finds the method in the protocol, it’s unclear whether this will call a conforming class&#39;s method, a static type’s method, or a dynamic type’s method; if it’s not the last, it’s hardly an “override”. I maintain that this is the wrong behavior for any class hierarchy that does include heterogeneous operations, including &quot;assignment operators, operators for chaining tasks, DSLs for constraint systems, etc” (me, from last time).<br></p><p>More from last time:<br></p><p>&gt;&gt; - for class types, regardless of whether one is a base of the other or both share a common third base type, neither static nor instance methods completely solve the problem and won&#39;t until/unless Swift supports multiple dispatch, and the proposed behavior is not a regression in those cases<br>&gt;&gt; <br>&gt; I guess I’m not convinced of the chain of reasoning here. “Multi-method dispatch is the most correct way to solve the problem” is fine; “therefore, anything short of that isn’t worth doing” is where I get stuck. Instance methods partially solve the problem, and it’s possible (again, no data on hand) that they solve the problem in the majority of cases.<br>&gt; <br>&gt; (It’s also possible that the prevalence of OO has made people prefer operators that can be dispatched based on the left-hand side, so I guess I’d want to go look at, e.g. Haskell and Perl to see what operators don’t fit in that bucket.)<br>&gt; <br>&gt; <br>&gt; I guess I’d summarize my stance as “this proposal enshrines our current problems with operator semantics in order to improve consistency in the syntax” (with “enshrines” meaning “makes harder to change later”), and that doesn’t seem like a good enough reason to change from what we have now.<br></p><p>…and I have to say I still feel that way. It’s not clear how much of a performance win we’ll get, and it’s not clear these are the right semantics, and it is clear that operators interact poorly with classes.<br></p><p>Jordan<br></p><p>P.S. The proposal also has this line:<br></p><p>&gt; non-static operator method syntax be deprecated in Swift 2 and removed in Swift 3<br></p><p>which should be updated in one way or another.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160712/c0e22c55/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0091: Improving operator requirements in protocols</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>July 13, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jul 12, 2016, at 10:35 AM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; [Proposal: https://github.com/apple/swift-evolution/blob/master/proposals/0091-improving-operators-in-protocols.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0091-improving-operators-in-protocols.md&gt; ]<br>&gt; <br>&gt; I definitely think this is an improvement over the last version! Nice work, Tony and Doug.<br>&gt; <br>&gt; I am a little confused about the implementation, though. The proposal says this:<br>&gt; <br>&gt;&gt; Instead, Swift should always perform operator lookup universally such that it sees all operators defined at either module scope or within a type/extension of a type. This gives us the syntactic improvements immediately and the natural Swift thing of defining your functionality within the type or an extension thereof just works.<br>&gt; <br>&gt; and then later says<br>&gt; <br>&gt;&gt; Therefore, we can achieve the performance improvements by making that insight part of the semantic model: when we find all operators, we also find the operators in the protocols themselves. The operators in the protocols are naturally generic.<br>&gt; <br>&gt;&gt; Then, we say that we do not consider an operator function if it implements a protocol requirement, because the requirement is a generalization of all of the operator functions that satisfy that requirement. With this rule, we’re effectively getting the same effects as if users had declared trampoline operators, but it&#39;s automatic.<br>&gt; <br>&gt; How do we know if an operator function implements a protocol requirement?<br></p><p>Well, we can track it explicitly in the modules that define the protocol and that define conformances of specific types to the protocol. Alternatively, we try the protocol requirements *first*. Once we’ve inferred the ‘Self’ type of the protocol (which is part of trying the protocol requirement), we can look up a conformance and the witness to see which witnesses should no longer be considered.<br></p><p>&gt; What happens when an operator function implements a protocol requirement, but is also more general than that?<br></p><p>*Right now*, it’s only really possible when you’re using a global generic operator, because we require exact type matches between requirements and witnesses. If/when we allow the witness to be a supertype of the requirement, you’ll start to see more of the semantic effects of this model, because shadowing the witness with the requirement can reject code that is well-formed now.<br></p><p>That’s why the shadowing behavior needs to be part of the semantic model. Implementation will let us settle the exact details so we can state those semantics more precisely.<br></p><p>&gt; And if we do find the implementation in the protocol, what conformance do we use to invoke the function when the types involved aren’t all &#39;Self’?<br></p><p>If there isn’t a reference to ‘Self’, type inference for the use of the protocol requirement will fail.<br></p><p>&gt; <br>&gt; I still prefer the rule that says we perform lookup into the left type and the right type, then fall back to top-level scope for backwards compatibility.<br></p><p>We thought about it a lot, and it’s not implementable in a way that’s consistent with type inference, because one of the left or right types might not be known yet, and you also need to consider the context type for something like, e.g.,<br></p><p>	let x: UInt = 1 + 2<br></p><p><br>&gt; <br>&gt; <br>&gt; Separately from the lookup rules, I’m still unhappy with the class problem. The proposal states this:<br>&gt; <br>&gt;&gt; We expect classes to implement the static operators in the protocol using `class` methods instead of `static` methods, which allows subclases to override them.<br>&gt; <br>&gt; However, if lookup only finds the method in the protocol, it’s unclear whether this will call a conforming class&#39;s method, a static type’s method, or a dynamic type’s method; if it’s not the last, it’s hardly an “override”. I maintain that this is the wrong behavior for any class hierarchy that does include heterogeneous operations, including &quot;assignment operators, operators for chaining tasks, DSLs for constraint systems, etc” (me, from last time).<br>&gt; <br>&gt; More from last time:<br>&gt; <br>&gt;&gt;&gt; - for class types, regardless of whether one is a base of the other or both share a common third base type, neither static nor instance methods completely solve the problem and won&#39;t until/unless Swift supports multiple dispatch, and the proposed behavior is not a regression in those cases<br>&gt;&gt;&gt; <br>&gt;&gt; I guess I’m not convinced of the chain of reasoning here. “Multi-method dispatch is the most correct way to solve the problem” is fine; “therefore, anything short of that isn’t worth doing” is where I get stuck. Instance methods partially solve the problem, and it’s possible (again, no data on hand) that they solve the problem in the majority of cases.<br>&gt;&gt; <br>&gt;&gt; (It’s also possible that the prevalence of OO has made people prefer operators that can be dispatched based on the left-hand side, so I guess I’d want to go look at, e.g. Haskell and Perl to see what operators don’t fit in that bucket.)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I guess I’d summarize my stance as “this proposal enshrines our current problems with operator semantics in order to improve consistency in the syntax” (with “enshrines” meaning “makes harder to change later”), and that doesn’t seem like a good enough reason to change from what we have now.<br>&gt; <br>&gt; …and I have to say I still feel that way. It’s not clear how much of a performance win we’ll get, and it’s not clear these are the right semantics, and it is clear that operators interact poorly with classes.<br></p><p>This is a good point, and one that’d I’d missed from the previous discussions. Left-bias is probably defensible, but I’m happy to do the conservative thing here: require the operator to be ‘final’. That’s no worse than what we have today—you have to delegate to something that’s explicitly dynamically dispatched based on whichever of the types you choose—and leaves open the possibility of loosening the rule in the future.<br></p><p>&gt; Jordan<br>&gt; <br>&gt; P.S. The proposal also has this line:<br>&gt; <br>&gt;&gt; non-static operator method syntax be deprecated in Swift 2 and removed in Swift 3<br>&gt; <br>&gt; which should be updated in one way or another.<br></p><p>Sure.<br></p><p>	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160713/c98719f4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0091: Improving operator requirements in protocols</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 13, 2016 at 01:00:00pm</p></header><div class="content"><p>On Wed, Jul 13, 2016 at 1:14 PM, Douglas Gregor via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Jul 12, 2016, at 10:35 AM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;<br>&gt; [Proposal:<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0091-improving-operators-in-protocols.md<br>&gt; ]<br>&gt;<br>&gt; I definitely think this is an improvement over the last version! Nice<br>&gt; work, Tony and Doug.<br>&gt;<br>&gt; I *am* a little confused about the implementation, though. The proposal<br>&gt; says this:<br>&gt;<br>&gt; Instead, Swift should always perform operator lookup universally such that<br>&gt; it sees all operators defined at either module scope or within a<br>&gt; type/extension of a type. This gives us the syntactic<br>&gt; improvements immediately and the natural Swift thing of defining your<br>&gt; functionality within the type or an extension thereof just works.<br>&gt;<br>&gt;<br>&gt; and then later says<br>&gt;<br>&gt; Therefore, we can achieve the performance improvements by making that<br>&gt; insight part of the semantic model: when we find all operators, we also<br>&gt; find the operators in the protocols themselves. The operators in the<br>&gt; protocols are naturally generic.<br>&gt;<br>&gt;<br>&gt; Then, we say that we do not consider an operator function if it implements<br>&gt; a protocol requirement, because the requirement is a generalization of all<br>&gt; of the operator functions that satisfy that requirement. With this rule,<br>&gt; we’re effectively getting the same effects as if users had<br>&gt; declared trampoline operators, but it&#39;s automatic.<br>&gt;<br>&gt;<br>&gt; How do we know if an operator function implements a protocol requirement?<br>&gt;<br>&gt;<br>&gt; Well, we can track it explicitly in the modules that define the protocol<br>&gt; and that define conformances of specific types to the protocol.<br>&gt; Alternatively, we try the protocol requirements *first*. Once we’ve<br>&gt; inferred the ‘Self’ type of the protocol (which is part of trying the<br>&gt; protocol requirement), we can look up a conformance and the witness to see<br>&gt; which witnesses should no longer be considered.<br>&gt;<br>&gt; What happens when an operator function implements a protocol requirement,<br>&gt; but is also more general than that?<br>&gt;<br>&gt;<br>&gt; *Right now*, it’s only really possible when you’re using a global generic<br>&gt; operator, because we require exact type matches between requirements and<br>&gt; witnesses. If/when we allow the witness to be a supertype of the<br>&gt; requirement, you’ll start to see more of the semantic effects of this<br>&gt; model, because shadowing the witness with the requirement can reject code<br>&gt; that is well-formed now.<br>&gt;<br>&gt; That’s why the shadowing behavior needs to be part of the semantic model.<br>&gt; Implementation will let us settle the exact details so we can state those<br>&gt; semantics more precisely.<br>&gt;<br>&gt; And if we do find the implementation in the protocol, what conformance do<br>&gt; we use to invoke the function when the types involved aren’t all &#39;Self’?<br>&gt;<br>&gt;<br>&gt; If there isn’t a reference to ‘Self’, type inference for the use of the<br>&gt; protocol requirement will fail.<br>&gt;<br>&gt;<br>&gt; I still prefer the rule that says we perform lookup into the left type and<br>&gt; the right type, then fall back to top-level scope for backwards<br>&gt; compatibility.<br>&gt;<br>&gt;<br>&gt; We thought about it a lot, and it’s not implementable in a way that’s<br>&gt; consistent with type inference, because one of the left or right types<br>&gt; might not be known yet, and you also need to consider the context type for<br>&gt; something like, e.g.,<br>&gt;<br>&gt; let x: UInt = 1 + 2<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; Separately from the lookup rules, I’m still unhappy with the class<br>&gt; problem. The proposal states this:<br>&gt;<br>&gt; We expect classes to implement the static operators in the protocol using<br>&gt; `class` methods instead of `static` methods, which allows subclases to<br>&gt; override them.<br>&gt;<br>&gt;<br>&gt; However, if lookup only finds the method in the protocol, it’s unclear<br>&gt; whether this will call a conforming class&#39;s method, a static type’s method,<br>&gt; or a dynamic type’s method; if it’s not the last, it’s hardly an<br>&gt; “override”. I maintain that this is the wrong behavior for any class<br>&gt; hierarchy that *does* include heterogeneous operations, including<br>&gt; &quot;assignment operators, operators for chaining tasks, DSLs for constraint<br>&gt; systems, etc” (me, from last time).<br>&gt;<br>&gt; More from last time:<br>&gt;<br>&gt; - for class types, regardless of whether one is a base of the other or<br>&gt; both share a common third base type, neither static nor instance methods<br>&gt; completely solve the problem and won&#39;t until/unless Swift supports multiple<br>&gt; dispatch, and the proposed behavior is not a regression in those cases<br>&gt;<br>&gt; I guess I’m not convinced of the chain of reasoning here. “Multi-method<br>&gt; dispatch is the most correct way to solve the problem” is fine; “therefore,<br>&gt; anything short of that isn’t worth doing” is where I get stuck. Instance<br>&gt; methods partially solve the problem, and it’s possible (again, no data on<br>&gt; hand) that they solve the problem in the majority of cases.<br>&gt;<br>&gt; (It’s also possible that the prevalence of OO has made people prefer<br>&gt; operators that can be dispatched based on the left-hand side, so I guess<br>&gt; I’d want to go look at, e.g. Haskell and Perl to see what operators don’t<br>&gt; fit in that bucket.)<br>&gt;<br>&gt;<br>&gt; I guess I’d summarize my stance as “this proposal enshrines our current<br>&gt; problems with operator semantics in order to improve consistency in the<br>&gt; syntax” (with “enshrines” meaning “makes harder to change later”), and that<br>&gt; doesn’t seem like a good enough reason to change from what we have now.<br>&gt;<br>&gt;<br>&gt; …and I have to say I still feel that way. It’s not clear how much of a<br>&gt; performance win we’ll get, and it’s not clear these are the right<br>&gt; semantics, and it *is* clear that operators interact poorly with classes.<br>&gt;<br>&gt;<br>&gt; This is a good point, and one that’d I’d missed from the previous<br>&gt; discussions. Left-bias is probably defensible<br>&gt;<br></p><p>Jumping in where I don&#39;t really have any business: left-bias for all infix<br>operators, or left-bias for left-associative operators and right-bias for<br>right-associative operators?<br></p><p><br>&gt; , but I’m happy to do the conservative thing here: require the operator to<br>&gt; be ‘final’. That’s no worse than what we have today—you have to delegate to<br>&gt; something that’s explicitly dynamically dispatched based on whichever of<br>&gt; the types you choose—and leaves open the possibility of loosening the rule<br>&gt; in the future.<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt; P.S. The proposal also has this line:<br>&gt;<br>&gt; non-static operator method syntax be *deprecated* in Swift 2 and *removed* in<br>&gt; Swift 3<br>&gt;<br>&gt;<br>&gt; which should be updated in one way or another.<br>&gt;<br>&gt;<br>&gt; Sure.<br>&gt;<br>&gt; - Doug<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160713/2d2d7a82/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
