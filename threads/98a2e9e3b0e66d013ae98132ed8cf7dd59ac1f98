<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f292ab7887c2e8698d013b40e1718e8b?s=50"></div><header><strong>Code Contracts</strong> from <string>Suminda Dharmasena</string> &lt;sirinath1978m at gmail.com&gt;<p>January 14, 2016 at 08:00:00am</p></header><div class="content"><p>Hello,<br></p><p>One feature that might be very useful to have in Swift is code contracts.<br>Is it possible to see how this can be added to the language?<br></p><p>Suminda<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160114/98a21f98/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c0eafab7106ab63b8db4025e57c1a8d2?s=50"></div><header><strong>Code Contracts</strong> from <string>Javier Soto</string> &lt;javier.api at gmail.com&gt;<p>January 14, 2016 at 11:00:00pm</p></header><div class="content"><p>Hi!<br></p><p>Maybe it&#39;s unfamiliarity on my part, but &quot;code contract&quot; seems like a very<br>vague term.<br>Do you have an example of what this could look like in swift and what the<br>benefits of such feature would be?<br></p><p>Thanks!<br>On Wed, Jan 13, 2016 at 6:59 PM Suminda Dharmasena via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hello,<br>&gt;<br>&gt; One feature that might be very useful to have in Swift is code contracts.<br>&gt; Is it possible to see how this can be added to the language?<br>&gt;<br>&gt; Suminda<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-- <br>Javier Soto<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160114/66a3d5e9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f292ab7887c2e8698d013b40e1718e8b?s=50"></div><header><strong>Code Contracts</strong> from <string>Suminda Dharmasena</string> &lt;sirinath1978m at gmail.com&gt;<p>January 15, 2016 at 10:00:00am</p></header><div class="content"><p>E.g.<br></p><p><br>   1. var @where(&quot;myVariable &lt;= 100 &amp;&amp; myVariable &gt;= 0&quot;) myVariable = 42<br></p><p><br></p><p><br>   1. @where(&quot;myVariable &lt;= 80 &amp;&amp; myVariable &gt;= 50&quot;)<br>   2. {<br>   3. ...<br>   4. }<br></p><p><br></p><p><br>   1. @where(&quot;score &lt;= 100 &amp;&amp; score &gt;= 0&quot;)<br>   2. for score in individualScores {<br>   3. ...<br>   4. }<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160115/f944b211/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c0eafab7106ab63b8db4025e57c1a8d2?s=50"></div><header><strong>Code Contracts</strong> from <string>Javier Soto</string> &lt;javier.api at gmail.com&gt;<p>January 15, 2016 at 04:00:00am</p></header><div class="content"><p>Is this something that in your opinion is worth extra, special syntax?<br>Those examples could be implement easily like:<br></p><p>didSet {<br>precondition(score &lt;= 100)<br>}<br></p><p><br>On Thu, Jan 14, 2016 at 8:32 PM Suminda Dharmasena &lt;sirinath1978m at gmail.com&gt;<br>wrote:<br></p><p>&gt; E.g.<br>&gt;<br>&gt;<br>&gt;    1. var @where(&quot;myVariable &lt;= 100 &amp;&amp; myVariable &gt;= 0&quot;) myVariable = 42<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;    1. @where(&quot;myVariable &lt;= 80 &amp;&amp; myVariable &gt;= 50&quot;)<br>&gt;    2. {<br>&gt;    3. ...<br>&gt;    4. }<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;    1. @where(&quot;score &lt;= 100 &amp;&amp; score &gt;= 0&quot;)<br>&gt;    2. for score in individualScores {<br>&gt;    3. ...<br>&gt;    4. }<br>&gt;<br>&gt; --<br>Javier Soto<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160115/38e89486/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>Code Contracts</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>January 14, 2016 at 11:00:00pm</p></header><div class="content"><p>Mhm, -1 for this reason.  If there were richer preconditions (say, a refinement typing scheme) here rather than C0-style contracts it&#39;d be worth the extra syntax.<br></p><p>~Robert Widmann<br></p><p>2016/01/14 23:36、Javier Soto via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br></p><p>&gt; Is this something that in your opinion is worth extra, special syntax? Those examples could be implement easily like:<br>&gt; <br>&gt; didSet {<br>&gt; precondition(score &lt;= 100)<br>&gt; }<br>&gt; <br>&gt; <br>&gt;&gt; On Thu, Jan 14, 2016 at 8:32 PM Suminda Dharmasena &lt;sirinath1978m at gmail.com&gt; wrote:<br>&gt;&gt; E.g. <br>&gt;&gt; <br>&gt;&gt; var @where(&quot;myVariable &lt;= 100 &amp;&amp; myVariable &gt;= 0&quot;) myVariable = 42<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; @where(&quot;myVariable &lt;= 80 &amp;&amp; myVariable &gt;= 50&quot;)<br>&gt;&gt; {<br>&gt;&gt;     ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; @where(&quot;score &lt;= 100 &amp;&amp; score &gt;= 0&quot;)<br>&gt;&gt; for score in individualScores {<br>&gt;&gt;     ...<br>&gt;&gt; }<br>&gt; <br>&gt; -- <br>&gt; Javier Soto <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160114/dade407d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f292ab7887c2e8698d013b40e1718e8b?s=50"></div><header><strong>Code Contracts</strong> from <string>Suminda Dharmasena</string> &lt;sirinath1978m at gmail.com&gt;<p>January 15, 2016 at 01:00:00pm</p></header><div class="content"><p>This is how C# does it -<br>https://msdn.microsoft.com/en-us/library/dd264808(v=vs.110).aspx<br></p><p>There is a language called WhyML which has it buildin -<br>http://why3.lri.fr/doc-0.80/manual004.html. Another such language is:<br>http://whiley.org/ and Ada (Spark subset) :<br>https://en.wikipedia.org/wiki/SPARK_(programming_language)<br></p><p>In F* see section on &quot;Statically checked assertions&quot; -<br>https://www.fstar-lang.org/tutorial/<br></p><p>This can give a better idea on available syntax and how this can be adopted<br>to Swift.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160115/0497dc31/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Code Contracts</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>January 14, 2016 at 09:00:00pm</p></header><div class="content"><p>This is the same thing as Refinement Types, right?<br>https://en.wikipedia.org/wiki/Refinement_(computing)#Refinement_types<br>http://goto.ucsd.edu/~rjhala/liquid/haskell/blog/blog/2013/01/01/refinement-types-101.lhs/<br></p><p>I’m in favor of it, but I think someone’s already made that suggestion… At the very least, I didn’t know what the phrase meant until a few days ago, and I know I learned about it from reading something on swift-evolution.<br></p><p>- Dave Sweeris<br></p><p>&gt; On Jan 14, 2016, at 20:32, Suminda Dharmasena via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; E.g. <br>&gt; <br>&gt; var @where(&quot;myVariable &lt;= 100 &amp;&amp; myVariable &gt;= 0&quot;) myVariable = 42<br>&gt; <br>&gt; <br>&gt; @where(&quot;myVariable &lt;= 80 &amp;&amp; myVariable &gt;= 50&quot;)<br>&gt; {<br>&gt;     ...<br>&gt; }<br>&gt; <br>&gt; <br>&gt; @where(&quot;score &lt;= 100 &amp;&amp; score &gt;= 0&quot;)<br>&gt; for score in individualScores {<br>&gt;     ...<br>&gt; }<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160114/4581f3b2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ec8a60462a511e833c5c4a83b424c958?s=50"></div><header><strong>Code Contracts</strong> from <string>Dennis Weissmann</string> &lt;dennis at dennisweissmann.me&gt;<p>January 15, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jan 15, 2016, at 6:53 AM, Dave via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This is the same thing as Refinement Types, right?<br>&gt; https://en.wikipedia.org/wiki/Refinement_(computing)#Refinement_types &lt;https://en.wikipedia.org/wiki/Refinement_(computing)#Refinement_types&gt;<br>&gt; http://goto.ucsd.edu/~rjhala/liquid/haskell/blog/blog/2013/01/01/refinement-types-101.lhs/ &lt;http://goto.ucsd.edu/~rjhala/liquid/haskell/blog/blog/2013/01/01/refinement-types-101.lhs/&gt;<br>&gt; <br></p><p>Yes, it seems they are. There is a pretty nice and easy to understand explanation [here](https://github.com/tomprimozic/type-systems/tree/master/refined_types):<br></p><p>Refined types or contracts are a restricted form of dependent types that combine base datatypes with logical predicates; for example, the type of natural numbers could be written x : int if x ≥ 0 (the notation most commonly used in academic literature is {ν : int | ν ≥ 0}).<br></p><p>&gt; I’m in favor of it, but I think someone’s already made that suggestion… At the very least, I didn’t know what the phrase meant until a few days ago, and I know I learned about it from reading something on swift-evolution.<br></p><p>That was probably Matthew (https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/005925.html) or me (https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/005918.html) - the thread is called &#39;Proposal: named invariants for variable declarations&#39;<br></p><p>And I agree with Matthew that this won’t happen anytime soon. That’s why I didn’t want to discuss that topic too much. It’s just that the ABI will be finalized later this year and I wanted to mention that there is definitely interest in this area in case some ABI-related things are needed for refinement types (or even dependent types, someday, one can dream 😇) which need to be thought of before the finalization.<br></p><p>- Dennis<br></p><p>&gt; - Dave Sweeris<br>&gt; <br>&gt;&gt; On Jan 14, 2016, at 20:32, Suminda Dharmasena via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; E.g. <br>&gt;&gt; <br>&gt;&gt; var @where(&quot;myVariable &lt;= 100 &amp;&amp; myVariable &gt;= 0&quot;) myVariable = 42<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; @where(&quot;myVariable &lt;= 80 &amp;&amp; myVariable &gt;= 50&quot;)<br>&gt;&gt; {<br>&gt;&gt;     ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; @where(&quot;score &lt;= 100 &amp;&amp; score &gt;= 0&quot;)<br>&gt;&gt; for score in individualScores {<br>&gt;&gt;     ...<br>&gt;&gt; }<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160115/d4f11ca1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0fc40f95a5c6b063df44b3bc136d764b?s=50"></div><header><strong>Code Contracts</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.com&gt;<p>January 15, 2016 at 12:00:00pm</p></header><div class="content"><p>This is pretty interesting; while the actual compile-time type-checking could be complex and take some time to implement, it seems to me that the actual notation could be implemented in advance and simply perform runtime assertions until the real type-checking is ready? In cases where the type-checker can’t be certain of a value’s safety, a run-time assertion might make sense anyway, so this short-term behaviour could actually be left in, with the caveat being that your restriction could still fail at run-time (which is what I think most people would want when the compile-time check isn’t enough).<br></p><p>I’d be particularly interested in getting the notation available sooner if it&#39;s concise enough to make it worth using in place of current if statements. For example, it’d be nice if there were some shorthand for integers, as these seem like they’d be a particularly common use-case, for example:<br></p><p>var @where(“0 &lt;= myVariable &lt;= 100”) myVariable = 42<br>var @where(“0 &lt;= $1 &lt;= 100) myVariable = 42<br></p><p>Though personally I’d prefer something even more concise like:<br></p><p>var myVariable(0…100) = 42<br>var myVariable:Int(0…100) = 42<br></p><p>Leaving the @where clause for more complex (i.e- non-numeric) cases. A really powerful alternative would be to allow us some mechanism to define how to handle restrictions in our classes and structs; these would be compiled first so that they can be executed by the type checker (which may limit what they can do) but could allow us full control of how they work. So, for example, an integer definition might look like:<br></p><p>struct Int… {<br>	...<br>	restriction(range:Range&lt;Int&gt;) -&gt; Bool { return range.contains(self) }<br>}<br>var myVariable(0…100) = 42<br></p><p>At run-time this would be equivalent to:<br></p><p>var myVariable = 42<br>assert(myVariable.restriction(0…100), “Value of myVariable is out of bounds [0…100]”)<br></p><p>With the idea being that in future the type-checker would call the restriction check, find 42 to be in range and omit the assertion entirely.<br></p><p>Just some thoughts, but the main thing for me is that this is something that I’d like to use a lot if implemented, so the more concise it can be, the better.<br></p><p>- Haravikk<br></p><p>&gt; On 15 Jan 2016, at 12:27, Dennis Weissmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 15, 2016, at 6:53 AM, Dave via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This is the same thing as Refinement Types, right?<br>&gt;&gt; https://en.wikipedia.org/wiki/Refinement_(computing)#Refinement_types &lt;https://en.wikipedia.org/wiki/Refinement_(computing)#Refinement_types&gt;<br>&gt;&gt; http://goto.ucsd.edu/~rjhala/liquid/haskell/blog/blog/2013/01/01/refinement-types-101.lhs/ &lt;http://goto.ucsd.edu/~rjhala/liquid/haskell/blog/blog/2013/01/01/refinement-types-101.lhs/&gt;<br>&gt;&gt; <br>&gt; <br>&gt; Yes, it seems they are. There is a pretty nice and easy to understand explanation [here](https://github.com/tomprimozic/type-systems/tree/master/refined_types &lt;https://github.com/tomprimozic/type-systems/tree/master/refined_types&gt;):<br>&gt; <br>&gt; Refined types or contracts are a restricted form of dependent types that combine base datatypes with logical predicates; for example, the type of natural numbers could be written x : int if x ≥ 0 (the notation most commonly used in academic literature is {ν : int | ν ≥ 0}).<br>&gt; <br>&gt;&gt; I’m in favor of it, but I think someone’s already made that suggestion… At the very least, I didn’t know what the phrase meant until a few days ago, and I know I learned about it from reading something on swift-evolution.<br>&gt; <br>&gt; That was probably Matthew (https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/005925.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/005925.html&gt;) or me (https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/005918.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/005918.html&gt;) - the thread is called &#39;Proposal: named invariants for variable declarations&#39;<br>&gt; <br>&gt; And I agree with Matthew that this won’t happen anytime soon. That’s why I didn’t want to discuss that topic too much. It’s just that the ABI will be finalized later this year and I wanted to mention that there is definitely interest in this area in case some ABI-related things are needed for refinement types (or even dependent types, someday, one can dream 😇) which need to be thought of before the finalization.<br>&gt; <br>&gt; - Dennis<br>&gt; <br>&gt;&gt; - Dave Sweeris<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 14, 2016, at 20:32, Suminda Dharmasena via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; E.g. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var @where(&quot;myVariable &lt;= 100 &amp;&amp; myVariable &gt;= 0&quot;) myVariable = 42<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; @where(&quot;myVariable &lt;= 80 &amp;&amp; myVariable &gt;= 50&quot;)<br>&gt;&gt;&gt; {<br>&gt;&gt;&gt;     ...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; @where(&quot;score &lt;= 100 &amp;&amp; score &gt;= 0&quot;)<br>&gt;&gt;&gt; for score in individualScores {<br>&gt;&gt;&gt;     ...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160115/f45e1519/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ec8a60462a511e833c5c4a83b424c958?s=50"></div><header><strong>Code Contracts</strong> from <string>Dennis Weissmann</string> &lt;dennis at dennisweissmann.me&gt;<p>January 15, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jan 15, 2016, at 1:56 PM, Haravikk &lt;swift-evolution at haravikk.com&gt; wrote:<br>&gt; <br>&gt; This is pretty interesting; while the actual compile-time type-checking could be complex and take some time to implement, it seems to me that the actual notation could be implemented in advance and simply perform runtime assertions until the real type-checking is ready? In cases where the type-checker can’t be certain of a value’s safety, a run-time assertion might make sense anyway, so this short-term behaviour could actually be left in, with the caveat being that your restriction could still fail at run-time (which is what I think most people would want when the compile-time check isn’t enough).<br>&gt; <br></p><p>That’s an interesting approach! I like it :)<br></p><p>&gt; I’d be particularly interested in getting the notation available sooner if it&#39;s concise enough to make it worth using in place of current if statements. For example, it’d be nice if there were some shorthand for integers, as these seem like they’d be a particularly common use-case, for example:<br>&gt; <br>&gt; var @where(“0 &lt;= myVariable &lt;= 100”) myVariable = 42<br>&gt; var @where(“0 &lt;= $1 &lt;= 100) myVariable = 42<br>&gt; <br>&gt; Though personally I’d prefer something even more concise like:<br>&gt; <br>&gt; var myVariable(0…100) = 42<br>&gt; var myVariable:Int(0…100) = 42<br>&gt; <br></p><p>I don’t like the @where syntax too much either (but I don’t have the time right now to come up with a better, well-thought-out and practical syntax myself).<br>Here are just some quick thoughts:<br></p><p>// Annotating the type<br>let value: Int&lt;1...100&gt; = 42                // Generics?<br>let value: Int(1...100) = 42                // Initializer?<br>let value: Int{1...100} = 42                // Scope?<br>let value: {value: Int | 1...100} = 42      // LiquidHaskell<br>let value: Int where Type == 1...100 = 42   // `where` already is a keyword that acts very similar (but at runtime)<br></p><p>// Annotating the variable (the inferred type)<br>let value&lt;1...100&gt; = 42<br>let value(1...100) = 42<br>let value{1...100} = 42<br>let value{value: Int | 1...100} = 42<br>let value where Type == 1...100 = 42<br></p><p>Even though it is more verbose, I like the last approach best. I think the common use-case is to predefine some very common ones (e.g. RGBA) in typealiases like so:<br></p><p>typealias RGBAValue = Int where Type == 0...255<br></p><p>This makes it much nicer (IMO) to declare (e.g.) functions. `UIColor` for example could gain an initializer taking values from 0 to 255:<br></p><p>init(red: RGBAValue, green: RGBAValue, blue: RGBAValue, alpha: RGBAValue)<br></p><p>&gt; Leaving the @where clause for more complex (i.e- non-numeric) cases. A really powerful alternative would be to allow us some mechanism to define how to handle restrictions in our classes and structs; these would be compiled first so that they can be executed by the type checker (which may limit what they can do) but could allow us full control of how they work. So, for example, an integer definition might look like:<br>&gt; <br>&gt; struct Int… {<br>&gt; 	...<br>&gt; 	restriction(range:Range&lt;Int&gt;) -&gt; Bool { return range.contains(self) }<br>&gt; }<br>&gt; var myVariable(0…100) = 42<br>&gt; <br>&gt; At run-time this would be equivalent to:<br>&gt; <br>&gt; var myVariable = 42<br>&gt; assert(myVariable.restriction(0…100), “Value of myVariable is out of bounds [0…100]”)<br>&gt; <br>&gt; With the idea being that in future the type-checker would call the restriction check, find 42 to be in range and omit the assertion entirely.<br>&gt; <br>&gt; Just some thoughts, but the main thing for me is that this is something that I’d like to use a lot if implemented, so the more concise it can be, the better.<br>&gt; <br>Exactly :) If the type is precise enough the compiler can actually write (infer) a lot of your code)<br></p><p>&gt; - Haravikk<br>&gt; <br>&gt;&gt; On 15 Jan 2016, at 12:27, Dennis Weissmann via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 15, 2016, at 6:53 AM, Dave via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is the same thing as Refinement Types, right?<br>&gt;&gt;&gt; https://en.wikipedia.org/wiki/Refinement_(computing)#Refinement_types &lt;https://en.wikipedia.org/wiki/Refinement_(computing)#Refinement_types&gt;<br>&gt;&gt;&gt; http://goto.ucsd.edu/~rjhala/liquid/haskell/blog/blog/2013/01/01/refinement-types-101.lhs/ &lt;http://goto.ucsd.edu/~rjhala/liquid/haskell/blog/blog/2013/01/01/refinement-types-101.lhs/&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Yes, it seems they are. There is a pretty nice and easy to understand explanation [here](https://github.com/tomprimozic/type-systems/tree/master/refined_types &lt;https://github.com/tomprimozic/type-systems/tree/master/refined_types&gt;):<br>&gt;&gt; <br>&gt;&gt; Refined types or contracts are a restricted form of dependent types that combine base datatypes with logical predicates; for example, the type of natural numbers could be written x : int if x ≥ 0 (the notation most commonly used in academic literature is {ν : int | ν ≥ 0}).<br>&gt;&gt; <br>&gt;&gt;&gt; I’m in favor of it, but I think someone’s already made that suggestion… At the very least, I didn’t know what the phrase meant until a few days ago, and I know I learned about it from reading something on swift-evolution.<br>&gt;&gt; <br>&gt;&gt; That was probably Matthew (https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/005925.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/005925.html&gt;) or me (https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/005918.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/005918.html&gt;) - the thread is called &#39;Proposal: named invariants for variable declarations&#39;<br>&gt;&gt; <br>&gt;&gt; And I agree with Matthew that this won’t happen anytime soon. That’s why I didn’t want to discuss that topic too much. It’s just that the ABI will be finalized later this year and I wanted to mention that there is definitely interest in this area in case some ABI-related things are needed for refinement types (or even dependent types, someday, one can dream 😇) which need to be thought of before the finalization.<br>&gt;&gt; <br>&gt;&gt; - Dennis<br>&gt;&gt; <br>&gt;&gt;&gt; - Dave Sweeris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 14, 2016, at 20:32, Suminda Dharmasena via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; E.g. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var @where(&quot;myVariable &lt;= 100 &amp;&amp; myVariable &gt;= 0&quot;) myVariable = 42<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; @where(&quot;myVariable &lt;= 80 &amp;&amp; myVariable &gt;= 50&quot;)<br>&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;     ...<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; @where(&quot;score &lt;= 100 &amp;&amp; score &gt;= 0&quot;)<br>&gt;&gt;&gt;&gt; for score in individualScores {<br>&gt;&gt;&gt;&gt;     ...<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160115/02bfbb92/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>Code Contracts</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>January 15, 2016 at 09:00:00am</p></header><div class="content"><p>I had a similar idea in the early days of the mailing list before I knew it had a name. I don’t think it got much (any, really) discussion at the time: https://lists.swift.org/pipermail/swift-evolution/2015-December/000022.html<br></p><p>l8r<br>Sean<br></p><p><br>&gt; On Jan 15, 2016, at 8:53 AM, Dennis Weissmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 15, 2016, at 1:56 PM, Haravikk &lt;swift-evolution at haravikk.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This is pretty interesting; while the actual compile-time type-checking could be complex and take some time to implement, it seems to me that the actual notation could be implemented in advance and simply perform runtime assertions until the real type-checking is ready? In cases where the type-checker can’t be certain of a value’s safety, a run-time assertion might make sense anyway, so this short-term behaviour could actually be left in, with the caveat being that your restriction could still fail at run-time (which is what I think most people would want when the compile-time check isn’t enough).<br>&gt;&gt; <br>&gt; <br>&gt; That’s an interesting approach! I like it :)<br>&gt; <br>&gt;&gt; I’d be particularly interested in getting the notation available sooner if it&#39;s concise enough to make it worth using in place of current if statements. For example, it’d be nice if there were some shorthand for integers, as these seem like they’d be a particularly common use-case, for example:<br>&gt;&gt; <br>&gt;&gt; var @where(“0 &lt;= myVariable &lt;= 100”) myVariable = 42<br>&gt;&gt; var @where(“0 &lt;= $1 &lt;= 100) myVariable = 42<br>&gt;&gt; <br>&gt;&gt; Though personally I’d prefer something even more concise like:<br>&gt;&gt; <br>&gt;&gt; var myVariable(0…100) = 42<br>&gt;&gt; var myVariable:Int(0…100) = 42<br>&gt;&gt; <br>&gt; <br>&gt; I don’t like the @where syntax too much either (but I don’t have the time right now to come up with a better, well-thought-out and practical syntax myself).<br>&gt; Here are just some quick thoughts:<br>&gt; <br>&gt; // Annotating the type<br>&gt; let value: Int&lt;1...100&gt; = 42                // Generics?<br>&gt; let value: Int(1...100) = 42                // Initializer?<br>&gt; let value: Int{1...100} = 42                // Scope?<br>&gt; let value: {value: Int | 1...100} = 42      // LiquidHaskell<br>&gt; let value: Int where Type == 1...100 = 42   // `where` already is a keyword that acts very similar (but at runtime)<br>&gt; <br>&gt; // Annotating the variable (the inferred type)<br>&gt; let value&lt;1...100&gt; = 42<br>&gt; let value(1...100) = 42<br>&gt; let value{1...100} = 42<br>&gt; let value{value: Int | 1...100} = 42<br>&gt; let value where Type == 1...100 = 42<br>&gt; <br>&gt; Even though it is more verbose, I like the last approach best. I think the common use-case is to predefine some very common ones (e.g. RGBA) in typealiases like so:<br>&gt; <br>&gt; typealias RGBAValue = Int where Type == 0...255<br>&gt; <br>&gt; This makes it much nicer (IMO) to declare (e.g.) functions. `UIColor` for example could gain an initializer taking values from 0 to 255:<br>&gt; <br>&gt; init(red: RGBAValue, green: RGBAValue, blue: RGBAValue, alpha: RGBAValue)<br>&gt; <br>&gt;&gt; Leaving the @where clause for more complex (i.e- non-numeric) cases. A really powerful alternative would be to allow us some mechanism to define how to handle restrictions in our classes and structs; these would be compiled first so that they can be executed by the type checker (which may limit what they can do) but could allow us full control of how they work. So, for example, an integer definition might look like:<br>&gt;&gt; <br>&gt;&gt; struct Int… {<br>&gt;&gt; 	...<br>&gt;&gt; 	restriction(range:Range&lt;Int&gt;) -&gt; Bool { return range.contains(self) }<br>&gt;&gt; }<br>&gt;&gt; var myVariable(0…100) = 42<br>&gt;&gt; <br>&gt;&gt; At run-time this would be equivalent to:<br>&gt;&gt; <br>&gt;&gt; var myVariable = 42<br>&gt;&gt; assert(myVariable.restriction(0…100), “Value of myVariable is out of bounds [0…100]”)<br>&gt;&gt; <br>&gt;&gt; With the idea being that in future the type-checker would call the restriction check, find 42 to be in range and omit the assertion entirely.<br>&gt;&gt; <br>&gt;&gt; Just some thoughts, but the main thing for me is that this is something that I’d like to use a lot if implemented, so the more concise it can be, the better.<br>&gt;&gt; <br>&gt; Exactly :) If the type is precise enough the compiler can actually write (infer) a lot of your code)<br>&gt; <br>&gt;&gt; - Haravikk<br>&gt;&gt; <br>&gt;&gt;&gt; On 15 Jan 2016, at 12:27, Dennis Weissmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 15, 2016, at 6:53 AM, Dave via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is the same thing as Refinement Types, right?<br>&gt;&gt;&gt;&gt; https://en.wikipedia.org/wiki/Refinement_(computing)#Refinement_types<br>&gt;&gt;&gt;&gt; http://goto.ucsd.edu/~rjhala/liquid/haskell/blog/blog/2013/01/01/refinement-types-101.lhs/<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, it seems they are. There is a pretty nice and easy to understand explanation [here](https://github.com/tomprimozic/type-systems/tree/master/refined_types):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Refined types or contracts are a restricted form of dependent types that combine base datatypes with logical predicates; for example, the type of natural numbers could be written x : int if x ≥ 0 (the notation most commonly used in academic literature is {ν : int | ν ≥ 0}).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m in favor of it, but I think someone’s already made that suggestion… At the very least, I didn’t know what the phrase meant until a few days ago, and I know I learned about it from reading something on swift-evolution.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That was probably Matthew (https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/005925.html) or me (https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/005918.html) - the thread is called &#39;Proposal: named invariants for variable declarations&#39;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And I agree with Matthew that this won’t happen anytime soon. That’s why I didn’t want to discuss that topic too much. It’s just that the ABI will be finalized later this year and I wanted to mention that there is definitely interest in this area in case some ABI-related things are needed for refinement types (or even dependent types, someday, one can dream 😇) which need to be thought of before the finalization.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Dennis<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Dave Sweeris<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 14, 2016, at 20:32, Suminda Dharmasena via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; E.g. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	• var @where(&quot;myVariable &lt;= 100 &amp;&amp; myVariable &gt;= 0&quot;) myVariable = 42<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	• @where(&quot;myVariable &lt;= 80 &amp;&amp; myVariable &gt;= 50&quot;)<br>&gt;&gt;&gt;&gt;&gt; 	• {<br>&gt;&gt;&gt;&gt;&gt; 	•     ...<br>&gt;&gt;&gt;&gt;&gt; 	• }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	• @where(&quot;score &lt;= 100 &amp;&amp; score &gt;= 0&quot;)<br>&gt;&gt;&gt;&gt;&gt; 	• for score in individualScores {<br>&gt;&gt;&gt;&gt;&gt; 	•     ...<br>&gt;&gt;&gt;&gt;&gt; 	• }<br>&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ec8a60462a511e833c5c4a83b424c958?s=50"></div><header><strong>Code Contracts</strong> from <string>Dennis Weissmann</string> &lt;dennis at dennisweissmann.me&gt;<p>January 15, 2016 at 05:00:00pm</p></header><div class="content"><p>Hey Sean,<br></p><p>+ 1<br></p><p>That’s indeed very similar, I must have overlooked your email in the flood of emails at the time.<br></p><p>Especially<br></p><p>&gt; I like the idea of this always being a compile-time check when possible, but it could also be useful to force the requirement to be evaluated at runtime by adding a force operator to it:<br>&gt; <br>&gt; func scale(x: Float in! 0…1) -&gt; Float {<br>&gt;   return someValue * x<br>&gt; }<br></p><p>&gt; In this scenario the compiler would probably still try to prove it statically - and if it could, it’d skip runtime checks - but if it cannot, it would then insert runtime guards that catch requirement failures and crash as necessary - similar to a forced unwrap - instead of being a compile time error.<br></p><p>The reasons I think `in` isn’t the best choice for this keyword are<br></p><p>- `in` already is a keyword with a totally different meaning<br>- a range is just an example of such a predicate, here are some examples (using the `Type` version of my last email, though I think the name doesn’t make much sense, we’re refining the type, yes, but the calculation in the predicate is applied to an instance of that type 🤔):<br>    typealias RGBAInt = Int where Type &gt;= 0 &amp;&amp; Type &lt;= 255                            // Can be rewritten as a range (0...255)<br>    typealias RGBADouble = Double where Type &gt;= 0 &amp;&amp; Type &lt;= 1.0                      // Can be rewritten as a range (0...1.0)<br>    typealias BatteryLevel = Int where Type &gt;= 0 &amp;&amp; Type &lt;= 100                       // Can be rewritten as a range (0...100)<br>    typealias Primes10 = Int where Type == 2 || Type == 3 || Type == 5 || Type == 7   // Cannot be rewritten as a range<br>    typealias EvenNumber = Int where Type % 2 == 0                                    // Cannot be rewritten as a range<br>  <br>What do you think?<br></p><p>- Dennis<br></p><p>&gt; On Jan 15, 2016, at 4:41 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt; <br>&gt; I had a similar idea in the early days of the mailing list before I knew it had a name. I don’t think it got much (any, really) discussion at the time: https://lists.swift.org/pipermail/swift-evolution/2015-December/000022.html<br>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 15, 2016, at 8:53 AM, Dennis Weissmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 15, 2016, at 1:56 PM, Haravikk &lt;swift-evolution at haravikk.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is pretty interesting; while the actual compile-time type-checking could be complex and take some time to implement, it seems to me that the actual notation could be implemented in advance and simply perform runtime assertions until the real type-checking is ready? In cases where the type-checker can’t be certain of a value’s safety, a run-time assertion might make sense anyway, so this short-term behaviour could actually be left in, with the caveat being that your restriction could still fail at run-time (which is what I think most people would want when the compile-time check isn’t enough).<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; That’s an interesting approach! I like it :)<br>&gt;&gt; <br>&gt;&gt;&gt; I’d be particularly interested in getting the notation available sooner if it&#39;s concise enough to make it worth using in place of current if statements. For example, it’d be nice if there were some shorthand for integers, as these seem like they’d be a particularly common use-case, for example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var @where(“0 &lt;= myVariable &lt;= 100”) myVariable = 42<br>&gt;&gt;&gt; var @where(“0 &lt;= $1 &lt;= 100) myVariable = 42<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Though personally I’d prefer something even more concise like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var myVariable(0…100) = 42<br>&gt;&gt;&gt; var myVariable:Int(0…100) = 42<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I don’t like the @where syntax too much either (but I don’t have the time right now to come up with a better, well-thought-out and practical syntax myself).<br>&gt;&gt; Here are just some quick thoughts:<br>&gt;&gt; <br>&gt;&gt; // Annotating the type<br>&gt;&gt; let value: Int&lt;1...100&gt; = 42                // Generics?<br>&gt;&gt; let value: Int(1...100) = 42                // Initializer?<br>&gt;&gt; let value: Int{1...100} = 42                // Scope?<br>&gt;&gt; let value: {value: Int | 1...100} = 42      // LiquidHaskell<br>&gt;&gt; let value: Int where Type == 1...100 = 42   // `where` already is a keyword that acts very similar (but at runtime)<br>&gt;&gt; <br>&gt;&gt; // Annotating the variable (the inferred type)<br>&gt;&gt; let value&lt;1...100&gt; = 42<br>&gt;&gt; let value(1...100) = 42<br>&gt;&gt; let value{1...100} = 42<br>&gt;&gt; let value{value: Int | 1...100} = 42<br>&gt;&gt; let value where Type == 1...100 = 42<br>&gt;&gt; <br>&gt;&gt; Even though it is more verbose, I like the last approach best. I think the common use-case is to predefine some very common ones (e.g. RGBA) in typealiases like so:<br>&gt;&gt; <br>&gt;&gt; typealias RGBAValue = Int where Type == 0...255<br>&gt;&gt; <br>&gt;&gt; This makes it much nicer (IMO) to declare (e.g.) functions. `UIColor` for example could gain an initializer taking values from 0 to 255:<br>&gt;&gt; <br>&gt;&gt; init(red: RGBAValue, green: RGBAValue, blue: RGBAValue, alpha: RGBAValue)<br>&gt;&gt; <br>&gt;&gt;&gt; Leaving the @where clause for more complex (i.e- non-numeric) cases. A really powerful alternative would be to allow us some mechanism to define how to handle restrictions in our classes and structs; these would be compiled first so that they can be executed by the type checker (which may limit what they can do) but could allow us full control of how they work. So, for example, an integer definition might look like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Int… {<br>&gt;&gt;&gt; 	...<br>&gt;&gt;&gt; 	restriction(range:Range&lt;Int&gt;) -&gt; Bool { return range.contains(self) }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; var myVariable(0…100) = 42<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; At run-time this would be equivalent to:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var myVariable = 42<br>&gt;&gt;&gt; assert(myVariable.restriction(0…100), “Value of myVariable is out of bounds [0…100]”)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With the idea being that in future the type-checker would call the restriction check, find 42 to be in range and omit the assertion entirely.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Just some thoughts, but the main thing for me is that this is something that I’d like to use a lot if implemented, so the more concise it can be, the better.<br>&gt;&gt;&gt; <br>&gt;&gt; Exactly :) If the type is precise enough the compiler can actually write (infer) a lot of your code)<br>&gt;&gt; <br>&gt;&gt;&gt; - Haravikk<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 15 Jan 2016, at 12:27, Dennis Weissmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 15, 2016, at 6:53 AM, Dave via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is the same thing as Refinement Types, right?<br>&gt;&gt;&gt;&gt;&gt; https://en.wikipedia.org/wiki/Refinement_(computing)#Refinement_types<br>&gt;&gt;&gt;&gt;&gt; http://goto.ucsd.edu/~rjhala/liquid/haskell/blog/blog/2013/01/01/refinement-types-101.lhs/<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, it seems they are. There is a pretty nice and easy to understand explanation [here](https://github.com/tomprimozic/type-systems/tree/master/refined_types):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Refined types or contracts are a restricted form of dependent types that combine base datatypes with logical predicates; for example, the type of natural numbers could be written x : int if x ≥ 0 (the notation most commonly used in academic literature is {ν : int | ν ≥ 0}).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’m in favor of it, but I think someone’s already made that suggestion… At the very least, I didn’t know what the phrase meant until a few days ago, and I know I learned about it from reading something on swift-evolution.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That was probably Matthew (https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/005925.html) or me (https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/005918.html) - the thread is called &#39;Proposal: named invariants for variable declarations&#39;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And I agree with Matthew that this won’t happen anytime soon. That’s why I didn’t want to discuss that topic too much. It’s just that the ABI will be finalized later this year and I wanted to mention that there is definitely interest in this area in case some ABI-related things are needed for refinement types (or even dependent types, someday, one can dream 😇) which need to be thought of before the finalization.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Dennis<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - Dave Sweeris<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 14, 2016, at 20:32, Suminda Dharmasena via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; E.g. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	• var @where(&quot;myVariable &lt;= 100 &amp;&amp; myVariable &gt;= 0&quot;) myVariable = 42<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	• @where(&quot;myVariable &lt;= 80 &amp;&amp; myVariable &gt;= 50&quot;)<br>&gt;&gt;&gt;&gt;&gt;&gt; 	• {<br>&gt;&gt;&gt;&gt;&gt;&gt; 	•     ...<br>&gt;&gt;&gt;&gt;&gt;&gt; 	• }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	• @where(&quot;score &lt;= 100 &amp;&amp; score &gt;= 0&quot;)<br>&gt;&gt;&gt;&gt;&gt;&gt; 	• for score in individualScores {<br>&gt;&gt;&gt;&gt;&gt;&gt; 	•     ...<br>&gt;&gt;&gt;&gt;&gt;&gt; 	• }<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160115/7500a171/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>Code Contracts</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>January 15, 2016 at 10:00:00am</p></header><div class="content"><p>The “where” keyword makes a lot of sense - I like it. I use “where” this way myself all over the place in for loops, etc, so it’s a pretty natural thing to imagine it showing up here, IMO. To me the most important aspect of this would be to ensure the compiler could (eventually) prove as many of them as possible at compile time and emit the appropriate warnings/errors.<br></p><p>I think this sort of idea would pair nicely with the “newtype” concept, but I have not been following that discussion and don’t know all of the details there. Perhaps something like:<br></p><p>newtype Scaler = Float where self &gt;= -1 &amp;&amp; self &lt;= 1<br></p><p>And that would create a new distinct type called Scaler that is based on Float but with those value ranges applied as a kind of contract where the compiler would attempt to ensure as much as it can at compile time, and when not possible, could insert precondition() checks appropriately to catch mistakes at runtime.<br></p><p>For example:<br></p><p>func scaleSomething(amount: Scalar) {<br>   var newAmount: Scalar = amount * 2	// allowed since it cannot prove this *always* violates the rule<br>   precondition(newAmount &gt;= -1 &amp;&amp; newAmount &lt;= 1)	// inserted by the compiler due to the ambiguity of previous line<br>   newAmount = amount + 5 		// ideally this is a compiler error since there’s no way this doesn’t violate the rules for Scalar<br>}<br></p><p>func doThing(val: Float) {<br>   precondition(val &gt;= -1 &amp;&amp; val &lt;= 1)	// inserted by the compiler because we’re “converting” a bare Float to a Scaler and we don’t know the value here<br>   scaleSomething(val)<br>}<br></p><p>let var: Float = 42<br>scaleSomething(val)		// compiler error since it can plainly see that 42 is not a valid scalar value<br></p><p>l8r<br>Sean<br></p><p><br>&gt; On Jan 15, 2016, at 10:30 AM, Dennis Weissmann &lt;dennis at dennisweissmann.me&gt; wrote:<br>&gt; <br>&gt; Hey Sean,<br>&gt; <br>&gt; + 1<br>&gt; <br>&gt; That’s indeed very similar, I must have overlooked your email in the flood of emails at the time.<br>&gt; <br>&gt; Especially<br>&gt; <br>&gt;&gt; I like the idea of this always being a compile-time check when possible, but it could also be useful to force the requirement to be evaluated at runtime by adding a force operator to it:<br>&gt;&gt; <br>&gt;&gt; func scale(x: Float in! 0…1) -&gt; Float {<br>&gt;&gt;   return someValue * x<br>&gt;&gt; }<br>&gt;&gt; In this scenario the compiler would probably still try to prove it statically - and if it could, it’d skip runtime checks - but if it cannot, it would then insert runtime guards that catch requirement failures and crash as necessary - similar to a forced unwrap - instead of being a compile time error.<br>&gt; <br>&gt; The reasons I think `in` isn’t the best choice for this keyword are<br>&gt; <br>&gt; - `in` already is a keyword with a totally different meaning<br>&gt; - a range is just an example of such a predicate, here are some examples (using the `Type` version of my last email, though I think the name doesn’t make much sense, we’re refining the type, yes, but the calculation in the predicate is applied to an instance of that type 🤔):<br>&gt;     typealias RGBAInt = Int where Type &gt;= 0 &amp;&amp; Type &lt;= 255                            // Can be rewritten as a range (0...255)<br>&gt;     typealias RGBADouble = Double where Type &gt;= 0 &amp;&amp; Type &lt;= 1.0                      // Can be rewritten as a range (0...1.0)<br>&gt;     typealias BatteryLevel = Int where Type &gt;= 0 &amp;&amp; Type &lt;= 100                       // Can be rewritten as a range (0...100)<br>&gt;     typealias Primes10 = Int where Type == 2 || Type == 3 || Type == 5 || Type == 7   // Cannot be rewritten as a range<br>&gt;     typealias EvenNumber = Int where Type % 2 == 0                                    // Cannot be rewritten as a range<br>&gt;   <br>&gt; What do you think?<br>&gt; <br>&gt; - Dennis<br>&gt; <br>&gt;&gt; On Jan 15, 2016, at 4:41 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I had a similar idea in the early days of the mailing list before I knew it had a name. I don’t think it got much (any, really) discussion at the time: https://lists.swift.org/pipermail/swift-evolution/2015-December/000022.html<br>&gt;&gt; <br>&gt;&gt; l8r<br>&gt;&gt; Sean<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 15, 2016, at 8:53 AM, Dennis Weissmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 15, 2016, at 1:56 PM, Haravikk &lt;swift-evolution at haravikk.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is pretty interesting; while the actual compile-time type-checking could be complex and take some time to implement, it seems to me that the actual notation could be implemented in advance and simply perform runtime assertions until the real type-checking is ready? In cases where the type-checker can’t be certain of a value’s safety, a run-time assertion might make sense anyway, so this short-term behaviour could actually be left in, with the caveat being that your restriction could still fail at run-time (which is what I think most people would want when the compile-time check isn’t enough).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That’s an interesting approach! I like it :)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’d be particularly interested in getting the notation available sooner if it&#39;s concise enough to make it worth using in place of current if statements. For example, it’d be nice if there were some shorthand for integers, as these seem like they’d be a particularly common use-case, for example:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var @where(“0 &lt;= myVariable &lt;= 100”) myVariable = 42<br>&gt;&gt;&gt;&gt; var @where(“0 &lt;= $1 &lt;= 100) myVariable = 42<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Though personally I’d prefer something even more concise like:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var myVariable(0…100) = 42<br>&gt;&gt;&gt;&gt; var myVariable:Int(0…100) = 42<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t like the @where syntax too much either (but I don’t have the time right now to come up with a better, well-thought-out and practical syntax myself).<br>&gt;&gt;&gt; Here are just some quick thoughts:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Annotating the type<br>&gt;&gt;&gt; let value: Int&lt;1...100&gt; = 42                // Generics?<br>&gt;&gt;&gt; let value: Int(1...100) = 42                // Initializer?<br>&gt;&gt;&gt; let value: Int{1...100} = 42                // Scope?<br>&gt;&gt;&gt; let value: {value: Int | 1...100} = 42      // LiquidHaskell<br>&gt;&gt;&gt; let value: Int where Type == 1...100 = 42   // `where` already is a keyword that acts very similar (but at runtime)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Annotating the variable (the inferred type)<br>&gt;&gt;&gt; let value&lt;1...100&gt; = 42<br>&gt;&gt;&gt; let value(1...100) = 42<br>&gt;&gt;&gt; let value{1...100} = 42<br>&gt;&gt;&gt; let value{value: Int | 1...100} = 42<br>&gt;&gt;&gt; let value where Type == 1...100 = 42<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Even though it is more verbose, I like the last approach best. I think the common use-case is to predefine some very common ones (e.g. RGBA) in typealiases like so:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; typealias RGBAValue = Int where Type == 0...255<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This makes it much nicer (IMO) to declare (e.g.) functions. `UIColor` for example could gain an initializer taking values from 0 to 255:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; init(red: RGBAValue, green: RGBAValue, blue: RGBAValue, alpha: RGBAValue)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Leaving the @where clause for more complex (i.e- non-numeric) cases. A really powerful alternative would be to allow us some mechanism to define how to handle restrictions in our classes and structs; these would be compiled first so that they can be executed by the type checker (which may limit what they can do) but could allow us full control of how they work. So, for example, an integer definition might look like:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct Int… {<br>&gt;&gt;&gt;&gt; 	...<br>&gt;&gt;&gt;&gt; 	restriction(range:Range&lt;Int&gt;) -&gt; Bool { return range.contains(self) }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; var myVariable(0…100) = 42<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; At run-time this would be equivalent to:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var myVariable = 42<br>&gt;&gt;&gt;&gt; assert(myVariable.restriction(0…100), “Value of myVariable is out of bounds [0…100]”)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; With the idea being that in future the type-checker would call the restriction check, find 42 to be in range and omit the assertion entirely.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Just some thoughts, but the main thing for me is that this is something that I’d like to use a lot if implemented, so the more concise it can be, the better.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; Exactly :) If the type is precise enough the compiler can actually write (infer) a lot of your code)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Haravikk<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 15 Jan 2016, at 12:27, Dennis Weissmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 15, 2016, at 6:53 AM, Dave via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This is the same thing as Refinement Types, right?<br>&gt;&gt;&gt;&gt;&gt;&gt; https://en.wikipedia.org/wiki/Refinement_(computing)#Refinement_types<br>&gt;&gt;&gt;&gt;&gt;&gt; http://goto.ucsd.edu/~rjhala/liquid/haskell/blog/blog/2013/01/01/refinement-types-101.lhs/<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yes, it seems they are. There is a pretty nice and easy to understand explanation [here](https://github.com/tomprimozic/type-systems/tree/master/refined_types):<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Refined types or contracts are a restricted form of dependent types that combine base datatypes with logical predicates; for example, the type of natural numbers could be written x : int if x ≥ 0 (the notation most commonly used in academic literature is {ν : int | ν ≥ 0}).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I’m in favor of it, but I think someone’s already made that suggestion… At the very least, I didn’t know what the phrase meant until a few days ago, and I know I learned about it from reading something on swift-evolution.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That was probably Matthew (https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/005925.html) or me (https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/005918.html) - the thread is called &#39;Proposal: named invariants for variable declarations&#39;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; And I agree with Matthew that this won’t happen anytime soon. That’s why I didn’t want to discuss that topic too much. It’s just that the ABI will be finalized later this year and I wanted to mention that there is definitely interest in this area in case some ABI-related things are needed for refinement types (or even dependent types, someday, one can dream 😇) which need to be thought of before the finalization.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - Dennis<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; - Dave Sweeris<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 14, 2016, at 20:32, Suminda Dharmasena via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; E.g. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	• var @where(&quot;myVariable &lt;= 100 &amp;&amp; myVariable &gt;= 0&quot;) myVariable = 42<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	• @where(&quot;myVariable &lt;= 80 &amp;&amp; myVariable &gt;= 50&quot;)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	• {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	•     ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	• }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	• @where(&quot;score &lt;= 100 &amp;&amp; score &gt;= 0&quot;)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	• for score in individualScores {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	•     ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	• }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2b19ddab2d7de4523412c875c258e278?s=50"></div><header><strong>Code Contracts</strong> from <string>Matt Whiteside</string> &lt;mwhiteside.dev at gmail.com&gt;<p>January 16, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt;&gt;&gt; On Jan 15, 2016, at 8:53 AM, Dennis Weissmann via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 15, 2016, at 1:56 PM, Haravikk &lt;swift-evolution at haravikk.com &lt;mailto:swift-evolution at haravikk.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is pretty interesting; while the actual compile-time type-checking could be complex and take some time to implement, it seems to me that the actual notation could be implemented in advance and simply perform runtime assertions until the real type-checking is ready? In cases where the type-checker can’t be certain of a value’s safety, a run-time assertion might make sense anyway, so this short-term behaviour could actually be left in, with the caveat being that your restriction could still fail at run-time (which is what I think most people would want when the compile-time check isn’t enough).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That’s an interesting approach! I like it :)<br></p><p>I agree this approach is interesting, and I’ve had similar thoughts.<br></p><p>Regarding your syntax idea,<br></p><p>&gt;     typealias RGBAInt = Int where Type &gt;= 0 &amp;&amp; Type &lt;= 255                            // Can be rewritten as a range (0...255)<br>&gt;     typealias RGBADouble = Double where Type &gt;= 0 &amp;&amp; Type &lt;= 1.0                      // Can be rewritten as a range (0...1.0)<br>&gt;     typealias BatteryLevel = Int where Type &gt;= 0 &amp;&amp; Type &lt;= 100                       // Can be rewritten as a range (0...100)<br>&gt;     typealias Primes10 = Int where Type == 2 || Type == 3 || Type == 5 || Type == 7   // Cannot be rewritten as a range<br>&gt;     typealias EvenNumber = Int where Type % 2 == 0                                    // Cannot be rewritten as a range<br>&gt;   <br>&gt; What do you think?<br>&gt; <br>&gt; - Dennis<br></p><p>I was discussing something like this on another thread, about compile time execution, and this is close to the syntax that I imagined.  The only thing I might suggest is that `typealias` doesn&#39;t seem like the ideal keyword here, since that is meant to indicate that the 2 types are one and the same.  These are some options that I thought might be good:<br></p><p>struct InvertibleMatrix: SquareMatrix where determinant() != 0 <br></p><p>typedef InvertibleMatrix = SquareMatrix where determinant() != 0 <br></p><p>typerefinement InvertibleMatrix = SquareMatrix where determinant() != 0 <br></p><p>Matt<br></p><p><br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160116/a11ef0ee/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>Code Contracts</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>January 16, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt;From what I understand of the goals of Swift, I think that any addition to<br>runtime machinery will be hard won. The Swift runtime is deliberately<br>small. I completely support refinement types and their logical conclusion<br>of dependent types but I don&#39;t think that the approach of &quot;runtime checking<br>until capable of compile time checking&quot; will gain much traction. I suggest<br>that we work primarily on creating a syntax so that, by the time that we<br>can implement it in the compiler, we have a truly compelling case.<br>TJ<br></p><p>On Sat, Jan 16, 2016 at 6:04 PM, Matt Whiteside via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Jan 15, 2016, at 8:53 AM, Dennis Weissmann via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Jan 15, 2016, at 1:56 PM, Haravikk &lt;swift-evolution at haravikk.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; This is pretty interesting; while the actual compile-time type-checking<br>&gt; could be complex and take some time to implement, it seems to me that the<br>&gt; actual notation could be implemented in advance and simply perform runtime<br>&gt; assertions until the real type-checking is ready? In cases where the<br>&gt; type-checker can’t be certain of a value’s safety, a run-time assertion<br>&gt; might make sense anyway, so this short-term behaviour could actually be<br>&gt; left in, with the caveat being that your restriction could still fail at<br>&gt; run-time (which is what I think most people would want when the<br>&gt; compile-time check isn’t enough).<br>&gt;<br>&gt;<br>&gt; That’s an interesting approach! I like it :)<br>&gt;<br>&gt;<br>&gt; I agree this approach is interesting, and I’ve had similar thoughts.<br>&gt;<br>&gt; Regarding your syntax idea,<br>&gt;<br>&gt;     typealias RGBAInt = Int where Type &gt;= 0 &amp;&amp; Type &lt;= 255<br>&gt;              // Can be rewritten as a range (0...255)<br>&gt;     typealias RGBADouble = Double where Type &gt;= 0 &amp;&amp; Type &lt;= 1.0<br>&gt;             // Can be rewritten as a range (0...1.0)<br>&gt;     typealias BatteryLevel = Int where Type &gt;= 0 &amp;&amp; Type &lt;= 100<br>&gt;             // Can be rewritten as a range (0...100)<br>&gt;     typealias Primes10 = Int where Type == 2 || Type == 3 || Type == 5 ||<br>&gt; Type == 7   // Cannot be rewritten as a range<br>&gt;     typealias EvenNumber = Int where Type % 2 == 0<br>&gt;             // Cannot be rewritten as a range<br>&gt;<br>&gt; What do you think?<br>&gt;<br>&gt; - Dennis<br>&gt;<br>&gt;<br>&gt; I was discussing something like this on another thread, about compile time<br>&gt; execution, and this is close to the syntax that I imagined.  The only thing<br>&gt; I might suggest is that `typealias` doesn&#39;t seem like the ideal keyword<br>&gt; here, since that is meant to indicate that the 2 types are one and the<br>&gt; same.  These are some options that I thought might be good:<br>&gt;<br>&gt; struct InvertibleMatrix: SquareMatrix where determinant() != 0<br>&gt;<br>&gt; typedef InvertibleMatrix = SquareMatrix where determinant() != 0<br>&gt;<br>&gt; typerefinement InvertibleMatrix = SquareMatrix where determinant() != 0<br>&gt;<br>&gt; Matt<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160116/8d341149/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
