<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Pitch] Richer function identifiers, simpler function types</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>April 28, 2016 at 01:00:00pm</p></header><div class="content"><p>This is another reaction to SE-0066 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0066-standardize-function-type-syntax.md&gt; to which I&#39;m mildly against.<br></p><p>I&#39;d like to propose the following language changes to simplify function types and clarify what a function&#39;s name is. What gets removed is already ambiguous. And what is added makes higher-level programming with functions considerably simpler than currently. Furthermore, the proposed change considerably limits what constitutes the overload set of a function, which probably also speeds up the compilation process.<br></p><p>Let&#39;s consider the following declarations:<br></p><p>    func foo()                       // #1 Function named &#39;foo(_)&#39; with type &#39;() -&gt; ()&#39;.<br>    func foo(x: Int) -&gt; Int          // #2 Function named &#39;foo(x:)&#39; with type &#39;Int -&gt; Int&#39; (not an overload).<br>    func foo(_ x: Int) -&gt; Int        // #3 Function named &#39;foo(_:)&#39; with type &#39;Int -&gt; Int&#39;<br>    func foo(_ x: (Int, Int)) -&gt; Int // #4 Function named &#39;foo(_:)&#39; with type &#39;(Int, Int) -&gt; Int&#39; (overload of #3).<br>    func foo(x: Int, y: Int) -&gt; Int  // #5 Function named &#39;foo(x:y:)&#39; with type &#39;(Int, Int) -&gt; Int&#39;.<br>    func foo(x: Int, y: Int) -&gt; Bool // #6 Function named &#39;foo(x:y:)&#39; with type &#39;(Int, Int) -&gt; Bool&#39; (overload of #5).<br>    let foo: Int                     // error: invalid redeclaration of &#39;foo&#39; (previously declared as a function)<br>    let baz: (Int, Int) -&gt; Int       // #7 Variable named &#39;baz&#39; with type &#39;(Int, Int) -&gt; Int&#39;.<br>    class Bar {<br>        func baz()                   // #8 Method named &#39;Bar.baz(_)&#39; with type &#39;Bar -&gt; () -&gt; ()&#39;.<br>        func baz(x y: Int)           // #9 Method named &#39;Bar.baz(x:)&#39; with type &#39;Bar -&gt; Int -&gt; ()&#39;.<br>        static func baz(x: Int = 0)  // #10 Static method named &#39;Bar.Self.baz(x:)&#39; with type &#39;Int -&gt; ()&#39;.<br>    }<br>    let f1 = foo                     // error: not a function reference, did you mean &#39;foo(_)&#39;?<br>    let f2 = foo as () -&gt; ()         // error: not a function reference, did you mean &#39;foo(_)&#39;?<br>    let f3 = foo(_)                  // #11 Function reference to #1. Has type &#39;() -&gt; ()&#39;.<br>    let f4 = foo(x:)                 // #12 Function reference to #2. Has type &#39;Int -&gt; Int&#39;.<br>    let f5 = foo(_:)                 // error: ambiguous function reference. Could be &#39;Int -&gt; Int&#39; or &#39;(Int, Int) -&gt; Int&#39;<br>    let f6 = foo(_:) as Int -&gt; Int   // #13 Function reference to #3. Has type &#39;Int -&gt; Int&#39;.<br>    let f7 = foo(_:) as (Int, Int) -&gt; Int // #14 Function reference to #4. Has type &#39;(Int, Int) -&gt; Int&#39;.<br>    let x1: Int = foo(x:y:)(1, 2)    // #15 Function application of #5. Picks the right overload by explicit return type.<br>    let x2: Bool = foo(x:y:)((1, 2)) // #16 Function application of #6. Allowing a tuple here causes no ambiguity.<br>    let f9 = baz                     // #17 Function reference synonymous to #7. Has type &#39;(Int, Int) -&gt; Int&#39;.<br>    let bar = Bar()<br>    let f10 = bar.baz                // error: not a function reference, did you mean &#39;bar.baz(_)&#39; or &#39;bar.baz(x:)&#39;?<br>    let f11 = bar.baz(_)             // #18 Function synonymous to the closure &#39;{ bar.baz() }&#39; with type &#39;() -&gt; ()&#39;.<br>    let f12 = bar.baz(x:)            // #19 Function synonymous to the closure &#39;{ bar.baz(x: $0) }&#39; with type &#39;Int -&gt; ()&#39;.<br>    let f13 = Bar.Self.baz(x:)       // #20 Function synonymous to the closure &#39;{ Bar.baz(x: $0) }&#39; with type &#39;Int -&gt; ()&#39;.<br>    let f14 = Bar.Self.baz(_)        // #21 Function synonymous to the closure &#39;{ Bar.baz() }&#39; with type &#39;() -&gt; ()&#39;.<br></p><p>The following list of proposed changes sum up what&#39;s new above.<br></p><p>C1: Extend SE-0021 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0021-generalized-naming.md&gt; by adding the underscore-in-parentheses syntax `foo(_)` to refer to the zero-argument function #1.<br></p><p>C2: Extend SE-0021 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0021-generalized-naming.md&gt; by removing the ambiguity between instance and type members. From now on, `Bar.baz(_)` <br></p><p>C3: Extend SE-0021 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0021-generalized-naming.md&gt; by banning the use of base name only to refer to a function, i.e. neither `foo` nor `Bar.baz` can be used to refer to refer to any of #1–#6 or #8–#10.<br></p><p>C4: Extend SE-0021 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0021-generalized-naming.md&gt; to allow the selective omission of defaulted arguments, e.g. `let f = print(_:separator:)` creates the function variable `f: (Any, String) -&gt; ()` equivalent to `{ print($0, separator: $1) }`.<br></p><p>C5: Clarify the language specification by stating that functions with different labels (e.g. `foo(_:)` vs. `foo(x:)`) are not overloads of each other. Instead, two functions are considered overloads of each other if only if they have matching base names (e.g. `foo`) and matching argument labels (e.g. `(x:y:)`) but differing argument or return types (e.g. #3 and #4, or #5 and #6).<br></p><p>C6: Clarify that by using the base name `foo` for a function, the same scope cannot define a variable with the name `foo`. And, vice versa, in a scope that defines a variable named `foo`, there can be no function `foo(...)` defined at the same scope level.<br></p><p>The implications are:<br></p><p>I1: The use of a function&#39;s base name to refer to a function will cease to work. It has, however, been buggy up to this date. Consider the following:<br></p><p>    let f = [Int].prefix // &#39;[Int] -&gt; Int -&gt; ArraySlice&lt;Int&gt;&#39;<br></p><p>    let g1 = [Int].dropFirst // Inexplicably chooses the &#39;[Int] -&gt; Int -&gt; ArraySlice&lt;Int&gt;&#39; overload!<br>    let g2 = [Int].dropFirst as [Int] -&gt; () -&gt; ArraySlice&lt;Int&gt; // Disambiguate by type.<br></p><p>    let h1 = [Int].sorted // Chooses the &#39;[Int] -&gt; () -&gt; [Int]&#39; overload, unlike &#39;dropFirst&#39; above.<br>    let h2 = [Int].sorted as [Int] -&gt; ((Int, Int) -&gt; Bool) -&gt; [Int] // Disambiguate by type.<br></p><p>With the proposed changes, the above becomes:<br></p><p>    let f = [Int].prefix(_:)     // &#39;[Int] -&gt; Int -&gt; ArraySlice&lt;Int&gt;&#39;<br></p><p>    let g1 = [Int].dropFirst(_:) // &#39;[Int] -&gt; Int -&gt; ArraySlice&lt;Int&gt;&#39;<br>    let g2 = [Int].dropFirst(_)  // &#39;[Int] -&gt; () -&gt; ArraySlice&lt;Int&gt;&#39;<br></p><p>    let h1 = [Int].sorted(_)                // &#39;[Int] -&gt; () -&gt; [Int]&#39;<br>    let h2 = [Int].sorted(isOrderedBefore:) // &#39;[Int] -&gt; ((Int, Int) -&gt; Bool) -&gt; [Int]&#39;<br></p><p>I2: When referring to functions the argument labels disappear in the returned function. That&#39;s a good thing because there&#39;s no generic way to call functions with arguments, and that&#39;s why closures too always come without argument labels. We don&#39;t, however, lose any clarity at the point where the function reference is passed as an argument because function references always contain the labels in the new notation. (Also, see the future directions for an idea how argument labels can be restored in the function variable.)<br></p><p>I3: Function argument lists are no longer that special and there&#39;s no need to notate single-n-tuple argument lists separately from n-argument functions, i.e. SE-0066 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0066-standardize-function-type-syntax.md&gt; is not really needed anymore. The new intuition here is that it&#39;s the function&#39;s name that defines how a function can be called, not its type.<br></p><p>I4: Because function variables cannot be overloaded, we can without ambiguity allow all of the following &quot;tuple splatting&quot;:<br></p><p>    let tuple1 = (1, 2)<br>    let tuple2 = (x: 1, y: 2)<br>    let tuple3 = (a: 1, b: 2)<br>    let y1 = foo(tuple1)       // Not a &quot;tuple splat&quot;, calls #4 as normal.<br>    let y2 = foo(tuple2)       // Not a &quot;tuple splat&quot;, calls #4 as normal.<br>    let y3 = foo(tuple3)       // Not a &quot;tuple splat&quot;, calls #4 as normal.<br>    let y4 = foo(_:)(1, 2)     // Not a &quot;tuple splat&quot;, calls the reference to #4 as normal.<br>    let y5 = foo(_:)((1, 2))   // &quot;Tuple splat&quot;, calls #4.<br>    let y6 = foo(_:)(((1, 2))) // &quot;Tuple splat&quot;, calls #4. Nothing special here, just an unnecessary pair of parens.<br>    let y7 = foo(_:)(tuple1)   // &quot;Tuple splat&quot;, calls #4.<br>    let y8 = foo(_:)(tuple2)   // &quot;Tuple splat&quot;, calls #4. The labelled tuple type is compatible with &#39;(Int, Int)&#39;.<br>    let z1 = foo(x:y:)(tuple1) as Int // &quot;Tuple splat&quot;, calls #5 because the return type is explicitly &#39;Int&#39;.<br>    let z2 = foo(x:y:)(tuple2) as Int // &quot;Tuple splat&quot;, calls #5. The labels don&#39;t really matter here.<br>    let z3 = foo(x:y:)(tuple3) as Int // &quot;Tuple splat&quot;, calls #5. Like above, any tuple labels are compatible in the call.<br>    let z4 = (foo(x:y:) as (Int, Int) -&gt; Bool)(tuple3) // Here&#39;s another way to explicitly pick up the overload.<br></p><p>Future directions<br></p><p>F1: In this proposal, I made a difference between function identifier names and variable identifier names. However, it could be well allowed to use function-like names for function variables when clarity is needed. Then calling a block would require the argument labels just like functions:<br></p><p>    let block(value:) = {value in ...}<br>    block(value: 1)<br></p><p>    func foo(_ isOrderedBefore(lhs:rhs:): (Int, Int) -&gt; Bool) {<br>        let x = isOrderedBefore(lhs: 1, rhs: 2)<br>    }<br></p><p>F2: The following idea probably divides opinions, but because function variables are unambiguous, we could even allow calling them without parentheses like in Haskell. That would open up many doors to currying and building highly composable functional libraries:<br></p><p>    let f = {x in ...}<br>    let y = f 1 // calls &#39;f&#39; with an &#39;Int&#39;<br>    let z = f (1, 2) // calls &#39;f&#39; with an &#39;(Int, Int)&#39;<br></p><p>F3: And if that was allowed, maybe it could be possible to define functions with variable-like names and currying too, but now I&#39;m getting too far. I think the proposal is worth considering even if we never go to the direction of Haskell in this way.<br></p><p>— Pyry<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160428/350fa906/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Pitch] Richer function identifiers, simpler function types</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>April 28, 2016 at 02:00:00pm</p></header><div class="content"><p>Corrections, additions below…<br></p><p>&gt; Let&#39;s consider the following declarations:<br>&gt; <br>&gt;     class Bar {<br>&gt;         func baz()                   // #8 Method named &#39;Bar.baz(_)&#39; with type &#39;Bar -&gt; () -&gt; ()&#39;.<br>&gt;         func baz(x y: Int)           // #9 Method named &#39;Bar.baz(x:)&#39; with type &#39;Bar -&gt; Int -&gt; ()&#39;.<br>&gt;         static func baz(x: Int = 0)  // #10 Static method named &#39;Bar.Self.baz(x:)&#39; with type &#39;Int -&gt; ()&#39;.<br>&gt;     }<br>&gt;     // ...<br>&gt;     let bar = Bar()<br>&gt;     let f10 = bar.baz                // error: not a function reference, did you mean &#39;bar.baz(_)&#39; or &#39;bar.baz(x:)&#39;?<br>&gt;     let f11 = bar.baz(_)             // #18 Function synonymous to the closure &#39;{ bar.baz() }&#39; with type &#39;() -&gt; ()&#39;.<br>&gt;     let f12 = bar.baz(x:)            // #19 Function synonymous to the closure &#39;{ bar.baz(x: $0) }&#39; with type &#39;Int -&gt; ()&#39;.<br>&gt;     let f13 = Bar.Self.baz(x:)       // #20 Function synonymous to the closure &#39;{ Bar.baz(x: $0) }&#39; with type &#39;Int -&gt; ()&#39;.<br>&gt;     let f14 = Bar.Self.baz(_)        // #21 Function synonymous to the closure &#39;{ Bar.baz() }&#39; with type &#39;() -&gt; ()&#39;.<br></p><p>(…)<br></p><p>&gt; C2: Extend SE-0021 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0021-generalized-naming.md&gt; by removing the ambiguity between instance and type members. From now on, `Bar.baz(_)` <br></p><p>That was meant to read:<br></p><p>&quot;(…) From now on, `Bar.baz(_)` unambiguously refers to the instance method named `baz(_)`. To refer to the static or class method named `baz(_)`, put the keyword `.Self` between the type and the base name. This syntax should align with the outcome of SE-0068 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0068-universal-self.md&gt; such the keyword resembles the static method call `thing.Self.baz()` of a `thing` of type `Bar`.&quot;<br></p><p>(Alternatives considered: (1) the use of `Bar.self.baz(_)` with lower-case `self`, which is probably more confusing; and (2) inverting the choice and making the instance method require a keyword instead, which would harm readability as it&#39;s usually the instance method that you&#39;d refer to and not the static one.)<br></p><p>&gt; C6: Clarify that by using the base name `foo` for a function, the same scope cannot define a variable with the name `foo`. And, vice versa, in a scope that defines a variable named `foo`, there can be no function `foo(...)` defined at the same scope level.<br></p><p>This doesn&#39;t prevent shadowing of course. E.g. An inner scope with a variable named `foo` would shadow all functions named `foo(...)` of an enclosing scope.<br></p><p>&gt; The implications are:<br>&gt; <br>&gt; I1: The use of a function&#39;s base name to refer to a function will cease to work. It has, however, been buggy up to this date. Consider the following:<br>&gt; <br>&gt;     let f = [Int].prefix // &#39;[Int] -&gt; Int -&gt; ArraySlice&lt;Int&gt;&#39;<br>&gt; <br>&gt;     let g1 = [Int].dropFirst // Inexplicably chooses the &#39;[Int] -&gt; Int -&gt; ArraySlice&lt;Int&gt;&#39; overload!<br>&gt;     let g2 = [Int].dropFirst as [Int] -&gt; () -&gt; ArraySlice&lt;Int&gt; // Disambiguate by type.<br>&gt; <br>&gt;     let h1 = [Int].sorted // Chooses the &#39;[Int] -&gt; () -&gt; [Int]&#39; overload, unlike &#39;dropFirst&#39; above.<br>&gt;     let h2 = [Int].sorted as [Int] -&gt; ((Int, Int) -&gt; Bool) -&gt; [Int] // Disambiguate by type.<br></p><p>By the way, the same also happens with the current Swift (both 2.2 and 3 master) when referring to the partially applied instance method like so:<br></p><p>    let xs = [1,3,2]<br>    let g = xs.dropFirst // Chooses the &#39;Int -&gt; ArraySlice&lt;Int&gt;&#39; overload.<br>    let h = xs.sorted    // Chooses the &#39;() -&gt; [Int]&#39; overload, unlike &#39;dropFirst&#39; above.<br></p><p>&gt; I3: Function argument lists are no longer that special and there&#39;s no need to notate single-n-tuple argument lists separately from n-argument functions, i.e. SE-0066 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0066-standardize-function-type-syntax.md&gt; is not really needed anymore. The new intuition here is that it&#39;s the function&#39;s name that defines how a function can be called, not its type.<br></p><p>In yet other words, we don&#39;t have to capture the arity of a function in the type system at all—it&#39;s enough to carry that information around in the function name.<br></p><p>~&gt;<br></p><p>Finally, this was a fairly technical pitch but a pitch anyway. Any ideas pro or against?<br></p><p>— Pyry<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160428/ecb01a5b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Pitch] Richer function identifiers, simpler function types</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>April 28, 2016 at 01:00:00pm</p></header><div class="content"><p>Although SE-0021 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0021-generalized-naming.md&gt; has a good goal, I don&#39;t like the details due to the use of parenthesis:<br>I&#39;d prefer to keep them limited to actual function calls.<br>But most of the time, it would be possible to avoid ambiguity and keep the simpler syntax; this would be eliminated with you proposal, so I&#39;m against it  (SE-0021 would only be needed in situations that can&#39;t be solved with the old form).<br></p><p>&gt; C1: Extend SE-0021 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0021-generalized-naming.md&gt; by adding the underscore-in-parentheses syntax `foo(_)` to refer to the zero-argument function #1.<br>I don&#39;t think that&#39;s consistent with the other use cases of the underscore: Afair, it never means &quot;nothing&quot;, but always &quot;there is something, but ignore it&quot;<br></p><p>Additionally, I think it would be nice to have a clean way to avoid all ambiguities when referring to a function be specifying all involved types, so unless I didn&#39;t miss any downsides of using square brackets, my favorite would look like<br></p><p>&gt;     func foo()                       // #1 Function named &#39;foo(_)&#39; with type &#39;() -&gt; ()&#39;.<br>let f = foo<br></p><p>&gt;     func foo(x: Int) -&gt; Int          // #2 Function named &#39;foo(x:)&#39; with type &#39;Int -&gt; Int&#39; (not an overload).<br>let f = foo[x: Int]<br></p><p>&gt;     func foo(_ x: Int) -&gt; Int        // #3 Function named &#39;foo(_:)&#39; with type &#39;Int -&gt; Int&#39;<br>let f = foo[Int]<br></p><p>&gt;     func foo(_ x: (Int, Int)) -&gt; Int // #4 Function named &#39;foo(_:)&#39; with type &#39;(Int, Int) -&gt; Int&#39; (overload of #3).<br>let f = foo[(Int, Int)]<br></p><p>&gt;     func foo(x: Int, y: Int) -&gt; Int  // #5 Function named &#39;foo(x:y:)&#39; with type &#39;(Int, Int) -&gt; Int&#39;.<br>let f = foo[x: Int, y: Int]<br></p><p>&gt;     func foo(x: Int, y: Int) -&gt; Bool // #6 Function named &#39;foo(x:y:)&#39; with type &#39;(Int, Int) -&gt; Bool&#39; (overload of #5).<br>let f = foo[x: Int, y: Int]<br></p><p>Ideally, it should be possible to specify the return type as well… but there are so many syntax options for this, and I don&#39;t see a natural choice...<br>let f = foo:Bool[x: Int, y: Int]<br>let f = foo-&gt;Bool[x: Int, y: Int]<br>let f = foo[x: Int, y: Int; Bool]<br>let f = foo[x: Int, y: Int]-&gt;Bool<br></p><p>Tino<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160428/1767f975/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Pitch] Richer function identifiers, simpler function types</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>April 28, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On 28 Apr 2016, at 14:37, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; <br>&gt;&gt; C1: Extend SE-0021 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0021-generalized-naming.md&gt; by adding the underscore-in-parentheses syntax `foo(_)` to refer to the zero-argument function #1.<br>&gt; I don&#39;t think that&#39;s consistent with the other use cases of the underscore: Afair, it never means &quot;nothing&quot;, but always &quot;there is something, but ignore it&quot;<br></p><p>Right, that was another choice I forgot to justify:<br></p><p>We already refer to `func foo(_ x: Int, _ y: Int)` as `foo(_:_:)` even if the function call only contains a comma and no colons nor underscores. Yes, `func foo()` neither has an underscore in the definition. But we need something to distinguish its from the function call `foo()`, so `foo(_)` is an honest attempt to stick to the existing SE-0021 practice.<br></p><p>Personally, I&#39;m fine with the syntax introduced by SE-0021 and I&#39;d rather keep its criticism out of this thread if possible.<br></p><p>However, we could consider the alternative that you proposed where `foo` alone may only refer to the zero-argument function and for everything else, the argument list is always required.<br></p><p>&gt; (…) so unless I didn&#39;t miss any downsides of using square brackets, (…)<br>&gt; <br>&gt; let f = foo<br>&gt; let f = foo[x: Int]<br>&gt; let f = foo[Int]<br>&gt; let f = foo[(Int, Int)]<br>&gt; let f = foo[x: Int, y: Int]<br>&gt; let f = foo[x: Int, y: Int]<br></p><p>The square brackets do avoid the ambiguity too but FWIW, they look foreign to me. It&#39;s also pretty noisy having to spell out all the argument types (unless you meant that it&#39;s optional doing so). In the majority of cases, there is no overloading by type, or if there is then the type can be inferred at the point of use.<br></p><p>— Pyry<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160428/ce243f87/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9ae1f2ed10d2ef77cce06bbb5a2dcf7e?s=50"></div><header><strong>[Pitch] Richer function identifiers, simpler function types</strong> from <string>Alex Hoppen</string> &lt;alex at ateamer.de&gt;<p>May  4, 2016 at 04:00:00pm</p></header><div class="content"><p>Sorry for answering this late, but I think this is a great proposal and would like to see especially the `foo(_)` syntax up for review, as it came up twice already while Doug Gregor and I discussed the implementation of getters and setters for #selector (here &lt;https://bugs.swift.org/browse/SR-1239?focusedCommentId=13980&amp;#comment-13980&gt; and here &lt;https://github.com/apple/swift-evolution/pull/280&gt;) and the upcoming proposal for disallowing arbitrary expressions inside #selector (Link to proposal &lt;https://github.com/ahoppen/swift-evolution/blob/arbitrary-expressions-in-selectors/proposals/0000-arbitrary-expressions-in-selectors.md&gt;). I think not being able to reference an overloaded method without parameters without using `as` to disambiguate by type is a major hole in the type system. <br></p><p>Some comments inline. <br></p><p>&gt; This is another reaction to SE-0066 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0066-standardize-function-type-syntax.md&gt; to which I&#39;m mildly against.<br>&gt; <br>&gt; I&#39;d like to propose the following language changes to simplify function types and clarify what a function&#39;s name is. What gets removed is already ambiguous. And what is added makes higher-level programming with functions considerably simpler than currently. Furthermore, the proposed change considerably limits what constitutes the overload set of a function, which probably also speeds up the compilation process.<br>&gt; <br>&gt; Let&#39;s consider the following declarations:<br>&gt; <br>&gt;     func foo()                       // #1 Function named &#39;foo(_)&#39; with type &#39;() -&gt; ()&#39;.<br>&gt;     func foo(x: Int) -&gt; Int          // #2 Function named &#39;foo(x:)&#39; with type &#39;Int -&gt; Int&#39; (not an overload).<br>&gt;     func foo(_ x: Int) -&gt; Int        // #3 Function named &#39;foo(_:)&#39; with type &#39;Int -&gt; Int&#39;<br>&gt;     func foo(_ x: (Int, Int)) -&gt; Int // #4 Function named &#39;foo(_:)&#39; with type &#39;(Int, Int) -&gt; Int&#39; (overload of #3).<br>&gt;     func foo(x: Int, y: Int) -&gt; Int  // #5 Function named &#39;foo(x:y:)&#39; with type &#39;(Int, Int) -&gt; Int&#39;.<br>&gt;     func foo(x: Int, y: Int) -&gt; Bool // #6 Function named &#39;foo(x:y:)&#39; with type &#39;(Int, Int) -&gt; Bool&#39; (overload of #5).<br>&gt;     let foo: Int                     // error: invalid redeclaration of &#39;foo&#39; (previously declared as a function)<br>&gt;     let baz: (Int, Int) -&gt; Int       // #7 Variable named &#39;baz&#39; with type &#39;(Int, Int) -&gt; Int&#39;.<br>&gt;     class Bar {<br>&gt;         func baz()                   // #8 Method named &#39;Bar.baz(_)&#39; with type &#39;Bar -&gt; () -&gt; ()&#39;.<br>&gt;         func baz(x y: Int)           // #9 Method named &#39;Bar.baz(x:)&#39; with type &#39;Bar -&gt; Int -&gt; ()&#39;.<br>&gt;         static func baz(x: Int = 0)  // #10 Static method named &#39;Bar.Self.baz(x:)&#39; with type &#39;Int -&gt; ()&#39;.<br>&gt;     }<br>&gt;     let f1 = foo                     // error: not a function reference, did you mean &#39;foo(_)&#39;?<br>&gt;     let f2 = foo as () -&gt; ()         // error: not a function reference, did you mean &#39;foo(_)&#39;?<br>&gt;     let f3 = foo(_)                  // #11 Function reference to #1. Has type &#39;() -&gt; ()&#39;.<br>&gt;     let f4 = foo(x:)                 // #12 Function reference to #2. Has type &#39;Int -&gt; Int&#39;.<br>&gt;     let f5 = foo(_:)                 // error: ambiguous function reference. Could be &#39;Int -&gt; Int&#39; or &#39;(Int, Int) -&gt; Int&#39;<br>&gt;     let f6 = foo(_:) as Int -&gt; Int   // #13 Function reference to #3. Has type &#39;Int -&gt; Int&#39;.<br>&gt;     let f7 = foo(_:) as (Int, Int) -&gt; Int // #14 Function reference to #4. Has type &#39;(Int, Int) -&gt; Int&#39;.<br>&gt;     let x1: Int = foo(x:y:)(1, 2)    // #15 Function application of #5. Picks the right overload by explicit return type.<br>&gt;     let x2: Bool = foo(x:y:)((1, 2)) // #16 Function application of #6. Allowing a tuple here causes no ambiguity.<br>&gt;     let f9 = baz                     // #17 Function reference synonymous to #7. Has type &#39;(Int, Int) -&gt; Int&#39;.<br>&gt;     let bar = Bar()<br>&gt;     let f10 = bar.baz                // error: not a function reference, did you mean &#39;bar.baz(_)&#39; or &#39;bar.baz(x:)&#39;?<br>&gt;     let f11 = bar.baz(_)             // #18 Function synonymous to the closure &#39;{ bar.baz() }&#39; with type &#39;() -&gt; ()&#39;.<br>&gt;     let f12 = bar.baz(x:)            // #19 Function synonymous to the closure &#39;{ bar.baz(x: $0) }&#39; with type &#39;Int -&gt; ()&#39;.<br>&gt;     let f13 = Bar.Self.baz(x:)       // #20 Function synonymous to the closure &#39;{ Bar.baz(x: $0) }&#39; with type &#39;Int -&gt; ()&#39;.<br>&gt;     let f14 = Bar.Self.baz(_)        // #21 Function synonymous to the closure &#39;{ Bar.baz() }&#39; with type &#39;() -&gt; ()&#39;.<br>&gt; <br>&gt; The following list of proposed changes sum up what&#39;s new above.<br>&gt; <br>&gt; C1: Extend SE-0021 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0021-generalized-naming.md&gt; by adding the underscore-in-parentheses syntax `foo(_)` to refer to the zero-argument function #1.<br></p><p>A huge +10 on this one as it stands. I think in the context of functions the underscore already has a meaning of &quot;there is nothing&quot; as in the parameter names. The only possible issue I see is whether we may end up in a conflict should we ever decide for functions to have out-only parameters that you may ignore by passing &quot;_&quot; as argument. But I don&#39;t see this coming. Only opinions from the core team?<br></p><p>&gt; C2: Extend SE-0021 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0021-generalized-naming.md&gt; by removing the ambiguity between instance and type members. From now on, `Bar.baz(_)` <br></p><p>I’m slightly opposed to this one. I, for my part, would expect `Bar.baz(_)` to refer to the static function instead of `Bar`, since nothing in this name suggests a instance methods. The fact that you can access instance methods on a type as `(Type) -&gt; (Args) -&gt; ReturnValue` has always seem more like magic to me.<br></p><p>&gt; C3: Extend SE-0021 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0021-generalized-naming.md&gt; by banning the use of base name only to refer to a function, i.e. neither `foo` nor `Bar.baz` can be used to refer to refer to any of #1–#6 or #8–#10.<br></p><p>I think this is largely impacted by the future direction of Swift on whether argument names are counted as part of a function’s name or not. I think they currently aren’t but if I recall correctly there are thought to change this. If this is the case, removing the option to use `foo` to refer to `foo(x:)` or `foo(_)` would only make sense from my point of view and should be done in the Swift 3 timeframe as a source breaking change. Otherwise I see no point in removing the option to reference a method by its base name, because technically speaking, it’s simply its name. <br>Could maybe someone of the core team comment on the future direction, Swift should take?<br></p><p>&gt; C4: Extend SE-0021 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0021-generalized-naming.md&gt; to allow the selective omission of defaulted arguments, e.g. `let f = print(_:separator:)` creates the function variable `f: (Any, String) -&gt; ()` equivalent to `{ print($0, separator: $1) }`.<br></p><p>Sounds very reasonable to me. Especially, I think the idea of creating a new function that simply forwards to the original function solves the problem of handling unspecified default parameters very elegantly. <br>At first I was worried about the additional indirection and its potential performance implications, but functions with default parameters already dispatch another function call for each argument anyway, so this shouldn’t be a problem.<br></p><p>&gt; C5: Clarify the language specification by stating that functions with different labels (e.g. `foo(_:)` vs. `foo(x:)`) are not overloads of each other. Instead, two functions are considered overloads of each other if only if they have matching base names (e.g. `foo`) and matching argument labels (e.g. `(x:y:)`) but differing argument or return types (e.g. #3 and #4, or #5 and #6).<br></p><p>AFAIK, currently they are. See my comment on C3 for this.<br></p><p>&gt; C6: Clarify that by using the base name `foo` for a function, the same scope cannot define a variable with the name `foo`. And, vice versa, in a scope that defines a variable named `foo`, there can be no function `foo(...)` defined at the same scope level.<br></p><p>Again implied by the decision on whether arguments (and their names) are counted as part of the function’s signature or not.<br></p><p>&gt; The implications are:<br>&gt; <br>&gt; I1: The use of a function&#39;s base name to refer to a function will cease to work. It has, however, been buggy up to this date. Consider the following:<br>&gt; <br>&gt;     let f = [Int].prefix // &#39;[Int] -&gt; Int -&gt; ArraySlice&lt;Int&gt;&#39;<br>&gt; <br>&gt;     let g1 = [Int].dropFirst // Inexplicably chooses the &#39;[Int] -&gt; Int -&gt; ArraySlice&lt;Int&gt;&#39; overload!<br>&gt;     let g2 = [Int].dropFirst as [Int] -&gt; () -&gt; ArraySlice&lt;Int&gt; // Disambiguate by type.<br>&gt; <br>&gt;     let h1 = [Int].sorted // Chooses the &#39;[Int] -&gt; () -&gt; [Int]&#39; overload, unlike &#39;dropFirst&#39; above.<br>&gt;     let h2 = [Int].sorted as [Int] -&gt; ((Int, Int) -&gt; Bool) -&gt; [Int] // Disambiguate by type.<br>&gt; <br>&gt; With the proposed changes, the above becomes:<br>&gt; <br>&gt;     let f = [Int].prefix(_:)     // &#39;[Int] -&gt; Int -&gt; ArraySlice&lt;Int&gt;&#39;<br>&gt; <br>&gt;     let g1 = [Int].dropFirst(_:) // &#39;[Int] -&gt; Int -&gt; ArraySlice&lt;Int&gt;&#39;<br>&gt;     let g2 = [Int].dropFirst(_)  // &#39;[Int] -&gt; () -&gt; ArraySlice&lt;Int&gt;&#39;<br>&gt; <br>&gt;     let h1 = [Int].sorted(_)                // &#39;[Int] -&gt; () -&gt; [Int]&#39;<br>&gt;     let h2 = [Int].sorted(isOrderedBefore:) // &#39;[Int] -&gt; ((Int, Int) -&gt; Bool) -&gt; [Int]&#39;<br>&gt; <br>&gt; I2: When referring to functions the argument labels disappear in the returned function. That&#39;s a good thing because there&#39;s no generic way to call functions with arguments, and that&#39;s why closures too always come without argument labels. We don&#39;t, however, lose any clarity at the point where the function reference is passed as an argument because function references always contain the labels in the new notation. (Also, see the future directions for an idea how argument labels can be restored in the function variable.)<br></p><p>I can’t really see where this implication comes from and I’m strongly against it. I wouldn’t expect value of a variable to change just because I assign it to a new variable. Neither would I want my function’s signature to change just because I assign the function to another variable. <br>I rather think that it’s a missing feature that closures cannot have named arguments, but that’s orthogonal to this proposal.<br></p><p>&gt; I3: Function argument lists are no longer that special and there&#39;s no need to notate single-n-tuple argument lists separately from n-argument functions, i.e. SE-0066 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0066-standardize-function-type-syntax.md&gt; is not really needed anymore. The new intuition here is that it&#39;s the function&#39;s name that defines how a function can be called, not its type.<br>&gt; <br>&gt; I4: Because function variables cannot be overloaded, we can without ambiguity allow all of the following &quot;tuple splatting&quot;:<br>&gt; <br>&gt;     let tuple1 = (1, 2)<br>&gt;     let tuple2 = (x: 1, y: 2)<br>&gt;     let tuple3 = (a: 1, b: 2)<br>&gt;     let y1 = foo(tuple1)       // Not a &quot;tuple splat&quot;, calls #4 as normal.<br>&gt;     let y2 = foo(tuple2)       // Not a &quot;tuple splat&quot;, calls #4 as normal.<br>&gt;     let y3 = foo(tuple3)       // Not a &quot;tuple splat&quot;, calls #4 as normal.<br>&gt;     let y4 = foo(_:)(1, 2)     // Not a &quot;tuple splat&quot;, calls the reference to #4 as normal.<br>&gt;     let y5 = foo(_:)((1, 2))   // &quot;Tuple splat&quot;, calls #4.<br>&gt;     let y6 = foo(_:)(((1, 2))) // &quot;Tuple splat&quot;, calls #4. Nothing special here, just an unnecessary pair of parens.<br>&gt;     let y7 = foo(_:)(tuple1)   // &quot;Tuple splat&quot;, calls #4.<br>&gt;     let y8 = foo(_:)(tuple2)   // &quot;Tuple splat&quot;, calls #4. The labelled tuple type is compatible with &#39;(Int, Int)&#39;.<br>&gt;     let z1 = foo(x:y:)(tuple1) as Int // &quot;Tuple splat&quot;, calls #5 because the return type is explicitly &#39;Int&#39;.<br>&gt;     let z2 = foo(x:y:)(tuple2) as Int // &quot;Tuple splat&quot;, calls #5. The labels don&#39;t really matter here.<br>&gt;     let z3 = foo(x:y:)(tuple3) as Int // &quot;Tuple splat&quot;, calls #5. Like above, any tuple labels are compatible in the call.<br>&gt;     let z4 = (foo(x:y:) as (Int, Int) -&gt; Bool)(tuple3) // Here&#39;s another way to explicitly pick up the overload.<br></p><p>All function arguments used to be one tuple, but it turned out that certain features (inout params and varargs, if i recall correctly) cannot be handled if a function is considered as only taking one tuple as an argument. Tuple splatting was removed because it didn’t fit into the language naturally anymore.<br></p><p>– Alex<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160504/9966569a/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
