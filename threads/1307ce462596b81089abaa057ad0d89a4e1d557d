<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Bike-shedding alternate collections API</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>March 24, 2016 at 06:00:00pm</p></header><div class="content"><p>Bike-shedding alternate collections API - cut down to keep them short enough to post.<br></p><p>They differ from the current collections API and the new proposed collections API in that:<br>They use the existing external iterator, `iterator.next()`, rather than the proposed style, `iterator.next(&amp;i)`, because the new style ties the iterator to a particular collection type and therefore cannot be type erased. Type erasure is required to keep return types generic, e.g. rather than map returning an Array it returns an `AnyNextorable&lt;Element&gt;` (see point 5 below).<br>The protocols are not, in general, heirarchical; instead they are small building blocks at the top level that can be fitted together.<br>Protocols are split when a good default implementation cannot be provided, e.g. CountableCollection is seperate because the default of iterating and counting the elements is not a good implimentation of count.<br>Hierarchies are used for convenience, e.g. ArrayCollection is a convenience protocol that extends base protocols.<br>The protocol member&#39;s return generic implementations of protocols, e.g. where you might return an Array instead you return an `AnyNextorable&lt;Element&gt;`. This sidesteps issues with associated types and generics and prevents large type signatures. The downside is that you have comitted to a particular interface and therefore lost covariance. When generics are completed hopefully these return types can be replaced with `Any&lt;... where ...&gt;`, e.g. `Any&lt;Nextorable where Element == Element&gt;`<br>LazyNextable is split out seperately so that the semantics of lazy are articulated in the type system. The design of LazyNextable is also compatible with adding ParallelLazyNextable in the future.<br>The naming of the protocols is one of:<br>Xxxable because it is a main behavioural protocol and its main member is xxx, e.g. Nextorable has a main property nextor.<br>If in the rare case that a protocol extends another protocol then the new property is prepended, e.g. MutableSubstriptable extends Substriptable and the main method added is mutable subscripting.<br>If they don&#39;t have a main member then they are named after what they are used for, e.g. ArrayCollection defines the members of Array like collections. Note name format of XxxCollection.<br>AnyXxxx is a type erased implimentation of Xxx, e.g. AnyLazyNextable is an erased LazyNextable.<br>Xxxee and xxxee is used for the subject of an action, e.g. Rangee is a collection of methods that a type must impliment to be used in a Range.<br>Range has an Int index of 0 to count - 1 and a value of start + index * stride, where start and stride are of type Rangee. Int and Double via extension are made Rangees.<br>Index, used in Subscriptables, can be any type.<br></p><p><br>The main protocols that define what a collection is are:<br></p><p><br>/// Mutable, potentially infinite, and multiply traversable (because nextor is non-mutating) collection.<br>protocol Nextorable {<br>    associatedtype Element<br>    <br>    /// Give a new nextable for iterating through the collection.<br>    /// The collection can be iterated multiple times and therefore each Nextable must contain its own state.<br>    var nextor: AnyNextable&lt;Element&gt; { get }<br>    <br>    /// View this collection as a LazyNextable.<br>    /// If the collection changes then the view may or may not change, it depends upon the semantics of the collection.<br>    /// Default implementation provided.<br>    var asLazy: AnyLazyNextable&lt;Element&gt; { get }<br>    <br>    /// Note how the map&#39;s return type is a protocol not a specific type.<br>    /// Default implementation provided.<br>    @warn_unused_result func map&lt;Mapped&gt;(@noescape mapper: (Element) throws -&gt; Mapped) rethrows -&gt; AnyNextorable&lt;Mapped&gt;<br>    <br>    /// Default implementation provided for IterableCollections.<br>    func forEach(@noescape eacher: (Element) throws -&gt; Void) rethrows<br>    <br>    /// View this Nextorable as an AnyNextorable.<br>    /// Default implementation provided.<br>    var asNextorable: AnyNextorable&lt;Element&gt; { get }<br>}<br></p><p>/// Protocol that allows a sequence of elements to be iterated from a collection or generated anew by calling the next method.<br>protocol Nextable {<br>    associatedtype Element<br></p><p>    /// Gives the next element in a collection or generates a new element (if used as a generator), if there is one.<br>    /// A return of nil, mean no more elements.<br>    /// If the collection underlying the Nextable isn&#39;t modified and if this Nextable has returned nil it should continue to return nil.<br>    /// If the collection underlying the Nextable is modified whilst iterating; next can return a previous value that was in the collection, can skip some or all values, or can repeat values, but should still ultimate terminate when called repeatedly and return nil.<br>    /// Even if next has returned nil, if the underlting collection is modified it could return values again.<br>    @warn_unused_result mutating func next() -&gt; Element?<br>    <br>    /// View this Nextable as an AnyNextable.<br>    /// Default implementation provided.<br>    @warn_unused_result mutating func asNextable() -&gt; AnyNextable&lt;Element&gt;<br>}<br></p><p>/// Thrown by the next function in a LazyNextable collection to indicate the end of the collection.<br>/// LazyNext.end can also be thrown to act like a break in a for loop.<br>enum LazyNext: ErrorType {<br>    case end<br>}<br></p><p>/// An immutable, potentially infinite, and singley traversable collection that is evaluated lazily.<br>/// The internal iterator is exposed via next, so that something external may control the iteration.<br>protocol LazyNextable {<br>    associatedtype Element<br>    <br>    /// Eagerly gives the next element in the lazy collection.<br>    /// A throw of LazyNext.end means no more elements.<br>    /// If the LazyNextable isn&#39;t modified and it has thrown LazyNext.end it should continue to thrown LazyNext.end.<br>    /// If the LazyNextable is modified whilst iterating; next can return a previous value that was in the collection, can skip some or all values, or can repeat values, but should still ultimate terminate when called repeatedly and throw LazyNext.end.<br>    /// Even if next has thrown LazyNext.end, if the collection is modified it could return values again.<br>    @warn_unused_result mutating func next() throws -&gt; Element<br>    <br>    /// Maps all the remaining elements of the collection lazily.<br>    /// See next for semantics in the face of mutation of the underlying collection.<br>    /// The returned LazyNextable typically modifies self, hence this function is mutating<br>    /// Default implementation provided.<br>    @warn_unused_result mutating func map&lt;Mapped&gt;(mapper: (Element) throws -&gt; Mapped) -&gt; AnyLazyNextable&lt;Mapped&gt;<br>    <br>    /// Applies the eacher eagerly to all the remaining elements in the collection.<br>    /// Note: a mutating function since it forces evaluation of the colection, it is eager.<br>    /// See next for semantics in the face of mutation of the underlying collection.<br>    /// Default implementation provided.<br>    mutating func forEach(@noescape eacher: (Element) throws -&gt; Void)<br>    <br>    /// View into this collection wrapped in an AnyLazyNextable.<br>    /// Note it is a mutating func because the LazyNextable returned can mutate this LazyNextable (self).<br>    /// Default implementation provided.<br>    @warn_unused_result mutating func asNextable() -&gt; AnyLazyNextable&lt;Element&gt;<br>}<br></p><p>protocol Subscriptable {<br>    associatedtype Element<br>    associatedtype Index<br>    var firstIndex: Index { get }<br>    var lastIndex: Index { get }<br>    subscript(index: Index) -&gt; Element { get }<br>    <br>    /// Provides a lazy view into this collection; mapping the indices.<br>    /// It provides a collection whose subscript(Index) is `self[range[index]]`.<br>    /// If self or range change then this view changes.<br>    /// Ideally you could specify a generic argument for subscript range, but in Swift 2.1 you can&#39;t :(;<br>    /// something like, `subscript&lt;S: SubscriptableCollection where S.Element = Index&gt;(range: S) -&gt; Subscriptable&lt;Element, S.Index&gt; { get }`.<br>    /// To partially compensate use `asSubscriptable` as in `self[range.asSubsctiptable]`.<br>    /// This only partially compensates because the range argument is `AnySubscriptable&lt;Index, Index&gt;`, not `AnySubscriptable&lt;Index, NewIndex&gt;` and hence the return type is `AnySubscriptable&lt;Element, Index&gt;` not `AnySubscriptable&lt;Element, NewIndex&gt;`.<br>    /// Default implementation provided.<br>    subscript(range: AnySubscriptable&lt;Index, Index&gt;) -&gt; AnySubscriptable&lt;Element, Index&gt; { get }<br>    <br>    /// View as a type erased Subscriptable.<br>    /// Default implementation provided.<br>    var asSubscriptable: AnySubscriptable&lt;Element, Index&gt; { get }<br>}<br></p><p>/// A SubscriptableCollection that also allows subscripts to mutate self.<br>protocol MutableSubscriptableCollection: Subscriptable {<br>    // `sets` commented out because of compiler issues in Xcode 7.3<br>    subscript(index: Index) -&gt; Element { get /*set*/ }<br>    subscript(range: AnySubscriptable&lt;Index, Index&gt;) -&gt; AnyMutableSubscriptable&lt;Element, Index&gt; { get /*set*/ }<br>    var asMutableSubscriptable: AnyMutableSubscriptable&lt;Element, Index&gt; { get }<br>}<br></p><p>/// Provide the capabilities needed to impliment Range.<br>/// Ranges are indexed with an Int index between 0 and count - 1 inclusive and they return start + index * stride, where start and stride are Rangees.<br>/// Via extensions Int and Double are Rangees.<br>protocol Rangee {<br>    /// self += rhs<br>    mutating func add(rhs: Self)<br>    <br>    /// self -= rhs<br>    mutating func sub(rhs: Self)<br>    <br>    /// self *= rhs<br>    mutating func mult(rhs: Self)<br>    <br>    /// self /= rhs<br>    mutating func div(rhs: Self)<br>    <br>    /// Converts to an Int, truncating towards 0 if necessary<br>    var toInt: Int { get }<br>    <br>    /// Convert from an int, fails if the int is not representable<br>    static func fromInt(i: Int) -&gt; Self<br>}<br></p><p><br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/1307557d/attachment-0001.html&gt;<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
