<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Option parameters (potential resilience advantages)</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 28, 2015 at 10:00:00am</p></header><div class="content"><p>I&#39;ve had an idea floating around in my mind for a couple weeks now and would like to find out what others think about it.<br></p><p>The basic idea is really simple.  It introduces an `@option` parameter attribute.  Parameters with this attribute would behave like parameters with a default value at the call site, however they would not actually have a default value.  Instead, the argument seen in the body would be an optional of the type of the parameter value.<br></p><p>func foo(@option value: Int) {<br>	// value has type Int? in the body of the function<br>	let valueToUse = value ?? 42<br>}<br></p><p>At first glance it probably seems like this is of no value.  Why not just declare `value: Int? = nil`.  Obviously it must bring something to the table to be worth considering.<br></p><p>This idea first occurred to me while thinking about flexible memberwise initialization.  One of the use cases I have had in mind while writing that proposal is a theoretical Swift version of UIKit that exposes all of its appearance properties as memberwise initialization parameters with defaults rather than just initializing the members to a default value.  Obviously this could lead to a very large stack frame that isn&#39;t really necessary.  Using the `@option` approach we can avoid the unnecessarily large stack frame.<br></p><p>Instead of always passing a value for every parameter the compiler would use a single dynamic data structure containing the values of all `@option` arguments provided at the call site.  The layout of the data structure would be an implementation detail of the language and would be part of the ABI.  It would contain a header of some kind indicating which parameters were actually provided with arguments at the call site and any additional information necessary to recover the value.  In the body of the function, references to the parameter value would be replaced with a lookup into the data structure which returned an optional value of the type of the parameter.<br></p><p>Perhaps the most interesting thing about `@option` is that careful design of the implementation might allow for `@option` parameters to be added or removed from a function without breaking ABI compatibility:<br></p><p>1. When new parameters are added, existing callers will simply never provide arguments and the implementation will see a nil optional value.  <br>2. When parameters are removed, existing clients will continue to provide them and the data structure will still be populated with them.  The implmentation will simply never look for the value.  The function will behave as if the parameter was still specified in the signature and simply not used.  The client would receive a compiler warning when compiling agains the newer SDK but everything would continue to work without issue until they did so.<br></p><p>If this is possible `@option` parameters would enable more robust evolution for functions containing parameters that may be omitted or have default values.<br></p><p>Another benefit of `@option` is that it provides better encapsulation of default values because they do not appear in function and method signatures.  My understanding of the planned mechanism for default arguments is that any changes to default parameter values will not be visible to clients until they recompile against the new version of the library.  If this is the case `@option` would also provide additional control to library authors who may wish to modify the default behavior of their implementation without breaking ABI.<br></p><p>Lastly, but potentially useful benefit of `@option` is that default argument values do not allow a function to distinguish between the case when a caller explicitly provides a value that happens to be the same as the default and the case when no argument was provided.  `@option` provides this information to the body of the function.<br></p><p>Finally, an interesting observation: changing a parameter from having a default value to `@option` or vice versa would break ABI but would be source-compatible.<br></p><p>I am very interested to hear whether others think this idea is worth pursuing further or not.<br></p><p>Matthew<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Pitch] Option parameters (potential resilience advantages)</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>December 28, 2015 at 02:00:00pm</p></header><div class="content"><p>The current workaround is to add an overload that calls the &quot;main&quot; version:<br></p><p>&gt; class Foo {<br>&gt; 	// version 1<br>&gt; 	func foo() {<br>&gt; 		print(5)<br>&gt; 	}<br>&gt; 	<br>&gt; 	// version 2<br>&gt; 	func foo() {<br>&gt; 		foo(5)<br>&gt; 	}<br>&gt; 	<br>&gt; 	func foo(value: Int) {<br>&gt; 		print(value)<br>&gt; 	}<br>&gt; }<br></p><p><br>How would you say that your solution compares?<br></p><p>Félix<br></p><p>&gt; Le 28 déc. 2015 à 11:11:57, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; I&#39;ve had an idea floating around in my mind for a couple weeks now and would like to find out what others think about it.<br>&gt; <br>&gt; The basic idea is really simple.  It introduces an `@option` parameter attribute.  Parameters with this attribute would behave like parameters with a default value at the call site, however they would not actually have a default value.  Instead, the argument seen in the body would be an optional of the type of the parameter value.<br>&gt; <br>&gt; func foo(@option value: Int) {<br>&gt; 	// value has type Int? in the body of the function<br>&gt; 	let valueToUse = value ?? 42<br>&gt; }<br>&gt; <br>&gt; At first glance it probably seems like this is of no value.  Why not just declare `value: Int? = nil`.  Obviously it must bring something to the table to be worth considering.<br>&gt; <br>&gt; This idea first occurred to me while thinking about flexible memberwise initialization.  One of the use cases I have had in mind while writing that proposal is a theoretical Swift version of UIKit that exposes all of its appearance properties as memberwise initialization parameters with defaults rather than just initializing the members to a default value.  Obviously this could lead to a very large stack frame that isn&#39;t really necessary.  Using the `@option` approach we can avoid the unnecessarily large stack frame.<br>&gt; <br>&gt; Instead of always passing a value for every parameter the compiler would use a single dynamic data structure containing the values of all `@option` arguments provided at the call site.  The layout of the data structure would be an implementation detail of the language and would be part of the ABI.  It would contain a header of some kind indicating which parameters were actually provided with arguments at the call site and any additional information necessary to recover the value.  In the body of the function, references to the parameter value would be replaced with a lookup into the data structure which returned an optional value of the type of the parameter.<br>&gt; <br>&gt; Perhaps the most interesting thing about `@option` is that careful design of the implementation might allow for `@option` parameters to be added or removed from a function without breaking ABI compatibility:<br>&gt; <br>&gt; 1. When new parameters are added, existing callers will simply never provide arguments and the implementation will see a nil optional value.  <br>&gt; 2. When parameters are removed, existing clients will continue to provide them and the data structure will still be populated with them.  The implmentation will simply never look for the value.  The function will behave as if the parameter was still specified in the signature and simply not used.  The client would receive a compiler warning when compiling agains the newer SDK but everything would continue to work without issue until they did so.<br>&gt; <br>&gt; If this is possible `@option` parameters would enable more robust evolution for functions containing parameters that may be omitted or have default values.<br>&gt; <br>&gt; Another benefit of `@option` is that it provides better encapsulation of default values because they do not appear in function and method signatures.  My understanding of the planned mechanism for default arguments is that any changes to default parameter values will not be visible to clients until they recompile against the new version of the library.  If this is the case `@option` would also provide additional control to library authors who may wish to modify the default behavior of their implementation without breaking ABI.<br>&gt; <br>&gt; Lastly, but potentially useful benefit of `@option` is that default argument values do not allow a function to distinguish between the case when a caller explicitly provides a value that happens to be the same as the default and the case when no argument was provided.  `@option` provides this information to the body of the function.<br>&gt; <br>&gt; Finally, an interesting observation: changing a parameter from having a default value to `@option` or vice versa would break ABI but would be source-compatible.<br>&gt; <br>&gt; I am very interested to hear whether others think this idea is worth pursuing further or not.<br>&gt; <br>&gt; Matthew<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Option parameters (potential resilience advantages)</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 28, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 28, 2015, at 1:08 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; <br>&gt; The current workaround is to add an overload that calls the &quot;main&quot; version:<br>&gt; <br>&gt;&gt; class Foo {<br>&gt;&gt; 	// version 1<br>&gt;&gt; 	func foo() {<br>&gt;&gt; 		print(5)<br>&gt;&gt; 	}<br>&gt;&gt; 	<br>&gt;&gt; 	// version 2<br>&gt;&gt; 	func foo() {<br>&gt;&gt; 		foo(5)<br>&gt;&gt; 	}<br>&gt;&gt; 	<br>&gt;&gt; 	func foo(value: Int) {<br>&gt;&gt; 		print(value)<br>&gt;&gt; 	}<br>&gt;&gt; }<br>&gt; <br>&gt; <br>&gt; How would you say that your solution compares?<br></p><p>I don’t quite understand how this is a “workaround”.  I don’t believe it would have the potential resilience benefits that prompted me to share the idea.  <br></p><p>It also doesn’t cover a case where there might be several option parameters and you want to allow the user to specify any combination of them.  Parameters with default values do cover that case but would also be less resilient than the “option” parameter idea.<br></p><p>As I stated a couple of times now, I am not “proposing” this idea, simply sharing it to see what the community response is.<br></p><p>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 28 déc. 2015 à 11:11:57, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; I&#39;ve had an idea floating around in my mind for a couple weeks now and would like to find out what others think about it.<br>&gt;&gt; <br>&gt;&gt; The basic idea is really simple.  It introduces an `@option` parameter attribute.  Parameters with this attribute would behave like parameters with a default value at the call site, however they would not actually have a default value.  Instead, the argument seen in the body would be an optional of the type of the parameter value.<br>&gt;&gt; <br>&gt;&gt; func foo(@option value: Int) {<br>&gt;&gt; 	// value has type Int? in the body of the function<br>&gt;&gt; 	let valueToUse = value ?? 42<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; At first glance it probably seems like this is of no value.  Why not just declare `value: Int? = nil`.  Obviously it must bring something to the table to be worth considering.<br>&gt;&gt; <br>&gt;&gt; This idea first occurred to me while thinking about flexible memberwise initialization.  One of the use cases I have had in mind while writing that proposal is a theoretical Swift version of UIKit that exposes all of its appearance properties as memberwise initialization parameters with defaults rather than just initializing the members to a default value.  Obviously this could lead to a very large stack frame that isn&#39;t really necessary.  Using the `@option` approach we can avoid the unnecessarily large stack frame.<br>&gt;&gt; <br>&gt;&gt; Instead of always passing a value for every parameter the compiler would use a single dynamic data structure containing the values of all `@option` arguments provided at the call site.  The layout of the data structure would be an implementation detail of the language and would be part of the ABI.  It would contain a header of some kind indicating which parameters were actually provided with arguments at the call site and any additional information necessary to recover the value.  In the body of the function, references to the parameter value would be replaced with a lookup into the data structure which returned an optional value of the type of the parameter.<br>&gt;&gt; <br>&gt;&gt; Perhaps the most interesting thing about `@option` is that careful design of the implementation might allow for `@option` parameters to be added or removed from a function without breaking ABI compatibility:<br>&gt;&gt; <br>&gt;&gt; 1. When new parameters are added, existing callers will simply never provide arguments and the implementation will see a nil optional value.  <br>&gt;&gt; 2. When parameters are removed, existing clients will continue to provide them and the data structure will still be populated with them.  The implmentation will simply never look for the value.  The function will behave as if the parameter was still specified in the signature and simply not used.  The client would receive a compiler warning when compiling agains the newer SDK but everything would continue to work without issue until they did so.<br>&gt;&gt; <br>&gt;&gt; If this is possible `@option` parameters would enable more robust evolution for functions containing parameters that may be omitted or have default values.<br>&gt;&gt; <br>&gt;&gt; Another benefit of `@option` is that it provides better encapsulation of default values because they do not appear in function and method signatures.  My understanding of the planned mechanism for default arguments is that any changes to default parameter values will not be visible to clients until they recompile against the new version of the library.  If this is the case `@option` would also provide additional control to library authors who may wish to modify the default behavior of their implementation without breaking ABI.<br>&gt;&gt; <br>&gt;&gt; Lastly, but potentially useful benefit of `@option` is that default argument values do not allow a function to distinguish between the case when a caller explicitly provides a value that happens to be the same as the default and the case when no argument was provided.  `@option` provides this information to the body of the function.<br>&gt;&gt; <br>&gt;&gt; Finally, an interesting observation: changing a parameter from having a default value to `@option` or vice versa would break ABI but would be source-compatible.<br>&gt;&gt; <br>&gt;&gt; I am very interested to hear whether others think this idea is worth pursuing further or not.<br>&gt;&gt; <br>&gt;&gt; Matthew<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d68c97e8e2f1653b54c24493caf236ae?s=50"></div><header><strong>[Pitch] Option parameters (potential resilience advantages)</strong> from <string>Stephen Celis</string> &lt;stephen.celis at gmail.com&gt;<p>December 28, 2015 at 02:00:00pm</p></header><div class="content"><p>I&#39;m not sure I understand the use case. Aren&#39;t these optimizations that could be better handled by the compiler? Do we really want to provide hints like these manually in our own libraries? Instead of `value: Int? = nil`, why not `value: Int = 42`?<br></p><p>Stephen<br></p><p>&gt; On Dec 28, 2015, at 11:11 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;ve had an idea floating around in my mind for a couple weeks now and would like to find out what others think about it.<br>&gt; <br>&gt; The basic idea is really simple.  It introduces an `@option` parameter attribute.  Parameters with this attribute would behave like parameters with a default value at the call site, however they would not actually have a default value.  Instead, the argument seen in the body would be an optional of the type of the parameter value.<br>&gt; <br>&gt; func foo(@option value: Int) {<br>&gt; 	// value has type Int? in the body of the function<br>&gt; 	let valueToUse = value ?? 42<br>&gt; }<br>&gt; <br>&gt; At first glance it probably seems like this is of no value.  Why not just declare `value: Int? = nil`.  Obviously it must bring something to the table to be worth considering.<br>&gt; <br>&gt; This idea first occurred to me while thinking about flexible memberwise initialization.  One of the use cases I have had in mind while writing that proposal is a theoretical Swift version of UIKit that exposes all of its appearance properties as memberwise initialization parameters with defaults rather than just initializing the members to a default value.  Obviously this could lead to a very large stack frame that isn&#39;t really necessary.  Using the `@option` approach we can avoid the unnecessarily large stack frame.<br>&gt; <br>&gt; Instead of always passing a value for every parameter the compiler would use a single dynamic data structure containing the values of all `@option` arguments provided at the call site.  The layout of the data structure would be an implementation detail of the language and would be part of the ABI.  It would contain a header of some kind indicating which parameters were actually provided with arguments at the call site and any additional information necessary to recover the value.  In the body of the function, references to the parameter value would be replaced with a lookup into the data structure which returned an optional value of the type of the parameter.<br>&gt; <br>&gt; Perhaps the most interesting thing about `@option` is that careful design of the implementation might allow for `@option` parameters to be added or removed from a function without breaking ABI compatibility:<br>&gt; <br>&gt; 1. When new parameters are added, existing callers will simply never provide arguments and the implementation will see a nil optional value.  <br>&gt; 2. When parameters are removed, existing clients will continue to provide them and the data structure will still be populated with them.  The implmentation will simply never look for the value.  The function will behave as if the parameter was still specified in the signature and simply not used.  The client would receive a compiler warning when compiling agains the newer SDK but everything would continue to work without issue until they did so.<br>&gt; <br>&gt; If this is possible `@option` parameters would enable more robust evolution for functions containing parameters that may be omitted or have default values.<br>&gt; <br>&gt; Another benefit of `@option` is that it provides better encapsulation of default values because they do not appear in function and method signatures.  My understanding of the planned mechanism for default arguments is that any changes to default parameter values will not be visible to clients until they recompile against the new version of the library.  If this is the case `@option` would also provide additional control to library authors who may wish to modify the default behavior of their implementation without breaking ABI.<br>&gt; <br>&gt; Lastly, but potentially useful benefit of `@option` is that default argument values do not allow a function to distinguish between the case when a caller explicitly provides a value that happens to be the same as the default and the case when no argument was provided.  `@option` provides this information to the body of the function.<br>&gt; <br>&gt; Finally, an interesting observation: changing a parameter from having a default value to `@option` or vice versa would break ABI but would be source-compatible.<br>&gt; <br>&gt; I am very interested to hear whether others think this idea is worth pursuing further or not.<br>&gt; <br>&gt; Matthew<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Option parameters (potential resilience advantages)</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 28, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 28, 2015, at 1:39 PM, Stephen Celis &lt;stephen.celis at gmail.com&gt; wrote:<br>&gt; <br>&gt; I&#39;m not sure I understand the use case. Aren&#39;t these optimizations that could be better handled by the compiler? Do we really want to provide hints like these manually in our own libraries? Instead of `value: Int? = nil`, why not `value: Int = 42`?<br></p><p>I agree that part of this is simply an optimization.  The part that was interesting enough that I thought it is worth sharing is that it could improve resilience in a way that a default value does not allow.<br></p><p>That said, it is not a “proposal”.  I’m not sure whether it is really worth considering or not.  But I think it is interesting enough to toss out to the community and see what the response is.<br></p><p>&gt; <br>&gt; Stephen<br>&gt; <br>&gt;&gt; On Dec 28, 2015, at 11:11 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;ve had an idea floating around in my mind for a couple weeks now and would like to find out what others think about it.<br>&gt;&gt; <br>&gt;&gt; The basic idea is really simple.  It introduces an `@option` parameter attribute.  Parameters with this attribute would behave like parameters with a default value at the call site, however they would not actually have a default value.  Instead, the argument seen in the body would be an optional of the type of the parameter value.<br>&gt;&gt; <br>&gt;&gt; func foo(@option value: Int) {<br>&gt;&gt; 	// value has type Int? in the body of the function<br>&gt;&gt; 	let valueToUse = value ?? 42<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; At first glance it probably seems like this is of no value.  Why not just declare `value: Int? = nil`.  Obviously it must bring something to the table to be worth considering.<br>&gt;&gt; <br>&gt;&gt; This idea first occurred to me while thinking about flexible memberwise initialization.  One of the use cases I have had in mind while writing that proposal is a theoretical Swift version of UIKit that exposes all of its appearance properties as memberwise initialization parameters with defaults rather than just initializing the members to a default value.  Obviously this could lead to a very large stack frame that isn&#39;t really necessary.  Using the `@option` approach we can avoid the unnecessarily large stack frame.<br>&gt;&gt; <br>&gt;&gt; Instead of always passing a value for every parameter the compiler would use a single dynamic data structure containing the values of all `@option` arguments provided at the call site.  The layout of the data structure would be an implementation detail of the language and would be part of the ABI.  It would contain a header of some kind indicating which parameters were actually provided with arguments at the call site and any additional information necessary to recover the value.  In the body of the function, references to the parameter value would be replaced with a lookup into the data structure which returned an optional value of the type of the parameter.<br>&gt;&gt; <br>&gt;&gt; Perhaps the most interesting thing about `@option` is that careful design of the implementation might allow for `@option` parameters to be added or removed from a function without breaking ABI compatibility:<br>&gt;&gt; <br>&gt;&gt; 1. When new parameters are added, existing callers will simply never provide arguments and the implementation will see a nil optional value.  <br>&gt;&gt; 2. When parameters are removed, existing clients will continue to provide them and the data structure will still be populated with them.  The implmentation will simply never look for the value.  The function will behave as if the parameter was still specified in the signature and simply not used.  The client would receive a compiler warning when compiling agains the newer SDK but everything would continue to work without issue until they did so.<br>&gt;&gt; <br>&gt;&gt; If this is possible `@option` parameters would enable more robust evolution for functions containing parameters that may be omitted or have default values.<br>&gt;&gt; <br>&gt;&gt; Another benefit of `@option` is that it provides better encapsulation of default values because they do not appear in function and method signatures.  My understanding of the planned mechanism for default arguments is that any changes to default parameter values will not be visible to clients until they recompile against the new version of the library.  If this is the case `@option` would also provide additional control to library authors who may wish to modify the default behavior of their implementation without breaking ABI.<br>&gt;&gt; <br>&gt;&gt; Lastly, but potentially useful benefit of `@option` is that default argument values do not allow a function to distinguish between the case when a caller explicitly provides a value that happens to be the same as the default and the case when no argument was provided.  `@option` provides this information to the body of the function.<br>&gt;&gt; <br>&gt;&gt; Finally, an interesting observation: changing a parameter from having a default value to `@option` or vice versa would break ABI but would be source-compatible.<br>&gt;&gt; <br>&gt;&gt; I am very interested to hear whether others think this idea is worth pursuing further or not.<br>&gt;&gt; <br>&gt;&gt; Matthew<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Pitch] Option parameters (potential resilience advantages)</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 28, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; On Dec 28, 2015, at 11:46 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 28, 2015, at 1:39 PM, Stephen Celis &lt;stephen.celis at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;m not sure I understand the use case. Aren&#39;t these optimizations that could be better handled by the compiler? Do we really want to provide hints like these manually in our own libraries? Instead of `value: Int? = nil`, why not `value: Int = 42`?<br>&gt; <br>&gt; I agree that part of this is simply an optimization.  The part that was interesting enough that I thought it is worth sharing is that it could improve resilience in a way that a default value does not allow.<br>&gt; <br>&gt; That said, it is not a “proposal”.  I’m not sure whether it is really worth considering or not.  But I think it is interesting enough to toss out to the community and see what the response is.<br></p><p>You can provide resilience with a non-optional parameter by making the default argument the result of calling a resilient function (or evaluating a resilient property):<br></p><p>@availability(x.y)<br>internal func defaultForFoo() -&gt; Int { return 941 }<br></p><p>public func foo(value: Int = defaultForFoo()) { }<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151228/34a4f9ff/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Option parameters (potential resilience advantages)</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 28, 2015 at 02:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On Dec 28, 2015, at 2:04 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Dec 28, 2015, at 11:46 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 28, 2015, at 1:39 PM, Stephen Celis &lt;stephen.celis at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m not sure I understand the use case. Aren&#39;t these optimizations that could be better handled by the compiler? Do we really want to provide hints like these manually in our own libraries? Instead of `value: Int? = nil`, why not `value: Int = 42`?<br>&gt;&gt; <br>&gt;&gt; I agree that part of this is simply an optimization.  The part that was interesting enough that I thought it is worth sharing is that it could improve resilience in a way that a default value does not allow.<br>&gt;&gt; <br>&gt;&gt; That said, it is not a “proposal”.  I’m not sure whether it is really worth considering or not.  But I think it is interesting enough to toss out to the community and see what the response is.<br>&gt; <br>&gt; You can provide resilience with a non-optional parameter by making the default argument the result of calling a resilient function (or evaluating a resilient property):<br>&gt; <br>&gt; @availability(x.y)<br>&gt; internal func defaultForFoo() -&gt; Int { return 941 }<br>&gt; <br>&gt; public func foo(value: Int = defaultForFoo()) { }<br>&gt; <br></p><p>I don&#39;t think I&#39;ve tried calling a lower visibility function to get a default like that before.  That&#39;s interesting.  Good to know it is possible.<br></p><p>I was especially thinking about the ability to add or remove option parameters without breaking ABI.  In that case the existing function might be able to forward to a new overload with a different set of parameters with defaults, but it also seems like that would lead to ambiguity at call sites in many cases when compiling against the new binary.<br></p><p>Will there be a way to &quot;hide&quot; the old function (i.e. give it in some kind of &quot;public for backwards compatibility only&quot; visibility) so call sites are still unambiguous during compilation and the module interface is not unnecessarily cluttered while also retaining the original function for ABI compatibility?  (I hope that long sentence is comprehensible)<br></p><p>If it is possible to effectively add and remove parameters with default values one way or another without breaking ABI then the option parameter idea is almost certainly not worth the complexity.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151228/f0ef8d51/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Pitch] Option parameters (potential resilience advantages)</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 28, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; On Dec 28, 2015, at 12:29 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt; On Dec 28, 2015, at 2:04 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 28, 2015, at 11:46 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 28, 2015, at 1:39 PM, Stephen Celis &lt;stephen.celis at gmail.com &lt;mailto:stephen.celis at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m not sure I understand the use case. Aren&#39;t these optimizations that could be better handled by the compiler? Do we really want to provide hints like these manually in our own libraries? Instead of `value: Int? = nil`, why not `value: Int = 42`?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree that part of this is simply an optimization.  The part that was interesting enough that I thought it is worth sharing is that it could improve resilience in a way that a default value does not allow.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That said, it is not a “proposal”.  I’m not sure whether it is really worth considering or not.  But I think it is interesting enough to toss out to the community and see what the response is.<br>&gt;&gt; <br>&gt;&gt; You can provide resilience with a non-optional parameter by making the default argument the result of calling a resilient function (or evaluating a resilient property):<br>&gt;&gt; <br>&gt;&gt; @availability(x.y)<br>&gt;&gt; internal func defaultForFoo() -&gt; Int { return 941 }<br>&gt;&gt; <br>&gt;&gt; public func foo(value: Int = defaultForFoo()) { }<br>&gt;&gt; <br>&gt; <br>&gt; I don&#39;t think I&#39;ve tried calling a lower visibility function to get a default like that before.  That&#39;s interesting.  Good to know it is possible.<br>&gt; <br>&gt; I was especially thinking about the ability to add or remove option parameters without breaking ABI.  In that case the existing function might be able to forward to a new overload with a different set of parameters with defaults, but it also seems like that would lead to ambiguity at call sites in many cases when compiling against the new binary.<br>&gt; <br>&gt; Will there be a way to &quot;hide&quot; the old function (i.e. give it in some kind of &quot;public for backwards compatibility only&quot; visibility) so call sites are still unambiguous during compilation and the module interface is not unnecessarily cluttered while also retaining the original function for ABI compatibility?  (I hope that long sentence is comprehensible)<br></p><p>Yeah, you ought to be able to do this by deprecating the old entry point and implementing it by forwarding to the new more general entry point. <br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151228/7d87943b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Option parameters (potential resilience advantages)</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 28, 2015 at 03:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On Dec 28, 2015, at 2:52 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 28, 2015, at 12:29 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 28, 2015, at 2:04 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 28, 2015, at 11:46 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 28, 2015, at 1:39 PM, Stephen Celis &lt;stephen.celis at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;m not sure I understand the use case. Aren&#39;t these optimizations that could be better handled by the compiler? Do we really want to provide hints like these manually in our own libraries? Instead of `value: Int? = nil`, why not `value: Int = 42`?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I agree that part of this is simply an optimization.  The part that was interesting enough that I thought it is worth sharing is that it could improve resilience in a way that a default value does not allow.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That said, it is not a “proposal”.  I’m not sure whether it is really worth considering or not.  But I think it is interesting enough to toss out to the community and see what the response is.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You can provide resilience with a non-optional parameter by making the default argument the result of calling a resilient function (or evaluating a resilient property):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; @availability(x.y)<br>&gt;&gt;&gt; internal func defaultForFoo() -&gt; Int { return 941 }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public func foo(value: Int = defaultForFoo()) { }<br>&gt;&gt; <br>&gt;&gt; I don&#39;t think I&#39;ve tried calling a lower visibility function to get a default like that before.  That&#39;s interesting.  Good to know it is possible.<br>&gt;&gt; <br>&gt;&gt; I was especially thinking about the ability to add or remove option parameters without breaking ABI.  In that case the existing function might be able to forward to a new overload with a different set of parameters with defaults, but it also seems like that would lead to ambiguity at call sites in many cases when compiling against the new binary.<br>&gt;&gt; <br>&gt;&gt; Will there be a way to &quot;hide&quot; the old function (i.e. give it in some kind of &quot;public for backwards compatibility only&quot; visibility) so call sites are still unambiguous during compilation and the module interface is not unnecessarily cluttered while also retaining the original function for ABI compatibility?  (I hope that long sentence is comprehensible)<br>&gt; <br>&gt; Yeah, you ought to be able to do this by deprecating the old entry point and implementing it by forwarding to the new more general entry point. <br>&gt; <br></p><p>Cool.  The option parameter idea seems to have no value to us then.  I suspected as much but wasn&#39;t sure so thought it was worth seeing what the response was.  Thanks for taking time to respond.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151228/7e9d3677/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
