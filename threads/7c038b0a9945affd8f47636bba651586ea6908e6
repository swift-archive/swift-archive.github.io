<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c40db4457ab2c91a0d8006da31b177c6?s=50"></div><header><strong>[Proposal] Make non-escaping closures the default</strong> from <string>Trent Nadeau</string> &lt;tanadeau at gmail.com&gt;<p>June  5, 2016 at 11:00:00pm</p></header><div class="content"><p>https://github.com/tanadeau/swift-evolution/blob/make-noescape-default/proposals/XXXX-make-noescape-default.md<br></p><p># Make non-escaping closures the default<br></p><p>* Proposal: [SE-NNNN](NNNN-name.md)<br>* Author: [Trent Nadeau](https://github.com/tanadeau)<br>* Status: **Awaiting review**<br>* Review manager: TBD<br></p><p>## Introduction<br></p><p>The current default of closure arguments to functions (i.e., arguments to<br>functions that themselves have function type such as `(T) -&gt; U`) is to be<br>&quot;escaping&quot;, meaning they can escape the function body such as saving it to<br>a field in a struct or a global variable. In order to say that a closure<br>argument cannot possibly escape the function body (&quot;non-escaping&quot;), the<br>developer must explicitly add an `@noescape` annotation to the argument<br>type.<br></p><p>This proposal switches the default to be non-escaping and requires an<br>`@escaping` annotation if a closure argument can escape the function body.<br>Since the escaping case can be statically detected, this annotation can be<br>added via an error with a fixit. Other annotations that have consequences<br>for escape semantics (e.g., `@autoclosure(escaping)`) will be altered to<br>make use of the new `@escaping` annotation.<br></p><p>Swift-evolution threads: [Discussion thread topic for that proposal (TBD)](<br>http://news.gmane.org/gmane.comp.lang.swift.evolution)<br></p><p>## Motivation<br></p><p>Per Chris Lattner [on swift-evolution](<br>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160530/019880.html<br>):<br></p><p>&gt; To provide some more details, this approach has the following advantages:<br>&gt;<br>&gt; - Most functional algorithms written in pure Swift will benefit because<br>they are naturally noescape.  The core team feels that this will reduce the<br>boilerplate involved with writing these algorithms.<br>&gt;<br>&gt; - The compiler has enough logic in it to provide a great QoI experience<br>when a developer doesn’t think about escaping, and tries to escape a<br>closure - it can provide a fixit that suggests adding @escaping.<br>&gt;<br>&gt; - Recent changes (to disallow escaping closures to close over an inout<br>parameter) are pushing the language to prefer noescape closures.  noescape<br>closures have also always been the preferred default, since they eliminate<br>a class of retain cycle issues.<br>&gt;<br>&gt; - &quot;@autoclosure(escaping)&quot; can be simplified and standardized to<br>&quot;@autoclosure @escaping”<br></p><p>## Detailed design<br></p><p>The `@noescape` annotation is removed from the language. The compiler will<br>emit an error with a fixit to remove the annotation.<br></p><p>The compiler will emit an error if a closure argument is found to possibly<br>escape the function body. In order to silence the warning, the developer<br>must add, manually or via fixit, the `@escaping` annotation to the argument<br>type.<br></p><p>The compiler&#39;s semantic analysis implementation can be simplified as the<br>more constrained escaping case that conflicts with other attributes is now<br>no longer the default.<br></p><p>The standard library should be changed to use the new default whenever<br>possible by removing all uses of `@noescape` and only adding `@escaping`<br>where the compiler detects the need.<br></p><p>### Imported C/Objective-C APIs<br></p><p>Per the Core Team, most Cocoa closure/block parameters are escaping (e.g.,<br>delegates). As such the Clang importer will automatically add the<br>`@escaping` annotation to closure/block parameters encountered in imported<br>Objective-C APIs unless they are explicitly marked with the Clang<br>`((noescape))` attribute. This will also be done with imported C APIs with<br>function pointer or block parameters.<br></p><p>## Impact on existing code<br></p><p>Existing code using the `@noescape` attribute will need to be migrated to<br>remove the attribute since it will be the default. In addition, the<br>compiler will need to detect escaping closures that are not marked with<br>`@escaping` and create an error with a fixit to add the required attribute.<br></p><p>Uses of `@autoclosure(escaping)` must be changed to `@autoclosure<br>@escaping`.<br></p><p>There should be few, if any, changes required for uses of Cocoa APIs as<br>these will be mostly marked as `@escaping`, and escaping closure arguments<br>are *more* constrained than non-escaping ones.<br></p><p>## Future directions<br></p><p>The `@noescape(once)` annotation proposed in [SE-0073](<br>https://github.com/apple/swift-evolution/blob/master/proposals/0073-noescape-once.md)<br>would, if some future version is accepted, just become `@once`.<br></p><p>## Alternatives considered<br></p><p>Leave the `@noescape` attribute and existing semantics as they are now.<br></p><p>## Acknowledgements<br></p><p>Thanks to Chris Lattner, **TBD**, and anyone else who reviewed and<br>contributed to this proposal.<br></p><p><br>-- <br>Trent Nadeau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160605/7c0308e6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal] Make non-escaping closures the default</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June  7, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; This proposal switches the default to be non-escaping and requires an `@escaping` annotation if a closure argument can escape the function body. <br></p><p>Is @escaping part of the function type syntax (like @autoclosure) or the parameter syntax (like inout)? It seems to me that there are places where you *do* want non-parameter closure variables to be non-escaping:<br></p><p>	func foo(closure: () -&gt; Void) {<br>		let bar = closure	// You should not be able to escape through `bar`<br>	}<br></p><p>But then there are also many places where you would have to write @escaping even though a non-escaping closure would be obviously nonsensical:<br></p><p>	struct Foo {<br>		var closure: () -&gt; Void			// Error; @escaping is mandatory here<br>		func method() -&gt; () -&gt; Void {...}	// Same<br>	}<br></p><p>Requiring a boilerplate attribute like this is not really so great.<br></p><p>&gt; Existing code using the `@noescape` attribute will need to be migrated to remove the attribute since it will be the default. In addition, the compiler will need to detect escaping closures that are not marked with `@escaping` and create an error with a fixit to add the required attribute.<br></p><p>This becomes difficult when a protocol has a closure parameter; there&#39;s not necessarily a default implementation to examine for escaping, and even if there is one, the default may be a simple, non-escaping implementation for something which ought to allow escaping from other implementations. Similar concerns apply to non-final class members.<br></p><p>One way to address this issue would be to have the migrator conservatively mark non- at noescape closure parameters in protocol and class definitions as @escaping, but that might undermine the intent of automatically transitioning a lot of code to the new default.<br></p><p>(By the way, is an @escaping closure a subtype of a non-escaping closure?)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c40db4457ab2c91a0d8006da31b177c6?s=50"></div><header><strong>[Proposal] Make non-escaping closures the default</strong> from <string>Trent Nadeau</string> &lt;tanadeau at gmail.com&gt;<p>June  7, 2016 at 08:00:00am</p></header><div class="content"><p>@escaping would be part of the parameter type just as @noescape is today.<br>Your foo(closure:) example wouldn&#39;t compile with my proposal, the same as<br>today if you marked the parameter with @noescape. Non-escaping function<br>parameters are only allowed to be called. They can&#39;t be assigned to<br>variables.<br></p><p>The current @noescape and the proposed @escaping can only be applied to the<br>types of function parameters so the code in your `struct Foo` example<br>wouldn&#39;t change.<br></p><p>Currently escaping and non-escaping closures are considered to be different<br>types so there is already a problem when a protocol requires a function<br>with a closure parameter. All conforming types must use the same<br>&quot;escapiness&quot; as the protocol.<br></p><p>On Tue, Jun 7, 2016 at 3:45 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>wrote:<br></p><p>&gt; &gt; This proposal switches the default to be non-escaping and requires an<br>&gt; `@escaping` annotation if a closure argument can escape the function body.<br>&gt;<br>&gt; Is @escaping part of the function type syntax (like @autoclosure) or the<br>&gt; parameter syntax (like inout)? It seems to me that there are places where<br>&gt; you *do* want non-parameter closure variables to be non-escaping:<br>&gt;<br>&gt;         func foo(closure: () -&gt; Void) {<br>&gt;                 let bar = closure       // You should not be able to<br>&gt; escape through `bar`<br>&gt;         }<br>&gt;<br>&gt; But then there are also many places where you would have to write<br>&gt; @escaping even though a non-escaping closure would be obviously nonsensical:<br>&gt;<br>&gt;         struct Foo {<br>&gt;                 var closure: () -&gt; Void                 // Error;<br>&gt; @escaping is mandatory here<br>&gt;                 func method() -&gt; () -&gt; Void {...}       // Same<br>&gt;         }<br>&gt;<br>&gt; Requiring a boilerplate attribute like this is not really so great.<br>&gt;<br>&gt; &gt; Existing code using the `@noescape` attribute will need to be migrated<br>&gt; to remove the attribute since it will be the default. In addition, the<br>&gt; compiler will need to detect escaping closures that are not marked with<br>&gt; `@escaping` and create an error with a fixit to add the required attribute.<br>&gt;<br>&gt; This becomes difficult when a protocol has a closure parameter; there&#39;s<br>&gt; not necessarily a default implementation to examine for escaping, and even<br>&gt; if there is one, the default may be a simple, non-escaping implementation<br>&gt; for something which ought to allow escaping from other implementations.<br>&gt; Similar concerns apply to non-final class members.<br>&gt;<br>&gt; One way to address this issue would be to have the migrator conservatively<br>&gt; mark non- at noescape closure parameters in protocol and class definitions<br>&gt; as @escaping, but that might undermine the intent of automatically<br>&gt; transitioning a lot of code to the new default.<br>&gt;<br>&gt; (By the way, is an @escaping closure a subtype of a non-escaping closure?)<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt;<br></p><p><br>-- <br>Trent Nadeau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160607/d2403c4e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal] Make non-escaping closures the default</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June  7, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; @escaping would be part of the parameter type just as @noescape is today. Your foo(closure:) example wouldn&#39;t compile with my proposal, the same as today if you marked the parameter with @noescape. Non-escaping function parameters are only allowed to be called. They can&#39;t be assigned to variables.<br></p><p>Okay, that does correct that issue. Although it raises a separate issue: a bare closure type now means something different in a parameter list than anywhere else.<br></p><p>Are generic types which happen to be functions in some particular use automatically @escaping? Are typealiases and associated types automatically @escaping?<br></p><p>Also, if `@escaping` is a part of the parameter list syntax (like `inout`) instead of the type syntax (like `@autoclosure`), would it make sense to drop its `@` sign to make them more syntactically similar?<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Proposal] Make non-escaping closures the default</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>June  8, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jun 7, 2016, at 7:25 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; @escaping would be part of the parameter type just as @noescape is today. Your foo(closure:) example wouldn&#39;t compile with my proposal, the same as today if you marked the parameter with @noescape. Non-escaping function parameters are only allowed to be called. They can&#39;t be assigned to variables.<br>&gt; <br>&gt; Okay, that does correct that issue. Although it raises a separate issue: a bare closure type now means something different in a parameter list than anywhere else.<br></p><p>@escaping is really a parameter-specific aspect of the outer function type, not an aspect of the parameter&#39;s type.  It&#39;s just like something like NS_CONSUMED in Objective-C ARC.<br></p><p>John.<br></p><p>&gt; Are generic types which happen to be functions in some particular use automatically @escaping? Are typealiases and associated types automatically @escaping?<br>&gt; <br>&gt; Also, if `@escaping` is a part of the parameter list syntax (like `inout`) instead of the type syntax (like `@autoclosure`), would it make sense to drop its `@` sign to make them more syntactically similar?<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c40db4457ab2c91a0d8006da31b177c6?s=50"></div><header><strong>[Proposal] Make non-escaping closures the default</strong> from <string>Trent Nadeau</string> &lt;tanadeau at gmail.com&gt;<p>June  9, 2016 at 06:00:00pm</p></header><div class="content"><p>When would be a good time to actual put out a PR to the swift-evolution<br>repo for this proposal? The feedback so far has been very light, but I&#39;m<br>not sure if that&#39;s because everyone&#39;s gearing up for WWDC, if there&#39;s<br>little interest, or if it&#39;s uncontroversial.<br></p><p>On Wed, Jun 8, 2016 at 1:17 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br></p><p>&gt; &gt; On Jun 7, 2016, at 7:25 PM, Brent Royal-Gordon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt; @escaping would be part of the parameter type just as @noescape is<br>&gt; today. Your foo(closure:) example wouldn&#39;t compile with my proposal, the<br>&gt; same as today if you marked the parameter with @noescape. Non-escaping<br>&gt; function parameters are only allowed to be called. They can&#39;t be assigned<br>&gt; to variables.<br>&gt; &gt;<br>&gt; &gt; Okay, that does correct that issue. Although it raises a separate issue:<br>&gt; a bare closure type now means something different in a parameter list than<br>&gt; anywhere else.<br>&gt;<br>&gt; @escaping is really a parameter-specific aspect of the outer function<br>&gt; type, not an aspect of the parameter&#39;s type.  It&#39;s just like something like<br>&gt; NS_CONSUMED in Objective-C ARC.<br>&gt;<br>&gt; John.<br>&gt;<br>&gt; &gt; Are generic types which happen to be functions in some particular use<br>&gt; automatically @escaping? Are typealiases and associated types automatically<br>&gt; @escaping?<br>&gt; &gt;<br>&gt; &gt; Also, if `@escaping` is a part of the parameter list syntax (like<br>&gt; `inout`) instead of the type syntax (like `@autoclosure`), would it make<br>&gt; sense to drop its `@` sign to make them more syntactically similar?<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Brent Royal-Gordon<br>&gt; &gt; Architechies<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p><p><br>-- <br>Trent Nadeau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/de26d5b3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Proposal] Make non-escaping closures the default</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>June  9, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jun 9, 2016, at 3:17 PM, Trent Nadeau &lt;tanadeau at gmail.com&gt; wrote:<br>&gt; When would be a good time to actual put out a PR to the swift-evolution repo for this proposal? The feedback so far has been very light, but I&#39;m not sure if that&#39;s because everyone&#39;s gearing up for WWDC, if there&#39;s little interest, or if it&#39;s uncontroversial.<br></p><p>The initial feedback phase is intended for discussion which shapes the basic content of a proposal, e.g. exploring the goals, suggesting different ways of achieving those goals, etc.  Specifically, it&#39;s not designed to determine whether people actually *like* the proposal; that&#39;s what formal review is for.  In this case, I don&#39;t see much room for variation in the basic content: we have to flip the default rule, we have to provide some way to declare a closure as escaping, that way pretty much has to be a parameter attribute, the obvious spelling for that attribute is @escaping, etc.  So if you&#39;re happy with the content of the proposal, just send the PR and we&#39;ll schedule some time to talk about it.  That time will obviously not be WWDC week. :)<br></p><p>John.<br></p><p>&gt; <br>&gt; On Wed, Jun 8, 2016 at 1:17 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt; &gt; On Jun 7, 2016, at 7:25 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt; @escaping would be part of the parameter type just as @noescape is today. Your foo(closure:) example wouldn&#39;t compile with my proposal, the same as today if you marked the parameter with @noescape. Non-escaping function parameters are only allowed to be called. They can&#39;t be assigned to variables.<br>&gt; &gt;<br>&gt; &gt; Okay, that does correct that issue. Although it raises a separate issue: a bare closure type now means something different in a parameter list than anywhere else.<br>&gt; <br>&gt; @escaping is really a parameter-specific aspect of the outer function type, not an aspect of the parameter&#39;s type.  It&#39;s just like something like NS_CONSUMED in Objective-C ARC.<br>&gt; <br>&gt; John.<br>&gt; <br>&gt; &gt; Are generic types which happen to be functions in some particular use automatically @escaping? Are typealiases and associated types automatically @escaping?<br>&gt; &gt;<br>&gt; &gt; Also, if `@escaping` is a part of the parameter list syntax (like `inout`) instead of the type syntax (like `@autoclosure`), would it make sense to drop its `@` sign to make them more syntactically similar?<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Brent Royal-Gordon<br>&gt; &gt; Architechies<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Trent Nadeau<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/e24e58d0/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Proposal] Make non-escaping closures the default</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>June  9, 2016 at 03:00:00pm</p></header><div class="content"><p>I&#39;m against this for library evolution reasons: if someone releases a version of their library that has a non-escaping closure and later discovers it needs to be escaping, they can&#39;t change it.<br></p><p>IIRC the counterpoint to this is that people were probably implicitly relying on it being non-escaping already, and that there aren&#39;t many cases where you&#39;d want to do this anyway. My counter-counterpoint is that you might have some case, like dispatch_async (er, DispatchQueue.async) with a semaphore where you know the closure isn&#39;t escaping, but you need to treat it as one. Maybe that just means we need an asUnsafeEscapingClosure helper in the standard library.<br></p><p>I also think it might be useful to be able to annotate references as non-escaping (purely for performance reasons), and I can&#39;t see those being non-escaping by default. I know we don&#39;t want to block one change because of something else that might happen down the line, but still.<br></p><p>Jordan<br></p><p><br>&gt; On Jun 5, 2016, at 20:49, Trent Nadeau via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; https://github.com/tanadeau/swift-evolution/blob/make-noescape-default/proposals/XXXX-make-noescape-default.md &lt;https://github.com/tanadeau/swift-evolution/blob/make-noescape-default/proposals/XXXX-make-noescape-default.md&gt;<br>&gt; <br>&gt; # Make non-escaping closures the default<br>&gt; <br>&gt; * Proposal: [SE-NNNN](NNNN-name.md)<br>&gt; * Author: [Trent Nadeau](https://github.com/tanadeau &lt;https://github.com/tanadeau&gt;)<br>&gt; * Status: **Awaiting review**<br>&gt; * Review manager: TBD<br>&gt; <br>&gt; ## Introduction<br>&gt; <br>&gt; The current default of closure arguments to functions (i.e., arguments to functions that themselves have function type such as `(T) -&gt; U`) is to be &quot;escaping&quot;, meaning they can escape the function body such as saving it to a field in a struct or a global variable. In order to say that a closure argument cannot possibly escape the function body (&quot;non-escaping&quot;), the developer must explicitly add an `@noescape` annotation to the argument type.<br>&gt; <br>&gt; This proposal switches the default to be non-escaping and requires an `@escaping` annotation if a closure argument can escape the function body. Since the escaping case can be statically detected, this annotation can be added via an error with a fixit. Other annotations that have consequences for escape semantics (e.g., `@autoclosure(escaping)`) will be altered to make use of the new `@escaping` annotation.<br>&gt; <br>&gt; Swift-evolution threads: [Discussion thread topic for that proposal (TBD)](http://news.gmane.org/gmane.comp.lang.swift.evolution &lt;http://news.gmane.org/gmane.comp.lang.swift.evolution&gt;)<br>&gt; <br>&gt; ## Motivation<br>&gt; <br>&gt; Per Chris Lattner [on swift-evolution](https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160530/019880.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160530/019880.html&gt;):<br>&gt; <br>&gt; &gt; To provide some more details, this approach has the following advantages:<br>&gt; &gt;<br>&gt; &gt; - Most functional algorithms written in pure Swift will benefit because they are naturally noescape.  The core team feels that this will reduce the boilerplate involved with writing these algorithms.<br>&gt; &gt;<br>&gt; &gt; - The compiler has enough logic in it to provide a great QoI experience when a developer doesn’t think about escaping, and tries to escape a closure - it can provide a fixit that suggests adding @escaping.<br>&gt; &gt;<br>&gt; &gt; - Recent changes (to disallow escaping closures to close over an inout parameter) are pushing the language to prefer noescape closures.  noescape closures have also always been the preferred default, since they eliminate a class of retain cycle issues.<br>&gt; &gt;<br>&gt; &gt; - &quot;@autoclosure(escaping)&quot; can be simplified and standardized to &quot;@autoclosure @escaping”<br>&gt; <br>&gt; ## Detailed design<br>&gt; <br>&gt; The `@noescape` annotation is removed from the language. The compiler will emit an error with a fixit to remove the annotation.<br>&gt; <br>&gt; The compiler will emit an error if a closure argument is found to possibly escape the function body. In order to silence the warning, the developer must add, manually or via fixit, the `@escaping` annotation to the argument type.<br>&gt; <br>&gt; The compiler&#39;s semantic analysis implementation can be simplified as the more constrained escaping case that conflicts with other attributes is now no longer the default.<br>&gt; <br>&gt; The standard library should be changed to use the new default whenever possible by removing all uses of `@noescape` and only adding `@escaping` where the compiler detects the need.<br>&gt; <br>&gt; ### Imported C/Objective-C APIs<br>&gt; <br>&gt; Per the Core Team, most Cocoa closure/block parameters are escaping (e.g., delegates). As such the Clang importer will automatically add the `@escaping` annotation to closure/block parameters encountered in imported Objective-C APIs unless they are explicitly marked with the Clang `((noescape))` attribute. This will also be done with imported C APIs with function pointer or block parameters.<br>&gt; <br>&gt; ## Impact on existing code<br>&gt; <br>&gt; Existing code using the `@noescape` attribute will need to be migrated to remove the attribute since it will be the default. In addition, the compiler will need to detect escaping closures that are not marked with `@escaping` and create an error with a fixit to add the required attribute.<br>&gt; <br>&gt; Uses of `@autoclosure(escaping)` must be changed to `@autoclosure @escaping`.<br>&gt; <br>&gt; There should be few, if any, changes required for uses of Cocoa APIs as these will be mostly marked as `@escaping`, and escaping closure arguments are *more* constrained than non-escaping ones.<br>&gt; <br>&gt; ## Future directions<br>&gt; <br>&gt; The `@noescape(once)` annotation proposed in [SE-0073](https://github.com/apple/swift-evolution/blob/master/proposals/0073-noescape-once.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0073-noescape-once.md&gt;) would, if some future version is accepted, just become `@once`.<br>&gt; <br>&gt; ## Alternatives considered<br>&gt; <br>&gt; Leave the `@noescape` attribute and existing semantics as they are now.<br>&gt; <br>&gt; ## Acknowledgements<br>&gt; <br>&gt; Thanks to Chris Lattner, **TBD**, and anyone else who reviewed and contributed to this proposal.<br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Trent Nadeau<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/bcd8647b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Proposal] Make non-escaping closures the default</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>June  9, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jun 9, 2016, at 3:43 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;m against this for library evolution reasons: if someone releases a version of their library that has a non-escaping closure and later discovers it needs to be escaping, they can&#39;t change it.<br>&gt; <br>&gt; IIRC the counterpoint to this is that people were probably implicitly relying on it being non-escaping already, and that there aren&#39;t many cases where you&#39;d want to do this anyway.<br></p><p>Right.  APIs are already semantically constrained in how they&#39;re allowed to use their closure arguments.  Closure arguments inject arbitrary code, with arbitrary data access, into the callee; as a rule, the caller must know how the callee intends to use the closure, or its semantics will be grossly violated.  You can&#39;t re-implement an existing API that always synchronously sub-invokes a closure to instead call the closure asynchronously or concurrently because it is completely reasonable for the caller to pass a closure that relies on being called synchronously or from at most one thread at once and/or within a fixed range of time.  For example, the closure may modify a captured local variable, or it may it use a network connection that will be closed after the API returns.  APIs that want to do this sort of thing have to reserve the right to do that (and even then, they may have binary compatibility limitations), in which case it is totally reasonable to expect them to express that in the type.<br></p><p>&gt; My counter-counterpoint is that you might have some case, like dispatch_async (er, DispatchQueue.async) with a semaphore where you know the closure isn&#39;t escaping, but you need to treat it as one. Maybe that just means we need an asUnsafeEscapingClosure helper in the standard library.<br></p><p>I agree that it&#39;s important to have some unsafe method of dodging the restriction.  Apparently unsafeBitCast works right now, although it really shouldn&#39;t and we should come up with a better alternative.<br></p><p>John.<br></p><p>&gt; I also think it might be useful to be able to annotate references as non-escaping (purely for performance reasons), and I can&#39;t see those being non-escaping by default. I know we don&#39;t want to block one change because of something else that might happen down the line, but still.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 5, 2016, at 20:49, Trent Nadeau via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; https://github.com/tanadeau/swift-evolution/blob/make-noescape-default/proposals/XXXX-make-noescape-default.md &lt;https://github.com/tanadeau/swift-evolution/blob/make-noescape-default/proposals/XXXX-make-noescape-default.md&gt;<br>&gt;&gt; <br>&gt;&gt; # Make non-escaping closures the default<br>&gt;&gt; <br>&gt;&gt; * Proposal: [SE-NNNN](NNNN-name.md)<br>&gt;&gt; * Author: [Trent Nadeau](https://github.com/tanadeau &lt;https://github.com/tanadeau&gt;)<br>&gt;&gt; * Status: **Awaiting review**<br>&gt;&gt; * Review manager: TBD<br>&gt;&gt; <br>&gt;&gt; ## Introduction<br>&gt;&gt; <br>&gt;&gt; The current default of closure arguments to functions (i.e., arguments to functions that themselves have function type such as `(T) -&gt; U`) is to be &quot;escaping&quot;, meaning they can escape the function body such as saving it to a field in a struct or a global variable. In order to say that a closure argument cannot possibly escape the function body (&quot;non-escaping&quot;), the developer must explicitly add an `@noescape` annotation to the argument type.<br>&gt;&gt; <br>&gt;&gt; This proposal switches the default to be non-escaping and requires an `@escaping` annotation if a closure argument can escape the function body. Since the escaping case can be statically detected, this annotation can be added via an error with a fixit. Other annotations that have consequences for escape semantics (e.g., `@autoclosure(escaping)`) will be altered to make use of the new `@escaping` annotation.<br>&gt;&gt; <br>&gt;&gt; Swift-evolution threads: [Discussion thread topic for that proposal (TBD)](http://news.gmane.org/gmane.comp.lang.swift.evolution &lt;http://news.gmane.org/gmane.comp.lang.swift.evolution&gt;)<br>&gt;&gt; <br>&gt;&gt; ## Motivation<br>&gt;&gt; <br>&gt;&gt; Per Chris Lattner [on swift-evolution](https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160530/019880.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160530/019880.html&gt;):<br>&gt;&gt; <br>&gt;&gt; &gt; To provide some more details, this approach has the following advantages:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; - Most functional algorithms written in pure Swift will benefit because they are naturally noescape.  The core team feels that this will reduce the boilerplate involved with writing these algorithms.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; - The compiler has enough logic in it to provide a great QoI experience when a developer doesn’t think about escaping, and tries to escape a closure - it can provide a fixit that suggests adding @escaping.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; - Recent changes (to disallow escaping closures to close over an inout parameter) are pushing the language to prefer noescape closures.  noescape closures have also always been the preferred default, since they eliminate a class of retain cycle issues.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; - &quot;@autoclosure(escaping)&quot; can be simplified and standardized to &quot;@autoclosure @escaping”<br>&gt;&gt; <br>&gt;&gt; ## Detailed design<br>&gt;&gt; <br>&gt;&gt; The `@noescape` annotation is removed from the language. The compiler will emit an error with a fixit to remove the annotation.<br>&gt;&gt; <br>&gt;&gt; The compiler will emit an error if a closure argument is found to possibly escape the function body. In order to silence the warning, the developer must add, manually or via fixit, the `@escaping` annotation to the argument type.<br>&gt;&gt; <br>&gt;&gt; The compiler&#39;s semantic analysis implementation can be simplified as the more constrained escaping case that conflicts with other attributes is now no longer the default.<br>&gt;&gt; <br>&gt;&gt; The standard library should be changed to use the new default whenever possible by removing all uses of `@noescape` and only adding `@escaping` where the compiler detects the need.<br>&gt;&gt; <br>&gt;&gt; ### Imported C/Objective-C APIs<br>&gt;&gt; <br>&gt;&gt; Per the Core Team, most Cocoa closure/block parameters are escaping (e.g., delegates). As such the Clang importer will automatically add the `@escaping` annotation to closure/block parameters encountered in imported Objective-C APIs unless they are explicitly marked with the Clang `((noescape))` attribute. This will also be done with imported C APIs with function pointer or block parameters.<br>&gt;&gt; <br>&gt;&gt; ## Impact on existing code<br>&gt;&gt; <br>&gt;&gt; Existing code using the `@noescape` attribute will need to be migrated to remove the attribute since it will be the default. In addition, the compiler will need to detect escaping closures that are not marked with `@escaping` and create an error with a fixit to add the required attribute.<br>&gt;&gt; <br>&gt;&gt; Uses of `@autoclosure(escaping)` must be changed to `@autoclosure @escaping`.<br>&gt;&gt; <br>&gt;&gt; There should be few, if any, changes required for uses of Cocoa APIs as these will be mostly marked as `@escaping`, and escaping closure arguments are *more* constrained than non-escaping ones.<br>&gt;&gt; <br>&gt;&gt; ## Future directions<br>&gt;&gt; <br>&gt;&gt; The `@noescape(once)` annotation proposed in [SE-0073](https://github.com/apple/swift-evolution/blob/master/proposals/0073-noescape-once.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0073-noescape-once.md&gt;) would, if some future version is accepted, just become `@once`.<br>&gt;&gt; <br>&gt;&gt; ## Alternatives considered<br>&gt;&gt; <br>&gt;&gt; Leave the `@noescape` attribute and existing semantics as they are now.<br>&gt;&gt; <br>&gt;&gt; ## Acknowledgements<br>&gt;&gt; <br>&gt;&gt; Thanks to Chris Lattner, **TBD**, and anyone else who reviewed and contributed to this proposal.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Trent Nadeau<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/69da89ef/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Proposal] Make non-escaping closures the default</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>June  9, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jun 9, 2016, at 16:10, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jun 9, 2016, at 3:43 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;m against this for library evolution reasons: if someone releases a version of their library that has a non-escaping closure and later discovers it needs to be escaping, they can&#39;t change it.<br>&gt;&gt; <br>&gt;&gt; IIRC the counterpoint to this is that people were probably implicitly relying on it being non-escaping already, and that there aren&#39;t many cases where you&#39;d want to do this anyway.<br>&gt; <br>&gt; Right.  APIs are already semantically constrained in how they&#39;re allowed to use their closure arguments.  Closure arguments inject arbitrary code, with arbitrary data access, into the callee; as a rule, the caller must know how the callee intends to use the closure, or its semantics will be grossly violated.  You can&#39;t re-implement an existing API that always synchronously sub-invokes a closure to instead call the closure asynchronously or concurrently because it is completely reasonable for the caller to pass a closure that relies on being called synchronously or from at most one thread at once and/or within a fixed range of time.  For example, the closure may modify a captured local variable, or it may it use a network connection that will be closed after the API returns.  APIs that want to do this sort of thing have to reserve the right to do that (and even then, they may have binary compatibility limitations), in which case it is totally reasonable to expect them to express that in the type.<br></p><p>I don&#39;t buy this. If someone publishes an API that executes something on the current thread today and on a background queue tomorrow, that&#39;s totally fine if they never promised it would execute on a particular thread. If a client accidentally assumes an implementation detail is part of the interface, that&#39;s their fault, and always has been…though the library author might decide to continue supporting their use in the future in the interest of not making waves.<br></p><p>(Escaping/non-escaping by default doesn&#39;t affect this, by the way, but by the same token this argument doesn&#39;t really affect escaping/non-escaping by default.)<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/719f7bab/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Proposal] Make non-escaping closures the default</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>June  9, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jun 9, 2016, at 4:15 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;&gt; On Jun 9, 2016, at 16:10, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 9, 2016, at 3:43 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m against this for library evolution reasons: if someone releases a version of their library that has a non-escaping closure and later discovers it needs to be escaping, they can&#39;t change it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; IIRC the counterpoint to this is that people were probably implicitly relying on it being non-escaping already, and that there aren&#39;t many cases where you&#39;d want to do this anyway.<br>&gt;&gt; <br>&gt;&gt; Right.  APIs are already semantically constrained in how they&#39;re allowed to use their closure arguments.  Closure arguments inject arbitrary code, with arbitrary data access, into the callee; as a rule, the caller must know how the callee intends to use the closure, or its semantics will be grossly violated.  You can&#39;t re-implement an existing API that always synchronously sub-invokes a closure to instead call the closure asynchronously or concurrently because it is completely reasonable for the caller to pass a closure that relies on being called synchronously or from at most one thread at once and/or within a fixed range of time.  For example, the closure may modify a captured local variable, or it may it use a network connection that will be closed after the API returns.  APIs that want to do this sort of thing have to reserve the right to do that (and even then, they may have binary compatibility limitations), in which case it is totally reasonable to expect them to express that in the type.<br>&gt; <br>&gt; I don&#39;t buy this. If someone publishes an API that executes something on the current thread today and on a background queue tomorrow, that&#39;s totally fine if they never promised it would execute on a particular thread. If a client accidentally assumes an implementation detail is part of the interface, that&#39;s their fault, and always has been…though the library author might decide to continue supporting their use in the future in the interest of not making waves.<br></p><p>Synchronous-but-off-thread is kind of a special case because it&#39;s only observable in very special ways, e.g. thread-local storage and the current thread ID.  Concurrent (e.g. calling an enumeration callback on multiple threads simultaneously) and asynchronous (even if it comes back to the current queue) are absolutely something you have to know about as a caller.  It is deeply unreasonable for an API to suddenly start invoking a closure asynchronously when it hasn&#39;t documented that it might do that (perhaps implicitly by obviously following some well-known pattern, e.g. calling the closure a completion handler); that would be a huge semantic and binary-compatibility problem.<br></p><p>Another line of argument: flipping the default is a huge boon to static analysis because (1) closure execution becomes ordered by default and (2) an escaping closure becomes a much more meaningful hint.  For example, consider a use-after-free static analysis that sees this code:<br></p><p>  func foo(ptr: UnsafeMutablePointer&lt;Int&gt;) {<br>    bar { ptr[5] = 0 }<br>    ptr.dealloc()<br>  }<br></p><p>This analysis is currently blocked by this abstraction unless it knows something specific about &#39;bar&#39;.  If &#39;bar&#39; marks its argument @noescape, then the analysis knows that this is safe; but if not, the analysis is unlikely to be willing to warn because it&#39;s quite likely that &#39;bar&#39; is just missing an annotation and does not actually execute its closure asynchronously.  However, if the polarity is flipped, the analysis wins on both ends: it can prove correctness in many more cases by default, and the cases where the closure actually escapes become much more suspicious, probably enough to warn by default.<br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/55973686/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c40db4457ab2c91a0d8006da31b177c6?s=50"></div><header><strong>[Proposal] Make non-escaping closures the default</strong> from <string>Trent Nadeau</string> &lt;tanadeau at gmail.com&gt;<p>June  9, 2016 at 10:00:00pm</p></header><div class="content"><p>Thanks for the very interesting design discussion so far. It&#39;s exactly what<br>I was wanting to see :)<br></p><p>I&#39;m going to incorporate some of this in the next draft of the proposal.<br>I&#39;m also going to add that there should be an asUnsafeEscapingClosure(_:)<br>helper that will convert a default/noescape closure to an escaping one. For<br>the initial implementation it could use unsafeBitCast(_:to:) to perhaps be<br>changed later.<br></p><p>On Thu, Jun 9, 2016 at 8:29 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br></p><p>&gt; On Jun 9, 2016, at 4:15 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;<br>&gt; On Jun 9, 2016, at 16:10, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;<br>&gt; On Jun 9, 2016, at 3:43 PM, Jordan Rose via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I&#39;m against this for library evolution reasons: if someone releases a<br>&gt; version of their library that has a non-escaping closure and later<br>&gt; discovers it needs to be escaping, they can&#39;t change it.<br>&gt;<br>&gt; IIRC the counterpoint to this is that people were probably implicitly<br>&gt; relying on it being non-escaping already, and that there aren&#39;t many cases<br>&gt; where you&#39;d want to do this anyway.<br>&gt;<br>&gt;<br>&gt; Right.  APIs are already semantically constrained in how they&#39;re allowed<br>&gt; to use their closure arguments.  Closure arguments inject arbitrary code,<br>&gt; with arbitrary data access, into the callee; as a rule, the caller must<br>&gt; know how the callee intends to use the closure, or its semantics will be<br>&gt; grossly violated.  You can&#39;t re-implement an existing API that always<br>&gt; synchronously sub-invokes a closure to instead call the closure<br>&gt; asynchronously or concurrently because it is completely reasonable for the<br>&gt; caller to pass a closure that relies on being called synchronously or from<br>&gt; at most one thread at once and/or within a fixed range of time.  For<br>&gt; example, the closure may modify a captured local variable, or it may it use<br>&gt; a network connection that will be closed after the API returns.  APIs that<br>&gt; want to do this sort of thing have to reserve the right to do that (and<br>&gt; even then, they may have binary compatibility limitations), in which case<br>&gt; it is totally reasonable to expect them to express that in the type.<br>&gt;<br>&gt;<br>&gt; I don&#39;t buy this. If someone publishes an API that executes something on<br>&gt; the current thread today and on a background queue tomorrow, that&#39;s totally<br>&gt; fine if they never promised it would execute on a particular thread. If a<br>&gt; client accidentally assumes an implementation detail is part of the<br>&gt; interface, that&#39;s their fault, and always has been…though the library<br>&gt; author might decide to continue supporting their use in the future in the<br>&gt; interest of not making waves.<br>&gt;<br>&gt;<br>&gt; Synchronous-but-off-thread is kind of a special case because it&#39;s only<br>&gt; observable in very special ways, e.g. thread-local storage and the current<br>&gt; thread ID.  Concurrent (e.g. calling an enumeration callback on multiple<br>&gt; threads simultaneously) and asynchronous (even if it comes back to the<br>&gt; current queue) are absolutely something you have to know about as a<br>&gt; caller.  It is deeply unreasonable for an API to suddenly start invoking a<br>&gt; closure asynchronously when it hasn&#39;t documented that it might do that<br>&gt; (perhaps implicitly by obviously following some well-known pattern, e.g.<br>&gt; calling the closure a completion handler); that would be a huge semantic<br>&gt; and binary-compatibility problem.<br>&gt;<br>&gt; Another line of argument: flipping the default is a huge boon to static<br>&gt; analysis because (1) closure execution becomes ordered by default and (2)<br>&gt; an escaping closure becomes a much more meaningful hint.  For example,<br>&gt; consider a use-after-free static analysis that sees this code:<br>&gt;<br>&gt;   func foo(ptr: UnsafeMutablePointer&lt;Int&gt;) {<br>&gt;     bar { ptr[5] = 0 }<br>&gt;     ptr.dealloc()<br>&gt;   }<br>&gt;<br>&gt; This analysis is currently blocked by this abstraction unless it knows<br>&gt; something specific about &#39;bar&#39;.  If &#39;bar&#39; marks its argument @noescape,<br>&gt; then the analysis knows that this is safe; but if not, the analysis is<br>&gt; unlikely to be willing to warn because it&#39;s quite likely that &#39;bar&#39; is just<br>&gt; missing an annotation and does not actually execute its closure<br>&gt; asynchronously.  However, if the polarity is flipped, the analysis wins on<br>&gt; both ends: it can prove correctness in many more cases by default, and the<br>&gt; cases where the closure actually escapes become much more suspicious,<br>&gt; probably enough to warn by default.<br>&gt;<br>&gt; John.<br>&gt;<br></p><p><br></p><p>-- <br>Trent Nadeau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/84cac815/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Make non-escaping closures the default</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>June 20, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jun 9, 2016, at 4:15 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jun 9, 2016, at 16:10, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 9, 2016, at 3:43 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m against this for library evolution reasons: if someone releases a version of their library that has a non-escaping closure and later discovers it needs to be escaping, they can&#39;t change it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; IIRC the counterpoint to this is that people were probably implicitly relying on it being non-escaping already, and that there aren&#39;t many cases where you&#39;d want to do this anyway.<br>&gt;&gt; <br>&gt;&gt; Right.  APIs are already semantically constrained in how they&#39;re allowed to use their closure arguments.  Closure arguments inject arbitrary code, with arbitrary data access, into the callee; as a rule, the caller must know how the callee intends to use the closure, or its semantics will be grossly violated.  You can&#39;t re-implement an existing API that always synchronously sub-invokes a closure to instead call the closure asynchronously or concurrently because it is completely reasonable for the caller to pass a closure that relies on being called synchronously or from at most one thread at once and/or within a fixed range of time.  For example, the closure may modify a captured local variable, or it may it use a network connection that will be closed after the API returns.  APIs that want to do this sort of thing have to reserve the right to do that (and even then, they may have binary compatibility limitations), in which case it is totally reasonable to expect them to express that in the type.<br>&gt; <br>&gt; I don&#39;t buy this. If someone publishes an API that executes something on the current thread today and on a background queue tomorrow, that&#39;s totally fine if they never promised it would execute on a particular thread. If a client accidentally assumes an implementation detail is part of the interface, that&#39;s their fault, and always has been…though the library author might decide to continue supporting their use in the future in the interest of not making waves.<br>&gt; <br>&gt; (Escaping/non-escaping by default doesn&#39;t affect this, by the way, but by the same token this argument doesn&#39;t really affect escaping/non-escaping by default.)<br></p><p>This hardly ever goes well. There&#39;s a pretty long blood trail of blog posts about this kind of attempted evolution in Javascript land; http://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/ happens to be the one I have on hand this moment.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c40db4457ab2c91a0d8006da31b177c6?s=50"></div><header><strong>[Proposal] Make non-escaping closures the default</strong> from <string>Trent Nadeau</string> &lt;tanadeau at gmail.com&gt;<p>June 20, 2016 at 10:00:00pm</p></header><div class="content"><p>I&#39;ve created the PR for the proposal at<br>https://github.com/apple/swift-evolution/pull/373.<br></p><p>Thanks again to everyone that has discussed this so far.<br></p><p>On Mon, Jun 20, 2016 at 8:18 PM, Joe Groff via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Jun 9, 2016, at 4:15 PM, Jordan Rose via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; On Jun 9, 2016, at 16:10, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On Jun 9, 2016, at 3:43 PM, Jordan Rose via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; I&#39;m against this for library evolution reasons: if someone releases a<br>&gt; version of their library that has a non-escaping closure and later<br>&gt; discovers it needs to be escaping, they can&#39;t change it.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; IIRC the counterpoint to this is that people were probably implicitly<br>&gt; relying on it being non-escaping already, and that there aren&#39;t many cases<br>&gt; where you&#39;d want to do this anyway.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Right.  APIs are already semantically constrained in how they&#39;re<br>&gt; allowed to use their closure arguments.  Closure arguments inject arbitrary<br>&gt; code, with arbitrary data access, into the callee; as a rule, the caller<br>&gt; must know how the callee intends to use the closure, or its semantics will<br>&gt; be grossly violated.  You can&#39;t re-implement an existing API that always<br>&gt; synchronously sub-invokes a closure to instead call the closure<br>&gt; asynchronously or concurrently because it is completely reasonable for the<br>&gt; caller to pass a closure that relies on being called synchronously or from<br>&gt; at most one thread at once and/or within a fixed range of time.  For<br>&gt; example, the closure may modify a captured local variable, or it may it use<br>&gt; a network connection that will be closed after the API returns.  APIs that<br>&gt; want to do this sort of thing have to reserve the right to do that (and<br>&gt; even then, they may have binary compatibility limitations), in which case<br>&gt; it is totally reasonable to expect them to express that in the type.<br>&gt; &gt;<br>&gt; &gt; I don&#39;t buy this. If someone publishes an API that executes something on<br>&gt; the current thread today and on a background queue tomorrow, that&#39;s totally<br>&gt; fine if they never promised it would execute on a particular thread. If a<br>&gt; client accidentally assumes an implementation detail is part of the<br>&gt; interface, that&#39;s their fault, and always has been…though the library<br>&gt; author might decide to continue supporting their use in the future in the<br>&gt; interest of not making waves.<br>&gt; &gt;<br>&gt; &gt; (Escaping/non-escaping by default doesn&#39;t affect this, by the way, but<br>&gt; by the same token this argument doesn&#39;t really affect escaping/non-escaping<br>&gt; by default.)<br>&gt;<br>&gt; This hardly ever goes well. There&#39;s a pretty long blood trail of blog<br>&gt; posts about this kind of attempted evolution in Javascript land;<br>&gt; http://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/<br>&gt; happens to be the one I have on hand this moment.<br>&gt;<br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br></p><p>-- <br>Trent Nadeau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160620/f8999b74/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
