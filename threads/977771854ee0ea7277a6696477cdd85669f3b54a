<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>&quot;AnyValue&quot;, &quot;protocol MyProtocol : value&quot; as counterpart to &quot;AnyObject&quot;, &quot;: class&quot;</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>May 15, 2016 at 05:00:00am</p></header><div class="content"><p>I was building a collection object recently, which stores an array of tuples: (Range&lt;I&gt;, T) - some generic type, and a range. <br>Part of the workings of the collection involves splitting these tuples, which means we need to split the Range (easy enough) and duplicate T.<br></p><p>In practice, I was using value types for T (it was another Array), so I could duplicate by assignment; but what if somebody stuck an NSArray or other reference-type in instead?<br></p><p>My first thought was - I could allow it, create some “Copyable” protocol and require conformance. But there are other guarantees I get from value types as well. Let’s say I had a sorted Array of T; if T could be a reference-type, anybody who gets a T from the collection could mutate it and invalidate the sort order at any time! That could lead to unexpected behaviour, such as infinite loops in binary-search algorithms, and it might not be obvious to a user of the collection how that happened (or that it’s even their fault - how are they supposed to know this is kept in a sorted Array, especially if it’s wrapped by another type, and that this particular search algorithm could infinitely loop if the Array is not sorted?). I could return a copy from the getter, but at this point I’m basically re-inventing value-type semantics for classes while creating burdensome requirements for actual value-types.<br></p><p>Actually, this is a problem with the language in general. While we have a way to specify that a generic type or protocol must obey reference-type semantics (via “&lt;T where T:AnyObject&gt;”, “protocol MyProtocol : class”), we don’t have a value-type semantic counterpart.<br></p><p>So I’d like to see us provide an “AnyValue” and “value” equivalent. We should be able to require that generic types or protocols are satisfied by values so we know how to treat them.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>&quot;AnyValue&quot;, &quot;protocol MyProtocol : value&quot; as counterpart to &quot;AnyObject&quot;, &quot;: class&quot;</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May 15, 2016 at 09:00:00am</p></header><div class="content"><p>Might have a look at this thread, where value semantics is been discussed already: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160502/016286.html (Should we rename &quot;class&quot; when referring to	protocol conformance?)<br></p><p>I’m also proposing for a `Type` merging mechanism with the potential to replace `protocol&lt;&gt;` called `type&lt;&gt;` aka. `all&lt;&gt;` aka. `All&lt;&gt;` (and in some point the core team names a portion of it `Any&lt;&gt;` in their docs: https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md).<br></p><p>My proposal thread is here: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160502/016523.html ([Pitch] merge types and protocols back together with type&lt;Type, Protocol, …&gt;)<br></p><p>If you want to read my detailed design, take a look at this WIP draft: https://github.com/DevAndArtist/swift-evolution/blob/master/proposals/nnnn-merging-types-with-protocols.md <br>I will rewrite a few things when I find some time to match a few things from the GenericsManifesto.<br></p><p>Anyways may I sum a few of my thoughts up for you:<br></p><p>- from the GenericsManifesto we “might“ see something like “Generalized `class` constraints“ in Swifts future: `typealias AnyObject = protocol&lt;class&gt;`<br></p><p>- if my proposal will be accepted and `class` is generalized already we’ll have something like this: `typealias AnyObject = All&lt;class&gt;`<br>        * `All&lt;&gt;` will create a type from all constraints inside the angle brackets, this will create a new `Type` like `All&lt;UIView, SomeProtocol&gt;` where `SomeProtocol` sits on the .dynamicType rather than on `UIView`<br>        * this will solve this problem https://openradar.appspot.com/20990743<br>        * future flattened version of `All&lt;&gt;` might have operators and could be expressed like this: `func foo(value: UIView &amp; SomeProtocol)`<br></p><p>- there are two future directions in my proposal: <br>       (1) `Any&lt;&gt;` which takes only one type from the angle brackets: `Any&lt;String, Int&gt;` or `String | Int`<br>       (2) if we already have a generalized `class` keyword, so why we don’t get `struct` and `enum` as well?<br></p><p>With this we can create a typealias for `AnyValue` like this (at least for generalized extendable types): <br>       `typealias AnyStruct = All&lt;struct&gt;`<br>       `typealias AnyEnum = All&lt;enum&gt;`<br>       `typealias AnyValue = Any&lt;All&lt;struct&gt;, All&lt;enum&gt;&gt;`<br>       `typealias AnyValue = AnyStruct | AnyEnum`<br></p><p>The future might also see:  `typealias AnyValue = Any&lt;All&lt;struct&gt;, All&lt;enum&gt;, All&lt;tuple&gt;&gt;`<br></p><p>But again I have to rewrite a lot of things in my proposal towards this direction. ;)<br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 15. Mai 2016 bei 05:20:29, Karl via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p>I was building a collection object recently, which stores an array of tuples: (Range&lt;I&gt;, T) - some generic type, and a range.  <br>Part of the workings of the collection involves splitting these tuples, which means we need to split the Range (easy enough) and duplicate T.<br></p><p>In practice, I was using value types for T (it was another Array), so I could duplicate by assignment; but what if somebody stuck an NSArray or other reference-type in instead?<br></p><p>My first thought was - I could allow it, create some “Copyable” protocol and require conformance. But there are other guarantees I get from value types as well. Let’s say I had a sorted Array of T; if T could be a reference-type, anybody who gets a T from the collection could mutate it and invalidate the sort order at any time! That could lead to unexpected behaviour, such as infinite loops in binary-search algorithms, and it might not be obvious to a user of the collection how that happened (or that it’s even their fault - how are they supposed to know this is kept in a sorted Array, especially if it’s wrapped by another type, and that this particular search algorithm could infinitely loop if the Array is not sorted?). I could return a copy from the getter, but at this point I’m basically re-inventing value-type semantics for classes while creating burdensome requirements for actual value-types.<br></p><p>Actually, this is a problem with the language in general. While we have a way to specify that a generic type or protocol must obey reference-type semantics (via “&lt;T where T:AnyObject&gt;”, “protocol MyProtocol : class”), we don’t have a value-type semantic counterpart.<br></p><p>So I’d like to see us provide an “AnyValue” and “value” equivalent. We should be able to require that generic types or protocols are satisfied by values so we know how to treat them.<br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160515/f16bb772/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
