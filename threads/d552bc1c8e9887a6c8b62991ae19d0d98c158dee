<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8809800aec2460f291384b794d7e6f8f?s=50"></div><header><strong>Will Swift ever support optional methods without @objc?</strong> from <string>Rick Mann</string> &lt;rmann at latencyzero.com&gt;<p>November 14, 2016 at 03:00:00pm</p></header><div class="content"><p>Will Swift ever support optional methods without @objc?<br></p><p>What are the disadvantages of marking a protocol @objc?<br></p><p>Thanks!<br></p><p>-- <br>Rick Mann<br>rmann at latencyzero.com<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4c198ffcf0853e6011f58fdcdd32a111?s=50"></div><header><strong>Will Swift ever support optional methods without @objc?</strong> from <string>Benjamin Spratling</string> &lt;bspratling at mac.com&gt;<p>November 14, 2016 at 06:00:00pm</p></header><div class="content"><p>Given optionals and closures, is it necessary to support optional protocols?<br></p><p>protocol MyProtocol {<br>	var titleForRow:((_ indexPath:IndexPath)-&gt;(String))? { get }<br>}<br></p><p>One disadvantage is that you need Obj-C, which means it doesn’t run on linux, or several other platforms.<br>Another disadvantage, as I understand it, is it requires slower Obj-c dispatch, instead of witness tables.  Obj-C dispatch also only considers names, not argument &amp; return types.<br></p><p>&gt; On Nov 14, 2016, at 5:48 PM, Rick Mann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Will Swift ever support optional methods without @objc?<br>&gt; <br>&gt; What are the disadvantages of marking a protocol @objc?<br>&gt; <br>&gt; Thanks!<br>&gt; <br>&gt; -- <br>&gt; Rick Mann<br>&gt; rmann at latencyzero.com<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e941adb360692446106cebd7f6d2a1a3?s=50"></div><header><strong>Will Swift ever support optional methods without @objc?</strong> from <string>Charles Constant</string> &lt;charles at charlesism.com&gt;<p>November 14, 2016 at 05:00:00pm</p></header><div class="content"><p>The disadvantage is that it&#39;s easy in Swift to push millions of things in<br>protocols, and end up with:<br></p><p>    class MyClass: SwiftProtocollable, MoreFunctionalityable, MoreHereable,<br>StillMoreable, ThisTooable, StillMoreable {<br>        ...<br>    }<br></p><p>Given enough thought, maybe this can be avoided, but the problem is (as far<br>as I can tell, and I may be out to lunch) that protocols are<br>philosophically the &quot;correct&quot; way in Swift to do a lot of things.<br></p><p>I recently wrote a tiny framework for Drag n Drop, and I wound up with<br>various combinations of almost 10 protocols - and, afai could tell, that<br>was &quot;correct&quot; because I was specifying the different abilities of my<br>classes (eg: do they have methods for reading text data, file data, writing<br>promises, reading promises, etc) It&#39;s just not easy to read.<br></p><p><br></p><p><br>On Mon, Nov 14, 2016 at 4:10 PM, Benjamin Spratling via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Given optionals and closures, is it necessary to support optional<br>&gt; protocols?<br>&gt;<br>&gt; protocol MyProtocol {<br>&gt;         var titleForRow:((_ indexPath:IndexPath)-&gt;(String))? { get }<br>&gt; }<br>&gt;<br>&gt; One disadvantage is that you need Obj-C, which means it doesn’t run on<br>&gt; linux, or several other platforms.<br>&gt; Another disadvantage, as I understand it, is it requires slower Obj-c<br>&gt; dispatch, instead of witness tables.  Obj-C dispatch also only considers<br>&gt; names, not argument &amp; return types.<br>&gt;<br>&gt; &gt; On Nov 14, 2016, at 5:48 PM, Rick Mann via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Will Swift ever support optional methods without @objc?<br>&gt; &gt;<br>&gt; &gt; What are the disadvantages of marking a protocol @objc?<br>&gt; &gt;<br>&gt; &gt; Thanks!<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Rick Mann<br>&gt; &gt; rmann at latencyzero.com<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161114/e4172f2d/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8809800aec2460f291384b794d7e6f8f?s=50"></div><header><strong>Will Swift ever support optional methods without @objc?</strong> from <string>Rick Mann</string> &lt;rmann at latencyzero.com&gt;<p>November 14, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Nov 14, 2016, at 16:10 , Benjamin Spratling via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Given optionals and closures, is it necessary to support optional protocols?<br>&gt; <br>&gt; protocol MyProtocol {<br>&gt; 	var titleForRow:((_ indexPath:IndexPath)-&gt;(String))? { get }<br>&gt; }<br></p><p>Well, it would be nice if making a func optional at least acted as syntactic sugar for this, wouldn&#39;t it?<br></p><p>&gt; One disadvantage is that you need Obj-C, which means it doesn’t run on linux, or several other platforms.<br>&gt; Another disadvantage, as I understand it, is it requires slower Obj-c dispatch, instead of witness tables.  Obj-C dispatch also only considers names, not argument &amp; return types.<br></p><p>Does implementing an @objc protocol then make all my class&#39; methods use objc-dispatch? Or just the ones in the protocol?<br></p><p>Thanks,<br></p><p>&gt; <br>&gt;&gt; On Nov 14, 2016, at 5:48 PM, Rick Mann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Will Swift ever support optional methods without @objc?<br>&gt;&gt; <br>&gt;&gt; What are the disadvantages of marking a protocol @objc?<br>&gt;&gt; <br>&gt;&gt; Thanks!<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Rick Mann<br>&gt;&gt; rmann at latencyzero.com<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br>-- <br>Rick Mann<br>rmann at latencyzero.com<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>Will Swift ever support optional methods without @objc?</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>November 15, 2016 at 07:00:00am</p></header><div class="content"><p>One major example is the NS/UITableViewDataSource or Delegate - there are many many methods that you don&#39;t need to implement, hence are optional.<br></p><p>But I think that this was partially solved by default implementation of protocol methods, which pretty much does what you want...<br></p><p><br>&gt; On Nov 15, 2016, at 1:10 AM, Benjamin Spratling via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Given optionals and closures, is it necessary to support optional protocols?<br>&gt; <br>&gt; protocol MyProtocol {<br>&gt; 	var titleForRow:((_ indexPath:IndexPath)-&gt;(String))? { get }<br>&gt; }<br>&gt; <br>&gt; One disadvantage is that you need Obj-C, which means it doesn’t run on linux, or several other platforms.<br>&gt; Another disadvantage, as I understand it, is it requires slower Obj-c dispatch, instead of witness tables.  Obj-C dispatch also only considers names, not argument &amp; return types.<br>&gt; <br>&gt;&gt; On Nov 14, 2016, at 5:48 PM, Rick Mann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Will Swift ever support optional methods without @objc?<br>&gt;&gt; <br>&gt;&gt; What are the disadvantages of marking a protocol @objc?<br>&gt;&gt; <br>&gt;&gt; Thanks!<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Rick Mann<br>&gt;&gt; rmann at latencyzero.com<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8809800aec2460f291384b794d7e6f8f?s=50"></div><header><strong>Will Swift ever support optional methods without @objc?</strong> from <string>Rick Mann</string> &lt;rmann at latencyzero.com&gt;<p>November 14, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Nov 14, 2016, at 22:51 , Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; One major example is the NS/UITableViewDataSource or Delegate - there are many many methods that you don&#39;t need to implement, hence are optional.<br>&gt; <br>&gt; But I think that this was partially solved by default implementation of protocol methods, which pretty much does what you want...<br></p><p>I just realized I only responded to someone else, and not the whole list. It does, but it forces me to make the return value of the protocol method optional, so that the default implementation can return nil. <br></p><p>In the end, I guess that&#39;s not so bad, since I&#39;m not happy with the entire approach, but it&#39;ll do for now.<br></p><p>-- <br>Rick Mann<br>rmann at latencyzero.com<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>Will Swift ever support optional methods without @objc?</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>November 15, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Nov 15, 2016, at 8:53 AM, Rick Mann &lt;rmann at latencyzero.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Nov 14, 2016, at 22:51 , Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; One major example is the NS/UITableViewDataSource or Delegate - there are many many methods that you don&#39;t need to implement, hence are optional.<br>&gt;&gt; <br>&gt;&gt; But I think that this was partially solved by default implementation of protocol methods, which pretty much does what you want...<br>&gt; <br>&gt; I just realized I only responded to someone else, and not the whole list. It does, but it forces me to make the return value of the protocol method optional, so that the default implementation can return nil. <br></p><p>You&#39;d still get an optional even with @optional protocol methods:<br></p><p>@objc<br>protocol Foo {<br>	@optional func bar() -&gt; Int<br>}<br></p><p>let x = foo.bar?() // x is Int?<br></p><p>Nevertheless, in the previous example:<br></p><p>&gt; 	var titleForRow:((_ indexPath:IndexPath)-&gt;(String))? { get }<br></p><p>You can return String? in the closure instead and the default implementation can simply return a closure that returns nil. This is pretty much equivalent.<br></p><p><br>&gt; In the end, I guess that&#39;s not so bad, since I&#39;m not happy with the entire approach, but it&#39;ll do for now.<br>&gt; <br>&gt; -- <br>&gt; Rick Mann<br>&gt; rmann at latencyzero.com<br>&gt; <br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Will Swift ever support optional methods without @objc?</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>November 15, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On 15 Nov 2016, at 07:53, Rick Mann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Nov 14, 2016, at 22:51 , Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; One major example is the NS/UITableViewDataSource or Delegate - there are many many methods that you don&#39;t need to implement, hence are optional.<br>&gt;&gt; <br>&gt;&gt; But I think that this was partially solved by default implementation of protocol methods, which pretty much does what you want...<br>&gt; <br>&gt; I just realized I only responded to someone else, and not the whole list. It does, but it forces me to make the return value of the protocol method optional, so that the default implementation can return nil. <br>&gt; <br>&gt; In the end, I guess that&#39;s not so bad, since I&#39;m not happy with the entire approach, but it&#39;ll do for now.<br></p><p>What&#39;s different about having the method return nil vs being optional? You&#39;re attempting to call it either way, and presumably need some means of handling the return value, except in Swift it&#39;s all nice and explicit and easy to put in a conditional like:<br></p><p>	if let result = myObject.someOptionalMethod() { /* Do some stuff */ }<br>	print(myObject.someOptionalStringMethod() ?? &quot;&quot;)<br></p><p>And so-on. If you need a method to be both optional, and return a nilable result then you can use a double optional like so:<br></p><p>	if let result = myObject.someDoubleOptionalMethod() { // Method was implemented<br>		if let value = result { // Method returned a value<br>			/* Do some stuff */<br>		}<br>	}<br></p><p><br>By defining the methods as returning an Optional and throwing in default implementations you can specify fewer, bigger protocols and make clear what the requirements really are, though personally given the choice I&#39;d prefer a dozen smaller protocols that are absolutely explicit in what they do.<br></p><p>But yeah, I think the tools you need are all there already; maybe there&#39;s an argument to be made for allowing default return values on protocol methods, to reduce the boiler-plate?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161115/e0aea347/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>Will Swift ever support optional methods without @objc?</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>November 15, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On 15 Nov 2016, at 12:22, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 15 Nov 2016, at 07:53, Rick Mann via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Nov 14, 2016, at 22:51 , Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One major example is the NS/UITableViewDataSource or Delegate - there are many many methods that you don&#39;t need to implement, hence are optional.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But I think that this was partially solved by default implementation of protocol methods, which pretty much does what you want...<br>&gt;&gt; <br>&gt;&gt; I just realized I only responded to someone else, and not the whole list. It does, but it forces me to make the return value of the protocol method optional, so that the default implementation can return nil. <br>&gt;&gt; <br>&gt;&gt; In the end, I guess that&#39;s not so bad, since I&#39;m not happy with the entire approach, but it&#39;ll do for now.<br>&gt; <br>&gt; What&#39;s different about having the method return nil vs being optional? You&#39;re attempting to call it either way, and presumably need some means of handling the return value, except in Swift it&#39;s all nice and explicit and easy to put in a conditional like:<br>&gt; <br>&gt; 	if let result = myObject.someOptionalMethod() { /* Do some stuff */ }<br>&gt; 	print(myObject.someOptionalStringMethod() ?? &quot;&quot;)<br>&gt; <br>&gt; And so-on. If you need a method to be both optional, and return a nilable result then you can use a double optional like so:<br>&gt; <br>&gt; 	if let result = myObject.someDoubleOptionalMethod() { // Method was implemented<br>&gt; 		if let value = result { // Method returned a value<br>&gt; 			/* Do some stuff */<br>&gt; 		}<br>&gt; 	}<br>&gt; <br>&gt; <br>&gt; By defining the methods as returning an Optional and throwing in default implementations you can specify fewer, bigger protocols and make clear what the requirements really are, though personally given the choice I&#39;d prefer a dozen smaller protocols that are absolutely explicit in what they do.<br>&gt; <br>&gt; But yeah, I think the tools you need are all there already; maybe there&#39;s an argument to be made for allowing default return values on protocol methods, to reduce the boiler-plate?<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>I think there is a difference between:<br></p><p>- A method which returns an optional result, and<br>- An optional method which, if present, always returns a result<br></p><p>Perhaps not so much of a difference at the usage site (it’s just a question of placing a ? for optional chaining), but semantically and when conforming to the protocol, they mean different things.<br></p><p>- Karl<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161115/e13f1fc9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>Will Swift ever support optional methods without @objc?</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>November 15, 2016 at 03:00:00pm</p></header><div class="content"><p>This has been discussed somewhat heavily in the past and nothing yet has<br>really moved forward on it. I do think a good way of doing something like<br>this would be helpful. I have resulted to defining an interface with an<br>extension that provides empty defaults and for each function a match bool<br>var exists to imply if it exists or not. The code accepting a delegate can<br>probe these bool vars to configure itself to efficiently operate based on<br>knowledge about what the delegate expects (some missing from most proposed<br>solutions other then @objc optional).<br>On Tue, Nov 15, 2016 at 6:59 AM Karl via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On 15 Nov 2016, at 12:22, Haravikk via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On 15 Nov 2016, at 07:53, Rick Mann via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Nov 14, 2016, at 22:51 , Charlie Monroe via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; One major example is the NS/UITableViewDataSource or Delegate - there are<br>&gt; many many methods that you don&#39;t need to implement, hence are optional.<br>&gt;<br>&gt; But I think that this was partially solved by default implementation of<br>&gt; protocol methods, which pretty much does what you want...<br>&gt;<br>&gt;<br>&gt; I just realized I only responded to someone else, and not the whole list.<br>&gt; It does, but it forces me to make the return value of the protocol method<br>&gt; optional, so that the default implementation can return nil.<br>&gt;<br>&gt; In the end, I guess that&#39;s not so bad, since I&#39;m not happy with the entire<br>&gt; approach, but it&#39;ll do for now.<br>&gt;<br>&gt;<br>&gt; What&#39;s different about having the method return nil vs being optional?<br>&gt; You&#39;re attempting to call it either way, and presumably need some means of<br>&gt; handling the return value, except in Swift it&#39;s all nice and explicit and<br>&gt; easy to put in a conditional like:<br>&gt;<br>&gt; if let result = myObject.someOptionalMethod() { /* Do some stuff */ }<br>&gt; print(myObject.someOptionalStringMethod() ?? &quot;&quot;)<br>&gt;<br>&gt; And so-on. If you need a method to be both optional, and return a nilable<br>&gt; result then you can use a double optional like so:<br>&gt;<br>&gt; if let result = myObject.someDoubleOptionalMethod() { // Method was<br>&gt; implemented<br>&gt; if let value = result { // Method returned a value<br>&gt; /* Do some stuff */<br>&gt; }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; By defining the methods as returning an Optional and throwing in default<br>&gt; implementations you can specify fewer, bigger protocols and make clear what<br>&gt; the requirements really are, though personally given the choice I&#39;d prefer<br>&gt; a dozen smaller protocols that are absolutely explicit in what they do.<br>&gt;<br>&gt; But yeah, I think the tools you need are all there already; maybe there&#39;s<br>&gt; an argument to be made for allowing default return values on protocol<br>&gt; methods, to reduce the boiler-plate?<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; I think there is a difference between:<br>&gt;<br>&gt; - A method which returns an optional result, and<br>&gt; - An optional method which, if present, always returns a result<br>&gt;<br>&gt; Perhaps not so much of a difference at the usage site (it’s just a<br>&gt; question of placing a ? for optional chaining), but semantically and when<br>&gt; conforming to the protocol, they mean different things.<br>&gt;<br>&gt; - Karl<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161115/d0c9cf5d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>Will Swift ever support optional methods without @objc?</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>November 15, 2016 at 03:00:00pm</p></header><div class="content"><p>Note you can also use a protocol of optional methods to do the same things<br>as the var... I for now haven&#39;t done it that way.<br></p><p>On Tue, Nov 15, 2016 at 7:46 AM Shawn Erickson &lt;shawnce at gmail.com&gt; wrote:<br></p><p>&gt; This has been discussed somewhat heavily in the past and nothing yet has<br>&gt; really moved forward on it. I do think a good way of doing something like<br>&gt; this would be helpful. I have resulted to defining an interface with an<br>&gt; extension that provides empty defaults and for each function a match bool<br>&gt; var exists to imply if it exists or not. The code accepting a delegate can<br>&gt; probe these bool vars to configure itself to efficiently operate based on<br>&gt; knowledge about what the delegate expects (some missing from most proposed<br>&gt; solutions other then @objc optional).<br>&gt; On Tue, Nov 15, 2016 at 6:59 AM Karl via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On 15 Nov 2016, at 12:22, Haravikk via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On 15 Nov 2016, at 07:53, Rick Mann via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Nov 14, 2016, at 22:51 , Charlie Monroe via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; One major example is the NS/UITableViewDataSource or Delegate - there are<br>&gt; many many methods that you don&#39;t need to implement, hence are optional.<br>&gt;<br>&gt; But I think that this was partially solved by default implementation of<br>&gt; protocol methods, which pretty much does what you want...<br>&gt;<br>&gt;<br>&gt; I just realized I only responded to someone else, and not the whole list.<br>&gt; It does, but it forces me to make the return value of the protocol method<br>&gt; optional, so that the default implementation can return nil.<br>&gt;<br>&gt; In the end, I guess that&#39;s not so bad, since I&#39;m not happy with the entire<br>&gt; approach, but it&#39;ll do for now.<br>&gt;<br>&gt;<br>&gt; What&#39;s different about having the method return nil vs being optional?<br>&gt; You&#39;re attempting to call it either way, and presumably need some means of<br>&gt; handling the return value, except in Swift it&#39;s all nice and explicit and<br>&gt; easy to put in a conditional like:<br>&gt;<br>&gt; if let result = myObject.someOptionalMethod() { /* Do some stuff */ }<br>&gt; print(myObject.someOptionalStringMethod() ?? &quot;&quot;)<br>&gt;<br>&gt; And so-on. If you need a method to be both optional, and return a nilable<br>&gt; result then you can use a double optional like so:<br>&gt;<br>&gt; if let result = myObject.someDoubleOptionalMethod() { // Method was<br>&gt; implemented<br>&gt; if let value = result { // Method returned a value<br>&gt; /* Do some stuff */<br>&gt; }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; By defining the methods as returning an Optional and throwing in default<br>&gt; implementations you can specify fewer, bigger protocols and make clear what<br>&gt; the requirements really are, though personally given the choice I&#39;d prefer<br>&gt; a dozen smaller protocols that are absolutely explicit in what they do.<br>&gt;<br>&gt; But yeah, I think the tools you need are all there already; maybe there&#39;s<br>&gt; an argument to be made for allowing default return values on protocol<br>&gt; methods, to reduce the boiler-plate?<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; I think there is a difference between:<br>&gt;<br>&gt; - A method which returns an optional result, and<br>&gt; - An optional method which, if present, always returns a result<br>&gt;<br>&gt; Perhaps not so much of a difference at the usage site (it’s just a<br>&gt; question of placing a ? for optional chaining), but semantically and when<br>&gt; conforming to the protocol, they mean different things.<br>&gt;<br>&gt; - Karl<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161115/b83db288/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>Will Swift ever support optional methods without @objc?</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>November 15, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On 15 Nov 2016, at 16:46, Shawn Erickson &lt;shawnce at gmail.com&gt; wrote:<br>&gt; <br>&gt; This has been discussed somewhat heavily in the past and nothing yet has really moved forward on it. I do think a good way of doing something like this would be helpful. I have resulted to defining an interface with an extension that provides empty defaults and for each function a match bool var exists to imply if it exists or not. The code accepting a delegate can probe these bool vars to configure itself to efficiently operate based on knowledge about what the delegate expects (some missing from most proposed solutions other then @objc optional).<br>&gt; On Tue, Nov 15, 2016 at 6:59 AM Karl via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On 15 Nov 2016, at 12:22, Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 15 Nov 2016, at 07:53, Rick Mann via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Nov 14, 2016, at 22:51 , Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One major example is the NS/UITableViewDataSource or Delegate - there are many many methods that you don&#39;t need to implement, hence are optional.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But I think that this was partially solved by default implementation of protocol methods, which pretty much does what you want...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I just realized I only responded to someone else, and not the whole list. It does, but it forces me to make the return value of the protocol method optional, so that the default implementation can return nil. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In the end, I guess that&#39;s not so bad, since I&#39;m not happy with the entire approach, but it&#39;ll do for now.<br>&gt;&gt; <br>&gt;&gt; What&#39;s different about having the method return nil vs being optional? You&#39;re attempting to call it either way, and presumably need some means of handling the return value, except in Swift it&#39;s all nice and explicit and easy to put in a conditional like:<br>&gt;&gt; <br>&gt;&gt; 	if let result = myObject.someOptionalMethod() { /* Do some stuff */ }<br>&gt;&gt; 	print(myObject.someOptionalStringMethod() ?? &quot;&quot;)<br>&gt;&gt; <br>&gt;&gt; And so-on. If you need a method to be both optional, and return a nilable result then you can use a double optional like so:<br>&gt;&gt; <br>&gt;&gt; 	if let result = myObject.someDoubleOptionalMethod() { // Method was implemented<br>&gt;&gt; 		if let value = result { // Method returned a value<br>&gt;&gt; 			/* Do some stuff */<br>&gt;&gt; 		}<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; By defining the methods as returning an Optional and throwing in default implementations you can specify fewer, bigger protocols and make clear what the requirements really are, though personally given the choice I&#39;d prefer a dozen smaller protocols that are absolutely explicit in what they do.<br>&gt;&gt; <br>&gt;&gt; But yeah, I think the tools you need are all there already; maybe there&#39;s an argument to be made for allowing default return values on protocol methods, to reduce the boiler-plate?<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; I think there is a difference between:<br>&gt; <br>&gt; - A method which returns an optional result, and<br>&gt; - An optional method which, if present, always returns a result<br>&gt; <br>&gt; Perhaps not so much of a difference at the usage site (it’s just a question of placing a ? for optional chaining), but semantically and when conforming to the protocol, they mean different things.<br>&gt; <br>&gt; - Karl<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>If you don’t mind me asking, what is your use-case?<br></p><p>Even though I think &quot;optional methods&quot; and “methods returning optionals” are different things, I don’t really have any examples where optional methods are better than sub-protocols.<br></p><p>e.g.<br></p><p>```<br>// Core callbacks<br>protocol MyDelegate { }<br></p><p>// Optional callbacks, added like a mixin<br>protocol MyDelegateWithExtras : MyDelegate { }<br></p><p>// Some more optional callbacks<br>protocol MySubDelegate : MyDelegate {}<br></p><p>class DelegateImpl : MySubDelegate, MyDelegateWithExtras {<br>  // Implement all core + optional callbacks<br>}<br></p><p>var d : MyDelegate = DelegateImpl()<br></p><p>if let extras = d as? MyDelegateWithExtras {<br>    // invoke optional functionality<br>}<br>```<br></p><p>I don’t know what the overhead of the as? call is, but it’s almost certainly less than an Obj-C `respondsToSelector` call. Depending on whether you need to swap the delegate for objects of different types, you could also use generics to optimise the checks (and possibly more) away.<br></p><p>- Karl<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161115/c74345cd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>Will Swift ever support optional methods without @objc?</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>November 15, 2016 at 06:00:00pm</p></header><div class="content"><p>Using sub-protocols may be sufficient and make sense... to be honest I<br>haven&#39;t had the time to fully explore this space and convert some things I<br>have done in objective-c to pure swift. I do wonder how often that those<br>sub-protocols would degenerate into having single methods.<br></p><p>In a nut shell it isn&#39;t atypical for a delegate to only care about<br>&quot;injecting itself&quot; (e.g. implementing a delegate function) for a subset of<br>the available delegation points leaving the others unimplemented. In the<br>objective-c case the delegator can evaluate what delegation points a<br>delegate implements at time of delegate registration (or more dynamically<br>... however I often did imp caching for performance reasons in some of my<br>designs). This probe on delegate registration may make sense for the<br>delegator if additional bookkeeping, processing, state management, or<br>potentially whole code path/objects can be avoided if the delegate doesn&#39;t<br>implement a delegation point(s). If the delegation points happened to be<br>implemented using a default nop implementation this type of optimization<br>may not be possible.<br></p><p>In a nutshell I see and have the need for the delegator to know if the<br>delegate has actually provided an implementation of their own or not so I<br>can potentially leverage optimizations internal to my delegator. As a<br>delegate is also nice to know clearly what I have to implement or not and<br>the optional protocol member concept is one way of doing that, it would be<br>nice to have something like that to help delegate implementors.<br></p><p>I suggest mentally evaluating the delegation points of URLSession with the<br>perspective of the delegator (URLSession) being able to optimize what it<br>does based what it delegate has provided and implementation for. For<br>example the new metrics delegation point like could optimize away book<br>keeping and related processing if the delegate isn&#39;t interested.<br>Additionally look at it from the point of view of a delegate implementor<br>noting the despite already having some number of sub-protocols you still<br>often only implement one or two delegate points. Alternate swifty<br>implementations likely exist that would be interesting to explore to help<br>inform what makes sense as a language addition and/or help folks used to<br>&quot;traditional&quot; delegation pattern under Objective-C follow more Swifty<br>patterns going forward.<br></p><p>-Shawn<br></p><p>On Tue, Nov 15, 2016 at 9:24 AM Karl &lt;razielim at gmail.com&gt; wrote:<br></p><p>&gt;<br>&gt; On 15 Nov 2016, at 16:46, Shawn Erickson &lt;shawnce at gmail.com&gt; wrote:<br>&gt;<br>&gt; This has been discussed somewhat heavily in the past and nothing yet has<br>&gt; really moved forward on it. I do think a good way of doing something like<br>&gt; this would be helpful. I have resulted to defining an interface with an<br>&gt; extension that provides empty defaults and for each function a match bool<br>&gt; var exists to imply if it exists or not. The code accepting a delegate can<br>&gt; probe these bool vars to configure itself to efficiently operate based on<br>&gt; knowledge about what the delegate expects (some missing from most proposed<br>&gt; solutions other then @objc optional).<br>&gt; On Tue, Nov 15, 2016 at 6:59 AM Karl via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On 15 Nov 2016, at 12:22, Haravikk via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On 15 Nov 2016, at 07:53, Rick Mann via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Nov 14, 2016, at 22:51 , Charlie Monroe via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; One major example is the NS/UITableViewDataSource or Delegate - there are<br>&gt; many many methods that you don&#39;t need to implement, hence are optional.<br>&gt;<br>&gt; But I think that this was partially solved by default implementation of<br>&gt; protocol methods, which pretty much does what you want...<br>&gt;<br>&gt;<br>&gt; I just realized I only responded to someone else, and not the whole list.<br>&gt; It does, but it forces me to make the return value of the protocol method<br>&gt; optional, so that the default implementation can return nil.<br>&gt;<br>&gt; In the end, I guess that&#39;s not so bad, since I&#39;m not happy with the entire<br>&gt; approach, but it&#39;ll do for now.<br>&gt;<br>&gt;<br>&gt; What&#39;s different about having the method return nil vs being optional?<br>&gt; You&#39;re attempting to call it either way, and presumably need some means of<br>&gt; handling the return value, except in Swift it&#39;s all nice and explicit and<br>&gt; easy to put in a conditional like:<br>&gt;<br>&gt; if let result = myObject.someOptionalMethod() { /* Do some stuff */ }<br>&gt; print(myObject.someOptionalStringMethod() ?? &quot;&quot;)<br>&gt;<br>&gt; And so-on. If you need a method to be both optional, and return a nilable<br>&gt; result then you can use a double optional like so:<br>&gt;<br>&gt; if let result = myObject.someDoubleOptionalMethod() { // Method was<br>&gt; implemented<br>&gt; if let value = result { // Method returned a value<br>&gt; /* Do some stuff */<br>&gt; }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; By defining the methods as returning an Optional and throwing in default<br>&gt; implementations you can specify fewer, bigger protocols and make clear what<br>&gt; the requirements really are, though personally given the choice I&#39;d prefer<br>&gt; a dozen smaller protocols that are absolutely explicit in what they do.<br>&gt;<br>&gt; But yeah, I think the tools you need are all there already; maybe there&#39;s<br>&gt; an argument to be made for allowing default return values on protocol<br>&gt; methods, to reduce the boiler-plate?<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; I think there is a difference between:<br>&gt;<br>&gt; - A method which returns an optional result, and<br>&gt; - An optional method which, if present, always returns a result<br>&gt;<br>&gt; Perhaps not so much of a difference at the usage site (it’s just a<br>&gt; question of placing a ? for optional chaining), but semantically and when<br>&gt; conforming to the protocol, they mean different things.<br>&gt;<br>&gt; - Karl<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; If you don’t mind me asking, what is your use-case?<br>&gt;<br>&gt; Even though I think &quot;optional methods&quot; and “methods returning optionals”<br>&gt; are different things, I don’t really have any examples where optional<br>&gt; methods are better than sub-protocols.<br>&gt;<br>&gt; e.g.<br>&gt;<br>&gt; ```<br>&gt; // Core callbacks<br>&gt; protocol MyDelegate { }<br>&gt;<br>&gt; // Optional callbacks, added like a mixin<br>&gt; protocol MyDelegateWithExtras : MyDelegate { }<br>&gt;<br>&gt; // Some more optional callbacks<br>&gt; protocol MySubDelegate : MyDelegate {}<br>&gt;<br>&gt; class DelegateImpl : MySubDelegate, MyDelegateWithExtras {<br>&gt;   // Implement all core + optional callbacks<br>&gt; }<br>&gt;<br>&gt; var d : MyDelegate = DelegateImpl()<br>&gt;<br>&gt; if let extras = d as? MyDelegateWithExtras {<br>&gt;     // invoke optional functionality<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; I don’t know what the overhead of the as? call is, but it’s almost<br>&gt; certainly less than an Obj-C `respondsToSelector` call. Depending on<br>&gt; whether you need to swap the delegate for objects of different types, you<br>&gt; could also use generics to optimise the checks (and possibly more) away.<br>&gt;<br>&gt; - Karl<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161115/b316e55d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>Will Swift ever support optional methods without @objc?</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>November 16, 2016 at 02:00:00am</p></header><div class="content"><p>&gt; On 15 Nov 2016, at 19:38, Shawn Erickson &lt;shawnce at gmail.com&gt; wrote:<br>&gt; <br>&gt; Using sub-protocols may be sufficient and make sense... to be honest I haven&#39;t had the time to fully explore this space and convert some things I have done in objective-c to pure swift. I do wonder how often that those sub-protocols would degenerate into having single methods.<br>&gt; <br>&gt; In a nut shell it isn&#39;t atypical for a delegate to only care about &quot;injecting itself&quot; (e.g. implementing a delegate function) for a subset of the available delegation points leaving the others unimplemented. In the objective-c case the delegator can evaluate what delegation points a delegate implements at time of delegate registration (or more dynamically ... however I often did imp caching for performance reasons in some of my designs). This probe on delegate registration may make sense for the delegator if additional bookkeeping, processing, state management, or potentially whole code path/objects can be avoided if the delegate doesn&#39;t implement a delegation point(s). If the delegation points happened to be implemented using a default nop implementation this type of optimization may not be possible.<br>&gt; <br>&gt; In a nutshell I see and have the need for the delegator to know if the delegate has actually provided an implementation of their own or not so I can potentially leverage optimizations internal to my delegator. As a delegate is also nice to know clearly what I have to implement or not and the optional protocol member concept is one way of doing that, it would be nice to have something like that to help delegate implementors.<br>&gt; <br>&gt; I suggest mentally evaluating the delegation points of URLSession with the perspective of the delegator (URLSession) being able to optimize what it does based what it delegate has provided and implementation for. For example the new metrics delegation point like could optimize away book keeping and related processing if the delegate isn&#39;t interested. Additionally look at it from the point of view of a delegate implementor noting the despite already having some number of sub-protocols you still often only implement one or two delegate points. Alternate swifty implementations likely exist that would be interesting to explore to help inform what makes sense as a language addition  and/or help folks used to &quot;traditional&quot; delegation pattern under Objective-C follow more Swifty patterns going forward.<br>&gt; <br>&gt; -Shawn<br>&gt; <br>&gt; On Tue, Nov 15, 2016 at 9:24 AM Karl &lt;razielim at gmail.com &lt;mailto:razielim at gmail.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On 15 Nov 2016, at 16:46, Shawn Erickson &lt;shawnce at gmail.com &lt;mailto:shawnce at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This has been discussed somewhat heavily in the past and nothing yet has really moved forward on it. I do think a good way of doing something like this would be helpful. I have resulted to defining an interface with an extension that provides empty defaults and for each function a match bool var exists to imply if it exists or not. The code accepting a delegate can probe these bool vars to configure itself to efficiently operate based on knowledge about what the delegate expects (some missing from most proposed solutions other then @objc optional).<br>&gt;&gt; On Tue, Nov 15, 2016 at 6:59 AM Karl via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On 15 Nov 2016, at 12:22, Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 15 Nov 2016, at 07:53, Rick Mann via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Nov 14, 2016, at 22:51 , Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; One major example is the NS/UITableViewDataSource or Delegate - there are many many methods that you don&#39;t need to implement, hence are optional.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; But I think that this was partially solved by default implementation of protocol methods, which pretty much does what you want...<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I just realized I only responded to someone else, and not the whole list. It does, but it forces me to make the return value of the protocol method optional, so that the default implementation can return nil. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In the end, I guess that&#39;s not so bad, since I&#39;m not happy with the entire approach, but it&#39;ll do for now.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What&#39;s different about having the method return nil vs being optional? You&#39;re attempting to call it either way, and presumably need some means of handling the return value, except in Swift it&#39;s all nice and explicit and easy to put in a conditional like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	if let result = myObject.someOptionalMethod() { /* Do some stuff */ }<br>&gt;&gt;&gt; 	print(myObject.someOptionalStringMethod() ?? &quot;&quot;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And so-on. If you need a method to be both optional, and return a nilable result then you can use a double optional like so:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	if let result = myObject.someDoubleOptionalMethod() { // Method was implemented<br>&gt;&gt;&gt; 		if let value = result { // Method returned a value<br>&gt;&gt;&gt; 			/* Do some stuff */<br>&gt;&gt;&gt; 		}<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; By defining the methods as returning an Optional and throwing in default implementations you can specify fewer, bigger protocols and make clear what the requirements really are, though personally given the choice I&#39;d prefer a dozen smaller protocols that are absolutely explicit in what they do.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But yeah, I think the tools you need are all there already; maybe there&#39;s an argument to be made for allowing default return values on protocol methods, to reduce the boiler-plate?<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; I think there is a difference between:<br>&gt;&gt; <br>&gt;&gt; - A method which returns an optional result, and<br>&gt;&gt; - An optional method which, if present, always returns a result<br>&gt;&gt; <br>&gt;&gt; Perhaps not so much of a difference at the usage site (it’s just a question of placing a ? for optional chaining), but semantically and when conforming to the protocol, they mean different things.<br>&gt;&gt; <br>&gt;&gt; - Karl<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; If you don’t mind me asking, what is your use-case?<br>&gt; <br>&gt; Even though I think &quot;optional methods&quot; and “methods returning optionals” are different things, I don’t really have any examples where optional methods are better than sub-protocols.<br>&gt; <br>&gt; e.g.<br>&gt; <br>&gt; ```<br>&gt; // Core callbacks<br>&gt; protocol MyDelegate { }<br>&gt; <br>&gt; // Optional callbacks, added like a mixin<br>&gt; protocol MyDelegateWithExtras : MyDelegate { }<br>&gt; <br>&gt; // Some more optional callbacks<br>&gt; protocol MySubDelegate : MyDelegate {}<br>&gt; <br>&gt; class DelegateImpl : MySubDelegate, MyDelegateWithExtras {<br>&gt;   // Implement all core + optional callbacks<br>&gt; }<br>&gt; <br>&gt; var d : MyDelegate = DelegateImpl()<br>&gt; <br>&gt; if let extras = d as? MyDelegateWithExtras {<br>&gt;     // invoke optional functionality<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; I don’t know what the overhead of the as? call is, but it’s almost certainly less than an Obj-C `respondsToSelector` call. Depending on whether you need to swap the delegate for objects of different types, you could also use generics to optimise the checks (and possibly more) away.<br>&gt; <br>&gt; - Karl<br></p><p><br>You sometimes needed those kind of caching techniques in Objective-C, because it’s such a dynamic language. The question of “does this object respond to this selector” has many complex considerations. For one thing, objects may add and remove methods (or have it done to them) at any time. Objects can even synthesise implementations the first time they receive a selector. It’s been optimised massively over the years, but it can still be a pretty slow operation -- and since hardly anything actually makes use of those features it’s common to ask once and cache the responses in a bitmask. In Objective-C, asking whether or not an object conforms to a protocol just cascades in to a bunch of calls to “respondsToSelector”, so it’s also very painful.<br></p><p>The Swift runtime doesn’t have those dynamic features. If you added any methods to a bridged Swift object via the Obj-C runtime, those methods wouldn’t be callable from your Swift code anyway, so we never have to worry about that. Protocols in Swift are not the loose contracts of Objective-C; you can create empty “marker” protocols and different objects may or may not conform to it, even though it has no functional requirements. That means testing for conformance should be much faster, too (and covers all requirements at once).<br></p><p>Protocol dispatch in Swift is fast, there is something called a “protocol witness table” (vtable + pointer + lifetime func ptrs), which is what is actually getting stored when you declare a variable with only a protocol for a type. So there isn’t really a huge runtime cost from the dispatch anymore either, and you don’t need to explicitly resolve and store the IMPs yourself to get decent performance.<br></p><p>- Karl<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161116/528cba91/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Will Swift ever support optional methods without @objc?</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>November 15, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Nov 15, 2016, at 7:27 PM, Karl via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; In Objective-C, asking whether or not an object conforms to a protocol just cascades in to a bunch of calls to “respondsToSelector”, so it’s also very painful.<br></p><p>This isn’t true; Objective-C stores a list of protocols that a class conforms to, so -respondsToSelector: does not need to be called when checking protocol conformance (also: simply adopting a protocol’s methods will not cause a class to conform to the protocol).<br></p><p>You can test this yourself:<br></p><p>#import &lt;Foundation/Foundation.h&gt;<br></p><p>@protocol P<br>	<br>- (void)foo;<br>	<br>@end<br></p><p>@interface C: NSObject&lt;P&gt;<br></p><p>- (void)foo;<br></p><p>@end<br></p><p>@implementation C<br></p><p>- (void)foo {<br>	NSLog(@&quot;foo&quot;);<br>}<br></p><p>- (BOOL)respondsToSelector:(SEL)selector {<br>	NSLog(@&quot;respondsToSelector: called&quot;);<br>	<br>	return [super respondsToSelector:selector];<br>}<br></p><p>@end<br></p><p>int main(int argc, char *argv[]) {<br>	@autoreleasepool {<br>		C *c = [C new];<br>		<br>		NSLog(@&quot;C is P: %@&quot;, [c conformsToProtocol:@protocol(P)] ? @&quot;YES&quot; : @&quot;NO&quot;);<br>	}<br>}<br></p><p>The output is only:<br></p><p>C is P: YES<br></p><p>The log we put in -respondsToSelector: never gets printed.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161115/99d2b24b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>Will Swift ever support optional methods without @objc?</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>November 16, 2016 at 05:00:00am</p></header><div class="content"><p>&gt; On 16 Nov 2016, at 03:42, Charles Srstka &lt;cocoadev at charlessoft.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Nov 15, 2016, at 7:27 PM, Karl via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; In Objective-C, asking whether or not an object conforms to a protocol just cascades in to a bunch of calls to “respondsToSelector”, so it’s also very painful.<br>&gt; <br>&gt; This isn’t true; Objective-C stores a list of protocols that a class conforms to, so -respondsToSelector: does not need to be called when checking protocol conformance (also: simply adopting a protocol’s methods will not cause a class to conform to the protocol).<br>&gt; <br>&gt; You can test this yourself:<br>&gt; <br>&gt; #import &lt;Foundation/Foundation.h&gt;<br>&gt; <br>&gt; @protocol P<br>&gt; 	<br>&gt; - (void)foo;<br>&gt; 	<br>&gt; @end<br>&gt; <br>&gt; @interface C: NSObject&lt;P&gt;<br>&gt; <br>&gt; - (void)foo;<br>&gt; <br>&gt; @end<br>&gt; <br>&gt; @implementation C<br>&gt; <br>&gt; - (void)foo {<br>&gt; 	NSLog(@&quot;foo&quot;);<br>&gt; }<br>&gt; <br>&gt; - (BOOL)respondsToSelector:(SEL)selector {<br>&gt; 	NSLog(@&quot;respondsToSelector: called&quot;);<br>&gt; 	<br>&gt; 	return [super respondsToSelector:selector];<br>&gt; }<br>&gt; <br>&gt; @end<br>&gt; <br>&gt; int main(int argc, char *argv[]) {<br>&gt; 	@autoreleasepool {<br>&gt; 		C *c = [C new];<br>&gt; 		<br>&gt; 		NSLog(@&quot;C is P: %@&quot;, [c conformsToProtocol:@protocol(P)] ? @&quot;YES&quot; : @&quot;NO&quot;);<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; The output is only:<br>&gt; <br>&gt; C is P: YES<br>&gt; <br>&gt; The log we put in -respondsToSelector: never gets printed.<br>&gt; <br>&gt; Charles<br>&gt; <br></p><p>Huh. I’ve been using Objective-C for maybe 15 years and I’ve always avoided “conformsToProtocol” because I didn’t think it gave a strong contract like that. You learn something new every day :)<br></p><p>- Karl<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161116/4abc57fe/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>Will Swift ever support optional methods without @objc?</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>November 15, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Nov 15, 2016, at 6:42 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Nov 15, 2016, at 7:27 PM, Karl via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; In Objective-C, asking whether or not an object conforms to a protocol just cascades in to a bunch of calls to “respondsToSelector”, so it’s also very painful.<br>&gt; <br>&gt; This isn’t true; Objective-C stores a list of protocols that a class conforms to, so -respondsToSelector: does not need to be called when checking protocol conformance (also: simply adopting a protocol’s methods will not cause a class to conform to the protocol).<br></p><p>That&#39;s right. -conformsToProtocol: asks &quot;does the class implementation (or some superclass thereof or category thereon) claim to conform to the protocol?&quot; The class&#39;s method lists are not consulted.<br></p><p>This affects the result of -conformsToProtocol: with a protocol whose methods are all optional. Devolving to selector checks would say that all classes conform to that protocol. Honoring declared conformances as the runtime actually does gives a different answer.<br></p><p>This also affects the result if you add required methods to a protocol without recompiling all of the protocol&#39;s clients. Old classes will still claim to conform to the protocol, even though they might not implement the protocol&#39;s new methods.<br></p><p>-conformsToProtocol: is usually slower than a single -respondsToSelector: check. The latter uses the runtime&#39;s method cache while the former always walks the protocol lists of the class and all of its superclasses. But -conformsToProtocol: on a flat hierarchy with few protocols can be faster than performing multiple -respondsToSelector: checks.<br></p><p><br>-- <br>Greg Parker     gparker at apple.com &lt;mailto:gparker at apple.com&gt;     Runtime Wrangler<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161115/1d2d1244/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>Will Swift ever support optional methods without @objc?</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>November 16, 2016 at 03:00:00am</p></header><div class="content"><p>I think you are fixating on my talk about imp caching instead of my main<br>point about setting up the state of my delegator to avoid unneeded work<br>when a registered delegate hasn&#39;t implement a delegation point. It an<br>unrelated topic to what is being discussed.<br></p><p>-Shawn<br></p><p>On Tue, Nov 15, 2016 at 5:27 PM Karl &lt;razielim at gmail.com&gt; wrote:<br></p><p>&gt;<br>&gt; On 15 Nov 2016, at 19:38, Shawn Erickson &lt;shawnce at gmail.com&gt; wrote:<br>&gt;<br>&gt; Using sub-protocols may be sufficient and make sense... to be honest I<br>&gt; haven&#39;t had the time to fully explore this space and convert some things I<br>&gt; have done in objective-c to pure swift. I do wonder how often that those<br>&gt; sub-protocols would degenerate into having single methods.<br>&gt;<br>&gt; In a nut shell it isn&#39;t atypical for a delegate to only care about<br>&gt; &quot;injecting itself&quot; (e.g. implementing a delegate function) for a subset of<br>&gt; the available delegation points leaving the others unimplemented. In the<br>&gt; objective-c case the delegator can evaluate what delegation points a<br>&gt; delegate implements at time of delegate registration (or more dynamically<br>&gt; ... however I often did imp caching for performance reasons in some of my<br>&gt; designs). This probe on delegate registration may make sense for the<br>&gt; delegator if additional bookkeeping, processing, state management, or<br>&gt; potentially whole code path/objects can be avoided if the delegate doesn&#39;t<br>&gt; implement a delegation point(s). If the delegation points happened to be<br>&gt; implemented using a default nop implementation this type of optimization<br>&gt; may not be possible.<br>&gt;<br>&gt; In a nutshell I see and have the need for the delegator to know if the<br>&gt; delegate has actually provided an implementation of their own or not so I<br>&gt; can potentially leverage optimizations internal to my delegator. As a<br>&gt; delegate is also nice to know clearly what I have to implement or not and<br>&gt; the optional protocol member concept is one way of doing that, it would be<br>&gt; nice to have something like that to help delegate implementors.<br>&gt;<br>&gt; I suggest mentally evaluating the delegation points of URLSession with the<br>&gt; perspective of the delegator (URLSession) being able to optimize what it<br>&gt; does based what it delegate has provided and implementation for. For<br>&gt; example the new metrics delegation point like could optimize away book<br>&gt; keeping and related processing if the delegate isn&#39;t interested.<br>&gt; Additionally look at it from the point of view of a delegate implementor<br>&gt; noting the despite already having some number of sub-protocols you still<br>&gt; often only implement one or two delegate points. Alternate swifty<br>&gt; implementations likely exist that would be interesting to explore to help<br>&gt; inform what makes sense as a language addition and/or help folks used to<br>&gt; &quot;traditional&quot; delegation pattern under Objective-C follow more Swifty<br>&gt; patterns going forward.<br>&gt;<br>&gt; -Shawn<br>&gt;<br>&gt; On Tue, Nov 15, 2016 at 9:24 AM Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On 15 Nov 2016, at 16:46, Shawn Erickson &lt;shawnce at gmail.com&gt; wrote:<br>&gt;<br>&gt; This has been discussed somewhat heavily in the past and nothing yet has<br>&gt; really moved forward on it. I do think a good way of doing something like<br>&gt; this would be helpful. I have resulted to defining an interface with an<br>&gt; extension that provides empty defaults and for each function a match bool<br>&gt; var exists to imply if it exists or not. The code accepting a delegate can<br>&gt; probe these bool vars to configure itself to efficiently operate based on<br>&gt; knowledge about what the delegate expects (some missing from most proposed<br>&gt; solutions other then @objc optional).<br>&gt; On Tue, Nov 15, 2016 at 6:59 AM Karl via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On 15 Nov 2016, at 12:22, Haravikk via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On 15 Nov 2016, at 07:53, Rick Mann via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Nov 14, 2016, at 22:51 , Charlie Monroe via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; One major example is the NS/UITableViewDataSource or Delegate - there are<br>&gt; many many methods that you don&#39;t need to implement, hence are optional.<br>&gt;<br>&gt; But I think that this was partially solved by default implementation of<br>&gt; protocol methods, which pretty much does what you want...<br>&gt;<br>&gt;<br>&gt; I just realized I only responded to someone else, and not the whole list.<br>&gt; It does, but it forces me to make the return value of the protocol method<br>&gt; optional, so that the default implementation can return nil.<br>&gt;<br>&gt; In the end, I guess that&#39;s not so bad, since I&#39;m not happy with the entire<br>&gt; approach, but it&#39;ll do for now.<br>&gt;<br>&gt;<br>&gt; What&#39;s different about having the method return nil vs being optional?<br>&gt; You&#39;re attempting to call it either way, and presumably need some means of<br>&gt; handling the return value, except in Swift it&#39;s all nice and explicit and<br>&gt; easy to put in a conditional like:<br>&gt;<br>&gt; if let result = myObject.someOptionalMethod() { /* Do some stuff */ }<br>&gt; print(myObject.someOptionalStringMethod() ?? &quot;&quot;)<br>&gt;<br>&gt; And so-on. If you need a method to be both optional, and return a nilable<br>&gt; result then you can use a double optional like so:<br>&gt;<br>&gt; if let result = myObject.someDoubleOptionalMethod() { // Method was<br>&gt; implemented<br>&gt; if let value = result { // Method returned a value<br>&gt; /* Do some stuff */<br>&gt; }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; By defining the methods as returning an Optional and throwing in default<br>&gt; implementations you can specify fewer, bigger protocols and make clear what<br>&gt; the requirements really are, though personally given the choice I&#39;d prefer<br>&gt; a dozen smaller protocols that are absolutely explicit in what they do.<br>&gt;<br>&gt; But yeah, I think the tools you need are all there already; maybe there&#39;s<br>&gt; an argument to be made for allowing default return values on protocol<br>&gt; methods, to reduce the boiler-plate?<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; I think there is a difference between:<br>&gt;<br>&gt; - A method which returns an optional result, and<br>&gt; - An optional method which, if present, always returns a result<br>&gt;<br>&gt; Perhaps not so much of a difference at the usage site (it’s just a<br>&gt; question of placing a ? for optional chaining), but semantically and when<br>&gt; conforming to the protocol, they mean different things.<br>&gt;<br>&gt; - Karl<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; If you don’t mind me asking, what is your use-case?<br>&gt;<br>&gt; Even though I think &quot;optional methods&quot; and “methods returning optionals”<br>&gt; are different things, I don’t really have any examples where optional<br>&gt; methods are better than sub-protocols.<br>&gt;<br>&gt; e.g.<br>&gt;<br>&gt; ```<br>&gt; // Core callbacks<br>&gt; protocol MyDelegate { }<br>&gt;<br>&gt; // Optional callbacks, added like a mixin<br>&gt; protocol MyDelegateWithExtras : MyDelegate { }<br>&gt;<br>&gt; // Some more optional callbacks<br>&gt; protocol MySubDelegate : MyDelegate {}<br>&gt;<br>&gt; class DelegateImpl : MySubDelegate, MyDelegateWithExtras {<br>&gt;   // Implement all core + optional callbacks<br>&gt; }<br>&gt;<br>&gt; var d : MyDelegate = DelegateImpl()<br>&gt;<br>&gt; if let extras = d as? MyDelegateWithExtras {<br>&gt;     // invoke optional functionality<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; I don’t know what the overhead of the as? call is, but it’s almost<br>&gt; certainly less than an Obj-C `respondsToSelector` call. Depending on<br>&gt; whether you need to swap the delegate for objects of different types, you<br>&gt; could also use generics to optimise the checks (and possibly more) away.<br>&gt;<br>&gt; - Karl<br>&gt;<br>&gt;<br>&gt;<br>&gt; You sometimes needed those kind of caching techniques in Objective-C,<br>&gt; because it’s such a dynamic language. The question of “does this object<br>&gt; respond to this selector” has many complex considerations. For one thing,<br>&gt; objects may add and remove methods (or have it done to them) at any time.<br>&gt; Objects can even synthesise implementations the first time they receive a<br>&gt; selector. It’s been optimised massively over the years, but it can still be<br>&gt; a pretty slow operation -- and since hardly anything actually makes use of<br>&gt; those features it’s common to ask once and cache the responses in a<br>&gt; bitmask. In Objective-C, asking whether or not an object conforms to a<br>&gt; protocol just cascades in to a bunch of calls to “respondsToSelector”, so<br>&gt; it’s also very painful.<br>&gt;<br>&gt; The Swift runtime doesn’t have those dynamic features. If you added any<br>&gt; methods to a bridged Swift object via the Obj-C runtime, those methods<br>&gt; wouldn’t be callable from your Swift code anyway, so we never have to worry<br>&gt; about that. Protocols in Swift are not the loose contracts of Objective-C;<br>&gt; you can create empty “marker” protocols and different objects may or may<br>&gt; not conform to it, even though it has no functional requirements. That<br>&gt; means testing for conformance should be much faster, too (and covers all<br>&gt; requirements at once).<br>&gt;<br>&gt; Protocol dispatch in Swift is fast, there is something called a “protocol<br>&gt; witness table” (vtable + pointer + lifetime func ptrs), which is what is<br>&gt; actually getting stored when you declare a variable with only a protocol<br>&gt; for a type. So there isn’t really a huge runtime cost from the dispatch<br>&gt; anymore either, and you don’t need to explicitly resolve and store the IMPs<br>&gt; yourself to get decent performance.<br>&gt;<br>&gt; - Karl<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161116/56ccb262/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>Will Swift ever support optional methods without @objc?</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>November 16, 2016 at 05:00:00am</p></header><div class="content"><p>&gt; On 16 Nov 2016, at 04:37, Shawn Erickson &lt;shawnce at gmail.com&gt; wrote:<br>&gt; <br>&gt; I think you are fixating on my talk about imp caching instead of my main point about setting up the state of my delegator to avoid unneeded work when a registered delegate hasn&#39;t implement a delegation point. It an unrelated topic to what is being discussed.<br>&gt; <br>&gt; -Shawn<br>&gt; <br>&gt; On Tue, Nov 15, 2016 at 5:27 PM Karl &lt;razielim at gmail.com &lt;mailto:razielim at gmail.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On 15 Nov 2016, at 19:38, Shawn Erickson &lt;shawnce at gmail.com &lt;mailto:shawnce at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Using sub-protocols may be sufficient and make sense... to be honest I haven&#39;t had the time to fully explore this space and convert some things I have done in objective-c to pure swift. I do wonder how often that those sub-protocols would degenerate into having single methods.<br>&gt;&gt; <br>&gt;&gt; In a nut shell it isn&#39;t atypical for a delegate to only care about &quot;injecting itself&quot; (e.g. implementing a delegate function) for a subset of the available delegation points leaving the others unimplemented. In the objective-c case the delegator can evaluate what delegation points a delegate implements at time of delegate registration (or more dynamically ... however I often did imp caching for performance reasons in some of my designs). This probe on delegate registration may make sense for the delegator if additional bookkeeping, processing, state management, or potentially whole code path/objects can be avoided if the delegate doesn&#39;t implement a delegation point(s). If the delegation points happened to be implemented using a default nop implementation this type of optimization may not be possible.<br>&gt;&gt; <br>&gt;&gt; In a nutshell I see and have the need for the delegator to know if the delegate has actually provided an implementation of their own or not so I can potentially leverage optimizations internal to my delegator. As a delegate is also nice to know clearly what I have to implement or not and the optional protocol member concept is one way of doing that, it would be nice to have something like that to help delegate implementors.<br>&gt;&gt; <br>&gt;&gt; I suggest mentally evaluating the delegation points of URLSession with the perspective of the delegator (URLSession) being able to optimize what it does based what it delegate has provided and implementation for. For example the new metrics delegation point like could optimize away book keeping and related processing if the delegate isn&#39;t interested. Additionally look at it from the point of view of a delegate implementor noting the despite already having some number of sub-protocols you still often only implement one or two delegate points. Alternate swifty implementations likely exist that would be interesting to explore to help inform what makes sense as a language addition  and/or help folks used to &quot;traditional&quot; delegation pattern under Objective-C follow more Swifty patterns going forward.<br>&gt;&gt; <br>&gt;&gt; -Shawn<br>&gt;&gt; <br>&gt;&gt; On Tue, Nov 15, 2016 at 9:24 AM Karl &lt;razielim at gmail.com &lt;mailto:razielim at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On 15 Nov 2016, at 16:46, Shawn Erickson &lt;shawnce at gmail.com &lt;mailto:shawnce at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This has been discussed somewhat heavily in the past and nothing yet has really moved forward on it. I do think a good way of doing something like this would be helpful. I have resulted to defining an interface with an extension that provides empty defaults and for each function a match bool var exists to imply if it exists or not. The code accepting a delegate can probe these bool vars to configure itself to efficiently operate based on knowledge about what the delegate expects (some missing from most proposed solutions other then @objc optional).<br>&gt;&gt;&gt; On Tue, Nov 15, 2016 at 6:59 AM Karl via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 15 Nov 2016, at 12:22, Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 15 Nov 2016, at 07:53, Rick Mann via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Nov 14, 2016, at 22:51 , Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; One major example is the NS/UITableViewDataSource or Delegate - there are many many methods that you don&#39;t need to implement, hence are optional.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; But I think that this was partially solved by default implementation of protocol methods, which pretty much does what you want...<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I just realized I only responded to someone else, and not the whole list. It does, but it forces me to make the return value of the protocol method optional, so that the default implementation can return nil. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In the end, I guess that&#39;s not so bad, since I&#39;m not happy with the entire approach, but it&#39;ll do for now.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What&#39;s different about having the method return nil vs being optional? You&#39;re attempting to call it either way, and presumably need some means of handling the return value, except in Swift it&#39;s all nice and explicit and easy to put in a conditional like:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	if let result = myObject.someOptionalMethod() { /* Do some stuff */ }<br>&gt;&gt;&gt;&gt; 	print(myObject.someOptionalStringMethod() ?? &quot;&quot;)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And so-on. If you need a method to be both optional, and return a nilable result then you can use a double optional like so:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	if let result = myObject.someDoubleOptionalMethod() { // Method was implemented<br>&gt;&gt;&gt;&gt; 		if let value = result { // Method returned a value<br>&gt;&gt;&gt;&gt; 			/* Do some stuff */<br>&gt;&gt;&gt;&gt; 		}<br>&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; By defining the methods as returning an Optional and throwing in default implementations you can specify fewer, bigger protocols and make clear what the requirements really are, though personally given the choice I&#39;d prefer a dozen smaller protocols that are absolutely explicit in what they do.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But yeah, I think the tools you need are all there already; maybe there&#39;s an argument to be made for allowing default return values on protocol methods, to reduce the boiler-plate?<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think there is a difference between:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - A method which returns an optional result, and<br>&gt;&gt;&gt; - An optional method which, if present, always returns a result<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Perhaps not so much of a difference at the usage site (it’s just a question of placing a ? for optional chaining), but semantically and when conforming to the protocol, they mean different things.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Karl<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; If you don’t mind me asking, what is your use-case?<br>&gt;&gt; <br>&gt;&gt; Even though I think &quot;optional methods&quot; and “methods returning optionals” are different things, I don’t really have any examples where optional methods are better than sub-protocols.<br>&gt;&gt; <br>&gt;&gt; e.g.<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; // Core callbacks<br>&gt;&gt; protocol MyDelegate { }<br>&gt;&gt; <br>&gt;&gt; // Optional callbacks, added like a mixin<br>&gt;&gt; protocol MyDelegateWithExtras : MyDelegate { }<br>&gt;&gt; <br>&gt;&gt; // Some more optional callbacks<br>&gt;&gt; protocol MySubDelegate : MyDelegate {}<br>&gt;&gt; <br>&gt;&gt; class DelegateImpl : MySubDelegate, MyDelegateWithExtras {<br>&gt;&gt;   // Implement all core + optional callbacks<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; var d : MyDelegate = DelegateImpl()<br>&gt;&gt; <br>&gt;&gt; if let extras = d as? MyDelegateWithExtras {<br>&gt;&gt;     // invoke optional functionality<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; I don’t know what the overhead of the as? call is, but it’s almost certainly less than an Obj-C `respondsToSelector` call. Depending on whether you need to swap the delegate for objects of different types, you could also use generics to optimise the checks (and possibly more) away.<br>&gt;&gt; <br>&gt;&gt; - Karl<br>&gt; <br>&gt; <br>&gt; You sometimes needed those kind of caching techniques in Objective-C, because it’s such a dynamic language. The question of “does this object respond to this selector” has many complex considerations. For one thing, objects may add and remove methods (or have it done to them) at any time. Objects can even synthesise implementations the first time they receive a selector. It’s been optimised massively over the years, but it can still be a pretty slow operation -- and since hardly anything actually makes use of those features it’s common to ask once and cache the responses in a bitmask. In Objective-C, asking whether or not an object conforms to a protocol just cascades in to a bunch of calls to “respondsToSelector”, so it’s also very painful.<br>&gt; <br>&gt; The Swift runtime doesn’t have those dynamic features. If you added any methods to a bridged Swift object via the Obj-C runtime, those methods wouldn’t be callable from your Swift code anyway, so we never have to worry about that. Protocols in Swift are not the loose contracts of Objective-C; you can create empty “marker” protocols and different objects may or may not conform to it, even though it has no functional requirements. That means testing for conformance should be much faster, too (and covers all requirements at once).<br>&gt; <br>&gt; Protocol dispatch in Swift is fast, there is something called a “protocol witness table” (vtable + pointer + lifetime func ptrs), which is what is actually getting stored when you declare a variable with only a protocol for a type. So there isn’t really a huge runtime cost from the dispatch anymore either, and you don’t need to explicitly resolve and store the IMPs yourself to get decent performance.<br>&gt; <br>&gt; - Karl<br></p><p><br>It’s the same point. I’ll try to make it more obvious: put your optional stuff in a sub-protocol and check for conformance to the sub-protocol. It’ll be fast and you don’t need any of the caching you do with Objective-C.<br></p><p>(delegate as? SpecialSubDelegate)?.extraCallback() <br></p><p>Should be as fast as whatever you were doing in Objective-C before. If you have larger blocks of potentially-avoidable work to do, wrap the delegate cast in an “if let” and do it there.<br></p><p>For example:<br></p><p>protocol ScrollViewDelegate : class {}<br>protocol ScrollObserver : ScrollViewDelegate {<br>    func scrollViewDidScroll(_ scrollview: UIScrollView)<br>}<br>protocol ScrollToTopController : ScrollViewDelegate {<br>    func scrollViewShouldScrollToTop(_ scrollview: UIScrollView) -&gt; Bool<br>    func scrollViewDidScrollToTop(_ scrollview: UIScrollView)<br>}<br></p><p>Then, in your scrollview code, you’d declare your delegate as:<br></p><p>weak delegate : ScrollViewDelegate<br></p><p>and when you want to use the optional methods, as described earlier:<br></p><p>(delegate as? ScrollObserver)?.scrollViewDidScroll(self)<br></p><p>or if you have more work to do:<br></p><p>if let controller = delegate as? ScrollToTopController,<br>       controller.scrollViewShouldScrollToTop(self) {<br></p><p>  // Perform the scroll<br>  controller.scrollViewDidScrollToTop(self)<br>}<br></p><p>- Karl<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161116/b9a35bcd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>Will Swift ever support optional methods without @objc?</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>November 16, 2016 at 04:00:00am</p></header><div class="content"><p>Again my point isn&#39;t worrying about point of calling out to the delegate<br>but configuring my delegator to avoid a body of work or state management<br>that is unneeded if the delegate doesn&#39;t care about some mix of potential<br>delegation points. I was trying to point out things to consider for those<br>stating &quot;why not just provide a default implementation that is a nop, etc.&quot;<br>when in fact knowing if the delegate decided to not implement something can<br>be helpful for some delegators.<br></p><p>Anyway as stated earlier sub protocols likely are good enough however I am<br>concerned about it degenerating into a single func per sub protocol in not<br>atypical situations.<br></p><p>-Shawn<br></p><p>On Tue, Nov 15, 2016 at 8:10 PM Karl &lt;razielim at gmail.com&gt; wrote:<br></p><p>&gt;<br>&gt; On 16 Nov 2016, at 04:37, Shawn Erickson &lt;shawnce at gmail.com&gt; wrote:<br>&gt;<br>&gt; I think you are fixating on my talk about imp caching instead of my main<br>&gt; point about setting up the state of my delegator to avoid unneeded work<br>&gt; when a registered delegate hasn&#39;t implement a delegation point. It an<br>&gt; unrelated topic to what is being discussed.<br>&gt;<br>&gt; -Shawn<br>&gt;<br>&gt; On Tue, Nov 15, 2016 at 5:27 PM Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On 15 Nov 2016, at 19:38, Shawn Erickson &lt;shawnce at gmail.com&gt; wrote:<br>&gt;<br>&gt; Using sub-protocols may be sufficient and make sense... to be honest I<br>&gt; haven&#39;t had the time to fully explore this space and convert some things I<br>&gt; have done in objective-c to pure swift. I do wonder how often that those<br>&gt; sub-protocols would degenerate into having single methods.<br>&gt;<br>&gt; In a nut shell it isn&#39;t atypical for a delegate to only care about<br>&gt; &quot;injecting itself&quot; (e.g. implementing a delegate function) for a subset of<br>&gt; the available delegation points leaving the others unimplemented. In the<br>&gt; objective-c case the delegator can evaluate what delegation points a<br>&gt; delegate implements at time of delegate registration (or more dynamically<br>&gt; ... however I often did imp caching for performance reasons in some of my<br>&gt; designs). This probe on delegate registration may make sense for the<br>&gt; delegator if additional bookkeeping, processing, state management, or<br>&gt; potentially whole code path/objects can be avoided if the delegate doesn&#39;t<br>&gt; implement a delegation point(s). If the delegation points happened to be<br>&gt; implemented using a default nop implementation this type of optimization<br>&gt; may not be possible.<br>&gt;<br>&gt; In a nutshell I see and have the need for the delegator to know if the<br>&gt; delegate has actually provided an implementation of their own or not so I<br>&gt; can potentially leverage optimizations internal to my delegator. As a<br>&gt; delegate is also nice to know clearly what I have to implement or not and<br>&gt; the optional protocol member concept is one way of doing that, it would be<br>&gt; nice to have something like that to help delegate implementors.<br>&gt;<br>&gt; I suggest mentally evaluating the delegation points of URLSession with the<br>&gt; perspective of the delegator (URLSession) being able to optimize what it<br>&gt; does based what it delegate has provided and implementation for. For<br>&gt; example the new metrics delegation point like could optimize away book<br>&gt; keeping and related processing if the delegate isn&#39;t interested.<br>&gt; Additionally look at it from the point of view of a delegate implementor<br>&gt; noting the despite already having some number of sub-protocols you still<br>&gt; often only implement one or two delegate points. Alternate swifty<br>&gt; implementations likely exist that would be interesting to explore to help<br>&gt; inform what makes sense as a language addition and/or help folks used to<br>&gt; &quot;traditional&quot; delegation pattern under Objective-C follow more Swifty<br>&gt; patterns going forward.<br>&gt;<br>&gt; -Shawn<br>&gt;<br>&gt; On Tue, Nov 15, 2016 at 9:24 AM Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On 15 Nov 2016, at 16:46, Shawn Erickson &lt;shawnce at gmail.com&gt; wrote:<br>&gt;<br>&gt; This has been discussed somewhat heavily in the past and nothing yet has<br>&gt; really moved forward on it. I do think a good way of doing something like<br>&gt; this would be helpful. I have resulted to defining an interface with an<br>&gt; extension that provides empty defaults and for each function a match bool<br>&gt; var exists to imply if it exists or not. The code accepting a delegate can<br>&gt; probe these bool vars to configure itself to efficiently operate based on<br>&gt; knowledge about what the delegate expects (some missing from most proposed<br>&gt; solutions other then @objc optional).<br>&gt; On Tue, Nov 15, 2016 at 6:59 AM Karl via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On 15 Nov 2016, at 12:22, Haravikk via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On 15 Nov 2016, at 07:53, Rick Mann via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Nov 14, 2016, at 22:51 , Charlie Monroe via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; One major example is the NS/UITableViewDataSource or Delegate - there are<br>&gt; many many methods that you don&#39;t need to implement, hence are optional.<br>&gt;<br>&gt; But I think that this was partially solved by default implementation of<br>&gt; protocol methods, which pretty much does what you want...<br>&gt;<br>&gt;<br>&gt; I just realized I only responded to someone else, and not the whole list.<br>&gt; It does, but it forces me to make the return value of the protocol method<br>&gt; optional, so that the default implementation can return nil.<br>&gt;<br>&gt; In the end, I guess that&#39;s not so bad, since I&#39;m not happy with the entire<br>&gt; approach, but it&#39;ll do for now.<br>&gt;<br>&gt;<br>&gt; What&#39;s different about having the method return nil vs being optional?<br>&gt; You&#39;re attempting to call it either way, and presumably need some means of<br>&gt; handling the return value, except in Swift it&#39;s all nice and explicit and<br>&gt; easy to put in a conditional like:<br>&gt;<br>&gt; if let result = myObject.someOptionalMethod() { /* Do some stuff */ }<br>&gt; print(myObject.someOptionalStringMethod() ?? &quot;&quot;)<br>&gt;<br>&gt; And so-on. If you need a method to be both optional, and return a nilable<br>&gt; result then you can use a double optional like so:<br>&gt;<br>&gt; if let result = myObject.someDoubleOptionalMethod() { // Method was<br>&gt; implemented<br>&gt; if let value = result { // Method returned a value<br>&gt; /* Do some stuff */<br>&gt; }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; By defining the methods as returning an Optional and throwing in default<br>&gt; implementations you can specify fewer, bigger protocols and make clear what<br>&gt; the requirements really are, though personally given the choice I&#39;d prefer<br>&gt; a dozen smaller protocols that are absolutely explicit in what they do.<br>&gt;<br>&gt; But yeah, I think the tools you need are all there already; maybe there&#39;s<br>&gt; an argument to be made for allowing default return values on protocol<br>&gt; methods, to reduce the boiler-plate?<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; I think there is a difference between:<br>&gt;<br>&gt; - A method which returns an optional result, and<br>&gt; - An optional method which, if present, always returns a result<br>&gt;<br>&gt; Perhaps not so much of a difference at the usage site (it’s just a<br>&gt; question of placing a ? for optional chaining), but semantically and when<br>&gt; conforming to the protocol, they mean different things.<br>&gt;<br>&gt; - Karl<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; If you don’t mind me asking, what is your use-case?<br>&gt;<br>&gt; Even though I think &quot;optional methods&quot; and “methods returning optionals”<br>&gt; are different things, I don’t really have any examples where optional<br>&gt; methods are better than sub-protocols.<br>&gt;<br>&gt; e.g.<br>&gt;<br>&gt; ```<br>&gt; // Core callbacks<br>&gt; protocol MyDelegate { }<br>&gt;<br>&gt; // Optional callbacks, added like a mixin<br>&gt; protocol MyDelegateWithExtras : MyDelegate { }<br>&gt;<br>&gt; // Some more optional callbacks<br>&gt; protocol MySubDelegate : MyDelegate {}<br>&gt;<br>&gt; class DelegateImpl : MySubDelegate, MyDelegateWithExtras {<br>&gt;   // Implement all core + optional callbacks<br>&gt; }<br>&gt;<br>&gt; var d : MyDelegate = DelegateImpl()<br>&gt;<br>&gt; if let extras = d as? MyDelegateWithExtras {<br>&gt;     // invoke optional functionality<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; I don’t know what the overhead of the as? call is, but it’s almost<br>&gt; certainly less than an Obj-C `respondsToSelector` call. Depending on<br>&gt; whether you need to swap the delegate for objects of different types, you<br>&gt; could also use generics to optimise the checks (and possibly more) away.<br>&gt;<br>&gt; - Karl<br>&gt;<br>&gt;<br>&gt;<br>&gt; You sometimes needed those kind of caching techniques in Objective-C,<br>&gt; because it’s such a dynamic language. The question of “does this object<br>&gt; respond to this selector” has many complex considerations. For one thing,<br>&gt; objects may add and remove methods (or have it done to them) at any time.<br>&gt; Objects can even synthesise implementations the first time they receive a<br>&gt; selector. It’s been optimised massively over the years, but it can still be<br>&gt; a pretty slow operation -- and since hardly anything actually makes use of<br>&gt; those features it’s common to ask once and cache the responses in a<br>&gt; bitmask. In Objective-C, asking whether or not an object conforms to a<br>&gt; protocol just cascades in to a bunch of calls to “respondsToSelector”, so<br>&gt; it’s also very painful.<br>&gt;<br>&gt; The Swift runtime doesn’t have those dynamic features. If you added any<br>&gt; methods to a bridged Swift object via the Obj-C runtime, those methods<br>&gt; wouldn’t be callable from your Swift code anyway, so we never have to worry<br>&gt; about that. Protocols in Swift are not the loose contracts of Objective-C;<br>&gt; you can create empty “marker” protocols and different objects may or may<br>&gt; not conform to it, even though it has no functional requirements. That<br>&gt; means testing for conformance should be much faster, too (and covers all<br>&gt; requirements at once).<br>&gt;<br>&gt; Protocol dispatch in Swift is fast, there is something called a “protocol<br>&gt; witness table” (vtable + pointer + lifetime func ptrs), which is what is<br>&gt; actually getting stored when you declare a variable with only a protocol<br>&gt; for a type. So there isn’t really a huge runtime cost from the dispatch<br>&gt; anymore either, and you don’t need to explicitly resolve and store the IMPs<br>&gt; yourself to get decent performance.<br>&gt;<br>&gt; - Karl<br>&gt;<br>&gt;<br>&gt;<br>&gt; It’s the same point. I’ll try to make it more obvious: put your optional<br>&gt; stuff in a sub-protocol and check for conformance to the sub-protocol.<br>&gt; It’ll be fast and you don’t need any of the caching you do with Objective-C.<br>&gt;<br>&gt; (delegate as? SpecialSubDelegate)?.extraCallback()<br>&gt;<br>&gt;<br>&gt; Should be as fast as whatever you were doing in Objective-C before. If you<br>&gt; have larger blocks of potentially-avoidable work to do, wrap the delegate<br>&gt; cast in an “if let” and do it there.<br>&gt;<br>&gt; For example:<br>&gt;<br>&gt; protocol ScrollViewDelegate : class {}<br>&gt; protocol ScrollObserver : ScrollViewDelegate {<br>&gt;     func scrollViewDidScroll(_ scrollview: UIScrollView)<br>&gt; }<br>&gt; protocol ScrollToTopController : ScrollViewDelegate {<br>&gt;     func scrollViewShouldScrollToTop(_ scrollview: UIScrollView) -&gt; Bool<br>&gt;     func scrollViewDidScrollToTop(_ scrollview: UIScrollView)<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Then, in your scrollview code, you’d declare your delegate as:<br>&gt;<br>&gt; weak delegate : ScrollViewDelegate<br>&gt;<br>&gt;<br>&gt; and when you want to use the optional methods, as described earlier:<br>&gt;<br>&gt; (delegate as? ScrollObserver)?.scrollViewDidScroll(self)<br>&gt;<br>&gt; or if you have more work to do:<br>&gt;<br>&gt;<br>&gt; if let controller = delegate as? ScrollToTopController,<br>&gt;        controller.scrollViewShouldScrollToTop(self) {<br>&gt;<br>&gt;   // Perform the scroll<br>&gt;   controller.scrollViewDidScrollToTop(self)<br>&gt; }<br>&gt;<br>&gt;<br>&gt; - Karl<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161116/82272c9d/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Will Swift ever support optional methods without @objc?</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>November 15, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On 15 Nov 2016, at 14:59, Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt;&gt; On 15 Nov 2016, at 12:22, Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; What&#39;s different about having the method return nil vs being optional? You&#39;re attempting to call it either way, and presumably need some means of handling the return value, except in Swift it&#39;s all nice and explicit and easy to put in a conditional like:<br>&gt;&gt; <br>&gt;&gt; 	if let result = myObject.someOptionalMethod() { /* Do some stuff */ }<br>&gt;&gt; 	print(myObject.someOptionalStringMethod() ?? &quot;&quot;)<br>&gt;&gt; <br>&gt;&gt; And so-on. If you need a method to be both optional, and return a nilable result then you can use a double optional like so:<br>&gt;&gt; <br>&gt;&gt; 	if let result = myObject.someDoubleOptionalMethod() { // Method was implemented<br>&gt;&gt; 		if let value = result { // Method returned a value<br>&gt;&gt; 			/* Do some stuff */<br>&gt;&gt; 		}<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; By defining the methods as returning an Optional and throwing in default implementations you can specify fewer, bigger protocols and make clear what the requirements really are, though personally given the choice I&#39;d prefer a dozen smaller protocols that are absolutely explicit in what they do.<br>&gt;&gt; <br>&gt;&gt; But yeah, I think the tools you need are all there already; maybe there&#39;s an argument to be made for allowing default return values on protocol methods, to reduce the boiler-plate?<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; I think there is a difference between:<br>&gt; <br>&gt; - A method which returns an optional result, and<br>&gt; - An optional method which, if present, always returns a result<br>&gt; <br>&gt; Perhaps not so much of a difference at the usage site (it’s just a question of placing a ? for optional chaining), but semantically and when conforming to the protocol, they mean different things.<br></p><p>Maybe, but it just seems like default implementations do everything that optional methods require, it&#39;s just not got a shorthand to make it easier.<br></p><p>Really the question is, do we adopt the optional keyword for non @objc methods, along with the special syntax for calling them (it&#39;s not exactly the same as chaining). Personally though I&#39;d rather do the opposite and do away with both, and have @objc optional methods replaced by default implementations somehow.<br></p><p>The question then is how; simply making the methods optional (return type becomes optional, or more optional) is not the best solution as testing optionality isn&#39;t a one-size-fits-all solution. For example, API designers may prefer to return a method&#39;s non-implemented state with a specific int or enum case, or by throwing an exception or producing an error. You can do all of these things with default implementations.<br></p><p>Otherwise you could allow specifying of default return values within a protocol itself, functionally this would be identical to adding a default implementation, just a bit easier for the simplest case, I&#39;m not sure it warrants special treatment though.<br></p><p><br>I mean, when it comes down to it an optional method is just one that might do nothing; but a default implementation that returns a default value or has no body achieves this just as effectively. The only advantage here is the call-site semantics, but you can enforce the same by having an optional return value if that&#39;s required.<br></p><p>Put another way, I don&#39;t see what&#39;s gained by the first of these two:<br></p><p>	foo.someOptionalMethod?() // @objc optional method<br>	foo.someMethod() // default implementation is empty<br></p><p>You&#39;ve attempted to call both, and in both cases it just won&#39;t do anything. Your knowing that doesn&#39;t really change anything. Meanwhile if you have a return value:<br></p><p>	if let result = foo.someOptionalMethod?() { /* Process result * / }<br>	if let result = foo.someMethod() { /* Process result */ } // default implementation returns nil<br></p><p><br>If just doesn&#39;t seem like such a special case to require special treatment when Swift&#39;s optional support is already really good and encapsulates the same ideas, and the void case just needs a default implementation that&#39;s a no-op. Plus by using a default implementation you have more flexibility overall in how you actually respond when a method isn&#39;t implemented.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161115/fa4830e7/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Will Swift ever support optional methods without @objc?</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>November 15, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Nov 14, 2016, at 3:48 PM, Rick Mann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Will Swift ever support optional methods without @objc?<br>&gt; <br></p><p>We discussed this extensively in the Swift 3 timeframe, and I believe that the consensus was “no”: optional requirements are considered an Objective-C compatibility feature.<br></p><p>I don’t recall all of the discussion, but a major one would have to be that it is highly redundant with other language features we already have, and makes the design space of Swift APIs more complicated.  If Objective-C didn’t already have them, we would never consider adding them to our protocol model.<br></p><p>-Chris<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
