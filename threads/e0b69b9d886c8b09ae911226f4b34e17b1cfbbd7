<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Dropping Comparable requirement for indices</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July  5, 2016 at 07:00:00pm</p></header><div class="content"><p>I&#39;ve already raised the question here of whether we should weaken the<br>requirement that Collection.Index be Comparable to merely being<br>Equatable.  <br></p><p>Part of the motivation was to support data structures that otherwise<br>would be expensive or impossible to implement.  For example, with<br>Comparable indices, you can&#39;t build a linked list that supports<br>restructuring (e.g. insert, delete, splice) in O(1) without invalidating<br>indices... not even an unsafe linked list with reference semantics.<br>[While I don&#39;t think linked lists are terribly good data structures for<br>most things, they are still useful in teaching, and it bothered me that<br>we were ruling them out.]  Even if you take away the index invalidation<br>restriction, you have to store a counter in the index, which is an awkward inefficiency.<br>Supporting Comparable indices for a tree data structure requires<br>encoding the path from the root to the node.  It&#39;s only one or two words<br>in practice, but it&#39;s another awkward inefficiency.<br></p><p>Over the weekend, I tried lifting the restriction to see what kind of<br>effect it would have on the standard library.<br>https://github.com/apple/swift/pull/3325<br></p><p>Although I *had* been leaning strongly toward making this change, having<br>looked at the effects, I am now more ambivalent:<br></p><p>* A Range&lt;T&gt;, where T is not Comparable, could be constructed with any<br>  pair of Equatable T instances.  We&#39;d only detect that the Range may be<br>  invalid when T happened to also be Comparable.  However, the fact that<br>  you are creating a Range already sort of implies an underlying<br>  ordering.<br></p><p>* A Collection with non-Comparable indices still imposes an ordering<br>  upon the indices.<br></p><p>* In a Collection with Comparable indices, the ordering implied by &lt;<br>  needs to match the ordering of indices in the collection.  Otherwise,<br>  there would be no way to form Ranges (for use in slicing, for example)<br>  without causing a trap.  This is *weird*!  There&#39;s little precedent<br>  for imposing stronger semantic requirements on an associated type if<br>  it conforms to a particular protocol (Comparable in this case), except<br>  where the requirement is part of the protocol.<br></p><p>Also, Dmitri reminded me that even with a Comparable requirement on<br>indices, there is still no problem converting an equatable iteration<br>state into an index; you just need to augment it with an integer<br>counter.  So it&#39;s still trivial to create a Collection from nearly<br>everything that is today a multipass Sequence.  It does make indexing<br>slightly more expensive, but it&#39;s likely we&#39;d optimize that overhead<br>away in many critical situations.<br></p><p>Anyway, the thoughts of the community on this topic would be interesting<br>to us.  We need to make a decision about this very soon.<br></p><p>Thanks!<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Dropping Comparable requirement for indices</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July  6, 2016 at 06:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jul 5, 2016, at 9:39 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; I&#39;ve already raised the question here of whether we should weaken the<br>&gt; requirement that Collection.Index be Comparable to merely being<br>&gt; Equatable.  <br>&gt; <br>&gt; Part of the motivation was to support data structures that otherwise<br>&gt; would be expensive or impossible to implement.  For example, with<br>&gt; Comparable indices, you can&#39;t build a linked list that supports<br>&gt; restructuring (e.g. insert, delete, splice) in O(1) without invalidating<br>&gt; indices... not even an unsafe linked list with reference semantics.<br>&gt; [While I don&#39;t think linked lists are terribly good data structures for<br>&gt; most things, they are still useful in teaching, and it bothered me that<br>&gt; we were ruling them out.]  Even if you take away the index invalidation<br>&gt; restriction, you have to store a counter in the index, which is an awkward inefficiency.<br>&gt; Supporting Comparable indices for a tree data structure requires<br>&gt; encoding the path from the root to the node.  It&#39;s only one or two words<br>&gt; in practice, but it&#39;s another awkward inefficiency.<br>&gt; <br>&gt; Over the weekend, I tried lifting the restriction to see what kind of<br>&gt; effect it would have on the standard library.<br>&gt; https://github.com/apple/swift/pull/3325<br>&gt; <br>&gt; Although I *had* been leaning strongly toward making this change, having<br>&gt; looked at the effects, I am now more ambivalent:<br>&gt; <br>&gt; * A Range&lt;T&gt;, where T is not Comparable, could be constructed with any<br>&gt;  pair of Equatable T instances.  We&#39;d only detect that the Range may be<br>&gt;  invalid when T happened to also be Comparable.  However, the fact that<br>&gt;  you are creating a Range already sort of implies an underlying<br>&gt;  ordering.<br>&gt; <br>&gt; * A Collection with non-Comparable indices still imposes an ordering<br>&gt;  upon the indices.<br>&gt; <br>&gt; * In a Collection with Comparable indices, the ordering implied by &lt;<br>&gt;  needs to match the ordering of indices in the collection.  Otherwise,<br>&gt;  there would be no way to form Ranges (for use in slicing, for example)<br>&gt;  without causing a trap.  This is *weird*!  There&#39;s little precedent<br>&gt;  for imposing stronger semantic requirements on an associated type if<br>&gt;  it conforms to a particular protocol (Comparable in this case), except<br>&gt;  where the requirement is part of the protocol.<br>&gt; <br>&gt; Also, Dmitri reminded me that even with a Comparable requirement on<br>&gt; indices, there is still no problem converting an equatable iteration<br>&gt; state into an index; you just need to augment it with an integer<br>&gt; counter.  So it&#39;s still trivial to create a Collection from nearly<br>&gt; everything that is today a multipass Sequence.  It does make indexing<br>&gt; slightly more expensive, but it&#39;s likely we&#39;d optimize that overhead<br>&gt; away in many critical situations.<br>&gt; <br>&gt; Anyway, the thoughts of the community on this topic would be interesting<br>&gt; to us.  We need to make a decision about this very soon.<br></p><p>Dmitri&#39;s suggestion removes the primary concern I had about retaining the Comparable requirement if we require all multi pass sequences to conform to Collection.  (I was focused on comparability of the iteration state itself and didn&#39;t consider other ways to meet that requirement)<br></p><p>I agree that the points you list above seem to point in the direction of retaining the Comparable requirement.<br></p><p>&gt; <br>&gt; Thanks!<br>&gt; <br>&gt; -- <br>&gt; Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Dropping Comparable requirement for indices</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>July  6, 2016 at 05:00:00am</p></header><div class="content"><p>&gt; On Jul 5, 2016, at 7:39 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Anyway, the thoughts of the community on this topic would be interesting<br>&gt; to us.  We need to make a decision about this very soon.<br></p><p>I&#39;ve wanted the Index protocols to be Comparable since the Swift 1 days. (Apple people, see rdar://17768142; non-Apple people, I was looking to measure distance and, under the old indexing model, the inability to determine which index came later was one of several impediments.) <br></p><p>Going back to the beginning:<br></p><p>&gt; For example, with<br>&gt; Comparable indices, you can&#39;t build a linked list that supports<br>&gt; restructuring (e.g. insert, delete, splice) in O(1) without invalidating<br>&gt; indices... not even an unsafe linked list with reference semantics.<br>&gt; [While I don&#39;t think linked lists are terribly good data structures for<br>&gt; most things, they are still useful in teaching, and it bothered me that<br>&gt; we were ruling them out.]  Even if you take away the index invalidation<br>&gt; restriction, you have to store a counter in the index, which is an awkward inefficiency.<br></p><p>You *can* have O(1) restructuring without index invalidation if you&#39;re willing to tolerate O(n) comparisons; you just walk forward from the left-hand side and return `true` if you encounter the right-hand side before reaching the end. I&#39;m not certain, but I think there&#39;s a three-way tradeoff here: you can have any two of fast restructuring, fast comparisons, and always-valid indices.<br></p><p>In general, though, `Collection` is not very good at modeling linked lists—for one thing, it can&#39;t model a value-typed linked list without enormous index invalidation issues. I can&#39;t quite bring myself to worry too much about linked-list handling here.<br></p><p>&gt; * A Range&lt;T&gt;, where T is not Comparable, could be constructed with any<br>&gt;  pair of Equatable T instances.  We&#39;d only detect that the Range may be<br>&gt;  invalid when T happened to also be Comparable.  However, the fact that<br>&gt;  you are creating a Range already sort of implies an underlying<br>&gt;  ordering.<br></p><p>Such a Range can&#39;t actually test whether a given value is *in* the range. That basically just makes it a glorified typealias for `(lowerBound: Bound, upperBound: Bound)`. A Range without Comparable is a type without any semantics.<br></p><p>&gt; * A Collection with non-Comparable indices still imposes an ordering<br>&gt;  upon the indices.<br></p><p><br>And it also still needs to be able to *test* the ordering of indices. For instance, `distance(from:to:)` is a bit difficult to implement (at least in `BidirectionalCollection`) if you can&#39;t tell which index comes earlier in the collection.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Dropping Comparable requirement for indices</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July  6, 2016 at 11:00:00am</p></header><div class="content"><p>on Wed Jul 06 2016, Brent Royal-Gordon &lt;brent-AT-architechies.com&gt; wrote:<br></p><p>&gt;&gt; On Jul 5, 2016, at 7:39 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Anyway, the thoughts of the community on this topic would be interesting<br>&gt;&gt; to us.  We need to make a decision about this very soon.<br>&gt;<br>&gt; I&#39;ve wanted the Index protocols to be Comparable since the Swift 1<br>&gt; days. (Apple people, see rdar://17768142; non-Apple people, I was<br>&gt; looking to measure distance and, under the old indexing model, the<br>&gt; inability to determine which index came later was one of several<br>&gt; impediments.)<br>&gt;<br>&gt; Going back to the beginning:<br>&gt;<br>&gt;&gt; For example, with<br>&gt;&gt; Comparable indices, you can&#39;t build a linked list that supports<br>&gt;&gt; restructuring (e.g. insert, delete, splice) in O(1) without invalidating<br>&gt;&gt; indices... not even an unsafe linked list with reference semantics.<br>&gt;&gt; [While I don&#39;t think linked lists are terribly good data structures for<br>&gt;&gt; most things, they are still useful in teaching, and it bothered me that<br>&gt;&gt; we were ruling them out.]  Even if you take away the index invalidation<br>&gt;&gt; restriction, you have to store a counter in the index, which is an awkward inefficiency.<br>&gt;<br>&gt; You *can* have O(1) restructuring without index invalidation if you&#39;re<br>&gt; willing to tolerate O(n) comparisons; you just walk forward from the<br>&gt; left-hand side and return `true` if you encounter the right-hand side<br>&gt; before reaching the end. <br></p><p>Yeah, but O(1) is a basic requirement of Comparable.  I consider that to<br>be inviolable.<br></p><p>&gt; I&#39;m not certain, but I think there&#39;s a three-way tradeoff here: you<br>&gt; can have any two of fast restructuring, fast comparisons, and<br>&gt; always-valid indices.<br>&gt;<br>&gt; In general, though, `Collection` is not very good at modeling linked<br>&gt; lists—for one thing, it can&#39;t model a value-typed linked list without<br>&gt; enormous index invalidation issues. I can&#39;t quite bring myself to<br>&gt; worry too much about linked-list handling here.<br></p><p>Yes, I&#39;m not too worried about it either.  I&#39;m more concerned about<br>trees, FWIW.<br></p><p>&gt;&gt; * A Range&lt;T&gt;, where T is not Comparable, could be constructed with any<br>&gt;&gt;  pair of Equatable T instances.  We&#39;d only detect that the Range may be<br>&gt;&gt;  invalid when T happened to also be Comparable.  However, the fact that<br>&gt;&gt;  you are creating a Range already sort of implies an underlying<br>&gt;&gt;  ordering.<br>&gt;<br>&gt; Such a Range can&#39;t actually test whether a given value is *in* the<br>&gt; range. That basically just makes it a glorified typealias for<br>&gt; `(lowerBound: Bound, upperBound: Bound)`. <br></p><p>Yes.<br></p><p>&gt; A Range without Comparable is a type without any semantics.<br></p><p>Practically speaking, yes.<br></p><p>&gt;&gt; * A Collection with non-Comparable indices still imposes an ordering<br>&gt;&gt;  upon the indices.<br>&gt;<br>&gt; And it also still needs to be able to *test* the ordering of<br>&gt; indices. For instance, `distance(from:to:)` is a bit difficult to<br>&gt; implement (at least in `BidirectionalCollection`) if you can&#39;t tell<br>&gt; which index comes earlier in the collection.<br></p><p>Well, you can make it a precondition that the indices are in order.<br>That&#39;s what Swift 2 did (and what C++ does with its forward and<br>bidirectional iterators).  It is certainly nice that Swift 3 lifts that<br>restriction.<br></p><p>-- <br>Dave<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>Dropping Comparable requirement for indices</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>July  6, 2016 at 04:00:00pm</p></header><div class="content"><p>What about dropping all requirements on indices? Collections will handle<br>comparison of their indices, as well. These methods will be<br>default-implemented in case Index is actually Comparable.<br>With this change, ranges really become pairs of indices that mean nothing<br>without their collection. But I don&#39;t think this is somethng catastrophic.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160706/66b07f9e/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5f463dd4e7af28b64ad8f0e032ee82dc?s=50"></div><header><strong>Dropping Comparable requirement for indices</strong> from <string>Nate Cook</string> &lt;natecook at gmail.com&gt;<p>July  6, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jul 5, 2016, at 9:39 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;ve already raised the question here of whether we should weaken the<br>&gt; requirement that Collection.Index be Comparable to merely being<br>&gt; Equatable.  <br>&gt; <br>&gt; Part of the motivation was to support data structures that otherwise<br>&gt; would be expensive or impossible to implement.  For example, with<br>&gt; Comparable indices, you can&#39;t build a linked list that supports<br>&gt; restructuring (e.g. insert, delete, splice) in O(1) without invalidating<br>&gt; indices... not even an unsafe linked list with reference semantics.<br>&gt; [While I don&#39;t think linked lists are terribly good data structures for<br>&gt; most things, they are still useful in teaching, and it bothered me that<br>&gt; we were ruling them out.]  Even if you take away the index invalidation<br>&gt; restriction, you have to store a counter in the index, which is an awkward inefficiency.<br>&gt; Supporting Comparable indices for a tree data structure requires<br>&gt; encoding the path from the root to the node.  It&#39;s only one or two words<br>&gt; in practice, but it&#39;s another awkward inefficiency.<br></p><p>So far in Swift 3 I&#39;ve enjoyed the Comparable requirement on indices—it&#39;s much easier to perform bounds checks in collection algorithms as a result. However, I haven&#39;t tried implementing linked-lists or other non-linear collections since the Comparable requirement was added. I can see that requirement being a significant burden, particularly in a structure like a self-balancing tree, where managing index comparability could grow quite cumbersome.<br></p><p>&gt; Over the weekend, I tried lifting the restriction to see what kind of<br>&gt; effect it would have on the standard library.<br>&gt; https://github.com/apple/swift/pull/3325<br>&gt; <br>&gt; Although I *had* been leaning strongly toward making this change, having<br>&gt; looked at the effects, I am now more ambivalent:<br>&gt; <br>&gt; * A Range&lt;T&gt;, where T is not Comparable, could be constructed with any<br>&gt;  pair of Equatable T instances.  We&#39;d only detect that the Range may be<br>&gt;  invalid when T happened to also be Comparable.  However, the fact that<br>&gt;  you are creating a Range already sort of implies an underlying<br>&gt;  ordering.<br></p><p>This was exactly how Ranges worked from Swift&#39;s public launch up until the collections-move-indices changes landed, so it doesn&#39;t seem like a major problem to bring this behavior back. If we can promise better/faster bounds checking for Comparable indices, hopefully most collection authors would opt into that whenever possible.<br></p><p>&gt; * A Collection with non-Comparable indices still imposes an ordering<br>&gt;  upon the indices.<br>&gt; <br>&gt; * In a Collection with Comparable indices, the ordering implied by &lt;<br>&gt;  needs to match the ordering of indices in the collection.  Otherwise,<br>&gt;  there would be no way to form Ranges (for use in slicing, for example)<br>&gt;  without causing a trap.  This is *weird*!  There&#39;s little precedent<br>&gt;  for imposing stronger semantic requirements on an associated type if<br>&gt;  it conforms to a particular protocol (Comparable in this case), except<br>&gt;  where the requirement is part of the protocol.<br></p><p>This sounds like an argument *for* removing the Comparable requirement. Is the issue that it&#39;s difficult to guarantee that the &lt; ordering matches the collection, or is the issue that even if you drop the Comparable requirement, there&#39;s an implicit comparability anyway?<br></p><p>&gt; Also, Dmitri reminded me that even with a Comparable requirement on<br>&gt; indices, there is still no problem converting an equatable iteration<br>&gt; state into an index; you just need to augment it with an integer<br>&gt; counter.  So it&#39;s still trivial to create a Collection from nearly<br>&gt; everything that is today a multipass Sequence.  It does make indexing<br>&gt; slightly more expensive, but it&#39;s likely we&#39;d optimize that overhead<br>&gt; away in many critical situations.<br>&gt; <br>&gt; Anyway, the thoughts of the community on this topic would be interesting<br>&gt; to us.  We need to make a decision about this very soon.<br></p><p>I don&#39;t know that I&#39;ve helped at all, but those are my thoughts. Thanks!<br>Nate<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Dropping Comparable requirement for indices</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>July  6, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On 6 Jul 2016, at 03:39, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; For example, with<br>&gt; Comparable indices, you can&#39;t build a linked list that supports<br>&gt; restructuring (e.g. insert, delete, splice) in O(1) without invalidating<br>&gt; indices... not even an unsafe linked list with reference semantics.<br></p><p>I think the question is why you need to retain indices in these cases?<br></p><p>When it comes to these operations I wonder if we might want to investigate something like a mutating iterator; you might still use an index to jump to an initial position, but then use .insert(), .remove() etc. methods of the iterator to perform modification without the need to track indices at all. This is essentially how you want to edit trees anyway, as indexing them isn&#39;t especially pretty, as it avoids the need to track the indices at all for these operations, and many common cases should work well when done as part of an iterator in this way.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>Dropping Comparable requirement for indices</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>July  6, 2016 at 07:00:00pm</p></header><div class="content"><p>My own 2c is to drop the comparable requirement.<br></p><p>I can elaborate if necessary, but wanted to at least cast my “+1” for removing the requirement.<br></p><p>&gt; On Jul 5, 2016, at 9:39 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; I&#39;ve already raised the question here of whether we should weaken the<br>&gt; requirement that Collection.Index be Comparable to merely being<br>&gt; Equatable.  <br>&gt; <br>&gt; Part of the motivation was to support data structures that otherwise<br>&gt; would be expensive or impossible to implement.  For example, with<br>&gt; Comparable indices, you can&#39;t build a linked list that supports<br>&gt; restructuring (e.g. insert, delete, splice) in O(1) without invalidating<br>&gt; indices... not even an unsafe linked list with reference semantics.<br>&gt; [While I don&#39;t think linked lists are terribly good data structures for<br>&gt; most things, they are still useful in teaching, and it bothered me that<br>&gt; we were ruling them out.]  Even if you take away the index invalidation<br>&gt; restriction, you have to store a counter in the index, which is an awkward inefficiency.<br>&gt; Supporting Comparable indices for a tree data structure requires<br>&gt; encoding the path from the root to the node.  It&#39;s only one or two words<br>&gt; in practice, but it&#39;s another awkward inefficiency.<br>&gt; <br>&gt; Over the weekend, I tried lifting the restriction to see what kind of<br>&gt; effect it would have on the standard library.<br>&gt; https://github.com/apple/swift/pull/3325<br>&gt; <br>&gt; Although I *had* been leaning strongly toward making this change, having<br>&gt; looked at the effects, I am now more ambivalent:<br>&gt; <br>&gt; * A Range&lt;T&gt;, where T is not Comparable, could be constructed with any<br>&gt;  pair of Equatable T instances.  We&#39;d only detect that the Range may be<br>&gt;  invalid when T happened to also be Comparable.  However, the fact that<br>&gt;  you are creating a Range already sort of implies an underlying<br>&gt;  ordering.<br>&gt; <br>&gt; * A Collection with non-Comparable indices still imposes an ordering<br>&gt;  upon the indices.<br>&gt; <br>&gt; * In a Collection with Comparable indices, the ordering implied by &lt;<br>&gt;  needs to match the ordering of indices in the collection.  Otherwise,<br>&gt;  there would be no way to form Ranges (for use in slicing, for example)<br>&gt;  without causing a trap.  This is *weird*!  There&#39;s little precedent<br>&gt;  for imposing stronger semantic requirements on an associated type if<br>&gt;  it conforms to a particular protocol (Comparable in this case), except<br>&gt;  where the requirement is part of the protocol.<br>&gt; <br>&gt; Also, Dmitri reminded me that even with a Comparable requirement on<br>&gt; indices, there is still no problem converting an equatable iteration<br>&gt; state into an index; you just need to augment it with an integer<br>&gt; counter.  So it&#39;s still trivial to create a Collection from nearly<br>&gt; everything that is today a multipass Sequence.  It does make indexing<br>&gt; slightly more expensive, but it&#39;s likely we&#39;d optimize that overhead<br>&gt; away in many critical situations.<br>&gt; <br>&gt; Anyway, the thoughts of the community on this topic would be interesting<br>&gt; to us.  We need to make a decision about this very soon.<br>&gt; <br>&gt; Thanks!<br>&gt; <br>&gt; -- <br>&gt; Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Dropping Comparable requirement for indices</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July  7, 2016 at 12:00:00am</p></header><div class="content"><p>I for one would be interested in your elaboration. Based on Dave&#39;s<br>comments, I&#39;m pretty convinced that the Comparable requirement is best left<br>in place.<br>On Wed, Jul 6, 2016 at 19:19 plx via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; My own 2c is to drop the comparable requirement.<br>&gt;<br>&gt; I can elaborate if necessary, but wanted to at least cast my “+1” for<br>&gt; removing the requirement.<br>&gt;<br>&gt; &gt; On Jul 5, 2016, at 9:39 PM, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; I&#39;ve already raised the question here of whether we should weaken the<br>&gt; &gt; requirement that Collection.Index be Comparable to merely being<br>&gt; &gt; Equatable.<br>&gt; &gt;<br>&gt; &gt; Part of the motivation was to support data structures that otherwise<br>&gt; &gt; would be expensive or impossible to implement.  For example, with<br>&gt; &gt; Comparable indices, you can&#39;t build a linked list that supports<br>&gt; &gt; restructuring (e.g. insert, delete, splice) in O(1) without invalidating<br>&gt; &gt; indices... not even an unsafe linked list with reference semantics.<br>&gt; &gt; [While I don&#39;t think linked lists are terribly good data structures for<br>&gt; &gt; most things, they are still useful in teaching, and it bothered me that<br>&gt; &gt; we were ruling them out.]  Even if you take away the index invalidation<br>&gt; &gt; restriction, you have to store a counter in the index, which is an<br>&gt; awkward inefficiency.<br>&gt; &gt; Supporting Comparable indices for a tree data structure requires<br>&gt; &gt; encoding the path from the root to the node.  It&#39;s only one or two words<br>&gt; &gt; in practice, but it&#39;s another awkward inefficiency.<br>&gt; &gt;<br>&gt; &gt; Over the weekend, I tried lifting the restriction to see what kind of<br>&gt; &gt; effect it would have on the standard library.<br>&gt; &gt; https://github.com/apple/swift/pull/3325<br>&gt; &gt;<br>&gt; &gt; Although I *had* been leaning strongly toward making this change, having<br>&gt; &gt; looked at the effects, I am now more ambivalent:<br>&gt; &gt;<br>&gt; &gt; * A Range&lt;T&gt;, where T is not Comparable, could be constructed with any<br>&gt; &gt;  pair of Equatable T instances.  We&#39;d only detect that the Range may be<br>&gt; &gt;  invalid when T happened to also be Comparable.  However, the fact that<br>&gt; &gt;  you are creating a Range already sort of implies an underlying<br>&gt; &gt;  ordering.<br>&gt; &gt;<br>&gt; &gt; * A Collection with non-Comparable indices still imposes an ordering<br>&gt; &gt;  upon the indices.<br>&gt; &gt;<br>&gt; &gt; * In a Collection with Comparable indices, the ordering implied by &lt;<br>&gt; &gt;  needs to match the ordering of indices in the collection.  Otherwise,<br>&gt; &gt;  there would be no way to form Ranges (for use in slicing, for example)<br>&gt; &gt;  without causing a trap.  This is *weird*!  There&#39;s little precedent<br>&gt; &gt;  for imposing stronger semantic requirements on an associated type if<br>&gt; &gt;  it conforms to a particular protocol (Comparable in this case), except<br>&gt; &gt;  where the requirement is part of the protocol.<br>&gt; &gt;<br>&gt; &gt; Also, Dmitri reminded me that even with a Comparable requirement on<br>&gt; &gt; indices, there is still no problem converting an equatable iteration<br>&gt; &gt; state into an index; you just need to augment it with an integer<br>&gt; &gt; counter.  So it&#39;s still trivial to create a Collection from nearly<br>&gt; &gt; everything that is today a multipass Sequence.  It does make indexing<br>&gt; &gt; slightly more expensive, but it&#39;s likely we&#39;d optimize that overhead<br>&gt; &gt; away in many critical situations.<br>&gt; &gt;<br>&gt; &gt; Anyway, the thoughts of the community on this topic would be interesting<br>&gt; &gt; to us.  We need to make a decision about this very soon.<br>&gt; &gt;<br>&gt; &gt; Thanks!<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Dave<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160707/88996f3a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Dropping Comparable requirement for indices</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July  6, 2016 at 07:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jul 6, 2016, at 7:33 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I for one would be interested in your elaboration. Based on Dave&#39;s comments, I&#39;m pretty convinced that the Comparable requirement is best left in place.<br></p><p>+1<br></p><p>&gt;&gt; On Wed, Jul 6, 2016 at 19:19 plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; My own 2c is to drop the comparable requirement.<br>&gt;&gt; <br>&gt;&gt; I can elaborate if necessary, but wanted to at least cast my “+1” for removing the requirement.<br>&gt;&gt; <br>&gt;&gt; &gt; On Jul 5, 2016, at 9:39 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I&#39;ve already raised the question here of whether we should weaken the<br>&gt;&gt; &gt; requirement that Collection.Index be Comparable to merely being<br>&gt;&gt; &gt; Equatable.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Part of the motivation was to support data structures that otherwise<br>&gt;&gt; &gt; would be expensive or impossible to implement.  For example, with<br>&gt;&gt; &gt; Comparable indices, you can&#39;t build a linked list that supports<br>&gt;&gt; &gt; restructuring (e.g. insert, delete, splice) in O(1) without invalidating<br>&gt;&gt; &gt; indices... not even an unsafe linked list with reference semantics.<br>&gt;&gt; &gt; [While I don&#39;t think linked lists are terribly good data structures for<br>&gt;&gt; &gt; most things, they are still useful in teaching, and it bothered me that<br>&gt;&gt; &gt; we were ruling them out.]  Even if you take away the index invalidation<br>&gt;&gt; &gt; restriction, you have to store a counter in the index, which is an awkward inefficiency.<br>&gt;&gt; &gt; Supporting Comparable indices for a tree data structure requires<br>&gt;&gt; &gt; encoding the path from the root to the node.  It&#39;s only one or two words<br>&gt;&gt; &gt; in practice, but it&#39;s another awkward inefficiency.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Over the weekend, I tried lifting the restriction to see what kind of<br>&gt;&gt; &gt; effect it would have on the standard library.<br>&gt;&gt; &gt; https://github.com/apple/swift/pull/3325<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Although I *had* been leaning strongly toward making this change, having<br>&gt;&gt; &gt; looked at the effects, I am now more ambivalent:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; * A Range&lt;T&gt;, where T is not Comparable, could be constructed with any<br>&gt;&gt; &gt;  pair of Equatable T instances.  We&#39;d only detect that the Range may be<br>&gt;&gt; &gt;  invalid when T happened to also be Comparable.  However, the fact that<br>&gt;&gt; &gt;  you are creating a Range already sort of implies an underlying<br>&gt;&gt; &gt;  ordering.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; * A Collection with non-Comparable indices still imposes an ordering<br>&gt;&gt; &gt;  upon the indices.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; * In a Collection with Comparable indices, the ordering implied by &lt;<br>&gt;&gt; &gt;  needs to match the ordering of indices in the collection.  Otherwise,<br>&gt;&gt; &gt;  there would be no way to form Ranges (for use in slicing, for example)<br>&gt;&gt; &gt;  without causing a trap.  This is *weird*!  There&#39;s little precedent<br>&gt;&gt; &gt;  for imposing stronger semantic requirements on an associated type if<br>&gt;&gt; &gt;  it conforms to a particular protocol (Comparable in this case), except<br>&gt;&gt; &gt;  where the requirement is part of the protocol.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Also, Dmitri reminded me that even with a Comparable requirement on<br>&gt;&gt; &gt; indices, there is still no problem converting an equatable iteration<br>&gt;&gt; &gt; state into an index; you just need to augment it with an integer<br>&gt;&gt; &gt; counter.  So it&#39;s still trivial to create a Collection from nearly<br>&gt;&gt; &gt; everything that is today a multipass Sequence.  It does make indexing<br>&gt;&gt; &gt; slightly more expensive, but it&#39;s likely we&#39;d optimize that overhead<br>&gt;&gt; &gt; away in many critical situations.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Anyway, the thoughts of the community on this topic would be interesting<br>&gt;&gt; &gt; to us.  We need to make a decision about this very soon.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Thanks!<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; --<br>&gt;&gt; &gt; Dave<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160706/4d169691/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>Dropping Comparable requirement for indices</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>July  8, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jul 6, 2016, at 7:33 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; I for one would be interested in your elaboration. Based on Dave&#39;s comments, I&#39;m pretty convinced that the Comparable requirement is best left in place.<br></p><p>I am short on time (and will remain so for several more weeks) so this should be seen as essentially a fire-and-forget message. <br></p><p>I&#39;ll preface the rest with the disclaimer that I don&#39;t think any of the assessments already made are *wrong* on the facts...I simply (a) disagree on what to make of them and also (b) think there is more cost to requiring  `Comparable` than has been noted so far.<br></p><p>For (a), I agree with the following pair of facts:<br></p><p>- there are &quot;collections&quot; for which the &quot;natural&quot; choice of index is awkward to make `Comparable` (thus making conformance to `Collection` awkward)...<br>- such &quot;non-comparable indices&quot; can easily be made comparable when needed, e.g. by stapling an `Int` onto each &quot;natural&quot; index (or via some similar augmentation)<br></p><p>...but to me this argues in favor of dropping the requirement:<br></p><p>- dropping it allows more &quot;collections&quot; to become proper `Collection`s (while still using the &quot;natural&quot; index)<br>- when you specifically need comparable indices, they are easy to add (so why not *not* pay for comparability except when you specifically need it)<br></p><p>For (b), I think that the long-term costs of techniques like &quot;`Int`-stapling&quot; are actually rather more severe than just the overhead of the stapled-on `Int` (etc.); to illustrate this, consider linked-lists, since they&#39;ve already been brought up.<br></p><p>I&#39;ll state without proof that the following are reasonable:<br></p><p>- if we only need `Equatable` indices:<br>  - the list nodes are the natural choice of &quot;index&quot;<br>  - the list nodes are *robust* indices (very few updates invalidate them)<br>- if we instead need `Comparable` indices:<br>  - the easiest index is a pair like `(list-node, counter)`<br>  - these indices are *fragile* indices (invalidated after most updates)<br></p><p>...and proceed to my point:<br></p><p>It&#39;s not hard to imagine at some point introducing a protocol for a mutable collection with *robust* indices -- e.g., behaving like the &quot;natural&quot; indices we could get away with here if we only needed `Equatable` -- and providing either (or both):<br></p><p>- improved generic implementations of standard mutation operations<br>- additional mutation operations that are only practical with robust indices<br></p><p>...and the unfortunate consequence of the `Comparable`-index requirement is that our linked-list would **not** be able to adopt such a protocol -- and benefit from such algorithms, etc. -- b/c that requirement means that the `Index` it will expose in a generic setting is the more-fragile, “stapled index” instead of the more-robust, “natural index” we could have used otherwise. <br></p><p>This has been discussing linked-lists but I think it generalizes; e.g. for other things that “could be ‘collections’” without the `Comparable`-`Index` requirement, you can easily make indices that *do* satisfy the `Comparable` requirement…at the cost of winding up with comparatively-fragile indices that are a bit pessimal for use with mutation operations. I’ll speculate that the issues being alluded-to for trees are roughly similar: it’s not that it’s hard to make the tree indices comparable, it’s that there’s no good way to do that without making the resulting indices “artificially” fragile.<br></p><p>And so on. <br></p><p>So to conclude, I don’t really disagree that the issues raised by non-comparable indices are real issues, but I *do* think the cost/benefit analysis should include the cost of having &quot;locked-in&quot; the use of fragile, easily-invalidated indices vis-a-vis what might otherwise have been used. It’s not amazingly convincing without more-concrete examples, but this is all I have time for.<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Dropping Comparable requirement for indices</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>July  8, 2016 at 10:00:00pm</p></header><div class="content"><p>Right now I&#39;m working on a lib for charts/plots, and I choose to create a custom interval-type that has no comparable requirement.<br>Of course, as soon as I leave the completely abstract and generic world, I need to bring things into an order — but if this order has to be defined by a global function &quot;&lt;&quot;, there is a loss in flexibility.<br>My plan is to use &quot;&lt;&quot; as a default wherever possible to define my ranges, with the option to change it to a custom alternative; maybe similar reasoning can be applied to the index-problem.<br></p><p>Tino<br></p><p>Real world example:<br>Let&#39;s assume I want to create a bar-chart to compare the population of several countries.<br>There is no natural order for countries (I hope we can agree on that ;-), so no matter how I&#39;d model them, it would feel wrong to define &quot;&lt;&quot;:<br>Sort by name might be the most obvious choice, but it could also be the size, the timezone, average income, the peak hight of its highest mountain...<br>Additionally, I might want to use different orders for different charts, which is only possible when I can change the function which dictates the order.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Dropping Comparable requirement for indices</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July  8, 2016 at 08:00:00pm</p></header><div class="content"><p>This sounds like a scenario where you&#39;d be using or extending an existing<br>stdlib generic type such as Set, no?<br>On Fri, Jul 8, 2016 at 15:53 Tino Heth via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Right now I&#39;m working on a lib for charts/plots, and I choose to create a<br>&gt; custom interval-type that has no comparable requirement.<br>&gt; Of course, as soon as I leave the completely abstract and generic world, I<br>&gt; need to bring things into an order — but if this order has to be defined by<br>&gt; a global function &quot;&lt;&quot;, there is a loss in flexibility.<br>&gt; My plan is to use &quot;&lt;&quot; as a default wherever possible to define my ranges,<br>&gt; with the option to change it to a custom alternative; maybe similar<br>&gt; reasoning can be applied to the index-problem.<br>&gt;<br>&gt; Tino<br>&gt;<br>&gt; Real world example:<br>&gt; Let&#39;s assume I want to create a bar-chart to compare the population of<br>&gt; several countries.<br>&gt; There is no natural order for countries (I hope we can agree on that ;-),<br>&gt; so no matter how I&#39;d model them, it would feel wrong to define &quot;&lt;&quot;:<br>&gt; Sort by name might be the most obvious choice, but it could also be the<br>&gt; size, the timezone, average income, the peak hight of its highest<br>&gt; mountain...<br>&gt; Additionally, I might want to use different orders for different charts,<br>&gt; which is only possible when I can change the function which dictates the<br>&gt; order.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160708/006f9437/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
