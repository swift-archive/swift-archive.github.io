<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>[Proposal draft] Bridge Numeric Types to NSNumber and Cocoa Structs to NSValue</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>August 23, 2016 at 04:00:00pm</p></header><div class="content"><p>A big +1<br></p><p>&gt; Introduction<br>&gt; <br>&gt; A handful of Swift numeric types are bridged to NSNumber when passed into Objective-C object contexts. We should extend this bridging behavior to all Swift numeric types. We should also bridge common Cocoa structs such as NSRangeby boxing them into NSValue objects.<br>&gt; <br>&gt; Swift-evolution thread: TBD &lt;https://lists.swift.org/pipermail/swift-evolution/ &lt;https://lists.swift.org/pipermail/swift-evolution/&gt;&gt;<br>&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-nsnumber-and-nsvalue.md#motivation &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-nsnumber-and-nsvalue.md#motivation&gt;&gt;Motivation<br>&gt; <br>&gt; SE-0116 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0116-id-as-any.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0116-id-as-any.md&gt;&gt; changed how Objective-C&#39;s id and untyped collections import into Swift to use the Any type. This makes it much more natural to pass in Swift value types such as String and Array, but introduces the hazard of passing in types that don&#39;t bridge well to Objective-C objects. Particularly problematic are number types; whereas Int, UInt, and Double will automatically bridge as NSNumber, other-sized numeric types fall back to opaque boxing:<br>&gt; <br>&gt; let i = 17<br>&gt; let plist = [&quot;seventeen&quot;: i]<br>&gt; // OK<br>&gt; try! NSJSONSerialization.data(withJSONObject: plist)<br>&gt; <br>&gt; let j: UInt8 = 38<br>&gt; let brokenPlist = [&quot;thirty-eight&quot;: j]<br>&gt; // Will throw because `j` didn&#39;t bridge to a JSON type<br>&gt; try! NSJSONSerialization.data(withJSONObject: brokenPlist)<br>&gt; We had shied away from enabling this bridging for all numeric types in the Swift 1.x days, among other reasons because we allowed implicit bridging conversions in both directions from Swift value types to NS objects and back, which meant that you could slowly and brokenly convert between any two numeric types transitively via NSNumber if we allowed this. We killed the implicit conversions completely with SE-0072 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0072-eliminate-implicit-bridging-conversions.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0072-eliminate-implicit-bridging-conversions.md&gt;&gt; so that is no longer a concern, so expanding the bridging behavior should no longer be a major problem, since it must now always be explicitly asked for.<br>&gt; <br>&gt; There are also many Cocoa APIs that accept NSArray and NSDictionary objects with members that are NSValue-boxed structs. Matt Neuberg highlights Core Automation as an example in this bug report &lt;https://bugs.swift.org/browse/SR-2414 &lt;https://bugs.swift.org/browse/SR-2414&gt;&gt;. With id-as-Any, it&#39;s natural to expect this to work:<br>&gt; <br>&gt; anim.toValue = CGPoint.zero<br>&gt; However, the CGPoint value does not box as a meaningful Objective-C object, so this currently breaks Core Animation at runtime despite compiling successfully. It would be more idiomatic to bridge these types to NSValue.<br>&gt; <br>&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-nsnumber-and-nsvalue.md#proposed-solution &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-nsnumber-and-nsvalue.md#proposed-solution&gt;&gt;Proposed solution<br>&gt; <br>&gt; All of Swift&#39;s number types should be made to bridge to NSNumber when used as objects in Objective-C:<br>&gt; <br>&gt; Int8<br>&gt; Int16<br>&gt; Int32<br>&gt; Int64<br>&gt; UInt8<br>&gt; UInt16<br>&gt; UInt32<br>&gt; UInt64<br>&gt; Float<br>&gt; Double<br>&gt; Cocoa structs with existing NSValue factory and property support should be made to bridge to NSValue when used as objects:<br>&gt; <br>&gt; NSRange<br>&gt; CGPoint<br>&gt; CGVector<br>&gt; CGSize<br>&gt; CGRect<br>&gt; CGAffineTransform<br>&gt; UIEdgeInsets<br>&gt; UIOffset<br>&gt; CATransform3D<br>&gt; CMTime<br>&gt; CMTimeRange<br>&gt; CMTimeMapping<br>&gt; MKCoordinate<br>&gt; MKCoordinateSpan<br>&gt; SCNVector3<br>&gt; SCNVector4<br>&gt; SCNMatrix4<br>&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-nsnumber-and-nsvalue.md#detailed-design &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-nsnumber-and-nsvalue.md#detailed-design&gt;&gt;Detailed design<br>&gt; <br>&gt; Bridged NSNumber and NSValue objects must be castable back to their original Swift value types. NSValue normally preserves the type information of its included struct in its objCType property. We can check the objCType of an NSValue instance when attempting to cast back to a specific bridged struct type.<br>&gt; <br>&gt; NSNumber is a bit trickier, since Cocoa&#39;s implementation does not generally guarantee to remember the exact number type an instance was constructed from. We can instead say that casting an NSNumber to a Swift number type succeeds if the value of the NSNumber is exactly representable as the target type. This is imperfect, since it means that an NSNumbercan potentially be cast to a different type from the original value, but it at least ensures that Swift values round-trip through the bridge without depending on NSNumber implementation details.<br>&gt; <br>&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-nsnumber-and-nsvalue.md#impact-on-existing-code &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-nsnumber-and-nsvalue.md#impact-on-existing-code&gt;&gt;Impact on existing code<br>&gt; <br>&gt; This change has no static source impact, but changes the dynamic behavior of the Objective-C bridge. From Objective-C&#39;s perspective, values that used to bridge as opaque objects will now come in as semantically meaningful Objective-C objects. This should be a safe change, since existing code should not be relying on the behavior of opaque bridged objects. From Swift&#39;s perspective, values should still be able to round-trip from concrete number and struct types to Anyto id to Any and back by dynamic casting. The ability to reliably distinguish the exact number type that an NSNumberwas constructed from would be lost.<br>&gt; <br>&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-nsnumber-and-nsvalue.md#alternatives-considered &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-nsnumber-and-nsvalue.md#alternatives-considered&gt;&gt;Alternatives considered<br>&gt; <br>&gt; We can of course do nothing and leave the behavior as-is.<br>&gt; <br>&gt; NSValue also carries factories for valueWithPointer: and valueWithNonretainedObject:. Maybe we could bridgeUnsafePointer and Unmanaged this way, but we probably shouldnâ€™t.<br>&gt; <br>&gt; 	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160823/9e193d38/attachment.html&gt;<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
