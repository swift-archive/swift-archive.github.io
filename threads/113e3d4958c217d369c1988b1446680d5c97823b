<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June  5, 2016 at 05:00:00pm</p></header><div class="content"><p>on Thu Jun 02 2016, John McCall &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;  On Jun 2, 2016, at 8:48 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt;  wrote:<br>&gt;<br>&gt;  On Jun 2, 2016, at 10:38 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt;  Well, as I understand it, it&#39;s not actually possible to write your own type(of:), so we&#39;re going from a &quot;magic&quot; property to a &quot;magic&quot;<br>&gt;  function at least for now.<br>&gt;<br>&gt;  No, but you *can* write `func foo&lt;T&gt;(_ t: T)` which accepts any value (you *cannot* write a property that is available for all properties -<br>&gt;  that would require the ability to write `extension Any`. This is the distinction I am making. Of course the implementation is compiler<br>&gt;  magic no matter how we express it syntactically. But we can make it *appear* just like it might if the implementation *wasn’t* compiler<br>&gt;  magic. That makes it fit into the language better IMO and was the biggest motivator for changing `dynamicType`.<br>&gt;<br>&gt;  I&#39;m most alarmed that one implication of the MemoryLayout proposal is loss of the `ofValue` family of functions. These functions<br>&gt;  don&#39;t fit with the design: imagine, what is `MemoryLayout&lt;Double&gt;.size(ofValue: Float(42))`? But the response seems to be that<br>&gt;  these functions don&#39;t seem necessary at all and should be removed. &quot;I don&#39;t see a use for it&quot; is an insufficient justification for a<br>&gt;  feature removal. Looking to other languages, C# has sizeof as a static property but tellingly offers the equivalent of sizeofValue<br>&gt;  (well, strideofValue) as a function in a different module. Essentially every other C-family language that exposes pointers to the<br>&gt;  user offers both of and ofValue equivalents. The question is, how does a user with existing code using sizeofValue() migrate to<br>&gt;  Swift 3? I do not see a viable answer with the MemoryLayout design.<br>&gt;<br>&gt;  Going with MemoryLayout *does not* mean we would have to give up the value functions if we don’t want to:<br>&gt;<br>&gt;  struct MemoryLayout&lt;T&gt; {<br>&gt;  init() {}<br>&gt;  init(t: T) { /* throw away the value */ }<br>&gt;  // we could omit the static properties and require <br>&gt;  // writing MemoryLayout&lt;Int&gt;() if we don’t like the duplication<br>&gt;  static let size: Int<br>&gt;  static let spacing: Int<br>&gt;  static let alignment: Int<br>&gt;<br>&gt;  let size: Int<br>&gt;  let spacing: Int<br>&gt;  let alignment: Int<br>&gt;  }<br>&gt;<br>&gt;  let size = MemoryLayout&lt;Int&gt;.size<br>&gt;  let sizeOfValue = MemoryLayout(42).size<br>&gt;<br>&gt; There&#39;s no good reason for this type to be generic. <br></p><p>I can think of at least two: improved syntax at the use-site and lower<br>API surface area.  But I&#39;m comparing a design I had in my mind for<br>MemoryLayout with the only other alternative I&#39;ve thought of.  Maybe<br>you&#39;d care offer an alternative design.<br></p><p>&gt; It should be non-generic and require the use of the instance<br>&gt; properties.<br></p><p>Instance properties?  Why should we ever create an instance of this<br>thing?<br></p><p>&gt; It&#39;s actively harmful for this type to appear to be computed from a<br>&gt; value. <br></p><p>I agree.<br></p><p>&gt; The layout is not in any way tied to the dynamic type of the value —<br>&gt; for example, it is not the instance layout of the most-derived class<br>&gt; or the value layout of the dynamic type of an<br>&gt; existential. Furthermore, saying that it is computed from a value<br>&gt; means that attempting to compute it from a type will succeed using the<br>&gt; layout of the metatype, which seems like a catastrophic failure of API<br>&gt; design.<br>&gt;<br>&gt; John.<br>&gt;<br>&gt;  On Thu, Jun 2, 2016 at 8:03 AM Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;<br>&gt;  Sent from my iPad<br>&gt;<br>&gt;  On Jun 2, 2016, at 12:27 AM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;  On Thu, Jun 2, 2016 at 12:24 AM, Patrick Smith &lt;pgwsmith at gmail.com&gt; wrote:<br>&gt;<br>&gt;  I really like this idea. This IMO is lower level functionality than `type(of:)` (née dynamicType), so I think it makes<br>&gt;  sense for it to be grouped under its own domain, the MemoryLayout type.<br>&gt;<br>&gt;  Plus MemoryLayout can be extended with new convenience methods.<br>&gt;<br>&gt;  I’m fine with those old methods being removed, but I never use them so! Is it the same as calling type(of:) then<br>&gt;  using that with MemoryLayout? I imagine they could be fixit’d easily, and that they compile down to the same<br>&gt;  underlying code.<br>&gt;<br>&gt;  I&#39;m actually souring to the idea. It goes in the diametrically opposite direction from dynamicType. There, something<br>&gt;  was changed from being property-like to being function-like. Here, Dave&#39;s proposal would take something that&#39;s a<br>&gt;  function and turn it into a property. Hmm.<br>&gt;<br>&gt;  That&#39;s not a fair comparison though. With dynamicType we removed a &quot;magic&quot; property visible on all types, which isn&#39;t<br>&gt;  something you can write and turned it into a function (which is obviously something you can write). <br>&gt;<br>&gt;  Dave&#39;s MemoryLayout creates a new type to bundle together related items which makes their semantic relationship more<br>&gt;  clear. It also receives the type via a generic argument rather than a function argument and makes the properties static. That<br>&gt;  is more representative of what is actually happening and could help to prevent confusion. <br>&gt;<br>&gt;  If we really need an &#39;ofValue&#39; option that infers T from a value the properties on MemoryLayout could also be made<br>&gt;  available as instance properties and it could have an initializer that accepts an instance to T and throws the value away.<br>&gt;  However, I&#39;m not at all convinced this is necessary.<br>&gt;<br>&gt;  On 2 Jun 2016, at 3:05 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;  2. Dave A. and others expressed the opinion that these should probably not be global functions; his<br>&gt;  preference was for:<br>&gt;<br>&gt;  ```<br>&gt;  MemoryLayout&lt;T&gt;.size // currently sizeof()<br>&gt;  MemoryLayout&lt;T&gt;.spacing // currently strideof()<br>&gt;  MemoryLayout&lt;T&gt;.alignment // currently alignof()<br>&gt;  ```<br>&gt;<br>&gt;  3. Dave A. proposed that sizeofValue(), strideofValue(), and alignofValue() are better off removed<br>&gt;  altogether. I don&#39;t know if people are going to be happy about this idea.<br>&gt;<br>&gt;  _______________________________________________<br>&gt;  swift-evolution mailing list<br>&gt;  swift-evolution at swift.org<br>&gt;  https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;  _______________________________________________<br>&gt;  swift-evolution mailing list<br>&gt;  swift-evolution at swift.org<br>&gt;  https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p>-- <br>-Dave<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
