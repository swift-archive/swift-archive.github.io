<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/886f7902c986a59d5cc184425d513c36?s=50"></div><header><strong>Add a while clause to for loops</strong> from <string>Tim Vermeulen</string> &lt;tvermeulen at me.com&gt;<p>June  9, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; Since Swift strives to be an opinionated language without dialects, there shouldn&#39;t be more &quot;choice&quot; but rather one general solution, IMO.<br></p><p>I agree with you on this in general, but this proposal isn’t just about adding choices to the language. At least, that’s not the point. It doesn’t add any new functionality per se, but there might be value in making a common coding pattern more shorter and more intuitive. `guard` is a lot more powerful than `where` or `while` as discussed here, but such clauses can possibly make code more readable. You don’t have to agree with me that those clauses are actually more readable than using `guard`, but that’s the way I see it and in my opinion it’s about more than just having more options.<br></p><p>In fact, if this proposal is accepted, one could consider `guard someCondition else { continue/break }` at the start of a for loop to be a code smell because a `where`/`while` clause could have been used instead. So using those clauses would then be the general solution to the problem, which is in line with what you said Swift strives to be.<br></p><p>To me this issue feels similar to adding `guard` despite already having `if` (if we disregard `guard let` for a second). Now you can write both `guard someCondition else { return }` and `if !someCondition { return }`, but I would consider the first one the general solution and the second one code smell. This pattern is so common that adding `guard` was justified.<br></p><p>&gt; On Wed, Jun 8, 2016 at 1:58 PM, Tim Vermeulen&lt;tvermeulen at me.com(mailto:tvermeulen at me.com)&gt;wrote:<br>&gt; &gt; That’s why I said “potentially less elegant”, some people might prefer `where` over `guard`. This proposal would give them the choice (in very specific situations) to use `where` rather than `guard` if they don’t want to sacrifice performance.<br>&gt; Since Swift strives to be an opinionated language without dialects, there shouldn&#39;t be more &quot;choice&quot; but rather one general solution, IMO. Since `guard` doesn&#39;t sacrifice performance and is the most general, I would oppose adding the option of `while` to offer more choice.<br>&gt; <br>&gt; &gt; <br>&gt; &gt; &gt;On Wed, Jun 8, 2016 at 1:35 PM, Tim Vermeulen via swift-evolution&lt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)(mailto:swift-evolution at swift.org)&gt;wrote:<br>&gt; &gt; &gt;&gt;This is a really strong argument in my opinion. If we don’t add a `while` to for loops, then in some situations we will have to rewrite a `where` clause to something potentially less elegant, given that we don’t want to give up performance.<br>&gt; &gt; &gt;I disagree. I argue that what you call &quot;less elegant&quot;, namely if (or guard) inside the loop, is the most elegant solution.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;IMO `.prefix` is just not the equal alternative for as proposed `while` :<br>&gt; &gt; &gt;&gt;&gt;in case of &#39;while&#39; expression `number&lt;4_000_000` will be calculated<br>&gt; &gt; &gt;&gt;&gt;*only* for those who `number % 2 == 0`. In case of `prefix` - the<br>&gt; &gt; &gt;&gt;&gt;expression will be processed for each `number` and only after this filtered<br>&gt; &gt; &gt;&gt;&gt;by `number % 2`. Let&#39;s assume we need to check for some<br>&gt; &gt; &gt;&gt;&gt;veryExpensiveTest(number):<br>&gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;for number in fibonacci where number % 2 == 0 while<br>&gt; &gt; &gt;&gt;&gt;veryExpensiveTest(number) {}<br>&gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;let numbers = fibonacci.prefix { veryExpensiveTest($0) }<br>&gt; &gt; &gt;&gt;&gt;for number in numbers where number % 2 == 0 {}<br>&gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;So, `while` for `for` loops just can&#39;t be always replaced with `prefix`<br>&gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;On 08.06.2016 2:02, Xiaodi Wu via swift-evolution wrote:<br>&gt; &gt; &gt;&gt;&gt;&gt;On Tue, Jun 7, 2016 at 5:11 PM, Tim Vermeulen&lt;tvermeulen at me.com(mailto:tvermeulen at me.com)(mailto:tvermeulen at me.com)<br>&gt; &gt; &gt;&gt;&gt;&gt;&lt;mailto:tvermeulen at me.com&gt;&gt;wrote:<br>&gt; &gt; &gt;&gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;&gt;I’ve been thinking about this for a bit now, and I think it would make<br>&gt; &gt; &gt;&gt;&gt;&gt;most sense to evaluate these clauses from left to right. However, cases<br>&gt; &gt; &gt;&gt;&gt;&gt;where the order matters are very uncommon, and I would rather have the<br>&gt; &gt; &gt;&gt;&gt;&gt;power to choose which clause is evaluated first than to have a forced<br>&gt; &gt; &gt;&gt;&gt;&gt;default order. Either way I don’t see this as a reason not to allow<br>&gt; &gt; &gt;&gt;&gt;&gt;combining the two clauses because IMO it can lead to some very clean<br>&gt; &gt; &gt;&gt;&gt;&gt;code. For instance, say we want to loop through all even fibonacci<br>&gt; &gt; &gt;&gt;&gt;&gt;numbers below 4 million (see problem #2 from project euler), we could<br>&gt; &gt; &gt;&gt;&gt;&gt;do this:<br>&gt; &gt; &gt;&gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;&gt;`for number in fibonacci where number % 2 == 0 while number&lt;4_000_000<br>&gt; &gt; &gt;&gt;&gt;&gt;{ }`<br>&gt; &gt; &gt;&gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;&gt;This statement looks like spaghetti to me. I would not at all support<br>&gt; &gt; &gt;&gt;&gt;&gt;extending the language to permit it. Do you really think it&#39;s more readable<br>&gt; &gt; &gt;&gt;&gt;&gt;than going step-by-step?<br>&gt; &gt; &gt;&gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;&gt;```<br>&gt; &gt; &gt;&gt;&gt;&gt;let numbers = fibonacci.prefix { $0&lt;4_000_000 }<br>&gt; &gt; &gt;&gt;&gt;&gt;for number in numbers where number % 2 == 0 {<br>&gt; &gt; &gt;&gt;&gt;&gt;// ...<br>&gt; &gt; &gt;&gt;&gt;&gt;}<br>&gt; &gt; &gt;&gt;&gt;&gt;```<br>&gt; &gt; &gt;&gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;&gt;or just:<br>&gt; &gt; &gt;&gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;&gt;```<br>&gt; &gt; &gt;&gt;&gt;&gt;let numbers = fibonacci.prefix { $0&lt;4_000_000 }<br>&gt; &gt; &gt;&gt;&gt;&gt;let evens = numbers.filter { $0 % 2 == 0 }<br>&gt; &gt; &gt;&gt;&gt;&gt;for number in evens {<br>&gt; &gt; &gt;&gt;&gt;&gt;// ...<br>&gt; &gt; &gt;&gt;&gt;&gt;}<br>&gt; &gt; &gt;&gt;&gt;&gt;```<br>&gt; &gt; &gt;&gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;&gt;I could have ordered the two clauses in any way I want. If combining<br>&gt; &gt; &gt;&gt;&gt;&gt;the clauses weren’t allowed, I’d have to put (at least) one of them<br>&gt; &gt; &gt;&gt;&gt;&gt;inside the block, which would be a (minor) pain.<br>&gt; &gt; &gt;&gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;&gt;I don’t currently have a very strong opinion about the order of<br>&gt; &gt; &gt;&gt;&gt;&gt;evaluation, so I might be convinced otherwise. But combining the two<br>&gt; &gt; &gt;&gt;&gt;&gt;clauses is so powerful that I don’t think it’s worth to get rid of just<br>&gt; &gt; &gt;&gt;&gt;&gt;because of an edge case.<br>&gt; &gt; &gt;&gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt;It may be workable if you can have only one or the other, but mixing and matching them as proposed above would be a world of hurt:<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt;```<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt;for foo in bar where condition1 while condition2 { ... }<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt;```<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt;If condition1 and condition2 both evaluate to true, then whether you continue or break would depend on the relative order of where and while; for generality, you would want to allow both `for...in...where...while` and `for...in...while...where`, and likely `for...in...while...where...while`, etc. There is nothing in the meaning of those words that would suggest that `while...where` behaves differently from `where...while`, etc. This is why words like &quot;break&quot; and &quot;continue&quot; are IMO far superior.<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt;On Tue, Jun 7, 2016 at 2:34 PM, Erica Sadun&lt;erica at ericasadun.com(mailto:erica at ericasadun.com)(mailto:erica at ericasadun.com)<br>&gt; &gt; &gt;&gt;&gt;&gt;&lt;mailto:erica at ericasadun.com&gt;(mailto:erica at ericasadun.com<br>&gt; &gt; &gt;&gt;&gt;&gt;&lt;mailto:erica at ericasadun.com&gt;)&gt;wrote:<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;On Jun 7, 2016, at 1:16 PM, Tim Vermeulen via swift-evolution&lt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)(mailto:swift-evolution at swift.org)<br>&gt; &gt; &gt;&gt;&gt;&gt;&lt;mailto:swift-evolution at swift.org&gt;(mailto:swift-evolution at swift.org<br>&gt; &gt; &gt;&gt;&gt;&gt;&lt;mailto:swift-evolution at swift.org&gt;)&gt;wrote:<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;The meaning of the proposed while is not at all a pair for where, since where clauses in while loops would do the same thing as while clauses in for loops. That&#39;s crazy.<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;It sounds crazy, but it’s the nature of the while loop. A where clause in a while loop also has a different result than a where clause in a for loop.<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;The where_clause appears in the for in statement<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;for_in_statement : &#39;for&#39; &#39;case&#39;? pattern &#39;in&#39; expression where_clause? code_block<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;It&#39;s syntactic sugar because the expression can be already be limited through functional chaining of some sort or another. At the same time, it&#39;s nice and pleasant to have `where` and I&#39;m not itching to throw it out. The same courtesy could be easily extend to `when` (because I don&#39;t really want to use the `while` keyword here, but I could easily be convinced otherwise because I don&#39;t have a strong stance either way):<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;for_in_statement : &#39;for&#39; &#39;case&#39;? pattern &#39;in&#39; expression (where_clause | when_clause)? code_block<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;when_clause : &#39;when&#39; expression<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;and again it could be nice and pleasant to have, although not necessary. The question comes down to how much does the language benefit by this sugar.<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;I&#39;d say that in both cases, combining chaining and statements is<br>&gt; &gt; &gt;&gt;&gt;&gt;marginallyless goodthan either using standalone chaining or statements<br>&gt; &gt; &gt;&gt;&gt;&gt;without chaining. But as I say this, I know as a fact, I fully intend<br>&gt; &gt; &gt;&gt;&gt;&gt;to use `sequence(_:, next:).take(while:)` with for0in statements, so<br>&gt; &gt; &gt;&gt;&gt;&gt;I&#39;m starting from a hypocritical vantage point.<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;To summarize, I&#39;m more +0.01 than I am -0.01 on this.<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;-- E<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;p.s. Sorry, wux<br>&gt; &gt; &gt;&gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;&gt;_______________________________________________<br>&gt; &gt; &gt;&gt;&gt;&gt;swift-evolution mailing list<br>&gt; &gt; &gt;&gt;&gt;&gt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)(mailto:swift-evolution at swift.org)<br>&gt; &gt; &gt;&gt;&gt;&gt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;_______________________________________________<br>&gt; &gt; &gt;&gt;swift-evolution mailing list<br>&gt; &gt; &gt;&gt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)(mailto:swift-evolution at swift.org)<br>&gt; &gt; &gt;&gt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;<br>&gt; <br>&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Add a while clause to for loops</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June  8, 2016 at 06:00:00pm</p></header><div class="content"><p>On Wed, Jun 8, 2016 at 6:05 PM, Tim Vermeulen &lt;tvermeulen at me.com&gt; wrote:<br></p><p>&gt; &gt; Since Swift strives to be an opinionated language without dialects,<br>&gt; there shouldn&#39;t be more &quot;choice&quot; but rather one general solution, IMO.<br>&gt;<br>&gt; I agree with you on this in general, but this proposal isn’t just about<br>&gt; adding choices to the language. At least, that’s not the point. It doesn’t<br>&gt; add any new functionality per se, but there might be value in making a<br>&gt; common coding pattern more shorter and more intuitive. `guard` is a lot<br>&gt; more powerful than `where` or `while` as discussed here, but such clauses<br>&gt; can possibly make code more readable. You don’t have to agree with me that<br>&gt; those clauses are actually more readable than using `guard`, but that’s the<br>&gt; way I see it and in my opinion it’s about more than just having more<br>&gt; options.<br>&gt;<br>&gt; In fact, if this proposal is accepted, one could consider `guard<br>&gt; someCondition else { continue/break }` at the start of a for loop to be a<br>&gt; code smell because a `where`/`while` clause could have been used instead.<br>&gt; So using those clauses would then be the general solution to the problem,<br>&gt; which is in line with what you said Swift strives to be.<br>&gt;<br>&gt; To me this issue feels similar to adding `guard` despite already having<br>&gt; `if` (if we disregard `guard let` for a second). Now you can write both<br>&gt; `guard someCondition else { return }` and `if !someCondition { return }`,<br>&gt; but I would consider the first one the general solution and the second one<br>&gt; code smell. This pattern is so common that adding `guard` was justified.<br>&gt;<br></p><p>Well, we shouldn&#39;t ignore `guard let`, because there&#39;s a major difference<br>between `guard let` and `if let`: the scope in which the unwrapping takes<br>place. When `guard` was introduced, it solved a real problem encountered in<br>everyday use: the `if let` pyramid of doom. If you&#39;ll recall, before the<br>introduction of `guard`, unwrapping several optionals in a row resulted in<br>code that was deeply indented and very unsightly to read. By contrast, I&#39;m<br>arguing that the code being written currently is actually quite pretty<br>without `while` clauses in `for` loops, so I don&#39;t think the same parallels<br>apply.<br></p><p>There&#39;s another major feature of `guard`: it&#39;s not just a drop-in<br>replacement for `if !` because it enforces exiting the scope. Using `guard`<br>means you get an error when you forget to write something that exists the<br>scope, and I&#39;ve been saved by that feature more than a few times. By<br>contrast, `where` or `while` does not enforce any comparable limits on what<br>comes after it (one conceivable limit, which apparently can&#39;t be enforced<br>by the grammar, is a semantic relationship between what&#39;s being looped over<br>and the boolean assertion that follows), nor does it even guarantee that<br>the loop will terminate! (I can write, for example, `for i in<br>sequence(first: 0, next: { $0 }) where 2 &lt; 4 { ... }` and there&#39;s nothing<br>you could do to warn me!<br></p><p><br>&gt;<br>&gt; &gt; On Wed, Jun 8, 2016 at 1:58 PM, Tim Vermeulen&lt;tvermeulen at me.com(mailto:<br>&gt; tvermeulen at me.com)&gt;wrote:<br>&gt; &gt; &gt; That’s why I said “potentially less elegant”, some people might prefer<br>&gt; `where` over `guard`. This proposal would give them the choice (in very<br>&gt; specific situations) to use `where` rather than `guard` if they don’t want<br>&gt; to sacrifice performance.<br>&gt; &gt; Since Swift strives to be an opinionated language without dialects,<br>&gt; there shouldn&#39;t be more &quot;choice&quot; but rather one general solution, IMO.<br>&gt; Since `guard` doesn&#39;t sacrifice performance and is the most general, I<br>&gt; would oppose adding the option of `while` to offer more choice.<br>&gt; &gt;<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; &gt;On Wed, Jun 8, 2016 at 1:35 PM, Tim Vermeulen via swift-evolution&lt;<br>&gt; swift-evolution at swift.org(mailto:swift-evolution at swift.org)(mailto:<br>&gt; swift-evolution at swift.org)&gt;wrote:<br>&gt; &gt; &gt; &gt;&gt;This is a really strong argument in my opinion. If we don’t add a<br>&gt; `while` to for loops, then in some situations we will have to rewrite a<br>&gt; `where` clause to something potentially less elegant, given that we don’t<br>&gt; want to give up performance.<br>&gt; &gt; &gt; &gt;I disagree. I argue that what you call &quot;less elegant&quot;, namely if (or<br>&gt; guard) inside the loop, is the most elegant solution.<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;&gt;IMO `.prefix` is just not the equal alternative for as proposed<br>&gt; `while` :<br>&gt; &gt; &gt; &gt;&gt;&gt;in case of &#39;while&#39; expression `number&lt;4_000_000` will be calculated<br>&gt; &gt; &gt; &gt;&gt;&gt;*only* for those who `number % 2 == 0`. In case of `prefix` - the<br>&gt; &gt; &gt; &gt;&gt;&gt;expression will be processed for each `number` and only after this<br>&gt; filtered<br>&gt; &gt; &gt; &gt;&gt;&gt;by `number % 2`. Let&#39;s assume we need to check for some<br>&gt; &gt; &gt; &gt;&gt;&gt;veryExpensiveTest(number):<br>&gt; &gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;&gt;for number in fibonacci where number % 2 == 0 while<br>&gt; &gt; &gt; &gt;&gt;&gt;veryExpensiveTest(number) {}<br>&gt; &gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;&gt;let numbers = fibonacci.prefix { veryExpensiveTest($0) }<br>&gt; &gt; &gt; &gt;&gt;&gt;for number in numbers where number % 2 == 0 {}<br>&gt; &gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;&gt;So, `while` for `for` loops just can&#39;t be always replaced with<br>&gt; `prefix`<br>&gt; &gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;&gt;On 08.06.2016 2:02, Xiaodi Wu via swift-evolution wrote:<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;On Tue, Jun 7, 2016 at 5:11 PM, Tim Vermeulen&lt;tvermeulen at me.com<br>&gt; (mailto:tvermeulen at me.com)(mailto:tvermeulen at me.com)<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;&lt;mailto:tvermeulen at me.com&gt;&gt;wrote:<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;I’ve been thinking about this for a bit now, and I think it would<br>&gt; make<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;most sense to evaluate these clauses from left to right. However,<br>&gt; cases<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;where the order matters are very uncommon, and I would rather have<br>&gt; the<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;power to choose which clause is evaluated first than to have a<br>&gt; forced<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;default order. Either way I don’t see this as a reason not to allow<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;combining the two clauses because IMO it can lead to some very<br>&gt; clean<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;code. For instance, say we want to loop through all even fibonacci<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;numbers below 4 million (see problem #2 from project euler), we<br>&gt; could<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;do this:<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;`for number in fibonacci where number % 2 == 0 while<br>&gt; number&lt;4_000_000<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;{ }`<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;This statement looks like spaghetti to me. I would not at all<br>&gt; support<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;extending the language to permit it. Do you really think it&#39;s more<br>&gt; readable<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;than going step-by-step?<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;```<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;let numbers = fibonacci.prefix { $0&lt;4_000_000 }<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;for number in numbers where number % 2 == 0 {<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;// ...<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;}<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;```<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;or just:<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;```<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;let numbers = fibonacci.prefix { $0&lt;4_000_000 }<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;let evens = numbers.filter { $0 % 2 == 0 }<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;for number in evens {<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;// ...<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;}<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;```<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;I could have ordered the two clauses in any way I want. If<br>&gt; combining<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;the clauses weren’t allowed, I’d have to put (at least) one of them<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;inside the block, which would be a (minor) pain.<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;I don’t currently have a very strong opinion about the order of<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;evaluation, so I might be convinced otherwise. But combining the<br>&gt; two<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;clauses is so powerful that I don’t think it’s worth to get rid of<br>&gt; just<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;because of an edge case.<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;It may be workable if you can have only one or the other, but<br>&gt; mixing and matching them as proposed above would be a world of hurt:<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;```<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;for foo in bar where condition1 while condition2 { ... }<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;```<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;If condition1 and condition2 both evaluate to true, then whether<br>&gt; you continue or break would depend on the relative order of where and<br>&gt; while; for generality, you would want to allow both<br>&gt; `for...in...where...while` and `for...in...while...where`, and likely<br>&gt; `for...in...while...where...while`, etc. There is nothing in the meaning of<br>&gt; those words that would suggest that `while...where` behaves differently<br>&gt; from `where...while`, etc. This is why words like &quot;break&quot; and &quot;continue&quot;<br>&gt; are IMO far superior.<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;On Tue, Jun 7, 2016 at 2:34 PM, Erica Sadun&lt;erica at ericasadun.com<br>&gt; (mailto:erica at ericasadun.com)(mailto:erica at ericasadun.com)<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;&lt;mailto:erica at ericasadun.com&gt;(mailto:erica at ericasadun.com<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;&lt;mailto:erica at ericasadun.com&gt;)&gt;wrote:<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;On Jun 7, 2016, at 1:16 PM, Tim Vermeulen via swift-evolution&lt;<br>&gt; swift-evolution at swift.org(mailto:swift-evolution at swift.org)(mailto:<br>&gt; swift-evolution at swift.org)<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;&lt;mailto:swift-evolution at swift.org&gt;(mailto:<br>&gt; swift-evolution at swift.org<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;&lt;mailto:swift-evolution at swift.org&gt;)&gt;wrote:<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;The meaning of the proposed while is not at all a pair for<br>&gt; where, since where clauses in while loops would do the same thing as while<br>&gt; clauses in for loops. That&#39;s crazy.<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;It sounds crazy, but it’s the nature of the while loop. A where<br>&gt; clause in a while loop also has a different result than a where clause in a<br>&gt; for loop.<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;The where_clause appears in the for in statement<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;for_in_statement : &#39;for&#39; &#39;case&#39;? pattern &#39;in&#39; expression<br>&gt; where_clause? code_block<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;It&#39;s syntactic sugar because the expression can be already be<br>&gt; limited through functional chaining of some sort or another. At the same<br>&gt; time, it&#39;s nice and pleasant to have `where` and I&#39;m not itching to throw<br>&gt; it out. The same courtesy could be easily extend to `when` (because I don&#39;t<br>&gt; really want to use the `while` keyword here, but I could easily be<br>&gt; convinced otherwise because I don&#39;t have a strong stance either way):<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;for_in_statement : &#39;for&#39; &#39;case&#39;? pattern &#39;in&#39; expression<br>&gt; (where_clause | when_clause)? code_block<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;when_clause : &#39;when&#39; expression<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;and again it could be nice and pleasant to have, although not<br>&gt; necessary. The question comes down to how much does the language benefit by<br>&gt; this sugar.<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;I&#39;d say that in both cases, combining chaining and statements is<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;marginallyless goodthan either using standalone chaining or<br>&gt; statements<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;without chaining. But as I say this, I know as a fact, I fully<br>&gt; intend<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;to use `sequence(_:, next:).take(while:)` with for0in statements,<br>&gt; so<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;I&#39;m starting from a hypocritical vantage point.<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;To summarize, I&#39;m more +0.01 than I am -0.01 on this.<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;-- E<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;p.s. Sorry, wux<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;_______________________________________________<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;swift-evolution mailing list<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;swift-evolution at swift.org(mailto:swift-evolution at swift.org<br>&gt; )(mailto:swift-evolution at swift.org)<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;_______________________________________________<br>&gt; &gt; &gt; &gt;&gt;swift-evolution mailing list<br>&gt; &gt; &gt; &gt;&gt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)(mailto:<br>&gt; swift-evolution at swift.org)<br>&gt; &gt; &gt; &gt;&gt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160608/84dfecdd/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ab486d7597af4cfe0be33a762150848?s=50"></div><header><strong>Add a while clause to for loops</strong> from <string>Dany St-Amant</string> &lt;dsa.mls at icloud.com&gt;<p>June  8, 2016 at 09:00:00pm</p></header><div class="content"><p>Le 8 juin 2016 à 19:05, Tim Vermeulen via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br></p><p>&gt;&gt; Since Swift strives to be an opinionated language without dialects, there shouldn&#39;t be more &quot;choice&quot; but rather one general solution, IMO.<br>&gt; <br>&gt; I agree with you on this in general, but this proposal isn’t just about adding choices to the language. At least, that’s not the point. It doesn’t add any new functionality per se, but there might be value in making a common coding pattern more shorter and more intuitive. `guard` is a lot more powerful than `where` or `while` as discussed here, but such clauses can possibly make code more readable. You don’t have to agree with me that those clauses are actually more readable than using `guard`, but that’s the way I see it and in my opinion it’s about more than just having more options.<br></p><p>I do not think shortness is that much a valid criteria (sorry), but expressiveness of the intention matter. A &#39;guard&#39; send a message of a condition to be protected from; &#39;where&#39; carry a notion of conditional criteria; while &#39;while&#39; suggest a on going state.<br></p><p>Having the choice between if/guard/where/while can be seen as confusing to newbie (which one should I use, why does this code use one over the other), but for an experimented developer it can help carry the intention behind the code better than a comment could.<br></p><p>Dany <br></p><p>&gt; In fact, if this proposal is accepted, one could consider `guard someCondition else { continue/break }` at the start of a for loop to be a code smell because a `where`/`while` clause could have been used instead. So using those clauses would then be the general solution to the problem, which is in line with what you said Swift strives to be.<br>&gt; <br>&gt; To me this issue feels similar to adding `guard` despite already having `if` (if we disregard `guard let` for a second). Now you can write both `guard someCondition else { return }` and `if !someCondition { return }`, but I would consider the first one the general solution and the second one code smell. This pattern is so common that adding `guard` was justified.<br>&gt; <br>&gt;&gt; On Wed, Jun 8, 2016 at 1:58 PM, Tim Vermeulen&lt;tvermeulen at me.com(mailto:tvermeulen at me.com)&gt;wrote:<br>&gt;&gt;&gt; That’s why I said “potentially less elegant”, some people might prefer `where` over `guard`. This proposal would give them the choice (in very specific situations) to use `where` rather than `guard` if they don’t want to sacrifice performance.<br>&gt;&gt; Since Swift strives to be an opinionated language without dialects, there shouldn&#39;t be more &quot;choice&quot; but rather one general solution, IMO. Since `guard` doesn&#39;t sacrifice performance and is the most general, I would oppose adding the option of `while` to offer more choice.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Wed, Jun 8, 2016 at 1:35 PM, Tim Vermeulen via swift-evolution&lt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)(mailto:swift-evolution at swift.org)&gt;wrote:<br>&gt;&gt;&gt;&gt;&gt; This is a really strong argument in my opinion. If we don’t add a `while` to for loops, then in some situations we will have to rewrite a `where` clause to something potentially less elegant, given that we don’t want to give up performance.<br>&gt;&gt;&gt;&gt; I disagree. I argue that what you call &quot;less elegant&quot;, namely if (or guard) inside the loop, is the most elegant solution.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; IMO `.prefix` is just not the equal alternative for as proposed `while` :<br>&gt;&gt;&gt;&gt;&gt;&gt; in case of &#39;while&#39; expression `number&lt;4_000_000` will be calculated<br>&gt;&gt;&gt;&gt;&gt;&gt; *only* for those who `number % 2 == 0`. In case of `prefix` - the<br>&gt;&gt;&gt;&gt;&gt;&gt; expression will be processed for each `number` and only after this filtered<br>&gt;&gt;&gt;&gt;&gt;&gt; by `number % 2`. Let&#39;s assume we need to check for some<br>&gt;&gt;&gt;&gt;&gt;&gt; veryExpensiveTest(number):<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; for number in fibonacci where number % 2 == 0 while<br>&gt;&gt;&gt;&gt;&gt;&gt; veryExpensiveTest(number) {}<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let numbers = fibonacci.prefix { veryExpensiveTest($0) }<br>&gt;&gt;&gt;&gt;&gt;&gt; for number in numbers where number % 2 == 0 {}<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; So, `while` for `for` loops just can&#39;t be always replaced with `prefix`<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 08.06.2016 2:02, Xiaodi Wu via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Tue, Jun 7, 2016 at 5:11 PM, Tim Vermeulen&lt;tvermeulen at me.com(mailto:tvermeulen at me.com)(mailto:tvermeulen at me.com)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:tvermeulen at me.com&gt;&gt;wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I’ve been thinking about this for a bit now, and I think it would make<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; most sense to evaluate these clauses from left to right. However, cases<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; where the order matters are very uncommon, and I would rather have the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; power to choose which clause is evaluated first than to have a forced<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; default order. Either way I don’t see this as a reason not to allow<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; combining the two clauses because IMO it can lead to some very clean<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; code. For instance, say we want to loop through all even fibonacci<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; numbers below 4 million (see problem #2 from project euler), we could<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; do this:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; `for number in fibonacci where number % 2 == 0 while number&lt;4_000_000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; { }`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This statement looks like spaghetti to me. I would not at all support<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; extending the language to permit it. Do you really think it&#39;s more readable<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; than going step-by-step?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let numbers = fibonacci.prefix { $0&lt;4_000_000 }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; for number in numbers where number % 2 == 0 {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; or just:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let numbers = fibonacci.prefix { $0&lt;4_000_000 }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let evens = numbers.filter { $0 % 2 == 0 }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; for number in evens {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I could have ordered the two clauses in any way I want. If combining<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; the clauses weren’t allowed, I’d have to put (at least) one of them<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; inside the block, which would be a (minor) pain.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I don’t currently have a very strong opinion about the order of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; evaluation, so I might be convinced otherwise. But combining the two<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; clauses is so powerful that I don’t think it’s worth to get rid of just<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; because of an edge case.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It may be workable if you can have only one or the other, but mixing and matching them as proposed above would be a world of hurt:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; for foo in bar where condition1 while condition2 { ... }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If condition1 and condition2 both evaluate to true, then whether you continue or break would depend on the relative order of where and while; for generality, you would want to allow both `for...in...where...while` and `for...in...while...where`, and likely `for...in...while...where...while`, etc. There is nothing in the meaning of those words that would suggest that `while...where` behaves differently from `where...while`, etc. This is why words like &quot;break&quot; and &quot;continue&quot; are IMO far superior.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Tue, Jun 7, 2016 at 2:34 PM, Erica Sadun&lt;erica at ericasadun.com(mailto:erica at ericasadun.com)(mailto:erica at ericasadun.com)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:erica at ericasadun.com&gt;(mailto:erica at ericasadun.com<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:erica at ericasadun.com&gt;)&gt;wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 1:16 PM, Tim Vermeulen via swift-evolution&lt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)(mailto:swift-evolution at swift.org)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;(mailto:swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;)&gt;wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The meaning of the proposed while is not at all a pair for where, since where clauses in while loops would do the same thing as while clauses in for loops. That&#39;s crazy.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It sounds crazy, but it’s the nature of the while loop. A where clause in a while loop also has a different result than a where clause in a for loop.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The where_clause appears in the for in statement<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; for_in_statement : &#39;for&#39; &#39;case&#39;? pattern &#39;in&#39; expression where_clause? code_block<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It&#39;s syntactic sugar because the expression can be already be limited through functional chaining of some sort or another. At the same time, it&#39;s nice and pleasant to have `where` and I&#39;m not itching to throw it out. The same courtesy could be easily extend to `when` (because I don&#39;t really want to use the `while` keyword here, but I could easily be convinced otherwise because I don&#39;t have a strong stance either way):<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; for_in_statement : &#39;for&#39; &#39;case&#39;? pattern &#39;in&#39; expression (where_clause | when_clause)? code_block<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; when_clause : &#39;when&#39; expression<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; and again it could be nice and pleasant to have, although not necessary. The question comes down to how much does the language benefit by this sugar.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I&#39;d say that in both cases, combining chaining and statements is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; marginallyless goodthan either using standalone chaining or statements<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; without chaining. But as I say this, I know as a fact, I fully intend<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; to use `sequence(_:, next:).take(while:)` with for0in statements, so<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I&#39;m starting from a hypocritical vantage point.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To summarize, I&#39;m more +0.01 than I am -0.01 on this.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -- E<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; p.s. Sorry, wux<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org(mailto:swift-evolution at swift.org)(mailto:swift-evolution at swift.org)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org(mailto:swift-evolution at swift.org)(mailto:swift-evolution at swift.org)<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
