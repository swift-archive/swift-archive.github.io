<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[proposal] Allow function argument type to be	omitted when passing a default value from which it can be inferred</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 11, 2016 at 12:00:00pm</p></header><div class="content"><p>Am 11. Mai 2016 um 05:33 schrieb Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt;:<br></p><p><br>On May 10, 2016, at 3:02 AM, Sam Dods via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>I propose that function argument types could be omitted in the same way as variable and property argument types are omitted when they are set at point of definition.<br>[...]<br></p><p><br>We have a pretty strict rule here: types are allowed to be inferred in implementations, but not interfaces. This is important for efficient compilation, encourages people to think about their API interfaces, and somewhat reduces the damage when they don’t.<br></p><p><br>+1<br></p><p><br>-Thorsten<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160511/922a12fc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[proposal] Allow function argument type to be omitted when passing a default value from which it can be inferred</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 11, 2016 at 03:00:00pm</p></header><div class="content"><p>Inline<br></p><p>On 11.05.2016 15:09, Thorsten Seitz via swift-evolution wrote:<br>&gt; Am 11. Mai 2016 um 05:33 schrieb Chris Lattner via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt;:<br>&gt;<br>&gt;&gt; On May 10, 2016, at 3:02 AM, Sam Dods via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; I propose that function argument types could be omitted in the same way<br>&gt;&gt;&gt; as variable and property argument types are omitted when they are set at<br>&gt;&gt;&gt; point of definition.<br>&gt;&gt;&gt; [...]<br>&gt;&gt;<br>&gt;&gt; We have a pretty strict rule here: types are allowed to be inferred in<br>&gt;&gt; implementations, but not interfaces. This is important for efficient<br>&gt;&gt; compilation, encourages people to think about their API interfaces, and<br>&gt;&gt; somewhat reduces the damage when they don’t.<br>&gt;<br>&gt; +1<br></p><p>Sorry, but this(&quot;We have a pretty strict rule&quot;) seems just like not true. <br>The rule is broken as you can see (so not such a &#39;strict&#39;) :<br></p><p>public class A {<br>   public var a = guessWhatTypeOfThisProperty()<br>}<br>// guessWhatTypeOfThisProperty is a global function defined far-far away<br></p><p>So, can&#39;t see any reason why Swift should not infer type of default <br>parameter *currently*. This will not break any &#39;strict&#39; rule.<br></p><p>Or, what I&#39;ll probably prefer, we should *actually* disallow type inference <br>in interface part of type *if* assigned not simple &#39;raw&#39; value like <br>Int/Double/String..<br></p><p>I.e.<br>public var a = 10 // OK, all is clear here<br>public var a = &quot;sdfsdf&quot; // OK<br>public var a = someFunction() // not OK - add type of `a` explicitly<br></p><p>And in this case, yes, there is no place for type inference for default <br>parameters.<br></p><p>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[proposal] Allow function argument type to be omitted when passing a default value from which it can be inferred</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>May 11, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On 11 May 2016, at 13:49, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; public var a = 10 // OK, all is clear here<br>&gt; public var a = &quot;sdfsdf&quot; // OK<br>&gt; public var a = someFunction() // not OK - add type of `a` explicitly<br></p><p>I’m not clear on why you think the third one isn’t okay; Xcode can tell you what the type was inferred to be, you can check the function signature (alt - click the name) which will tell the type that it returns, as well as call up any documentation about what it does.<br></p><p>The only reason you would need to set a type on the property is if you know you’ll need to assign something less specific in future, e.g- a parent type in a class hierarchy.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160511/db1bae4d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[proposal] Allow function argument type to be omitted when passing a default value from which it can be inferred</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 11, 2016 at 04:00:00pm</p></header><div class="content"><p>Inline<br></p><p>On 11.05.2016 16:03, Haravikk wrote:<br>&gt;<br>&gt;&gt; On 11 May 2016, at 13:49, Vladimir.S via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; public var a = 10 // OK, all is clear here<br>&gt;&gt; public var a = &quot;sdfsdf&quot; // OK<br>&gt;&gt; public var a = someFunction() // not OK - add type of `a` explicitly<br>&gt;<br>&gt; I’m not clear on why you think the third one isn’t okay; Xcode can tell you<br>&gt; what the type was inferred to be, you can check the function signature (alt<br>&gt; - click the name) which will tell the type that it returns, as well as call<br>&gt; up any documentation about what it does.<br></p><p>Well.. First of all Swift != XCode, and the OSX is not the only system <br>where Swift is used ;-)<br></p><p>Yes, XCode can help a lot - should we design the language with XCode help <br>in mind? I think we should not even think about XCode when discussing Swift <br>features.<br></p><p>Second, we were discussing type inference for default parameters. I said <br>that if we have this type inference in property - IMO there is no reason to <br>not allow the same for default parameters. I.e. you can also use XCode to <br>check the type of default parameter.<br></p><p>BUT personally I prefer to not allow type inference for properties if the <br>assigned value is not &#39;simple&#39; raw value like 10, 1.5, &quot;sdfsdf&quot; or probably <br>explicit type constructor(like MyEnum.someCase; can be discussed)<br></p><p>&gt;<br>&gt; The only reason you would need to set a type on the property is if you know<br>&gt; you’ll need to assign something less specific in future, e.g- a parent type<br>&gt; in a class hierarchy.<br></p><p>I was replying to Chris Lattner&#39;s &quot;We have a pretty strict rule here: types <br>are allowed to be inferred in implementations, but not interfaces&quot;<br>IMO we already has type inference in interfaces, this is why IMO Swift can <br>have type inference in default parameters.<br></p><p>The reason you want to have explicit type declaration - is clarity and <br>explicitness of the code, when you understand *interface* of type just by <br>reading it. Not always Swift code will be reviewed in XCode and you can <br>click the function to read its result type.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[proposal] Allow function argument type to be omitted when passing a default value from which it can be inferred</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>May 11, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On 11 May 2016, at 14:59, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt; <br>&gt; On 11.05.2016 16:03, Haravikk wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On 11 May 2016, at 13:49, Vladimir.S via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public var a = 10 // OK, all is clear here<br>&gt;&gt;&gt; public var a = &quot;sdfsdf&quot; // OK<br>&gt;&gt;&gt; public var a = someFunction() // not OK - add type of `a` explicitly<br>&gt;&gt; <br>&gt;&gt; I’m not clear on why you think the third one isn’t okay; Xcode can tell you<br>&gt;&gt; what the type was inferred to be, you can check the function signature (alt<br>&gt;&gt; - click the name) which will tell the type that it returns, as well as call<br>&gt;&gt; up any documentation about what it does.<br>&gt; <br>&gt; Well.. First of all Swift != XCode, and the OSX is not the only system where Swift is used ;-)<br></p><p>I don’t disagree, but nor is Xcode unique in helping to figure out what a type is; I think it’s okay to consider that any good modern IDE should be able to tell us what a type is if the compiler can. Besides, in the example, someFunction() could be buried somewhere hard to find, sure, or it could also be declared clearly earlier in the same file, or in a commonly used file for that module, in which case it’s probably very well known. I think it’s fine to infer the type in these cases because forcing the developer to supply it may not add anything, and in cases where it does it’s easy enough to just do this yourself; even if you’re maintaining unfamiliar code, it shouldn’t take long to look up the type and add it for others if you really feel you have to, but again, any good IDE should render it a non-issue.<br></p><p><br>As to the original issue (realised I hadn’t commented on it yet), I’m undecided; I like type inference for declarations as inference is very common for these, and I myself usually only supply a type if there’s ambiguity or I want something to become optional. My main concern is that default parameter values are relatively rare (compared to those without them), so it becomes an issue of consistency for me.<br>It might be different if for example we could omit type when it can inferred by other means as well, for example:<br></p><p>	protocol FooType {<br>		func someMethod(value:String) -&gt; Void<br>	}<br></p><p>	struct Foo : FooType {<br>		func someMethod(value) -&gt; Void { … } // value is a String<br>	}<br></p><p>But I’m not sure if I’d want to do that or not. Generally I like things that shorten function signatures, but on its own I’d prefer consistency over inference in this case I think.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160511/25d28e84/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[proposal] Allow function argument type to be omitted when passing a default value from which it can be inferred</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>May 11, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On May 11, 2016, at 08:19, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; It might be different if for example we could omit type when it can inferred by other means as well, for example:<br>&gt; <br>&gt; 	protocol FooType {<br>&gt; 		func someMethod(value:String) -&gt; Void<br>&gt; 	}<br>&gt; <br>&gt; 	struct Foo : FooType {<br>&gt; 		func someMethod(value) -&gt; Void { … } // value is a String<br>&gt; 	}<br>&gt; <br>&gt; But I’m not sure if I’d want to do that or not. Generally I like things that shorten function signatures, but on its own I’d prefer consistency over inference in this case I think.<br></p><p>Without commenting on the rest of it, there’s a difference to me between something that can be inferred based on local information and something that I have to look elsewhere to figure out. In the protocol case, I’d have to notice that this method satisfies a protocol requirement and know enough about the protocol to know what the type of the parameter is. In the default argument case, I only have to know about the type of the expression, which is very often a literal. (And even when it’s not, we generally assume the return type of most functions is inferrable from the name and arguments, or we’d be requiring types for locals too.)<br></p><p>(By the way, that’s also the history of inference for properties and globals: we knew we wanted it for locals and implemented it, and then it was immediately a little weird to have to write types elsewhere.)<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160511/8c718b41/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[proposal] Allow function argument type to be omitted when passing a default value from which it can be inferred</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 11, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On May 11, 2016, at 5:49 AM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Inline<br>&gt; <br>&gt; On 11.05.2016 15:09, Thorsten Seitz via swift-evolution wrote:<br>&gt;&gt; Am 11. Mai 2016 um 05:33 schrieb Chris Lattner via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; On May 10, 2016, at 3:02 AM, Sam Dods via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; I propose that function argument types could be omitted in the same way<br>&gt;&gt;&gt;&gt; as variable and property argument types are omitted when they are set at<br>&gt;&gt;&gt;&gt; point of definition.<br>&gt;&gt;&gt;&gt; [...]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We have a pretty strict rule here: types are allowed to be inferred in<br>&gt;&gt;&gt; implementations, but not interfaces. This is important for efficient<br>&gt;&gt;&gt; compilation, encourages people to think about their API interfaces, and<br>&gt;&gt;&gt; somewhat reduces the damage when they don’t.<br>&gt;&gt; <br>&gt;&gt; +1<br>&gt; <br>&gt; Sorry, but this(&quot;We have a pretty strict rule&quot;) seems just like not true. The rule is broken as you can see (so not such a &#39;strict&#39;) :<br></p><p>Yes, I’m aware of that, that’s why I used the waffly word “pretty” :-)<br></p><p>-Chris<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
