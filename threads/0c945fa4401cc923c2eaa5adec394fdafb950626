<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ddfdaf0f44f9f985f1de1b27edc06ae9?s=50"></div><header><strong>Proposal: Add implicit/default else-behaviour for the guard statement</strong> from <string>Vester Gottfried</string> &lt;vester.gottfried at gmail.com&gt;<p>December 16, 2015 at 12:00:00am</p></header><div class="content"><p>I find myself writing the same else blocks for guard statements over and<br>over again, so it might be reasonable to think about a default behaviour.<br></p><p>In a current project I found 217 guard statements from which 183 have<br>repetitive else clauses<br></p><p>&gt;From which:<br>131 end with &quot;else { return nil }&quot;<br>44 &quot;else { return }&quot;<br>6 &quot;else { continue }&quot;<br>2 &quot;else { break }&quot;<br></p><p>My proposal would be to make the else block optional and define a default<br>behaviour.<br></p><p>For example:<br></p><p>func foo(x: Int) {<br>​    ​<br>guard x &lt; 10<br>​    ​<br>...<br>}<br></p><p>swift would implicitly add &quot;else { return }&quot;<br></p><p>--<br></p><p>func foo(x: Int) -&gt; Int? {<br>​    ​<br>guard x &lt; 10<br>​    ​<br>...<br>}<br></p><p>swift would implicitly add &quot;else { return nil }&quot;<br></p><p>--<br></p><p>for i in 0..&lt;10 {<br>​    ​<br>guard i%2 == 0<br>}<br></p><p>swift would implicitly add &quot;else { continue }&quot;<br></p><p>--<br></p><p>switch {<br>case a :<br>​    ​<br>guard x != y<br>case b :<br>​    ...​<br></p><p>}<br></p><p>swift would implicitly add &quot;else { break }&quot;<br></p><p>--<br></p><p>func foo(x: Int) -&gt; Int {<br>​    ​<br>guard x &lt; 10<br>​    ​<br>...<br>}<br></p><p>swift would provide a warning that the guard statement needs an else block<br></p><p>--<br></p><p>Possible advantages<br>- Less code<br>​ to write​<br></p><p>- visually cleaner<br>-<br>​ ​<br>In code with multiple guard statements<br>​ ​<br>you<br>​ ​<br>would not have to repeat the else block<br></p><p><br>Possible Disadvantages<br>- Different behaviour in different contexts (func/return, for/continue,<br>switch/break, …) needs to be learned and understood<br>- programmers might forget that guard + else {} is an option<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/0c940626/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Proposal: Add implicit/default else-behaviour for the guard statement</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>December 15, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; On Dec 15, 2015, at 4:53 PM, Vester Gottfried via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&lt;snip&gt;<br></p><p>&gt; My proposal would be to make the else block optional and define a default behaviour.<br>&gt; <br>&gt; For example:<br>&gt; <br>&gt; func foo(x: Int) {<br>&gt; ​    ​guard x &lt; 10<br>&gt; ​    ​...<br>&gt; }<br>&gt; <br>&gt; swift would implicitly add &quot;else { return }”<br>&gt; <br></p><p>That makes sense<br></p><p>&gt; --<br>&gt; <br>&gt; func foo(x: Int) -&gt; Int? {<br>&gt; ​    ​guard x &lt; 10<br>&gt; ​    ​…<br>&gt; }<br>&gt; <br>&gt; swift would implicitly add &quot;else { return nil }”<br>&gt; <br>You would need to decide how this plays into the type system <br>- is Optional a special case<br>- or, will it work with anything NilLiteralConvertible (Optional, ImplicitlyUnwrappedOptional, Pointer types, Selectors)<br></p><p>I thought of using the no-argument initializer, but that creates too much default behavior (empty arrays, zero doubles, etc). <br></p><p>Plus, it is inconsistent with variable declarations, which require explicit initialization before use.<br></p><p>&gt; --<br>&gt; <br>&gt; for i in 0..&lt;10 {<br>&gt; ​    ​guard i%2 == 0<br>&gt; }<br>&gt; swift would implicitly add &quot;else { continue }”<br>&gt; switch {<br>&gt; case a :<br>&gt; ​    ​guard x != y<br>&gt; case b :<br>&gt; ​    ...​<br>&gt; }<br>&gt; swift would implicitly add &quot;else { break }&quot;<br></p><p>-1 . Flow control functions need to be explicit, else I risk having (and assuming) the wrong behavior when I copy and paste code from one context to another.<br></p><p>Plus, why would I expect a guard in a for loop to break or continue as a default behavior? I personally know I would constantly think this guard as ‘does what I mean’, while in the debugger it seems to be doing exactly the opposite of what I assumed, every time, regardless of my assumption ;-)<br></p><p>&gt; <br>&gt; func foo(x: Int) -&gt; Int {<br>&gt; ​    ​guard x &lt; 10<br>&gt; ​    ​...<br>&gt; }<br>&gt; <br>&gt; swift would provide a warning that the guard statement needs an else block<br></p><p>Iff your proposal was to call the no-argument initializer, this would return 0. For the other options this would need to return an error, not a warning. <br></p><p>-DW<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/0e2414ff/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4002684831b0a89736f4837d2e60f66a?s=50"></div><header><strong>Proposal: Add implicit/default else-behaviour for the guard statement</strong> from <string>Pierre Monod-Broca</string> &lt;pierremonodbroca at gmail.com&gt;<p>December 16, 2015 at 08:00:00am</p></header><div class="content"><p>Looking at the numbers it would make sense mostly to return from a function. And I agree with David that control flow in loops and switches should be explicit.<br></p><p>So maybe a function could declare a default behavior for all its `guard`<br></p><p>Pierre<br></p><p>&gt; Le 16 déc. 2015 à 01:42, David Waite via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Dec 15, 2015, at 4:53 PM, Vester Gottfried via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &lt;snip&gt;<br>&gt;&gt; <br>&gt;&gt; My proposal would be to make the else block optional and define a default behaviour.<br>&gt;&gt; <br>&gt;&gt; For example:<br>&gt;&gt; <br>&gt;&gt; func foo(x: Int) {<br>&gt;&gt; ​    ​guard x &lt; 10<br>&gt;&gt; ​    ​...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; swift would implicitly add &quot;else { return }”<br>&gt; <br>&gt; That makes sense<br>&gt; <br>&gt;&gt; --<br>&gt;&gt; <br>&gt;&gt; func foo(x: Int) -&gt; Int? {<br>&gt;&gt; ​    ​guard x &lt; 10<br>&gt;&gt; ​    ​…<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; swift would implicitly add &quot;else { return nil }”<br>&gt; You would need to decide how this plays into the type system <br>&gt; - is Optional a special case<br>&gt; - or, will it work with anything NilLiteralConvertible (Optional, ImplicitlyUnwrappedOptional, Pointer types, Selectors)<br>&gt; <br>&gt; I thought of using the no-argument initializer, but that creates too much default behavior (empty arrays, zero doubles, etc). <br>&gt; <br>&gt; Plus, it is inconsistent with variable declarations, which require explicit initialization before use.<br>&gt; <br>&gt;&gt; --<br>&gt;&gt; <br>&gt;&gt; for i in 0..&lt;10 {<br>&gt;&gt; ​    ​guard i%2 == 0<br>&gt;&gt; }<br>&gt;&gt; swift would implicitly add &quot;else { continue }”<br>&gt;&gt; switch {<br>&gt;&gt; case a :<br>&gt;&gt; ​    ​guard x != y<br>&gt;&gt; case b :<br>&gt;&gt; ​    ...​<br>&gt;&gt; }<br>&gt;&gt; swift would implicitly add &quot;else { break }&quot;<br>&gt; <br>&gt; -1 . Flow control functions need to be explicit, else I risk having (and assuming) the wrong behavior when I copy and paste code from one context to another.<br>&gt; <br>&gt; Plus, why would I expect a guard in a for loop to break or continue as a default behavior? I personally know I would constantly think this guard as ‘does what I mean’, while in the debugger it seems to be doing exactly the opposite of what I assumed, every time, regardless of my assumption ;-)<br>&gt; <br>&gt;&gt; <br>&gt;&gt; func foo(x: Int) -&gt; Int {<br>&gt;&gt; ​    ​guard x &lt; 10<br>&gt;&gt; ​    ​...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; swift would provide a warning that the guard statement needs an else block<br>&gt; <br>&gt; Iff your proposal was to call the no-argument initializer, this would return 0. For the other options this would need to return an error, not a warning. <br>&gt; <br>&gt; -DW<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/bd16ed1e/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2861bfeb71de9de58206bb6ae750bc2f?s=50"></div><header><strong>Proposal: Add implicit/default else-behaviour for the guard statement</strong> from <string>ilya</string> &lt;ilya.nikokoshev at gmail.com&gt;<p>December 16, 2015 at 07:00:00am</p></header><div class="content"><p>+1 on default return<br></p><p>-1 on default continue or break, this is ambiguous.<br>Even inside switch it&#39;s not clear if guard should break or return, so let&#39;s<br>not make people guess. .<br></p><p>Also can we stop requiring braces for simple one-liners:<br></p><p>guard x&lt;10 else return 5<br></p><p>As for default return values, we could create a VoidLiteralConvertible, so<br>that default return automatically becomes return nil or return [] in an<br>Optional or Array context respectively. As a bonus, it will be technically<br>possible to override this behavior inside a specific function scope.<br></p><p>&gt; swift would provide a warning that the guard statement needs an else block<br></p><p>In this specific case the compiler basically has to guess, so an error<br>seems more appropriate.<br></p><p>Ilya.<br></p><p>On Wed, Dec 16, 2015 at 02:53 Vester Gottfried via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I find myself writing the same else blocks for guard statements over and<br>&gt; over again, so it might be reasonable to think about a default behaviour.<br>&gt;<br>&gt; In a current project I found 217 guard statements from which 183 have<br>&gt; repetitive else clauses<br>&gt;<br>&gt; From which:<br>&gt; 131 end with &quot;else { return nil }&quot;<br>&gt; 44 &quot;else { return }&quot;<br>&gt; 6 &quot;else { continue }&quot;<br>&gt; 2 &quot;else { break }&quot;<br>&gt;<br>&gt; My proposal would be to make the else block optional and define a default<br>&gt; behaviour.<br>&gt;<br>&gt; For example:<br>&gt;<br>&gt; func foo(x: Int) {<br>&gt; ​    ​<br>&gt; guard x &lt; 10<br>&gt; ​    ​<br>&gt; ...<br>&gt; }<br>&gt;<br>&gt; swift would implicitly add &quot;else { return }&quot;<br>&gt;<br>&gt; --<br>&gt;<br>&gt; func foo(x: Int) -&gt; Int? {<br>&gt; ​    ​<br>&gt; guard x &lt; 10<br>&gt; ​    ​<br>&gt; ...<br>&gt; }<br>&gt;<br>&gt; swift would implicitly add &quot;else { return nil }&quot;<br>&gt;<br>&gt; --<br>&gt;<br>&gt; for i in 0..&lt;10 {<br>&gt; ​    ​<br>&gt; guard i%2 == 0<br>&gt; }<br>&gt;<br>&gt; swift would implicitly add &quot;else { continue }&quot;<br>&gt;<br>&gt; --<br>&gt;<br>&gt; switch {<br>&gt; case a :<br>&gt; ​    ​<br>&gt; guard x != y<br>&gt; case b :<br>&gt; ​    ...​<br>&gt;<br>&gt; }<br>&gt;<br>&gt; swift would implicitly add &quot;else { break }&quot;<br>&gt;<br>&gt; --<br>&gt;<br>&gt; func foo(x: Int) -&gt; Int {<br>&gt; ​    ​<br>&gt; guard x &lt; 10<br>&gt; ​    ​<br>&gt; ...<br>&gt; }<br>&gt;<br>&gt; swift would provide a warning that the guard statement needs an else block<br>&gt;<br>&gt; --<br>&gt;<br>&gt; Possible advantages<br>&gt; - Less code<br>&gt; ​ to write​<br>&gt;<br>&gt; - visually cleaner<br>&gt; -<br>&gt; ​ ​<br>&gt; In code with multiple guard statements<br>&gt; ​ ​<br>&gt; you<br>&gt; ​ ​<br>&gt; would not have to repeat the else block<br>&gt;<br>&gt;<br>&gt; Possible Disadvantages<br>&gt; - Different behaviour in different contexts (func/return, for/continue,<br>&gt; switch/break, …) needs to be learned and understood<br>&gt; - programmers might forget that guard + else {} is an option<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/e6f0249f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2861bfeb71de9de58206bb6ae750bc2f?s=50"></div><header><strong>Proposal: Add implicit/default else-behaviour for the guard statement</strong> from <string>ilya</string> &lt;ilya.nikokoshev at gmail.com&gt;<p>December 16, 2015 at 04:00:00pm</p></header><div class="content"><p>Actually I thought about VoidLiteralConvertible some more and now I think<br>if we include it the only nontrivial case in the standard library case<br>should be Optional.Nonel. Empty arrays and dictionaries are different from<br>nothing, so it&#39;s best to always return them explicitly.<br></p><p>Oh, and it would help with default values, e.g.<br></p><p>var something:Something?<br>// where does the default value come from? VoidLiteralConvertible!<br></p><p>I want all default values for String in this scope be &quot;none&quot;:<br></p><p>private extension String: VoidLiteralConvertible { ... return &quot;None&quot; ... }<br></p><p>On Wed, Dec 16, 2015 at 10:49 ilya &lt;ilya.nikokoshev at gmail.com&gt; wrote:<br></p><p>&gt; +1 on default return<br>&gt;<br>&gt; -1 on default continue or break, this is ambiguous.<br>&gt; Even inside switch it&#39;s not clear if guard should break or return, so<br>&gt; let&#39;s not make people guess. .<br>&gt;<br>&gt; Also can we stop requiring braces for simple one-liners:<br>&gt;<br>&gt; guard x&lt;10 else return 5<br>&gt;<br>&gt; As for default return values, we could create a VoidLiteralConvertible, so<br>&gt; that default return automatically becomes return nil or return [] in an<br>&gt; Optional or Array context respectively. As a bonus, it will be technically<br>&gt; possible to override this behavior inside a specific function scope.<br>&gt;<br>&gt; &gt; swift would provide a warning that the guard statement needs an else<br>&gt; block<br>&gt;<br>&gt; In this specific case the compiler basically has to guess, so an error<br>&gt; seems more appropriate.<br>&gt;<br>&gt; Ilya.<br>&gt;<br>&gt; On Wed, Dec 16, 2015 at 02:53 Vester Gottfried via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; I find myself writing the same else blocks for guard statements over and<br>&gt;&gt; over again, so it might be reasonable to think about a default behaviour.<br>&gt;&gt;<br>&gt;&gt; In a current project I found 217 guard statements from which 183 have<br>&gt;&gt; repetitive else clauses<br>&gt;&gt;<br>&gt;&gt; From which:<br>&gt;&gt; 131 end with &quot;else { return nil }&quot;<br>&gt;&gt; 44 &quot;else { return }&quot;<br>&gt;&gt; 6 &quot;else { continue }&quot;<br>&gt;&gt; 2 &quot;else { break }&quot;<br>&gt;&gt;<br>&gt;&gt; My proposal would be to make the else block optional and define a default<br>&gt;&gt; behaviour.<br>&gt;&gt;<br>&gt;&gt; For example:<br>&gt;&gt;<br>&gt;&gt; func foo(x: Int) {<br>&gt;&gt; ​    ​<br>&gt;&gt; guard x &lt; 10<br>&gt;&gt; ​    ​<br>&gt;&gt; ...<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; swift would implicitly add &quot;else { return }&quot;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt;<br>&gt;&gt; func foo(x: Int) -&gt; Int? {<br>&gt;&gt; ​    ​<br>&gt;&gt; guard x &lt; 10<br>&gt;&gt; ​    ​<br>&gt;&gt; ...<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; swift would implicitly add &quot;else { return nil }&quot;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt;<br>&gt;&gt; for i in 0..&lt;10 {<br>&gt;&gt; ​    ​<br>&gt;&gt; guard i%2 == 0<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; swift would implicitly add &quot;else { continue }&quot;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt;<br>&gt;&gt; switch {<br>&gt;&gt; case a :<br>&gt;&gt; ​    ​<br>&gt;&gt; guard x != y<br>&gt;&gt; case b :<br>&gt;&gt; ​    ...​<br>&gt;&gt;<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; swift would implicitly add &quot;else { break }&quot;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt;<br>&gt;&gt; func foo(x: Int) -&gt; Int {<br>&gt;&gt; ​    ​<br>&gt;&gt; guard x &lt; 10<br>&gt;&gt; ​    ​<br>&gt;&gt; ...<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; swift would provide a warning that the guard statement needs an else block<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt;<br>&gt;&gt; Possible advantages<br>&gt;&gt; - Less code<br>&gt;&gt; ​ to write​<br>&gt;&gt;<br>&gt;&gt; - visually cleaner<br>&gt;&gt; -<br>&gt;&gt; ​ ​<br>&gt;&gt; In code with multiple guard statements<br>&gt;&gt; ​ ​<br>&gt;&gt; you<br>&gt;&gt; ​ ​<br>&gt;&gt; would not have to repeat the else block<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Possible Disadvantages<br>&gt;&gt; - Different behaviour in different contexts (func/return, for/continue,<br>&gt;&gt; switch/break, …) needs to be learned and understood<br>&gt;&gt; - programmers might forget that guard + else {} is an option<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/4fc7ce20/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85ade213ef182c4a30916753b3c82b1e?s=50"></div><header><strong>Proposal: Add implicit/default else-behaviour for the guard statement</strong> from <string>Ian Ynda-Hummel</string> &lt;ianynda at gmail.com&gt;<p>December 16, 2015 at 06:00:00pm</p></header><div class="content"><p>I am also +1 for implicit return, but -1 on continue/break for the reasons<br>already stated.<br></p><p>I&#39;m -1 for removing braces for one-liners. I think maintaining braces<br>around blocks helps distinguish them from expressions. For example,<br></p><p>    guard x &lt; 10 else return<br></p><p>would catch me off guard (pardon the pun).<br></p><p>I think I&#39;m -1 on VoidLiteralConvertible, but I&#39;m somewhat undecided. I<br>think that separating the return value from the actual return point could<br>lead to a lot of confusion, and would subsequently also make it easy to<br>accidentally return the default value when you didn&#39;t intend to as the<br>compiler wouldn&#39;t complain about a missing return value.  I don&#39;t think I<br>have totally convinced myself that the latter is a non-trivial problem, but<br>I thought it was worth mentioning.<br></p><p>On Wed, Dec 16, 2015 at 11:59 AM ilya via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Actually I thought about VoidLiteralConvertible some more and now I think<br>&gt; if we include it the only nontrivial case in the standard library case<br>&gt; should be Optional.Nonel. Empty arrays and dictionaries are different from<br>&gt; nothing, so it&#39;s best to always return them explicitly.<br>&gt;<br>&gt; Oh, and it would help with default values, e.g.<br>&gt;<br>&gt; var something:Something?<br>&gt; // where does the default value come from? VoidLiteralConvertible!<br>&gt;<br>&gt; I want all default values for String in this scope be &quot;none&quot;:<br>&gt;<br>&gt; private extension String: VoidLiteralConvertible { ... return &quot;None&quot; ... }<br>&gt;<br>&gt; On Wed, Dec 16, 2015 at 10:49 ilya &lt;ilya.nikokoshev at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; +1 on default return<br>&gt;&gt;<br>&gt;&gt; -1 on default continue or break, this is ambiguous.<br>&gt;&gt; Even inside switch it&#39;s not clear if guard should break or return, so<br>&gt;&gt; let&#39;s not make people guess. .<br>&gt;&gt;<br>&gt;&gt; Also can we stop requiring braces for simple one-liners:<br>&gt;&gt;<br>&gt;&gt; guard x&lt;10 else return 5<br>&gt;&gt;<br>&gt;&gt; As for default return values, we could create a VoidLiteralConvertible,<br>&gt;&gt; so that default return automatically becomes return nil or return [] in an<br>&gt;&gt; Optional or Array context respectively. As a bonus, it will be technically<br>&gt;&gt; possible to override this behavior inside a specific function scope.<br>&gt;&gt;<br>&gt;&gt; &gt; swift would provide a warning that the guard statement needs an else<br>&gt;&gt; block<br>&gt;&gt;<br>&gt;&gt; In this specific case the compiler basically has to guess, so an error<br>&gt;&gt; seems more appropriate.<br>&gt;&gt;<br>&gt;&gt; Ilya.<br>&gt;&gt;<br>&gt;&gt; On Wed, Dec 16, 2015 at 02:53 Vester Gottfried via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; I find myself writing the same else blocks for guard statements over and<br>&gt;&gt;&gt; over again, so it might be reasonable to think about a default behaviour.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In a current project I found 217 guard statements from which 183 have<br>&gt;&gt;&gt; repetitive else clauses<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; From which:<br>&gt;&gt;&gt; 131 end with &quot;else { return nil }&quot;<br>&gt;&gt;&gt; 44 &quot;else { return }&quot;<br>&gt;&gt;&gt; 6 &quot;else { continue }&quot;<br>&gt;&gt;&gt; 2 &quot;else { break }&quot;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; My proposal would be to make the else block optional and define a<br>&gt;&gt;&gt; default behaviour.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; For example:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func foo(x: Int) {<br>&gt;&gt;&gt; ​    ​<br>&gt;&gt;&gt; guard x &lt; 10<br>&gt;&gt;&gt; ​    ​<br>&gt;&gt;&gt; ...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; swift would implicitly add &quot;else { return }&quot;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func foo(x: Int) -&gt; Int? {<br>&gt;&gt;&gt; ​    ​<br>&gt;&gt;&gt; guard x &lt; 10<br>&gt;&gt;&gt; ​    ​<br>&gt;&gt;&gt; ...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; swift would implicitly add &quot;else { return nil }&quot;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; for i in 0..&lt;10 {<br>&gt;&gt;&gt; ​    ​<br>&gt;&gt;&gt; guard i%2 == 0<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; swift would implicitly add &quot;else { continue }&quot;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; switch {<br>&gt;&gt;&gt; case a :<br>&gt;&gt;&gt; ​    ​<br>&gt;&gt;&gt; guard x != y<br>&gt;&gt;&gt; case b :<br>&gt;&gt;&gt; ​    ...​<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; swift would implicitly add &quot;else { break }&quot;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func foo(x: Int) -&gt; Int {<br>&gt;&gt;&gt; ​    ​<br>&gt;&gt;&gt; guard x &lt; 10<br>&gt;&gt;&gt; ​    ​<br>&gt;&gt;&gt; ...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; swift would provide a warning that the guard statement needs an else<br>&gt;&gt;&gt; block<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Possible advantages<br>&gt;&gt;&gt; - Less code<br>&gt;&gt;&gt; ​ to write​<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - visually cleaner<br>&gt;&gt;&gt; -<br>&gt;&gt;&gt; ​ ​<br>&gt;&gt;&gt; In code with multiple guard statements<br>&gt;&gt;&gt; ​ ​<br>&gt;&gt;&gt; you<br>&gt;&gt;&gt; ​ ​<br>&gt;&gt;&gt; would not have to repeat the else block<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Possible Disadvantages<br>&gt;&gt;&gt; - Different behaviour in different contexts (func/return, for/continue,<br>&gt;&gt;&gt; switch/break, …) needs to be learned and understood<br>&gt;&gt;&gt; - programmers might forget that guard + else {} is an option<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/060ce056/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0eaab3d5d1d4428f74a711f724f2eb47?s=50"></div><header><strong>Proposal: Add implicit/default else-behaviour for the guard statement</strong> from <string>Etan Kissling</string> &lt;kissling at oberon.ch&gt;<p>December 16, 2015 at 10:00:00pm</p></header><div class="content"><p>Also +1 on default return, -1 on default continue / break, and -1 for removing braces<br></p><p>Instead of VoidLiteralConvertible, one could extend on the idea with something that is not specifically tailored to nil, like<br></p><p>func foo(x: Int) -&gt; Int = 5 {<br>    guard x &lt; 10 // Would return default 5 for x &gt;= 10<br></p><p>    if x &gt; 5 {<br>        return // Would return default 5<br>    }<br>    return x<br>}<br></p><p><br></p><p>Etan<br></p><p><br>On 16 Dec 2015, at 19:39, Ian Ynda-Hummel via swift-evolution &lt;swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br></p><p>I am also +1 for implicit return, but -1 on continue/break for the reasons already stated.<br></p><p>I&#39;m -1 for removing braces for one-liners. I think maintaining braces around blocks helps distinguish them from expressions. For example,<br></p><p>    guard x &lt; 10 else return<br></p><p>would catch me off guard (pardon the pun).<br></p><p>I think I&#39;m -1 on VoidLiteralConvertible, but I&#39;m somewhat undecided. I think that separating the return value from the actual return point could lead to a lot of confusion, and would subsequently also make it easy to accidentally return the default value when you didn&#39;t intend to as the compiler wouldn&#39;t complain about a missing return value.  I don&#39;t think I have totally convinced myself that the latter is a non-trivial problem, but I thought it was worth mentioning.<br></p><p>On Wed, Dec 16, 2015 at 11:59 AM ilya via swift-evolution &lt;swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>Actually I thought about VoidLiteralConvertible some more and now I think if we include it the only nontrivial case in the standard library case should be Optional.Nonel. Empty arrays and dictionaries are different from nothing, so it&#39;s best to always return them explicitly.<br></p><p>Oh, and it would help with default values, e.g.<br></p><p>var something:Something?<br>// where does the default value come from? VoidLiteralConvertible!<br></p><p>I want all default values for String in this scope be &quot;none&quot;:<br></p><p>private extension String: VoidLiteralConvertible { ... return &quot;None&quot; ... }<br></p><p>On Wed, Dec 16, 2015 at 10:49 ilya &lt;ilya.nikokoshev at gmail.com&lt;mailto:ilya.nikokoshev at gmail.com&gt;&gt; wrote:<br>+1 on default return<br></p><p>-1 on default continue or break, this is ambiguous.<br>Even inside switch it&#39;s not clear if guard should break or return, so let&#39;s not make people guess. .<br></p><p>Also can we stop requiring braces for simple one-liners:<br></p><p>guard x&lt;10 else return 5<br></p><p>As for default return values, we could create a VoidLiteralConvertible, so that default return automatically becomes return nil or return [] in an Optional or Array context respectively. As a bonus, it will be technically possible to override this behavior inside a specific function scope.<br></p><p>&gt; swift would provide a warning that the guard statement needs an else block<br></p><p>In this specific case the compiler basically has to guess, so an error seems more appropriate.<br></p><p>Ilya.<br></p><p>On Wed, Dec 16, 2015 at 02:53 Vester Gottfried via swift-evolution &lt;swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>I find myself writing the same else blocks for guard statements over and over again, so it might be reasonable to think about a default behaviour.<br></p><p>In a current project I found 217 guard statements from which 183 have repetitive else clauses<br></p><p>From which:<br>131 end with &quot;else { return nil }&quot;<br>44 &quot;else { return }&quot;<br>6 &quot;else { continue }&quot;<br>2 &quot;else { break }&quot;<br></p><p>My proposal would be to make the else block optional and define a default behaviour.<br></p><p>For example:<br></p><p>func foo(x: Int) {<br>​    ​<br>guard x &lt; 10<br>​    ​<br>...<br>}<br></p><p>swift would implicitly add &quot;else { return }&quot;<br></p><p>--<br></p><p>func foo(x: Int) -&gt; Int? {<br>​    ​<br>guard x &lt; 10<br>​    ​<br>...<br>}<br></p><p>swift would implicitly add &quot;else { return nil }&quot;<br></p><p>--<br></p><p>for i in 0..&lt;10 {<br>​    ​<br>guard i%2 == 0<br>}<br></p><p>swift would implicitly add &quot;else { continue }&quot;<br></p><p>--<br></p><p>switch {<br>case a :<br>​    ​<br>guard x != y<br>case b :<br>​    ...​<br></p><p>}<br></p><p>swift would implicitly add &quot;else { break }&quot;<br></p><p>--<br></p><p>func foo(x: Int) -&gt; Int {<br>​    ​<br>guard x &lt; 10<br>​    ​<br>...<br>}<br></p><p>swift would provide a warning that the guard statement needs an else block<br></p><p>--<br></p><p>Possible advantages<br>- Less code<br>​ to write​<br></p><p>- visually cleaner<br>-<br>​ ​<br>In code with multiple guard statements<br>​ ​<br>you<br>​ ​<br>would not have to repeat the else block<br></p><p><br>Possible Disadvantages<br>- Different behaviour in different contexts (func/return, for/continue, switch/break, …) needs to be learned and understood<br>- programmers might forget that guard + else {} is an option<br> _______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br> _______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br> _______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/321b9d0f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/706baf09e574d70814e4af2d54a315e0?s=50"></div><header><strong>Proposal: Add implicit/default else-behaviour for the guard statement</strong> from <string>Vinicius Vendramini</string> &lt;vinivendra at gmail.com&gt;<p>December 16, 2015 at 05:00:00pm</p></header><div class="content"><p>Bringing up a possible edge case:<br></p><p>func foo() {<br>    while(…) {<br>        guard x &gt; 0<br>    }<br>}<br></p><p>if guard defaulted to return even inside a while (as was suggested), this might be counterintuitive.<br></p><p>&gt; On Dec 16, 2015, at 5:06 PM, Etan Kissling via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Also +1 on default return, -1 on default continue / break, and -1 for removing braces<br>&gt; <br>&gt; Instead of VoidLiteralConvertible, one could extend on the idea with something that is not specifically tailored to nil, like<br>&gt; <br>&gt; func foo(x: Int) -&gt; Int = 5 {<br>&gt;     guard x &lt; 10 // Would return default 5 for x &gt;= 10<br>&gt; <br>&gt;     if x &gt; 5 {<br>&gt;         return // Would return default 5<br>&gt;     }<br>&gt;     return x<br>&gt; }<br>&gt; <br>&gt; <br>&gt; <br>&gt; Etan<br>&gt; <br>&gt; <br>&gt;&gt; On 16 Dec 2015, at 19:39, Ian Ynda-Hummel via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I am also +1 for implicit return, but -1 on continue/break for the reasons already stated.<br>&gt;&gt; <br>&gt;&gt; I&#39;m -1 for removing braces for one-liners. I think maintaining braces around blocks helps distinguish them from expressions. For example,<br>&gt;&gt; <br>&gt;&gt;     guard x &lt; 10 else return<br>&gt;&gt; <br>&gt;&gt; would catch me off guard (pardon the pun).<br>&gt;&gt; <br>&gt;&gt; I think I&#39;m -1 on VoidLiteralConvertible, but I&#39;m somewhat undecided. I think that separating the return value from the actual return point could lead to a lot of confusion, and would subsequently also make it easy to accidentally return the default value when you didn&#39;t intend to as the compiler wouldn&#39;t complain about a missing return value.  I don&#39;t think I have totally convinced myself that the latter is a non-trivial problem, but I thought it was worth mentioning.<br>&gt;&gt; <br>&gt;&gt; On Wed, Dec 16, 2015 at 11:59 AM ilya via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Actually I thought about VoidLiteralConvertible some more and now I think if we include it the only nontrivial case in the standard library case should be Optional.Nonel. Empty arrays and dictionaries are different<br>&gt;&gt;  from nothing, so it&#39;s best to always return them explicitly. <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Oh, and it would help with default values, e.g.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; var something:Something?<br>&gt;&gt; <br>&gt;&gt; // where does the default value come from? VoidLiteralConvertible! <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I want all default values for String in this scope be &quot;none&quot;:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; private extension String: VoidLiteralConvertible { ... return &quot;None&quot; ... }<br>&gt;&gt; <br>&gt;&gt; On Wed, Dec 16, 2015 at 10:49 ilya &lt;ilya.nikokoshev at gmail.com &lt;mailto:ilya.nikokoshev at gmail.com&gt;&gt; wrote:<br>&gt;&gt; +1 on default return <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -1 on default continue or break, this is ambiguous. <br>&gt;&gt; <br>&gt;&gt; Even inside switch it&#39;s not clear if guard should break or return, so let&#39;s not make people guess. .<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Also can we stop requiring braces for simple one-liners: <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; guard x&lt;10 else return 5<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; As for default return values, we could create a VoidLiteralConvertible, so that default return automatically becomes return nil or return [] in an Optional or Array context respectively. As a bonus, it will be technically possible to override this behavior<br>&gt;&gt;  inside a specific function scope. <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; &gt; swift would provide a warning that the guard statement needs an else block<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; In this specific case the compiler basically has to guess, so an error seems more appropriate.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Ilya. <br>&gt;&gt; <br>&gt;&gt; On Wed, Dec 16, 2015 at 02:53 Vester Gottfried via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; I find myself writing the same else blocks for guard statements over and over again, so it might be reasonable to think about a default behaviour.<br>&gt;&gt; <br>&gt;&gt; In a current project I found 217 guard statements from which 183 have repetitive else clauses<br>&gt;&gt; <br>&gt;&gt; From which:<br>&gt;&gt; 131 end with &quot;else { return nil }&quot;<br>&gt;&gt; 44 &quot;else { return }&quot;<br>&gt;&gt; 6 &quot;else { continue }&quot;<br>&gt;&gt; 2 &quot;else { break }&quot;<br>&gt;&gt; <br>&gt;&gt; My proposal would be to make the else block optional and define a default behaviour.<br>&gt;&gt; <br>&gt;&gt; For example:<br>&gt;&gt; <br>&gt;&gt; func foo(x: Int) {<br>&gt;&gt; ​    ​ guard x &lt; 10<br>&gt;&gt; ​    ​ ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; swift would implicitly add &quot;else { return }&quot;<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; <br>&gt;&gt; func foo(x: Int) -&gt; Int? {<br>&gt;&gt; ​    ​ guard x &lt; 10<br>&gt;&gt; ​    ​ ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; swift would implicitly add &quot;else { return nil }&quot;<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; <br>&gt;&gt; for i in 0..&lt;10 {<br>&gt;&gt; ​    ​ guard i%2 == 0<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; swift would implicitly add &quot;else { continue }&quot;<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; <br>&gt;&gt; switch {<br>&gt;&gt; case a :<br>&gt;&gt; ​    ​ guard x != y<br>&gt;&gt; case b :<br>&gt;&gt; ​    ...​ <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; swift would implicitly add &quot;else { break }&quot;<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; <br>&gt;&gt; func foo(x: Int) -&gt; Int {<br>&gt;&gt; ​    ​ guard x &lt; 10<br>&gt;&gt; ​    ​ ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; swift would provide a warning that the guard statement needs an else block<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; <br>&gt;&gt; Possible advantages<br>&gt;&gt; - Less code ​ to write​ <br>&gt;&gt; - visually cleaner<br>&gt;&gt; - ​ ​ In code with multiple guard statements ​ ​ you ​ ​ would not have to repeat the else block<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Possible Disadvantages<br>&gt;&gt; - Different behaviour in different contexts (func/return, for/continue, switch/break, …) needs to be learned and understood<br>&gt;&gt; - programmers might forget that guard + else {} is an option<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/2e247f1e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0eaab3d5d1d4428f74a711f724f2eb47?s=50"></div><header><strong>Proposal: Add implicit/default else-behaviour for the guard statement</strong> from <string>Etan Kissling</string> &lt;kissling at oberon.ch&gt;<p>December 16, 2015 at 10:00:00pm</p></header><div class="content"><p>If guard defaults to something context-dependent, it&#39;s also counterintuitive.<br></p><p><br>Me personally is fine with guard x &gt; 0 returning from the function in this case.<br></p><p>I use guard mainly as a glorified assert that allows safe exit from the function instead of crashing the program on fail.<br>If you think about it that way, it&#39;s perfectly reasonable that it returns in all cases.<br></p><p><br></p><p>On the other hand, the implicit default else behaviour could only trigger if there is no outer scope that can be exited with break.<br>Maybe OP could post additional statistics of the number cases where &quot;guard ... else { return }&quot; is used inside a breakable scope.<br></p><p><br>Etan<br></p><p><br></p><p><br></p><p>&gt; On 16 Dec 2015, at 23:15, Vinicius Vendramini &lt;vinivendra at gmail.com&gt; wrote:<br>&gt; <br>&gt; Bringing up a possible edge case:<br>&gt; <br>&gt; func foo() {<br>&gt;     while(…) {<br>&gt;         guard x &gt; 0<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; if guard defaulted to return even inside a while (as was suggested), this might be counterintuitive.<br>&gt; <br>&gt;&gt; On Dec 16, 2015, at 5:06 PM, Etan Kissling via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Also +1 on default return, -1 on default continue / break, and -1 for removing braces<br>&gt;&gt; <br>&gt;&gt; Instead of VoidLiteralConvertible, one could extend on the idea with something that is not specifically tailored to nil, like<br>&gt;&gt; <br>&gt;&gt; func foo(x: Int) -&gt; Int = 5 {<br>&gt;&gt;     guard x &lt; 10 // Would return default 5 for x &gt;= 10<br>&gt;&gt; <br>&gt;&gt;     if x &gt; 5 {<br>&gt;&gt;         return // Would return default 5<br>&gt;&gt;     }<br>&gt;&gt;     return x<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Etan<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 16 Dec 2015, at 19:39, Ian Ynda-Hummel via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I am also +1 for implicit return, but -1 on continue/break for the reasons already stated.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m -1 for removing braces for one-liners. I think maintaining braces around blocks helps distinguish them from expressions. For example,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     guard x &lt; 10 else return<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; would catch me off guard (pardon the pun).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think I&#39;m -1 on VoidLiteralConvertible, but I&#39;m somewhat undecided. I think that separating the return value from the actual return point could lead to a lot of confusion, and would subsequently also make it easy to accidentally return the default value when you didn&#39;t intend to as the compiler wouldn&#39;t complain about a missing return value.  I don&#39;t think I have totally convinced myself that the latter is a non-trivial problem, but I thought it was worth mentioning.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Wed, Dec 16, 2015 at 11:59 AM ilya via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; Actually I thought about VoidLiteralConvertible some more and now I think if we include it the only nontrivial case in the standard library case should be Optional.Nonel. Empty arrays and dictionaries are different<br>&gt;&gt;&gt;  from nothing, so it&#39;s best to always return them explicitly.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Oh, and it would help with default values, e.g.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var something:Something?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // where does the default value come from? VoidLiteralConvertible!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I want all default values for String in this scope be &quot;none&quot;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; private extension String: VoidLiteralConvertible { ... return &quot;None&quot; ... }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Wed, Dec 16, 2015 at 10:49 ilya &lt;ilya.nikokoshev at gmail.com &lt;mailto:ilya.nikokoshev at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; +1 on default return<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -1 on default continue or break, this is ambiguous.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Even inside switch it&#39;s not clear if guard should break or return, so let&#39;s not make people guess. .<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Also can we stop requiring braces for simple one-liners:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; guard x&lt;10 else return 5<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As for default return values, we could create a VoidLiteralConvertible, so that default return automatically becomes return nil or return [] in an Optional or Array context respectively. As a bonus, it will be technically possible to override this behavior<br>&gt;&gt;&gt;  inside a specific function scope.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; swift would provide a warning that the guard statement needs an else block<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In this specific case the compiler basically has to guess, so an error seems more appropriate.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Ilya.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Wed, Dec 16, 2015 at 02:53 Vester Gottfried via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; I find myself writing the same else blocks for guard statements over and over again, so it might be reasonable to think about a default behaviour.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In a current project I found 217 guard statements from which 183 have repetitive else clauses<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; From which:<br>&gt;&gt;&gt; 131 end with &quot;else { return nil }&quot;<br>&gt;&gt;&gt; 44 &quot;else { return }&quot;<br>&gt;&gt;&gt; 6 &quot;else { continue }&quot;<br>&gt;&gt;&gt; 2 &quot;else { break }&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My proposal would be to make the else block optional and define a default behaviour.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func foo(x: Int) {<br>&gt;&gt;&gt; ​    ​ guard x &lt; 10<br>&gt;&gt;&gt; ​    ​ ...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; swift would implicitly add &quot;else { return }&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func foo(x: Int) -&gt; Int? {<br>&gt;&gt;&gt; ​    ​ guard x &lt; 10<br>&gt;&gt;&gt; ​    ​ ...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; swift would implicitly add &quot;else { return nil }&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; for i in 0..&lt;10 {<br>&gt;&gt;&gt; ​    ​ guard i%2 == 0<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; swift would implicitly add &quot;else { continue }&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; switch {<br>&gt;&gt;&gt; case a :<br>&gt;&gt;&gt; ​    ​ guard x != y<br>&gt;&gt;&gt; case b :<br>&gt;&gt;&gt; ​    ...​<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; swift would implicitly add &quot;else { break }&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func foo(x: Int) -&gt; Int {<br>&gt;&gt;&gt; ​    ​ guard x &lt; 10<br>&gt;&gt;&gt; ​    ​ ...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; swift would provide a warning that the guard statement needs an else block<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Possible advantages<br>&gt;&gt;&gt; - Less code ​ to write​<br>&gt;&gt;&gt; - visually cleaner<br>&gt;&gt;&gt; - ​ ​ In code with multiple guard statements ​ ​ you ​ ​ would not have to repeat the else block<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Possible Disadvantages<br>&gt;&gt;&gt; - Different behaviour in different contexts (func/return, for/continue, switch/break, …) needs to be learned and understood<br>&gt;&gt;&gt; - programmers might forget that guard + else {} is an option<br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/cd8e0722/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 801 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/cd8e0722/attachment.sig&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ddfdaf0f44f9f985f1de1b27edc06ae9?s=50"></div><header><strong>Proposal: Add implicit/default else-behaviour for the guard statement</strong> from <string>Vester Gottfried</string> &lt;vester.gottfried at gmail.com&gt;<p>December 16, 2015 at 11:00:00pm</p></header><div class="content"><p>I just skipped through 200+ guard statements that return Void, nil or a<br>value and no statement was inside a scope that can be exited with break.<br></p><p>I am also thinking about the proposals regarding default values to return,<br>but I am not sure if this would even be necessary.  In my case 80% of all<br>guard statements end with &quot;else { return }&quot; or &quot;else { return nil }&quot;.<br></p><p>On Wed, Dec 16, 2015 at 11:20 PM, Etan Kissling via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; If guard defaults to something context-dependent, it&#39;s also<br>&gt; counterintuitive.<br>&gt;<br>&gt;<br>&gt; Me personally is fine with guard x &gt; 0 returning from the function in this<br>&gt; case.<br>&gt;<br>&gt; I use guard mainly as a glorified assert that allows safe exit from the<br>&gt; function instead of crashing the program on fail.<br>&gt; If you think about it that way, it&#39;s perfectly reasonable that it returns<br>&gt; in all cases.<br>&gt;<br>&gt;<br>&gt;<br>&gt; On the other hand, the implicit default else behaviour could only trigger<br>&gt; if there is no outer scope that can be exited with break.<br>&gt; Maybe OP could post additional statistics of the number cases where &quot;guard<br>&gt; ... else { return }&quot; is used inside a breakable scope.<br>&gt;<br>&gt;<br>&gt; Etan<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; On 16 Dec 2015, at 23:15, Vinicius Vendramini &lt;vinivendra at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; Bringing up a possible edge case:<br>&gt;<br>&gt; func foo() {<br>&gt;     while(…) {<br>&gt;         guard x &gt; 0<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; if guard defaulted to return even inside a while (as was suggested), this<br>&gt; might be counterintuitive.<br>&gt;<br>&gt; On Dec 16, 2015, at 5:06 PM, Etan Kissling via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Also +1 on default return, -1 on default continue / break, and -1 for<br>&gt; removing braces<br>&gt;<br>&gt; Instead of VoidLiteralConvertible, one could extend on the idea with<br>&gt; something that is not specifically tailored to nil, like<br>&gt;<br>&gt; func foo(x: Int) -&gt; Int = 5 {<br>&gt;     guard x &lt; 10 // Would return default 5 for x &gt;= 10<br>&gt;<br>&gt;     if x &gt; 5 {<br>&gt;         return // Would return default 5<br>&gt;     }<br>&gt;     return x<br>&gt; }<br>&gt;<br>&gt;<br>&gt;<br>&gt; Etan<br>&gt;<br>&gt;<br>&gt; On 16 Dec 2015, at 19:39, Ian Ynda-Hummel via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I am also +1 for implicit return, but -1 on continue/break for the reasons<br>&gt; already stated.<br>&gt;<br>&gt; I&#39;m -1 for removing braces for one-liners. I think maintaining braces<br>&gt; around blocks helps distinguish them from expressions. For example,<br>&gt;<br>&gt;     guard x &lt; 10 else return<br>&gt;<br>&gt; would catch me off guard (pardon the pun).<br>&gt;<br>&gt; I think I&#39;m -1 on VoidLiteralConvertible, but I&#39;m somewhat undecided. I<br>&gt; think that separating the return value from the actual return point could<br>&gt; lead to a lot of confusion, and would subsequently also make it easy to<br>&gt; accidentally return the default value when you didn&#39;t intend to as the<br>&gt; compiler wouldn&#39;t complain about a missing return value.  I don&#39;t think I<br>&gt; have totally convinced myself that the latter is a non-trivial problem, but<br>&gt; I thought it was worth mentioning.<br>&gt;<br>&gt; On Wed, Dec 16, 2015 at 11:59 AM ilya via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Actually I thought about VoidLiteralConvertible some more and now I think<br>&gt;&gt; if we include it the only nontrivial case in the standard library case<br>&gt;&gt; should be Optional.Nonel. Empty arrays and dictionaries are different from<br>&gt;&gt; nothing, so it&#39;s best to always return them explicitly.<br>&gt;&gt;<br>&gt;&gt; Oh, and it would help with default values, e.g.<br>&gt;&gt;<br>&gt;&gt; var something:Something?<br>&gt;&gt; // where does the default value come from? VoidLiteralConvertible!<br>&gt;&gt;<br>&gt;&gt; I want all default values for String in this scope be &quot;none&quot;:<br>&gt;&gt;<br>&gt;&gt; private extension String: VoidLiteralConvertible { ... return &quot;None&quot; ... }<br>&gt;&gt;<br>&gt;&gt; On Wed, Dec 16, 2015 at 10:49 ilya &lt;ilya.nikokoshev at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; +1 on default return<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -1 on default continue or break, this is ambiguous.<br>&gt;&gt;&gt; Even inside switch it&#39;s not clear if guard should break or return, so<br>&gt;&gt;&gt; let&#39;s not make people guess. .<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Also can we stop requiring braces for simple one-liners:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; guard x&lt;10 else return 5<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; As for default return values, we could create a VoidLiteralConvertible,<br>&gt;&gt;&gt; so that default return automatically becomes return nil or return [] in an<br>&gt;&gt;&gt; Optional or Array context respectively. As a bonus, it will be technically<br>&gt;&gt;&gt; possible to override this behavior inside a specific function scope.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; swift would provide a warning that the guard statement needs an else<br>&gt;&gt;&gt; block<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In this specific case the compiler basically has to guess, so an error<br>&gt;&gt;&gt; seems more appropriate.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Ilya.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Wed, Dec 16, 2015 at 02:53 Vester Gottfried via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I find myself writing the same else blocks for guard statements over<br>&gt;&gt;&gt;&gt; and over again, so it might be reasonable to think about a default<br>&gt;&gt;&gt;&gt; behaviour.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; In a current project I found 217 guard statements from which 183 have<br>&gt;&gt;&gt;&gt; repetitive else clauses<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; From which:<br>&gt;&gt;&gt;&gt; 131 end with &quot;else { return nil }&quot;<br>&gt;&gt;&gt;&gt; 44 &quot;else { return }&quot;<br>&gt;&gt;&gt;&gt; 6 &quot;else { continue }&quot;<br>&gt;&gt;&gt;&gt; 2 &quot;else { break }&quot;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; My proposal would be to make the else block optional and define a<br>&gt;&gt;&gt;&gt; default behaviour.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; For example:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; func foo(x: Int) {<br>&gt;&gt;&gt;&gt; ​    ​<br>&gt;&gt;&gt;&gt; guard x &lt; 10<br>&gt;&gt;&gt;&gt; ​    ​<br>&gt;&gt;&gt;&gt; ...<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; swift would implicitly add &quot;else { return }&quot;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; func foo(x: Int) -&gt; Int? {<br>&gt;&gt;&gt;&gt; ​    ​<br>&gt;&gt;&gt;&gt; guard x &lt; 10<br>&gt;&gt;&gt;&gt; ​    ​<br>&gt;&gt;&gt;&gt; ...<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; swift would implicitly add &quot;else { return nil }&quot;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; for i in 0..&lt;10 {<br>&gt;&gt;&gt;&gt; ​    ​<br>&gt;&gt;&gt;&gt; guard i%2 == 0<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; swift would implicitly add &quot;else { continue }&quot;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; switch {<br>&gt;&gt;&gt;&gt; case a :<br>&gt;&gt;&gt;&gt; ​    ​<br>&gt;&gt;&gt;&gt; guard x != y<br>&gt;&gt;&gt;&gt; case b :<br>&gt;&gt;&gt;&gt; ​    ...​<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; swift would implicitly add &quot;else { break }&quot;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; func foo(x: Int) -&gt; Int {<br>&gt;&gt;&gt;&gt; ​    ​<br>&gt;&gt;&gt;&gt; guard x &lt; 10<br>&gt;&gt;&gt;&gt; ​    ​<br>&gt;&gt;&gt;&gt; ...<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; swift would provide a warning that the guard statement needs an else<br>&gt;&gt;&gt;&gt; block<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Possible advantages<br>&gt;&gt;&gt;&gt; - Less code<br>&gt;&gt;&gt;&gt; ​ to write​<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; - visually cleaner<br>&gt;&gt;&gt;&gt; -<br>&gt;&gt;&gt;&gt; ​ ​<br>&gt;&gt;&gt;&gt; In code with multiple guard statements<br>&gt;&gt;&gt;&gt; ​ ​<br>&gt;&gt;&gt;&gt; you<br>&gt;&gt;&gt;&gt; ​ ​<br>&gt;&gt;&gt;&gt; would not have to repeat the else block<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Possible Disadvantages<br>&gt;&gt;&gt;&gt; - Different behaviour in different contexts (func/return, for/continue,<br>&gt;&gt;&gt;&gt; switch/break, …) needs to be learned and understood<br>&gt;&gt;&gt;&gt; - programmers might forget that guard + else {} is an option<br>&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/4b4dd85a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d68c97e8e2f1653b54c24493caf236ae?s=50"></div><header><strong>Proposal: Add implicit/default else-behaviour for the guard statement</strong> from <string>Stephen Celis</string> &lt;stephen.celis at gmail.com&gt;<p>December 16, 2015 at 06:00:00pm</p></header><div class="content"><p>I&#39;m opposed. I don&#39;t think `else { return }` is enough of a mouthful to add<br>a default behavior that must be learned and reasoned with.<br></p><p>Stephen<br></p><p>On Wed, Dec 16, 2015 at 5:36 PM, Vester Gottfried via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I just skipped through 200+ guard statements that return Void, nil or a<br>&gt; value and no statement was inside a scope that can be exited with break.<br>&gt;<br>&gt; I am also thinking about the proposals regarding default values to return,<br>&gt; but I am not sure if this would even be necessary.  In my case 80% of all<br>&gt; guard statements end with &quot;else { return }&quot; or &quot;else { return nil }&quot;.<br>&gt;<br>&gt; On Wed, Dec 16, 2015 at 11:20 PM, Etan Kissling via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; If guard defaults to something context-dependent, it&#39;s also<br>&gt;&gt; counterintuitive.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Me personally is fine with guard x &gt; 0 returning from the function in<br>&gt;&gt; this case.<br>&gt;&gt;<br>&gt;&gt; I use guard mainly as a glorified assert that allows safe exit from the<br>&gt;&gt; function instead of crashing the program on fail.<br>&gt;&gt; If you think about it that way, it&#39;s perfectly reasonable that it returns<br>&gt;&gt; in all cases.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On the other hand, the implicit default else behaviour could only trigger<br>&gt;&gt; if there is no outer scope that can be exited with break.<br>&gt;&gt; Maybe OP could post additional statistics of the number cases where<br>&gt;&gt; &quot;guard ... else { return }&quot; is used inside a breakable scope.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Etan<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On 16 Dec 2015, at 23:15, Vinicius Vendramini &lt;vinivendra at gmail.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Bringing up a possible edge case:<br>&gt;&gt;<br>&gt;&gt; func foo() {<br>&gt;&gt;     while(…) {<br>&gt;&gt;         guard x &gt; 0<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; if guard defaulted to return even inside a while (as was suggested), this<br>&gt;&gt; might be counterintuitive.<br>&gt;&gt;<br>&gt;&gt; On Dec 16, 2015, at 5:06 PM, Etan Kissling via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Also +1 on default return, -1 on default continue / break, and -1 for<br>&gt;&gt; removing braces<br>&gt;&gt;<br>&gt;&gt; Instead of VoidLiteralConvertible, one could extend on the idea with<br>&gt;&gt; something that is not specifically tailored to nil, like<br>&gt;&gt;<br>&gt;&gt; func foo(x: Int) -&gt; Int = 5 {<br>&gt;&gt;     guard x &lt; 10 // Would return default 5 for x &gt;= 10<br>&gt;&gt;<br>&gt;&gt;     if x &gt; 5 {<br>&gt;&gt;         return // Would return default 5<br>&gt;&gt;     }<br>&gt;&gt;     return x<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Etan<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On 16 Dec 2015, at 19:39, Ian Ynda-Hummel via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I am also +1 for implicit return, but -1 on continue/break for the<br>&gt;&gt; reasons already stated.<br>&gt;&gt;<br>&gt;&gt; I&#39;m -1 for removing braces for one-liners. I think maintaining braces<br>&gt;&gt; around blocks helps distinguish them from expressions. For example,<br>&gt;&gt;<br>&gt;&gt;     guard x &lt; 10 else return<br>&gt;&gt;<br>&gt;&gt; would catch me off guard (pardon the pun).<br>&gt;&gt;<br>&gt;&gt; I think I&#39;m -1 on VoidLiteralConvertible, but I&#39;m somewhat undecided. I<br>&gt;&gt; think that separating the return value from the actual return point could<br>&gt;&gt; lead to a lot of confusion, and would subsequently also make it easy to<br>&gt;&gt; accidentally return the default value when you didn&#39;t intend to as the<br>&gt;&gt; compiler wouldn&#39;t complain about a missing return value.  I don&#39;t think I<br>&gt;&gt; have totally convinced myself that the latter is a non-trivial problem, but<br>&gt;&gt; I thought it was worth mentioning.<br>&gt;&gt;<br>&gt;&gt; On Wed, Dec 16, 2015 at 11:59 AM ilya via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Actually I thought about VoidLiteralConvertible some more and now I<br>&gt;&gt;&gt; think if we include it the only nontrivial case in the standard library<br>&gt;&gt;&gt; case should be Optional.Nonel. Empty arrays and dictionaries are different<br>&gt;&gt;&gt; from nothing, so it&#39;s best to always return them explicitly.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Oh, and it would help with default values, e.g.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; var something:Something?<br>&gt;&gt;&gt; // where does the default value come from? VoidLiteralConvertible!<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I want all default values for String in this scope be &quot;none&quot;:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; private extension String: VoidLiteralConvertible { ... return &quot;None&quot; ...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Wed, Dec 16, 2015 at 10:49 ilya &lt;ilya.nikokoshev at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; +1 on default return<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; -1 on default continue or break, this is ambiguous.<br>&gt;&gt;&gt;&gt; Even inside switch it&#39;s not clear if guard should break or return, so<br>&gt;&gt;&gt;&gt; let&#39;s not make people guess. .<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Also can we stop requiring braces for simple one-liners:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; guard x&lt;10 else return 5<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; As for default return values, we could create a VoidLiteralConvertible,<br>&gt;&gt;&gt;&gt; so that default return automatically becomes return nil or return [] in an<br>&gt;&gt;&gt;&gt; Optional or Array context respectively. As a bonus, it will be technically<br>&gt;&gt;&gt;&gt; possible to override this behavior inside a specific function scope.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt; swift would provide a warning that the guard statement needs an else<br>&gt;&gt;&gt;&gt; block<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; In this specific case the compiler basically has to guess, so an error<br>&gt;&gt;&gt;&gt; seems more appropriate.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Ilya.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 02:53 Vester Gottfried via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I find myself writing the same else blocks for guard statements over<br>&gt;&gt;&gt;&gt;&gt; and over again, so it might be reasonable to think about a default<br>&gt;&gt;&gt;&gt;&gt; behaviour.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; In a current project I found 217 guard statements from which 183 have<br>&gt;&gt;&gt;&gt;&gt; repetitive else clauses<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; From which:<br>&gt;&gt;&gt;&gt;&gt; 131 end with &quot;else { return nil }&quot;<br>&gt;&gt;&gt;&gt;&gt; 44 &quot;else { return }&quot;<br>&gt;&gt;&gt;&gt;&gt; 6 &quot;else { continue }&quot;<br>&gt;&gt;&gt;&gt;&gt; 2 &quot;else { break }&quot;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; My proposal would be to make the else block optional and define a<br>&gt;&gt;&gt;&gt;&gt; default behaviour.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; For example:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; func foo(x: Int) {<br>&gt;&gt;&gt;&gt;&gt; ​    ​<br>&gt;&gt;&gt;&gt;&gt; guard x &lt; 10<br>&gt;&gt;&gt;&gt;&gt; ​    ​<br>&gt;&gt;&gt;&gt;&gt; ...<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; swift would implicitly add &quot;else { return }&quot;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; func foo(x: Int) -&gt; Int? {<br>&gt;&gt;&gt;&gt;&gt; ​    ​<br>&gt;&gt;&gt;&gt;&gt; guard x &lt; 10<br>&gt;&gt;&gt;&gt;&gt; ​    ​<br>&gt;&gt;&gt;&gt;&gt; ...<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; swift would implicitly add &quot;else { return nil }&quot;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; for i in 0..&lt;10 {<br>&gt;&gt;&gt;&gt;&gt; ​    ​<br>&gt;&gt;&gt;&gt;&gt; guard i%2 == 0<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; swift would implicitly add &quot;else { continue }&quot;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; switch {<br>&gt;&gt;&gt;&gt;&gt; case a :<br>&gt;&gt;&gt;&gt;&gt; ​    ​<br>&gt;&gt;&gt;&gt;&gt; guard x != y<br>&gt;&gt;&gt;&gt;&gt; case b :<br>&gt;&gt;&gt;&gt;&gt; ​    ...​<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; swift would implicitly add &quot;else { break }&quot;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; func foo(x: Int) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt; ​    ​<br>&gt;&gt;&gt;&gt;&gt; guard x &lt; 10<br>&gt;&gt;&gt;&gt;&gt; ​    ​<br>&gt;&gt;&gt;&gt;&gt; ...<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; swift would provide a warning that the guard statement needs an else<br>&gt;&gt;&gt;&gt;&gt; block<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Possible advantages<br>&gt;&gt;&gt;&gt;&gt; - Less code<br>&gt;&gt;&gt;&gt;&gt; ​ to write​<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; - visually cleaner<br>&gt;&gt;&gt;&gt;&gt; -<br>&gt;&gt;&gt;&gt;&gt; ​ ​<br>&gt;&gt;&gt;&gt;&gt; In code with multiple guard statements<br>&gt;&gt;&gt;&gt;&gt; ​ ​<br>&gt;&gt;&gt;&gt;&gt; you<br>&gt;&gt;&gt;&gt;&gt; ​ ​<br>&gt;&gt;&gt;&gt;&gt; would not have to repeat the else block<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Possible Disadvantages<br>&gt;&gt;&gt;&gt;&gt; - Different behaviour in different contexts (func/return,<br>&gt;&gt;&gt;&gt;&gt; for/continue, switch/break, …) needs to be learned and understood<br>&gt;&gt;&gt;&gt;&gt; - programmers might forget that guard + else {} is an option<br>&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/e3778243/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/aeab22e60ba7b7e2bd445775850448d1?s=50"></div><header><strong>Proposal: Add implicit/default else-behaviour for the guard statement</strong> from <string>Radosław Pietruszewski</string> &lt;radexpl at gmail.com&gt;<p>December 17, 2015 at 12:00:00am</p></header><div class="content"><p>I’m also against, for two reasons:<br></p><p>- looking at my code, `return` and `return nil` are most common, but not super-overwhelmingly so. I’m all for common-sense default behavior, but here, I’m just not convinced it’s worth it. Likewise, I hate noise in code, but I’m not bothered by explicit `else` blocks at all.<br>- guard is already confusing enough until you truly, fully get it. Having an `else` block makes it far more clearer that it’s a (specialized) branching operation. Having something implicitly return from my method sounds almost scary.<br></p><p>— Radek<br></p><p>&gt; On 17 Dec 2015, at 00:26, Stephen Celis via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;m opposed. I don&#39;t think `else { return }` is enough of a mouthful to add a default behavior that must be learned and reasoned with.<br>&gt; <br>&gt; Stephen<br>&gt; <br>&gt; On Wed, Dec 16, 2015 at 5:36 PM, Vester Gottfried via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; I just skipped through 200+ guard statements that return Void, nil or a value and no statement was inside a scope that can be exited with break. <br>&gt; <br>&gt; I am also thinking about the proposals regarding default values to return, but I am not sure if this would even be necessary.  In my case 80% of all guard statements end with &quot;else { return }&quot; or &quot;else { return nil }&quot;. <br>&gt; <br>&gt; On Wed, Dec 16, 2015 at 11:20 PM, Etan Kissling via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; If guard defaults to something context-dependent, it&#39;s also counterintuitive.<br>&gt; <br>&gt; <br>&gt; Me personally is fine with guard x &gt; 0 returning from the function in this case.<br>&gt; <br>&gt; I use guard mainly as a glorified assert that allows safe exit from the function instead of crashing the program on fail.<br>&gt; If you think about it that way, it&#39;s perfectly reasonable that it returns in all cases.<br>&gt; <br>&gt; <br>&gt; <br>&gt; On the other hand, the implicit default else behaviour could only trigger if there is no outer scope that can be exited with break.<br>&gt; Maybe OP could post additional statistics of the number cases where &quot;guard ... else { return }&quot; is used inside a breakable scope.<br>&gt; <br>&gt; <br>&gt; Etan<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On 16 Dec 2015, at 23:15, Vinicius Vendramini &lt;vinivendra at gmail.com &lt;mailto:vinivendra at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Bringing up a possible edge case:<br>&gt;&gt; <br>&gt;&gt; func foo() {<br>&gt;&gt;     while(…) {<br>&gt;&gt;         guard x &gt; 0<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; if guard defaulted to return even inside a while (as was suggested), this might be counterintuitive.<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 16, 2015, at 5:06 PM, Etan Kissling via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Also +1 on default return, -1 on default continue / break, and -1 for removing braces<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Instead of VoidLiteralConvertible, one could extend on the idea with something that is not specifically tailored to nil, like<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func foo(x: Int) -&gt; Int = 5 {<br>&gt;&gt;&gt;     guard x &lt; 10 // Would return default 5 for x &gt;= 10<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     if x &gt; 5 {<br>&gt;&gt;&gt;         return // Would return default 5<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     return x<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Etan<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 16 Dec 2015, at 19:39, Ian Ynda-Hummel via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I am also +1 for implicit return, but -1 on continue/break for the reasons already stated.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m -1 for removing braces for one-liners. I think maintaining braces around blocks helps distinguish them from expressions. For example,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     guard x &lt; 10 else return<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; would catch me off guard (pardon the pun).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think I&#39;m -1 on VoidLiteralConvertible, but I&#39;m somewhat undecided. I think that separating the return value from the actual return point could lead to a lot of confusion, and would subsequently also make it easy to accidentally return the default value when you didn&#39;t intend to as the compiler wouldn&#39;t complain about a missing return value.  I don&#39;t think I have totally convinced myself that the latter is a non-trivial problem, but I thought it was worth mentioning.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 11:59 AM ilya via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; Actually I thought about VoidLiteralConvertible some more and now I think if we include it the only nontrivial case in the standard library case should be Optional.Nonel. Empty arrays and dictionaries are different<br>&gt;&gt;&gt;&gt;  from nothing, so it&#39;s best to always return them explicitly. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Oh, and it would help with default values, e.g.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var something:Something?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // where does the default value come from? VoidLiteralConvertible! <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I want all default values for String in this scope be &quot;none&quot;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; private extension String: VoidLiteralConvertible { ... return &quot;None&quot; ... }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 10:49 ilya &lt;ilya.nikokoshev at gmail.com &lt;mailto:ilya.nikokoshev at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; +1 on default return <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -1 on default continue or break, this is ambiguous. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Even inside switch it&#39;s not clear if guard should break or return, so let&#39;s not make people guess. .<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Also can we stop requiring braces for simple one-liners: <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; guard x&lt;10 else return 5<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As for default return values, we could create a VoidLiteralConvertible, so that default return automatically becomes return nil or return [] in an Optional or Array context respectively. As a bonus, it will be technically possible to override this behavior<br>&gt;&gt;&gt;&gt;  inside a specific function scope. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt; swift would provide a warning that the guard statement needs an else block<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In this specific case the compiler basically has to guess, so an error seems more appropriate.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Ilya. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 02:53 Vester Gottfried via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; I find myself writing the same else blocks for guard statements over and over again, so it might be reasonable to think about a default behaviour.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In a current project I found 217 guard statements from which 183 have repetitive else clauses<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; From which:<br>&gt;&gt;&gt;&gt; 131 end with &quot;else { return nil }&quot;<br>&gt;&gt;&gt;&gt; 44 &quot;else { return }&quot;<br>&gt;&gt;&gt;&gt; 6 &quot;else { continue }&quot;<br>&gt;&gt;&gt;&gt; 2 &quot;else { break }&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; My proposal would be to make the else block optional and define a default behaviour.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For example:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func foo(x: Int) {<br>&gt;&gt;&gt;&gt; ​    ​ guard x &lt; 10<br>&gt;&gt;&gt;&gt; ​    ​ ...<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; swift would implicitly add &quot;else { return }&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func foo(x: Int) -&gt; Int? {<br>&gt;&gt;&gt;&gt; ​    ​ guard x &lt; 10<br>&gt;&gt;&gt;&gt; ​    ​ ...<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; swift would implicitly add &quot;else { return nil }&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; for i in 0..&lt;10 {<br>&gt;&gt;&gt;&gt; ​    ​ guard i%2 == 0<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; swift would implicitly add &quot;else { continue }&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; switch {<br>&gt;&gt;&gt;&gt; case a :<br>&gt;&gt;&gt;&gt; ​    ​ guard x != y<br>&gt;&gt;&gt;&gt; case b :<br>&gt;&gt;&gt;&gt; ​    ...​ <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; swift would implicitly add &quot;else { break }&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func foo(x: Int) -&gt; Int {<br>&gt;&gt;&gt;&gt; ​    ​ guard x &lt; 10<br>&gt;&gt;&gt;&gt; ​    ​ ...<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; swift would provide a warning that the guard statement needs an else block<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Possible advantages<br>&gt;&gt;&gt;&gt; - Less code ​ to write​ <br>&gt;&gt;&gt;&gt; - visually cleaner<br>&gt;&gt;&gt;&gt; - ​ ​ In code with multiple guard statements ​ ​ you ​ ​ would not have to repeat the else block<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Possible Disadvantages<br>&gt;&gt;&gt;&gt; - Different behaviour in different contexts (func/return, for/continue, switch/break, …) needs to be learned and understood<br>&gt;&gt;&gt;&gt; - programmers might forget that guard + else {} is an option<br>&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/0534f3e8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Proposal: Add implicit/default else-behaviour for the guard statement</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>December 16, 2015 at 05:00:00pm</p></header><div class="content"><p>Count me in as a &quot;no&quot;. Despite the redundancy, actually spelling out how the else clause leaves scope is valuable to reading the code.<br></p><p>-- E<br></p><p><br></p><p>&gt; On Dec 16, 2015, at 4:40 PM, Radosław Pietruszewski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I’m also against, for two reasons:<br>&gt; <br>&gt; - looking at my code, `return` and `return nil` are most common, but not super-overwhelmingly so. I’m all for common-sense default behavior, but here, I’m just not convinced it’s worth it. Likewise, I hate noise in code, but I’m not bothered by explicit `else` blocks at all.<br>&gt; - guard is already confusing enough until you truly, fully get it. Having an `else` block makes it far more clearer that it’s a (specialized) branching operation. Having something implicitly return from my method sounds almost scary.<br>&gt; <br>&gt; — Radek<br>&gt; <br>&gt;&gt; On 17 Dec 2015, at 00:26, Stephen Celis via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;m opposed. I don&#39;t think `else { return }` is enough of a mouthful to add a default behavior that must be learned and reasoned with.<br>&gt;&gt; <br>&gt;&gt; Stephen<br>&gt;&gt; <br>&gt;&gt; On Wed, Dec 16, 2015 at 5:36 PM, Vester Gottfried via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; I just skipped through 200+ guard statements that return Void, nil or a value and no statement was inside a scope that can be exited with break. <br>&gt;&gt; <br>&gt;&gt; I am also thinking about the proposals regarding default values to return, but I am not sure if this would even be necessary.  In my case 80% of all guard statements end with &quot;else { return }&quot; or &quot;else { return nil }&quot;. <br>&gt;&gt; <br>&gt;&gt; On Wed, Dec 16, 2015 at 11:20 PM, Etan Kissling via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; If guard defaults to something context-dependent, it&#39;s also counterintuitive.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Me personally is fine with guard x &gt; 0 returning from the function in this case.<br>&gt;&gt; <br>&gt;&gt; I use guard mainly as a glorified assert that allows safe exit from the function instead of crashing the program on fail.<br>&gt;&gt; If you think about it that way, it&#39;s perfectly reasonable that it returns in all cases.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On the other hand, the implicit default else behaviour could only trigger if there is no outer scope that can be exited with break.<br>&gt;&gt; Maybe OP could post additional statistics of the number cases where &quot;guard ... else { return }&quot; is used inside a breakable scope.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Etan<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 16 Dec 2015, at 23:15, Vinicius Vendramini &lt;vinivendra at gmail.com &lt;mailto:vinivendra at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Bringing up a possible edge case:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func foo() {<br>&gt;&gt;&gt;     while(…) {<br>&gt;&gt;&gt;         guard x &gt; 0<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; if guard defaulted to return even inside a while (as was suggested), this might be counterintuitive.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 16, 2015, at 5:06 PM, Etan Kissling via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Also +1 on default return, -1 on default continue / break, and -1 for removing braces<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Instead of VoidLiteralConvertible, one could extend on the idea with something that is not specifically tailored to nil, like<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func foo(x: Int) -&gt; Int = 5 {<br>&gt;&gt;&gt;&gt;     guard x &lt; 10 // Would return default 5 for x &gt;= 10<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     if x &gt; 5 {<br>&gt;&gt;&gt;&gt;         return // Would return default 5<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;     return x<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Etan<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 16 Dec 2015, at 19:39, Ian Ynda-Hummel via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I am also +1 for implicit return, but -1 on continue/break for the reasons already stated.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;m -1 for removing braces for one-liners. I think maintaining braces around blocks helps distinguish them from expressions. For example,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     guard x &lt; 10 else return<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; would catch me off guard (pardon the pun).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think I&#39;m -1 on VoidLiteralConvertible, but I&#39;m somewhat undecided. I think that separating the return value from the actual return point could lead to a lot of confusion, and would subsequently also make it easy to accidentally return the default value when you didn&#39;t intend to as the compiler wouldn&#39;t complain about a missing return value.  I don&#39;t think I have totally convinced myself that the latter is a non-trivial problem, but I thought it was worth mentioning.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 11:59 AM ilya via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; Actually I thought about VoidLiteralConvertible some more and now I think if we include it the only nontrivial case in the standard library case should be Optional.Nonel. Empty arrays and dictionaries are different<br>&gt;&gt;&gt;&gt;&gt;  from nothing, so it&#39;s best to always return them explicitly. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Oh, and it would help with default values, e.g.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; var something:Something?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // where does the default value come from? VoidLiteralConvertible! <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I want all default values for String in this scope be &quot;none&quot;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; private extension String: VoidLiteralConvertible { ... return &quot;None&quot; ... }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 10:49 ilya &lt;ilya.nikokoshev at gmail.com &lt;mailto:ilya.nikokoshev at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; +1 on default return <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -1 on default continue or break, this is ambiguous. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Even inside switch it&#39;s not clear if guard should break or return, so let&#39;s not make people guess. .<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Also can we stop requiring braces for simple one-liners: <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; guard x&lt;10 else return 5<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; As for default return values, we could create a VoidLiteralConvertible, so that default return automatically becomes return nil or return [] in an Optional or Array context respectively. As a bonus, it will be technically possible to override this behavior<br>&gt;&gt;&gt;&gt;&gt;  inside a specific function scope. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; swift would provide a warning that the guard statement needs an else block<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In this specific case the compiler basically has to guess, so an error seems more appropriate.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Ilya. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 02:53 Vester Gottfried via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; I find myself writing the same else blocks for guard statements over and over again, so it might be reasonable to think about a default behaviour.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In a current project I found 217 guard statements from which 183 have repetitive else clauses<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; From which:<br>&gt;&gt;&gt;&gt;&gt; 131 end with &quot;else { return nil }&quot;<br>&gt;&gt;&gt;&gt;&gt; 44 &quot;else { return }&quot;<br>&gt;&gt;&gt;&gt;&gt; 6 &quot;else { continue }&quot;<br>&gt;&gt;&gt;&gt;&gt; 2 &quot;else { break }&quot;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; My proposal would be to make the else block optional and define a default behaviour.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; For example:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func foo(x: Int) {<br>&gt;&gt;&gt;&gt;&gt; ​    ​ guard x &lt; 10<br>&gt;&gt;&gt;&gt;&gt; ​    ​ ...<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; swift would implicitly add &quot;else { return }&quot;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func foo(x: Int) -&gt; Int? {<br>&gt;&gt;&gt;&gt;&gt; ​    ​ guard x &lt; 10<br>&gt;&gt;&gt;&gt;&gt; ​    ​ ...<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; swift would implicitly add &quot;else { return nil }&quot;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; for i in 0..&lt;10 {<br>&gt;&gt;&gt;&gt;&gt; ​    ​ guard i%2 == 0<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; swift would implicitly add &quot;else { continue }&quot;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; switch {<br>&gt;&gt;&gt;&gt;&gt; case a :<br>&gt;&gt;&gt;&gt;&gt; ​    ​ guard x != y<br>&gt;&gt;&gt;&gt;&gt; case b :<br>&gt;&gt;&gt;&gt;&gt; ​    ...​ <br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; swift would implicitly add &quot;else { break }&quot;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func foo(x: Int) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt; ​    ​ guard x &lt; 10<br>&gt;&gt;&gt;&gt;&gt; ​    ​ ...<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; swift would provide a warning that the guard statement needs an else block<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Possible advantages<br>&gt;&gt;&gt;&gt;&gt; - Less code ​ to write​ <br>&gt;&gt;&gt;&gt;&gt; - visually cleaner<br>&gt;&gt;&gt;&gt;&gt; - ​ ​ In code with multiple guard statements ​ ​ you ​ ​ would not have to repeat the else block<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Possible Disadvantages<br>&gt;&gt;&gt;&gt;&gt; - Different behaviour in different contexts (func/return, for/continue, switch/break, …) needs to be learned and understood<br>&gt;&gt;&gt;&gt;&gt; - programmers might forget that guard + else {} is an option<br>&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/24972308/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Add implicit/default else-behaviour for the guard statement</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 17, 2015 at 12:00:00am</p></header><div class="content"><p>On Wed, Dec 16, 2015, at 04:30 PM, Erica Sadun via swift-evolution wrote:<br>&gt; Count me in as a &quot;no&quot;. Despite the redundancy, actually spelling out<br>&gt; how the else clause leaves scope is valuable to reading the code.<br></p><p>Agreed. Count me as a &quot;no&quot; as well. `else { return }` is not problematic<br>enough to justify the penalty to reading comprehension.<br></p><p>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/d9a1f241/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>Proposal: Add implicit/default else-behaviour for the guard statement</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>December 17, 2015 at 04:00:00pm</p></header><div class="content"><p>I&#39;m conflicted.<br></p><p>Pros:<br></p><p>1) Neat. :-)<br></p><p>2) Um, less typing? But Xcode has snippets, you know.<br></p><p>3) Less visual noise? Perhaps someone considers that visual noise, but to me { return nil } is an essential part of the flow and actually helps to understand it.<br></p><p>4) I would love a “guard!” variant that crashes instead of returning.<br></p><p>Cons:<br></p><p>1) Can no longer find all returns by just looking for &#39;return&#39;.<br></p><p>2) Reads more like an assertion than like a return.<br></p><p>I believe there are no good arguments one way or another, so we have to fall back on the taste of the core team.<br></p><p>A.<br></p><p><br>&gt; On Dec 17, 2015, at 2:35 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Wed, Dec 16, 2015, at 04:30 PM, Erica Sadun via swift-evolution wrote:<br>&gt;&gt; Count me in as a &quot;no&quot;. Despite the redundancy, actually spelling out how the else clause leaves scope is valuable to reading the code.<br>&gt;  <br>&gt; Agreed. Count me as a &quot;no&quot; as well. `else { return }` is not problematic enough to justify the penalty to reading comprehension.<br>&gt;  <br>&gt; -Kevin Ballard<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/819b775e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>Proposal: Add implicit/default else-behaviour for the guard statement</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>December 17, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; Le 17 déc. 2015 à 11:58, Andrey Tarantsov via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; 4) I would love a “guard!” variant that crashes instead of returning.<br></p><p>Isn’t it the role of assert and precondition?<br></p><p>Yet I have to admit that assert and precondition can not replace guards like the following, which define a variable:<br></p><p>	guard let x = optionalX else {<br>	    fatalError(&quot;Missing x&quot;)<br>	}<br>	// use x<br></p><p>Gwendal Roué<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Proposal: Add implicit/default else-behaviour for the guard statement</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>December 17, 2015 at 10:00:00pm</p></header><div class="content"><p>I&#39;m a +1 on the return defaults with void/optional.<br>Within a switch I&#39;m on the fence, it seems reasonable to break, but you may<br>want to return.<br>Within a loop I&#39;m against it, I think I think that continue makes the most<br>sense (forEach will exhibit the same behaviour), but you may want break or<br>return.<br></p><p><br>On Thu, Dec 17, 2015 at 10:01 PM, Gwendal Roué &lt;swift-evolution at swift.org&gt;<br>wrote:<br></p><p>&gt;<br>&gt; &gt; Le 17 déc. 2015 à 11:58, Andrey Tarantsov via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt; &gt;<br>&gt; &gt; 4) I would love a “guard!” variant that crashes instead of returning.<br>&gt;<br>&gt; Isn’t it the role of assert and precondition?<br>&gt;<br>&gt; Yet I have to admit that assert and precondition can not replace guards<br>&gt; like the following, which define a variable:<br>&gt;<br>&gt;         guard let x = optionalX else {<br>&gt;             fatalError(&quot;Missing x&quot;)<br>&gt;         }<br>&gt;         // use x<br>&gt;<br>&gt; Gwendal Roué<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/03b1c72e/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>Proposal: Add implicit/default else-behaviour for the guard statement</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>December 17, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt;&gt; 4) I would love a “guard!” variant that crashes instead of returning.<br>&gt; <br>&gt; Isn’t it the role of assert and precondition?<br></p><p>Well, there&#39;s another thread talking about an alternative name for assert. guard! could be a good one. And, yes, &quot;guard! let&quot; isn&#39;t currently possible with assert.<br></p><p>More importantly, sometimes I change my mind about whether something is a valid failure or should be a crash, and a one-character difference would be appreciated. (Granted, that doesn&#39;t happen often, just sometimes.)<br></p><p>A.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d68c97e8e2f1653b54c24493caf236ae?s=50"></div><header><strong>Proposal: Add implicit/default else-behaviour for the guard statement</strong> from <string>Stephen Celis</string> &lt;stephen.celis at gmail.com&gt;<p>December 17, 2015 at 08:00:00am</p></header><div class="content"><p>&gt; On Dec 17, 2015, at 6:01 AM, Gwendal Roué via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Yet I have to admit that assert and precondition can not replace guards like the following, which define a variable:<br>&gt; <br>&gt; 	guard let x = optionalX else {<br>&gt; 	    fatalError(&quot;Missing x&quot;)<br>&gt; 	}<br>&gt; 	// use x<br></p><p>Isn&#39;t this essentially<br></p><p>    let x = optionalX!<br></p><p>:)<br></p><p>Stephen<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>Proposal: Add implicit/default else-behaviour for the guard statement</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>December 17, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; Le 17 déc. 2015 à 14:06, Stephen Celis &lt;stephen.celis at gmail.com&gt; a écrit :<br>&gt; <br>&gt;&gt; On Dec 17, 2015, at 6:01 AM, Gwendal Roué via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Yet I have to admit that assert and precondition can not replace guards like the following, which define a variable:<br>&gt;&gt; <br>&gt;&gt; 	guard let x = optionalX else {<br>&gt;&gt; 	    fatalError(&quot;Missing x&quot;)<br>&gt;&gt; 	}<br>&gt;&gt; 	// use x<br>&gt; <br>&gt; Isn&#39;t this essentially<br>&gt; <br>&gt;    let x = optionalX!<br>&gt; <br>&gt; :)<br>&gt; <br>&gt; Stephen<br></p><p>Yes it is :-) Happy to see you there :-)<br></p><p>Gwendal<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
