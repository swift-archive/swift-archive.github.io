<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/58198fee5117e461741cf98ff9a8a9e6?s=50"></div><header><strong>try? shouldn&#39;t work on non-method-call</strong> from <string>Sikhapol Saijit</string> &lt;sikhapol at gmail.com&gt;<p>August 18, 2016 at 12:00:00pm</p></header><div class="content"><p>Hi all,<br></p><p><br>Yesterday I tried this code:<br></p><p>func couldFailButWillNot() throws -&gt; Any {<br>    return 42<br>}<br></p><p>if let a = try? couldFailButWillNot() as? Int {<br>    print(a)<br>}<br></p><p>And was surprised that the output was Optional(42) on both Swift 2 and Swift 3.<br>I always have the impression that when a variable is resolved with if let it will never be optional.<br></p><p>So, with a little investigation, I found out that it happens because as? has higher precedence than try? and is evaluated first.<br>And the whole expression `try? couldFailButWillNot() as? Int` evaluated as Optional(Optional(42)).<br></p><p>Also, I’m surprised that try? can be used with non-method-call.<br>This code: `print(try? 42)` will print Optional(42).<br></p><p>So, the questions are:<br></p><p>1. Is it intentional that try? can be used with a &quot;non-method-call&quot; and return an optional of the type that follows?<br></p><p>2. Should we design try? to have higher precedence than as? or any operators at all?<br>My intuition tells me that <br>let a = try? couldFailButWillNot() as? Int<br>should be equivalent to<br>let a = (try? couldFailButWillNot()) as? Int <br></p><p>3. Do you think that doubly-nested optional (or multi-level-nested optional) is confusing and should be removed from Swift? (Yes, I’ve seen this blog post Optionals Case Study: valuesForKeys &lt;https://developer.apple.com/swift/blog/?id=12&gt;).<br>For me Optional(nil) (aka Optional.Some(Optional.None))) doesn’t make much sense. <br>Maybe, one of the solution is to always have optional of optional merged into a single level optional? Like Optional(Optional(Optional(42))) should be the merged to and evaluated as Optional(42).<br></p><p>BTW, the code above is merely for a demonstration. The actual code was more of something like this:<br></p><p>func parse(JSON: Data) throws -&gt; Any {<br>    // …<br>}<br></p><p>if let dict = try? parse(JSON: json) as? [String: Any] {<br>    // assume dict is a valid [String: Any] dictionary<br>    // …<br>}<br></p><p>I’m new to this mailing list so I’m not sure if this belongs here. I’m sorry in advance if it doesn’t.<br></p><p><br>Thank you,<br>Sam<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160818/131672de/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>try? shouldn&#39;t work on non-method-call</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>August 18, 2016 at 09:00:00am</p></header><div class="content"><p>Opinions inline:<br></p><p>&gt; On 18 Aug 2016, at 07:43, Sikhapol Saijit via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; <br>&gt; Yesterday I tried this code:<br>&gt; <br>&gt; func couldFailButWillNot() throws -&gt; Any {<br>&gt;     return 42<br>&gt; }<br>&gt; <br>&gt; if let a = try? couldFailButWillNot() as? Int {<br>&gt;     print(a)<br>&gt; }<br>&gt; <br>&gt; And was surprised that the output was Optional(42) on both Swift 2 and Swift 3.<br>&gt; I always have the impression that when a variable is resolved with if let it will never be optional.<br>&gt; <br>&gt; So, with a little investigation, I found out that it happens because as? has higher precedence than try? and is evaluated first.<br>&gt; And the whole expression `try? couldFailButWillNot() as? Int` evaluated as Optional(Optional(42)).<br>&gt; <br>&gt; Also, I’m surprised that try? can be used with non-method-call.<br>&gt; This code: `print(try? 42)` will print Optional(42).<br>&gt; <br>&gt; So, the questions are:<br>&gt; <br>&gt; 1. Is it intentional that try? can be used with a &quot;non-method-call&quot; and return an optional of the type that follows?<br></p><p>I think this is the real solution. try and try? should not be allowed on non-throwing functions or expressions.<br></p><p>&gt; 2. Should we design try? to have higher precedence than as? or any operators at all?<br>&gt; My intuition tells me that <br>&gt; let a = try? couldFailButWillNot() as? Int<br>&gt; should be equivalent to<br>&gt; let a = (try? couldFailButWillNot()) as? Int <br></p><p>That’s worth considering. try feels like it should tie very strongly with the throwing expression.<br></p><p>&gt; 3. Do you think that doubly-nested optional (or multi-level-nested optional) is confusing and should be removed from Swift? (Yes, I’ve seen this blog post Optionals Case Study: valuesForKeys &lt;https://developer.apple.com/swift/blog/?id=12&gt;).<br>&gt; For me Optional(nil) (aka Optional.Some(Optional.None))) doesn’t make much sense. <br>&gt; Maybe, one of the solution is to always have optional of optional merged into a single level optional? Like Optional(Optional(Optional(42))) should be the merged to and evaluated as Optional(42).<br></p><p>I don’t think this is the solution. Even if it was, how would you expect to “remove” them from Swift? Optionals are simply an enum with an associated value. We’d have to introduce a language feature to restrict values that can be stored in enum cases? It sounds awfully complicated.<br></p><p>&gt; BTW, the code above is merely for a demonstration. The actual code was more of something like this:<br>&gt; <br>&gt; func parse(JSON: Data) throws -&gt; Any {<br>&gt;     // …<br>&gt; }<br>&gt; <br>&gt; if let dict = try? parse(JSON: json) as? [String: Any] {<br>&gt;     // assume dict is a valid [String: Any] dictionary<br>&gt;     // …<br>&gt; }<br>&gt; <br>&gt; I’m new to this mailing list so I’m not sure if this belongs here. I’m sorry in advance if it doesn’t.<br>&gt; <br>&gt; <br>&gt; Thank you,<br>&gt; Sam<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160818/ba168506/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>try? shouldn&#39;t work on non-method-call</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>August 18, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; On Aug 18, 2016, at 12:52 AM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Opinions inline:<br>&gt; <br>&gt;&gt; On 18 Aug 2016, at 07:43, Sikhapol Saijit via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Yesterday I tried this code:<br>&gt;&gt; <br>&gt;&gt; func couldFailButWillNot() throws -&gt; Any {<br>&gt;&gt;     return 42<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; if let a = try? couldFailButWillNot() as? Int {<br>&gt;&gt;     print(a)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; And was surprised that the output was Optional(42) on both Swift 2 and Swift 3.<br>&gt;&gt; I always have the impression that when a variable is resolved with if let it will never be optional.<br>&gt;&gt; <br>&gt;&gt; So, with a little investigation, I found out that it happens because as? has higher precedence than try? and is evaluated first.<br>&gt;&gt; And the whole expression `try? couldFailButWillNot() as? Int` evaluated as Optional(Optional(42)).<br>&gt;&gt; <br>&gt;&gt; Also, I’m surprised that try? can be used with non-method-call.<br>&gt;&gt; This code: `print(try? 42)` will print Optional(42).<br>&gt;&gt; <br>&gt;&gt; So, the questions are:<br>&gt;&gt; <br>&gt;&gt; 1. Is it intentional that try? can be used with a &quot;non-method-call&quot; and return an optional of the type that follows?<br>&gt; <br>&gt; I think this is the real solution. try and try? should not be allowed on non-throwing functions or expressions.<br></p><p>This is a warning right now — do you think it should be an error?<br></p><p>Slavas-MacBook-Pro:~ slava$ cat ttt.swift <br>func f() {}<br></p><p>func g() {<br>  try f()<br>  try? f()<br>}<br></p><p>Slavas-MacBook-Pro:~ slava$ swiftc ttt.swift <br>ttt.swift:4:3: warning: no calls to throwing functions occur within &#39;try&#39; expression<br>  try f()<br>  ^<br>ttt.swift:5:8: warning: no calls to throwing functions occur within &#39;try&#39; expression<br>  try? f()<br>       ^<br></p><p>&gt; <br>&gt;&gt; 2. Should we design try? to have higher precedence than as? or any operators at all?<br>&gt;&gt; My intuition tells me that <br>&gt;&gt; let a = try? couldFailButWillNot() as? Int<br>&gt;&gt; should be equivalent to<br>&gt;&gt; let a = (try? couldFailButWillNot()) as? Int <br>&gt; <br>&gt; That’s worth considering. try feels like it should tie very strongly with the throwing expression.<br>&gt; <br>&gt;&gt; 3. Do you think that doubly-nested optional (or multi-level-nested optional) is confusing and should be removed from Swift? (Yes, I’ve seen this blog post Optionals Case Study: valuesForKeys &lt;https://developer.apple.com/swift/blog/?id=12&gt;).<br>&gt;&gt; For me Optional(nil) (aka Optional.Some(Optional.None))) doesn’t make much sense. <br>&gt;&gt; Maybe, one of the solution is to always have optional of optional merged into a single level optional? Like Optional(Optional(Optional(42))) should be the merged to and evaluated as Optional(42).<br>&gt; <br>&gt; I don’t think this is the solution. Even if it was, how would you expect to “remove” them from Swift? Optionals are simply an enum with an associated value. We’d have to introduce a language feature to restrict values that can be stored in enum cases? It sounds awfully complicated.<br>&gt; <br>&gt;&gt; BTW, the code above is merely for a demonstration. The actual code was more of something like this:<br>&gt;&gt; <br>&gt;&gt; func parse(JSON: Data) throws -&gt; Any {<br>&gt;&gt;     // …<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; if let dict = try? parse(JSON: json) as? [String: Any] {<br>&gt;&gt;     // assume dict is a valid [String: Any] dictionary<br>&gt;&gt;     // …<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I’m new to this mailing list so I’m not sure if this belongs here. I’m sorry in advance if it doesn’t.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Thank you,<br>&gt;&gt; Sam<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160818/27ac3295/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>try? shouldn&#39;t work on non-method-call</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>August 18, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; On Aug 18, 2016, at 1:42 AM, Slava Pestov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Aug 18, 2016, at 12:52 AM, David Hart via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Opinions inline:<br>&gt;&gt; <br>&gt;&gt;&gt; On 18 Aug 2016, at 07:43, Sikhapol Saijit via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yesterday I tried this code:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func couldFailButWillNot() throws -&gt; Any {<br>&gt;&gt;&gt;     return 42<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; if let a = try? couldFailButWillNot() as? Int {<br>&gt;&gt;&gt;     print(a)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And was surprised that the output was Optional(42) on both Swift 2 and Swift 3.<br>&gt;&gt;&gt; I always have the impression that when a variable is resolved with if let it will never be optional.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So, with a little investigation, I found out that it happens because as? has higher precedence than try? and is evaluated first.<br>&gt;&gt;&gt; And the whole expression `try? couldFailButWillNot() as? Int` evaluated as Optional(Optional(42)).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Also, I’m surprised that try? can be used with non-method-call.<br>&gt;&gt;&gt; This code: `print(try? 42)` will print Optional(42).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So, the questions are:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. Is it intentional that try? can be used with a &quot;non-method-call&quot; and return an optional of the type that follows?<br>&gt;&gt; <br>&gt;&gt; I think this is the real solution. try and try? should not be allowed on non-throwing functions or expressions.<br>&gt; <br>&gt; This is a warning right now — do you think it should be an error?<br>&gt; <br>&gt; Slavas-MacBook-Pro:~ slava$ cat ttt.swift <br>&gt; func f() {}<br>&gt; <br>&gt; func g() {<br>&gt;   try f()<br>&gt;   try? f()<br>&gt; }<br>&gt; <br>&gt; Slavas-MacBook-Pro:~ slava$ swiftc ttt.swift <br>&gt; ttt.swift:4:3: warning: no calls to throwing functions occur within &#39;try&#39; expression<br>&gt;   try f()<br>&gt;   ^<br>&gt; ttt.swift:5:8: warning: no calls to throwing functions occur within &#39;try&#39; expression<br>&gt;   try? f()<br>&gt;        ^<br></p><p>… Replying to myself: I also think it would be more logical for this to be an error, but I vaguely recall some internal discussion where we agreed that removing ‘throws’ from a function should not break source or binary compatibility (I don’t know if the current implementation makes good on the latter).<br></p><p>Jordan, do you remember the reasoning for this being a warning and not an error?<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; 2. Should we design try? to have higher precedence than as? or any operators at all?<br>&gt;&gt;&gt; My intuition tells me that <br>&gt;&gt;&gt; let a = try? couldFailButWillNot() as? Int<br>&gt;&gt;&gt; should be equivalent to<br>&gt;&gt;&gt; let a = (try? couldFailButWillNot()) as? Int <br>&gt;&gt; <br>&gt;&gt; That’s worth considering. try feels like it should tie very strongly with the throwing expression.<br>&gt;&gt; <br>&gt;&gt;&gt; 3. Do you think that doubly-nested optional (or multi-level-nested optional) is confusing and should be removed from Swift? (Yes, I’ve seen this blog post Optionals Case Study: valuesForKeys &lt;https://developer.apple.com/swift/blog/?id=12&gt;).<br>&gt;&gt;&gt; For me Optional(nil) (aka Optional.Some(Optional.None))) doesn’t make much sense. <br>&gt;&gt;&gt; Maybe, one of the solution is to always have optional of optional merged into a single level optional? Like Optional(Optional(Optional(42))) should be the merged to and evaluated as Optional(42).<br>&gt;&gt; <br>&gt;&gt; I don’t think this is the solution. Even if it was, how would you expect to “remove” them from Swift? Optionals are simply an enum with an associated value. We’d have to introduce a language feature to restrict values that can be stored in enum cases? It sounds awfully complicated.<br>&gt;&gt; <br>&gt;&gt;&gt; BTW, the code above is merely for a demonstration. The actual code was more of something like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func parse(JSON: Data) throws -&gt; Any {<br>&gt;&gt;&gt;     // …<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; if let dict = try? parse(JSON: json) as? [String: Any] {<br>&gt;&gt;&gt;     // assume dict is a valid [String: Any] dictionary<br>&gt;&gt;&gt;     // …<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m new to this mailing list so I’m not sure if this belongs here. I’m sorry in advance if it doesn’t.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt; Sam<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160818/0b623cdb/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/58198fee5117e461741cf98ff9a8a9e6?s=50"></div><header><strong>try? shouldn&#39;t work on non-method-call</strong> from <string>Sikhapol Saijit</string> &lt;sikhapol at gmail.com&gt;<p>August 18, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Aug 18, 2016, at 3:42 PM, Slava Pestov &lt;spestov at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Aug 18, 2016, at 12:52 AM, David Hart via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Opinions inline:<br>&gt;&gt; <br>&gt;&gt;&gt; On 18 Aug 2016, at 07:43, Sikhapol Saijit via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yesterday I tried this code:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func couldFailButWillNot() throws -&gt; Any {<br>&gt;&gt;&gt;     return 42<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; if let a = try? couldFailButWillNot() as? Int {<br>&gt;&gt;&gt;     print(a)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And was surprised that the output was Optional(42) on both Swift 2 and Swift 3.<br>&gt;&gt;&gt; I always have the impression that when a variable is resolved with if let it will never be optional.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So, with a little investigation, I found out that it happens because as? has higher precedence than try? and is evaluated first.<br>&gt;&gt;&gt; And the whole expression `try? couldFailButWillNot() as? Int` evaluated as Optional(Optional(42)).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Also, I’m surprised that try? can be used with non-method-call.<br>&gt;&gt;&gt; This code: `print(try? 42)` will print Optional(42).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So, the questions are:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. Is it intentional that try? can be used with a &quot;non-method-call&quot; and return an optional of the type that follows?<br>&gt;&gt; <br>&gt;&gt; I think this is the real solution. try and try? should not be allowed on non-throwing functions or expressions.<br>&gt; <br>&gt; This is a warning right now — do you think it should be an error?<br>&gt; <br>&gt; Slavas-MacBook-Pro:~ slava$ cat ttt.swift <br>&gt; func f() {}<br>&gt; <br>&gt; func g() {<br>&gt;   try f()<br>&gt;   try? f()<br>&gt; }<br>&gt; <br>&gt; Slavas-MacBook-Pro:~ slava$ swiftc ttt.swift <br>&gt; ttt.swift:4:3: warning: no calls to throwing functions occur within &#39;try&#39; expression<br>&gt;   try f()<br>&gt;   ^<br>&gt; ttt.swift:5:8: warning: no calls to throwing functions occur within &#39;try&#39; expression<br>&gt;   try? f()<br>&gt;        ^<br></p><p>Thank you Slava,<br></p><p>While I think using try/try? on anything but a throwing function call should be an error, right now it even works with anything. `try? 42` will just wrap 42 in an optional and give some warning now.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; 2. Should we design try? to have higher precedence than as? or any operators at all?<br>&gt;&gt;&gt; My intuition tells me that <br>&gt;&gt;&gt; let a = try? couldFailButWillNot() as? Int<br>&gt;&gt;&gt; should be equivalent to<br>&gt;&gt;&gt; let a = (try? couldFailButWillNot()) as? Int <br>&gt;&gt; <br>&gt;&gt; That’s worth considering. try feels like it should tie very strongly with the throwing expression.<br>&gt;&gt; <br>&gt;&gt;&gt; 3. Do you think that doubly-nested optional (or multi-level-nested optional) is confusing and should be removed from Swift? (Yes, I’ve seen this blog post Optionals Case Study: valuesForKeys &lt;https://developer.apple.com/swift/blog/?id=12&gt;).<br>&gt;&gt;&gt; For me Optional(nil) (aka Optional.Some(Optional.None))) doesn’t make much sense. <br>&gt;&gt;&gt; Maybe, one of the solution is to always have optional of optional merged into a single level optional? Like Optional(Optional(Optional(42))) should be the merged to and evaluated as Optional(42).<br>&gt;&gt; <br>&gt;&gt; I don’t think this is the solution. Even if it was, how would you expect to “remove” them from Swift? Optionals are simply an enum with an associated value. We’d have to introduce a language feature to restrict values that can be stored in enum cases? It sounds awfully complicated.<br>&gt;&gt; <br>&gt;&gt;&gt; BTW, the code above is merely for a demonstration. The actual code was more of something like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func parse(JSON: Data) throws -&gt; Any {<br>&gt;&gt;&gt;     // …<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; if let dict = try? parse(JSON: json) as? [String: Any] {<br>&gt;&gt;&gt;     // assume dict is a valid [String: Any] dictionary<br>&gt;&gt;&gt;     // …<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m new to this mailing list so I’m not sure if this belongs here. I’m sorry in advance if it doesn’t.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt; Sam<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160818/fe461f59/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>try? shouldn&#39;t work on non-method-call</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 18, 2016 at 10:00:00am</p></header><div class="content"><p>Lots of interesting points here. I do think there&#39;s an improvement possible<br>here, but it&#39;s actually along the lines of Sam&#39;s original suggestion #3<br>(not vis-a-vis all of Swift, but specifically for how try? composes with<br>as?):<br></p><p>A. I&#39;m in favor of the current behavior where try prefixes an entire<br>statement: it solves the precise issue of multiple nested optionals or<br>multiple unwrapping of optionals in the situation where one statement has<br>calls to many throwing functions. It says instead, I want nil if anything<br>in this statement throws, otherwise, give me .some(value).<br></p><p>Sam--I think you may have misunderstood Charles&#39;s explanation. He&#39;s not<br>saying &quot;try?&quot; attaches with lower or higher precedence as compared to<br>&quot;as?&quot;. Rather, I think the mental model is that &quot;try?&quot; prefixes the whole<br>right-hand side (rhs), and if *any* call on the rhs throws, the whole rhs<br>evaluates to nil, but if *any* call could potentially throw but doesn&#39;t,<br>&quot;try?&quot; wraps the entire rhs and gives you .some(value). IMO, this is pretty<br>sensible for the reason he gives.<br></p><p>B. I&#39;m in favor of warning instead of error, for precisely the internal<br>discussion rationale communicated by Slava. I&#39;m willing to live with &quot;try?<br>42&quot; being only a warning if that means my code won&#39;t stop compiling when<br>someone decides a library function doesn&#39;t need to throw.<br></p><p>Sam--here, changing warning to error would not solve your original problem,<br>because in that example &quot;try?&quot; does prefix at least one throwing function,<br>so you wouldn&#39;t get an error anyway.<br></p><p>C. However, given the thinking in (A), I do think how &quot;try?&quot; composes with<br>&quot;as?&quot; is a little counterintuitive or at least overly ceremonious, though<br>technically it is possible to reason through.<br></p><p>It&#39;s true that currently you can use the multiple nested optionals to<br>figure out whether either a throwing function threw (but not which throwing<br>function out of potentially more than one) or whether the cast did not<br>succeed. But, since &quot;try?&quot; after all means &quot;give me nil if anything<br>throws,&quot; it kind of makes less sense that you get all this nesting and<br>detailed information when it composes with &quot;as?&quot;. If you really wanted that<br>level of detail, you could always evaluate &quot;try?&quot; and &quot;as?&quot; in separate<br>statements. What I&#39;d propose instead is this:<br></p><p>If &quot;try?&quot; is composed with &quot;as?&quot;, and &quot;as?&quot; yields &quot;nil&quot;, then &quot;try?&quot;<br>should not wrap that value in another optional.<br></p><p>Does that sound sensible?<br></p><p><br>On Thu, Aug 18, 2016 at 3:54 AM, Sikhapol Saijit via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Aug 18, 2016, at 3:42 PM, Slava Pestov &lt;spestov at apple.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Aug 18, 2016, at 12:52 AM, David Hart via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Opinions inline:<br>&gt;<br>&gt; On 18 Aug 2016, at 07:43, Sikhapol Saijit via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Hi all,<br>&gt;<br>&gt;<br>&gt; Yesterday I tried this code:<br>&gt;<br>&gt; func couldFailButWillNot() throws -&gt; Any {<br>&gt;     return 42<br>&gt; }<br>&gt;<br>&gt; if let a = try? couldFailButWillNot() as? Int {<br>&gt;     print(a)<br>&gt; }<br>&gt;<br>&gt; And was surprised that the output was *Optional(42)* on both Swift 2 and<br>&gt; Swift 3.<br>&gt; I always have the impression that when a variable is resolved with if let it<br>&gt; will never be optional.<br>&gt;<br>&gt; So, with a little investigation, I found out that it happens because as? has<br>&gt; higher precedence than try? and is evaluated first.<br>&gt; And the whole expression `try? couldFailButWillNot() as? Int` evaluated<br>&gt; as *Optional(Optional(42))*.<br>&gt;<br>&gt; Also, I’m surprised that try? can be used with non-method-call.<br>&gt; This code: `print(try? 42)` will print *Optional(42)*.<br>&gt;<br>&gt; So, the questions are:<br>&gt;<br>&gt; 1. Is it intentional that try? can be used with a &quot;non-method-call&quot; and<br>&gt; return an optional of the type that follows?<br>&gt;<br>&gt;<br>&gt; I think this is the real solution. try and try? should not be allowed on<br>&gt; non-throwing functions or expressions.<br>&gt;<br>&gt;<br>&gt; This is a warning right now — do you think it should be an error?<br>&gt;<br>&gt; Slavas-MacBook-Pro:~ slava$ cat ttt.swift<br>&gt; func f() {}<br>&gt;<br>&gt; func g() {<br>&gt;   try f()<br>&gt;   try? f()<br>&gt; }<br>&gt;<br>&gt; Slavas-MacBook-Pro:~ slava$ swiftc ttt.swift<br>&gt; *ttt.swift:4:3: **warning: **no calls to throwing functions occur within<br>&gt; &#39;try&#39; expression*<br>&gt;   try f()<br>&gt; *  ^*<br>&gt; *ttt.swift:5:8: **warning: **no calls to throwing functions occur within<br>&gt; &#39;try&#39; expression*<br>&gt;   try? f()<br>&gt; *       ^*<br>&gt;<br>&gt;<br>&gt; Thank you Slava,<br>&gt;<br>&gt; While I think using try/try? on anything but a throwing function call<br>&gt; should be an error, right now it even works with anything. `try? 42` will<br>&gt; just wrap 42 in an optional and give some warning now.<br>&gt;<br>&gt;<br>&gt;<br>&gt; 2. Should we design try? to have higher precedence than as? or any<br>&gt; operators at all?<br>&gt; My intuition tells me that<br>&gt; let a = try? couldFailButWillNot() as? Int<br>&gt; should be equivalent to<br>&gt; let a = (try? couldFailButWillNot()) as? Int<br>&gt;<br>&gt;<br>&gt; That’s worth considering. try feels like it should tie very strongly with<br>&gt; the throwing expression.<br>&gt;<br>&gt; 3. Do you think that doubly-nested optional (or multi-level-nested<br>&gt; optional) is confusing and should be removed from Swift? (Yes, I’ve seen<br>&gt; this blog post Optionals Case Study: valuesForKeys<br>&gt; &lt;https://developer.apple.com/swift/blog/?id=12&gt;).<br>&gt; For me *Optional(nil)* (aka *Optional.Some(Optional.None))*) doesn’t make<br>&gt; much sense.<br>&gt; Maybe, one of the solution is to always have optional of optional merged<br>&gt; into a single level optional? Like *Optional(Optional(Optional(42)))* should<br>&gt; be the merged to and evaluated as *Optional(42)*.<br>&gt;<br>&gt;<br>&gt; I don’t think this is the solution. Even if it was, how would you expect<br>&gt; to “remove” them from Swift? Optionals are simply an enum with an<br>&gt; associated value. We’d have to introduce a language feature to restrict<br>&gt; values that can be stored in enum cases? It sounds awfully complicated.<br>&gt;<br>&gt; BTW, the code above is merely for a demonstration. The actual code was<br>&gt; more of something like this:<br>&gt;<br>&gt; func parse(JSON: Data) throws -&gt; Any {<br>&gt;     // …<br>&gt; }<br>&gt;<br>&gt; if let dict = try? parse(JSON: json) as? [String: Any] {<br>&gt;     // assume dict is a valid [String: Any] dictionary<br>&gt;     // …<br>&gt; }<br>&gt;<br>&gt; I’m new to this mailing list so I’m not sure if this belongs here. I’m<br>&gt; sorry in advance if it doesn’t.<br>&gt;<br>&gt;<br>&gt; Thank you,<br>&gt; Sam<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160818/31b58a93/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>try? shouldn&#39;t work on non-method-call</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 18, 2016 at 10:00:00am</p></header><div class="content"><p>On Thu, Aug 18, 2016 at 10:19 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br></p><p>&gt; Lots of interesting points here. I do think there&#39;s an improvement<br>&gt; possible here, but it&#39;s actually along the lines of Sam&#39;s original<br>&gt; suggestion #3 (not vis-a-vis all of Swift, but specifically for how try?<br>&gt; composes with as?):<br>&gt;<br>&gt; A. I&#39;m in favor of the current behavior where try prefixes an entire<br>&gt; statement: it solves the precise issue of multiple nested optionals or<br>&gt; multiple unwrapping of optionals in the situation where one statement has<br>&gt; calls to many throwing functions. It says instead, I want nil if anything<br>&gt; in this statement throws, otherwise, give me .some(value).<br>&gt;<br>&gt; Sam--I think you may have misunderstood Charles&#39;s explanation. He&#39;s not<br>&gt; saying &quot;try?&quot; attaches with lower or higher precedence as compared to<br>&gt; &quot;as?&quot;. Rather, I think the mental model is that &quot;try?&quot; prefixes the whole<br>&gt; right-hand side (rhs), and if *any* call on the rhs throws, the whole rhs<br>&gt; evaluates to nil, but if *any* call<br>&gt;<br></p><p>(Here, I meant to say, if *all* calls that could potentially throw don&#39;t<br>throw...)<br></p><p><br>&gt; could potentially throw but doesn&#39;t, &quot;try?&quot; wraps the entire rhs and gives<br>&gt; you .some(value). IMO, this is pretty sensible for the reason he gives.<br>&gt;<br>&gt; B. I&#39;m in favor of warning instead of error, for precisely the internal<br>&gt; discussion rationale communicated by Slava. I&#39;m willing to live with &quot;try?<br>&gt; 42&quot; being only a warning if that means my code won&#39;t stop compiling when<br>&gt; someone decides a library function doesn&#39;t need to throw.<br>&gt;<br>&gt; Sam--here, changing warning to error would not solve your original<br>&gt; problem, because in that example &quot;try?&quot; does prefix at least one throwing<br>&gt; function, so you wouldn&#39;t get an error anyway.<br>&gt;<br>&gt; C. However, given the thinking in (A), I do think how &quot;try?&quot; composes with<br>&gt; &quot;as?&quot; is a little counterintuitive or at least overly ceremonious, though<br>&gt; technically it is possible to reason through.<br>&gt;<br>&gt; It&#39;s true that currently you can use the multiple nested optionals to<br>&gt; figure out whether either a throwing function threw (but not which throwing<br>&gt; function out of potentially more than one) or whether the cast did not<br>&gt; succeed. But, since &quot;try?&quot; after all means &quot;give me nil if anything<br>&gt; throws,&quot; it kind of makes less sense that you get all this nesting and<br>&gt; detailed information when it composes with &quot;as?&quot;. If you really wanted that<br>&gt; level of detail, you could always evaluate &quot;try?&quot; and &quot;as?&quot; in separate<br>&gt; statements. What I&#39;d propose instead is this:<br>&gt;<br>&gt; If &quot;try?&quot; is composed with &quot;as?&quot;, and &quot;as?&quot; yields &quot;nil&quot;, then &quot;try?&quot;<br>&gt; should not wrap that value in another optional.<br>&gt;<br>&gt; Does that sound sensible?<br>&gt;<br>&gt;<br>&gt; On Thu, Aug 18, 2016 at 3:54 AM, Sikhapol Saijit via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Aug 18, 2016, at 3:42 PM, Slava Pestov &lt;spestov at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Aug 18, 2016, at 12:52 AM, David Hart via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Opinions inline:<br>&gt;&gt;<br>&gt;&gt; On 18 Aug 2016, at 07:43, Sikhapol Saijit via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Hi all,<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Yesterday I tried this code:<br>&gt;&gt;<br>&gt;&gt; func couldFailButWillNot() throws -&gt; Any {<br>&gt;&gt;     return 42<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; if let a = try? couldFailButWillNot() as? Int {<br>&gt;&gt;     print(a)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; And was surprised that the output was *Optional(42)* on both Swift 2 and<br>&gt;&gt; Swift 3.<br>&gt;&gt; I always have the impression that when a variable is resolved with if let<br>&gt;&gt;  it will never be optional.<br>&gt;&gt;<br>&gt;&gt; So, with a little investigation, I found out that it happens because as? has<br>&gt;&gt; higher precedence than try? and is evaluated first.<br>&gt;&gt; And the whole expression `try? couldFailButWillNot() as? Int` evaluated<br>&gt;&gt; as *Optional(Optional(42))*.<br>&gt;&gt;<br>&gt;&gt; Also, I’m surprised that try? can be used with non-method-call.<br>&gt;&gt; This code: `print(try? 42)` will print *Optional(42)*.<br>&gt;&gt;<br>&gt;&gt; So, the questions are:<br>&gt;&gt;<br>&gt;&gt; 1. Is it intentional that try? can be used with a &quot;non-method-call&quot; and<br>&gt;&gt; return an optional of the type that follows?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I think this is the real solution. try and try? should not be allowed on<br>&gt;&gt; non-throwing functions or expressions.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; This is a warning right now — do you think it should be an error?<br>&gt;&gt;<br>&gt;&gt; Slavas-MacBook-Pro:~ slava$ cat ttt.swift<br>&gt;&gt; func f() {}<br>&gt;&gt;<br>&gt;&gt; func g() {<br>&gt;&gt;   try f()<br>&gt;&gt;   try? f()<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Slavas-MacBook-Pro:~ slava$ swiftc ttt.swift<br>&gt;&gt; *ttt.swift:4:3: **warning: **no calls to throwing functions occur within<br>&gt;&gt; &#39;try&#39; expression*<br>&gt;&gt;   try f()<br>&gt;&gt; *  ^*<br>&gt;&gt; *ttt.swift:5:8: **warning: **no calls to throwing functions occur within<br>&gt;&gt; &#39;try&#39; expression*<br>&gt;&gt;   try? f()<br>&gt;&gt; *       ^*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Thank you Slava,<br>&gt;&gt;<br>&gt;&gt; While I think using try/try? on anything but a throwing function call<br>&gt;&gt; should be an error, right now it even works with anything. `try? 42` will<br>&gt;&gt; just wrap 42 in an optional and give some warning now.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; 2. Should we design try? to have higher precedence than as? or any<br>&gt;&gt; operators at all?<br>&gt;&gt; My intuition tells me that<br>&gt;&gt; let a = try? couldFailButWillNot() as? Int<br>&gt;&gt; should be equivalent to<br>&gt;&gt; let a = (try? couldFailButWillNot()) as? Int<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; That’s worth considering. try feels like it should tie very strongly with<br>&gt;&gt; the throwing expression.<br>&gt;&gt;<br>&gt;&gt; 3. Do you think that doubly-nested optional (or multi-level-nested<br>&gt;&gt; optional) is confusing and should be removed from Swift? (Yes, I’ve seen<br>&gt;&gt; this blog post Optionals Case Study: valuesForKeys<br>&gt;&gt; &lt;https://developer.apple.com/swift/blog/?id=12&gt;).<br>&gt;&gt; For me *Optional(nil)* (aka *Optional.Some(Optional.None))*) doesn’t<br>&gt;&gt; make much sense.<br>&gt;&gt; Maybe, one of the solution is to always have optional of optional merged<br>&gt;&gt; into a single level optional? Like *Optional(Optional(Optional(42)))* should<br>&gt;&gt; be the merged to and evaluated as *Optional(42)*.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I don’t think this is the solution. Even if it was, how would you expect<br>&gt;&gt; to “remove” them from Swift? Optionals are simply an enum with an<br>&gt;&gt; associated value. We’d have to introduce a language feature to restrict<br>&gt;&gt; values that can be stored in enum cases? It sounds awfully complicated.<br>&gt;&gt;<br>&gt;&gt; BTW, the code above is merely for a demonstration. The actual code was<br>&gt;&gt; more of something like this:<br>&gt;&gt;<br>&gt;&gt; func parse(JSON: Data) throws -&gt; Any {<br>&gt;&gt;     // …<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; if let dict = try? parse(JSON: json) as? [String: Any] {<br>&gt;&gt;     // assume dict is a valid [String: Any] dictionary<br>&gt;&gt;     // …<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; I’m new to this mailing list so I’m not sure if this belongs here. I’m<br>&gt;&gt; sorry in advance if it doesn’t.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Thank you,<br>&gt;&gt; Sam<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160818/c254d9a7/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>try? shouldn&#39;t work on non-method-call</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>August 18, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Aug 18, 2016, at 8:19 AM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Lots of interesting points here. I do think there&#39;s an improvement possible here, but it&#39;s actually along the lines of Sam&#39;s original suggestion #3 (not vis-a-vis all of Swift, but specifically for how try? composes with as?):<br>&gt; <br>&gt; A. I&#39;m in favor of the current behavior where try prefixes an entire statement: it solves the precise issue of multiple nested optionals or multiple unwrapping of optionals in the situation where one statement has calls to many throwing functions. It says instead, I want nil if anything in this statement throws, otherwise, give me .some(value).<br>&gt; <br>&gt; Sam--I think you may have misunderstood Charles&#39;s explanation. He&#39;s not saying &quot;try?&quot; attaches with lower or higher precedence as compared to &quot;as?&quot;. Rather, I think the mental model is that &quot;try?&quot; prefixes the whole right-hand side (rhs), and if *any* call on the rhs throws, the whole rhs evaluates to nil, but if *any* call could potentially throw but doesn&#39;t, &quot;try?&quot; wraps the entire rhs and gives you .some(value). IMO, this is pretty sensible for the reason he gives.<br>&gt; <br>&gt; B. I&#39;m in favor of warning instead of error, for precisely the internal discussion rationale communicated by Slava. I&#39;m willing to live with &quot;try? 42&quot; being only a warning if that means my code won&#39;t stop compiling when someone decides a library function doesn&#39;t need to throw.<br>&gt; <br>&gt; Sam--here, changing warning to error would not solve your original problem, because in that example &quot;try?&quot; does prefix at least one throwing function, so you wouldn&#39;t get an error anyway.<br>&gt; <br>&gt; C. However, given the thinking in (A), I do think how &quot;try?&quot; composes with &quot;as?&quot; is a little counterintuitive or at least overly ceremonious, though technically it is possible to reason through.<br>&gt; <br>&gt; It&#39;s true that currently you can use the multiple nested optionals to figure out whether either a throwing function threw (but not which throwing function out of potentially more than one) or whether the cast did not succeed. But, since &quot;try?&quot; after all means &quot;give me nil if anything throws,&quot; it kind of makes less sense that you get all this nesting and detailed information when it composes with &quot;as?&quot;. If you really wanted that level of detail, you could always evaluate &quot;try?&quot; and &quot;as?&quot; in separate statements. What I&#39;d propose instead is this:<br>&gt; <br>&gt; If &quot;try?&quot; is composed with &quot;as?&quot;, and &quot;as?&quot; yields &quot;nil&quot;, then &quot;try?&quot; should not wrap that value in another optional.<br></p><p>We can&#39;t make the typing decision dependent on a dynamic property like whether the cast fails.  And I don&#39;t like the idea of changing its typing rule based on the form of the nested expression.  But we could make &quot;try? foo()&quot; avoid adding an extra level of optionality, the same way that &quot;a?.foo()&quot; does.<br></p><p>John.<br></p><p>&gt; <br>&gt; Does that sound sensible?<br>&gt; <br>&gt; <br>&gt; On Thu, Aug 18, 2016 at 3:54 AM, Sikhapol Saijit via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Aug 18, 2016, at 3:42 PM, Slava Pestov &lt;spestov at apple.com &lt;mailto:spestov at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Aug 18, 2016, at 12:52 AM, David Hart via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Opinions inline:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 18 Aug 2016, at 07:43, Sikhapol Saijit via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yesterday I tried this code:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func couldFailButWillNot() throws -&gt; Any {<br>&gt;&gt;&gt;&gt;     return 42<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; if let a = try? couldFailButWillNot() as? Int {<br>&gt;&gt;&gt;&gt;     print(a)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And was surprised that the output was Optional(42) on both Swift 2 and Swift 3.<br>&gt;&gt;&gt;&gt; I always have the impression that when a variable is resolved with if let it will never be optional.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So, with a little investigation, I found out that it happens because as? has higher precedence than try? and is evaluated first.<br>&gt;&gt;&gt;&gt; And the whole expression `try? couldFailButWillNot() as? Int` evaluated as Optional(Optional(42)).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Also, I’m surprised that try? can be used with non-method-call.<br>&gt;&gt;&gt;&gt; This code: `print(try? 42)` will print Optional(42).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So, the questions are:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. Is it intentional that try? can be used with a &quot;non-method-call&quot; and return an optional of the type that follows?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think this is the real solution. try and try? should not be allowed on non-throwing functions or expressions.<br>&gt;&gt; <br>&gt;&gt; This is a warning right now — do you think it should be an error?<br>&gt;&gt; <br>&gt;&gt; Slavas-MacBook-Pro:~ slava$ cat ttt.swift <br>&gt;&gt; func f() {}<br>&gt;&gt; <br>&gt;&gt; func g() {<br>&gt;&gt;   try f()<br>&gt;&gt;   try? f()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Slavas-MacBook-Pro:~ slava$ swiftc ttt.swift <br>&gt;&gt; ttt.swift:4:3: warning: no calls to throwing functions occur within &#39;try&#39; expression<br>&gt;&gt;   try f()<br>&gt;&gt;   ^<br>&gt;&gt; ttt.swift:5:8: warning: no calls to throwing functions occur within &#39;try&#39; expression<br>&gt;&gt;   try? f()<br>&gt;&gt;        ^<br>&gt; <br>&gt; Thank you Slava,<br>&gt; <br>&gt; While I think using try/try? on anything but a throwing function call should be an error, right now it even works with anything. `try? 42` will just wrap 42 in an optional and give some warning now.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2. Should we design try? to have higher precedence than as? or any operators at all?<br>&gt;&gt;&gt;&gt; My intuition tells me that <br>&gt;&gt;&gt;&gt; let a = try? couldFailButWillNot() as? Int<br>&gt;&gt;&gt;&gt; should be equivalent to<br>&gt;&gt;&gt;&gt; let a = (try? couldFailButWillNot()) as? Int <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That’s worth considering. try feels like it should tie very strongly with the throwing expression.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 3. Do you think that doubly-nested optional (or multi-level-nested optional) is confusing and should be removed from Swift? (Yes, I’ve seen this blog post Optionals Case Study: valuesForKeys &lt;https://developer.apple.com/swift/blog/?id=12&gt;).<br>&gt;&gt;&gt;&gt; For me Optional(nil) (aka Optional.Some(Optional.None))) doesn’t make much sense. <br>&gt;&gt;&gt;&gt; Maybe, one of the solution is to always have optional of optional merged into a single level optional? Like Optional(Optional(Optional(42))) should be the merged to and evaluated as Optional(42).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t think this is the solution. Even if it was, how would you expect to “remove” them from Swift? Optionals are simply an enum with an associated value. We’d have to introduce a language feature to restrict values that can be stored in enum cases? It sounds awfully complicated.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; BTW, the code above is merely for a demonstration. The actual code was more of something like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func parse(JSON: Data) throws -&gt; Any {<br>&gt;&gt;&gt;&gt;     // …<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; if let dict = try? parse(JSON: json) as? [String: Any] {<br>&gt;&gt;&gt;&gt;     // assume dict is a valid [String: Any] dictionary<br>&gt;&gt;&gt;&gt;     // …<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m new to this mailing list so I’m not sure if this belongs here. I’m sorry in advance if it doesn’t.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt;&gt; Sam<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160818/0accd520/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>try? shouldn&#39;t work on non-method-call</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 18, 2016 at 03:00:00pm</p></header><div class="content"><p>The issue would be that, in the case of &quot;try? foo()&quot;, nil and .some(nil)<br>might mean very different things.<br>On Thu, Aug 18, 2016 at 10:40 John McCall &lt;rjmccall at apple.com&gt; wrote:<br></p><p>&gt; On Aug 18, 2016, at 8:19 AM, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Lots of interesting points here. I do think there&#39;s an improvement<br>&gt; possible here, but it&#39;s actually along the lines of Sam&#39;s original<br>&gt; suggestion #3 (not vis-a-vis all of Swift, but specifically for how try?<br>&gt; composes with as?):<br>&gt;<br>&gt; A. I&#39;m in favor of the current behavior where try prefixes an entire<br>&gt; statement: it solves the precise issue of multiple nested optionals or<br>&gt; multiple unwrapping of optionals in the situation where one statement has<br>&gt; calls to many throwing functions. It says instead, I want nil if anything<br>&gt; in this statement throws, otherwise, give me .some(value).<br>&gt;<br>&gt; Sam--I think you may have misunderstood Charles&#39;s explanation. He&#39;s not<br>&gt; saying &quot;try?&quot; attaches with lower or higher precedence as compared to<br>&gt; &quot;as?&quot;. Rather, I think the mental model is that &quot;try?&quot; prefixes the whole<br>&gt; right-hand side (rhs), and if *any* call on the rhs throws, the whole rhs<br>&gt; evaluates to nil, but if *any* call could potentially throw but doesn&#39;t,<br>&gt; &quot;try?&quot; wraps the entire rhs and gives you .some(value). IMO, this is pretty<br>&gt; sensible for the reason he gives.<br>&gt;<br>&gt; B. I&#39;m in favor of warning instead of error, for precisely the internal<br>&gt; discussion rationale communicated by Slava. I&#39;m willing to live with &quot;try?<br>&gt; 42&quot; being only a warning if that means my code won&#39;t stop compiling when<br>&gt; someone decides a library function doesn&#39;t need to throw.<br>&gt;<br>&gt; Sam--here, changing warning to error would not solve your original<br>&gt; problem, because in that example &quot;try?&quot; does prefix at least one throwing<br>&gt; function, so you wouldn&#39;t get an error anyway.<br>&gt;<br>&gt; C. However, given the thinking in (A), I do think how &quot;try?&quot; composes with<br>&gt; &quot;as?&quot; is a little counterintuitive or at least overly ceremonious, though<br>&gt; technically it is possible to reason through.<br>&gt;<br>&gt; It&#39;s true that currently you can use the multiple nested optionals to<br>&gt; figure out whether either a throwing function threw (but not which throwing<br>&gt; function out of potentially more than one) or whether the cast did not<br>&gt; succeed. But, since &quot;try?&quot; after all means &quot;give me nil if anything<br>&gt; throws,&quot; it kind of makes less sense that you get all this nesting and<br>&gt; detailed information when it composes with &quot;as?&quot;. If you really wanted that<br>&gt; level of detail, you could always evaluate &quot;try?&quot; and &quot;as?&quot; in separate<br>&gt; statements. What I&#39;d propose instead is this:<br>&gt;<br>&gt; If &quot;try?&quot; is composed with &quot;as?&quot;, and &quot;as?&quot; yields &quot;nil&quot;, then &quot;try?&quot;<br>&gt; should not wrap that value in another optional.<br>&gt;<br>&gt;<br>&gt; We can&#39;t make the typing decision dependent on a dynamic property like<br>&gt; whether the cast fails.  And I don&#39;t like the idea of changing its typing<br>&gt; rule based on the form of the nested expression.  But we could make &quot;try?<br>&gt; foo()&quot; avoid adding an extra level of optionality, the same way that<br>&gt; &quot;a?.foo()&quot; does.<br>&gt;<br>&gt; John.<br>&gt;<br>&gt;<br>&gt; Does that sound sensible?<br>&gt;<br>&gt;<br>&gt; On Thu, Aug 18, 2016 at 3:54 AM, Sikhapol Saijit via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Aug 18, 2016, at 3:42 PM, Slava Pestov &lt;spestov at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Aug 18, 2016, at 12:52 AM, David Hart via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Opinions inline:<br>&gt;&gt;<br>&gt;&gt; On 18 Aug 2016, at 07:43, Sikhapol Saijit via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Hi all,<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Yesterday I tried this code:<br>&gt;&gt;<br>&gt;&gt; func couldFailButWillNot() throws -&gt; Any {<br>&gt;&gt;     return 42<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; if let a = try? couldFailButWillNot() as? Int {<br>&gt;&gt;     print(a)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; And was surprised that the output was *Optional(42)* on both Swift 2 and<br>&gt;&gt; Swift 3.<br>&gt;&gt; I always have the impression that when a variable is resolved with if let<br>&gt;&gt;  it will never be optional.<br>&gt;&gt;<br>&gt;&gt; So, with a little investigation, I found out that it happens because as? has<br>&gt;&gt; higher precedence than try? and is evaluated first.<br>&gt;&gt; And the whole expression `try? couldFailButWillNot() as? Int` evaluated<br>&gt;&gt; as *Optional(Optional(42))*.<br>&gt;&gt;<br>&gt;&gt; Also, I’m surprised that try? can be used with non-method-call.<br>&gt;&gt; This code: `print(try? 42)` will print *Optional(42)*.<br>&gt;&gt;<br>&gt;&gt; So, the questions are:<br>&gt;&gt;<br>&gt;&gt; 1. Is it intentional that try? can be used with a &quot;non-method-call&quot; and<br>&gt;&gt; return an optional of the type that follows?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I think this is the real solution. try and try? should not be allowed on<br>&gt;&gt; non-throwing functions or expressions.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; This is a warning right now — do you think it should be an error?<br>&gt;&gt;<br>&gt;&gt; Slavas-MacBook-Pro:~ slava$ cat ttt.swift<br>&gt;&gt; func f() {}<br>&gt;&gt;<br>&gt;&gt; func g() {<br>&gt;&gt;   try f()<br>&gt;&gt;   try? f()<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Slavas-MacBook-Pro:~ slava$ swiftc ttt.swift<br>&gt;&gt; *ttt.swift:4:3: **warning: **no calls to throwing functions occur within<br>&gt;&gt; &#39;try&#39; expression*<br>&gt;&gt;   try f()<br>&gt;&gt; *  ^*<br>&gt;&gt; *ttt.swift:5:8: **warning: **no calls to throwing functions occur within<br>&gt;&gt; &#39;try&#39; expression*<br>&gt;&gt;   try? f()<br>&gt;&gt; *       ^*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Thank you Slava,<br>&gt;&gt;<br>&gt;&gt; While I think using try/try? on anything but a throwing function call<br>&gt;&gt; should be an error, right now it even works with anything. `try? 42` will<br>&gt;&gt; just wrap 42 in an optional and give some warning now.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; 2. Should we design try? to have higher precedence than as? or any<br>&gt;&gt; operators at all?<br>&gt;&gt; My intuition tells me that<br>&gt;&gt; let a = try? couldFailButWillNot() as? Int<br>&gt;&gt; should be equivalent to<br>&gt;&gt; let a = (try? couldFailButWillNot()) as? Int<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; That’s worth considering. try feels like it should tie very strongly with<br>&gt;&gt; the throwing expression.<br>&gt;&gt;<br>&gt;&gt; 3. Do you think that doubly-nested optional (or multi-level-nested<br>&gt;&gt; optional) is confusing and should be removed from Swift? (Yes, I’ve seen<br>&gt;&gt; this blog post Optionals Case Study: valuesForKeys<br>&gt;&gt; &lt;https://developer.apple.com/swift/blog/?id=12&gt;).<br>&gt;&gt; For me *Optional(nil)* (aka *Optional.Some(Optional.None))*) doesn’t<br>&gt;&gt; make much sense.<br>&gt;&gt; Maybe, one of the solution is to always have optional of optional merged<br>&gt;&gt; into a single level optional? Like *Optional(Optional(Optional(42)))* should<br>&gt;&gt; be the merged to and evaluated as *Optional(42)*.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I don’t think this is the solution. Even if it was, how would you expect<br>&gt;&gt; to “remove” them from Swift? Optionals are simply an enum with an<br>&gt;&gt; associated value. We’d have to introduce a language feature to restrict<br>&gt;&gt; values that can be stored in enum cases? It sounds awfully complicated.<br>&gt;&gt;<br>&gt;&gt; BTW, the code above is merely for a demonstration. The actual code was<br>&gt;&gt; more of something like this:<br>&gt;&gt;<br>&gt;&gt; func parse(JSON: Data) throws -&gt; Any {<br>&gt;&gt;     // …<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; if let dict = try? parse(JSON: json) as? [String: Any] {<br>&gt;&gt;     // assume dict is a valid [String: Any] dictionary<br>&gt;&gt;     // …<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; I’m new to this mailing list so I’m not sure if this belongs here. I’m<br>&gt;&gt; sorry in advance if it doesn’t.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Thank you,<br>&gt;&gt; Sam<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160818/456d062b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>try? shouldn&#39;t work on non-method-call</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>August 18, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Aug 18, 2016, at 8:46 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; The issue would be that, in the case of &quot;try? foo()&quot;, nil and .some(nil) might mean very different things.<br></p><p>This is true of a?.foo() as well.  But yes, I think it is more likely that someone would want to treat them differently for try?.<br></p><p>John.<br></p><p>&gt; On Thu, Aug 18, 2016 at 10:40 John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt; On Aug 18, 2016, at 8:19 AM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Lots of interesting points here. I do think there&#39;s an improvement possible here, but it&#39;s actually along the lines of Sam&#39;s original suggestion #3 (not vis-a-vis all of Swift, but specifically for how try? composes with as?):<br>&gt;&gt; <br>&gt;&gt; A. I&#39;m in favor of the current behavior where try prefixes an entire statement: it solves the precise issue of multiple nested optionals or multiple unwrapping of optionals in the situation where one statement has calls to many throwing functions. It says instead, I want nil if anything in this statement throws, otherwise, give me .some(value).<br>&gt;&gt; <br>&gt;&gt; Sam--I think you may have misunderstood Charles&#39;s explanation. He&#39;s not saying &quot;try?&quot; attaches with lower or higher precedence as compared to &quot;as?&quot;. Rather, I think the mental model is that &quot;try?&quot; prefixes the whole right-hand side (rhs), and if *any* call on the rhs throws, the whole rhs evaluates to nil, but if *any* call could potentially throw but doesn&#39;t, &quot;try?&quot; wraps the entire rhs and gives you .some(value). IMO, this is pretty sensible for the reason he gives.<br>&gt;&gt; <br>&gt;&gt; B. I&#39;m in favor of warning instead of error, for precisely the internal discussion rationale communicated by Slava. I&#39;m willing to live with &quot;try? 42&quot; being only a warning if that means my code won&#39;t stop compiling when someone decides a library function doesn&#39;t need to throw.<br>&gt;&gt; <br>&gt;&gt; Sam--here, changing warning to error would not solve your original problem, because in that example &quot;try?&quot; does prefix at least one throwing function, so you wouldn&#39;t get an error anyway.<br>&gt;&gt; <br>&gt;&gt; C. However, given the thinking in (A), I do think how &quot;try?&quot; composes with &quot;as?&quot; is a little counterintuitive or at least overly ceremonious, though technically it is possible to reason through.<br>&gt;&gt; <br>&gt;&gt; It&#39;s true that currently you can use the multiple nested optionals to figure out whether either a throwing function threw (but not which throwing function out of potentially more than one) or whether the cast did not succeed. But, since &quot;try?&quot; after all means &quot;give me nil if anything throws,&quot; it kind of makes less sense that you get all this nesting and detailed information when it composes with &quot;as?&quot;. If you really wanted that level of detail, you could always evaluate &quot;try?&quot; and &quot;as?&quot; in separate statements. What I&#39;d propose instead is this:<br>&gt;&gt; <br>&gt;&gt; If &quot;try?&quot; is composed with &quot;as?&quot;, and &quot;as?&quot; yields &quot;nil&quot;, then &quot;try?&quot; should not wrap that value in another optional.<br>&gt; <br>&gt; We can&#39;t make the typing decision dependent on a dynamic property like whether the cast fails.  And I don&#39;t like the idea of changing its typing rule based on the form of the nested expression.  But we could make &quot;try? foo()&quot; avoid adding an extra level of optionality, the same way that &quot;a?.foo()&quot; does.<br>&gt; <br>&gt; John.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Does that sound sensible?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Thu, Aug 18, 2016 at 3:54 AM, Sikhapol Saijit via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Aug 18, 2016, at 3:42 PM, Slava Pestov &lt;spestov at apple.com &lt;mailto:spestov at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Aug 18, 2016, at 12:52 AM, David Hart via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Opinions inline:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 18 Aug 2016, at 07:43, Sikhapol Saijit via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yesterday I tried this code:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func couldFailButWillNot() throws -&gt; Any {<br>&gt;&gt;&gt;&gt;&gt;     return 42<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; if let a = try? couldFailButWillNot() as? Int {<br>&gt;&gt;&gt;&gt;&gt;     print(a)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; And was surprised that the output was Optional(42) on both Swift 2 and Swift 3.<br>&gt;&gt;&gt;&gt;&gt; I always have the impression that when a variable is resolved with if let it will never be optional.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; So, with a little investigation, I found out that it happens because as? has higher precedence than try? and is evaluated first.<br>&gt;&gt;&gt;&gt;&gt; And the whole expression `try? couldFailButWillNot() as? Int` evaluated as Optional(Optional(42)).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Also, I’m surprised that try? can be used with non-method-call.<br>&gt;&gt;&gt;&gt;&gt; This code: `print(try? 42)` will print Optional(42).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; So, the questions are:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1. Is it intentional that try? can be used with a &quot;non-method-call&quot; and return an optional of the type that follows?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think this is the real solution. try and try? should not be allowed on non-throwing functions or expressions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a warning right now — do you think it should be an error?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Slavas-MacBook-Pro:~ slava$ cat ttt.swift <br>&gt;&gt;&gt; func f() {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func g() {<br>&gt;&gt;&gt;   try f()<br>&gt;&gt;&gt;   try? f()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Slavas-MacBook-Pro:~ slava$ swiftc ttt.swift <br>&gt;&gt;&gt; ttt.swift:4:3: warning: no calls to throwing functions occur within &#39;try&#39; expression<br>&gt;&gt;&gt;   try f()<br>&gt;&gt;&gt;   ^<br>&gt;&gt;&gt; ttt.swift:5:8: warning: no calls to throwing functions occur within &#39;try&#39; expression<br>&gt;&gt;&gt;   try? f()<br>&gt;&gt;&gt;        ^<br>&gt;&gt; <br>&gt;&gt; Thank you Slava,<br>&gt;&gt; <br>&gt;&gt; While I think using try/try? on anything but a throwing function call should be an error, right now it even works with anything. `try? 42` will just wrap 42 in an optional and give some warning now.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2. Should we design try? to have higher precedence than as? or any operators at all?<br>&gt;&gt;&gt;&gt;&gt; My intuition tells me that <br>&gt;&gt;&gt;&gt;&gt; let a = try? couldFailButWillNot() as? Int<br>&gt;&gt;&gt;&gt;&gt; should be equivalent to<br>&gt;&gt;&gt;&gt;&gt; let a = (try? couldFailButWillNot()) as? Int <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That’s worth considering. try feels like it should tie very strongly with the throwing expression.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 3. Do you think that doubly-nested optional (or multi-level-nested optional) is confusing and should be removed from Swift? (Yes, I’ve seen this blog post Optionals Case Study: valuesForKeys &lt;https://developer.apple.com/swift/blog/?id=12&gt;).<br>&gt;&gt;&gt;&gt;&gt; For me Optional(nil) (aka Optional.Some(Optional.None))) doesn’t make much sense. <br>&gt;&gt;&gt;&gt;&gt; Maybe, one of the solution is to always have optional of optional merged into a single level optional? Like Optional(Optional(Optional(42))) should be the merged to and evaluated as Optional(42).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don’t think this is the solution. Even if it was, how would you expect to “remove” them from Swift? Optionals are simply an enum with an associated value. We’d have to introduce a language feature to restrict values that can be stored in enum cases? It sounds awfully complicated.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; BTW, the code above is merely for a demonstration. The actual code was more of something like this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func parse(JSON: Data) throws -&gt; Any {<br>&gt;&gt;&gt;&gt;&gt;     // …<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; if let dict = try? parse(JSON: json) as? [String: Any] {<br>&gt;&gt;&gt;&gt;&gt;     // assume dict is a valid [String: Any] dictionary<br>&gt;&gt;&gt;&gt;&gt;     // …<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’m new to this mailing list so I’m not sure if this belongs here. I’m sorry in advance if it doesn’t.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt;&gt;&gt; Sam<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160818/519955c5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>try? shouldn&#39;t work on non-method-call</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 18, 2016 at 05:00:00pm</p></header><div class="content"><p>On Thu, Aug 18, 2016 at 11:30 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br></p><p>&gt; On Aug 18, 2016, at 8:46 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; The issue would be that, in the case of &quot;try? foo()&quot;, nil and .some(nil)<br>&gt; might mean very different things.<br>&gt;<br>&gt;<br>&gt; This is true of a?.foo() as well.  But yes, I think it is more likely that<br>&gt; someone would want to treat them differently for try?.<br>&gt;<br></p><p>Agreed.<br></p><p>My proposed solution was half-baked, but it may be workable--I&#39;m not<br>suggesting typing decisions based on a dynamic property, of course. It&#39;d be<br>something like this:<br></p><p>`as?` would produce a result of a type named something like<br>CastingOptional&lt;T&gt;, which on assignment or essentially any other operation<br>is promoted/bridged/[insert much more correct term here] to an Optional&lt;T&gt;<br>like how T is automatically promoted to Optional&lt;T&gt;. However, `try?` will<br>not wrap a CastingOptional&lt;T&gt; into an Optional&lt;Optional&lt;T&gt;&gt;.<br></p><p><br>&gt; John.<br>&gt;<br>&gt; On Thu, Aug 18, 2016 at 10:40 John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt; On Aug 18, 2016, at 8:19 AM, Xiaodi Wu via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Lots of interesting points here. I do think there&#39;s an improvement<br>&gt;&gt; possible here, but it&#39;s actually along the lines of Sam&#39;s original<br>&gt;&gt; suggestion #3 (not vis-a-vis all of Swift, but specifically for how try?<br>&gt;&gt; composes with as?):<br>&gt;&gt;<br>&gt;&gt; A. I&#39;m in favor of the current behavior where try prefixes an entire<br>&gt;&gt; statement: it solves the precise issue of multiple nested optionals or<br>&gt;&gt; multiple unwrapping of optionals in the situation where one statement has<br>&gt;&gt; calls to many throwing functions. It says instead, I want nil if anything<br>&gt;&gt; in this statement throws, otherwise, give me .some(value).<br>&gt;&gt;<br>&gt;&gt; Sam--I think you may have misunderstood Charles&#39;s explanation. He&#39;s not<br>&gt;&gt; saying &quot;try?&quot; attaches with lower or higher precedence as compared to<br>&gt;&gt; &quot;as?&quot;. Rather, I think the mental model is that &quot;try?&quot; prefixes the whole<br>&gt;&gt; right-hand side (rhs), and if *any* call on the rhs throws, the whole rhs<br>&gt;&gt; evaluates to nil, but if *any* call could potentially throw but doesn&#39;t,<br>&gt;&gt; &quot;try?&quot; wraps the entire rhs and gives you .some(value). IMO, this is pretty<br>&gt;&gt; sensible for the reason he gives.<br>&gt;&gt;<br>&gt;&gt; B. I&#39;m in favor of warning instead of error, for precisely the internal<br>&gt;&gt; discussion rationale communicated by Slava. I&#39;m willing to live with &quot;try?<br>&gt;&gt; 42&quot; being only a warning if that means my code won&#39;t stop compiling when<br>&gt;&gt; someone decides a library function doesn&#39;t need to throw.<br>&gt;&gt;<br>&gt;&gt; Sam--here, changing warning to error would not solve your original<br>&gt;&gt; problem, because in that example &quot;try?&quot; does prefix at least one throwing<br>&gt;&gt; function, so you wouldn&#39;t get an error anyway.<br>&gt;&gt;<br>&gt;&gt; C. However, given the thinking in (A), I do think how &quot;try?&quot; composes<br>&gt;&gt; with &quot;as?&quot; is a little counterintuitive or at least overly ceremonious,<br>&gt;&gt; though technically it is possible to reason through.<br>&gt;&gt;<br>&gt;&gt; It&#39;s true that currently you can use the multiple nested optionals to<br>&gt;&gt; figure out whether either a throwing function threw (but not which throwing<br>&gt;&gt; function out of potentially more than one) or whether the cast did not<br>&gt;&gt; succeed. But, since &quot;try?&quot; after all means &quot;give me nil if anything<br>&gt;&gt; throws,&quot; it kind of makes less sense that you get all this nesting and<br>&gt;&gt; detailed information when it composes with &quot;as?&quot;. If you really wanted that<br>&gt;&gt; level of detail, you could always evaluate &quot;try?&quot; and &quot;as?&quot; in separate<br>&gt;&gt; statements. What I&#39;d propose instead is this:<br>&gt;&gt;<br>&gt;&gt; If &quot;try?&quot; is composed with &quot;as?&quot;, and &quot;as?&quot; yields &quot;nil&quot;, then &quot;try?&quot;<br>&gt;&gt; should not wrap that value in another optional.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; We can&#39;t make the typing decision dependent on a dynamic property like<br>&gt;&gt; whether the cast fails.  And I don&#39;t like the idea of changing its typing<br>&gt;&gt; rule based on the form of the nested expression.  But we could make &quot;try?<br>&gt;&gt; foo()&quot; avoid adding an extra level of optionality, the same way that<br>&gt;&gt; &quot;a?.foo()&quot; does.<br>&gt;&gt;<br>&gt;&gt; John.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Does that sound sensible?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Thu, Aug 18, 2016 at 3:54 AM, Sikhapol Saijit via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Aug 18, 2016, at 3:42 PM, Slava Pestov &lt;spestov at apple.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Aug 18, 2016, at 12:52 AM, David Hart via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Opinions inline:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 18 Aug 2016, at 07:43, Sikhapol Saijit via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Yesterday I tried this code:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func couldFailButWillNot() throws -&gt; Any {<br>&gt;&gt;&gt;     return 42<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; if let a = try? couldFailButWillNot() as? Int {<br>&gt;&gt;&gt;     print(a)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; And was surprised that the output was *Optional(42)* on both Swift 2<br>&gt;&gt;&gt; and Swift 3.<br>&gt;&gt;&gt; I always have the impression that when a variable is resolved with if<br>&gt;&gt;&gt; let it will never be optional.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; So, with a little investigation, I found out that it happens because as? has<br>&gt;&gt;&gt; higher precedence than try? and is evaluated first.<br>&gt;&gt;&gt; And the whole expression `try? couldFailButWillNot() as? Int` evaluated<br>&gt;&gt;&gt; as *Optional(Optional(42))*.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Also, I’m surprised that try? can be used with non-method-call.<br>&gt;&gt;&gt; This code: `print(try? 42)` will print *Optional(42)*.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; So, the questions are:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 1. Is it intentional that try? can be used with a &quot;non-method-call&quot; and<br>&gt;&gt;&gt; return an optional of the type that follows?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I think this is the real solution. try and try? should not be allowed on<br>&gt;&gt;&gt; non-throwing functions or expressions.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This is a warning right now — do you think it should be an error?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Slavas-MacBook-Pro:~ slava$ cat ttt.swift<br>&gt;&gt;&gt; func f() {}<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func g() {<br>&gt;&gt;&gt;   try f()<br>&gt;&gt;&gt;   try? f()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Slavas-MacBook-Pro:~ slava$ swiftc ttt.swift<br>&gt;&gt;&gt; *ttt.swift:4:3: **warning: **no calls to throwing functions occur<br>&gt;&gt;&gt; within &#39;try&#39; expression*<br>&gt;&gt;&gt;   try f()<br>&gt;&gt;&gt; *  ^*<br>&gt;&gt;&gt; *ttt.swift:5:8: **warning: **no calls to throwing functions occur<br>&gt;&gt;&gt; within &#39;try&#39; expression*<br>&gt;&gt;&gt;   try? f()<br>&gt;&gt;&gt; *       ^*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Thank you Slava,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; While I think using try/try? on anything but a throwing function call<br>&gt;&gt;&gt; should be an error, right now it even works with anything. `try? 42` will<br>&gt;&gt;&gt; just wrap 42 in an optional and give some warning now.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 2. Should we design try? to have higher precedence than as? or any<br>&gt;&gt;&gt; operators at all?<br>&gt;&gt;&gt; My intuition tells me that<br>&gt;&gt;&gt; let a = try? couldFailButWillNot() as? Int<br>&gt;&gt;&gt; should be equivalent to<br>&gt;&gt;&gt; let a = (try? couldFailButWillNot()) as? Int<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; That’s worth considering. try feels like it should tie very strongly<br>&gt;&gt;&gt; with the throwing expression.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 3. Do you think that doubly-nested optional (or multi-level-nested<br>&gt;&gt;&gt; optional) is confusing and should be removed from Swift? (Yes, I’ve seen<br>&gt;&gt;&gt; this blog post Optionals Case Study: valuesForKeys<br>&gt;&gt;&gt; &lt;https://developer.apple.com/swift/blog/?id=12&gt;).<br>&gt;&gt;&gt; For me *Optional(nil)* (aka *Optional.Some(Optional.None))*) doesn’t<br>&gt;&gt;&gt; make much sense.<br>&gt;&gt;&gt; Maybe, one of the solution is to always have optional of optional merged<br>&gt;&gt;&gt; into a single level optional? Like *Optional(Optional(Optional(42)))* should<br>&gt;&gt;&gt; be the merged to and evaluated as *Optional(42)*.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I don’t think this is the solution. Even if it was, how would you expect<br>&gt;&gt;&gt; to “remove” them from Swift? Optionals are simply an enum with an<br>&gt;&gt;&gt; associated value. We’d have to introduce a language feature to restrict<br>&gt;&gt;&gt; values that can be stored in enum cases? It sounds awfully complicated.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; BTW, the code above is merely for a demonstration. The actual code was<br>&gt;&gt;&gt; more of something like this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func parse(JSON: Data) throws -&gt; Any {<br>&gt;&gt;&gt;     // …<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; if let dict = try? parse(JSON: json) as? [String: Any] {<br>&gt;&gt;&gt;     // assume dict is a valid [String: Any] dictionary<br>&gt;&gt;&gt;     // …<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I’m new to this mailing list so I’m not sure if this belongs here. I’m<br>&gt;&gt;&gt; sorry in advance if it doesn’t.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt; Sam<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160818/25f1462a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>try? shouldn&#39;t work on non-method-call</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>August 18, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Aug 18, 2016, at 10:11 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; On Thu, Aug 18, 2016 at 11:30 AM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt; On Aug 18, 2016, at 8:46 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; The issue would be that, in the case of &quot;try? foo()&quot;, nil and .some(nil) might mean very different things.<br>&gt; <br>&gt; This is true of a?.foo() as well.  But yes, I think it is more likely that someone would want to treat them differently for try?.<br>&gt; <br>&gt; Agreed.<br>&gt; <br>&gt; My proposed solution was half-baked, but it may be workable--I&#39;m not suggesting typing decisions based on a dynamic property, of course. It&#39;d be something like this:<br>&gt; <br>&gt; `as?` would produce a result of a type named something like CastingOptional&lt;T&gt;, which on assignment or essentially any other operation is promoted/bridged/[insert much more correct term here] to an Optional&lt;T&gt; like how T is automatically promoted to Optional&lt;T&gt;. However, `try?` will not wrap a CastingOptional&lt;T&gt; into an Optional&lt;Optional&lt;T&gt;&gt;.<br></p><p>The way this is done for ?-chaining is that the result of the chain is coerced to T?, for a fresh unbound type T.  If the result is already of type U?, T will be bound to U and there&#39;s no &quot;stacking&quot; of optionals; if the result is a non-optional type V, T will be bound to V and therefore the chain gains a level of optionality.  I think that is simpler and more consistent than inventing a new flavor of Optional with complex conversion and defaulting rules.<br></p><p>John.<br></p><p>&gt;  <br>&gt; John.<br>&gt; <br>&gt;&gt; On Thu, Aug 18, 2016 at 10:40 John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; On Aug 18, 2016, at 8:19 AM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Lots of interesting points here. I do think there&#39;s an improvement possible here, but it&#39;s actually along the lines of Sam&#39;s original suggestion #3 (not vis-a-vis all of Swift, but specifically for how try? composes with as?):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A. I&#39;m in favor of the current behavior where try prefixes an entire statement: it solves the precise issue of multiple nested optionals or multiple unwrapping of optionals in the situation where one statement has calls to many throwing functions. It says instead, I want nil if anything in this statement throws, otherwise, give me .some(value).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sam--I think you may have misunderstood Charles&#39;s explanation. He&#39;s not saying &quot;try?&quot; attaches with lower or higher precedence as compared to &quot;as?&quot;. Rather, I think the mental model is that &quot;try?&quot; prefixes the whole right-hand side (rhs), and if *any* call on the rhs throws, the whole rhs evaluates to nil, but if *any* call could potentially throw but doesn&#39;t, &quot;try?&quot; wraps the entire rhs and gives you .some(value). IMO, this is pretty sensible for the reason he gives.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; B. I&#39;m in favor of warning instead of error, for precisely the internal discussion rationale communicated by Slava. I&#39;m willing to live with &quot;try? 42&quot; being only a warning if that means my code won&#39;t stop compiling when someone decides a library function doesn&#39;t need to throw.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sam--here, changing warning to error would not solve your original problem, because in that example &quot;try?&quot; does prefix at least one throwing function, so you wouldn&#39;t get an error anyway.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; C. However, given the thinking in (A), I do think how &quot;try?&quot; composes with &quot;as?&quot; is a little counterintuitive or at least overly ceremonious, though technically it is possible to reason through.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s true that currently you can use the multiple nested optionals to figure out whether either a throwing function threw (but not which throwing function out of potentially more than one) or whether the cast did not succeed. But, since &quot;try?&quot; after all means &quot;give me nil if anything throws,&quot; it kind of makes less sense that you get all this nesting and detailed information when it composes with &quot;as?&quot;. If you really wanted that level of detail, you could always evaluate &quot;try?&quot; and &quot;as?&quot; in separate statements. What I&#39;d propose instead is this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If &quot;try?&quot; is composed with &quot;as?&quot;, and &quot;as?&quot; yields &quot;nil&quot;, then &quot;try?&quot; should not wrap that value in another optional.<br>&gt;&gt; <br>&gt;&gt; We can&#39;t make the typing decision dependent on a dynamic property like whether the cast fails.  And I don&#39;t like the idea of changing its typing rule based on the form of the nested expression.  But we could make &quot;try? foo()&quot; avoid adding an extra level of optionality, the same way that &quot;a?.foo()&quot; does.<br>&gt;&gt; <br>&gt;&gt; John.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Does that sound sensible?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Thu, Aug 18, 2016 at 3:54 AM, Sikhapol Saijit via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Aug 18, 2016, at 3:42 PM, Slava Pestov &lt;spestov at apple.com &lt;mailto:spestov at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Aug 18, 2016, at 12:52 AM, David Hart via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Opinions inline:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 18 Aug 2016, at 07:43, Sikhapol Saijit via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Yesterday I tried this code:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func couldFailButWillNot() throws -&gt; Any {<br>&gt;&gt;&gt;&gt;&gt;&gt;     return 42<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; if let a = try? couldFailButWillNot() as? Int {<br>&gt;&gt;&gt;&gt;&gt;&gt;     print(a)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; And was surprised that the output was Optional(42) on both Swift 2 and Swift 3.<br>&gt;&gt;&gt;&gt;&gt;&gt; I always have the impression that when a variable is resolved with if let it will never be optional.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; So, with a little investigation, I found out that it happens because as? has higher precedence than try? and is evaluated first.<br>&gt;&gt;&gt;&gt;&gt;&gt; And the whole expression `try? couldFailButWillNot() as? Int` evaluated as Optional(Optional(42)).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Also, I’m surprised that try? can be used with non-method-call.<br>&gt;&gt;&gt;&gt;&gt;&gt; This code: `print(try? 42)` will print Optional(42).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; So, the questions are:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 1. Is it intentional that try? can be used with a &quot;non-method-call&quot; and return an optional of the type that follows?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think this is the real solution. try and try? should not be allowed on non-throwing functions or expressions.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is a warning right now — do you think it should be an error?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Slavas-MacBook-Pro:~ slava$ cat ttt.swift <br>&gt;&gt;&gt;&gt; func f() {}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func g() {<br>&gt;&gt;&gt;&gt;   try f()<br>&gt;&gt;&gt;&gt;   try? f()<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Slavas-MacBook-Pro:~ slava$ swiftc ttt.swift <br>&gt;&gt;&gt;&gt; ttt.swift:4:3: warning: no calls to throwing functions occur within &#39;try&#39; expression<br>&gt;&gt;&gt;&gt;   try f()<br>&gt;&gt;&gt;&gt;   ^<br>&gt;&gt;&gt;&gt; ttt.swift:5:8: warning: no calls to throwing functions occur within &#39;try&#39; expression<br>&gt;&gt;&gt;&gt;   try? f()<br>&gt;&gt;&gt;&gt;        ^<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thank you Slava,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; While I think using try/try? on anything but a throwing function call should be an error, right now it even works with anything. `try? 42` will just wrap 42 in an optional and give some warning now.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 2. Should we design try? to have higher precedence than as? or any operators at all?<br>&gt;&gt;&gt;&gt;&gt;&gt; My intuition tells me that <br>&gt;&gt;&gt;&gt;&gt;&gt; let a = try? couldFailButWillNot() as? Int<br>&gt;&gt;&gt;&gt;&gt;&gt; should be equivalent to<br>&gt;&gt;&gt;&gt;&gt;&gt; let a = (try? couldFailButWillNot()) as? Int <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That’s worth considering. try feels like it should tie very strongly with the throwing expression.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 3. Do you think that doubly-nested optional (or multi-level-nested optional) is confusing and should be removed from Swift? (Yes, I’ve seen this blog post Optionals Case Study: valuesForKeys &lt;https://developer.apple.com/swift/blog/?id=12&gt;).<br>&gt;&gt;&gt;&gt;&gt;&gt; For me Optional(nil) (aka Optional.Some(Optional.None))) doesn’t make much sense. <br>&gt;&gt;&gt;&gt;&gt;&gt; Maybe, one of the solution is to always have optional of optional merged into a single level optional? Like Optional(Optional(Optional(42))) should be the merged to and evaluated as Optional(42).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I don’t think this is the solution. Even if it was, how would you expect to “remove” them from Swift? Optionals are simply an enum with an associated value. We’d have to introduce a language feature to restrict values that can be stored in enum cases? It sounds awfully complicated.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; BTW, the code above is merely for a demonstration. The actual code was more of something like this:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func parse(JSON: Data) throws -&gt; Any {<br>&gt;&gt;&gt;&gt;&gt;&gt;     // …<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; if let dict = try? parse(JSON: json) as? [String: Any] {<br>&gt;&gt;&gt;&gt;&gt;&gt;     // assume dict is a valid [String: Any] dictionary<br>&gt;&gt;&gt;&gt;&gt;&gt;     // …<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I’m new to this mailing list so I’m not sure if this belongs here. I’m sorry in advance if it doesn’t.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt;&gt;&gt;&gt; Sam<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160818/988de6ae/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>try? shouldn&#39;t work on non-method-call</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 18, 2016 at 02:00:00pm</p></header><div class="content"><p>On Thu, Aug 18, 2016 at 1:20 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br></p><p>&gt; On Aug 18, 2016, at 10:11 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; On Thu, Aug 18, 2016 at 11:30 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt; On Aug 18, 2016, at 8:46 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt; The issue would be that, in the case of &quot;try? foo()&quot;, nil and .some(nil)<br>&gt;&gt; might mean very different things.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; This is true of a?.foo() as well.  But yes, I think it is more likely<br>&gt;&gt; that someone would want to treat them differently for try?.<br>&gt;&gt;<br>&gt;<br>&gt; Agreed.<br>&gt;<br>&gt; My proposed solution was half-baked, but it may be workable--I&#39;m not<br>&gt; suggesting typing decisions based on a dynamic property, of course. It&#39;d be<br>&gt; something like this:<br>&gt;<br>&gt; `as?` would produce a result of a type named something like<br>&gt; CastingOptional&lt;T&gt;, which on assignment or essentially any other operation<br>&gt; is promoted/bridged/[insert much more correct term here] to an Optional&lt;T&gt;<br>&gt; like how T is automatically promoted to Optional&lt;T&gt;. However, `try?` will<br>&gt; not wrap a CastingOptional&lt;T&gt; into an Optional&lt;Optional&lt;T&gt;&gt;.<br>&gt;<br>&gt;<br>&gt; The way this is done for ?-chaining is that the result of the chain is<br>&gt; coerced to T?, for a fresh unbound type T.  If the result is already of<br>&gt; type U?, T will be bound to U and there&#39;s no &quot;stacking&quot; of optionals; if<br>&gt; the result is a non-optional type V, T will be bound to V and therefore the<br>&gt; chain gains a level of optionality.  I think that is simpler and more<br>&gt; consistent than inventing a new flavor of Optional with complex conversion<br>&gt; and defaulting rules.<br>&gt;<br></p><p>Yeah, that&#39;s definitely much simpler.<br></p><p>I&#39;m just not sure I&#39;d be comfortable with `try?` refusing to stack<br>optionals for all arbitrary functions `(...) -&gt; Optional&lt;T&gt;` just like it<br>works for ?-chaining, for the reasons we just discussed. So, if we&#39;re to<br>stick to consistent rules, I&#39;d rather that `try?` continue to stack<br>optionals all the time.<br></p><p>The status quo isn&#39;t unteachable: if you have try? and as?, that&#39;s two<br>question marks, so you get back two stacked optionals. That&#39;s livable.<br></p><p><br>&gt; John.<br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt; John.<br>&gt;&gt;<br>&gt;&gt; On Thu, Aug 18, 2016 at 10:40 John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; On Aug 18, 2016, at 8:19 AM, Xiaodi Wu via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Lots of interesting points here. I do think there&#39;s an improvement<br>&gt;&gt;&gt; possible here, but it&#39;s actually along the lines of Sam&#39;s original<br>&gt;&gt;&gt; suggestion #3 (not vis-a-vis all of Swift, but specifically for how try?<br>&gt;&gt;&gt; composes with as?):<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; A. I&#39;m in favor of the current behavior where try prefixes an entire<br>&gt;&gt;&gt; statement: it solves the precise issue of multiple nested optionals or<br>&gt;&gt;&gt; multiple unwrapping of optionals in the situation where one statement has<br>&gt;&gt;&gt; calls to many throwing functions. It says instead, I want nil if anything<br>&gt;&gt;&gt; in this statement throws, otherwise, give me .some(value).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Sam--I think you may have misunderstood Charles&#39;s explanation. He&#39;s not<br>&gt;&gt;&gt; saying &quot;try?&quot; attaches with lower or higher precedence as compared to<br>&gt;&gt;&gt; &quot;as?&quot;. Rather, I think the mental model is that &quot;try?&quot; prefixes the whole<br>&gt;&gt;&gt; right-hand side (rhs), and if *any* call on the rhs throws, the whole rhs<br>&gt;&gt;&gt; evaluates to nil, but if *any* call could potentially throw but doesn&#39;t,<br>&gt;&gt;&gt; &quot;try?&quot; wraps the entire rhs and gives you .some(value). IMO, this is pretty<br>&gt;&gt;&gt; sensible for the reason he gives.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; B. I&#39;m in favor of warning instead of error, for precisely the internal<br>&gt;&gt;&gt; discussion rationale communicated by Slava. I&#39;m willing to live with &quot;try?<br>&gt;&gt;&gt; 42&quot; being only a warning if that means my code won&#39;t stop compiling when<br>&gt;&gt;&gt; someone decides a library function doesn&#39;t need to throw.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Sam--here, changing warning to error would not solve your original<br>&gt;&gt;&gt; problem, because in that example &quot;try?&quot; does prefix at least one throwing<br>&gt;&gt;&gt; function, so you wouldn&#39;t get an error anyway.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; C. However, given the thinking in (A), I do think how &quot;try?&quot; composes<br>&gt;&gt;&gt; with &quot;as?&quot; is a little counterintuitive or at least overly ceremonious,<br>&gt;&gt;&gt; though technically it is possible to reason through.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It&#39;s true that currently you can use the multiple nested optionals to<br>&gt;&gt;&gt; figure out whether either a throwing function threw (but not which throwing<br>&gt;&gt;&gt; function out of potentially more than one) or whether the cast did not<br>&gt;&gt;&gt; succeed. But, since &quot;try?&quot; after all means &quot;give me nil if anything<br>&gt;&gt;&gt; throws,&quot; it kind of makes less sense that you get all this nesting and<br>&gt;&gt;&gt; detailed information when it composes with &quot;as?&quot;. If you really wanted that<br>&gt;&gt;&gt; level of detail, you could always evaluate &quot;try?&quot; and &quot;as?&quot; in separate<br>&gt;&gt;&gt; statements. What I&#39;d propose instead is this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If &quot;try?&quot; is composed with &quot;as?&quot;, and &quot;as?&quot; yields &quot;nil&quot;, then &quot;try?&quot;<br>&gt;&gt;&gt; should not wrap that value in another optional.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; We can&#39;t make the typing decision dependent on a dynamic property like<br>&gt;&gt;&gt; whether the cast fails.  And I don&#39;t like the idea of changing its typing<br>&gt;&gt;&gt; rule based on the form of the nested expression.  But we could make &quot;try?<br>&gt;&gt;&gt; foo()&quot; avoid adding an extra level of optionality, the same way that<br>&gt;&gt;&gt; &quot;a?.foo()&quot; does.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; John.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Does that sound sensible?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Thu, Aug 18, 2016 at 3:54 AM, Sikhapol Saijit via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Aug 18, 2016, at 3:42 PM, Slava Pestov &lt;spestov at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Aug 18, 2016, at 12:52 AM, David Hart via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Opinions inline:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On 18 Aug 2016, at 07:43, Sikhapol Saijit via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Yesterday I tried this code:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; func couldFailButWillNot() throws -&gt; Any {<br>&gt;&gt;&gt;&gt;     return 42<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; if let a = try? couldFailButWillNot() as? Int {<br>&gt;&gt;&gt;&gt;     print(a)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; And was surprised that the output was *Optional(42)* on both Swift 2<br>&gt;&gt;&gt;&gt; and Swift 3.<br>&gt;&gt;&gt;&gt; I always have the impression that when a variable is resolved with if<br>&gt;&gt;&gt;&gt; let it will never be optional.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; So, with a little investigation, I found out that it happens because as<br>&gt;&gt;&gt;&gt; ? has higher precedence than try? and is evaluated first.<br>&gt;&gt;&gt;&gt; And the whole expression `try? couldFailButWillNot() as? Int` evaluated<br>&gt;&gt;&gt;&gt; as *Optional(Optional(42))*.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Also, I’m surprised that try? can be used with non-method-call.<br>&gt;&gt;&gt;&gt; This code: `print(try? 42)` will print *Optional(42)*.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; So, the questions are:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; 1. Is it intentional that try? can be used with a &quot;non-method-call&quot;<br>&gt;&gt;&gt;&gt; and return an optional of the type that follows?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I think this is the real solution. try and try? should not be allowed<br>&gt;&gt;&gt;&gt; on non-throwing functions or expressions.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This is a warning right now — do you think it should be an error?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Slavas-MacBook-Pro:~ slava$ cat ttt.swift<br>&gt;&gt;&gt;&gt; func f() {}<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; func g() {<br>&gt;&gt;&gt;&gt;   try f()<br>&gt;&gt;&gt;&gt;   try? f()<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Slavas-MacBook-Pro:~ slava$ swiftc ttt.swift<br>&gt;&gt;&gt;&gt; *ttt.swift:4:3: **warning: **no calls to throwing functions occur<br>&gt;&gt;&gt;&gt; within &#39;try&#39; expression*<br>&gt;&gt;&gt;&gt;   try f()<br>&gt;&gt;&gt;&gt; *  ^*<br>&gt;&gt;&gt;&gt; *ttt.swift:5:8: **warning: **no calls to throwing functions occur<br>&gt;&gt;&gt;&gt; within &#39;try&#39; expression*<br>&gt;&gt;&gt;&gt;   try? f()<br>&gt;&gt;&gt;&gt; *       ^*<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Thank you Slava,<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; While I think using try/try? on anything but a throwing function call<br>&gt;&gt;&gt;&gt; should be an error, right now it even works with anything. `try? 42` will<br>&gt;&gt;&gt;&gt; just wrap 42 in an optional and give some warning now.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; 2. Should we design try? to have higher precedence than as? or any<br>&gt;&gt;&gt;&gt; operators at all?<br>&gt;&gt;&gt;&gt; My intuition tells me that<br>&gt;&gt;&gt;&gt; let a = try? couldFailButWillNot() as? Int<br>&gt;&gt;&gt;&gt; should be equivalent to<br>&gt;&gt;&gt;&gt; let a = (try? couldFailButWillNot()) as? Int<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; That’s worth considering. try feels like it should tie very strongly<br>&gt;&gt;&gt;&gt; with the throwing expression.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; 3. Do you think that doubly-nested optional (or multi-level-nested<br>&gt;&gt;&gt;&gt; optional) is confusing and should be removed from Swift? (Yes, I’ve seen<br>&gt;&gt;&gt;&gt; this blog post Optionals Case Study: valuesForKeys<br>&gt;&gt;&gt;&gt; &lt;https://developer.apple.com/swift/blog/?id=12&gt;).<br>&gt;&gt;&gt;&gt; For me *Optional(nil)* (aka *Optional.Some(Optional.None))*) doesn’t<br>&gt;&gt;&gt;&gt; make much sense.<br>&gt;&gt;&gt;&gt; Maybe, one of the solution is to always have optional of optional<br>&gt;&gt;&gt;&gt; merged into a single level optional? Like<br>&gt;&gt;&gt;&gt; *Optional(Optional(Optional(42)))* should be the merged to and<br>&gt;&gt;&gt;&gt; evaluated as *Optional(42)*.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I don’t think this is the solution. Even if it was, how would you<br>&gt;&gt;&gt;&gt; expect to “remove” them from Swift? Optionals are simply an enum with an<br>&gt;&gt;&gt;&gt; associated value. We’d have to introduce a language feature to restrict<br>&gt;&gt;&gt;&gt; values that can be stored in enum cases? It sounds awfully complicated.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; BTW, the code above is merely for a demonstration. The actual code was<br>&gt;&gt;&gt;&gt; more of something like this:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; func parse(JSON: Data) throws -&gt; Any {<br>&gt;&gt;&gt;&gt;     // …<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; if let dict = try? parse(JSON: json) as? [String: Any] {<br>&gt;&gt;&gt;&gt;     // assume dict is a valid [String: Any] dictionary<br>&gt;&gt;&gt;&gt;     // …<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I’m new to this mailing list so I’m not sure if this belongs here. I’m<br>&gt;&gt;&gt;&gt; sorry in advance if it doesn’t.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt;&gt; Sam<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160818/37642e31/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>try? shouldn&#39;t work on non-method-call</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>August 18, 2016 at 03:00:00am</p></header><div class="content"><p>&gt; On Aug 18, 2016, at 12:43 AM, Sikhapol Saijit via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; 1. Is it intentional that try? can be used with a &quot;non-method-call&quot; and return an optional of the type that follows?<br></p><p>a. I’m not sure what you mean by “non-method-call”, since the thing you called in your example *was* a function that was marked with “throws”. Using try? on a non-throwing function or method does indeed produce a warning.<br></p><p>b. I’m not a member of the development team, but I think it probably is intentional. There are two levels of optionality going on here; <br></p><p>&gt; 2. Should we design try? to have higher precedence than as? or any operators at all?<br>&gt; My intuition tells me that <br>&gt; let a = try? couldFailButWillNot() as? Int<br>&gt; should be equivalent to<br>&gt; let a = (try? couldFailButWillNot()) as? Int <br></p><p>This is more debatable whether it *should* be the case, but it’s worth pointing out that try/try?/try! work on the entire rest of the line, which means you can include more throwing calls and not have to put an ! each time:<br></p><p>func foo() throws -&gt; Int { return 3 }<br></p><p>func bar() throws -&gt; Int { return 5 }<br></p><p>if let i = try? foo() + bar() { // not try foo() + try bar()<br>    print(&quot;i is \(i)&quot;)<br>}<br></p><p>Or this:<br></p><p>func foo() throws -&gt; Int { return 3 }<br></p><p>func bar(_ i: Int) throws -&gt; Int { return i + 2 }<br></p><p>if let i = try? bar(foo()) { // not bar(try foo())<br>    print(&quot;i is \(i)&quot;)<br>}<br></p><p>So multiple throwing statements can be used on a single line without having to throw “try” all over the place. Now, whether that’s worth the admittedly confusing behavior you noted above is probably a decent topic for debate.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160818/1b66bd8e/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>try? shouldn&#39;t work on non-method-call</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>August 18, 2016 at 03:00:00am</p></header><div class="content"><p>Sorry for the resend! Some of my previous e-mail was left out for some reason. Here it is again, as it should have been:<br></p><p>&gt; On Aug 18, 2016, at 12:43 AM, Sikhapol Saijit via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; 1. Is it intentional that try? can be used with a &quot;non-method-call&quot; and return an optional of the type that follows?<br></p><p>a. I’m not sure what you mean by “non-method-call”, since the thing you called in your example *was* a function that was marked with “throws”. Using try? on a non-throwing function or method does indeed produce a warning.<br></p><p>b. I’m not an Apple employee or a member of the development team, but I think it probably is intentional. There are two levels of optionality going on here; one, the possibility that the throwing method could have failed, and the other, that the optional result may or may not contain a value. Either of those two things being nil could mean quite different things, so the double-optional makes sense.<br></p><p>&gt; 2. Should we design try? to have higher precedence than as? or any operators at all?<br>&gt; My intuition tells me that <br>&gt; let a = try? couldFailButWillNot() as? Int<br>&gt; should be equivalent to<br>&gt; let a = (try? couldFailButWillNot()) as? Int <br></p><p>This is more debatable whether it *should* be the case, but it’s worth pointing out that try/try?/try! work on the entire rest of the line, which means you can include more throwing calls and not have to put an ! each time:<br></p><p>func foo() throws -&gt; Int { return 3 }<br></p><p>func bar() throws -&gt; Int { return 5 }<br></p><p>if let i = try? foo() + bar() { // not try foo() + try bar()<br>    print(&quot;i is \(i)&quot;)<br>}<br></p><p>Or this:<br></p><p>func foo() throws -&gt; Int { return 3 }<br></p><p>func bar(_ i: Int) throws -&gt; Int { return i + 2 }<br></p><p>if let i = try? bar(foo()) { // not bar(try foo())<br>    print(&quot;i is \(i)&quot;)<br>}<br></p><p>So multiple throwing statements can be used on a single line without having to throw “try” all over the place. Now, whether that’s worth the admittedly confusing behavior you noted above is probably a decent topic for debate.<br></p><p>Charles<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160818/7d66f52d/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/58198fee5117e461741cf98ff9a8a9e6?s=50"></div><header><strong>try? shouldn&#39;t work on non-method-call</strong> from <string>Sikhapol Saijit</string> &lt;sikhapol at gmail.com&gt;<p>August 18, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Aug 18, 2016, at 3:15 PM, Charles Srstka &lt;cocoadev at charlessoft.com&gt; wrote:<br>&gt; <br>&gt; Sorry for the resend! Some of my previous e-mail was left out for some reason. Here it is again, as it should have been:<br>&gt; <br>&gt;&gt; On Aug 18, 2016, at 12:43 AM, Sikhapol Saijit via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; 1. Is it intentional that try? can be used with a &quot;non-method-call&quot; and return an optional of the type that follows?<br>&gt; <br>&gt; a. I’m not sure what you mean by “non-method-call”, since the thing you called in your example *was* a function that was marked with “throws”. Using try? on a non-throwing function or method does indeed produce a warning.<br></p><p>In my sample code It did look like that try? was tied to the throwing function call but it actually operate on the result of the following as? operator.<br></p><p>So<br>if let a = try? couldFailButWillNot() as? Int { … }<br>was actually work like this:<br>if let a = try? (couldFailButWillNot() as? Int /* evaluated to Optional(42)) */) { … }<br></p><p>Try typing `print(try? 42)` in the playground and you will understand what I mean.<br></p><p>&gt; <br>&gt; b. I’m not an Apple employee or a member of the development team, but I think it probably is intentional. There are two levels of optionality going on here; one, the possibility that the throwing method could have failed, and the other, that the optional result may or may not contain a value. Either of those two things being nil could mean quite different things, so the double-optional makes sense.<br>&gt; <br>&gt;&gt; 2. Should we design try? to have higher precedence than as? or any operators at all?<br>&gt;&gt; My intuition tells me that <br>&gt;&gt; let a = try? couldFailButWillNot() as? Int<br>&gt;&gt; should be equivalent to<br>&gt;&gt; let a = (try? couldFailButWillNot()) as? Int <br>&gt; <br>&gt; This is more debatable whether it *should* be the case, but it’s worth pointing out that try/try?/try! work on the entire rest of the line, which means you can include more throwing calls and not have to put an ! each time:<br>&gt; <br>&gt; func foo() throws -&gt; Int { return 3 }<br>&gt; <br>&gt; func bar() throws -&gt; Int { return 5 }<br>&gt; <br>&gt; if let i = try? foo() + bar() { // not try foo() + try bar()<br>&gt;     print(&quot;i is \(i)&quot;)<br>&gt; }<br>&gt; <br>&gt; Or this:<br>&gt; <br>&gt; func foo() throws -&gt; Int { return 3 }<br>&gt; <br>&gt; func bar(_ i: Int) throws -&gt; Int { return i + 2 }<br>&gt; <br>&gt; if let i = try? bar(foo()) { // not bar(try foo())<br>&gt;     print(&quot;i is \(i)&quot;)<br>&gt; }<br>&gt; <br>&gt; So multiple throwing statements can be used on a single line without having to throw “try” all over the place. Now, whether that’s worth the admittedly confusing behavior you noted above is probably a decent topic for debate.<br>&gt; <br>&gt; Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160818/613b29da/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
