<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cf2e4441943974c6550424bb9fa45d6b?s=50"></div><header><strong>Rethink about the SequenceType, GeneratorType and CollectionType</strong> from <string>Susan Cheng</string> &lt;susan.doggie at gmail.com&gt;<p>January 11, 2016 at 06:00:00pm</p></header><div class="content"><p>Jordan Rose has a thought in PermutationGenerator thread that about any<br>GeneratorType &quot;is-a&quot; SequenceType. (I missed the thread)<br>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/005525.html<br></p><p>So i get a graph with:<br></p><p>SequenceType -----------------------------------&gt; CollectionType<br>        ∟ generate() ----&gt; GeneratorType<br></p><p>if this correct, we will redefine the GeneratorType as SequenceType<br></p><p>/// Encapsulates iteration state and interface for iteration over a<br></p><p>/// *sequence*.<br></p><p>///<br></p><p>/// - Note: While it is safe to copy a *generator*, advancing one<br></p><p>///   copy may invalidate the others.<br></p><p>///<br></p><p>/// Any code that uses multiple generators (or `for`...`in` loops)<br></p><p>/// over a single *sequence* should have static knowledge that the<br></p><p>/// specific *sequence* is multi-pass, either because its concrete<br></p><p>/// type is known or because it is constrained to `CollectionType`.<br></p><p>/// Also, the generators must be obtained by distinct calls to the<br></p><p>/// *sequence&#39;s* `generate()` method, rather than by copying.<br></p><p>public protocol GeneratorType : SequenceType {<br></p><p>    /// The type of element generated by `self`.<br></p><p>    typealias Element<br></p><p>    /// Advance to the next element and return it, or `nil` if no next<br></p><p>    /// element exists.<br></p><p>    ///<br></p><p>    /// - Requires: `next()` has not been applied to a copy of `self`<br></p><p>    ///   since the copy was made, and no preceding call to `self.next()`<br></p><p>    ///   has returned `nil`.  Specific implementations of this protocol<br></p><p>    ///   are encouraged to respond to violations of this requirement by<br></p><p>    ///   calling `preconditionFailure(&quot;...&quot;)`.<br></p><p>    @warn_unused_result<br></p><p>    public mutating func next() -&gt; Self.Element?<br></p><p>}<br></p><p><br>extension GeneratorType {<br></p><p><br></p><p>    public func generate() -&gt; Self {<br></p><p>        return self<br></p><p>    }<br></p><p>}<br></p><p><br>and discard this(break circularity between SequenceType and GeneratorType):<br></p><p><br>extension SequenceType where Self.Generator == Self, Self : GeneratorType {<br></p><p>    public func generate() -&gt; Self<br></p><p>}<br></p><p><br>also, adding the follows to stdlib:<br></p><p><br>public extension SequenceType where Self : Indexable {<br></p><p><br></p><p>    var startIndex: MultipassIndex&lt;Generator&gt; {<br></p><p>        var g = self.enumerate().generate()<br></p><p>        if let (idx, val) = g.next() {<br></p><p>            return MultipassIndex(reachEnd: false, index: idx, buffer: val,<br>generator: g)<br></p><p>        }<br></p><p>        return MultipassIndex(reachEnd: true, index: nil, buffer: nil,<br>generator: g)<br></p><p>    }<br></p><p><br></p><p>    var endIndex: MultipassIndex&lt;Generator&gt; {<br></p><p>        return MultipassIndex(reachEnd: true, index: nil, buffer: nil,<br>generator: self.enumerate().generate())<br></p><p>    }<br></p><p><br></p><p>    subscript(position: MultipassIndex&lt;Generator&gt;) -&gt; Generator.Element {<br></p><p>        return position.buffer!<br></p><p>    }<br></p><p>}<br></p><p><br>// Note: Requires G has value semantics<br></p><p>public struct MultipassIndex&lt;G: GeneratorType&gt; : ForwardIndexType {<br></p><p>    public func successor() -&gt; MultipassIndex {<br></p><p>        var r = self<br></p><p>        if !reachEnd, let (idx, val) = r.generator.next() {<br></p><p>            r.index = idx<br></p><p>            r.buffer = val<br></p><p>        } else {<br></p><p>            r.reachEnd = true<br></p><p>            r.index = nil<br></p><p>            r.buffer = nil<br></p><p>        }<br></p><p>        return r<br></p><p>    }<br></p><p>    var reachEnd: Bool<br></p><p>    var index: Int?<br></p><p>    var buffer: G.Element?<br></p><p>    var generator: EnumerateGenerator&lt;G&gt;<br></p><p>}<br></p><p><br>public func == &lt;T&gt;(x: MultipassIndex&lt;T&gt;, y: MultipassIndex&lt;T&gt;) -&gt; Bool {<br></p><p>    return x.index == y.index<br></p><p>}<br></p><p><br>That means we can defined a collection as follows and implement Indexable<br>automatically:<br></p><p><br>struct Fib : CollectionType {<br></p><p><br></p><p>    typealias Generator = FibGenerator<br></p><p><br></p><p>    var a, b: Int<br></p><p><br></p><p>    func generate() -&gt; FibGenerator {<br></p><p>        return FibGenerator(a: a, b: b)<br></p><p>    }<br></p><p>}<br></p><p><br>struct FibGenerator : GeneratorType {<br></p><p><br></p><p>    var a, b: Int<br></p><p><br></p><p>    mutating func next() -&gt; Int? {<br></p><p>        let temp = a<br></p><p>        (a, b) = (b, a + b)<br></p><p>        return temp<br></p><p>    }<br></p><p>}<br></p><p><br>in this case, because of GeneratorType is clearly a destructive iteration<br>type and CollectionType is clearly a multi-pass indexed type<br></p><p>we should stop using the SequenceType (or just rename it to _SequenceType<br>and tell people don&#39;t use it directly) directly. we have the GeneratorType<br>which confirms SequenceType already. it can reduce<br>confusion of SequenceType.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/63d3505a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cf2e4441943974c6550424bb9fa45d6b?s=50"></div><header><strong>Rethink about the SequenceType, GeneratorType and CollectionType</strong> from <string>Susan Cheng</string> &lt;susan.doggie at gmail.com&gt;<p>January 11, 2016 at 06:00:00pm</p></header><div class="content"><p>i find that IndexingGenerator is also causing circularity<br></p><p>2016-01-11 18:14 GMT+08:00 Susan Cheng &lt;susan.doggie at gmail.com&gt;:<br></p><p>&gt; Jordan Rose has a thought in PermutationGenerator thread that about any<br>&gt; GeneratorType &quot;is-a&quot; SequenceType. (I missed the thread)<br>&gt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/005525.html<br>&gt;<br>&gt; So i get a graph with:<br>&gt;<br>&gt; SequenceType -----------------------------------&gt; CollectionType<br>&gt;         ∟ generate() ----&gt; GeneratorType<br>&gt;<br>&gt; if this correct, we will redefine the GeneratorType as SequenceType<br>&gt;<br>&gt; /// Encapsulates iteration state and interface for iteration over a<br>&gt;<br>&gt; /// *sequence*.<br>&gt;<br>&gt; ///<br>&gt;<br>&gt; /// - Note: While it is safe to copy a *generator*, advancing one<br>&gt;<br>&gt; ///   copy may invalidate the others.<br>&gt;<br>&gt; ///<br>&gt;<br>&gt; /// Any code that uses multiple generators (or `for`...`in` loops)<br>&gt;<br>&gt; /// over a single *sequence* should have static knowledge that the<br>&gt;<br>&gt; /// specific *sequence* is multi-pass, either because its concrete<br>&gt;<br>&gt; /// type is known or because it is constrained to `CollectionType`.<br>&gt;<br>&gt; /// Also, the generators must be obtained by distinct calls to the<br>&gt;<br>&gt; /// *sequence&#39;s* `generate()` method, rather than by copying.<br>&gt;<br>&gt; public protocol GeneratorType : SequenceType {<br>&gt;<br>&gt;     /// The type of element generated by `self`.<br>&gt;<br>&gt;     typealias Element<br>&gt;<br>&gt;     /// Advance to the next element and return it, or `nil` if no next<br>&gt;<br>&gt;     /// element exists.<br>&gt;<br>&gt;     ///<br>&gt;<br>&gt;     /// - Requires: `next()` has not been applied to a copy of `self`<br>&gt;<br>&gt;     ///   since the copy was made, and no preceding call to `self.next()`<br>&gt;<br>&gt;     ///   has returned `nil`.  Specific implementations of this protocol<br>&gt;<br>&gt;     ///   are encouraged to respond to violations of this requirement by<br>&gt;<br>&gt;     ///   calling `preconditionFailure(&quot;...&quot;)`.<br>&gt;<br>&gt;     @warn_unused_result<br>&gt;<br>&gt;     public mutating func next() -&gt; Self.Element?<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; extension GeneratorType {<br>&gt;<br>&gt;<br>&gt;<br>&gt;     public func generate() -&gt; Self {<br>&gt;<br>&gt;         return self<br>&gt;<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; and discard this(break circularity between SequenceType and GeneratorType<br>&gt; ):<br>&gt;<br>&gt;<br>&gt; extension SequenceType where Self.Generator == Self, Self : GeneratorType<br>&gt; {<br>&gt;<br>&gt;     public func generate() -&gt; Self<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; also, adding the follows to stdlib:<br>&gt;<br>&gt;<br>&gt; public extension SequenceType where Self : Indexable {<br>&gt;<br>&gt;<br>&gt;<br>&gt;     var startIndex: MultipassIndex&lt;Generator&gt; {<br>&gt;<br>&gt;         var g = self.enumerate().generate()<br>&gt;<br>&gt;         if let (idx, val) = g.next() {<br>&gt;<br>&gt;             return MultipassIndex(reachEnd: false, index: idx, buffer:<br>&gt; val, generator: g)<br>&gt;<br>&gt;         }<br>&gt;<br>&gt;         return MultipassIndex(reachEnd: true, index: nil, buffer: nil,<br>&gt; generator: g)<br>&gt;<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;<br>&gt;     var endIndex: MultipassIndex&lt;Generator&gt; {<br>&gt;<br>&gt;         return MultipassIndex(reachEnd: true, index: nil, buffer: nil,<br>&gt; generator: self.enumerate().generate())<br>&gt;<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;<br>&gt;     subscript(position: MultipassIndex&lt;Generator&gt;) -&gt; Generator.Element {<br>&gt;<br>&gt;         return position.buffer!<br>&gt;<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; // Note: Requires G has value semantics<br>&gt;<br>&gt; public struct MultipassIndex&lt;G: GeneratorType&gt; : ForwardIndexType {<br>&gt;<br>&gt;     public func successor() -&gt; MultipassIndex {<br>&gt;<br>&gt;         var r = self<br>&gt;<br>&gt;         if !reachEnd, let (idx, val) = r.generator.next() {<br>&gt;<br>&gt;             r.index = idx<br>&gt;<br>&gt;             r.buffer = val<br>&gt;<br>&gt;         } else {<br>&gt;<br>&gt;             r.reachEnd = true<br>&gt;<br>&gt;             r.index = nil<br>&gt;<br>&gt;             r.buffer = nil<br>&gt;<br>&gt;         }<br>&gt;<br>&gt;         return r<br>&gt;<br>&gt;     }<br>&gt;<br>&gt;     var reachEnd: Bool<br>&gt;<br>&gt;     var index: Int?<br>&gt;<br>&gt;     var buffer: G.Element?<br>&gt;<br>&gt;     var generator: EnumerateGenerator&lt;G&gt;<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; public func == &lt;T&gt;(x: MultipassIndex&lt;T&gt;, y: MultipassIndex&lt;T&gt;) -&gt; Bool {<br>&gt;<br>&gt;     return x.index == y.index<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; That means we can defined a collection as follows and implement Indexable<br>&gt; automatically:<br>&gt;<br>&gt;<br>&gt; struct Fib : CollectionType {<br>&gt;<br>&gt;<br>&gt;<br>&gt;     typealias Generator = FibGenerator<br>&gt;<br>&gt;<br>&gt;<br>&gt;     var a, b: Int<br>&gt;<br>&gt;<br>&gt;<br>&gt;     func generate() -&gt; FibGenerator {<br>&gt;<br>&gt;         return FibGenerator(a: a, b: b)<br>&gt;<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; struct FibGenerator : GeneratorType {<br>&gt;<br>&gt;<br>&gt;<br>&gt;     var a, b: Int<br>&gt;<br>&gt;<br>&gt;<br>&gt;     mutating func next() -&gt; Int? {<br>&gt;<br>&gt;         let temp = a<br>&gt;<br>&gt;         (a, b) = (b, a + b)<br>&gt;<br>&gt;         return temp<br>&gt;<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; in this case, because of GeneratorType is clearly a destructive iteration<br>&gt; type and CollectionType is clearly a multi-pass indexed type<br>&gt;<br>&gt; we should stop using the SequenceType (or just rename it to _SequenceType<br>&gt; and tell people don&#39;t use it directly) directly. we have the GeneratorType<br>&gt; which confirms SequenceType already. it can reduce<br>&gt; confusion of SequenceType.<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/7cf58274/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
