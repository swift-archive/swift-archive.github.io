<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Review] SE-0062: Referencing Objective-C key-paths</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>April  7, 2016 at 09:00:00am</p></header><div class="content"><p>Hello Swift community,<br></p><p>The review of SE-0062 “Referencing Objective-C key-paths&quot; begins now and runs through April 12, 2016. The proposal is available here:<br></p><p>https://github.com/apple/swift-evolution/blob/master/proposals/0062-objc-keypaths.md<br>Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br></p><p>https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br></p><p>Proposal link:<br></p><p>https://github.com/apple/swift-evolution/blob/master/proposals/0062-objc-keypaths.md<br>Reply text<br></p><p>Other replies<br> &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What goes into a review?<br></p><p>The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br></p><p>What is your evaluation of the proposal?<br>Is the problem being addressed significant enough to warrant a change to Swift?<br>Does this proposal fit well with the feel and direction of Swift?<br>If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>More information about the Swift evolution process is available at<br></p><p>https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>Thank you,<br></p><p>-Doug Gregor<br></p><p>Review Manager<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution-announce/attachments/20160407/80341aaf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review] SE-0062: Referencing Objective-C key-paths</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April  7, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0062-objc-keypaths.md<br></p><p>&gt; 	• What is your evaluation of the proposal?<br></p><p>I&#39;m definitely in favor and look forward to using #keyPath. I have one note, one suggestion and one concern, but even without any of them being addressed, I would want to see this proposal become part of Swift.<br></p><p>* * *<br></p><p>The note: The Collection crossing might apply only to types which offer `Index -&gt; Element` and `Range&lt;Index&gt; -&gt; SubSequence` subscripts, but no others. That would include Array and Set but exclude Dictionary.<br></p><p>On the other hand, NSDictionary *does* have KVC behavior: the particular key is unconstrained and it always results in an instance of the dictionary&#39;s ObjectType. #keyPath could usefully support that in some way.<br></p><p>* * *<br></p><p>The suggestion: Many key paths are immediately passed to methods on the object they will eventually act on. For example:<br></p><p>	chris.value(forKeyPath: #keyPath(Person.friends.firstName))<br></p><p>It would be nice if we could use leading dot to refer to the type of the object the key path is being passed to:<br></p><p>	chris.value(forKeyPath: #keyPath(.friends.firstName))<br></p><p>Leading dot does not have any other useful meaning in this context; it would always refer to a static variable on String, which is not a sensible key path to try to construct.<br></p><p>* * *<br></p><p>The concern: I&#39;m a little worried that the &quot;value expression&quot; feature can be ambiguous when accessing properties of `self`. Consider these expressions (as they might appear in the `Person.find(name:)` example):<br></p><p>	#keyPath(firstName.uppercased)	=&gt; &quot;firstName.uppercased&quot;<br>	#keyPath(name.uppercased)		=&gt; &quot;uppercased&quot;<br></p><p>Although they look quite similar, they end up giving very different behaviors because `firstName` is a property while `name` is a variable. I think this could be misleading—particularly because it&#39;ll be tempting to say things like this:<br></p><p>	firstName.value(forKeyPath: #keyPath(firstName.uppercased))	// oops, that&#39;s getting `self.firstName.firstName.uppercased`!<br></p><p>I see two simple but inconsistent alternatives here, and one which is more complex but also more consistent:<br></p><p>1. Require `self` for a property&#39;s key path. This makes it clear that you&#39;re going to get &quot;firstName.uppercased&quot;, but it&#39;s a little inconvenient in the plain `firstName` case, which isn&#39;t ambiguous.<br></p><p>2. Require `self` for a property&#39;s key path only when there are additional parts to the key path. In other words, you can say `#keyPath(firstName)`, but firstName.uppercased&#39;s keypath has to be written `#keyPath(self.firstName.uppercased)`. This removes the inconvenience of #1, but it&#39;s a complicated rule to explain.<br></p><p>3. Change the syntax entirely so that the thing you&#39;re looking for the key path of goes before the #keyPath keyword. This would make it crystal clear which part is the key path and which part merely specifies the type the key path will be used on; it would also allow you to use a more complicated expression to provide the type. Examples:<br></p><p>	Person.#keyPath(firstName.uppercased)<br>	self.#keyPath(firstName.uppercased)<br>	#keyPath(firstName.uppercased)	// Implicit `self`<br>	<br>	// Here&#39;s an example of a complicated path to the object you want to work from<br>	textView.layoutManager.typesetter.#keyPath(usesFontLeading)<br>	<br>	// The leading dot feature I asked for would look like:<br>	chris.value(forKeyPath: .#keyPath(friends.firstName))<br></p><p>This looks weird when you&#39;re not used to it, but it&#39;s not really that strange an idea conceptually; if #foo() is a compile-time function, this is a compile-time method.<br></p><p>* * *<br></p><p>Despite these concerns, I really like this proposal a lot, and I hope to see it be accepted.<br></p><p>&gt; 	• Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes. Simply put, stringly-typed code is a menace, but often a necessary one. Anything that makes it safer is a winner in my book.<br></p><p>&gt; 	• Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes. It&#39;s particularly reminiscent of #selector, but it actually goes further by providing a feature people had to hack into Objective-C with horrible macros.<br></p><p>&gt; 	• If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>That&#39;s...actually kind of an interesting question. But my thoughts on that matter are not on topic for this review, so for now I&#39;ll say no, I don&#39;t have any relevant experience.<br></p><p>(Well, I have seen various horrible macros which offer some semblance of typo safety for KVC. But these are best not spoken of.)<br></p><p>&gt; 	• How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I read the proposal and participated in the discussion.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Review] SE-0062: Referencing Objective-C key-paths</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>April  8, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; What is your evaluation of the proposal?<br>I like it and think it’s something Swift should definitely have.<br></p><p>A quibble: I think there’d be value in also having:<br></p><p>   #key(ClassName.propertyName)<br></p><p>…which is the same as `#keyPath`, but without support for *paths*.<br></p><p>It’s functionally-redundant with the more-general #keyPath but makes intent clearer, and is IMHO both shorter and clearer at any call-site that require keys, not key-paths.<br></p><p>&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>Yes for the same reasons #selector was added.<br></p><p>&gt; Does this proposal fit well with the feel and direction of Swift?<br>Yes.<br></p><p>&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>Quick read, didn’t follow the lead-up discussion.<br></p><p>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt; Thank you,<br>&gt; <br>&gt; -Doug Gregor<br>&gt; <br>&gt; Review Manager<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160408/0edd538a/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/47e3aeeaf151d4f51ee15fc7871bf584?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0062: Referencing Objective-C key-paths</strong> from <string>Rudolf Adamkovič</string> &lt;salutis at me.com&gt;<p>April 10, 2016 at 07:00:00pm</p></header><div class="content"><p>A very big +1 from me!<br></p><p>This proposal will have a significant impact on majority of Cocoa developers. To mention one thing, all Core Data stuff (predicates, search descriptors) will become much safer. I&#39;m strongly in favor. Let&#39;s do this!<br></p><p>Sent from my iPhone<br></p><p>&gt; On 07 Apr 2016, at 18:48, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of SE-0062 “Referencing Objective-C key-paths&quot; begins now and runs through April 12, 2016. The proposal is available here:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0062-objc-keypaths.md<br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br>&gt; <br>&gt; Proposal link:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0062-objc-keypaths.md<br>&gt; Reply text<br>&gt; <br>&gt; Other replies<br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; What is your evaluation of the proposal?<br>&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; Thank you,<br>&gt; <br>&gt; -Doug Gregor<br>&gt; <br>&gt; Review Manager<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution-announce mailing list<br>&gt; swift-evolution-announce at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution-announce<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160410/f523fd03/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
