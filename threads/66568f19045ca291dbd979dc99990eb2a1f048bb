<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e5b8fa5e4f9e527ea335031bf2ec9a03?s=50"></div><header><strong>Proposal: One-past-end array pointers and convertibility of nil for interaction with C APIs</strong> from <string>Árpád Goretity</string> &lt;arpad.goretity at gmail.com&gt;<p>December 24, 2015 at 02:00:00am</p></header><div class="content"><p>Hi everyone,<br></p><p>I was recently trying to use a C API (LLVM for the record) that required<br>passing an array to a function in the form of a pointer and a size. I<br>couldn&#39;t find a straightforward way to pass a null pointer to the function<br>in question conditionally (when the array is empty), since the following –<br>simplified – code doesn&#39;t currently typecheck:<br></p><p>    // C function with signature: void foo(T *ptr, unsigned size)<br>    // imported into Swift as: (UnsafeMutablePointer&lt;T&gt;, UInt32) -&gt; ()<br>    var arr: [T] = []<br>    foo(arr.count &gt; 0 ? &amp;arr[0] : nil, UInt32(arr.count))<br></p><p>The error is: result values in &#39;? :&#39; expression have mismatching types<br>&#39;inout T&#39; and &#39;_&#39;<br></p><p>This does not make sense since although `nil` is typeless by itself, its<br>concrete type should still be able to be inferred from the context (just<br>like it is inferred correctly if one writes<br></p><p>    condition ? 1 as Optional&lt;Int&gt; : nil<br></p><p>which is an analogous scenario.)<br></p><p>Since the inout operator (&amp;) can only be used in function call arguments<br>(so it&#39;s not exactly C&#39;s address-of), I believe that there&#39;s no easy way of<br>elegantly passing a null pointer when the array is empty. (Yes, I could<br>write two almost-identical calls, but meh…) And even if there is one (and<br>I&#39;m just missing it), the fact that the above code does not work seems<br>inconsistent to me.<br></p><p>I also realized that this specific issue generalizes to the (in)ability of<br>passing one-past-end pointers – which would be equally valid and even more<br>convenient in the above case, as the callee does not dereference the passed<br>pointer when the count is 0, but in general, it can be applied to functions<br>accepting [begin, end + 1) ranges.<br></p><p>The problem here is that a one-past-end pointer does not reside at a valid<br>index (pretty much by definition), so bounds checking kicks in and kills<br>the program.<br></p><p>My proposed solutions:<br></p><p> – Extend type inference for unsafe pointers and nil, so that when a value<br>is passed by address to a function, it&#39;s not only the result of an<br>&amp;-expression that has its type inferred to be (or implicitly converted to)<br>Unsafe[Mutable]Pointer, but if there&#39;s a nil somewhere around, such as the<br>one in the example above, it gets promoted to that type too, just like NULL<br>in C or nullptr in C++.<br></p><p> – Stop overloading the inout &#39;&amp;&#39; operator and using it for C-style<br>address-of operations. I could imagine a similar, but distinct operator or<br>even a library function (something along the lines of unsafeAddressOf) that<br>specifically yields the physical address of its operand as an unsafe C<br>pointer, and which is thus first-class in the sense that it may be used<br>anywhere other expressions may be, not just as immediate call arguments.<br></p><p> – Make array bounds checking more lenient when passing pointers to array<br>elements into C functions. Bounds checking should, in these cases, allow<br>indexing the one-past-end element of an array if (and only if) it is the<br>argument of the address-of operator.<br></p><p>Comments and questions are welcome (you might need clarification, as it&#39;s<br>2:35 AM here when I&#39;m writing this…)<br></p><p>Cheers,<br></p><p>-- <br>Author of the Sparkling language<br>http://h2co3.org/<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151224/665648bb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Proposal: One-past-end array pointers and convertibility of nil for interaction with C APIs</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>December 23, 2015 at 08:00:00pm</p></header><div class="content"><p>The &amp; operator isn&#39;t exactly an address-of operator. Does &amp;arr[0] even return a pointer to the inner buffer? When you use &amp; with properties (and possibly with subscripts as well), Swift may create a local, copy the property value to it, pass a pointer to that local, and copy back the output to the property.<br></p><p>Anyway, you are probably looking for Array.withUnsafe(Mutable?)BufferPointer:<br></p><p>arr.withUnsafeMutableBufferPointer { foo($0, $0.count) }<br></p><p>Félix<br></p><p>&gt; Le 23 déc. 2015 à 20:35:09, Árpád Goretity via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Hi everyone,<br>&gt; <br>&gt; I was recently trying to use a C API (LLVM for the record) that required passing an array to a function in the form of a pointer and a size. I couldn&#39;t find a straightforward way to pass a null pointer to the function in question conditionally (when the array is empty), since the following – simplified – code doesn&#39;t currently typecheck:<br>&gt; <br>&gt;     // C function with signature: void foo(T *ptr, unsigned size)<br>&gt;     // imported into Swift as: (UnsafeMutablePointer&lt;T&gt;, UInt32) -&gt; ()<br>&gt;     var arr: [T] = []<br>&gt;     foo(arr.count &gt; 0 ? &amp;arr[0] : nil, UInt32(arr.count))<br>&gt; <br>&gt; The error is: result values in &#39;? :&#39; expression have mismatching types &#39;inout T&#39; and &#39;_&#39; <br>&gt; <br>&gt; This does not make sense since although `nil` is typeless by itself, its concrete type should still be able to be inferred from the context (just like it is inferred correctly if one writes<br>&gt; <br>&gt;     condition ? 1 as Optional&lt;Int&gt; : nil<br>&gt; <br>&gt; which is an analogous scenario.)<br>&gt; <br>&gt; Since the inout operator (&amp;) can only be used in function call arguments (so it&#39;s not exactly C&#39;s address-of), I believe that there&#39;s no easy way of elegantly passing a null pointer when the array is empty. (Yes, I could write two almost-identical calls, but meh…) And even if there is one (and I&#39;m just missing it), the fact that the above code does not work seems inconsistent to me.<br>&gt; <br>&gt; I also realized that this specific issue generalizes to the (in)ability of passing one-past-end pointers – which would be equally valid and even more convenient in the above case, as the callee does not dereference the passed pointer when the count is 0, but in general, it can be applied to functions accepting [begin, end + 1) ranges.<br>&gt; <br>&gt; The problem here is that a one-past-end pointer does not reside at a valid index (pretty much by definition), so bounds checking kicks in and kills the program.<br>&gt; <br>&gt; My proposed solutions:<br>&gt; <br>&gt;  – Extend type inference for unsafe pointers and nil, so that when a value is passed by address to a function, it&#39;s not only the result of an &amp;-expression that has its type inferred to be (or implicitly converted to) Unsafe[Mutable]Pointer, but if there&#39;s a nil somewhere around, such as the one in the example above, it gets promoted to that type too, just like NULL in C or nullptr in C++.<br>&gt; <br>&gt;  – Stop overloading the inout &#39;&amp;&#39; operator and using it for C-style address-of operations. I could imagine a similar, but distinct operator or even a library function (something along the lines of unsafeAddressOf) that specifically yields the physical address of its operand as an unsafe C pointer, and which is thus first-class in the sense that it may be used anywhere other expressions may be, not just as immediate call arguments.<br>&gt; <br>&gt;  – Make array bounds checking more lenient when passing pointers to array elements into C functions. Bounds checking should, in these cases, allow indexing the one-past-end element of an array if (and only if) it is the argument of the address-of operator.<br>&gt; <br>&gt; Comments and questions are welcome (you might need clarification, as it&#39;s 2:35 AM here when I&#39;m writing this…)<br>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; -- <br>&gt; Author of the Sparkling language<br>&gt; http://h2co3.org/ &lt;http://h2co3.org/&gt;<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/b0056212/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Proposal: One-past-end array pointers and convertibility of nil for interaction with C APIs</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 23, 2015 at 06:00:00pm</p></header><div class="content"><p>&gt; On Dec 23, 2015, at 5:50 PM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The &amp; operator isn&#39;t exactly an address-of operator. Does &amp;arr[0] even return a pointer to the inner buffer? When you use &amp; with properties (and possibly with subscripts as well), Swift may create a local, copy the property value to it, pass a pointer to that local, and copy back the output to the property.<br>&gt; <br>&gt; Anyway, you are probably looking for Array.withUnsafe(Mutable?)BufferPointer:<br>&gt; <br>&gt; arr.withUnsafeMutableBufferPointer { foo($0, $0.count) }<br></p><p>For most purposes, foo(arr, arr.count)  (or foo(&amp;arr, arr.count) if you need to mutate the array) does the same thing.<br></p><p>&gt; Félix<br>&gt; <br>&gt;&gt; Le 23 déc. 2015 à 20:35:09, Árpád Goretity via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; Hi everyone,<br>&gt;&gt; <br>&gt;&gt; I was recently trying to use a C API (LLVM for the record) that required passing an array to a function in the form of a pointer and a size. I couldn&#39;t find a straightforward way to pass a null pointer to the function in question conditionally (when the array is empty), since the following – simplified – code doesn&#39;t currently typecheck:<br>&gt;&gt; <br>&gt;&gt;     // C function with signature: void foo(T *ptr, unsigned size)<br>&gt;&gt;     // imported into Swift as: (UnsafeMutablePointer&lt;T&gt;, UInt32) -&gt; ()<br>&gt;&gt;     var arr: [T] = []<br>&gt;&gt;     foo(arr.count &gt; 0 ? &amp;arr[0] : nil, UInt32(arr.count))<br>&gt;&gt; <br>&gt;&gt; The error is: result values in &#39;? :&#39; expression have mismatching types &#39;inout T&#39; and &#39;_&#39; <br>&gt;&gt; <br>&gt;&gt; This does not make sense since although `nil` is typeless by itself, its concrete type should still be able to be inferred from the context (just like it is inferred correctly if one writes<br>&gt;&gt; <br>&gt;&gt;     condition ? 1 as Optional&lt;Int&gt; : nil<br>&gt;&gt; <br>&gt;&gt; which is an analogous scenario.)<br>&gt;&gt; <br>&gt;&gt; Since the inout operator (&amp;) can only be used in function call arguments (so it&#39;s not exactly C&#39;s address-of), I believe that there&#39;s no easy way of elegantly passing a null pointer when the array is empty. (Yes, I could write two almost-identical calls, but meh…) And even if there is one (and I&#39;m just missing it), the fact that the above code does not work seems inconsistent to me.<br>&gt;&gt; <br>&gt;&gt; I also realized that this specific issue generalizes to the (in)ability of passing one-past-end pointers – which would be equally valid and even more convenient in the above case, as the callee does not dereference the passed pointer when the count is 0, but in general, it can be applied to functions accepting [begin, end + 1) ranges.<br>&gt;&gt; <br>&gt;&gt; The problem here is that a one-past-end pointer does not reside at a valid index (pretty much by definition), so bounds checking kicks in and kills the program.<br>&gt;&gt; <br>&gt;&gt; My proposed solutions:<br>&gt;&gt; <br>&gt;&gt;  – Extend type inference for unsafe pointers and nil, so that when a value is passed by address to a function, it&#39;s not only the result of an &amp;-expression that has its type inferred to be (or implicitly converted to) Unsafe[Mutable]Pointer, but if there&#39;s a nil somewhere around, such as the one in the example above, it gets promoted to that type too, just like NULL in C or nullptr in C++.<br>&gt;&gt; <br>&gt;&gt;  – Stop overloading the inout &#39;&amp;&#39; operator and using it for C-style address-of operations. I could imagine a similar, but distinct operator or even a library function (something along the lines of unsafeAddressOf) that specifically yields the physical address of its operand as an unsafe C pointer, and which is thus first-class in the sense that it may be used anywhere other expressions may be, not just as immediate call arguments.<br>&gt;&gt; <br>&gt;&gt;  – Make array bounds checking more lenient when passing pointers to array elements into C functions. Bounds checking should, in these cases, allow indexing the one-past-end element of an array if (and only if) it is the argument of the address-of operator.<br>&gt;&gt; <br>&gt;&gt; Comments and questions are welcome (you might need clarification, as it&#39;s 2:35 AM here when I&#39;m writing this…)<br>&gt;&gt; <br>&gt;&gt; Cheers,<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Author of the Sparkling language<br>&gt;&gt; http://h2co3.org/ &lt;http://h2co3.org/&gt;<br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-Dave<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/70229b83/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Proposal: One-past-end array pointers and convertibility of nil for interaction with C APIs</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>December 24, 2015 at 12:00:00am</p></header><div class="content"><p>&gt; On Dec 23, 2015, at 7:50 PM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The &amp; operator isn&#39;t exactly an address-of operator. Does &amp;arr[0] even return a pointer to the inner buffer? When you use &amp; with properties (and possibly with subscripts as well), Swift may create a local, copy the property value to it, pass a pointer to that local, and copy back the output to the property.<br>&gt; <br>&gt; Anyway, you are probably looking for Array.withUnsafe(Mutable?)BufferPointer:<br>&gt; <br>&gt; arr.withUnsafeMutableBufferPointer { foo($0, $0.count) }<br>&gt; <br>&gt; Félix<br></p><p>The comments in the generated header for UnsafeMutablePointer claim that its regular init() method constructs a null pointer. Therefore, I think you should just be able to:<br></p><p>foo(UnsafeMutablePointer&lt;T&gt;(), 0)<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151224/898b0af8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e5b8fa5e4f9e527ea335031bf2ec9a03?s=50"></div><header><strong>Proposal: One-past-end array pointers and convertibility of nil for interaction with C APIs</strong> from <string>Árpád Goretity</string> &lt;arpad.goretity at gmail.com&gt;<p>December 24, 2015 at 08:00:00am</p></header><div class="content"><p>&gt; The comments in the generated header for UnsafeMutablePointer claim that<br>its regular init() method constructs a null pointer.<br></p><p>That&#39;s right, and I have tried it as well. Yet, type inference doesn&#39;t like<br>like it, and I get back an error similar to what I have already described,<br>but this time with inout and UnsafeMutablePointer:<br></p><p>    result values in &#39;? :&#39; expression have mismatching types &#39;inout T&#39; and<br>&#39;UnsafeMutablePointer&lt;T&gt;&#39;<br></p><p><br>On Thu, Dec 24, 2015 at 7:56 AM, Charles Srstka &lt;cocoadev at charlessoft.com&gt;<br>wrote:<br></p><p>&gt; On Dec 23, 2015, at 7:50 PM, Félix Cloutier via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; The &amp; operator isn&#39;t exactly an address-of operator. Does &amp;arr[0] even<br>&gt; return a pointer to the inner buffer? When you use &amp; with properties (and<br>&gt; possibly with subscripts as well), Swift may create a local, copy the<br>&gt; property value to it, pass a pointer to that local, and copy back the<br>&gt; output to the property.<br>&gt;<br>&gt; Anyway, you are probably looking for<br>&gt; Array.withUnsafe(Mutable?)BufferPointer:<br>&gt;<br>&gt; arr.withUnsafeMutableBufferPointer { foo($0, $0.count) }<br>&gt;<br>&gt; Félix<br>&gt;<br>&gt;<br>&gt; The comments in the generated header for UnsafeMutablePointer claim that<br>&gt; its regular init() method constructs a null pointer. Therefore, I think you<br>&gt; should just be able to:<br>&gt;<br>&gt; foo(UnsafeMutablePointer&lt;T&gt;(), 0)<br>&gt;<br>&gt; Charles<br>&gt;<br>&gt;<br></p><p><br>-- <br>Author of the Sparkling language<br>http://h2co3.org/<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151224/9437cc7c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Proposal: One-past-end array pointers and convertibility of nil for interaction with C APIs</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>December 24, 2015 at 02:00:00am</p></header><div class="content"><p>&gt; On Dec 24, 2015, at 1:11 AM, Árpád Goretity &lt;arpad.goretity at gmail.com&gt; wrote:<br>&gt; <br>&gt; &gt; The comments in the generated header for UnsafeMutablePointer claim that its regular init() method constructs a null pointer.<br>&gt; <br>&gt; That&#39;s right, and I have tried it as well. Yet, type inference doesn&#39;t like like it, and I get back an error similar to what I have already described, but this time with inout and UnsafeMutablePointer:<br>&gt; <br>&gt;     result values in &#39;? :&#39; expression have mismatching types &#39;inout T&#39; and &#39;UnsafeMutablePointer&lt;T&gt;&#39;<br></p><p><br>That’s because you’re putting it in a ternary expression. Swift has magic to automatically turn inout arguments (which is what you get when you put a &amp; in front of an argument) into Unsafe(Mutable)Pointers if that’s what a function asks for. However, you’re not getting to that point, because you’re putting an inout argument and an UnsafeMutablePointer on opposite sides of the ternary operator. That won’t work, because the ternary operator requires both objects to be of the same type, and since your inout argument hasn’t been sent to the function yet, it hasn’t been automagically translated into a pointer.<br></p><p>What Félix said is also true; you can’t trust that &amp;array[0] will get you a pointer to the array’s internal storage. It’s better to use .withUnsafeMutableBufferPointer for that.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151224/b949931d/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: One-past-end array pointers and convertibility of nil for interaction with C APIs</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 24, 2015 at 08:00:00am</p></header><div class="content"><p>&gt; On Dec 23, 2015, at 5:35 PM, Árpád Goretity via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi everyone,<br>&gt; <br>&gt; I was recently trying to use a C API (LLVM for the record) that required passing an array to a function in the form of a pointer and a size. I couldn&#39;t find a straightforward way to pass a null pointer to the function in question conditionally (when the array is empty), since the following – simplified – code doesn&#39;t currently typecheck:<br>&gt; <br>&gt;     // C function with signature: void foo(T *ptr, unsigned size)<br>&gt;     // imported into Swift as: (UnsafeMutablePointer&lt;T&gt;, UInt32) -&gt; ()<br>&gt;     var arr: [T] = []<br>&gt;     foo(arr.count &gt; 0 ? &amp;arr[0] : nil, UInt32(arr.count))<br>&gt; <br>&gt; The error is: result values in &#39;? :&#39; expression have mismatching types &#39;inout T&#39; and &#39;_&#39; <br></p><p>The diagnostic here sucks. The inout-to-pointer is only available to function argument expressions; it&#39;s not even considered in a ternary expression here, so the type checker can&#39;t find any way to match &#39;nil&#39; and an inout.<br></p><p>&gt; Since the inout operator (&amp;) can only be used in function call arguments (so it&#39;s not exactly C&#39;s address-of), I believe that there&#39;s no easy way of elegantly passing a null pointer when the array is empty. (Yes, I could write two almost-identical calls, but meh…) And even if there is one (and I&#39;m just missing it), the fact that the above code does not work seems inconsistent to me.<br>&gt; <br>&gt; I also realized that this specific issue generalizes to the (in)ability of passing one-past-end pointers – which would be equally valid and even more convenient in the above case, as the callee does not dereference the passed pointer when the count is 0, but in general, it can be applied to functions accepting [begin, end + 1) ranges.<br>&gt; <br>&gt; The problem here is that a one-past-end pointer does not reside at a valid index (pretty much by definition), so bounds checking kicks in and kills the program.<br></p><p>Past-the-end indices are valid pointers (and valid in Swift collections in general). That&#39;s not the problem. `&amp;arr[0]` fails because it&#39;s providing a temporary buffer connected only to the *element* &amp;arr[0], rather than a buffer representing the entire array. This won&#39;t do what you expect for any Swift array, even if it&#39;s non-empty.<br></p><p>In general, we can&#39;t support fully first-class pointers into managed Swift entities like Array and properties, without breaking the encapsulation of those abstractions. We can provide scoped operations like `withUnsafePointer` that give you a pointer to a possibly-temporary buffer that represents the value of that array or value for the duration of a block. When you say `CFunctionThatTakesPointer(&amp;a)`, Swift&#39;s really wrapping that call in the equivalent of `withUnsafeMutableBufferPointer` on your behalf. You can see how that would be problematic if the wrapping needs to be conditional, such as if it appeared in a ternary or &amp;&amp;/|| expression. I think the thing to do is to make two calls:<br></p><p>if arr.empty {<br>  foo(nil, 0)<br>} else {<br>  foo(&amp;arr, arr.count)<br>}<br></p><p>since preparing the buffer for the pointer itself isn&#39;t necessarily free, and you&#39;d want to avoid that work if you don&#39;t need it.<br></p><p>It might be OK to have the pointer produced for an empty array be null to begin with, which would avoid the need for this conditional at all. In most cases, you can&#39;t safely dereference a pointer to nothing anyway. I&#39;m also sympathetic to the idea of disconnecting &quot;address-of&quot; and &quot;inout&quot;, since it often leads to confusion like this.<br></p><p>-Joe<br></p><p>&gt; My proposed solutions:<br>&gt; <br>&gt;  – Extend type inference for unsafe pointers and nil, so that when a value is passed by address to a function, it&#39;s not only the result of an &amp;-expression that has its type inferred to be (or implicitly converted to) Unsafe[Mutable]Pointer, but if there&#39;s a nil somewhere around, such as the one in the example above, it gets promoted to that type too, just like NULL in C or nullptr in C++.<br>&gt; <br>&gt;  – Stop overloading the inout &#39;&amp;&#39; operator and using it for C-style address-of operations. I could imagine a similar, but distinct operator or even a library function (something along the lines of unsafeAddressOf) that specifically yields the physical address of its operand as an unsafe C pointer, and which is thus first-class in the sense that it may be used anywhere other expressions may be, not just as immediate call arguments.<br>&gt; <br>&gt;  – Make array bounds checking more lenient when passing pointers to array elements into C functions. Bounds checking should, in these cases, allow indexing the one-past-end element of an array if (and only if) it is the argument of the address-of operator.<br>&gt; <br>&gt; Comments and questions are welcome (you might need clarification, as it&#39;s 2:35 AM here when I&#39;m writing this…)<br>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; -- <br>&gt; Author of the Sparkling language<br>&gt; http://h2co3.org/ &lt;http://h2co3.org/&gt;<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151224/779b02ae/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
