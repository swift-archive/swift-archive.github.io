<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c65faa002b79348ac10e1fb9c1a9ad83?s=50"></div><header><strong>[Review] SE-0005 Better Translation of	Objective-C APIs Into Swift</strong> from <string>Colin Cornaby</string> &lt;colin.cornaby at mac.com&gt;<p>February  1, 2016 at 07:00:00pm</p></header><div class="content"><p>I think there are some rough edges here that could be refined, but as a long time Obj-C guy, I&#39;m fine leaving prefixes behind. They&#39;ve frequently been misused. Third parties are supposed to use three letter prefixes, but frequently only use two, increasing the chances of a collision. Name prefixes to me have seemed like a ticking time bomb. I have nightmares about us or a dependency colliding with Apple&#39;s prefixes in an OS update, especially now that I&#39;ve seen a few three letter prefixes coming from Apple.<br></p><p>I also don&#39;t think prefixes fit well with Swift Foundation, and Swift Foundation shouldn&#39;t diverge that significantly from Apple Foundation.<br></p><p>I think there are several ways of dealing with the issues raised here:<br>- Promote defining variables by their fully quantified type names. I wasn&#39;t even sure that I could do Foundation.NSString until I tried it just now.<br>- Keep the hierarchies small. What always drives me crazy in languages like Java (and that C# example) is the huge hierarchies. We should probably strive to keep things simple. Foundation.String, not System.Utils.Foundation.Text.String.<br></p><p>Something like CoreImage.Image and AppKit.Image is a little more bulky, but I think it actually reads better.<br></p><p>I don&#39;t have strong opinions on selectively importing portions of modules. But if that was to be promoted as a development methodology, I&#39;d like Xcode to automatically manage my imports, much like Eclipse and Android Studio do. When I umbrella import a module, I typically do so out of laziness, so having the IDE take care of my imports for me is a nice compromise.<br></p><p>On Feb 01, 2016, at 10:21 AM, Drew Crawford via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>I am in favor of this proposal on balance, and I leave the bulk of this to people who interop with Objective-C more often than I do.<br></p><p>I would like to confine my remarks to one corner where I think we are making a very serious mistake.<br></p><p>The removal of the &quot;NS&quot; prefix for the Foundation module (or other specifically identified modules) is a mechanical translation for all global symbols defined within that module that can be performed in the Clang importer. <br></p><p>As I understand it (and I am no Cocoa historian) the NS prefix was originally introduced because Objective-C lacks namespacing.<br></p><p>The thinking seems to be that since Swift has proper namespacing, this historicism is no longer necessary.  I find this argument very flimsy.<br></p><p>Of course Swift has stronger namespacing if one&#39;s frame of reference is Objective-C or C.  But for those of us coming from other language backgrounds, namespacing means something much stronger than Swift&#39;s concept of it.  I don&#39;t mean to suggest that Swift&#39;s design is wrong exactly (less is sometimes more), but I do mean to say that if we propose to undo a decision that worked for several decades and break every Swift project in existence on the theory that Swift&#39;s namespacing is strong enough we had better be right.<br></p><p>For those unfamiliar, I will explain some of the namespacing tools Swift lacks relative to other languages.  First, many languages have a &quot;hierarchical&quot; namespace system, where one can say<br></p><p>import Foundation.Net.URL<br>let s = Session(...)<br></p><p>instead of for example<br></p><p>import Foundation<br>let s = NSURLSession(...)<br></p><p>Some form of this is used in Rust, Python, and C#, as far as I know.  I believe Swift has some counterfeit version of this, as the book mentions you can import a &quot;submodule&quot;, but I do not know what that is, do not know how to make one, have never seen anyone use one, the book suggests it goes only 2 levels deep, and perhaps as a consequences of some of these problems nobody thought of using this for Foundation.<br></p><p>A closely related difference is the use of so-called &quot;selective&quot; imports, where we import only a single symbol (or a list of explicitly-identified symbols) into the scope.  We might express this as<br></p><p>from Foundation.Net.URL import Session, HTTP //import two classes only<br>let s = Session(...)<br></p><p>Again I think Swift technically supports some way to avoid importing a whole gigantic namespace like Foundation, but I am not aware of any actual uses of this feature, and certainly the convention is not to write code this way.  Meanwhile, let&#39;s check in with the Python community, who standardized the following guidance on these &quot;wildcard&quot; imports as part of their language evolution process:<br></p><p>Wildcard imports ( from &lt;module&gt; import * ) should be avoided, as they make it unclear which names are present in the namespace, confusing both readers and many automated tools. There is one defensible use case for a wildcard import...<br></p><p>When a language has a robust namespacing system, which we do not, there are many follow-on consequences.  One is that an import statement is much more of a scalpel than a bludgeon; each import statement only introduces a handful of new names (even if it is a so-called &quot;wildcard&quot; import that grabs all children of some namespace, most of those children are themselves namespaces), unlike importing Foundation which contains thousands of direct child types that are injected into the local scope.<br></p><p>Another consequence is that class names become quite short, shadow each other, and nobody bats an eye.  I searched the C# standard library for &quot;Session&quot;, and found some 12 classes with that name:<br></p><p><br></p><p>These &quot;standard library&quot; classes not only potentially shadow programmer-defined types, they also shadow each other.  But because the C# language has a robust namespacing system, the chances of there being more than one thing called &quot;Session&quot; in scope in your program (or for that matter, when developing the standard library itself) is quite small, so it&#39;s a non-issue.<br></p><p>Now we return to the question of dropping the NS prefix, which will rename thousands of classes in a typical program that has `import Foundation`, in a way that potentially (let&#39;s be honest.  More like &quot;probably&quot;) shadows one or more programmer-defined classes.  Our review criteria is:<br></p><p>Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>No, the elimination of 2 characters is not significant enough of a problem to break all Swift programs, let alone to introduce literally thousands of new opportunities for shadowing.<br></p><p>To its credit, the proposal acknowledges this, and offers a concession:<br></p><p>Note that this removal can create conflicts with the standard library. For example, NSString and NSArray will become String and Array, respectively, and Foundation&#39;s versions will shadow the standard library&#39;s versions.  In cases where the Swift 3 names of standard library entities conflict with prefix-stripped Foundation entities, we retain the NS prefix. These Foundation entities are: NSArray, NSDictionary, NSInteger, NSRange, NSSet, and NSString.<br></p><p>But of course this needlessly draws a distinction between NSString et al and the &quot;normal&quot; Foundation types, and what&#39;s more it draws that distinction based on the present composition of the Swift standard library and the present composition of Foundation.  But we have already decided not to guarantee the source compatibility of the standard library, so what happens when that composition changes?  Will we then go back and tweak which classes get NS prefixed to them again?<br></p><p>In my view, if Swift&#39;s namespacing is not good enough to let us drop the NS in NSString it is not good enough to drop any prefix.  If we believe that a programmer will struggle to distinguish between Swift String and Foundation String then we should expect them to struggle for any two classes in any two frameworks, and this is special pleading on the part of Foundation.  C#&#39;s libraries declare *twelve* different `Session`s and nobody bats an eye, but we have two types share a name and everybody loses their minds?  Our namespacing is not good enough to kill the prefix, period.<br></p><p>We should either drop these prefixes or we should not; because the claimed motivation–that we have &quot;good enough&quot; namespacing in the language now–is either true or it is not.  This proposal admits that it is not, and tries to drop the prefixes anyway.  I believe that is a mistake.<br></p><p>I certainly support the goal of eliminating these prefixes, they are ugly, they need to be killed, and namespacing is the right solution.  But we must not jump out of the plane until we are very sure our parachute is in order.  In Swift 3 it is not.<br></p><p>I do think the bulk of the proposal is fine, and I apologize for using quite stark language for such a small paragraph in an otherwise reasonable proposal, but I think the problem buried in here is quite serious and is being overlooked.<br></p><p>Drew<br></p><p><br>On Jan 22, 2016, at 3:02 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>Hello Swift community,<br></p><p>The review of SE-0005&quot;Better Translation of Objective-C APIs Into Swift&quot; begins now and runs through January 31, 2016. The proposal is available here:<br></p><p>https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md<br>Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br></p><p>https://lists.swift.org/mailman/listinfo/swift-evolution<br>or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br></p><p>Proposal link:<br></p><p>https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md<br>Reply text<br></p><p>Other replies<br>What goes into a review?<br></p><p>The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br></p><p>What is your evaluation of the proposal?<br>Is the problem being addressed significant enough to warrant a change to Swift?<br>Does this proposal fit well with the feel and direction of Swift?<br>If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>More information about the Swift evolution process is available at<br></p><p>https://github.com/apple/swift-evolution/blob/master/process.md<br>Thank you,<br></p><p>-Doug Gregor<br></p><p>Review Manager<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/1ddb5c55/attachment-0001.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: Screen Shot 2016-01-30 at 3.44.23 PM.png<br>Type: image/png<br>Size: 231549 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/1ddb5c55/attachment-0001.png&gt;<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
