<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72390862d2525bc8e2883ea3c36f8e5b?s=50"></div><header><strong>Make distinction between ?? -&gt; T and ?? -&gt; T?</strong> from <string>Sébastien Blondiau</string> &lt;sebastien.blondiau at me.com&gt;<p>March  7, 2016 at 10:00:00pm</p></header><div class="content"><p>Currently, there is only one nil coalescing operator, which may return an optional value or not, depending on the second parameter. This variability can leads to unclear line of code:<br></p><p>var isItOptionalOrNot = value ?? otherValue<br></p><p>I think there should be two distinct operators:<br></p><p>var certainlyOptional = value ?? otherValue<br>var certainlyNotOptional = value ?! notOptionalValue<br></p><p>In my point of view, this differentiation brings more clarity about wether the result is an optional or not.<br></p><p>What&#39;s your opinion?<br></p><p>--<br>Sébastien Blondiau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160307/10269745/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Make distinction between ?? -&gt; T and ?? -&gt; T?</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>March  7, 2016 at 02:00:00pm</p></header><div class="content"><p>I would assume ?! has the possibility of having an assert kill my application.<br></p><p>Is there a particular reason you are proposing this, such as a hard-to-diagnose bug?<br></p><p>-DW<br></p><p>&gt; On Mar 7, 2016, at 2:29 PM, Sébastien Blondiau via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Currently, there is only one nil coalescing operator, which may return an optional value or not, depending on the second parameter. This variability can leads to unclear line of code:<br>&gt; <br>&gt; var isItOptionalOrNot = value ?? otherValue<br>&gt; <br>&gt; I think there should be two distinct operators:<br>&gt; <br>&gt; var certainlyOptional = value ?? otherValue<br>&gt; var certainlyNotOptional = value ?! notOptionalValue<br>&gt; <br>&gt; In my point of view, this differentiation brings more clarity about wether the result is an optional or not.<br>&gt; <br>&gt; What&#39;s your opinion?<br>&gt; <br>&gt; --<br>&gt; Sébastien Blondiau<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160307/1e1842ca/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 496 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160307/1e1842ca/attachment.sig&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/aeab22e60ba7b7e2bd445775850448d1?s=50"></div><header><strong>Make distinction between ?? -&gt; T and ?? -&gt; T?</strong> from <string>Radosław Pietruszewski</string> &lt;radexpl at gmail.com&gt;<p>March  7, 2016 at 11:00:00pm</p></header><div class="content"><p>-1, never seen a real world situation where this would be confusing/problematic.<br></p><p>Having one operator is nice for chaining:<br></p><p>var value = someArray ?? someFallback ?? secondaryFallback ?? []<br></p><p>— Radek<br></p><p>&gt; On 07 Mar 2016, at 22:29, Sébastien Blondiau via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Currently, there is only one nil coalescing operator, which may return an optional value or not, depending on the second parameter. This variability can leads to unclear line of code:<br>&gt; <br>&gt; var isItOptionalOrNot = value ?? otherValue<br>&gt; <br>&gt; I think there should be two distinct operators:<br>&gt; <br>&gt; var certainlyOptional = value ?? otherValue<br>&gt; var certainlyNotOptional = value ?! notOptionalValue<br>&gt; <br>&gt; In my point of view, this differentiation brings more clarity about wether the result is an optional or not.<br>&gt; <br>&gt; What&#39;s your opinion?<br>&gt; <br>&gt; --<br>&gt; Sébastien Blondiau<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160307/93726bd1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d172fa3c47108d84ee35a68e8d675c1?s=50"></div><header><strong>Make distinction between ?? -&gt; T and ?? -&gt; T?</strong> from <string>Ross O&#39;Brien</string> &lt;narrativium+swift at gmail.com&gt;<p>March  7, 2016 at 10:00:00pm</p></header><div class="content"><p>During the review of the proposal for a &#39;??=&#39; operator, one of the given<br>disadvantages was the confusion over the meaning of &#39;??&#39;. Since one of its<br>two meanings is that it nil-coalesces a chained expression into a<br>non-optional result, it might be misinterpreted that given the expression<br>&#39;lhs ??= rhs&#39; and a non-optional &#39;rhs&#39;, &#39;lhs&#39; would no longer be optional.<br>&#39;??&#39; is an overloaded operator; unloading one of its two responsibilities<br>to a second operator would improve code clarity.<br></p><p>Radoslaw&#39;s example is simplistic because &#39;[]&#39; is unambiguously<br>non-optional. So let&#39;s replace it:<br></p><p>var value = someArray ?? someFallback ?? secondaryFallback ??<br>tertiaryFallback<br></p><p>Is &#39;value&#39; optional or non-optional?<br></p><p>var value = someArray ?? someFallback ?? secondaryFallback ?!<br>tertiaryFallback<br></p><p>Now we can see immediately that &#39;value&#39; is optional in the first case, and<br>non-optional in the second. However, since &#39;!&#39; is associated with<br>assertions, I agree that perhaps there&#39;s a better choice of operator for<br>this meaning.<br></p><p><br>On Mon, Mar 7, 2016 at 10:26 PM, Radosław Pietruszewski &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; -1, never seen a real world situation where this would be<br>&gt; confusing/problematic.<br>&gt;<br>&gt; Having one operator is nice for chaining:<br>&gt;<br>&gt; var value = someArray ?? someFallback ?? secondaryFallback ?? []<br>&gt;<br>&gt; — Radek<br>&gt;<br>&gt; On 07 Mar 2016, at 22:29, Sébastien Blondiau via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Currently, there is only one nil coalescing operator, which may return an<br>&gt; optional value or not, depending on the second parameter. This variability<br>&gt; can leads to unclear line of code:<br>&gt;<br>&gt; var isItOptionalOrNot = value ?? otherValue<br>&gt;<br>&gt; I think there should be two distinct operators:<br>&gt;<br>&gt; var certainlyOptional = value ?? otherValue<br>&gt; var certainlyNotOptional = value ?! notOptionalValue<br>&gt;<br>&gt; In my point of view, this differentiation brings more clarity about wether<br>&gt; the result is an optional or not.<br>&gt;<br>&gt; What&#39;s your opinion?<br>&gt;<br>&gt; --<br>&gt; Sébastien Blondiau<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160307/e9689bd2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72390862d2525bc8e2883ea3c36f8e5b?s=50"></div><header><strong>Make distinction between ?? -&gt; T and ?? -&gt; T?</strong> from <string>Sébastien Blondiau</string> &lt;sebastien.blondiau at me.com&gt;<p>March  8, 2016 at 02:00:00pm</p></header><div class="content"><p>The situation in which I found a little confusing that that was the same operator, was something like that:<br></p><p>func someFunction() -&gt; T {<br>    <br>    var someValue: T<br>    <br>    /* some code */<br>    <br>    var value = someOptionalValue ?? someValue<br>    <br>    /* some code */<br>    <br>    return value<br>}<br></p><p>For some reasons, I had to consider a new case where someValue had to be an optional<br></p><p>func someFunction() -&gt; T {<br>    <br>    var someValue: T?<br>    <br>    /* some code */<br>    <br>    var value = someOptionalValue ?? someValue<br>    <br>    /* some code */<br>    <br>    return value	// error: value of optional type &#39;T?&#39; not unwrapped; did you mean to use &#39;!&#39; <br>}<br></p><p>In my point of view, the error was not at the return line but rather at the declaration of value. The existence of two operators would have forced me in the first case to use ?! to have value as a non optional, and would make the localisation of the error obvious.<br></p><p>The operator ?! have to have a lower precedence to return the non optional value after that ?? returned the optional one.<br>Having two operators would not prevent programmers from chaining. The case:<br></p><p>var value = someArray ?? someFallback ?? secondaryFallback ?? []<br></p><p>would just be replaced by:<br></p><p>var value = someArray ?? someFallback ?? secondaryFallback ?! []<br></p><p>Same changes would occur everywhere value is non optional. With these changes, I don&#39;t see any situation where code would be broken.<br></p><p>--<br>Sébastien Blondiau<br></p><p>&gt; Le 7 mars 2016 à 23:53, Ross O&#39;Brien &lt;narrativium+swift at gmail.com&gt; a écrit :<br>&gt; <br>&gt; During the review of the proposal for a &#39;??=&#39; operator, one of the given disadvantages was the confusion over the meaning of &#39;??&#39;. Since one of its two meanings is that it nil-coalesces a chained expression into a non-optional result, it might be misinterpreted that given the expression &#39;lhs ??= rhs&#39; and a non-optional &#39;rhs&#39;, &#39;lhs&#39; would no longer be optional. &#39;??&#39; is an overloaded operator; unloading one of its two responsibilities to a second operator would improve code clarity.<br>&gt; <br>&gt; Radoslaw&#39;s example is simplistic because &#39;[]&#39; is unambiguously non-optional. So let&#39;s replace it:<br>&gt; <br>&gt; var value = someArray ?? someFallback ?? secondaryFallback ?? tertiaryFallback<br>&gt; <br>&gt; Is &#39;value&#39; optional or non-optional?<br>&gt; <br>&gt; var value = someArray ?? someFallback ?? secondaryFallback ?! tertiaryFallback<br>&gt; <br>&gt; Now we can see immediately that &#39;value&#39; is optional in the first case, and non-optional in the second. However, since &#39;!&#39; is associated with assertions, I agree that perhaps there&#39;s a better choice of operator for this meaning.<br>&gt; <br>&gt; <br>&gt; On Mon, Mar 7, 2016 at 10:26 PM, Radosław Pietruszewski &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; -1, never seen a real world situation where this would be confusing/problematic.<br>&gt; <br>&gt; Having one operator is nice for chaining:<br>&gt; <br>&gt; var value = someArray ?? someFallback ?? secondaryFallback ?? []<br>&gt; <br>&gt; — Radek<br>&gt; <br>&gt;&gt; On 07 Mar 2016, at 22:29, Sébastien Blondiau via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Currently, there is only one nil coalescing operator, which may return an optional value or not, depending on the second parameter. This variability can leads to unclear line of code:<br>&gt;&gt; <br>&gt;&gt; var isItOptionalOrNot = value ?? otherValue<br>&gt;&gt; <br>&gt;&gt; I think there should be two distinct operators:<br>&gt;&gt; <br>&gt;&gt; var certainlyOptional = value ?? otherValue<br>&gt;&gt; var certainlyNotOptional = value ?! notOptionalValue<br>&gt;&gt; <br>&gt;&gt; In my point of view, this differentiation brings more clarity about wether the result is an optional or not.<br>&gt;&gt; <br>&gt;&gt; What&#39;s your opinion?<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; Sébastien Blondiau<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160308/76c8b596/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72390862d2525bc8e2883ea3c36f8e5b?s=50"></div><header><strong>Make distinction between ?? -&gt; T and ?? -&gt; T?</strong> from <string>Sébastien Blondiau</string> &lt;sebastien.blondiau at me.com&gt;<p>March 10, 2016 at 01:00:00pm</p></header><div class="content"><p>Here is my proposal:<br></p><p>Distinction between ?? -&gt; T? and ?? -&gt; T<br></p><p> &lt;https://github.com/HyperSeb/nil-coalescing-operator/tree/master#introduction&gt;Introduction<br></p><p>The current nil coalescing operator can return an optional or not, depending on the second parameter.<br></p><p>The prosposed solution is the use of two distinct operators: ?? and ?!.<br></p><p> &lt;https://github.com/HyperSeb/nil-coalescing-operator/tree/master#motivation&gt;Motivation<br></p><p>Currently, the only nil coalescing operator may return an optional value or not. This variability can leads to unclear line of code:<br></p><p>var result = value ?? otherValue<br>where result may be an optional, and cannot be determined without looking for the definition of otherValue.<br></p><p>A real situation where I found the unique operator confusing was something like that:<br></p><p>func someFunction() -&gt; T {<br></p><p>    var someValue: T<br></p><p>    /* some code */<br></p><p>    var value = someOptionalValue ?? someValue<br></p><p>    /* some code */<br></p><p>    return value<br>}<br>For some reasons, I had to consider a new case where someValue had to be an optional<br></p><p>func someFunction() -&gt; T {<br></p><p>    var someValue: T?<br></p><p>    /* some code */<br></p><p>    var value = someOptionalValue ?? someValue<br></p><p>    /* some code */<br></p><p>    return value    // error: value of optional type &#39;T?&#39; not unwrapped; did you mean to use &#39;!&#39; <br>}<br>In my situation, the error was not at the return line but rather at the declaration of value. value was non optional in the first code and implicitly became optional in the second code.<br></p><p> &lt;https://github.com/HyperSeb/nil-coalescing-operator/tree/master#proposed-solution&gt;Proposed solution<br></p><p>A new operator ?! , which take a non optional second parameter and return a non optional value. This new operator replaces the current ?? which return a non optional.<br></p><p>This ensures the programmer knows if whether the value is optional or not:<br></p><p>var value = someOptionalValue ?? someValue  // value is optional, without depending on someValue optionality<br></p><p>var value = someOptionalValue ?! someValue  // value is not optional<br>// but if someValue is optional then this produces an error<br>The nil coalescing chaining benefits the same clarity:<br></p><p>var optionalValue    = someArray ?? someFallback ?? secondaryFallback ?? tertiaryFallback<br>var nonOptionalValue = someArray ?? someFallback ?? secondaryFallback ?! tertiaryFallback<br> &lt;https://github.com/HyperSeb/nil-coalescing-operator/tree/master#detailed-design&gt;Detailed design<br></p><p>Under this proposal, the ?! operator has a lower precedence than ?? to have the described form of chaining: the operator ?! returns a non optional after that ?? has returned an optional.<br></p><p>infix operator ?? { associativity right precedence 131 }<br></p><p>+infix operator ?! { precedence 130 }<br>The ?! operator is non associative to avoid bad usages, which would lose some interest of the new operator:<br></p><p>-var nonOptionalValue = someArray ?! someFallback ?! secondaryFallback ?! tertiaryFallback<br>+var nonOptionalValue = someArray ?? someFallback ?? secondaryFallback ?! tertiaryFallback<br>Only the function ?? which returns a non optional is replaced:<br></p><p>-public func ??&lt;T&gt;(optional: T?, @autoclosure defaultValue: () throws -&gt; T) rethrows -&gt; T<br>+public func ?!&lt;T&gt;(optional: T?, @autoclosure defaultValue: () throws -&gt; T) rethrows -&gt; T<br>The internal implementation do not need to change.<br></p><p> &lt;https://github.com/HyperSeb/nil-coalescing-operator/tree/master#impact-on-existing-code&gt;Impact on existing code<br></p><p>This proposal will impact every code using the nil coalesing operator to get a non optional value.<br></p><p>The migration can be done automatically by replacing all ?? which currently return non optional value.<br></p><p> &lt;https://github.com/HyperSeb/nil-coalescing-operator/tree/master#alternatives-considered&gt;Alternatives considered<br></p><p>There are currently no alternatives considered.<br></p><p>Thoughts?<br></p><p>--<br>Sébastien Blondiau<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160310/e44a992e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Make distinction between ?? -&gt; T and ?? -&gt; T?</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>March 10, 2016 at 09:00:00am</p></header><div class="content"><p>I forgot to mention it but I&#39;m (also?) very much against adding a new operator with &quot;!&quot; in the name that won&#39;t ever trap. The &quot;not&quot; operator got pulled in from C, but every other use of &quot;!&quot; means &quot;I am asserting I know more than the compiler does&quot; (or perhaps more accurately &quot;there is a precondition here that the compiler doesn&#39;t know about&quot;). That includes !-to-unwrap, ImplicitlyUnwrappedOptional, &#39;as!&#39;, and &#39;try!&#39;.<br></p><p>Jordan<br></p><p><br>&gt; On Mar 10, 2016, at 4:49 , Sébastien Blondiau via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Here is my proposal:<br>&gt; <br>&gt; Distinction between ?? -&gt; T? and ?? -&gt; T<br>&gt; <br>&gt;  &lt;https://github.com/HyperSeb/nil-coalescing-operator/tree/master#introduction&gt;Introduction<br>&gt; <br>&gt; The current nil coalescing operator can return an optional or not, depending on the second parameter.<br>&gt; <br>&gt; The prosposed solution is the use of two distinct operators: ?? and ?!.<br>&gt; <br>&gt;  &lt;https://github.com/HyperSeb/nil-coalescing-operator/tree/master#motivation&gt;Motivation<br>&gt; <br>&gt; Currently, the only nil coalescing operator may return an optional value or not. This variability can leads to unclear line of code:<br>&gt; <br>&gt; var result = value ?? otherValue<br>&gt; where result may be an optional, and cannot be determined without looking for the definition of otherValue.<br>&gt; <br>&gt; A real situation where I found the unique operator confusing was something like that:<br>&gt; <br>&gt; func someFunction() -&gt; T {<br>&gt; <br>&gt;     var someValue: T<br>&gt; <br>&gt;     /* some code */<br>&gt; <br>&gt;     var value = someOptionalValue ?? someValue<br>&gt; <br>&gt;     /* some code */<br>&gt; <br>&gt;     return value<br>&gt; }<br>&gt; For some reasons, I had to consider a new case where someValue had to be an optional<br>&gt; <br>&gt; func someFunction() -&gt; T {<br>&gt; <br>&gt;     var someValue: T?<br>&gt; <br>&gt;     /* some code */<br>&gt; <br>&gt;     var value = someOptionalValue ?? someValue<br>&gt; <br>&gt;     /* some code */<br>&gt; <br>&gt;     return value    // error: value of optional type &#39;T?&#39; not unwrapped; did you mean to use &#39;!&#39; <br>&gt; }<br>&gt; In my situation, the error was not at the return line but rather at the declaration of value. value was non optional in the first code and implicitly became optional in the second code.<br>&gt; <br>&gt;  &lt;https://github.com/HyperSeb/nil-coalescing-operator/tree/master#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; A new operator ?! , which take a non optional second parameter and return a non optional value. This new operator replaces the current ?? which return a non optional.<br>&gt; <br>&gt; This ensures the programmer knows if whether the value is optional or not:<br>&gt; <br>&gt; var value = someOptionalValue ?? someValue  // value is optional, without depending on someValue optionality<br>&gt; <br>&gt; var value = someOptionalValue ?! someValue  // value is not optional<br>&gt; // but if someValue is optional then this produces an error<br>&gt; The nil coalescing chaining benefits the same clarity:<br>&gt; <br>&gt; var optionalValue    = someArray ?? someFallback ?? secondaryFallback ?? tertiaryFallback<br>&gt; var nonOptionalValue = someArray ?? someFallback ?? secondaryFallback ?! tertiaryFallback<br>&gt;  &lt;https://github.com/HyperSeb/nil-coalescing-operator/tree/master#detailed-design&gt;Detailed design<br>&gt; <br>&gt; Under this proposal, the ?! operator has a lower precedence than ?? to have the described form of chaining: the operator ?! returns a non optional after that ?? has returned an optional.<br>&gt; <br>&gt; infix operator ?? { associativity right precedence 131 }<br>&gt; <br>&gt; +infix operator ?! { precedence 130 }<br>&gt; The ?! operator is non associative to avoid bad usages, which would lose some interest of the new operator:<br>&gt; <br>&gt; -var nonOptionalValue = someArray ?! someFallback ?! secondaryFallback ?! tertiaryFallback<br>&gt; +var nonOptionalValue = someArray ?? someFallback ?? secondaryFallback ?! tertiaryFallback<br>&gt; Only the function ?? which returns a non optional is replaced:<br>&gt; <br>&gt; -public func ??&lt;T&gt;(optional: T?, @autoclosure defaultValue: () throws -&gt; T) rethrows -&gt; T<br>&gt; +public func ?!&lt;T&gt;(optional: T?, @autoclosure defaultValue: () throws -&gt; T) rethrows -&gt; T<br>&gt; The internal implementation do not need to change.<br>&gt; <br>&gt;  &lt;https://github.com/HyperSeb/nil-coalescing-operator/tree/master#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; This proposal will impact every code using the nil coalesing operator to get a non optional value.<br>&gt; <br>&gt; The migration can be done automatically by replacing all ?? which currently return non optional value.<br>&gt; <br>&gt;  &lt;https://github.com/HyperSeb/nil-coalescing-operator/tree/master#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt; There are currently no alternatives considered.<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; --<br>&gt; Sébastien Blondiau<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160310/55bf945e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>Make distinction between ?? -&gt; T and ?? -&gt; T?</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>March 10, 2016 at 05:00:00pm</p></header><div class="content"><p>-1 on ?! since it doesn&#39;t trap like others uses of !<br>-1 on the need for this, the compiler won&#39;t let you do the wrong thing<br>here, yeah I understand that at a glance a human can&#39;t quickly tell however<br>the same thing happens things that return an option when assigned into a<br>var/let<br></p><p>On Thu, Mar 10, 2016 at 9:23 AM Jordan Rose via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I forgot to mention it but I&#39;m (also?) very much against adding a new<br>&gt; operator with &quot;!&quot; in the name that won&#39;t ever trap. The &quot;not&quot; operator got<br>&gt; pulled in from C, but every other use of &quot;!&quot; means &quot;I am asserting I know<br>&gt; more than the compiler does&quot; (or perhaps more accurately &quot;there is a<br>&gt; *precondition* here that the compiler doesn&#39;t know about&quot;). That includes<br>&gt; !-to-unwrap, ImplicitlyUnwrappedOptional, &#39;as!&#39;, and &#39;try!&#39;.<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt;<br>&gt; On Mar 10, 2016, at 4:49 , Sébastien Blondiau via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Here is my proposal:<br>&gt;<br>&gt; Distinction between ?? -&gt; T? and ?? -&gt; T<br>&gt; &lt;https://github.com/HyperSeb/nil-coalescing-operator/tree/master#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; The current nil coalescing operator can return an optional or not,<br>&gt; depending on the second parameter.<br>&gt;<br>&gt; The prosposed solution is the use of two distinct operators: ?? and ?!.<br>&gt;<br>&gt; &lt;https://github.com/HyperSeb/nil-coalescing-operator/tree/master#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; Currently, the only nil coalescing operator may return an optional value<br>&gt; or not. This variability can leads to unclear line of code:<br>&gt;<br>&gt; var result = value ?? otherValue<br>&gt;<br>&gt; where result may be an optional, and cannot be determined without looking<br>&gt; for the definition of otherValue.<br>&gt;<br>&gt; A real situation where I found the unique operator confusing was something<br>&gt; like that:<br>&gt;<br>&gt; func someFunction() -&gt; T {<br>&gt;<br>&gt;     var someValue: T<br>&gt;<br>&gt;     /* some code */<br>&gt;<br>&gt;     var value = someOptionalValue ?? someValue<br>&gt;<br>&gt;     /* some code */<br>&gt;<br>&gt;     return value<br>&gt; }<br>&gt;<br>&gt; For some reasons, I had to consider a new case where someValue had to be<br>&gt; an optional<br>&gt;<br>&gt; func someFunction() -&gt; T {<br>&gt;<br>&gt;     var someValue: T?<br>&gt;<br>&gt;     /* some code */<br>&gt;<br>&gt;     var value = someOptionalValue ?? someValue<br>&gt;<br>&gt;     /* some code */<br>&gt;<br>&gt;     return value    // error: value of optional type &#39;T?&#39; not unwrapped; did you mean to use &#39;!&#39;<br>&gt; }<br>&gt;<br>&gt; In my situation, the error was not at the return line but rather at the<br>&gt; declaration of value. value was non optional in the first code and<br>&gt; implicitly became optional in the second code.<br>&gt;<br>&gt; &lt;https://github.com/HyperSeb/nil-coalescing-operator/tree/master#proposed-solution&gt;Proposed<br>&gt; solution<br>&gt;<br>&gt; A new operator ?! , which take a non optional second parameter and return<br>&gt; a non optional value. This new operator replaces the current ?? which<br>&gt; return a non optional.<br>&gt;<br>&gt; This ensures the programmer knows if whether the value is optional or not:<br>&gt;<br>&gt; var value = someOptionalValue ?? someValue  // value is optional, without depending on someValue optionality<br>&gt; var value = someOptionalValue ?! someValue  // value is not optional// but if someValue is optional then this produces an error<br>&gt;<br>&gt; The nil coalescing chaining benefits the same clarity:<br>&gt;<br>&gt; var optionalValue    = someArray ?? someFallback ?? secondaryFallback ?? tertiaryFallbackvar nonOptionalValue = someArray ?? someFallback ?? secondaryFallback ?! tertiaryFallback<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/HyperSeb/nil-coalescing-operator/tree/master#detailed-design&gt;Detailed<br>&gt; design<br>&gt;<br>&gt; Under this proposal, the ?! operator has a lower precedence than ?? to<br>&gt; have the described form of chaining: the operator ?! returns a non<br>&gt; optional after that ?? has returned an optional.<br>&gt;<br>&gt; infix operator ?? { associativity right precedence 131 }<br>&gt; +infix operator ?! { precedence 130 }<br>&gt;<br>&gt; The ?! operator is non associative to avoid bad usages, which would lose<br>&gt; some interest of the new operator:<br>&gt;<br>&gt; -var nonOptionalValue = someArray ?! someFallback ?! secondaryFallback ?! tertiaryFallback+var nonOptionalValue = someArray ?? someFallback ?? secondaryFallback ?! tertiaryFallback<br>&gt;<br>&gt; Only the function ?? which returns a non optional is replaced:<br>&gt;<br>&gt; -public func ??&lt;T&gt;(optional: T?, @autoclosure defaultValue: () throws -&gt; T) rethrows -&gt; T+public func ?!&lt;T&gt;(optional: T?, @autoclosure defaultValue: () throws -&gt; T) rethrows -&gt; T<br>&gt;<br>&gt; The internal implementation do not need to change.<br>&gt;<br>&gt; &lt;https://github.com/HyperSeb/nil-coalescing-operator/tree/master#impact-on-existing-code&gt;Impact<br>&gt; on existing code<br>&gt;<br>&gt; This proposal will impact every code using the nil coalesing operator to<br>&gt; get a non optional value.<br>&gt;<br>&gt; The migration can be done automatically by replacing all ?? which<br>&gt; currently return non optional value.<br>&gt;<br>&gt; &lt;https://github.com/HyperSeb/nil-coalescing-operator/tree/master#alternatives-considered&gt;Alternatives<br>&gt; considered<br>&gt; There are currently no alternatives considered.<br>&gt;<br>&gt; Thoughts?<br>&gt;<br>&gt; --<br>&gt; Sébastien Blondiau<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160310/909ea86a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Make distinction between ?? -&gt; T and ?? -&gt; T?</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>March 10, 2016 at 06:00:00pm</p></header><div class="content"><p>I agree with Shawn an Jordan.<br>-1 to the proposal.<br></p><p>-Thorsten <br></p><p>&gt; Am 10.03.2016 um 18:29 schrieb Shawn Erickson via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; -1 on ?! since it doesn&#39;t trap like others uses of !<br>&gt; -1 on the need for this, the compiler won&#39;t let you do the wrong thing here, yeah I understand that at a glance a human can&#39;t quickly tell however the same thing happens things that return an option when assigned into a var/let<br>&gt; <br>&gt;&gt; On Thu, Mar 10, 2016 at 9:23 AM Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; I forgot to mention it but I&#39;m (also?) very much against adding a new operator with &quot;!&quot; in the name that won&#39;t ever trap. The &quot;not&quot; operator got pulled in from C, but every other use of &quot;!&quot; means &quot;I am asserting I know more than the compiler does&quot; (or perhaps more accurately &quot;there is a precondition here that the compiler doesn&#39;t know about&quot;). That includes !-to-unwrap, ImplicitlyUnwrappedOptional, &#39;as!&#39;, and &#39;try!&#39;.<br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 10, 2016, at 4:49 , Sébastien Blondiau via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here is my proposal:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Distinction between ?? -&gt; T? and ?? -&gt; T<br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The current nil coalescing operator can return an optional or not, depending on the second parameter.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The prosposed solution is the use of two distinct operators: ?? and ?!.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Currently, the only nil coalescing operator may return an optional value or not. This variability can leads to unclear line of code:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var result = value ?? otherValue<br>&gt;&gt;&gt; where result may be an optional, and cannot be determined without looking for the definition of otherValue.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A real situation where I found the unique operator confusing was something like that:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func someFunction() -&gt; T {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     var someValue: T<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     /* some code */<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     var value = someOptionalValue ?? someValue<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     /* some code */<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     return value<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; For some reasons, I had to consider a new case where someValue had to be an optional<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func someFunction() -&gt; T {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     var someValue: T?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     /* some code */<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     var value = someOptionalValue ?? someValue<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     /* some code */<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     return value    // error: value of optional type &#39;T?&#39; not unwrapped; did you mean to use &#39;!&#39; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; In my situation, the error was not at the return line but rather at the declaration of value. value was non optional in the first code and implicitly became optional in the second code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A new operator ?! , which take a non optional second parameter and return a non optional value. This new operator replaces the current ?? which return a non optional.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This ensures the programmer knows if whether the value is optional or not:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var value = someOptionalValue ?? someValue  // value is optional, without depending on someValue optionality<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var value = someOptionalValue ?! someValue  // value is not optional<br>&gt;&gt;&gt; // but if someValue is optional then this produces an error<br>&gt;&gt;&gt; The nil coalescing chaining benefits the same clarity:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var optionalValue    = someArray ?? someFallback ?? secondaryFallback ?? tertiaryFallback<br>&gt;&gt;&gt; var nonOptionalValue = someArray ?? someFallback ?? secondaryFallback ?! tertiaryFallback<br>&gt;&gt;&gt; Detailed design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Under this proposal, the ?! operator has a lower precedence than ?? to have the described form of chaining: the operator ?! returns a non optional after that ?? has returned an optional.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; infix operator ?? { associativity right precedence 131 }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +infix operator ?! { precedence 130 }<br>&gt;&gt;&gt; The ?! operator is non associative to avoid bad usages, which would lose some interest of the new operator:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -var nonOptionalValue = someArray ?! someFallback ?! secondaryFallback ?! tertiaryFallback<br>&gt;&gt;&gt; +var nonOptionalValue = someArray ?? someFallback ?? secondaryFallback ?! tertiaryFallback<br>&gt;&gt;&gt; Only the function ?? which returns a non optional is replaced:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -public func ??&lt;T&gt;(optional: T?, @autoclosure defaultValue: () throws -&gt; T) rethrows -&gt; T<br>&gt;&gt;&gt; +public func ?!&lt;T&gt;(optional: T?, @autoclosure defaultValue: () throws -&gt; T) rethrows -&gt; T<br>&gt;&gt;&gt; The internal implementation do not need to change.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This proposal will impact every code using the nil coalesing operator to get a non optional value.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The migration can be done automatically by replacing all ?? which currently return non optional value.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are currently no alternatives considered.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Sébastien Blondiau<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160310/54aeed58/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5c9df42e3c293e3cdb5f3e1b34d44ef9?s=50"></div><header><strong>Make distinction between ?? -&gt; T and ?? -&gt; T?</strong> from <string>Step C</string> &lt;schristopher at bignerdranch.com&gt;<p>March 10, 2016 at 11:00:00pm</p></header><div class="content"><p>-1. <br></p><p>Jordan explained the meaning of ! In Swift. For those reasons &quot;?!&quot; Does not work as an operator for non-optional. <br></p><p>But further, optionals work in Swift by providing just enough explicitness without too much friction. This operator makes a distinction that is not sufficiently valuable beyond what the type system already provides. Comments below on the example. <br></p><p>&gt;&gt; Am 10.03.2016 um 18:29 schrieb Shawn Erickson via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; -1 on ?! since it doesn&#39;t trap like others uses of !<br>&gt;&gt; -1 on the need for this, the compiler won&#39;t let you do the wrong thing here, yeah I understand that at a glance a human can&#39;t quickly tell however the same thing happens things that return an option when assigned into a var/let<br>&gt;&gt; <br>&gt;&gt;&gt; On Thu, Mar 10, 2016 at 9:23 AM Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; I forgot to mention it but I&#39;m (also?) very much against adding a new operator with &quot;!&quot; in the name that won&#39;t ever trap. The &quot;not&quot; operator got pulled in from C, but every other use of &quot;!&quot; means &quot;I am asserting I know more than the compiler does&quot; (or perhaps more accurately &quot;there is a precondition here that the compiler doesn&#39;t know about&quot;). That includes !-to-unwrap, ImplicitlyUnwrappedOptional, &#39;as!&#39;, and &#39;try!&#39;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mar 10, 2016, at 4:49 , Sébastien Blondiau via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here is my proposal:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Distinction between ?? -&gt; T? and ?? -&gt; T<br>Snip<br>&gt;&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Currently, the only nil coalescing operator may return an optional value or not. This variability can leads to unclear line of code:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var result = value ?? otherValue<br>&gt;&gt;&gt;&gt; where result may be an optional, and cannot be determined without looking for the definition of otherValue.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A real situation where I found the unique operator confusing was something like that:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func someFunction() -&gt; T {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     var someValue: T<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     /* some code */<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     var value = someOptionalValue ?? someValue<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     /* some code */<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     return value<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; For some reasons, I had to consider a new case where someValue had to be an optional<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func someFunction() -&gt; T {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     var someValue: T?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     /* some code */<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     var value = someOptionalValue ?? someValue<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     /* some code */<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     return value    // error: value of optional type &#39;T?&#39; not unwrapped; did you mean to use &#39;!&#39; <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; In my situation, the error was not at the return line but rather at the declaration of value. value was non optional in the first code and implicitly became optional in the second code.<br>&gt;&gt;&gt;&gt; <br>But the type system gave you an error.  Easy enough to find where the optional is coming from, and not unreasonable that the compiler can&#39;t tell which bit of this logic was the incorrect part. I think this is essential complexity, the price we pay (of having optionals and having to reason about them) is worth it and unavoidable for the benefit of having this method as it was originally - with no optional values. <br></p><p>(End of my reply)<br></p><p><br>&gt;&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A new operator ?! , which take a non optional second parameter and return a non optional value. This new operator replaces the current ?? which return a non optional.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This ensures the programmer knows if whether the value is optional or not:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var value = someOptionalValue ?? someValue  // value is optional, without depending on someValue optionality<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var value = someOptionalValue ?! someValue  // value is not optional<br>&gt;&gt;&gt;&gt; // but if someValue is optional then this produces an error<br>&gt;&gt;&gt;&gt; The nil coalescing chaining benefits the same clarity:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var optionalValue    = someArray ?? someFallback ?? secondaryFallback ?? tertiaryFallback<br>&gt;&gt;&gt;&gt; var nonOptionalValue = someArray ?? someFallback ?? secondaryFallback ?! tertiaryFallback<br>&gt;&gt;&gt;&gt; Detailed design<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Under this proposal, the ?! operator has a lower precedence than ?? to have the described form of chaining: the operator ?! returns a non optional after that ?? has returned an optional.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; infix operator ?? { associativity right precedence 131 }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; +infix operator ?! { precedence 130 }<br>&gt;&gt;&gt;&gt; The ?! operator is non associative to avoid bad usages, which would lose some interest of the new operator:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -var nonOptionalValue = someArray ?! someFallback ?! secondaryFallback ?! tertiaryFallback<br>&gt;&gt;&gt;&gt; +var nonOptionalValue = someArray ?? someFallback ?? secondaryFallback ?! tertiaryFallback<br>&gt;&gt;&gt;&gt; Only the function ?? which returns a non optional is replaced:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -public func ??&lt;T&gt;(optional: T?, @autoclosure defaultValue: () throws -&gt; T) rethrows -&gt; T<br>&gt;&gt;&gt;&gt; +public func ?!&lt;T&gt;(optional: T?, @autoclosure defaultValue: () throws -&gt; T) rethrows -&gt; T<br>&gt;&gt;&gt;&gt; The internal implementation do not need to change.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This proposal will impact every code using the nil coalesing operator to get a non optional value.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The migration can be done automatically by replacing all ?? which currently return non optional value.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are currently no alternatives considered.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; Sébastien Blondiau<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160310/248bac54/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05e222e6ef4d84013bb3baeb0e25c90b?s=50"></div><header><strong>Make distinction between ?? -&gt; T and ?? -&gt; T?</strong> from <string>Patrick Gili</string> &lt;gili.patrick.r at gili-labs.com&gt;<p>March 10, 2016 at 02:00:00pm</p></header><div class="content"><p>I&#39;m very much against having two operators that essential do the same thing. This proposal sounds like something that will become a source of confusion, which is a bad direction for Swift.<br></p><p>-Patrick<br></p><p>&gt; On Mar 10, 2016, at 7:49 AM, Sébastien Blondiau via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Here is my proposal:<br>&gt; <br>&gt; Distinction between ?? -&gt; T? and ?? -&gt; T<br>&gt; <br>&gt;  &lt;https://github.com/HyperSeb/nil-coalescing-operator/tree/master#introduction&gt;Introduction<br>&gt; <br>&gt; The current nil coalescing operator can return an optional or not, depending on the second parameter.<br>&gt; <br>&gt; The prosposed solution is the use of two distinct operators: ?? and ?!.<br>&gt; <br>&gt;  &lt;https://github.com/HyperSeb/nil-coalescing-operator/tree/master#motivation&gt;Motivation<br>&gt; <br>&gt; Currently, the only nil coalescing operator may return an optional value or not. This variability can leads to unclear line of code:<br>&gt; <br>&gt; var result = value ?? otherValue<br>&gt; where result may be an optional, and cannot be determined without looking for the definition of otherValue.<br>&gt; <br>&gt; A real situation where I found the unique operator confusing was something like that:<br>&gt; <br>&gt; func someFunction() -&gt; T {<br>&gt; <br>&gt;     var someValue: T<br>&gt; <br>&gt;     /* some code */<br>&gt; <br>&gt;     var value = someOptionalValue ?? someValue<br>&gt; <br>&gt;     /* some code */<br>&gt; <br>&gt;     return value<br>&gt; }<br>&gt; For some reasons, I had to consider a new case where someValue had to be an optional<br>&gt; <br>&gt; func someFunction() -&gt; T {<br>&gt; <br>&gt;     var someValue: T?<br>&gt; <br>&gt;     /* some code */<br>&gt; <br>&gt;     var value = someOptionalValue ?? someValue<br>&gt; <br>&gt;     /* some code */<br>&gt; <br>&gt;     return value    // error: value of optional type &#39;T?&#39; not unwrapped; did you mean to use &#39;!&#39; <br>&gt; }<br>&gt; In my situation, the error was not at the return line but rather at the declaration of value. value was non optional in the first code and implicitly became optional in the second code.<br>&gt; <br>&gt;  &lt;https://github.com/HyperSeb/nil-coalescing-operator/tree/master#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; A new operator ?! , which take a non optional second parameter and return a non optional value. This new operator replaces the current ?? which return a non optional.<br>&gt; <br>&gt; This ensures the programmer knows if whether the value is optional or not:<br>&gt; <br>&gt; var value = someOptionalValue ?? someValue  // value is optional, without depending on someValue optionality<br>&gt; <br>&gt; var value = someOptionalValue ?! someValue  // value is not optional<br>&gt; // but if someValue is optional then this produces an error<br>&gt; The nil coalescing chaining benefits the same clarity:<br>&gt; <br>&gt; var optionalValue    = someArray ?? someFallback ?? secondaryFallback ?? tertiaryFallback<br>&gt; var nonOptionalValue = someArray ?? someFallback ?? secondaryFallback ?! tertiaryFallback<br>&gt;  &lt;https://github.com/HyperSeb/nil-coalescing-operator/tree/master#detailed-design&gt;Detailed design<br>&gt; <br>&gt; Under this proposal, the ?! operator has a lower precedence than ?? to have the described form of chaining: the operator ?! returns a non optional after that ?? has returned an optional.<br>&gt; <br>&gt; infix operator ?? { associativity right precedence 131 }<br>&gt; <br>&gt; +infix operator ?! { precedence 130 }<br>&gt; The ?! operator is non associative to avoid bad usages, which would lose some interest of the new operator:<br>&gt; <br>&gt; -var nonOptionalValue = someArray ?! someFallback ?! secondaryFallback ?! tertiaryFallback<br>&gt; +var nonOptionalValue = someArray ?? someFallback ?? secondaryFallback ?! tertiaryFallback<br>&gt; Only the function ?? which returns a non optional is replaced:<br>&gt; <br>&gt; -public func ??&lt;T&gt;(optional: T?, @autoclosure defaultValue: () throws -&gt; T) rethrows -&gt; T<br>&gt; +public func ?!&lt;T&gt;(optional: T?, @autoclosure defaultValue: () throws -&gt; T) rethrows -&gt; T<br>&gt; The internal implementation do not need to change.<br>&gt; <br>&gt;  &lt;https://github.com/HyperSeb/nil-coalescing-operator/tree/master#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; This proposal will impact every code using the nil coalesing operator to get a non optional value.<br>&gt; <br>&gt; The migration can be done automatically by replacing all ?? which currently return non optional value.<br>&gt; <br>&gt;  &lt;https://github.com/HyperSeb/nil-coalescing-operator/tree/master#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt; There are currently no alternatives considered.<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; --<br>&gt; Sébastien Blondiau<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160310/5699f8a9/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Make distinction between ?? -&gt; T and ?? -&gt; T?</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>March 11, 2016 at 01:00:00pm</p></header><div class="content"><p>-1, for the reasons mentioned by everyone else.<br></p><p>- Dave Sweeris<br></p><p>&gt; On Mar 10, 2016, at 6:49 AM, Sébastien Blondiau via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Here is my proposal:<br>&gt; <br>&gt; Distinction between ?? -&gt; T? and ?? -&gt; T<br>&gt; <br>&gt;  &lt;https://github.com/HyperSeb/nil-coalescing-operator/tree/master#introduction&gt;Introduction<br>&gt; <br>&gt; The current nil coalescing operator can return an optional or not, depending on the second parameter.<br>&gt; <br>&gt; The prosposed solution is the use of two distinct operators: ?? and ?!.<br>&gt; <br>&gt;  &lt;https://github.com/HyperSeb/nil-coalescing-operator/tree/master#motivation&gt;Motivation<br>&gt; <br>&gt; Currently, the only nil coalescing operator may return an optional value or not. This variability can leads to unclear line of code:<br>&gt; <br>&gt; var result = value ?? otherValue<br>&gt; where result may be an optional, and cannot be determined without looking for the definition of otherValue.<br>&gt; <br>&gt; A real situation where I found the unique operator confusing was something like that:<br>&gt; <br>&gt; func someFunction() -&gt; T {<br>&gt; <br>&gt;     var someValue: T<br>&gt; <br>&gt;     /* some code */<br>&gt; <br>&gt;     var value = someOptionalValue ?? someValue<br>&gt; <br>&gt;     /* some code */<br>&gt; <br>&gt;     return value<br>&gt; }<br>&gt; For some reasons, I had to consider a new case where someValue had to be an optional<br>&gt; <br>&gt; func someFunction() -&gt; T {<br>&gt; <br>&gt;     var someValue: T?<br>&gt; <br>&gt;     /* some code */<br>&gt; <br>&gt;     var value = someOptionalValue ?? someValue<br>&gt; <br>&gt;     /* some code */<br>&gt; <br>&gt;     return value    // error: value of optional type &#39;T?&#39; not unwrapped; did you mean to use &#39;!&#39; <br>&gt; }<br>&gt; In my situation, the error was not at the return line but rather at the declaration of value. value was non optional in the first code and implicitly became optional in the second code.<br>&gt; <br>&gt;  &lt;https://github.com/HyperSeb/nil-coalescing-operator/tree/master#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; A new operator ?! , which take a non optional second parameter and return a non optional value. This new operator replaces the current ?? which return a non optional.<br>&gt; <br>&gt; This ensures the programmer knows if whether the value is optional or not:<br>&gt; <br>&gt; var value = someOptionalValue ?? someValue  // value is optional, without depending on someValue optionality<br>&gt; <br>&gt; var value = someOptionalValue ?! someValue  // value is not optional<br>&gt; // but if someValue is optional then this produces an error<br>&gt; The nil coalescing chaining benefits the same clarity:<br>&gt; <br>&gt; var optionalValue    = someArray ?? someFallback ?? secondaryFallback ?? tertiaryFallback<br>&gt; var nonOptionalValue = someArray ?? someFallback ?? secondaryFallback ?! tertiaryFallback<br>&gt;  &lt;https://github.com/HyperSeb/nil-coalescing-operator/tree/master#detailed-design&gt;Detailed design<br>&gt; <br>&gt; Under this proposal, the ?! operator has a lower precedence than ?? to have the described form of chaining: the operator ?! returns a non optional after that ?? has returned an optional.<br>&gt; <br>&gt; infix operator ?? { associativity right precedence 131 }<br>&gt; <br>&gt; +infix operator ?! { precedence 130 }<br>&gt; The ?! operator is non associative to avoid bad usages, which would lose some interest of the new operator:<br>&gt; <br>&gt; -var nonOptionalValue = someArray ?! someFallback ?! secondaryFallback ?! tertiaryFallback<br>&gt; +var nonOptionalValue = someArray ?? someFallback ?? secondaryFallback ?! tertiaryFallback<br>&gt; Only the function ?? which returns a non optional is replaced:<br>&gt; <br>&gt; -public func ??&lt;T&gt;(optional: T?, @autoclosure defaultValue: () throws -&gt; T) rethrows -&gt; T<br>&gt; +public func ?!&lt;T&gt;(optional: T?, @autoclosure defaultValue: () throws -&gt; T) rethrows -&gt; T<br>&gt; The internal implementation do not need to change.<br>&gt; <br>&gt;  &lt;https://github.com/HyperSeb/nil-coalescing-operator/tree/master#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; This proposal will impact every code using the nil coalesing operator to get a non optional value.<br>&gt; <br>&gt; The migration can be done automatically by replacing all ?? which currently return non optional value.<br>&gt; <br>&gt;  &lt;https://github.com/HyperSeb/nil-coalescing-operator/tree/master#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt; There are currently no alternatives considered.<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; --<br>&gt; Sébastien Blondiau<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160311/a1e13263/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e7e554db1f80d7d6041d92edd5145698?s=50"></div><header><strong>Make distinction between ?? -&gt; T and ?? -&gt; T?</strong> from <string>Hooman Mehr</string> &lt;hooman at mac.com&gt;<p>March 11, 2016 at 01:00:00pm</p></header><div class="content"><p>Here is what I do:<br></p><p>I have this function:<br></p><p>	func nilCrash&lt;T&gt;(message: String = &quot;&quot;) -&gt; T { preconditionFailure(message) }<br></p><p>Sometimes I have a bunch of optionals, but I assert at least one of them is not `nil` using the above:<br></p><p>	let value = optional1 ?? optional2 ?? optional3 ?? nilCrash()<br></p><p>A beneficial side effect is that the type of `value` does not become optional.<br></p><p>An alternative would be: <br></p><p>	let value = optional1 ?? optional2 ?? optional3!<br></p><p>With the same effect: Non-optional `value` type. So: <br></p><p>-1. It is not worth it.<br></p><p><br>&gt; On Mar 11, 2016, at 11:27 AM, Dave via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; -1, for the reasons mentioned by everyone else.<br>&gt; <br>&gt; - Dave Sweeris<br>&gt; <br>&gt;&gt; On Mar 10, 2016, at 6:49 AM, Sébastien Blondiau via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Here is my proposal:<br>&gt;&gt; <br>&gt;&gt; Distinction between ?? -&gt; T? and ?? -&gt; T<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/HyperSeb/nil-coalescing-operator/tree/master#introduction&gt;Introduction<br>&gt;&gt; <br>&gt;&gt; The current nil coalescing operator can return an optional or not, depending on the second parameter.<br>&gt;&gt; <br>&gt;&gt; The prosposed solution is the use of two distinct operators: ?? and ?!.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/HyperSeb/nil-coalescing-operator/tree/master#motivation&gt;Motivation<br>&gt;&gt; <br>&gt;&gt; Currently, the only nil coalescing operator may return an optional value or not. This variability can leads to unclear line of code:<br>&gt;&gt; <br>&gt;&gt; var result = value ?? otherValue<br>&gt;&gt; where result may be an optional, and cannot be determined without looking for the definition of otherValue.<br>&gt;&gt; <br>&gt;&gt; A real situation where I found the unique operator confusing was something like that:<br>&gt;&gt; <br>&gt;&gt; func someFunction() -&gt; T {<br>&gt;&gt; <br>&gt;&gt;     var someValue: T<br>&gt;&gt; <br>&gt;&gt;     /* some code */<br>&gt;&gt; <br>&gt;&gt;     var value = someOptionalValue ?? someValue<br>&gt;&gt; <br>&gt;&gt;     /* some code */<br>&gt;&gt; <br>&gt;&gt;     return value<br>&gt;&gt; }<br>&gt;&gt; For some reasons, I had to consider a new case where someValue had to be an optional<br>&gt;&gt; <br>&gt;&gt; func someFunction() -&gt; T {<br>&gt;&gt; <br>&gt;&gt;     var someValue: T?<br>&gt;&gt; <br>&gt;&gt;     /* some code */<br>&gt;&gt; <br>&gt;&gt;     var value = someOptionalValue ?? someValue<br>&gt;&gt; <br>&gt;&gt;     /* some code */<br>&gt;&gt; <br>&gt;&gt;     return value    // error: value of optional type &#39;T?&#39; not unwrapped; did you mean to use &#39;!&#39; <br>&gt;&gt; }<br>&gt;&gt; In my situation, the error was not at the return line but rather at the declaration of value. value was non optional in the first code and implicitly became optional in the second code.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/HyperSeb/nil-coalescing-operator/tree/master#proposed-solution&gt;Proposed solution<br>&gt;&gt; <br>&gt;&gt; A new operator ?! , which take a non optional second parameter and return a non optional value. This new operator replaces the current ?? which return a non optional.<br>&gt;&gt; <br>&gt;&gt; This ensures the programmer knows if whether the value is optional or not:<br>&gt;&gt; <br>&gt;&gt; var value = someOptionalValue ?? someValue  // value is optional, without depending on someValue optionality<br>&gt;&gt; <br>&gt;&gt; var value = someOptionalValue ?! someValue  // value is not optional<br>&gt;&gt; // but if someValue is optional then this produces an error<br>&gt;&gt; The nil coalescing chaining benefits the same clarity:<br>&gt;&gt; <br>&gt;&gt; var optionalValue    = someArray ?? someFallback ?? secondaryFallback ?? tertiaryFallback<br>&gt;&gt; var nonOptionalValue = someArray ?? someFallback ?? secondaryFallback ?! tertiaryFallback<br>&gt;&gt;  &lt;https://github.com/HyperSeb/nil-coalescing-operator/tree/master#detailed-design&gt;Detailed design<br>&gt;&gt; <br>&gt;&gt; Under this proposal, the ?! operator has a lower precedence than ?? to have the described form of chaining: the operator ?! returns a non optional after that ?? has returned an optional.<br>&gt;&gt; <br>&gt;&gt; infix operator ?? { associativity right precedence 131 }<br>&gt;&gt; <br>&gt;&gt; +infix operator ?! { precedence 130 }<br>&gt;&gt; The ?! operator is non associative to avoid bad usages, which would lose some interest of the new operator:<br>&gt;&gt; <br>&gt;&gt; -var nonOptionalValue = someArray ?! someFallback ?! secondaryFallback ?! tertiaryFallback<br>&gt;&gt; +var nonOptionalValue = someArray ?? someFallback ?? secondaryFallback ?! tertiaryFallback<br>&gt;&gt; Only the function ?? which returns a non optional is replaced:<br>&gt;&gt; <br>&gt;&gt; -public func ??&lt;T&gt;(optional: T?, @autoclosure defaultValue: () throws -&gt; T) rethrows -&gt; T<br>&gt;&gt; +public func ?!&lt;T&gt;(optional: T?, @autoclosure defaultValue: () throws -&gt; T) rethrows -&gt; T<br>&gt;&gt; The internal implementation do not need to change.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/HyperSeb/nil-coalescing-operator/tree/master#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt; <br>&gt;&gt; This proposal will impact every code using the nil coalesing operator to get a non optional value.<br>&gt;&gt; <br>&gt;&gt; The migration can be done automatically by replacing all ?? which currently return non optional value.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/HyperSeb/nil-coalescing-operator/tree/master#alternatives-considered&gt;Alternatives considered<br>&gt;&gt; <br>&gt;&gt; There are currently no alternatives considered.<br>&gt;&gt; <br>&gt;&gt; Thoughts?<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; Sébastien Blondiau<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160311/613bfd36/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72390862d2525bc8e2883ea3c36f8e5b?s=50"></div><header><strong>Make distinction between ?? -&gt; T and ?? -&gt; T?</strong> from <string>Sébastien Blondiau</string> &lt;sebastien.blondiau at me.com&gt;<p>March 12, 2016 at 09:00:00am</p></header><div class="content"><p>Thank&#39;s for your feedbacks.<br></p><p>I have to agree with you that ! is associated with assertion, an other name is indeed required (maybe ?. or anything else).<br></p><p>In opposition to what Patrick said, the interest of the new operator was avoid the confusion which exists between the two functions of ?? (one which returns an optional, the other which returns a non optional). This confusion has been proofed during the review of the proposal about the ??= operator.<br></p><p>I understand that this proposal only offers some human readability and does not prevent from errors which are not caught by the compiler, so is not really important.<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Make distinction between ?? -&gt; T and ?? -&gt; T?</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March  7, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Mar 7, 2016, at 2:26 PM, Radosław Pietruszewski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; -1, never seen a real world situation where this would be confusing/problematic.<br>&gt; <br>&gt; Having one operator is nice for chaining:<br>&gt; <br>&gt; var value = someArray ?? someFallback ?? secondaryFallback ?? []<br></p><p>This case could be handled by making `??` right-associative. In fact, I had originally implemented it that way. I don&#39;t recall why we changed it and added the extra overload; Jordan, do you recall?<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Make distinction between ?? -&gt; T and ?? -&gt; T?</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>March  7, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Mar 7, 2016, at 15:17, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 7, 2016, at 2:26 PM, Radosław Pietruszewski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; -1, never seen a real world situation where this would be confusing/problematic.<br>&gt;&gt; <br>&gt;&gt; Having one operator is nice for chaining:<br>&gt;&gt; <br>&gt;&gt; var value = someArray ?? someFallback ?? secondaryFallback ?? []<br>&gt; <br>&gt; This case could be handled by making `??` right-associative. In fact, I had originally implemented it that way. I don&#39;t recall why we changed it and added the extra overload; Jordan, do you recall?<br></p><p>&#39;??&#39; doesn&#39;t have to fold all the optionals. I consider that a feature and am happy we have it; others may disagree.<br></p><p>When there is a non-optional case at the end, the two versions are equivalent; they just build different intermediate closures.<br></p><p>(((someArray ?? someFallback) ?? secondaryFallback) ?? []) // left-associative<br>(someArray ?? (someFallback ?? (secondaryFallback ?? []))) // right-associative<br></p><p>If &#39;someFallback&#39; is the first non-nil argument, then in both cases &#39;someArray&#39; and &#39;someFallback&#39; will be evaluated and &#39;secondaryFallback&#39; and &#39;[]&#39; will not. With the left-associative version, we have to do extra tests for nil, but those will be optimized away when ?? is inlined. We also create more closure instances, but again we can probably optimize that away. With the right-associative version, we end up with nested closures instead, which may be harder to optimize…or may not be.<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160307/02608475/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>Make distinction between ?? -&gt; T and ?? -&gt; T?</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>March  8, 2016 at 03:00:00am</p></header><div class="content"><p>&gt; With the left-associative version, we have to do extra tests for nil, but those will be optimized away when ?? is inlined. We also create more closure instances, but again we can probably optimize that away. With the right-associative version, we end up with nested closures instead, which may be harder to optimize…or may not be.<br></p><p>FWIW, the current implementation is right-associative: https://github.com/apple/swift/blob/12b793c87f160a0f18bb8762e425174205c5d80a/stdlib/public/core/Policy.swift#L399<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>Make distinction between ?? -&gt; T and ?? -&gt; T?</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>March  8, 2016 at 02:00:00am</p></header><div class="content"><p>&gt; On 07 Mar 2016, at 23:29, Sébastien Blondiau via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think there should be two distinct operators:<br>&gt; <br>&gt; var certainlyOptional = value ?? otherValue<br>&gt; var certainlyNotOptional = value ?! notOptionalValue<br></p><p>Consider a parallel Swiftverse where the standard library only defined the following single overload of `??`:<br></p><p>infix operator ?? { associativity right precedence 131 }<br></p><p>func ?? &lt;T&gt;(x: T?, @autoclosure y: () -&gt; T) -&gt; T {<br>    if let x = x { return x } else { return y() }<br>}<br></p><p>With that defined, life went on and things worked just fine:<br></p><p>let some: Int? = 1<br>let none: Int? = nil<br>let one = some ?? 2         // = 1: Int<br>let two = none ?? 2         // = 2: Int<br>let ein = none ?? some ?? 3 // = 1: Int<br></p><p>(That last line, by the way, is equivalent to `none ?? (some ?? 3)` because of the right associativity.)<br></p><p>However, because of implicit optional wrapping, the following lines compiled as well:<br></p><p>let un   = some ?? none // = Optional(1): Int?<br>let deux = 2    ?? none // = Optional(2): Int?<br>let rien = none ?? some // = nil: Int?<br></p><p>The reason was the compiler would Optional-wrap the left-hand side of `??` over and over again, until the argument pair met the shape `(T?, T)` for a type `T`, which happened to be `Int?` in this case:<br></p><p>some ?? none  →  Optional(some)        ?? none<br>2    ?? none  →  Optional(Optional(2)) ?? none<br>none ?? some  →  Optional(none)        ?? some<br></p><p>Don&#39;t you think the last line was especially surprising? Just a couple of lines up, the definition of `ein` looked almost identical:<br></p><p>let ein  = none ?? some ?? 3 // = 1:   Int<br>let rien = none ?? some      // = nil: Int?<br></p><p>…yet with an entirely different result! Of course that&#39;s just because of associativity rules, but who remembered! So I guess in our world, the intention with the second overload `(T?, T?) -&gt; T?` is beginner friendliness, and I can&#39;t argue against.<br></p><p>— Pyry<br></p><p>Epilogue: The parallel Swiftverse, however, went their own way and protected fellow swiftizens against indecision with:<br></p><p>enum Nope {}<br></p><p>@available(*, deprecated,<br>    message=&quot;Your unwrappingness gets nowhere less Optional. See?&quot;)<br>func ** &lt;T&gt;(x: T?, y: T?) -&gt; Nope { fatalError(&quot;How embarrassing!&quot;) }<br></p><p>Who knows, maybe one day they went on and invented a way to turn that thing into a compiler error? Who knows.<br></p><p>The End.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160308/e3e1b9bc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>Make distinction between ?? -&gt; T and ?? -&gt; T?</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>March  8, 2016 at 02:00:00am</p></header><div class="content"><p>&gt; @available(*, deprecated,<br>&gt;     message=&quot;Your unwrappingness gets nowhere less Optional. See?&quot;)<br>&gt; func ** &lt;T&gt;(x: T?, y: T?) -&gt; Nope { fatalError(&quot;How embarrassing!&quot;) }<br></p><p>This should be `func ??` of course. Used `**` in the playground when writing this, and failed at copy-paste-and-edit.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160308/c1b65564/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
