<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines (when to use properties)</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January 27, 2016 at 11:00:00am</p></header><div class="content"><p>on Sat Jan 23 2016, Jacob Bandes-Storch &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Proposal link:<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md<br>&gt;<br>&gt;&gt; What is your evaluation of the proposal?<br>&gt;<br>&gt; I think there are more things which would make a &quot;guidelines&quot; document<br>&gt; even<br>&gt; better for promoting consistent code:<br>&gt;<br>&gt; - When to use functions vs. properties for getters. The changes in<br>&gt; SE-0006<br>&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0006-apply-api-guidelines-to-the-standard-library.md&gt;<br>&gt; include<br>&gt; &quot;func min()&quot; and &quot;var underestimatedCount&quot;. SE-0005<br>&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md&gt;<br>&gt; includes &quot;class func darkGray()&quot;. I imagine it should be implied that<br>&gt; properties are more efficient to compute, but this doesn&#39;t seem to be<br>&gt; applied consistently.<br></p><p>I&#39;m glad you mentioned this, Jacob.  We had extensive internal<br>discussions about properties, and made substantial progress, but we do<br>not yet have wording suitable for the guidelines.  Let me tell you where<br>things stand.<br></p><p>,----[ Side Note, since you mentioned efficiency ]<br>| I originally wanted to uphold the principle that, “if it isn&#39;t O(1), you<br>| don&#39;t make it a property.”  The implication is that on collections,<br>| “count” would be a method.  That would include Array, for which counting<br>| the elements *is* O(1).  Some people argued that:<br>| <br>| 1. The idea of writing “a.count()” instead of “a.count” to count the<br>|    elements of an Array was absurd.<br>| 2. Programmers don&#39;t draw conclusions about efficiency based on whether<br>|    something is a property.<br>| 3. The fact that Array would have an O(1) non-property that *could* have<br>|    been a property (if it weren&#39;t for CollectionType conformance)<br>|    undermines any communicative power that you might get from using this<br>|    distinction to choose properties.<br>| <br>| I did not win that argument :-)<br>`----<br></p><p>So we surveyed the entire standard library, trying to arrive at some<br>consensus about what ought to be a property and what ought not to be<br>one.  Fortunately I happen to already have a write-up of those results:<br>https://gist.github.com/dabrahams/b6b79f19c2bf9b2a0083<br></p><p>The parts I&#39;m not currently satisfied with are:<br></p><p>1. I don&#39;t know how to nail down what was meant by “intrinsic” in:<br></p><p>     Things that are “intrinsic” to the receiver are properties<br></p><p>2. (possibly-related): The following don&#39;t seem (to me) to be a clear<br>   fit for any of the criteria.  I think we made the right decision in<br>   most cases, but I don&#39;t know how to describe why:<br></p><p>   * description, debugDescription, customReflectable.customMirror<br>   * first<br>   * unsafePointer.pointee<br>   * string.utf8.nulTerminatedUTF8<br>   * collection.min()<br>   * sequence.iterator()<br></p><p>3. I don&#39;t understand the rationale we currently have for<br>   sequence.iterator() not being a property, even though I think that&#39;s<br>   the right choice.<br></p><p>I *do* think there&#39;s enough here to eventually turn it into wording for<br>the guidelines, but it&#39;s going to take a little more work.  If the<br>community can help us clarify the points above, I&#39;m sure it could be a<br>big help!<br></p><p>Cheers,<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines (when to use properties)</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>January 27, 2016 at 01:00:00pm</p></header><div class="content"><p>IMHO, there are safety-level consistency aspects below the design/consistency aspects. <br></p><p>From a safety perspective, people expect property and subscript getters to behave like pure functions (at least externally) - calling does not change the state. Whether I get a collection’s count once at the start of my loop or for each iteration of my loop, both will give me safe behavior.<br></p><p>People expect property setters to be idempotent - if they mutate an object, calling a setter again will result in the same object representation (at least externally) and not further mutation.<br></p><p>Once you have the safety aspect underway, usability and consistency determine what stays as properties or gets promoted to methods.<br></p><p>Example: from a safety perspective, “reverse” and many other methods could be getter property on CollectionType. However, they could not be properties on the super type SequenceType, because SequenceType is allowed to consume the underlying data. To have “reverse’ be consistent across both SequenceType and its subtype CollectionType, it needs to be a method.<br></p><p>underestimateCount() looks like it could be a property for safety, but some other design/consistency aspects made it a method.<br></p><p>-DW<br></p><p>&gt; On Jan 27, 2016, at 12:23 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;m glad you mentioned this, Jacob.  We had extensive internal<br>&gt; discussions about properties, and made substantial progress, but we do<br>&gt; not yet have wording suitable for the guidelines.  Let me tell you where<br>&gt; things stand.<br>&gt; <br>&gt; ,----[ Side Note, since you mentioned efficiency ]<br>&gt; | I originally wanted to uphold the principle that, “if it isn&#39;t O(1), you<br>&gt; | don&#39;t make it a property.”  The implication is that on collections,<br>&gt; | “count” would be a method.  That would include Array, for which counting<br>&gt; | the elements *is* O(1).  Some people argued that:<br>&gt; | <br>&gt; | 1. The idea of writing “a.count()” instead of “a.count” to count the<br>&gt; |    elements of an Array was absurd.<br>&gt; | 2. Programmers don&#39;t draw conclusions about efficiency based on whether<br>&gt; |    something is a property.<br>&gt; | 3. The fact that Array would have an O(1) non-property that *could* have<br>&gt; |    been a property (if it weren&#39;t for CollectionType conformance)<br>&gt; |    undermines any communicative power that you might get from using this<br>&gt; |    distinction to choose properties.<br>&gt; | <br>&gt; | I did not win that argument :-)<br>&gt; `----<br>&gt; <br>&gt; So we surveyed the entire standard library, trying to arrive at some<br>&gt; consensus about what ought to be a property and what ought not to be<br>&gt; one.  Fortunately I happen to already have a write-up of those results:<br>&gt; https://gist.github.com/dabrahams/b6b79f19c2bf9b2a0083<br>&gt; <br>&gt; The parts I&#39;m not currently satisfied with are:<br>&gt; <br>&gt; 1. I don&#39;t know how to nail down what was meant by “intrinsic” in:<br>&gt; <br>&gt;     Things that are “intrinsic” to the receiver are properties<br>&gt; <br>&gt; 2. (possibly-related): The following don&#39;t seem (to me) to be a clear<br>&gt;   fit for any of the criteria.  I think we made the right decision in<br>&gt;   most cases, but I don&#39;t know how to describe why:<br>&gt; <br>&gt;   * description, debugDescription, customReflectable.customMirror<br>&gt;   * first<br>&gt;   * unsafePointer.pointee<br>&gt;   * string.utf8.nulTerminatedUTF8<br>&gt;   * collection.min()<br>&gt;   * sequence.iterator()<br>&gt; <br>&gt; 3. I don&#39;t understand the rationale we currently have for<br>&gt;   sequence.iterator() not being a property, even though I think that&#39;s<br>&gt;   the right choice.<br>&gt; <br>&gt; I *do* think there&#39;s enough here to eventually turn it into wording for<br>&gt; the guidelines, but it&#39;s going to take a little more work.  If the<br>&gt; community can help us clarify the points above, I&#39;m sure it could be a<br>&gt; big help!<br>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines (when to use properties)</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January 28, 2016 at 07:00:00am</p></header><div class="content"><p>I would say that if it doesn&#39;t have arguments and doesn&#39;t mutate then it<br>should be a property, since it will read better and is flexible (you can<br>switch between a stored and calculated property without affecting the<br>external interface easily).<br></p><p>On Thursday, 28 January 2016, David Waite via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; IMHO, there are safety-level consistency aspects below the<br>&gt; design/consistency aspects.<br>&gt;<br>&gt; From a safety perspective, people expect property and subscript getters to<br>&gt; behave like pure functions (at least externally) - calling does not change<br>&gt; the state. Whether I get a collection’s count once at the start of my loop<br>&gt; or for each iteration of my loop, both will give me safe behavior.<br>&gt;<br>&gt; People expect property setters to be idempotent - if they mutate an<br>&gt; object, calling a setter again will result in the same object<br>&gt; representation (at least externally) and not further mutation.<br>&gt;<br>&gt; Once you have the safety aspect underway, usability and consistency<br>&gt; determine what stays as properties or gets promoted to methods.<br>&gt;<br>&gt; Example: from a safety perspective, “reverse” and many other methods could<br>&gt; be getter property on CollectionType. However, they could not be properties<br>&gt; on the super type SequenceType, because SequenceType is allowed to consume<br>&gt; the underlying data. To have “reverse’ be consistent across both<br>&gt; SequenceType and its subtype CollectionType, it needs to be a method.<br>&gt;<br>&gt; underestimateCount() looks like it could be a property for safety, but<br>&gt; some other design/consistency aspects made it a method.<br>&gt;<br>&gt; -DW<br>&gt;<br>&gt; &gt; On Jan 27, 2016, at 12:23 PM, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I&#39;m glad you mentioned this, Jacob.  We had extensive internal<br>&gt; &gt; discussions about properties, and made substantial progress, but we do<br>&gt; &gt; not yet have wording suitable for the guidelines.  Let me tell you where<br>&gt; &gt; things stand.<br>&gt; &gt;<br>&gt; &gt; ,----[ Side Note, since you mentioned efficiency ]<br>&gt; &gt; | I originally wanted to uphold the principle that, “if it isn&#39;t O(1),<br>&gt; you<br>&gt; &gt; | don&#39;t make it a property.”  The implication is that on collections,<br>&gt; &gt; | “count” would be a method.  That would include Array, for which<br>&gt; counting<br>&gt; &gt; | the elements *is* O(1).  Some people argued that:<br>&gt; &gt; |<br>&gt; &gt; | 1. The idea of writing “a.count()” instead of “a.count” to count the<br>&gt; &gt; |    elements of an Array was absurd.<br>&gt; &gt; | 2. Programmers don&#39;t draw conclusions about efficiency based on whether<br>&gt; &gt; |    something is a property.<br>&gt; &gt; | 3. The fact that Array would have an O(1) non-property that *could*<br>&gt; have<br>&gt; &gt; |    been a property (if it weren&#39;t for CollectionType conformance)<br>&gt; &gt; |    undermines any communicative power that you might get from using<br>&gt; this<br>&gt; &gt; |    distinction to choose properties.<br>&gt; &gt; |<br>&gt; &gt; | I did not win that argument :-)<br>&gt; &gt; `----<br>&gt; &gt;<br>&gt; &gt; So we surveyed the entire standard library, trying to arrive at some<br>&gt; &gt; consensus about what ought to be a property and what ought not to be<br>&gt; &gt; one.  Fortunately I happen to already have a write-up of those results:<br>&gt; &gt; https://gist.github.com/dabrahams/b6b79f19c2bf9b2a0083<br>&gt; &gt;<br>&gt; &gt; The parts I&#39;m not currently satisfied with are:<br>&gt; &gt;<br>&gt; &gt; 1. I don&#39;t know how to nail down what was meant by “intrinsic” in:<br>&gt; &gt;<br>&gt; &gt;     Things that are “intrinsic” to the receiver are properties<br>&gt; &gt;<br>&gt; &gt; 2. (possibly-related): The following don&#39;t seem (to me) to be a clear<br>&gt; &gt;   fit for any of the criteria.  I think we made the right decision in<br>&gt; &gt;   most cases, but I don&#39;t know how to describe why:<br>&gt; &gt;<br>&gt; &gt;   * description, debugDescription, customReflectable.customMirror<br>&gt; &gt;   * first<br>&gt; &gt;   * unsafePointer.pointee<br>&gt; &gt;   * string.utf8.nulTerminatedUTF8<br>&gt; &gt;   * collection.min()<br>&gt; &gt;   * sequence.iterator()<br>&gt; &gt;<br>&gt; &gt; 3. I don&#39;t understand the rationale we currently have for<br>&gt; &gt;   sequence.iterator() not being a property, even though I think that&#39;s<br>&gt; &gt;   the right choice.<br>&gt; &gt;<br>&gt; &gt; I *do* think there&#39;s enough here to eventually turn it into wording for<br>&gt; &gt; the guidelines, but it&#39;s going to take a little more work.  If the<br>&gt; &gt; community can help us clarify the points above, I&#39;m sure it could be a<br>&gt; &gt; big help!<br>&gt; &gt;<br>&gt; &gt; Cheers,<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; -Dave<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/0f2ae516/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines (when to use properties)</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>January 27, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jan 27, 2016, at 1:56 PM, Howard Lovatt &lt;howard.lovatt at gmail.com&gt; wrote:<br>&gt; <br>&gt; I would say that if it doesn&#39;t have arguments and doesn&#39;t mutate then it should be a property, since it will read better and is flexible (you can switch between a stored and calculated property without affecting the external interface easily).<br></p><p>It can mutate as long as the mutation is not externally visible on that interface. An example of this would be if the implementation of Set were internally backed by a Splay Tree, where balancing of the tree happens on every access.<br></p><p>https://en.wikipedia.org/wiki/Splay_tree<br></p><p>Another example is any computed property ever which output logging.<br></p><p>-DW<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines (when to use properties)</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January 28, 2016 at 03:00:00pm</p></header><div class="content"><p>Yes. Better wording would be no externally visible mutation.<br></p><p>On Thursday, 28 January 2016, David Waite &lt;david at alkaline-solutions.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; &gt; On Jan 27, 2016, at 1:56 PM, Howard Lovatt &lt;howard.lovatt at gmail.com<br>&gt; &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I would say that if it doesn&#39;t have arguments and doesn&#39;t mutate then it<br>&gt; should be a property, since it will read better and is flexible (you can<br>&gt; switch between a stored and calculated property without affecting the<br>&gt; external interface easily).<br>&gt;<br>&gt; It can mutate as long as the mutation is not externally visible on that<br>&gt; interface. An example of this would be if the implementation of Set were<br>&gt; internally backed by a Splay Tree, where balancing of the tree happens on<br>&gt; every access.<br>&gt;<br>&gt; https://en.wikipedia.org/wiki/Splay_tree<br>&gt;<br>&gt; Another example is any computed property ever which output logging.<br>&gt;<br>&gt; -DW<br>&gt;<br>&gt;<br></p><p>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/90e35746/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines (when to use properties)</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January 27, 2016 at 03:00:00pm</p></header><div class="content"><p>on Wed Jan 27 2016, Howard Lovatt &lt;howard.lovatt-AT-gmail.com&gt; wrote:<br></p><p>&gt; I would say that if it doesn&#39;t have arguments and doesn&#39;t mutate then it<br>&gt; should be a property, since it will read better and is flexible (you can<br>&gt; switch between a stored and calculated property without affecting the<br>&gt; external interface easily).<br></p><p>We had at least one member of the guidelines group initially felt *very*<br>strongly that we should use (basically) that criterion.  But then, in<br>our survey of the standard library, we found that applying it left us<br>with many properties that he wasn&#39;t comfortable with, such as<br>`sequence.iterator` (today&#39;s `sequence.generate()`).  <br></p><p>&gt; On Thursday, 28 January 2016, David Waite via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; IMHO, there are safety-level consistency aspects below the<br>&gt;&gt; design/consistency aspects.<br>&gt;&gt;<br>&gt;&gt; From a safety perspective, people expect property and subscript getters to<br>&gt;&gt; behave like pure functions (at least externally) - calling does not change<br>&gt;&gt; the state. Whether I get a collection’s count once at the start of my loop<br>&gt;&gt; or for each iteration of my loop, both will give me safe behavior.<br>&gt;&gt;<br>&gt;&gt; People expect property setters to be idempotent - if they mutate an<br>&gt;&gt; object, calling a setter again will result in the same object<br>&gt;&gt; representation (at least externally) and not further mutation.<br>&gt;&gt;<br>&gt;&gt; Once you have the safety aspect underway, usability and consistency<br>&gt;&gt; determine what stays as properties or gets promoted to methods.<br>&gt;&gt;<br>&gt;&gt; Example: from a safety perspective, “reverse” and many other methods could<br>&gt;&gt; be getter property on CollectionType. However, they could not be properties<br>&gt;&gt; on the super type SequenceType, because SequenceType is allowed to consume<br>&gt;&gt; the underlying data. To have “reverse’ be consistent across both<br>&gt;&gt; SequenceType and its subtype CollectionType, it needs to be a method.<br>&gt;&gt;<br>&gt;&gt; underestimateCount() looks like it could be a property for safety, but<br>&gt;&gt; some other design/consistency aspects made it a method.<br>&gt;&gt;<br>&gt;&gt; -DW<br>&gt;&gt;<br>&gt;&gt; &gt; On Jan 27, 2016, at 12:23 PM, Dave Abrahams via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org &lt;javascript:;&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I&#39;m glad you mentioned this, Jacob.  We had extensive internal<br>&gt;&gt; &gt; discussions about properties, and made substantial progress, but we do<br>&gt;&gt; &gt; not yet have wording suitable for the guidelines.  Let me tell you where<br>&gt;&gt; &gt; things stand.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; ,----[ Side Note, since you mentioned efficiency ]<br>&gt;&gt; &gt; | I originally wanted to uphold the principle that, “if it isn&#39;t O(1),<br>&gt;&gt; you<br>&gt;&gt; &gt; | don&#39;t make it a property.”  The implication is that on collections,<br>&gt;&gt; &gt; | “count” would be a method.  That would include Array, for which<br>&gt;&gt; counting<br>&gt;&gt; &gt; | the elements *is* O(1).  Some people argued that:<br>&gt;&gt; &gt; |<br>&gt;&gt; &gt; | 1. The idea of writing “a.count()” instead of “a.count” to count the<br>&gt;&gt; &gt; |    elements of an Array was absurd.<br>&gt;&gt; &gt; | 2. Programmers don&#39;t draw conclusions about efficiency based on whether<br>&gt;&gt; &gt; |    something is a property.<br>&gt;&gt; &gt; | 3. The fact that Array would have an O(1) non-property that *could*<br>&gt;&gt; have<br>&gt;&gt; &gt; |    been a property (if it weren&#39;t for CollectionType conformance)<br>&gt;&gt; &gt; |    undermines any communicative power that you might get from using<br>&gt;&gt; this<br>&gt;&gt; &gt; |    distinction to choose properties.<br>&gt;&gt; &gt; |<br>&gt;&gt; &gt; | I did not win that argument :-)<br>&gt;&gt; &gt; `----<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; So we surveyed the entire standard library, trying to arrive at some<br>&gt;&gt; &gt; consensus about what ought to be a property and what ought not to be<br>&gt;&gt; &gt; one.  Fortunately I happen to already have a write-up of those results:<br>&gt;&gt; &gt; https://gist.github.com/dabrahams/b6b79f19c2bf9b2a0083<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The parts I&#39;m not currently satisfied with are:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; 1. I don&#39;t know how to nail down what was meant by “intrinsic” in:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;     Things that are “intrinsic” to the receiver are properties<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; 2. (possibly-related): The following don&#39;t seem (to me) to be a clear<br>&gt;&gt; &gt;   fit for any of the criteria.  I think we made the right decision in<br>&gt;&gt; &gt;   most cases, but I don&#39;t know how to describe why:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;   * description, debugDescription, customReflectable.customMirror<br>&gt;&gt; &gt;   * first<br>&gt;&gt; &gt;   * unsafePointer.pointee<br>&gt;&gt; &gt;   * string.utf8.nulTerminatedUTF8<br>&gt;&gt; &gt;   * collection.min()<br>&gt;&gt; &gt;   * sequence.iterator()<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; 3. I don&#39;t understand the rationale we currently have for<br>&gt;&gt; &gt;   sequence.iterator() not being a property, even though I think that&#39;s<br>&gt;&gt; &gt;   the right choice.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I *do* think there&#39;s enough here to eventually turn it into wording for<br>&gt;&gt; &gt; the guidelines, but it&#39;s going to take a little more work.  If the<br>&gt;&gt; &gt; community can help us clarify the points above, I&#39;m sure it could be a<br>&gt;&gt; &gt; big help!<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Cheers,<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; --<br>&gt;&gt; &gt; -Dave<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines (when to use properties)</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January 28, 2016 at 03:00:00pm</p></header><div class="content"><p>I would have no such qualms. To me array.iterator reads better that<br>array.iterator(). There is precedence for this approach also; Scala. In<br>Scala they go even further, if you declare a function with no args you can<br>always call it without brackets. This works well in Scala and mixes well<br>with their properties that are very similar to Swift properties (though<br>different syntax).<br></p><p>On Thursday, 28 January 2016, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; on Wed Jan 27 2016, Howard Lovatt &lt;howard.lovatt-AT-gmail.com&gt; wrote:<br>&gt;<br>&gt; &gt; I would say that if it doesn&#39;t have arguments and doesn&#39;t mutate then it<br>&gt; &gt; should be a property, since it will read better and is flexible (you can<br>&gt; &gt; switch between a stored and calculated property without affecting the<br>&gt; &gt; external interface easily).<br>&gt;<br>&gt; We had at least one member of the guidelines group initially felt *very*<br>&gt; strongly that we should use (basically) that criterion.  But then, in<br>&gt; our survey of the standard library, we found that applying it left us<br>&gt; with many properties that he wasn&#39;t comfortable with, such as<br>&gt; `sequence.iterator` (today&#39;s `sequence.generate()`).<br>&gt;<br>&gt; &gt; On Thursday, 28 January 2016, David Waite via swift-evolution &lt;<br>&gt; &gt; swift-evolution at swift.org &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; IMHO, there are safety-level consistency aspects below the<br>&gt; &gt;&gt; design/consistency aspects.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; From a safety perspective, people expect property and subscript getters<br>&gt; to<br>&gt; &gt;&gt; behave like pure functions (at least externally) - calling does not<br>&gt; change<br>&gt; &gt;&gt; the state. Whether I get a collection’s count once at the start of my<br>&gt; loop<br>&gt; &gt;&gt; or for each iteration of my loop, both will give me safe behavior.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; People expect property setters to be idempotent - if they mutate an<br>&gt; &gt;&gt; object, calling a setter again will result in the same object<br>&gt; &gt;&gt; representation (at least externally) and not further mutation.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Once you have the safety aspect underway, usability and consistency<br>&gt; &gt;&gt; determine what stays as properties or gets promoted to methods.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Example: from a safety perspective, “reverse” and many other methods<br>&gt; could<br>&gt; &gt;&gt; be getter property on CollectionType. However, they could not be<br>&gt; properties<br>&gt; &gt;&gt; on the super type SequenceType, because SequenceType is allowed to<br>&gt; consume<br>&gt; &gt;&gt; the underlying data. To have “reverse’ be consistent across both<br>&gt; &gt;&gt; SequenceType and its subtype CollectionType, it needs to be a method.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; underestimateCount() looks like it could be a property for safety, but<br>&gt; &gt;&gt; some other design/consistency aspects made it a method.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; -DW<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt; On Jan 27, 2016, at 12:23 PM, Dave Abrahams via swift-evolution &lt;<br>&gt; &gt;&gt; swift-evolution at swift.org &lt;javascript:;&gt; &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; I&#39;m glad you mentioned this, Jacob.  We had extensive internal<br>&gt; &gt;&gt; &gt; discussions about properties, and made substantial progress, but we do<br>&gt; &gt;&gt; &gt; not yet have wording suitable for the guidelines.  Let me tell you<br>&gt; where<br>&gt; &gt;&gt; &gt; things stand.<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; ,----[ Side Note, since you mentioned efficiency ]<br>&gt; &gt;&gt; &gt; | I originally wanted to uphold the principle that, “if it isn&#39;t O(1),<br>&gt; &gt;&gt; you<br>&gt; &gt;&gt; &gt; | don&#39;t make it a property.”  The implication is that on collections,<br>&gt; &gt;&gt; &gt; | “count” would be a method.  That would include Array, for which<br>&gt; &gt;&gt; counting<br>&gt; &gt;&gt; &gt; | the elements *is* O(1).  Some people argued that:<br>&gt; &gt;&gt; &gt; |<br>&gt; &gt;&gt; &gt; | 1. The idea of writing “a.count()” instead of “a.count” to count the<br>&gt; &gt;&gt; &gt; |    elements of an Array was absurd.<br>&gt; &gt;&gt; &gt; | 2. Programmers don&#39;t draw conclusions about efficiency based on<br>&gt; whether<br>&gt; &gt;&gt; &gt; |    something is a property.<br>&gt; &gt;&gt; &gt; | 3. The fact that Array would have an O(1) non-property that *could*<br>&gt; &gt;&gt; have<br>&gt; &gt;&gt; &gt; |    been a property (if it weren&#39;t for CollectionType conformance)<br>&gt; &gt;&gt; &gt; |    undermines any communicative power that you might get from using<br>&gt; &gt;&gt; this<br>&gt; &gt;&gt; &gt; |    distinction to choose properties.<br>&gt; &gt;&gt; &gt; |<br>&gt; &gt;&gt; &gt; | I did not win that argument :-)<br>&gt; &gt;&gt; &gt; `----<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; So we surveyed the entire standard library, trying to arrive at some<br>&gt; &gt;&gt; &gt; consensus about what ought to be a property and what ought not to be<br>&gt; &gt;&gt; &gt; one.  Fortunately I happen to already have a write-up of those<br>&gt; results:<br>&gt; &gt;&gt; &gt; https://gist.github.com/dabrahams/b6b79f19c2bf9b2a0083<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; The parts I&#39;m not currently satisfied with are:<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; 1. I don&#39;t know how to nail down what was meant by “intrinsic” in:<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt;     Things that are “intrinsic” to the receiver are properties<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; 2. (possibly-related): The following don&#39;t seem (to me) to be a clear<br>&gt; &gt;&gt; &gt;   fit for any of the criteria.  I think we made the right decision in<br>&gt; &gt;&gt; &gt;   most cases, but I don&#39;t know how to describe why:<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt;   * description, debugDescription, customReflectable.customMirror<br>&gt; &gt;&gt; &gt;   * first<br>&gt; &gt;&gt; &gt;   * unsafePointer.pointee<br>&gt; &gt;&gt; &gt;   * string.utf8.nulTerminatedUTF8<br>&gt; &gt;&gt; &gt;   * collection.min()<br>&gt; &gt;&gt; &gt;   * sequence.iterator()<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; 3. I don&#39;t understand the rationale we currently have for<br>&gt; &gt;&gt; &gt;   sequence.iterator() not being a property, even though I think that&#39;s<br>&gt; &gt;&gt; &gt;   the right choice.<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; I *do* think there&#39;s enough here to eventually turn it into wording<br>&gt; for<br>&gt; &gt;&gt; &gt; the guidelines, but it&#39;s going to take a little more work.  If the<br>&gt; &gt;&gt; &gt; community can help us clarify the points above, I&#39;m sure it could be a<br>&gt; &gt;&gt; &gt; big help!<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; Cheers,<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; --<br>&gt; &gt;&gt; &gt; -Dave<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; _______________________________________________<br>&gt; &gt;&gt; &gt; swift-evolution mailing list<br>&gt; &gt;&gt; &gt; swift-evolution at swift.org &lt;javascript:;&gt; &lt;javascript:;&gt;<br>&gt; &gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org &lt;javascript:;&gt; &lt;javascript:;&gt;<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;<br>&gt;<br>&gt; --<br>&gt; -Dave<br>&gt;<br></p><p><br>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/a69c8ef5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines (when to use properties)</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>January 27, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Jan 27, 2016, at 9:48 PM, Howard Lovatt &lt;howard.lovatt at gmail.com&gt; wrote:<br>&gt; <br>&gt; I would have no such qualms. To me array.iterator reads better that array.iterator().<br></p><p>I’d make the same argument as I did before for reverse(), except in this case the generator mutates state indirectly (the results of next() on two generators returned from the same sequence are not defined to be similar)<br></p><p>&gt; There is precedence for this approach also; Scala. In Scala they go even further, if you declare a function with no args you can always call it without brackets. This works well in Scala and mixes well with their properties that are very similar to Swift properties (though different syntax).<br></p><p>Not surprising considering Scala’s functional influences. In a pure functional system, no input to a function means something is a constant.<br></p><p>In Ruby, the pattern to only really require parens to disambiguate an expression. The language allows ‘!’ to be used in a method signature to remind developers of side effects (or to disambiguate a non-mutating version, e.g. String#capitalize vs capitalize!)<br></p><p>This has been overloaded somewhat to indicate methods which would be expected to mutate and return a result are instead mutating and raising an exception on failure (e.g. ActiveRecord::Base#save vs save!)<br></p><p>-DW<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines (when to use properties)</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January 28, 2016 at 06:00:00pm</p></header><div class="content"><p>@David,<br></p><p>As an aside: I think that iterator is a bad example because iterator itself<br>is undefined as to whether it is single or multi pass. In Java the two<br>concepts are seperate; an iterator is always multi pass and a stream is<br>maybe multi pass but is treated as single pass unless you are really sure<br>it is multi pass (it generates a runtime error if it is single pass and you<br>attempt twice). This is probably a better approach and in Swift terms it<br>would be sequence.iterator and sequence.stream() (to remind you that stream<br>is probably single pass).<br></p><p>Back to the main topic: If we take reverse as an example then I think<br>sequence.reverse() reads well because you cannot iterate twice.<br></p><p>On 28 January 2016 at 16:46, David Waite &lt;david at alkaline-solutions.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; &gt; On Jan 27, 2016, at 9:48 PM, Howard Lovatt &lt;howard.lovatt at gmail.com&gt;<br>&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I would have no such qualms. To me array.iterator reads better that<br>&gt; array.iterator().<br>&gt;<br>&gt; I’d make the same argument as I did before for reverse(), except in this<br>&gt; case the generator mutates state indirectly (the results of next() on two<br>&gt; generators returned from the same sequence are not defined to be similar)<br>&gt;<br>&gt; &gt; There is precedence for this approach also; Scala. In Scala they go even<br>&gt; further, if you declare a function with no args you can always call it<br>&gt; without brackets. This works well in Scala and mixes well with their<br>&gt; properties that are very similar to Swift properties (though different<br>&gt; syntax).<br>&gt;<br>&gt; Not surprising considering Scala’s functional influences. In a pure<br>&gt; functional system, no input to a function means something is a constant.<br>&gt;<br>&gt; In Ruby, the pattern to only really require parens to disambiguate an<br>&gt; expression. The language allows ‘!’ to be used in a method signature to<br>&gt; remind developers of side effects (or to disambiguate a non-mutating<br>&gt; version, e.g. String#capitalize vs capitalize!)<br>&gt;<br>&gt; This has been overloaded somewhat to indicate methods which would be<br>&gt; expected to mutate and return a result are instead mutating and raising an<br>&gt; exception on failure (e.g. ActiveRecord::Base#save vs save!)<br>&gt;<br>&gt; -DW<br></p><p><br></p><p><br>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/ddd7fafc/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0acf75deb034e62d9e8c18c2d3680b54?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines (when to use properties)</strong> from <string>Michael Wells</string> &lt;michael at michaelwells.com&gt;<p>January 28, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; &gt;&gt; &gt; ,----[ Side Note, since you mentioned efficiency ]<br>&gt; &gt;&gt; &gt; | I originally wanted to uphold the principle that, “if it isn&#39;t O(1),<br>&gt; &gt;&gt; you<br>&gt; &gt;&gt; &gt; | don&#39;t make it a property.”  The implication is that on collections,<br>&gt; &gt;&gt; &gt; | “count” would be a method.  That would include Array, for which<br>&gt; &gt;&gt; counting<br>&gt; &gt;&gt; &gt; | the elements *is* O(1).  Some people argued that:<br>&gt; &gt;&gt; &gt; |<br>&gt; &gt;&gt; &gt; | 1. The idea of writing “a.count()” instead of “a.count” to count the<br>&gt; &gt;&gt; &gt; |    elements of an Array was absurd.<br>&gt; &gt;&gt; &gt; | 2. Programmers don&#39;t draw conclusions about efficiency based on whether<br>&gt; &gt;&gt; &gt; |    something is a property.<br>&gt; &gt;&gt; &gt; | 3. The fact that Array would have an O(1) non-property that *could*<br>&gt; &gt;&gt; have<br>&gt; &gt;&gt; &gt; |    been a property (if it weren&#39;t for CollectionType conformance)<br>&gt; &gt;&gt; &gt; |    undermines any communicative power that you might get from using<br>&gt; &gt;&gt; this<br>&gt; &gt;&gt; &gt; |    distinction to choose properties.<br>&gt; &gt;&gt; &gt; |<br>&gt; &gt;&gt; &gt; | I did not win that argument :-)<br></p><p>I strongly agree that properties imply O(1) and most programmers I’ve ever worked with make the same assumptions. Even if the documentation says otherwise, code like<br></p><p>fibonacciNumbers.count<br></p><p>looks as if you’re accessing a c-style field ‘count’ and that implies (at least to me) that it is a near-costless operation. Some of the biggest design mistakes I’ve ever seen use properties that trigger time-consuming operations like database or network access. <br></p><p>And I don’t think having to use a.count() is absurd. :-)<br></p><p><br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/916d2fbb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines (when to use properties)</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January 31, 2016 at 12:00:00pm</p></header><div class="content"><p>I disagree that a property should imply O(1), this is an implementation<br>detail that might change. For example an array based collection will almost<br>always have a count property that is O(1), but a liked-list based<br>collection will almost always be O(N).<br></p><p>On Friday, 29 January 2016, Michael Wells &lt;michael at michaelwells.com&gt; wrote:<br></p><p>&gt;<br>&gt; &gt;&gt; &gt; ,----[ Side Note, since you mentioned efficiency ]<br>&gt;&gt; &gt;&gt; &gt; | I originally wanted to uphold the principle that, “if it isn&#39;t<br>&gt;&gt; O(1),<br>&gt;&gt; &gt;&gt; you<br>&gt;&gt; &gt;&gt; &gt; | don&#39;t make it a property.”  The implication is that on collections,<br>&gt;&gt; &gt;&gt; &gt; | “count” would be a method.  That would include Array, for which<br>&gt;&gt; &gt;&gt; counting<br>&gt;&gt; &gt;&gt; &gt; | the elements *is* O(1).  Some people argued that:<br>&gt;&gt; &gt;&gt; &gt; |<br>&gt;&gt; &gt;&gt; &gt; | 1. The idea of writing “a.count()” instead of “a.count” to count<br>&gt;&gt; the<br>&gt;&gt; &gt;&gt; &gt; |    elements of an Array was absurd.<br>&gt;&gt; &gt;&gt; &gt; | 2. Programmers don&#39;t draw conclusions about efficiency based on<br>&gt;&gt; whether<br>&gt;&gt; &gt;&gt; &gt; |    something is a property.<br>&gt;&gt; &gt;&gt; &gt; | 3. The fact that Array would have an O(1) non-property that *could*<br>&gt;&gt; &gt;&gt; have<br>&gt;&gt; &gt;&gt; &gt; |    been a property (if it weren&#39;t for CollectionType conformance)<br>&gt;&gt; &gt;&gt; &gt; |    undermines any communicative power that you might get from using<br>&gt;&gt; &gt;&gt; this<br>&gt;&gt; &gt;&gt; &gt; |    distinction to choose properties.<br>&gt;&gt; &gt;&gt; &gt; |<br>&gt;&gt; &gt;&gt; &gt; | I did not win that argument :-)<br>&gt;&gt;<br>&gt;<br>&gt; I strongly agree that properties imply O(1) and most programmers I’ve ever<br>&gt; worked with make the same assumptions. Even if the documentation says<br>&gt; otherwise, code like<br>&gt;<br>&gt; fibonacciNumbers.count<br>&gt;<br>&gt; looks as if you’re accessing a c-style field ‘count’ and that implies (at<br>&gt; least to me) that it is a near-costless operation. Some of the biggest<br>&gt; design mistakes I’ve ever seen use properties that trigger time-consuming<br>&gt; operations like database or network access.<br>&gt;<br>&gt; And I don’t think having to use a.count() is absurd. :-)<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br></p><p>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160131/6d0119b0/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5818a8a9211c31af95d6db8974457683?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines (when to use properties)</strong> from <string>Joseph Lord</string> &lt;joseph at human-friendly.com&gt;<p>January 31, 2016 at 01:00:00am</p></header><div class="content"><p>On 27/01/2016 23:50, Dave Abrahams via swift-evolution wrote:<br>&gt;<br>&gt; on Wed Jan 27 2016, Howard Lovatt &lt;howard.lovatt-AT-gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; I would say that if it doesn&#39;t have arguments and doesn&#39;t mutate then it<br>&gt;&gt; should be a property, since it will read better and is flexible (you can<br>&gt;&gt; switch between a stored and calculated property without affecting the<br>&gt;&gt; external interface easily).<br>&gt;<br>&gt; We had at least one member of the guidelines group initially felt *very*<br>&gt; strongly that we should use (basically) that criterion.  But then, in<br>&gt; our survey of the standard library, we found that applying it left us<br>&gt; with many properties that he wasn&#39;t comfortable with, such as<br>&gt; `sequence.iterator` (today&#39;s `sequence.generate()`).<br></p><p>I think that if you get a new instance of something back that will be <br>distinct from the one you will get if you access it again then it should <br>be a method and not a property. In a way the state has changed because <br>it won&#39;t give you the same instance. This would keep generate() in the <br>method category (for single use ones anyway).<br></p><p>Joseph<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines (when to use properties)</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January 27, 2016 at 03:00:00pm</p></header><div class="content"><p>on Wed Jan 27 2016, David Waite &lt;david-AT-alkaline-solutions.com&gt; wrote:<br></p><p>&gt; IMHO, there are safety-level consistency aspects below the design/consistency aspects. <br>&gt;<br>&gt; From a safety perspective, people expect property and subscript<br>&gt; getters to behave like pure functions (at least externally) - calling<br>&gt; does not change the state. <br></p><p>Yes, I&#39;m sorry that I wasn&#39;t explicit about this; the guidelines group<br>takes this for granted as a requirement for being a property.  Thanks<br>for pointing it out.<br></p><p>&gt; Whether I get a collection’s count once at the start of my loop or for<br>&gt; each iteration of my loop, both will give me safe behavior.<br></p><p>I&#39;m not sure whether you&#39;re conflating two ideas here.  When we say<br>&quot;safe&quot; in Swift, we don&#39;t mean &quot;doesn&#39;t have side-effects;&quot; we mean<br>either type safety (not accessing initialized memory as a type it<br>doesn&#39;t have) or memory safety (not accessing uninitialized memory).<br>Could you clarify what you mean?<br></p><p>&gt; People expect property setters to be idempotent - if they mutate an<br>&gt; object, calling a setter again will result in the same object<br>&gt; representation (at least externally) and not further mutation.<br></p><p>Again, the group takes this for granted as a requirement for being a<br>property. Thanks for pointing it out.<br></p><p>&gt; Once you have the safety aspect underway, usability and consistency<br>&gt; determine what stays as properties or gets promoted to methods.<br>&gt;<br>&gt; Example: from a safety perspective, “reverse” and many other methods<br>&gt; could be getter property on CollectionType. However, they could not be<br>&gt; properties on the super type SequenceType, because SequenceType is<br>&gt; allowed to consume the underlying data. To have “reverse’ be<br>&gt; consistent across both SequenceType and its subtype CollectionType, it<br>&gt; needs to be a method.<br>&gt;<br>&gt; underestimateCount() looks like it could be a property for safety, but<br>&gt; some other design/consistency aspects made it a method.<br></p><p>This is useful, thanks!<br></p><p>&gt; -DW<br>&gt;<br>&gt;&gt; On Jan 27, 2016, at 12:23 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;m glad you mentioned this, Jacob.  We had extensive internal<br>&gt;&gt; discussions about properties, and made substantial progress, but we do<br>&gt;&gt; not yet have wording suitable for the guidelines.  Let me tell you where<br>&gt;&gt; things stand.<br>&gt;&gt; <br>&gt;&gt; ,----[ Side Note, since you mentioned efficiency ]<br>&gt;&gt; | I originally wanted to uphold the principle that, “if it isn&#39;t O(1), you<br>&gt;&gt; | don&#39;t make it a property.”  The implication is that on collections,<br>&gt;&gt; | “count” would be a method.  That would include Array, for which counting<br>&gt;&gt; | the elements *is* O(1).  Some people argued that:<br>&gt;&gt; | <br>&gt;&gt; | 1. The idea of writing “a.count()” instead of “a.count” to count the<br>&gt;&gt; |    elements of an Array was absurd.<br>&gt;&gt; | 2. Programmers don&#39;t draw conclusions about efficiency based on whether<br>&gt;&gt; |    something is a property.<br>&gt;&gt; | 3. The fact that Array would have an O(1) non-property that *could* have<br>&gt;&gt; |    been a property (if it weren&#39;t for CollectionType conformance)<br>&gt;&gt; |    undermines any communicative power that you might get from using this<br>&gt;&gt; |    distinction to choose properties.<br>&gt;&gt; | <br>&gt;&gt; | I did not win that argument :-)<br>&gt;&gt; `----<br>&gt;&gt; <br>&gt;&gt; So we surveyed the entire standard library, trying to arrive at some<br>&gt;&gt; consensus about what ought to be a property and what ought not to be<br>&gt;&gt; one.  Fortunately I happen to already have a write-up of those results:<br>&gt;&gt; https://gist.github.com/dabrahams/b6b79f19c2bf9b2a0083<br>&gt;&gt; <br>&gt;&gt; The parts I&#39;m not currently satisfied with are:<br>&gt;&gt; <br>&gt;&gt; 1. I don&#39;t know how to nail down what was meant by “intrinsic” in:<br>&gt;&gt; <br>&gt;&gt;     Things that are “intrinsic” to the receiver are properties<br>&gt;&gt; <br>&gt;&gt; 2. (possibly-related): The following don&#39;t seem (to me) to be a clear<br>&gt;&gt;   fit for any of the criteria.  I think we made the right decision in<br>&gt;&gt;   most cases, but I don&#39;t know how to describe why:<br>&gt;&gt; <br>&gt;&gt;   * description, debugDescription, customReflectable.customMirror<br>&gt;&gt;   * first<br>&gt;&gt;   * unsafePointer.pointee<br>&gt;&gt;   * string.utf8.nulTerminatedUTF8<br>&gt;&gt;   * collection.min()<br>&gt;&gt;   * sequence.iterator()<br>&gt;&gt; <br>&gt;&gt; 3. I don&#39;t understand the rationale we currently have for<br>&gt;&gt;   sequence.iterator() not being a property, even though I think that&#39;s<br>&gt;&gt;   the right choice.<br>&gt;&gt; <br>&gt;&gt; I *do* think there&#39;s enough here to eventually turn it into wording for<br>&gt;&gt; the guidelines, but it&#39;s going to take a little more work.  If the<br>&gt;&gt; community can help us clarify the points above, I&#39;m sure it could be a<br>&gt;&gt; big help!<br>&gt;&gt; <br>&gt;&gt; Cheers,<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines (when to use properties)</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>January 27, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jan 27, 2016, at 4:45 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; on Wed Jan 27 2016, David Waite &lt;david-AT-alkaline-solutions.com &lt;http://david-at-alkaline-solutions.com/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Whether I get a collection’s count once at the start of my loop or for<br>&gt;&gt; each iteration of my loop, both will give me safe behavior.<br>&gt; <br>&gt; I&#39;m not sure whether you&#39;re conflating two ideas here.  When we say<br>&gt; &quot;safe&quot; in Swift, we don&#39;t mean &quot;doesn&#39;t have side-effects;&quot; we mean<br>&gt; either type safety (not accessing initialized memory as a type it<br>&gt; doesn&#39;t have) or memory safety (not accessing uninitialized memory).<br>&gt; Could you clarify what you mean?<br></p><p>Apologies, I omitted the definition of safe I was using when paring down the email and didn’t notice (FYI, the original definition of safe and idempotent came from HTTP).<br></p><p>I mean without *impacting* side effects. For value types this means non-mutable, but not necessarily forbidding mutation of classes (including ones referenced internally by the struct). This means that any side effects are not visible from the API perspective.<br></p><p>On a separate reply of what I mean by this, I gave the example of using a logging interface, or having a collection backed by a splay tree (a data structure whose topology is modified on read).<br></p><p>&gt; <br>&gt;&gt; Once you have the safety aspect underway, usability and consistency<br>&gt;&gt; determine what stays as properties or gets promoted to methods.<br>&gt;&gt; <br>&gt;&gt; Example: from a safety perspective, “reverse” and many other methods<br>&gt;&gt; could be getter property on CollectionType. However, they could not be<br>&gt;&gt; properties on the super type SequenceType, because SequenceType is<br>&gt;&gt; allowed to consume the underlying data. To have “reverse’ be<br>&gt;&gt; consistent across both SequenceType and its subtype CollectionType, it<br>&gt;&gt; needs to be a method.<br>&gt;&gt; <br>&gt;&gt; underestimateCount() looks like it could be a property for safety, but<br>&gt;&gt; some other design/consistency aspects made it a method.<br>&gt; <br>&gt; This is useful, thanks!<br></p><p>Yeah, once you qualify what can be a property by the basic level of user expectation, there are other aspects (including complexity and usage) that come into play when deciding between properties and methods.<br></p><p>Count is a great example; with C-style for loops in the picture, it was probable someone would call count in their comparison on each loop, not realizing it backs a possibly O(n) operation. With C-style loops gone, having count be a property is more easily justified.<br></p><p>-DW<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/8993e1fe/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0089229ece6e648767cff4dc6c6d38ab?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines (when to use properties)</strong> from <string>Charles Kissinger</string> &lt;crk at akkyra.com&gt;<p>January 27, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Jan 27, 2016, at 11:23 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; 1. I don&#39;t know how to nail down what was meant by “intrinsic” in:<br>&gt; <br>&gt;     Things that are “intrinsic” to the receiver are properties<br></p><p>How about: If something is, or logically could be, a value stored in memory as part of the object, it is intrinsic.<br></p><p>&gt; 3. I don&#39;t understand the rationale we currently have for<br>&gt;   sequence.iterator() not being a property, even though I think that&#39;s<br>&gt;   the right choice.<br></p><p>To me, a sequence.iterator property would suggest there is one such thing that is intrinsic to the sequence. A sequence.iterator() method better expresses the idea that there can be multiple independent iterators existing at once (for multi-pass sequences anyway).<br></p><p>—CK<br></p><p>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
