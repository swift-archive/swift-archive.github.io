<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Post Swift 3] [Proposal] Introducing `group` mechanism</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>June 29, 2016 at 03:00:00pm</p></header><div class="content"><p>Dear Swift community, as most of you may know we’ve been discussing the future of extintials and diverse design ideas. The result for Swift 3 is a proposal which makes the first step by replacing procotol&lt;A, B&gt; with a new shorthand syntax A &amp; B.<br></p><p>The reason I’m posting this proposal so early is to get some feedback about this idea in general. If the feedback is positive, I also would like some of you to consider the removal of the access modifier from extensions. By that I don’t mean to remove it completely. My honest opinion is that extensions should have exactly the same access control like classes, enums and structs.<br></p><p>One take the access control from protocols and mix it with the access control of classes (etc.) and the result is the access control for extensions. I just can’t agree with the fact of laziness of typing out access modifier on extension members some of you might have.<br></p><p>The current access control on extensions disallow us to use access modifier when we involve protocol conformances.<br></p><p>Default implementations have three ways of declaring public visibility:<br></p><p>extension SomeProtocol {<br>    public func someMember() {}<br>}<br>     <br>public extension SomeProtocol {<br>    func someMember() {}<br>}<br>     <br>public extension SomeProtocol {<br>    public func someMember() {}<br>}<br>If it was the access control mechanism for classes (etc.) there would be only a single correct way to achieve this:<br></p><p>public class SomeClass {<br>    public func someMember() {}<br>}<br>Feel free to join the conversation about removing the current behavior from extensions for Swift 3. Here is the &gt;&gt;link&lt;&lt; to the last post. (I still have to rewrite a few things to reflect my thoughts from the conversation.)<br></p><p>I’d like to introduce a new scoped but typeless mechanism to Swift (which might be added after Swift 3 drops). I gave it a clean name group to showcase what it will be used for. You can read my formatted draft &gt;&gt;here&lt;&lt;.<br></p><p>These were the basic ideas I had. I’ve already seen a few threads where some people were asking for a way organizing variables into groups by an access modifier. So here it is, but a group can solve other problems too. We could finally stop abusing enums and also create access labels for a clear and swifty code design.<br></p><p>The idea of groups is based on the access control of protocols. It would be great if this mechanism could have its own scope, which then could be used almost anywhere.<br></p><p>Detailed design<br></p><p>A group is typeless, and should be used for organization purposes.<br></p><p>Organizing members by an access modifier.<br></p><p>Providing an access label to type members (CamelCase).<br></p><p>Providing namespacing for API design (UpperCamelCase).<br></p><p>public group Reference {<br>    /* implicitly public */ class String { ... }<br>    /* implicitly public */ class Char { ... }<br>}<br>Possible usage:<br></p><p>let instance = Reference.String()  <br>A group can be used inside any scope or at file level.<br></p><p>A group has one or no label at all:<br></p><p>A group without a label has always an explicit access modifier:<br></p><p>public struct A {<br>         <br>    public group {<br>        var a: Int { return self._a }<br>        var aTimesTen: Int { return self.a * 10 }<br>    }<br>             <br>    internal group {<br>        var _a: Int = 10<br>        var _b: Int = 42<br>    }<br>}<br>A group with a label has an optional access modifier:<br></p><p>Labeled groups without an access modifier are automatically internal.<br>Group members have the same access modifier as the group itself (like access modifier on protocols).<br>Nested groups inherit the access modifier from its root group.<br>Labeled groups cannot be stored in any manner.<br>public class UIScrollView : ... {<br>         <br>    public group {<br>     <br>        /* implicitly public */ group content {<br>            /* implicitly public */ var offset: CGPoint<br>            /* implicitly public */ var size: CGSize<br>            /* implicitly public */ var inset: UIEdgeInsets<br>        }<br>                 <br>        /* implicitly public */ var someCoolPublicInteger: Int<br>    }<br>    ...<br>}<br>Possible usage:<br></p><p>- scrollViewInstance.contentOffset<br>+ scrollViewInstance.content.offset<br>It should be possible to create multiple groups with the same/different access modfier and the same acess label:<br></p><p>public struct B {<br>     <br>    public group labelName {<br>        var someVarName: Int<br>    }<br>         <br>    public group labelName {<br>        var someOtherVarName: String<br>    }<br>         <br>    internal group labelName {<br>        var _internalVarName: Double<br>    }<br>}<br>It should be possible to extend existing labeled groups.<br></p><p>public struct C {<br>     <br>    public group labelName {<br>        var someVarName: Int<br>    }<br>}<br>     <br>public extension C {<br>     <br>    public group labelName {<br>        var computedProperty: Int { ... }<br>    }<br>}<br>Attributes aplied to a group will automatically be aplied to all members.<br></p><p>public class D {<br>     <br>    public static group {<br>         <br>        // public static var<br>        var something: Int = 42<br>             <br>        // public static func<br>        func foo() { ... }<br>    }<br>}<br>Grammar<br></p><p>declaration → group-declaration<br></p><p>group-declaration → attributesopt access-level-modifier group group-body<br></p><p>group-declaration → attributesopt access-level-modifieropt group group-name group-body<br></p><p>group-name → identifier­<br></p><p>group-body → { declarations }<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/731a6d6d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Post Swift 3] [Proposal] Introducing `group` mechanism</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>June 29, 2016 at 05:00:00pm</p></header><div class="content"><p>A similar proposal can be found here:<br></p><p>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160613/020968.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160613/020968.html&gt;<br></p><p>It uses a bit different syntax, but the gist of it seems the same to me...<br></p><p><br>&gt; On Jun 29, 2016, at 3:49 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Dear Swift community, as most of you may know we’ve been discussing the future of extintials and diverse design ideas. The result for Swift 3 is a proposal which makes the first step by replacing procotol&lt;A, B&gt; with a new shorthand syntax A &amp; B.<br>&gt; <br>&gt; The reason I’m posting this proposal so early is to get some feedback about this idea in general. If the feedback is positive, I also would like some of you to consider the removal of the access modifier from extensions. By that I don’t mean to remove it completely. My honest opinion is that extensions should have exactly the same access control like classes, enums and structs. <br>&gt; <br>&gt; One take the access control from protocols and mix it with the access control of classes (etc.) and the result is the access control for extensions. I just can’t agree with the fact of laziness of typing out access modifier on extension members some of you might have. <br>&gt; <br>&gt; The current access control on extensions disallow us to use access modifier when we involve protocol conformances. <br>&gt; <br>&gt; Default implementations have three ways of declaring public visibility:<br>&gt; <br>&gt; extension SomeProtocol {<br>&gt;     public func someMember() {}<br>&gt; }<br>&gt;      <br>&gt; public extension SomeProtocol {<br>&gt;     func someMember() {}<br>&gt; }<br>&gt;      <br>&gt; public extension SomeProtocol {<br>&gt;     public func someMember() {}<br>&gt; }<br>&gt; If it was the access control mechanism for classes (etc.) there would be only a single correct way to achieve this:<br>&gt; <br>&gt; public class SomeClass {<br>&gt;     public func someMember() {}<br>&gt; }<br>&gt; Feel free to join the conversation about removing the current behavior from extensions for Swift 3. Here is the &gt;&gt;link&lt;&lt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160627/022511.html&gt; to the last post. (I still have to rewrite a few things to reflect my thoughts from the conversation.)<br>&gt; <br>&gt; I’d like to introduce a new scoped but typeless mechanism to Swift (which might be added after Swift 3 drops). I gave it a clean name group to showcase what it will be used for. You can read my formatted draft &gt;&gt;here&lt;&lt; &lt;https://gist.github.com/DevAndArtist/c74f706febf93452999881335f6ca1f9&gt;.<br>&gt; <br>&gt; These were the basic ideas I had. I’ve already seen a few threads where some people were asking for a way organizing variables into groups by an access modifier. So here it is, but a group can solve other problems too. We could finally stop abusing enums and also create access labels for a clear and swifty code design.<br>&gt; <br>&gt; The idea of groups is based on the access control of protocols. It would be great if this mechanism could have its own scope, which then could be used almost anywhere.<br>&gt; <br>&gt; Detailed design<br>&gt; <br>&gt; A group is typeless, and should be used for organization purposes.<br>&gt; <br>&gt; Organizing members by an access modifier.<br>&gt; <br>&gt; Providing an access label to type members (CamelCase).<br>&gt; <br>&gt; Providing namespacing for API design (UpperCamelCase).<br>&gt; <br>&gt; public group Reference {<br>&gt;     /* implicitly public */ class String { ... }<br>&gt;     /* implicitly public */ class Char { ... }<br>&gt; }<br>&gt; Possible usage:<br>&gt; <br>&gt; let instance = Reference.String()  <br>&gt; A group can be used inside any scope or at file level.<br>&gt; <br>&gt; A group has one or no label at all:<br>&gt; <br>&gt; A group without a label has always an explicit access modifier:<br>&gt; <br>&gt; public struct A {<br>&gt;          <br>&gt;     public group {<br>&gt;         var a: Int { return self._a }<br>&gt;         var aTimesTen: Int { return self.a * 10 }<br>&gt;     }<br>&gt;              <br>&gt;     internal group {<br>&gt;         var _a: Int = 10<br>&gt;         var _b: Int = 42<br>&gt;     }<br>&gt; }<br>&gt; A group with a label has an optional access modifier:<br>&gt; <br>&gt; Labeled groups without an access modifier are automatically internal.<br>&gt; Group members have the same access modifier as the group itself (like access modifier on protocols).<br>&gt; Nested groups inherit the access modifier from its root group.<br>&gt; Labeled groups cannot be stored in any manner.<br>&gt; public class UIScrollView : ... {<br>&gt;          <br>&gt;     public group {<br>&gt;      <br>&gt;         /* implicitly public */ group content {<br>&gt;             /* implicitly public */ var offset: CGPoint<br>&gt;             /* implicitly public */ var size: CGSize<br>&gt;             /* implicitly public */ var inset: UIEdgeInsets<br>&gt;         }<br>&gt;                  <br>&gt;         /* implicitly public */ var someCoolPublicInteger: Int<br>&gt;     }<br>&gt;     ...<br>&gt; }<br>&gt; Possible usage:<br>&gt; <br>&gt; - scrollViewInstance.contentOffset<br>&gt; + scrollViewInstance.content.offset<br>&gt; It should be possible to create multiple groups with the same/different access modfier and the same acess label:<br>&gt; <br>&gt; public struct B {<br>&gt;      <br>&gt;     public group labelName {<br>&gt;         var someVarName: Int<br>&gt;     }<br>&gt;          <br>&gt;     public group labelName {<br>&gt;         var someOtherVarName: String<br>&gt;     }<br>&gt;          <br>&gt;     internal group labelName {<br>&gt;         var _internalVarName: Double<br>&gt;     }<br>&gt; }<br>&gt; It should be possible to extend existing labeled groups.<br>&gt; <br>&gt; public struct C {<br>&gt;      <br>&gt;     public group labelName {<br>&gt;         var someVarName: Int<br>&gt;     }<br>&gt; }<br>&gt;      <br>&gt; public extension C {<br>&gt;      <br>&gt;     public group labelName {<br>&gt;         var computedProperty: Int { ... }<br>&gt;     }<br>&gt; }<br>&gt; Attributes aplied to a group will automatically be aplied to all members.<br>&gt; <br>&gt; public class D {<br>&gt;      <br>&gt;     public static group {<br>&gt;          <br>&gt;         // public static var<br>&gt;         var something: Int = 42<br>&gt;              <br>&gt;         // public static func<br>&gt;         func foo() { ... }<br>&gt;     }<br>&gt; }<br>&gt; Grammar<br>&gt; <br>&gt; declaration → group-declaration<br>&gt; <br>&gt; group-declaration → attributesopt access-level-modifier group group-body<br>&gt; <br>&gt; group-declaration → attributesopt access-level-modifieropt group group-name group-body<br>&gt; <br>&gt; group-name → identifier­<br>&gt; <br>&gt; group-body → { declarations }<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/9635f80d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Post Swift 3] [Proposal] Introducing `group` mechanism</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>June 29, 2016 at 05:00:00pm</p></header><div class="content"><p>This is one of the posts I was referring to, thanks for providing the link. I enhanced the idea to solve more problems with a single mechanism.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 29. Juni 2016 um 17:39:05, Charlie Monroe (charlie at charliemonroe.net) schrieb:<br></p><p>A similar proposal can be found here:<br></p><p>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160613/020968.html<br></p><p>It uses a bit different syntax, but the gist of it seems the same to me...<br></p><p><br>On Jun 29, 2016, at 3:49 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>Dear Swift community, as most of you may know we’ve been discussing the future of extintials and diverse design ideas. The result for Swift 3 is a proposal which makes the first step by replacing procotol&lt;A, B&gt; with a new shorthand syntax A &amp; B.<br></p><p>The reason I’m posting this proposal so early is to get some feedback about this idea in general. If the feedback is positive, I also would like some of you to consider the removal of the access modifier from extensions. By that I don’t mean to remove it completely. My honest opinion is that extensions should have exactly the same access control like classes, enums and structs. <br></p><p>One take the access control from protocols and mix it with the access control of classes (etc.) and the result is the access control for extensions. I just can’t agree with the fact of laziness of typing out access modifier on extension members some of you might have. <br></p><p>The current access control on extensions disallow us to use access modifier when we involve protocol conformances. <br></p><p>Default implementations have three ways of declaring public visibility:<br></p><p>extension SomeProtocol {<br>    public func someMember() {}<br>}<br>      <br>public extension SomeProtocol {<br>    func someMember() {}<br>}<br>      <br>public extension SomeProtocol {<br>    public func someMember() {}<br>}<br>If it was the access control mechanism for classes (etc.) there would be only a single correct way to achieve this:<br></p><p>public class SomeClass {<br>    public func someMember() {}<br>}<br>Feel free to join the conversation about removing the current behavior from extensions for Swift 3. Here is the &gt;&gt;link&lt;&lt; to the last post. (I still have to rewrite a few things to reflect my thoughts from the conversation.)<br></p><p>I’d like to introduce a new scoped but typeless mechanism to Swift (which might be added after Swift 3 drops). I gave it a clean name group to showcase what it will be used for. You can read my formatted draft &gt;&gt;here&lt;&lt;.<br></p><p>These were the basic ideas I had. I’ve already seen a few threads where some people were asking for a way organizing variables into groups by an access modifier. So here it is, but a group can solve other problems too. We could finally stop abusing enums and also create access labels for a clear and swifty code design.<br></p><p>The idea of groups is based on the access control of protocols. It would be great if this mechanism could have its own scope, which then could be used almost anywhere.<br></p><p>Detailed design<br></p><p>A group is typeless, and should be used for organization purposes.<br></p><p>Organizing members by an access modifier.<br></p><p>Providing an access label to type members (CamelCase).<br></p><p>Providing namespacing for API design (UpperCamelCase).<br></p><p>public group Reference {<br>    /* implicitly public */ class String { ... }<br>    /* implicitly public */ class Char { ... }<br>}<br>Possible usage:<br></p><p>let instance = Reference.String()   <br>A group can be used inside any scope or at file level.<br></p><p>A group has one or no label at all:<br></p><p>A group without a label has always an explicit access modifier:<br></p><p>public struct A {<br>          <br>    public group {<br>        var a: Int { return self._a }<br>        var aTimesTen: Int { return self.a * 10 }<br>    }<br>              <br>    internal group {<br>        var _a: Int = 10<br>        var _b: Int = 42<br>    }<br>}<br>A group with a label has an optional access modifier:<br></p><p>Labeled groups without an access modifier are automatically internal.<br>Group members have the same access modifier as the group itself (like access modifier on protocols).<br>Nested groups inherit the access modifier from its root group.<br>Labeled groups cannot be stored in any manner.<br>public class UIScrollView : ... {<br>          <br>    public group {<br>      <br>        /* implicitly public */ group content {<br>            /* implicitly public */ var offset: CGPoint<br>            /* implicitly public */ var size: CGSize<br>            /* implicitly public */ var inset: UIEdgeInsets<br>        }<br>                  <br>        /* implicitly public */ var someCoolPublicInteger: Int<br>    }<br>    ...<br>}<br>Possible usage:<br></p><p>- scrollViewInstance.contentOffset<br>+ scrollViewInstance.content.offset<br>It should be possible to create multiple groups with the same/different access modfier and the same acess label:<br></p><p>public struct B {<br>      <br>    public group labelName {<br>        var someVarName: Int<br>    }<br>          <br>    public group labelName {<br>        var someOtherVarName: String<br>    }<br>          <br>    internal group labelName {<br>        var _internalVarName: Double<br>    }<br>}<br>It should be possible to extend existing labeled groups.<br></p><p>public struct C {<br>      <br>    public group labelName {<br>        var someVarName: Int<br>    }<br>}<br>      <br>public extension C {<br>      <br>    public group labelName {<br>        var computedProperty: Int { ... }<br>    }<br>}<br>Attributes aplied to a group will automatically be aplied to all members.<br></p><p>public class D {<br>      <br>    public static group {<br>          <br>        // public static var<br>        var something: Int = 42<br>              <br>        // public static func<br>        func foo() { ... }<br>    }<br>}<br>Grammar<br></p><p>declaration → group-declaration<br></p><p>group-declaration → attributesopt access-level-modifier group group-body<br></p><p>group-declaration → attributesopt access-level-modifieropt group group-name group-body<br></p><p>group-name → identifier­<br></p><p>group-body → { declarations }<br></p><p><br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/11556b27/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Post Swift 3] [Proposal] Introducing `group` mechanism</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June 29, 2016 at 07:00:00pm</p></header><div class="content"><p>-1 looks like a kludgy hack. <br>It will force people to have to scroll back to the declaration of a group (with no assistance to find where it is) in order to ascertain the visibility of a given method, while pushing code further to the right for every single method. Couple that with the zealous following of the 80c rules and that makes for a less than stellar coding experience... all in the name of not have to type a modifier.<br>Regards<br>(From mobile)<br></p><p>&gt; On Jun 29, 2016, at 3:49 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Dear Swift community, as most of you may know we’ve been discussing the future of extintials and diverse design ideas. The result for Swift 3 is a proposal which makes the first step by replacing procotol&lt;A, B&gt; with a new shorthand syntax A &amp; B.<br>&gt; <br>&gt; The reason I’m posting this proposal so early is to get some feedback about this idea in general. If the feedback is positive, I also would like some of you to consider the removal of the access modifier from extensions. By that I don’t mean to remove it completely. My honest opinion is that extensions should have exactly the same access control like classes, enums and structs.<br>&gt; <br>&gt; One take the access control from protocols and mix it with the access control of classes (etc.) and the result is the access control for extensions. I just can’t agree with the fact of laziness of typing out access modifier on extension members some of you might have.<br>&gt; <br>&gt; The current access control on extensions disallow us to use access modifier when we involve protocol conformances.<br>&gt; <br>&gt; Default implementations have three ways of declaring public visibility:<br>&gt; <br>&gt; extension SomeProtocol {<br>&gt;     public func someMember() {}<br>&gt; }<br>&gt;      <br>&gt; public extension SomeProtocol {<br>&gt;     func someMember() {}<br>&gt; }<br>&gt;      <br>&gt; public extension SomeProtocol {<br>&gt;     public func someMember() {}<br>&gt; }<br>&gt; If it was the access control mechanism for classes (etc.) there would be only a single correct way to achieve this:<br>&gt; <br>&gt; public class SomeClass {<br>&gt;     public func someMember() {}<br>&gt; }<br>&gt; Feel free to join the conversation about removing the current behavior from extensions for Swift 3. Here is the &gt;&gt;link&lt;&lt; to the last post. (I still have to rewrite a few things to reflect my thoughts from the conversation.)<br>&gt; <br>&gt; I’d like to introduce a new scoped but typeless mechanism to Swift (which might be added after Swift 3 drops). I gave it a clean name group to showcase what it will be used for. You can read my formatted draft &gt;&gt;here&lt;&lt;.<br>&gt; <br>&gt; These were the basic ideas I had. I’ve already seen a few threads where some people were asking for a way organizing variables into groups by an access modifier. So here it is, but a group can solve other problems too. We could finally stop abusing enums and also create access labels for a clear and swifty code design.<br>&gt; <br>&gt; The idea of groups is based on the access control of protocols. It would be great if this mechanism could have its own scope, which then could be used almost anywhere.<br>&gt; <br>&gt; Detailed design<br>&gt; <br>&gt; A group is typeless, and should be used for organization purposes.<br>&gt; <br>&gt; Organizing members by an access modifier.<br>&gt; <br>&gt; Providing an access label to type members (CamelCase).<br>&gt; <br>&gt; Providing namespacing for API design (UpperCamelCase).<br>&gt; <br>&gt; public group Reference {<br>&gt;     /* implicitly public */ class String { ... }<br>&gt;     /* implicitly public */ class Char { ... }<br>&gt; }<br>&gt; Possible usage:<br>&gt; <br>&gt; let instance = Reference.String()  <br>&gt; A group can be used inside any scope or at file level.<br>&gt; <br>&gt; A group has one or no label at all:<br>&gt; <br>&gt; A group without a label has always an explicit access modifier:<br>&gt; <br>&gt; public struct A {<br>&gt;          <br>&gt;     public group {<br>&gt;         var a: Int { return self._a }<br>&gt;         var aTimesTen: Int { return self.a * 10 }<br>&gt;     }<br>&gt;              <br>&gt;     internal group {<br>&gt;         var _a: Int = 10<br>&gt;         var _b: Int = 42<br>&gt;     }<br>&gt; }<br>&gt; A group with a label has an optional access modifier:<br>&gt; <br>&gt; Labeled groups without an access modifier are automatically internal.<br>&gt; Group members have the same access modifier as the group itself (like access modifier on protocols).<br>&gt; Nested groups inherit the access modifier from its root group.<br>&gt; Labeled groups cannot be stored in any manner.<br>&gt; public class UIScrollView : ... {<br>&gt;          <br>&gt;     public group {<br>&gt;      <br>&gt;         /* implicitly public */ group content {<br>&gt;             /* implicitly public */ var offset: CGPoint<br>&gt;             /* implicitly public */ var size: CGSize<br>&gt;             /* implicitly public */ var inset: UIEdgeInsets<br>&gt;         }<br>&gt;                  <br>&gt;         /* implicitly public */ var someCoolPublicInteger: Int<br>&gt;     }<br>&gt;     ...<br>&gt; }<br>&gt; Possible usage:<br>&gt; <br>&gt; - scrollViewInstance.contentOffset<br>&gt; + scrollViewInstance.content.offset<br>&gt; It should be possible to create multiple groups with the same/different access modfier and the same acess label:<br>&gt; <br>&gt; public struct B {<br>&gt;      <br>&gt;     public group labelName {<br>&gt;         var someVarName: Int<br>&gt;     }<br>&gt;          <br>&gt;     public group labelName {<br>&gt;         var someOtherVarName: String<br>&gt;     }<br>&gt;          <br>&gt;     internal group labelName {<br>&gt;         var _internalVarName: Double<br>&gt;     }<br>&gt; }<br>&gt; It should be possible to extend existing labeled groups.<br>&gt; <br>&gt; public struct C {<br>&gt;      <br>&gt;     public group labelName {<br>&gt;         var someVarName: Int<br>&gt;     }<br>&gt; }<br>&gt;      <br>&gt; public extension C {<br>&gt;      <br>&gt;     public group labelName {<br>&gt;         var computedProperty: Int { ... }<br>&gt;     }<br>&gt; }<br>&gt; Attributes aplied to a group will automatically be aplied to all members.<br>&gt; <br>&gt; public class D {<br>&gt;      <br>&gt;     public static group {<br>&gt;          <br>&gt;         // public static var<br>&gt;         var something: Int = 42<br>&gt;              <br>&gt;         // public static func<br>&gt;         func foo() { ... }<br>&gt;     }<br>&gt; }<br>&gt; Grammar<br>&gt; <br>&gt; declaration → group-declaration<br>&gt; <br>&gt; group-declaration → attributesopt access-level-modifier group group-body<br>&gt; <br>&gt; group-declaration → attributesopt access-level-modifieropt group group-name group-body<br>&gt; <br>&gt; group-name → identifier­<br>&gt; <br>&gt; group-body → { declarations }<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/511ba7f7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Post Swift 3] [Proposal] Introducing `group` mechanism</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>June 29, 2016 at 07:00:00pm</p></header><div class="content"><p>Am I understanding your feedback right that you’re in favor of this:<br></p><p>public class func member1() {}<br>public class func member2() {}<br>public class func member3() {}<br>public class func member4() {}<br>public class func member5() {}<br>Instead of:<br></p><p>public class group {<br></p><p>    func member1() {}<br>    func member2() {}<br>    func member3() {}<br>    func member4() {}<br>    func member5() {}<br>}<br>And you’re argument is ‘scrolling back’?<br></p><p>If so, I’d think that you’re logic would also apply to the default access modifier on extensions.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 29. Juni 2016 um 19:35:35, L. Mihalkovic (laurent.mihalkovic at gmail.com) schrieb:<br></p><p>-1 looks like a kludgy hack. <br>It will force people to have to scroll back to the declaration of a group (with no assistance to find where it is) in order to ascertain the visibility of a given method, while pushing code further to the right for every single method. Couple that with the zealous following of the 80c rules and that makes for a less than stellar coding experience... all in the name of not have to type a modifier.<br>Regards<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/02b9929b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Post Swift 3] [Proposal] Introducing `group` mechanism</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June 29, 2016 at 08:00:00pm</p></header><div class="content"><p>Regards<br>(From mobile)<br></p><p>&gt; On Jun 29, 2016, at 7:43 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Am I understanding your feedback right that you’re in favor of this:<br>&gt; <br>&gt; public class func member1() {}<br>&gt; public class func member2() {}<br>&gt; public class func member3() {}<br>&gt; public class func member4() {}<br>&gt; public class func member5() {}<br>&gt; Instead of:<br>&gt; <br>&gt; public class group {<br>&gt; <br>&gt;     func member1() {}<br>&gt;     func member2() {}<br>&gt;     func member3() {}<br>&gt;     func member4() {}<br>&gt;     func member5() {}<br>&gt; }<br>&gt; And you’re argument is ‘scrolling back’?<br>&gt; <br>No sure i understand your point here. The problem i see with this proposal is that what may look quaint with empty methods in an email will turn into a practicality nightmare with real code. If I recall, there was even a past argument from a core team member (chris?) about something different but alluding to a very similar lack-of-practicality-at-scale.<br></p><p>&gt; <br>&gt; Am 29. Juni 2016 um 19:35:35, L. Mihalkovic (laurent.mihalkovic at gmail.com) schrieb:<br>&gt; <br>&gt;&gt; -1 looks like a kludgy hack. <br>&gt;&gt; It will force people to have to scroll back to the declaration of a group (with no assistance to find where it is) in order to ascertain the visibility of a given method, while pushing code further to the right for every single method. Couple that with the zealous following of the 80c rules and that makes for a less than stellar coding experience... all in the name of not have to type a modifier.<br>&gt;&gt; Regards<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/f71782cb/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Post Swift 3] [Proposal] Introducing `group` mechanism</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>June 29, 2016 at 08:00:00pm</p></header><div class="content"><p>+1 what an argument! This doesn’t help here in any way.<br></p><p>If you think there must be a solution for the problem you mentioned in your first reply here, feel free to propose for no more implicit access modifier.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 29. Juni 2016 um 20:24:26, L. Mihalkovic (laurent.mihalkovic at gmail.com) schrieb:<br></p><p>If I recall, there was even a past argument from a core team member (chris?) about something different but alluding to a very similar lack-of-practicality-at-scale.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/e59a66ea/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d9dbc0dfeb74eab8dd9bbd9cbd84680?s=50"></div><header><strong>[Post Swift 3] [Proposal] Introducing `group` mechanism</strong> from <string>Jose Cheyo Jimenez</string> &lt;cheyo at masters3d.com&gt;<p>June 29, 2016 at 10:00:00pm</p></header><div class="content"><p>You are being apprehensive about this. We all want grouping of access modifiers just like c++ has but what you are proposing doesn&#39;t seem to be a clear win. In fact I would much rather have plain c++ groupings than group{}.<br></p><p>Could you also &quot;replay all&quot; not just the evolution list? It makes it hard to follow threads. <br></p><p>-1 from me as well, sorry. You should bring this additive change up again for discussion in August though. <br></p><p><br>&gt; On Jun 29, 2016, at 11:43 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1 what an argument! This doesn’t help here in any way.<br>&gt; <br>&gt; If you think there must be a solution for the problem you mentioned in your first reply here, feel free to propose for no more implicit access modifier.<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Am 29. Juni 2016 um 20:24:26, L. Mihalkovic (laurent.mihalkovic at gmail.com) schrieb:<br>&gt; <br>&gt;&gt; If I recall, there was even a past argument from a core team member (chris?) about something different but alluding to a very similar lack-of-practicality-at-scale.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/2669d82c/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Post Swift 3] [Proposal] Introducing `group` mechanism</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>June 29, 2016 at 08:00:00pm</p></header><div class="content"><p>Looking at how c++ has a similar access modifier indent mechanism I’m still wondering if you’d argue about scrolling there.<br></p><p>with no assistance to find where it is<br>An assistant isn’t something the language solves for you. This is a different talk about the IDE. Grab some stdlib or foundation code and look at the filename and the code inside the file. The file might not contain only a single type equal to the filename. Also if there is another huge type present and you have a small display and currently looking at some specific member in the middle of that that type, which assistance have to find out the type of that member? Here we go again: you’re own assistant will your own negative argument ‘scrolling’.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/34785ece/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Post Swift 3] [Proposal] Introducing `group` mechanism</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>June 29, 2016 at 08:00:00pm</p></header><div class="content"><p>I can’t resist I’ve got a third argument for your ‘scrolling’: Grab a huge protocol that does not fit on your screen, which assistance do you have to get its access modifier?<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 29. Juni 2016 um 20:03:31, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br></p><p>Looking at how c++ has a similar access modifier indent mechanism I’m still wondering if you’d argue about scrolling there.<br></p><p>with no assistance to find where it is<br>An assistant isn’t something the language solves for you. This is a different talk about the IDE. Grab some stdlib or foundation code and look at the filename and the code inside the file. The file might not contain only a single type equal to the filename. Also if there is another huge type present and you have a small display and currently looking at some specific member in the middle of that that type, which assistance have to find out the type of that member? Here we go again: you’re own assistant will your own negative argument ‘scrolling’.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/a31db449/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Post Swift 3] [Proposal] Introducing `group` mechanism</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 29, 2016 at 01:00:00pm</p></header><div class="content"><p>-1 from me as well. As mentioned before, submodules will require their own<br>extensive discussion and is another matter entirely from grouping access<br>modifiers. These two topics don&#39;t really share anything in common other<br>than that they are units of code. I have a hard time subscribing to the<br>idea that an issue as broad as submodules should be solved with a syntax<br>that simply means &quot;this is an arbitrary unit of code&quot;.<br></p><p>On Wed, Jun 29, 2016 at 1:16 PM, Adrian Zubarev via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I can’t resist I’ve got a third argument for your ‘scrolling’: Grab a huge<br>&gt; protocol that does not fit on your screen, which assistance do you have to<br>&gt; get its access modifier?<br>&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt;<br>&gt; Am 29. Juni 2016 um 20:03:31, Adrian Zubarev (<br>&gt; adrian.zubarev at devandartist.com) schrieb:<br>&gt;<br>&gt; Looking at how c++ has a similar access modifier indent mechanism I’m<br>&gt; still wondering if you’d argue about scrolling there.<br>&gt;<br>&gt; with no assistance to find where it is<br>&gt;<br>&gt; An assistant isn’t something the language solves for you. This is a<br>&gt; different talk about the IDE. Grab some stdlib or foundation code and look<br>&gt; at the filename and the code inside the file. The file might not contain<br>&gt; only a single type equal to the filename. Also if there is another huge<br>&gt; type present and you have a small display and currently looking at some<br>&gt; specific member in the middle of that that type, which assistance have to<br>&gt; find out the type of that member? Here we go again: you’re own assistant<br>&gt; will your own negative argument ‘scrolling’.<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/5e1c166f/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Post Swift 3] [Proposal] Introducing `group` mechanism</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June 29, 2016 at 08:00:00pm</p></header><div class="content"><p>Regards<br>(From mobile)<br></p><p>&gt; On Jun 29, 2016, at 8:16 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I can’t resist I’ve got a third argument for your ‘scrolling’: Grab a huge protocol that does not fit on your screen, which assistance do you have to get its access modifier?<br>&gt; <br></p><p>Is this argument a translation for &quot;look, the problem already exists, so it should really not matter that we make it worse&quot;? <br></p><p>&gt; <br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Am 29. Juni 2016 um 20:03:31, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br>&gt; <br>&gt;&gt; Looking at how c++ has a similar access modifier indent mechanism I’m still wondering if you’d argue about scrolling there.<br>&gt;&gt; <br>&gt;&gt; with no assistance to find where it is<br>&gt;&gt; An assistant isn’t something the language solves for you. This is a different talk about the IDE. Grab some stdlib or foundation code and look at the filename and the code inside the file. The file might not contain only a single type equal to the filename. Also if there is another huge type present and you have a small display and currently looking at some specific member in the middle of that that type, which assistance have to find out the type of that member? Here we go again: you’re own assistant will your own negative argument ‘scrolling’.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Adrian Zubarev<br>&gt;&gt; Sent with Airmail<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/b6b27eeb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Post Swift 3] [Proposal] Introducing `group` mechanism</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>June 29, 2016 at 08:00:00pm</p></header><div class="content"><p>How is this worse? Your argument about scrolling is just ridiculous. I can repeat myself but this time you could look a some current extension without any conformances. If all members don’t override the default access modifier you’ll end up in the same situation. Your argument is about the lack of an assistant to see some information about a member, which is indeed not present in the model of a group, but it also isn’t in protocols and in some extensions.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 29. Juni 2016 um 20:32:01, L. Mihalkovic (laurent.mihalkovic at gmail.com) schrieb:<br></p><p>Is this argument a translation for &quot;look, the problem already exists, so it should really not matter that we make it worse&quot;? <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/dc14fa50/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Post Swift 3] [Proposal] Introducing `group` mechanism</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June 30, 2016 at 06:00:00am</p></header><div class="content"><p>Regards<br>(From mobile)<br></p><p>&gt; On Jun 29, 2016, at 8:39 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; How is this worse? Your argument about scrolling is just ridiculous.<br>&gt; <br></p><p>Look you may want to consider your language... did i call the proposal ridiculous? I could have ... The fact that you do not seem to understand or agree with something does not change its validity. I find the proposal highly impractical when considered at scale and truly hope it does not make it into the language.<br></p><p>&gt; I can repeat myself but this time you could look a some current extension without any conformances. If all members don’t override the default access modifier you’ll end up in the same situation. Your argument is about the lack of an assistant to see some information about a member, which is indeed not present in the model of a group, but it also isn’t in protocols and in some extensions.<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Am 29. Juni 2016 um 20:32:01, L. Mihalkovic (laurent.mihalkovic at gmail.com) schrieb:<br>&gt; <br>&gt;&gt; Is this argument a translation for &quot;look, the problem already exists, so it should really not matter that we make it worse&quot;? <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/f263819c/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Post Swift 3] [Proposal] Introducing `group` mechanism</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>June 29, 2016 at 04:00:00pm</p></header><div class="content"><p>Speaking of C++, is the “group” keyword even necessary? To borrow your own example from earlier, it seems like we could just as easily say this:<br>public struct A {<br>    public { // all public<br>        func member1() {}<br>        func member2() {}<br>        func member3() {}<br>    }<br>    public labelName {// all public, accessible under `foo.lableName`<br>        func member4() {}<br>        func member5() {}<br>        func member6() {}<br>    }<br>}<br>(which is not C++’s syntax, I know… the comment just got me thinking about it is all)<br></p><p>- Dave Sweeris<br></p><p>&gt; On Jun 29, 2016, at 1:03 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Looking at how c++ has a similar access modifier indent mechanism I’m still wondering if you’d argue about scrolling there.<br>&gt; <br>&gt; with no assistance to find where it is<br>&gt; An assistant isn’t something the language solves for you. This is a different talk about the IDE. Grab some stdlib or foundation code and look at the filename and the code inside the file. The file might not contain only a single type equal to the filename. Also if there is another huge type present and you have a small display and currently looking at some specific member in the middle of that that type, which assistance have to find out the type of that member? Here we go again: you’re own assistant will your own negative argument ‘scrolling’.<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/771152ea/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Post Swift 3] [Proposal] Introducing `group` mechanism</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June 30, 2016 at 07:00:00am</p></header><div class="content"><p>Comparing with c++ is interesting... Do you remember that when u look at the implementation, the modifier is on every single method, so that when looking at a single page of code u do not have to go far to be reminded of the signature of what you are modifying... additionally, because the impl is separate, the code does not have to float 2 tabs away fromthe left margin (not to mention that in c++ we tend to favor 2 spaces indentations). Altogether the c++ has a more viable set of compromises than this proposal offers.<br>Regards<br>(From mobile)<br></p><p>&gt; On Jun 29, 2016, at 11:41 PM, David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Speaking of C++, is the “group” keyword even necessary? To borrow your own example from earlier, it seems like we could just as easily say this:<br>&gt; public struct A {<br>&gt;     public { // all public<br>&gt;         func member1() {}<br>&gt;         func member2() {}<br>&gt;         func member3() {}<br>&gt;     }<br>&gt;     public labelName {// all public, accessible under `foo.lableName`<br>&gt;         func member4() {}<br>&gt;         func member5() {}<br>&gt;         func member6() {}<br>&gt;     }<br>&gt; }<br>&gt; (which is not C++’s syntax, I know… the comment just got me thinking about it is all)<br>&gt; <br>&gt; - Dave Sweeris<br>&gt; <br>&gt;&gt; On Jun 29, 2016, at 1:03 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Looking at how c++ has a similar access modifier indent mechanism I’m still wondering if you’d argue about scrolling there.<br>&gt;&gt; <br>&gt;&gt; with no assistance to find where it is<br>&gt;&gt; An assistant isn’t something the language solves for you. This is a different talk about the IDE. Grab some stdlib or foundation code and look at the filename and the code inside the file. The file might not contain only a single type equal to the filename. Also if there is another huge type present and you have a small display and currently looking at some specific member in the middle of that that type, which assistance have to find out the type of that member? Here we go again: you’re own assistant will your own negative argument ‘scrolling’.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Adrian Zubarev<br>&gt;&gt; Sent with Airmail<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/e9e2037f/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Post Swift 3] [Proposal] Introducing `group` mechanism</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>June 30, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On 29 Jun 2016, at 22:41, David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Speaking of C++, is the “group” keyword even necessary? To borrow your own example from earlier, it seems like we could just as easily say this:<br>&gt; public struct A {<br>&gt;     public { // all public<br>&gt;         func member1() {}<br>&gt;         func member2() {}<br>&gt;         func member3() {}<br>&gt;     }<br>&gt;     public labelName {// all public, accessible under `foo.lableName`<br>&gt;         func member4() {}<br>&gt;         func member5() {}<br>&gt;         func member6() {}<br>&gt;     }<br>&gt; }<br>&gt; (which is not C++’s syntax, I know… the comment just got me thinking about it is all)<br>&gt; <br>&gt; - Dave Sweeris<br></p><p>This form is interesting, but personally when it comes to grouping I&#39;ve become a huge fan of using focused extensions, meaning my type declarations are usually nothing but the bare minimum definition for stored properties and required constructors, everything else goes into the most relevant extension.<br></p><p>As such it seems to me like this feature request could be handled by two features; named extensions, and access modifiers on extensions, so I could do something like so:<br></p><p>	public struct A { … }<br></p><p>	// My awesome labelName implementation<br>	public extension A.labelName {<br>		func member4() { … }<br>		func member5() { … }<br>		func member6() { … }<br>	}<br></p><p>Here the public modifier changes the default for functions without a modifier of their own, purely for convenience (as they can still be overridden if I need a private method to implement them) and the label lets me organise them under the parent type. Multiple such extensions could be specified for the same label, with their own default access and/or type constraints.<br></p><p>So yeah, grouping is handy, but I think that extensions already provide a good way to achieve this, and it would make more sense to focus any additions onto them.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/d4a1d3ad/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Post Swift 3] [Proposal] Introducing `group` mechanism</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>June 30, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On 30 Jun 2016, at 11:04, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This form is interesting, but personally when it comes to grouping I&#39;ve become a huge fan of using focused extensions, meaning my type declarations are usually nothing but the bare minimum definition for stored properties and required constructors, everything else goes into the most relevant extension.<br>&gt; <br>&gt; As such it seems to me like this feature request could be handled by two features; named extensions, and access modifiers on extensions, so I could do something like so:<br>&gt; <br>&gt; 	public struct A { … }<br>&gt; <br>&gt; 	// My awesome labelName implementation<br>&gt; 	public extension A.labelName {<br>&gt; 		func member4() { … }<br>&gt; 		func member5() { … }<br>&gt; 		func member6() { … }<br>&gt; 	}<br>&gt; <br>&gt; Here the public modifier changes the default for functions without a modifier of their own, purely for convenience (as they can still be overridden if I need a private method to implement them) and the label lets me organise them under the parent type. Multiple such extensions could be specified for the same label, with their own default access and/or type constraints.<br>&gt; <br>&gt; So yeah, grouping is handy, but I think that extensions already provide a good way to achieve this, and it would make more sense to focus any additions onto them.<br></p><p>Sorry for the immediate followup, but somehow I forgot that we can already have access modifiers on extensions for setting the default, so really all that&#39;s needed to meet the remaining needs of the proposal seems to be named extensions. I seem to recall a proposal for this may already exist but can&#39;t find it, anyone remember and have a link handy?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/157070f0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Post Swift 3] [Proposal] Introducing `group` mechanism</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 30, 2016 at 07:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jun 30, 2016, at 5:10 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 30 Jun 2016, at 11:04, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This form is interesting, but personally when it comes to grouping I&#39;ve become a huge fan of using focused extensions, meaning my type declarations are usually nothing but the bare minimum definition for stored properties and required constructors, everything else goes into the most relevant extension.<br>&gt;&gt; <br>&gt;&gt; As such it seems to me like this feature request could be handled by two features; named extensions, and access modifiers on extensions, so I could do something like so:<br>&gt;&gt; <br>&gt;&gt; 	public struct A { … }<br>&gt;&gt; <br>&gt;&gt; 	// My awesome labelName implementation<br>&gt;&gt; 	public extension A.labelName {<br>&gt;&gt; 		func member4() { … }<br>&gt;&gt; 		func member5() { … }<br>&gt;&gt; 		func member6() { … }<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; Here the public modifier changes the default for functions without a modifier of their own, purely for convenience (as they can still be overridden if I need a private method to implement them) and the label lets me organise them under the parent type. Multiple such extensions could be specified for the same label, with their own default access and/or type constraints.<br>&gt;&gt; <br>&gt;&gt; So yeah, grouping is handy, but I think that extensions already provide a good way to achieve this, and it would make more sense to focus any additions onto them.<br>&gt; <br>&gt; Sorry for the immediate followup, but somehow I forgot that we can already have access modifiers on extensions for setting the default, so really all that&#39;s needed to meet the remaining needs of the proposal seems to be named extensions. I seem to recall a proposal for this may already exist but can&#39;t find it, anyone remember and have a link handy?<br></p><p>There is no specific proposal for naming extensions because there is nothing gained by just giving them a name.  However, named extensions have been discussed in the context of other features such as allowing extensions to have stored properties.  This is discussed in the appendix of the partial initializer proposal I started but tabled until after Swift 3: https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md.  You can find some discussion in the list archive during the early to mid January timeframe. <br></p><p>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/49a1530d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>[Post Swift 3] [Proposal] Introducing `group` mechanism</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>June 30, 2016 at 09:00:00am</p></header><div class="content"><p>I also floated this idea awhile back too: http://article.gmane.org/gmane.comp.lang.swift.evolution/17289<br></p><p>Obviously this kind of thing is out of scope for Swift 3<br></p><p>Brandon <br></p><p>Sent from my iPad<br></p><p>&gt; On Jun 30, 2016, at 8:14 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt;&gt; On Jun 30, 2016, at 5:10 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 30 Jun 2016, at 11:04, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This form is interesting, but personally when it comes to grouping I&#39;ve become a huge fan of using focused extensions, meaning my type declarations are usually nothing but the bare minimum definition for stored properties and required constructors, everything else goes into the most relevant extension.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As such it seems to me like this feature request could be handled by two features; named extensions, and access modifiers on extensions, so I could do something like so:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	public struct A { … }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	// My awesome labelName implementation<br>&gt;&gt;&gt; 	public extension A.labelName {<br>&gt;&gt;&gt; 		func member4() { … }<br>&gt;&gt;&gt; 		func member5() { … }<br>&gt;&gt;&gt; 		func member6() { … }<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here the public modifier changes the default for functions without a modifier of their own, purely for convenience (as they can still be overridden if I need a private method to implement them) and the label lets me organise them under the parent type. Multiple such extensions could be specified for the same label, with their own default access and/or type constraints.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So yeah, grouping is handy, but I think that extensions already provide a good way to achieve this, and it would make more sense to focus any additions onto them.<br>&gt;&gt; <br>&gt;&gt; Sorry for the immediate followup, but somehow I forgot that we can already have access modifiers on extensions for setting the default, so really all that&#39;s needed to meet the remaining needs of the proposal seems to be named extensions. I seem to recall a proposal for this may already exist but can&#39;t find it, anyone remember and have a link handy?<br>&gt; <br>&gt; There is no specific proposal for naming extensions because there is nothing gained by just giving them a name.  However, named extensions have been discussed in the context of other features such as allowing extensions to have stored properties.  This is discussed in the appendix of the partial initializer proposal I started but tabled until after Swift 3: https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md.  You can find some discussion in the list archive during the early to mid January timeframe. <br>&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/7a974aa1/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
