<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Stdlib closure argument labels and parameter names</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June 20, 2016 at 02:00:00pm</p></header><div class="content"><p>Hi All,<br></p><p>A couple of weeks ago we started to notice that we had some poorly-named<br>closure parameters and argument labels in the standard library, so we<br>did a complete audit of the standard library&#39;s APIs and came up with a<br>preliminary proposal for changes, which we applied in a branch and you<br>can review in https://github.com/apple/swift/pull/2981.  Let&#39;s please<br>carry on further discussion here rather than in the pull request, though.<br></p><p>I&#39;ll be submitting a formal proposal for review this week but wanted to<br>give people a chance to weigh in on some of the changes first.  I view<br>this step as a necessary one before taking up Patrick Pijnappel&#39;s<br>proposal for renaming functional algorithms:<br>http://news.gmane.org/find-root.php?message_id=CAKA%3djdbxiC%5fq0Fe%3dXc%3dmSWu7OtGxMgAQyb0QMA6%5fOaiiLB3foA%40mail.gmail.com<br></p><p>Thanks,<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Stdlib closure argument labels and parameter names</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June 20, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; A couple of weeks ago we started to notice that we had some poorly-named<br>&gt; closure parameters and argument labels in the standard library, so we<br>&gt; did a complete audit of the standard library&#39;s APIs and came up with a<br>&gt; preliminary proposal for changes, which we applied in a branch and you<br>&gt; can review in https://github.com/apple/swift/pull/2981.  Let&#39;s please<br>&gt; carry on further discussion here rather than in the pull request, though.<br></p><p>In general, I like this; `orderingBy` is a particularly nice improvement over the old `isOrderedBefore` convention. A few specific comments about things I don&#39;t like:<br></p><p>* In `map` and `flatMap`, I&#39;m not sure how much `transform` buys us over `elementTransform`.<br></p><p>* In general, I&#39;m not a fan of most of the changes away from `where` labels. Those are a nice, straightforward convention applied broadly across the Sequence APIs. (Yes, I criticized `where` as a method name in another thread, but I don&#39;t think `where` is a problem when there&#39;s a function base name to give it context.) When they don&#39;t work, that&#39;s usually because of a less-than-ideal base name. I&#39;m not saying that *all* base names that aren&#39;t compatible with `where` should be changed, but rather that if `where` is not enough, that&#39;s an API smell.<br></p><p>* In particular, `elementWhere` is not a good label for the same reason that `removeElement` is not a good name. Session 403 last week actually talked about this between roughly minutes 8 and 11. (I&#39;m sure you know about its content; you probably saw it before we did.)<br></p><p>* I like `separatedWhere` on `split`, but I think the Equatable version needs a similar renaming. Perhaps `separatedBy`? `separatedOn`? The usual opposite of `where`, `of`, doesn&#39;t work here. (Alternatively, `separatedWhere` could be `separatorWhere` instead, but that&#39;s not quite as elegant.)<br></p><p>* I&#39;m very uncomfortable with the amount of weight `accumulatingResultBy` adds to `reduce`. `combinedBy` seems perfectly cromulent to me. I&#39;m even more concerned by your suggestion in the pull request body of `accumulating(startingFrom:combiningBy:)`. `reduce` is a subtle and slightly confusing operation; adding more words to its call sites will not solve that problem. If you want to invent a new name from whole cloth, I would probably use something like `combining(with initialResult: T, by nextResult: (T, Element) -&gt; T)`. (For that matter, while we&#39;re working in this area, `sequence(first:next:)` could use a similar coat of paint.)<br></p><p>* I agree with the comment on GitHub that `invoke` should be `execute`. If you see a distinction between the two cases on the number of arguments, I would then suggest `passTo` as the label on these methods: `views.forEach(passTo: addSubview)`, `withUnsafeBufferPointer(&amp;bytes, passTo: Data.init(buffer:))`.<br></p><p>* It&#39;s a little odd that you&#39;re using `comparingBy` for `Equatable` and `orderingBy` for `Comparable`. Did you judge `equatingBy` to be too awkward? Perhaps the real problem is that `Equatable` ought to be `Comparable` and `Comparable` ought to be `Orderable`? Or maybe `comparingBy` should just be something more general, like `matchingBy`? That would make perfectly sensible but slightly odd use cases like this one read better:<br></p><p>	let isAnIdiot = luggageCombination.starts(with: [1, 2, 3, 4, 5], matchingBy: &lt;=)	// Matches [1,2,3,4,5], but also [1,1,1,1,1], [1,2,3,2,1], etc.<br></p><p>Very soon (hopefully), I will be posting an early draft of a proposal renaming the various first/last/prefix/suffix/etc. APIs. I believe the only place it touches on your proposal is in `starts(with:isEquivalent:)`, but I think your changes to the second parameter label can be easily incorporated into what I&#39;m doing.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>Stdlib closure argument labels and parameter names</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>June 21, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On 21 Jun 2016, at 01:52, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; * I&#39;m very uncomfortable with the amount of weight `accumulatingResultBy` adds to `reduce`. `combinedBy` seems perfectly cromulent to me. I&#39;m even more concerned by your suggestion in the pull request body of `accumulating(startingFrom:combiningBy:)`. `reduce` is a subtle and slightly confusing operation; adding more words to its call sites will not solve that problem. If you want to invent a new name from whole cloth, I would probably use something like `combining(with initialResult: T, by nextResult: (T, Element) -&gt; T)`. (For that matter, while we&#39;re working in this area, `sequence(first:next:)` could use a similar coat of paint.)<br></p><p>Didn’t have time to give it a thorough read, but `accumulatingResultBy` did stand out negatively for me as being a bit too verbose.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160621/9449fb6c/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Stdlib closure argument labels and parameter names</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>June 22, 2016 at 08:00:00pm</p></header><div class="content"><p>On Jun 20, 2016, at 3:25 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Hi All,<br>&gt; <br>&gt; A couple of weeks ago we started to notice that we had some poorly-named<br>&gt; closure parameters and argument labels in the standard library, so we<br>&gt; did a complete audit of the standard library&#39;s APIs and came up with a<br>&gt; preliminary proposal for changes, which we applied in a branch and you<br>&gt; can review in https://github.com/apple/swift/pull/2981.  Let&#39;s please<br>&gt; carry on further discussion here rather than in the pull request, though.<br></p><p>-  /// - `isEquivalent(a, a)` is always `true`. (Reflexivity)<br> -  /// - `isEquivalent(a, b)` implies `isEquivalent(b, a)`. (Symmetry)<br> -  /// - If `isEquivalent(a, b)` and `isEquivalent(b, c)` are both `true`, then<br> -  ///   `isEquivalent(a, c)` is also `true`. (Transitivity)<br> +  /// - `areEquivalent(a, a)` is always `true`. (Reflexivity)<br> +  /// - `areEquivalent(a, b)` implies `areEquivalent(b, a)`. (Symmetry)<br> +  /// - If `areEquivalent(a, b)` and `areEquivalent(b, c)` are both `true`, then<br> +  ///   `areEquivalent(a, c)` is also `true`. (Transitivity)<br></p><p>I like this change!<br></p><p>-    func forEach&lt;S: SequenceType&gt;(_ body: (S.Iterator.Element) -&gt; ())<br>+    func forEach&lt;S: SequenceType&gt;(invoke body: (S.Iterator.Element) -&gt; ())<br></p><p>Adding an external label makes sense here. This is a procedural call and<br>using it within the parens should have a &quot;code ripple&quot;.<br></p><p>That said, would prefer `do` or `perform` over `invoke` or `invoking` as in<br>`runRaceTest`, `_forAllPermutationsImpl`, `expectFailure`, etc. This also applies<br>where there&#39;s a `body` label instead of an empty external label.<br></p><p>-public func withInvalidOrderings(_ body: ((Int, Int) -&gt; Bool) -&gt; Void) {<br>+public func withInvalidOrderings(invoke body: ((Int, Int) -&gt; Bool) -&gt; Void) {<br></p><p>For any with/external label pair, I&#39;d prefer `with-do` or `with-perform` <br>over `with-invoke`.<br></p><p>-  return IteratorSequence(it).reduce(initial, combine: f)<br>+  return IteratorSequence(it).reduce(initial, accumulatingBy: f)<br></p><p>For `reduce`, I&#39;d prefer `applying:` or `byApplying:`<br></p><p>Similarly in `starts(with:comparingBy:)`, I&#39;d prefer byComparing`,<br>min/max, byOrdering<br></p><p>-      ).encode(encoding, output: output)<br>+      ).encode(encoding, sendingOutputTo: processCodeUnit)<br></p><p>How about `exportingTo`?<br></p><p><br>-  tempwords.sort(isOrderedBefore: &lt;)<br>+  tempwords.sort(orderingBy: &lt;)<br></p><p>With `sort` and `sorted`, I&#39;d prefer `by:`<br></p><p>-  if !expected.elementsEqual(actual, isEquivalent: sameValue) {<br>+  if !expected.elementsEqual(actual, comparingBy: sameValue) {<br></p><p>I&#39;m torn on this one. I don&#39;t like but I don&#39;t have a good solution.<br></p><p>-  /// for which `predicate(x) == true`.<br>+  /// for which `isIncluded(x) == true`.<br>-      _base: base.makeIterator(), whereElementsSatisfy: _include)<br>+      _base: base.makeIterator(), suchThat: _include)<br></p><p>How about simply `include` for both? I get the `is` desire but it&#39;s being tossed away<br>in a lot of other places in this diff. and `suchThat` feels out of place.<br></p><p>-      || u16.contains({ $0 &gt; 127 || _isspace_clocale($0) }) {<br>+    || u16.contains(elementWhere: { $0 &gt; 127 || _isspace_clocale($0) }) {<br></p><p>I assume the challenge here is differentiating contains(element) from contains(closure).<br>This feels predicate-y, which is why I put it near the predicates. But I think something<br>like `containsElement(where:)` works better.<br></p><p> -    let result = try base._withUnsafeMutableBufferPointerIfSupported(body)<br>+    let result = try base._withUnsafeMutableBufferPointerIfSupported(invoke: body)<br></p><p>I hate &quot;ifSupported&quot; but that&#39;s another discussion (withSupportedUnsafeMutableBufferPointer,<br>withAvailableUnsafeMutableBufferPointer, it&#39;s all lipstick)<br></p><p>This is procedural, so `do` or `perform` rather than `invoke`<br></p><p>-      for test in removeFirstTests.filter({ $0.numberToRemove == 1 }) {<br>+      for test in removeFirstTests.filter(<br>+        suchThat: { $0.numberToRemove == 1 }<br></p><p>The difference between `filter` and `forEach` is that `forEach` is explicitly <br>procedural while `filter` is functional.  I do not like functional chainable<br>calls being modified to use explicit external labels in this way. <br></p><p>I&#39;d prefer no label here.<br></p><p>public func split(<br>      maxSplits: Int = Int.max,<br>      omittingEmptySubsequences: Bool = true,<br>-    isSeparator: @noescape (Base.Iterator.Element) throws -&gt; Bool<br>+    separatedWhere isSeparator: @noescape (Base.Iterator.Element) throws -&gt; Bool<br></p><p>I&#39;m torn on this one. It&#39;s not the worst ever but something more like where/at/when<br>makes more sense to me than &quot;separatedWhere/separatedAt/separatedWhen&quot;.<br></p><p>+      count: __manager._headerPointer.pointee.count)<br></p><p>For the sake of Zippy the Pinhead, surely there has to be something better than `pointee`.<br>Like...`reference`?<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160622/ce404f44/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Stdlib closure argument labels and parameter names</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 23, 2016 at 02:00:00am</p></header><div class="content"><p>Let&#39;s not go through more churn with `pointee`. It&#39;s already just been<br>changed from `memory`.<br>On Wed, Jun 22, 2016 at 21:02 Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Jun 20, 2016, at 3:25 PM, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt;<br>&gt; Hi All,<br>&gt;<br>&gt; A couple of weeks ago we started to notice that we had some poorly-named<br>&gt; closure parameters and argument labels in the standard library, so we<br>&gt; did a complete audit of the standard library&#39;s APIs and came up with a<br>&gt; preliminary proposal for changes, which we applied in a branch and you<br>&gt; can review in https://github.com/apple/swift/pull/2981.  Let&#39;s please<br>&gt; carry on further discussion here rather than in the pull request, though.<br>&gt;<br>&gt;<br>&gt; *-  /// - `isEquivalent(a, a)` is always `true`. (Reflexivity)*<br>&gt; * -  /// - `isEquivalent(a, b)` implies `isEquivalent(b, a)`. (Symmetry)*<br>&gt; * -  /// - If `isEquivalent(a, b)` and `isEquivalent(b, c)` are both<br>&gt; `true`, then*<br>&gt; * -  ///   `isEquivalent(a, c)` is also `true`. (Transitivity)*<br>&gt; * +  /// - `areEquivalent(a, a)` is always `true`. (Reflexivity)*<br>&gt; * +  /// - `areEquivalent(a, b)` implies `areEquivalent(b, a)`. (Symmetry)*<br>&gt; * +  /// - If `areEquivalent(a, b)` and `areEquivalent(b, c)` are both<br>&gt; `true`, then*<br>&gt; * +  ///   `areEquivalent(a, c)` is also `true`. (Transitivity)*<br>&gt;<br>&gt; I like this change!<br>&gt;<br>&gt; *-    func forEach&lt;S: SequenceType&gt;(_ body: (S.Iterator.Element) -&gt; ())*<br>&gt; *+    func forEach&lt;S: SequenceType&gt;(invoke body: (S.Iterator.Element) -&gt;<br>&gt; ())*<br>&gt;<br>&gt; Adding an external label makes sense here. This is a procedural call and<br>&gt; using it within the parens should have a &quot;code ripple&quot;.<br>&gt;<br>&gt; That said, would prefer `do` or `perform` over `invoke` or `invoking` as in<br>&gt; `runRaceTest`, `_forAllPermutationsImpl`, `expectFailure`, etc. This also<br>&gt; applies<br>&gt; where there&#39;s a `body` label instead of an empty external label.<br>&gt;<br>&gt; *-public func withInvalidOrderings(_ body: ((Int, Int) -&gt; Bool) -&gt; Void) {*<br>&gt; *+public func withInvalidOrderings(invoke body: ((Int, Int) -&gt; Bool) -&gt;<br>&gt; Void) {*<br>&gt;<br>&gt; For any with/external label pair, I&#39;d prefer `with-do` or `with-perform`<br>&gt; over `with-invoke`.<br>&gt;<br>&gt; *-  return IteratorSequence(it).reduce(initial, combine: f)*<br>&gt; *+  return IteratorSequence(it).reduce(initial, accumulatingBy: f)*<br>&gt;<br>&gt; For `reduce`, I&#39;d prefer `applying:` or `byApplying:`<br>&gt;<br>&gt; Similarly in `starts(with:comparingBy:)`, I&#39;d prefer byComparing`,<br>&gt; min/max, byOrdering<br>&gt;<br>&gt; *-      ).encode(encoding, output: output)*<br>&gt; *+      ).encode(encoding, sendingOutputTo: processCodeUnit)*<br>&gt;<br>&gt; How about `exportingTo`?<br>&gt;<br>&gt;<br>&gt; *-  tempwords.sort(isOrderedBefore: &lt;)*<br>&gt; *+  tempwords.sort(orderingBy: &lt;)*<br>&gt;<br>&gt; With `sort` and `sorted`, I&#39;d prefer `by:`<br>&gt;<br>&gt; *-  if !expected.elementsEqual(actual, isEquivalent: sameValue) {*<br>&gt; *+  if !expected.elementsEqual(actual, comparingBy: sameValue) {*<br>&gt;<br>&gt; I&#39;m torn on this one. I don&#39;t like but I don&#39;t have a good solution.<br>&gt;<br>&gt; *-  /// for which `predicate(x) == true`.*<br>&gt; *+  /// for which `isIncluded(x) == true`.*<br>&gt; *-      _base: base.makeIterator(), whereElementsSatisfy: _include)*<br>&gt; *+      _base: base.makeIterator(), suchThat: _include)*<br>&gt;<br>&gt; How about simply `include` for both? I get the `is` desire but it&#39;s being<br>&gt; tossed away<br>&gt; in a lot of other places in this diff. and `suchThat` feels out of place.<br>&gt;<br>&gt; *-      || u16.contains({ $0 &gt; 127 || _isspace_clocale($0) }) {*<br>&gt; *+    || u16.contains(elementWhere: { $0 &gt; 127 || _isspace_clocale($0) })<br>&gt; {*<br>&gt;<br>&gt; I assume the challenge here is differentiating contains(element) from<br>&gt; contains(closure).<br>&gt; This feels predicate-y, which is why I put it near the predicates. But I<br>&gt; think something<br>&gt; like `containsElement(where:)` works better.<br>&gt;<br>&gt; * -    let result = try<br>&gt; base._withUnsafeMutableBufferPointerIfSupported(body)*<br>&gt; *+    let result = try<br>&gt; base._withUnsafeMutableBufferPointerIfSupported(invoke: body)*<br>&gt;<br>&gt; I hate &quot;ifSupported&quot; but that&#39;s another discussion<br>&gt; (withSupportedUnsafeMutableBufferPointer,<br>&gt; withAvailableUnsafeMutableBufferPointer, it&#39;s all lipstick)<br>&gt;<br>&gt; This is procedural, so `do` or `perform` rather than `invoke`<br>&gt;<br>&gt; *-      for test in removeFirstTests.filter({ $0.numberToRemove == 1 }) {*<br>&gt; *+      for test in removeFirstTests.filter(*<br>&gt; *+        suchThat: { $0.numberToRemove == 1 }*<br>&gt;<br>&gt; The difference between `filter` and `forEach` is that `forEach` is<br>&gt; explicitly<br>&gt; procedural while `filter` is functional.  I do not like functional<br>&gt; chainable<br>&gt; calls being modified to use explicit external labels in this way.<br>&gt;<br>&gt; I&#39;d prefer no label here.<br>&gt;<br>&gt; *public func split(*<br>&gt; *      maxSplits: Int = Int.max,*<br>&gt; *      omittingEmptySubsequences: Bool = true,*<br>&gt; *-    isSeparator: @noescape (Base.Iterator.Element) throws -&gt; Bool*<br>&gt; *+    separatedWhere isSeparator: @noescape (Base.Iterator.Element) throws<br>&gt; -&gt; Bool*<br>&gt;<br>&gt; I&#39;m torn on this one. It&#39;s not the worst ever but something more like<br>&gt; where/at/when<br>&gt; makes more sense to me than &quot;separatedWhere/separatedAt/separatedWhen&quot;.<br>&gt;<br>&gt; *+      count: __manager._headerPointer.pointee.count)*<br>&gt;<br>&gt; For the sake of Zippy the Pinhead, surely there has to be something better<br>&gt; than `pointee`.<br>&gt; Like...`reference`?<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/214a8337/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>Stdlib closure argument labels and parameter names</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>June 23, 2016 at 08:00:00am</p></header><div class="content"><p>I did not pay a lot of attention to this renaming because I thought the trailing closure syntax would shield me from labels. But I forgot that in if/for/while statements, I’m going to be forced to use them. In those cases, I’d prefer more succinct labels.<br></p><p>I added some comments inline where I have issues with the new labels:<br></p><p>&gt; On 23 Jun 2016, at 04:02, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Jun 20, 2016, at 3:25 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Hi All,<br>&gt;&gt; <br>&gt;&gt; A couple of weeks ago we started to notice that we had some poorly-named<br>&gt;&gt; closure parameters and argument labels in the standard library, so we<br>&gt;&gt; did a complete audit of the standard library&#39;s APIs and came up with a<br>&gt;&gt; preliminary proposal for changes, which we applied in a branch and you<br>&gt;&gt; can review in https://github.com/apple/swift/pull/2981 &lt;https://github.com/apple/swift/pull/2981&gt;.  Let&#39;s please<br>&gt;&gt; carry on further discussion here rather than in the pull request, though.<br>&gt; <br>&gt; -  /// - `isEquivalent(a, a)` is always `true`. (Reflexivity)<br>&gt;  -  /// - `isEquivalent(a, b)` implies `isEquivalent(b, a)`. (Symmetry)<br>&gt;  -  /// - If `isEquivalent(a, b)` and `isEquivalent(b, c)` are both `true`, then<br>&gt;  -  ///   `isEquivalent(a, c)` is also `true`. (Transitivity)<br>&gt;  +  /// - `areEquivalent(a, a)` is always `true`. (Reflexivity)<br>&gt;  +  /// - `areEquivalent(a, b)` implies `areEquivalent(b, a)`. (Symmetry)<br>&gt;  +  /// - If `areEquivalent(a, b)` and `areEquivalent(b, c)` are both `true`, then<br>&gt;  +  ///   `areEquivalent(a, c)` is also `true`. (Transitivity)<br>&gt; <br>&gt; I like this change!<br>&gt; <br>&gt; -    func forEach&lt;S: SequenceType&gt;(_ body: (S.Iterator.Element) -&gt; ())<br>&gt; +    func forEach&lt;S: SequenceType&gt;(invoke body: (S.Iterator.Element) -&gt; ())<br>&gt; <br>&gt; Adding an external label makes sense here. This is a procedural call and<br>&gt; using it within the parens should have a &quot;code ripple&quot;.<br>&gt; <br>&gt; That said, would prefer `do` or `perform` over `invoke` or `invoking` as in<br>&gt; `runRaceTest`, `_forAllPermutationsImpl`, `expectFailure`, etc. This also applies<br>&gt; where there&#39;s a `body` label instead of an empty external label.<br>&gt; <br>&gt; -public func withInvalidOrderings(_ body: ((Int, Int) -&gt; Bool) -&gt; Void) {<br>&gt; +public func withInvalidOrderings(invoke body: ((Int, Int) -&gt; Bool) -&gt; Void) {<br>&gt; <br>&gt; For any with/external label pair, I&#39;d prefer `with-do` or `with-perform` <br>&gt; over `with-invoke`.<br>&gt; <br>&gt; -  return IteratorSequence(it).reduce(initial, combine: f)<br>&gt; +  return IteratorSequence(it).reduce(initial, accumulatingBy: f)<br>&gt; <br>&gt; For `reduce`, I&#39;d prefer `applying:` or `byApplying:`<br>&gt; <br>&gt; Similarly in `starts(with:comparingBy:)`, I&#39;d prefer byComparing`,<br>&gt; min/max, byOrdering<br>&gt; <br>&gt; -      ).encode(encoding, output: output)<br>&gt; +      ).encode(encoding, sendingOutputTo: processCodeUnit)<br>&gt; <br>&gt; How about `exportingTo`?<br></p><p>I know this label does not need to be necessarily short, but I’d prefer Erica’s suggestion, or even `to`. encode(a, to: b) reads well to me.<br></p><p>&gt; -  tempwords.sort(isOrderedBefore: &lt;)<br>&gt; +  tempwords.sort(orderingBy: &lt;)<br>&gt; <br>&gt; With `sort` and `sorted`, I&#39;d prefer `by:`<br></p><p>I also agree that `by` is more than enough. `sort` already implies an `ordering`.<br></p><p>&gt; -  if !expected.elementsEqual(actual, isEquivalent: sameValue) {<br>&gt; +  if !expected.elementsEqual(actual, comparingBy: sameValue) {<br>&gt; <br>&gt; I&#39;m torn on this one. I don&#39;t like but I don&#39;t have a good solution.<br></p><p>This one has a noticeable chance of appearing in conditional clauses so I’d like to go for something short. How about `by`?<br></p><p>&gt; -  /// for which `predicate(x) == true`.<br>&gt; +  /// for which `isIncluded(x) == true`.<br>&gt; -      _base: base.makeIterator(), whereElementsSatisfy: _include)<br>&gt; +      _base: base.makeIterator(), suchThat: _include)<br>&gt; <br>&gt; How about simply `include` for both? I get the `is` desire but it&#39;s being tossed away<br>&gt; in a lot of other places in this diff. and `suchThat` feels out of place.<br>&gt; <br>&gt; -      || u16.contains({ $0 &gt; 127 || _isspace_clocale($0) }) {<br>&gt; +    || u16.contains(elementWhere: { $0 &gt; 127 || _isspace_clocale($0) }) {<br>&gt; <br>&gt; I assume the challenge here is differentiating contains(element) from contains(closure).<br>&gt; This feels predicate-y, which is why I put it near the predicates. But I think something<br>&gt; like `containsElement(where:)` works better.<br></p><p>Agreed. Again, same argument. As this is a boolean function, this has a higher chance of appearing in conditional clauses so should be short. `where` works well for me.<br></p><p>&gt;  -    let result = try base._withUnsafeMutableBufferPointerIfSupported(body)<br>&gt; +    let result = try base._withUnsafeMutableBufferPointerIfSupported(invoke: body)<br>&gt; <br>&gt; I hate &quot;ifSupported&quot; but that&#39;s another discussion (withSupportedUnsafeMutableBufferPointer,<br>&gt; withAvailableUnsafeMutableBufferPointer, it&#39;s all lipstick)<br>&gt; <br>&gt; This is procedural, so `do` or `perform` rather than `invoke`<br>&gt; <br>&gt; -      for test in removeFirstTests.filter({ $0.numberToRemove == 1 }) {<br>&gt; +      for test in removeFirstTests.filter(<br>&gt; +        suchThat: { $0.numberToRemove == 1 }<br>&gt; <br>&gt; The difference between `filter` and `forEach` is that `forEach` is explicitly <br>&gt; procedural while `filter` is functional.  I do not like functional chainable<br>&gt; calls being modified to use explicit external labels in this way. <br>&gt; <br>&gt; I&#39;d prefer no label here.<br></p><p>Quick aside. Eric, if you prefer no label here, why did you not also prefer no labels for contains and elementsEqual? They also have very functional. But if we must have a label, I’d vote for `where`.<br></p><p>&gt; public func split(<br>&gt;       maxSplits: Int = Int.max,<br>&gt;       omittingEmptySubsequences: Bool = true,<br>&gt; -    isSeparator: @noescape (Base.Iterator.Element) throws -&gt; Bool<br>&gt; +    separatedWhere isSeparator: @noescape (Base.Iterator.Element) throws -&gt; Bool<br>&gt; <br>&gt; I&#39;m torn on this one. It&#39;s not the worst ever but something more like where/at/when<br>&gt; makes more sense to me than &quot;separatedWhere/separatedAt/separatedWhen”.<br></p><p>I care less about this one, but `where` also sounds better.<br></p><p>&gt; +      count: __manager._headerPointer.pointee.count)<br>&gt; <br>&gt; For the sake of Zippy the Pinhead, surely there has to be something better than `pointee`.<br>&gt; Like...`reference`?<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/6806c4e5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Stdlib closure argument labels and parameter names</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>June 23, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jun 23, 2016, at 12:39 AM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;&gt; -      for test in removeFirstTests.filter({ $0.numberToRemove == 1 }) {<br>&gt;&gt; +      for test in removeFirstTests.filter(<br>&gt;&gt; +        suchThat: { $0.numberToRemove == 1 }<br>&gt;&gt; <br>&gt;&gt; The difference between `filter` and `forEach` is that `forEach` is explicitly <br>&gt;&gt; procedural while `filter` is functional.  I do not like functional chainable<br>&gt;&gt; calls being modified to use explicit external labels in this way. <br>&gt;&gt; <br>&gt;&gt; I&#39;d prefer no label here.<br>&gt; <br>&gt; Quick aside. Eric, if you prefer no label here, why did you not also prefer no labels for contains and elementsEqual? They also have very functional. But if we must have a label, I’d vote for `where`.<br></p><p>contains and elementsEqual both return Booleans which are almost never chained.<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/65144332/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Stdlib closure argument labels and parameter names</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June 25, 2016 at 03:00:00pm</p></header><div class="content"><p>on Thu Jun 23 2016, Erica Sadun &lt;erica-AT-ericasadun.com&gt; wrote:<br></p><p>&gt;&gt; On Jun 23, 2016, at 12:39 AM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;&gt;&gt; -      for test in removeFirstTests.filter({ $0.numberToRemove == 1 }) {<br>&gt;&gt;&gt; +      for test in removeFirstTests.filter(<br>&gt;&gt;&gt; +        suchThat: { $0.numberToRemove == 1 }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The difference between `filter` and `forEach` is that `forEach` is explicitly <br>&gt;&gt;&gt; procedural while `filter` is functional.  I do not like functional chainable<br>&gt;&gt;&gt; calls being modified to use explicit external labels in this way. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;d prefer no label here.<br>&gt;&gt; <br>&gt;&gt; Quick aside. Eric, if you prefer no label here, why did you not also<br>&gt;&gt; prefer no labels for contains and elementsEqual? They also have very<br>&gt;&gt; functional. But if we must have a label, I’d vote for `where`.<br>&gt;<br>&gt; contains and elementsEqual both return Booleans which are almost never chained.<br></p><p>What does chaining have to do with the presence of argument labels?<br></p><p>-- <br>-Dave<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Stdlib closure argument labels and parameter names</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June 25, 2016 at 03:00:00pm</p></header><div class="content"><p>on Wed Jun 22 2016, David Hart &lt;david-AT-hartbit.com&gt; wrote:<br></p><p>&gt; I did not pay a lot of attention to this renaming because I thought<br>&gt; the trailing closure syntax would shield me from labels. But I forgot<br>&gt; that in if/for/while statements, I’m going to be forced to use<br>&gt; them. In those cases, I’d prefer more succinct labels.<br>&gt;<br>&gt; I added some comments inline where I have issues with the new labels:<br>&gt;<br>&gt;&gt; On 23 Jun 2016, at 04:02, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Jun 20, 2016, at 3:25 PM, Dave Abrahams via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi All,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A couple of weeks ago we started to notice that we had some poorly-named<br>&gt;&gt;&gt; closure parameters and argument labels in the standard library, so we<br>&gt;&gt;&gt; did a complete audit of the standard library&#39;s APIs and came up with a<br>&gt;&gt;&gt; preliminary proposal for changes, which we applied in a branch and you<br>&gt;&gt;&gt; can review in https://github.com/apple/swift/pull/2981 &lt;https://github.com/apple/swift/pull/2981&gt;.  Let&#39;s please<br>&gt;&gt;&gt; carry on further discussion here rather than in the pull request, though.<br>&gt;&gt; <br>&gt;&gt; -  /// - `isEquivalent(a, a)` is always `true`. (Reflexivity)<br>&gt;&gt;  -  /// - `isEquivalent(a, b)` implies `isEquivalent(b, a)`. (Symmetry)<br>&gt;&gt;  -  /// - If `isEquivalent(a, b)` and `isEquivalent(b, c)` are both `true`, then<br>&gt;&gt;  -  ///   `isEquivalent(a, c)` is also `true`. (Transitivity)<br>&gt;&gt;  +  /// - `areEquivalent(a, a)` is always `true`. (Reflexivity)<br>&gt;&gt;  +  /// - `areEquivalent(a, b)` implies `areEquivalent(b, a)`. (Symmetry)<br>&gt;&gt;  +  /// - If `areEquivalent(a, b)` and `areEquivalent(b, c)` are both `true`, then<br>&gt;&gt;  +  ///   `areEquivalent(a, c)` is also `true`. (Transitivity)<br>&gt;&gt; <br>&gt;&gt; I like this change!<br>&gt;&gt; <br>&gt;&gt; -    func forEach&lt;S: SequenceType&gt;(_ body: (S.Iterator.Element) -&gt; ())<br>&gt;&gt; +    func forEach&lt;S: SequenceType&gt;(invoke body: (S.Iterator.Element) -&gt; ())<br>&gt;&gt; <br>&gt;&gt; Adding an external label makes sense here. This is a procedural call and<br>&gt;&gt; using it within the parens should have a &quot;code ripple&quot;.<br>&gt;&gt; <br>&gt;&gt; That said, would prefer `do` or `perform` over `invoke` or `invoking` as in<br>&gt;&gt; `runRaceTest`, `_forAllPermutationsImpl`, `expectFailure`, etc. This also applies<br>&gt;&gt; where there&#39;s a `body` label instead of an empty external label.<br>&gt;&gt; <br>&gt;&gt; -public func withInvalidOrderings(_ body: ((Int, Int) -&gt; Bool) -&gt; Void) {<br>&gt;&gt; +public func withInvalidOrderings(invoke body: ((Int, Int) -&gt; Bool) -&gt; Void) {<br>&gt;&gt; <br>&gt;&gt; For any with/external label pair, I&#39;d prefer `with-do` or `with-perform` <br>&gt;&gt; over `with-invoke`.<br>&gt;&gt; <br>&gt;&gt; -  return IteratorSequence(it).reduce(initial, combine: f)<br>&gt;&gt; +  return IteratorSequence(it).reduce(initial, accumulatingBy: f)<br>&gt;&gt; <br>&gt;&gt; For `reduce`, I&#39;d prefer `applying:` or `byApplying:`<br>&gt;&gt; <br>&gt;&gt; Similarly in `starts(with:comparingBy:)`, I&#39;d prefer byComparing`,<br>&gt;&gt; min/max, byOrdering<br>&gt;&gt; <br>&gt;&gt; -      ).encode(encoding, output: output)<br>&gt;&gt; +      ).encode(encoding, sendingOutputTo: processCodeUnit)<br>&gt;&gt; <br>&gt;&gt; How about `exportingTo`?<br>&gt;<br>&gt; I know this label does not need to be necessarily short, but I’d<br>&gt; prefer Erica’s suggestion, or even `to`. encode(a, to: b) reads well<br>&gt; to me.<br></p><p>Makes sense.<br></p><p>&gt;&gt; -  tempwords.sort(isOrderedBefore: &lt;)<br>&gt;&gt; +  tempwords.sort(orderingBy: &lt;)<br>&gt;&gt; <br>&gt;&gt; With `sort` and `sorted`, I&#39;d prefer `by:`<br>&gt;<br>&gt; I also agree that `by` is more than enough. `sort` already implies an<br>&gt; `ordering`.<br></p><p>See my reply to Erica.<br></p><p>&gt;&gt; -  if !expected.elementsEqual(actual, isEquivalent: sameValue) {<br>&gt;&gt; +  if !expected.elementsEqual(actual, comparingBy: sameValue) {<br>&gt;&gt; <br>&gt;&gt; I&#39;m torn on this one. I don&#39;t like but I don&#39;t have a good solution.<br>&gt;<br>&gt; This one has a noticeable chance of appearing in conditional clauses<br>&gt; so I’d like to go for something short. How about `by`?<br></p><p>You know, it&#39;s not bad.  Maybe it&#39;s just the fever talking but I am<br>starting to like these short labels.<br></p><p>&gt;&gt; -  /// for which `predicate(x) == true`.<br>&gt;&gt; +  /// for which `isIncluded(x) == true`.<br>&gt;&gt; -      _base: base.makeIterator(), whereElementsSatisfy: _include)<br>&gt;&gt; +      _base: base.makeIterator(), suchThat: _include)<br>&gt;&gt; <br>&gt;&gt; How about simply `include` for both? I get the `is` desire but it&#39;s being tossed away<br>&gt;&gt; in a lot of other places in this diff. and `suchThat` feels out of place.<br>&gt;&gt; <br>&gt;&gt; -      || u16.contains({ $0 &gt; 127 || _isspace_clocale($0) }) {<br>&gt;&gt; +    || u16.contains(elementWhere: { $0 &gt; 127 || _isspace_clocale($0) }) {<br>&gt;&gt; <br>&gt;&gt; I assume the challenge here is differentiating contains(element) from contains(closure).<br>&gt;&gt; This feels predicate-y, which is why I put it near the predicates. But I think something<br>&gt;&gt; like `containsElement(where:)` works better.<br>&gt;<br>&gt; Agreed. Again, same argument. As this is a boolean function, this has<br>&gt; a higher chance of appearing in conditional clauses so should be<br>&gt; short. `where` works well for me.<br></p><p>  if friends.contains(where: {$0.firstName == &quot;ted&quot;}) { ... }<br></p><p>?  `contains(where:` doesn&#39;t seem very fluent to me.<br></p><p>&gt;&gt;  -    let result = try base._withUnsafeMutableBufferPointerIfSupported(body)<br>&gt;&gt; +    let result = try base._withUnsafeMutableBufferPointerIfSupported(invoke: body)<br>&gt;&gt; <br>&gt;&gt; I hate &quot;ifSupported&quot; but that&#39;s another discussion (withSupportedUnsafeMutableBufferPointer,<br>&gt;&gt; withAvailableUnsafeMutableBufferPointer, it&#39;s all lipstick)<br>&gt;&gt; <br>&gt;&gt; This is procedural, so `do` or `perform` rather than `invoke`<br>&gt;&gt; <br>&gt;&gt; -      for test in removeFirstTests.filter({ $0.numberToRemove == 1 }) {<br>&gt;&gt; +      for test in removeFirstTests.filter(<br>&gt;&gt; +        suchThat: { $0.numberToRemove == 1 }<br>&gt;&gt; <br>&gt;&gt; The difference between `filter` and `forEach` is that `forEach` is explicitly <br>&gt;&gt; procedural while `filter` is functional.  I do not like functional chainable<br>&gt;&gt; calls being modified to use explicit external labels in this way. <br>&gt;&gt; <br>&gt;&gt; I&#39;d prefer no label here.<br>&gt;<br>&gt; Quick aside. Eric, if you prefer no label here, why did you not also<br>&gt; prefer no labels for contains and elementsEqual? They also have very<br>&gt; functional. But if we must have a label, I’d vote for `where`.<br></p><p>IMO `where` fails to correct one of the great weaknesses of the basename<br>`filter`, which is the strong implication that the predicate&#39;s meaning<br>is the inverse of what it actually is.  That&#39;s why I favor `soEach`.<br></p><p>&gt;&gt; public func split(<br>&gt;&gt;       maxSplits: Int = Int.max,<br>&gt;&gt;       omittingEmptySubsequences: Bool = true,<br>&gt;&gt; -    isSeparator: @noescape (Base.Iterator.Element) throws -&gt; Bool<br>&gt;&gt; +    separatedWhere isSeparator: @noescape (Base.Iterator.Element) throws -&gt; Bool<br>&gt;&gt; <br>&gt;&gt; I&#39;m torn on this one. It&#39;s not the worst ever but something more like where/at/when<br>&gt;&gt; makes more sense to me than &quot;separatedWhere/separatedAt/separatedWhen”.<br>&gt;<br>&gt; I care less about this one, but `where` also sounds better.<br></p><p>As I noted in my reply to Erica, I think `where` without some reference<br>to the separator is potentially misleading.<br></p><p>Perhaps<br></p><p>    contiguousNonPrimes = (0..&lt;100).split(whereSeparator: isPrime)<br></p><p>would be better for use sites than what&#39;s in the patch, though.<br></p><p>-- <br>-Dave<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Stdlib closure argument labels and parameter names</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June 25, 2016 at 03:00:00pm</p></header><div class="content"><p>on Wed Jun 22 2016, Erica Sadun &lt;erica-AT-ericasadun.com&gt; wrote:<br></p><p>&gt; On Jun 20, 2016, at 3:25 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Hi All,<br>&gt;&gt; <br>&gt;&gt; A couple of weeks ago we started to notice that we had some poorly-named<br>&gt;&gt; closure parameters and argument labels in the standard library, so we<br>&gt;&gt; did a complete audit of the standard library&#39;s APIs and came up with a<br>&gt;&gt; preliminary proposal for changes, which we applied in a branch and you<br>&gt;&gt; can review in https://github.com/apple/swift/pull/2981.  Let&#39;s please<br>&gt;&gt; carry on further discussion here rather than in the pull request, though.<br>&gt;<br>&gt; -  /// - `isEquivalent(a, a)` is always `true`. (Reflexivity)<br>&gt;  -  /// - `isEquivalent(a, b)` implies `isEquivalent(b, a)`. (Symmetry)<br>&gt;  -  /// - If `isEquivalent(a, b)` and `isEquivalent(b, c)` are both `true`, then<br>&gt;  -  ///   `isEquivalent(a, c)` is also `true`. (Transitivity)<br>&gt;  +  /// - `areEquivalent(a, a)` is always `true`. (Reflexivity)<br>&gt;  +  /// - `areEquivalent(a, b)` implies `areEquivalent(b, a)`. (Symmetry)<br>&gt;  +  /// - If `areEquivalent(a, b)` and `areEquivalent(b, c)` are both `true`, then<br>&gt;  +  ///   `areEquivalent(a, c)` is also `true`. (Transitivity)<br>&gt;<br>&gt; I like this change!<br>&gt;<br>&gt; -    func forEach&lt;S: SequenceType&gt;(_ body: (S.Iterator.Element) -&gt; ())<br>&gt; +    func forEach&lt;S: SequenceType&gt;(invoke body: (S.Iterator.Element) -&gt; ())<br>&gt;<br>&gt; Adding an external label makes sense here. This is a procedural call and<br>&gt; using it within the parens should have a &quot;code ripple&quot;.<br></p><p>I don&#39;t think I understand what you mean here.<br></p><p>&gt; That said, would prefer `do` or `perform` over `invoke` or `invoking` as in<br>&gt; `runRaceTest`, `_forAllPermutationsImpl`, `expectFailure`, etc. <br></p><p>Sorry, again, I&#39;m a little lost.  Forgive my overly-literal brain but<br>could you please spell out how those latter 3 names relate to the choice<br>of `do` or `perform` over `invoke`?   <br></p><p>&gt; This also applies where there&#39;s a `body` label instead of an empty<br>&gt; external label.<br></p><p>We don&#39;t have any methods with a `body` label IIUC.<br></p><p>&gt; -public func withInvalidOrderings(_ body: ((Int, Int) -&gt; Bool) -&gt; Void) {<br>&gt; +public func withInvalidOrderings(invoke body: ((Int, Int) -&gt; Bool) -&gt; Void) {<br>&gt;<br>&gt; For any with/external label pair, I&#39;d prefer `with-do` or `with-perform` <br>&gt; over `with-invoke`.<br></p><p>OK.  Is there a rationale, or is it just personal taste?<br></p><p>&gt; -  return IteratorSequence(it).reduce(initial, combine: f)<br>&gt; +  return IteratorSequence(it).reduce(initial, accumulatingBy: f)<br>&gt;<br>&gt; For `reduce`, I&#39;d prefer `applying:` or `byApplying:`<br></p><p>Makes sense.<br></p><p>&gt; Similarly in `starts(with:comparingBy:)`, I&#39;d prefer byComparing`,<br></p><p>I don&#39;t see how that works.  You&#39;re not comparing the closure with<br>anything.<br></p><p>&gt; min/max, byOrdering<br></p><p>Likewise, you&#39;re not ordering the closure.<br></p><p>&gt; -      ).encode(encoding, output: output)<br>&gt; +      ).encode(encoding, sendingOutputTo: processCodeUnit)<br>&gt;<br>&gt; How about `exportingTo`?<br></p><p>“export” is freighted with various connotations that I don&#39;t think we<br>want to make here.  In fact it doesn&#39;t mean anything more exotic than<br>“sending output to.”<br></p><p>&gt; -  tempwords.sort(isOrderedBefore: &lt;)<br>&gt; +  tempwords.sort(orderingBy: &lt;)<br>&gt;<br>&gt; With `sort` and `sorted`, I&#39;d prefer `by:`<br></p><p>When people talk about “sorting by XXX”, XXX is a property of the<br>elements being sorted.  Therefore IMIO that label should probably be<br>reserved for a version that takes a unary projection function:<br></p><p>     friends.sort(by: {$0.lastName})<br></p><p>&gt; -  if !expected.elementsEqual(actual, isEquivalent: sameValue) {<br>&gt; +  if !expected.elementsEqual(actual, comparingBy: sameValue) {<br>&gt;<br>&gt; I&#39;m torn on this one. I don&#39;t like but I don&#39;t have a good solution.<br>&gt;<br>&gt; -  /// for which `predicate(x) == true`.<br>&gt; +  /// for which `isIncluded(x) == true`.<br>&gt; -      _base: base.makeIterator(), whereElementsSatisfy: _include)<br>&gt; +      _base: base.makeIterator(), suchThat: _include)<br>&gt;<br>&gt; How about simply `include` for both? <br></p><p>Looking at the effect on the doc comments—which is how we should judge<br>parameter names—I think `predicate` might read better.<br></p><p>&gt; I get the `is` desire but it&#39;s being tossed away in a lot of other<br>&gt; places in this diff. and `suchThat` feels out of place.<br></p><p>I think I&#39;m pretty strongly sold on “soEach” as a label for closures in<br>all the filtering components.<br></p><p>&gt; -      || u16.contains({ $0 &gt; 127 || _isspace_clocale($0) }) {<br>&gt; +    || u16.contains(elementWhere: { $0 &gt; 127 || _isspace_clocale($0) }) {<br>&gt;<br>&gt; I assume the challenge here is differentiating contains(element) from contains(closure).<br>&gt; This feels predicate-y, which is why I put it near the predicates. But I think something<br>&gt; like `containsElement(where:)` works better.<br></p><p>I understand your motivation for suggesting it.  The downside is that it<br>severs the strong basename relationship between algorithms that do<br>effectively the same things, one using a default comparison and the<br>other using an explicitly-specified one.  I&#39;m truly not sure where we<br>ought to land on this one.<br></p><p>&gt;  -    let result = try base._withUnsafeMutableBufferPointerIfSupported(body)<br>&gt; +    let result = try base._withUnsafeMutableBufferPointerIfSupported(invoke: body)<br>&gt;<br>&gt; I hate &quot;ifSupported&quot; <br></p><p>Me too.<br></p><p>&gt; but that&#39;s another discussion<br></p><p>Quite.  It&#39;s also an internal API so it&#39;s not an evolution issue.  The<br>point of having that change as part of the diff (as with all the other<br>use sites), is to observe how the changes affect real usage.<br></p><p>&gt; (withSupportedUnsafeMutableBufferPointer,<br>&gt; withAvailableUnsafeMutableBufferPointer, it&#39;s all lipstick)<br>&gt;<br>&gt; This is procedural, so `do` or `perform` rather than `invoke`<br>&gt;<br>&gt; -      for test in removeFirstTests.filter({ $0.numberToRemove == 1 }) {<br>&gt; +      for test in removeFirstTests.filter(<br>&gt; +        suchThat: { $0.numberToRemove == 1 }<br>&gt;<br>&gt; The difference between `filter` and `forEach` is that `forEach` is explicitly <br>&gt; procedural while `filter` is functional.  I do not like functional chainable<br>&gt; calls being modified to use explicit external labels in this way. <br>&gt;<br>&gt; I&#39;d prefer no label here.<br></p><p>Can you provide rationale for treating functional methods differently,<br>or is it just personal taste?<br></p><p>&gt; public func split(<br>&gt;       maxSplits: Int = Int.max,<br>&gt;       omittingEmptySubsequences: Bool = true,<br>&gt; -    isSeparator: @noescape (Base.Iterator.Element) throws -&gt; Bool<br>&gt; +    separatedWhere isSeparator: @noescape (Base.Iterator.Element) throws -&gt; Bool<br>&gt;<br>&gt; I&#39;m torn on this one. It&#39;s not the worst ever but something more like where/at/when<br>&gt; makes more sense to me than<br>&gt; &quot;separatedWhere/separatedAt/separatedWhen&quot;.<br></p><p>The biggest reason to keep “separate” in the name is the connection with<br>the semantics of the other `split` method, that takes a single element<br>that is tested for equality.  I think this is very similar to the<br>`contains(elementWhere` vs `containsElement(where` discussion.  If you<br>leave “separate” out of the name it fails to imply that those elements<br>for which the predicate returns true are not present in the result.<br></p><p>&gt;<br>&gt; +      count: __manager._headerPointer.pointee.count)<br>&gt;<br>&gt; For the sake of Zippy the Pinhead, surely there has to be something better than `pointee`.<br>&gt; Like...`reference`?<br></p><p>It&#39;s not a reference; it&#39;s a value.  But that, my friend, is an<br>*entirely* different discussion. Let&#39;s try to stick to the scope of the<br>proposal: names and labels for parameters of function type, OK?<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>Stdlib closure argument labels and parameter names</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>June 26, 2016 at 01:00:00am</p></header><div class="content"><p>Comments inline:<br></p><p><br></p><p>Sent from my iPhone<br>&gt; On 26 Jun 2016, at 00:25, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; on Wed Jun 22 2016, Erica Sadun &lt;erica-AT-ericasadun.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 20, 2016, at 3:25 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi All,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A couple of weeks ago we started to notice that we had some poorly-named<br>&gt;&gt;&gt; closure parameters and argument labels in the standard library, so we<br>&gt;&gt;&gt; did a complete audit of the standard library&#39;s APIs and came up with a<br>&gt;&gt;&gt; preliminary proposal for changes, which we applied in a branch and you<br>&gt;&gt;&gt; can review in https://github.com/apple/swift/pull/2981.  Let&#39;s please<br>&gt;&gt;&gt; carry on further discussion here rather than in the pull request, though.<br>&gt;&gt; <br>&gt;&gt; -  /// - `isEquivalent(a, a)` is always `true`. (Reflexivity)<br>&gt;&gt; -  /// - `isEquivalent(a, b)` implies `isEquivalent(b, a)`. (Symmetry)<br>&gt;&gt; -  /// - If `isEquivalent(a, b)` and `isEquivalent(b, c)` are both `true`, then<br>&gt;&gt; -  ///   `isEquivalent(a, c)` is also `true`. (Transitivity)<br>&gt;&gt; +  /// - `areEquivalent(a, a)` is always `true`. (Reflexivity)<br>&gt;&gt; +  /// - `areEquivalent(a, b)` implies `areEquivalent(b, a)`. (Symmetry)<br>&gt;&gt; +  /// - If `areEquivalent(a, b)` and `areEquivalent(b, c)` are both `true`, then<br>&gt;&gt; +  ///   `areEquivalent(a, c)` is also `true`. (Transitivity)<br>&gt;&gt; <br>&gt;&gt; I like this change!<br>&gt;&gt; <br>&gt;&gt; -    func forEach&lt;S: SequenceType&gt;(_ body: (S.Iterator.Element) -&gt; ())<br>&gt;&gt; +    func forEach&lt;S: SequenceType&gt;(invoke body: (S.Iterator.Element) -&gt; ())<br>&gt;&gt; <br>&gt;&gt; Adding an external label makes sense here. This is a procedural call and<br>&gt;&gt; using it within the parens should have a &quot;code ripple&quot;.<br>&gt; <br>&gt; I don&#39;t think I understand what you mean here.<br>&gt; <br>&gt;&gt; That said, would prefer `do` or `perform` over `invoke` or `invoking` as in<br>&gt;&gt; `runRaceTest`, `_forAllPermutationsImpl`, `expectFailure`, etc. <br>&gt; <br>&gt; Sorry, again, I&#39;m a little lost.  Forgive my overly-literal brain but<br>&gt; could you please spell out how those latter 3 names relate to the choice<br>&gt; of `do` or `perform` over `invoke`?<br></p><p>I&#39;d vote for `do`, just to keep those functional method labels short.<br></p><p>&gt;&gt; This also applies where there&#39;s a `body` label instead of an empty<br>&gt;&gt; external label.<br>&gt; <br>&gt; We don&#39;t have any methods with a `body` label IIUC.<br>&gt; <br>&gt;&gt; -public func withInvalidOrderings(_ body: ((Int, Int) -&gt; Bool) -&gt; Void) {<br>&gt;&gt; +public func withInvalidOrderings(invoke body: ((Int, Int) -&gt; Bool) -&gt; Void) {<br>&gt;&gt; <br>&gt;&gt; For any with/external label pair, I&#39;d prefer `with-do` or `with-perform` <br>&gt;&gt; over `with-invoke`.<br>&gt; <br>&gt; OK.  Is there a rationale, or is it just personal taste?<br>&gt; <br>&gt;&gt; -  return IteratorSequence(it).reduce(initial, combine: f)<br>&gt;&gt; +  return IteratorSequence(it).reduce(initial, accumulatingBy: f)<br>&gt;&gt; <br>&gt;&gt; For `reduce`, I&#39;d prefer `applying:` or `byApplying:`<br>&gt; <br>&gt; Makes sense.<br></p><p>`applying` looks great. The `by` looks redundant in this case.<br></p><p>&gt;&gt; Similarly in `starts(with:comparingBy:)`, I&#39;d prefer byComparing`,<br>&gt; <br>&gt; I don&#39;t see how that works.  You&#39;re not comparing the closure with<br>&gt; anything.<br>&gt;&gt; min/max, byOrdering<br>&gt; <br>&gt; Likewise, you&#39;re not ordering the closure.<br></p><p>I agree with you Dave on both of those.<br></p><p>&gt; <br>&gt;&gt; -      ).encode(encoding, output: output)<br>&gt;&gt; +      ).encode(encoding, sendingOutputTo: processCodeUnit)<br>&gt;&gt; <br>&gt;&gt; How about `exportingTo`?<br>&gt; <br>&gt; “export” is freighted with various connotations that I don&#39;t think we<br>&gt; want to make here.  In fact it doesn&#39;t mean anything more exotic than<br>&gt; “sending output to.”<br>&gt; <br>&gt;&gt; -  tempwords.sort(isOrderedBefore: &lt;)<br>&gt;&gt; +  tempwords.sort(orderingBy: &lt;)<br>&gt;&gt; <br>&gt;&gt; With `sort` and `sorted`, I&#39;d prefer `by:`<br>&gt; <br>&gt; When people talk about “sorting by XXX”, XXX is a property of the<br>&gt; elements being sorted.  Therefore IMIO that label should probably be<br>&gt; reserved for a version that takes a unary projection function:<br>&gt; <br>&gt;     friends.sort(by: {$0.lastName})<br></p><p>How about `sort(with:)` then?<br></p><p>&gt; <br>&gt;&gt; -  if !expected.elementsEqual(actual, isEquivalent: sameValue) {<br>&gt;&gt; +  if !expected.elementsEqual(actual, comparingBy: sameValue) {<br>&gt;&gt; <br>&gt;&gt; I&#39;m torn on this one. I don&#39;t like but I don&#39;t have a good solution.<br>&gt;&gt; <br>&gt;&gt; -  /// for which `predicate(x) == true`.<br>&gt;&gt; +  /// for which `isIncluded(x) == true`.<br>&gt;&gt; -      _base: base.makeIterator(), whereElementsSatisfy: _include)<br>&gt;&gt; +      _base: base.makeIterator(), suchThat: _include)<br>&gt;&gt; <br>&gt;&gt; How about simply `include` for both? <br>&gt; <br>&gt; Looking at the effect on the doc comments—which is how we should judge<br>&gt; parameter names—I think `predicate` might read better.<br>&gt; <br>&gt;&gt; I get the `is` desire but it&#39;s being tossed away in a lot of other<br>&gt;&gt; places in this diff. and `suchThat` feels out of place.<br>&gt; <br>&gt; I think I&#39;m pretty strongly sold on “soEach” as a label for closures in<br>&gt; all the filtering components.<br>&gt; <br>&gt;&gt; -      || u16.contains({ $0 &gt; 127 || _isspace_clocale($0) }) {<br>&gt;&gt; +    || u16.contains(elementWhere: { $0 &gt; 127 || _isspace_clocale($0) }) {<br>&gt;&gt; <br>&gt;&gt; I assume the challenge here is differentiating contains(element) from contains(closure).<br>&gt;&gt; This feels predicate-y, which is why I put it near the predicates. But I think something<br>&gt;&gt; like `containsElement(where:)` works better.<br>&gt; <br>&gt; I understand your motivation for suggesting it.  The downside is that it<br>&gt; severs the strong basename relationship between algorithms that do<br>&gt; effectively the same things, one using a default comparison and the<br>&gt; other using an explicitly-specified one.  I&#39;m truly not sure where we<br>&gt; ought to land on this one.<br></p><p>I agree with Dave, the algorithms do the same thing, but with different arguments. I think we&#39;d loose discoverability if we applied Erica&#39;s proposition.<br></p><p>&gt;&gt; -    let result = try base._withUnsafeMutableBufferPointerIfSupported(body)<br>&gt;&gt; +    let result = try base._withUnsafeMutableBufferPointerIfSupported(invoke: body)<br>&gt;&gt; <br>&gt;&gt; I hate &quot;ifSupported&quot; <br>&gt; <br>&gt; Me too.<br>&gt; <br>&gt;&gt; but that&#39;s another discussion<br>&gt; <br>&gt; Quite.  It&#39;s also an internal API so it&#39;s not an evolution issue.  The<br>&gt; point of having that change as part of the diff (as with all the other<br>&gt; use sites), is to observe how the changes affect real usage.<br>&gt; <br>&gt;&gt; (withSupportedUnsafeMutableBufferPointer,<br>&gt;&gt; withAvailableUnsafeMutableBufferPointer, it&#39;s all lipstick)<br>&gt;&gt; <br>&gt;&gt; This is procedural, so `do` or `perform` rather than `invoke`<br>&gt;&gt; <br>&gt;&gt; -      for test in removeFirstTests.filter({ $0.numberToRemove == 1 }) {<br>&gt;&gt; +      for test in removeFirstTests.filter(<br>&gt;&gt; +        suchThat: { $0.numberToRemove == 1 }<br>&gt;&gt; <br>&gt;&gt; The difference between `filter` and `forEach` is that `forEach` is explicitly <br>&gt;&gt; procedural while `filter` is functional.  I do not like functional chainable<br>&gt;&gt; calls being modified to use explicit external labels in this way. <br>&gt;&gt; <br>&gt;&gt; I&#39;d prefer no label here.<br>&gt; <br>&gt; Can you provide rationale for treating functional methods differently,<br>&gt; or is it just personal taste?<br>&gt; <br>&gt;&gt; public func split(<br>&gt;&gt;      maxSplits: Int = Int.max,<br>&gt;&gt;      omittingEmptySubsequences: Bool = true,<br>&gt;&gt; -    isSeparator: @noescape (Base.Iterator.Element) throws -&gt; Bool<br>&gt;&gt; +    separatedWhere isSeparator: @noescape (Base.Iterator.Element) throws -&gt; Bool<br>&gt;&gt; <br>&gt;&gt; I&#39;m torn on this one. It&#39;s not the worst ever but something more like where/at/when<br>&gt;&gt; makes more sense to me than<br>&gt;&gt; &quot;separatedWhere/separatedAt/separatedWhen&quot;.<br>&gt; <br>&gt; The biggest reason to keep “separate” in the name is the connection with<br>&gt; the semantics of the other `split` method, that takes a single element<br>&gt; that is tested for equality.  I think this is very similar to the<br>&gt; `contains(elementWhere` vs `containsElement(where` discussion.  If you<br>&gt; leave “separate” out of the name it fails to imply that those elements<br>&gt; for which the predicate returns true are not present in the result.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; +      count: __manager._headerPointer.pointee.count)<br>&gt;&gt; <br>&gt;&gt; For the sake of Zippy the Pinhead, surely there has to be something better than `pointee`.<br>&gt;&gt; Like...`reference`?<br>&gt; <br>&gt; It&#39;s not a reference; it&#39;s a value.  But that, my friend, is an<br>&gt; *entirely* different discussion. Let&#39;s try to stick to the scope of the<br>&gt; proposal: names and labels for parameters of function type, OK?<br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Stdlib closure argument labels and parameter names</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>June 25, 2016 at 06:00:00pm</p></header><div class="content"><p>On Jun 25, 2016, at 4:25 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; on Wed Jun 22 2016, Erica Sadun &lt;erica-AT-ericasadun.com&gt; wrote:<br>&gt; On Jun 20, 2016, at 3:25 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; -    func forEach&lt;S: SequenceType&gt;(_ body: (S.Iterator.Element) -&gt; ())<br>&gt;&gt; +    func forEach&lt;S: SequenceType&gt;(invoke body: (S.Iterator.Element) -&gt; ())<br>&gt;&gt; <br>&gt;&gt; Adding an external label makes sense here. This is a procedural call and<br>&gt;&gt; using it within the parens should have a &quot;code ripple&quot;.<br>&gt; <br>&gt; I don&#39;t think I understand what you mean here.<br></p><p>When using a procedural &quot;trailable&quot; closure inside parentheses, the intention<br>to do so should be clear:<br></p><p>p(x, perform: {...})<br>p(x, do: {...})<br></p><p>vs<br></p><p>p(x) {<br>   ...<br>}<br></p><p>Anyone reading this code can immediately identify that an otherwise trailing<br>closure has been pulled inside the signature because the call has become <br>significantly more  complex. The point-of-coding decision ripples through<br>to point-of-reading/point-of-maintenance.<br></p><p>&gt;&gt; That said, would prefer `do` or `perform` over `invoke` or `invoking` as in<br>&gt;&gt; `runRaceTest`, `_forAllPermutationsImpl`, `expectFailure`, etc. <br>&gt; <br>&gt; Sorry, again, I&#39;m a little lost.  Forgive my overly-literal brain but<br>&gt; could you please spell out how those latter 3 names relate to the choice<br>&gt; of `do` or `perform` over `invoke`?   <br></p><p>I read through the pull request. I grouped related modifications<br>together, although not exhaustively. They fall under the same umbrella, <br>choosing `do` or `perform` compared to `invoke` or `invoking`.<br></p><p>-    _forAllPermutationsImpl(index + 1, size, &amp;perm, &amp;visited, body)<br>+    _forAllPermutationsImpl(index + 1, size, &amp;perm, &amp;visited, invoke: body)<br></p><p>-public func runRaceTest(trials: Int, threads: Int? = nil, body: () -&gt; ()) {<br>+public func runRaceTest(<br>+  trials: Int, threads: Int? = nil, invoking body: () -&gt; ()<br>+) {<br></p><p>-public func expectFailure(${TRACE}, body: () -&gt; Void) {<br>+public func expectFailure(${TRACE}, invoking body: () -&gt; Void) {<br></p><p><br>&gt; <br>&gt;&gt; This also applies where there&#39;s a `body` label instead of an empty<br>&gt;&gt; external label.<br>&gt; <br>&gt; We don&#39;t have any methods with a `body` label IIUC.<br></p><p>You did, as in the examples just above, which you recommend a rename to `invoke` or<br>`invoking`.<br></p><p>&gt;&gt; -public func withInvalidOrderings(_ body: ((Int, Int) -&gt; Bool) -&gt; Void) {<br>&gt;&gt; +public func withInvalidOrderings(invoke body: ((Int, Int) -&gt; Bool) -&gt; Void) {<br>&gt;&gt; <br>&gt;&gt; For any with/external label pair, I&#39;d prefer `with-do` or `with-perform` <br>&gt;&gt; over `with-invoke`.<br>&gt; <br>&gt; OK.  Is there a rationale, or is it just personal taste?<br></p><p>Strong personal taste, backed by tech writing. Simpler words. <br>From the Corpus of Contemporary American English:<br>do: 18<br>perform: 955<br>invoke: does not appear on list.<br>&gt; <br>&gt;&gt; -  return IteratorSequence(it).reduce(initial, combine: f)<br>&gt;&gt; +  return IteratorSequence(it).reduce(initial, accumulatingBy: f)<br>&gt;&gt; <br>&gt;&gt; For `reduce`, I&#39;d prefer `applying:` or `byApplying:`<br>&gt; <br>&gt; Makes sense.<br>&gt; <br>&gt;&gt; Similarly in `starts(with:comparingBy:)`, I&#39;d prefer byComparing`,<br>&gt; <br>&gt; I don&#39;t see how that works.  You&#39;re not comparing the closure with<br>&gt; anything.<br></p><p>I get your point but I think it&#39;s unnecessarily fussy. <br></p><p>Alternatives are slim on the ground. `usingComparison:` is too long,<br>as is `byComparingWith:` (which still reads better but you will point<br>out can be mistaken by some pedant to mean that the sequence is being<br>compared to the closure), and you won&#39;t allow for `comparing:`.<br>I&#39;m not in love with `comparingWith:` but it reads slightly better to me <br>than `comparingBy:`.<br></p><p><br>&gt; <br>&gt;&gt; min/max, byOrdering<br>&gt; <br>&gt; Likewise, you&#39;re not ordering the closure.<br></p><p>Same reasoning.<br></p><p>&gt; <br>&gt;&gt; -      ).encode(encoding, output: output)<br>&gt;&gt; +      ).encode(encoding, sendingOutputTo: processCodeUnit)<br>&gt;&gt; <br>&gt;&gt; How about `exportingTo`?<br>&gt; <br>&gt; “export” is freighted with various connotations that I don&#39;t think we<br>&gt; want to make here.  In fact it doesn&#39;t mean anything more exotic than<br>&gt; “sending output to.”<br></p><p>For a language that treasures concision and clarity, this may be clear<br>but it&#39;s notably inconcise. (Yes, that is a new word.)<br></p><p>&gt; <br>&gt;&gt; -  tempwords.sort(isOrderedBefore: &lt;)<br>&gt;&gt; +  tempwords.sort(orderingBy: &lt;)<br>&gt;&gt; <br>&gt;&gt; With `sort` and `sorted`, I&#39;d prefer `by:`<br>&gt; <br>&gt; When people talk about “sorting by XXX”, XXX is a property of the<br>&gt; elements being sorted.  Therefore IMIO that label should probably be<br>&gt; reserved for a version that takes a unary projection function:<br>&gt; <br>&gt;     friends.sort(by: {$0.lastName})<br></p><p>But they&#39;re sorting now, and that feature isn&#39;t in Swift.<br></p><p>However, `sorted` falls under another umbrella, which is potential<br>chaining. In such case, I would prefer there be no internal label at all<br>to allow cleaner functional flow.<br></p><p>&gt; <br>&gt;&gt; -  if !expected.elementsEqual(actual, isEquivalent: sameValue) {<br>&gt;&gt; +  if !expected.elementsEqual(actual, comparingBy: sameValue) {<br>&gt;&gt; <br>&gt;&gt; I&#39;m torn on this one. I don&#39;t like but I don&#39;t have a good solution.<br></p><p>I actually meant to move this up to the other discussion of `byComparing` and<br>forgot to. So please assume you disagree with me on this one too.<br></p><p>&gt;&gt; <br>&gt;&gt; -  /// for which `predicate(x) == true`.<br>&gt;&gt; +  /// for which `isIncluded(x) == true`.<br>&gt;&gt; -      _base: base.makeIterator(), whereElementsSatisfy: _include)<br>&gt;&gt; +      _base: base.makeIterator(), suchThat: _include)<br>&gt;&gt; <br>&gt;&gt; How about simply `include` for both? <br>&gt; <br>&gt; Looking at the effect on the doc comments—which is how we should judge<br>&gt; parameter names—I think `predicate` might read better.<br></p><p>I like `predicate`. I endorse `predicate`. Does this mean the rule of &quot;must<br>read like a sentence&quot; can be overturned for things like &quot;comparison&quot; and<br>&quot;order&quot;? If so, woo!<br></p><p>&gt; <br>&gt;&gt; I get the `is` desire but it&#39;s being tossed away in a lot of other<br>&gt;&gt; places in this diff. and `suchThat` feels out of place.<br>&gt; <br>&gt; I think I&#39;m pretty strongly sold on “soEach” as a label for closures in<br>&gt; all the filtering components.<br></p><p>To quote greatness:, &quot;I personally find `soEach` repulsive&quot;.<br>(cite: http://article.gmane.org/gmane.comp.lang.swift.evolution/16998/match=repulsive &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/16998/match=repulsive&gt;)<br></p><p>&gt; <br>&gt;&gt; -      || u16.contains({ $0 &gt; 127 || _isspace_clocale($0) }) {<br>&gt;&gt; +    || u16.contains(elementWhere: { $0 &gt; 127 || _isspace_clocale($0) }) {<br>&gt;&gt; <br>&gt;&gt; I assume the challenge here is differentiating contains(element) from contains(closure).<br>&gt;&gt; This feels predicate-y, which is why I put it near the predicates. But I think something<br>&gt;&gt; like `containsElement(where:)` works better.<br>&gt; <br>&gt; I understand your motivation for suggesting it.  The downside is that it<br>&gt; severs the strong basename relationship between algorithms that do<br>&gt; effectively the same things, one using a default comparison and the<br>&gt; other using an explicitly-specified one.  I&#39;m truly not sure where we<br>&gt; ought to land on this one.<br></p><p>May I recommend `predicate:` then since it looks like that&#39;s actually a possibility?<br></p><p>&gt; <br>&gt;&gt; -    let result = try base._withUnsafeMutableBufferPointerIfSupported(body)<br>&gt;&gt; +    let result = try base._withUnsafeMutableBufferPointerIfSupported(invoke: body)<br>&gt;&gt; <br>&gt;&gt; I hate &quot;ifSupported&quot; <br>&gt; <br>&gt; Me too.<br>&gt; <br>&gt;&gt; but that&#39;s another discussion<br>&gt; <br>&gt; Quite.  It&#39;s also an internal API so it&#39;s not an evolution issue.  The<br>&gt; point of having that change as part of the diff (as with all the other<br>&gt; use sites), is to observe how the changes affect real usage.<br></p><p>Woody Allen: &quot;The heart wants what it wants&quot;<br>Me: &quot;The spleen vents what it vents&quot;<br></p><p>&gt; <br>&gt;&gt; (withSupportedUnsafeMutableBufferPointer,<br>&gt;&gt; withAvailableUnsafeMutableBufferPointer, it&#39;s all lipstick)<br>&gt;&gt; <br>&gt;&gt; This is procedural, so `do` or `perform` rather than `invoke`<br>&gt;&gt; <br>&gt;&gt; -      for test in removeFirstTests.filter({ $0.numberToRemove == 1 }) {<br>&gt;&gt; +      for test in removeFirstTests.filter(<br>&gt;&gt; +        suchThat: { $0.numberToRemove == 1 }<br>&gt;&gt; <br>&gt;&gt; The difference between `filter` and `forEach` is that `forEach` is explicitly <br>&gt;&gt; procedural while `filter` is functional.  I do not like functional chainable<br>&gt;&gt; calls being modified to use explicit external labels in this way. <br>&gt;&gt; <br>&gt;&gt; I&#39;d prefer no label here.<br>&gt; <br>&gt; Can you provide rationale for treating functional methods differently,<br>&gt; or is it just personal taste?<br></p><p>Functional programming flow. I follow Kevin Ballard&#39;s rule of parens around<br>functional elements and naked braces for trailing closures that do not return<br>values. This ensures the compiler is never confused at places like:<br></p><p>for x in foo when y.f{...} {<br>    ...<br>}<br></p><p>and instantly identifies to the reader when there&#39;s a non-returning scope, as<br>in forEach or GCD dispatch.<br></p><p>However, if you use chaining and if the language insists on external label <br>preambles, which would not be seen when using the call with a trailing closure,<br>it becomes far less readable and encourages people  to use trailing closures to <br>avoid the label, i.e. an attractive nuisance. Simple selectors encourage better fp:<br></p><p>let x = myStream.f1({...}).f2({...})<br></p><p>&gt; <br>&gt;&gt; public func split(<br>&gt;&gt;      maxSplits: Int = Int.max,<br>&gt;&gt;      omittingEmptySubsequences: Bool = true,<br>&gt;&gt; -    isSeparator: @noescape (Base.Iterator.Element) throws -&gt; Bool<br>&gt;&gt; +    separatedWhere isSeparator: @noescape (Base.Iterator.Element) throws -&gt; Bool<br>&gt;&gt; <br>&gt;&gt; I&#39;m torn on this one. It&#39;s not the worst ever but something more like where/at/when<br>&gt;&gt; makes more sense to me than<br>&gt;&gt; &quot;separatedWhere/separatedAt/separatedWhen&quot;.<br>&gt; <br>&gt; The biggest reason to keep “separate” in the name is the connection with<br>&gt; the semantics of the other `split` method, that takes a single element<br>&gt; that is tested for equality.  I think this is very similar to the<br>&gt; `contains(elementWhere` vs `containsElement(where` discussion.  If you<br>&gt; leave “separate” out of the name it fails to imply that those elements<br>&gt; for which the predicate returns true are not present in the result.<br></p><p>`predicate` ftw.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; +      count: __manager._headerPointer.pointee.count)<br>&gt;&gt; <br>&gt;&gt; For the sake of Zippy the Pinhead, surely there has to be something better than `pointee`.<br>&gt;&gt; Like...`reference`?<br>&gt; <br>&gt; It&#39;s not a reference; it&#39;s a value.  But that, my friend, is an<br>&gt; *entirely* different discussion. Let&#39;s try to stick to the scope of the<br>&gt; proposal: names and labels for parameters of function type, OK?<br></p><p>It was humor. It was at the end. I assumed the joke would lighten the<br>previous complaints and bookend the positive support at the start of<br>my message.<br></p><p>&gt; <br>&gt; -- <br>&gt; -Dave<br></p><p>-- E<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160625/9b41c128/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>Stdlib closure argument labels and parameter names</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>June 26, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On 26 Jun 2016, at 02:03, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Jun 25, 2016, at 4:25 PM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt; on Wed Jun 22 2016, Erica Sadun &lt;erica-AT-ericasadun.com &lt;http://erica-at-ericasadun.com/&gt;&gt; wrote:<br>&gt;&gt; On Jun 20, 2016, at 3:25 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -    func forEach&lt;S: SequenceType&gt;(_ body: (S.Iterator.Element) -&gt; ())<br>&gt;&gt;&gt; +    func forEach&lt;S: SequenceType&gt;(invoke body: (S.Iterator.Element) -&gt; ())<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Adding an external label makes sense here. This is a procedural call and<br>&gt;&gt;&gt; using it within the parens should have a &quot;code ripple&quot;.<br>&gt;&gt; <br>&gt;&gt; I don&#39;t think I understand what you mean here.<br>&gt; <br>&gt; When using a procedural &quot;trailable&quot; closure inside parentheses, the intention<br>&gt; to do so should be clear:<br>&gt; <br>&gt; p(x, perform: {...})<br>&gt; p(x, do: {...})<br>&gt; <br>&gt; vs<br>&gt; <br>&gt; p(x) {<br>&gt;    ...<br>&gt; }<br>&gt; <br>&gt; Anyone reading this code can immediately identify that an otherwise trailing<br>&gt; closure has been pulled inside the signature because the call has become <br>&gt; significantly more  complex. The point-of-coding decision ripples through<br>&gt; to point-of-reading/point-of-maintenance.<br>&gt; <br>&gt;&gt;&gt; That said, would prefer `do` or `perform` over `invoke` or `invoking` as in<br>&gt;&gt;&gt; `runRaceTest`, `_forAllPermutationsImpl`, `expectFailure`, etc. <br>&gt;&gt; <br>&gt;&gt; Sorry, again, I&#39;m a little lost.  Forgive my overly-literal brain but<br>&gt;&gt; could you please spell out how those latter 3 names relate to the choice<br>&gt;&gt; of `do` or `perform` over `invoke`?   <br>&gt; <br>&gt; I read through the pull request. I grouped related modifications<br>&gt; together, although not exhaustively. They fall under the same umbrella, <br>&gt; choosing `do` or `perform` compared to `invoke` or `invoking`.<br>&gt; <br>&gt; -    _forAllPermutationsImpl(index + 1, size, &amp;perm, &amp;visited, body)<br>&gt; +    _forAllPermutationsImpl(index + 1, size, &amp;perm, &amp;visited, invoke: body)<br>&gt; <br>&gt; -public func runRaceTest(trials: Int, threads: Int? = nil, body: () -&gt; ()) {<br>&gt; +public func runRaceTest(<br>&gt; +  trials: Int, threads: Int? = nil, invoking body: () -&gt; ()<br>&gt; +) {<br>&gt; <br>&gt; -public func expectFailure(${TRACE}, body: () -&gt; Void) {<br>&gt; +public func expectFailure(${TRACE}, invoking body: () -&gt; Void) {<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; This also applies where there&#39;s a `body` label instead of an empty<br>&gt;&gt;&gt; external label.<br>&gt;&gt; <br>&gt;&gt; We don&#39;t have any methods with a `body` label IIUC.<br>&gt; <br>&gt; You did, as in the examples just above, which you recommend a rename to `invoke` or<br>&gt; `invoking`.<br>&gt; <br>&gt;&gt;&gt; -public func withInvalidOrderings(_ body: ((Int, Int) -&gt; Bool) -&gt; Void) {<br>&gt;&gt;&gt; +public func withInvalidOrderings(invoke body: ((Int, Int) -&gt; Bool) -&gt; Void) {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For any with/external label pair, I&#39;d prefer `with-do` or `with-perform` <br>&gt;&gt;&gt; over `with-invoke`.<br>&gt;&gt; <br>&gt;&gt; OK.  Is there a rationale, or is it just personal taste?<br>&gt; <br>&gt; Strong personal taste, backed by tech writing. Simpler words. <br>&gt; From the Corpus of Contemporary American English:<br>&gt; do: 18<br>&gt; perform: 955<br>&gt; invoke: does not appear on list.<br>&gt;&gt; <br>&gt;&gt;&gt; -  return IteratorSequence(it).reduce(initial, combine: f)<br>&gt;&gt;&gt; +  return IteratorSequence(it).reduce(initial, accumulatingBy: f)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For `reduce`, I&#39;d prefer `applying:` or `byApplying:`<br>&gt;&gt; <br>&gt;&gt; Makes sense.<br>&gt;&gt; <br>&gt;&gt;&gt; Similarly in `starts(with:comparingBy:)`, I&#39;d prefer byComparing`,<br>&gt;&gt; <br>&gt;&gt; I don&#39;t see how that works.  You&#39;re not comparing the closure with<br>&gt;&gt; anything.<br>&gt; <br>&gt; I get your point but I think it&#39;s unnecessarily fussy. <br>&gt; <br>&gt; Alternatives are slim on the ground. `usingComparison:` is too long,<br>&gt; as is `byComparingWith:` (which still reads better but you will point<br>&gt; out can be mistaken by some pedant to mean that the sequence is being<br>&gt; compared to the closure), and you won&#39;t allow for `comparing:`.<br>&gt; I&#39;m not in love with `comparingWith:` but it reads slightly better to me <br>&gt; than `comparingBy:`.<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; min/max, byOrdering<br>&gt;&gt; <br>&gt;&gt; Likewise, you&#39;re not ordering the closure.<br>&gt; <br>&gt; Same reasoning.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; -      ).encode(encoding, output: output)<br>&gt;&gt;&gt; +      ).encode(encoding, sendingOutputTo: processCodeUnit)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; How about `exportingTo`?<br>&gt;&gt; <br>&gt;&gt; “export” is freighted with various connotations that I don&#39;t think we<br>&gt;&gt; want to make here.  In fact it doesn&#39;t mean anything more exotic than<br>&gt;&gt; “sending output to.”<br>&gt; <br>&gt; For a language that treasures concision and clarity, this may be clear<br>&gt; but it&#39;s notably inconcise. (Yes, that is a new word.)<br></p><p>verbose<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; -  tempwords.sort(isOrderedBefore: &lt;)<br>&gt;&gt;&gt; +  tempwords.sort(orderingBy: &lt;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With `sort` and `sorted`, I&#39;d prefer `by:`<br>&gt;&gt; <br>&gt;&gt; When people talk about “sorting by XXX”, XXX is a property of the<br>&gt;&gt; elements being sorted.  Therefore IMIO that label should probably be<br>&gt;&gt; reserved for a version that takes a unary projection function:<br>&gt;&gt; <br>&gt;&gt;     friends.sort(by: {$0.lastName})<br>&gt; <br>&gt; But they&#39;re sorting now, and that feature isn&#39;t in Swift.<br>&gt; <br>&gt; However, `sorted` falls under another umbrella, which is potential<br>&gt; chaining. In such case, I would prefer there be no internal label at all<br>&gt; to allow cleaner functional flow.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; -  if !expected.elementsEqual(actual, isEquivalent: sameValue) {<br>&gt;&gt;&gt; +  if !expected.elementsEqual(actual, comparingBy: sameValue) {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m torn on this one. I don&#39;t like but I don&#39;t have a good solution.<br>&gt; <br>&gt; I actually meant to move this up to the other discussion of `byComparing` and<br>&gt; forgot to. So please assume you disagree with me on this one too.<br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  /// for which `predicate(x) == true`.<br>&gt;&gt;&gt; +  /// for which `isIncluded(x) == true`.<br>&gt;&gt;&gt; -      _base: base.makeIterator(), whereElementsSatisfy: _include)<br>&gt;&gt;&gt; +      _base: base.makeIterator(), suchThat: _include)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; How about simply `include` for both? <br>&gt;&gt; <br>&gt;&gt; Looking at the effect on the doc comments—which is how we should judge<br>&gt;&gt; parameter names—I think `predicate` might read better.<br>&gt; <br>&gt; I like `predicate`. I endorse `predicate`. Does this mean the rule of &quot;must<br>&gt; read like a sentence&quot; can be overturned for things like &quot;comparison&quot; and<br>&gt; &quot;order&quot;? If so, woo!<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; I get the `is` desire but it&#39;s being tossed away in a lot of other<br>&gt;&gt;&gt; places in this diff. and `suchThat` feels out of place.<br>&gt;&gt; <br>&gt;&gt; I think I&#39;m pretty strongly sold on “soEach” as a label for closures in<br>&gt;&gt; all the filtering components.<br>&gt; <br>&gt; To quote greatness:, &quot;I personally find `soEach` repulsive&quot;.<br>&gt; (cite: http://article.gmane.org/gmane.comp.lang.swift.evolution/16998/match=repulsive &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/16998/match=repulsive&gt;)<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; -      || u16.contains({ $0 &gt; 127 || _isspace_clocale($0) }) {<br>&gt;&gt;&gt; +    || u16.contains(elementWhere: { $0 &gt; 127 || _isspace_clocale($0) }) {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I assume the challenge here is differentiating contains(element) from contains(closure).<br>&gt;&gt;&gt; This feels predicate-y, which is why I put it near the predicates. But I think something<br>&gt;&gt;&gt; like `containsElement(where:)` works better.<br>&gt;&gt; <br>&gt;&gt; I understand your motivation for suggesting it.  The downside is that it<br>&gt;&gt; severs the strong basename relationship between algorithms that do<br>&gt;&gt; effectively the same things, one using a default comparison and the<br>&gt;&gt; other using an explicitly-specified one.  I&#39;m truly not sure where we<br>&gt;&gt; ought to land on this one.<br>&gt; <br>&gt; May I recommend `predicate:` then since it looks like that&#39;s actually a possibility?<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; -    let result = try base._withUnsafeMutableBufferPointerIfSupported(body)<br>&gt;&gt;&gt; +    let result = try base._withUnsafeMutableBufferPointerIfSupported(invoke: body)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I hate &quot;ifSupported&quot; <br>&gt;&gt; <br>&gt;&gt; Me too.<br>&gt;&gt; <br>&gt;&gt;&gt; but that&#39;s another discussion<br>&gt;&gt; <br>&gt;&gt; Quite.  It&#39;s also an internal API so it&#39;s not an evolution issue.  The<br>&gt;&gt; point of having that change as part of the diff (as with all the other<br>&gt;&gt; use sites), is to observe how the changes affect real usage.<br>&gt; <br>&gt; Woody Allen: &quot;The heart wants what it wants&quot;<br>&gt; Me: &quot;The spleen vents what it vents&quot;<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; (withSupportedUnsafeMutableBufferPointer,<br>&gt;&gt;&gt; withAvailableUnsafeMutableBufferPointer, it&#39;s all lipstick)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is procedural, so `do` or `perform` rather than `invoke`<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -      for test in removeFirstTests.filter({ $0.numberToRemove == 1 }) {<br>&gt;&gt;&gt; +      for test in removeFirstTests.filter(<br>&gt;&gt;&gt; +        suchThat: { $0.numberToRemove == 1 }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The difference between `filter` and `forEach` is that `forEach` is explicitly <br>&gt;&gt;&gt; procedural while `filter` is functional.  I do not like functional chainable<br>&gt;&gt;&gt; calls being modified to use explicit external labels in this way. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;d prefer no label here.<br>&gt;&gt; <br>&gt;&gt; Can you provide rationale for treating functional methods differently,<br>&gt;&gt; or is it just personal taste?<br>&gt; <br>&gt; Functional programming flow. I follow Kevin Ballard&#39;s rule of parens around<br>&gt; functional elements and naked braces for trailing closures that do not return<br>&gt; values. This ensures the compiler is never confused at places like:<br>&gt; <br>&gt; for x in foo when y.f{...} {<br>&gt;     ...<br>&gt; }<br>&gt; <br>&gt; and instantly identifies to the reader when there&#39;s a non-returning scope, as<br>&gt; in forEach or GCD dispatch.<br>&gt; <br>&gt; However, if you use chaining and if the language insists on external label <br>&gt; preambles, which would not be seen when using the call with a trailing closure,<br>&gt; it becomes far less readable and encourages people  to use trailing closures to <br>&gt; avoid the label, i.e. an attractive nuisance. Simple selectors encourage better fp:<br>&gt; <br>&gt; let x = myStream.f1({...}).f2({...})<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; public func split(<br>&gt;&gt;&gt;      maxSplits: Int = Int.max,<br>&gt;&gt;&gt;      omittingEmptySubsequences: Bool = true,<br>&gt;&gt;&gt; -    isSeparator: @noescape (Base.Iterator.Element) throws -&gt; Bool<br>&gt;&gt;&gt; +    separatedWhere isSeparator: @noescape (Base.Iterator.Element) throws -&gt; Bool<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m torn on this one. It&#39;s not the worst ever but something more like where/at/when<br>&gt;&gt;&gt; makes more sense to me than<br>&gt;&gt;&gt; &quot;separatedWhere/separatedAt/separatedWhen&quot;.<br>&gt;&gt; <br>&gt;&gt; The biggest reason to keep “separate” in the name is the connection with<br>&gt;&gt; the semantics of the other `split` method, that takes a single element<br>&gt;&gt; that is tested for equality.  I think this is very similar to the<br>&gt;&gt; `contains(elementWhere` vs `containsElement(where` discussion.  If you<br>&gt;&gt; leave “separate” out of the name it fails to imply that those elements<br>&gt;&gt; for which the predicate returns true are not present in the result.<br>&gt; <br>&gt; `predicate` ftw.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +      count: __manager._headerPointer.pointee.count)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For the sake of Zippy the Pinhead, surely there has to be something better than `pointee`.<br>&gt;&gt;&gt; Like...`reference`?<br>&gt;&gt; <br>&gt;&gt; It&#39;s not a reference; it&#39;s a value.  But that, my friend, is an<br>&gt;&gt; *entirely* different discussion. Let&#39;s try to stick to the scope of the<br>&gt;&gt; proposal: names and labels for parameters of function type, OK?<br>&gt; <br>&gt; It was humor. It was at the end. I assumed the joke would lighten the<br>&gt; previous complaints and bookend the positive support at the start of<br>&gt; my message.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>The problem with finding a good argument label for “filter” is that when you use it as a verb in regular English, you typically mean to filter something _out_, but in this usage, we mean a specifier for the items to include.<br></p><p>If we flipped it (that’s another proposal, I know), we could have the eloquent-looking:<br></p><p>[1, 2, 3, 4, 5].filter(out: { $0 &gt; 3 })   // Returns [1, 2, 3] <br></p><p>Otherwise, the only context I can think of where you regularly talk about inclusive filters is in electronics, where we have low-pass/high-pass filters. Given that:<br></p><p>[1, 2, 3, 4, 5].filter(passing: { $0 % 2 == 0 })   // Returns [2, 4] <br></p><p>I’m not sure about it, but I definitely think it should be “passing” or “including” or some other very descriptive word that indicates the closure is a pass condition. “filter(where: {})” could be either an inclusive or exclusive filter.<br></p><p>Karl<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160626/67a4a2a7/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Stdlib closure argument labels and parameter names</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June 26, 2016 at 09:00:00am</p></header><div class="content"><p>on Sat Jun 25 2016, Erica Sadun &lt;erica-AT-ericasadun.com&gt; wrote:<br></p><p>&gt; On Jun 25, 2016, at 4:25 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; on Wed Jun 22 2016, Erica Sadun &lt;erica-AT-ericasadun.com&gt; wrote:<br>&gt;&gt; On Jun 20, 2016, at 3:25 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -    func forEach&lt;S: SequenceType&gt;(_ body: (S.Iterator.Element) -&gt; ())<br>&gt;&gt;&gt; +    func forEach&lt;S: SequenceType&gt;(invoke body: (S.Iterator.Element) -&gt; ())<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Adding an external label makes sense here. This is a procedural call and<br>&gt;&gt;&gt; using it within the parens should have a &quot;code ripple&quot;.<br>&gt;&gt; <br>&gt;&gt; I don&#39;t think I understand what you mean here.<br>&gt;<br>&gt; When using a procedural &quot;trailable&quot; closure inside parentheses, the intention<br>&gt; to do so should be clear:<br>&gt;<br>&gt; p(x, perform: {...})<br>&gt; p(x, do: {...})<br>&gt;<br>&gt; vs<br>&gt;<br>&gt; p(x) {<br>&gt;    ...<br>&gt; }<br>&gt;<br>&gt; Anyone reading this code can immediately identify that an otherwise trailing<br>&gt; closure has been pulled inside the signature because the call has become <br>&gt; significantly more  complex. The point-of-coding decision ripples through<br>&gt; to point-of-reading/point-of-maintenance.<br>&gt;<br>&gt;&gt;&gt; That said, would prefer `do` or `perform` over `invoke` or `invoking` as in<br>&gt;&gt;&gt; `runRaceTest`, `_forAllPermutationsImpl`, `expectFailure`, etc. <br>&gt;&gt; <br>&gt;&gt; Sorry, again, I&#39;m a little lost.  Forgive my overly-literal brain but<br>&gt;&gt; could you please spell out how those latter 3 names relate to the choice<br>&gt;&gt; of `do` or `perform` over `invoke`?   <br>&gt;<br>&gt; I read through the pull request. I grouped related modifications<br>&gt; together, although not exhaustively. They fall under the same umbrella, <br>&gt; choosing `do` or `perform` compared to `invoke` or `invoking`.<br>&gt;<br>&gt; -    _forAllPermutationsImpl(index + 1, size, &amp;perm, &amp;visited, body)<br>&gt; +    _forAllPermutationsImpl(index + 1, size, &amp;perm, &amp;visited, invoke: body)<br>&gt;<br>&gt; -public func runRaceTest(trials: Int, threads: Int? = nil, body: () -&gt; ()) {<br>&gt; +public func runRaceTest(<br>&gt; +  trials: Int, threads: Int? = nil, invoking body: () -&gt; ()<br>&gt; +) {<br>&gt;<br>&gt; -public func expectFailure(${TRACE}, body: () -&gt; Void) {<br>&gt; +public func expectFailure(${TRACE}, invoking body: () -&gt; Void) {<br></p><p>OK, I understand your process now.  I still don&#39;t understand your<br>rationale for saying `do` or `perform` is better than `invoke`.  Or is<br>it just personal taste?<br></p><p>&gt;&gt; <br>&gt;&gt;&gt; This also applies where there&#39;s a `body` label instead of an empty<br>&gt;&gt;&gt; external label.<br>&gt;&gt; <br>&gt;&gt; We don&#39;t have any methods with a `body` label IIUC.<br>&gt;<br>&gt; You did, as in the examples just above, which you recommend a rename to `invoke` or<br>&gt; `invoking`.<br></p><p>Ah, thanks.<br></p><p>&gt;&gt;&gt; -public func withInvalidOrderings(_ body: ((Int, Int) -&gt; Bool) -&gt; Void) {<br>&gt;&gt;&gt; +public func withInvalidOrderings(invoke body: ((Int, Int) -&gt; Bool) -&gt; Void) {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For any with/external label pair, I&#39;d prefer `with-do` or `with-perform` <br>&gt;&gt;&gt; over `with-invoke`.<br>&gt;&gt; <br>&gt;&gt; OK.  Is there a rationale, or is it just personal taste?<br>&gt;<br>&gt; Strong personal taste, backed by tech writing. Simpler words. <br>&gt; From the Corpus of Contemporary American English:<br>&gt; do: 18<br>&gt; perform: 955<br>&gt; invoke: does not appear on list.<br></p><p>I&#39;m unable to reproduce those numbers using http://corpus.byu.edu/coca/.<br>What exactly did you do to get them?<br></p><p>Also, I&#39;m not sure commonality of use is a good rationale.  I bet<br>“function” doesn&#39;t appear as often as “task” either, but the argument<br>here is a function and we invoke functions.  Sometimes the appropriate<br>word is just less common.<br></p><p>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; -  return IteratorSequence(it).reduce(initial, combine: f)<br>&gt;&gt;&gt; +  return IteratorSequence(it).reduce(initial, accumulatingBy: f)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For `reduce`, I&#39;d prefer `applying:` or `byApplying:`<br>&gt;&gt; <br>&gt;&gt; Makes sense.<br>&gt;&gt; <br>&gt;&gt;&gt; Similarly in `starts(with:comparingBy:)`, I&#39;d prefer byComparing`,<br>&gt;&gt; <br>&gt;&gt; I don&#39;t see how that works.  You&#39;re not comparing the closure with<br>&gt;&gt; anything.<br>&gt;<br>&gt; I get your point but I think it&#39;s unnecessarily fussy. <br></p><p>I plead guilty to sometimes having unnecessarily fussy tendencies, but<br>in this case I believe strongly that “byComparing” would be actively<br>misleading and harmful.  Even if there&#39;s only one possible sane<br>interpretation, if readers have to scratch their heads and do an<br>exhaustive search through possible interpretations of what something<br>might mean because the one directly implied by the grammar is nonsense,<br>that&#39;s bad.<br></p><p>&gt; Alternatives are slim on the ground. `usingComparison:` is too long,<br>&gt; as is `byComparingWith:` (which still reads better but you will point<br>&gt; out can be mistaken by some pedant to mean that the sequence is being<br>&gt; compared to the closure), and you won&#39;t allow for `comparing:`.  I&#39;m<br>&gt; not in love with `comparingWith:` but it reads slightly better to me<br>&gt; than `comparingBy:`.<br></p><p>There is definitely something awkward about “xxxBy:” for these uses, and<br>I&#39;m open to using “xxxWith:” instead, even though as you say it&#39;s<br>confusable.<br></p><p>  if x.starts(with: y, comparingBy: { $0.name == $1.name }) {<br>    ...<br>  }<br></p><p>  if x.starts(with: y, comparingWith: { $0.name == $1.name }) {<br>    ...<br>  }<br></p><p>At some point I start to wonder if giving up fluency is best:<br></p><p>  if x.starts(with: y, equality: { $0.name == $1.name }) {<br>    ...<br>  }<br></p><p>&gt;&gt;&gt; min/max, byOrdering<br>&gt;&gt; <br>&gt;&gt; Likewise, you&#39;re not ordering the closure.<br>&gt;<br>&gt; Same reasoning.<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; -      ).encode(encoding, output: output)<br>&gt;&gt;&gt; +      ).encode(encoding, sendingOutputTo: processCodeUnit)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; How about `exportingTo`?<br>&gt;&gt; <br>&gt;&gt; “export” is freighted with various connotations that I don&#39;t think we<br>&gt;&gt; want to make here.  In fact it doesn&#39;t mean anything more exotic than<br>&gt;&gt; “sending output to.”<br>&gt;<br>&gt; For a language that treasures concision and clarity, this may be clear<br>&gt; but it&#39;s notably inconcise. (Yes, that is a new word.)<br></p><p>I agree, but if you want concision I&#39;d rather stick with something that<br>doesn&#39;t imply anything unintended, such as “to” or “into.”<br></p><p>&gt;&gt;&gt; -  tempwords.sort(isOrderedBefore: &lt;)<br>&gt;&gt;&gt; +  tempwords.sort(orderingBy: &lt;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With `sort` and `sorted`, I&#39;d prefer `by:`<br>&gt;&gt; <br>&gt;&gt; When people talk about “sorting by XXX”, XXX is a property of the<br>&gt;&gt; elements being sorted.  Therefore IMIO that label should probably be<br>&gt;&gt; reserved for a version that takes a unary projection function:<br>&gt;&gt; <br>&gt;&gt;     friends.sort(by: {$0.lastName})<br>&gt;<br>&gt; But they&#39;re sorting now, and that feature isn&#39;t in Swift.<br></p><p>That doesn&#39;t mean we should claim the syntax for another purpose.<br>I think we probably do want that feature eventually.<br></p><p>&gt; However, `sorted` falls under another umbrella, which is potential<br>&gt; chaining. In such case, I would prefer there be no internal label at all<br>&gt; to allow cleaner functional flow.<br></p><p>IMO whether a method has a non-Void return value (and thus is chainable)<br>should not be the determining feature on whether we use argument labels.<br></p><p>We *could* decide to drop all labels for trailing closures (on the<br>grounds that they often won&#39;t appear at the call site) and say the<br>policy is that if there&#39;s something you want to communicate about the<br>closure&#39;s role, you simply do the best you can with the parameter name<br>and let the clarity at the call site fend for itself.  That, at least,<br>would be a reasonably principled approach.<br></p><p>&gt;&gt;&gt; -  if !expected.elementsEqual(actual, isEquivalent: sameValue) {<br>&gt;&gt;&gt; +  if !expected.elementsEqual(actual, comparingBy: sameValue) {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m torn on this one. I don&#39;t like but I don&#39;t have a good solution.<br>&gt;<br>&gt; I actually meant to move this up to the other discussion of `byComparing` and<br>&gt; forgot to. So please assume you disagree with me on this one too.<br>&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  /// for which `predicate(x) == true`.<br>&gt;&gt;&gt; +  /// for which `isIncluded(x) == true`.<br>&gt;&gt;&gt; -      _base: base.makeIterator(), whereElementsSatisfy: _include)<br>&gt;&gt;&gt; +      _base: base.makeIterator(), suchThat: _include)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; How about simply `include` for both? <br>&gt;&gt; <br>&gt;&gt; Looking at the effect on the doc comments—which is how we should judge<br>&gt;&gt; parameter names—I think `predicate` might read better.<br>&gt;<br>&gt; I like `predicate`. I endorse `predicate`. Does this mean the rule of &quot;must<br>&gt; read like a sentence&quot; can be overturned for things like &quot;comparison&quot; and<br>&gt; &quot;order&quot;? If so, woo!<br></p><p>I don&#39;t know what you mean.  There is no such rule.  There are<br>guidelines about reading like a phrase at the use site, but the<br>*parameter name* has no effect on the use site.<br></p><p>&gt;&gt;&gt; I get the `is` desire but it&#39;s being tossed away in a lot of other<br>&gt;&gt;&gt; places in this diff. and `suchThat` feels out of place.<br>&gt;&gt; <br>&gt;&gt; I think I&#39;m pretty strongly sold on “soEach” as a label for closures in<br>&gt;&gt; all the filtering components.<br>&gt;<br>&gt; To quote greatness:, &quot;I personally find `soEach` repulsive&quot;.<br>&gt; (cite:<br>&gt; http://article.gmane.org/gmane.comp.lang.swift.evolution/16998/match=repulsive<br>&gt; &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/16998/match=repulsive&gt;)<br></p><p>Sorry to hear that.  Let&#39;s change “filter” to “where” so this can become<br>a non-issue.<br></p><p>&gt;&gt; <br>&gt;&gt;&gt; -      || u16.contains({ $0 &gt; 127 || _isspace_clocale($0) }) {<br>&gt;&gt;&gt; +    || u16.contains(elementWhere: { $0 &gt; 127 || _isspace_clocale($0) }) {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I assume the challenge here is differentiating contains(element) from contains(closure).<br>&gt;&gt;&gt; This feels predicate-y, which is why I put it near the predicates. But I think something<br>&gt;&gt;&gt; like `containsElement(where:)` works better.<br>&gt;&gt; <br>&gt;&gt; I understand your motivation for suggesting it.  The downside is that it<br>&gt;&gt; severs the strong basename relationship between algorithms that do<br>&gt;&gt; effectively the same things, one using a default comparison and the<br>&gt;&gt; other using an explicitly-specified one.  I&#39;m truly not sure where we<br>&gt;&gt; ought to land on this one.<br>&gt;<br>&gt; May I recommend `predicate:` then since it looks like that&#39;s actually<br>&gt; a possibility?<br></p><p>I never suggested predicate as an argument label.<br></p><p>&gt;&gt;&gt; -    let result = try base._withUnsafeMutableBufferPointerIfSupported(body)<br>&gt;&gt;&gt; +    let result = try base._withUnsafeMutableBufferPointerIfSupported(invoke: body)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I hate &quot;ifSupported&quot; <br>&gt;&gt; <br>&gt;&gt; Me too.<br>&gt;&gt; <br>&gt;&gt;&gt; but that&#39;s another discussion<br>&gt;&gt; <br>&gt;&gt; Quite.  It&#39;s also an internal API so it&#39;s not an evolution issue.  The<br>&gt;&gt; point of having that change as part of the diff (as with all the other<br>&gt;&gt; use sites), is to observe how the changes affect real usage.<br>&gt;<br>&gt; Woody Allen: &quot;The heart wants what it wants&quot;<br>&gt; Me: &quot;The spleen vents what it vents&quot;<br></p><p>SOL (snort out loud)<br></p><p>&gt;&gt; <br>&gt;&gt;&gt; (withSupportedUnsafeMutableBufferPointer,<br>&gt;&gt;&gt; withAvailableUnsafeMutableBufferPointer, it&#39;s all lipstick)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is procedural, so `do` or `perform` rather than `invoke`<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -      for test in removeFirstTests.filter({ $0.numberToRemove == 1 }) {<br>&gt;&gt;&gt; +      for test in removeFirstTests.filter(<br>&gt;&gt;&gt; +        suchThat: { $0.numberToRemove == 1 }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The difference between `filter` and `forEach` is that `forEach` is explicitly <br>&gt;&gt;&gt; procedural while `filter` is functional.  I do not like functional chainable<br>&gt;&gt;&gt; calls being modified to use explicit external labels in this way. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;d prefer no label here.<br>&gt;&gt; <br>&gt;&gt; Can you provide rationale for treating functional methods differently,<br>&gt;&gt; or is it just personal taste?<br>&gt;<br>&gt; Functional programming flow. I follow Kevin Ballard&#39;s rule of parens around<br>&gt; functional elements and naked braces for trailing closures that do not return<br>&gt; values. This ensures the compiler is never confused at places like:<br>&gt;<br>&gt; for x in foo when y.f{...} {<br>&gt;     ...<br>&gt; }<br></p><p>? It&#39;s never confused there; it tells you it&#39;s illegal.<br></p><p>&gt; and instantly identifies to the reader when there&#39;s a non-returning scope, as<br>&gt; in forEach or GCD dispatch.<br></p><p>Why is it useful to identify when there&#39;s a scope that doesn&#39;t return a<br>value?  Isn&#39;t that already clear from whether the value is assigned<br>somewhere?  <br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Stdlib closure argument labels and parameter names</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>June 26, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jun 26, 2016, at 10:35 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Sat Jun 25 2016, Erica Sadun &lt;erica-AT-ericasadun.com &lt;http://erica-at-ericasadun.com/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Jun 25, 2016, at 4:25 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt; on Wed Jun 22 2016, Erica Sadun &lt;erica-AT-ericasadun.com&gt; wrote:<br>&gt;&gt;&gt; On Jun 20, 2016, at 3:25 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -    func forEach&lt;S: SequenceType&gt;(_ body: (S.Iterator.Element) -&gt; ())<br>&gt;&gt;&gt;&gt; +    func forEach&lt;S: SequenceType&gt;(invoke body: (S.Iterator.Element) -&gt; ())<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Adding an external label makes sense here. This is a procedural call and<br>&gt;&gt;&gt;&gt; using it within the parens should have a &quot;code ripple&quot;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t think I understand what you mean here.<br>&gt;&gt; <br>&gt;&gt; When using a procedural &quot;trailable&quot; closure inside parentheses, the intention<br>&gt;&gt; to do so should be clear:<br>&gt;&gt; <br>&gt;&gt; p(x, perform: {...})<br>&gt;&gt; p(x, do: {...})<br>&gt;&gt; <br>&gt;&gt; vs<br>&gt;&gt; <br>&gt;&gt; p(x) {<br>&gt;&gt;   ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Anyone reading this code can immediately identify that an otherwise trailing<br>&gt;&gt; closure has been pulled inside the signature because the call has become <br>&gt;&gt; significantly more  complex. The point-of-coding decision ripples through<br>&gt;&gt; to point-of-reading/point-of-maintenance.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; That said, would prefer `do` or `perform` over `invoke` or `invoking` as in<br>&gt;&gt;&gt;&gt; `runRaceTest`, `_forAllPermutationsImpl`, `expectFailure`, etc. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sorry, again, I&#39;m a little lost.  Forgive my overly-literal brain but<br>&gt;&gt;&gt; could you please spell out how those latter 3 names relate to the choice<br>&gt;&gt;&gt; of `do` or `perform` over `invoke`?   <br>&gt;&gt; <br>&gt;&gt; I read through the pull request. I grouped related modifications<br>&gt;&gt; together, although not exhaustively. They fall under the same umbrella, <br>&gt;&gt; choosing `do` or `perform` compared to `invoke` or `invoking`.<br>&gt;&gt; <br>&gt;&gt; -    _forAllPermutationsImpl(index + 1, size, &amp;perm, &amp;visited, body)<br>&gt;&gt; +    _forAllPermutationsImpl(index + 1, size, &amp;perm, &amp;visited, invoke: body)<br>&gt;&gt; <br>&gt;&gt; -public func runRaceTest(trials: Int, threads: Int? = nil, body: () -&gt; ()) {<br>&gt;&gt; +public func runRaceTest(<br>&gt;&gt; +  trials: Int, threads: Int? = nil, invoking body: () -&gt; ()<br>&gt;&gt; +) {<br>&gt;&gt; <br>&gt;&gt; -public func expectFailure(${TRACE}, body: () -&gt; Void) {<br>&gt;&gt; +public func expectFailure(${TRACE}, invoking body: () -&gt; Void) {<br>&gt; <br>&gt; OK, I understand your process now.  I still don&#39;t understand your<br>&gt; rationale for saying `do` or `perform` is better than `invoke`.  Or is<br>&gt; it just personal taste?<br></p><p>See below.  But in a  nutshell, `do` gets the idea across. It&#39;s short. It&#39;s pithy.<br>It uses a common, comfortable word. So yes, personal taste. But it&#39;s personal<br>taste backed up by some statistics.<br></p><p>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This also applies where there&#39;s a `body` label instead of an empty<br>&gt;&gt;&gt;&gt; external label.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We don&#39;t have any methods with a `body` label IIUC.<br>&gt;&gt; <br>&gt;&gt; You did, as in the examples just above, which you recommend a rename to `invoke` or<br>&gt;&gt; `invoking`.<br>&gt; <br>&gt; Ah, thanks.<br>&gt; <br>&gt;&gt;&gt;&gt; -public func withInvalidOrderings(_ body: ((Int, Int) -&gt; Bool) -&gt; Void) {<br>&gt;&gt;&gt;&gt; +public func withInvalidOrderings(invoke body: ((Int, Int) -&gt; Bool) -&gt; Void) {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For any with/external label pair, I&#39;d prefer `with-do` or `with-perform` <br>&gt;&gt;&gt;&gt; over `with-invoke`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; OK.  Is there a rationale, or is it just personal taste?<br>&gt;&gt; <br>&gt;&gt; Strong personal taste, backed by tech writing. Simpler words. <br>&gt;&gt; From the Corpus of Contemporary American English:<br>&gt;&gt; do: 18<br>&gt;&gt; perform: 955<br>&gt;&gt; invoke: does not appear on list.<br>&gt; <br>&gt; I&#39;m unable to reproduce those numbers using http://corpus.byu.edu/coca/ &lt;http://corpus.byu.edu/coca/&gt;.<br>&gt; What exactly did you do to get them?<br></p><p>I used a secondary webpage that rates word frequency based on the COCA corpus:<br>http://www.wordfrequency.info/free.asp?s=y<br></p><p><br>&gt; Also, I&#39;m not sure commonality of use is a good rationale.  I bet<br>&gt; “function” doesn&#39;t appear as often as “task” either, but the argument<br>&gt; here is a function and we invoke functions.  Sometimes the appropriate<br>&gt; word is just less common.<br></p><p>1051 task<br>1449 function<br></p><p>Numbers aside, there&#39;s always a &quot;term of art&quot; argument to be made. A term of<br>art is precise and instantly communicates the meaning to the user. <br></p><p>I don&#39;t think a &quot;term of art&quot; argument can be made here since invoke, perform, and <br>do all communicate the same idea to the end-coder, who doesn&#39;t need to know <br>exactly how the compiler sees the argument.<br></p><p>In naming theory, I&#39;d say the member name carries the greatest weight when using<br>exact terms and that internal labels should accessorize the primary name. When using a<br>&quot;term of art&quot; argument, it should apply most strongly to a method/function/<br>property/type name and less to supporting external labels.<br></p><p>&gt;&gt;&gt;&gt; -  return IteratorSequence(it).reduce(initial, combine: f)<br>&gt;&gt;&gt;&gt; +  return IteratorSequence(it).reduce(initial, accumulatingBy: f)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For `reduce`, I&#39;d prefer `applying:` or `byApplying:`<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Makes sense.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Similarly in `starts(with:comparingBy:)`, I&#39;d prefer byComparing`,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t see how that works.  You&#39;re not comparing the closure with<br>&gt;&gt;&gt; anything.<br>&gt;&gt; <br>&gt;&gt; I get your point but I think it&#39;s unnecessarily fussy. <br>&gt; <br>&gt; I plead guilty to sometimes having unnecessarily fussy tendencies, but<br>&gt; in this case I believe strongly that “byComparing” would be actively<br>&gt; misleading and harmful.  Even if there&#39;s only one possible sane<br>&gt; interpretation, if readers have to scratch their heads and do an<br>&gt; exhaustive search through possible interpretations of what something<br>&gt; might mean because the one directly implied by the grammar is nonsense,<br>&gt; that&#39;s bad.<br></p><p>&quot;Comparing by&quot; is not actively misleading or harmful but it does sound<br>strained.  I think a well-designed language should use comfortable<br>constructs.Why not use a single , plain word that describes a parameter&#39;s<br>role. Why not &quot;compare:&quot;? It&#39;s far less fussy and it&#39;s clear.<br></p><p>&gt;&gt; Alternatives are slim on the ground. `usingComparison:` is too long,<br>&gt;&gt; as is `byComparingWith:` (which still reads better but you will point<br>&gt;&gt; out can be mistaken by some pedant to mean that the sequence is being<br>&gt;&gt; compared to the closure), and you won&#39;t allow for `comparing:`.  I&#39;m<br>&gt;&gt; not in love with `comparingWith:` but it reads slightly better to me<br>&gt;&gt; than `comparingBy:`.<br>&gt; <br>&gt; There is definitely something awkward about “xxxBy:” for these uses, and<br>&gt; I&#39;m open to using “xxxWith:” instead, even though as you say it&#39;s<br>&gt; confusable.<br>&gt; <br>&gt;  if x.starts(with: y, comparingBy: { $0.name == $1.name }) {<br>&gt;    ...<br>&gt;  }<br>&gt; <br>&gt;  if x.starts(with: y, comparingWith: { $0.name == $1.name }) {<br>&gt;    ...<br>&gt;  }<br>&gt; <br>&gt; At some point I start to wonder if giving up fluency is best:<br>&gt; <br>&gt;  if x.starts(with: y, equality: { $0.name == $1.name }) {<br>&gt;    ...<br>&gt;  }<br></p><p>Yes.  `predicate`, `compare` (or `comparison`), `order:`, etc.<br></p><p>To riff off Gerard Manley Hopkins, &quot;Glory be for simple things, for<br>short words and trim APIs&quot;.<br></p><p>&gt;&gt;&gt;&gt; min/max, byOrdering<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Likewise, you&#39;re not ordering the closure.<br>&gt;&gt; <br>&gt;&gt; Same reasoning.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -      ).encode(encoding, output: output)<br>&gt;&gt;&gt;&gt; +      ).encode(encoding, sendingOutputTo: processCodeUnit)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; How about `exportingTo`?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; “export” is freighted with various connotations that I don&#39;t think we<br>&gt;&gt;&gt; want to make here.  In fact it doesn&#39;t mean anything more exotic than<br>&gt;&gt;&gt; “sending output to.”<br>&gt;&gt; <br>&gt;&gt; For a language that treasures concision and clarity, this may be clear<br>&gt;&gt; but it&#39;s notably inconcise. (Yes, that is a new word.)<br>&gt; <br>&gt; I agree, but if you want concision I&#39;d rather stick with something that<br>&gt; doesn&#39;t imply anything unintended, such as “to” or “into.”<br></p><p>I much prefer `to` and `into`<br></p><p>&gt;&gt;&gt;&gt; -  tempwords.sort(isOrderedBefore: &lt;)<br>&gt;&gt;&gt;&gt; +  tempwords.sort(orderingBy: &lt;)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; With `sort` and `sorted`, I&#39;d prefer `by:`<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When people talk about “sorting by XXX”, XXX is a property of the<br>&gt;&gt;&gt; elements being sorted.  Therefore IMIO that label should probably be<br>&gt;&gt;&gt; reserved for a version that takes a unary projection function:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    friends.sort(by: {$0.lastName})<br>&gt;&gt; <br>&gt;&gt; But they&#39;re sorting now, and that feature isn&#39;t in Swift.<br>&gt; <br>&gt; That doesn&#39;t mean we should claim the syntax for another purpose.<br>&gt; I think we probably do want that feature eventually.<br>&gt; <br>&gt;&gt; However, `sorted` falls under another umbrella, which is potential<br>&gt;&gt; chaining. In such case, I would prefer there be no internal label at all<br>&gt;&gt; to allow cleaner functional flow.<br>&gt; <br>&gt; IMO whether a method has a non-Void return value (and thus is chainable)<br>&gt; should not be the determining feature on whether we use argument labels.<br></p><p>If any method returns a sequence or collection, I think it *should* be considered<br>in that specific light as a candidate for chaining. I agree that expanding that to<br>any return value is too wide.<br></p><p>&gt; We *could* decide to drop all labels for trailing closures (on the<br>&gt; grounds that they often won&#39;t appear at the call site) and say the<br>&gt; policy is that if there&#39;s something you want to communicate about the<br>&gt; closure&#39;s role, you simply do the best you can with the parameter name<br>&gt; and let the clarity at the call site fend for itself.  That, at least,<br>&gt; would be a reasonably principled approach.<br></p><p>I like labels for trailing closures when they are  `-&gt; Void`.  You know a priori<br>that the closure is used for side-effects, so if they are put into a function or<br>method call, the label alerts you to design intent.<br></p><p>I want to omit labels for trailing closures when they return collections, sequences, <br>iterators, etc. because these return types are most likely to be chained.<br></p><p>If you force a label for, say, map, people will choose <br></p><p>map {  ...  }<br></p><p>over<br></p><p>map(label: { ... })<br></p><p>because the former reads better, especially when chaining but it introduces<br>bad habits, because it will not compile when used with constructs like:<br></p><p>for i in map { ... } { // will not compile<br>    ... <br>}<br></p><p>But if you treat collection/sequence fp as &quot;highly likely to be chained&quot;, it encourages<br>results more like:<br></p><p>for i in x.map({ ...}).filter({ ... }) {<br>    ....<br>}<br></p><p>which is compiler-safe, more readable, etc, especially for very short-form items like:<br></p><p>for var i in x.flatMap({Int($0)}).filter({ $0 &lt; 10 }) {<br>    ...<br>}<br></p><p><br>&gt; <br>&gt;&gt;&gt;&gt; -  if !expected.elementsEqual(actual, isEquivalent: sameValue) {<br>&gt;&gt;&gt;&gt; +  if !expected.elementsEqual(actual, comparingBy: sameValue) {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m torn on this one. I don&#39;t like but I don&#39;t have a good solution.<br>&gt;&gt; <br>&gt;&gt; I actually meant to move this up to the other discussion of `byComparing` and<br>&gt;&gt; forgot to. So please assume you disagree with me on this one too.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  /// for which `predicate(x) == true`.<br>&gt;&gt;&gt;&gt; +  /// for which `isIncluded(x) == true`.<br>&gt;&gt;&gt;&gt; -      _base: base.makeIterator(), whereElementsSatisfy: _include)<br>&gt;&gt;&gt;&gt; +      _base: base.makeIterator(), suchThat: _include)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; How about simply `include` for both? <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Looking at the effect on the doc comments—which is how we should judge<br>&gt;&gt;&gt; parameter names—I think `predicate` might read better.<br>&gt;&gt; <br>&gt;&gt; I like `predicate`. I endorse `predicate`. Does this mean the rule of &quot;must<br>&gt;&gt; read like a sentence&quot; can be overturned for things like &quot;comparison&quot; and<br>&gt;&gt; &quot;order&quot;? If so, woo!<br>&gt; <br>&gt; I don&#39;t know what you mean.  There is no such rule.  There are<br>&gt; guidelines about reading like a phrase at the use site, but the<br>&gt; *parameter name* has no effect on the use site.<br>&gt; <br>&gt;&gt;&gt;&gt; I get the `is` desire but it&#39;s being tossed away in a lot of other<br>&gt;&gt;&gt;&gt; places in this diff. and `suchThat` feels out of place.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think I&#39;m pretty strongly sold on “soEach” as a label for closures in<br>&gt;&gt;&gt; all the filtering components.<br>&gt;&gt; <br>&gt;&gt; To quote greatness:, &quot;I personally find `soEach` repulsive&quot;.<br>&gt;&gt; (cite:<br>&gt;&gt; http://article.gmane.org/gmane.comp.lang.swift.evolution/16998/match=repulsive &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/16998/match=repulsive&gt;<br>&gt;&gt; &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/16998/match=repulsive &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/16998/match=repulsive&gt;&gt;)<br>&gt; <br>&gt; Sorry to hear that.  Let&#39;s change “filter” to “where” so this can become<br>&gt; a non-issue.<br></p><p>:)<br></p><p>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -      || u16.contains({ $0 &gt; 127 || _isspace_clocale($0) }) {<br>&gt;&gt;&gt;&gt; +    || u16.contains(elementWhere: { $0 &gt; 127 || _isspace_clocale($0) }) {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I assume the challenge here is differentiating contains(element) from contains(closure).<br>&gt;&gt;&gt;&gt; This feels predicate-y, which is why I put it near the predicates. But I think something<br>&gt;&gt;&gt;&gt; like `containsElement(where:)` works better.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I understand your motivation for suggesting it.  The downside is that it<br>&gt;&gt;&gt; severs the strong basename relationship between algorithms that do<br>&gt;&gt;&gt; effectively the same things, one using a default comparison and the<br>&gt;&gt;&gt; other using an explicitly-specified one.  I&#39;m truly not sure where we<br>&gt;&gt;&gt; ought to land on this one.<br>&gt;&gt; <br>&gt;&gt; May I recommend `predicate:` then since it looks like that&#39;s actually<br>&gt;&gt; a possibility?<br>&gt; <br>&gt; I never suggested predicate as an argument label.<br>&gt; <br>&gt;&gt;&gt;&gt; -    let result = try base._withUnsafeMutableBufferPointerIfSupported(body)<br>&gt;&gt;&gt;&gt; +    let result = try base._withUnsafeMutableBufferPointerIfSupported(invoke: body)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I hate &quot;ifSupported&quot; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Me too.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; but that&#39;s another discussion<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Quite.  It&#39;s also an internal API so it&#39;s not an evolution issue.  The<br>&gt;&gt;&gt; point of having that change as part of the diff (as with all the other<br>&gt;&gt;&gt; use sites), is to observe how the changes affect real usage.<br>&gt;&gt; <br>&gt;&gt; Woody Allen: &quot;The heart wants what it wants&quot;<br>&gt;&gt; Me: &quot;The spleen vents what it vents&quot;<br>&gt; <br>&gt; SOL (snort out loud)<br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (withSupportedUnsafeMutableBufferPointer,<br>&gt;&gt;&gt;&gt; withAvailableUnsafeMutableBufferPointer, it&#39;s all lipstick)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is procedural, so `do` or `perform` rather than `invoke`<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -      for test in removeFirstTests.filter({ $0.numberToRemove == 1 }) {<br>&gt;&gt;&gt;&gt; +      for test in removeFirstTests.filter(<br>&gt;&gt;&gt;&gt; +        suchThat: { $0.numberToRemove == 1 }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The difference between `filter` and `forEach` is that `forEach` is explicitly <br>&gt;&gt;&gt;&gt; procedural while `filter` is functional.  I do not like functional chainable<br>&gt;&gt;&gt;&gt; calls being modified to use explicit external labels in this way. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;d prefer no label here.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Can you provide rationale for treating functional methods differently,<br>&gt;&gt;&gt; or is it just personal taste?<br>&gt;&gt; <br>&gt;&gt; Functional programming flow. I follow Kevin Ballard&#39;s rule of parens around<br>&gt;&gt; functional elements and naked braces for trailing closures that do not return<br>&gt;&gt; values. This ensures the compiler is never confused at places like:<br>&gt;&gt; <br>&gt;&gt; for x in foo when y.f{...} {<br>&gt;&gt;    ...<br>&gt;&gt; }<br>&gt; <br>&gt; ? It&#39;s never confused there; it tells you it&#39;s illegal.<br>&gt; <br>&gt;&gt; and instantly identifies to the reader when there&#39;s a non-returning scope, as<br>&gt;&gt; in forEach or GCD dispatch.<br>&gt; <br>&gt; Why is it useful to identify when there&#39;s a scope that doesn&#39;t return a<br>&gt; value?  Isn&#39;t that already clear from whether the value is assigned<br>&gt; somewhere?  <br></p><p>Enhanced readability from explicit coding intent. Trailing closures <br>*look* like a scope created by a native construct. Those enclosed in <br>parens *look* like arguments.<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160626/703ab057/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Stdlib closure argument labels and parameter names</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 27, 2016 at 01:00:00am</p></header><div class="content"><p>On Sun, Jun 26, 2016 at 2:18 PM, Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Jun 26, 2016, at 10:35 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; on Sat Jun 25 2016, Erica Sadun &lt;erica-AT-ericasadun.com<br>&gt; &lt;http://erica-at-ericasadun.com/&gt;&gt; wrote:<br>&gt;<br>&gt; On Jun 25, 2016, at 4:25 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;<br>&gt; on Wed Jun 22 2016, Erica Sadun &lt;erica-AT-ericasadun.com<br>&gt; &lt;http://erica-at-ericasadun.com&gt;&gt; wrote:<br>&gt; On Jun 20, 2016, at 3:25 PM, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; -    func forEach&lt;S: SequenceType&gt;(_ body: (S.Iterator.Element) -&gt; ())<br>&gt; +    func forEach&lt;S: SequenceType&gt;(invoke body: (S.Iterator.Element) -&gt; ())<br>&gt;<br>&gt; Adding an external label makes sense here. This is a procedural call and<br>&gt; using it within the parens should have a &quot;code ripple&quot;.<br>&gt;<br>&gt;<br>&gt; I don&#39;t think I understand what you mean here.<br>&gt;<br>&gt;<br>&gt; When using a procedural &quot;trailable&quot; closure inside parentheses, the<br>&gt; intention<br>&gt; to do so should be clear:<br>&gt;<br>&gt; p(x, perform: {...})<br>&gt; p(x, do: {...})<br>&gt;<br>&gt; vs<br>&gt;<br>&gt; p(x) {<br>&gt;   ...<br>&gt; }<br>&gt;<br>&gt; Anyone reading this code can immediately identify that an otherwise<br>&gt; trailing<br>&gt; closure has been pulled inside the signature because the call has become<br>&gt; significantly more  complex. The point-of-coding decision ripples through<br>&gt; to point-of-reading/point-of-maintenance.<br>&gt;<br>&gt; That said, would prefer `do` or `perform` over `invoke` or `invoking` as in<br>&gt; `runRaceTest`, `_forAllPermutationsImpl`, `expectFailure`, etc.<br>&gt;<br>&gt;<br>&gt; Sorry, again, I&#39;m a little lost.  Forgive my overly-literal brain but<br>&gt; could you please spell out how those latter 3 names relate to the choice<br>&gt; of `do` or `perform` over `invoke`?<br>&gt;<br>&gt;<br>&gt; I read through the pull request. I grouped related modifications<br>&gt; together, although not exhaustively. They fall under the same umbrella,<br>&gt; choosing `do` or `perform` compared to `invoke` or `invoking`.<br>&gt;<br>&gt; -    _forAllPermutationsImpl(index + 1, size, &amp;perm, &amp;visited, body)<br>&gt; +    _forAllPermutationsImpl(index + 1, size, &amp;perm, &amp;visited, invoke:<br>&gt; body)<br>&gt;<br>&gt; -public func runRaceTest(trials: Int, threads: Int? = nil, body: () -&gt; ())<br>&gt; {<br>&gt; +public func runRaceTest(<br>&gt; +  trials: Int, threads: Int? = nil, invoking body: () -&gt; ()<br>&gt; +) {<br>&gt;<br>&gt; -public func expectFailure(${TRACE}, body: () -&gt; Void) {<br>&gt; +public func expectFailure(${TRACE}, invoking body: () -&gt; Void) {<br>&gt;<br>&gt;<br>&gt; OK, I understand your process now.  I still don&#39;t understand your<br>&gt; rationale for saying `do` or `perform` is better than `invoke`.  Or is<br>&gt; it just personal taste?<br>&gt;<br>&gt;<br>&gt; See below.  But in a  nutshell, `do` gets the idea across. It&#39;s short.<br>&gt; It&#39;s pithy.<br>&gt; It uses a common, comfortable word. So yes, personal taste. But it&#39;s<br>&gt; personal<br>&gt; taste backed up by some statistics.<br>&gt;<br></p><p>I&#39;ve made this comment previously in another thread, but I&#39;ll chime in here<br>because it seems pertinent. Just like the parentheses around function<br>arguments can imply the word &quot;with&quot; or &quot;using,&quot; and just as Swift 3 renamed<br>`foo(atIndex: Int)` to `foo(at: Int)` because an argument of type Int<br>implies an index, a closure to me implies the word &quot;do,&quot; &quot;invoke,&quot;<br>&quot;perform&quot; or even &quot;soEach.&quot; After all, it&#39;s absurd that a closure would be<br>supplied as an argument for any purpose other than being done or invoked or<br>performed. That a label such as `do` or `body` or `soEach` could be applied<br>so broadly seems to me a good sign that these labels might be extraneous.<br></p><p>This also applies where there&#39;s a `body` label instead of an empty<br>&gt; external label.<br>&gt;<br>&gt;<br>&gt; We don&#39;t have any methods with a `body` label IIUC.<br>&gt;<br>&gt;<br>&gt; You did, as in the examples just above, which you recommend a rename to<br>&gt; `invoke` or<br>&gt; `invoking`.<br>&gt;<br>&gt;<br>&gt; Ah, thanks.<br>&gt;<br>&gt; -public func withInvalidOrderings(_ body: ((Int, Int) -&gt; Bool) -&gt; Void) {<br>&gt; +public func withInvalidOrderings(invoke body: ((Int, Int) -&gt; Bool) -&gt;<br>&gt; Void) {<br>&gt;<br>&gt; For any with/external label pair, I&#39;d prefer `with-do` or `with-perform`<br>&gt; over `with-invoke`.<br>&gt;<br>&gt;<br>&gt; OK.  Is there a rationale, or is it just personal taste?<br>&gt;<br>&gt;<br>&gt; Strong personal taste, backed by tech writing. Simpler words.<br>&gt; From the Corpus of Contemporary American English:<br>&gt; do: 18<br>&gt; perform: 955<br>&gt; invoke: does not appear on list.<br>&gt;<br>&gt;<br>&gt; I&#39;m unable to reproduce those numbers using http://corpus.byu.edu/coca/.<br>&gt; What exactly did you do to get them?<br>&gt;<br>&gt;<br>&gt; I used a secondary webpage that rates word frequency based on the COCA<br>&gt; corpus:<br>&gt; http://www.wordfrequency.info/free.asp?s=y<br>&gt;<br>&gt;<br>&gt; Also, I&#39;m not sure commonality of use is a good rationale.  I bet<br>&gt; “function” doesn&#39;t appear as often as “task” either, but the argument<br>&gt; here is a function and we invoke functions.  Sometimes the appropriate<br>&gt; word is just less common.<br>&gt;<br>&gt;<br>&gt; 1051 task<br>&gt; 1449 function<br>&gt;<br>&gt; Numbers aside, there&#39;s always a &quot;term of art&quot; argument to be made. A term<br>&gt; of<br>&gt; art is precise and instantly communicates the meaning to the user.<br>&gt;<br>&gt; I don&#39;t think a &quot;term of art&quot; argument can be made here since invoke,<br>&gt; perform, and<br>&gt; do all communicate the same idea to the end-coder, who doesn&#39;t need to<br>&gt; know<br>&gt; exactly how the compiler sees the argument.<br>&gt;<br>&gt; In naming theory, I&#39;d say the member name carries the greatest weight when<br>&gt; using<br>&gt; exact terms and that internal labels should accessorize the primary name.<br>&gt; When using a<br>&gt; &quot;term of art&quot; argument, it should apply most strongly to a method/function/<br>&gt; property/type name and less to supporting external labels.<br>&gt;<br>&gt; -  return IteratorSequence(it).reduce(initial, combine: f)<br>&gt; +  return IteratorSequence(it).reduce(initial, accumulatingBy: f)<br>&gt;<br>&gt; For `reduce`, I&#39;d prefer `applying:` or `byApplying:`<br>&gt;<br>&gt;<br>&gt; Makes sense.<br>&gt;<br>&gt; Similarly in `starts(with:comparingBy:)`, I&#39;d prefer byComparing`,<br>&gt;<br>&gt;<br>&gt; I don&#39;t see how that works.  You&#39;re not comparing the closure with<br>&gt; anything.<br>&gt;<br>&gt;<br>&gt; I get your point but I think it&#39;s unnecessarily fussy.<br>&gt;<br>&gt;<br>&gt; I plead guilty to sometimes having unnecessarily fussy tendencies, but<br>&gt; in this case I believe strongly that “byComparing” would be actively<br>&gt; misleading and harmful.  Even if there&#39;s only one possible sane<br>&gt; interpretation, if readers have to scratch their heads and do an<br>&gt; exhaustive search through possible interpretations of what something<br>&gt; might mean because the one directly implied by the grammar is nonsense,<br>&gt; that&#39;s bad.<br>&gt;<br>&gt;<br>&gt; &quot;Comparing by&quot; is not actively misleading or harmful but it does sound<br>&gt; strained.  I think a well-designed language should use comfortable<br>&gt; constructs.Why not use a single , plain word that describes a parameter&#39;s<br>&gt; role. Why not &quot;compare:&quot;? It&#39;s far less fussy and it&#39;s clear.<br>&gt;<br>&gt; Alternatives are slim on the ground. `usingComparison:` is too long,<br>&gt; as is `byComparingWith:` (which still reads better but you will point<br>&gt; out can be mistaken by some pedant to mean that the sequence is being<br>&gt; compared to the closure), and you won&#39;t allow for `comparing:`.  I&#39;m<br>&gt; not in love with `comparingWith:` but it reads slightly better to me<br>&gt; than `comparingBy:`.<br>&gt;<br>&gt;<br>&gt; There is definitely something awkward about “xxxBy:” for these uses, and<br>&gt; I&#39;m open to using “xxxWith:” instead, even though as you say it&#39;s<br>&gt; confusable.<br>&gt;<br>&gt;  if x.starts(with: y, comparingBy: { $0.name == $1.name }) {<br>&gt;    ...<br>&gt;  }<br>&gt;<br>&gt;  if x.starts(with: y, comparingWith: { $0.name == $1.name }) {<br>&gt;    ...<br>&gt;  }<br>&gt;<br>&gt; At some point I start to wonder if giving up fluency is best:<br>&gt;<br>&gt;  if x.starts(with: y, equality: { $0.name == $1.name }) {<br>&gt;    ...<br>&gt;  }<br>&gt;<br>&gt;<br>&gt; Yes.  `predicate`, `compare` (or `comparison`), `order:`, etc.<br>&gt;<br>&gt; To riff off Gerard Manley Hopkins, &quot;Glory be for simple things, for<br>&gt; short words and trim APIs&quot;.<br>&gt;<br>&gt; min/max, byOrdering<br>&gt;<br>&gt;<br>&gt; Likewise, you&#39;re not ordering the closure.<br>&gt;<br>&gt;<br>&gt; Same reasoning.<br>&gt;<br>&gt;<br>&gt; -      ).encode(encoding, output: output)<br>&gt; +      ).encode(encoding, sendingOutputTo: processCodeUnit)<br>&gt;<br>&gt; How about `exportingTo`?<br>&gt;<br>&gt;<br>&gt; “export” is freighted with various connotations that I don&#39;t think we<br>&gt; want to make here.  In fact it doesn&#39;t mean anything more exotic than<br>&gt; “sending output to.”<br>&gt;<br>&gt;<br>&gt; For a language that treasures concision and clarity, this may be clear<br>&gt; but it&#39;s notably inconcise. (Yes, that is a new word.)<br>&gt;<br>&gt;<br>&gt; I agree, but if you want concision I&#39;d rather stick with something that<br>&gt; doesn&#39;t imply anything unintended, such as “to” or “into.”<br>&gt;<br>&gt;<br>&gt; I much prefer `to` and `into`<br>&gt;<br>&gt; -  tempwords.sort(isOrderedBefore: &lt;)<br>&gt; +  tempwords.sort(orderingBy: &lt;)<br>&gt;<br>&gt; With `sort` and `sorted`, I&#39;d prefer `by:`<br>&gt;<br>&gt;<br>&gt; When people talk about “sorting by XXX”, XXX is a property of the<br>&gt; elements being sorted.  Therefore IMIO that label should probably be<br>&gt; reserved for a version that takes a unary projection function:<br>&gt;<br>&gt;    friends.sort(by: {$0.lastName})<br>&gt;<br>&gt;<br>&gt; But they&#39;re sorting now, and that feature isn&#39;t in Swift.<br>&gt;<br>&gt;<br>&gt; That doesn&#39;t mean we should claim the syntax for another purpose.<br>&gt; I think we probably do want that feature eventually.<br>&gt;<br>&gt; However, `sorted` falls under another umbrella, which is potential<br>&gt; chaining. In such case, I would prefer there be no internal label at all<br>&gt; to allow cleaner functional flow.<br>&gt;<br>&gt;<br>&gt; IMO whether a method has a non-Void return value (and thus is chainable)<br>&gt; should not be the determining feature on whether we use argument labels.<br>&gt;<br>&gt;<br>&gt; If any method returns a sequence or collection, I think it *should* be<br>&gt; considered<br>&gt; in that specific light as a candidate for chaining. I agree that expanding<br>&gt; that to<br>&gt; any return value is too wide.<br>&gt;<br>&gt; We *could* decide to drop all labels for trailing closures (on the<br>&gt; grounds that they often won&#39;t appear at the call site) and say the<br>&gt; policy is that if there&#39;s something you want to communicate about the<br>&gt; closure&#39;s role, you simply do the best you can with the parameter name<br>&gt; and let the clarity at the call site fend for itself.  That, at least,<br>&gt; would be a reasonably principled approach.<br>&gt;<br>&gt;<br>&gt; I like labels for trailing closures when they are  `-&gt; Void`.  You know a<br>&gt; priori<br>&gt; that the closure is used for side-effects, so if they are put into a<br>&gt; function or<br>&gt; method call, the label alerts you to design intent.<br>&gt;<br>&gt; I want to omit labels for trailing closures when they return collections,<br>&gt; sequences,<br>&gt; iterators, etc. because these return types are most likely to be chained.<br>&gt;<br>&gt; If you force a label for, say, map, people will choose<br>&gt;<br>&gt; map {  ...  }<br>&gt;<br>&gt; over<br>&gt;<br>&gt; map(label: { ... })<br>&gt;<br>&gt; because the former reads better, especially when chaining but it introduces<br>&gt; bad habits, because it will not compile when used with constructs like:<br>&gt;<br>&gt; for i in map { ... } { // will not compile<br>&gt;     ...<br>&gt; }<br>&gt;<br>&gt; But if you treat collection/sequence fp as &quot;highly likely to be chained&quot;,<br>&gt; it encourages<br>&gt; results more like:<br>&gt;<br>&gt; for i in x.map({ ...}).filter({ ... }) {<br>&gt;     ....<br>&gt; }<br>&gt;<br>&gt; which is compiler-safe, more readable, etc, especially for very short-form<br>&gt; items like:<br>&gt;<br>&gt; for var i in x.flatMap({Int($0)}).filter({ $0 &lt; 10 }) {<br>&gt;     ...<br>&gt; }<br>&gt;<br>&gt;<br>&gt;<br>&gt; -  if !expected.elementsEqual(actual, isEquivalent: sameValue) {<br>&gt; +  if !expected.elementsEqual(actual, comparingBy: sameValue) {<br>&gt;<br>&gt; I&#39;m torn on this one. I don&#39;t like but I don&#39;t have a good solution.<br>&gt;<br>&gt;<br>&gt; I actually meant to move this up to the other discussion of `byComparing`<br>&gt; and<br>&gt; forgot to. So please assume you disagree with me on this one too.<br>&gt;<br>&gt;<br>&gt; -  /// for which `predicate(x) == true`.<br>&gt; +  /// for which `isIncluded(x) == true`.<br>&gt; -      _base: base.makeIterator(), whereElementsSatisfy: _include)<br>&gt; +      _base: base.makeIterator(), suchThat: _include)<br>&gt;<br>&gt; How about simply `include` for both?<br>&gt;<br>&gt;<br>&gt; Looking at the effect on the doc comments—which is how we should judge<br>&gt; parameter names—I think `predicate` might read better.<br>&gt;<br>&gt;<br>&gt; I like `predicate`. I endorse `predicate`. Does this mean the rule of &quot;must<br>&gt; read like a sentence&quot; can be overturned for things like &quot;comparison&quot; and<br>&gt; &quot;order&quot;? If so, woo!<br>&gt;<br>&gt;<br>&gt; I don&#39;t know what you mean.  There is no such rule.  There are<br>&gt; guidelines about reading like a phrase at the use site, but the<br>&gt; *parameter name* has no effect on the use site.<br>&gt;<br>&gt; I get the `is` desire but it&#39;s being tossed away in a lot of other<br>&gt; places in this diff. and `suchThat` feels out of place.<br>&gt;<br>&gt;<br>&gt; I think I&#39;m pretty strongly sold on “soEach” as a label for closures in<br>&gt; all the filtering components.<br>&gt;<br>&gt;<br>&gt; To quote greatness:, &quot;I personally find `soEach` repulsive&quot;.<br>&gt; (cite:<br>&gt;<br>&gt; http://article.gmane.org/gmane.comp.lang.swift.evolution/16998/match=repulsive<br>&gt; &lt;<br>&gt; http://article.gmane.org/gmane.comp.lang.swift.evolution/16998/match=repulsive<br>&gt; &gt;)<br>&gt;<br>&gt;<br>&gt; Sorry to hear that.  Let&#39;s change “filter” to “where” so this can become<br>&gt; a non-issue.<br>&gt;<br>&gt;<br>&gt; :)<br>&gt;<br>&gt;<br>&gt;<br>&gt; -      || u16.contains({ $0 &gt; 127 || _isspace_clocale($0) }) {<br>&gt; +    || u16.contains(elementWhere: { $0 &gt; 127 || _isspace_clocale($0) }) {<br>&gt;<br>&gt; I assume the challenge here is differentiating contains(element) from<br>&gt; contains(closure).<br>&gt; This feels predicate-y, which is why I put it near the predicates. But I<br>&gt; think something<br>&gt; like `containsElement(where:)` works better.<br>&gt;<br>&gt;<br>&gt; I understand your motivation for suggesting it.  The downside is that it<br>&gt; severs the strong basename relationship between algorithms that do<br>&gt; effectively the same things, one using a default comparison and the<br>&gt; other using an explicitly-specified one.  I&#39;m truly not sure where we<br>&gt; ought to land on this one.<br>&gt;<br>&gt;<br>&gt; May I recommend `predicate:` then since it looks like that&#39;s actually<br>&gt; a possibility?<br>&gt;<br>&gt;<br>&gt; I never suggested predicate as an argument label.<br>&gt;<br>&gt; -    let result = try base._withUnsafeMutableBufferPointerIfSupported(body)<br>&gt; +    let result = try<br>&gt; base._withUnsafeMutableBufferPointerIfSupported(invoke: body)<br>&gt;<br>&gt; I hate &quot;ifSupported&quot;<br>&gt;<br>&gt;<br>&gt; Me too.<br>&gt;<br>&gt; but that&#39;s another discussion<br>&gt;<br>&gt;<br>&gt; Quite.  It&#39;s also an internal API so it&#39;s not an evolution issue.  The<br>&gt; point of having that change as part of the diff (as with all the other<br>&gt; use sites), is to observe how the changes affect real usage.<br>&gt;<br>&gt;<br>&gt; Woody Allen: &quot;The heart wants what it wants&quot;<br>&gt; Me: &quot;The spleen vents what it vents&quot;<br>&gt;<br>&gt;<br>&gt; SOL (snort out loud)<br>&gt;<br>&gt;<br>&gt; (withSupportedUnsafeMutableBufferPointer,<br>&gt; withAvailableUnsafeMutableBufferPointer, it&#39;s all lipstick)<br>&gt;<br>&gt; This is procedural, so `do` or `perform` rather than `invoke`<br>&gt;<br>&gt; -      for test in removeFirstTests.filter({ $0.numberToRemove == 1 }) {<br>&gt; +      for test in removeFirstTests.filter(<br>&gt; +        suchThat: { $0.numberToRemove == 1 }<br>&gt;<br>&gt; The difference between `filter` and `forEach` is that `forEach` is<br>&gt; explicitly<br>&gt; procedural while `filter` is functional.  I do not like functional<br>&gt; chainable<br>&gt; calls being modified to use explicit external labels in this way.<br>&gt;<br>&gt; I&#39;d prefer no label here.<br>&gt;<br>&gt;<br>&gt; Can you provide rationale for treating functional methods differently,<br>&gt; or is it just personal taste?<br>&gt;<br>&gt;<br>&gt; Functional programming flow. I follow Kevin Ballard&#39;s rule of parens around<br>&gt; functional elements and naked braces for trailing closures that do not<br>&gt; return<br>&gt; values. This ensures the compiler is never confused at places like:<br>&gt;<br>&gt; for x in foo when y.f{...} {<br>&gt;    ...<br>&gt; }<br>&gt;<br>&gt;<br>&gt; ? It&#39;s never confused there; it tells you it&#39;s illegal.<br>&gt;<br>&gt; and instantly identifies to the reader when there&#39;s a non-returning scope,<br>&gt; as<br>&gt; in forEach or GCD dispatch.<br>&gt;<br>&gt;<br>&gt; Why is it useful to identify when there&#39;s a scope that doesn&#39;t return a<br>&gt; value?  Isn&#39;t that already clear from whether the value is assigned<br>&gt; somewhere?<br>&gt;<br>&gt;<br>&gt; Enhanced readability from explicit coding intent. Trailing closures<br>&gt; *look* like a scope created by a native construct. Those enclosed in<br>&gt; parens *look* like arguments.<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/9d7dd795/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Stdlib closure argument labels and parameter names</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June 27, 2016 at 06:00:00am</p></header><div class="content"><p>on Sun Jun 26 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br></p><p>&gt; On Sun, Jun 26, 2016 at 2:18 PM, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; See below.  But in a nutshell, `do` gets the idea across. It&#39;s short.<br>&gt;&gt; It&#39;s pithy.  It uses a common, comfortable word. So yes, personal<br>&gt;&gt; taste. But it&#39;s personal taste backed up by some statistics.<br>&gt;&gt;<br>&gt;<br>&gt; I&#39;ve made this comment previously in another thread, but I&#39;ll chime in here<br>&gt; because it seems pertinent. Just like the parentheses around function<br>&gt; arguments can imply the word &quot;with&quot; or &quot;using,&quot; and just as Swift 3 renamed<br>&gt; `foo(atIndex: Int)` to `foo(at: Int)` because an argument of type Int<br>&gt; implies an index, a closure to me implies the word &quot;do,&quot; &quot;invoke,&quot;<br>&gt; &quot;perform&quot; or even &quot;soEach.&quot; After all, it&#39;s absurd that a closure would be<br>&gt; supplied as an argument for any purpose other than being done or invoked or<br>&gt; performed. <br></p><p>Not at all.<br></p><p>    callbacks.append( { print(&quot;ring ring&quot;) } )<br></p><p>&gt; That a label such as `do` or `body` or `soEach` could be applied so<br>&gt; broadly seems to me a good sign that these labels might be extraneous.<br></p><p>I totally buy that argument when it comes to `do` or `body`.  That said,<br>as I have pointed out many times, “soEach” has very specific<br>communicative value that none of these others do.<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Stdlib closure argument labels and parameter names</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 27, 2016 at 10:00:00am</p></header><div class="content"><p>On Mon, Jun 27, 2016 at 9:10 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; on Sun Jun 26 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt;<br>&gt; &gt; On Sun, Jun 26, 2016 at 2:18 PM, Erica Sadun via swift-evolution &lt;<br>&gt; &gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; See below.  But in a nutshell, `do` gets the idea across. It&#39;s short.<br>&gt; &gt;&gt; It&#39;s pithy.  It uses a common, comfortable word. So yes, personal<br>&gt; &gt;&gt; taste. But it&#39;s personal taste backed up by some statistics.<br>&gt; &gt;&gt;<br>&gt; &gt;<br>&gt; &gt; I&#39;ve made this comment previously in another thread, but I&#39;ll chime in<br>&gt; here<br>&gt; &gt; because it seems pertinent. Just like the parentheses around function<br>&gt; &gt; arguments can imply the word &quot;with&quot; or &quot;using,&quot; and just as Swift 3<br>&gt; renamed<br>&gt; &gt; `foo(atIndex: Int)` to `foo(at: Int)` because an argument of type Int<br>&gt; &gt; implies an index, a closure to me implies the word &quot;do,&quot; &quot;invoke,&quot;<br>&gt; &gt; &quot;perform&quot; or even &quot;soEach.&quot; After all, it&#39;s absurd that a closure would<br>&gt; be<br>&gt; &gt; supplied as an argument for any purpose other than being done or invoked<br>&gt; or<br>&gt; &gt; performed.<br>&gt;<br>&gt; Not at all.<br>&gt;<br>&gt;     callbacks.append( { print(&quot;ring ring&quot;) } )<br>&gt;<br></p><p>I&#39;m not sure I understand. Your closure here would be a callback, as in you<br>expect it to be called or done or invoked, no? Would you find value in<br>having it rewritten `callbacks.append(callee: { print(&quot;ring ring&quot;) })`?<br></p><p>&gt; That a label such as `do` or `body` or `soEach` could be applied so<br>&gt; &gt; broadly seems to me a good sign that these labels might be extraneous.<br>&gt;<br>&gt; I totally buy that argument when it comes to `do` or `body`.  That said,<br>&gt; as I have pointed out many times, “soEach” has very specific<br>&gt; communicative value that none of these others do.<br>&gt;<br></p><p>I get what you&#39;re aiming for with &quot;soEach.&quot; So that we&#39;re on the same page,<br>here&#39;s what I think you think:<br></p><p>(1) &quot;so&quot; communicates that, in the case of filtering, the elements that<br>satisfy the predicate are kept rather than discarded<br>(2) &quot;each&quot; communicates that the predicate operates on an individual<br>element at a time<br></p><p>Regarding (2)--I think clarifying this isn&#39;t extremely valuable, because:<br></p><p>A. That a property or method has to do with an individual element of a<br>sequence/collection is frequently understood by implication in property and<br>method names. For example: `first` isn&#39;t `firstElement`; it&#39;s simply<br>understood.<br></p><p>B. In plain English, we frequently understand that a verb used in relation<br>to a thing with multiple constituent parts operates on said constituent<br>parts one-by-one.<br></p><p>Regarding (1)--I agree that knowing whether elements satisfying the<br>predicate are kept or discarded, etc., is essential. I&#39;ll call this the<br>&quot;keeping vs. discarding&quot; issue. That said, since trailing closure syntax<br>allows the label to be omitted, and since we take into consideration<br>clarity for the reader at the call site as much as clarity for the writer<br>at the time of reading the documentation, I would propose the following:<br></p><p>A. If &quot;keeping vs. discarding&quot; is ambiguous from the base name (or at<br>least, the full method name minus the predicate&#39;s label), then clarifying<br>words should be inserted somewhere other than the label so that the same<br>clarity can be assured at any call site.<br></p><p>B. If &quot;keeping vs. discarding&quot; is unambiguous without taking into<br>consideration the predicate&#39;s label, it&#39;s extraneous to reiterate the point<br>in the label.<br></p><p>C. I question whether there really exist scenarios that are not important<br>enough to justify (A) but just unclear enough that (B) is unsatisfactory;<br>where reasonable people differ, I propose erring on the side of caution and<br>going with (A).<br></p><p><br></p><p>&gt; --<br>&gt; -Dave<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/25399518/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Stdlib closure argument labels and parameter names</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June 27, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; After all, it&#39;s absurd that a closure would be supplied as an argument for any purpose other than being done or invoked or performed.<br></p><p>In the calls at hand, like `withUnsafeMutablePointer`, &quot;do&quot; is the verb of the call. That is not true of many—perhaps most—closures. For instance, the verb of `map(_:)` is &quot;map&quot;. The verb of `save(to:for:completionHandler:)` is &quot;save&quot;.<br></p><p>On the other hand, in `withUnsafeMutablePointer(_:do:)`, the verb of the call really *is* &quot;do&quot;. Doing the closure and causing its side effects to occur or its return value to be calculated is the entire purpose of that call. In a sense, the call is sort of backwards; if it weren&#39;t for the fact that closures are very long, it might be better written as `do(_:withUnsafeMutablePointer:)`.<br></p><p>(Hmm. *Technically* I suppose that call *ought* to be `withUnsafeMutablePointer(to:do:)`...)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Stdlib closure argument labels and parameter names</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June 27, 2016 at 06:00:00am</p></header><div class="content"><p>on Sun Jun 26 2016, Erica Sadun &lt;erica-AT-ericasadun.com&gt; wrote:<br></p><p>&gt;&gt; On Jun 26, 2016, at 10:35 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Sat Jun 25 2016, Erica Sadun &lt;erica-AT-ericasadun.com<br>&gt;&gt; &lt;http://erica-at-ericasadun.com/&gt;&gt; wrote:<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 25, 2016, at 4:25 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; on Wed Jun 22 2016, Erica Sadun &lt;erica-AT-ericasadun.com&gt; wrote:<br>&gt;&gt;&gt;&gt; On Jun 20, 2016, at 3:25 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -    func forEach&lt;S: SequenceType&gt;(_ body: (S.Iterator.Element) -&gt; ())<br>&gt;&gt;&gt;&gt;&gt; +    func forEach&lt;S: SequenceType&gt;(invoke body: (S.Iterator.Element) -&gt; ())<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Adding an external label makes sense here. This is a procedural call and<br>&gt;&gt;&gt;&gt;&gt; using it within the parens should have a &quot;code ripple&quot;.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don&#39;t think I understand what you mean here.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When using a procedural &quot;trailable&quot; closure inside parentheses, the intention<br>&gt;&gt;&gt; to do so should be clear:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; p(x, perform: {...})<br>&gt;&gt;&gt; p(x, do: {...})<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; vs<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; p(x) {<br>&gt;&gt;&gt;   ...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Anyone reading this code can immediately identify that an otherwise trailing<br>&gt;&gt;&gt; closure has been pulled inside the signature because the call has become <br>&gt;&gt;&gt; significantly more  complex. The point-of-coding decision ripples through<br>&gt;&gt;&gt; to point-of-reading/point-of-maintenance.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That said, would prefer `do` or `perform` over `invoke` or `invoking` as in<br>&gt;&gt;&gt;&gt;&gt; `runRaceTest`, `_forAllPermutationsImpl`, `expectFailure`, etc. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sorry, again, I&#39;m a little lost.  Forgive my overly-literal brain but<br>&gt;&gt;&gt;&gt; could you please spell out how those latter 3 names relate to the choice<br>&gt;&gt;&gt;&gt; of `do` or `perform` over `invoke`?   <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I read through the pull request. I grouped related modifications<br>&gt;&gt;&gt; together, although not exhaustively. They fall under the same umbrella, <br>&gt;&gt;&gt; choosing `do` or `perform` compared to `invoke` or `invoking`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -    _forAllPermutationsImpl(index + 1, size, &amp;perm, &amp;visited, body)<br>&gt;&gt;&gt; +    _forAllPermutationsImpl(index + 1, size, &amp;perm, &amp;visited, invoke: body)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -public func runRaceTest(trials: Int, threads: Int? = nil, body: () -&gt; ()) {<br>&gt;&gt;&gt; +public func runRaceTest(<br>&gt;&gt;&gt; +  trials: Int, threads: Int? = nil, invoking body: () -&gt; ()<br>&gt;&gt;&gt; +) {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -public func expectFailure(${TRACE}, body: () -&gt; Void) {<br>&gt;&gt;&gt; +public func expectFailure(${TRACE}, invoking body: () -&gt; Void) {<br>&gt;&gt; <br>&gt;&gt; OK, I understand your process now.  I still don&#39;t understand your<br>&gt;&gt; rationale for saying `do` or `perform` is better than `invoke`.  Or is<br>&gt;&gt; it just personal taste?<br>&gt;<br>&gt; See below.  But in a  nutshell, `do` gets the idea across. It&#39;s short. It&#39;s pithy.<br>&gt; It uses a common, comfortable word. So yes, personal taste. But it&#39;s personal<br>&gt; taste backed up by some statistics.<br></p><p>I get the reasons for `do`; I can&#39;t understand how `perform` might be an<br>improvement over `invoke`.<br></p><p>&gt;&gt;&gt;&gt;&gt; This also applies where there&#39;s a `body` label instead of an empty<br>&gt;&gt;&gt;&gt;&gt; external label.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We don&#39;t have any methods with a `body` label IIUC.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You did, as in the examples just above, which you recommend a rename to `invoke` or<br>&gt;&gt;&gt; `invoking`.<br>&gt;&gt; <br>&gt;&gt; Ah, thanks.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -public func withInvalidOrderings(_ body: ((Int, Int) -&gt; Bool) -&gt; Void) {<br>&gt;&gt;&gt;&gt;&gt; +public func withInvalidOrderings(invoke body: ((Int, Int) -&gt; Bool) -&gt; Void) {<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; For any with/external label pair, I&#39;d prefer `with-do` or `with-perform` <br>&gt;&gt;&gt;&gt;&gt; over `with-invoke`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; OK.  Is there a rationale, or is it just personal taste?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Strong personal taste, backed by tech writing. Simpler words. <br>&gt;&gt;&gt; From the Corpus of Contemporary American English:<br>&gt;&gt;&gt; do: 18<br>&gt;&gt;&gt; perform: 955<br>&gt;&gt;&gt; invoke: does not appear on list.<br>&gt;&gt; <br>&gt;&gt; I&#39;m unable to reproduce those numbers using<br>&gt;&gt; http://corpus.byu.edu/coca/ &lt;http://corpus.byu.edu/coca/&gt;.<br>&gt;&gt; What exactly did you do to get them?<br>&gt;<br>&gt; I used a secondary webpage that rates word frequency based on the COCA corpus:<br>&gt; http://www.wordfrequency.info/free.asp?s=y<br>&gt;<br>&gt;&gt; Also, I&#39;m not sure commonality of use is a good rationale.  I bet<br>&gt;&gt; “function” doesn&#39;t appear as often as “task” either, but the argument<br>&gt;&gt; here is a function and we invoke functions.  Sometimes the appropriate<br>&gt;&gt; word is just less common.<br>&gt;<br>&gt; 1051 task<br>&gt; 1449 function<br>&gt;<br>&gt; Numbers aside, there&#39;s always a &quot;term of art&quot; argument to be made. A term of<br>&gt; art is precise and instantly communicates the meaning to the user. <br>&gt;<br>&gt; I don&#39;t think a &quot;term of art&quot; argument can be made here since invoke,<br>&gt; perform, and do all communicate the same idea to the end-coder, who<br>&gt; doesn&#39;t need to know exactly how the compiler sees the argument.<br>&gt;<br>&gt; In naming theory, I&#39;d say the member name carries the greatest weight<br>&gt; when using exact terms and that internal labels should accessorize the<br>&gt; primary name. When using a &quot;term of art&quot; argument, it should apply<br>&gt; most strongly to a method/function/ property/type name and less to<br>&gt; supporting external labels.<br>&gt;<br>&gt;&gt;&gt;&gt;&gt; -  return IteratorSequence(it).reduce(initial, combine: f)<br>&gt;&gt;&gt;&gt;&gt; +  return IteratorSequence(it).reduce(initial, accumulatingBy: f)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; For `reduce`, I&#39;d prefer `applying:` or `byApplying:`<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Makes sense.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Similarly in `starts(with:comparingBy:)`, I&#39;d prefer byComparing`,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don&#39;t see how that works.  You&#39;re not comparing the closure with<br>&gt;&gt;&gt;&gt; anything.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I get your point but I think it&#39;s unnecessarily fussy. <br>&gt;&gt; <br>&gt;&gt; I plead guilty to sometimes having unnecessarily fussy tendencies, but<br>&gt;&gt; in this case I believe strongly that “byComparing” would be actively<br>&gt;&gt; misleading and harmful.  Even if there&#39;s only one possible sane<br>&gt;&gt; interpretation, if readers have to scratch their heads and do an<br>&gt;&gt; exhaustive search through possible interpretations of what something<br>&gt;&gt; might mean because the one directly implied by the grammar is nonsense,<br>&gt;&gt; that&#39;s bad.<br>&gt;<br>&gt; &quot;Comparing by&quot; is not actively misleading or harmful but it does sound<br>&gt; strained.  <br></p><p>Absolutely.<br></p><p>&gt; I think a well-designed language should use comfortable constructs.Why<br>&gt; not use a single , plain word that describes a parameter&#39;s role. Why<br>&gt; not &quot;compare:&quot;? It&#39;s far less fussy and it&#39;s clear.<br></p><p>Yes, we can do that at the cost of fluency.  Fluency isn&#39;t everything.<br></p><p>&gt;&gt;&gt; Alternatives are slim on the ground. `usingComparison:` is too long,<br>&gt;&gt;&gt; as is `byComparingWith:` (which still reads better but you will point<br>&gt;&gt;&gt; out can be mistaken by some pedant to mean that the sequence is being<br>&gt;&gt;&gt; compared to the closure), and you won&#39;t allow for `comparing:`.  I&#39;m<br>&gt;&gt;&gt; not in love with `comparingWith:` but it reads slightly better to me<br>&gt;&gt;&gt; than `comparingBy:`.<br>&gt;&gt; <br>&gt;&gt; There is definitely something awkward about “xxxBy:” for these uses, and<br>&gt;&gt; I&#39;m open to using “xxxWith:” instead, even though as you say it&#39;s<br>&gt;&gt; confusable.<br>&gt;&gt; <br>&gt;&gt;  if x.starts(with: y, comparingBy: { $0.name == $1.name }) {<br>&gt;&gt;    ...<br>&gt;&gt;  }<br>&gt;&gt; <br>&gt;&gt;  if x.starts(with: y, comparingWith: { $0.name == $1.name }) {<br>&gt;&gt;    ...<br>&gt;&gt;  }<br>&gt;&gt; <br>&gt;&gt; At some point I start to wonder if giving up fluency is best:<br>&gt;&gt; <br>&gt;&gt;  if x.starts(with: y, equality: { $0.name == $1.name }) {<br>&gt;&gt;    ...<br>&gt;&gt;  }<br>&gt;<br>&gt; Yes.  `predicate`, `compare` (or `comparison`), `order:`, etc.<br>&gt;<br>&gt; To riff off Gerard Manley Hopkins, &quot;Glory be for simple things, for<br>&gt; short words and trim APIs&quot;.<br>&gt;<br>&gt;&gt;&gt;&gt;&gt; min/max, byOrdering<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Likewise, you&#39;re not ordering the closure.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Same reasoning.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -      ).encode(encoding, output: output)<br>&gt;&gt;&gt;&gt;&gt; +      ).encode(encoding, sendingOutputTo: processCodeUnit)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; How about `exportingTo`?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; “export” is freighted with various connotations that I don&#39;t think we<br>&gt;&gt;&gt;&gt; want to make here.  In fact it doesn&#39;t mean anything more exotic than<br>&gt;&gt;&gt;&gt; “sending output to.”<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For a language that treasures concision and clarity, this may be clear<br>&gt;&gt;&gt; but it&#39;s notably inconcise. (Yes, that is a new word.)<br>&gt;&gt; <br>&gt;&gt; I agree, but if you want concision I&#39;d rather stick with something that<br>&gt;&gt; doesn&#39;t imply anything unintended, such as “to” or “into.”<br>&gt;<br>&gt; I much prefer `to` and `into`<br>&gt;<br>&gt;&gt;&gt;&gt;&gt; -  tempwords.sort(isOrderedBefore: &lt;)<br>&gt;&gt;&gt;&gt;&gt; +  tempwords.sort(orderingBy: &lt;)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; With `sort` and `sorted`, I&#39;d prefer `by:`<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; When people talk about “sorting by XXX”, XXX is a property of the<br>&gt;&gt;&gt;&gt; elements being sorted.  Therefore IMIO that label should probably be<br>&gt;&gt;&gt;&gt; reserved for a version that takes a unary projection function:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    friends.sort(by: {$0.lastName})<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But they&#39;re sorting now, and that feature isn&#39;t in Swift.<br>&gt;&gt; <br>&gt;&gt; That doesn&#39;t mean we should claim the syntax for another purpose.<br>&gt;&gt; I think we probably do want that feature eventually.<br>&gt;&gt; <br>&gt;&gt;&gt; However, `sorted` falls under another umbrella, which is potential<br>&gt;&gt;&gt; chaining. In such case, I would prefer there be no internal label at all<br>&gt;&gt;&gt; to allow cleaner functional flow.<br>&gt;&gt; <br>&gt;&gt; IMO whether a method has a non-Void return value (and thus is chainable)<br>&gt;&gt; should not be the determining feature on whether we use argument labels.<br>&gt;<br>&gt; If any method returns a sequence or collection, I think it *should* be<br>&gt; considered in that specific light as a candidate for chaining. I agree<br>&gt; that expanding that to any return value is too wide.<br>&gt;<br>&gt;&gt; We *could* decide to drop all labels for trailing closures (on the<br>&gt;&gt; grounds that they often won&#39;t appear at the call site) and say the<br>&gt;&gt; policy is that if there&#39;s something you want to communicate about the<br>&gt;&gt; closure&#39;s role, you simply do the best you can with the parameter name<br>&gt;&gt; and let the clarity at the call site fend for itself.  That, at least,<br>&gt;&gt; would be a reasonably principled approach.<br>&gt;<br>&gt; I like labels for trailing closures when they are  `-&gt; Void`.  You know a priori<br>&gt; that the closure is used for side-effects, so if they are put into a function or<br>&gt; method call, the label alerts you to design intent.<br>&gt;<br>&gt; I want to omit labels for trailing closures when they return collections, sequences, <br>&gt; iterators, etc. because these return types are most likely to be chained.<br>&gt;<br>&gt; If you force a label for, say, map, people will choose <br>&gt;<br>&gt; map {  ...  }<br>&gt;<br>&gt; over<br>&gt;<br>&gt; map(label: { ... })<br>&gt;<br>&gt; because the former reads better, especially when chaining but it introduces<br>&gt; bad habits, because it will not compile when used with constructs like:<br>&gt;<br>&gt; for i in map { ... } { // will not compile<br>&gt;     ... <br>&gt; }<br></p><p>I don&#39;t think Swift wants to buy into the idea that using map without<br>trailing closures is a bad habit.  We strongly believe in trailing<br>closure syntax.  I would much rather find ways to make the syntax above<br>legal.  Furthermore, the logic doesn&#39;t follow for me.  There are other<br>ways to get that to compile, such as <br></p><p>     for i in (map { ... }) { // will not compile<br></p><p>Why not make the argument that it&#39;s a bad habit to call map without<br>*surrounding* parentheses?<br></p><p>&gt; But if you treat collection/sequence fp as &quot;highly likely to be<br>&gt; chained&quot;, it encourages<br>&gt; results more like:<br>&gt;<br>&gt; for i in x.map({ ...}).filter({ ... }) {<br>&gt;     ....<br>&gt; }<br>&gt;<br>&gt; which is compiler-safe, more readable, etc, especially for very<br>&gt; short-form items like:<br>&gt;<br>&gt; for var i in x.flatMap({Int($0)}).filter({ $0 &lt; 10 }) {<br></p><p>I disagree about readability.  One set of surrounding parentheses is<br>clearer<br></p><p>     for var i in (x.flatMap{ Int($0) }.filter{ $0 &lt; 10 }) {<br></p><p>Further, I am concerned about pervasive inefficiency when people try to<br>pack this kind of chaining into a for loop with as few characters as<br>possible.  Generally speaking, it would be better to do it lazily.<br></p><p>&gt;&gt;&gt; Functional programming flow. I follow Kevin Ballard&#39;s rule of parens around<br>&gt;&gt;&gt; functional elements and naked braces for trailing closures that do not return<br>&gt;&gt;&gt; values. This ensures the compiler is never confused at places like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; for x in foo when y.f{...} {<br>&gt;&gt;&gt;    ...<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; ? It&#39;s never confused there; it tells you it&#39;s illegal.<br>&gt;&gt; <br>&gt;&gt;&gt; and instantly identifies to the reader when there&#39;s a non-returning scope, as<br>&gt;&gt;&gt; in forEach or GCD dispatch.<br>&gt;&gt; <br>&gt;&gt; Why is it useful to identify when there&#39;s a scope that doesn&#39;t return a<br>&gt;&gt; value?  Isn&#39;t that already clear from whether the value is assigned<br>&gt;&gt; somewhere?  <br>&gt;<br>&gt; Enhanced readability from explicit coding intent. Trailing closures <br>&gt; *look* like a scope created by a native construct. Those enclosed in <br>&gt; parens *look* like arguments.<br></p><p>I understand what you&#39;re saying, but I think it&#39;s unnecessarily fussy<br>;-)<br></p><p>two-can-play-at-that-game-ly y&#39;rs,<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Stdlib closure argument labels and parameter names</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>June 27, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jun 27, 2016, at 7:05 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; for i in map { ... } { // will not compile<br>&gt;&gt;    ... <br>&gt;&gt; }<br>&gt; <br>&gt; I don&#39;t think Swift wants to buy into the idea that using map without<br>&gt; trailing closures is a bad habit.  We strongly believe in trailing<br>&gt; closure syntax.<br></p><p>I strongly believe that trailing closure syntax isn&#39;t always the right thing. For example, <br>many APIs, specifically those sourced from Cocoa, shouldn&#39;t use trailing closures for <br>&quot;completion&quot;, &quot;on error&quot; handlers, etc.<br></p><p>// Should use argument label. Clear, easy to distinguish<br>UIView.animate(<br>    withDuration: 0.5,<br>    delay: 0.0,<br>    options: [.curveEaseOut],<br>    animations: {<br>        <br>        //...<br>        <br>    },<br>    completion: {<br>        <br>        _ in print(&quot;done animating&quot;)<br></p><p>    }<br>)<br></p><p>// Shouldn&#39;t use trailing closure syntax. The call look like <br>// it&#39;s &quot;running&quot; the completion block. <br>//<br>UIView.animate(<br>    withDuration: 0.5,<br>    delay: 0.0,<br>    options: [.curveEaseOut],<br>    animations: {<br>        <br>        // ...<br>        <br>}) {<br>    <br>    _ in print(&quot;done animating&quot;)<br>    <br>}<br></p><p>Compare with:<br></p><p>// Should. Elegant, simple.<br>DispatchQueue.main.after(when: .now() + 1.0) {<br></p><p>    print(&quot;complete&quot;)<br>    PlaygroundPage.finishExecution(PlaygroundPage.current)<br></p><p>}<br></p><p>// Slightly less good<br>DispatchQueue.main.after(when: .now() + 1.0, execute: {<br></p><p>    print(&quot;complete&quot;)<br>    PlaygroundPage.finishExecution(PlaygroundPage.current)<br></p><p>})<br></p><p>&gt; Why not make the argument that it&#39;s a bad habit to call map without<br>&gt; *surrounding* parentheses?<br></p><p>It&#39;s a fair question and as I have readily admitted, a highly stylized personal choice.<br>Using my style is a choice that has measurable benefits and limited impact. It fixes a real <br>(not theoretical) problem, is never harmful to code and when adhered to consistently<br>clarifies intent at the point of use, especially when expanded to functional calls that<br>aren&#39;t pre-built into the language -- so readers may not know at a glance what they&#39;re <br>looking at as they would with `map`, `flatMap`, `filter`, and whatever sort is being called<br>this week.<br></p><p>&gt; I disagree about readability.  One set of surrounding parentheses is<br>&gt; clearer<br>&gt; <br>&gt;     for var i in (x.flatMap{ Int($0) }.filter{ $0 &lt; 10 }) {<br>&gt; <br></p><p>chacun à son goût. see above.<br></p><p>&gt; Further, I am concerned about pervasive inefficiency when people try to<br>&gt; pack this kind of chaining into a for loop with as few characters as<br>&gt; possible.  Generally speaking, it would be better to do it lazily.<br></p><p>Yeah, kicking myself over that. Can&#39;t Swift remind me to add `lazy` <br>by emitting a warning or something? I keep assuming certain things are<br>naturally lazy and then have to go back and de-eagerize.<br></p><p>&gt;&gt; Enhanced readability from explicit coding intent. Trailing closures <br>&gt;&gt; *look* like a scope created by a native construct. Those enclosed in <br>&gt;&gt; parens *look* like arguments.<br>&gt; <br>&gt; I understand what you&#39;re saying, but I think it&#39;s unnecessarily fussy<br>&gt; ;-)<br>&gt; <br>&gt; two-can-play-at-that-game-ly y&#39;rs,<br></p><p>A hit, a very palpable hit.<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/dd65deab/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>Stdlib closure argument labels and parameter names</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>June 28, 2016 at 01:00:00pm</p></header><div class="content"><p>Side question: is there going to be any situation where I’m iterating through a sequence/collection that I wouldn’t want to always use `lazy`? Is `lazy` *always* going to be more efficient than the array-creating defaults when the result is iterated?<br></p><p>For instance, something much better than this terrible syntax:<br></p><p>for a in sequence where .filter({ $0 &gt; 5 }).map({ $0 * 2 })  {<br>  print(a)<br>}<br></p><p>It would be up to the compiler what calls it turns that into, possibly it could make a certain whitelist of transformations (filter, map) as efficient as using `for … where` or `guard` today? Or it could simply make use of `lazy`.<br></p><p>`for` is already hiding ‘magic’ by calling `makeIterator()`, why can’t it do more ‘magic’, especially since `lazy` is a member of `Sequence` just like `makeIterator()`.<br></p><p>Anyway, something for the future after Swift 3.0.<br></p><p>Patrick<br></p><p>&gt; On 28 Jun 2016, at 1:58 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Yeah, kicking myself over that. Can&#39;t Swift remind me to add `lazy` <br>&gt; by emitting a warning or something? I keep assuming certain things are<br>&gt; naturally lazy and then have to go back and de-eagerize.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/f627c7b5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Stdlib closure argument labels and parameter names</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June 27, 2016 at 10:00:00pm</p></header><div class="content"><p>on Mon Jun 27 2016, Patrick Smith &lt;pgwsmith-AT-gmail.com&gt; wrote:<br></p><p>&gt; Side question: is there going to be any situation where I’m iterating<br>&gt; through a sequence/collection that I wouldn’t want to always use<br>&gt; `lazy`? Is `lazy` *always* going to be more efficient than the<br>&gt; array-creating defaults when the result is iterated?<br></p><p>If all you&#39;re going to do is iterate over it at most once, then yeah,<br>the lazy version will pretty much always be more efficient.  If anything<br>you do with the lazy result makes multiple passes (including<br>constructing an array if it is a collection with O(N) count, like the<br>result of a lazy filter), then you have to be prepared for the closures<br>you use to be called multiple times.<br></p><p>&gt; For instance, something much better than this terrible syntax:<br>&gt;<br>&gt; for a in sequence where .filter({ $0 &gt; 5 }).map({ $0 * 2 })  {<br>&gt;   print(a)<br>&gt; }<br></p><p><br>I don&#39;t know what that&#39;s supposed to illustrate.<br></p><p>&gt; It would be up to the compiler what calls it turns that into, possibly<br>&gt; it could make a certain whitelist of transformations (filter, map) as<br>&gt; efficient as using `for … where` or `guard` today? Or it could simply<br>&gt; make use of `lazy`.<br>&gt;<br>&gt; `for` is already hiding ‘magic’ by calling `makeIterator()`, why can’t<br>&gt; it do more ‘magic’, especially since `lazy` is a member of `Sequence`<br>&gt; just like `makeIterator()`.<br>&gt;<br>&gt; Anyway, something for the future after Swift 3.0.<br></p><p>It&#39;s an interesting thought, yes.<br></p><p>-- <br>Dave<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>Stdlib closure argument labels and parameter names</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>June 27, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; I like `predicate`. I endorse `predicate`. Does this mean the rule of &quot;must<br>&gt; read like a sentence&quot; can be overturned for things like &quot;comparison&quot; and<br>&gt; &quot;order&quot;? If so, woo!<br></p><p>I&#39;ve suggested that a few emails back as well, but I&#39;ve asked myself if it&#39;s not a bit confusing when you have (NS)Predicate - if it doesn&#39;t seem like something taking the Predicate object argument instead of a block.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; I get the `is` desire but it&#39;s being tossed away in a lot of other<br>&gt;&gt;&gt; places in this diff. and `suchThat` feels out of place.<br>&gt;&gt; <br>&gt;&gt; I think I&#39;m pretty strongly sold on “soEach” as a label for closures in<br>&gt;&gt; all the filtering components.<br>&gt; <br>&gt; To quote greatness:, &quot;I personally find `soEach` repulsive&quot;.<br>&gt; (cite: http://article.gmane.org/gmane.comp.lang.swift.evolution/16998/match=repulsive &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/16998/match=repulsive&gt;)<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; -      || u16.contains({ $0 &gt; 127 || _isspace_clocale($0) }) {<br>&gt;&gt;&gt; +    || u16.contains(elementWhere: { $0 &gt; 127 || _isspace_clocale($0) }) {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I assume the challenge here is differentiating contains(element) from contains(closure).<br>&gt;&gt;&gt; This feels predicate-y, which is why I put it near the predicates. But I think something<br>&gt;&gt;&gt; like `containsElement(where:)` works better.<br>&gt;&gt; <br>&gt;&gt; I understand your motivation for suggesting it.  The downside is that it<br>&gt;&gt; severs the strong basename relationship between algorithms that do<br>&gt;&gt; effectively the same things, one using a default comparison and the<br>&gt;&gt; other using an explicitly-specified one.  I&#39;m truly not sure where we<br>&gt;&gt; ought to land on this one.<br>&gt; <br>&gt; May I recommend `predicate:` then since it looks like that&#39;s actually a possibility?<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; -    let result = try base._withUnsafeMutableBufferPointerIfSupported(body)<br>&gt;&gt;&gt; +    let result = try base._withUnsafeMutableBufferPointerIfSupported(invoke: body)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I hate &quot;ifSupported&quot; <br>&gt;&gt; <br>&gt;&gt; Me too.<br>&gt;&gt; <br>&gt;&gt;&gt; but that&#39;s another discussion<br>&gt;&gt; <br>&gt;&gt; Quite.  It&#39;s also an internal API so it&#39;s not an evolution issue.  The<br>&gt;&gt; point of having that change as part of the diff (as with all the other<br>&gt;&gt; use sites), is to observe how the changes affect real usage.<br>&gt; <br>&gt; Woody Allen: &quot;The heart wants what it wants&quot;<br>&gt; Me: &quot;The spleen vents what it vents&quot;<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; (withSupportedUnsafeMutableBufferPointer,<br>&gt;&gt;&gt; withAvailableUnsafeMutableBufferPointer, it&#39;s all lipstick)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is procedural, so `do` or `perform` rather than `invoke`<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -      for test in removeFirstTests.filter({ $0.numberToRemove == 1 }) {<br>&gt;&gt;&gt; +      for test in removeFirstTests.filter(<br>&gt;&gt;&gt; +        suchThat: { $0.numberToRemove == 1 }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The difference between `filter` and `forEach` is that `forEach` is explicitly <br>&gt;&gt;&gt; procedural while `filter` is functional.  I do not like functional chainable<br>&gt;&gt;&gt; calls being modified to use explicit external labels in this way. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;d prefer no label here.<br>&gt;&gt; <br>&gt;&gt; Can you provide rationale for treating functional methods differently,<br>&gt;&gt; or is it just personal taste?<br>&gt; <br>&gt; Functional programming flow. I follow Kevin Ballard&#39;s rule of parens around<br>&gt; functional elements and naked braces for trailing closures that do not return<br>&gt; values. This ensures the compiler is never confused at places like:<br>&gt; <br>&gt; for x in foo when y.f{...} {<br>&gt;     ...<br>&gt; }<br>&gt; <br>&gt; and instantly identifies to the reader when there&#39;s a non-returning scope, as<br>&gt; in forEach or GCD dispatch.<br>&gt; <br>&gt; However, if you use chaining and if the language insists on external label <br>&gt; preambles, which would not be seen when using the call with a trailing closure,<br>&gt; it becomes far less readable and encourages people  to use trailing closures to <br>&gt; avoid the label, i.e. an attractive nuisance. Simple selectors encourage better fp:<br>&gt; <br>&gt; let x = myStream.f1({...}).f2({...})<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; public func split(<br>&gt;&gt;&gt;      maxSplits: Int = Int.max,<br>&gt;&gt;&gt;      omittingEmptySubsequences: Bool = true,<br>&gt;&gt;&gt; -    isSeparator: @noescape (Base.Iterator.Element) throws -&gt; Bool<br>&gt;&gt;&gt; +    separatedWhere isSeparator: @noescape (Base.Iterator.Element) throws -&gt; Bool<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m torn on this one. It&#39;s not the worst ever but something more like where/at/when<br>&gt;&gt;&gt; makes more sense to me than<br>&gt;&gt;&gt; &quot;separatedWhere/separatedAt/separatedWhen&quot;.<br>&gt;&gt; <br>&gt;&gt; The biggest reason to keep “separate” in the name is the connection with<br>&gt;&gt; the semantics of the other `split` method, that takes a single element<br>&gt;&gt; that is tested for equality.  I think this is very similar to the<br>&gt;&gt; `contains(elementWhere` vs `containsElement(where` discussion.  If you<br>&gt;&gt; leave “separate” out of the name it fails to imply that those elements<br>&gt;&gt; for which the predicate returns true are not present in the result.<br>&gt; <br>&gt; `predicate` ftw.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +      count: __manager._headerPointer.pointee.count)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For the sake of Zippy the Pinhead, surely there has to be something better than `pointee`.<br>&gt;&gt;&gt; Like...`reference`?<br>&gt;&gt; <br>&gt;&gt; It&#39;s not a reference; it&#39;s a value.  But that, my friend, is an<br>&gt;&gt; *entirely* different discussion. Let&#39;s try to stick to the scope of the<br>&gt;&gt; proposal: names and labels for parameters of function type, OK?<br>&gt; <br>&gt; It was humor. It was at the end. I assumed the joke would lighten the<br>&gt; previous complaints and bookend the positive support at the start of<br>&gt; my message.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/acf05890/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
