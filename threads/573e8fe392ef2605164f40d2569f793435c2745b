<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>March 28, 2016 at 02:00:00pm</p></header><div class="content"><p>on Mon Mar 28 2016, Erica Sadun &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On Mar 28, 2016, at 3:25 PM, Dave Abrahams via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Mon Mar 28 2016, Xiaodi Wu<br>&gt;<br>&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Right, Countable could refine Strideable. I&#39;m no expert on this, but<br>&gt;&gt;&gt; some cursory reading suggests that the analogous feature in C++ simply<br>&gt;&gt;&gt; requires the type to have operator++ defined. Obviously, that won&#39;t<br>&gt;&gt;&gt; work for Swift 3.0...<br>&gt;&gt; <br>&gt;&gt; Hmm, instead of defining a new protocol (Countable), what if we just use<br>&gt;&gt; “Strideable where Stride : Integer” as a constraint?<br>&gt;<br>&gt; I like a differentiation between continuous and discrete things<br>&gt; although both can have ranges, membership, fences,<br>&gt; and a way to stride through them<br></p><p>Strideable where Stride : Integer expresses just exactly that.  Now if I<br>could only get the type-checker to cooperate...<br></p><p>&gt;<br>&gt;<br>&gt; -- E, just musing, not passing judgement on names<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>March 28, 2016 at 10:00:00pm</p></header><div class="content"><p>D&#39;oh! Of course, that sounds great. Would it require you to do something<br>else to cover your example with UnsafePointers though?<br>On Mon, Mar 28, 2016 at 4:56 PM Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; on Mon Mar 28 2016, Erica Sadun &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; &gt;&gt; On Mar 28, 2016, at 3:25 PM, Dave Abrahams via swift-evolution<br>&gt; &gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; on Mon Mar 28 2016, Xiaodi Wu<br>&gt; &gt;<br>&gt; &gt;&gt; &lt;swift-evolution at swift.org<br>&gt; &gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt; &gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; Right, Countable could refine Strideable. I&#39;m no expert on this, but<br>&gt; &gt;&gt;&gt; some cursory reading suggests that the analogous feature in C++ simply<br>&gt; &gt;&gt;&gt; requires the type to have operator++ defined. Obviously, that won&#39;t<br>&gt; &gt;&gt;&gt; work for Swift 3.0...<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Hmm, instead of defining a new protocol (Countable), what if we just use<br>&gt; &gt;&gt; “Strideable where Stride : Integer” as a constraint?<br>&gt; &gt;<br>&gt; &gt; I like a differentiation between continuous and discrete things<br>&gt; &gt; although both can have ranges, membership, fences,<br>&gt; &gt; and a way to stride through them<br>&gt;<br>&gt; Strideable where Stride : Integer expresses just exactly that.  Now if I<br>&gt; could only get the type-checker to cooperate...<br>&gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; -- E, just musing, not passing judgement on names<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; --<br>&gt; Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160328/c5d6099c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>March 28, 2016 at 04:00:00pm</p></header><div class="content"><p>on Mon Mar 28 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br></p><p>&gt; D&#39;oh! Of course, that sounds great. Would it require you to do something<br>&gt; else to cover your example with UnsafePointers though?<br></p><p>Nope; it Just Works™<br></p><p>&gt; On Mon, Mar 28, 2016 at 4:56 PM Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; on Mon Mar 28 2016, Erica Sadun &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; &gt;&gt; On Mar 28, 2016, at 3:25 PM, Dave Abrahams via swift-evolution<br>&gt;&gt; &gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; on Mon Mar 28 2016, Xiaodi Wu<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt; &gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; &gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Right, Countable could refine Strideable. I&#39;m no expert on this, but<br>&gt;&gt; &gt;&gt;&gt; some cursory reading suggests that the analogous feature in C++ simply<br>&gt;&gt; &gt;&gt;&gt; requires the type to have operator++ defined. Obviously, that won&#39;t<br>&gt;&gt; &gt;&gt;&gt; work for Swift 3.0...<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Hmm, instead of defining a new protocol (Countable), what if we just use<br>&gt;&gt; &gt;&gt; “Strideable where Stride : Integer” as a constraint?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I like a differentiation between continuous and discrete things<br>&gt;&gt; &gt; although both can have ranges, membership, fences,<br>&gt;&gt; &gt; and a way to stride through them<br>&gt;&gt;<br>&gt;&gt; Strideable where Stride : Integer expresses just exactly that.  Now if I<br>&gt;&gt; could only get the type-checker to cooperate...<br>&gt;&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; -- E, just musing, not passing judgement on names<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Dave<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br></p><p>-- <br>Dave<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March 28, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Mar 28, 2016, at 3:54 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Mon Mar 28 2016, Erica Sadun &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Mar 28, 2016, at 3:25 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Mon Mar 28 2016, Xiaodi Wu<br>&gt;&gt; <br>&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Right, Countable could refine Strideable. I&#39;m no expert on this, but<br>&gt;&gt;&gt;&gt; some cursory reading suggests that the analogous feature in C++ simply<br>&gt;&gt;&gt;&gt; requires the type to have operator++ defined. Obviously, that won&#39;t<br>&gt;&gt;&gt;&gt; work for Swift 3.0...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hmm, instead of defining a new protocol (Countable), what if we just use<br>&gt;&gt;&gt; “Strideable where Stride : Integer” as a constraint?<br>&gt;&gt; <br>&gt;&gt; I like a differentiation between continuous and discrete things<br>&gt;&gt; although both can have ranges, membership, fences,<br>&gt;&gt; and a way to stride through them<br>&gt; <br>&gt; Strideable where Stride : Integer expresses just exactly that.  Now if I<br>&gt; could only get the type-checker to cooperate...<br></p><p>I am ridiculously excited about what you&#39;re doing there. <br>Looking forward to beautiful floating point strides if for no<br>other reason than I can point out how well they work for math<br>in comparison to traditional for;;loops, so maybe people will<br>stop burning semicolons on my lawn.<br></p><p>What are you feelings about disjoint and invertible intervals? <br>(I&#39;ll admit they currently fail the Lattner test[1], but they appeal to<br>my aesthetics)<br></p><p>-- E<br></p><p>[1] First rule of Lattner: A language change should provide a highly focused<br>tweak to Swift with limited impact and a measurable benefit to developers<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>March 29, 2016 at 10:00:00am</p></header><div class="content"><p>You could implement Range like below. So that range[i] = first + i *<br>stride. This makes Range play nice with floats and other non-exact<br>quantities.<br></p><p>/// Provide the capabilities needed to impliment Range.<br></p><p>/// Ranges are indexed with an Int index between 0 and count - 1 inclusive<br>and they return start + index * stride, where start and stride are Rangees.<br></p><p>/// Via extensions Int and Double are Rangees.<br></p><p>protocol Rangee {<br></p><p>    /// self += rhs<br></p><p>    mutating func add(rhs: Self)<br></p><p><br></p><p>    /// self -= rhs<br></p><p>    mutating func sub(rhs: Self)<br></p><p><br></p><p>    /// self *= rhs<br></p><p>    mutating func mult(rhs: Self)<br></p><p><br></p><p>    /// self /= rhs<br></p><p>    mutating func div(rhs: Self)<br></p><p><br></p><p>    /// Converts to an Int, truncating towards 0 if necessary<br></p><p>    var toInt: Int { get }<br></p><p><br></p><p>    /// Convert from an int, fails if the int is not representable<br></p><p>    static func fromInt(i: Int) -&gt; Self<br></p><p>}<br></p><p><br>// Make Int a Rangee<br></p><p>extension Int: Rangee {<br></p><p>    mutating func add(rhs: Int) { self += rhs }<br></p><p>    mutating func sub(rhs: Int) { self -= rhs }<br></p><p>    mutating func mult(rhs: Int) { self *= rhs }<br></p><p>    mutating func div(rhs: Int) { self /= rhs }<br></p><p>    var toInt: Int { return self }<br></p><p>    static func fromInt(i: Int) -&gt; Int { return i }<br></p><p>}<br></p><p><br>// Make Double a Rangee<br></p><p>extension Double: Rangee {<br></p><p>    mutating func add(rhs: Double) { self += rhs }<br></p><p>    mutating func sub(rhs: Double) { self -= rhs }<br></p><p>    mutating func mult(rhs: Double) { self *= rhs }<br></p><p>    mutating func div(rhs: Double) { self /= rhs }<br></p><p>    var toInt: Int { return Int(trunc(self)) }<br></p><p>    static func fromInt(i: Int) -&gt; Double { return Double(i) }<br></p><p>}<br></p><p><br>/// An immutable-array-like collection that represents a<br>potentially-inclusive range of Rangables such that `range[index] = first +<br>index * stride`, where index in an Int between 0 and count - 1.<br></p><p>/// `count = Int(trunc((last - first) / stride)) + 1`;<br></p><p>/// therefore if `(last - first) / stride` is an integer, then the range<br>includes last (or approximately last if underlying arithmetic type is<br>non-exact).<br></p><p>/// Name is MyRange to stop clash with Range, in practice woule be Range.<br></p><p>struct MyRange&lt;R: Rangee&gt;: CollectionType {<br></p><p>    let first: R<br></p><p>    let last: R<br></p><p>    let stride: R<br></p><p>    let count: Int<br></p><p>    init(first: R, last: R, stride: R) {<br></p><p>        self.first = first<br></p><p>        self.last = last<br></p><p>        self.stride = stride<br></p><p>        self.count = MyRange.index(first: first, stride: stride, of: last)<br>+ 1<br></p><p>    }<br></p><p>    private static func index(first first: R, stride: R, of: R) -&gt; Int {<br></p><p>        var index = of<br></p><p>        index.sub(first)<br></p><p>        index.div(stride)<br></p><p>        return index.toInt<br></p><p>    }<br></p><p>    func index(of: R) -&gt; Int { return MyRange.index(first: first, stride:<br>stride, of: of) }<br></p><p>    var endIndex: Int { return count }<br></p><p>    var startIndex: Int { return 0 }<br></p><p>    // Note Range not MyRange needed for subscriptable range, in practice<br>MyRange would be Range<br></p><p>    subscript(bounds: Range&lt;Int&gt;) -&gt; MyRange&lt;R&gt; { return MyRange(first: self<br>[bounds.startIndex], last: self[bounds.endIndex - 1], stride: self.stride) }<br></p><p>    subscript(index: Int) -&gt; R {<br></p><p>        guard index &gt;= 0 else { fatalError(&quot;Index, \(index), negative&quot;) }<br></p><p>        guard index &lt; count else { fatalError(&quot;Index, \(index), &gt;= count, \(<br>count)&quot;) }<br></p><p>        var result = stride<br></p><p>        result.mult(R.fromInt(index))<br></p><p>        result.add(first)<br></p><p>        return result<br></p><p>    }<br></p><p>}<br></p><p>  -- Howard.<br></p><p>On 29 March 2016 at 09:35, Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Mar 28, 2016, at 3:54 PM, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; on Mon Mar 28 2016, Erica Sadun &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt;&gt; On Mar 28, 2016, at 3:25 PM, Dave Abrahams via swift-evolution<br>&gt; &gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; on Mon Mar 28 2016, Xiaodi Wu<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt; &gt;&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Right, Countable could refine Strideable. I&#39;m no expert on this, but<br>&gt; &gt;&gt;&gt;&gt; some cursory reading suggests that the analogous feature in C++ simply<br>&gt; &gt;&gt;&gt;&gt; requires the type to have operator++ defined. Obviously, that won&#39;t<br>&gt; &gt;&gt;&gt;&gt; work for Swift 3.0...<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Hmm, instead of defining a new protocol (Countable), what if we just<br>&gt; use<br>&gt; &gt;&gt;&gt; “Strideable where Stride : Integer” as a constraint?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I like a differentiation between continuous and discrete things<br>&gt; &gt;&gt; although both can have ranges, membership, fences,<br>&gt; &gt;&gt; and a way to stride through them<br>&gt; &gt;<br>&gt; &gt; Strideable where Stride : Integer expresses just exactly that.  Now if I<br>&gt; &gt; could only get the type-checker to cooperate...<br>&gt;<br>&gt; I am ridiculously excited about what you&#39;re doing there.<br>&gt; Looking forward to beautiful floating point strides if for no<br>&gt; other reason than I can point out how well they work for math<br>&gt; in comparison to traditional for;;loops, so maybe people will<br>&gt; stop burning semicolons on my lawn.<br>&gt;<br>&gt; What are you feelings about disjoint and invertible intervals?<br>&gt; (I&#39;ll admit they currently fail the Lattner test[1], but they appeal to<br>&gt; my aesthetics)<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt; [1] First rule of Lattner: A language change should provide a highly<br>&gt; focused<br>&gt; tweak to Swift with limited impact and a measurable benefit to developers<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160329/ddab9904/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>March 28, 2016 at 04:00:00pm</p></header><div class="content"><p>on Mon Mar 28 2016, Erica Sadun &lt;erica-AT-ericasadun.com&gt; wrote:<br></p><p>&gt;&gt; On Mar 28, 2016, at 3:54 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Mon Mar 28 2016, Erica Sadun &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;&gt;&gt; On Mar 28, 2016, at 3:25 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Mon Mar 28 2016, Xiaodi Wu<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Right, Countable could refine Strideable. I&#39;m no expert on this, but<br>&gt;&gt;&gt;&gt;&gt; some cursory reading suggests that the analogous feature in C++ simply<br>&gt;&gt;&gt;&gt;&gt; requires the type to have operator++ defined. Obviously, that won&#39;t<br>&gt;&gt;&gt;&gt;&gt; work for Swift 3.0...<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hmm, instead of defining a new protocol (Countable), what if we just use<br>&gt;&gt;&gt;&gt; “Strideable where Stride : Integer” as a constraint?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I like a differentiation between continuous and discrete things<br>&gt;&gt;&gt; although both can have ranges, membership, fences,<br>&gt;&gt;&gt; and a way to stride through them<br>&gt;&gt; <br>&gt;&gt; Strideable where Stride : Integer expresses just exactly that.  Now if I<br>&gt;&gt; could only get the type-checker to cooperate...<br>&gt;<br>&gt; I am ridiculously excited about what you&#39;re doing there. <br></p><p>:-)<br></p><p>&gt; Looking forward to beautiful floating point strides if for no<br>&gt; other reason than I can point out how well they work for math<br>&gt; in comparison to traditional for;;loops, <br></p><p>How would you like to implement the FP part of this?<br></p><p><br>&gt; so maybe people will stop burning semicolons on my lawn.<br></p><p>Naw, showing them a better way&#39;ll just get &#39;em more riled up.  <br></p><p>&gt; What are you feelings about disjoint and invertible intervals? <br></p><p>I don&#39;t know what these things are supposed to be, so it&#39;s hard to say.<br></p><p>&gt; (I&#39;ll admit they currently fail the Lattner test[1],<br></p><p>Presumably this isn&#39;t a language change, though.<br></p><p>&gt; but they appeal to my aesthetics)<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt; [1] First rule of Lattner: A language change should provide a highly focused<br>&gt; tweak to Swift with limited impact and a measurable benefit to developers<br></p><p>-- <br>Dave<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
