<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Pitch] Deeper Xcode Integration for SwiftPM</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May 18, 2016 at 09:00:00pm</p></header><div class="content"><p>I’d like to discuss an idea that will make development in Xcode easier. I assume that SwiftPM will see its Xcode integration when the final version will be released.<br></p><p>Problem I’ll try to describe is mostly about namespaces. Right now some people abuses enums, struct or classes to create a namespace for a specific need.<br></p><p>class Reference {<br>    class String { … }<br>    class Character {<br>        enum Error { … }<br>    }<br></p><p>    private init() {}<br>}<br></p><p>This will create a pseudo namespace for the nested types:<br></p><p>* Reference.String<br>* Reference.Character<br>* Reference.Character.Error<br></p><p>One could argue of using modules instead of abusing a class here, which is a great argument.<br></p><p>The problem that comes to my mind here is that we will have to create subprojects inside our main project file and using the references to them just to achieve that shiny namespace.<br>One could also use SwiftPM, which is awesome, but there is a need to re-build the module if any changes have been done. As soon as we’ll create some complex dependencies between different modules this will get messy.<br></p><p>Before posting here I asked Joe Groff if there is any mailing list I can use to discuss my idea. He told me this might be a good place, because I was referring to the package manager. Then I’ve done my research to not create any redundant thread, but I only found one topic about the integration of SwiftPM in Xcode: https://lists.swift.org/pipermail/swift-build-dev/Week-of-Mon-20160215/000272.html<br></p><p>So here are my thoughts about a deeper integration of SwiftPM here:<br></p><p>- What if Xcode will introduce two new types of groups (the folder color could be orange like Swift for example, or even contain the bird icon).<br>- These groups are analogous to already existing group types except they’ll represent Swift modules / packages<br>- Basically we’ll have a single project file with multiple modules, where these modules should only exist inside that project (this is my own need right now)<br>- Such a package / module group will have a configurable utilities, where one could configure the modules<br>- This will reduce the re-building process, allow us to keep everything (not only .a or we’ll be able to hide .a files and just keep the sourcefiles inside such groups) inside a single project, gain the shiny namespaces like above, and make the file management way easier <br>- This also should allow us create cross-dependencies if there is a good need for that in our project<br></p><p>+ MainProject<br>|<br>+—Reference (module)<br>|<br>+—+— Magic (module)<br>      |<br>      +— SomeSubMagic (module)<br></p><p>We could easily create cross dependencies between modules here by just using the modules names and the types they provide.<br></p><p>// SomeSubMagic is a sub module of Magic<br>class SomeSubMagic {<br>    var magic: Magic // referring to its parent module<br>}<br>       <br>What do you think about this?<br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160518/1a59a3c6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>[Pitch] Deeper Xcode Integration for SwiftPM</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>May 19, 2016 at 01:00:00pm</p></header><div class="content"><p>Right now modules are most appropriately used at the same granularity that frameworks or shared libraries would be used in C/Obj-C/C++. This is the situation for which the variety of access control modifiers in Swift and things like Whole Module Optimization were designed for. While there are a lot of reasons to like modules as a way to provide namespaces, they really haven&#39;t been designed to provide these very fine grained namespaces.<br></p><p>My guess is that the right answer here doesn&#39;t really involve the Xcode integration, but rather figuring out the right way that these concepts fit into the language in a first class way. I would expect concepts like submodules or namespaces to be language concepts that Xcode just exposes, not something that was coupled together.<br></p><p> - Daniel<br></p><p>&gt; On May 18, 2016, at 12:37 PM, Adrian Zubarev via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; I’d like to discuss an idea that will make development in Xcode easier. I assume that SwiftPM will see its Xcode integration when the final version will be released.<br>&gt; <br>&gt; Problem I’ll try to describe is mostly about namespaces. Right now some people abuses enums, struct or classes to create a namespace for a specific need.<br>&gt; <br>&gt; class Reference {<br>&gt;     class String { … }<br>&gt;     class Character {<br>&gt;         enum Error { … }<br>&gt;     }<br>&gt; <br>&gt;     private init() {}<br>&gt; }<br>&gt; <br>&gt; This will create a pseudo namespace for the nested types:<br>&gt; <br>&gt; * Reference.String<br>&gt; * Reference.Character<br>&gt; * Reference.Character.Error<br>&gt; <br>&gt; One could argue of using modules instead of abusing a class here, which is a great argument.<br>&gt; <br>&gt; The problem that comes to my mind here is that we will have to create subprojects inside our main project file and using the references to them just to achieve that shiny namespace.<br>&gt; One could also use SwiftPM, which is awesome, but there is a need to re-build the module if any changes have been done. As soon as we’ll create some complex dependencies between different modules this will get messy.<br>&gt; <br>&gt; Before posting here I asked Joe Groff if there is any mailing list I can use to discuss my idea. He told me this might be a good place, because I was referring to the package manager. Then I’ve done my research to not create any redundant thread, but I only found one topic about the integration of SwiftPM in Xcode: https://lists.swift.org/pipermail/swift-build-dev/Week-of-Mon-20160215/000272.html &lt;https://lists.swift.org/pipermail/swift-build-dev/Week-of-Mon-20160215/000272.html&gt;<br>&gt; <br>&gt; So here are my thoughts about a deeper integration of SwiftPM here:<br>&gt; <br>&gt; - What if Xcode will introduce two new types of groups (the folder color could be orange like Swift for example, or even contain the bird icon).<br>&gt; - These groups are analogous to already existing group types except they’ll represent Swift modules / packages<br>&gt; - Basically we’ll have a single project file with multiple modules, where these modules should only exist inside that project (this is my own need right now)<br>&gt; - Such a package / module group will have a configurable utilities, where one could configure the modules<br>&gt; - This will reduce the re-building process, allow us to keep everything (not only .a or we’ll be able to hide .a files and just keep the sourcefiles inside such groups) inside a single project, gain the shiny namespaces like above, and make the file management way easier <br>&gt; - This also should allow us create cross-dependencies if there is a good need for that in our project<br>&gt; <br>&gt; + MainProject<br>&gt; |<br>&gt; +—Reference (module)<br>&gt; |<br>&gt; +—+— Magic (module)<br>&gt;       |<br>&gt;       +— SomeSubMagic (module)<br>&gt; <br>&gt; We could easily create cross dependencies between modules here by just using the modules names and the types they provide.<br>&gt; <br>&gt; // SomeSubMagic is a sub module of Magic<br>&gt; class SomeSubMagic {<br>&gt;     var magic: Magic // referring to its parent module<br>&gt; }<br>&gt;        <br>&gt; What do you think about this?<br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; _______________________________________________<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev &lt;https://lists.swift.org/mailman/listinfo/swift-build-dev&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160519/d699ef50/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Discussion] Namespaces</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May 20, 2016 at 02:00:00pm</p></header><div class="content"><p>I want to revive this topic.<br></p><p>Is there any technical reason why we can’t have namespaces in Swift? I’ve found just a few threads about namespaces, but most of them had arguments to use modules instead.<br></p><p>I’m fine with modules but they just don’t serve everything I would want to. I can’t enforce the developer to use the modules name if there is no naming conflict.<br></p><p>I asked in the SwiftPM mail list for a easier Xcode integration of modules, but the response is exactly the opposite for using modules for namespaces (read below).<br></p><p>If I’m building one huge project I don’t want to build a lot of different modules just shiny namespaces and clean code.<br></p><p>So I ask the community again why can’t we have optional namespaces?<br>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 19. Mai 2016 bei 22:33:19, Daniel Dunbar (daniel_dunbar at apple.com) schrieb:<br></p><p>Right now modules are most appropriately used at the same granularity that frameworks or shared libraries would be used in C/Obj-C/C++. This is the situation for which the variety of access control modifiers in Swift and things like Whole Module Optimization were designed for. While there are a lot of reasons to like modules as a way to provide namespaces, they really haven&#39;t been designed to provide these very fine grained namespaces.<br></p><p>My guess is that the right answer here doesn&#39;t really involve the Xcode integration, but rather figuring out the right way that these concepts fit into the language in a first class way. I would expect concepts like submodules or namespaces to be language concepts that Xcode just exposes, not something that was coupled together.<br></p><p> - Daniel<br></p><p>On May 18, 2016, at 12:37 PM, Adrian Zubarev via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br></p><p>I’d like to discuss an idea that will make development in Xcode easier. I assume that SwiftPM will see its Xcode integration when the final version will be released.<br></p><p>Problem I’ll try to describe is mostly about namespaces. Right now some people abuses enums, struct or classes to create a namespace for a specific need.<br></p><p>class Reference {<br>    class String { … }<br>    class Character {<br>        enum Error { … }<br>    }<br></p><p>    private init() {}<br>}<br></p><p>This will create a pseudo namespace for the nested types:<br></p><p>* Reference.String<br>* Reference.Character<br>* Reference.Character.Error<br></p><p>One could argue of using modules instead of abusing a class here, which is a great argument.<br></p><p>The problem that comes to my mind here is that we will have to create subprojects inside our main project file and using the references to them just to achieve that shiny namespace.<br>One could also use SwiftPM, which is awesome, but there is a need to re-build the module if any changes have been done. As soon as we’ll create some complex dependencies between different modules this will get messy.<br></p><p>Before posting here I asked Joe Groff if there is any mailing list I can use to discuss my idea. He told me this might be a good place, because I was referring to the package manager. Then I’ve done my research to not create any redundant thread, but I only found one topic about the integration of SwiftPM in Xcode: https://lists.swift.org/pipermail/swift-build-dev/Week-of-Mon-20160215/000272.html<br></p><p>So here are my thoughts about a deeper integration of SwiftPM here:<br></p><p>- What if Xcode will introduce two new types of groups (the folder color could be orange like Swift for example, or even contain the bird icon).<br>- These groups are analogous to already existing group types except they’ll represent Swift modules / packages<br>- Basically we’ll have a single project file with multiple modules, where these modules should only exist inside that project (this is my own need right now)<br>- Such a package / module group will have a configurable utilities, where one could configure the modules<br>- This will reduce the re-building process, allow us to keep everything (not only .a or we’ll be able to hide .a files and just keep the sourcefiles inside such groups) inside a single project, gain the shiny namespaces like above, and make the file management way easier <br>- This also should allow us create cross-dependencies if there is a good need for that in our project<br></p><p>+ MainProject<br>|<br>+—Reference (module)<br>|<br>+—+— Magic (module)<br>      |<br>      +— SomeSubMagic (module)<br></p><p>We could easily create cross dependencies between modules here by just using the modules names and the types they provide.<br></p><p>// SomeSubMagic is a sub module of Magic<br>class SomeSubMagic {<br>    var magic: Magic // referring to its parent module<br>}<br>       <br>What do you think about this?<br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br>_______________________________________________<br>swift-build-dev mailing list<br>swift-build-dev at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-build-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/7fa2696c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[Discussion] Namespaces</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>May 20, 2016 at 10:00:00am</p></header><div class="content"><p>Adrian, I myself don&#39;t see a reason other than &quot;Objective-C never had it so why bother about it now?&quot; Most (if not all) .net languages support optional namespaces and even PHP began supporting it in version 5 (if I&#39;m not sure if the version is right). No technical reason against and I&#39;m particularly in favour too so let&#39;s hear the others in the group.<br></p><p>-----Original Message-----<br>From: &quot;Adrian Zubarev via swift-evolution&quot; &lt;swift-evolution at swift.org&gt;<br>Sent: ‎20/‎05/‎2016 09:16 AM<br>To: &quot;swift-evolution at swift.org&quot; &lt;swift-evolution at swift.org&gt;<br>Subject: [swift-evolution] [Discussion] Namespaces<br></p><p>I want to revive this topic.<br></p><p><br>Is there any technical reason why we can’t have namespaces in Swift? I’ve found just a few threads about namespaces, but most of them had arguments to use modules instead.<br></p><p><br>I’m fine with modules but they just don’t serve everything I would want to. I can’t enforce the developer to use the modules name if there is no naming conflict.<br></p><p><br>I asked in the SwiftPM mail list for a easier Xcode integration of modules, but the response is exactly the opposite for using modules for namespaces (read below).<br></p><p><br>If I’m building one huge project I don’t want to build a lot of different modules just shiny namespaces and clean code.<br></p><p><br>So I ask the community again why can’t we have optional namespaces?<br>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p><br>Am 19. Mai 2016 bei 22:33:19, Daniel Dunbar (daniel_dunbar at apple.com) schrieb:<br>Right now modules are most appropriately used at the same granularity that frameworks or shared libraries would be used in C/Obj-C/C++. This is the situation for which the variety of access control modifiers in Swift and things like Whole Module Optimization were designed for. While there are a lot of reasons to like modules as a way to provide namespaces, they really haven&#39;t been designed to provide these very fine grained namespaces.<br></p><p><br>My guess is that the right answer here doesn&#39;t really involve the Xcode integration, but rather figuring out the right way that these concepts fit into the language in a first class way. I would expect concepts like submodules or namespaces to be language concepts that Xcode just exposes, not something that was coupled together.<br></p><p><br> - Daniel<br></p><p><br>On May 18, 2016, at 12:37 PM, Adrian Zubarev via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br></p><p><br>I’d like to discuss an idea that will make development in Xcode easier. I assume that SwiftPM will see its Xcode integration when the final version will be released.<br>Problem I’ll try to describe is mostly about namespaces. Right now some people abuses enums, struct or classes to create a namespace for a specific need.<br></p><p><br>class Reference {<br>    class String { … }<br>    class Character {<br>        enum Error { … }<br>    }<br></p><p><br>    private init() {}<br>}<br></p><p><br>This will create a pseudo namespace for the nested types:<br></p><p><br>* Reference.String<br>* Reference.Character<br>* Reference.Character.Error<br></p><p><br>One could argue of using modules instead of abusing a class here, which is a great argument.<br></p><p><br>The problem that comes to my mind here is that we will have to create subprojects inside our main project file and using the references to them just to achieve that shiny namespace.<br>One could also use SwiftPM, which is awesome, but there is a need to re-build the module if any changes have been done. As soon as we’ll create some complex dependencies between different modules this will get messy.<br></p><p><br>Before posting here I asked Joe Groff if there is any mailing list I can use to discuss my idea. He told me this might be a good place, because I was referring to the package manager. Then I’ve done my research to not create any redundant thread, but I only found one topic about the integration of SwiftPM in Xcode: https://lists.swift.org/pipermail/swift-build-dev/Week-of-Mon-20160215/000272.html<br></p><p><br>So here are my thoughts about a deeper integration of SwiftPM here:<br></p><p><br>- What if Xcode will introduce two new types of groups (the folder color could be orange like Swift for example, or even contain the bird icon).<br>- These groups are analogous to already existing group types except they’ll represent Swift modules / packages<br>- Basically we’ll have a single project file with multiple modules, where these modules should only exist inside that project (this is my own need right now)<br>- Such a package / module group will have a configurable utilities, where one could configure the modules<br>- This will reduce the re-building process, allow us to keep everything (not only .a or we’ll be able to hide .a files and just keep the sourcefiles inside such groups) inside a single project, gain the shiny namespaces like above, and make the file management way easier <br>- This also should allow us create cross-dependencies if there is a good need for that in our project<br></p><p><br>+ MainProject<br>|<br>+—Reference (module)<br>&lt;div style=&quot;font-family: Helvetica, Arial; font-size: <br></p><p>[The entire original message is not included.]<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/7af4bcf6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3dad7bea24aa580cabe5c16e8e64183e?s=50"></div><header><strong>[Discussion] Namespaces</strong> from <string>Krystof Vasa</string> &lt;kvasa at icloud.com&gt;<p>May 20, 2016 at 03:00:00pm</p></header><div class="content"><p>I personally dislike the habit of deliberately naming different classes using the same name within a single project/module/library, just using different namespaces - one should be able to deduct from the code *which* class is being used without excessive checking.<br></p><p>When you have namespaces Car and Animal and each contains a class called List, IMHO there should be classes CarList and AnimalList. It&#39;s more verbose, but you imediately know which class is being used in opposite of just using List.<br></p><p>I don&#39;t have much experience with C++ and C#, but sometimes I have to dive into C# code and you can hear my teeth grind since there is a declaration of a variable of class List and you have no idea which List is this, since there are dozens of classes with this name. You don&#39;t always have the code in an IDE to resolve the symbol for you, sometimes you browse it on git, etc.<br></p><p>Which is why I personally find modules sufficient in providing a way to prevent naming collisions, yet strict enough to discourage the habits of other languages described above.<br></p><p>Hence for me -1 on introducing multiple namespaces within a single module.<br></p><p>&gt; On May 20, 2016, at 3:27 PM, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Adrian, I myself don&#39;t see a reason other than &quot;Objective-C never had it so why bother about it now?&quot; Most (if not all) .net languages support optional namespaces and even PHP began supporting it in version 5 (if I&#39;m not sure if the version is right). No technical reason against and I&#39;m particularly in favour too so let&#39;s hear the others in the group.<br>&gt; From: Adrian Zubarev via swift-evolution &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; Sent: ‎20/‎05/‎2016 09:16 AM<br>&gt; To: swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; Subject: [swift-evolution] [Discussion] Namespaces<br>&gt; <br>&gt; I want to revive this topic.<br>&gt; <br>&gt; Is there any technical reason why we can’t have namespaces in Swift? I’ve found just a few threads about namespaces, but most of them had arguments to use modules instead.<br>&gt; <br>&gt; I’m fine with modules but they just don’t serve everything I would want to. I can’t enforce the developer to use the modules name if there is no naming conflict.<br>&gt; <br>&gt; I asked in the SwiftPM mail list for a easier Xcode integration of modules, but the response is exactly the opposite for using modules for namespaces (read below).<br>&gt; <br>&gt; If I’m building one huge project I don’t want to build a lot of different modules just shiny namespaces and clean code.<br>&gt; <br>&gt; So I ask the community again why can’t we have optional namespaces?<br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Am 19. Mai 2016 bei 22:33:19, Daniel Dunbar (daniel_dunbar at apple.com &lt;mailto:daniel_dunbar at apple.com&gt;) schrieb:<br>&gt; <br>&gt;&gt; Right now modules are most appropriately used at the same granularity that frameworks or shared libraries would be used in C/Obj-C/C++. This is the situation for which the variety of access control modifiers in Swift and things like Whole Module Optimization were designed for. While there are a lot of reasons to like modules as a way to provide namespaces, they really haven&#39;t been designed to provide these very fine grained namespaces.<br>&gt;&gt; <br>&gt;&gt; My guess is that the right answer here doesn&#39;t really involve the Xcode integration, but rather figuring out the right way that these concepts fit into the language in a first class way. I would expect concepts like submodules or namespaces to be language concepts that Xcode just exposes, not something that was coupled together.<br>&gt;&gt; <br>&gt;&gt;  - Daniel<br>&gt;&gt; <br>&gt;&gt;&gt; On May 18, 2016, at 12:37 PM, Adrian Zubarev via swift-build-dev &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’d like to discuss an idea that will make development in Xcode easier. I assume that SwiftPM will see its Xcode integration when the final version will be released.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Problem I’ll try to describe is mostly about namespaces. Right now some people abuses enums, struct or classes to create a namespace for a specific need.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Reference {<br>&gt;&gt;&gt;     class String { … }<br>&gt;&gt;&gt;     class Character {<br>&gt;&gt;&gt;         enum Error { … }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     private init() {}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This will create a pseudo namespace for the nested types:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Reference.String<br>&gt;&gt;&gt; * Reference.Character<br>&gt;&gt;&gt; * Reference.Character.Error<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One could argue of using modules instead of abusing a class here, which is a great argument.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The problem that comes to my mind here is that we will have to create subprojects inside our main project file and using the references to them just to achieve that shiny namespace.<br>&gt;&gt;&gt; One could also use SwiftPM, which is awesome, but there is a need to re-build the module if any changes have been done. As soon as we’ll create some complex dependencies between different modules this will get messy.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Before posting here I asked Joe Groff if there is any mailing list I can use to discuss my idea. He told me this might be a good place, because I was referring to the package manager. Then I’ve done my research to not create any redundant thread, but I only found one topic about the integration of SwiftPM in Xcode: https://lists.swift.org/pipermail/swift-build-dev/Week-of-Mon-20160215/000272.html &lt;https://lists.swift.org/pipermail/swift-build-dev/Week-of-Mon-20160215/000272.html&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So here are my thoughts about a deeper integration of SwiftPM here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - What if Xcode will introduce two new types of groups (the folder color could be orange like Swift for example, or even contain the bird icon).<br>&gt;&gt;&gt; - These groups are analogous to already existing group types except they’ll represent Swift modules / packages<br>&gt;&gt;&gt; - Basically we’ll have a single project file with multiple modules, where these modules should only exist inside that project (this is my own need right now)<br>&gt;&gt;&gt; - Such a package / module group will have a configurable utilities, where one could configure the modules<br>&gt;&gt;&gt; - This will reduce the re-building process, allow us to keep everything (not only .a or we’ll be able to hide .a files and just keep the sourcefiles inside such groups) inside a single project, gain the shiny namespaces like above, and make the file management way easier <br>&gt;&gt;&gt; - This also should allow us create cross-dependencies if there is a good need for that in our project<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; + MainProject<br>&gt;&gt;&gt; |<br>&gt;&gt;&gt; +—Reference (module)<br>&gt; <br>&gt; [The entire original message is not included.]<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/936099ee/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Discussion] Namespaces</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May 20, 2016 at 04:00:00pm</p></header><div class="content"><p>I personally dislike the habit of deliberately naming different classes using the same name within a single project/module/library, just using different namespaces - one should be able to deduct from the code *which* class is being used without excessive checking.<br></p><p>When you have namespaces Car and Animal and each contains a class called List, IMHO there should be classes CarList and AnimalList. It&#39;s more verbose, but you imediately know which class is being used in opposite of just using List.<br>I assume you would still stick around with a standalone `SomeCustomeViewDelegate` protocol rather than use `SomeCustomView.Delegate` and nest the `Delegate` protocol inside `SomeCustomView`? This isn’t an example about namespaces but you get the idea.<br></p><p>What looks better to you?<br></p><p>protocol SomeCustomeViewDelegate {…}<br></p><p>or<br></p><p>extension SomeCustomView {<br></p><p>     protocol Delegate {…}<br></p><p>}<br></p><p>I don&#39;t have much experience with C++ and C#, but sometimes I have to dive into C# code and you can hear my teeth grind since there is a declaration of a variable of class List and you have no idea which List is this, since there are dozens of classes with this name. You don&#39;t always have the code in an IDE to resolve the symbol for you, sometimes you browse it on git, etc.<br></p><p>Which is why I personally find modules sufficient in providing a way to prevent naming collisions, yet strict enough to discourage the habits of other languages described above.<br>In my eyes namespaces in Swift (if we get them) should be optional which will allow someone write clear code if there is any desire.<br></p><p>For my project I’m working on it’s something like:<br></p><p>Reference.Buffer<br></p><p>Reference.String<br></p><p>Where I’m working with Pointers inside.<br></p><p>If I will use a module for this in my project, there will be a name collision with String when I forget about `Reference.`.<br></p><p>One can already achieve a pseudo namespaces by abusing structs for example.<br></p><p>struct Namespace {<br>     private init() {}<br>}<br></p><p>But you still can something like:<br></p><p>extension Namespace { … }<br></p><p>This doesn’t fell right.<br></p><p>Downside of modules in a huge project is that you might need re-build modules all over again when you changes something. :/<br>-- <br>Adrian Zubarev<br>Sent with Airmail<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/4ebfcb1e/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Discussion] Namespaces</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>May 20, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On 20 May 2016, at 14:51, Krystof Vasa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; When you have namespaces Car and Animal and each contains a class called List, IMHO there should be classes CarList and AnimalList. It&#39;s more verbose, but you imediately know which class is being used in opposite of just using List.<br></p><p>Why not use Car.List and Animal.List when its unclear from context? With Swift’s type inference you don’t often need to specify types anyway so your editor will know which list type you’re using based on how you obtained it.<br></p><p>That said it does depend on the purpose of each List; do they have any commonality? They could for example both be generic List implementations, but were never factored out into a common module. If however they are specialised constructs specific to cars or animals, then the prefix may make most sense.<br></p><p>For example, in the libdispatch thread the naming of Dispatch.DispatchQueue was queried, however this isn’t a general purpose queue type, it’s more specialised than that, so a name of “Queue” doesn’t convoy enough information, just as List might not. But it depends on what it actually does, which a basic example tends not to include ;)<br></p><p><br>Anyway, I’m +1 for namespaces everywhere, some names can be common. For example Node could be related to trees, physics engines and all sorts of constructs. “Node” may be a perfectly fine name for these. That said, these are sometimes tied to specific types in which case nesting them may make more sense, which I believe is already being addressed (currently we can’t nest generic types)? It’s certainly not as simple as it can appear!<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Discussion] Namespaces</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>May 20, 2016 at 11:00:00am</p></header><div class="content"><p>+1 for namespaces.<br></p><p>On Fri, May 20, 2016 at 10:52 AM, Haravikk via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On 20 May 2016, at 14:51, Krystof Vasa via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; When you have namespaces Car and Animal and each contains a class called<br>&gt; List, IMHO there should be classes CarList and AnimalList. It&#39;s more<br>&gt; verbose, but you imediately know which class is being used in opposite of<br>&gt; just using List.<br>&gt;<br>&gt; Why not use Car.List and Animal.List when its unclear from context? With<br>&gt; Swift’s type inference you don’t often need to specify types anyway so your<br>&gt; editor will know which list type you’re using based on how you obtained it.<br>&gt;<br>&gt; That said it does depend on the purpose of each List; do they have any<br>&gt; commonality? They could for example both be generic List implementations,<br>&gt; but were never factored out into a common module. If however they are<br>&gt; specialised constructs specific to cars or animals, then the prefix may<br>&gt; make most sense.<br>&gt;<br>&gt; For example, in the libdispatch thread the naming of<br>&gt; Dispatch.DispatchQueue was queried, however this isn’t a general purpose<br>&gt; queue type, it’s more specialised than that, so a name of “Queue” doesn’t<br>&gt; convoy enough information, just as List might not. But it depends on what<br>&gt; it actually does, which a basic example tends not to include ;)<br>&gt;<br>&gt;<br>&gt; Anyway, I’m +1 for namespaces everywhere, some names can be common. For<br>&gt; example Node could be related to trees, physics engines and all sorts of<br>&gt; constructs. “Node” may be a perfectly fine name for these. That said, these<br>&gt; are sometimes tied to specific types in which case nesting them may make<br>&gt; more sense, which I believe is already being addressed (currently we can’t<br>&gt; nest generic types)? It’s certainly not as simple as it can appear!<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/13811a4b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>[Discussion] Namespaces</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>May 20, 2016 at 03:00:00pm</p></header><div class="content"><p>Another use case to consider: code generation. There, namespaces can be<br>vital; they let you isolate code that you may have no real control over<br>(for example, data models that correspond to remote services) from the rest<br>of your code to avoid collisions. In some cases that can be achieved by<br>putting the shared code in its own module, but if that data description<br>format has hierarchical namespaces/packages of its own (Google&#39;s protocol<br>buffers, for example), then the lack of namespaces forces the code<br>generator to come up with contrived schemes for naming nested entities<br>(like the Objective-C implementation, which uses<br>underscore_delimited_names). The result is that Swift code using those<br>services would look *very* unnatural.<br></p><p><br>On Fri, May 20, 2016 at 8:08 AM T.J. Usiyan via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; +1 for namespaces.<br>&gt;<br>&gt; On Fri, May 20, 2016 at 10:52 AM, Haravikk via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; On 20 May 2016, at 14:51, Krystof Vasa via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; When you have namespaces Car and Animal and each contains a class<br>&gt;&gt; called List, IMHO there should be classes CarList and AnimalList. It&#39;s more<br>&gt;&gt; verbose, but you imediately know which class is being used in opposite of<br>&gt;&gt; just using List.<br>&gt;&gt;<br>&gt;&gt; Why not use Car.List and Animal.List when its unclear from context? With<br>&gt;&gt; Swift’s type inference you don’t often need to specify types anyway so your<br>&gt;&gt; editor will know which list type you’re using based on how you obtained it.<br>&gt;&gt;<br>&gt;&gt; That said it does depend on the purpose of each List; do they have any<br>&gt;&gt; commonality? They could for example both be generic List implementations,<br>&gt;&gt; but were never factored out into a common module. If however they are<br>&gt;&gt; specialised constructs specific to cars or animals, then the prefix may<br>&gt;&gt; make most sense.<br>&gt;&gt;<br>&gt;&gt; For example, in the libdispatch thread the naming of<br>&gt;&gt; Dispatch.DispatchQueue was queried, however this isn’t a general purpose<br>&gt;&gt; queue type, it’s more specialised than that, so a name of “Queue” doesn’t<br>&gt;&gt; convoy enough information, just as List might not. But it depends on what<br>&gt;&gt; it actually does, which a basic example tends not to include ;)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Anyway, I’m +1 for namespaces everywhere, some names can be common. For<br>&gt;&gt; example Node could be related to trees, physics engines and all sorts of<br>&gt;&gt; constructs. “Node” may be a perfectly fine name for these. That said, these<br>&gt;&gt; are sometimes tied to specific types in which case nesting them may make<br>&gt;&gt; more sense, which I believe is already being addressed (currently we can’t<br>&gt;&gt; nest generic types)? It’s certainly not as simple as it can appear!<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/dc746643/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>[Discussion] Namespaces</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>May 20, 2016 at 11:00:00am</p></header><div class="content"><p>This would be out of scope for Swift 3 right? Or is this relatively &quot;easy&quot; to implement?<br></p><p>Brandon <br></p><p>Sent from my iPad<br></p><p>&gt; On May 20, 2016, at 11:27 AM, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Another use case to consider: code generation. There, namespaces can be vital; they let you isolate code that you may have no real control over (for example, data models that correspond to remote services) from the rest of your code to avoid collisions. In some cases that can be achieved by putting the shared code in its own module, but if that data description format has hierarchical namespaces/packages of its own (Google&#39;s protocol buffers, for example), then the lack of namespaces forces the code generator to come up with contrived schemes for naming nested entities (like the Objective-C implementation, which uses underscore_delimited_names). The result is that Swift code using those services would look *very* unnatural.<br>&gt; <br>&gt; <br>&gt;&gt; On Fri, May 20, 2016 at 8:08 AM T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; +1 for namespaces. <br>&gt;&gt; <br>&gt;&gt;&gt; On Fri, May 20, 2016 at 10:52 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; On 20 May 2016, at 14:51, Krystof Vasa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; When you have namespaces Car and Animal and each contains a class called List, IMHO there should be classes CarList and AnimalList. It&#39;s more verbose, but you imediately know which class is being used in opposite of just using List.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Why not use Car.List and Animal.List when its unclear from context? With Swift’s type inference you don’t often need to specify types anyway so your editor will know which list type you’re using based on how you obtained it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That said it does depend on the purpose of each List; do they have any commonality? They could for example both be generic List implementations, but were never factored out into a common module. If however they are specialised constructs specific to cars or animals, then the prefix may make most sense.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For example, in the libdispatch thread the naming of Dispatch.DispatchQueue was queried, however this isn’t a general purpose queue type, it’s more specialised than that, so a name of “Queue” doesn’t convoy enough information, just as List might not. But it depends on what it actually does, which a basic example tends not to include ;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Anyway, I’m +1 for namespaces everywhere, some names can be common. For example Node could be related to trees, physics engines and all sorts of constructs. “Node” may be a perfectly fine name for these. That said, these are sometimes tied to specific types in which case nesting them may make more sense, which I believe is already being addressed (currently we can’t nest generic types)? It’s certainly not as simple as it can appear!<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/2ee5c6b2/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] Namespaces</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 20, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On May 20, 2016, at 10:27 AM, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Another use case to consider: code generation. There, namespaces can be vital; they let you isolate code that you may have no real control over (for example, data models that correspond to remote services) from the rest of your code to avoid collisions. In some cases that can be achieved by putting the shared code in its own module, but if that data description format has hierarchical namespaces/packages of its own (Google&#39;s protocol buffers, for example), then the lack of namespaces forces the code generator to come up with contrived schemes for naming nested entities (like the Objective-C implementation, which uses underscore_delimited_names). The result is that Swift code using those services would look *very* unnatural.<br></p><p>What benefits do namespaces provide that empty enums and / or submodules do not?  This isn’t clear to me and I think it is an essential part of the case that must be made.<br></p><p>Nobody is arguing that we don’t need a way to isolate names.  The question is whether namespaces are the right mechanism for doing that or not.<br></p><p>&gt; <br>&gt; <br>&gt; On Fri, May 20, 2016 at 8:08 AM T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; +1 for namespaces. <br>&gt; <br>&gt; On Fri, May 20, 2016 at 10:52 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; &gt; On 20 May 2016, at 14:51, Krystof Vasa via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; When you have namespaces Car and Animal and each contains a class called List, IMHO there should be classes CarList and AnimalList. It&#39;s more verbose, but you imediately know which class is being used in opposite of just using List.<br>&gt; <br>&gt; Why not use Car.List and Animal.List when its unclear from context? With Swift’s type inference you don’t often need to specify types anyway so your editor will know which list type you’re using based on how you obtained it.<br>&gt; <br>&gt; That said it does depend on the purpose of each List; do they have any commonality? They could for example both be generic List implementations, but were never factored out into a common module. If however they are specialised constructs specific to cars or animals, then the prefix may make most sense.<br>&gt; <br>&gt; For example, in the libdispatch thread the naming of Dispatch.DispatchQueue was queried, however this isn’t a general purpose queue type, it’s more specialised than that, so a name of “Queue” doesn’t convoy enough information, just as List might not. But it depends on what it actually does, which a basic example tends not to include ;)<br>&gt; <br>&gt; <br>&gt; Anyway, I’m +1 for namespaces everywhere, some names can be common. For example Node could be related to trees, physics engines and all sorts of constructs. “Node” may be a perfectly fine name for these. That said, these are sometimes tied to specific types in which case nesting them may make more sense, which I believe is already being addressed (currently we can’t nest generic types)? It’s certainly not as simple as it can appear!<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/fbda34af/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>[Discussion] Namespaces</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>May 20, 2016 at 04:00:00pm</p></header><div class="content"><p>On Fri, May 20, 2016 at 8:48 AM Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt; On May 20, 2016, at 10:27 AM, Tony Allevato via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Another use case to consider: code generation. There, namespaces can be<br>&gt; vital; they let you isolate code that you may have no real control over<br>&gt; (for example, data models that correspond to remote services) from the rest<br>&gt; of your code to avoid collisions. In some cases that can be achieved by<br>&gt; putting the shared code in its own module, but if that data description<br>&gt; format has hierarchical namespaces/packages of its own (Google&#39;s protocol<br>&gt; buffers, for example), then the lack of namespaces forces the code<br>&gt; generator to come up with contrived schemes for naming nested entities<br>&gt; (like the Objective-C implementation, which uses<br>&gt; underscore_delimited_names). The result is that Swift code using those<br>&gt; services would look *very* unnatural.<br>&gt;<br>&gt;<br>&gt; What benefits do namespaces provide that empty enums and / or submodules<br>&gt; do not?  This isn’t clear to me and I think it is an essential part of the<br>&gt; case that must be made.<br>&gt;<br></p><p>&gt; Nobody is arguing that we don’t need a way to isolate names.  The question<br>&gt; is whether namespaces are the right mechanism for doing that or not.<br>&gt;<br></p><p>I&#39;m certainly flexible on the way that organization manifests itself. In a<br>general sense, using structs-with-private-initializers or enums seems like<br>abuse of those constructs. Generic types also can&#39;t be nested yet (but this<br>is well-known and on the list of things to fix).<br></p><p>Some other concerns from my own experience in the domain of code generation:<br></p><p>I need to be able to define namespaces/organization in the source code, not<br>as an artifact of the build system, which may prevent submodules from<br>working as intended. Unless we want to be so prescriptive as to say, this<br>is the One True Way that you will build your Swift code and nothing else<br>matters, in which case I could probably generate a companion Swift package<br>manifest.<br></p><p>Would submodules support circular references between them? If module<br>Foo.Bar has a type that references something in Foo.Baz, and Foo.Baz has a<br>type that references something in Foo.Bar, will that import work (they<br>don&#39;t even have to be circular references between two *types*, just<br>different types within two *modules*)? If it&#39;s like regular top-level<br>modules now, that&#39;s not possible, because A can&#39;t import B if B imports A.<br></p><p>Structs/enums as faux namespaces also fall apart if you try to link<br>multiple build artifacts into the same library or executable. Let&#39;s say I&#39;m<br>using a code generator to generate types from a data model that defines a<br>namespace Foo. Let&#39;s go on to say that, due to the way the dependencies of<br>my project are structured, the code for type Foo.Bar is generated<br>separately from Foo.Baz. Each run of the code generator needs to be<br>independent, so in order to do that, it defines an empty Foo struct and<br>extend it with the types inside that namespace that are generated in that<br>run. So, in one run I have this:<br></p><p>generated1/Foo.swift:<br>public struct Foo { private init() {} }<br></p><p>generated1/Foo.Bar.swift:<br>extension Foo {<br>  struct Bar { ... }<br>}<br></p><p>and in another run, I have this:<br></p><p>generated2/Foo.swift:<br>public struct Foo { private init() {} }<br></p><p>generated2/Foo.Baz.swift:<br>extension Foo {<br>  struct Baz { ... }<br>}<br></p><p>I have two copies of the Foo struct, so I can&#39;t easily compile these<br>sources into object files and then pull them all together to link. Even<br>though Foo doesn&#39;t contain anything other than nested types, the compiler<br>outputs metadata symbols for Foo itself that causes duplicate link errors.<br></p><p>Swift as it is today already gets me *almost* the whole way there—merging<br>the .swiftmodules produced from the builds above works fine and results in<br>a module that defines both Bar and Baz inside Foo. Essentially, my use case<br>would be solved if I could somehow say &quot;Foo is not actually a type, it&#39;s<br>used for organization and name mangling only, so please don&#39;t include any<br>symbols for it alone in the output binary&quot;. Then everything would link<br>correctly.<br></p><p><br></p><p>&gt;<br>&gt;<br>&gt; On Fri, May 20, 2016 at 8:08 AM T.J. Usiyan via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; +1 for namespaces.<br>&gt;&gt;<br>&gt;&gt; On Fri, May 20, 2016 at 10:52 AM, Haravikk via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; On 20 May 2016, at 14:51, Krystof Vasa via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; When you have namespaces Car and Animal and each contains a class<br>&gt;&gt;&gt; called List, IMHO there should be classes CarList and AnimalList. It&#39;s more<br>&gt;&gt;&gt; verbose, but you imediately know which class is being used in opposite of<br>&gt;&gt;&gt; just using List.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Why not use Car.List and Animal.List when its unclear from context? With<br>&gt;&gt;&gt; Swift’s type inference you don’t often need to specify types anyway so your<br>&gt;&gt;&gt; editor will know which list type you’re using based on how you obtained it.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; That said it does depend on the purpose of each List; do they have any<br>&gt;&gt;&gt; commonality? They could for example both be generic List implementations,<br>&gt;&gt;&gt; but were never factored out into a common module. If however they are<br>&gt;&gt;&gt; specialised constructs specific to cars or animals, then the prefix may<br>&gt;&gt;&gt; make most sense.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; For example, in the libdispatch thread the naming of<br>&gt;&gt;&gt; Dispatch.DispatchQueue was queried, however this isn’t a general purpose<br>&gt;&gt;&gt; queue type, it’s more specialised than that, so a name of “Queue” doesn’t<br>&gt;&gt;&gt; convoy enough information, just as List might not. But it depends on what<br>&gt;&gt;&gt; it actually does, which a basic example tends not to include ;)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Anyway, I’m +1 for namespaces everywhere, some names can be common. For<br>&gt;&gt;&gt; example Node could be related to trees, physics engines and all sorts of<br>&gt;&gt;&gt; constructs. “Node” may be a perfectly fine name for these. That said, these<br>&gt;&gt;&gt; are sometimes tied to specific types in which case nesting them may make<br>&gt;&gt;&gt; more sense, which I believe is already being addressed (currently we can’t<br>&gt;&gt;&gt; nest generic types)? It’s certainly not as simple as it can appear!<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/27ee7a30/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] Namespaces</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 20, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On May 20, 2016, at 11:15 AM, Tony Allevato &lt;allevato at google.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Fri, May 20, 2016 at 8:48 AM Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; On May 20, 2016, at 10:27 AM, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Another use case to consider: code generation. There, namespaces can be vital; they let you isolate code that you may have no real control over (for example, data models that correspond to remote services) from the rest of your code to avoid collisions. In some cases that can be achieved by putting the shared code in its own module, but if that data description format has hierarchical namespaces/packages of its own (Google&#39;s protocol buffers, for example), then the lack of namespaces forces the code generator to come up with contrived schemes for naming nested entities (like the Objective-C implementation, which uses underscore_delimited_names). The result is that Swift code using those services would look *very* unnatural.<br>&gt; <br>&gt; What benefits do namespaces provide that empty enums and / or submodules do not?  This isn’t clear to me and I think it is an essential part of the case that must be made. <br>&gt; <br>&gt; Nobody is arguing that we don’t need a way to isolate names.  The question is whether namespaces are the right mechanism for doing that or not.<br>&gt; <br>&gt; I&#39;m certainly flexible on the way that organization manifests itself. In a general sense, using structs-with-private-initializers or enums seems like abuse of those constructs. Generic types also can&#39;t be nested yet (but this is well-known and on the list of things to fix).<br></p><p>Yes, it’s definitely an abuse, but one with a reasonable degree of utility.  I bring it up primarily to drive the discussion of what people want namespaces to do that this does not do today.  I don’t actually think they are a sufficient solution. :-)<br></p><p>&gt; <br>&gt; Some other concerns from my own experience in the domain of code generation:<br>&gt; <br>&gt; I need to be able to define namespaces/organization in the source code, not as an artifact of the build system, which may prevent submodules from working as intended. Unless we want to be so prescriptive as to say, this is the One True Way that you will build your Swift code and nothing else matters, in which case I could probably generate a companion Swift package manifest.<br></p><p>I would expect submodules to be able to do this.  The compilation target is the module.  Submodules are defined in source within the module, but otherwise provide the same benefits of encapsulation that modules do.  For example, `internal` visibility would be restricted to the submodule (which raises the question of whether we would want the ability to distinguish “submodule only” vs “whole module” visibility).<br></p><p>Namespaces and submodules are similar enough that we probably shouldn’t have both.  There are a couple of primary differences between them IMO.  The big one is that namespaces only deal with encapsulating names, whereas modules and submodules deal with encapsulation more generally.  <br></p><p>The other is that depending on the design of namespaces, it might be possible to introduce names into the same namespace from *different* modules.  That is a questionable capability in my mind and I would prefer to have the more generalized encapsulation of submodules.<br></p><p><br>&gt; <br>&gt; Would submodules support circular references between them? If module Foo.Bar has a type that references something in Foo.Baz, and Foo.Baz has a type that references something in Foo.Bar, will that import work (they don&#39;t even have to be circular references between two *types*, just different types within two *modules*)? If it&#39;s like regular top-level modules now, that&#39;s not possible, because A can&#39;t import B if B imports A.<br></p><p>This is a good question.  This is kind of thing I was looking for.  I would hope this is possible since they are compiled together.<br></p><p>&gt; <br>&gt; Structs/enums as faux namespaces also fall apart if you try to link multiple build artifacts into the same library or executable. Let&#39;s say I&#39;m using a code generator to generate types from a data model that defines a namespace Foo. Let&#39;s go on to say that, due to the way the dependencies of my project are structured, the code for type Foo.Bar is generated separately from Foo.Baz. Each run of the code generator needs to be independent, so in order to do that, it defines an empty Foo struct and extend it with the types inside that namespace that are generated in that run. So, in one run I have this:<br>&gt; <br>&gt; generated1/Foo.swift:<br>&gt; public struct Foo { private init() {} }<br>&gt; <br>&gt; generated1/Foo.Bar.swift:<br>&gt; extension Foo {<br>&gt;   struct Bar { ... }<br>&gt; }<br>&gt; <br>&gt; and in another run, I have this:<br>&gt; <br>&gt; generated2/Foo.swift:<br>&gt; public struct Foo { private init() {} }<br>&gt; <br>&gt; generated2/Foo.Baz.swift:<br>&gt; extension Foo {<br>&gt;   struct Baz { ... }<br>&gt; }<br>&gt; <br>&gt; I have two copies of the Foo struct, so I can&#39;t easily compile these sources into object files and then pull them all together to link. Even though Foo doesn&#39;t contain anything other than nested types, the compiler outputs metadata symbols for Foo itself that causes duplicate link errors.<br>&gt; <br>&gt; Swift as it is today already gets me *almost* the whole way there—merging the .swiftmodules produced from the builds above works fine and results in a module that defines both Bar and Baz inside Foo. Essentially, my use case would be solved if I could somehow say &quot;Foo is not actually a type, it&#39;s used for organization and name mangling only, so please don&#39;t include any symbols for it alone in the output binary&quot;. Then everything would link correctly.<br></p><p>If you absolutely need the two runs to be totally independent I can see why it is frustrating to be so close.  What is the reason that you can’t have them share the struct “namespace” declarations in a third folder?  It’s not a good long-term solution but might help you move forward with what we have available today.<br></p><p>namespaces/Foo.swift:<br>public struct Foo { private init() {} }<br></p><p>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Fri, May 20, 2016 at 8:08 AM T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; +1 for namespaces. <br>&gt;&gt; <br>&gt;&gt; On Fri, May 20, 2016 at 10:52 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt; On 20 May 2016, at 14:51, Krystof Vasa via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; When you have namespaces Car and Animal and each contains a class called List, IMHO there should be classes CarList and AnimalList. It&#39;s more verbose, but you imediately know which class is being used in opposite of just using List.<br>&gt;&gt; <br>&gt;&gt; Why not use Car.List and Animal.List when its unclear from context? With Swift’s type inference you don’t often need to specify types anyway so your editor will know which list type you’re using based on how you obtained it.<br>&gt;&gt; <br>&gt;&gt; That said it does depend on the purpose of each List; do they have any commonality? They could for example both be generic List implementations, but were never factored out into a common module. If however they are specialised constructs specific to cars or animals, then the prefix may make most sense.<br>&gt;&gt; <br>&gt;&gt; For example, in the libdispatch thread the naming of Dispatch.DispatchQueue was queried, however this isn’t a general purpose queue type, it’s more specialised than that, so a name of “Queue” doesn’t convoy enough information, just as List might not. But it depends on what it actually does, which a basic example tends not to include ;)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Anyway, I’m +1 for namespaces everywhere, some names can be common. For example Node could be related to trees, physics engines and all sorts of constructs. “Node” may be a perfectly fine name for these. That said, these are sometimes tied to specific types in which case nesting them may make more sense, which I believe is already being addressed (currently we can’t nest generic types)? It’s certainly not as simple as it can appear!<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/dc377ba6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>[Discussion] Namespaces</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>May 20, 2016 at 05:00:00pm</p></header><div class="content"><p>On Fri, May 20, 2016 at 9:37 AM Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt; On May 20, 2016, at 11:15 AM, Tony Allevato &lt;allevato at google.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Fri, May 20, 2016 at 8:48 AM Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; On May 20, 2016, at 10:27 AM, Tony Allevato via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Another use case to consider: code generation. There, namespaces can be<br>&gt;&gt; vital; they let you isolate code that you may have no real control over<br>&gt;&gt; (for example, data models that correspond to remote services) from the rest<br>&gt;&gt; of your code to avoid collisions. In some cases that can be achieved by<br>&gt;&gt; putting the shared code in its own module, but if that data description<br>&gt;&gt; format has hierarchical namespaces/packages of its own (Google&#39;s protocol<br>&gt;&gt; buffers, for example), then the lack of namespaces forces the code<br>&gt;&gt; generator to come up with contrived schemes for naming nested entities<br>&gt;&gt; (like the Objective-C implementation, which uses<br>&gt;&gt; underscore_delimited_names). The result is that Swift code using those<br>&gt;&gt; services would look *very* unnatural.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; What benefits do namespaces provide that empty enums and / or submodules<br>&gt;&gt; do not?  This isn’t clear to me and I think it is an essential part of the<br>&gt;&gt; case that must be made.<br>&gt;&gt;<br>&gt;<br>&gt;&gt; Nobody is arguing that we don’t need a way to isolate names.  The<br>&gt;&gt; question is whether namespaces are the right mechanism for doing that or<br>&gt;&gt; not.<br>&gt;&gt;<br>&gt;<br>&gt; I&#39;m certainly flexible on the way that organization manifests itself. In a<br>&gt; general sense, using structs-with-private-initializers or enums seems<br>&gt; like abuse of those constructs. Generic types also can&#39;t be nested yet (but<br>&gt; this is well-known and on the list of things to fix).<br>&gt;<br>&gt;<br>&gt; Yes, it’s definitely an abuse, but one with a reasonable degree of<br>&gt; utility.  I bring it up primarily to drive the discussion of what people<br>&gt; want namespaces to do that this does not do today.  I don’t actually think<br>&gt; they are a sufficient solution. :-)<br>&gt;<br>&gt;<br>&gt; Some other concerns from my own experience in the domain of code<br>&gt; generation:<br>&gt;<br>&gt; I need to be able to define namespaces/organization in the source code,<br>&gt; not as an artifact of the build system, which may prevent submodules from<br>&gt; working as intended. Unless we want to be so prescriptive as to say, this<br>&gt; is the One True Way that you will build your Swift code and nothing else<br>&gt; matters, in which case I could probably generate a companion Swift package<br>&gt; manifest.<br>&gt;<br>&gt;<br>&gt; I would expect submodules to be able to do this.  The compilation target<br>&gt; is the module.  Submodules are defined in source *within* the module, but<br>&gt; otherwise provide the same benefits of encapsulation that modules do.  For<br>&gt; example, `internal` visibility would be restricted to the submodule (which<br>&gt; raises the question of whether we would want the ability to distinguish<br>&gt; “submodule only” vs “whole module” visibility).<br>&gt;<br>&gt; Namespaces and submodules are similar enough that we probably shouldn’t<br>&gt; have both.  There are a couple of primary differences between them IMO.<br>&gt; The big one is that namespaces only deal with encapsulating names, whereas<br>&gt; modules and submodules deal with encapsulation more generally.<br>&gt;<br>&gt; The other is that depending on the design of namespaces, it might be<br>&gt; possible to introduce names into the same namespace from *different*<br>&gt; modules.  That is a questionable capability in my mind and I would prefer<br>&gt; to have the more generalized encapsulation of submodules.<br>&gt;<br>&gt;<br>&gt;<br>&gt; Would submodules support circular references between them? If module<br>&gt; Foo.Bar has a type that references something in Foo.Baz, and Foo.Baz has a<br>&gt; type that references something in Foo.Bar, will that import work (they<br>&gt; don&#39;t even have to be circular references between two *types*, just<br>&gt; different types within two *modules*)? If it&#39;s like regular top-level<br>&gt; modules now, that&#39;s not possible, because A can&#39;t import B if B imports A.<br>&gt;<br>&gt;<br>&gt; This is a good question.  This is kind of thing I was looking for.  I<br>&gt; would hope this is possible since they are compiled together.<br>&gt;<br>&gt;<br>&gt; Structs/enums as faux namespaces also fall apart if you try to link<br>&gt; multiple build artifacts into the same library or executable. Let&#39;s say I&#39;m<br>&gt; using a code generator to generate types from a data model that defines a<br>&gt; namespace Foo. Let&#39;s go on to say that, due to the way the dependencies of<br>&gt; my project are structured, the code for type Foo.Bar is generated<br>&gt; separately from Foo.Baz. Each run of the code generator needs to be<br>&gt; independent, so in order to do that, it defines an empty Foo struct and<br>&gt; extend it with the types inside that namespace that are generated in that<br>&gt; run. So, in one run I have this:<br>&gt;<br>&gt; generated1/Foo.swift:<br>&gt; public struct Foo { private init() {} }<br>&gt;<br>&gt; generated1/Foo.Bar.swift:<br>&gt; extension Foo {<br>&gt;   struct Bar { ... }<br>&gt; }<br>&gt;<br>&gt; and in another run, I have this:<br>&gt;<br>&gt; generated2/Foo.swift:<br>&gt; public struct Foo { private init() {} }<br>&gt;<br>&gt; generated2/Foo.Baz.swift:<br>&gt; extension Foo {<br>&gt;   struct Baz { ... }<br>&gt; }<br>&gt;<br>&gt; I have two copies of the Foo struct, so I can&#39;t easily compile these<br>&gt; sources into object files and then pull them all together to link. Even<br>&gt; though Foo doesn&#39;t contain anything other than nested types, the compiler<br>&gt; outputs metadata symbols for Foo itself that causes duplicate link errors.<br>&gt;<br>&gt;<br>&gt; Swift as it is today already gets me *almost* the whole way there—merging<br>&gt; the .swiftmodules produced from the builds above works fine and results in<br>&gt; a module that defines both Bar and Baz inside Foo. Essentially, my use case<br>&gt; would be solved if I could somehow say &quot;Foo is not actually a type, it&#39;s<br>&gt; used for organization and name mangling only, so please don&#39;t include any<br>&gt; symbols for it alone in the output binary&quot;. Then everything would link<br>&gt; correctly.<br>&gt;<br>&gt;<br>&gt; If you absolutely need the two runs to be totally independent I can see<br>&gt; why it is frustrating to be so close.  What is the reason that you can’t<br>&gt; have them share the struct “namespace” declarations in a third folder?<br>&gt; It’s not a good long-term solution but might help you move forward with<br>&gt; what we have available today.<br>&gt;<br></p><p>In my situation, the build system puts artifacts in a derived path based on<br>its source path in the workspace; using additional rules to move them into<br>different locations or merge them is nontrivial, and inconvenient for the<br>end user who wants to build two different dependencies and have them &quot;just<br>work&quot; (especially since they could be dependencies of dependencies that<br>they pull in without their knowledge).<br></p><p><br></p><p>&gt; namespaces/Foo.swift:<br>&gt;<br>&gt; public struct Foo { private init() {} }<br>&gt;<br>&gt; On Fri, May 20, 2016 at 8:08 AM T.J. Usiyan via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; +1 for namespaces.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Fri, May 20, 2016 at 10:52 AM, Haravikk via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt; On 20 May 2016, at 14:51, Krystof Vasa via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; When you have namespaces Car and Animal and each contains a class<br>&gt;&gt;&gt;&gt; called List, IMHO there should be classes CarList and AnimalList. It&#39;s more<br>&gt;&gt;&gt;&gt; verbose, but you imediately know which class is being used in opposite of<br>&gt;&gt;&gt;&gt; just using List.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Why not use Car.List and Animal.List when its unclear from context?<br>&gt;&gt;&gt;&gt; With Swift’s type inference you don’t often need to specify types anyway so<br>&gt;&gt;&gt;&gt; your editor will know which list type you’re using based on how you<br>&gt;&gt;&gt;&gt; obtained it.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; That said it does depend on the purpose of each List; do they have any<br>&gt;&gt;&gt;&gt; commonality? They could for example both be generic List implementations,<br>&gt;&gt;&gt;&gt; but were never factored out into a common module. If however they are<br>&gt;&gt;&gt;&gt; specialised constructs specific to cars or animals, then the prefix may<br>&gt;&gt;&gt;&gt; make most sense.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; For example, in the libdispatch thread the naming of<br>&gt;&gt;&gt;&gt; Dispatch.DispatchQueue was queried, however this isn’t a general purpose<br>&gt;&gt;&gt;&gt; queue type, it’s more specialised than that, so a name of “Queue” doesn’t<br>&gt;&gt;&gt;&gt; convoy enough information, just as List might not. But it depends on what<br>&gt;&gt;&gt;&gt; it actually does, which a basic example tends not to include ;)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Anyway, I’m +1 for namespaces everywhere, some names can be common. For<br>&gt;&gt;&gt;&gt; example Node could be related to trees, physics engines and all sorts of<br>&gt;&gt;&gt;&gt; constructs. “Node” may be a perfectly fine name for these. That said, these<br>&gt;&gt;&gt;&gt; are sometimes tied to specific types in which case nesting them may make<br>&gt;&gt;&gt;&gt; more sense, which I believe is already being addressed (currently we can’t<br>&gt;&gt;&gt;&gt; nest generic types)? It’s certainly not as simple as it can appear!<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/71ea9680/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] Namespaces</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 20, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On May 20, 2016, at 12:08 PM, Tony Allevato &lt;allevato at google.com&gt; wrote:<br>&gt; <br>&gt; On Fri, May 20, 2016 at 9:37 AM Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; On May 20, 2016, at 11:15 AM, Tony Allevato &lt;allevato at google.com &lt;mailto:allevato at google.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Fri, May 20, 2016 at 8:48 AM Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt; On May 20, 2016, at 10:27 AM, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another use case to consider: code generation. There, namespaces can be vital; they let you isolate code that you may have no real control over (for example, data models that correspond to remote services) from the rest of your code to avoid collisions. In some cases that can be achieved by putting the shared code in its own module, but if that data description format has hierarchical namespaces/packages of its own (Google&#39;s protocol buffers, for example), then the lack of namespaces forces the code generator to come up with contrived schemes for naming nested entities (like the Objective-C implementation, which uses underscore_delimited_names). The result is that Swift code using those services would look *very* unnatural.<br>&gt;&gt; <br>&gt;&gt; What benefits do namespaces provide that empty enums and / or submodules do not?  This isn’t clear to me and I think it is an essential part of the case that must be made. <br>&gt;&gt; <br>&gt;&gt; Nobody is arguing that we don’t need a way to isolate names.  The question is whether namespaces are the right mechanism for doing that or not.<br>&gt;&gt; <br>&gt;&gt; I&#39;m certainly flexible on the way that organization manifests itself. In a general sense, using structs-with-private-initializers or enums seems like abuse of those constructs. Generic types also can&#39;t be nested yet (but this is well-known and on the list of things to fix).<br>&gt; <br>&gt; Yes, it’s definitely an abuse, but one with a reasonable degree of utility.  I bring it up primarily to drive the discussion of what people want namespaces to do that this does not do today.  I don’t actually think they are a sufficient solution. :-)<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Some other concerns from my own experience in the domain of code generation:<br>&gt;&gt; <br>&gt;&gt; I need to be able to define namespaces/organization in the source code, not as an artifact of the build system, which may prevent submodules from working as intended. Unless we want to be so prescriptive as to say, this is the One True Way that you will build your Swift code and nothing else matters, in which case I could probably generate a companion Swift package manifest.<br>&gt; <br>&gt; I would expect submodules to be able to do this.  The compilation target is the module.  Submodules are defined in source within the module, but otherwise provide the same benefits of encapsulation that modules do.  For example, `internal` visibility would be restricted to the submodule (which raises the question of whether we would want the ability to distinguish “submodule only” vs “whole module” visibility).<br>&gt; <br>&gt; Namespaces and submodules are similar enough that we probably shouldn’t have both.  There are a couple of primary differences between them IMO.  The big one is that namespaces only deal with encapsulating names, whereas modules and submodules deal with encapsulation more generally.  <br>&gt; <br>&gt; The other is that depending on the design of namespaces, it might be possible to introduce names into the same namespace from *different* modules.  That is a questionable capability in my mind and I would prefer to have the more generalized encapsulation of submodules.<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; Would submodules support circular references between them? If module Foo.Bar has a type that references something in Foo.Baz, and Foo.Baz has a type that references something in Foo.Bar, will that import work (they don&#39;t even have to be circular references between two *types*, just different types within two *modules*)? If it&#39;s like regular top-level modules now, that&#39;s not possible, because A can&#39;t import B if B imports A.<br>&gt; <br>&gt; This is a good question.  This is kind of thing I was looking for.  I would hope this is possible since they are compiled together.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Structs/enums as faux namespaces also fall apart if you try to link multiple build artifacts into the same library or executable. Let&#39;s say I&#39;m using a code generator to generate types from a data model that defines a namespace Foo. Let&#39;s go on to say that, due to the way the dependencies of my project are structured, the code for type Foo.Bar is generated separately from Foo.Baz. Each run of the code generator needs to be independent, so in order to do that, it defines an empty Foo struct and extend it with the types inside that namespace that are generated in that run. So, in one run I have this:<br>&gt;&gt; <br>&gt;&gt; generated1/Foo.swift:<br>&gt;&gt; public struct Foo { private init() {} }<br>&gt;&gt; <br>&gt;&gt; generated1/Foo.Bar.swift:<br>&gt;&gt; extension Foo {<br>&gt;&gt;   struct Bar { ... }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; and in another run, I have this:<br>&gt;&gt; <br>&gt;&gt; generated2/Foo.swift:<br>&gt;&gt; public struct Foo { private init() {} }<br>&gt;&gt; <br>&gt;&gt; generated2/Foo.Baz.swift:<br>&gt;&gt; extension Foo {<br>&gt;&gt;   struct Baz { ... }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I have two copies of the Foo struct, so I can&#39;t easily compile these sources into object files and then pull them all together to link. Even though Foo doesn&#39;t contain anything other than nested types, the compiler outputs metadata symbols for Foo itself that causes duplicate link errors.<br>&gt;&gt; <br>&gt;&gt; Swift as it is today already gets me *almost* the whole way there—merging the .swiftmodules produced from the builds above works fine and results in a module that defines both Bar and Baz inside Foo. Essentially, my use case would be solved if I could somehow say &quot;Foo is not actually a type, it&#39;s used for organization and name mangling only, so please don&#39;t include any symbols for it alone in the output binary&quot;. Then everything would link correctly.<br>&gt; <br>&gt; If you absolutely need the two runs to be totally independent I can see why it is frustrating to be so close.  What is the reason that you can’t have them share the struct “namespace” declarations in a third folder?  It’s not a good long-term solution but might help you move forward with what we have available today.<br>&gt; <br>&gt; In my situation, the build system puts artifacts in a derived path based on its source path in the workspace; using additional rules to move them into different locations or merge them is nontrivial, and inconvenient for the end user who wants to build two different dependencies and have them &quot;just work&quot; (especially since they could be dependencies of dependencies that they pull in without their knowledge).<br></p><p>I’m confused by “build two different dependences”.  Are they building two totally separate target modules?  This can’t be the case can it?  If so, the structs would be independent because they would be in separate modules, even thought they have the same name.  `Generated1.Foo` would not be the same as `Generated2.Foo`.<br></p><p><br>&gt; <br>&gt; <br>&gt; <br>&gt; namespaces/Foo.swift:<br>&gt; <br>&gt; public struct Foo { private init() {} }<br>&gt;&gt;&gt; On Fri, May 20, 2016 at 8:08 AM T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; +1 for namespaces. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Fri, May 20, 2016 at 10:52 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; On 20 May 2016, at 14:51, Krystof Vasa via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; When you have namespaces Car and Animal and each contains a class called List, IMHO there should be classes CarList and AnimalList. It&#39;s more verbose, but you imediately know which class is being used in opposite of just using List.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Why not use Car.List and Animal.List when its unclear from context? With Swift’s type inference you don’t often need to specify types anyway so your editor will know which list type you’re using based on how you obtained it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That said it does depend on the purpose of each List; do they have any commonality? They could for example both be generic List implementations, but were never factored out into a common module. If however they are specialised constructs specific to cars or animals, then the prefix may make most sense.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For example, in the libdispatch thread the naming of Dispatch.DispatchQueue was queried, however this isn’t a general purpose queue type, it’s more specialised than that, so a name of “Queue” doesn’t convoy enough information, just as List might not. But it depends on what it actually does, which a basic example tends not to include ;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Anyway, I’m +1 for namespaces everywhere, some names can be common. For example Node could be related to trees, physics engines and all sorts of constructs. “Node” may be a perfectly fine name for these. That said, these are sometimes tied to specific types in which case nesting them may make more sense, which I believe is already being addressed (currently we can’t nest generic types)? It’s certainly not as simple as it can appear!<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/1d8a3122/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Discussion] Namespaces</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 20, 2016 at 06:00:00pm</p></header><div class="content"><p>Regards<br>(From mobile)<br></p><p>&gt; On May 20, 2016, at 5:48 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 20, 2016, at 10:27 AM, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Another use case to consider: code generation. There, namespaces can be vital; they let you isolate code that you may have no real control over (for example, data models that correspond to remote services) from the rest of your code to avoid collisions. In some cases that can be achieved by putting the shared code in its own module, but if that data description format has hierarchical namespaces/packages of its own (Google&#39;s protocol buffers, for example), then the lack of namespaces forces the code generator to come up with contrived schemes for naming nested entities (like the Objective-C implementation, which uses underscore_delimited_names). The result is that Swift code using those services would look *very* unnatural.<br>&gt; <br>&gt; What benefits do namespaces provide that empty enums and / or submodules do not?  This isn’t clear to me and I think it is an essential part of the case that must be made.<br>&gt; <br>&gt; Nobody is arguing that we don’t need a way to isolate names.  The question is whether namespaces are the right mechanism for doing that or not.<br></p><p>Yes, IMO they would, for the simple fact that they would be a easy to recognize boundary line where the linking behavior would changes (this is what modules do). Because of modules being tied to the dylib behavior, it means namespaces would have to follow suit and basically limit themselves to be submodules (I&#39;m sure something could be done to pretend that 2 separate dylibs form a single namespace, but i am not sure this is the best way for someone to use their time, not to mention how it would break all the work done in the last couple years with profile optimizations).<br></p><p><br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Fri, May 20, 2016 at 8:08 AM T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; +1 for namespaces. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Fri, May 20, 2016 at 10:52 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt; On 20 May 2016, at 14:51, Krystof Vasa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; When you have namespaces Car and Animal and each contains a class called List, IMHO there should be classes CarList and AnimalList. It&#39;s more verbose, but you imediately know which class is being used in opposite of just using List.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Why not use Car.List and Animal.List when its unclear from context? With Swift’s type inference you don’t often need to specify types anyway so your editor will know which list type you’re using based on how you obtained it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That said it does depend on the purpose of each List; do they have any commonality? They could for example both be generic List implementations, but were never factored out into a common module. If however they are specialised constructs specific to cars or animals, then the prefix may make most sense.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For example, in the libdispatch thread the naming of Dispatch.DispatchQueue was queried, however this isn’t a general purpose queue type, it’s more specialised than that, so a name of “Queue” doesn’t convoy enough information, just as List might not. But it depends on what it actually does, which a basic example tends not to include ;)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Anyway, I’m +1 for namespaces everywhere, some names can be common. For example Node could be related to trees, physics engines and all sorts of constructs. “Node” may be a perfectly fine name for these. That said, these are sometimes tied to specific types in which case nesting them may make more sense, which I believe is already being addressed (currently we can’t nest generic types)? It’s certainly not as simple as it can appear!<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/e387f3da/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bffdf86cef4f7a52a9c00edefdbf57ed?s=50"></div><header><strong>[Discussion] Namespaces</strong> from <string>Robert Schwalbe</string> &lt;dev-null at inode.com&gt;<p>May 20, 2016 at 11:00:00am</p></header><div class="content"><p>&gt;Anyway, I&#39;m +1 for namespaces everywhere, some names can be common. <br>&gt;For example Node could be related to trees, physics engines and all <br>&gt;sorts of constructs. &quot;Node&quot; may be a perfectly fine name for these. <br>&gt;That said, these are sometimes tied to specific types in which case <br>&gt;nesting them may make more sense, which I believe is already being <br>&gt;addressed (currently we can&#39;t nest generic types)? It&#39;s certainly <br>&gt;not as simple as it can appear!<br></p><p>Absolutely +1 for namespaces.<br></p><p>Even if you despise the concept of namespaces that seems like that <br>can be addressed by a project and/or company style guide that <br>explicitly forbids their use.<br></p><p>For the people/projects that would embrace namespaces, namespaces <br>would be a godsend.<br></p><p>Sure, you can probably pull all kind of stunts to simulate <br>namespaces, but besides creating additional  work for the Swift team <br>(and I do not say nor take that lightly), they really need to be <br>supported and implemented at the language/syntax level for first <br>class citizenry.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] Namespaces</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 20, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On May 20, 2016, at 10:43 AM, Robert Schwalbe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Anyway, I&#39;m +1 for namespaces everywhere, some names can be common. For example Node could be related to trees, physics engines and all sorts of constructs. &quot;Node&quot; may be a perfectly fine name for these. That said, these are sometimes tied to specific types in which case nesting them may make more sense, which I believe is already being addressed (currently we can&#39;t nest generic types)? It&#39;s certainly not as simple as it can appear!<br>&gt; <br>&gt; Absolutely +1 for namespaces.<br>&gt; <br>&gt; Even if you despise the concept of namespaces that seems like that can be addressed by a project and/or company style guide that explicitly forbids their use.<br>&gt; <br>&gt; For the people/projects that would embrace namespaces, namespaces would be a godsend.<br>&gt; <br>&gt; Sure, you can probably pull all kind of stunts to simulate namespaces, but besides creating additional  work for the Swift team (and I do not say nor take that lightly), they really need to be supported and implemented at the language/syntax level for first class citizenry.<br></p><p>What benefit do namespaces provide that submodules would not?<br></p><p>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Discussion] Namespaces</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May 20, 2016 at 05:00:00pm</p></header><div class="content"><p>Can submodules enforce the developer to use its name ’Submodule.SomeClass’? Do I have to re-build submodules when I made any changes to them before building the outside code base? Can they efficiently used for cross decencies between different modules/submodules?<br></p><p>—— <br>Empty enums is an abuse of the language! <br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 20. Mai 2016 bei 17:49:29, Matthew Johnson via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p><br>&gt; On May 20, 2016, at 10:43 AM, Robert Schwalbe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;  <br>&gt;&gt; Anyway, I&#39;m +1 for namespaces everywhere, some names can be common. For example Node could be related to trees, physics engines and all sorts of constructs. &quot;Node&quot; may be a perfectly fine name for these. That said, these are sometimes tied to specific types in which case nesting them may make more sense, which I believe is already being addressed (currently we can&#39;t nest generic types)? It&#39;s certainly not as simple as it can appear!<br>&gt;  <br>&gt; Absolutely +1 for namespaces.<br>&gt;  <br>&gt; Even if you despise the concept of namespaces that seems like that can be addressed by a project and/or company style guide that explicitly forbids their use.<br>&gt;  <br>&gt; For the people/projects that would embrace namespaces, namespaces would be a godsend.<br>&gt;  <br>&gt; Sure, you can probably pull all kind of stunts to simulate namespaces, but besides creating additional work for the Swift team (and I do not say nor take that lightly), they really need to be supported and implemented at the language/syntax level for first class citizenry.<br></p><p>What benefit do namespaces provide that submodules would not?<br></p><p>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/4fbbadaa/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] Namespaces</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 20, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On May 20, 2016, at 10:54 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Can submodules enforce the developer to use its name ’Submodule.SomeClass’?<br></p><p>Ideally we would have flexible import syntax that allows for control over *how* names are imported into a lexical context (including the ability to import names within a very specific scope if desired).<br></p><p>&gt; Do I have to re-build submodules when I made any changes to them before building the outside code base?<br></p><p>All submodules are part of the same target as the module that contains them.<br></p><p>&gt; Can they efficiently used for cross decencies between different modules/submodules?<br></p><p>Cross decencies?  I don’t understand.<br></p><p>&gt; <br>&gt; —— <br>&gt; Empty enums is an abuse of the language! <br></p><p>But it is a practical and effective one.  Introducing a new construct like namespaces must carry significant advantages over what is already possible.<br></p><p>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Am 20. Mai 2016 bei 17:49:29, Matthew Johnson via swift-evolution (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;) schrieb:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; &gt; On May 20, 2016, at 10:43 AM, Robert Schwalbe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt; <br>&gt;&gt; &gt;&gt; Anyway, I&#39;m +1 for namespaces everywhere, some names can be common. For example Node could be related to trees, physics engines and all sorts of constructs. &quot;Node&quot; may be a perfectly fine name for these. That said, these are sometimes tied to specific types in which case nesting them may make more sense, which I believe is already being addressed (currently we can&#39;t nest generic types)? It&#39;s certainly not as simple as it can appear!<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; Absolutely +1 for namespaces.<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; Even if you despise the concept of namespaces that seems like that can be addressed by a project and/or company style guide that explicitly forbids their use.<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; For the people/projects that would embrace namespaces, namespaces would be a godsend.<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; Sure, you can probably pull all kind of stunts to simulate namespaces, but besides creating additional work for the Swift team (and I do not say nor take that lightly), they really need to be supported and implemented at the language/syntax level for first class citizenry.<br>&gt;&gt; <br>&gt;&gt; What benefit do namespaces provide that submodules would not?<br>&gt;&gt; <br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/39bf5ca4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>[Discussion] Namespaces</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>May 20, 2016 at 12:00:00pm</p></header><div class="content"><p>I&#39;m pretty sure he meant &quot;cross dependencies&quot;<br></p><p>Brandon <br></p><p>Sent from my iPad<br></p><p>&gt; On May 20, 2016, at 12:06 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 20, 2016, at 10:54 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Can submodules enforce the developer to use its name ’Submodule.SomeClass’?<br>&gt; <br>&gt; Ideally we would have flexible import syntax that allows for control over *how* names are imported into a lexical context (including the ability to import names within a very specific scope if desired).<br>&gt; <br>&gt;&gt; Do I have to re-build submodules when I made any changes to them before building the outside code base?<br>&gt; <br>&gt; All submodules are part of the same target as the module that contains them.<br>&gt; <br>&gt;&gt; Can they efficiently used for cross decencies between different modules/submodules?<br>&gt; <br>&gt; Cross decencies?  I don’t understand.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; —— <br>&gt;&gt; Empty enums is an abuse of the language! <br>&gt; <br>&gt; But it is a practical and effective one.  Introducing a new construct like namespaces must carry significant advantages over what is already possible.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Adrian Zubarev<br>&gt;&gt; Sent with Airmail<br>&gt;&gt; <br>&gt;&gt; Am 20. Mai 2016 bei 17:49:29, Matthew Johnson via swift-evolution (swift-evolution at swift.org) schrieb:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; On May 20, 2016, at 10:43 AM, Robert Schwalbe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt; &gt;&gt; Anyway, I&#39;m +1 for namespaces everywhere, some names can be common. For example Node could be related to trees, physics engines and all sorts of constructs. &quot;Node&quot; may be a perfectly fine name for these. That said, these are sometimes tied to specific types in which case nesting them may make more sense, which I believe is already being addressed (currently we can&#39;t nest generic types)? It&#39;s certainly not as simple as it can appear!<br>&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt; &gt; Absolutely +1 for namespaces.<br>&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt; &gt; Even if you despise the concept of namespaces that seems like that can be addressed by a project and/or company style guide that explicitly forbids their use.<br>&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt; &gt; For the people/projects that would embrace namespaces, namespaces would be a godsend.<br>&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt; &gt; Sure, you can probably pull all kind of stunts to simulate namespaces, but besides creating additional work for the Swift team (and I do not say nor take that lightly), they really need to be supported and implemented at the language/syntax level for first class citizenry.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What benefit do namespaces provide that submodules would not?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/9b48332a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] Namespaces</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 20, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On May 20, 2016, at 11:09 AM, Brandon Knope &lt;bknope at me.com&gt; wrote:<br>&gt; <br>&gt; I&#39;m pretty sure he meant &quot;cross dependencies”<br></p><p>It’s still unclear to me how namespaces might help in a way that submodules wouldn’t.  Can one of you provide an example of the problem you have in mind and how it is solved with namespaces?<br></p><p>&gt; <br>&gt; Brandon <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On May 20, 2016, at 12:06 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 20, 2016, at 10:54 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Can submodules enforce the developer to use its name ’Submodule.SomeClass’?<br>&gt;&gt; <br>&gt;&gt; Ideally we would have flexible import syntax that allows for control over *how* names are imported into a lexical context (including the ability to import names within a very specific scope if desired).<br>&gt;&gt; <br>&gt;&gt;&gt; Do I have to re-build submodules when I made any changes to them before building the outside code base?<br>&gt;&gt; <br>&gt;&gt; All submodules are part of the same target as the module that contains them.<br>&gt;&gt; <br>&gt;&gt;&gt; Can they efficiently used for cross decencies between different modules/submodules?<br>&gt;&gt; <br>&gt;&gt; Cross decencies?  I don’t understand.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; —— <br>&gt;&gt;&gt; Empty enums is an abuse of the language! <br>&gt;&gt; <br>&gt;&gt; But it is a practical and effective one.  Introducing a new construct like namespaces must carry significant advantages over what is already possible.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 20. Mai 2016 bei 17:49:29, Matthew Johnson via swift-evolution (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;) schrieb:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt; On May 20, 2016, at 10:43 AM, Robert Schwalbe via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt; &gt;&gt; Anyway, I&#39;m +1 for namespaces everywhere, some names can be common. For example Node could be related to trees, physics engines and all sorts of constructs. &quot;Node&quot; may be a perfectly fine name for these. That said, these are sometimes tied to specific types in which case nesting them may make more sense, which I believe is already being addressed (currently we can&#39;t nest generic types)? It&#39;s certainly not as simple as it can appear!<br>&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt; &gt; Absolutely +1 for namespaces.<br>&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt; &gt; Even if you despise the concept of namespaces that seems like that can be addressed by a project and/or company style guide that explicitly forbids their use.<br>&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt; &gt; For the people/projects that would embrace namespaces, namespaces would be a godsend.<br>&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt; &gt; Sure, you can probably pull all kind of stunts to simulate namespaces, but besides creating additional work for the Swift team (and I do not say nor take that lightly), they really need to be supported and implemented at the language/syntax level for first class citizenry.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What benefit do namespaces provide that submodules would not?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/a77b6344/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>[Discussion] Namespaces</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>May 20, 2016 at 12:00:00pm</p></header><div class="content"><p>I&#39;m definitely leaning toward submodules too. That seems more &quot;Swifty&quot; to me. <br></p><p>I too would like to see some examples of namespaces in action <br></p><p>Brandon <br></p><p>&gt; On May 20, 2016, at 12:12 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 20, 2016, at 11:09 AM, Brandon Knope &lt;bknope at me.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;m pretty sure he meant &quot;cross dependencies”<br>&gt; <br>&gt; It’s still unclear to me how namespaces might help in a way that submodules wouldn’t.  Can one of you provide an example of the problem you have in mind and how it is solved with namespaces?<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Brandon <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt;&gt; On May 20, 2016, at 12:06 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 20, 2016, at 10:54 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Can submodules enforce the developer to use its name ’Submodule.SomeClass’?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Ideally we would have flexible import syntax that allows for control over *how* names are imported into a lexical context (including the ability to import names within a very specific scope if desired).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Do I have to re-build submodules when I made any changes to them before building the outside code base?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; All submodules are part of the same target as the module that contains them.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Can they efficiently used for cross decencies between different modules/submodules?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Cross decencies?  I don’t understand.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; —— <br>&gt;&gt;&gt;&gt; Empty enums is an abuse of the language! <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But it is a practical and effective one.  Introducing a new construct like namespaces must carry significant advantages over what is already possible.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 20. Mai 2016 bei 17:49:29, Matthew Johnson via swift-evolution (swift-evolution at swift.org) schrieb:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; On May 20, 2016, at 10:43 AM, Robert Schwalbe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; Anyway, I&#39;m +1 for namespaces everywhere, some names can be common. For example Node could be related to trees, physics engines and all sorts of constructs. &quot;Node&quot; may be a perfectly fine name for these. That said, these are sometimes tied to specific types in which case nesting them may make more sense, which I believe is already being addressed (currently we can&#39;t nest generic types)? It&#39;s certainly not as simple as it can appear!<br>&gt;&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; Absolutely +1 for namespaces.<br>&gt;&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; Even if you despise the concept of namespaces that seems like that can be addressed by a project and/or company style guide that explicitly forbids their use.<br>&gt;&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; For the people/projects that would embrace namespaces, namespaces would be a godsend.<br>&gt;&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; Sure, you can probably pull all kind of stunts to simulate namespaces, but besides creating additional work for the Swift team (and I do not say nor take that lightly), they really need to be supported and implemented at the language/syntax level for first class citizenry.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; What benefit do namespaces provide that submodules would not?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/18d2b165/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Discussion] Namespaces</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May 20, 2016 at 06:00:00pm</p></header><div class="content"><p>On May 20, 2016, at 10:54 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>Can submodules enforce the developer to use its name ’Submodule.SomeClass’?<br></p><p>Ideally we would have flexible import syntax that allows for control over *how* names are imported into a lexical context (including the ability to import names within a very specific scope if desired).<br>Ok fine.<br></p><p>Do I have to re-build submodules when I made any changes to them before building the outside code base?<br></p><p>All submodules are part of the same target as the module that contains them.<br></p><p>Can they efficiently used for cross decencies between different modules/submodules?<br></p><p>Cross decencies?  I don’t understand.<br>Sorry it’s me again: &quot;cross dependencies“<br></p><p>MainProject (module/package)<br></p><p>   |__Submodule<br>   |           |__SubSubmodule<br>   |__AnotherSubmodule<br></p><p>Can I enforce usage of `AnotherSubmodule.Someclass` inside of `SubSubmodule`???<br>Empty enums is an abuse of the language! <br></p><p>But it is a practical and effective one.  Introducing a new construct like namespaces must carry significant advantages over what is already possible.<br></p><p>Still abuse of the language no matter how you turn it. I don’t say `namespaces` should only do the same enums do (in my case it would be enough), if there is more they could solve sure why not. Thats a discussion is for isn’t it? I’m not an expert so I want to learn from people that might provide good examples and reasons why namespaces are good or not. <br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/db5605a8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] Namespaces</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 20, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On May 20, 2016, at 11:16 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 20, 2016, at 10:54 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Can submodules enforce the developer to use its name ’Submodule.SomeClass’?<br>&gt;&gt; <br>&gt;&gt; Ideally we would have flexible import syntax that allows for control over *how* names are imported into a lexical context (including the ability to import names within a very specific scope if desired).<br>&gt; <br>&gt; Ok fine.<br>&gt; <br>&gt;&gt;&gt; Do I have to re-build submodules when I made any changes to them before building the outside code base?<br>&gt;&gt; <br>&gt;&gt; All submodules are part of the same target as the module that contains them.<br>&gt;&gt; <br>&gt;&gt;&gt; Can they efficiently used for cross decencies between different modules/submodules?<br>&gt;&gt; <br>&gt;&gt; Cross decencies?  I don’t understand.<br>&gt; <br>&gt; Sorry it’s me again: &quot;cross dependencies“<br>&gt; <br>&gt; MainProject (module/package)<br>&gt; <br>&gt;    |__Submodule<br>&gt;    |           |__SubSubmodule<br>&gt;    |__AnotherSubmodule<br>&gt; <br>&gt; Can I enforce usage of `AnotherSubmodule.Someclass` inside of `SubSubmodule`???<br></p><p>With a sufficiently flexible import mechanism you could import `AnotherSubmodule` such that `Someclass` is referenced in the way that you see fit in a specific scope.  You could not require all uses to use the full name `AnotherSubmodule.Someclass`.  That is a stylistic choice.  However, namespaces usually allow for similar flexibility so I don’t see this as a distinction between namespaces and submodules.<br></p><p>&gt;&gt;&gt; Empty enums is an abuse of the language! <br>&gt;&gt; <br>&gt;&gt; But it is a practical and effective one.  Introducing a new construct like namespaces must carry significant advantages over what is already possible.<br>&gt; <br>&gt; Still abuse of the language no matter how you turn it. I don’t say `namespaces` should only do the same enums do (in my case it would be enough), if there is more they could solve sure why not. Thats a discussion is for isn’t it? I’m not an expert so I want to learn from people that might provide good examples and reasons why namespaces are good or not. <br></p><p>Yes, as I mentioned elsewhere, I agree that we need more.  But I want us to be clear on what problems we are solving and what capabilities we need.  Empty enums are a good point of reference for that discussion as they are what we have today.<br></p><p>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/3cbff3ee/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>[Discussion] Namespaces</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>May 20, 2016 at 12:00:00pm</p></header><div class="content"><p>This seems like a problem that would be better solved by adopting the Python philosophy that you must provide the full namespace for types, either upon import or explicitly in the code. It also makes searching things in the code easier as it’s clear exactly which namespace each type belongs to.<br></p><p>I don’t see any other motivation for why would you want to force a developer to use the submodule name. If there are no conflicts, why force them to use it?<br></p><p>&gt; On May 20, 2016, at 8:54 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Can submodules enforce the developer to use its name ’Submodule.SomeClass’? Do I have to re-build submodules when I made any changes to them before building the outside code base? Can they efficiently used for cross decencies between different modules/submodules?<br>&gt; <br>&gt; —— <br>&gt; Empty enums is an abuse of the language! <br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Am 20. Mai 2016 bei 17:49:29, Matthew Johnson via swift-evolution (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;) schrieb:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; &gt; On May 20, 2016, at 10:43 AM, Robert Schwalbe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt; <br>&gt;&gt; &gt;&gt; Anyway, I&#39;m +1 for namespaces everywhere, some names can be common. For example Node could be related to trees, physics engines and all sorts of constructs. &quot;Node&quot; may be a perfectly fine name for these. That said, these are sometimes tied to specific types in which case nesting them may make more sense, which I believe is already being addressed (currently we can&#39;t nest generic types)? It&#39;s certainly not as simple as it can appear!<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; Absolutely +1 for namespaces.<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; Even if you despise the concept of namespaces that seems like that can be addressed by a project and/or company style guide that explicitly forbids their use.<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; For the people/projects that would embrace namespaces, namespaces would be a godsend.<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; Sure, you can probably pull all kind of stunts to simulate namespaces, but besides creating additional work for the Swift team (and I do not say nor take that lightly), they really need to be supported and implemented at the language/syntax level for first class citizenry.<br>&gt;&gt; <br>&gt;&gt; What benefit do namespaces provide that submodules would not?<br>&gt;&gt; <br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/e9f4fc21/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Discussion] Namespaces</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May 20, 2016 at 09:00:00pm</p></header><div class="content"><p>I don’t see any other motivation for why would you want to force a developer to use the submodule name. If there are no conflicts, why force them to use it?<br>In my particular case I have something like this where i communicate to the developer that there are references involved:<br></p><p>Reference.Buffer<br></p><p>Reference.String<br></p><p>Reference.Character<br></p><p>And so on. String or Character would collide with Swift.String and Swift.Character here. Namespaces would solve this (or submodules).<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 20. Mai 2016 bei 21:18:46, Tyler Cloutier (cloutiertyler at aol.com) schrieb:<br></p><p>I don’t see any other motivation for why would you want to force a developer to use the submodule name. If there are no conflicts, why force them to use it?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/02a5ca83/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] Namespaces</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 20, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On May 20, 2016, at 2:30 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; I don’t see any other motivation for why would you want to force a developer to use the submodule name. If there are no conflicts, why force them to use it?<br>&gt; <br>&gt; In my particular case I have something like this where i communicate to the developer that there are references involved:<br>&gt; <br>&gt; Reference.Buffer<br>&gt; <br>&gt; Reference.String<br>&gt; <br>&gt; Reference.Character<br>&gt; <br>&gt; And so on. String or Character would collide with Swift.String and Swift.Character here. Namespaces would solve this (or submodules).<br>&gt; <br>&gt; <br></p><p>I don&#39;t support any mechanism that allows you to *require* the developer to use your (sub)module or namespace name as a prefix in all cases.  However, I *do* support allowing them to *choose* to use it for either stylistic reasons or to resolve ambiguity.<br></p><p>&gt; <br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Am 20. Mai 2016 bei 21:18:46, Tyler Cloutier (cloutiertyler at aol.com &lt;mailto:cloutiertyler at aol.com&gt;) schrieb:<br>&gt; <br>&gt;&gt; I don’t see any other motivation for why would you want to force a developer to use the submodule name. If there are no conflicts, why force them to use it?<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/2a9258b1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Discussion] Namespaces</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May 20, 2016 at 09:00:00pm</p></header><div class="content"><p>I don&#39;t support any mechanism that allows you to *require* the developer to use your (sub)module or namespace name as a prefix in all cases.  However, I *do* support allowing them to *choose* to use it for either stylistic reasons or to resolve ambiguity.<br>I’m absolutely fine with your second point, just because I’ll get my desired `Reference.Type` without abusing enums.<br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/b8be0659/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Discussion] Namespaces</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 20, 2016 at 08:00:00am</p></header><div class="content"><p>I think namespaces are definitely worth exploring.<br></p><p>Here&#39;s something that might be interesting to research. Right now, you can have two protocols that have associated types with the same name. If you adopt both protocols, you have to make the associated types the same, even if they really don&#39;t have anything to do with each other. I think this might be a good argument for how namespaces can make your code more expressive:<br></p><p>protocol A {<br>  associatedtype Thing<br>  func foo(x: Thing)<br>}<br></p><p>protocol B {<br>  associatedtype Thing<br>  func bar(x: Thing)<br>}<br></p><p>struct Foo : A, B {<br>  func foo(x: Int) { }<br>  // Error: type &#39;Foo&#39; does not conform to protocol &#39;B&#39;<br>  // protocol requires function &#39;bar&#39; with type &#39;Thing&#39;<br>  func bar(x: String) { }<br>}<br></p><p>In this example, I want to use &quot;Int&quot; for A&#39;s Thing type, and &quot;String&quot; for B&#39;s Thing type, but I can&#39;t.<br></p><p>Best,<br>Austin<br></p><p><br>&gt; On May 20, 2016, at 5:16 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I want to revive this topic.<br>&gt; <br>&gt; Is there any technical reason why we can’t have namespaces in Swift? I’ve found just a few threads about namespaces, but most of them had arguments to use modules instead.<br>&gt; <br>&gt; I’m fine with modules but they just don’t serve everything I would want to. I can’t enforce the developer to use the modules name if there is no naming conflict.<br>&gt; <br>&gt; I asked in the SwiftPM mail list for a easier Xcode integration of modules, but the response is exactly the opposite for using modules for namespaces (read below).<br>&gt; <br>&gt; If I’m building one huge project I don’t want to build a lot of different modules just shiny namespaces and clean code.<br>&gt; <br>&gt; So I ask the community again why can’t we have optional namespaces?<br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Am 19. Mai 2016 bei 22:33:19, Daniel Dunbar (daniel_dunbar at apple.com &lt;mailto:daniel_dunbar at apple.com&gt;) schrieb:<br>&gt; <br>&gt;&gt; Right now modules are most appropriately used at the same granularity that frameworks or shared libraries would be used in C/Obj-C/C++. This is the situation for which the variety of access control modifiers in Swift and things like Whole Module Optimization were designed for. While there are a lot of reasons to like modules as a way to provide namespaces, they really haven&#39;t been designed to provide these very fine grained namespaces.<br>&gt;&gt; <br>&gt;&gt; My guess is that the right answer here doesn&#39;t really involve the Xcode integration, but rather figuring out the right way that these concepts fit into the language in a first class way. I would expect concepts like submodules or namespaces to be language concepts that Xcode just exposes, not something that was coupled together.<br>&gt;&gt; <br>&gt;&gt;  - Daniel<br>&gt;&gt; <br>&gt;&gt;&gt; On May 18, 2016, at 12:37 PM, Adrian Zubarev via swift-build-dev &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’d like to discuss an idea that will make development in Xcode easier. I assume that SwiftPM will see its Xcode integration when the final version will be released.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Problem I’ll try to describe is mostly about namespaces. Right now some people abuses enums, struct or classes to create a namespace for a specific need.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Reference {<br>&gt;&gt;&gt;     class String { … }<br>&gt;&gt;&gt;     class Character {<br>&gt;&gt;&gt;         enum Error { … }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     private init() {}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This will create a pseudo namespace for the nested types:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Reference.String<br>&gt;&gt;&gt; * Reference.Character<br>&gt;&gt;&gt; * Reference.Character.Error<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One could argue of using modules instead of abusing a class here, which is a great argument.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The problem that comes to my mind here is that we will have to create subprojects inside our main project file and using the references to them just to achieve that shiny namespace.<br>&gt;&gt;&gt; One could also use SwiftPM, which is awesome, but there is a need to re-build the module if any changes have been done. As soon as we’ll create some complex dependencies between different modules this will get messy.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Before posting here I asked Joe Groff if there is any mailing list I can use to discuss my idea. He told me this might be a good place, because I was referring to the package manager. Then I’ve done my research to not create any redundant thread, but I only found one topic about the integration of SwiftPM in Xcode: https://lists.swift.org/pipermail/swift-build-dev/Week-of-Mon-20160215/000272.html &lt;https://lists.swift.org/pipermail/swift-build-dev/Week-of-Mon-20160215/000272.html&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So here are my thoughts about a deeper integration of SwiftPM here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - What if Xcode will introduce two new types of groups (the folder color could be orange like Swift for example, or even contain the bird icon).<br>&gt;&gt;&gt; - These groups are analogous to already existing group types except they’ll represent Swift modules / packages<br>&gt;&gt;&gt; - Basically we’ll have a single project file with multiple modules, where these modules should only exist inside that project (this is my own need right now)<br>&gt;&gt;&gt; - Such a package / module group will have a configurable utilities, where one could configure the modules<br>&gt;&gt;&gt; - This will reduce the re-building process, allow us to keep everything (not only .a or we’ll be able to hide .a files and just keep the sourcefiles inside such groups) inside a single project, gain the shiny namespaces like above, and make the file management way easier <br>&gt;&gt;&gt; - This also should allow us create cross-dependencies if there is a good need for that in our project<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; + MainProject<br>&gt;&gt;&gt; |<br>&gt;&gt;&gt; +—Reference (module)<br>&gt;&gt;&gt; |<br>&gt;&gt;&gt; +—+— Magic (module)<br>&gt;&gt;&gt;       |<br>&gt;&gt;&gt;       +— SomeSubMagic (module)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We could easily create cross dependencies between modules here by just using the modules names and the types they provide.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // SomeSubMagic is a sub module of Magic<br>&gt;&gt;&gt; class SomeSubMagic {<br>&gt;&gt;&gt;     var magic: Magic // referring to its parent module<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;        <br>&gt;&gt;&gt; What do you think about this?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-build-dev mailing list<br>&gt;&gt;&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev &lt;https://lists.swift.org/mailman/listinfo/swift-build-dev&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/d0946275/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Discussion] Namespaces</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May 20, 2016 at 05:00:00pm</p></header><div class="content"><p>+1 for this example! :)<br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 20. Mai 2016 bei 17:20:42, Austin Zheng (austinzheng at gmail.com) schrieb:<br></p><p>I think namespaces are definitely worth exploring.<br></p><p>Here&#39;s something that might be interesting to research. Right now, you can have two protocols that have associated types with the same name. If you adopt both protocols, you have to make the associated types the same, even if they really don&#39;t have anything to do with each other. I think this might be a good argument for how namespaces can make your code more expressive:<br></p><p>protocol A {<br>  associatedtype Thing<br>  func foo(x: Thing)<br>}<br></p><p>protocol B {<br>  associatedtype Thing<br>  func bar(x: Thing)<br>}<br></p><p>struct Foo : A, B {<br>  func foo(x: Int) { }<br>  // Error: type &#39;Foo&#39; does not conform to protocol &#39;B&#39;<br>  // protocol requires function &#39;bar&#39; with type &#39;Thing&#39;<br>  func bar(x: String) { }<br>}<br></p><p>In this example, I want to use &quot;Int&quot; for A&#39;s Thing type, and &quot;String&quot; for B&#39;s Thing type, but I can&#39;t.<br></p><p>Best,<br>Austin<br></p><p><br>On May 20, 2016, at 5:16 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>I want to revive this topic.<br></p><p>Is there any technical reason why we can’t have namespaces in Swift? I’ve found just a few threads about namespaces, but most of them had arguments to use modules instead.<br></p><p>I’m fine with modules but they just don’t serve everything I would want to. I can’t enforce the developer to use the modules name if there is no naming conflict.<br></p><p>I asked in the SwiftPM mail list for a easier Xcode integration of modules, but the response is exactly the opposite for using modules for namespaces (read below).<br></p><p>If I’m building one huge project I don’t want to build a lot of different modules just shiny namespaces and clean code.<br></p><p>So I ask the community again why can’t we have optional namespaces?<br>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 19. Mai 2016 bei 22:33:19, Daniel Dunbar (daniel_dunbar at apple.com) schrieb:<br></p><p>Right now modules are most appropriately used at the same granularity that frameworks or shared libraries would be used in C/Obj-C/C++. This is the situation for which the variety of access control modifiers in Swift and things like Whole Module Optimization were designed for. While there are a lot of reasons to like modules as a way to provide namespaces, they really haven&#39;t been designed to provide these very fine grained namespaces.<br></p><p>My guess is that the right answer here doesn&#39;t really involve the Xcode integration, but rather figuring out the right way that these concepts fit into the language in a first class way. I would expect concepts like submodules or namespaces to be language concepts that Xcode just exposes, not something that was coupled together.<br></p><p> - Daniel<br></p><p>On May 18, 2016, at 12:37 PM, Adrian Zubarev via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br></p><p>I’d like to discuss an idea that will make development in Xcode easier. I assume that SwiftPM will see its Xcode integration when the final version will be released.<br></p><p>Problem I’ll try to describe is mostly about namespaces. Right now some people abuses enums, struct or classes to create a namespace for a specific need.<br></p><p>class Reference {<br>    class String { … }<br>    class Character {<br>        enum Error { … }<br>    }<br></p><p>    private init() {}<br>}<br></p><p>This will create a pseudo namespace for the nested types:<br></p><p>* Reference.String<br>* Reference.Character<br>* Reference.Character.Error<br></p><p>One could argue of using modules instead of abusing a class here, which is a great argument.<br></p><p>The problem that comes to my mind here is that we will have to create subprojects inside our main project file and using the references to them just to achieve that shiny namespace.<br>One could also use SwiftPM, which is awesome, but there is a need to re-build the module if any changes have been done. As soon as we’ll create some complex dependencies between different modules this will get messy.<br></p><p>Before posting here I asked Joe Groff if there is any mailing list I can use to discuss my idea. He told me this might be a good place, because I was referring to the package manager. Then I’ve done my research to not create any redundant thread, but I only found one topic about the integration of SwiftPM in Xcode: https://lists.swift.org/pipermail/swift-build-dev/Week-of-Mon-20160215/000272.html<br></p><p>So here are my thoughts about a deeper integration of SwiftPM here:<br></p><p>- What if Xcode will introduce two new types of groups (the folder color could be orange like Swift for example, or even contain the bird icon).<br>- These groups are analogous to already existing group types except they’ll represent Swift modules / packages<br>- Basically we’ll have a single project file with multiple modules, where these modules should only exist inside that project (this is my own need right now)<br>- Such a package / module group will have a configurable utilities, where one could configure the modules<br>- This will reduce the re-building process, allow us to keep everything (not only .a or we’ll be able to hide .a files and just keep the sourcefiles inside such groups) inside a single project, gain the shiny namespaces like above, and make the file management way easier <br>- This also should allow us create cross-dependencies if there is a good need for that in our project<br></p><p>+ MainProject<br>|<br>+—Reference (module)<br>|<br>+—+— Magic (module)<br>      |<br>      +— SomeSubMagic (module)<br></p><p>We could easily create cross dependencies between modules here by just using the modules names and the types they provide.<br></p><p>// SomeSubMagic is a sub module of Magic<br>class SomeSubMagic {<br>    var magic: Magic // referring to its parent module<br>}<br>       <br>What do you think about this?<br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br>_______________________________________________<br>swift-build-dev mailing list<br>swift-build-dev at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-build-dev<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/7f8764c7/attachment-0001.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1c20add0141a66d37f9bcb554d40084b?s=50"></div><header><strong>[Discussion] Namespaces</strong> from <string>Luis Henrique B. Sousa</string> &lt;lshsousa at gmail.com&gt;<p>May 20, 2016 at 04:00:00pm</p></header><div class="content"><p>Good example, +1 for namespaces in swift.<br></p><p><br>On Fri, May 20, 2016 at 4:21 PM, Austin Zheng via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I think namespaces are definitely worth exploring.<br>&gt;<br>&gt; Here&#39;s something that might be interesting to research. Right now, you can<br>&gt; have two protocols that have associated types with the same name. If you<br>&gt; adopt both protocols, you have to make the associated types the same, even<br>&gt; if they really don&#39;t have anything to do with each other. I think this<br>&gt; might be a good argument for how namespaces can make your code more<br>&gt; expressive:<br>&gt;<br>&gt; protocol A {<br>&gt;   associatedtype Thing<br>&gt;   func foo(x: Thing)<br>&gt; }<br>&gt;<br>&gt; protocol B {<br>&gt;   associatedtype Thing<br>&gt;   func bar(x: Thing)<br>&gt; }<br>&gt;<br>&gt; struct Foo : A, B {<br>&gt;   func foo(x: Int) { }<br>&gt;   // Error: type &#39;Foo&#39; does not conform to protocol &#39;B&#39;<br>&gt;   // protocol requires function &#39;bar&#39; with type &#39;Thing&#39;<br>&gt;   func bar(x: String) { }<br>&gt; }<br>&gt;<br>&gt; In this example, I want to use &quot;Int&quot; for A&#39;s Thing type, and &quot;String&quot; for<br>&gt; B&#39;s Thing type, but I can&#39;t.<br>&gt;<br>&gt; Best,<br>&gt; Austin<br>&gt;<br>&gt;<br>&gt; On May 20, 2016, at 5:16 AM, Adrian Zubarev via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I want to revive this topic.<br>&gt;<br>&gt; Is there any technical reason why we can’t have namespaces in Swift? I’ve<br>&gt; found just a few threads about namespaces, but most of them had arguments<br>&gt; to use modules instead.<br>&gt;<br>&gt; I’m fine with modules but they just don’t serve everything I would want<br>&gt; to. I can’t enforce the developer to use the modules name if there is no<br>&gt; naming conflict.<br>&gt;<br>&gt; I asked in the SwiftPM mail list for a easier Xcode integration of<br>&gt; modules, but the response is exactly the opposite for using modules for<br>&gt; namespaces (read below).<br>&gt;<br>&gt; If I’m building one huge project I don’t want to build a lot of different<br>&gt; modules just shiny namespaces and clean code.<br>&gt;<br>&gt; So I ask the community again why can’t we have optional namespaces?<br>&gt; --<br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt;<br>&gt; Am 19. Mai 2016 bei 22:33:19, Daniel Dunbar (daniel_dunbar at apple.com)<br>&gt; schrieb:<br>&gt;<br>&gt; Right now modules are most appropriately used at the same granularity that<br>&gt; frameworks or shared libraries would be used in C/Obj-C/C++. This is the<br>&gt; situation for which the variety of access control modifiers in Swift and<br>&gt; things like Whole Module Optimization were designed for. While there are a<br>&gt; lot of reasons to like modules as a way to provide namespaces, they really<br>&gt; haven&#39;t been designed to provide these very fine grained namespaces.<br>&gt;<br>&gt; My guess is that the right answer here doesn&#39;t really involve the Xcode<br>&gt; integration, but rather figuring out the right way that these concepts fit<br>&gt; into the language in a first class way. I would expect concepts like<br>&gt; submodules or namespaces to be language concepts that Xcode just exposes,<br>&gt; not something that was coupled together.<br>&gt;<br>&gt;  - Daniel<br>&gt;<br>&gt; On May 18, 2016, at 12:37 PM, Adrian Zubarev via swift-build-dev &lt;<br>&gt; swift-build-dev at swift.org&gt; wrote:<br>&gt;<br>&gt; I’d like to discuss an idea that will make development in Xcode easier. I<br>&gt; assume that SwiftPM will see its Xcode integration when the final version<br>&gt; will be released.<br>&gt; Problem I’ll try to describe is mostly about namespaces. Right now some<br>&gt; people abuses enums, struct or classes to create a namespace for a specific<br>&gt; need.<br>&gt;<br>&gt; class Reference {<br>&gt;     class String { … }<br>&gt;     class Character {<br>&gt;         enum Error { … }<br>&gt;     }<br>&gt;<br>&gt;     private init() {}<br>&gt; }<br>&gt;<br>&gt; This will create a pseudo namespace for the nested types:<br>&gt;<br>&gt; * Reference.String<br>&gt; * Reference.Character<br>&gt; * Reference.Character.Error<br>&gt;<br>&gt; One could argue of using modules instead of abusing a class here, which is<br>&gt; a great argument.<br>&gt;<br>&gt; The problem that comes to my mind here is that we will have to create<br>&gt; subprojects inside our main project file and using the references to them<br>&gt; just to achieve that shiny namespace.<br>&gt; One could also use SwiftPM, which is awesome, but there is a need to<br>&gt; re-build the module if any changes have been done. As soon as we’ll create<br>&gt; some complex dependencies between different modules this will get messy.<br>&gt;<br>&gt; Before posting here I asked Joe Groff if there is any mailing list I can<br>&gt; use to discuss my idea. He told me this might be a good place, because I<br>&gt; was referring to the package manager. Then I’ve done my research to not<br>&gt; create any redundant thread, but I only found one topic about the<br>&gt; integration of SwiftPM in Xcode:<br>&gt; https://lists.swift.org/pipermail/swift-build-dev/Week-of-Mon-20160215/000272.html<br>&gt;<br>&gt; So here are my thoughts about a deeper integration of SwiftPM here:<br>&gt;<br>&gt; - What if Xcode will introduce two new types of groups (the folder color<br>&gt; could be orange like Swift for example, or even contain the bird icon).<br>&gt; - These groups are analogous to already existing group types except<br>&gt; they’ll represent Swift modules / packages<br>&gt; - Basically we’ll have a single project file with multiple modules, where<br>&gt; these modules should only exist inside that project (this is my own need<br>&gt; right now)<br>&gt; - Such a package / module group will have a configurable utilities, where<br>&gt; one could configure the modules<br>&gt; - This will reduce the re-building process, allow us to keep everything<br>&gt; (not only .a or we’ll be able to hide .a files and just keep the<br>&gt; sourcefiles inside such groups) inside a single project, *gain the shiny<br>&gt; namespaces like above*, and make the file management way easier<br>&gt; - This also should allow us create cross-dependencies if there is a good<br>&gt; need for that in our project<br>&gt;<br>&gt; + MainProject<br>&gt; |<br>&gt; +—Reference (module)<br>&gt; |<br>&gt; +—+— Magic (module)<br>&gt;       |<br>&gt;       +— SomeSubMagic (module)<br>&gt;<br>&gt; We could easily create cross dependencies between modules here by just<br>&gt; using the modules names and the types they provide.<br>&gt;<br>&gt; // SomeSubMagic is a sub module of Magic<br>&gt; class SomeSubMagic {<br>&gt;     var magic: Magic // referring to its parent module<br>&gt; }<br>&gt;<br>&gt; What do you think about this?<br>&gt;<br>&gt; --<br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; _______________________________________________<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/01a8c274/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] Namespaces</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 20, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On May 20, 2016, at 10:21 AM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think namespaces are definitely worth exploring.<br>&gt; <br>&gt; Here&#39;s something that might be interesting to research. Right now, you can have two protocols that have associated types with the same name. If you adopt both protocols, you have to make the associated types the same, even if they really don&#39;t have anything to do with each other. I think this might be a good argument for how namespaces can make your code more expressive:<br>&gt; <br>&gt; protocol A {<br>&gt;   associatedtype Thing<br>&gt;   func foo(x: Thing)<br>&gt; }<br>&gt; <br>&gt; protocol B {<br>&gt;   associatedtype Thing<br>&gt;   func bar(x: Thing)<br>&gt; }<br>&gt; <br>&gt; struct Foo : A, B {<br>&gt;   func foo(x: Int) { }<br>&gt;   // Error: type &#39;Foo&#39; does not conform to protocol &#39;B&#39;<br>&gt;   // protocol requires function &#39;bar&#39; with type &#39;Thing&#39;<br>&gt;   func bar(x: String) { }<br>&gt; }<br>&gt; <br>&gt; In this example, I want to use &quot;Int&quot; for A&#39;s Thing type, and &quot;String&quot; for B&#39;s Thing type, but I can’t.<br></p><p>This is totally orthogonal to namespaces.  C# provides a mechanism to clarify implementation of multiple interfaces with the same requirements and it has nothing to do with C# namespaces.  For example, it might be possible to just prefix member declarations with the name of the protocol.  These implementations would not be visible via the primary type interface.<br></p><p>struct Foo : A, B {<br>  typealias A.Thing = Int<br>  typealias B.Thing = Bar<br>  func foo(x: Int) { }<br>  func bar(x: String) { }<br>}<br></p><p>We could also allow you to omit the protocol-specific declaration for one of the conflicting protocols if you wanted that to be visible through the interface of your concrete type.<br></p><p>struct Foo : A, B {<br>  typealias A.Thing = Int<br>  func foo(x: Int) { }<br>  func bar(x: String) { }<br>}<br></p><p>The same mechanism could work for any members (properties, methods, etc).  In this case, `foo` is scoped specifically to the implementation of `A` even though it is not resolving any ambiguity.  It is not visible via the interface of the concrete type `Foo`.<br></p><p>struct Foo : A, B {<br>  typealias A.Thing = Int<br>  func A.foo(x: Int) { }<br>  func bar(x: String) { }<br>}<br></p><p>&gt; <br>&gt; Best,<br>&gt; Austin<br>&gt; <br>&gt; <br>&gt;&gt; On May 20, 2016, at 5:16 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I want to revive this topic.<br>&gt;&gt; <br>&gt;&gt; Is there any technical reason why we can’t have namespaces in Swift? I’ve found just a few threads about namespaces, but most of them had arguments to use modules instead.<br>&gt;&gt; <br>&gt;&gt; I’m fine with modules but they just don’t serve everything I would want to. I can’t enforce the developer to use the modules name if there is no naming conflict.<br>&gt;&gt; <br>&gt;&gt; I asked in the SwiftPM mail list for a easier Xcode integration of modules, but the response is exactly the opposite for using modules for namespaces (read below).<br>&gt;&gt; <br>&gt;&gt; If I’m building one huge project I don’t want to build a lot of different modules just shiny namespaces and clean code.<br>&gt;&gt; <br>&gt;&gt; So I ask the community again why can’t we have optional namespaces?<br>&gt;&gt; -- <br>&gt;&gt; Adrian Zubarev<br>&gt;&gt; Sent with Airmail<br>&gt;&gt; <br>&gt;&gt; Am 19. Mai 2016 bei 22:33:19, Daniel Dunbar (daniel_dunbar at apple.com &lt;mailto:daniel_dunbar at apple.com&gt;) schrieb:<br>&gt;&gt; <br>&gt;&gt;&gt; Right now modules are most appropriately used at the same granularity that frameworks or shared libraries would be used in C/Obj-C/C++. This is the situation for which the variety of access control modifiers in Swift and things like Whole Module Optimization were designed for. While there are a lot of reasons to like modules as a way to provide namespaces, they really haven&#39;t been designed to provide these very fine grained namespaces.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My guess is that the right answer here doesn&#39;t really involve the Xcode integration, but rather figuring out the right way that these concepts fit into the language in a first class way. I would expect concepts like submodules or namespaces to be language concepts that Xcode just exposes, not something that was coupled together.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  - Daniel<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 18, 2016, at 12:37 PM, Adrian Zubarev via swift-build-dev &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’d like to discuss an idea that will make development in Xcode easier. I assume that SwiftPM will see its Xcode integration when the final version will be released.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Problem I’ll try to describe is mostly about namespaces. Right now some people abuses enums, struct or classes to create a namespace for a specific need.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class Reference {<br>&gt;&gt;&gt;&gt;     class String { … }<br>&gt;&gt;&gt;&gt;     class Character {<br>&gt;&gt;&gt;&gt;         enum Error { … }<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     private init() {}<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This will create a pseudo namespace for the nested types:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * Reference.String<br>&gt;&gt;&gt;&gt; * Reference.Character<br>&gt;&gt;&gt;&gt; * Reference.Character.Error<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One could argue of using modules instead of abusing a class here, which is a great argument.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The problem that comes to my mind here is that we will have to create subprojects inside our main project file and using the references to them just to achieve that shiny namespace.<br>&gt;&gt;&gt;&gt; One could also use SwiftPM, which is awesome, but there is a need to re-build the module if any changes have been done. As soon as we’ll create some complex dependencies between different modules this will get messy.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Before posting here I asked Joe Groff if there is any mailing list I can use to discuss my idea. He told me this might be a good place, because I was referring to the package manager. Then I’ve done my research to not create any redundant thread, but I only found one topic about the integration of SwiftPM in Xcode: https://lists.swift.org/pipermail/swift-build-dev/Week-of-Mon-20160215/000272.html &lt;https://lists.swift.org/pipermail/swift-build-dev/Week-of-Mon-20160215/000272.html&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So here are my thoughts about a deeper integration of SwiftPM here:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - What if Xcode will introduce two new types of groups (the folder color could be orange like Swift for example, or even contain the bird icon).<br>&gt;&gt;&gt;&gt; - These groups are analogous to already existing group types except they’ll represent Swift modules / packages<br>&gt;&gt;&gt;&gt; - Basically we’ll have a single project file with multiple modules, where these modules should only exist inside that project (this is my own need right now)<br>&gt;&gt;&gt;&gt; - Such a package / module group will have a configurable utilities, where one could configure the modules<br>&gt;&gt;&gt;&gt; - This will reduce the re-building process, allow us to keep everything (not only .a or we’ll be able to hide .a files and just keep the sourcefiles inside such groups) inside a single project, gain the shiny namespaces like above, and make the file management way easier <br>&gt;&gt;&gt;&gt; - This also should allow us create cross-dependencies if there is a good need for that in our project<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; + MainProject<br>&gt;&gt;&gt;&gt; |<br>&gt;&gt;&gt;&gt; +—Reference (module)<br>&gt;&gt;&gt;&gt; |<br>&gt;&gt;&gt;&gt; +—+— Magic (module)<br>&gt;&gt;&gt;&gt;       |<br>&gt;&gt;&gt;&gt;       +— SomeSubMagic (module)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We could easily create cross dependencies between modules here by just using the modules names and the types they provide.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // SomeSubMagic is a sub module of Magic<br>&gt;&gt;&gt;&gt; class SomeSubMagic {<br>&gt;&gt;&gt;&gt;     var magic: Magic // referring to its parent module<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;        <br>&gt;&gt;&gt;&gt; What do you think about this?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-build-dev mailing list<br>&gt;&gt;&gt;&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev &lt;https://lists.swift.org/mailman/listinfo/swift-build-dev&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/0673c141/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Discussion] Namespaces</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 20, 2016 at 08:00:00am</p></header><div class="content"><p>Good to know. Maybe it&#39;s not namespacing proper, but it&#39;s a component in a larger system (which allows disambiguation of ambiguously named types by hierarchical qualification), and should be at least thought about.<br></p><p>Austin<br></p><p>&gt; On May 20, 2016, at 8:45 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; This is totally orthogonal to namespaces.  C# provides a mechanism to clarify implementation of multiple interfaces with the same requirements and it has nothing to do with C# namespaces.  For example, it might be possible to just prefix member declarations with the name of the protocol.  These implementations would not be visible via the primary type interface.<br>&gt; <br>&gt; struct Foo : A, B {<br>&gt;   typealias A.Thing = Int<br>&gt;   typealias B.Thing = Bar<br>&gt;   func foo(x: Int) { }<br>&gt;   func bar(x: String) { }<br>&gt; }<br>&gt; <br>&gt; We could also allow you to omit the protocol-specific declaration for one of the conflicting protocols if you wanted that to be visible through the interface of your concrete type.<br>&gt; <br>&gt; struct Foo : A, B {<br>&gt;   typealias A.Thing = Int<br>&gt;   func foo(x: Int) { }<br>&gt;   func bar(x: String) { }<br>&gt; }<br>&gt; <br>&gt; The same mechanism could work for any members (properties, methods, etc).  In this case, `foo` is scoped specifically to the implementation of `A` even though it is not resolving any ambiguity.  It is not visible via the interface of the concrete type `Foo`.<br>&gt; <br>&gt; struct Foo : A, B {<br>&gt;   typealias A.Thing = Int<br>&gt;   func A.foo(x: Int) { }<br>&gt;   func bar(x: String) { }<br>&gt; }<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Best,<br>&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 20, 2016, at 5:16 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I want to revive this topic.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is there any technical reason why we can’t have namespaces in Swift? I’ve found just a few threads about namespaces, but most of them had arguments to use modules instead.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m fine with modules but they just don’t serve everything I would want to. I can’t enforce the developer to use the modules name if there is no naming conflict.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I asked in the SwiftPM mail list for a easier Xcode integration of modules, but the response is exactly the opposite for using modules for namespaces (read below).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If I’m building one huge project I don’t want to build a lot of different modules just shiny namespaces and clean code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So I ask the community again why can’t we have optional namespaces?<br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 19. Mai 2016 bei 22:33:19, Daniel Dunbar (daniel_dunbar at apple.com &lt;mailto:daniel_dunbar at apple.com&gt;) schrieb:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Right now modules are most appropriately used at the same granularity that frameworks or shared libraries would be used in C/Obj-C/C++. This is the situation for which the variety of access control modifiers in Swift and things like Whole Module Optimization were designed for. While there are a lot of reasons to like modules as a way to provide namespaces, they really haven&#39;t been designed to provide these very fine grained namespaces.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; My guess is that the right answer here doesn&#39;t really involve the Xcode integration, but rather figuring out the right way that these concepts fit into the language in a first class way. I would expect concepts like submodules or namespaces to be language concepts that Xcode just exposes, not something that was coupled together.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  - Daniel<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 18, 2016, at 12:37 PM, Adrian Zubarev via swift-build-dev &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’d like to discuss an idea that will make development in Xcode easier. I assume that SwiftPM will see its Xcode integration when the final version will be released.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Problem I’ll try to describe is mostly about namespaces. Right now some people abuses enums, struct or classes to create a namespace for a specific need.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; class Reference {<br>&gt;&gt;&gt;&gt;&gt;     class String { … }<br>&gt;&gt;&gt;&gt;&gt;     class Character {<br>&gt;&gt;&gt;&gt;&gt;         enum Error { … }<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     private init() {}<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This will create a pseudo namespace for the nested types:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; * Reference.String<br>&gt;&gt;&gt;&gt;&gt; * Reference.Character<br>&gt;&gt;&gt;&gt;&gt; * Reference.Character.Error<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; One could argue of using modules instead of abusing a class here, which is a great argument.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The problem that comes to my mind here is that we will have to create subprojects inside our main project file and using the references to them just to achieve that shiny namespace.<br>&gt;&gt;&gt;&gt;&gt; One could also use SwiftPM, which is awesome, but there is a need to re-build the module if any changes have been done. As soon as we’ll create some complex dependencies between different modules this will get messy.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Before posting here I asked Joe Groff if there is any mailing list I can use to discuss my idea. He told me this might be a good place, because I was referring to the package manager. Then I’ve done my research to not create any redundant thread, but I only found one topic about the integration of SwiftPM in Xcode: https://lists.swift.org/pipermail/swift-build-dev/Week-of-Mon-20160215/000272.html &lt;https://lists.swift.org/pipermail/swift-build-dev/Week-of-Mon-20160215/000272.html&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; So here are my thoughts about a deeper integration of SwiftPM here:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - What if Xcode will introduce two new types of groups (the folder color could be orange like Swift for example, or even contain the bird icon).<br>&gt;&gt;&gt;&gt;&gt; - These groups are analogous to already existing group types except they’ll represent Swift modules / packages<br>&gt;&gt;&gt;&gt;&gt; - Basically we’ll have a single project file with multiple modules, where these modules should only exist inside that project (this is my own need right now)<br>&gt;&gt;&gt;&gt;&gt; - Such a package / module group will have a configurable utilities, where one could configure the modules<br>&gt;&gt;&gt;&gt;&gt; - This will reduce the re-building process, allow us to keep everything (not only .a or we’ll be able to hide .a files and just keep the sourcefiles inside such groups) inside a single project, gain the shiny namespaces like above, and make the file management way easier <br>&gt;&gt;&gt;&gt;&gt; - This also should allow us create cross-dependencies if there is a good need for that in our project<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; + MainProject<br>&gt;&gt;&gt;&gt;&gt; |<br>&gt;&gt;&gt;&gt;&gt; +—Reference (module)<br>&gt;&gt;&gt;&gt;&gt; |<br>&gt;&gt;&gt;&gt;&gt; +—+— Magic (module)<br>&gt;&gt;&gt;&gt;&gt;       |<br>&gt;&gt;&gt;&gt;&gt;       +— SomeSubMagic (module)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We could easily create cross dependencies between modules here by just using the modules names and the types they provide.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // SomeSubMagic is a sub module of Magic<br>&gt;&gt;&gt;&gt;&gt; class SomeSubMagic {<br>&gt;&gt;&gt;&gt;&gt;     var magic: Magic // referring to its parent module<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;        <br>&gt;&gt;&gt;&gt;&gt; What do you think about this?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-build-dev mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev &lt;https://lists.swift.org/mailman/listinfo/swift-build-dev&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/269ce305/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[Discussion] Namespaces</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>May 20, 2016 at 04:00:00pm</p></header><div class="content"><p>We&#39;ve been discussing some thing like this on another thread about<br>protocols and this looks like a great solution to the problem<br>expressed there with a very simple change in syntax (and no new<br>keyword involved). I&#39;d like to see this turned into a separate<br>proposal (since I&#39;m new on the group and lack the experience, I&#39;m not<br>the most suitable person to write).<br></p><p>I agree with others that we can nowadays subvert the purpose of an<br>existing construct of the language to simulate a namespace and I<br>believe most people here agree that&#39;s not the best way to work but<br>that&#39;s what we have now. I think that&#39;s why we&#39;re here discussing the<br>idea of namespaces (or submodules, could someone disambiguate them,<br>please?).<br></p><p><br>On 20 May 2016 at 12:45, Matthew Johnson via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On May 20, 2016, at 10:21 AM, Austin Zheng via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I think namespaces are definitely worth exploring.<br>&gt;<br>&gt; Here&#39;s something that might be interesting to research. Right now, you can<br>&gt; have two protocols that have associated types with the same name. If you<br>&gt; adopt both protocols, you have to make the associated types the same, even<br>&gt; if they really don&#39;t have anything to do with each other. I think this might<br>&gt; be a good argument for how namespaces can make your code more expressive:<br>&gt;<br>&gt; protocol A {<br>&gt;   associatedtype Thing<br>&gt;   func foo(x: Thing)<br>&gt; }<br>&gt;<br>&gt; protocol B {<br>&gt;   associatedtype Thing<br>&gt;   func bar(x: Thing)<br>&gt; }<br>&gt;<br>&gt; struct Foo : A, B {<br>&gt;   func foo(x: Int) { }<br>&gt;   // Error: type &#39;Foo&#39; does not conform to protocol &#39;B&#39;<br>&gt;   // protocol requires function &#39;bar&#39; with type &#39;Thing&#39;<br>&gt;   func bar(x: String) { }<br>&gt; }<br>&gt;<br>&gt; In this example, I want to use &quot;Int&quot; for A&#39;s Thing type, and &quot;String&quot; for<br>&gt; B&#39;s Thing type, but I can’t.<br>&gt;<br>&gt;<br>&gt; This is totally orthogonal to namespaces.  C# provides a mechanism to<br>&gt; clarify implementation of multiple interfaces with the same requirements and<br>&gt; it has nothing to do with C# namespaces.  For example, it might be possible<br>&gt; to just prefix member declarations with the name of the protocol.  These<br>&gt; implementations would not be visible via the primary type interface.<br>&gt;<br>&gt; struct Foo : A, B {<br>&gt;   typealias A.Thing = Int<br>&gt;   typealias B.Thing = Bar<br>&gt;   func foo(x: Int) { }<br>&gt;   func bar(x: String) { }<br>&gt; }<br>&gt;<br>&gt; We could also allow you to omit the protocol-specific declaration for one of<br>&gt; the conflicting protocols if you wanted that to be visible through the<br>&gt; interface of your concrete type.<br>&gt;<br>&gt; struct Foo : A, B {<br>&gt;   typealias A.Thing = Int<br>&gt;   func foo(x: Int) { }<br>&gt;   func bar(x: String) { }<br>&gt; }<br>&gt;<br>&gt; The same mechanism could work for any members (properties, methods, etc).<br>&gt; In this case, `foo` is scoped specifically to the implementation of `A` even<br>&gt; though it is not resolving any ambiguity.  It is not visible via the<br>&gt; interface of the concrete type `Foo`.<br>&gt;<br>&gt; struct Foo : A, B {<br>&gt;   typealias A.Thing = Int<br>&gt;   func A.foo(x: Int) { }<br>&gt;   func bar(x: String) { }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Best,<br>&gt; Austin<br>&gt;<br>&gt;<br>&gt; On May 20, 2016, at 5:16 AM, Adrian Zubarev via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I want to revive this topic.<br>&gt;<br>&gt; Is there any technical reason why we can’t have namespaces in Swift? I’ve<br>&gt; found just a few threads about namespaces, but most of them had arguments to<br>&gt; use modules instead.<br>&gt;<br>&gt; I’m fine with modules but they just don’t serve everything I would want to.<br>&gt; I can’t enforce the developer to use the modules name if there is no naming<br>&gt; conflict.<br>&gt;<br>&gt; I asked in the SwiftPM mail list for a easier Xcode integration of modules,<br>&gt; but the response is exactly the opposite for using modules for namespaces<br>&gt; (read below).<br>&gt;<br>&gt; If I’m building one huge project I don’t want to build a lot of different<br>&gt; modules just shiny namespaces and clean code.<br>&gt;<br>&gt; So I ask the community again why can’t we have optional namespaces?<br>&gt; --<br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt;<br>&gt; Am 19. Mai 2016 bei 22:33:19, Daniel Dunbar (daniel_dunbar at apple.com)<br>&gt; schrieb:<br>&gt;<br>&gt; Right now modules are most appropriately used at the same granularity that<br>&gt; frameworks or shared libraries would be used in C/Obj-C/C++. This is the<br>&gt; situation for which the variety of access control modifiers in Swift and<br>&gt; things like Whole Module Optimization were designed for. While there are a<br>&gt; lot of reasons to like modules as a way to provide namespaces, they really<br>&gt; haven&#39;t been designed to provide these very fine grained namespaces.<br>&gt;<br>&gt; My guess is that the right answer here doesn&#39;t really involve the Xcode<br>&gt; integration, but rather figuring out the right way that these concepts fit<br>&gt; into the language in a first class way. I would expect concepts like<br>&gt; submodules or namespaces to be language concepts that Xcode just exposes,<br>&gt; not something that was coupled together.<br>&gt;<br>&gt;  - Daniel<br>&gt;<br>&gt; On May 18, 2016, at 12:37 PM, Adrian Zubarev via swift-build-dev<br>&gt; &lt;swift-build-dev at swift.org&gt; wrote:<br>&gt;<br>&gt; I’d like to discuss an idea that will make development in Xcode easier. I<br>&gt; assume that SwiftPM will see its Xcode integration when the final version<br>&gt; will be released.<br>&gt;<br>&gt; Problem I’ll try to describe is mostly about namespaces. Right now some<br>&gt; people abuses enums, struct or classes to create a namespace for a specific<br>&gt; need.<br>&gt;<br>&gt; class Reference {<br>&gt;     class String { … }<br>&gt;     class Character {<br>&gt;         enum Error { … }<br>&gt;     }<br>&gt;<br>&gt;     private init() {}<br>&gt; }<br>&gt;<br>&gt; This will create a pseudo namespace for the nested types:<br>&gt;<br>&gt; * Reference.String<br>&gt; * Reference.Character<br>&gt; * Reference.Character.Error<br>&gt;<br>&gt; One could argue of using modules instead of abusing a class here, which is a<br>&gt; great argument.<br>&gt;<br>&gt; The problem that comes to my mind here is that we will have to create<br>&gt; subprojects inside our main project file and using the references to them<br>&gt; just to achieve that shiny namespace.<br>&gt; One could also use SwiftPM, which is awesome, but there is a need to<br>&gt; re-build the module if any changes have been done. As soon as we’ll create<br>&gt; some complex dependencies between different modules this will get messy.<br>&gt;<br>&gt; Before posting here I asked Joe Groff if there is any mailing list I can use<br>&gt; to discuss my idea. He told me this might be a good place, because I was<br>&gt; referring to the package manager. Then I’ve done my research to not create<br>&gt; any redundant thread, but I only found one topic about the integration of<br>&gt; SwiftPM in Xcode:<br>&gt; https://lists.swift.org/pipermail/swift-build-dev/Week-of-Mon-20160215/000272.html<br>&gt;<br>&gt; So here are my thoughts about a deeper integration of SwiftPM here:<br>&gt;<br>&gt; - What if Xcode will introduce two new types of groups (the folder color<br>&gt; could be orange like Swift for example, or even contain the bird icon).<br>&gt; - These groups are analogous to already existing group types except they’ll<br>&gt; represent Swift modules / packages<br>&gt; - Basically we’ll have a single project file with multiple modules, where<br>&gt; these modules should only exist inside that project (this is my own need<br>&gt; right now)<br>&gt; - Such a package / module group will have a configurable utilities, where<br>&gt; one could configure the modules<br>&gt; - This will reduce the re-building process, allow us to keep everything (not<br>&gt; only .a or we’ll be able to hide .a files and just keep the sourcefiles<br>&gt; inside such groups) inside a single project, gain the shiny namespaces like<br>&gt; above, and make the file management way easier<br>&gt; - This also should allow us create cross-dependencies if there is a good<br>&gt; need for that in our project<br>&gt;<br>&gt; + MainProject<br>&gt; |<br>&gt; +—Reference (module)<br>&gt; |<br>&gt; +—+— Magic (module)<br>&gt;       |<br>&gt;       +— SomeSubMagic (module)<br>&gt;<br>&gt; We could easily create cross dependencies between modules here by just using<br>&gt; the modules names and the types they provide.<br>&gt;<br>&gt; // SomeSubMagic is a sub module of Magic<br>&gt; class SomeSubMagic {<br>&gt;     var magic: Magic // referring to its parent module<br>&gt; }<br>&gt;<br>&gt; What do you think about this?<br>&gt;<br>&gt; --<br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; _______________________________________________<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] Namespaces</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 20, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On May 20, 2016, at 2:48 PM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br>&gt; <br>&gt; We&#39;ve been discussing some thing like this on another thread about<br>&gt; protocols and this looks like a great solution to the problem<br>&gt; expressed there with a very simple change in syntax (and no new<br>&gt; keyword involved). I&#39;d like to see this turned into a separate<br>&gt; proposal (since I&#39;m new on the group and lack the experience, I&#39;m not<br>&gt; the most suitable person to write).<br>&gt; <br>&gt; I agree with others that we can nowadays subvert the purpose of an<br>&gt; existing construct of the language to simulate a namespace and I<br>&gt; believe most people here agree that&#39;s not the best way to work but<br>&gt; that&#39;s what we have now. I think that&#39;s why we&#39;re here discussing the<br>&gt; idea of namespaces (or submodules, could someone disambiguate them,<br>&gt; please?).<br></p><p>The big difference is one of encapsulation.<br></p><p>Namespaces encapsulate names to avoid naming conflicts.  It is common for them to be open to extension across modules, similar to how types in Swift are open to extension across module boundaries.  Empty enums approximate this aspect of namespaces very well.  One thing they do not (currently) support is the ability to import names from a namespace into a lexical scope so they may used directly, without the namespace prefix.  Here’s a hypothetical  example where that limitation is removed:<br></p><p>enum Foo { // alternatively: namespace Foo<br>    static func bar() -&gt; String {}<br>    struct S {}<br>}<br></p><p>elsewhere:<br></p><p>import Foo<br></p><p>let s = S() // creates an instance of Foo.S which has been imported into the lexical context<br>let b = bar() // calls Foo.bar which has been imported into the lexical context<br></p><p>I think it would be interesting to consider allowing the top-level / static names of a type to be imported into a lexical context whether we have namespaces or not.<br></p><p>One minor difference between an empty enum and a namespace is that you can define instance methods for an empty enum even though you can’t actually instantiate an empty enum (one could argue that this should not be allowed).<br></p><p>The duplicate definition issue Tony mentioned is probably the most significant difference between an empty enum and a namespace.  Related to this is the need to use `extension Foo` syntax everywhere except the initial introduction of `enum Foo`.  The ability to use `namespace Foo` everywhere and not worry about duplicate definition is the most important reason why empty enums do not suffice as a substitute for namespaces.<br></p><p>Submodules are different in that they are first class modules in every respect, they just happen to be compiled as a part of their containing module.  They provide more encapsulation, but because of that they *are not* open to extension in the way that namespaces can be (depending on the design of the namespace feature).<br></p><p>The big question in my mind is whether we really need a namespace mechanism that is open to extension across module boundaries.  There is a good reason types are open to extension across module boundaries: it allows you to retroactively conform them to protocols, introduce additional methods, etc.  These reasons do not apply to namespaces.  <br></p><p>If there isn’t a compelling argument that we need such a mechanism submodules will prove to be a better solution.  I believe this will be the right answer for Swift, but am certainly willing to listen to counter-arguments.<br></p><p>If there is a compelling argument for open namespaces then the question becomes whether the benefit is sufficient to support them either *instead of* or *in addition to* submodules.  <br></p><p>-Matthew<br></p><p><br>&gt; <br>&gt; <br>&gt; On 20 May 2016 at 12:45, Matthew Johnson via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On May 20, 2016, at 10:21 AM, Austin Zheng via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I think namespaces are definitely worth exploring.<br>&gt;&gt; <br>&gt;&gt; Here&#39;s something that might be interesting to research. Right now, you can<br>&gt;&gt; have two protocols that have associated types with the same name. If you<br>&gt;&gt; adopt both protocols, you have to make the associated types the same, even<br>&gt;&gt; if they really don&#39;t have anything to do with each other. I think this might<br>&gt;&gt; be a good argument for how namespaces can make your code more expressive:<br>&gt;&gt; <br>&gt;&gt; protocol A {<br>&gt;&gt;  associatedtype Thing<br>&gt;&gt;  func foo(x: Thing)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; protocol B {<br>&gt;&gt;  associatedtype Thing<br>&gt;&gt;  func bar(x: Thing)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct Foo : A, B {<br>&gt;&gt;  func foo(x: Int) { }<br>&gt;&gt;  // Error: type &#39;Foo&#39; does not conform to protocol &#39;B&#39;<br>&gt;&gt;  // protocol requires function &#39;bar&#39; with type &#39;Thing&#39;<br>&gt;&gt;  func bar(x: String) { }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; In this example, I want to use &quot;Int&quot; for A&#39;s Thing type, and &quot;String&quot; for<br>&gt;&gt; B&#39;s Thing type, but I can’t.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; This is totally orthogonal to namespaces.  C# provides a mechanism to<br>&gt;&gt; clarify implementation of multiple interfaces with the same requirements and<br>&gt;&gt; it has nothing to do with C# namespaces.  For example, it might be possible<br>&gt;&gt; to just prefix member declarations with the name of the protocol.  These<br>&gt;&gt; implementations would not be visible via the primary type interface.<br>&gt;&gt; <br>&gt;&gt; struct Foo : A, B {<br>&gt;&gt;  typealias A.Thing = Int<br>&gt;&gt;  typealias B.Thing = Bar<br>&gt;&gt;  func foo(x: Int) { }<br>&gt;&gt;  func bar(x: String) { }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; We could also allow you to omit the protocol-specific declaration for one of<br>&gt;&gt; the conflicting protocols if you wanted that to be visible through the<br>&gt;&gt; interface of your concrete type.<br>&gt;&gt; <br>&gt;&gt; struct Foo : A, B {<br>&gt;&gt;  typealias A.Thing = Int<br>&gt;&gt;  func foo(x: Int) { }<br>&gt;&gt;  func bar(x: String) { }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The same mechanism could work for any members (properties, methods, etc).<br>&gt;&gt; In this case, `foo` is scoped specifically to the implementation of `A` even<br>&gt;&gt; though it is not resolving any ambiguity.  It is not visible via the<br>&gt;&gt; interface of the concrete type `Foo`.<br>&gt;&gt; <br>&gt;&gt; struct Foo : A, B {<br>&gt;&gt;  typealias A.Thing = Int<br>&gt;&gt;  func A.foo(x: Int) { }<br>&gt;&gt;  func bar(x: String) { }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Best,<br>&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On May 20, 2016, at 5:16 AM, Adrian Zubarev via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I want to revive this topic.<br>&gt;&gt; <br>&gt;&gt; Is there any technical reason why we can’t have namespaces in Swift? I’ve<br>&gt;&gt; found just a few threads about namespaces, but most of them had arguments to<br>&gt;&gt; use modules instead.<br>&gt;&gt; <br>&gt;&gt; I’m fine with modules but they just don’t serve everything I would want to.<br>&gt;&gt; I can’t enforce the developer to use the modules name if there is no naming<br>&gt;&gt; conflict.<br>&gt;&gt; <br>&gt;&gt; I asked in the SwiftPM mail list for a easier Xcode integration of modules,<br>&gt;&gt; but the response is exactly the opposite for using modules for namespaces<br>&gt;&gt; (read below).<br>&gt;&gt; <br>&gt;&gt; If I’m building one huge project I don’t want to build a lot of different<br>&gt;&gt; modules just shiny namespaces and clean code.<br>&gt;&gt; <br>&gt;&gt; So I ask the community again why can’t we have optional namespaces?<br>&gt;&gt; --<br>&gt;&gt; Adrian Zubarev<br>&gt;&gt; Sent with Airmail<br>&gt;&gt; <br>&gt;&gt; Am 19. Mai 2016 bei 22:33:19, Daniel Dunbar (daniel_dunbar at apple.com)<br>&gt;&gt; schrieb:<br>&gt;&gt; <br>&gt;&gt; Right now modules are most appropriately used at the same granularity that<br>&gt;&gt; frameworks or shared libraries would be used in C/Obj-C/C++. This is the<br>&gt;&gt; situation for which the variety of access control modifiers in Swift and<br>&gt;&gt; things like Whole Module Optimization were designed for. While there are a<br>&gt;&gt; lot of reasons to like modules as a way to provide namespaces, they really<br>&gt;&gt; haven&#39;t been designed to provide these very fine grained namespaces.<br>&gt;&gt; <br>&gt;&gt; My guess is that the right answer here doesn&#39;t really involve the Xcode<br>&gt;&gt; integration, but rather figuring out the right way that these concepts fit<br>&gt;&gt; into the language in a first class way. I would expect concepts like<br>&gt;&gt; submodules or namespaces to be language concepts that Xcode just exposes,<br>&gt;&gt; not something that was coupled together.<br>&gt;&gt; <br>&gt;&gt; - Daniel<br>&gt;&gt; <br>&gt;&gt; On May 18, 2016, at 12:37 PM, Adrian Zubarev via swift-build-dev<br>&gt;&gt; &lt;swift-build-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I’d like to discuss an idea that will make development in Xcode easier. I<br>&gt;&gt; assume that SwiftPM will see its Xcode integration when the final version<br>&gt;&gt; will be released.<br>&gt;&gt; <br>&gt;&gt; Problem I’ll try to describe is mostly about namespaces. Right now some<br>&gt;&gt; people abuses enums, struct or classes to create a namespace for a specific<br>&gt;&gt; need.<br>&gt;&gt; <br>&gt;&gt; class Reference {<br>&gt;&gt;    class String { … }<br>&gt;&gt;    class Character {<br>&gt;&gt;        enum Error { … }<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    private init() {}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This will create a pseudo namespace for the nested types:<br>&gt;&gt; <br>&gt;&gt; * Reference.String<br>&gt;&gt; * Reference.Character<br>&gt;&gt; * Reference.Character.Error<br>&gt;&gt; <br>&gt;&gt; One could argue of using modules instead of abusing a class here, which is a<br>&gt;&gt; great argument.<br>&gt;&gt; <br>&gt;&gt; The problem that comes to my mind here is that we will have to create<br>&gt;&gt; subprojects inside our main project file and using the references to them<br>&gt;&gt; just to achieve that shiny namespace.<br>&gt;&gt; One could also use SwiftPM, which is awesome, but there is a need to<br>&gt;&gt; re-build the module if any changes have been done. As soon as we’ll create<br>&gt;&gt; some complex dependencies between different modules this will get messy.<br>&gt;&gt; <br>&gt;&gt; Before posting here I asked Joe Groff if there is any mailing list I can use<br>&gt;&gt; to discuss my idea. He told me this might be a good place, because I was<br>&gt;&gt; referring to the package manager. Then I’ve done my research to not create<br>&gt;&gt; any redundant thread, but I only found one topic about the integration of<br>&gt;&gt; SwiftPM in Xcode:<br>&gt;&gt; https://lists.swift.org/pipermail/swift-build-dev/Week-of-Mon-20160215/000272.html<br>&gt;&gt; <br>&gt;&gt; So here are my thoughts about a deeper integration of SwiftPM here:<br>&gt;&gt; <br>&gt;&gt; - What if Xcode will introduce two new types of groups (the folder color<br>&gt;&gt; could be orange like Swift for example, or even contain the bird icon).<br>&gt;&gt; - These groups are analogous to already existing group types except they’ll<br>&gt;&gt; represent Swift modules / packages<br>&gt;&gt; - Basically we’ll have a single project file with multiple modules, where<br>&gt;&gt; these modules should only exist inside that project (this is my own need<br>&gt;&gt; right now)<br>&gt;&gt; - Such a package / module group will have a configurable utilities, where<br>&gt;&gt; one could configure the modules<br>&gt;&gt; - This will reduce the re-building process, allow us to keep everything (not<br>&gt;&gt; only .a or we’ll be able to hide .a files and just keep the sourcefiles<br>&gt;&gt; inside such groups) inside a single project, gain the shiny namespaces like<br>&gt;&gt; above, and make the file management way easier<br>&gt;&gt; - This also should allow us create cross-dependencies if there is a good<br>&gt;&gt; need for that in our project<br>&gt;&gt; <br>&gt;&gt; + MainProject<br>&gt;&gt; |<br>&gt;&gt; +—Reference (module)<br>&gt;&gt; |<br>&gt;&gt; +—+— Magic (module)<br>&gt;&gt;      |<br>&gt;&gt;      +— SomeSubMagic (module)<br>&gt;&gt; <br>&gt;&gt; We could easily create cross dependencies between modules here by just using<br>&gt;&gt; the modules names and the types they provide.<br>&gt;&gt; <br>&gt;&gt; // SomeSubMagic is a sub module of Magic<br>&gt;&gt; class SomeSubMagic {<br>&gt;&gt;    var magic: Magic // referring to its parent module<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; What do you think about this?<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; Adrian Zubarev<br>&gt;&gt; Sent with Airmail<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-build-dev mailing list<br>&gt;&gt; swift-build-dev at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/9062e4da/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Discussion] Namespaces</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 20, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On May 20, 2016, at 10:30 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On May 20, 2016, at 2:48 PM, Leonardo Pessoa &lt;me at lmpessoa.com &lt;mailto:me at lmpessoa.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; We&#39;ve been discussing some thing like this on another thread about<br>&gt;&gt; protocols and this looks like a great solution to the problem<br>&gt;&gt; expressed there with a very simple change in syntax (and no new<br>&gt;&gt; keyword involved). I&#39;d like to see this turned into a separate<br>&gt;&gt; proposal (since I&#39;m new on the group and lack the experience, I&#39;m not<br>&gt;&gt; the most suitable person to write).<br>&gt;&gt; <br>&gt;&gt; I agree with others that we can nowadays subvert the purpose of an<br>&gt;&gt; existing construct of the language to simulate a namespace and I<br>&gt;&gt; believe most people here agree that&#39;s not the best way to work but<br>&gt;&gt; that&#39;s what we have now. I think that&#39;s why we&#39;re here discussing the<br>&gt;&gt; idea of namespaces (or submodules, could someone disambiguate them,<br>&gt;&gt; please?).<br>&gt; <br>&gt; The big difference is one of encapsulation.<br>&gt; <br>&gt; Namespaces encapsulate names to avoid naming conflicts.  It is common for them to be open to extension across modules, similar to how types in Swift are open to extension across module boundaries.  Empty enums approximate this aspect of namespaces very well.  One thing they do not (currently) support is the ability to import names from a namespace into a lexical scope so they may used directly, without the namespace prefix.  Here’s a hypothetical  example where that limitation is removed:<br>&gt; <br>&gt; enum Foo { // alternatively: namespace Foo<br>&gt;     static func bar() -&gt; String {}<br>&gt;     struct S {}<br>&gt; }<br>&gt; <br>&gt; elsewhere:<br>&gt; <br>&gt; import Foo<br>&gt; <br>&gt; let s = S() // creates an instance of Foo.S which has been imported into the lexical context<br>&gt; let b = bar() // calls Foo.bar which has been imported into the lexical context<br>&gt; <br>&gt; I think it would be interesting to consider allowing the top-level / static names of a type to be imported into a lexical context whether we have namespaces or not.<br>&gt; <br>&gt; One minor difference between an empty enum and a namespace is that you can define instance methods for an empty enum even though you can’t actually instantiate an empty enum (one could argue that this should not be allowed).<br>&gt; <br>&gt; The duplicate definition issue Tony mentioned is probably the most significant difference between an empty enum and a namespace.  Related to this is the need to use `extension Foo` syntax everywhere except the initial introduction of `enum Foo`.  The ability to use `namespace Foo` everywhere and not worry about duplicate definition is the most important reason why empty enums do not suffice as a substitute for namespaces.<br>&gt; <br>&gt; Submodules are different in that they are first class modules in every respect, they just happen to be compiled as a part of their containing module.  They provide more encapsulation, but because of that they *are not* open to extension in the way that namespaces can be (depending on the design of the namespace feature).<br>&gt; <br>&gt; The big question in my mind is whether we really need a namespace mechanism that is open to extension across module boundaries.  There is a good reason types are open to extension across module boundaries: it allows you to retroactively conform them to protocols, introduce additional methods, etc.  These reasons do not apply to namespaces.  <br>&gt; <br>&gt; If there isn’t a compelling argument that we need such a mechanism submodules will prove to be a better solution.  I believe this will be the right answer for Swift, but am certainly willing to listen to counter-arguments.<br>&gt; <br></p><p><br>import Quartz.PDFKit<br>import Quartz.ImageKit<br></p><p>Quarts is one of these russian doll modules/submodule structure.<br></p><p>versioning part:<br></p><p>modX.framework<br>   modX.dylib<br>   Frameworks/<br>     modXsub1.framework<br>        modXsub1.dylib<br>     modXsub2.framework<br>        modXsub2.dylib<br></p><p><br></p><p>&gt; If there is a compelling argument for open namespaces then the question becomes whether the benefit is sufficient to support them either *instead of* or *in addition to* submodules.  <br>&gt; <br>&gt; -Matthew<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On 20 May 2016 at 12:45, Matthew Johnson via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 20, 2016, at 10:21 AM, Austin Zheng via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think namespaces are definitely worth exploring.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here&#39;s something that might be interesting to research. Right now, you can<br>&gt;&gt;&gt; have two protocols that have associated types with the same name. If you<br>&gt;&gt;&gt; adopt both protocols, you have to make the associated types the same, even<br>&gt;&gt;&gt; if they really don&#39;t have anything to do with each other. I think this might<br>&gt;&gt;&gt; be a good argument for how namespaces can make your code more expressive:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol A {<br>&gt;&gt;&gt;  associatedtype Thing<br>&gt;&gt;&gt;  func foo(x: Thing)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol B {<br>&gt;&gt;&gt;  associatedtype Thing<br>&gt;&gt;&gt;  func bar(x: Thing)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Foo : A, B {<br>&gt;&gt;&gt;  func foo(x: Int) { }<br>&gt;&gt;&gt;  // Error: type &#39;Foo&#39; does not conform to protocol &#39;B&#39;<br>&gt;&gt;&gt;  // protocol requires function &#39;bar&#39; with type &#39;Thing&#39;<br>&gt;&gt;&gt;  func bar(x: String) { }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In this example, I want to use &quot;Int&quot; for A&#39;s Thing type, and &quot;String&quot; for<br>&gt;&gt;&gt; B&#39;s Thing type, but I can’t.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is totally orthogonal to namespaces.  C# provides a mechanism to<br>&gt;&gt;&gt; clarify implementation of multiple interfaces with the same requirements and<br>&gt;&gt;&gt; it has nothing to do with C# namespaces.  For example, it might be possible<br>&gt;&gt;&gt; to just prefix member declarations with the name of the protocol.  These<br>&gt;&gt;&gt; implementations would not be visible via the primary type interface.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Foo : A, B {<br>&gt;&gt;&gt;  typealias A.Thing = Int<br>&gt;&gt;&gt;  typealias B.Thing = Bar<br>&gt;&gt;&gt;  func foo(x: Int) { }<br>&gt;&gt;&gt;  func bar(x: String) { }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We could also allow you to omit the protocol-specific declaration for one of<br>&gt;&gt;&gt; the conflicting protocols if you wanted that to be visible through the<br>&gt;&gt;&gt; interface of your concrete type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Foo : A, B {<br>&gt;&gt;&gt;  typealias A.Thing = Int<br>&gt;&gt;&gt;  func foo(x: Int) { }<br>&gt;&gt;&gt;  func bar(x: String) { }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The same mechanism could work for any members (properties, methods, etc).<br>&gt;&gt;&gt; In this case, `foo` is scoped specifically to the implementation of `A` even<br>&gt;&gt;&gt; though it is not resolving any ambiguity.  It is not visible via the<br>&gt;&gt;&gt; interface of the concrete type `Foo`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Foo : A, B {<br>&gt;&gt;&gt;  typealias A.Thing = Int<br>&gt;&gt;&gt;  func A.foo(x: Int) { }<br>&gt;&gt;&gt;  func bar(x: String) { }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Best,<br>&gt;&gt;&gt; Austin<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 20, 2016, at 5:16 AM, Adrian Zubarev via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I want to revive this topic.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is there any technical reason why we can’t have namespaces in Swift? I’ve<br>&gt;&gt;&gt; found just a few threads about namespaces, but most of them had arguments to<br>&gt;&gt;&gt; use modules instead.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m fine with modules but they just don’t serve everything I would want to.<br>&gt;&gt;&gt; I can’t enforce the developer to use the modules name if there is no naming<br>&gt;&gt;&gt; conflict.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I asked in the SwiftPM mail list for a easier Xcode integration of modules,<br>&gt;&gt;&gt; but the response is exactly the opposite for using modules for namespaces<br>&gt;&gt;&gt; (read below).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If I’m building one huge project I don’t want to build a lot of different<br>&gt;&gt;&gt; modules just shiny namespaces and clean code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So I ask the community again why can’t we have optional namespaces?<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 19. Mai 2016 bei 22:33:19, Daniel Dunbar (daniel_dunbar at apple.com &lt;mailto:daniel_dunbar at apple.com&gt;)<br>&gt;&gt;&gt; schrieb:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Right now modules are most appropriately used at the same granularity that<br>&gt;&gt;&gt; frameworks or shared libraries would be used in C/Obj-C/C++. This is the<br>&gt;&gt;&gt; situation for which the variety of access control modifiers in Swift and<br>&gt;&gt;&gt; things like Whole Module Optimization were designed for. While there are a<br>&gt;&gt;&gt; lot of reasons to like modules as a way to provide namespaces, they really<br>&gt;&gt;&gt; haven&#39;t been designed to provide these very fine grained namespaces.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My guess is that the right answer here doesn&#39;t really involve the Xcode<br>&gt;&gt;&gt; integration, but rather figuring out the right way that these concepts fit<br>&gt;&gt;&gt; into the language in a first class way. I would expect concepts like<br>&gt;&gt;&gt; submodules or namespaces to be language concepts that Xcode just exposes,<br>&gt;&gt;&gt; not something that was coupled together.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Daniel<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 18, 2016, at 12:37 PM, Adrian Zubarev via swift-build-dev<br>&gt;&gt;&gt; &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’d like to discuss an idea that will make development in Xcode easier. I<br>&gt;&gt;&gt; assume that SwiftPM will see its Xcode integration when the final version<br>&gt;&gt;&gt; will be released.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Problem I’ll try to describe is mostly about namespaces. Right now some<br>&gt;&gt;&gt; people abuses enums, struct or classes to create a namespace for a specific<br>&gt;&gt;&gt; need.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Reference {<br>&gt;&gt;&gt;    class String { … }<br>&gt;&gt;&gt;    class Character {<br>&gt;&gt;&gt;        enum Error { … }<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    private init() {}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This will create a pseudo namespace for the nested types:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Reference.String<br>&gt;&gt;&gt; * Reference.Character<br>&gt;&gt;&gt; * Reference.Character.Error<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One could argue of using modules instead of abusing a class here, which is a<br>&gt;&gt;&gt; great argument.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The problem that comes to my mind here is that we will have to create<br>&gt;&gt;&gt; subprojects inside our main project file and using the references to them<br>&gt;&gt;&gt; just to achieve that shiny namespace.<br>&gt;&gt;&gt; One could also use SwiftPM, which is awesome, but there is a need to<br>&gt;&gt;&gt; re-build the module if any changes have been done. As soon as we’ll create<br>&gt;&gt;&gt; some complex dependencies between different modules this will get messy.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Before posting here I asked Joe Groff if there is any mailing list I can use<br>&gt;&gt;&gt; to discuss my idea. He told me this might be a good place, because I was<br>&gt;&gt;&gt; referring to the package manager. Then I’ve done my research to not create<br>&gt;&gt;&gt; any redundant thread, but I only found one topic about the integration of<br>&gt;&gt;&gt; SwiftPM in Xcode:<br>&gt;&gt;&gt; https://lists.swift.org/pipermail/swift-build-dev/Week-of-Mon-20160215/000272.html &lt;https://lists.swift.org/pipermail/swift-build-dev/Week-of-Mon-20160215/000272.html&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So here are my thoughts about a deeper integration of SwiftPM here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - What if Xcode will introduce two new types of groups (the folder color<br>&gt;&gt;&gt; could be orange like Swift for example, or even contain the bird icon).<br>&gt;&gt;&gt; - These groups are analogous to already existing group types except they’ll<br>&gt;&gt;&gt; represent Swift modules / packages<br>&gt;&gt;&gt; - Basically we’ll have a single project file with multiple modules, where<br>&gt;&gt;&gt; these modules should only exist inside that project (this is my own need<br>&gt;&gt;&gt; right now)<br>&gt;&gt;&gt; - Such a package / module group will have a configurable utilities, where<br>&gt;&gt;&gt; one could configure the modules<br>&gt;&gt;&gt; - This will reduce the re-building process, allow us to keep everything (not<br>&gt;&gt;&gt; only .a or we’ll be able to hide .a files and just keep the sourcefiles<br>&gt;&gt;&gt; inside such groups) inside a single project, gain the shiny namespaces like<br>&gt;&gt;&gt; above, and make the file management way easier<br>&gt;&gt;&gt; - This also should allow us create cross-dependencies if there is a good<br>&gt;&gt;&gt; need for that in our project<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; + MainProject<br>&gt;&gt;&gt; |<br>&gt;&gt;&gt; +—Reference (module)<br>&gt;&gt;&gt; |<br>&gt;&gt;&gt; +—+— Magic (module)<br>&gt;&gt;&gt;      |<br>&gt;&gt;&gt;      +— SomeSubMagic (module)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We could easily create cross dependencies between modules here by just using<br>&gt;&gt;&gt; the modules names and the types they provide.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // SomeSubMagic is a sub module of Magic<br>&gt;&gt;&gt; class SomeSubMagic {<br>&gt;&gt;&gt;    var magic: Magic // referring to its parent module<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What do you think about this?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-build-dev mailing list<br>&gt;&gt;&gt; swift-build-dev at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/7a7a755b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] Namespaces</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 20, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On May 20, 2016, at 3:49 PM, L Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On May 20, 2016, at 10:30 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 20, 2016, at 2:48 PM, Leonardo Pessoa &lt;me at lmpessoa.com &lt;mailto:me at lmpessoa.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We&#39;ve been discussing some thing like this on another thread about<br>&gt;&gt;&gt; protocols and this looks like a great solution to the problem<br>&gt;&gt;&gt; expressed there with a very simple change in syntax (and no new<br>&gt;&gt;&gt; keyword involved). I&#39;d like to see this turned into a separate<br>&gt;&gt;&gt; proposal (since I&#39;m new on the group and lack the experience, I&#39;m not<br>&gt;&gt;&gt; the most suitable person to write).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree with others that we can nowadays subvert the purpose of an<br>&gt;&gt;&gt; existing construct of the language to simulate a namespace and I<br>&gt;&gt;&gt; believe most people here agree that&#39;s not the best way to work but<br>&gt;&gt;&gt; that&#39;s what we have now. I think that&#39;s why we&#39;re here discussing the<br>&gt;&gt;&gt; idea of namespaces (or submodules, could someone disambiguate them,<br>&gt;&gt;&gt; please?).<br>&gt;&gt; <br>&gt;&gt; The big difference is one of encapsulation.<br>&gt;&gt; <br>&gt;&gt; Namespaces encapsulate names to avoid naming conflicts.  It is common for them to be open to extension across modules, similar to how types in Swift are open to extension across module boundaries.  Empty enums approximate this aspect of namespaces very well.  One thing they do not (currently) support is the ability to import names from a namespace into a lexical scope so they may used directly, without the namespace prefix.  Here’s a hypothetical  example where that limitation is removed:<br>&gt;&gt; <br>&gt;&gt; enum Foo { // alternatively: namespace Foo<br>&gt;&gt;     static func bar() -&gt; String {}<br>&gt;&gt;     struct S {}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; elsewhere:<br>&gt;&gt; <br>&gt;&gt; import Foo<br>&gt;&gt; <br>&gt;&gt; let s = S() // creates an instance of Foo.S which has been imported into the lexical context<br>&gt;&gt; let b = bar() // calls Foo.bar which has been imported into the lexical context<br>&gt;&gt; <br>&gt;&gt; I think it would be interesting to consider allowing the top-level / static names of a type to be imported into a lexical context whether we have namespaces or not.<br>&gt;&gt; <br>&gt;&gt; One minor difference between an empty enum and a namespace is that you can define instance methods for an empty enum even though you can’t actually instantiate an empty enum (one could argue that this should not be allowed).<br>&gt;&gt; <br>&gt;&gt; The duplicate definition issue Tony mentioned is probably the most significant difference between an empty enum and a namespace.  Related to this is the need to use `extension Foo` syntax everywhere except the initial introduction of `enum Foo`.  The ability to use `namespace Foo` everywhere and not worry about duplicate definition is the most important reason why empty enums do not suffice as a substitute for namespaces.<br>&gt;&gt; <br>&gt;&gt; Submodules are different in that they are first class modules in every respect, they just happen to be compiled as a part of their containing module.  They provide more encapsulation, but because of that they *are not* open to extension in the way that namespaces can be (depending on the design of the namespace feature).<br>&gt;&gt; <br>&gt;&gt; The big question in my mind is whether we really need a namespace mechanism that is open to extension across module boundaries.  There is a good reason types are open to extension across module boundaries: it allows you to retroactively conform them to protocols, introduce additional methods, etc.  These reasons do not apply to namespaces.  <br>&gt;&gt; <br>&gt;&gt; If there isn’t a compelling argument that we need such a mechanism submodules will prove to be a better solution.  I believe this will be the right answer for Swift, but am certainly willing to listen to counter-arguments.<br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; import Quartz.PDFKit<br>&gt; import Quartz.ImageKit<br>&gt; <br>&gt; Quarts is one of these russian doll modules/submodule structure.<br>&gt; <br>&gt; versioning part:<br>&gt; <br>&gt; modX.framework<br>&gt;    modX.dylib<br>&gt;    Frameworks/<br>&gt;      modXsub1.framework<br>&gt;         modXsub1.dylib<br>&gt;      modXsub2.framework<br>&gt;         modXsub2.dylib<br></p><p>Good example.  In this case you’re suggesting that we should be able to compile submodules independently from the containing module.  However, they are still delivered together.  This makes sense to me and I would support a submodule design that allows for it.<br></p><p>What I am questioning is whether we need namespaces that are open to extension by third parties.<br></p><p>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; If there is a compelling argument for open namespaces then the question becomes whether the benefit is sufficient to support them either *instead of* or *in addition to* submodules.  <br>&gt;&gt; <br>&gt;&gt; -Matthew<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 20 May 2016 at 12:45, Matthew Johnson via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 20, 2016, at 10:21 AM, Austin Zheng via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think namespaces are definitely worth exploring.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here&#39;s something that might be interesting to research. Right now, you can<br>&gt;&gt;&gt;&gt; have two protocols that have associated types with the same name. If you<br>&gt;&gt;&gt;&gt; adopt both protocols, you have to make the associated types the same, even<br>&gt;&gt;&gt;&gt; if they really don&#39;t have anything to do with each other. I think this might<br>&gt;&gt;&gt;&gt; be a good argument for how namespaces can make your code more expressive:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol A {<br>&gt;&gt;&gt;&gt;  associatedtype Thing<br>&gt;&gt;&gt;&gt;  func foo(x: Thing)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol B {<br>&gt;&gt;&gt;&gt;  associatedtype Thing<br>&gt;&gt;&gt;&gt;  func bar(x: Thing)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct Foo : A, B {<br>&gt;&gt;&gt;&gt;  func foo(x: Int) { }<br>&gt;&gt;&gt;&gt;  // Error: type &#39;Foo&#39; does not conform to protocol &#39;B&#39;<br>&gt;&gt;&gt;&gt;  // protocol requires function &#39;bar&#39; with type &#39;Thing&#39;<br>&gt;&gt;&gt;&gt;  func bar(x: String) { }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In this example, I want to use &quot;Int&quot; for A&#39;s Thing type, and &quot;String&quot; for<br>&gt;&gt;&gt;&gt; B&#39;s Thing type, but I can’t.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is totally orthogonal to namespaces.  C# provides a mechanism to<br>&gt;&gt;&gt;&gt; clarify implementation of multiple interfaces with the same requirements and<br>&gt;&gt;&gt;&gt; it has nothing to do with C# namespaces.  For example, it might be possible<br>&gt;&gt;&gt;&gt; to just prefix member declarations with the name of the protocol.  These<br>&gt;&gt;&gt;&gt; implementations would not be visible via the primary type interface.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct Foo : A, B {<br>&gt;&gt;&gt;&gt;  typealias A.Thing = Int<br>&gt;&gt;&gt;&gt;  typealias B.Thing = Bar<br>&gt;&gt;&gt;&gt;  func foo(x: Int) { }<br>&gt;&gt;&gt;&gt;  func bar(x: String) { }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We could also allow you to omit the protocol-specific declaration for one of<br>&gt;&gt;&gt;&gt; the conflicting protocols if you wanted that to be visible through the<br>&gt;&gt;&gt;&gt; interface of your concrete type.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct Foo : A, B {<br>&gt;&gt;&gt;&gt;  typealias A.Thing = Int<br>&gt;&gt;&gt;&gt;  func foo(x: Int) { }<br>&gt;&gt;&gt;&gt;  func bar(x: String) { }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The same mechanism could work for any members (properties, methods, etc).<br>&gt;&gt;&gt;&gt; In this case, `foo` is scoped specifically to the implementation of `A` even<br>&gt;&gt;&gt;&gt; though it is not resolving any ambiguity.  It is not visible via the<br>&gt;&gt;&gt;&gt; interface of the concrete type `Foo`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct Foo : A, B {<br>&gt;&gt;&gt;&gt;  typealias A.Thing = Int<br>&gt;&gt;&gt;&gt;  func A.foo(x: Int) { }<br>&gt;&gt;&gt;&gt;  func bar(x: String) { }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Best,<br>&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 20, 2016, at 5:16 AM, Adrian Zubarev via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I want to revive this topic.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Is there any technical reason why we can’t have namespaces in Swift? I’ve<br>&gt;&gt;&gt;&gt; found just a few threads about namespaces, but most of them had arguments to<br>&gt;&gt;&gt;&gt; use modules instead.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m fine with modules but they just don’t serve everything I would want to.<br>&gt;&gt;&gt;&gt; I can’t enforce the developer to use the modules name if there is no naming<br>&gt;&gt;&gt;&gt; conflict.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I asked in the SwiftPM mail list for a easier Xcode integration of modules,<br>&gt;&gt;&gt;&gt; but the response is exactly the opposite for using modules for namespaces<br>&gt;&gt;&gt;&gt; (read below).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If I’m building one huge project I don’t want to build a lot of different<br>&gt;&gt;&gt;&gt; modules just shiny namespaces and clean code.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So I ask the community again why can’t we have optional namespaces?<br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 19. Mai 2016 bei 22:33:19, Daniel Dunbar (daniel_dunbar at apple.com &lt;mailto:daniel_dunbar at apple.com&gt;)<br>&gt;&gt;&gt;&gt; schrieb:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Right now modules are most appropriately used at the same granularity that<br>&gt;&gt;&gt;&gt; frameworks or shared libraries would be used in C/Obj-C/C++. This is the<br>&gt;&gt;&gt;&gt; situation for which the variety of access control modifiers in Swift and<br>&gt;&gt;&gt;&gt; things like Whole Module Optimization were designed for. While there are a<br>&gt;&gt;&gt;&gt; lot of reasons to like modules as a way to provide namespaces, they really<br>&gt;&gt;&gt;&gt; haven&#39;t been designed to provide these very fine grained namespaces.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; My guess is that the right answer here doesn&#39;t really involve the Xcode<br>&gt;&gt;&gt;&gt; integration, but rather figuring out the right way that these concepts fit<br>&gt;&gt;&gt;&gt; into the language in a first class way. I would expect concepts like<br>&gt;&gt;&gt;&gt; submodules or namespaces to be language concepts that Xcode just exposes,<br>&gt;&gt;&gt;&gt; not something that was coupled together.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Daniel<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 18, 2016, at 12:37 PM, Adrian Zubarev via swift-build-dev<br>&gt;&gt;&gt;&gt; &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’d like to discuss an idea that will make development in Xcode easier. I<br>&gt;&gt;&gt;&gt; assume that SwiftPM will see its Xcode integration when the final version<br>&gt;&gt;&gt;&gt; will be released.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Problem I’ll try to describe is mostly about namespaces. Right now some<br>&gt;&gt;&gt;&gt; people abuses enums, struct or classes to create a namespace for a specific<br>&gt;&gt;&gt;&gt; need.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class Reference {<br>&gt;&gt;&gt;&gt;    class String { … }<br>&gt;&gt;&gt;&gt;    class Character {<br>&gt;&gt;&gt;&gt;        enum Error { … }<br>&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    private init() {}<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This will create a pseudo namespace for the nested types:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * Reference.String<br>&gt;&gt;&gt;&gt; * Reference.Character<br>&gt;&gt;&gt;&gt; * Reference.Character.Error<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One could argue of using modules instead of abusing a class here, which is a<br>&gt;&gt;&gt;&gt; great argument.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The problem that comes to my mind here is that we will have to create<br>&gt;&gt;&gt;&gt; subprojects inside our main project file and using the references to them<br>&gt;&gt;&gt;&gt; just to achieve that shiny namespace.<br>&gt;&gt;&gt;&gt; One could also use SwiftPM, which is awesome, but there is a need to<br>&gt;&gt;&gt;&gt; re-build the module if any changes have been done. As soon as we’ll create<br>&gt;&gt;&gt;&gt; some complex dependencies between different modules this will get messy.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Before posting here I asked Joe Groff if there is any mailing list I can use<br>&gt;&gt;&gt;&gt; to discuss my idea. He told me this might be a good place, because I was<br>&gt;&gt;&gt;&gt; referring to the package manager. Then I’ve done my research to not create<br>&gt;&gt;&gt;&gt; any redundant thread, but I only found one topic about the integration of<br>&gt;&gt;&gt;&gt; SwiftPM in Xcode:<br>&gt;&gt;&gt;&gt; https://lists.swift.org/pipermail/swift-build-dev/Week-of-Mon-20160215/000272.html &lt;https://lists.swift.org/pipermail/swift-build-dev/Week-of-Mon-20160215/000272.html&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So here are my thoughts about a deeper integration of SwiftPM here:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - What if Xcode will introduce two new types of groups (the folder color<br>&gt;&gt;&gt;&gt; could be orange like Swift for example, or even contain the bird icon).<br>&gt;&gt;&gt;&gt; - These groups are analogous to already existing group types except they’ll<br>&gt;&gt;&gt;&gt; represent Swift modules / packages<br>&gt;&gt;&gt;&gt; - Basically we’ll have a single project file with multiple modules, where<br>&gt;&gt;&gt;&gt; these modules should only exist inside that project (this is my own need<br>&gt;&gt;&gt;&gt; right now)<br>&gt;&gt;&gt;&gt; - Such a package / module group will have a configurable utilities, where<br>&gt;&gt;&gt;&gt; one could configure the modules<br>&gt;&gt;&gt;&gt; - This will reduce the re-building process, allow us to keep everything (not<br>&gt;&gt;&gt;&gt; only .a or we’ll be able to hide .a files and just keep the sourcefiles<br>&gt;&gt;&gt;&gt; inside such groups) inside a single project, gain the shiny namespaces like<br>&gt;&gt;&gt;&gt; above, and make the file management way easier<br>&gt;&gt;&gt;&gt; - This also should allow us create cross-dependencies if there is a good<br>&gt;&gt;&gt;&gt; need for that in our project<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; + MainProject<br>&gt;&gt;&gt;&gt; |<br>&gt;&gt;&gt;&gt; +—Reference (module)<br>&gt;&gt;&gt;&gt; |<br>&gt;&gt;&gt;&gt; +—+— Magic (module)<br>&gt;&gt;&gt;&gt;      |<br>&gt;&gt;&gt;&gt;      +— SomeSubMagic (module)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We could easily create cross dependencies between modules here by just using<br>&gt;&gt;&gt;&gt; the modules names and the types they provide.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // SomeSubMagic is a sub module of Magic<br>&gt;&gt;&gt;&gt; class SomeSubMagic {<br>&gt;&gt;&gt;&gt;    var magic: Magic // referring to its parent module<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What do you think about this?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-build-dev mailing list<br>&gt;&gt;&gt;&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/a1c3ad25/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Discussion] Namespaces</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 20, 2016 at 06:00:00pm</p></header><div class="content"><p>+1<br></p><p>Exactly in this example I&#39;d probably want to have this to make it all clear <br>regarding &#39;things&#39;:<br></p><p>struct Foo : A,B {<br>   typealias A.Thing = Int<br>   typealias B.Thing = String<br></p><p>   func foo(x: Int) { }<br>   func bar(x: String) { }<br>}<br></p><p><br>On 20.05.2016 18:21, Austin Zheng via swift-evolution wrote:<br>&gt; I think namespaces are definitely worth exploring.<br>&gt;<br>&gt; Here&#39;s something that might be interesting to research. Right now, you can<br>&gt; have two protocols that have associated types with the same name. If you<br>&gt; adopt both protocols, you have to make the associated types the same, even<br>&gt; if they really don&#39;t have anything to do with each other. I think this<br>&gt; might be a good argument for how namespaces can make your code more expressive:<br>&gt;<br>&gt; protocolA {<br>&gt;   associatedtypeThing<br>&gt;   funcfoo(x: Thing)<br>&gt; }<br>&gt;<br>&gt; protocolB {<br>&gt;   associatedtypeThing<br>&gt;   funcbar(x: Thing)<br>&gt; }<br>&gt;<br>&gt; structFoo : A, B{<br>&gt;   funcfoo(x: Int) { }<br>&gt;   // Error: type &#39;Foo&#39; does not conform to protocol &#39;B&#39;<br>&gt;   // protocol requires function &#39;bar&#39; with type &#39;Thing&#39;<br>&gt;   funcbar(x: String) { }<br>&gt; }<br>&gt;<br>&gt; In this example, I want to use &quot;Int&quot; for A&#39;s Thing type, and &quot;String&quot; for<br>&gt; B&#39;s Thing type, but I can&#39;t.<br>&gt;<br>&gt; Best,<br>&gt; Austin<br>&gt;<br>&gt;<br>&gt;&gt; On May 20, 2016, at 5:16 AM, Adrian Zubarev via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I want to revive this topic.<br>&gt;&gt;<br>&gt;&gt; Is there any technical reason why we can’t have namespaces in Swift? I’ve<br>&gt;&gt; found just a few threads about namespaces, but most of them had arguments<br>&gt;&gt; to use modules instead.<br>&gt;&gt;<br>&gt;&gt; I’m fine with modules but they just don’t serve everything I would want<br>&gt;&gt; to. I can’t enforce the developer to use the modules name if there is no<br>&gt;&gt; naming conflict.<br>&gt;&gt;<br>&gt;&gt; I asked in the SwiftPM mail list for a easier Xcode integration of<br>&gt;&gt; modules, but the response is exactly the opposite for using modules for<br>&gt;&gt; namespaces (read below).<br>&gt;&gt;<br>&gt;&gt; If I’m building one huge project I don’t want to build a lot of different<br>&gt;&gt; modules just shiny namespaces and clean code.<br>&gt;&gt;<br>&gt;&gt; So I ask the community again why can’t we have optional namespaces?<br>&gt;&gt; --<br>&gt;&gt; Adrian Zubarev<br>&gt;&gt; Sent with Airmail<br>&gt;&gt;<br>&gt;&gt; Am 19. Mai 2016 bei 22:33:19, Daniel Dunbar (daniel_dunbar at apple.com<br>&gt;&gt; &lt;mailto:daniel_dunbar at apple.com&gt;) schrieb:<br>&gt;&gt;<br>&gt;&gt;&gt; Right now modules are most appropriately used at the same granularity<br>&gt;&gt;&gt; that frameworks or shared libraries would be used in C/Obj-C/C++. This<br>&gt;&gt;&gt; is the situation for which the variety of access control modifiers in<br>&gt;&gt;&gt; Swift and things like Whole Module Optimization were designed for. While<br>&gt;&gt;&gt; there are a lot of reasons to like modules as a way to provide<br>&gt;&gt;&gt; namespaces, they really haven&#39;t been designed to provide these very fine<br>&gt;&gt;&gt; grained namespaces.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; My guess is that the right answer here doesn&#39;t really involve the Xcode<br>&gt;&gt;&gt; integration, but rather figuring out the right way that these concepts<br>&gt;&gt;&gt; fit into the language in a first class way. I would expect concepts like<br>&gt;&gt;&gt; submodules or namespaces to be language concepts that Xcode just<br>&gt;&gt;&gt; exposes, not something that was coupled together.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;  - Daniel<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On May 18, 2016, at 12:37 PM, Adrian Zubarev via swift-build-dev<br>&gt;&gt;&gt;&gt; &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;   I’d like to discuss an idea that will make development in Xcode<br>&gt;&gt;&gt;&gt;   easier. I assume that SwiftPM will see its Xcode integration when the<br>&gt;&gt;&gt;&gt;   final version will be released.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Problem I’ll try to describe is mostly about namespaces. Right now some<br>&gt;&gt;&gt;&gt; people abuses enums, struct or classes to create a namespace for a<br>&gt;&gt;&gt;&gt; specific need.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; class Reference {<br>&gt;&gt;&gt;&gt;     class String { … }<br>&gt;&gt;&gt;&gt;     class Character {<br>&gt;&gt;&gt;&gt;         enum Error { … }<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     private init() {}<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This will create a pseudo namespace for the nested types:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; * Reference.String<br>&gt;&gt;&gt;&gt; * Reference.Character<br>&gt;&gt;&gt;&gt; * Reference.Character.Error<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; One could argue of using modules instead of abusing a class here, which<br>&gt;&gt;&gt;&gt; is a great argument.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The problem that comes to my mind here is that we will have to create<br>&gt;&gt;&gt;&gt; subprojects inside our main project file and using the references to<br>&gt;&gt;&gt;&gt; them just to achieve that shiny namespace.<br>&gt;&gt;&gt;&gt; One could also use SwiftPM, which is awesome, but there is a need to<br>&gt;&gt;&gt;&gt; re-build the module if any changes have been done. As soon as we’ll<br>&gt;&gt;&gt;&gt; create some complex dependencies between different modules this will<br>&gt;&gt;&gt;&gt; get messy.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Before posting here I asked Joe Groff if there is any mailing list I<br>&gt;&gt;&gt;&gt; can use to discuss my idea. He told me this might be a good place,<br>&gt;&gt;&gt;&gt; because I was referring to the package manager. Then I’ve done my<br>&gt;&gt;&gt;&gt; research to not create any redundant thread, but I only found one topic<br>&gt;&gt;&gt;&gt; about the integration of SwiftPM in<br>&gt;&gt;&gt;&gt; Xcode: https://lists.swift.org/pipermail/swift-build-dev/Week-of-Mon-20160215/000272.html<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; So here are my thoughts about a deeper integration of SwiftPM here:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; - What if Xcode will introduce two new types of groups (the folder<br>&gt;&gt;&gt;&gt; color could be orange like Swift for example, or even contain the bird<br>&gt;&gt;&gt;&gt; icon).<br>&gt;&gt;&gt;&gt; - These groups are analogous to already existing group types except<br>&gt;&gt;&gt;&gt; they’ll represent Swift modules / packages<br>&gt;&gt;&gt;&gt; - Basically we’ll have a single project file with multiple modules,<br>&gt;&gt;&gt;&gt; where these modules should only exist inside that project (this is my<br>&gt;&gt;&gt;&gt; own need right now)<br>&gt;&gt;&gt;&gt; - Such a package / module group will have a configurable utilities,<br>&gt;&gt;&gt;&gt; where one could configure the modules<br>&gt;&gt;&gt;&gt; - This will reduce the re-building process, allow us to keep everything<br>&gt;&gt;&gt;&gt; (not only .a or we’ll be able to hide .a files and just keep the<br>&gt;&gt;&gt;&gt; sourcefiles inside such groups) inside a single project, *gain the<br>&gt;&gt;&gt;&gt; shiny namespaces like above*, and make the file management way easier<br>&gt;&gt;&gt;&gt; - This also should allow us create cross-dependencies if there is a<br>&gt;&gt;&gt;&gt; good need for that in our project<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; + MainProject<br>&gt;&gt;&gt;&gt; |<br>&gt;&gt;&gt;&gt; +—Reference (module)<br>&gt;&gt;&gt;&gt; |<br>&gt;&gt;&gt;&gt; +—+— Magic (module)<br>&gt;&gt;&gt;&gt;       |<br>&gt;&gt;&gt;&gt;       +— SomeSubMagic (module)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; We could easily create cross dependencies between modules here by just<br>&gt;&gt;&gt;&gt; using the modules names and the types they provide.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; // SomeSubMagic is a sub module of Magic<br>&gt;&gt;&gt;&gt; class SomeSubMagic {<br>&gt;&gt;&gt;&gt;     var magic: Magic // referring to its parent module<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; What do you think about this?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-build-dev mailing list<br>&gt;&gt;&gt;&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Discussion] Namespaces</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 20, 2016 at 07:00:00pm</p></header><div class="content"><p>But this works:<br></p><p>protocol A {<br>   associatedtype Thing<br>   func foo(x: Thing)<br>}<br></p><p>protocol B {<br>   associatedtype Thing<br>   func foo(x: Thing)<br>}<br></p><p>struct Foo: A,B {<br>   typealias Thing = String<br></p><p>   func foo(x: Int) { }<br>   func foo(x: String) { }<br>}<br></p><p>or this also works:<br></p><p>struct Foo: A,B {<br>   typealias Thing = Int<br></p><p>   func foo(x: Int) { }<br>   func foo(x: String) { }<br>}<br></p><p><br>On 20.05.2016 18:21, Austin Zheng via swift-evolution wrote:<br>&gt; I think namespaces are definitely worth exploring.<br>&gt;<br>&gt; Here&#39;s something that might be interesting to research. Right now, you can<br>&gt; have two protocols that have associated types with the same name. If you<br>&gt; adopt both protocols, you have to make the associated types the same, even<br>&gt; if they really don&#39;t have anything to do with each other. I think this<br>&gt; might be a good argument for how namespaces can make your code more expressive:<br>&gt;<br>&gt; protocolA {<br>&gt;   associatedtypeThing<br>&gt;   funcfoo(x: Thing)<br>&gt; }<br>&gt;<br>&gt; protocolB {<br>&gt;   associatedtypeThing<br>&gt;   funcbar(x: Thing)<br>&gt; }<br>&gt;<br>&gt; structFoo : A, B{<br>&gt;   funcfoo(x: Int) { }<br>&gt;   // Error: type &#39;Foo&#39; does not conform to protocol &#39;B&#39;<br>&gt;   // protocol requires function &#39;bar&#39; with type &#39;Thing&#39;<br>&gt;   funcbar(x: String) { }<br>&gt; }<br>&gt;<br>&gt; In this example, I want to use &quot;Int&quot; for A&#39;s Thing type, and &quot;String&quot; for<br>&gt; B&#39;s Thing type, but I can&#39;t.<br>&gt;<br>&gt; Best,<br>&gt; Austin<br>&gt;<br>&gt;<br>&gt;&gt; On May 20, 2016, at 5:16 AM, Adrian Zubarev via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I want to revive this topic.<br>&gt;&gt;<br>&gt;&gt; Is there any technical reason why we can’t have namespaces in Swift? I’ve<br>&gt;&gt; found just a few threads about namespaces, but most of them had arguments<br>&gt;&gt; to use modules instead.<br>&gt;&gt;<br>&gt;&gt; I’m fine with modules but they just don’t serve everything I would want<br>&gt;&gt; to. I can’t enforce the developer to use the modules name if there is no<br>&gt;&gt; naming conflict.<br>&gt;&gt;<br>&gt;&gt; I asked in the SwiftPM mail list for a easier Xcode integration of<br>&gt;&gt; modules, but the response is exactly the opposite for using modules for<br>&gt;&gt; namespaces (read below).<br>&gt;&gt;<br>&gt;&gt; If I’m building one huge project I don’t want to build a lot of different<br>&gt;&gt; modules just shiny namespaces and clean code.<br>&gt;&gt;<br>&gt;&gt; So I ask the community again why can’t we have optional namespaces?<br>&gt;&gt; --<br>&gt;&gt; Adrian Zubarev<br>&gt;&gt; Sent with Airmail<br>&gt;&gt;<br>&gt;&gt; Am 19. Mai 2016 bei 22:33:19, Daniel Dunbar (daniel_dunbar at apple.com<br>&gt;&gt; &lt;mailto:daniel_dunbar at apple.com&gt;) schrieb:<br>&gt;&gt;<br>&gt;&gt;&gt; Right now modules are most appropriately used at the same granularity<br>&gt;&gt;&gt; that frameworks or shared libraries would be used in C/Obj-C/C++. This<br>&gt;&gt;&gt; is the situation for which the variety of access control modifiers in<br>&gt;&gt;&gt; Swift and things like Whole Module Optimization were designed for. While<br>&gt;&gt;&gt; there are a lot of reasons to like modules as a way to provide<br>&gt;&gt;&gt; namespaces, they really haven&#39;t been designed to provide these very fine<br>&gt;&gt;&gt; grained namespaces.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; My guess is that the right answer here doesn&#39;t really involve the Xcode<br>&gt;&gt;&gt; integration, but rather figuring out the right way that these concepts<br>&gt;&gt;&gt; fit into the language in a first class way. I would expect concepts like<br>&gt;&gt;&gt; submodules or namespaces to be language concepts that Xcode just<br>&gt;&gt;&gt; exposes, not something that was coupled together.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;  - Daniel<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On May 18, 2016, at 12:37 PM, Adrian Zubarev via swift-build-dev<br>&gt;&gt;&gt;&gt; &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;   I’d like to discuss an idea that will make development in Xcode<br>&gt;&gt;&gt;&gt;   easier. I assume that SwiftPM will see its Xcode integration when the<br>&gt;&gt;&gt;&gt;   final version will be released.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Problem I’ll try to describe is mostly about namespaces. Right now some<br>&gt;&gt;&gt;&gt; people abuses enums, struct or classes to create a namespace for a<br>&gt;&gt;&gt;&gt; specific need.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; class Reference {<br>&gt;&gt;&gt;&gt;     class String { … }<br>&gt;&gt;&gt;&gt;     class Character {<br>&gt;&gt;&gt;&gt;         enum Error { … }<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     private init() {}<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This will create a pseudo namespace for the nested types:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; * Reference.String<br>&gt;&gt;&gt;&gt; * Reference.Character<br>&gt;&gt;&gt;&gt; * Reference.Character.Error<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; One could argue of using modules instead of abusing a class here, which<br>&gt;&gt;&gt;&gt; is a great argument.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The problem that comes to my mind here is that we will have to create<br>&gt;&gt;&gt;&gt; subprojects inside our main project file and using the references to<br>&gt;&gt;&gt;&gt; them just to achieve that shiny namespace.<br>&gt;&gt;&gt;&gt; One could also use SwiftPM, which is awesome, but there is a need to<br>&gt;&gt;&gt;&gt; re-build the module if any changes have been done. As soon as we’ll<br>&gt;&gt;&gt;&gt; create some complex dependencies between different modules this will<br>&gt;&gt;&gt;&gt; get messy.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Before posting here I asked Joe Groff if there is any mailing list I<br>&gt;&gt;&gt;&gt; can use to discuss my idea. He told me this might be a good place,<br>&gt;&gt;&gt;&gt; because I was referring to the package manager. Then I’ve done my<br>&gt;&gt;&gt;&gt; research to not create any redundant thread, but I only found one topic<br>&gt;&gt;&gt;&gt; about the integration of SwiftPM in<br>&gt;&gt;&gt;&gt; Xcode: https://lists.swift.org/pipermail/swift-build-dev/Week-of-Mon-20160215/000272.html<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; So here are my thoughts about a deeper integration of SwiftPM here:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; - What if Xcode will introduce two new types of groups (the folder<br>&gt;&gt;&gt;&gt; color could be orange like Swift for example, or even contain the bird<br>&gt;&gt;&gt;&gt; icon).<br>&gt;&gt;&gt;&gt; - These groups are analogous to already existing group types except<br>&gt;&gt;&gt;&gt; they’ll represent Swift modules / packages<br>&gt;&gt;&gt;&gt; - Basically we’ll have a single project file with multiple modules,<br>&gt;&gt;&gt;&gt; where these modules should only exist inside that project (this is my<br>&gt;&gt;&gt;&gt; own need right now)<br>&gt;&gt;&gt;&gt; - Such a package / module group will have a configurable utilities,<br>&gt;&gt;&gt;&gt; where one could configure the modules<br>&gt;&gt;&gt;&gt; - This will reduce the re-building process, allow us to keep everything<br>&gt;&gt;&gt;&gt; (not only .a or we’ll be able to hide .a files and just keep the<br>&gt;&gt;&gt;&gt; sourcefiles inside such groups) inside a single project, *gain the<br>&gt;&gt;&gt;&gt; shiny namespaces like above*, and make the file management way easier<br>&gt;&gt;&gt;&gt; - This also should allow us create cross-dependencies if there is a<br>&gt;&gt;&gt;&gt; good need for that in our project<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; + MainProject<br>&gt;&gt;&gt;&gt; |<br>&gt;&gt;&gt;&gt; +—Reference (module)<br>&gt;&gt;&gt;&gt; |<br>&gt;&gt;&gt;&gt; +—+— Magic (module)<br>&gt;&gt;&gt;&gt;       |<br>&gt;&gt;&gt;&gt;       +— SomeSubMagic (module)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; We could easily create cross dependencies between modules here by just<br>&gt;&gt;&gt;&gt; using the modules names and the types they provide.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; // SomeSubMagic is a sub module of Magic<br>&gt;&gt;&gt;&gt; class SomeSubMagic {<br>&gt;&gt;&gt;&gt;     var magic: Magic // referring to its parent module<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; What do you think about this?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-build-dev mailing list<br>&gt;&gt;&gt;&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Discussion] Namespaces</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 20, 2016 at 09:00:00am</p></header><div class="content"><p>Yes. In this case you are basically telling the compiler which of the two foo()s you want to use to satisfy the protocol requirement, and which is just another method that happens to also be named foo().<br></p><p>Austin<br></p><p>&gt; On May 20, 2016, at 9:09 AM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt; <br>&gt; But this works:<br>&gt; <br>&gt; protocol A {<br>&gt;  associatedtype Thing<br>&gt;  func foo(x: Thing)<br>&gt; }<br>&gt; <br>&gt; protocol B {<br>&gt;  associatedtype Thing<br>&gt;  func foo(x: Thing)<br>&gt; }<br>&gt; <br>&gt; struct Foo: A,B {<br>&gt;  typealias Thing = String<br>&gt; <br>&gt;  func foo(x: Int) { }<br>&gt;  func foo(x: String) { }<br>&gt; }<br>&gt; <br>&gt; or this also works:<br>&gt; <br>&gt; struct Foo: A,B {<br>&gt;  typealias Thing = Int<br>&gt; <br>&gt;  func foo(x: Int) { }<br>&gt;  func foo(x: String) { }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; On 20.05.2016 18:21, Austin Zheng via swift-evolution wrote:<br>&gt;&gt; I think namespaces are definitely worth exploring.<br>&gt;&gt; <br>&gt;&gt; Here&#39;s something that might be interesting to research. Right now, you can<br>&gt;&gt; have two protocols that have associated types with the same name. If you<br>&gt;&gt; adopt both protocols, you have to make the associated types the same, even<br>&gt;&gt; if they really don&#39;t have anything to do with each other. I think this<br>&gt;&gt; might be a good argument for how namespaces can make your code more expressive:<br>&gt;&gt; <br>&gt;&gt; protocolA {<br>&gt;&gt;  associatedtypeThing<br>&gt;&gt;  funcfoo(x: Thing)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; protocolB {<br>&gt;&gt;  associatedtypeThing<br>&gt;&gt;  funcbar(x: Thing)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; structFoo : A, B{<br>&gt;&gt;  funcfoo(x: Int) { }<br>&gt;&gt;  // Error: type &#39;Foo&#39; does not conform to protocol &#39;B&#39;<br>&gt;&gt;  // protocol requires function &#39;bar&#39; with type &#39;Thing&#39;<br>&gt;&gt;  funcbar(x: String) { }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; In this example, I want to use &quot;Int&quot; for A&#39;s Thing type, and &quot;String&quot; for<br>&gt;&gt; B&#39;s Thing type, but I can&#39;t.<br>&gt;&gt; <br>&gt;&gt; Best,<br>&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 20, 2016, at 5:16 AM, Adrian Zubarev via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I want to revive this topic.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is there any technical reason why we can’t have namespaces in Swift? I’ve<br>&gt;&gt;&gt; found just a few threads about namespaces, but most of them had arguments<br>&gt;&gt;&gt; to use modules instead.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m fine with modules but they just don’t serve everything I would want<br>&gt;&gt;&gt; to. I can’t enforce the developer to use the modules name if there is no<br>&gt;&gt;&gt; naming conflict.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I asked in the SwiftPM mail list for a easier Xcode integration of<br>&gt;&gt;&gt; modules, but the response is exactly the opposite for using modules for<br>&gt;&gt;&gt; namespaces (read below).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If I’m building one huge project I don’t want to build a lot of different<br>&gt;&gt;&gt; modules just shiny namespaces and clean code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So I ask the community again why can’t we have optional namespaces?<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 19. Mai 2016 bei 22:33:19, Daniel Dunbar (daniel_dunbar at apple.com &lt;mailto:daniel_dunbar at apple.com&gt;<br>&gt;&gt;&gt; &lt;mailto:daniel_dunbar at apple.com &lt;mailto:daniel_dunbar at apple.com&gt;&gt;) schrieb:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Right now modules are most appropriately used at the same granularity<br>&gt;&gt;&gt;&gt; that frameworks or shared libraries would be used in C/Obj-C/C++. This<br>&gt;&gt;&gt;&gt; is the situation for which the variety of access control modifiers in<br>&gt;&gt;&gt;&gt; Swift and things like Whole Module Optimization were designed for. While<br>&gt;&gt;&gt;&gt; there are a lot of reasons to like modules as a way to provide<br>&gt;&gt;&gt;&gt; namespaces, they really haven&#39;t been designed to provide these very fine<br>&gt;&gt;&gt;&gt; grained namespaces.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; My guess is that the right answer here doesn&#39;t really involve the Xcode<br>&gt;&gt;&gt;&gt; integration, but rather figuring out the right way that these concepts<br>&gt;&gt;&gt;&gt; fit into the language in a first class way. I would expect concepts like<br>&gt;&gt;&gt;&gt; submodules or namespaces to be language concepts that Xcode just<br>&gt;&gt;&gt;&gt; exposes, not something that was coupled together.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Daniel<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 18, 2016, at 12:37 PM, Adrian Zubarev via swift-build-dev<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt; &lt;mailto:swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  I’d like to discuss an idea that will make development in Xcode<br>&gt;&gt;&gt;&gt;&gt;  easier. I assume that SwiftPM will see its Xcode integration when the<br>&gt;&gt;&gt;&gt;&gt;  final version will be released.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Problem I’ll try to describe is mostly about namespaces. Right now some<br>&gt;&gt;&gt;&gt;&gt; people abuses enums, struct or classes to create a namespace for a<br>&gt;&gt;&gt;&gt;&gt; specific need.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; class Reference {<br>&gt;&gt;&gt;&gt;&gt;    class String { … }<br>&gt;&gt;&gt;&gt;&gt;    class Character {<br>&gt;&gt;&gt;&gt;&gt;        enum Error { … }<br>&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;    private init() {}<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This will create a pseudo namespace for the nested types:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; * Reference.String<br>&gt;&gt;&gt;&gt;&gt; * Reference.Character<br>&gt;&gt;&gt;&gt;&gt; * Reference.Character.Error<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; One could argue of using modules instead of abusing a class here, which<br>&gt;&gt;&gt;&gt;&gt; is a great argument.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The problem that comes to my mind here is that we will have to create<br>&gt;&gt;&gt;&gt;&gt; subprojects inside our main project file and using the references to<br>&gt;&gt;&gt;&gt;&gt; them just to achieve that shiny namespace.<br>&gt;&gt;&gt;&gt;&gt; One could also use SwiftPM, which is awesome, but there is a need to<br>&gt;&gt;&gt;&gt;&gt; re-build the module if any changes have been done. As soon as we’ll<br>&gt;&gt;&gt;&gt;&gt; create some complex dependencies between different modules this will<br>&gt;&gt;&gt;&gt;&gt; get messy.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Before posting here I asked Joe Groff if there is any mailing list I<br>&gt;&gt;&gt;&gt;&gt; can use to discuss my idea. He told me this might be a good place,<br>&gt;&gt;&gt;&gt;&gt; because I was referring to the package manager. Then I’ve done my<br>&gt;&gt;&gt;&gt;&gt; research to not create any redundant thread, but I only found one topic<br>&gt;&gt;&gt;&gt;&gt; about the integration of SwiftPM in<br>&gt;&gt;&gt;&gt;&gt; Xcode: https://lists.swift.org/pipermail/swift-build-dev/Week-of-Mon-20160215/000272.html &lt;https://lists.swift.org/pipermail/swift-build-dev/Week-of-Mon-20160215/000272.html&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; So here are my thoughts about a deeper integration of SwiftPM here:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - What if Xcode will introduce two new types of groups (the folder<br>&gt;&gt;&gt;&gt;&gt; color could be orange like Swift for example, or even contain the bird<br>&gt;&gt;&gt;&gt;&gt; icon).<br>&gt;&gt;&gt;&gt;&gt; - These groups are analogous to already existing group types except<br>&gt;&gt;&gt;&gt;&gt; they’ll represent Swift modules / packages<br>&gt;&gt;&gt;&gt;&gt; - Basically we’ll have a single project file with multiple modules,<br>&gt;&gt;&gt;&gt;&gt; where these modules should only exist inside that project (this is my<br>&gt;&gt;&gt;&gt;&gt; own need right now)<br>&gt;&gt;&gt;&gt;&gt; - Such a package / module group will have a configurable utilities,<br>&gt;&gt;&gt;&gt;&gt; where one could configure the modules<br>&gt;&gt;&gt;&gt;&gt; - This will reduce the re-building process, allow us to keep everything<br>&gt;&gt;&gt;&gt;&gt; (not only .a or we’ll be able to hide .a files and just keep the<br>&gt;&gt;&gt;&gt;&gt; sourcefiles inside such groups) inside a single project, *gain the<br>&gt;&gt;&gt;&gt;&gt; shiny namespaces like above*, and make the file management way easier<br>&gt;&gt;&gt;&gt;&gt; - This also should allow us create cross-dependencies if there is a<br>&gt;&gt;&gt;&gt;&gt; good need for that in our project<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; + MainProject<br>&gt;&gt;&gt;&gt;&gt; |<br>&gt;&gt;&gt;&gt;&gt; +—Reference (module)<br>&gt;&gt;&gt;&gt;&gt; |<br>&gt;&gt;&gt;&gt;&gt; +—+— Magic (module)<br>&gt;&gt;&gt;&gt;&gt;      |<br>&gt;&gt;&gt;&gt;&gt;      +— SomeSubMagic (module)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We could easily create cross dependencies between modules here by just<br>&gt;&gt;&gt;&gt;&gt; using the modules names and the types they provide.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // SomeSubMagic is a sub module of Magic<br>&gt;&gt;&gt;&gt;&gt; class SomeSubMagic {<br>&gt;&gt;&gt;&gt;&gt;    var magic: Magic // referring to its parent module<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; What do you think about this?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-build-dev mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt; &lt;mailto:swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev &lt;https://lists.swift.org/mailman/listinfo/swift-build-dev&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/5d66aee2/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Discussion] Namespaces</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 20, 2016 at 07:00:00pm</p></header><div class="content"><p>Oh, yes, stupid me :-) Was playing with code and forget to change B.foo to <br>B.bar to check.<br></p><p>IMO We definitely need improvements in protocol implementation in types.<br></p><p>On 20.05.2016 19:14, Austin Zheng wrote:<br>&gt; Yes. In this case you are basically telling the compiler which of the two<br>&gt; foo()s you want to use to satisfy the protocol requirement, and which is<br>&gt; just another method that happens to also be named foo().<br>&gt;<br>&gt; Austin<br>&gt;<br>&gt;&gt; On May 20, 2016, at 9:09 AM, Vladimir.S &lt;svabox at gmail.com<br>&gt;&gt; &lt;mailto:svabox at gmail.com&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; But this works:<br>&gt;&gt;<br>&gt;&gt; protocol A {<br>&gt;&gt;  associatedtype Thing<br>&gt;&gt;  func foo(x: Thing)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; protocol B {<br>&gt;&gt;  associatedtype Thing<br>&gt;&gt;  func foo(x: Thing)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; struct Foo: A,B {<br>&gt;&gt;  typealias Thing = String<br>&gt;&gt;<br>&gt;&gt;  func foo(x: Int) { }<br>&gt;&gt;  func foo(x: String) { }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; or this also works:<br>&gt;&gt;<br>&gt;&gt; struct Foo: A,B {<br>&gt;&gt;  typealias Thing = Int<br>&gt;&gt;<br>&gt;&gt;  func foo(x: Int) { }<br>&gt;&gt;  func foo(x: String) { }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On 20.05.2016 18:21, Austin Zheng via swift-evolution wrote:<br>&gt;&gt;&gt; I think namespaces are definitely worth exploring.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Here&#39;s something that might be interesting to research. Right now, you can<br>&gt;&gt;&gt; have two protocols that have associated types with the same name. If you<br>&gt;&gt;&gt; adopt both protocols, you have to make the associated types the same, even<br>&gt;&gt;&gt; if they really don&#39;t have anything to do with each other. I think this<br>&gt;&gt;&gt; might be a good argument for how namespaces can make your code more<br>&gt;&gt;&gt; expressive:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocolA {<br>&gt;&gt;&gt;  associatedtypeThing<br>&gt;&gt;&gt;  funcfoo(x: Thing)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocolB {<br>&gt;&gt;&gt;  associatedtypeThing<br>&gt;&gt;&gt;  funcbar(x: Thing)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; structFoo : A, B{<br>&gt;&gt;&gt;  funcfoo(x: Int) { }<br>&gt;&gt;&gt;  // Error: type &#39;Foo&#39; does not conform to protocol &#39;B&#39;<br>&gt;&gt;&gt;  // protocol requires function &#39;bar&#39; with type &#39;Thing&#39;<br>&gt;&gt;&gt;  funcbar(x: String) { }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In this example, I want to use &quot;Int&quot; for A&#39;s Thing type, and &quot;String&quot; for<br>&gt;&gt;&gt; B&#39;s Thing type, but I can&#39;t.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Best,<br>&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On May 20, 2016, at 5:16 AM, Adrian Zubarev via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I want to revive this topic.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Is there any technical reason why we can’t have namespaces in Swift? I’ve<br>&gt;&gt;&gt;&gt; found just a few threads about namespaces, but most of them had arguments<br>&gt;&gt;&gt;&gt; to use modules instead.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I’m fine with modules but they just don’t serve everything I would want<br>&gt;&gt;&gt;&gt; to. I can’t enforce the developer to use the modules name if there is no<br>&gt;&gt;&gt;&gt; naming conflict.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I asked in the SwiftPM mail list for a easier Xcode integration of<br>&gt;&gt;&gt;&gt; modules, but the response is exactly the opposite for using modules for<br>&gt;&gt;&gt;&gt; namespaces (read below).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; If I’m building one huge project I don’t want to build a lot of different<br>&gt;&gt;&gt;&gt; modules just shiny namespaces and clean code.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; So I ask the community again why can’t we have optional namespaces?<br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Am 19. Mai 2016 bei 22:33:19, Daniel Dunbar (daniel_dunbar at apple.com<br>&gt;&gt;&gt;&gt; &lt;mailto:daniel_dunbar at apple.com&gt;<br>&gt;&gt;&gt;&gt; &lt;mailto:daniel_dunbar at apple.com&gt;) schrieb:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Right now modules are most appropriately used at the same granularity<br>&gt;&gt;&gt;&gt;&gt; that frameworks or shared libraries would be used in C/Obj-C/C++. This<br>&gt;&gt;&gt;&gt;&gt; is the situation for which the variety of access control modifiers in<br>&gt;&gt;&gt;&gt;&gt; Swift and things like Whole Module Optimization were designed for. While<br>&gt;&gt;&gt;&gt;&gt; there are a lot of reasons to like modules as a way to provide<br>&gt;&gt;&gt;&gt;&gt; namespaces, they really haven&#39;t been designed to provide these very fine<br>&gt;&gt;&gt;&gt;&gt; grained namespaces.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; My guess is that the right answer here doesn&#39;t really involve the Xcode<br>&gt;&gt;&gt;&gt;&gt; integration, but rather figuring out the right way that these concepts<br>&gt;&gt;&gt;&gt;&gt; fit into the language in a first class way. I would expect concepts like<br>&gt;&gt;&gt;&gt;&gt; submodules or namespaces to be language concepts that Xcode just<br>&gt;&gt;&gt;&gt;&gt; exposes, not something that was coupled together.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; - Daniel<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On May 18, 2016, at 12:37 PM, Adrian Zubarev via swift-build-dev<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-build-dev at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-build-dev at swift.org&gt; &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;  I’d like to discuss an idea that will make development in Xcode<br>&gt;&gt;&gt;&gt;&gt;&gt;  easier. I assume that SwiftPM will see its Xcode integration when the<br>&gt;&gt;&gt;&gt;&gt;&gt;  final version will be released.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Problem I’ll try to describe is mostly about namespaces. Right now some<br>&gt;&gt;&gt;&gt;&gt;&gt; people abuses enums, struct or classes to create a namespace for a<br>&gt;&gt;&gt;&gt;&gt;&gt; specific need.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; class Reference {<br>&gt;&gt;&gt;&gt;&gt;&gt;    class String { … }<br>&gt;&gt;&gt;&gt;&gt;&gt;    class Character {<br>&gt;&gt;&gt;&gt;&gt;&gt;        enum Error { … }<br>&gt;&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;    private init() {}<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; This will create a pseudo namespace for the nested types:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; * Reference.String<br>&gt;&gt;&gt;&gt;&gt;&gt; * Reference.Character<br>&gt;&gt;&gt;&gt;&gt;&gt; * Reference.Character.Error<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; One could argue of using modules instead of abusing a class here, which<br>&gt;&gt;&gt;&gt;&gt;&gt; is a great argument.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; The problem that comes to my mind here is that we will have to create<br>&gt;&gt;&gt;&gt;&gt;&gt; subprojects inside our main project file and using the references to<br>&gt;&gt;&gt;&gt;&gt;&gt; them just to achieve that shiny namespace.<br>&gt;&gt;&gt;&gt;&gt;&gt; One could also use SwiftPM, which is awesome, but there is a need to<br>&gt;&gt;&gt;&gt;&gt;&gt; re-build the module if any changes have been done. As soon as we’ll<br>&gt;&gt;&gt;&gt;&gt;&gt; create some complex dependencies between different modules this will<br>&gt;&gt;&gt;&gt;&gt;&gt; get messy.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Before posting here I asked Joe Groff if there is any mailing list I<br>&gt;&gt;&gt;&gt;&gt;&gt; can use to discuss my idea. He told me this might be a good place,<br>&gt;&gt;&gt;&gt;&gt;&gt; because I was referring to the package manager. Then I’ve done my<br>&gt;&gt;&gt;&gt;&gt;&gt; research to not create any redundant thread, but I only found one topic<br>&gt;&gt;&gt;&gt;&gt;&gt; about the integration of SwiftPM in<br>&gt;&gt;&gt;&gt;&gt;&gt; Xcode: https://lists.swift.org/pipermail/swift-build-dev/Week-of-Mon-20160215/000272.html<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; So here are my thoughts about a deeper integration of SwiftPM here:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; - What if Xcode will introduce two new types of groups (the folder<br>&gt;&gt;&gt;&gt;&gt;&gt; color could be orange like Swift for example, or even contain the bird<br>&gt;&gt;&gt;&gt;&gt;&gt; icon).<br>&gt;&gt;&gt;&gt;&gt;&gt; - These groups are analogous to already existing group types except<br>&gt;&gt;&gt;&gt;&gt;&gt; they’ll represent Swift modules / packages<br>&gt;&gt;&gt;&gt;&gt;&gt; - Basically we’ll have a single project file with multiple modules,<br>&gt;&gt;&gt;&gt;&gt;&gt; where these modules should only exist inside that project (this is my<br>&gt;&gt;&gt;&gt;&gt;&gt; own need right now)<br>&gt;&gt;&gt;&gt;&gt;&gt; - Such a package / module group will have a configurable utilities,<br>&gt;&gt;&gt;&gt;&gt;&gt; where one could configure the modules<br>&gt;&gt;&gt;&gt;&gt;&gt; - This will reduce the re-building process, allow us to keep everything<br>&gt;&gt;&gt;&gt;&gt;&gt; (not only .a or we’ll be able to hide .a files and just keep the<br>&gt;&gt;&gt;&gt;&gt;&gt; sourcefiles inside such groups) inside a single project, *gain the<br>&gt;&gt;&gt;&gt;&gt;&gt; shiny namespaces like above*, and make the file management way easier<br>&gt;&gt;&gt;&gt;&gt;&gt; - This also should allow us create cross-dependencies if there is a<br>&gt;&gt;&gt;&gt;&gt;&gt; good need for that in our project<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; + MainProject<br>&gt;&gt;&gt;&gt;&gt;&gt; |<br>&gt;&gt;&gt;&gt;&gt;&gt; +—Reference (module)<br>&gt;&gt;&gt;&gt;&gt;&gt; |<br>&gt;&gt;&gt;&gt;&gt;&gt; +—+— Magic (module)<br>&gt;&gt;&gt;&gt;&gt;&gt;      |<br>&gt;&gt;&gt;&gt;&gt;&gt;      +— SomeSubMagic (module)<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; We could easily create cross dependencies between modules here by just<br>&gt;&gt;&gt;&gt;&gt;&gt; using the modules names and the types they provide.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; // SomeSubMagic is a sub module of Magic<br>&gt;&gt;&gt;&gt;&gt;&gt; class SomeSubMagic {<br>&gt;&gt;&gt;&gt;&gt;&gt;    var magic: Magic // referring to its parent module<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; What do you think about this?<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt;&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-build-dev mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-build-dev at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-build-dev at swift.org&gt; &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
