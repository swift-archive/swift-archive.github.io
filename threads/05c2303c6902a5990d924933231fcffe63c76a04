<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Fwd: [Proposal Draft] Flexible memberwise initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  7, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; Begin forwarded message:<br>&gt; <br>&gt; From: Jordan Rose &lt;jordan_rose at apple.com&gt;<br>&gt; Subject: Re: [swift-evolution] [Proposal Draft] Flexible memberwise initialization<br>&gt; Date: January 6, 2016 at 9:29:19 PM CST<br>&gt; To: Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; Cc: Joe Groff &lt;jgroff at apple.com&gt;, swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 6, 2016, at 19:07 , Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt; On Jan 6, 2016, at 8:43 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 6, 2016, at 6:31 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 6, 2016, at 7:57 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 6, 2016, at 3:39 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 6, 2016, at 5:08 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I find it surprising that you key the initialization of &#39;var&#39;s based on whether their setter is visible or not. Initialization is not the same as setting, and memberwise initializers within the definition have private access to the member anyway; this is why `let` properties can be initialized, after all. `private(set)` is also a way for an API to communicate that a property is read-only without promising that it is or will always be immutable, so I think it&#39;s important that a &#39;private(set) var&#39; be as capable as a &#39;let&#39; to the maximum degree possible.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Hi Joe,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Thanks for bringing this topic up and moving the discussion to the list (it’s hard to get into details on Twitter).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I am definitely sympathetic to the points you raise.  The problem is that there is no good solution to this without involving at least one of the future enhancements.  Chris feels strongly that we need to focus on the core functionality for the initial proposal so we must choose a solution without them.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Using the `var` setter visibility is the least bad option in my mind.  There are many times when a var might represent internal state that a user is allowed to read, but should never be allowed to specify, whether via initialization or otherwise.  These will have `private(set)` visibility.  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If we allow memberwise initialization to expose them it will be a useless feature for types that contain a var like this.  There will not be any way to specify that they should not participate in memberwise initialization without at least one of the future enhancements.  On the other hand, if you do wish to expose them via the initializer it is easy to add a parameter and initialize the `var` manually.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This is also a safer solution.  The author of the type has specifically stated that users should not be setting the value of the `var`.  Maybe that doesn’t apply to initialization, but it is not the right decision to assume that IMO, at least without the ability to specify `init` visibility independently if desired.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In the case of `let`, if we do not use the only access control modifier they are allowed to have they would not be able to participate in memberwise initialization at all.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I think the proposal makes the least bad choice we can make without expanding it to include the ability to specify init visibility (which I would support if the core team was willing to do that).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;m not sure what you mean by init visibility.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The proposal suggests a possible future enhancement for specifying access control for init distinct from get and set like: &#39;private public(init)&#39;.  This would be available to both &#39;let&#39; and &#39;var&#39; properties and would allow a single memberwise initialization rule to be used for all properties.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I feel like all these arguments could also be made for &#39;let&#39;; what makes a get-only var different from the initializer&#39;s perspective?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is true in some sense.  The difference is that &#39;let&#39; properties only have access control for a getter making it the only option we have if they are allowed to participate in memberwise initialization.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That line of reasoning doesn&#39;t make sense. &#39;let&#39; properties only have access control for a getter because they never have a setter; the setter is effectively always private.<br>&gt;&gt; <br>&gt;&gt; Maybe I&#39;m not communicating very clearly, of course that is the case.  But &#39;let&#39; properties should still be able to participate in memberwise initialization.  If we are going to apply access control rules (which I think is important if we allow the automatic model for property eligibility) we have to use the only access control setting available to them in the language as it exists.  <br>&gt;&gt; <br>&gt;&gt; Allowing a distinct access control to be specified for initialization would solve this problem.  Adopting the opt-in model for property eligibility avoids the access control complications altogether.  I like that model quite a bit but Chris wanted to stick with the automatic model because it doesn&#39;t require a new declaration modifier on properties.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here&#39;s an example.  Think of a progress property.  That will be a far with a public getter but a private setter.  It would clearly be wrong if that were exposed by an initializer.  If we use the getter for a &#39;var&#39; in memberwise initialization it would be exposed to all memberwise initializers under the current proposal (without any of the enhancements).  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What type would have a progress property *and* useful memberwise initialization of its other state? In fact, what type has private state at all and useful memberwise initialization of its public state? I&#39;m having trouble seeing these as realistic use cases, since as soon as you have some form of state encapsulation you usually also want to curate the initialization of that state. At that point, hiding the memberwise code generation starts obscuring the logic rather than helping IMO, especially since there&#39;s probably validation that should be interleaved with it.<br>&gt;&gt; <br>&gt;&gt; I would have to think about the progress example longer than I have time at the moment to get specific.<br>&gt;&gt; <br>&gt;&gt; UI widgets very commonly have private state and also many appearance attributes that are user configurable and great candidates for memberwise initialization.  Many of them are likely to have &#39;public private(set) var&#39; properties as well which should not be exposed to callers during initialization.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The rules you&#39;ve proposed for what properties correspond to memberwise parameters are already tricky. It would be a nice simplification to say that all stored properties that need initialization end up in the memberwise initializer, regardless of visibility.<br>&gt;&gt; <br>&gt;&gt; That would severely cripple the feature IMO.  It would make it &quot;all or nothing&quot; and be useless in cases such as UI widgets where you need both private state and public state. <br>&gt;&gt; <br>&gt;&gt; It&#39;s common to just have callers set those attributes to desired values immediately after I initialization completes.  Many people write small helper libraries to make this less verbose, some of which have been discussed on this list.  This is a failure of the initialization capabilities of the language IMO.  This proposal is an attempt to make it easier to write types that can be fully configured during initialization.<br>&gt;&gt; <br>&gt;&gt; The opt-in model avoids the complexity while retaining flexibility at the cost of requiring a declaration modifier in properties.  I think this is a very reasonable tradeoff to make and would be happy to support that approach as an alternative to or in addition to the &quot;automatic&quot; approach used in the current proposal.<br>&gt; <br>&gt; I shared Joe&#39;s concern at first, but then I thought about the three kinds of public properties:<br>&gt; <br>&gt; - freely settable by the user (var)<br>&gt; - read-only outside of the module (internal(set) var)<br>&gt; - constant for the life of the object (let)<br>&gt; <br>&gt; Obviously there&#39;s no harm in putting the first into the memberwise initializer. The last could go either way—maybe it&#39;s a unique ID generated by the system, maybe it&#39;s configuration set by the user—but I would guess the latter is more common than the former.<br>&gt; <br>&gt; So what kind of things are read-only properties used for? A lot of computed properties are read-only: things derived from other aspects of the object&#39;s state, sometimes projections of internal state that you don&#39;t want to expose in its entirety (or its raw representation). But other times they represent output, such as the &#39;terminationStatus&#39; of an NSTask, or the &#39;URLs&#39; of an NSOpenPanel. There just aren&#39;t that many things where you can set the initial value of something, but can&#39;t change it later…but it can still change out from under you.<br>&gt; <br></p><p>Thanks Jordan.  This is what I mean when I say the rules specified in the proposal are likely to do the right thing most of the time.  I’m glad you brought up some specific examples.<br></p><p>When you think about the how different rules will behave in practice and how that compares to what you want, I think using the setter visibility for a `var` will be what you want more often.  <br></p><p>Aside from that, the feature is still useful when this doesn’t do what you want when using the `var` setter visibility and it is probably not useful when it doesn’t do what you want if we use the `var` getter.  If it exposes a property that needs to be private and you don’t have a way to prevent that you won’t be able to use the feature.<br></p><p>&gt; Therefore, even though it adds complexity to the proposal, I think Matthew&#39;s come up with the right tradeoff here.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; P.S. I have some concerns/feedback of my own, but I&#39;ll put that in a separate message.<br></p><p>Looking forward to hearing more from you.<br></p><p>Matthew<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/05c26a04/attachment.html&gt;<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
