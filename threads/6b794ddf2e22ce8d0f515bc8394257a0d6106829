<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be4c3c3b76631a155e1358db48066692?s=50"></div><header><strong>Mutability for Foundation types in Swift</strong> from <string>Tony Parker</string> &lt;anthony.parker at apple.com&gt;<p>April 22, 2016 at 10:00:00am</p></header><div class="content"><p>Dear swift-evolution denizens,<br></p><p>As you know from our announcement of Swift Open Source and our work on naming guidelines, one of our goals for Swift 3 is to “drop NS” for Foundation. We want to to make the cross-platform Foundation API that is available as part of swift-corelibs feel like it is not tied to just Darwin targets. We also want to reinforce the idea that new Foundation API must fit in with the language, standard library, and the rapidly evolving design patterns we see in the community.<br></p><p>You challenged us on one part of this plan: some Foundation API just doesn’t “feel Swifty”, and a large part of the reason why is that it often does not have the same value type behavior as other Swift types. We took this feedback seriously, and I would like to share with you the start of an important journey for some of the most commonly used APIs on all of our platforms: adopting value semantics for key Foundation types.<br></p><p>We have been working on this for some time now, and the set of diffs that result from this change is large. At this point, I am going to focus effort on an overview of the high level goals and not the individual API of each new type. In order to focus on delivering something up to our quality standards, we are intentionally leaving some class types as-is until a future proposal. If you don’t see your favorite class on the list — don’t despair. We are going to iterate on this over time. I see this as the start of the process.<br></p><p>One process note: we are still trying to figure out the best way to integrate changes to API that ship as part of the operating system (which includes Foundation) into the swift-evolution review process. Swift-evolution is normally focused on changes to functionality in the compiler or standard library. In general, I don’t expect all new Foundation API introduced in the Darwin/Objective-C framework to go through the open source process. However, as we’ve brought up this topic here before, I felt it was important to bring this particular change to the swift-evolution list.<br></p><p>As always I welcome your feedback.<br></p><p>https://github.com/apple/swift-evolution/blob/master/proposals/0069-swift-mutability-for-foundation.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0069-swift-mutability-for-foundation.md&gt;<br></p><p>Thanks,<br>- Tony<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160422/6b796829/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>Mutability for Foundation types in Swift</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>April 22, 2016 at 01:00:00pm</p></header><div class="content"><p>I don’t have anything significant to say other than that this is awesome.<br></p><p>l8r<br>Sean<br></p><p><br>&gt; On Apr 22, 2016, at 12:18 PM, Tony Parker via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Dear swift-evolution denizens,<br>&gt; <br>&gt; As you know from our announcement of Swift Open Source and our work on naming guidelines, one of our goals for Swift 3 is to “drop NS” for Foundation. We want to to make the cross-platform Foundation API that is available as part of swift-corelibs feel like it is not tied to just Darwin targets. We also want to reinforce the idea that new Foundation API must fit in with the language, standard library, and the rapidly evolving design patterns we see in the community.<br>&gt; <br>&gt; You challenged us on one part of this plan: some Foundation API just doesn’t “feel Swifty”, and a large part of the reason why is that it often does not have the same value type behavior as other Swift types. We took this feedback seriously, and I would like to share with you the start of an important journey for some of the most commonly used APIs on all of our platforms: adopting value semantics for key Foundation types.<br>&gt; <br>&gt; We have been working on this for some time now, and the set of diffs that result from this change is large. At this point, I am going to focus effort on an overview of the high level goals and not the individual API of each new type. In order to focus on delivering something up to our quality standards, we are intentionally leaving some class types as-is until a future proposal. If you don’t see your favorite class on the list — don’t despair. We are going to iterate on this over time. I see this as the start of the process.<br>&gt; <br>&gt; One process note: we are still trying to figure out the best way to integrate changes to API that ship as part of the operating system (which includes Foundation) into the swift-evolution review process. Swift-evolution is normally focused on changes to functionality in the compiler or standard library. In general, I don’t expect all new Foundation API introduced in the Darwin/Objective-C framework to go through the open source process. However, as we’ve brought up this topic here before, I felt it was important to bring this particular change to the swift-evolution list.<br>&gt; <br>&gt; As always I welcome your feedback.<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0069-swift-mutability-for-foundation.md<br>&gt; <br>&gt; Thanks,<br>&gt; - Tony<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Mutability for Foundation types in Swift</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>April 22, 2016 at 09:00:00pm</p></header><div class="content"><p>Just my thoughts :-) Great! Swift is moving forward and personally I like <br>the direction!<br></p><p>On 22.04.2016 21:04, Sean Heber via swift-evolution wrote:<br>&gt; I don’t have anything significant to say other than that this is awesome.<br>&gt;<br>&gt; l8r<br>&gt; Sean<br>&gt;<br>&gt;<br>&gt;&gt; On Apr 22, 2016, at 12:18 PM, Tony Parker via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Dear swift-evolution denizens,<br>&gt;&gt;<br>&gt;&gt; As you know from our announcement of Swift Open Source and our work on naming guidelines, one of our goals for Swift 3 is to “drop NS” for Foundation. We want to to make the cross-platform Foundation API that is available as part of swift-corelibs feel like it is not tied to just Darwin targets. We also want to reinforce the idea that new Foundation API must fit in with the language, standard library, and the rapidly evolving design patterns we see in the community.<br>&gt;&gt;<br>&gt;&gt; You challenged us on one part of this plan: some Foundation API just doesn’t “feel Swifty”, and a large part of the reason why is that it often does not have the same value type behavior as other Swift types. We took this feedback seriously, and I would like to share with you the start of an important journey for some of the most commonly used APIs on all of our platforms: adopting value semantics for key Foundation types.<br>&gt;&gt;<br>&gt;&gt; We have been working on this for some time now, and the set of diffs that result from this change is large. At this point, I am going to focus effort on an overview of the high level goals and not the individual API of each new type. In order to focus on delivering something up to our quality standards, we are intentionally leaving some class types as-is until a future proposal. If you don’t see your favorite class on the list — don’t despair. We are going to iterate on this over time. I see this as the start of the process.<br>&gt;&gt;<br>&gt;&gt; One process note: we are still trying to figure out the best way to integrate changes to API that ship as part of the operating system (which includes Foundation) into the swift-evolution review process. Swift-evolution is normally focused on changes to functionality in the compiler or standard library. In general, I don’t expect all new Foundation API introduced in the Darwin/Objective-C framework to go through the open source process. However, as we’ve brought up this topic here before, I felt it was important to bring this particular change to the swift-evolution list.<br>&gt;&gt;<br>&gt;&gt; As always I welcome your feedback.<br>&gt;&gt;<br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0069-swift-mutability-for-foundation.md<br>&gt;&gt;<br>&gt;&gt; Thanks,<br>&gt;&gt; - Tony<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5f463dd4e7af28b64ad8f0e032ee82dc?s=50"></div><header><strong>Mutability for Foundation types in Swift</strong> from <string>Nate Cook</string> &lt;natecook at gmail.com&gt;<p>April 22, 2016 at 01:00:00pm</p></header><div class="content"><p>This looks amazing—really looking forward to seeing the progression here!<br></p><p>I do have a question about how copy-on-write is handled for larger data types like Data (née NSData). The standard library types that can use bridged storage use immutable classes until there&#39;s a mutation, at which point the contents are copied into native storage. From then on (as long as the native storage is still uniquely referenced) the contents can be mutated in place without any copying.<br></p><p>With the proposed value semantics around an NSData instance, how do you handle that in-place mutation? When bridging from Objective-C to Swift, it sounds like you&#39;ll call copy() on an NSData instance. Does NSMutableData perform the role of the native storage when mutating? If so, is another copy needed when bridging a Data instance backed by NSMutableData back to NSData? <br></p><p>The proposal says: &quot;For reference-holding types like Data, we simply pass our interior NSData pointer back to Objective-C. The underlying data is not copied at bridging time.&quot; If the Data instance is backed by NSMutableData, can we still successfully check for uniqueness once we pass it back to Objective-C?<br></p><p>Thanks!<br>Nate<br></p><p><br>&gt; On Apr 22, 2016, at 12:18 PM, Tony Parker via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Dear swift-evolution denizens,<br>&gt; <br>&gt; As you know from our announcement of Swift Open Source and our work on naming guidelines, one of our goals for Swift 3 is to “drop NS” for Foundation. We want to to make the cross-platform Foundation API that is available as part of swift-corelibs feel like it is not tied to just Darwin targets. We also want to reinforce the idea that new Foundation API must fit in with the language, standard library, and the rapidly evolving design patterns we see in the community.<br>&gt; <br>&gt; You challenged us on one part of this plan: some Foundation API just doesn’t “feel Swifty”, and a large part of the reason why is that it often does not have the same value type behavior as other Swift types. We took this feedback seriously, and I would like to share with you the start of an important journey for some of the most commonly used APIs on all of our platforms: adopting value semantics for key Foundation types.<br>&gt; <br>&gt; We have been working on this for some time now, and the set of diffs that result from this change is large. At this point, I am going to focus effort on an overview of the high level goals and not the individual API of each new type. In order to focus on delivering something up to our quality standards, we are intentionally leaving some class types as-is until a future proposal. If you don’t see your favorite class on the list — don’t despair. We are going to iterate on this over time. I see this as the start of the process.<br>&gt; <br>&gt; One process note: we are still trying to figure out the best way to integrate changes to API that ship as part of the operating system (which includes Foundation) into the swift-evolution review process. Swift-evolution is normally focused on changes to functionality in the compiler or standard library. In general, I don’t expect all new Foundation API introduced in the Darwin/Objective-C framework to go through the open source process. However, as we’ve brought up this topic here before, I felt it was important to bring this particular change to the swift-evolution list.<br>&gt; <br>&gt; As always I welcome your feedback.<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0069-swift-mutability-for-foundation.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0069-swift-mutability-for-foundation.md&gt;<br>&gt; <br>&gt; Thanks,<br>&gt; - Tony<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160422/d1c6fcf2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be4c3c3b76631a155e1358db48066692?s=50"></div><header><strong>Mutability for Foundation types in Swift</strong> from <string>Tony Parker</string> &lt;anthony.parker at apple.com&gt;<p>April 22, 2016 at 12:00:00pm</p></header><div class="content"><p>Hi Nate,<br></p><p>&gt; On Apr 22, 2016, at 11:55 AM, Nate Cook &lt;natecook at gmail.com&gt; wrote:<br>&gt; <br>&gt; This looks amazing—really looking forward to seeing the progression here!<br>&gt; <br>&gt; I do have a question about how copy-on-write is handled for larger data types like Data (née NSData). The standard library types that can use bridged storage use immutable classes until there&#39;s a mutation, at which point the contents are copied into native storage. From then on (as long as the native storage is still uniquely referenced) the contents can be mutated in place without any copying.<br>&gt; <br>&gt; With the proposed value semantics around an NSData instance, how do you handle that in-place mutation? When bridging from Objective-C to Swift, it sounds like you&#39;ll call copy() on an NSData instance. Does NSMutableData perform the role of the native storage when mutating? If so, is another copy needed when bridging a Data instance backed by NSMutableData back to NSData? <br>&gt; <br>&gt; The proposal says: &quot;For reference-holding types like Data, we simply pass our interior NSData pointer back to Objective-C. The underlying data is not copied at bridging time.&quot; If the Data instance is backed by NSMutableData, can we still successfully check for uniqueness once we pass it back to Objective-C?<br>&gt; <br>&gt; Thanks!<br>&gt; Nate<br>&gt; <br></p><p>In reality, the stored reference object is a Swift class with Swift-native ref counting that implements the methods of the Objective-C NSData “protocol” (the interface described by @interface NSData) by holding a “real” NSMutableData ivar and forwarding messages to it. This technique is actually already in use in the standard library. <br></p><p>Starts around here:<br></p><p>https://github.com/apple/swift/blob/master/stdlib/public/core/Runtime.swift.gyb#L497<br></p><p>and then look here:<br></p><p>https://github.com/apple/swift/blob/e67acdb70d8887507747d0ed14898306f07a74f4/stdlib/public/stubs/SwiftNativeNSXXXBase.mm.gyb#L59<br></p><p>and finally here:<br></p><p>https://github.com/apple/swift/blob/4fd8418ba724963e1414e4d720a05bb9cc5fb77a/stdlib/public/core/SwiftNativeNSArray.swift#L40<br></p><p>This means that if an Objective-C client calls retain on this object (which is a _SwiftNativeNSData), it actually calls swift_retain, which mutates the Swift ref count. This means that a call to _isUniquelyReferencedNonObjC from Swift actually still works on this class type.<br></p><p>- Tony<br></p><p>&gt; <br>&gt;&gt; On Apr 22, 2016, at 12:18 PM, Tony Parker via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Dear swift-evolution denizens,<br>&gt;&gt; <br>&gt;&gt; As you know from our announcement of Swift Open Source and our work on naming guidelines, one of our goals for Swift 3 is to “drop NS” for Foundation. We want to to make the cross-platform Foundation API that is available as part of swift-corelibs feel like it is not tied to just Darwin targets. We also want to reinforce the idea that new Foundation API must fit in with the language, standard library, and the rapidly evolving design patterns we see in the community.<br>&gt;&gt; <br>&gt;&gt; You challenged us on one part of this plan: some Foundation API just doesn’t “feel Swifty”, and a large part of the reason why is that it often does not have the same value type behavior as other Swift types. We took this feedback seriously, and I would like to share with you the start of an important journey for some of the most commonly used APIs on all of our platforms: adopting value semantics for key Foundation types.<br>&gt;&gt; <br>&gt;&gt; We have been working on this for some time now, and the set of diffs that result from this change is large. At this point, I am going to focus effort on an overview of the high level goals and not the individual API of each new type. In order to focus on delivering something up to our quality standards, we are intentionally leaving some class types as-is until a future proposal. If you don’t see your favorite class on the list — don’t despair. We are going to iterate on this over time. I see this as the start of the process.<br>&gt;&gt; <br>&gt;&gt; One process note: we are still trying to figure out the best way to integrate changes to API that ship as part of the operating system (which includes Foundation) into the swift-evolution review process. Swift-evolution is normally focused on changes to functionality in the compiler or standard library. In general, I don’t expect all new Foundation API introduced in the Darwin/Objective-C framework to go through the open source process. However, as we’ve brought up this topic here before, I felt it was important to bring this particular change to the swift-evolution list.<br>&gt;&gt; <br>&gt;&gt; As always I welcome your feedback.<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0069-swift-mutability-for-foundation.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0069-swift-mutability-for-foundation.md&gt;<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; - Tony<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160422/7677f252/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Mutability for Foundation types in Swift</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>April 22, 2016 at 01:00:00pm</p></header><div class="content"><p>Amazing, I am really looking forward to this feature!<br></p><p>Comments:<br></p><p>- For Locale and Calendar, one possible Swift layout would be to synthesize a protocol and to use that to represent bridged API. You could then bridge inbound to either the immutable value type or the dynamic class-based type. On the swift side, these are constructed as two distinct types.<br></p><p>- For any of these types, are there improvements (similar to String) which would be worth making before exposing ’the’ Swift type and API? The ones I’m specifically worried about are Date and URL, since I’ve seen so many standard language time and networking API show their age over time.<br></p><p>-DW<br></p><p>&gt; On Apr 22, 2016, at 11:18 AM, Tony Parker via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Dear swift-evolution denizens,<br>&gt; <br>&gt; As you know from our announcement of Swift Open Source and our work on naming guidelines, one of our goals for Swift 3 is to “drop NS” for Foundation. We want to to make the cross-platform Foundation API that is available as part of swift-corelibs feel like it is not tied to just Darwin targets. We also want to reinforce the idea that new Foundation API must fit in with the language, standard library, and the rapidly evolving design patterns we see in the community.<br>&gt; <br>&gt; You challenged us on one part of this plan: some Foundation API just doesn’t “feel Swifty”, and a large part of the reason why is that it often does not have the same value type behavior as other Swift types. We took this feedback seriously, and I would like to share with you the start of an important journey for some of the most commonly used APIs on all of our platforms: adopting value semantics for key Foundation types.<br>&gt; <br>&gt; We have been working on this for some time now, and the set of diffs that result from this change is large. At this point, I am going to focus effort on an overview of the high level goals and not the individual API of each new type. In order to focus on delivering something up to our quality standards, we are intentionally leaving some class types as-is until a future proposal. If you don’t see your favorite class on the list — don’t despair. We are going to iterate on this over time. I see this as the start of the process.<br>&gt; <br>&gt; One process note: we are still trying to figure out the best way to integrate changes to API that ship as part of the operating system (which includes Foundation) into the swift-evolution review process. Swift-evolution is normally focused on changes to functionality in the compiler or standard library. In general, I don’t expect all new Foundation API introduced in the Darwin/Objective-C framework to go through the open source process. However, as we’ve brought up this topic here before, I felt it was important to bring this particular change to the swift-evolution list.<br>&gt; <br>&gt; As always I welcome your feedback.<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0069-swift-mutability-for-foundation.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0069-swift-mutability-for-foundation.md&gt;<br>&gt; <br>&gt; Thanks,<br>&gt; - Tony<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160422/e1f6d64f/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 496 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160422/e1f6d64f/attachment.sig&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be4c3c3b76631a155e1358db48066692?s=50"></div><header><strong>Mutability for Foundation types in Swift</strong> from <string>Tony Parker</string> &lt;anthony.parker at apple.com&gt;<p>April 22, 2016 at 12:00:00pm</p></header><div class="content"><p>Hi David,<br></p><p>&gt; On Apr 22, 2016, at 12:13 PM, David Waite &lt;david at alkaline-solutions.com&gt; wrote:<br>&gt; <br>&gt; Amazing, I am really looking forward to this feature!<br>&gt; <br>&gt; Comments:<br>&gt; <br>&gt; - For Locale and Calendar, one possible Swift layout would be to synthesize a protocol and to use that to represent bridged API. You could then bridge inbound to either the immutable value type or the dynamic class-based type. On the swift side, these are constructed as two distinct types.<br></p><p>That’s an interesting approach, I’ll consider that for these.<br></p><p>&gt; <br>&gt; - For any of these types, are there improvements (similar to String) which would be worth making before exposing ’the’ Swift type and API? The ones I’m specifically worried about are Date and URL, since I’ve seen so many standard language time and networking API show their age over time.<br>&gt; <br>&gt; -DW<br></p><p>We’re absolutely going to be making Swift-specific improvements to many of these types. I think the resulting API is better in many ways. For example, on URL the main improvement is that the resource values dictionary is now struct type with a lot of strongly-typed properties. It’s still got a lot of optionals because of the way that the underlying fetch works, but it’s better. Date gains mutating methods along with support for operators like += and &lt; &gt;. <br></p><p>One of the guiding principles of our effort was evolution over revolution. Foundation is obviously used in tons and tons of API. We want to maintain conceptual compatibility with the entire OS X / iOS / watchOS / tvOS SDK when it is imported into Swift. Hopefully this also means that converting from reference to value types in your own uses of these API does not require a complete rethink of how you use them, but still provide the benefits outlined in the proposal. We’ll continue to iterate and improve over time.<br></p><p>Thanks,<br></p><p>- Tony<br></p><p>&gt;  <br>&gt;&gt; On Apr 22, 2016, at 11:18 AM, Tony Parker via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Dear swift-evolution denizens,<br>&gt;&gt; <br>&gt;&gt; As you know from our announcement of Swift Open Source and our work on naming guidelines, one of our goals for Swift 3 is to “drop NS” for Foundation. We want to to make the cross-platform Foundation API that is available as part of swift-corelibs feel like it is not tied to just Darwin targets. We also want to reinforce the idea that new Foundation API must fit in with the language, standard library, and the rapidly evolving design patterns we see in the community.<br>&gt;&gt; <br>&gt;&gt; You challenged us on one part of this plan: some Foundation API just doesn’t “feel Swifty”, and a large part of the reason why is that it often does not have the same value type behavior as other Swift types. We took this feedback seriously, and I would like to share with you the start of an important journey for some of the most commonly used APIs on all of our platforms: adopting value semantics for key Foundation types.<br>&gt;&gt; <br>&gt;&gt; We have been working on this for some time now, and the set of diffs that result from this change is large. At this point, I am going to focus effort on an overview of the high level goals and not the individual API of each new type. In order to focus on delivering something up to our quality standards, we are intentionally leaving some class types as-is until a future proposal. If you don’t see your favorite class on the list — don’t despair. We are going to iterate on this over time. I see this as the start of the process.<br>&gt;&gt; <br>&gt;&gt; One process note: we are still trying to figure out the best way to integrate changes to API that ship as part of the operating system (which includes Foundation) into the swift-evolution review process. Swift-evolution is normally focused on changes to functionality in the compiler or standard library. In general, I don’t expect all new Foundation API introduced in the Darwin/Objective-C framework to go through the open source process. However, as we’ve brought up this topic here before, I felt it was important to bring this particular change to the swift-evolution list.<br>&gt;&gt; <br>&gt;&gt; As always I welcome your feedback.<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0069-swift-mutability-for-foundation.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0069-swift-mutability-for-foundation.md&gt;<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; - Tony<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160422/563d1187/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/009173d589176cfd9c8146cc49849ff6?s=50"></div><header><strong>Mutability for Foundation types in Swift</strong> from <string>Riley Testut</string> &lt;rileytestut at gmail.com&gt;<p>April 22, 2016 at 01:00:00pm</p></header><div class="content"><p>Very happy to see this proposal; felt strange that for a language so focused on value-types an entire framework open sourced with the language was composed entirely of reference-types (albeit for obvious reasons). So +1 for that.<br></p><p>One particular section that caught my interest was this:<br>&gt; The most obvious drawback to using a struct is that the type can no longer be subclassed. At first glance, this would seem to prevent the customization of behavior of these types. However, by publicizing the reference type and providing a mechanism to wrap it (mySubclassInstance as ValueType), we enable subclasses to provide customized behavior.<br></p><p>I&#39;m incredibly biased, but I recently proposed and submitted a pull request that would introduce &quot;factory initializers&quot; to the language (https://github.com/apple/swift-evolution/pull/247). The full proposal has more info, but essentially factory initializers would allow for directly returning initialized types from designated factory initializers, similar to how initializers are implemented in Objective-C.<br></p><p>Anyway, I feel the Factory Initializer proposal would work very well with this Foundation proposal. While I believe the current suggestion of casting the reference type as the value type works well, I don&#39;t believe it is necessarily the client of the API&#39;s job to use it; I believe it would make far more sense for there to be an extension adding additional factory initializers to the class, which would determine the underlying reference type to use based on the input parameters.<br></p><p>For example, here is the example of using a custom subclass for the Data type mentioned in this Foundation proposal:<br>&gt; /// Create a Data with a custom backing reference type.<br>&gt; class MyData : NSData { }<br>&gt; let dataReference = MyData()<br>&gt; let dataValue = dataReference as Data // dataValue copies dataReference<br></p><p>I personally would rather see something akin to this:<br></p><p>public extension Data {<br>	factory init(inputData: ...)<br>	{<br>		if ... {<br>			// Return subclass best suited for storing this particular input data<br>			return MyData(inputData) as Data<br>		}<br>		else {<br>			let data = NSData()<br></p><p>			/* OMITTED: add hypothetical inputData to NSData depending on what it is */<br>	<br>			return data <br>}<br></p><p>This means the client of the API never has to worry about which subclass is best suited for them; everything would &quot;just work&quot;. This also better mimics the existing class cluster pattern in Foundation, which might help with this transition should my proposal be accepted.<br></p><p>Regardless though, very happy to see this being pushed forward. Just thought I&#39;d suggest ways to make this proposal (hopefully) easier to both implement and use :)<br></p><p>&gt; On Apr 22, 2016, at 12:52 PM, Tony Parker via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi David,<br>&gt; <br>&gt;&gt; On Apr 22, 2016, at 12:13 PM, David Waite &lt;david at alkaline-solutions.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Amazing, I am really looking forward to this feature!<br>&gt;&gt; <br>&gt;&gt; Comments:<br>&gt;&gt; <br>&gt;&gt; - For Locale and Calendar, one possible Swift layout would be to synthesize a protocol and to use that to represent bridged API. You could then bridge inbound to either the immutable value type or the dynamic class-based type. On the swift side, these are constructed as two distinct types.<br>&gt; <br>&gt; That’s an interesting approach, I’ll consider that for these.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; - For any of these types, are there improvements (similar to String) which would be worth making before exposing ’the’ Swift type and API? The ones I’m specifically worried about are Date and URL, since I’ve seen so many standard language time and networking API show their age over time.<br>&gt;&gt; <br>&gt;&gt; -DW<br>&gt; <br>&gt; We’re absolutely going to be making Swift-specific improvements to many of these types. I think the resulting API is better in many ways. For example, on URL the main improvement is that the resource values dictionary is now struct type with a lot of strongly-typed properties. It’s still got a lot of optionals because of the way that the underlying fetch works, but it’s better. Date gains mutating methods along with support for operators like += and &lt; &gt;. <br>&gt; <br>&gt; One of the guiding principles of our effort was evolution over revolution. Foundation is obviously used in tons and tons of API. We want to maintain conceptual compatibility with the entire OS X / iOS / watchOS / tvOS SDK when it is imported into Swift. Hopefully this also means that converting from reference to value types in your own uses of these API does not require a complete rethink of how you use them, but still provide the benefits outlined in the proposal. We’ll continue to iterate and improve over time.<br>&gt; <br>&gt; Thanks,<br>&gt; <br>&gt; - Tony<br>&gt; <br>&gt;&gt;  <br>&gt;&gt;&gt; On Apr 22, 2016, at 11:18 AM, Tony Parker via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Dear swift-evolution denizens,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As you know from our announcement of Swift Open Source and our work on naming guidelines, one of our goals for Swift 3 is to “drop NS” for Foundation. We want to to make the cross-platform Foundation API that is available as part of swift-corelibs feel like it is not tied to just Darwin targets. We also want to reinforce the idea that new Foundation API must fit in with the language, standard library, and the rapidly evolving design patterns we see in the community.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You challenged us on one part of this plan: some Foundation API just doesn’t “feel Swifty”, and a large part of the reason why is that it often does not have the same value type behavior as other Swift types. We took this feedback seriously, and I would like to share with you the start of an important journey for some of the most commonly used APIs on all of our platforms: adopting value semantics for key Foundation types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We have been working on this for some time now, and the set of diffs that result from this change is large. At this point, I am going to focus effort on an overview of the high level goals and not the individual API of each new type. In order to focus on delivering something up to our quality standards, we are intentionally leaving some class types as-is until a future proposal. If you don’t see your favorite class on the list — don’t despair. We are going to iterate on this over time. I see this as the start of the process.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One process note: we are still trying to figure out the best way to integrate changes to API that ship as part of the operating system (which includes Foundation) into the swift-evolution review process. Swift-evolution is normally focused on changes to functionality in the compiler or standard library. In general, I don’t expect all new Foundation API introduced in the Darwin/Objective-C framework to go through the open source process. However, as we’ve brought up this topic here before, I felt it was important to bring this particular change to the swift-evolution list.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As always I welcome your feedback.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0069-swift-mutability-for-foundation.md<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; - Tony<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160422/29bba157/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be4c3c3b76631a155e1358db48066692?s=50"></div><header><strong>Mutability for Foundation types in Swift</strong> from <string>Tony Parker</string> &lt;anthony.parker at apple.com&gt;<p>April 22, 2016 at 02:00:00pm</p></header><div class="content"><p>Hi Riley,<br></p><p>&gt; On Apr 22, 2016, at 1:34 PM, Riley Testut &lt;rileytestut at gmail.com&gt; wrote:<br>&gt; <br>&gt; Very happy to see this proposal; felt strange that for a language so focused on value-types an entire framework open sourced with the language was composed entirely of reference-types (albeit for obvious reasons). So +1 for that.<br>&gt; <br>&gt; One particular section that caught my interest was this:<br>&gt;&gt; The most obvious drawback to using a struct is that the type can no longer be subclassed. At first glance, this would seem to prevent the customization of behavior of these types. However, by publicizing the reference type and providing a mechanism to wrap it (mySubclassInstance as ValueType), we enable subclasses to provide customized behavior.<br>&gt; <br>&gt; I&#39;m incredibly biased, but I recently proposed and submitted a pull request that would introduce &quot;factory initializers&quot; to the language (https://github.com/apple/swift-evolution/pull/247 &lt;https://github.com/apple/swift-evolution/pull/247&gt;). The full proposal has more info, but essentially factory initializers would allow for directly returning initialized types from designated factory initializers, similar to how initializers are implemented in Objective-C.<br>&gt; <br>&gt; Anyway, I feel the Factory Initializer proposal would work very well with this Foundation proposal. While I believe the current suggestion of casting the reference type as the value type works well, I don&#39;t believe it is necessarily the client of the API&#39;s job to use it; I believe it would make far more sense for there to be an extension adding additional factory initializers to the class, which would determine the underlying reference type to use based on the input parameters.<br>&gt; <br>&gt; For example, here is the example of using a custom subclass for the Data type mentioned in this Foundation proposal:<br>&gt;&gt; /// Create a Data with a custom backing reference type.<br>&gt;&gt; class MyData : NSData { }<br>&gt;&gt; let dataReference = MyData()<br>&gt;&gt; let dataValue = dataReference as Data // dataValue copies dataReference<br>&gt; <br>&gt; I personally would rather see something akin to this:<br>&gt; <br>&gt; public extension Data {<br>&gt; 	factory init(inputData: ...)<br>&gt; 	{<br>&gt; 		if ... {<br>&gt; 			// Return subclass best suited for storing this particular input data<br>&gt; 			return MyData(inputData) as Data<br>&gt; 		}<br>&gt; 		else {<br>&gt; 			let data = NSData()<br>&gt; <br>&gt; 			/* OMITTED: add hypothetical inputData to NSData depending on what it is */<br>&gt; 	<br>&gt; 			return data <br>&gt; }<br>&gt; <br>&gt; This means the client of the API never has to worry about which subclass is best suited for them; everything would &quot;just work&quot;. This also better mimics the existing class cluster pattern in Foundation, which might help with this transition should my proposal be accepted.<br>&gt; <br>&gt; Regardless though, very happy to see this being pushed forward. Just thought I&#39;d suggest ways to make this proposal (hopefully) easier to both implement and use :)<br></p><p>Thanks for your feedback.<br></p><p>For what it’s worth, I’m fully in support of your factory type proposal as well. I think we need it in order to finish a complete implementation of swift-corelibs-foundation, at the very least.<br></p><p>We can certainly extend these types to include use of the factory types once we get them into the language.<br></p><p>- Tony<br></p><p>&gt; <br>&gt; On Apr 22, 2016, at 12:52 PM, Tony Parker via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Hi David,<br>&gt;&gt; <br>&gt;&gt;&gt; On Apr 22, 2016, at 12:13 PM, David Waite &lt;david at alkaline-solutions.com &lt;mailto:david at alkaline-solutions.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Amazing, I am really looking forward to this feature!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Comments:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - For Locale and Calendar, one possible Swift layout would be to synthesize a protocol and to use that to represent bridged API. You could then bridge inbound to either the immutable value type or the dynamic class-based type. On the swift side, these are constructed as two distinct types.<br>&gt;&gt; <br>&gt;&gt; That’s an interesting approach, I’ll consider that for these.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - For any of these types, are there improvements (similar to String) which would be worth making before exposing ’the’ Swift type and API? The ones I’m specifically worried about are Date and URL, since I’ve seen so many standard language time and networking API show their age over time.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -DW<br>&gt;&gt; <br>&gt;&gt; We’re absolutely going to be making Swift-specific improvements to many of these types. I think the resulting API is better in many ways. For example, on URL the main improvement is that the resource values dictionary is now struct type with a lot of strongly-typed properties. It’s still got a lot of optionals because of the way that the underlying fetch works, but it’s better. Date gains mutating methods along with support for operators like += and &lt; &gt;. <br>&gt;&gt; <br>&gt;&gt; One of the guiding principles of our effort was evolution over revolution. Foundation is obviously used in tons and tons of API. We want to maintain conceptual compatibility with the entire OS X / iOS / watchOS / tvOS SDK when it is imported into Swift. Hopefully this also means that converting from reference to value types in your own uses of these API does not require a complete rethink of how you use them, but still provide the benefits outlined in the proposal. We’ll continue to iterate and improve over time.<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; <br>&gt;&gt; - Tony<br>&gt;&gt; <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; On Apr 22, 2016, at 11:18 AM, Tony Parker via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Dear swift-evolution denizens,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As you know from our announcement of Swift Open Source and our work on naming guidelines, one of our goals for Swift 3 is to “drop NS” for Foundation. We want to to make the cross-platform Foundation API that is available as part of swift-corelibs feel like it is not tied to just Darwin targets. We also want to reinforce the idea that new Foundation API must fit in with the language, standard library, and the rapidly evolving design patterns we see in the community.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You challenged us on one part of this plan: some Foundation API just doesn’t “feel Swifty”, and a large part of the reason why is that it often does not have the same value type behavior as other Swift types. We took this feedback seriously, and I would like to share with you the start of an important journey for some of the most commonly used APIs on all of our platforms: adopting value semantics for key Foundation types.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We have been working on this for some time now, and the set of diffs that result from this change is large. At this point, I am going to focus effort on an overview of the high level goals and not the individual API of each new type. In order to focus on delivering something up to our quality standards, we are intentionally leaving some class types as-is until a future proposal. If you don’t see your favorite class on the list — don’t despair. We are going to iterate on this over time. I see this as the start of the process.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One process note: we are still trying to figure out the best way to integrate changes to API that ship as part of the operating system (which includes Foundation) into the swift-evolution review process. Swift-evolution is normally focused on changes to functionality in the compiler or standard library. In general, I don’t expect all new Foundation API introduced in the Darwin/Objective-C framework to go through the open source process. However, as we’ve brought up this topic here before, I felt it was important to bring this particular change to the swift-evolution list.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As always I welcome your feedback.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0069-swift-mutability-for-foundation.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0069-swift-mutability-for-foundation.md&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt; - Tony<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160422/1f6cfb62/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>Mutability for Foundation types in Swift</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>April 22, 2016 at 03:00:00pm</p></header><div class="content"><p>On the one hand I like the idea (and particularly like the foundation types having meaningful `mutating` annotations, loosely speaking).<br></p><p>On the other hand I have two questions:<br></p><p>1. will the NS types actually remain visible/usable (on supported platforms, perhaps requiring a specific import to become visible)?<br>2. does this include — or are their separate plans for — exposing the backing reference type in some principled way? <br></p><p>For (2.) what I mean is something like having at least the heavyweight thing like `Data` (and ideally also Array/Set/Dictionary/IndexSet, etc.) have matching-API reference types like `DataRef` in the standard library. <br></p><p>I think this has come up before at some point, but if it did I didn’t follow it.<br></p><p>My interest in (1.) is mostly b/c I suspect the answer to (2.) is “no”.<br></p><p>Apologies if these are alrexdy-addressedd and I just missed it.<br></p><p>&gt; On Apr 22, 2016, at 12:18 PM, Tony Parker via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Dear swift-evolution denizens,<br>&gt; <br>&gt; As you know from our announcement of Swift Open Source and our work on naming guidelines, one of our goals for Swift 3 is to “drop NS” for Foundation. We want to to make the cross-platform Foundation API that is available as part of swift-corelibs feel like it is not tied to just Darwin targets. We also want to reinforce the idea that new Foundation API must fit in with the language, standard library, and the rapidly evolving design patterns we see in the community.<br>&gt; <br>&gt; You challenged us on one part of this plan: some Foundation API just doesn’t “feel Swifty”, and a large part of the reason why is that it often does not have the same value type behavior as other Swift types. We took this feedback seriously, and I would like to share with you the start of an important journey for some of the most commonly used APIs on all of our platforms: adopting value semantics for key Foundation types.<br>&gt; <br>&gt; We have been working on this for some time now, and the set of diffs that result from this change is large. At this point, I am going to focus effort on an overview of the high level goals and not the individual API of each new type. In order to focus on delivering something up to our quality standards, we are intentionally leaving some class types as-is until a future proposal. If you don’t see your favorite class on the list — don’t despair. We are going to iterate on this over time. I see this as the start of the process.<br>&gt; <br>&gt; One process note: we are still trying to figure out the best way to integrate changes to API that ship as part of the operating system (which includes Foundation) into the swift-evolution review process. Swift-evolution is normally focused on changes to functionality in the compiler or standard library. In general, I don’t expect all new Foundation API introduced in the Darwin/Objective-C framework to go through the open source process. However, as we’ve brought up this topic here before, I felt it was important to bring this particular change to the swift-evolution list.<br>&gt; <br>&gt; As always I welcome your feedback.<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0069-swift-mutability-for-foundation.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0069-swift-mutability-for-foundation.md&gt;<br>&gt; <br>&gt; Thanks,<br>&gt; - Tony<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160422/1bc2f3b1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/00f9939846257c9db8ddc42ce61ec6d1?s=50"></div><header><strong>Mutability for Foundation types in Swift</strong> from <string>Philippe Hausler</string> &lt;phausler at apple.com&gt;<p>April 22, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Apr 22, 2016, at 1:53 PM, plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On the one hand I like the idea (and particularly like the foundation types having meaningful `mutating` annotations, loosely speaking).<br>&gt; <br>&gt; On the other hand I have two questions:<br>&gt; <br>&gt; 1. will the NS types actually remain visible/usable (on supported platforms, perhaps requiring a specific import to become visible)?<br></p><p>NSData will still exist and be available (as will NSMutableData) on all platforms including swift-corelibs versions; there are still some reasons to have reference semantics from time to time hence why the proposal did not take away any of them.<br></p><p>&gt; 2. does this include — or are their separate plans for — exposing the backing reference type in some principled way? <br></p><p>`as` cast will grant a reference type, but of course this has a potential of a copy semantic. A direct access to the underlying box that contains the object would be dangerous; in that references passed around for that container would be beyond the scope of data’s control (Tony might be able to speak on this a bit more than myself)<br></p><p>The structure may later drop it’s reference to that object and construct a new version upon mutation etc.<br></p><p>&gt; <br>&gt; For (2.) what I mean is something like having at least the heavyweight thing like `Data` (and ideally also Array/Set/Dictionary/IndexSet, etc.) have matching-API reference types like `DataRef` in the standard library. <br></p><p><br>let dataStructure = Data(bytes: someBytes, count: 5)<br>let dataReference = dataStructure as NSData // this is a reference version of the structural container, but you should not count on the identity since the structure could mutate out and replace the backing storage.<br></p><p>&gt; <br>&gt; I think this has come up before at some point, but if it did I didn’t follow it.<br>&gt; <br>&gt; My interest in (1.) is mostly b/c I suspect the answer to (2.) is “no”.<br>&gt; <br>&gt; Apologies if these are alrexdy-addressedd and I just missed it.<br>&gt; <br>&gt;&gt; On Apr 22, 2016, at 12:18 PM, Tony Parker via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Dear swift-evolution denizens,<br>&gt;&gt; <br>&gt;&gt; As you know from our announcement of Swift Open Source and our work on naming guidelines, one of our goals for Swift 3 is to “drop NS” for Foundation. We want to to make the cross-platform Foundation API that is available as part of swift-corelibs feel like it is not tied to just Darwin targets. We also want to reinforce the idea that new Foundation API must fit in with the language, standard library, and the rapidly evolving design patterns we see in the community.<br>&gt;&gt; <br>&gt;&gt; You challenged us on one part of this plan: some Foundation API just doesn’t “feel Swifty”, and a large part of the reason why is that it often does not have the same value type behavior as other Swift types. We took this feedback seriously, and I would like to share with you the start of an important journey for some of the most commonly used APIs on all of our platforms: adopting value semantics for key Foundation types.<br>&gt;&gt; <br>&gt;&gt; We have been working on this for some time now, and the set of diffs that result from this change is large. At this point, I am going to focus effort on an overview of the high level goals and not the individual API of each new type. In order to focus on delivering something up to our quality standards, we are intentionally leaving some class types as-is until a future proposal. If you don’t see your favorite class on the list — don’t despair. We are going to iterate on this over time. I see this as the start of the process.<br>&gt;&gt; <br>&gt;&gt; One process note: we are still trying to figure out the best way to integrate changes to API that ship as part of the operating system (which includes Foundation) into the swift-evolution review process. Swift-evolution is normally focused on changes to functionality in the compiler or standard library. In general, I don’t expect all new Foundation API introduced in the Darwin/Objective-C framework to go through the open source process. However, as we’ve brought up this topic here before, I felt it was important to bring this particular change to the swift-evolution list.<br>&gt;&gt; <br>&gt;&gt; As always I welcome your feedback.<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0069-swift-mutability-for-foundation.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0069-swift-mutability-for-foundation.md&gt;<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; - Tony<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160422/a8be1223/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Mutability for Foundation types in Swift</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>April 22, 2016 at 04:00:00pm</p></header><div class="content"><p>One comment:<br></p><p>&quot;In the most common case where a developer does not provide a custom reference type, then the backing store is our existing NSData and NSMutableData implementations. This consolidates logic into one place and provides cheap bridging in many cases (see Bridging for more information).”<br></p><p>Would it not be more efficient to bridge to the C-based CFData and CFMutableData implementations instead, to avoid the object overhead?<br></p><p>Charles<br></p><p>&gt; On Apr 22, 2016, at 12:18 PM, Tony Parker via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Dear swift-evolution denizens,<br>&gt; <br>&gt; As you know from our announcement of Swift Open Source and our work on naming guidelines, one of our goals for Swift 3 is to “drop NS” for Foundation. We want to to make the cross-platform Foundation API that is available as part of swift-corelibs feel like it is not tied to just Darwin targets. We also want to reinforce the idea that new Foundation API must fit in with the language, standard library, and the rapidly evolving design patterns we see in the community.<br>&gt; <br>&gt; You challenged us on one part of this plan: some Foundation API just doesn’t “feel Swifty”, and a large part of the reason why is that it often does not have the same value type behavior as other Swift types. We took this feedback seriously, and I would like to share with you the start of an important journey for some of the most commonly used APIs on all of our platforms: adopting value semantics for key Foundation types.<br>&gt; <br>&gt; We have been working on this for some time now, and the set of diffs that result from this change is large. At this point, I am going to focus effort on an overview of the high level goals and not the individual API of each new type. In order to focus on delivering something up to our quality standards, we are intentionally leaving some class types as-is until a future proposal. If you don’t see your favorite class on the list — don’t despair. We are going to iterate on this over time. I see this as the start of the process.<br>&gt; <br>&gt; One process note: we are still trying to figure out the best way to integrate changes to API that ship as part of the operating system (which includes Foundation) into the swift-evolution review process. Swift-evolution is normally focused on changes to functionality in the compiler or standard library. In general, I don’t expect all new Foundation API introduced in the Darwin/Objective-C framework to go through the open source process. However, as we’ve brought up this topic here before, I felt it was important to bring this particular change to the swift-evolution list.<br>&gt; <br>&gt; As always I welcome your feedback.<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0069-swift-mutability-for-foundation.md<br>&gt; <br>&gt; Thanks,<br>&gt; - Tony<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>Mutability for Foundation types in Swift</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>April 22, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Apr 22, 2016, at 2:36 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; One comment:<br>&gt; <br>&gt; &quot;In the most common case where a developer does not provide a custom reference type, then the backing store is our existing NSData and NSMutableData implementations. This consolidates logic into one place and provides cheap bridging in many cases (see Bridging for more information).”<br>&gt; <br>&gt; Would it not be more efficient to bridge to the C-based CFData and CFMutableData implementations instead, to avoid the object overhead?<br></p><p>Not necessarily. Foundation often has less overhead than CF nowadays.<br></p><p><br>-- <br>Greg Parker     gparker at apple.com &lt;mailto:gparker at apple.com&gt;     Runtime Wrangler<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160422/9fdb3043/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Mutability for Foundation types in Swift</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>April 22, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Apr 22, 2016, at 5:05 PM, Greg Parker &lt;gparker at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Apr 22, 2016, at 2:36 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; One comment:<br>&gt;&gt; <br>&gt;&gt; &quot;In the most common case where a developer does not provide a custom reference type, then the backing store is our existing NSData and NSMutableData implementations. This consolidates logic into one place and provides cheap bridging in many cases (see Bridging for more information).”<br>&gt;&gt; <br>&gt;&gt; Would it not be more efficient to bridge to the C-based CFData and CFMutableData implementations instead, to avoid the object overhead?<br>&gt; <br>&gt; Not necessarily. Foundation often has less overhead than CF nowadays.<br></p><p>That’s interesting; I hadn’t known that. What causes that? My understanding had always been that the NS and CF objects, being toll-free bridged to each other, shared the same default implementations, with the only difference being that the NS versions involved the overhead from objc_msgSend() as well as, in many cases, an autorelease.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160422/cb525897/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7ba3c93f9350613c243eeb87c602935e?s=50"></div><header><strong>Mutability for Foundation types in Swift</strong> from <string>David Smith</string> &lt;david_smith at apple.com&gt;<p>April 22, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Apr 22, 2016, at 8:48 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Apr 22, 2016, at 5:05 PM, Greg Parker &lt;gparker at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Apr 22, 2016, at 2:36 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One comment:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &quot;In the most common case where a developer does not provide a custom reference type, then the backing store is our existing NSData and NSMutableData implementations. This consolidates logic into one place and provides cheap bridging in many cases (see Bridging for more information).”<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Would it not be more efficient to bridge to the C-based CFData and CFMutableData implementations instead, to avoid the object overhead?<br>&gt;&gt; <br>&gt;&gt; Not necessarily. Foundation often has less overhead than CF nowadays.<br>&gt; <br>&gt; That’s interesting; I hadn’t known that. What causes that? My understanding had always been that the NS and CF objects, being toll-free bridged to each other, shared the same default implementations, with the only difference being that the NS versions involved the overhead from objc_msgSend() as well as, in many cases, an autorelease.<br>&gt; <br>&gt; Charles<br></p><p>There&#39;s a wide variety of bridging techniques in use, but in NSData&#39;s case the implementations are separate (and there are 5 implementations for NSData, 1 for CFData). CFData also has to pay the cost for detecting whether it&#39;s argument is a bridged NSData, which is ironically about as expensive as a message send.<br></p><p>    David<br></p><p>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160422/378c2429/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/00f9939846257c9db8ddc42ce61ec6d1?s=50"></div><header><strong>Mutability for Foundation types in Swift</strong> from <string>Philippe Hausler</string> &lt;phausler at apple.com&gt;<p>April 22, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Apr 22, 2016, at 2:36 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; One comment:<br>&gt; <br>&gt; &quot;In the most common case where a developer does not provide a custom reference type, then the backing store is our existing NSData and NSMutableData implementations. This consolidates logic into one place and provides cheap bridging in many cases (see Bridging for more information).”<br>&gt; <br>&gt; Would it not be more efficient to bridge to the C-based CFData and CFMutableData implementations instead, to avoid the object overhead?<br></p><p>Actually it is often the case that the NS counterparts are faster than the CF versions (data being one of them).<br></p><p>&gt; <br>&gt; Charles<br>&gt; <br>&gt;&gt; On Apr 22, 2016, at 12:18 PM, Tony Parker via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Dear swift-evolution denizens,<br>&gt;&gt; <br>&gt;&gt; As you know from our announcement of Swift Open Source and our work on naming guidelines, one of our goals for Swift 3 is to “drop NS” for Foundation. We want to to make the cross-platform Foundation API that is available as part of swift-corelibs feel like it is not tied to just Darwin targets. We also want to reinforce the idea that new Foundation API must fit in with the language, standard library, and the rapidly evolving design patterns we see in the community.<br>&gt;&gt; <br>&gt;&gt; You challenged us on one part of this plan: some Foundation API just doesn’t “feel Swifty”, and a large part of the reason why is that it often does not have the same value type behavior as other Swift types. We took this feedback seriously, and I would like to share with you the start of an important journey for some of the most commonly used APIs on all of our platforms: adopting value semantics for key Foundation types.<br>&gt;&gt; <br>&gt;&gt; We have been working on this for some time now, and the set of diffs that result from this change is large. At this point, I am going to focus effort on an overview of the high level goals and not the individual API of each new type. In order to focus on delivering something up to our quality standards, we are intentionally leaving some class types as-is until a future proposal. If you don’t see your favorite class on the list — don’t despair. We are going to iterate on this over time. I see this as the start of the process.<br>&gt;&gt; <br>&gt;&gt; One process note: we are still trying to figure out the best way to integrate changes to API that ship as part of the operating system (which includes Foundation) into the swift-evolution review process. Swift-evolution is normally focused on changes to functionality in the compiler or standard library. In general, I don’t expect all new Foundation API introduced in the Darwin/Objective-C framework to go through the open source process. However, as we’ve brought up this topic here before, I felt it was important to bring this particular change to the swift-evolution list.<br>&gt;&gt; <br>&gt;&gt; As always I welcome your feedback.<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0069-swift-mutability-for-foundation.md<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; - Tony<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d9dbc0dfeb74eab8dd9bbd9cbd84680?s=50"></div><header><strong>Mutability for Foundation types in Swift</strong> from <string>Jose Cheyo Jimenez</string> &lt;cheyo at masters3d.com&gt;<p>April 22, 2016 at 02:00:00pm</p></header><div class="content"><p>Hi Tony, <br></p><p>Would value types like NSDateFormatterStyle or NSCalendarUnit etc get renamed with out `NS` in Swift ?<br></p><p>Would supporting classes to NSDate like NSDateComponents NSDateFormatter etc also get value semantics? <br></p><p>Thank you!<br></p><p><br>&gt; On Apr 22, 2016, at 10:18 AM, Tony Parker via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Dear swift-evolution denizens,<br>&gt; <br>&gt; As you know from our announcement of Swift Open Source and our work on naming guidelines, one of our goals for Swift 3 is to “drop NS” for Foundation. We want to to make the cross-platform Foundation API that is available as part of swift-corelibs feel like it is not tied to just Darwin targets. We also want to reinforce the idea that new Foundation API must fit in with the language, standard library, and the rapidly evolving design patterns we see in the community.<br>&gt; <br>&gt; You challenged us on one part of this plan: some Foundation API just doesn’t “feel Swifty”, and a large part of the reason why is that it often does not have the same value type behavior as other Swift types. We took this feedback seriously, and I would like to share with you the start of an important journey for some of the most commonly used APIs on all of our platforms: adopting value semantics for key Foundation types.<br>&gt; <br>&gt; We have been working on this for some time now, and the set of diffs that result from this change is large. At this point, I am going to focus effort on an overview of the high level goals and not the individual API of each new type. In order to focus on delivering something up to our quality standards, we are intentionally leaving some class types as-is until a future proposal. If you don’t see your favorite class on the list — don’t despair. We are going to iterate on this over time. I see this as the start of the process.<br>&gt; <br>&gt; One process note: we are still trying to figure out the best way to integrate changes to API that ship as part of the operating system (which includes Foundation) into the swift-evolution review process. Swift-evolution is normally focused on changes to functionality in the compiler or standard library. In general, I don’t expect all new Foundation API introduced in the Darwin/Objective-C framework to go through the open source process. However, as we’ve brought up this topic here before, I felt it was important to bring this particular change to the swift-evolution list.<br>&gt; <br>&gt; As always I welcome your feedback.<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0069-swift-mutability-for-foundation.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0069-swift-mutability-for-foundation.md&gt;<br>&gt; <br>&gt; Thanks,<br>&gt; - Tony<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160422/a5a92824/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be4c3c3b76631a155e1358db48066692?s=50"></div><header><strong>Mutability for Foundation types in Swift</strong> from <string>Tony Parker</string> &lt;anthony.parker at apple.com&gt;<p>April 22, 2016 at 02:00:00pm</p></header><div class="content"><p>Hi Jose,<br></p><p>&gt; On Apr 22, 2016, at 2:53 PM, Jose Cheyo Jimenez &lt;cheyo at masters3d.com&gt; wrote:<br>&gt; <br>&gt; Hi Tony, <br>&gt; <br>&gt; Would value types like NSDateFormatterStyle or NSCalendarUnit etc get renamed with out `NS` in Swift ?<br>&gt; <br></p><p>This, we are still iterating on in our team. I hope to have an update on that soon.<br></p><p>&gt; Would supporting classes to NSDate like NSDateComponents NSDateFormatter etc also get value semantics? <br>&gt; <br>&gt; Thank you!<br>&gt; <br></p><p>NSDateComponents will, but I forgot to put it on the list! Thanks for noticing that. I will fix it.<br></p><p>NSDateFormatter will remain a class type, at least for now. Formatters are part of a public class hierarchy (inheriting from NSFormatter), so if we want to turn them into value types I think we’ll need some additional motivation to change their API surface in this way.<br></p><p>Thanks,<br>- Tony<br></p><p>&gt; <br>&gt;&gt; On Apr 22, 2016, at 10:18 AM, Tony Parker via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Dear swift-evolution denizens,<br>&gt;&gt; <br>&gt;&gt; As you know from our announcement of Swift Open Source and our work on naming guidelines, one of our goals for Swift 3 is to “drop NS” for Foundation. We want to to make the cross-platform Foundation API that is available as part of swift-corelibs feel like it is not tied to just Darwin targets. We also want to reinforce the idea that new Foundation API must fit in with the language, standard library, and the rapidly evolving design patterns we see in the community.<br>&gt;&gt; <br>&gt;&gt; You challenged us on one part of this plan: some Foundation API just doesn’t “feel Swifty”, and a large part of the reason why is that it often does not have the same value type behavior as other Swift types. We took this feedback seriously, and I would like to share with you the start of an important journey for some of the most commonly used APIs on all of our platforms: adopting value semantics for key Foundation types.<br>&gt;&gt; <br>&gt;&gt; We have been working on this for some time now, and the set of diffs that result from this change is large. At this point, I am going to focus effort on an overview of the high level goals and not the individual API of each new type. In order to focus on delivering something up to our quality standards, we are intentionally leaving some class types as-is until a future proposal. If you don’t see your favorite class on the list — don’t despair. We are going to iterate on this over time. I see this as the start of the process.<br>&gt;&gt; <br>&gt;&gt; One process note: we are still trying to figure out the best way to integrate changes to API that ship as part of the operating system (which includes Foundation) into the swift-evolution review process. Swift-evolution is normally focused on changes to functionality in the compiler or standard library. In general, I don’t expect all new Foundation API introduced in the Darwin/Objective-C framework to go through the open source process. However, as we’ve brought up this topic here before, I felt it was important to bring this particular change to the swift-evolution list.<br>&gt;&gt; <br>&gt;&gt; As always I welcome your feedback.<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0069-swift-mutability-for-foundation.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0069-swift-mutability-for-foundation.md&gt;<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; - Tony<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160422/7c2fde85/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ac6593beac2a4da1e518e5001dbb2adc?s=50"></div><header><strong>Mutability for Foundation types in Swift</strong> from <string>Michael Buckley</string> &lt;michael at buckleyisms.com&gt;<p>April 22, 2016 at 03:00:00pm</p></header><div class="content"><p>Having read the proposal a couple times now, I like it, but I have couple<br>if small questions, and I&#39;m sure I&#39;ll have more in the next day or so. I&#39;m<br>going to refer to NSData et. al. in the questions because that&#39;s the<br>example given in the proposal, but these questions should be more widely<br>applicable.<br></p><p>First, relating to customizing the behavior though a custom subclass to<br>NSData, I&#39;m assuming that the as operator will box the instance of the<br>NSData subclass. That is, `MyData() as Data` will create a new instance of<br>MyData, a new instance of Data, and assign the MyData instance to the Data<br>instance&#39;s _box property.<br></p><p>If that&#39;s the case, why not make it more explicit that Data is wrapping<br>MyData and instead create an initializer for Data that takes the NSData<br>instance to wrap instead of using the as operator? It definitely matches<br>the use of the as operator from NSString to String, but that design<br>decision seems to predate a preference for initializers in type conversion,<br>and I&#39;m wondering if there&#39;s a disadvantage to initializers or an advantage<br>to the as operator that I&#39;m not seeing.<br></p><p>Second, let&#39;s say I have a MyMutableData class in Obj-C that&#39;s a subclass<br>of NSMutableData. I have an Objective-C method that returns an instance of<br>MyMutableData, and his function is called from Swift, and I do something<br>like `let foo = objCObj.objCMethod() as Data`. The foo instance is now<br>supposed to be immutable, but backed by a mutable Objective-C object. If I<br>then mutate the data in Objective-C, what happens?<br></p><p>If the answer to this is that the MyMutableData instance is copied in the<br>transfer from Objective-C to Swift so that mutations in Objective-C don&#39;t<br>affect the Swift instance, what about the case where I used `var foo`<br>instead of `let foo`? Does that mean that if I modify the data in<br>Objective-C that it won&#39;t get modified in Swift (and vice-versa)?<br></p><p><br>On Fri, Apr 22, 2016 at 10:18 AM, Tony Parker via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Dear swift-evolution denizens,<br>&gt;<br>&gt; As you know from our announcement of Swift Open Source and our work on<br>&gt; naming guidelines, one of our goals for Swift 3 is to “drop NS” for<br>&gt; Foundation. We want to to make the cross-platform Foundation API that is<br>&gt; available as part of swift-corelibs feel like it is not tied to just Darwin<br>&gt; targets. We also want to reinforce the idea that new Foundation API must<br>&gt; fit in with the language, standard library, and the rapidly evolving design<br>&gt; patterns we see in the community.<br>&gt;<br>&gt; You challenged us on one part of this plan: some Foundation API just<br>&gt; doesn’t “feel Swifty”, and a large part of the reason why is that it often<br>&gt; does not have the same value type behavior as other Swift types. We took<br>&gt; this feedback seriously, and I would like to share with you the start of an<br>&gt; important journey for some of the most commonly used APIs on all of our<br>&gt; platforms: adopting value semantics for key Foundation types.<br>&gt;<br>&gt; We have been working on this for some time now, and the set of diffs that<br>&gt; result from this change is large. At this point, I am going to focus effort<br>&gt; on an overview of the high level goals and not the individual API of each<br>&gt; new type. In order to focus on delivering something up to our quality<br>&gt; standards, we are intentionally leaving some class types as-is until a<br>&gt; future proposal. If you don’t see your favorite class on the list — don’t<br>&gt; despair. We are going to iterate on this over time. I see this as the start<br>&gt; of the process.<br>&gt;<br>&gt; One process note: we are still trying to figure out the best way to<br>&gt; integrate changes to API that ship as part of the operating system (which<br>&gt; includes Foundation) into the swift-evolution review process.<br>&gt; Swift-evolution is normally focused on changes to functionality in the<br>&gt; compiler or standard library. In general, I don’t expect all new Foundation<br>&gt; API introduced in the Darwin/Objective-C framework to go through the open<br>&gt; source process. However, as we’ve brought up this topic here before, I felt<br>&gt; it was important to bring this particular change to the swift-evolution<br>&gt; list.<br>&gt;<br>&gt; As always I welcome your feedback.<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0069-swift-mutability-for-foundation.md<br>&gt;<br>&gt; Thanks,<br>&gt; - Tony<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160422/0c62df4d/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Mutability for Foundation types in Swift</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April 24, 2016 at 03:00:00am</p></header><div class="content"><p>&gt; We took this feedback seriously, and I would like to share with you the start of an important journey for some of the most commonly used APIs on all of our platforms: adopting value semantics for key Foundation types.<br></p><p>This proposal is way cool, and I think you&#39;ve selected a great starting set of APIs.<br></p><p>Of the other candidate APIs you mentioned, I&#39;m definitely looking forward to AttributedString and some parts of the NSURL Loading system (primarily the requests and responses; the connections and sessions should probably be object types). Predicate, OrderedSet, CountedSet, and possibly Number and Value make sense as well.<br></p><p>However, I think that Locale, Progress, Operation, Calendar, and Port are poor candidates for becoming value types, because they represent specific resources which may be partially outside of your thread&#39;s/process&#39;s control; that is, they&#39;re rather like NS/UIView, in that they represent a specific, identifiable &quot;thing&quot; which cannot be copied without losing some aspect of its meaning. (I also see little value in an Error type; honestly, in the long run I&#39;d like to see Swift-facing Foundation grow towards pretending that NSError doesn&#39;t exist and only ErrorProtocol does.)<br></p><p>&gt; The following code is a more natural match for the way Swift developers would expect this to work:<br>&gt; <br>&gt; 	var myDate = Date()<br>&gt; 	myDate.addTimeInterval(60) // OK<br>&gt; 	<br>&gt; 	let myOtherDate = Date()<br>&gt; 	myOtherDate.addTimeInterval(60) // Error, as expected<br></p><p>The semantic is definitely more what Swift users expect, but the name may not be. As far as I can tell, this method should be called `add`, with `TimeInterval` elided under the &quot;omit needless words&quot; rule of Swift API translation. (Or just call it `+=`, of course...)<br></p><p>&gt; URL		NSURL<br>&gt; URLComponents	NSURLComponents<br></p><p><br>Have you considered unifying these? NSURL has no mutable counterpart, but NSURLComponents sort of informally plays that role. As it is, it seems like URL would not really be able to support mutation very well—the operations would all be nonmutating under the hood.<br></p><p>&gt; Using Swift structures for our smallest types can be as effective as using tagged pointers in Objective-C.<br></p><p><br>Have you looked at the performance and size of your value type designs when they&#39;re made Optional? In the general case, Optional works by adding a tag byte after the wrapped instance, but for reference types it uses the 0x0 address instead. Thus, depending on how they&#39;re designed and where Swift is clever enough to find memory savings, these value types might end up taking more memory than the corresponding reference types when made Optional, particularly if the reference types have tagged pointer representations.<br></p><p>&gt;     if !isUniquelyReferencedNonObjC(&amp;_box) {<br></p><p><br>Something I have often wondered about: Why doesn&#39;t `isUniquelyReferenced(_:)` use `-retainCount` on Objective-C objects? Alternatively, why not use `-retainCount` on fields in your value types when you&#39;re trying to implement COW behavior? It seems like that would allow you to extend the copy-on-write mechanism to Objective-C objects. I know that `-retainCount` is usually not very useful, but surely this copy-on-write situation, where you are using it in an advisory fashion and an overestimated retain count will simply cause you to unnecessarily lose some efficiency, is the exception to the rule?<br></p><p>There are likely good reasons for this decision—they simply aren&#39;t obvious, and I&#39;d like to understand them.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be4c3c3b76631a155e1358db48066692?s=50"></div><header><strong>Mutability for Foundation types in Swift</strong> from <string>Tony Parker</string> &lt;anthony.parker at apple.com&gt;<p>April 25, 2016 at 09:00:00am</p></header><div class="content"><p>Hi Brent,<br></p><p>Thanks for your feedback! You’ve got some great questions below, I’ll try to answer them as best I can.<br></p><p>&gt; On Apr 24, 2016, at 3:44 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; We took this feedback seriously, and I would like to share with you the start of an important journey for some of the most commonly used APIs on all of our platforms: adopting value semantics for key Foundation types.<br>&gt; <br>&gt; This proposal is way cool, and I think you&#39;ve selected a great starting set of APIs.<br>&gt; <br>&gt; Of the other candidate APIs you mentioned, I&#39;m definitely looking forward to AttributedString and some parts of the NSURL Loading system (primarily the requests and responses; the connections and sessions should probably be object types). Predicate, OrderedSet, CountedSet, and possibly Number and Value make sense as well.<br>&gt; <br>&gt; However, I think that Locale, Progress, Operation, Calendar, and Port are poor candidates for becoming value types, because they represent specific resources which may be partially outside of your thread&#39;s/process&#39;s control; that is, they&#39;re rather like NS/UIView, in that they represent a specific, identifiable &quot;thing&quot; which cannot be copied without losing some aspect of its meaning.<br></p><p>Agreed, that is why they are at the bottom in the “not value types” section. =)<br></p><p>&gt; (I also see little value in an Error type; honestly, in the long run I&#39;d like to see Swift-facing Foundation grow towards pretending that NSError doesn&#39;t exist and only ErrorProtocol does.)<br>&gt; <br></p><p>ErrorProtocol is a kind-of-NSError today, as the compiler magically generates the two NSError primitives for you (code and domain), but does not expose this anywhere to make it possible to do the correct thing w.r.t. localized error messages.<br></p><p>Anyway this is a complicated topic, which is why I deferred it to another proposal.<br></p><p>&gt;&gt; The following code is a more natural match for the way Swift developers would expect this to work:<br>&gt;&gt; <br>&gt;&gt; 	var myDate = Date()<br>&gt;&gt; 	myDate.addTimeInterval(60) // OK<br>&gt;&gt; 	<br>&gt;&gt; 	let myOtherDate = Date()<br>&gt;&gt; 	myOtherDate.addTimeInterval(60) // Error, as expected<br>&gt; <br>&gt; The semantic is definitely more what Swift users expect, but the name may not be. As far as I can tell, this method should be called `add`, with `TimeInterval` elided under the &quot;omit needless words&quot; rule of Swift API translation. (Or just call it `+=`, of course…)<br></p><p>The actual API uses +=, this is just an example to prove a point.<br></p><p>&gt; <br>&gt;&gt; URL		NSURL<br>&gt;&gt; URLComponents	NSURLComponents<br>&gt; <br>&gt; <br>&gt; Have you considered unifying these? NSURL has no mutable counterpart, but NSURLComponents sort of informally plays that role. As it is, it seems like URL would not really be able to support mutation very well—the operations would all be nonmutating under the hood.<br>&gt; <br></p><p>The pattern here is that URLComponents properties are basically the arguments to a factory that creates URL. They aren’t really the same thing as a URL itself. Also, like DateComponents or PersonNameComponents, you may want to represent a “partial URL” as some kind of intermediate object, in which case a URLComponents would be the right type because a URL should be valid.<br></p><p>&gt;&gt; Using Swift structures for our smallest types can be as effective as using tagged pointers in Objective-C.<br>&gt; <br>&gt; <br>&gt; Have you looked at the performance and size of your value type designs when they&#39;re made Optional? In the general case, Optional works by adding a tag byte after the wrapped instance, but for reference types it uses the 0x0 address instead. Thus, depending on how they&#39;re designed and where Swift is clever enough to find memory savings, these value types might end up taking more memory than the corresponding reference types when made Optional, particularly if the reference types have tagged pointer representations.<br>&gt; <br></p><p>That’s true, but not all reference types wind up as tagged pointers either. NSString, for example, does it based on the content and length of the C string.<br></p><p>I’m ok with the tradeoff here for the few types we have in this category (primarily Date).<br></p><p>&gt;&gt;    if !isUniquelyReferencedNonObjC(&amp;_box) {<br>&gt; <br>&gt; <br>&gt; Something I have often wondered about: Why doesn&#39;t `isUniquelyReferenced(_:)` use `-retainCount` on Objective-C objects? Alternatively, why not use `-retainCount` on fields in your value types when you&#39;re trying to implement COW behavior? It seems like that would allow you to extend the copy-on-write mechanism to Objective-C objects. I know that `-retainCount` is usually not very useful, but surely this copy-on-write situation, where you are using it in an advisory fashion and an overestimated retain count will simply cause you to unnecessarily lose some efficiency, is the exception to the rule?<br>&gt; <br>&gt; There are likely good reasons for this decision—they simply aren&#39;t obvious, and I&#39;d like to understand them.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br></p><p>There are a few reasons for this, but the one that sticks out most to me is that in Objective-C, retain, release, and retainCount don’t include weak references. If you take a look at the internals for the swift retain count function, you’ll see that there are two: owned and unowned.<br></p><p>- Tony<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Mutability for Foundation types in Swift</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>April 25, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Apr 25, 2016, at 9:20 AM, Tony Parker via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi Brent,<br>&gt; <br>&gt; Thanks for your feedback! You’ve got some great questions below, I’ll try to answer them as best I can.<br>&gt; <br>&gt;&gt; On Apr 24, 2016, at 3:44 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; We took this feedback seriously, and I would like to share with you the start of an important journey for some of the most commonly used APIs on all of our platforms: adopting value semantics for key Foundation types.<br>&gt;&gt; <br>&gt;&gt; This proposal is way cool, and I think you&#39;ve selected a great starting set of APIs.<br>&gt;&gt; <br>&gt;&gt; Of the other candidate APIs you mentioned, I&#39;m definitely looking forward to AttributedString and some parts of the NSURL Loading system (primarily the requests and responses; the connections and sessions should probably be object types). Predicate, OrderedSet, CountedSet, and possibly Number and Value make sense as well.<br>&gt;&gt; <br>&gt;&gt; However, I think that Locale, Progress, Operation, Calendar, and Port are poor candidates for becoming value types, because they represent specific resources which may be partially outside of your thread&#39;s/process&#39;s control; that is, they&#39;re rather like NS/UIView, in that they represent a specific, identifiable &quot;thing&quot; which cannot be copied without losing some aspect of its meaning.<br>&gt; <br>&gt;&gt;&gt;   if !isUniquelyReferencedNonObjC(&amp;_box) {<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Something I have often wondered about: Why doesn&#39;t `isUniquelyReferenced(_:)` use `-retainCount` on Objective-C objects? Alternatively, why not use `-retainCount` on fields in your value types when you&#39;re trying to implement COW behavior? It seems like that would allow you to extend the copy-on-write mechanism to Objective-C objects. I know that `-retainCount` is usually not very useful, but surely this copy-on-write situation, where you are using it in an advisory fashion and an overestimated retain count will simply cause you to unnecessarily lose some efficiency, is the exception to the rule?<br>&gt;&gt; <br>&gt;&gt; There are likely good reasons for this decision—they simply aren&#39;t obvious, and I&#39;d like to understand them.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt; <br>&gt; There are a few reasons for this, but the one that sticks out most to me is that in Objective-C, retain, release, and retainCount don’t include weak references. If you take a look at the internals for the swift retain count function, you’ll see that there are two: owned and unowned.<br></p><p><br>Right. I went down this rabbit hole a few weeks ago, trying to determine if we could make an “isUniquelyReferenced” that works for Objective-C-defined classes. One obvious issue is that you can’t always trust retainCount to do the right thing for an arbitrary Objective-C class, because it may have been overridden. We can probably say “don’t do that” and get away with it, but that brings us to Tony’s point: Objective-C weak references are stored in a separate side table, so we can’t atomically determine whether an Objective-C class is uniquely referenced. On platforms that have a non-pointer “isa” we could make this work through the inline reference count (which requires changes to the Objective-C runtime and therefore wouldn’t support backward deployment), but that still doesn’t give us “isUniquelyReferenced” for Objective-C classes everywhere.<br></p><p>Interestingly, while Swift’s object layout gives us the ability to consider the weak reference count, the Swift runtime currently does not do so. IIRC, part of our reasoning was that isUniquelyReferencedNonObjC is generally there to implement copy-on-write, where weak references aren’t actually interesting. However, we weren’t comfortable enough in that logic to commit to excluding weak references from isUniquelyReferencedNonObjC “forever&quot;, and certainly aren’t comfortable enough in that reasoning to enshrine “excluding weak references” as part of the semantics of isUniquelyReference for Objective-C classes.<br></p><p>	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160425/f7e462f0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Mutability for Foundation types in Swift</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>April 25, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Apr 25, 2016, at 10:32 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; On Apr 25, 2016, at 9:20 AM, Tony Parker via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi Brent,<br>&gt;&gt; <br>&gt;&gt; Thanks for your feedback! You’ve got some great questions below, I’ll try to answer them as best I can.<br>&gt;&gt; <br>&gt;&gt;&gt; On Apr 24, 2016, at 3:44 AM, Brent Royal-Gordon &lt;brent at architechies.com &lt;mailto:brent at architechies.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We took this feedback seriously, and I would like to share with you the start of an important journey for some of the most commonly used APIs on all of our platforms: adopting value semantics for key Foundation types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This proposal is way cool, and I think you&#39;ve selected a great starting set of APIs.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Of the other candidate APIs you mentioned, I&#39;m definitely looking forward to AttributedString and some parts of the NSURL Loading system (primarily the requests and responses; the connections and sessions should probably be object types). Predicate, OrderedSet, CountedSet, and possibly Number and Value make sense as well.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However, I think that Locale, Progress, Operation, Calendar, and Port are poor candidates for becoming value types, because they represent specific resources which may be partially outside of your thread&#39;s/process&#39;s control; that is, they&#39;re rather like NS/UIView, in that they represent a specific, identifiable &quot;thing&quot; which cannot be copied without losing some aspect of its meaning.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt;   if !isUniquelyReferencedNonObjC(&amp;_box) {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Something I have often wondered about: Why doesn&#39;t `isUniquelyReferenced(_:)` use `-retainCount` on Objective-C objects? Alternatively, why not use `-retainCount` on fields in your value types when you&#39;re trying to implement COW behavior? It seems like that would allow you to extend the copy-on-write mechanism to Objective-C objects. I know that `-retainCount` is usually not very useful, but surely this copy-on-write situation, where you are using it in an advisory fashion and an overestimated retain count will simply cause you to unnecessarily lose some efficiency, is the exception to the rule?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are likely good reasons for this decision—they simply aren&#39;t obvious, and I&#39;d like to understand them.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; There are a few reasons for this, but the one that sticks out most to me is that in Objective-C, retain, release, and retainCount don’t include weak references. If you take a look at the internals for the swift retain count function, you’ll see that there are two: owned and unowned.<br>&gt; <br>&gt; <br>&gt; Right. I went down this rabbit hole a few weeks ago, trying to determine if we could make an “isUniquelyReferenced” that works for Objective-C-defined classes. One obvious issue is that you can’t always trust retainCount to do the right thing for an arbitrary Objective-C class, because it may have been overridden. We can probably say “don’t do that” and get away with it, but that brings us to Tony’s point: Objective-C weak references are stored in a separate side table, so we can’t atomically determine whether an Objective-C class is uniquely referenced. On platforms that have a non-pointer “isa” we could make this work through the inline reference count (which requires changes to the Objective-C runtime and therefore wouldn’t support backward deployment), but that still doesn’t give us “isUniquelyReferenced” for Objective-C classes everywhere.<br></p><p>It&#39;s arguably not necessary to do this check atomically with respect to concurrent attempts to retain/release:<br>  - If somebody is racing to increase the reference count to 2, they must be copying this variable.<br>  - If somebody is racing to increase the reference count to &gt; 2, our reference is non-unique either way.<br>  - If somebody is racing to decrease the reference count to 1, then we either do an over-safe copy or we get lucky avoiding it.<br>  - If somebody is racing to decrease the reference count to 1, they must be mutating this variable.<br>We only do this uniqueness check when mutating the variable, so a concurrent attempt to copy or mutate it is an illegal read/write or write/write race.<br></p><p>Weak references are potentially a different story, both semantically and in terms of concurrency.  There could be an outstanding weak reference that somebody could be concurrently loading (and hence retaining), breaking the assumption in the first bullet above.  The only way to fix that is to treat weak references as making strong references non-unique, and AFAIK we have no way of detecting the non-existence of weak references on existing operating systems.  But it&#39;s not clear to me that we need to give this much weight to weak references; after all, it&#39;s equally possible to form unsafe references to existing objects, which is completely undetectable, and we&#39;ve traditionally described that as just an unsafe weak reference.<br></p><p>You have to come up with fairly contrived use cases for weak references to see problems with just ignoring them, like a memoization table that maintains both strong and weak references but drops the strong references when there&#39;s memory pressure.  In this case, our value type might end up with the last strong reference, and changing the object in-place would corrupt the cached value.  But this would be a really odd way to implement a memoization table, basically just using weak references for their own sake.<br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160425/d17960f7/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>Mutability for Foundation types in Swift</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>April 25, 2016 at 08:00:00pm</p></header><div class="content"><p>There aren’t enough +1s in the world for this, I fully endorse your proposal and would like to subscribe to your newsletter ;)<br></p><p>Do you envision the apinotes will be the vehicle for performing the bridging since ObjectiveCBridgeable was deferred? I actually haven’t checked if that was merged but left as a private protocol or if it still only works in collections.<br></p><p>Russ<br></p><p><br>&gt; On Apr 22, 2016, at 10:18 AM, Tony Parker via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Dear swift-evolution denizens,<br>&gt; <br>&gt; As you know from our announcement of Swift Open Source and our work on naming guidelines, one of our goals for Swift 3 is to “drop NS” for Foundation. We want to to make the cross-platform Foundation API that is available as part of swift-corelibs feel like it is not tied to just Darwin targets. We also want to reinforce the idea that new Foundation API must fit in with the language, standard library, and the rapidly evolving design patterns we see in the community.<br>&gt; <br>&gt; You challenged us on one part of this plan: some Foundation API just doesn’t “feel Swifty”, and a large part of the reason why is that it often does not have the same value type behavior as other Swift types. We took this feedback seriously, and I would like to share with you the start of an important journey for some of the most commonly used APIs on all of our platforms: adopting value semantics for key Foundation types.<br>&gt; <br>&gt; We have been working on this for some time now, and the set of diffs that result from this change is large. At this point, I am going to focus effort on an overview of the high level goals and not the individual API of each new type. In order to focus on delivering something up to our quality standards, we are intentionally leaving some class types as-is until a future proposal. If you don’t see your favorite class on the list — don’t despair. We are going to iterate on this over time. I see this as the start of the process.<br>&gt; <br>&gt; One process note: we are still trying to figure out the best way to integrate changes to API that ship as part of the operating system (which includes Foundation) into the swift-evolution review process. Swift-evolution is normally focused on changes to functionality in the compiler or standard library. In general, I don’t expect all new Foundation API introduced in the Darwin/Objective-C framework to go through the open source process. However, as we’ve brought up this topic here before, I felt it was important to bring this particular change to the swift-evolution list.<br>&gt; <br>&gt; As always I welcome your feedback.<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0069-swift-mutability-for-foundation.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0069-swift-mutability-for-foundation.md&gt;<br>&gt; <br>&gt; Thanks,<br>&gt; - Tony<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160425/c8be4d08/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Mutability for Foundation types in Swift</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>April 25, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Apr 25, 2016, at 8:39 PM, Russ Bishop via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; There aren’t enough +1s in the world for this, I fully endorse your proposal and would like to subscribe to your newsletter ;)<br>&gt; <br>&gt; Do you envision the apinotes will be the vehicle for performing the bridging since ObjectiveCBridgeable was deferred? I actually haven’t checked if that was merged but left as a private protocol or if it still only works in collections.<br></p><p>_ObjectiveCBridgeable is still there, and despite the underscore and the fact that it doesn’t match the interface in the deferred proposal, it’s essentially fully implemented. The Clang side (swift_bridge attribute) is in swift-clang, and there is API notes support for adding it without modifying headers.<br></p><p>	- Doug<br></p><p>&gt; <br>&gt; Russ<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 22, 2016, at 10:18 AM, Tony Parker via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Dear swift-evolution denizens,<br>&gt;&gt; <br>&gt;&gt; As you know from our announcement of Swift Open Source and our work on naming guidelines, one of our goals for Swift 3 is to “drop NS” for Foundation. We want to to make the cross-platform Foundation API that is available as part of swift-corelibs feel like it is not tied to just Darwin targets. We also want to reinforce the idea that new Foundation API must fit in with the language, standard library, and the rapidly evolving design patterns we see in the community.<br>&gt;&gt; <br>&gt;&gt; You challenged us on one part of this plan: some Foundation API just doesn’t “feel Swifty”, and a large part of the reason why is that it often does not have the same value type behavior as other Swift types. We took this feedback seriously, and I would like to share with you the start of an important journey for some of the most commonly used APIs on all of our platforms: adopting value semantics for key Foundation types.<br>&gt;&gt; <br>&gt;&gt; We have been working on this for some time now, and the set of diffs that result from this change is large. At this point, I am going to focus effort on an overview of the high level goals and not the individual API of each new type. In order to focus on delivering something up to our quality standards, we are intentionally leaving some class types as-is until a future proposal. If you don’t see your favorite class on the list — don’t despair. We are going to iterate on this over time. I see this as the start of the process.<br>&gt;&gt; <br>&gt;&gt; One process note: we are still trying to figure out the best way to integrate changes to API that ship as part of the operating system (which includes Foundation) into the swift-evolution review process. Swift-evolution is normally focused on changes to functionality in the compiler or standard library. In general, I don’t expect all new Foundation API introduced in the Darwin/Objective-C framework to go through the open source process. However, as we’ve brought up this topic here before, I felt it was important to bring this particular change to the swift-evolution list.<br>&gt;&gt; <br>&gt;&gt; As always I welcome your feedback.<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0069-swift-mutability-for-foundation.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0069-swift-mutability-for-foundation.md&gt;<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; - Tony<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160425/c9638cc0/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
