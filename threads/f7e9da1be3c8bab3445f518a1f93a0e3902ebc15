<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Philosophy question: Foundation and Standard Library</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>December 31, 2015 at 03:00:00pm</p></header><div class="content"><p>Under what criteria should we propose moving items into the standard library and out from the standard library into Swift Foundation? Or will these things eventually merge and become one grand unified module sometime in the distant future?<br></p><p>Thanks, -- E<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Philosophy question: Foundation and Standard Library</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January  1, 2016 at 03:00:00pm</p></header><div class="content"><p>My understanding is that Foundation closely maps to the ObjC Foundation framework.<br></p><p>Félix<br></p><p>&gt; Le 31 déc. 2015 à 17:54:39, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Under what criteria should we propose moving items into the standard library and out from the standard library into Swift Foundation? Or will these things eventually merge and become one grand unified module sometime in the distant future?<br>&gt; <br>&gt; Thanks, -- E<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Philosophy question: Foundation and Standard Library</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January  1, 2016 at 12:00:00pm</p></header><div class="content"><p>On Dec 31, 2015, at 2:54 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Under what criteria should we propose moving items into the standard library and out from the standard library into Swift Foundation? Or will these things eventually merge and become one grand unified module sometime in the distant future?<br></p><p>Hi Erica,<br></p><p>I don’t see any specific reason to merge the stdlib and Foundation together - it seems like Foundation depending on the swift stdlib is proper layering.  Lets look at the mission of both of these libraries:<br></p><p>For the Swift standard library, we want it to stay focused on the lowest-level “language support” primitives that includes things like Int, Array, Dictionary, OptionSet and the stuff they depend on (sequences etc).  Even though they are implemented in the stdlib, I consider to be part of the the language.  While we may elect to allow some minor scope creep, this will be carefully scrutinized and needs to be strongly justified.<br></p><p>For Foundation, there may be differing short-term and long-term answers here.  In the short-term, the corelibs projects have a very specific focus, which is to enable cross-platform Swift development by making common Foundation APIs available on other platforms.  This is a pretty huge project, so it is important that we keep focused on making this happen, even though folks have the natural inclination to do “new” things as well.<br></p><p>In this short term, I see SwiftPM as a great solution to avoid having to cram “everything interesting” into the standard library or Foundation.  Once SwiftPM is ready, there should be very little downside to something being a package hosted on github or elsewhere.<br></p><p><br>In the longer term, we’ll have to see what happens, and make a decision that makes sense given the direction the project takes.  We may decide to start adding new functionality to Foundation that doesn’t exist on Apple platforms yet (with the understanding that they will adopt it as well).  We may decide to “standardize” new corelibs from existing popular packages, if they are outside of the scope of Foundation (totally random example: perhaps a web templating framework).<br></p><p>Putting something into the standard Swift distribution (instead of it being an independent package) comes with pros and cons.  On the positive side, we want an official Swift release (e.g. &quot;Swift 3.0”) to provide a consistent set of APIs out of the box that are guaranteed to be there.  Getting your cool thing into the Swift distro guarantees that it will be available everywhere.  On the downside, this is a bad way to go for rapidly evolving APIs in multiple ways: first, Swift has relatively infrequent updates (e.g. twice a year at current cadence) so it will take a long time to get changes out.  Second, *changing* an API included in the Swift distribution will be comparatively hard.  Instead of bumping the major version number of a package, it will have to go through a (TBD) lengthy deprecation process that will likely span multiple years.<br></p><p>In any case, we’ll figure it out as we go.  We don’t have all the answers, and we’re learning too.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c40db4457ab2c91a0d8006da31b177c6?s=50"></div><header><strong>Philosophy question: Foundation and Standard Library</strong> from <string>Trent Nadeau</string> &lt;tanadeau at gmail.com&gt;<p>January  1, 2016 at 03:00:00pm</p></header><div class="content"><p>Speaking of release cadence, do you think that Swift could transition to<br>the release train model (i.e., staged release, beta, and nightly) once<br>source and ABI compatibility are both established? That would allow a<br>quicker cadence and more testing of new library and language features. It&#39;s<br>seems to be working well with Rust so far, at least.<br></p><p>On Fri, Jan 1, 2016 at 3:46 PM, Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Dec 31, 2015, at 2:54 PM, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; Under what criteria should we propose moving items into the standard<br>&gt; library and out from the standard library into Swift Foundation? Or will<br>&gt; these things eventually merge and become one grand unified module sometime<br>&gt; in the distant future?<br>&gt;<br>&gt; Hi Erica,<br>&gt;<br>&gt; I don’t see any specific reason to merge the stdlib and Foundation<br>&gt; together - it seems like Foundation depending on the swift stdlib is proper<br>&gt; layering.  Lets look at the mission of both of these libraries:<br>&gt;<br>&gt; For the Swift standard library, we want it to stay focused on the<br>&gt; lowest-level “language support” primitives that includes things like Int,<br>&gt; Array, Dictionary, OptionSet and the stuff they depend on (sequences etc).<br>&gt; Even though they are implemented in the stdlib, I consider to be part of<br>&gt; the the language.  While we may elect to allow some minor scope creep, this<br>&gt; will be carefully scrutinized and needs to be strongly justified.<br>&gt;<br>&gt; For Foundation, there may be differing short-term and long-term answers<br>&gt; here.  In the short-term, the corelibs projects have a very specific focus,<br>&gt; which is to enable cross-platform Swift development by making common<br>&gt; Foundation APIs available on other platforms.  This is a pretty huge<br>&gt; project, so it is important that we keep focused on making this happen,<br>&gt; even though folks have the natural inclination to do “new” things as well.<br>&gt;<br>&gt; In this short term, I see SwiftPM as a great solution to avoid having to<br>&gt; cram “everything interesting” into the standard library or Foundation.<br>&gt; Once SwiftPM is ready, there should be very little downside to something<br>&gt; being a package hosted on github or elsewhere.<br>&gt;<br>&gt;<br>&gt; In the longer term, we’ll have to see what happens, and make a decision<br>&gt; that makes sense given the direction the project takes.  We may decide to<br>&gt; start adding new functionality to Foundation that doesn’t exist on Apple<br>&gt; platforms yet (with the understanding that they will adopt it as well).  We<br>&gt; may decide to “standardize” new corelibs from existing popular packages, if<br>&gt; they are outside of the scope of Foundation (totally random example:<br>&gt; perhaps a web templating framework).<br>&gt;<br>&gt; Putting something into the standard Swift distribution (instead of it<br>&gt; being an independent package) comes with pros and cons.  On the positive<br>&gt; side, we want an official Swift release (e.g. &quot;Swift 3.0”) to provide a<br>&gt; consistent set of APIs out of the box that are guaranteed to be there.<br>&gt; Getting your cool thing into the Swift distro guarantees that it will be<br>&gt; available everywhere.  On the downside, this is a bad way to go for rapidly<br>&gt; evolving APIs in multiple ways: first, Swift has relatively infrequent<br>&gt; updates (e.g. twice a year at current cadence) so it will take a long time<br>&gt; to get changes out.  Second, *changing* an API included in the Swift<br>&gt; distribution will be comparatively hard.  Instead of bumping the major<br>&gt; version number of a package, it will have to go through a (TBD) lengthy<br>&gt; deprecation process that will likely span multiple years.<br>&gt;<br>&gt; In any case, we’ll figure it out as we go.  We don’t have all the answers,<br>&gt; and we’re learning too.<br>&gt;<br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br></p><p>-- <br>Trent Nadeau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160101/deb50cd5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Philosophy question: Foundation and Standard Library</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January  1, 2016 at 01:00:00pm</p></header><div class="content"><p>On Jan 1, 2016, at 12:56 PM, Trent Nadeau &lt;tanadeau at gmail.com&gt; wrote:<br>&gt; Speaking of release cadence, do you think that Swift could transition to the release train model (i.e., staged release, beta, and nightly) once source and ABI compatibility are both established? That would allow a quicker cadence and more testing of new library and language features. It&#39;s seems to be working well with Rust so far, at least.<br></p><p>Anything is possible, we’re always open to good ideas.<br></p><p>-Chris<br></p><p>&gt; <br>&gt; On Fri, Jan 1, 2016 at 3:46 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; On Dec 31, 2015, at 2:54 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt; Under what criteria should we propose moving items into the standard library and out from the standard library into Swift Foundation? Or will these things eventually merge and become one grand unified module sometime in the distant future?<br>&gt; <br>&gt; Hi Erica,<br>&gt; <br>&gt; I don’t see any specific reason to merge the stdlib and Foundation together - it seems like Foundation depending on the swift stdlib is proper layering.  Lets look at the mission of both of these libraries:<br>&gt; <br>&gt; For the Swift standard library, we want it to stay focused on the lowest-level “language support” primitives that includes things like Int, Array, Dictionary, OptionSet and the stuff they depend on (sequences etc).  Even though they are implemented in the stdlib, I consider to be part of the the language.  While we may elect to allow some minor scope creep, this will be carefully scrutinized and needs to be strongly justified.<br>&gt; <br>&gt; For Foundation, there may be differing short-term and long-term answers here.  In the short-term, the corelibs projects have a very specific focus, which is to enable cross-platform Swift development by making common Foundation APIs available on other platforms.  This is a pretty huge project, so it is important that we keep focused on making this happen, even though folks have the natural inclination to do “new” things as well.<br>&gt; <br>&gt; In this short term, I see SwiftPM as a great solution to avoid having to cram “everything interesting” into the standard library or Foundation.  Once SwiftPM is ready, there should be very little downside to something being a package hosted on github or elsewhere.<br>&gt; <br>&gt; <br>&gt; In the longer term, we’ll have to see what happens, and make a decision that makes sense given the direction the project takes.  We may decide to start adding new functionality to Foundation that doesn’t exist on Apple platforms yet (with the understanding that they will adopt it as well).  We may decide to “standardize” new corelibs from existing popular packages, if they are outside of the scope of Foundation (totally random example: perhaps a web templating framework).<br>&gt; <br>&gt; Putting something into the standard Swift distribution (instead of it being an independent package) comes with pros and cons.  On the positive side, we want an official Swift release (e.g. &quot;Swift 3.0”) to provide a consistent set of APIs out of the box that are guaranteed to be there.  Getting your cool thing into the Swift distro guarantees that it will be available everywhere.  On the downside, this is a bad way to go for rapidly evolving APIs in multiple ways: first, Swift has relatively infrequent updates (e.g. twice a year at current cadence) so it will take a long time to get changes out.  Second, *changing* an API included in the Swift distribution will be comparatively hard.  Instead of bumping the major version number of a package, it will have to go through a (TBD) lengthy deprecation process that will likely span multiple years.<br>&gt; <br>&gt; In any case, we’ll figure it out as we go.  We don’t have all the answers, and we’re learning too.<br>&gt; <br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Trent Nadeau<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160101/c83273c0/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Philosophy question: Foundation and Standard Library</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>January  1, 2016 at 03:00:00pm</p></header><div class="content"><p>Thanks Chris.  I want to figure out what the guiding principles are before I blow any further proposal-capital. This gives me a good place to start chewing on some thoughts.  In particular, I&#39;m considering two scenarios.<br></p><p>First, are things that seem unnaturally split between both places, such as &quot;joinWithSeparator&quot; (stdlib, seq type) and &quot;componentsSeparatedByString&quot; (fnd, NSString). The latter super non-Swifty but could easily evolve to be componentsSeparatedBySequence and rangeOfSequence. (We had some nifty attempts at this last night on #swift-lang in terms of trying to do this with reasonable speed.) <br></p><p>Second, is how to push on what to add -- particularly for integrating proposals from the rich libraries of other languages. I&#39;m interpreting what you wrote as that a standard library should be as flexible and widely applicable as possible while being implemented with the fewest possible moving parts (&quot;stay focused on the lowest-level “language support” primitives&quot;) <br></p><p>This is counter to having to cram everything interesting into the standard library or Foundation but opens the possibility of creating standard Ruby-esque, Rust-esque, Haskell-esque, etc. packages, right? I&#39;m going to take a wild guess that these latter items would have to be self organizing and fall outside the umbrella of Swift and Swift-Evolution. For this bit, I&#39;m going to defer to Kevin, etc for figuring out what would be awesome to add in.<br></p><p>-- E<br></p><p><br>&gt; On Jan 1, 2016, at 1:46 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; On Dec 31, 2015, at 2:54 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Under what criteria should we propose moving items into the standard library and out from the standard library into Swift Foundation? Or will these things eventually merge and become one grand unified module sometime in the distant future?<br>&gt; <br>&gt; Hi Erica,<br>&gt; <br>&gt; I don’t see any specific reason to merge the stdlib and Foundation together - it seems like Foundation depending on the swift stdlib is proper layering.  Lets look at the mission of both of these libraries:<br>&gt; <br>&gt; For the Swift standard library, we want it to stay focused on the lowest-level “language support” primitives that includes things like Int, Array, Dictionary, OptionSet and the stuff they depend on (sequences etc).  Even though they are implemented in the stdlib, I consider to be part of the the language.  While we may elect to allow some minor scope creep, this will be carefully scrutinized and needs to be strongly justified.<br>&gt; <br>&gt; For Foundation, there may be differing short-term and long-term answers here.  In the short-term, the corelibs projects have a very specific focus, which is to enable cross-platform Swift development by making common Foundation APIs available on other platforms.  This is a pretty huge project, so it is important that we keep focused on making this happen, even though folks have the natural inclination to do “new” things as well.<br>&gt; <br>&gt; In this short term, I see SwiftPM as a great solution to avoid having to cram “everything interesting” into the standard library or Foundation.  Once SwiftPM is ready, there should be very little downside to something being a package hosted on github or elsewhere.<br>&gt; <br>&gt; <br>&gt; In the longer term, we’ll have to see what happens, and make a decision that makes sense given the direction the project takes.  We may decide to start adding new functionality to Foundation that doesn’t exist on Apple platforms yet (with the understanding that they will adopt it as well).  We may decide to “standardize” new corelibs from existing popular packages, if they are outside of the scope of Foundation (totally random example: perhaps a web templating framework).<br>&gt; <br>&gt; Putting something into the standard Swift distribution (instead of it being an independent package) comes with pros and cons.  On the positive side, we want an official Swift release (e.g. &quot;Swift 3.0”) to provide a consistent set of APIs out of the box that are guaranteed to be there.  Getting your cool thing into the Swift distro guarantees that it will be available everywhere.  On the downside, this is a bad way to go for rapidly evolving APIs in multiple ways: first, Swift has relatively infrequent updates (e.g. twice a year at current cadence) so it will take a long time to get changes out.  Second, *changing* an API included in the Swift distribution will be comparatively hard.  Instead of bumping the major version number of a package, it will have to go through a (TBD) lengthy deprecation process that will likely span multiple years.<br>&gt; <br>&gt; In any case, we’ll figure it out as we go.  We don’t have all the answers, and we’re learning too.<br>&gt; <br>&gt; -Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>Philosophy question: Foundation and Standard Library</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>January  2, 2016 at 10:00:00am</p></header><div class="content"><p>Please see response inline<br></p><p>- Rod<br></p><p>&gt; On 2 Jan 2016, at 9:13 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Thanks Chris.  I want to figure out what the guiding principles are before I blow any further proposal-capital. This gives me a good place to start chewing on some thoughts.  In particular, I&#39;m considering two scenarios.<br>&gt; <br>&gt; First, are things that seem unnaturally split between both places, such as &quot;joinWithSeparator&quot; (stdlib, seq type) and &quot;componentsSeparatedByString&quot; (fnd, NSString). The latter super non-Swifty but could easily evolve to be componentsSeparatedBySequence and rangeOfSequence. (We had some nifty attempts at this last night on #swift-lang in terms of trying to do this with reasonable speed.) <br>&gt; <br></p><p>I find this a very good point and points to something interesting with Swift Foundation.<br></p><p>Is it more important to maintain design closely similar to Objective-C foundation, or to push for a more &quot;swift&quot; design philosophy that may indeed push away from Objective C foundation?<br></p><p>We are essentially outlining some of the foundational (no pun intended) elements of Swift, and a clean, coherent design makes sense. That said, I suspect branching away from Objective-C Foundation may create confusion for developers who write both for Apple Platforms and for servers - &quot;Am I using Swift Foundation, or Objective-C Foundation?&quot;<br></p><p>I think some clarifications on direction would be helpful here before I consider diving in and helping with Swift Foundation (which does interest me a lot!)<br></p><p>&gt; Second, is how to push on what to add -- particularly for integrating proposals from the rich libraries of other languages. I&#39;m interpreting what you wrote as that a standard library should be as flexible and widely applicable as possible while being implemented with the fewest possible moving parts (&quot;stay focused on the lowest-level “language support” primitives&quot;) <br>&gt; <br>&gt; This is counter to having to cram everything interesting into the standard library or Foundation but opens the possibility of creating standard Ruby-esque, Rust-esque, Haskell-esque, etc. packages, right? I&#39;m going to take a wild guess that these latter items would have to be self organizing and fall outside the umbrella of Swift and Swift-Evolution. For this bit, I&#39;m going to defer to Kevin, etc for figuring out what would be awesome to add in.<br>&gt; <br>&gt; -- E<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160102/6ae8502e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Philosophy question: Foundation and Standard Library</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January  1, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jan 1, 2016, at 3:32 PM, Rod Brown &lt;rodney.brown6 at icloud.com&gt; wrote:<br>&gt;&gt; Thanks Chris.  I want to figure out what the guiding principles are before I blow any further proposal-capital. This gives me a good place to start chewing on some thoughts.  In particular, I&#39;m considering two scenarios.<br>&gt;&gt; <br>&gt;&gt; First, are things that seem unnaturally split between both places, such as &quot;joinWithSeparator&quot; (stdlib, seq type) and &quot;componentsSeparatedByString&quot; (fnd, NSString). The latter super non-Swifty but could easily evolve to be componentsSeparatedBySequence and rangeOfSequence. (We had some nifty attempts at this last night on #swift-lang in terms of trying to do this with reasonable speed.) <br>&gt;&gt; <br>&gt; <br>&gt; I find this a very good point and points to something interesting with Swift Foundation.<br>&gt; <br>&gt; Is it more important to maintain design closely similar to Objective-C foundation, or to push for a more &quot;swift&quot; design philosophy that may indeed push away from Objective C foundation?<br></p><p>Our goal is to pull the two together, so that Foundation ultimately feels 100% Swift native.  This is one major reason that we’re doing corelibs-foundation the way we are in the first place, to force the design discussions to happen.<br></p><p>We plan to do this through a combination of improving how Swift imports Objective-C APIs (something that made a lot of progress in Swift 2, and should make at least some more progress in Swift 3) as well as by adding “more swifty” interfaces manually where it makes sense (e.g. through overlays).  This is something you should discuss on a case by case basis with the corelibs folks, because there is no one blanket answer.<br></p><p>&gt; We are essentially outlining some of the foundational (no pun intended) elements of Swift, and a clean, coherent design makes sense. That said, I suspect branching away from Objective-C Foundation may create confusion for developers who write both for Apple Platforms and for servers - &quot;Am I using Swift Foundation, or Objective-C Foundation?”<br></p><p>This would be a pretty big problem, defeating the goal of supporting cross-platform development with Swift.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>Philosophy question: Foundation and Standard Library</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>January  2, 2016 at 05:00:00pm</p></header><div class="content"><p>Brilliant. Makes sense and seems to be a best-of-both-worlds approach.<br></p><p>- Rod<br></p><p>On 2 Jan 2016, at 3:16 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br></p><p>&gt;&gt;&gt; On Jan 1, 2016, at 3:32 PM, Rod Brown &lt;rodney.brown6 at icloud.com&gt; wrote:<br>&gt;&gt;&gt; Thanks Chris.  I want to figure out what the guiding principles are before I blow any further proposal-capital. This gives me a good place to start chewing on some thoughts.  In particular, I&#39;m considering two scenarios.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; First, are things that seem unnaturally split between both places, such as &quot;joinWithSeparator&quot; (stdlib, seq type) and &quot;componentsSeparatedByString&quot; (fnd, NSString). The latter super non-Swifty but could easily evolve to be componentsSeparatedBySequence and rangeOfSequence. (We had some nifty attempts at this last night on #swift-lang in terms of trying to do this with reasonable speed.)<br>&gt;&gt; <br>&gt;&gt; I find this a very good point and points to something interesting with Swift Foundation.<br>&gt;&gt; <br>&gt;&gt; Is it more important to maintain design closely similar to Objective-C foundation, or to push for a more &quot;swift&quot; design philosophy that may indeed push away from Objective C foundation?<br>&gt; <br>&gt; Our goal is to pull the two together, so that Foundation ultimately feels 100% Swift native.  This is one major reason that we’re doing corelibs-foundation the way we are in the first place, to force the design discussions to happen.<br>&gt; <br>&gt; We plan to do this through a combination of improving how Swift imports Objective-C APIs (something that made a lot of progress in Swift 2, and should make at least some more progress in Swift 3) as well as by adding “more swifty” interfaces manually where it makes sense (e.g. through overlays).  This is something you should discuss on a case by case basis with the corelibs folks, because there is no one blanket answer.<br>&gt; <br>&gt;&gt; We are essentially outlining some of the foundational (no pun intended) elements of Swift, and a clean, coherent design makes sense. That said, I suspect branching away from Objective-C Foundation may create confusion for developers who write both for Apple Platforms and for servers - &quot;Am I using Swift Foundation, or Objective-C Foundation?”<br>&gt; <br>&gt; This would be a pretty big problem, defeating the goal of supporting cross-platform development with Swift.<br>&gt; <br>&gt; -Chris<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be4c3c3b76631a155e1358db48066692?s=50"></div><header><strong>Philosophy question: Foundation and Standard Library</strong> from <string>Tony Parker</string> &lt;anthony.parker at apple.com&gt;<p>January  4, 2016 at 04:00:00pm</p></header><div class="content"><p>Not that I need to say this, but I’ll chime in anyway with a big +1 to what Chris said. =)<br></p><p>Fortunately, the current code owners for swift-corelibs-foundation are the same people that work on Foundation for all of our other platforms. That means we’re in a great position to make Foundation great in Swift everywhere. As Chris said, we have a giant task of getting the fundamentals up and running without Objective-C, so that is our primary goal for Swift 3. However, we are interested in all kinds of improvements in the long term.<br></p><p>Thanks,<br>- Tony<br></p><p>&gt; On Jan 1, 2016, at 10:32 PM, Rod Brown via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Brilliant. Makes sense and seems to be a best-of-both-worlds approach.<br>&gt; <br>&gt; - Rod<br>&gt; <br>&gt; On 2 Jan 2016, at 3:16 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt;&gt; On Jan 1, 2016, at 3:32 PM, Rod Brown &lt;rodney.brown6 at icloud.com&gt; wrote:<br>&gt;&gt;&gt;&gt; Thanks Chris.  I want to figure out what the guiding principles are before I blow any further proposal-capital. This gives me a good place to start chewing on some thoughts.  In particular, I&#39;m considering two scenarios.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; First, are things that seem unnaturally split between both places, such as &quot;joinWithSeparator&quot; (stdlib, seq type) and &quot;componentsSeparatedByString&quot; (fnd, NSString). The latter super non-Swifty but could easily evolve to be componentsSeparatedBySequence and rangeOfSequence. (We had some nifty attempts at this last night on #swift-lang in terms of trying to do this with reasonable speed.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I find this a very good point and points to something interesting with Swift Foundation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is it more important to maintain design closely similar to Objective-C foundation, or to push for a more &quot;swift&quot; design philosophy that may indeed push away from Objective C foundation?<br>&gt;&gt; <br>&gt;&gt; Our goal is to pull the two together, so that Foundation ultimately feels 100% Swift native.  This is one major reason that we’re doing corelibs-foundation the way we are in the first place, to force the design discussions to happen.<br>&gt;&gt; <br>&gt;&gt; We plan to do this through a combination of improving how Swift imports Objective-C APIs (something that made a lot of progress in Swift 2, and should make at least some more progress in Swift 3) as well as by adding “more swifty” interfaces manually where it makes sense (e.g. through overlays).  This is something you should discuss on a case by case basis with the corelibs folks, because there is no one blanket answer.<br>&gt;&gt; <br>&gt;&gt;&gt; We are essentially outlining some of the foundational (no pun intended) elements of Swift, and a clean, coherent design makes sense. That said, I suspect branching away from Objective-C Foundation may create confusion for developers who write both for Apple Platforms and for servers - &quot;Am I using Swift Foundation, or Objective-C Foundation?”<br>&gt;&gt; <br>&gt;&gt; This would be a pretty big problem, defeating the goal of supporting cross-platform development with Swift.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Philosophy question: Foundation and Standard Library</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January  1, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jan 1, 2016, at 2:13 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Thanks Chris.  I want to figure out what the guiding principles are before I blow any further proposal-capital. This gives me a good place to start chewing on some thoughts.  In particular, I&#39;m considering two scenarios.<br>&gt; <br>&gt; First, are things that seem unnaturally split between both places, such as &quot;joinWithSeparator&quot; (stdlib, seq type) and &quot;componentsSeparatedByString&quot; (fnd, NSString). The latter super non-Swifty but could easily evolve to be componentsSeparatedBySequence and rangeOfSequence. (We had some nifty attempts at this last night on #swift-lang in terms of trying to do this with reasonable speed.) <br></p><p>It’s still a Swift 3 goal of the standard library to &quot;make String awesome” (which entails many things from better usability to broader functionality). IMO an awesome string has to be in the base layer of the language, and can’t require pulling in Foundation.  We’re not ready to start having this conversation in detail on swift-evolution yet, but I’m very much looking forward to discussing it with the community.<br></p><p>&gt; Second, is how to push on what to add -- particularly for integrating proposals from the rich libraries of other languages. I&#39;m interpreting what you wrote as that a standard library should be as flexible and widely applicable as possible while being implemented with the fewest possible moving parts (&quot;stay focused on the lowest-level “language support” primitives&quot;) <br>&gt; <br>&gt; This is counter to having to cram everything interesting into the standard library or Foundation but opens the possibility of creating standard Ruby-esque, Rust-esque, Haskell-esque, etc. packages, right? I&#39;m going to take a wild guess that these latter items would have to be self organizing and fall outside the umbrella of Swift and Swift-Evolution. For this bit, I&#39;m going to defer to Kevin, etc for figuring out what would be awesome to add in.<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 1, 2016, at 1:46 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Dec 31, 2015, at 2:54 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; Under what criteria should we propose moving items into the standard library and out from the standard library into Swift Foundation? Or will these things eventually merge and become one grand unified module sometime in the distant future?<br>&gt;&gt; <br>&gt;&gt; Hi Erica,<br>&gt;&gt; <br>&gt;&gt; I don’t see any specific reason to merge the stdlib and Foundation together - it seems like Foundation depending on the swift stdlib is proper layering.  Lets look at the mission of both of these libraries:<br>&gt;&gt; <br>&gt;&gt; For the Swift standard library, we want it to stay focused on the lowest-level “language support” primitives that includes things like Int, Array, Dictionary, OptionSet and the stuff they depend on (sequences etc).  Even though they are implemented in the stdlib, I consider to be part of the the language.  While we may elect to allow some minor scope creep, this will be carefully scrutinized and needs to be strongly justified.<br>&gt;&gt; <br>&gt;&gt; For Foundation, there may be differing short-term and long-term answers here.  In the short-term, the corelibs projects have a very specific focus, which is to enable cross-platform Swift development by making common Foundation APIs available on other platforms.  This is a pretty huge project, so it is important that we keep focused on making this happen, even though folks have the natural inclination to do “new” things as well.<br>&gt;&gt; <br>&gt;&gt; In this short term, I see SwiftPM as a great solution to avoid having to cram “everything interesting” into the standard library or Foundation.  Once SwiftPM is ready, there should be very little downside to something being a package hosted on github or elsewhere.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; In the longer term, we’ll have to see what happens, and make a decision that makes sense given the direction the project takes.  We may decide to start adding new functionality to Foundation that doesn’t exist on Apple platforms yet (with the understanding that they will adopt it as well).  We may decide to “standardize” new corelibs from existing popular packages, if they are outside of the scope of Foundation (totally random example: perhaps a web templating framework).<br>&gt;&gt; <br>&gt;&gt; Putting something into the standard Swift distribution (instead of it being an independent package) comes with pros and cons.  On the positive side, we want an official Swift release (e.g. &quot;Swift 3.0”) to provide a consistent set of APIs out of the box that are guaranteed to be there.  Getting your cool thing into the Swift distro guarantees that it will be available everywhere.  On the downside, this is a bad way to go for rapidly evolving APIs in multiple ways: first, Swift has relatively infrequent updates (e.g. twice a year at current cadence) so it will take a long time to get changes out.  Second, *changing* an API included in the Swift distribution will be comparatively hard.  Instead of bumping the major version number of a package, it will have to go through a (TBD) lengthy deprecation process that will likely span multiple years.<br>&gt;&gt; <br>&gt;&gt; In any case, we’ll figure it out as we go.  We don’t have all the answers, and we’re learning too.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-Dave<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Philosophy question: Foundation and Standard Library</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January  1, 2016 at 08:00:00pm</p></header><div class="content"><p>On Jan 1, 2016, at 2:13 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; Thanks Chris.  I want to figure out what the guiding principles are before I blow any further proposal-capital. This gives me a good place to start chewing on some thoughts.  In particular, I&#39;m considering two scenarios.<br>&gt; <br>&gt; First, are things that seem unnaturally split between both places, such as &quot;joinWithSeparator&quot; (stdlib, seq type) and &quot;componentsSeparatedByString&quot; (fnd, NSString). The latter super non-Swifty but could easily evolve to be componentsSeparatedBySequence and rangeOfSequence. (We had some nifty attempts at this last night on #swift-lang in terms of trying to do this with reasonable speed.)<br></p><p>Keep in mind that both are likely to be renamed as part of the swift 3 “renamification&quot; effort.  Tony and Dave A can comment a lot more about their plans there.  That said, there are a number of aspects of the current Foundation interfaces that can be improved with various levels of trickery.  One we’ve discussed in the past is for things like NSRegularExpression, which traffics a lot in UTF16 codepoint indexes.  We’ve discussed introducing a typedef that gets imported as the Swift UTF16 view index, which would make a lot of things nice.<br></p><p>Beyond things like that, we can also discuss completely new APIs, or completely different ways to craft interfaces.  However, I suspect the corelibs folks will treat those as a lot lower priority: the goal state there is much less clear, and we have a super-valuable target to shoot for in the short term.<br></p><p>As I mentioned before, our approach will surely evolve over time.<br></p><p>&gt; Second, is how to push on what to add -- particularly for integrating proposals from the rich libraries of other languages. I&#39;m interpreting what you wrote as that a standard library should be as flexible and widely applicable as possible while being implemented with the fewest possible moving parts (&quot;stay focused on the lowest-level “language support” primitives”)<br></p><p>I’m pretty sure I didn’t put it that way :-).  Let me give you some examples: print and readLine are in the Swift standard library, but we don’t (and shouldn’t have) a fully featured I/O package (that should live at the Foundation level).  Somewhere in between would be a “printf replacement” that would allow format control for print (this is something we’ve discussed a lot, but were blocked by missing language features in the swift 1 time, and didn’t have time in the swift 2 cycle).  I suspect that simple formatting functionality could exist at the swift stdlib level, but it would be quite a debate :-)<br></p><p>In short, I don’t have a simple answer for you.  However, it is always safe to start with a short email to swift-evolution saying “do you think this idea is in scope for the swift stdlib or not?”.<br></p><p>&gt; This is counter to having to cram everything interesting into the standard library or Foundation but opens the possibility of creating standard Ruby-esque, Rust-esque, Haskell-esque, etc. packages, right? I&#39;m going to take a wild guess that these latter items would have to be self organizing and fall outside the umbrella of Swift and Swift-Evolution. For this bit, I&#39;m going to defer to Kevin, etc for figuring out what would be awesome to add in.<br></p><p>I’m not sure what you mean when you reference those other languages’ packages, but yes, self-organization is a pretty big feature of SwiftPM packages.  We’ve discussed having a centralized index and would love to see that happen (so long as it is opt-in and not required - we also want SwiftPM to be usable for non-public projects and code), someone just needs to step forward to drive the effort.<br></p><p>-Chris<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
