<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Proposal] Disallow redundant `Any&lt;...&gt;` constructs</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May 20, 2016 at 11:00:00am</p></header><div class="content"><p>This is a follow up proposal to SE-0095 which should be considered for Swift 3 if SE-0095 will be accepted.<br></p><p>Here is the formatted draft: https://github.com/DevAndArtist/swift-evolution/blob/master/proposals/nnnn-ban-redundancy-in-any-existential.md<br></p><p>Please provide your feedback in this thread, and don’t make a race who is making a better proposal on the exact same topic.<br></p><p>If you spot any types or other mistakes I’d be happy to see you pointing me to them. ;)<br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br>Disallow redundant Any&lt;...&gt; constructs<br></p><p>Proposal: SE-NNNN<br>Author: Adrian Zubarev<br>Status: Awaiting review<br>Review manager: TBD<br>Introduction<br></p><p>This is a follow up proposal to SE–0095, if it will be accepted for Swift 3. The current concept of Any&lt;...&gt; introduced in SE–0095 will allow creation of redundant types like Any&lt;A&gt; == A. I propose to disallow such redundancy in Swift 3 to prevent breaking changes in a future version of Swift.<br></p><p>Swift-evolution thread: [Proposal] Disallow redundant Any&lt;...&gt; constructs<br></p><p>Motivation<br></p><p>If SE–0095 will be accepted there will be future proposals to enhance its capabilities. Two of these will be Any-type requirement (where type could be class, struct or enum) and Class requirement. Without any restrictions these will introduce more redundancy.<br></p><p>As said before it is possible to create redundant types like Any&lt;A&gt; == A or endless shadowed redundant nesting:<br></p><p>typealias A_1 = Any&lt;A&gt;<br>typealias A_2 = Any&lt;A_1&gt;<br>typealias A_3 = Any&lt;A_2&gt;<br>/* and so on */<br>This proposal should ban redundancy right from the beginning. If there might be any desire to relax a few things, it won’t introduce any breaking changes for Any&lt;...&gt; existential.<br></p><p>Proposed solution<br></p><p>If empty Any&lt;&gt; won’t be disallowed in SE–0095, we should disallow nesting empty Any&lt;&gt; inside of Any&lt;...&gt;.<br></p><p>Disallow nesting Any (type refers to current typealias Any = protocol&lt;&gt;) inside of Any&lt;...&gt;.<br></p><p>Disallow Any&lt;...&gt; containing a single Type like Any&lt;Type&gt;.<br></p><p>The first three rules will ban constructs like Any&lt;Any&lt;&gt;, Type&gt; or Any&lt;Any, Type&gt; and force the developer to use Type instead.<br></p><p>Disallow nesting a single Any&lt;...&gt; inside another Any&lt;...&gt;.<br>e.g. Any&lt;Any&lt;FirstType, SecondType&gt;&gt;<br>Disallow same type usage like Any&lt;A, A&gt; or Any&lt;A, B, A&gt; and force the developer to use A or Any&lt;A, B&gt; if A and B are distinct.<br></p><p>Disallow forming redundant types when the provided constraints are not independent.<br></p><p>// Right now `type` can only be `protocol` but in the future Any&lt;...&gt;  <br>// could also allow `class`, `struct` and `enum`.<br>// In this example `B` and `C` are distinct.<br>type A: B, C {}  <br>     <br>// all following types are equivalent to `A`<br>Any&lt;A, Any&lt;B, C&gt;&gt;<br>Any&lt;Any&lt;A, B&gt;, C&gt;<br>Any&lt;Any&lt;A, C&gt;, B&gt;<br>Any&lt;A, B, C&gt;<br>Any&lt;A, B&gt;<br>Any&lt;A, C&gt;<br>If all contraints form a known Type provide a Fix-it error depending on the current context. If there is more than one Type, provide all alternatives to the developer.<br></p><p>Using Any&lt;...&gt; in a generic context might not produce a Fix-it error:<br></p><p>protocol A {}<br>protocol B {}<br>protocol C: A, B {}<br>         <br>// there is no need for `Fix-it` in such a context<br>func foo&lt;T: Any&lt;A, B&gt;&gt;(value: T) {}<br>Impact on existing code<br></p><p>These changes will break existing code. Projects abusing Any&lt;...&gt; to create redundant types should be reconsidered of usings the equivalent Type the compiler would infer. One would be forced to use A instead of Any&lt;A&gt; for example. A Fix-it error message can help the developer to migrate his project.<br></p><p>Alternatives considered<br></p><p>Leave redundancy as-is for Swift 3 and live with it.<br>Deprecate redundancy in a future version of Swift, which will introduce breaking changes.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/eab4f47b/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Proposal] Disallow redundant `Any&lt;...&gt;` constructs</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 20, 2016 at 12:00:00pm</p></header><div class="content"><p>I think you should submit this for review, but I also think you should take<br>the part of your older proposal to add class support to Any&lt;...&gt; and submit<br>it as a separate proposal. (I mean, the part where you can define things<br>like &quot;Any&lt;UIViewController, Protocol&gt;&quot; or &quot;Any&lt;class, Protocol&gt;&quot;.)<br></p><p>Yes, it is additive, but even getting that feature into Swift 3 would be an<br>enormous benefit if it can be implemented easily. And the core team is<br>probably better positioned than anyone else to determine whether that&#39;s<br>true.<br></p><p>Austin<br></p><p>On Fri, May 20, 2016 at 2:39 AM, Adrian Zubarev via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; This is a follow up proposal to SE-0095<br>&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0095-any-as-existential.md&gt; which<br>&gt; should be considered for Swift 3 if SE-0095 will be accepted.<br>&gt;<br>&gt; Here is the formatted draft:<br>&gt; https://github.com/DevAndArtist/swift-evolution/blob/master/proposals/nnnn-ban-redundancy-in-any-existential.md<br>&gt;<br>&gt; Please provide your feedback in this thread, and don’t make a race who is<br>&gt; making a better proposal on the exact same topic.<br>&gt;<br>&gt; If you spot any types or other mistakes I’d be happy to see you pointing<br>&gt; me to them. ;)<br>&gt;<br>&gt; --<br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt;<br>&gt; Disallow redundant Any&lt;...&gt; constructs<br>&gt;<br>&gt;    - Proposal: SE-NNNN<br>&gt;    &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>&gt;    - Author: Adrian Zubarev &lt;https://github.com/DevAndArtist&gt;<br>&gt;    - Status: Awaiting review &lt;#m_3447501318802576264_rationale&gt;<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt; Introduction<br>&gt;<br>&gt; This is a follow up proposal to SE–0095<br>&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0095-any-as-existential.md&gt;,<br>&gt; if it will be accepted for Swift 3. The current concept of Any&lt;...&gt;<br>&gt; introduced in SE–0095 will allow creation of redundant types like Any&lt;A&gt;<br>&gt; == A. I propose to disallow such redundancy in Swift 3 to prevent<br>&gt; breaking changes in a future version of Swift.<br>&gt;<br>&gt; Swift-evolution thread: [Proposal] Disallow redundant Any&lt;...&gt; constructs<br>&gt; Motivation<br>&gt;<br>&gt; If SE–0095 will be accepted there will be future proposals to enhance its<br>&gt; capabilities. Two of these will be *Any-type requirement* (where *type*<br>&gt; could be class, struct or enum) and *Class requirement*. Without any<br>&gt; restrictions these will introduce more redundancy.<br>&gt;<br>&gt; As said before it is possible to create redundant types like Any&lt;A&gt; == A<br>&gt; or endless shadowed redundant nesting:<br>&gt;<br>&gt; typealias A_1 = Any&lt;A&gt;<br>&gt; typealias A_2 = Any&lt;A_1&gt;<br>&gt; typealias A_3 = Any&lt;A_2&gt;<br>&gt; /* and so on */<br>&gt;<br>&gt; This proposal should ban redundancy right from the beginning. If there<br>&gt; might be any desire to relax a few things, it won’t introduce any breaking<br>&gt; changes for Any&lt;...&gt; existential.<br>&gt; Proposed solution<br>&gt;<br>&gt;    1.<br>&gt;<br>&gt;    If empty Any&lt;&gt; won’t be disallowed in SE–0095, we should disallow<br>&gt;    nesting empty Any&lt;&gt; inside of Any&lt;...&gt;.<br>&gt;    2.<br>&gt;<br>&gt;    Disallow nesting Any (type refers to current typealias Any = protocol&lt;&gt;)<br>&gt;    inside of Any&lt;...&gt;.<br>&gt;    3.<br>&gt;<br>&gt;    Disallow Any&lt;...&gt; containing a single Type like Any&lt;Type&gt;.<br>&gt;<br>&gt;    The first three rules will ban constructs like Any&lt;Any&lt;&gt;, Type&gt; or Any&lt;Any,<br>&gt;    Type&gt; and force the developer to use Type instead.<br>&gt;    4. Disallow nesting a single Any&lt;...&gt; inside another Any&lt;...&gt;.<br>&gt;       - e.g. Any&lt;Any&lt;FirstType, SecondType&gt;&gt;<br>&gt;    5.<br>&gt;<br>&gt;    Disallow same type usage like Any&lt;A, A&gt; or Any&lt;A, B, A&gt; and force the<br>&gt;    developer to use A or Any&lt;A, B&gt; if A and B are distinct.<br>&gt;    6.<br>&gt;<br>&gt;    Disallow forming redundant types when the provided constraints are not<br>&gt;    independent.<br>&gt;<br>&gt;    // Right now `type` can only be `protocol` but in the future Any&lt;...&gt;<br>&gt;    // could also allow `class`, `struct` and `enum`.<br>&gt;    // In this example `B` and `C` are distinct.<br>&gt;    type A: B, C {}<br>&gt;<br>&gt;    // all following types are equivalent to `A`<br>&gt;    Any&lt;A, Any&lt;B, C&gt;&gt;<br>&gt;    Any&lt;Any&lt;A, B&gt;, C&gt;<br>&gt;    Any&lt;Any&lt;A, C&gt;, B&gt;<br>&gt;    Any&lt;A, B, C&gt;<br>&gt;    Any&lt;A, B&gt;<br>&gt;    Any&lt;A, C&gt;<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;       If all contraints form a known Type provide a Fix-it error<br>&gt;       depending on the current context. If there is more than one Type,<br>&gt;       provide all alternatives to the developer.<br>&gt;       -<br>&gt;<br>&gt;       Using Any&lt;...&gt; in a generic context might not produce a Fix-it<br>&gt;       error:<br>&gt;<br>&gt;       protocol A {}<br>&gt;       protocol B {}<br>&gt;       protocol C: A, B {}<br>&gt;<br>&gt;       // there is no need for `Fix-it` in such a context<br>&gt;       func foo&lt;T: Any&lt;A, B&gt;&gt;(value: T) {}<br>&gt;<br>&gt;<br>&gt; Impact on existing code<br>&gt;<br>&gt; These changes will break existing code. Projects abusing Any&lt;...&gt; to<br>&gt; create redundant types should be reconsidered of usings the equivalent<br>&gt; Type the compiler would infer. One would be forced to use A instead of<br>&gt; Any&lt;A&gt; for example. A Fix-it error message can help the developer to<br>&gt; migrate his project.<br>&gt; Alternatives considered<br>&gt;<br>&gt;    - Leave redundancy as-is for Swift 3 and live with it.<br>&gt;    - Deprecate redundancy in a future version of Swift, which will<br>&gt;    introduce breaking changes.<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/e7cbd60e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Disallow redundant `Any&lt;...&gt;` constructs</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 20, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On May 20, 2016, at 2:00 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think you should submit this for review, but I also think you should take the part of your older proposal to add class support to Any&lt;...&gt; and submit it as a separate proposal. (I mean, the part where you can define things like &quot;Any&lt;UIViewController, Protocol&gt;&quot; or &quot;Any&lt;class, Protocol&gt;&quot;.)<br>&gt; <br>&gt; Yes, it is additive, but even getting that feature into Swift 3 would be an enormous benefit if it can be implemented easily. And the core team is probably better positioned than anyone else to determine whether that&#39;s true.<br></p><p>Austin, what is your thought on switching to `any` rather than `Any` since it does not behave like a user-defined generic type?  The convention is for types to be uppercase and keywords to be lowercase.  This falls more into the category of a keyword and has its own behavior distinct from the behavior of all generic types.  Making it stand out syntactically will help to make that clear.<br></p><p>&gt; <br>&gt; Austin<br>&gt; <br>&gt; On Fri, May 20, 2016 at 2:39 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; This is a follow up proposal to SE-0095 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0095-any-as-existential.md&gt; which should be considered for Swift 3 if SE-0095 will be accepted.<br>&gt; <br>&gt; Here is the formatted draft: https://github.com/DevAndArtist/swift-evolution/blob/master/proposals/nnnn-ban-redundancy-in-any-existential.md &lt;https://github.com/DevAndArtist/swift-evolution/blob/master/proposals/nnnn-ban-redundancy-in-any-existential.md&gt;<br>&gt; <br>&gt; Please provide your feedback in this thread, and don’t make a race who is making a better proposal on the exact same topic.<br>&gt; <br>&gt; If you spot any types or other mistakes I’d be happy to see you pointing me to them. ;)<br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Disallow redundant Any&lt;...&gt; constructs<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>&gt; Author: Adrian Zubarev &lt;https://github.com/DevAndArtist&gt;<br>&gt; Status: Awaiting review &lt;x-msg://378/#m_3447501318802576264_rationale&gt;<br>&gt; Review manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; This is a follow up proposal to SE–0095 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0095-any-as-existential.md&gt;, if it will be accepted for Swift 3. The current concept of Any&lt;...&gt; introduced in SE–0095 will allow creation of redundant types like Any&lt;A&gt; == A. I propose to disallow such redundancy in Swift 3 to prevent breaking changes in a future version of Swift.<br>&gt; <br>&gt; Swift-evolution thread: [Proposal] Disallow redundant Any&lt;...&gt; constructs &lt;&gt;<br>&gt; Motivation<br>&gt; <br>&gt; If SE–0095 will be accepted there will be future proposals to enhance its capabilities. Two of these will be Any-type requirement (where type could be class, struct or enum) and Class requirement. Without any restrictions these will introduce more redundancy.<br>&gt; <br>&gt; As said before it is possible to create redundant types like Any&lt;A&gt; == A or endless shadowed redundant nesting:<br>&gt; <br>&gt; typealias A_1 = Any&lt;A&gt;<br>&gt; typealias A_2 = Any&lt;A_1&gt;<br>&gt; typealias A_3 = Any&lt;A_2&gt;<br>&gt; /* and so on */<br>&gt; This proposal should ban redundancy right from the beginning. If there might be any desire to relax a few things, it won’t introduce any breaking changes for Any&lt;...&gt; existential.<br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; If empty Any&lt;&gt; won’t be disallowed in SE–0095, we should disallow nesting empty Any&lt;&gt; inside of Any&lt;...&gt;.<br>&gt; <br>&gt; Disallow nesting Any (type refers to current typealias Any = protocol&lt;&gt;) inside of Any&lt;...&gt;.<br>&gt; <br>&gt; Disallow Any&lt;...&gt; containing a single Type like Any&lt;Type&gt;.<br>&gt; <br>&gt; The first three rules will ban constructs like Any&lt;Any&lt;&gt;, Type&gt; or Any&lt;Any, Type&gt; and force the developer to use Type instead.<br>&gt; <br>&gt; Disallow nesting a single Any&lt;...&gt; inside another Any&lt;...&gt;.<br>&gt; e.g. Any&lt;Any&lt;FirstType, SecondType&gt;&gt;<br>&gt; Disallow same type usage like Any&lt;A, A&gt; or Any&lt;A, B, A&gt; and force the developer to use A or Any&lt;A, B&gt; if A and B are distinct.<br>&gt; <br>&gt; Disallow forming redundant types when the provided constraints are not independent.<br>&gt; <br>&gt; // Right now `type` can only be `protocol` but in the future Any&lt;...&gt;  <br>&gt; // could also allow `class`, `struct` and `enum`.<br>&gt; // In this example `B` and `C` are distinct.<br>&gt; type A: B, C {}  <br>&gt;      <br>&gt; // all following types are equivalent to `A`<br>&gt; Any&lt;A, Any&lt;B, C&gt;&gt;<br>&gt; Any&lt;Any&lt;A, B&gt;, C&gt;<br>&gt; Any&lt;Any&lt;A, C&gt;, B&gt;<br>&gt; Any&lt;A, B, C&gt;<br>&gt; Any&lt;A, B&gt;<br>&gt; Any&lt;A, C&gt;<br>&gt; If all contraints form a known Type provide a Fix-it error depending on the current context. If there is more than one Type, provide all alternatives to the developer.<br>&gt; <br>&gt; Using Any&lt;...&gt; in a generic context might not produce a Fix-it error:<br>&gt; <br>&gt; protocol A {}<br>&gt; protocol B {}<br>&gt; protocol C: A, B {}<br>&gt;          <br>&gt; // there is no need for `Fix-it` in such a context<br>&gt; func foo&lt;T: Any&lt;A, B&gt;&gt;(value: T) {}<br>&gt; Impact on existing code<br>&gt; <br>&gt; These changes will break existing code. Projects abusing Any&lt;...&gt; to create redundant types should be reconsidered of usings the equivalent Type the compiler would infer. One would be forced to use A instead of Any&lt;A&gt; for example. A Fix-it error message can help the developer to migrate his project.<br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; Leave redundancy as-is for Swift 3 and live with it.<br>&gt; Deprecate redundancy in a future version of Swift, which will introduce breaking changes.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/639a2757/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Proposal] Disallow redundant `Any&lt;...&gt;` constructs</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 20, 2016 at 12:00:00pm</p></header><div class="content"><p>I actually like &quot;any&lt;P1, P2&gt;&quot;. It does provide that very distinctive visual<br>signal that any&lt;&gt; is not a generic type, and that &#39;any&#39; is not itself a<br>type, but rather a special keyword for constructing an existential:<br></p><p>Array&lt;Int&gt;  // a generic type, Array, containing integers<br>any&lt;P1, P2&gt; // a protocol composition of two protocols<br></p><p>In this case, would we want to support &quot;any&lt;&gt;&quot; in addition to Any? The<br>parsing issues should go away, since these are two different identifiers.<br></p><p>Austin<br></p><p><br></p><p>On Fri, May 20, 2016 at 12:04 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; On May 20, 2016, at 2:00 PM, Austin Zheng via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I think you should submit this for review, but I also think you should<br>&gt; take the part of your older proposal to add class support to Any&lt;...&gt; and<br>&gt; submit it as a separate proposal. (I mean, the part where you can define<br>&gt; things like &quot;Any&lt;UIViewController, Protocol&gt;&quot; or &quot;Any&lt;class, Protocol&gt;&quot;.)<br>&gt;<br>&gt; Yes, it is additive, but even getting that feature into Swift 3 would be<br>&gt; an enormous benefit if it can be implemented easily. And the core team is<br>&gt; probably better positioned than anyone else to determine whether that&#39;s<br>&gt; true.<br>&gt;<br>&gt;<br>&gt; Austin, what is your thought on switching to `any` rather than `Any` since<br>&gt; it does not behave like a user-defined generic type?  The convention is for<br>&gt; types to be uppercase and keywords to be lowercase.  This falls more into<br>&gt; the category of a keyword and has its own behavior distinct from the<br>&gt; behavior of all generic types.  Making it stand out syntactically will help<br>&gt; to make that clear.<br>&gt;<br>&gt;<br>&gt; Austin<br>&gt;<br>&gt; On Fri, May 20, 2016 at 2:39 AM, Adrian Zubarev via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; This is a follow up proposal to SE-0095<br>&gt;&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0095-any-as-existential.md&gt; which<br>&gt;&gt; should be considered for Swift 3 if SE-0095 will be accepted.<br>&gt;&gt;<br>&gt;&gt; Here is the formatted draft:<br>&gt;&gt; https://github.com/DevAndArtist/swift-evolution/blob/master/proposals/nnnn-ban-redundancy-in-any-existential.md<br>&gt;&gt;<br>&gt;&gt; Please provide your feedback in this thread, and don’t make a race who is<br>&gt;&gt; making a better proposal on the exact same topic.<br>&gt;&gt;<br>&gt;&gt; If you spot any types or other mistakes I’d be happy to see you pointing<br>&gt;&gt; me to them. ;)<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Adrian Zubarev<br>&gt;&gt; Sent with Airmail<br>&gt;&gt;<br>&gt;&gt; Disallow redundant Any&lt;...&gt; constructs<br>&gt;&gt;<br>&gt;&gt;    - Proposal: SE-NNNN<br>&gt;&gt;    &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>&gt;&gt;    - Author: Adrian Zubarev &lt;https://github.com/DevAndArtist&gt;<br>&gt;&gt;    - Status: Awaiting review<br>&gt;&gt;    - Review manager: TBD<br>&gt;&gt;<br>&gt;&gt; Introduction<br>&gt;&gt;<br>&gt;&gt; This is a follow up proposal to SE–0095<br>&gt;&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0095-any-as-existential.md&gt;,<br>&gt;&gt; if it will be accepted for Swift 3. The current concept of Any&lt;...&gt;<br>&gt;&gt; introduced in SE–0095 will allow creation of redundant types like Any&lt;A&gt;<br>&gt;&gt; == A. I propose to disallow such redundancy in Swift 3 to prevent<br>&gt;&gt; breaking changes in a future version of Swift.<br>&gt;&gt;<br>&gt;&gt; Swift-evolution thread: [Proposal] Disallow redundant Any&lt;...&gt; constructs<br>&gt;&gt; Motivation<br>&gt;&gt;<br>&gt;&gt; If SE–0095 will be accepted there will be future proposals to enhance its<br>&gt;&gt; capabilities. Two of these will be *Any-type requirement* (where *type*<br>&gt;&gt; could be class, struct or enum) and *Class requirement*. Without any<br>&gt;&gt; restrictions these will introduce more redundancy.<br>&gt;&gt;<br>&gt;&gt; As said before it is possible to create redundant types like Any&lt;A&gt; == A<br>&gt;&gt; or endless shadowed redundant nesting:<br>&gt;&gt;<br>&gt;&gt; typealias A_1 = Any&lt;A&gt;<br>&gt;&gt; typealias A_2 = Any&lt;A_1&gt;<br>&gt;&gt; typealias A_3 = Any&lt;A_2&gt;<br>&gt;&gt; /* and so on */<br>&gt;&gt;<br>&gt;&gt; This proposal should ban redundancy right from the beginning. If there<br>&gt;&gt; might be any desire to relax a few things, it won’t introduce any breaking<br>&gt;&gt; changes for Any&lt;...&gt; existential.<br>&gt;&gt; Proposed solution<br>&gt;&gt;<br>&gt;&gt;    1.<br>&gt;&gt;<br>&gt;&gt;    If empty Any&lt;&gt; won’t be disallowed in SE–0095, we should disallow<br>&gt;&gt;    nesting empty Any&lt;&gt; inside of Any&lt;...&gt;.<br>&gt;&gt;    2.<br>&gt;&gt;<br>&gt;&gt;    Disallow nesting Any (type refers to current typealias Any =<br>&gt;&gt;    protocol&lt;&gt;) inside of Any&lt;...&gt;.<br>&gt;&gt;    3.<br>&gt;&gt;<br>&gt;&gt;    Disallow Any&lt;...&gt; containing a single Type like Any&lt;Type&gt;.<br>&gt;&gt;<br>&gt;&gt;    The first three rules will ban constructs like Any&lt;Any&lt;&gt;, Type&gt; or Any&lt;Any,<br>&gt;&gt;    Type&gt; and force the developer to use Type instead.<br>&gt;&gt;    4. Disallow nesting a single Any&lt;...&gt; inside another Any&lt;...&gt;.<br>&gt;&gt;       - e.g. Any&lt;Any&lt;FirstType, SecondType&gt;&gt;<br>&gt;&gt;    5.<br>&gt;&gt;<br>&gt;&gt;    Disallow same type usage like Any&lt;A, A&gt; or Any&lt;A, B, A&gt; and force the<br>&gt;&gt;    developer to use A or Any&lt;A, B&gt; if A and B are distinct.<br>&gt;&gt;    6.<br>&gt;&gt;<br>&gt;&gt;    Disallow forming redundant types when the provided constraints are<br>&gt;&gt;    not independent.<br>&gt;&gt;<br>&gt;&gt;    // Right now `type` can only be `protocol` but in the future Any&lt;...&gt;<br>&gt;&gt;    // could also allow `class`, `struct` and `enum`.<br>&gt;&gt;    // In this example `B` and `C` are distinct.<br>&gt;&gt;    type A: B, C {}<br>&gt;&gt;<br>&gt;&gt;    // all following types are equivalent to `A`<br>&gt;&gt;    Any&lt;A, Any&lt;B, C&gt;&gt;<br>&gt;&gt;    Any&lt;Any&lt;A, B&gt;, C&gt;<br>&gt;&gt;    Any&lt;Any&lt;A, C&gt;, B&gt;<br>&gt;&gt;    Any&lt;A, B, C&gt;<br>&gt;&gt;    Any&lt;A, B&gt;<br>&gt;&gt;    Any&lt;A, C&gt;<br>&gt;&gt;<br>&gt;&gt;    -<br>&gt;&gt;<br>&gt;&gt;       If all contraints form a known Type provide a Fix-it error<br>&gt;&gt;       depending on the current context. If there is more than one Type,<br>&gt;&gt;       provide all alternatives to the developer.<br>&gt;&gt;       -<br>&gt;&gt;<br>&gt;&gt;       Using Any&lt;...&gt; in a generic context might not produce a Fix-it<br>&gt;&gt;       error:<br>&gt;&gt;<br>&gt;&gt;       protocol A {}<br>&gt;&gt;       protocol B {}<br>&gt;&gt;       protocol C: A, B {}<br>&gt;&gt;<br>&gt;&gt;       // there is no need for `Fix-it` in such a context<br>&gt;&gt;       func foo&lt;T: Any&lt;A, B&gt;&gt;(value: T) {}<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Impact on existing code<br>&gt;&gt;<br>&gt;&gt; These changes will break existing code. Projects abusing Any&lt;...&gt; to<br>&gt;&gt; create redundant types should be reconsidered of usings the equivalent<br>&gt;&gt; Type the compiler would infer. One would be forced to use A instead of<br>&gt;&gt; Any&lt;A&gt; for example. A Fix-it error message can help the developer to<br>&gt;&gt; migrate his project.<br>&gt;&gt; Alternatives considered<br>&gt;&gt;<br>&gt;&gt;    - Leave redundancy as-is for Swift 3 and live with it.<br>&gt;&gt;    - Deprecate redundancy in a future version of Swift, which will<br>&gt;&gt;    introduce breaking changes.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/0c7b8d75/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Proposal] Disallow redundant `Any&lt;...&gt;` constructs</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May 20, 2016 at 09:00:00pm</p></header><div class="content"><p>+1 for this as the original post suggested already `type&lt;…&gt;` or `all&lt;…&gt;`. `any&lt;…&gt;` is fine here.<br></p><p>Wrong thread though. :D<br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 20. Mai 2016 bei 21:07:20, Austin Zheng (austinzheng at gmail.com) schrieb:<br></p><p>I actually like &quot;any&lt;P1, P2&gt;&quot;. It does provide that very distinctive visual signal that any&lt;&gt; is not a generic type, and that &#39;any&#39; is not itself a type, but rather a special keyword for constructing an existential:<br></p><p>Array&lt;Int&gt;  // a generic type, Array, containing integers<br>any&lt;P1, P2&gt; // a protocol composition of two protocols<br></p><p>In this case, would we want to support &quot;any&lt;&gt;&quot; in addition to Any? The parsing issues should go away, since these are two different identifiers.<br></p><p>Austin<br></p><p><br></p><p>On Fri, May 20, 2016 at 12:04 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br></p><p>On May 20, 2016, at 2:00 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>I think you should submit this for review, but I also think you should take the part of your older proposal to add class support to Any&lt;...&gt; and submit it as a separate proposal. (I mean, the part where you can define things like &quot;Any&lt;UIViewController, Protocol&gt;&quot; or &quot;Any&lt;class, Protocol&gt;&quot;.)<br></p><p>Yes, it is additive, but even getting that feature into Swift 3 would be an enormous benefit if it can be implemented easily. And the core team is probably better positioned than anyone else to determine whether that&#39;s true.<br></p><p>Austin, what is your thought on switching to `any` rather than `Any` since it does not behave like a user-defined generic type?  The convention is for types to be uppercase and keywords to be lowercase.  This falls more into the category of a keyword and has its own behavior distinct from the behavior of all generic types.  Making it stand out syntactically will help to make that clear.<br></p><p><br>Austin<br></p><p>On Fri, May 20, 2016 at 2:39 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>This is a follow up proposal to SE-0095 which should be considered for Swift 3 if SE-0095 will be accepted.<br></p><p>Here is the formatted draft: https://github.com/DevAndArtist/swift-evolution/blob/master/proposals/nnnn-ban-redundancy-in-any-existential.md<br></p><p>Please provide your feedback in this thread, and don’t make a race who is making a better proposal on the exact same topic.<br></p><p>If you spot any types or other mistakes I’d be happy to see you pointing me to them. ;)<br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Disallow redundant Any&lt;...&gt; constructs<br></p><p>Proposal: SE-NNNN<br>Author: Adrian Zubarev<br>Status: Awaiting review<br>Review manager: TBD<br>Introduction<br></p><p>This is a follow up proposal to SE–0095, if it will be accepted for Swift 3. The current concept of Any&lt;...&gt; introduced in SE–0095 will allow creation of redundant types like Any&lt;A&gt; == A. I propose to disallow such redundancy in Swift 3 to prevent breaking changes in a future version of Swift.<br></p><p>Swift-evolution thread: [Proposal] Disallow redundant Any&lt;...&gt; constructs<br></p><p>Motivation<br></p><p>If SE–0095 will be accepted there will be future proposals to enhance its capabilities. Two of these will be Any-type requirement (where type could be class, struct or enum) and Class requirement. Without any restrictions these will introduce more redundancy.<br></p><p>As said before it is possible to create redundant types like Any&lt;A&gt; == A or endless shadowed redundant nesting:<br></p><p>typealias A_1 = Any&lt;A&gt;<br>typealias A_2 = Any&lt;A_1&gt;<br>typealias A_3 = Any&lt;A_2&gt;<br>/* and so on */<br></p><p>This proposal should ban redundancy right from the beginning. If there might be any desire to relax a few things, it won’t introduce any breaking changes for Any&lt;...&gt; existential.<br></p><p>Proposed solution<br></p><p>If empty Any&lt;&gt; won’t be disallowed in SE–0095, we should disallow nesting empty Any&lt;&gt; inside of Any&lt;...&gt;.<br></p><p>Disallow nesting Any (type refers to current typealias Any = protocol&lt;&gt;) inside of Any&lt;...&gt;.<br></p><p>Disallow Any&lt;...&gt; containing a single Type like Any&lt;Type&gt;.<br></p><p>The first three rules will ban constructs like Any&lt;Any&lt;&gt;, Type&gt; or Any&lt;Any, Type&gt; and force the developer to use Type instead.<br></p><p>Disallow nesting a single Any&lt;...&gt; inside another Any&lt;...&gt;.<br>e.g. Any&lt;Any&lt;FirstType, SecondType&gt;&gt;<br>Disallow same type usage like Any&lt;A, A&gt; or Any&lt;A, B, A&gt; and force the developer to use A or Any&lt;A, B&gt; if A and B are distinct.<br></p><p>Disallow forming redundant types when the provided constraints are not independent.<br></p><p>// Right now `type` can only be `protocol` but in the future Any&lt;...&gt;   <br>// could also allow `class`, `struct` and `enum`.<br>// In this example `B` and `C` are distinct.<br>type A: B, C {}   <br>      <br>// all following types are equivalent to `A`<br>Any&lt;A, Any&lt;B, C&gt;&gt;<br>Any&lt;Any&lt;A, B&gt;, C&gt;<br>Any&lt;Any&lt;A, C&gt;, B&gt;<br>Any&lt;A, B, C&gt;<br>Any&lt;A, B&gt;<br>Any&lt;A, C&gt;<br></p><p>If all contraints form a known Type provide a Fix-it error depending on the current context. If there is more than one Type, provide all alternatives to the developer.<br></p><p>Using Any&lt;...&gt; in a generic context might not produce a Fix-it error:<br></p><p>protocol A {}<br>protocol B {}<br>protocol C: A, B {}<br>          <br>// there is no need for `Fix-it` in such a context<br>func foo&lt;T: Any&lt;A, B&gt;&gt;(value: T) {}<br></p><p>Impact on existing code<br></p><p>These changes will break existing code. Projects abusing Any&lt;...&gt; to create redundant types should be reconsidered of usings the equivalent Type the compiler would infer. One would be forced to use A instead of Any&lt;A&gt; for example. A Fix-it error message can help the developer to migrate his project.<br></p><p>Alternatives considered<br></p><p>Leave redundancy as-is for Swift 3 and live with it.<br>Deprecate redundancy in a future version of Swift, which will introduce breaking changes.<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/ece21c05/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Disallow redundant `Any&lt;...&gt;` constructs</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 20, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On May 20, 2016, at 2:07 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; I actually like &quot;any&lt;P1, P2&gt;&quot;. It does provide that very distinctive visual signal that any&lt;&gt; is not a generic type, and that &#39;any&#39; is not itself a type, but rather a special keyword for constructing an existential:<br>&gt; <br>&gt; Array&lt;Int&gt;  // a generic type, Array, containing integers<br>&gt; any&lt;P1, P2&gt; // a protocol composition of two protocols<br>&gt; <br>&gt; In this case, would we want to support &quot;any&lt;&gt;&quot; in addition to Any? The parsing issues should go away, since these are two different identifiers.<br></p><p>Isn’t `Any` a typealias for `any&lt;&gt;`?  If so, we have to support `any&lt;&gt;`! :)<br></p><p>&gt; <br>&gt; Austin<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Fri, May 20, 2016 at 12:04 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On May 20, 2016, at 2:00 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I think you should submit this for review, but I also think you should take the part of your older proposal to add class support to Any&lt;...&gt; and submit it as a separate proposal. (I mean, the part where you can define things like &quot;Any&lt;UIViewController, Protocol&gt;&quot; or &quot;Any&lt;class, Protocol&gt;&quot;.)<br>&gt;&gt; <br>&gt;&gt; Yes, it is additive, but even getting that feature into Swift 3 would be an enormous benefit if it can be implemented easily. And the core team is probably better positioned than anyone else to determine whether that&#39;s true.<br>&gt; <br>&gt; Austin, what is your thought on switching to `any` rather than `Any` since it does not behave like a user-defined generic type?  The convention is for types to be uppercase and keywords to be lowercase.  This falls more into the category of a keyword and has its own behavior distinct from the behavior of all generic types.  Making it stand out syntactically will help to make that clear.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt; On Fri, May 20, 2016 at 2:39 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This is a follow up proposal to SE-0095 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0095-any-as-existential.md&gt; which should be considered for Swift 3 if SE-0095 will be accepted.<br>&gt;&gt; <br>&gt;&gt; Here is the formatted draft: https://github.com/DevAndArtist/swift-evolution/blob/master/proposals/nnnn-ban-redundancy-in-any-existential.md &lt;https://github.com/DevAndArtist/swift-evolution/blob/master/proposals/nnnn-ban-redundancy-in-any-existential.md&gt;<br>&gt;&gt; <br>&gt;&gt; Please provide your feedback in this thread, and don’t make a race who is making a better proposal on the exact same topic.<br>&gt;&gt; <br>&gt;&gt; If you spot any types or other mistakes I’d be happy to see you pointing me to them. ;)<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Adrian Zubarev<br>&gt;&gt; Sent with Airmail<br>&gt;&gt; <br>&gt;&gt; Disallow redundant Any&lt;...&gt; constructs<br>&gt;&gt; <br>&gt;&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>&gt;&gt; Author: Adrian Zubarev &lt;https://github.com/DevAndArtist&gt;<br>&gt;&gt; Status: Awaiting review &lt;&gt;<br>&gt;&gt; Review manager: TBD<br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; This is a follow up proposal to SE–0095 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0095-any-as-existential.md&gt;, if it will be accepted for Swift 3. The current concept of Any&lt;...&gt; introduced in SE–0095 will allow creation of redundant types like Any&lt;A&gt; == A. I propose to disallow such redundancy in Swift 3 to prevent breaking changes in a future version of Swift.<br>&gt;&gt; <br>&gt;&gt; Swift-evolution thread: [Proposal] Disallow redundant Any&lt;...&gt; constructs &lt;&gt;<br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; If SE–0095 will be accepted there will be future proposals to enhance its capabilities. Two of these will be Any-type requirement (where type could be class, struct or enum) and Class requirement. Without any restrictions these will introduce more redundancy.<br>&gt;&gt; <br>&gt;&gt; As said before it is possible to create redundant types like Any&lt;A&gt; == A or endless shadowed redundant nesting:<br>&gt;&gt; <br>&gt;&gt; typealias A_1 = Any&lt;A&gt;<br>&gt;&gt; typealias A_2 = Any&lt;A_1&gt;<br>&gt;&gt; typealias A_3 = Any&lt;A_2&gt;<br>&gt;&gt; /* and so on */<br>&gt;&gt; This proposal should ban redundancy right from the beginning. If there might be any desire to relax a few things, it won’t introduce any breaking changes for Any&lt;...&gt; existential.<br>&gt;&gt; <br>&gt;&gt; Proposed solution<br>&gt;&gt; <br>&gt;&gt; If empty Any&lt;&gt; won’t be disallowed in SE–0095, we should disallow nesting empty Any&lt;&gt; inside of Any&lt;...&gt;.<br>&gt;&gt; <br>&gt;&gt; Disallow nesting Any (type refers to current typealias Any = protocol&lt;&gt;) inside of Any&lt;...&gt;.<br>&gt;&gt; <br>&gt;&gt; Disallow Any&lt;...&gt; containing a single Type like Any&lt;Type&gt;.<br>&gt;&gt; <br>&gt;&gt; The first three rules will ban constructs like Any&lt;Any&lt;&gt;, Type&gt; or Any&lt;Any, Type&gt; and force the developer to use Type instead.<br>&gt;&gt; <br>&gt;&gt; Disallow nesting a single Any&lt;...&gt; inside another Any&lt;...&gt;.<br>&gt;&gt; e.g. Any&lt;Any&lt;FirstType, SecondType&gt;&gt;<br>&gt;&gt; Disallow same type usage like Any&lt;A, A&gt; or Any&lt;A, B, A&gt; and force the developer to use A or Any&lt;A, B&gt; if A and B are distinct.<br>&gt;&gt; <br>&gt;&gt; Disallow forming redundant types when the provided constraints are not independent.<br>&gt;&gt; <br>&gt;&gt; // Right now `type` can only be `protocol` but in the future Any&lt;...&gt;  <br>&gt;&gt; // could also allow `class`, `struct` and `enum`.<br>&gt;&gt; // In this example `B` and `C` are distinct.<br>&gt;&gt; type A: B, C {}  <br>&gt;&gt;      <br>&gt;&gt; // all following types are equivalent to `A`<br>&gt;&gt; Any&lt;A, Any&lt;B, C&gt;&gt;<br>&gt;&gt; Any&lt;Any&lt;A, B&gt;, C&gt;<br>&gt;&gt; Any&lt;Any&lt;A, C&gt;, B&gt;<br>&gt;&gt; Any&lt;A, B, C&gt;<br>&gt;&gt; Any&lt;A, B&gt;<br>&gt;&gt; Any&lt;A, C&gt;<br>&gt;&gt; If all contraints form a known Type provide a Fix-it error depending on the current context. If there is more than one Type, provide all alternatives to the developer.<br>&gt;&gt; <br>&gt;&gt; Using Any&lt;...&gt; in a generic context might not produce a Fix-it error:<br>&gt;&gt; <br>&gt;&gt; protocol A {}<br>&gt;&gt; protocol B {}<br>&gt;&gt; protocol C: A, B {}<br>&gt;&gt;          <br>&gt;&gt; // there is no need for `Fix-it` in such a context<br>&gt;&gt; func foo&lt;T: Any&lt;A, B&gt;&gt;(value: T) {}<br>&gt;&gt; Impact on existing code<br>&gt;&gt; <br>&gt;&gt; These changes will break existing code. Projects abusing Any&lt;...&gt; to create redundant types should be reconsidered of usings the equivalent Type the compiler would infer. One would be forced to use A instead of Any&lt;A&gt; for example. A Fix-it error message can help the developer to migrate his project.<br>&gt;&gt; <br>&gt;&gt; Alternatives considered<br>&gt;&gt; <br>&gt;&gt; Leave redundancy as-is for Swift 3 and live with it.<br>&gt;&gt; Deprecate redundancy in a future version of Swift, which will introduce breaking changes.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/98635c3a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Proposal] Disallow redundant `Any&lt;...&gt;` constructs</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May 20, 2016 at 09:00:00pm</p></header><div class="content"><p>Isn’t `Any` a typealias for `any&lt;&gt;`?  If so, we have to support `any&lt;&gt;`! :)<br>Yes it is and SE-0095 will cause that all types implicitly conform to empty any&lt;&gt;.<br></p><p>This still can be banned from any&lt;any&lt;&gt;, A&gt; because its useless and redundant. But is up to the core team to decide.<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/7c0b0e4e/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal] Disallow redundant `Any&lt;...&gt;` constructs</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 20, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; Austin, what is your thought on switching to `any` rather than `Any` since it does not behave like a user-defined generic type?  The convention is for types to be uppercase and keywords to be lowercase.  This falls more into the category of a keyword and has its own behavior distinct from the behavior of all generic types.  Making it stand out syntactically will help to make that clear.<br></p><p>You didn&#39;t ask me, but I&#39;ll weigh in: I&#39;m not a fan.<br></p><p>* I think `Any` (without parameters) should be uppercase, and I don&#39;t think we should have both `Any` and `any&lt;&gt;` or `any`. Death to the typealias!<br>* If type-erasing structs like `AnySequence` are eventually subsumed by this syntax, I would prefer they be called `Any&lt;Sequence&gt;` instead of `any&lt;Sequence&gt;`.<br>* In the `willSet` vs. `willset` thread, I proposed a rule that keywords which fit into a particular syntactic slot should be capitalized like normal members of that slot. For instance, if `dynamicType` is a pseudo-property, it should be capitalized like a property. Since `Any&lt;&gt;` fits in the syntactic slot of a type, it should be capitalized like a type.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Disallow redundant `Any&lt;...&gt;` constructs</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 20, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On May 20, 2016, at 6:56 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; Austin, what is your thought on switching to `any` rather than `Any` since it does not behave like a user-defined generic type?  The convention is for types to be uppercase and keywords to be lowercase.  This falls more into the category of a keyword and has its own behavior distinct from the behavior of all generic types.  Making it stand out syntactically will help to make that clear.<br>&gt; <br>&gt; You didn&#39;t ask me, but I&#39;ll weigh in: I&#39;m not a fan.<br></p><p>Sorry, I asked Austin because he is heading up the proposal.  Didn’t meant to leave anyone out.  Thanks for providing feedback!<br></p><p>&gt; <br>&gt; * I think `Any` (without parameters) should be uppercase, and I don&#39;t think we should have both `Any` and `any&lt;&gt;` or `any`. Death to the typealias!<br></p><p>Why do you think this?  `any&lt;&gt;` (or `Any&lt;&gt;`) is replacing `protocol&lt;&gt;`.  `protocol` is a keyword, so following the convention you shared it should be all lowercase.  Aside from that, it behaves differently than a user-defined type (which would be uppercase).<br></p><p>&gt; * If type-erasing structs like `AnySequence` are eventually subsumed by this syntax, I would prefer they be called `Any&lt;Sequence&gt;` instead of `any&lt;Sequence&gt;`.<br></p><p>Are you arguing this because they are types?  They are currently structs.  If they were subsumed by this proposal they most definitely would not be structs.  If it’s just syntax you’re concerned with, we could add a typealias:<br></p><p>typealias AnySequence&lt;T&gt; = any&lt;Sequence where .Iterator.Element == T&gt;<br></p><p>I haven’t evaluated AnySequence relative to the existential this typealias would produce.  If the visible interface is compatible there would be a strong argument for introducing this typealias.  The argument for lowercase wouldn’t apply to the typealias.<br></p><p>&gt; * In the `willSet` vs. `willset` thread, I proposed a rule that keywords which fit into a particular syntactic slot should be capitalized like normal members of that slot. For instance, if `dynamicType` is a pseudo-property, it should be capitalized like a property. Since `Any&lt;&gt;` fits in the syntactic slot of a type, it should be capitalized like a type.<br></p><p>Any has some overlap with types, but it cannot be used everywhere a type can.  This is precisely why it should be lowercase.  I don’t believe it falls under that exemption in your proposal.  I believe it’s a good exemption when the keyword is indistinguishable to users from a normal member.  I don’t believe it’s a good exemption when the behavior is “special” in some way.<br></p><p>-Matthew<br></p><p>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/54301588/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal] Disallow redundant `Any&lt;...&gt;` constructs</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 20, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt;&gt; * I think `Any` (without parameters) should be uppercase, and I don&#39;t think we should have both `Any` and `any&lt;&gt;` or `any`. Death to the typealias!<br>&gt; <br>&gt; Why do you think this?  `any&lt;&gt;` (or `Any&lt;&gt;`) is replacing `protocol&lt;&gt;`.  `protocol` is a keyword, so following the convention you shared it should be all lowercase.  Aside from that, it behaves differently than a user-defined type (which would be uppercase).<br></p><p>What I&#39;m saying is that I strongly prefer this:<br></p><p>	func print(_ values: Any..., separator: String, terminator: String)<br></p><p>To this:<br></p><p>	func print(_ values: any..., separator: String, terminator: String)<br></p><p>And that I think it would be confusing and unnecessarily duplicative to have both `Any` and `any&lt;...&gt;` in the language, differing only in capitalization.<br></p><p>&gt;&gt; * If type-erasing structs like `AnySequence` are eventually subsumed by this syntax, I would prefer they be called `Any&lt;Sequence&gt;` instead of `any&lt;Sequence&gt;`.<br>&gt; <br>&gt; Are you arguing this because they are types?  They are currently structs.  If they were subsumed by this proposal they most definitely would not be structs.<br></p><p>No—what I&#39;m saying is that, in a choice between `Any&lt;Sequence&gt;` and `any&lt;Sequence&gt;`, I would prefer to use `Any&lt;Sequence&gt;`. The `Any&lt;…&gt;` here is acting like a type (actually, it *is* a type, just a slightly special type) and it should be capitalized like a type.<br></p><p>&gt; If it’s just syntax you’re concerned with, we could add a typealias:<br>&gt; <br>&gt; typealias AnySequence&lt;T&gt; = any&lt;Sequence where .Iterator.Element == T&gt;<br></p><p>This is quite the opposite of what I would want—I would much prefer that people use `Any&lt;Sequence&gt;` directly rather than an `AnySequence` typedef. This will help them learn that the feature is there for other situations, like `Any&lt;Equatable&gt;`.<br></p><p>In general, I believe it&#39;s a good idea to expose `Any&lt;…&gt;` directly, rather than hiding it behind a typealias. For the cost of a few extra characters, we expose a lot of power and flexibility directly to the user. For instance, if you see `Any&lt;Collection where .Element == String&gt;`, it&#39;s a small step to realize that you could also say `Any&lt;Collection where .Index == Int&gt;`. If you&#39;re always using `AnyCollection&lt;String&gt;`, on the other hand, you may never figure that out.<br></p><p>&gt;&gt; * In the `willSet` vs. `willset` thread, I proposed a rule that keywords which fit into a particular syntactic slot should be capitalized like normal members of that slot. For instance, if `dynamicType` is a pseudo-property, it should be capitalized like a property. Since `Any&lt;&gt;` fits in the syntactic slot of a type, it should be capitalized like a type.<br>&gt; <br>&gt; Any has some overlap with types, but it cannot be used everywhere a type can.<br></p><p>Are there places where you can use any type *except* an `Any&lt;…&gt;` type? I know there are places where you need to use (for instance) a class or a protocol, but in those cases Swift is rejecting a wide variety of unacceptable types, only one of which is `Any&lt;…&gt;`.<br></p><p>&gt; This is precisely why it should be lowercase.  I don’t believe it falls under that exemption in your proposal.  I believe it’s a good exemption when the keyword is indistinguishable to users from a normal member.  I don’t believe it’s a good exemption when the behavior is “special” in some way.<br></p><p>The behavior of a keyword is always &quot;special&quot; in some way; if it weren&#39;t, it wouldn&#39;t be a keyword. `dynamicType` is special because it&#39;s available on all instances, even though `extension Any` is not valid. `willSet` is special (compared to accessors from user-provided property behaviors) because you don&#39;t need to enable some specific property behavior to get it. And `Any` is special because it&#39;s variadic and acts as a subtype of many unrelated types. But it still walks like a type and quacks like a type, and so we should still spell it like a type.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>[Proposal] Disallow redundant `Any&lt;...&gt;` constructs</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>May 21, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; What I&#39;m saying is that I strongly prefer this:<br>&gt; <br>&gt;    func print(_ values: Any..., separator: String, terminator: String)<br>&gt; <br>&gt; To this:<br>&gt; <br>&gt;    func print(_ values: any..., separator: String, terminator: String)<br>&gt; <br>&gt; And that I think it would be confusing and unnecessarily duplicative to have both `Any` and `any&lt;...&gt;` in the language, differing only in capitalization.<br></p><p>I agree personally. The way I see it, Any&lt;&gt; refers to the type, which should be upper camel case.<br></p><p>&gt; No—what I&#39;m saying is that, in a choice between `Any&lt;Sequence&gt;` and `any&lt;Sequence&gt;`, I would prefer to use `Any&lt;Sequence&gt;`. The `Any&lt;…&gt;` here is acting like a type (actually, it *is* a type, just a slightly special type) and it should be capitalized like a type.<br></p><p>Yep, you hit the nail on the head. Exactly right.<br></p><p>&gt; This is quite the opposite of what I would want—I would much prefer that people use `Any&lt;Sequence&gt;` directly rather than an `AnySequence` typedef. This will help them learn that the feature is there for other situations, like `Any&lt;Equatable&gt;`.<br></p><p>Agreed. Any&lt;&gt; is an extensible construct. AnySequence is not.<br></p><p>&gt; In general, I believe it&#39;s a good idea to expose `Any&lt;…&gt;` directly, rather than hiding it behind a typealias. For the cost of a few extra characters, we expose a lot of power and flexibility directly to the user. For instance, if you see `Any&lt;Collection where .Element == String&gt;`, it&#39;s a small step to realize that you could also say `Any&lt;Collection where .Index == Int&gt;`. If you&#39;re always using `AnyCollection&lt;String&gt;`, on the other hand, you may never figure that out.<br></p><p>- Rod<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Disallow redundant `Any&lt;...&gt;` constructs</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 20, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On May 20, 2016, at 8:29 PM, Rod Brown &lt;rodney.brown6 at icloud.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; What I&#39;m saying is that I strongly prefer this:<br>&gt;&gt; <br>&gt;&gt;   func print(_ values: Any..., separator: String, terminator: String)<br>&gt;&gt; <br>&gt;&gt; To this:<br>&gt;&gt; <br>&gt;&gt;   func print(_ values: any..., separator: String, terminator: String)<br>&gt;&gt; <br>&gt;&gt; And that I think it would be confusing and unnecessarily duplicative to have both `Any` and `any&lt;...&gt;` in the language, differing only in capitalization.<br>&gt; <br>&gt; I agree personally. The way I see it, Any&lt;&gt; refers to the type, which should be upper camel case.<br>&gt; <br>&gt;&gt; No—what I&#39;m saying is that, in a choice between `Any&lt;Sequence&gt;` and `any&lt;Sequence&gt;`, I would prefer to use `Any&lt;Sequence&gt;`. The `Any&lt;…&gt;` here is acting like a type (actually, it *is* a type, just a slightly special type) and it should be capitalized like a type.<br>&gt; <br>&gt; Yep, you hit the nail on the head. Exactly right.<br></p><p>If `any` could be used in all of the same ways as a generic type I would agree.  But it can’t.  I think making it look like a generic type would be confusing to new users.<br></p><p>&gt; <br>&gt;&gt; This is quite the opposite of what I would want—I would much prefer that people use `Any&lt;Sequence&gt;` directly rather than an `AnySequence` typedef. This will help them learn that the feature is there for other situations, like `Any&lt;Equatable&gt;`.<br>&gt; <br>&gt; Agreed. Any&lt;&gt; is an extensible construct. AnySequence is not.<br>&gt; <br>&gt;&gt; In general, I believe it&#39;s a good idea to expose `Any&lt;…&gt;` directly, rather than hiding it behind a typealias. For the cost of a few extra characters, we expose a lot of power and flexibility directly to the user. For instance, if you see `Any&lt;Collection where .Element == String&gt;`, it&#39;s a small step to realize that you could also say `Any&lt;Collection where .Index == Int&gt;`. If you&#39;re always using `AnyCollection&lt;String&gt;`, on the other hand, you may never figure that out.<br>&gt; <br>&gt; - Rod<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Disallow redundant `Any&lt;...&gt;` constructs</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 20, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On May 20, 2016, at 8:16 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; * I think `Any` (without parameters) should be uppercase, and I don&#39;t think we should have both `Any` and `any&lt;&gt;` or `any`. Death to the typealias!<br>&gt;&gt; <br>&gt;&gt; Why do you think this?  `any&lt;&gt;` (or `Any&lt;&gt;`) is replacing `protocol&lt;&gt;`.  `protocol` is a keyword, so following the convention you shared it should be all lowercase.  Aside from that, it behaves differently than a user-defined type (which would be uppercase).<br>&gt; <br>&gt; What I&#39;m saying is that I strongly prefer this:<br>&gt; <br>&gt; 	func print(_ values: Any..., separator: String, terminator: String)<br>&gt; <br>&gt; To this:<br>&gt; <br>&gt; 	func print(_ values: any..., separator: String, terminator: String)<br>&gt; <br>&gt; And that I think it would be confusing and unnecessarily duplicative to have both `Any` and `any&lt;...&gt;` in the language, differing only in capitalization.<br></p><p>If you don’t want the duplication it would be:<br></p><p>func print(_ values: any&lt;&gt;..., separator: String, terminator: String)<br></p><p>The fact that `any` is not a normal type is immediately obvious here.  That said, I favor keeping the typealias.<br></p><p>&gt; <br>&gt;&gt;&gt; * If type-erasing structs like `AnySequence` are eventually subsumed by this syntax, I would prefer they be called `Any&lt;Sequence&gt;` instead of `any&lt;Sequence&gt;`.<br>&gt;&gt; <br>&gt;&gt; Are you arguing this because they are types?  They are currently structs.  If they were subsumed by this proposal they most definitely would not be structs.<br>&gt; <br>&gt; No—what I&#39;m saying is that, in a choice between `Any&lt;Sequence&gt;` and `any&lt;Sequence&gt;`, I would prefer to use `Any&lt;Sequence&gt;`. The `Any&lt;…&gt;` here is acting like a type (actually, it *is* a type, just a slightly special type) and it should be capitalized like a type.<br></p><p>It can be used as a type in some ways.  It can also be used as a generic constraint.<br></p><p>But what happens inside the angle brackets is very different than what happens inside the angle brackets for a generic type.  You can most definitely not use it as if it were a generic type.  Making that distinction clear is important IMO.<br></p><p>To be honest it won’t bother me much either way.  I am arguing mostly out of what I think will cause the least confusion for new users learning the language.<br></p><p>&gt; <br>&gt;&gt; If it’s just syntax you’re concerned with, we could add a typealias:<br>&gt;&gt; <br>&gt;&gt; typealias AnySequence&lt;T&gt; = any&lt;Sequence where .Iterator.Element == T&gt;<br>&gt; <br>&gt; This is quite the opposite of what I would want—I would much prefer that people use `Any&lt;Sequence&gt;` directly rather than an `AnySequence` typedef. This will help them learn that the feature is there for other situations, like `Any&lt;Equatable&gt;`.<br></p><p>But any&lt;Sequence&gt; is not at all the same as AnySequence.  any&lt;Sequence&gt; is a valid existential which can be used as-is.  AnySequence is a generic struct that must be bound to a type argument before use.  any&lt;Sequence where .Iterator.Element == String&gt; is roughly the same as AnySequence&lt;String&gt;.  However, the former is much more verbose (even when you can just say .Element instead of .Iterator.Element), thus the attractiveness of a typealias.<br></p><p>&gt; <br>&gt; In general, I believe it&#39;s a good idea to expose `Any&lt;…&gt;` directly, rather than hiding it behind a typealias. For the cost of a few extra characters, we expose a lot of power and flexibility directly to the user. For instance, if you see `Any&lt;Collection where .Element == String&gt;`, it&#39;s a small step to realize that you could also say `Any&lt;Collection where .Index == Int&gt;`. If you&#39;re always using `AnyCollection&lt;String&gt;`, on the other hand, you may never figure that out.<br></p><p>I disagree.  Fully written out constrained existentials will quickly become verbose.  Typealias is essential to making them comfortable.<br></p><p>&gt; <br>&gt;&gt;&gt; * In the `willSet` vs. `willset` thread, I proposed a rule that keywords which fit into a particular syntactic slot should be capitalized like normal members of that slot. For instance, if `dynamicType` is a pseudo-property, it should be capitalized like a property. Since `Any&lt;&gt;` fits in the syntactic slot of a type, it should be capitalized like a type.<br>&gt;&gt; <br>&gt;&gt; Any has some overlap with types, but it cannot be used everywhere a type can.<br>&gt; <br>&gt; Are there places where you can use any type *except* an `Any&lt;…&gt;` type? I know there are places where you need to use (for instance) a class or a protocol, but in those cases Swift is rejecting a wide variety of unacceptable types, only one of which is `Any&lt;…&gt;`.<br></p><p>You cannot put any type dependent on generic arguments inside the angle brackets with `any`.<br></p><p>&gt; <br>&gt;&gt; This is precisely why it should be lowercase.  I don’t believe it falls under that exemption in your proposal.  I believe it’s a good exemption when the keyword is indistinguishable to users from a normal member.  I don’t believe it’s a good exemption when the behavior is “special” in some way.<br>&gt; <br>&gt; The behavior of a keyword is always &quot;special&quot; in some way; if it weren&#39;t, it wouldn&#39;t be a keyword. `dynamicType` is special because it&#39;s available on all instances, even though `extension Any` is not valid.<br></p><p>`dynamicType` is indistinguishable from a manually implemented property that returns a metatype.  The only thing “special” is the implicit implementation for all types.  The behavior of the member itself is not “special”.<br></p><p>The fact that `extension any` is not valid adds more weight to the argument that it does not behave like a type or protocol.<br></p><p>&gt; `willSet` is special (compared to accessors from user-provided property behaviors) because you don&#39;t need to enable some specific property behavior to get it.<br></p><p>Isn’t that going to change when we have property behaviors?  Even if it doesn’t, it could be implemented as a behavior (I believe Joe had an example of this in the proposal).<br></p><p>&gt; And `Any` is special because it&#39;s variadic and acts as a subtype of many unrelated types. But it still walks like a type and quacks like a type, and so we should still spell it like a type.<br></p><p>There are similarities but I think the differences are significant enough to warrant exempting `any` from your exemption rule.  They are certainly much more significant than in any of these other cases.<br></p><p>-Matthew<br></p><p>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Disallow redundant `Any&lt;...&gt;` constructs</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 20, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; The `Any&lt;…&gt;` here is acting like a type (actually, it *is* a type, just a slightly special type) and it should be capitalized like a type.<br></p><p>One more point around this comment.  While `any&lt;MyProtocol&gt;` is a type `any` is not a type.  `any` is a kind of type. We have classes, structs, enums, and existentials.  We don’t capitalize `struct`, `class`, or `enum`.  Why should we capitalize `any` just because it is often going to be declared ad-hoc (and again, I think it is worthwhile to give existential types a name in many cases, just as we give other types a name — preferring structs to tuples, for example).  Making `any` lowercase emphasizes the fact that it is a kind of type rather than a type.<br></p><p>I really don’t want to come across as argumentative here.  I’m just really trying to work out what is best for the language.  I will be very happy using a language with generalized existentials regardless of whether we capitalize the `a` or not.<br></p><p>-Matthew<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/f8698310/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal] Disallow redundant `Any&lt;...&gt;` constructs</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 20, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; One more point around this comment.  While `any&lt;MyProtocol&gt;` is a type `any` is not a type.  `any` is a kind of type. We have classes, structs, enums, and existentials.  We don’t capitalize `struct`, `class`, or `enum`.  Why should we capitalize `any` just because it is often going to be declared ad-hoc (and again, I think it is worthwhile to give existential types a name in many cases, just as we give other types a name — preferring structs to tuples, for example).  Making `any` lowercase emphasizes the fact that it is a kind of type rather than a type.<br></p><p>The current `Any`, and the proposed `any&lt;&gt;` (and `any`, which I&#39;m presuming is equivalent), *are* types. They are not categories of types like `class` or `struct` or `enum`; you can declare variables as them, you can cast to them, you can check if values match them. You probably ought to be able to take an `Any&lt;Foo, Bar&gt;.Type` and call a `Foo` or `Bar` initializer on it to get an `Any&lt;Foo, Bar&gt;` (although I don&#39;t know if Swift supports that right now). In short, you can do all the things with them that one would expect to do with a type. Because they are types.<br></p><p>So if you&#39;re saying that `any&lt;&gt;`/`Any&lt;&gt;` is not a type, I think you&#39;re quite wrong. If you&#39;re saying that `any&lt;&gt;`/`Any&lt;&gt;` is a type but `any`/`Any` is not, then we disagree on my position that these should be equivalent.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Disallow redundant `Any&lt;...&gt;` constructs</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 20, 2016 at 10:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>On May 20, 2016, at 10:47 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br></p><p>&gt;&gt; One more point around this comment.  While `any&lt;MyProtocol&gt;` is a type `any` is not a type.  `any` is a kind of type. We have classes, structs, enums, and existentials.  We don’t capitalize `struct`, `class`, or `enum`.  Why should we capitalize `any` just because it is often going to be declared ad-hoc (and again, I think it is worthwhile to give existential types a name in many cases, just as we give other types a name — preferring structs to tuples, for example).  Making `any` lowercase emphasizes the fact that it is a kind of type rather than a type.<br>&gt; <br>&gt; The current `Any`, and the proposed `any&lt;&gt;` (and `any`, which I&#39;m presuming is equivalent), *are* types. They are not categories of types like `class` or `struct` or `enum`;<br></p><p>Existentials most definitely are a distinct kind / category of type, with a distinct implementation and a distinct runtime representation.<br></p><p>&gt; you can declare variables as them, you can cast to them, you can check if values match them. You probably ought to be able to take an `Any&lt;Foo, Bar&gt;.Type` and call a `Foo` or `Bar` initializer on it to get an `Any&lt;Foo, Bar&gt;` (although I don&#39;t know if Swift supports that right now). In short, you can do all the things with them that one would expect to do with a type. Because they are types.<br>&gt; <br>&gt; So if you&#39;re saying that `any&lt;&gt;`/`Any&lt;&gt;` is not a type, I think you&#39;re quite wrong. If you&#39;re saying that `any&lt;&gt;`/`Any&lt;&gt;` is a type but `any`/`Any` is not, then we disagree on my position that these should be equivalent.<br></p><p>I am saying the latter.  I prefer the lowercase keyword and uppercase &#39;typealias Any = any&lt;&gt;&#39;<br></p><p>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Proposal] Disallow redundant `Any&lt;...&gt;` constructs</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May 21, 2016 at 09:00:00am</p></header><div class="content"><p>I am saying the latter. I prefer the lowercase keyword and uppercase &#39;typealias Any = any&lt;&gt;&#39;<br>Thats what I also would prefer.<br></p><p>And as we speak in this thread here: any&lt;Equatable&gt; won’t be allowed because its useless and redundant to Equatable.<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160521/2cab3bb7/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Proposal] Disallow redundant `Any&lt;...&gt;` constructs</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May 20, 2016 at 09:00:00pm</p></header><div class="content"><p>I think you should submit this for review, but I also think you should take the part of your older proposal to add class support to Any&lt;...&gt; and submit it as a separate proposal. (I mean, the part where you can define things like &quot;Any&lt;UIViewController, Protocol&gt;&quot; or &quot;Any&lt;class, Protocol&gt;&quot;.)<br></p><p>I’d like to separate these into different proposals like already suggested on github. Not sure about `Any&lt;class, Protocol&gt;`. I’m not even sure what we’ll get in Swift 3 now from the Generics Manifesto. I’ll submit `Any&lt;UIView, Protocol&gt;` proposal as soon as I can find some time to rewrite it.<br>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 20. Mai 2016 bei 21:00:38, Austin Zheng (austinzheng at gmail.com) schrieb:<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/e4fae2cb/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
