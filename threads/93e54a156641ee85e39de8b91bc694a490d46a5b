<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d2fcdd5a6abf7204973117f37a18671?s=50"></div><header><strong>NSTask and try!</strong> from <string>Bouke Haarsma</string> &lt;bouke at haarsma.eu&gt;<p>May 14, 2016 at 10:00:00am</p></header><div class="content"><p>The failing testcase is <br>TestNSTask.test_pipe_stdout_and_stderr_same_pipe. The call to <br>posix_spawn returns an error code 9 (EBADF). <br></p><p>In order to avoid code repetition I&#39;ve wrapped all posix calls with a <br>throwing status code check;<br></p><p>private func posix(_ code: Int32) throws {<br>    switch code {<br>    case 0: return<br>    default: throw NSError(domain: NSPOSIXErrorDomain, code: Int(code), <br>userInfo: nil)<br>    }<br>}<br></p><p>However this produces the not-so-helpful error dump on OSX:<br></p><p>Test Case &#39;TestNSTask.test_pipe_stdout_and_stderr_same_pipe&#39; started at <br>10:20:59.741<br>fatal error: &#39;try!&#39; expression unexpectedly raised an error: &lt;NSError: <br>0x0000600000067c40&gt;: file <br>/Users/buildnode/jenkins/workspace/oss-swift-package-osx/swift/stdlib/public/core/ErrorType.swift, <br>line 53<br></p><p><br></p><p>On 2016-05-13 21:07:59 +0000, Tony Parker via swift-corelibs-dev said:<br></p><p>&gt; <br>&gt;&gt; On May 13, 2016, at 1:05 PM, James Lee &lt;james at jelee.co.uk&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Cheers for the clarification. I started assuming there may be a reason <br>&gt;&gt; when changing the guard let on the launch args to use the <br>&gt;&gt; InvalidArgumentException.<br>&gt;&gt; <br>&gt;&gt; Could this be a position where we may need os checking to cover the <br>&gt;&gt; regression for the moment. It seems odd that the test would pass in CI <br>&gt;&gt; when an error is thrown with a try! but fail on OSX<br>&gt; Task is certainly one of the cases where the underlying stuff that <br>&gt; we’re abstracting is significantly different, so I’m not too surprised.<br>&gt; <br>&gt; We should try to get something in place so we’re not failing on OS X in <br>&gt; the short term for sure.<br>&gt; <br>&gt; - Tony<br>&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt;&gt; On 13 May 2016, at 20:48, Tony Parker &lt;anthony.parker at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi James,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 13, 2016, at 12:25 PM, James Lee via swift-corelibs-dev <br>&gt;&gt;&gt;&gt; &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Following on from a previous discussion with Tests failing on OSX. I <br>&gt;&gt;&gt;&gt; have been looking into the failures. It seems that one of the earliest <br>&gt;&gt;&gt;&gt; failures is due to an error from a try! within NSTask.launch(). This <br>&gt;&gt;&gt;&gt; came in with this commit: <br>&gt;&gt;&gt;&gt; https://github.com/apple/swift-corelibs-foundation/commit/4c6f04cfcad3d4b06688558021595d06751fc66a <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Going by the docs for Foundation - The launch function apparently <br>&gt;&gt;&gt;&gt; &quot;Raises an NSInvalidArgumentException if the launch path has not been <br>&gt;&gt;&gt;&gt; set or is invalid or if it fails to create a process.&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSTask_Class/#//apple_ref/occ/instm/NSTask/launch <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; My question is, should this be built into the Swift Foundation API? The <br>&gt;&gt;&gt;&gt; documentation for Swift doesn&#39;t state that the launch function throws.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; With the test that is failing expecting an error, it feels more Swift-y <br>&gt;&gt;&gt;&gt; to have any errors throw explicitly, rather than looking at what the <br>&gt;&gt;&gt;&gt; lower level fills the data with.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But before jumping into doing this, I would rather put it out there and <br>&gt;&gt;&gt;&gt; see what the community feels about this?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Unfortunately the ‘throws’ syntax in Swift often causes a mixup between <br>&gt;&gt;&gt; two different things, because it flipped the terminology from what all <br>&gt;&gt;&gt; of our documentation and header comments use.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. Cocoa uses exceptions (@throw in ObjC) to indicate programmer errors <br>&gt;&gt;&gt; and they are generally not intended to be recoverable.  Example: <br>&gt;&gt;&gt; passing nil where not expected, passing an invalid argument, failing to <br>&gt;&gt;&gt; meet a precondition of an API.<br>&gt;&gt;&gt; 2. Cocoa uses NSError ** to indicate runtime errors that are <br>&gt;&gt;&gt; recoverable or at least presentable to user. Example: out of disk <br>&gt;&gt;&gt; space, name of file already exists.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The ‘throws’ syntax in Swift is actually for case #2, not #1. In Swift, <br>&gt;&gt;&gt; #1 is fatalError or preconditionFailure. #2 is ‘throw Error’.<br></p><p>While API compatibility should be the fore-most goal here, I feel like <br>there&#39;s room for improvement here for the API overlays. While in ObjC <br>one has the ability to recover from NSInvalidArgumentException, on <br>Swift this would trap.<br></p><p>&gt;&gt;&gt; <br>&gt;&gt;&gt; In the case of NSTask, when the documentation says “raises an <br>&gt;&gt;&gt; NSInvalidArgumentException” (#1) then in Swift, that should translate <br>&gt;&gt;&gt; to fatalError or preconditionFailure.<br></p><p>As a resort; I propose to change the error wrapper (see <br>https://github.com/apple/swift-corelibs-foundation/pull/362):<br></p><p>private func posix(_ code: Int32) {<br>    switch code {<br>    case 0: return<br>    case EBADF: fatalError(&quot;POSIX command failed with error: \(code) -- EBADF&quot;)<br>    default: fatalError(&quot;POSIX command failed with error: \(code)&quot;)<br>    }<br>}<br></p><p>Which would produce the following –more helpful– error on OSX:<br></p><p>Test Case &#39;TestNSTask.test_pipe_stdout_and_stderr_same_pipe&#39; started at <br>10:13:55.584<br>fatal error: POSIX command failed with error: 9 -- EBADF: file <br>&lt;somedir&gt;/swift-corelibs-foundation/Foundation/NSTask.swift, line 424<br></p><p><br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hope this helps,<br>&gt;&gt;&gt; - Tony<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Cheers<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; James<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-corelibs-dev mailing list<br>&gt;&gt;&gt;&gt; swift-corelibs-dev at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-corelibs-dev mailing list<br>&gt; swift-corelibs-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20160514/93e56a5b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1d54deb32312ab6a282cde8637bc7077?s=50"></div><header><strong>NSTask and try!</strong> from <string>James Lee</string> &lt;james at jelee.co.uk&gt;<p>May 14, 2016 at 10:00:00am</p></header><div class="content"><p>This does seem to keep more inline with the current Darwin implementation. <br></p><p>Please excuse my ignorance, I have looked into the POSIX calls, but am I right in assuming that the EBADF is due to the test calling to a file that doesn&#39;t exist and that is just how OSX handles this case?<br></p><p>Cheers for the clarification<br></p><p>James<br></p><p>Sent from my iPhone<br></p><p>&gt; On 14 May 2016, at 09:33, Bouke Haarsma via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; The failing testcase is TestNSTask.test_pipe_stdout_and_stderr_same_pipe. The call to posix_spawn returns an error code 9 (EBADF). <br>&gt; <br>&gt; <br>&gt; <br>&gt; In order to avoid code repetition I&#39;ve wrapped all posix calls with a throwing status code check;<br>&gt; <br>&gt; <br>&gt; <br>&gt; private func posix(_ code: Int32) throws {<br>&gt; <br>&gt;     switch code {<br>&gt; <br>&gt;     case 0: return<br>&gt; <br>&gt;     default: throw NSError(domain: NSPOSIXErrorDomain, code: Int(code), userInfo: nil)<br>&gt; <br>&gt;     }<br>&gt; <br>&gt; }<br>&gt; <br>&gt; <br>&gt; <br>&gt; However this produces the not-so-helpful error dump on OSX:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Test Case &#39;TestNSTask.test_pipe_stdout_and_stderr_same_pipe&#39; started at 10:20:59.741<br>&gt; <br>&gt; fatal error: &#39;try!&#39; expression unexpectedly raised an error: &lt;NSError: 0x0000600000067c40&gt;: file /Users/buildnode/jenkins/workspace/oss-swift-package-osx/swift/stdlib/public/core/ErrorType.swift, line 53<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; On 2016-05-13 21:07:59 +0000, Tony Parker via swift-corelibs-dev said:<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; On May 13, 2016, at 1:05 PM, James Lee &lt;james at jelee.co.uk&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Cheers for the clarification. I started assuming there may be a reason when changing the guard let on the launch args to use the InvalidArgumentException.<br>&gt; <br>&gt; <br>&gt; <br>&gt; Could this be a position where we may need os checking to cover the regression for the moment. It seems odd that the test would pass in CI when an error is thrown with a try! but fail on OSX<br>&gt; <br>&gt; Task is certainly one of the cases where the underlying stuff that we’re abstracting is significantly different, so I’m not too surprised.<br>&gt; <br>&gt; <br>&gt; <br>&gt; We should try to get something in place so we’re not failing on OS X in the short term for sure.<br>&gt; <br>&gt; <br>&gt; <br>&gt; - Tony<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt; <br>&gt; <br>&gt; On 13 May 2016, at 20:48, Tony Parker &lt;anthony.parker at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Hi James,<br>&gt; <br>&gt; <br>&gt; <br>&gt; On May 13, 2016, at 12:25 PM, James Lee via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Following on from a previous discussion with Tests failing on OSX. I have been looking into the failures. It seems that one of the earliest failures is due to an error from a try! within NSTask.launch(). This came in with this commit: https://github.com/apple/swift-corelibs-foundation/commit/4c6f04cfcad3d4b06688558021595d06751fc66a<br>&gt; <br>&gt; <br>&gt; <br>&gt; Going by the docs for Foundation - The launch function apparently &quot;Raises an NSInvalidArgumentException if the launch path has not been set or is invalid or if it fails to create a process.&quot;<br>&gt; <br>&gt; <br>&gt; <br>&gt; https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSTask_Class/#//apple_ref/occ/instm/NSTask/launch<br>&gt; <br>&gt; <br>&gt; <br>&gt; My question is, should this be built into the Swift Foundation API? The documentation for Swift doesn&#39;t state that the launch function throws.<br>&gt; <br>&gt; <br>&gt; <br>&gt; With the test that is failing expecting an error, it feels more Swift-y to have any errors throw explicitly, rather than looking at what the lower level fills the data with.<br>&gt; <br>&gt; <br>&gt; <br>&gt; But before jumping into doing this, I would rather put it out there and see what the community feels about this?<br>&gt; <br>&gt; <br>&gt; <br>&gt; Unfortunately the ‘throws’ syntax in Swift often causes a mixup between two different things, because it flipped the terminology from what all of our documentation and header comments use.<br>&gt; <br>&gt; <br>&gt; <br>&gt; 1. Cocoa uses exceptions (@throw in ObjC) to indicate programmer errors and they are generally not intended to be recoverable.  Example: passing nil where not expected, passing an invalid argument, failing to meet a precondition of an API.<br>&gt; <br>&gt; 2. Cocoa uses NSError ** to indicate runtime errors that are recoverable or at least presentable to user. Example: out of disk space, name of file already exists.<br>&gt; <br>&gt; <br>&gt; <br>&gt; The ‘throws’ syntax in Swift is actually for case #2, not #1. In Swift, #1 is fatalError or preconditionFailure. #2 is ‘throw Error’.<br>&gt; <br>&gt; <br>&gt; <br>&gt; While API compatibility should be the fore-most goal here, I feel like there&#39;s room for improvement here for the API overlays. While in ObjC one has the ability to recover from NSInvalidArgumentException, on Swift this would trap.<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; In the case of NSTask, when the documentation says “raises an NSInvalidArgumentException” (#1) then in Swift, that should translate to fatalError or preconditionFailure.<br>&gt; <br>&gt; <br>&gt; <br>&gt; As a resort; I propose to change the error wrapper (see https://github.com/apple/swift-corelibs-foundation/pull/362):<br>&gt; <br>&gt; <br>&gt; <br>&gt; private func posix(_ code: Int32) {<br>&gt; <br>&gt;     switch code {<br>&gt; <br>&gt;     case 0: return<br>&gt; <br>&gt;     case EBADF: fatalError(&quot;POSIX command failed with error: \(code) -- EBADF&quot;)<br>&gt; <br>&gt;     default: fatalError(&quot;POSIX command failed with error: \(code)&quot;)<br>&gt; <br>&gt;     }<br>&gt; <br>&gt; }<br>&gt; <br>&gt; <br>&gt; <br>&gt; Which would produce the following –more helpful– error on OSX:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Test Case &#39;TestNSTask.test_pipe_stdout_and_stderr_same_pipe&#39; started at 10:13:55.584<br>&gt; <br>&gt; fatal error: POSIX command failed with error: 9 -- EBADF: file &lt;somedir&gt;/swift-corelibs-foundation/Foundation/NSTask.swift, line 424<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; Hope this helps,<br>&gt; <br>&gt; - Tony<br>&gt; <br>&gt; <br>&gt; <br>&gt; Cheers<br>&gt; <br>&gt; <br>&gt; <br>&gt; James<br>&gt; <br>&gt; _______________________________________________<br>&gt; <br>&gt; swift-corelibs-dev mailing list<br>&gt; <br>&gt; swift-corelibs-dev at swift.org<br>&gt; <br>&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; <br>&gt; swift-corelibs-dev mailing list<br>&gt; <br>&gt; swift-corelibs-dev at swift.org<br>&gt; <br>&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-corelibs-dev mailing list<br>&gt; swift-corelibs-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20160514/717a2c20/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
