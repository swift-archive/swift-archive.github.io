<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal] Automating Partial Application via Wildcards</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February  2, 2016 at 10:00:00am</p></header><div class="content"><p>First draft. Let&#39;s go Scala!<br></p><p>-- E<br></p><p>Automating Partial Application via Wildcards<br></p><p>Proposal: TBD<br>Author(s): Erica Sadun &lt;http://github.com/erica&gt;, Davide De Franceschi &lt;http://github.com/DeFrenZ&gt;<br>Status: TBD<br>Review manager: TBD<br> &lt;https://gist.github.com/erica/6327981d42eb9be6b4d2#introduction&gt;Introduction<br></p><p>SE-0002 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0002-remove-currying.md&gt; has been accepted for Swift 3.0. That proposal removes currying func declaration syntax from Swift. It reasons that currying introduces unnecessary language and implementation complexity and is easily replaced with chained function return types. <br></p><p>Because of SE-0002, this curried example:<br></p><p>public func projectFunctionToCoordinateSystem(function f: FunctionType)(p0: CGPoint, p1: CGPoint)(x: CGFloat) -&gt; CGPoint<br>becomes<br></p><p>public func projectFunctionToCoordinateSystem(function f: FunctionType) -&gt; (p0: CGPoint, p1: CGPoint) -&gt; (x: CGFloat) -&gt; CGPoint <br>in Swift 3.<br></p><p>It&#39;s mechanically simple to re-introduce partial application but the current solution adds unnecessary nesting and complicated closure declarations, as you see in the following Swift 3 version of this projection function.<br></p><p>public func projectFunctionToCoordinateSystem(function f: FunctionType) -&gt; (p0: CGPoint, p1: CGPoint) -&gt; (x: CGFloat) -&gt; CGPoint {<br>  return { p0, p1 in<br>    return { x in<br>      let (dx, dy) = (p1.x - p0.x, p1.y - p0.y)<br>      let (magnitude, theta) = (hypot(dy, dx), atan2(dy, dx)) // Thanks loooop<br>      var outPoint = CGPoint(x: x * magnitude, y: f(x) * magnitude)<br>      outPoint = CGPointApplyAffineTransform(outPoint, CGAffineTransformMakeRotation(theta))<br>      outPoint = CGPointApplyAffineTransform(outPoint, CGAffineTransformMakeTranslation(p0.x, p0.y))<br>      return CGPoint(x: outPoint.x, y: outPoint.y)<br>    }<br>  }<br>}<br>SE-0002 mentions the possibility of introducing Scala-style free-form partial implementation as a future step. This proposal requests that a Scala-style wildcard feature be adopted into Swift by introducing a form of automatic partial application.<br></p><p> &lt;https://gist.github.com/erica/6327981d42eb9be6b4d2#detail-design&gt;Detail Design<br></p><p>The proposed design replaces a Swift 3 curried signature like this: <br></p><p>public func projectFunctionToCoordinateSystem(function f: FunctionType) -&gt; (p0: CGPoint, p1: CGPoint) -&gt; (x: CGFloat) -&gt; CGPoint<br>with a non-curried, fully qualified call like this:<br></p><p>public func projectFunctionToCoordinateSystem(function f: FunctionType, p0: CGPoint, p1: CGPoint, x: CGFloat) -&gt; CGPoint<br>When called with wildcard tokens, the function is partially applied using the supplied arguments. For example:<br></p><p>let partial1 = projectFunctionToCoordinateSystem(function: mySinFunction, p0: p0, p1: p1, x: _)<br>// partial1(x: xValue)<br></p><p>let partial2 = projectFunctionToCoordinateSystem(function: mySinFunction, p0: .zero, p1: _, x: _)<br>// partial2(p1: p1Value, x: xValue) <br>// or<br>// let partial3 = partial2(p1: p1Value, x: _); partial3(x: 0.25)<br>This returns a curried form. Labels are retained and used, and the compiler should throw an error for any ambiguity that arises as a side effect.<br></p><p>The function implementation is fully configured as if all parameters are specified, losing all its nested params in/params in/params in... overhead:<br></p><p>public func projectFunctionToCoordinateSystem(function f: FunctionType, p0: CGPoint, p1: CGPoint, x: CGFloat) -&gt; CGPoint {<br>  let (dx, dy) = (p1.x - p0.x, p1.y - p0.y)<br>  let (magnitude, theta) = (hypot(dy, dx), atan2(dy, dx)) // Thanks loooop<br>  var outPoint = CGPoint(x: x * magnitude, y: f(x) * magnitude)<br>  outPoint = CGPointApplyAffineTransform(outPoint, CGAffineTransformMakeRotation(theta))<br>  outPoint = CGPointApplyAffineTransform(outPoint, CGAffineTransformMakeTranslation(p0.x, p0.y))<br>  return CGPoint(x: outPoint.x, y: outPoint.y)<br>}<br>The result is simple, readable, and written independently of how the currying is to be applied. as under this design, any parameter can be curried.<br></p><p> &lt;https://gist.github.com/erica/6327981d42eb9be6b4d2#alternatives-considered&gt;Alternatives Considered<br></p><p>Although our natural inclination is to use standard currying and partial application, we also considered defaulting arguments. In this scenario, wildcards return a version of the function with defaulted arguments for all non-wildcard values. In such a design, <br></p><p>let defaultedVersion = projectFunctionToCoordinateSystem(function: mySinFunction, p0: .zero, p1: _, x: _)<br>could be called with a p0 parameter even though that same parameter was already specified in the assignment as in the following example. So this:<br></p><p>defaultedVersion(p0: myNewOrigin, p1: myPoint, x: 0.5)<br>expands to:<br></p><p>defaultedVersionOfProjectFunctionToCoordinateSystem(function: mySinFunction, p0: myNewOrigin, p1: myPoint, x: 0.5)<br>where the new version of p0 overrides the defaulted version created in the initial wildcard assignment.<br></p><p>The implementation details for this alternative approach would differ but it might be easier to implement. As you&#39;d expect, any function called with fully qualified arguments would be executed rather than returning a defaulted version (or a partially applied version for the non-alternative implementation).<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/9d81f219/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8dfc6932943f38e7a7de48be3194f13c?s=50"></div><header><strong>[Proposal] Automating Partial Application via Wildcards</strong> from <string>Michael Ilseman</string> &lt;milseman at apple.com&gt;<p>February  2, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Feb 2, 2016, at 9:33 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; First draft. Let&#39;s go Scala!<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; Automating Partial Application via Wildcards<br>&gt; <br>&gt; Proposal: TBD<br>&gt; Author(s): Erica Sadun &lt;http://github.com/erica&gt;, Davide De Franceschi &lt;http://github.com/DeFrenZ&gt;<br>&gt; Status: TBD<br>&gt; Review manager: TBD<br>&gt;  &lt;https://gist.github.com/erica/6327981d42eb9be6b4d2#introduction&gt;Introduction<br>&gt; <br>&gt; SE-0002 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0002-remove-currying.md&gt; has been accepted for Swift 3.0. That proposal removes currying func declaration syntax from Swift. It reasons that currying introduces unnecessary language and implementation complexity and is easily replaced with chained function return types. <br>&gt; <br>&gt; Because of SE-0002, this curried example:<br>&gt; <br>&gt; public func projectFunctionToCoordinateSystem(function f: FunctionType)(p0: CGPoint, p1: CGPoint)(x: CGFloat) -&gt; CGPoint<br>&gt; becomes<br>&gt; <br>&gt; public func projectFunctionToCoordinateSystem(function f: FunctionType) -&gt; (p0: CGPoint, p1: CGPoint) -&gt; (x: CGFloat) -&gt; CGPoint <br>&gt; in Swift 3.<br>&gt; <br>&gt; It&#39;s mechanically simple to re-introduce partial application but the current solution adds unnecessary nesting and complicated closure declarations, as you see in the following Swift 3 version of this projection function.<br>&gt; <br>&gt; public func projectFunctionToCoordinateSystem(function f: FunctionType) -&gt; (p0: CGPoint, p1: CGPoint) -&gt; (x: CGFloat) -&gt; CGPoint {<br>&gt;   return { p0, p1 in<br>&gt;     return { x in<br>&gt;       let (dx, dy) = (p1.x - p0.x, p1.y - p0.y)<br>&gt;       let (magnitude, theta) = (hypot(dy, dx), atan2(dy, dx)) // Thanks loooop<br>&gt;       var outPoint = CGPoint(x: x * magnitude, y: f(x) * magnitude)<br>&gt;       outPoint = CGPointApplyAffineTransform(outPoint, CGAffineTransformMakeRotation(theta))<br>&gt;       outPoint = CGPointApplyAffineTransform(outPoint, CGAffineTransformMakeTranslation(p0.x, p0.y))<br>&gt;       return CGPoint(x: outPoint.x, y: outPoint.y)<br>&gt;     }<br>&gt;   }<br>&gt; }<br>&gt; SE-0002 mentions the possibility of introducing Scala-style free-form partial implementation as a future step. This proposal requests that a Scala-style wildcard feature be adopted into Swift by introducing a form of automatic partial application.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/6327981d42eb9be6b4d2#detail-design&gt;Detail Design<br>&gt; <br>&gt; The proposed design replaces a Swift 3 curried signature like this: <br>&gt; <br>&gt; public func projectFunctionToCoordinateSystem(function f: FunctionType) -&gt; (p0: CGPoint, p1: CGPoint) -&gt; (x: CGFloat) -&gt; CGPoint<br>&gt; with a non-curried, fully qualified call like this:<br>&gt; <br>&gt; public func projectFunctionToCoordinateSystem(function f: FunctionType, p0: CGPoint, p1: CGPoint, x: CGFloat) -&gt; CGPoint<br>&gt; When called with wildcard tokens, the function is partially applied using the supplied arguments. For example:<br>&gt; <br>&gt; let partial1 = projectFunctionToCoordinateSystem(function: mySinFunction, p0: p0, p1: p1, x: _)<br>&gt; // partial1(x: xValue)<br>&gt; <br>&gt; let partial2 = projectFunctionToCoordinateSystem(function: mySinFunction, p0: .zero, p1: _, x: _)<br>&gt; // partial2(p1: p1Value, x: xValue) <br>&gt; // or<br>&gt; // let partial3 = partial2(p1: p1Value, x: _); partial3(x: 0.25)<br>&gt; This returns a curried form. Labels are retained and used, and the compiler should throw an error for any ambiguity that arises as a side effect.<br>&gt; <br>&gt; <br></p><p>To someone more familiar with the implementation of type checking than myself: how much would this complicate overload resolution, as there are no constraints or contextual typing information present in “_”? Would this, in practice, be any worse than something like:<br></p><p>func foo(a : Int, b b: Int?) -&gt; Int {<br>    if let b = b {<br>        return a + b<br>    }<br>    return a<br>}<br>func foo(a : Int, b b: Float?) -&gt; Float {<br>    if let b = b {<br>        return Float(a) + b<br>    }<br>    return Float(a)<br>}<br></p><p>let a = foo(1, b: 2) // Int: 3<br>let b = foo(1, b: 2.0) // Float: 3<br>let c = foo(1, b: nil) // Error: ambiguous use of &#39;foo(_:b:)&#39;<br></p><p><br>&gt; The function implementation is fully configured as if all parameters are specified, losing all its nested params in/params in/params in... overhead:<br>&gt; <br>&gt; public func projectFunctionToCoordinateSystem(function f: FunctionType, p0: CGPoint, p1: CGPoint, x: CGFloat) -&gt; CGPoint {<br>&gt;   let (dx, dy) = (p1.x - p0.x, p1.y - p0.y)<br>&gt;   let (magnitude, theta) = (hypot(dy, dx), atan2(dy, dx)) // Thanks loooop<br>&gt;   var outPoint = CGPoint(x: x * magnitude, y: f(x) * magnitude)<br>&gt;   outPoint = CGPointApplyAffineTransform(outPoint, CGAffineTransformMakeRotation(theta))<br>&gt;   outPoint = CGPointApplyAffineTransform(outPoint, CGAffineTransformMakeTranslation(p0.x, p0.y))<br>&gt;   return CGPoint(x: outPoint.x, y: outPoint.y)<br>&gt; }<br>&gt; The result is simple, readable, and written independently of how the currying is to be applied. as under this design, any parameter can be curried.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/6327981d42eb9be6b4d2#alternatives-considered&gt;Alternatives Considered<br>&gt; <br>&gt; Although our natural inclination is to use standard currying and partial application, we also considered defaulting arguments. In this scenario, wildcards return a version of the function with defaulted arguments for all non-wildcard values. In such a design, <br>&gt; <br>&gt; let defaultedVersion = projectFunctionToCoordinateSystem(function: mySinFunction, p0: .zero, p1: _, x: _)<br>&gt; could be called with a p0 parameter even though that same parameter was already specified in the assignment as in the following example. So this:<br>&gt; <br>&gt; defaultedVersion(p0: myNewOrigin, p1: myPoint, x: 0.5)<br>&gt; expands to:<br>&gt; <br>&gt; defaultedVersionOfProjectFunctionToCoordinateSystem(function: mySinFunction, p0: myNewOrigin, p1: myPoint, x: 0.5)<br>&gt; where the new version of p0 overrides the defaulted version created in the initial wildcard assignment.<br>&gt; <br>&gt; The implementation details for this alternative approach would differ but it might be easier to implement. As you&#39;d expect, any function called with fully qualified arguments would be executed rather than returning a defaulted version (or a partially applied version for the non-alternative implementation).<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/79a23b12/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Proposal] Automating Partial Application via Wildcards</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>February  2, 2016 at 10:00:00am</p></header><div class="content"><p>I like this ad-hoc currying proposal.<br></p><p>Questions:<br>- How does this handle inout params? Are they just not allowed, to keep things simple? Or are they allowed as long as they aren&#39;t the parameter being curried?<br>- Would you be able to curry arbitrary params in the function decl, or only the n rightmost params?<br></p><p>Best,<br>Austin<br></p><p><br>&gt; On Feb 2, 2016, at 10:10 AM, Michael Ilseman via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 2, 2016, at 9:33 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; First draft. Let&#39;s go Scala!<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt; Automating Partial Application via Wildcards<br>&gt;&gt; <br>&gt;&gt; Proposal: TBD<br>&gt;&gt; Author(s): Erica Sadun &lt;http://github.com/erica&gt;, Davide De Franceschi &lt;http://github.com/DeFrenZ&gt;<br>&gt;&gt; Status: TBD<br>&gt;&gt; Review manager: TBD<br>&gt;&gt;  &lt;https://gist.github.com/erica/6327981d42eb9be6b4d2#introduction&gt;Introduction<br>&gt;&gt; <br>&gt;&gt; SE-0002 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0002-remove-currying.md&gt; has been accepted for Swift 3.0. That proposal removes currying func declaration syntax from Swift. It reasons that currying introduces unnecessary language and implementation complexity and is easily replaced with chained function return types. <br>&gt;&gt; <br>&gt;&gt; Because of SE-0002, this curried example:<br>&gt;&gt; <br>&gt;&gt; public func projectFunctionToCoordinateSystem(function f: FunctionType)(p0: CGPoint, p1: CGPoint)(x: CGFloat) -&gt; CGPoint<br>&gt;&gt; becomes<br>&gt;&gt; <br>&gt;&gt; public func projectFunctionToCoordinateSystem(function f: FunctionType) -&gt; (p0: CGPoint, p1: CGPoint) -&gt; (x: CGFloat) -&gt; CGPoint <br>&gt;&gt; in Swift 3.<br>&gt;&gt; <br>&gt;&gt; It&#39;s mechanically simple to re-introduce partial application but the current solution adds unnecessary nesting and complicated closure declarations, as you see in the following Swift 3 version of this projection function.<br>&gt;&gt; <br>&gt;&gt; public func projectFunctionToCoordinateSystem(function f: FunctionType) -&gt; (p0: CGPoint, p1: CGPoint) -&gt; (x: CGFloat) -&gt; CGPoint {<br>&gt;&gt;   return { p0, p1 in<br>&gt;&gt;     return { x in<br>&gt;&gt;       let (dx, dy) = (p1.x - p0.x, p1.y - p0.y)<br>&gt;&gt;       let (magnitude, theta) = (hypot(dy, dx), atan2(dy, dx)) // Thanks loooop<br>&gt;&gt;       var outPoint = CGPoint(x: x * magnitude, y: f(x) * magnitude)<br>&gt;&gt;       outPoint = CGPointApplyAffineTransform(outPoint, CGAffineTransformMakeRotation(theta))<br>&gt;&gt;       outPoint = CGPointApplyAffineTransform(outPoint, CGAffineTransformMakeTranslation(p0.x, p0.y))<br>&gt;&gt;       return CGPoint(x: outPoint.x, y: outPoint.y)<br>&gt;&gt;     }<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; SE-0002 mentions the possibility of introducing Scala-style free-form partial implementation as a future step. This proposal requests that a Scala-style wildcard feature be adopted into Swift by introducing a form of automatic partial application.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/erica/6327981d42eb9be6b4d2#detail-design&gt;Detail Design<br>&gt;&gt; <br>&gt;&gt; The proposed design replaces a Swift 3 curried signature like this: <br>&gt;&gt; <br>&gt;&gt; public func projectFunctionToCoordinateSystem(function f: FunctionType) -&gt; (p0: CGPoint, p1: CGPoint) -&gt; (x: CGFloat) -&gt; CGPoint<br>&gt;&gt; with a non-curried, fully qualified call like this:<br>&gt;&gt; <br>&gt;&gt; public func projectFunctionToCoordinateSystem(function f: FunctionType, p0: CGPoint, p1: CGPoint, x: CGFloat) -&gt; CGPoint<br>&gt;&gt; When called with wildcard tokens, the function is partially applied using the supplied arguments. For example:<br>&gt;&gt; <br>&gt;&gt; let partial1 = projectFunctionToCoordinateSystem(function: mySinFunction, p0: p0, p1: p1, x: _)<br>&gt;&gt; // partial1(x: xValue)<br>&gt;&gt; <br>&gt;&gt; let partial2 = projectFunctionToCoordinateSystem(function: mySinFunction, p0: .zero, p1: _, x: _)<br>&gt;&gt; // partial2(p1: p1Value, x: xValue) <br>&gt;&gt; // or<br>&gt;&gt; // let partial3 = partial2(p1: p1Value, x: _); partial3(x: 0.25)<br>&gt;&gt; This returns a curried form. Labels are retained and used, and the compiler should throw an error for any ambiguity that arises as a side effect.<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; To someone more familiar with the implementation of type checking than myself: how much would this complicate overload resolution, as there are no constraints or contextual typing information present in “_”? Would this, in practice, be any worse than something like:<br>&gt; <br>&gt; func foo(a : Int, b b: Int?) -&gt; Int {<br>&gt;     if let b = b {<br>&gt;         return a + b<br>&gt;     }<br>&gt;     return a<br>&gt; }<br>&gt; func foo(a : Int, b b: Float?) -&gt; Float {<br>&gt;     if let b = b {<br>&gt;         return Float(a) + b<br>&gt;     }<br>&gt;     return Float(a)<br>&gt; }<br>&gt; <br>&gt; let a = foo(1, b: 2) // Int: 3<br>&gt; let b = foo(1, b: 2.0) // Float: 3<br>&gt; let c = foo(1, b: nil) // Error: ambiguous use of &#39;foo(_:b:)&#39;<br>&gt; <br>&gt; <br>&gt;&gt; The function implementation is fully configured as if all parameters are specified, losing all its nested params in/params in/params in... overhead:<br>&gt;&gt; <br>&gt;&gt; public func projectFunctionToCoordinateSystem(function f: FunctionType, p0: CGPoint, p1: CGPoint, x: CGFloat) -&gt; CGPoint {<br>&gt;&gt;   let (dx, dy) = (p1.x - p0.x, p1.y - p0.y)<br>&gt;&gt;   let (magnitude, theta) = (hypot(dy, dx), atan2(dy, dx)) // Thanks loooop<br>&gt;&gt;   var outPoint = CGPoint(x: x * magnitude, y: f(x) * magnitude)<br>&gt;&gt;   outPoint = CGPointApplyAffineTransform(outPoint, CGAffineTransformMakeRotation(theta))<br>&gt;&gt;   outPoint = CGPointApplyAffineTransform(outPoint, CGAffineTransformMakeTranslation(p0.x, p0.y))<br>&gt;&gt;   return CGPoint(x: outPoint.x, y: outPoint.y)<br>&gt;&gt; }<br>&gt;&gt; The result is simple, readable, and written independently of how the currying is to be applied. as under this design, any parameter can be curried.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/erica/6327981d42eb9be6b4d2#alternatives-considered&gt;Alternatives Considered<br>&gt;&gt; <br>&gt;&gt; Although our natural inclination is to use standard currying and partial application, we also considered defaulting arguments. In this scenario, wildcards return a version of the function with defaulted arguments for all non-wildcard values. In such a design, <br>&gt;&gt; <br>&gt;&gt; let defaultedVersion = projectFunctionToCoordinateSystem(function: mySinFunction, p0: .zero, p1: _, x: _)<br>&gt;&gt; could be called with a p0 parameter even though that same parameter was already specified in the assignment as in the following example. So this:<br>&gt;&gt; <br>&gt;&gt; defaultedVersion(p0: myNewOrigin, p1: myPoint, x: 0.5)<br>&gt;&gt; expands to:<br>&gt;&gt; <br>&gt;&gt; defaultedVersionOfProjectFunctionToCoordinateSystem(function: mySinFunction, p0: myNewOrigin, p1: myPoint, x: 0.5)<br>&gt;&gt; where the new version of p0 overrides the defaulted version created in the initial wildcard assignment.<br>&gt;&gt; <br>&gt;&gt; The implementation details for this alternative approach would differ but it might be easier to implement. As you&#39;d expect, any function called with fully qualified arguments would be executed rather than returning a defaulted version (or a partially applied version for the non-alternative implementation).<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/5550740f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal] Automating Partial Application via Wildcards</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February  2, 2016 at 11:00:00am</p></header><div class="content"><p>I would not want to have to deal with inout, as &quot;bad things could happen&quot;™ And I&#39;m imagining arbitrary params, not just rightmost,<br>although I would defer to implementation realities (such as not using _) as needed.<br></p><p>-- E<br></p><p>&gt; On Feb 2, 2016, at 11:14 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; I like this ad-hoc currying proposal.<br>&gt; <br>&gt; Questions:<br>&gt; - How does this handle inout params? Are they just not allowed, to keep things simple? Or are they allowed as long as they aren&#39;t the parameter being curried?<br>&gt; - Would you be able to curry arbitrary params in the function decl, or only the n rightmost params?<br>&gt; <br>&gt; Best,<br>&gt; Austin<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 2, 2016, at 10:10 AM, Michael Ilseman via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 2, 2016, at 9:33 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; First draft. Let&#39;s go Scala!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- E<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Automating Partial Application via Wildcards<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposal: TBD<br>&gt;&gt;&gt; Author(s): Erica Sadun &lt;http://github.com/erica&gt;, Davide De Franceschi &lt;http://github.com/DeFrenZ&gt;<br>&gt;&gt;&gt; Status: TBD<br>&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt;  &lt;https://gist.github.com/erica/6327981d42eb9be6b4d2#introduction&gt;Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; SE-0002 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0002-remove-currying.md&gt; has been accepted for Swift 3.0. That proposal removes currying func declaration syntax from Swift. It reasons that currying introduces unnecessary language and implementation complexity and is easily replaced with chained function return types. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Because of SE-0002, this curried example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public func projectFunctionToCoordinateSystem(function f: FunctionType)(p0: CGPoint, p1: CGPoint)(x: CGFloat) -&gt; CGPoint<br>&gt;&gt;&gt; becomes<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public func projectFunctionToCoordinateSystem(function f: FunctionType) -&gt; (p0: CGPoint, p1: CGPoint) -&gt; (x: CGFloat) -&gt; CGPoint <br>&gt;&gt;&gt; in Swift 3.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s mechanically simple to re-introduce partial application but the current solution adds unnecessary nesting and complicated closure declarations, as you see in the following Swift 3 version of this projection function.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public func projectFunctionToCoordinateSystem(function f: FunctionType) -&gt; (p0: CGPoint, p1: CGPoint) -&gt; (x: CGFloat) -&gt; CGPoint {<br>&gt;&gt;&gt;   return { p0, p1 in<br>&gt;&gt;&gt;     return { x in<br>&gt;&gt;&gt;       let (dx, dy) = (p1.x - p0.x, p1.y - p0.y)<br>&gt;&gt;&gt;       let (magnitude, theta) = (hypot(dy, dx), atan2(dy, dx)) // Thanks loooop<br>&gt;&gt;&gt;       var outPoint = CGPoint(x: x * magnitude, y: f(x) * magnitude)<br>&gt;&gt;&gt;       outPoint = CGPointApplyAffineTransform(outPoint, CGAffineTransformMakeRotation(theta))<br>&gt;&gt;&gt;       outPoint = CGPointApplyAffineTransform(outPoint, CGAffineTransformMakeTranslation(p0.x, p0.y))<br>&gt;&gt;&gt;       return CGPoint(x: outPoint.x, y: outPoint.y)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; SE-0002 mentions the possibility of introducing Scala-style free-form partial implementation as a future step. This proposal requests that a Scala-style wildcard feature be adopted into Swift by introducing a form of automatic partial application.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://gist.github.com/erica/6327981d42eb9be6b4d2#detail-design&gt;Detail Design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The proposed design replaces a Swift 3 curried signature like this: <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public func projectFunctionToCoordinateSystem(function f: FunctionType) -&gt; (p0: CGPoint, p1: CGPoint) -&gt; (x: CGFloat) -&gt; CGPoint<br>&gt;&gt;&gt; with a non-curried, fully qualified call like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public func projectFunctionToCoordinateSystem(function f: FunctionType, p0: CGPoint, p1: CGPoint, x: CGFloat) -&gt; CGPoint<br>&gt;&gt;&gt; When called with wildcard tokens, the function is partially applied using the supplied arguments. For example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let partial1 = projectFunctionToCoordinateSystem(function: mySinFunction, p0: p0, p1: p1, x: _)<br>&gt;&gt;&gt; // partial1(x: xValue)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let partial2 = projectFunctionToCoordinateSystem(function: mySinFunction, p0: .zero, p1: _, x: _)<br>&gt;&gt;&gt; // partial2(p1: p1Value, x: xValue) <br>&gt;&gt;&gt; // or<br>&gt;&gt;&gt; // let partial3 = partial2(p1: p1Value, x: _); partial3(x: 0.25)<br>&gt;&gt;&gt; This returns a curried form. Labels are retained and used, and the compiler should throw an error for any ambiguity that arises as a side effect.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; To someone more familiar with the implementation of type checking than myself: how much would this complicate overload resolution, as there are no constraints or contextual typing information present in “_”? Would this, in practice, be any worse than something like:<br>&gt;&gt; <br>&gt;&gt; func foo(a : Int, b b: Int?) -&gt; Int {<br>&gt;&gt;     if let b = b {<br>&gt;&gt;         return a + b<br>&gt;&gt;     }<br>&gt;&gt;     return a<br>&gt;&gt; }<br>&gt;&gt; func foo(a : Int, b b: Float?) -&gt; Float {<br>&gt;&gt;     if let b = b {<br>&gt;&gt;         return Float(a) + b<br>&gt;&gt;     }<br>&gt;&gt;     return Float(a)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let a = foo(1, b: 2) // Int: 3<br>&gt;&gt; let b = foo(1, b: 2.0) // Float: 3<br>&gt;&gt; let c = foo(1, b: nil) // Error: ambiguous use of &#39;foo(_:b:)&#39;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; The function implementation is fully configured as if all parameters are specified, losing all its nested params in/params in/params in... overhead:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public func projectFunctionToCoordinateSystem(function f: FunctionType, p0: CGPoint, p1: CGPoint, x: CGFloat) -&gt; CGPoint {<br>&gt;&gt;&gt;   let (dx, dy) = (p1.x - p0.x, p1.y - p0.y)<br>&gt;&gt;&gt;   let (magnitude, theta) = (hypot(dy, dx), atan2(dy, dx)) // Thanks loooop<br>&gt;&gt;&gt;   var outPoint = CGPoint(x: x * magnitude, y: f(x) * magnitude)<br>&gt;&gt;&gt;   outPoint = CGPointApplyAffineTransform(outPoint, CGAffineTransformMakeRotation(theta))<br>&gt;&gt;&gt;   outPoint = CGPointApplyAffineTransform(outPoint, CGAffineTransformMakeTranslation(p0.x, p0.y))<br>&gt;&gt;&gt;   return CGPoint(x: outPoint.x, y: outPoint.y)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; The result is simple, readable, and written independently of how the currying is to be applied. as under this design, any parameter can be curried.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://gist.github.com/erica/6327981d42eb9be6b4d2#alternatives-considered&gt;Alternatives Considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Although our natural inclination is to use standard currying and partial application, we also considered defaulting arguments. In this scenario, wildcards return a version of the function with defaulted arguments for all non-wildcard values. In such a design, <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let defaultedVersion = projectFunctionToCoordinateSystem(function: mySinFunction, p0: .zero, p1: _, x: _)<br>&gt;&gt;&gt; could be called with a p0 parameter even though that same parameter was already specified in the assignment as in the following example. So this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; defaultedVersion(p0: myNewOrigin, p1: myPoint, x: 0.5)<br>&gt;&gt;&gt; expands to:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; defaultedVersionOfProjectFunctionToCoordinateSystem(function: mySinFunction, p0: myNewOrigin, p1: myPoint, x: 0.5)<br>&gt;&gt;&gt; where the new version of p0 overrides the defaulted version created in the initial wildcard assignment.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The implementation details for this alternative approach would differ but it might be easier to implement. As you&#39;d expect, any function called with fully qualified arguments would be executed rather than returning a defaulted version (or a partially applied version for the non-alternative implementation).<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/3e4c54a7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Proposal] Automating Partial Application via Wildcards</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>February  2, 2016 at 10:00:00am</p></header><div class="content"><p>Sounds good! I&#39;m sure a sigil/syntax can be figured out that satisfies everyone.<br></p><p>I think disallowing currying for functions with inout params is a good idea, and in the spirit of avoiding adding huge amounts of complexity for a fringe use case (like with removing the inout closure shadow copying behavior, proposed by Joe).<br></p><p>Austin<br></p><p>&gt; On Feb 2, 2016, at 10:19 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; I would not want to have to deal with inout, as &quot;bad things could happen&quot;™ And I&#39;m imagining arbitrary params, not just rightmost,<br>&gt; although I would defer to implementation realities (such as not using _) as needed.<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt;&gt; On Feb 2, 2016, at 11:14 AM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I like this ad-hoc currying proposal.<br>&gt;&gt; <br>&gt;&gt; Questions:<br>&gt;&gt; - How does this handle inout params? Are they just not allowed, to keep things simple? Or are they allowed as long as they aren&#39;t the parameter being curried?<br>&gt;&gt; - Would you be able to curry arbitrary params in the function decl, or only the n rightmost params?<br>&gt;&gt; <br>&gt;&gt; Best,<br>&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 2, 2016, at 10:10 AM, Michael Ilseman via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 2, 2016, at 9:33 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; First draft. Let&#39;s go Scala!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- E<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Automating Partial Application via Wildcards<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Proposal: TBD<br>&gt;&gt;&gt;&gt; Author(s): Erica Sadun &lt;http://github.com/erica&gt;, Davide De Franceschi &lt;http://github.com/DeFrenZ&gt;<br>&gt;&gt;&gt;&gt; Status: TBD<br>&gt;&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt;&gt;  &lt;https://gist.github.com/erica/6327981d42eb9be6b4d2#introduction&gt;Introduction<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; SE-0002 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0002-remove-currying.md&gt; has been accepted for Swift 3.0. That proposal removes currying func declaration syntax from Swift. It reasons that currying introduces unnecessary language and implementation complexity and is easily replaced with chained function return types. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Because of SE-0002, this curried example:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; public func projectFunctionToCoordinateSystem(function f: FunctionType)(p0: CGPoint, p1: CGPoint)(x: CGFloat) -&gt; CGPoint<br>&gt;&gt;&gt;&gt; becomes<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; public func projectFunctionToCoordinateSystem(function f: FunctionType) -&gt; (p0: CGPoint, p1: CGPoint) -&gt; (x: CGFloat) -&gt; CGPoint <br>&gt;&gt;&gt;&gt; in Swift 3.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It&#39;s mechanically simple to re-introduce partial application but the current solution adds unnecessary nesting and complicated closure declarations, as you see in the following Swift 3 version of this projection function.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; public func projectFunctionToCoordinateSystem(function f: FunctionType) -&gt; (p0: CGPoint, p1: CGPoint) -&gt; (x: CGFloat) -&gt; CGPoint {<br>&gt;&gt;&gt;&gt;   return { p0, p1 in<br>&gt;&gt;&gt;&gt;     return { x in<br>&gt;&gt;&gt;&gt;       let (dx, dy) = (p1.x - p0.x, p1.y - p0.y)<br>&gt;&gt;&gt;&gt;       let (magnitude, theta) = (hypot(dy, dx), atan2(dy, dx)) // Thanks loooop<br>&gt;&gt;&gt;&gt;       var outPoint = CGPoint(x: x * magnitude, y: f(x) * magnitude)<br>&gt;&gt;&gt;&gt;       outPoint = CGPointApplyAffineTransform(outPoint, CGAffineTransformMakeRotation(theta))<br>&gt;&gt;&gt;&gt;       outPoint = CGPointApplyAffineTransform(outPoint, CGAffineTransformMakeTranslation(p0.x, p0.y))<br>&gt;&gt;&gt;&gt;       return CGPoint(x: outPoint.x, y: outPoint.y)<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; SE-0002 mentions the possibility of introducing Scala-style free-form partial implementation as a future step. This proposal requests that a Scala-style wildcard feature be adopted into Swift by introducing a form of automatic partial application.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  &lt;https://gist.github.com/erica/6327981d42eb9be6b4d2#detail-design&gt;Detail Design<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The proposed design replaces a Swift 3 curried signature like this: <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; public func projectFunctionToCoordinateSystem(function f: FunctionType) -&gt; (p0: CGPoint, p1: CGPoint) -&gt; (x: CGFloat) -&gt; CGPoint<br>&gt;&gt;&gt;&gt; with a non-curried, fully qualified call like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; public func projectFunctionToCoordinateSystem(function f: FunctionType, p0: CGPoint, p1: CGPoint, x: CGFloat) -&gt; CGPoint<br>&gt;&gt;&gt;&gt; When called with wildcard tokens, the function is partially applied using the supplied arguments. For example:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let partial1 = projectFunctionToCoordinateSystem(function: mySinFunction, p0: p0, p1: p1, x: _)<br>&gt;&gt;&gt;&gt; // partial1(x: xValue)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let partial2 = projectFunctionToCoordinateSystem(function: mySinFunction, p0: .zero, p1: _, x: _)<br>&gt;&gt;&gt;&gt; // partial2(p1: p1Value, x: xValue) <br>&gt;&gt;&gt;&gt; // or<br>&gt;&gt;&gt;&gt; // let partial3 = partial2(p1: p1Value, x: _); partial3(x: 0.25)<br>&gt;&gt;&gt;&gt; This returns a curried form. Labels are retained and used, and the compiler should throw an error for any ambiguity that arises as a side effect.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To someone more familiar with the implementation of type checking than myself: how much would this complicate overload resolution, as there are no constraints or contextual typing information present in “_”? Would this, in practice, be any worse than something like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func foo(a : Int, b b: Int?) -&gt; Int {<br>&gt;&gt;&gt;     if let b = b {<br>&gt;&gt;&gt;         return a + b<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     return a<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; func foo(a : Int, b b: Float?) -&gt; Float {<br>&gt;&gt;&gt;     if let b = b {<br>&gt;&gt;&gt;         return Float(a) + b<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     return Float(a)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let a = foo(1, b: 2) // Int: 3<br>&gt;&gt;&gt; let b = foo(1, b: 2.0) // Float: 3<br>&gt;&gt;&gt; let c = foo(1, b: nil) // Error: ambiguous use of &#39;foo(_:b:)&#39;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The function implementation is fully configured as if all parameters are specified, losing all its nested params in/params in/params in... overhead:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; public func projectFunctionToCoordinateSystem(function f: FunctionType, p0: CGPoint, p1: CGPoint, x: CGFloat) -&gt; CGPoint {<br>&gt;&gt;&gt;&gt;   let (dx, dy) = (p1.x - p0.x, p1.y - p0.y)<br>&gt;&gt;&gt;&gt;   let (magnitude, theta) = (hypot(dy, dx), atan2(dy, dx)) // Thanks loooop<br>&gt;&gt;&gt;&gt;   var outPoint = CGPoint(x: x * magnitude, y: f(x) * magnitude)<br>&gt;&gt;&gt;&gt;   outPoint = CGPointApplyAffineTransform(outPoint, CGAffineTransformMakeRotation(theta))<br>&gt;&gt;&gt;&gt;   outPoint = CGPointApplyAffineTransform(outPoint, CGAffineTransformMakeTranslation(p0.x, p0.y))<br>&gt;&gt;&gt;&gt;   return CGPoint(x: outPoint.x, y: outPoint.y)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; The result is simple, readable, and written independently of how the currying is to be applied. as under this design, any parameter can be curried.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  &lt;https://gist.github.com/erica/6327981d42eb9be6b4d2#alternatives-considered&gt;Alternatives Considered<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Although our natural inclination is to use standard currying and partial application, we also considered defaulting arguments. In this scenario, wildcards return a version of the function with defaulted arguments for all non-wildcard values. In such a design, <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let defaultedVersion = projectFunctionToCoordinateSystem(function: mySinFunction, p0: .zero, p1: _, x: _)<br>&gt;&gt;&gt;&gt; could be called with a p0 parameter even though that same parameter was already specified in the assignment as in the following example. So this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; defaultedVersion(p0: myNewOrigin, p1: myPoint, x: 0.5)<br>&gt;&gt;&gt;&gt; expands to:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; defaultedVersionOfProjectFunctionToCoordinateSystem(function: mySinFunction, p0: myNewOrigin, p1: myPoint, x: 0.5)<br>&gt;&gt;&gt;&gt; where the new version of p0 overrides the defaulted version created in the initial wildcard assignment.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The implementation details for this alternative approach would differ but it might be easier to implement. As you&#39;d expect, any function called with fully qualified arguments would be executed rather than returning a defaulted version (or a partially applied version for the non-alternative implementation).<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/89057689/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal] Automating Partial Application via Wildcards</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>February  2, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Feb 2, 2016, at 9:33 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; When called with wildcard tokens, the function is partially applied using the supplied arguments. For example:<br>&gt; <br>&gt; let partial1 = projectFunctionToCoordinateSystem(function: mySinFunction, p0: p0, p1: p1, x: _)<br>&gt; // partial1(x: xValue)<br></p><p>One superficial comment on this: the use of _ here is a bad idea.  _ already means something in expressions - “discard”, and a closely related thing in declarations - “ignore”.  <br></p><p>Adding a third very different thing (placeholder to be filled in later) seems like a really confusing thing to do.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/4724ff36/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal] Automating Partial Application via Wildcards</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February  2, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Feb 2, 2016, at 11:15 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 2, 2016, at 9:33 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; When called with wildcard tokens, the function is partially applied using the supplied arguments. For example:<br>&gt;&gt; <br>&gt;&gt; let partial1 = projectFunctionToCoordinateSystem(function: mySinFunction, p0: p0, p1: p1, x: _)<br>&gt;&gt; // partial1(x: xValue)<br>&gt; <br>&gt; One superficial comment on this: the use of _ here is a bad idea.  _ already means something in expressions - “discard”, and a closely related thing in declarations - “ignore”.  <br>&gt; <br>&gt; Adding a third very different thing (placeholder to be filled in later) seems like a really confusing thing to do.<br>&gt; <br>&gt; -Chris<br>&gt; <br></p><p><br>#?<br></p><p>-- E, since it was freed up in the label liberation movement<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/a7f65f24/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal] Automating Partial Application via Wildcards</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>February  2, 2016 at 10:00:00am</p></header><div class="content"><p>On Feb 2, 2016, at 10:16 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; One superficial comment on this: the use of _ here is a bad idea.  _ already means something in expressions - “discard”, and a closely related thing in declarations - “ignore”.  <br>&gt;&gt; <br>&gt;&gt; Adding a third very different thing (placeholder to be filled in later) seems like a really confusing thing to do.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; #?<br></p><p># means “macro like” or “compiler synthesized”.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal] Automating Partial Application via Wildcards</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February  2, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Feb 2, 2016, at 11:20 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; On Feb 2, 2016, at 10:16 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One superficial comment on this: the use of _ here is a bad idea.  _ already means something in expressions - “discard”, and a closely related thing in declarations - “ignore”.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Adding a third very different thing (placeholder to be filled in later) seems like a really confusing thing to do.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; #?<br>&gt; <br>&gt; # means “macro like” or “compiler synthesized”.<br>&gt; <br>&gt; -Chris<br>&gt; <br></p><p>* would be bad, right? And naked ?-marks?<br></p><p>-- E<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>[Proposal] Automating Partial Application via Wildcards</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>February  2, 2016 at 07:00:00pm</p></header><div class="content"><p>Any operator character would be bad, since the function may accept it, as in `[1,2,3].reduce(1, combine: *)`<br></p><p>Gwendal<br></p><p>&gt; Le 2 févr. 2016 à 19:24, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 2, 2016, at 11:20 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Feb 2, 2016, at 10:16 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One superficial comment on this: the use of _ here is a bad idea.  _ already means something in expressions - “discard”, and a closely related thing in declarations - “ignore”.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Adding a third very different thing (placeholder to be filled in later) seems like a really confusing thing to do.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; #?<br>&gt;&gt; <br>&gt;&gt; # means “macro like” or “compiler synthesized”.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt; <br>&gt; * would be bad, right? And naked ?-marks?<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>[Proposal] Automating Partial Application via Wildcards</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>February  2, 2016 at 07:00:00pm</p></header><div class="content"><p>What about nothing?<br></p><p>let partial1 = f(arg1: 1, arg2:)<br>Gwendal<br></p><p>&gt; Le 2 févr. 2016 à 19:26, Gwendal Roué &lt;gwendal.roue at gmail.com&gt; a écrit :<br>&gt; <br>&gt; Any operator character would be bad, since the function may accept it, as in `[1,2,3].reduce(1, combine: *)`<br>&gt; <br>&gt; Gwendal<br>&gt; <br>&gt;&gt; Le 2 févr. 2016 à 19:24, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 2, 2016, at 11:20 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Feb 2, 2016, at 10:16 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; One superficial comment on this: the use of _ here is a bad idea.  _ already means something in expressions - “discard”, and a closely related thing in declarations - “ignore”.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Adding a third very different thing (placeholder to be filled in later) seems like a really confusing thing to do.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; #?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; # means “macro like” or “compiler synthesized”.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; * would be bad, right? And naked ?-marks?<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/a963ed4d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/caa7226ca750e974668243476ffbafd5?s=50"></div><header><strong>[Proposal] Automating Partial Application via Wildcards</strong> from <string>Greg Titus</string> &lt;greg at omnigroup.com&gt;<p>February  2, 2016 at 10:00:00am</p></header><div class="content"><p>What about $N?  :-)  <br></p><p>And then you could also put {} around it so that it is more obvious that partial1 is being assigned something that acts like a closure, and then you end up with:<br></p><p>let partial1 = { projectFunctionToCoordinateSystem(function: mySinFunction, p0: p0, p1: p1, x: $0) }<br>let partial2 = { projectFunctionToCoordinateSystem(function: mySinFunction, p0: .zero, p1: $0, x: $1) }<br></p><p>instead of:<br>&gt; let partial1 = projectFunctionToCoordinateSystem(function: mySinFunction, p0: p0, p1: p1, x: _) <br>&gt; let partial2 = projectFunctionToCoordinateSystem(function: mySinFunction, p0: .zero, p1: _, x: _) <br></p><p>I’m -1.<br></p><p>With the way that single expression closures work, and the fact that they are so syntactically light, I don’t think that this proposal would add utility, it would just be one more construct to learn.<br></p><p>	- Greg<br></p><p>&gt; On Feb 2, 2016, at 10:28 AM, Gwendal Roué via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; What about nothing?<br>&gt; <br>&gt; let partial1 = f(arg1: 1, arg2:)<br>&gt; Gwendal<br>&gt; <br>&gt;&gt; Le 2 févr. 2016 à 19:26, Gwendal Roué &lt;gwendal.roue at gmail.com &lt;mailto:gwendal.roue at gmail.com&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; Any operator character would be bad, since the function may accept it, as in `[1,2,3].reduce(1, combine: *)`<br>&gt;&gt; <br>&gt;&gt; Gwendal<br>&gt;&gt; <br>&gt;&gt;&gt; Le 2 févr. 2016 à 19:24, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 2, 2016, at 11:20 AM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 2, 2016, at 10:16 AM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; One superficial comment on this: the use of _ here is a bad idea.  _ already means something in expressions - “discard”, and a closely related thing in declarations - “ignore”.  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Adding a third very different thing (placeholder to be filled in later) seems like a really confusing thing to do.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; #?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; # means “macro like” or “compiler synthesized”.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * would be bad, right? And naked ?-marks?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- E<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/a7a59aec/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Automating Partial Application via Wildcards</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February  2, 2016 at 10:00:00am</p></header><div class="content"><p>Yeah, I&#39;m with Greg—I don&#39;t think this saves much over an explicit closure with $N arguments. Another problem with &#39;_&#39; is that it&#39;s nonobvious what the boundaries of the closure should be. You can say that it&#39;s the enclosing function application, but in the AST, a method invocation is two function applications, so by that rule &#39;_.foo(_)&#39; would mean {{ $0.foo }($0)}, and every operator is a separate function call, so &#39;_ + _ + _&#39; would be &#39;{{ $0 + $1 } + $0}&#39;, neither of which is likely to be expected. The { $N } syntax is almost as compact, and is both clearer and more general.<br></p><p>-Joe<br></p><p>&gt; On Feb 2, 2016, at 10:41 AM, Greg Titus via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; What about $N?  :-)  <br>&gt; <br>&gt; And then you could also put {} around it so that it is more obvious that partial1 is being assigned something that acts like a closure, and then you end up with:<br>&gt; <br>&gt; let partial1 = { projectFunctionToCoordinateSystem(function: mySinFunction, p0: p0, p1: p1, x: $0) }<br>&gt; let partial2 = { projectFunctionToCoordinateSystem(function: mySinFunction, p0: .zero, p1: $0, x: $1) }<br>&gt; <br>&gt; instead of:<br>&gt;&gt; let partial1 = projectFunctionToCoordinateSystem(function: mySinFunction, p0: p0, p1: p1, x: _) <br>&gt;&gt; let partial2 = projectFunctionToCoordinateSystem(function: mySinFunction, p0: .zero, p1: _, x: _) <br>&gt; <br>&gt; I’m -1.<br>&gt; <br>&gt; With the way that single expression closures work, and the fact that they are so syntactically light, I don’t think that this proposal would add utility, it would just be one more construct to learn.<br>&gt; <br>&gt; 	- Greg<br>&gt; <br>&gt;&gt; On Feb 2, 2016, at 10:28 AM, Gwendal Roué via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; What about nothing?<br>&gt;&gt; <br>&gt;&gt; let partial1 = f(arg1: 1, arg2:)<br>&gt;&gt; Gwendal<br>&gt;&gt; <br>&gt;&gt;&gt; Le 2 févr. 2016 à 19:26, Gwendal Roué &lt;gwendal.roue at gmail.com &lt;mailto:gwendal.roue at gmail.com&gt;&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Any operator character would be bad, since the function may accept it, as in `[1,2,3].reduce(1, combine: *)`<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Gwendal<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Le 2 févr. 2016 à 19:24, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Feb 2, 2016, at 11:20 AM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Feb 2, 2016, at 10:16 AM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; One superficial comment on this: the use of _ here is a bad idea.  _ already means something in expressions - “discard”, and a closely related thing in declarations - “ignore”.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Adding a third very different thing (placeholder to be filled in later) seems like a really confusing thing to do.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; #?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; # means “macro like” or “compiler synthesized”.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * would be bad, right? And naked ?-marks?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- E<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/bc048de7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Automating Partial Application via Wildcards</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>February  2, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Feb 2, 2016, at 12:59 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Yeah, I&#39;m with Greg—I don&#39;t think this saves much over an explicit closure with $N arguments. Another problem with &#39;_&#39; is that it&#39;s nonobvious what the boundaries of the closure should be. You can say that it&#39;s the enclosing function application, but in the AST, a method invocation is two function applications, so by that rule &#39;_.foo(_)&#39; would mean {{ $0.foo }($0)}, and every operator is a separate function call, so &#39;_ + _ + _&#39; would be &#39;{{ $0 + $1 } + $0}&#39;, neither of which is likely to be expected. The { $N } syntax is almost as compact, and is both clearer and more general.<br></p><p>I generally agree that specific syntax for partial application is not necessary.  The {} wrapping the closure is not burdensome enough to justify a special case feature for partial application.<br></p><p>However, I am not a huge fan of the $N placeholder syntax.  It looks noisy and also gets lost in the rest of the expression much more than underscore(s).  `_` leaves visual “whitespace” which makes the “hole” in the expression stand out.  <br></p><p>I know there is concern about overloading the semantics of `_` which is unfortunate as IMO it is the best symbol to serve as a placeholder.  I wonder if there has been confusion about the semantics in practice in languages like Scala where it is used in both ways.  Is there any evidence that this has been a problem?<br></p><p>I would like to see us consider switching to the the approach Dave posted:<br></p><p>&gt; Other systems have used “_”, and, for reordering parameters, “_0”,<br>&gt; “_1”, ...<br>&gt; <br>&gt; let partial1 = f(arg1: 1, arg2: _) // { f(arg1: 1, arg2: $0) }<br>&gt; let partial2 = f(arg1: _1, arg2: _0) // { f(arg1: $1, arg2: $0) }<br></p><p><br>Naked `_` would refer arguments in syntactic order, and could perhaps be limited to “partial application” style closures and single-argument closures.  In other cases `_N` would be used rather than `$N`.<br></p><p>-Matthew<br></p><p>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; On Feb 2, 2016, at 10:41 AM, Greg Titus via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; What about $N?  :-)  <br>&gt;&gt; <br>&gt;&gt; And then you could also put {} around it so that it is more obvious that partial1 is being assigned something that acts like a closure, and then you end up with:<br>&gt;&gt; <br>&gt;&gt; let partial1 = { projectFunctionToCoordinateSystem(function: mySinFunction, p0: p0, p1: p1, x: $0) }<br>&gt;&gt; let partial2 = { projectFunctionToCoordinateSystem(function: mySinFunction, p0: .zero, p1: $0, x: $1) }<br>&gt;&gt; <br>&gt;&gt; instead of:<br>&gt;&gt;&gt; let partial1 = projectFunctionToCoordinateSystem(function: mySinFunction, p0: p0, p1: p1, x: _) <br>&gt;&gt;&gt; let partial2 = projectFunctionToCoordinateSystem(function: mySinFunction, p0: .zero, p1: _, x: _) <br>&gt;&gt; <br>&gt;&gt; I’m -1.<br>&gt;&gt; <br>&gt;&gt; With the way that single expression closures work, and the fact that they are so syntactically light, I don’t think that this proposal would add utility, it would just be one more construct to learn.<br>&gt;&gt; <br>&gt;&gt; 	- Greg<br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 2, 2016, at 10:28 AM, Gwendal Roué via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What about nothing?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let partial1 = f(arg1: 1, arg2:)<br>&gt;&gt;&gt; Gwendal<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Le 2 févr. 2016 à 19:26, Gwendal Roué &lt;gwendal.roue at gmail.com &lt;mailto:gwendal.roue at gmail.com&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Any operator character would be bad, since the function may accept it, as in `[1,2,3].reduce(1, combine: *)`<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Gwendal<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Le 2 févr. 2016 à 19:24, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Feb 2, 2016, at 11:20 AM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Feb 2, 2016, at 10:16 AM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; One superficial comment on this: the use of _ here is a bad idea.  _ already means something in expressions - “discard”, and a closely related thing in declarations - “ignore”.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Adding a third very different thing (placeholder to be filled in later) seems like a really confusing thing to do.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; #?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; # means “macro like” or “compiler synthesized”.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; * would be bad, right? And naked ?-marks?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -- E<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/1e4b88e4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Automating Partial Application via Wildcards</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February  2, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Feb 2, 2016, at 11:14 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; I know there is concern about overloading the semantics of `_` which is unfortunate as IMO it is the best symbol to serve as a placeholder.  I wonder if there has been confusion about the semantics in practice in languages like Scala where it is used in both ways.  Is there any evidence that this has been a problem?<br></p><p>Not a super scientific study, but if you google &quot;scala underscore&quot;, several of the results on the first page indicate confusion or bewilderment:<br></p><p>Scala _ [underscore] magic · Anantha Kumaran &lt;https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;ved=0ahUKEwj-08ju59nKAhWj26YKHRuVBh8QFggdMAA&amp;url=http%3A%2F%2Fananthakumaran.in%2F2010%2F03%2F29%2Fscala-underscore-magic.html&amp;usg=AFQjCNEbIIoppVNYAjr6wqxL4byR9I1fAw&amp;sig2=Hlw6hEFfsPqvlDvEFaDoyQ&gt;<br></p><p>What are all the uses of an underscore in Scala? - Stack ... &lt;https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=2&amp;ved=0ahUKEwj-08ju59nKAhWj26YKHRuVBh8QFggjMAE&amp;url=http%3A%2F%2Fstackoverflow.com%2Fquestions%2F8000903%2Fwhat-are-all-the-uses-of-an-underscore-in-scala&amp;usg=AFQjCNHVNCJVosr0IzZYmh8pJRdnXTnf6g&amp;sig2=vqWgzaddf2kEkWrdgFQuoQ&amp;bvm=bv.113034660,d.dGY&gt;<br></p><p>Scala dreaded underscore - SlideShare &lt;https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=3&amp;ved=0ahUKEwj-08ju59nKAhWj26YKHRuVBh8QFggqMAI&amp;url=http%3A%2F%2Fwww.slideshare.net%2Fnormation%2Fscala-dreaded&amp;usg=AFQjCNEs5fGA4e8NsU10--FKfOyga8aEaA&amp;sig2=mlWWAnJgFVxSpA4UtA2wyw&gt;<br></p><p>underscore confusion | The Scala Programming Language &lt;http://www.scala-lang.org/old/node/2916.html&gt;<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/bd85b13e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Automating Partial Application via Wildcards</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>February  2, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Feb 2, 2016, at 1:31 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 2, 2016, at 11:14 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I know there is concern about overloading the semantics of `_` which is unfortunate as IMO it is the best symbol to serve as a placeholder.  I wonder if there has been confusion about the semantics in practice in languages like Scala where it is used in both ways.  Is there any evidence that this has been a problem?<br>&gt; <br>&gt; Not a super scientific study, but if you google &quot;scala underscore&quot;, several of the results on the first page indicate confusion or bewilderment:<br>&gt; <br>&gt; Scala _ [underscore] magic · Anantha Kumaran &lt;https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;ved=0ahUKEwj-08ju59nKAhWj26YKHRuVBh8QFggdMAA&amp;url=http%3A%2F%2Fananthakumaran.in%2F2010%2F03%2F29%2Fscala-underscore-magic.html&amp;usg=AFQjCNEbIIoppVNYAjr6wqxL4byR9I1fAw&amp;sig2=Hlw6hEFfsPqvlDvEFaDoyQ&gt;<br>&gt; <br>&gt; What are all the uses of an underscore in Scala? - Stack ... &lt;https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=2&amp;ved=0ahUKEwj-08ju59nKAhWj26YKHRuVBh8QFggjMAE&amp;url=http%3A%2F%2Fstackoverflow.com%2Fquestions%2F8000903%2Fwhat-are-all-the-uses-of-an-underscore-in-scala&amp;usg=AFQjCNHVNCJVosr0IzZYmh8pJRdnXTnf6g&amp;sig2=vqWgzaddf2kEkWrdgFQuoQ&amp;bvm=bv.113034660,d.dGY&gt;<br>&gt; <br>&gt; Scala dreaded underscore - SlideShare &lt;https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=3&amp;ved=0ahUKEwj-08ju59nKAhWj26YKHRuVBh8QFggqMAI&amp;url=http%3A%2F%2Fwww.slideshare.net%2Fnormation%2Fscala-dreaded&amp;usg=AFQjCNEs5fGA4e8NsU10--FKfOyga8aEaA&amp;sig2=mlWWAnJgFVxSpA4UtA2wyw&gt;<br>&gt; <br>&gt; underscore confusion | The Scala Programming Language &lt;http://www.scala-lang.org/old/node/2916.html&gt;<br>&gt; <br></p><p>Interesting.  It looks like Scala takes this to a crazy extreme.  I can definitely see why the core team is cautious about avoiding this mistake.  <br></p><p>The example in the last link you shared is a pretty strong argument for avoiding partial application syntax (regardless of placeholder).  It took me a minute to see what was happening there, while it would have been immediately clear with closure braces.<br></p><p>The thing I like about _ as a placeholder is the visual whitespace it leaves.  It looks like a “hole” in the expression.  I wish there was some other unclaimed symbol with that attribute.  <br></p><p>It would be nice if we could find something better than $.  The best argument in favor of that is precedent in other languages, but it comes at the cost of being noisy enough to impede readability IMO.<br></p><p>-Matthew<br></p><p>&gt; -Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/710e96bf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>[Proposal] Automating Partial Application via Wildcards</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>February  3, 2016 at 02:00:00am</p></header><div class="content"><p>There are things in Scala that flummoxed me early on - the underscore is not one of them.  It is just new syntax - similar to using $0 or something else that if you have not seen before or know what it is used for it throws you to begin with.  <br></p><p>It can always be taken to the extreme in a straw man argument to make a point, but for me it was definitely not an issue.<br></p><p><br></p><p><br>&gt; On 2016-02-03, at 2:42:44, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 2, 2016, at 1:31 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 2, 2016, at 11:14 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I know there is concern about overloading the semantics of `_` which is unfortunate as IMO it is the best symbol to serve as a placeholder.  I wonder if there has been confusion about the semantics in practice in languages like Scala where it is used in both ways.  Is there any evidence that this has been a problem?<br>&gt;&gt; <br>&gt;&gt; Not a super scientific study, but if you google &quot;scala underscore&quot;, several of the results on the first page indicate confusion or bewilderment:<br>&gt;&gt; <br>&gt;&gt; Scala _ [underscore] magic · Anantha Kumaran &lt;https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;ved=0ahUKEwj-08ju59nKAhWj26YKHRuVBh8QFggdMAA&amp;url=http%3A%2F%2Fananthakumaran.in%2F2010%2F03%2F29%2Fscala-underscore-magic.html&amp;usg=AFQjCNEbIIoppVNYAjr6wqxL4byR9I1fAw&amp;sig2=Hlw6hEFfsPqvlDvEFaDoyQ&gt;<br>&gt;&gt; <br>&gt;&gt; What are all the uses of an underscore in Scala? - Stack ... &lt;https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=2&amp;ved=0ahUKEwj-08ju59nKAhWj26YKHRuVBh8QFggjMAE&amp;url=http%3A%2F%2Fstackoverflow.com%2Fquestions%2F8000903%2Fwhat-are-all-the-uses-of-an-underscore-in-scala&amp;usg=AFQjCNHVNCJVosr0IzZYmh8pJRdnXTnf6g&amp;sig2=vqWgzaddf2kEkWrdgFQuoQ&amp;bvm=bv.113034660,d.dGY&gt;<br>&gt;&gt; <br>&gt;&gt; Scala dreaded underscore - SlideShare &lt;https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=3&amp;ved=0ahUKEwj-08ju59nKAhWj26YKHRuVBh8QFggqMAI&amp;url=http%3A%2F%2Fwww.slideshare.net%2Fnormation%2Fscala-dreaded&amp;usg=AFQjCNEs5fGA4e8NsU10--FKfOyga8aEaA&amp;sig2=mlWWAnJgFVxSpA4UtA2wyw&gt;<br>&gt;&gt; <br>&gt;&gt; underscore confusion | The Scala Programming Language &lt;http://www.scala-lang.org/old/node/2916.html&gt;<br>&gt;&gt; <br>&gt; <br>&gt; Interesting.  It looks like Scala takes this to a crazy extreme.  I can definitely see why the core team is cautious about avoiding this mistake.  <br>&gt; <br>&gt; The example in the last link you shared is a pretty strong argument for avoiding partial application syntax (regardless of placeholder).  It took me a minute to see what was happening there, while it would have been immediately clear with closure braces.<br>&gt; <br>&gt; The thing I like about _ as a placeholder is the visual whitespace it leaves.  It looks like a “hole” in the expression.  I wish there was some other unclaimed symbol with that attribute.  <br>&gt; <br>&gt; It would be nice if we could find something better than $.  The best argument in favor of that is precedent in other languages, but it comes at the cost of being noisy enough to impede readability IMO.<br>&gt; <br>&gt; -Matthew<br>&gt; <br>&gt;&gt; -Joe<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/cb4f343b/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Automating Partial Application via Wildcards</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February  2, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Feb 2, 2016, at 11:31 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 2, 2016, at 11:14 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I know there is concern about overloading the semantics of `_` which is unfortunate as IMO it is the best symbol to serve as a placeholder.  I wonder if there has been confusion about the semantics in practice in languages like Scala where it is used in both ways.  Is there any evidence that this has been a problem?<br>&gt; <br>&gt; Not a super scientific study, but if you google &quot;scala underscore&quot;, several of the results on the first page indicate confusion or bewilderment:<br>&gt; <br>&gt; Scala _ [underscore] magic · Anantha Kumaran &lt;https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;ved=0ahUKEwj-08ju59nKAhWj26YKHRuVBh8QFggdMAA&amp;url=http%3A%2F%2Fananthakumaran.in%2F2010%2F03%2F29%2Fscala-underscore-magic.html&amp;usg=AFQjCNEbIIoppVNYAjr6wqxL4byR9I1fAw&amp;sig2=Hlw6hEFfsPqvlDvEFaDoyQ&gt;<br>&gt; <br>&gt; What are all the uses of an underscore in Scala? - Stack ... &lt;https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=2&amp;ved=0ahUKEwj-08ju59nKAhWj26YKHRuVBh8QFggjMAE&amp;url=http%3A%2F%2Fstackoverflow.com%2Fquestions%2F8000903%2Fwhat-are-all-the-uses-of-an-underscore-in-scala&amp;usg=AFQjCNHVNCJVosr0IzZYmh8pJRdnXTnf6g&amp;sig2=vqWgzaddf2kEkWrdgFQuoQ&amp;bvm=bv.113034660,d.dGY&gt;<br>&gt; <br>&gt; Scala dreaded underscore - SlideShare &lt;https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=3&amp;ved=0ahUKEwj-08ju59nKAhWj26YKHRuVBh8QFggqMAI&amp;url=http%3A%2F%2Fwww.slideshare.net%2Fnormation%2Fscala-dreaded&amp;usg=AFQjCNEs5fGA4e8NsU10--FKfOyga8aEaA&amp;sig2=mlWWAnJgFVxSpA4UtA2wyw&gt;<br>&gt; <br>&gt; underscore confusion | The Scala Programming Language &lt;http://www.scala-lang.org/old/node/2916.html&gt;<br>&gt; <br></p><p>…and to be fair, I&#39;ve also seen a lot of complaints about Swift that there are too many syntaxes for forming function values, so I&#39;m hesitant to introduce yet more. If we had an awesome design that could *replace* some of the existing use cases, that might be more compelling.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/c6c6ce4b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e70505f1dd2dfb47c6d53d83492f3bdd?s=50"></div><header><strong>[Proposal] Automating Partial Application via Wildcards</strong> from <string>Christopher Whidden</string> &lt;christopher.whidden at gmail.com&gt;<p>February  2, 2016 at 02:00:00pm</p></header><div class="content"><p>After the removal of function currying in SE-0002, it seemed like partial application would be a sensible improvement to the general problem that function currying was trying to solve.  Scala-like partial application was even mentioned as an alternative in that proposal.<br>I was even thinking of writing up a proposal for this myself.<br></p><p>Joe’s arguments and his links have me pretty quickly convinced that this isn’t a great direction for Swift, especially with underscores.  Admittedly, this was always just a pure sugar feature, but I no longer think it has any redeeming qualities over Swift’s existing closure syntax with either $N parameters or named parameters.<br></p><p>Thanks for writing the proposal, Erica and Davide, but I’m -1 on this.<br></p><p><br>&gt; On Feb 2, 2016, at 1:31 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 2, 2016, at 11:14 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I know there is concern about overloading the semantics of `_` which is unfortunate as IMO it is the best symbol to serve as a placeholder.  I wonder if there has been confusion about the semantics in practice in languages like Scala where it is used in both ways.  Is there any evidence that this has been a problem?<br>&gt; <br>&gt; Not a super scientific study, but if you google &quot;scala underscore&quot;, several of the results on the first page indicate confusion or bewilderment:<br>&gt; <br>&gt; Scala _ [underscore] magic · Anantha Kumaran &lt;https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;ved=0ahUKEwj-08ju59nKAhWj26YKHRuVBh8QFggdMAA&amp;url=http%3A%2F%2Fananthakumaran.in%2F2010%2F03%2F29%2Fscala-underscore-magic.html&amp;usg=AFQjCNEbIIoppVNYAjr6wqxL4byR9I1fAw&amp;sig2=Hlw6hEFfsPqvlDvEFaDoyQ&gt;<br>&gt; <br>&gt; What are all the uses of an underscore in Scala? - Stack ... &lt;https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=2&amp;ved=0ahUKEwj-08ju59nKAhWj26YKHRuVBh8QFggjMAE&amp;url=http%3A%2F%2Fstackoverflow.com%2Fquestions%2F8000903%2Fwhat-are-all-the-uses-of-an-underscore-in-scala&amp;usg=AFQjCNHVNCJVosr0IzZYmh8pJRdnXTnf6g&amp;sig2=vqWgzaddf2kEkWrdgFQuoQ&amp;bvm=bv.113034660,d.dGY&gt;<br>&gt; <br>&gt; Scala dreaded underscore - SlideShare &lt;https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=3&amp;ved=0ahUKEwj-08ju59nKAhWj26YKHRuVBh8QFggqMAI&amp;url=http%3A%2F%2Fwww.slideshare.net%2Fnormation%2Fscala-dreaded&amp;usg=AFQjCNEs5fGA4e8NsU10--FKfOyga8aEaA&amp;sig2=mlWWAnJgFVxSpA4UtA2wyw&gt;<br>&gt; <br>&gt; underscore confusion | The Scala Programming Language &lt;http://www.scala-lang.org/old/node/2916.html&gt;<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/0f525551/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Proposal] Automating Partial Application via Wildcards</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>February  3, 2016 at 09:00:00am</p></header><div class="content"><p>Much prefer the syntax suggested by Greg that uses {} and $n<br></p><p>On Wednesday, 3 February 2016, Greg Titus via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; What about $N?  :-)<br>&gt;<br>&gt; And then you could also put {} around it so that it is more obvious that<br>&gt; partial1 is being assigned something that acts like a closure, and then you<br>&gt; end up with:<br>&gt;<br>&gt; let partial1 = { projectFunctionToCoordinateSystem(function:<br>&gt; mySinFunction, p0: p0, p1: p1, x: $0) }<br>&gt; let partial2 = { projectFunctionToCoordinateSystem(function:<br>&gt; mySinFunction, p0: .zero, p1: $0, x: $1) }<br>&gt;<br>&gt; instead of:<br>&gt;<br>&gt; let partial1 = projectFunctionToCoordinateSystem(function: mySinFunction,<br>&gt; p0: p0, p1: p1, x: _)<br>&gt; let partial2 = projectFunctionToCoordinateSystem(function: mySinFunction,<br>&gt; p0: .zero, p1: _, x: _)<br>&gt;<br>&gt;<br>&gt; I’m -1.<br>&gt;<br>&gt; With the way that single expression closures work, and the fact that they<br>&gt; are so syntactically light, I don’t think that this proposal would add<br>&gt; utility, it would just be one more construct to learn.<br>&gt;<br>&gt; - Greg<br>&gt;<br>&gt; On Feb 2, 2016, at 10:28 AM, Gwendal Roué via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt; What about nothing?<br>&gt;<br>&gt; let partial1 = f(arg1: 1, arg2:)<br>&gt;<br>&gt; Gwendal<br>&gt;<br>&gt; Le 2 févr. 2016 à 19:26, Gwendal Roué &lt;gwendal.roue at gmail.com<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;gwendal.roue at gmail.com&#39;);&gt;&gt; a écrit :<br>&gt;<br>&gt; Any operator character would be bad, since the function may accept it, as<br>&gt; in `[1,2,3].reduce(1, combine: *)`<br>&gt;<br>&gt; Gwendal<br>&gt;<br>&gt; Le 2 févr. 2016 à 19:24, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; a écrit :<br>&gt;<br>&gt;<br>&gt; On Feb 2, 2016, at 11:20 AM, Chris Lattner &lt;clattner at apple.com<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;clattner at apple.com&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt; On Feb 2, 2016, at 10:16 AM, Erica Sadun &lt;erica at ericasadun.com<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;erica at ericasadun.com&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt;<br>&gt; One superficial comment on this: the use of _ here is a bad idea.  _<br>&gt; already means something in expressions - “discard”, and a closely related<br>&gt; thing in declarations - “ignore”.<br>&gt;<br>&gt; Adding a third very different thing (placeholder to be filled in later)<br>&gt; seems like a really confusing thing to do.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>&gt;<br>&gt; #?<br>&gt;<br>&gt;<br>&gt; # means “macro like” or “compiler synthesized”.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>&gt; * would be bad, right? And naked ?-marks?<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br></p><p>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/6dcd4a9f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal] Automating Partial Application via Wildcards</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February  2, 2016 at 04:00:00pm</p></header><div class="content"><p>In current Swift,  this approach does not preserve argument labels :<br></p><p>let partial1 = { projectFunctionToCoordinateSystem(function: mySinFunction, p0: p0, p1: p1, x: $0) } // (CGFloat) -&gt; CGPoint<br>let partial2 = { projectFunctionToCoordinateSystem(function: mySinFunction, p0: .zero, p1: $0, x: $1) } // (CGPoint, CGFloat) -&gt; CGPoint<br></p><p><br>must be called partial1(0.5), not partial1(x: 0.5), unless you go to some significant work, as in the following:<br></p><p>let partial1: (x: CGFloat) -&gt; CGPoint = {<br>    projectFunctionToCoordinateSystem(function: mySinFunction, p0: p0, p1: p1, x: $0) <br>}<br></p><p>It&#39;s not that this is undoable, it&#39;s just ugly and laborious, things that are un-Swifty.  You must decide a priori which arguments will be applied, and manually name those that will not.<br></p><p>Compare with, for example, an imaginary version that uses $$ to accomplish the same with less planning and greater win:<br></p><p>let partial1 = projectFunctionToCoordinateSystem(function: mySinFunction, p0: p0, p1: p1, x: $$) // (x: CGFloat) -&gt; CGPoint<br></p><p>I find it a lot cleaner, less crufty™ and nicer to use than jerry-rigging with a closure.<br></p><p>-- E<br></p><p>&gt; On Feb 2, 2016, at 3:40 PM, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Much prefer the syntax suggested by Greg that uses {} and $n<br>&gt; <br>&gt; On Wednesday, 3 February 2016, Greg Titus via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; What about $N?  :-)  <br>&gt; <br>&gt; And then you could also put {} around it so that it is more obvious that partial1 is being assigned something that acts like a closure, and then you end up with:<br>&gt; <br>&gt; let partial1 = { projectFunctionToCoordinateSystem(function: mySinFunction, p0: p0, p1: p1, x: $0) }<br>&gt; let partial2 = { projectFunctionToCoordinateSystem(function: mySinFunction, p0: .zero, p1: $0, x: $1) }<br>&gt; <br>&gt; instead of:<br>&gt;&gt; let partial1 = projectFunctionToCoordinateSystem(function: mySinFunction, p0: p0, p1: p1, x: _) <br>&gt;&gt; let partial2 = projectFunctionToCoordinateSystem(function: mySinFunction, p0: .zero, p1: _, x: _) <br>&gt; <br>&gt; I’m -1.<br>&gt; <br>&gt; With the way that single expression closures work, and the fact that they are so syntactically light, I don’t think that this proposal would add utility, it would just be one more construct to learn.<br>&gt; <br>&gt; 	- Greg<br>&gt; <br>&gt;&gt; On Feb 2, 2016, at 10:28 AM, Gwendal Roué via swift-evolution &lt;swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; What about nothing?<br>&gt;&gt; <br>&gt;&gt; let partial1 = f(arg1: 1, arg2:)<br>&gt;&gt; Gwendal<br>&gt;&gt; <br>&gt;&gt;&gt; Le 2 févr. 2016 à 19:26, Gwendal Roué &lt;gwendal.roue at gmail.com &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;gwendal.roue at gmail.com&#39;);&gt;&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Any operator character would be bad, since the function may accept it, as in `[1,2,3].reduce(1, combine: *)`<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Gwendal<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Le 2 févr. 2016 à 19:24, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Feb 2, 2016, at 11:20 AM, Chris Lattner &lt;clattner at apple.com &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;clattner at apple.com&#39;);&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Feb 2, 2016, at 10:16 AM, Erica Sadun &lt;erica at ericasadun.com &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;erica at ericasadun.com&#39;);&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; One superficial comment on this: the use of _ here is a bad idea.  _ already means something in expressions - “discard”, and a closely related thing in declarations - “ignore”.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Adding a third very different thing (placeholder to be filled in later) seems like a really confusing thing to do.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; #?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; # means “macro like” or “compiler synthesized”.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * would be bad, right? And naked ?-marks?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- E<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt;   -- Howard.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/7da05dc5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Automating Partial Application via Wildcards</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February  2, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Feb 2, 2016, at 3:03 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; In current Swift,  this approach does not preserve argument labels :<br>&gt; <br>&gt; let partial1 = { projectFunctionToCoordinateSystem(function: mySinFunction, p0: p0, p1: p1, x: $0) } // (CGFloat) -&gt; CGPoint<br>&gt; let partial2 = { projectFunctionToCoordinateSystem(function: mySinFunction, p0: .zero, p1: $0, x: $1) } // (CGPoint, CGFloat) -&gt; CGPoint<br>&gt; <br>&gt; <br>&gt; must be called partial1(0.5), not partial1(x: 0.5), unless you go to some significant work, as in the following:<br>&gt; <br>&gt; let partial1: (x: CGFloat) -&gt; CGPoint = {<br>&gt;     projectFunctionToCoordinateSystem(function: mySinFunction, p0: p0, p1: p1, x: $0) <br>&gt; }<br>&gt; <br>&gt; It&#39;s not that this is undoable, it&#39;s just ugly and laborious, things that are un-Swifty.  You must decide a priori which arguments will be applied, and manually name those that will not.<br>&gt; <br>&gt; Compare with, for example, an imaginary version that uses $$ to accomplish the same with less planning and greater win:<br>&gt; <br>&gt; let partial1 = projectFunctionToCoordinateSystem(function: mySinFunction, p0: p0, p1: p1, x: $$) // (x: CGFloat) -&gt; CGPoint<br>&gt; <br>&gt; I find it a lot cleaner, less crufty™ and nicer to use than jerry-rigging with a closure.<br></p><p>Closures having unlabeled arguments is a feature, IMO. Propagating labels through the function type system introduces type differences where there don&#39;t need to be.<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/7dffc40b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal] Automating Partial Application via Wildcards</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February  2, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Feb 2, 2016, at 4:42 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Feb 2, 2016, at 3:03 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; In current Swift,  this approach does not preserve argument labels :<br>&gt;&gt; <br>&gt;&gt; let partial1 = { projectFunctionToCoordinateSystem(function: mySinFunction, p0: p0, p1: p1, x: $0) } // (CGFloat) -&gt; CGPoint<br>&gt;&gt; let partial2 = { projectFunctionToCoordinateSystem(function: mySinFunction, p0: .zero, p1: $0, x: $1) } // (CGPoint, CGFloat) -&gt; CGPoint<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; must be called partial1(0.5), not partial1(x: 0.5), unless you go to some significant work, as in the following:<br>&gt;&gt; <br>&gt;&gt; let partial1: (x: CGFloat) -&gt; CGPoint = {<br>&gt;&gt;     projectFunctionToCoordinateSystem(function: mySinFunction, p0: p0, p1: p1, x: $0) <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; It&#39;s not that this is undoable, it&#39;s just ugly and laborious, things that are un-Swifty.  You must decide a priori which arguments will be applied, and manually name those that will not.<br>&gt;&gt; <br>&gt;&gt; Compare with, for example, an imaginary version that uses $$ to accomplish the same with less planning and greater win:<br>&gt;&gt; <br>&gt;&gt; let partial1 = projectFunctionToCoordinateSystem(function: mySinFunction, p0: p0, p1: p1, x: $$) // (x: CGFloat) -&gt; CGPoint<br>&gt;&gt; <br>&gt;&gt; I find it a lot cleaner, less crufty™ and nicer to use than jerry-rigging with a closure.<br>&gt; <br>&gt; Closures having unlabeled arguments is a feature, IMO. Propagating labels through the function type system introduces type differences where there don&#39;t need to be.<br>&gt; <br>&gt; -Joe<br></p><p>I&#39;m not suggesting they do otherwise. I was saying that using closures for partial application vs scala-style currying has a cost, which makes them less desirable for this (partial) application.<br></p><p>Regardless, I want to thank everyone who participated in this discussion and gave feedback both positive and negative.<br></p><p>Appreciatively, -- Erica<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/a778b87f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Automating Partial Application via Wildcards</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February  2, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Feb 2, 2016, at 3:58 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Feb 2, 2016, at 4:42 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Feb 2, 2016, at 3:03 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In current Swift,  this approach does not preserve argument labels :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let partial1 = { projectFunctionToCoordinateSystem(function: mySinFunction, p0: p0, p1: p1, x: $0) } // (CGFloat) -&gt; CGPoint<br>&gt;&gt;&gt; let partial2 = { projectFunctionToCoordinateSystem(function: mySinFunction, p0: .zero, p1: $0, x: $1) } // (CGPoint, CGFloat) -&gt; CGPoint<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; must be called partial1(0.5), not partial1(x: 0.5), unless you go to some significant work, as in the following:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let partial1: (x: CGFloat) -&gt; CGPoint = {<br>&gt;&gt;&gt;     projectFunctionToCoordinateSystem(function: mySinFunction, p0: p0, p1: p1, x: $0) <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s not that this is undoable, it&#39;s just ugly and laborious, things that are un-Swifty.  You must decide a priori which arguments will be applied, and manually name those that will not.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Compare with, for example, an imaginary version that uses $$ to accomplish the same with less planning and greater win:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let partial1 = projectFunctionToCoordinateSystem(function: mySinFunction, p0: p0, p1: p1, x: $$) // (x: CGFloat) -&gt; CGPoint<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I find it a lot cleaner, less crufty™ and nicer to use than jerry-rigging with a closure.<br>&gt;&gt; <br>&gt;&gt; Closures having unlabeled arguments is a feature, IMO. Propagating labels through the function type system introduces type differences where there don&#39;t need to be.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt; <br>&gt; I&#39;m not suggesting they do otherwise. I was saying that using closures for partial application vs scala-style currying has a cost, which makes them less desirable for this (partial) application.<br></p><p>Ultimately, I think we want argument labels to be part of the name, not half-part-of-the-name-half-part-of-the-type like they are today. In the pure-names model, you could plausibly be allowed to name closure variables with compound names:<br></p><p>let partial2(p1:x:) = { projectFunctionToCoordinateSystem(function: mySinFunction, p0: .zero, p1: $0, x: $1) }<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/315f3d0d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal] Automating Partial Application via Wildcards</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February  3, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Feb 2, 2016, at 5:34 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; I&#39;m not suggesting they do otherwise. I was saying that using closures for partial application vs scala-style currying has a cost, which makes them less desirable for this (partial) application.<br>&gt; <br>&gt; Ultimately, I think we want argument labels to be part of the name, not half-part-of-the-name-half-part-of-the-type like they are today. In the pure-names model, you could plausibly be allowed to name closure variables with compound names:<br>&gt; <br>&gt; let partial2(p1:x:) = { projectFunctionToCoordinateSystem(function: mySinFunction, p0: .zero, p1: $0, x: $1) }<br>&gt; <br>&gt; -Joe<br></p><p>That would be awesome.<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/cdad8852/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Proposal] Automating Partial Application via Wildcards</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>February  3, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; Ultimately, I think we want argument labels to be part of the name, not half-part-of-the-name-half-part-of-the-type like they are today.<br></p><p>I think this would be a good move, as it could help with a topic that I haven&#39;t seen discussed here before:<br>Mixing Swift with other languages.<br></p><p>The goal &quot;Objective C without the C&quot; is good as long as it is about syntax and safety, but compatibility with the &quot;lingua franca&quot; of programming imho should be considered an advantage.<br>I know about calling C-code from Swift, but haven&#39;t seen much information on the other direction so far, and afair, it wasn&#39;t mentioned in SE-0021 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0021-generalized-naming.md&gt;<br></p><p>As argument labels are a concept that is not available in most languages, it would be nice if there was an easy way to move them into the function name.<br></p><p>Tino<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/f4dda46a/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Proposal] Automating Partial Application via Wildcards</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>February  4, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On 03 Feb 2016, at 01:34, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Ultimately, I think we want argument labels to be part of the name, not half-part-of-the-name-half-part-of-the-type like they are today.<br></p><p>I&#39;d really love for labels to be part-of-the-name only. Is it worth starting a proposition for that for the 3.0 time frame?<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Automating Partial Application via Wildcards</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February  3, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Feb 3, 2016, at 3:51 PM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 03 Feb 2016, at 01:34, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Ultimately, I think we want argument labels to be part of the name, not half-part-of-the-name-half-part-of-the-type like they are today.<br>&gt; <br>&gt; I&#39;d really love for labels to be part-of-the-name only. Is it worth starting a proposition for that for the 3.0 time frame?<br></p><p>Yeah, it&#39;s worth discussion, though I don&#39;t know that we have bandwidth to get all the way there this year. This part of the type checker is deep in technical debt. You might reach out to Chris Willmore, who&#39;s been exploring this space internally.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Proposal] Automating Partial Application via Wildcards</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>February  4, 2016 at 10:00:00am</p></header><div class="content"><p>I’ve started a discussion on that topic. Could you bring some input to help me understand the problem in detail?<br></p><p>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160201/009049.html<br></p><p>&gt; On 04 Feb 2016, at 01:06, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 3, 2016, at 3:51 PM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 03 Feb 2016, at 01:34, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Ultimately, I think we want argument labels to be part of the name, not half-part-of-the-name-half-part-of-the-type like they are today.<br>&gt;&gt; <br>&gt;&gt; I&#39;d really love for labels to be part-of-the-name only. Is it worth starting a proposition for that for the 3.0 time frame?<br>&gt; <br>&gt; Yeah, it&#39;s worth discussion, though I don&#39;t know that we have bandwidth to get all the way there this year. This part of the type checker is deep in technical debt. You might reach out to Chris Willmore, who&#39;s been exploring this space internally.<br>&gt; <br>&gt; -Joe<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal] Automating Partial Application via Wildcards</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>February  2, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Feb 2, 2016, at 9:33 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; First draft. Let&#39;s go Scala!<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; Automating Partial Application via Wildcards<br>&gt; <br>&gt; Proposal: TBD<br>&gt; Author(s): Erica Sadun &lt;http://github.com/erica&gt;, Davide De Franceschi &lt;http://github.com/DeFrenZ&gt;<br>&gt; Status: TBD<br>&gt; Review manager: TBD<br>&gt;  &lt;https://gist.github.com/erica/6327981d42eb9be6b4d2#introduction&gt;Introduction<br>&gt; <br>&gt; SE-0002 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0002-remove-currying.md&gt; has been accepted for Swift 3.0. That proposal removes currying func declaration syntax from Swift. It reasons that currying introduces unnecessary language and implementation complexity and is easily replaced with chained function return types. <br>&gt; <br>&gt; Because of SE-0002, this curried example:<br>&gt; <br>&gt; public func projectFunctionToCoordinateSystem(function f: FunctionType)(p0: CGPoint, p1: CGPoint)(x: CGFloat) -&gt; CGPoint<br>&gt; becomes<br>&gt; <br>&gt; public func projectFunctionToCoordinateSystem(function f: FunctionType) -&gt; (p0: CGPoint, p1: CGPoint) -&gt; (x: CGFloat) -&gt; CGPoint <br>&gt; in Swift 3.<br>&gt; <br>&gt; It&#39;s mechanically simple to re-introduce partial application but the current solution adds unnecessary nesting and complicated closure declarations, as you see in the following Swift 3 version of this projection function.<br>&gt; <br>&gt; public func projectFunctionToCoordinateSystem(function f: FunctionType) -&gt; (p0: CGPoint, p1: CGPoint) -&gt; (x: CGFloat) -&gt; CGPoint {<br>&gt;   return { p0, p1 in<br>&gt;     return { x in<br>&gt;       let (dx, dy) = (p1.x - p0.x, p1.y - p0.y)<br>&gt;       let (magnitude, theta) = (hypot(dy, dx), atan2(dy, dx)) // Thanks loooop<br>&gt;       var outPoint = CGPoint(x: x * magnitude, y: f(x) * magnitude)<br>&gt;       outPoint = CGPointApplyAffineTransform(outPoint, CGAffineTransformMakeRotation(theta))<br>&gt;       outPoint = CGPointApplyAffineTransform(outPoint, CGAffineTransformMakeTranslation(p0.x, p0.y))<br>&gt;       return CGPoint(x: outPoint.x, y: outPoint.y)<br>&gt;     }<br>&gt;   }<br>&gt; }<br>&gt; SE-0002 mentions the possibility of introducing Scala-style free-form partial implementation as a future step. This proposal requests that a Scala-style wildcard feature be adopted into Swift by introducing a form of automatic partial application.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/6327981d42eb9be6b4d2#detail-design&gt;Detail Design<br>&gt; <br>&gt; The proposed design replaces a Swift 3 curried signature like this: <br>&gt; <br>&gt; public func projectFunctionToCoordinateSystem(function f: FunctionType) -&gt; (p0: CGPoint, p1: CGPoint) -&gt; (x: CGFloat) -&gt; CGPoint<br>&gt; with a non-curried, fully qualified call like this:<br>&gt; <br>&gt; public func projectFunctionToCoordinateSystem(function f: FunctionType, p0: CGPoint, p1: CGPoint, x: CGFloat) -&gt; CGPoint<br>&gt; When called with wildcard tokens, the function is partially applied using the supplied arguments. For example:<br>&gt; <br>&gt; let partial1 = projectFunctionToCoordinateSystem(function: mySinFunction, p0: p0, p1: p1, x: _)<br>&gt; // partial1(x: xValue)<br>&gt; <br>&gt; let partial2 = projectFunctionToCoordinateSystem(function: mySinFunction, p0: .zero, p1: _, x: _)<br>&gt; // partial2(p1: p1Value, x: xValue) <br>&gt; // or<br>&gt; // let partial3 = partial2(p1: p1Value, x: _); partial3(x: 0.25)<br>In the SE-0021 acceptance rationale at <br></p><p>	http://article.gmane.org/gmane.comp.lang.swift.evolution/3961/match=accepted+0021<br></p><p>Joe Groff sayeth:<br></p><p>A number of contributors proposed an alternative syntax, using a placeholder in the argument value position:<br></p><p>let x = Foo.bar(_, bas: _)<br></p><p>with the idea that this could potentially generalize to partial application syntax. We don&#39;t think this is a good direction for Swift for a couple of reasons. Swift already has fairly compact syntax for forming closures over partially applied functions, { Foo.bar($0, bas: $1) }. It may not be everyone&#39;s aesthetic cup of tea, but this notation has several important advantages. The braces unambiguously delineate the boundaries of the closure, which is a subtle problem with Scala-like approaches. The braces also provide a visual cue that capture is occurring. The $n placeholders are also more general since they allow for reordering of arguments. &#39;_&#39; in particular is also a poor choice of placeholder, since in other contexts where it&#39;s used, it&#39;s meant as a &quot;black hole&quot; for value binding in patterns rather than as a placeholder for a meaningful bound value.<br></p><p><br>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/3bd2e29e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Proposal] Automating Partial Application via Wildcards</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>February  2, 2016 at 11:00:00am</p></header><div class="content"><p>Hmm...the rationale that Joe provided makes a lot of sense.<br></p><p>One question - is the explicit closure syntax amenable to multiple levels of currying? In particular, what are the scoping rules for the placeholders $n - are they limited to the immediate closure within which they appear, or can they be used within further-nested closures?<br></p><p>Best,<br>Austin<br></p><p>&gt; On Feb 2, 2016, at 11:01 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 2, 2016, at 9:33 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; First draft. Let&#39;s go Scala!<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt; Automating Partial Application via Wildcards<br>&gt;&gt; <br>&gt;&gt; Proposal: TBD<br>&gt;&gt; Author(s): Erica Sadun &lt;http://github.com/erica&gt;, Davide De Franceschi &lt;http://github.com/DeFrenZ&gt;<br>&gt;&gt; Status: TBD<br>&gt;&gt; Review manager: TBD<br>&gt;&gt;  &lt;https://gist.github.com/erica/6327981d42eb9be6b4d2#introduction&gt;Introduction<br>&gt;&gt; <br>&gt;&gt; SE-0002 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0002-remove-currying.md&gt; has been accepted for Swift 3.0. That proposal removes currying func declaration syntax from Swift. It reasons that currying introduces unnecessary language and implementation complexity and is easily replaced with chained function return types. <br>&gt;&gt; <br>&gt;&gt; Because of SE-0002, this curried example:<br>&gt;&gt; <br>&gt;&gt; public func projectFunctionToCoordinateSystem(function f: FunctionType)(p0: CGPoint, p1: CGPoint)(x: CGFloat) -&gt; CGPoint<br>&gt;&gt; becomes<br>&gt;&gt; <br>&gt;&gt; public func projectFunctionToCoordinateSystem(function f: FunctionType) -&gt; (p0: CGPoint, p1: CGPoint) -&gt; (x: CGFloat) -&gt; CGPoint <br>&gt;&gt; in Swift 3.<br>&gt;&gt; <br>&gt;&gt; It&#39;s mechanically simple to re-introduce partial application but the current solution adds unnecessary nesting and complicated closure declarations, as you see in the following Swift 3 version of this projection function.<br>&gt;&gt; <br>&gt;&gt; public func projectFunctionToCoordinateSystem(function f: FunctionType) -&gt; (p0: CGPoint, p1: CGPoint) -&gt; (x: CGFloat) -&gt; CGPoint {<br>&gt;&gt;   return { p0, p1 in<br>&gt;&gt;     return { x in<br>&gt;&gt;       let (dx, dy) = (p1.x - p0.x, p1.y - p0.y)<br>&gt;&gt;       let (magnitude, theta) = (hypot(dy, dx), atan2(dy, dx)) // Thanks loooop<br>&gt;&gt;       var outPoint = CGPoint(x: x * magnitude, y: f(x) * magnitude)<br>&gt;&gt;       outPoint = CGPointApplyAffineTransform(outPoint, CGAffineTransformMakeRotation(theta))<br>&gt;&gt;       outPoint = CGPointApplyAffineTransform(outPoint, CGAffineTransformMakeTranslation(p0.x, p0.y))<br>&gt;&gt;       return CGPoint(x: outPoint.x, y: outPoint.y)<br>&gt;&gt;     }<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; SE-0002 mentions the possibility of introducing Scala-style free-form partial implementation as a future step. This proposal requests that a Scala-style wildcard feature be adopted into Swift by introducing a form of automatic partial application.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/erica/6327981d42eb9be6b4d2#detail-design&gt;Detail Design<br>&gt;&gt; <br>&gt;&gt; The proposed design replaces a Swift 3 curried signature like this: <br>&gt;&gt; <br>&gt;&gt; public func projectFunctionToCoordinateSystem(function f: FunctionType) -&gt; (p0: CGPoint, p1: CGPoint) -&gt; (x: CGFloat) -&gt; CGPoint<br>&gt;&gt; with a non-curried, fully qualified call like this:<br>&gt;&gt; <br>&gt;&gt; public func projectFunctionToCoordinateSystem(function f: FunctionType, p0: CGPoint, p1: CGPoint, x: CGFloat) -&gt; CGPoint<br>&gt;&gt; When called with wildcard tokens, the function is partially applied using the supplied arguments. For example:<br>&gt;&gt; <br>&gt;&gt; let partial1 = projectFunctionToCoordinateSystem(function: mySinFunction, p0: p0, p1: p1, x: _)<br>&gt;&gt; // partial1(x: xValue)<br>&gt;&gt; <br>&gt;&gt; let partial2 = projectFunctionToCoordinateSystem(function: mySinFunction, p0: .zero, p1: _, x: _)<br>&gt;&gt; // partial2(p1: p1Value, x: xValue) <br>&gt;&gt; // or<br>&gt;&gt; // let partial3 = partial2(p1: p1Value, x: _); partial3(x: 0.25)<br>&gt; In the SE-0021 acceptance rationale at <br>&gt; <br>&gt; 	http://article.gmane.org/gmane.comp.lang.swift.evolution/3961/match=accepted+0021 &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/3961/match=accepted+0021&gt;<br>&gt; <br>&gt; Joe Groff sayeth:<br>&gt; <br>&gt; A number of contributors proposed an alternative syntax, using a placeholder in the argument value position:<br>&gt; <br>&gt; let x = Foo.bar(_, bas: _)<br>&gt; <br>&gt; with the idea that this could potentially generalize to partial application syntax. We don&#39;t think this is a good direction for Swift for a couple of reasons. Swift already has fairly compact syntax for forming closures over partially applied functions, { Foo.bar($0, bas: $1) }. It may not be everyone&#39;s aesthetic cup of tea, but this notation has several important advantages. The braces unambiguously delineate the boundaries of the closure, which is a subtle problem with Scala-like approaches. The braces also provide a visual cue that capture is occurring. The $n placeholders are also more general since they allow for reordering of arguments. &#39;_&#39; in particular is also a poor choice of placeholder, since in other contexts where it&#39;s used, it&#39;s meant as a &quot;black hole&quot; for value binding in patterns rather than as a placeholder for a meaningful bound value.<br>&gt; <br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/05effbab/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Automating Partial Application via Wildcards</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February  2, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Feb 2, 2016, at 11:12 AM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hmm...the rationale that Joe provided makes a lot of sense.<br>&gt; <br>&gt; One question - is the explicit closure syntax amenable to multiple levels of currying? In particular, what are the scoping rules for the placeholders $n - are they limited to the immediate closure within which they appear, or can they be used within further-nested closures?<br></p><p>Currently, they&#39;re always scoped to the immediate closure, so you need to use explicit named parameters if you want to nest closures.<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/0eb8a26f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Proposal] Automating Partial Application via Wildcards</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>February  2, 2016 at 11:00:00am</p></header><div class="content"><p>That makes sense too. It might be a little less elegant in appearance, but<br>I think all the expressive power is there.<br></p><p>Thanks for answering my questions; I&#39;m now at +0 with this proposal and<br>look forward to seeing what other people have to say, for or again.<br></p><p>Austin<br></p><p>On Tue, Feb 2, 2016 at 11:26 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Feb 2, 2016, at 11:12 AM, Austin Zheng via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Hmm...the rationale that Joe provided makes a lot of sense.<br>&gt;<br>&gt; One question - is the explicit closure syntax amenable to multiple levels<br>&gt; of currying? In particular, what are the scoping rules for the placeholders<br>&gt; $*n *- are they limited to the immediate closure within which they<br>&gt; appear, or can they be used within further-nested closures?<br>&gt;<br>&gt;<br>&gt; Currently, they&#39;re always scoped to the immediate closure, so you need to<br>&gt; use explicit named parameters if you want to nest closures.<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/8c1dbcae/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal] Automating Partial Application via Wildcards</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>February  2, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Feb 2, 2016, at 11:12 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; Hmm...the rationale that Joe provided makes a lot of sense.<br></p><p>If it wasn’t clear, that rationale is from the core team discussion of SE-0021. <br></p><p>I’m very strongly -1 on this.<br></p><p>	- Doug<br></p><p>&gt; One question - is the explicit closure syntax amenable to multiple levels of currying? In particular, what are the scoping rules for the placeholders $n - are they limited to the immediate closure within which they appear, or can they be used within further-nested closures?<br>&gt; <br>&gt; Best,<br>&gt; Austin<br>&gt; <br>&gt;&gt; On Feb 2, 2016, at 11:01 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 2, 2016, at 9:33 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; First draft. Let&#39;s go Scala!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- E<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Automating Partial Application via Wildcards<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposal: TBD<br>&gt;&gt;&gt; Author(s): Erica Sadun &lt;http://github.com/erica&gt;, Davide De Franceschi &lt;http://github.com/DeFrenZ&gt;<br>&gt;&gt;&gt; Status: TBD<br>&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt;  &lt;https://gist.github.com/erica/6327981d42eb9be6b4d2#introduction&gt;Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; SE-0002 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0002-remove-currying.md&gt; has been accepted for Swift 3.0. That proposal removes currying func declaration syntax from Swift. It reasons that currying introduces unnecessary language and implementation complexity and is easily replaced with chained function return types. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Because of SE-0002, this curried example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public func projectFunctionToCoordinateSystem(function f: FunctionType)(p0: CGPoint, p1: CGPoint)(x: CGFloat) -&gt; CGPoint<br>&gt;&gt;&gt; becomes<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public func projectFunctionToCoordinateSystem(function f: FunctionType) -&gt; (p0: CGPoint, p1: CGPoint) -&gt; (x: CGFloat) -&gt; CGPoint <br>&gt;&gt;&gt; in Swift 3.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s mechanically simple to re-introduce partial application but the current solution adds unnecessary nesting and complicated closure declarations, as you see in the following Swift 3 version of this projection function.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public func projectFunctionToCoordinateSystem(function f: FunctionType) -&gt; (p0: CGPoint, p1: CGPoint) -&gt; (x: CGFloat) -&gt; CGPoint {<br>&gt;&gt;&gt;   return { p0, p1 in<br>&gt;&gt;&gt;     return { x in<br>&gt;&gt;&gt;       let (dx, dy) = (p1.x - p0.x, p1.y - p0.y)<br>&gt;&gt;&gt;       let (magnitude, theta) = (hypot(dy, dx), atan2(dy, dx)) // Thanks loooop<br>&gt;&gt;&gt;       var outPoint = CGPoint(x: x * magnitude, y: f(x) * magnitude)<br>&gt;&gt;&gt;       outPoint = CGPointApplyAffineTransform(outPoint, CGAffineTransformMakeRotation(theta))<br>&gt;&gt;&gt;       outPoint = CGPointApplyAffineTransform(outPoint, CGAffineTransformMakeTranslation(p0.x, p0.y))<br>&gt;&gt;&gt;       return CGPoint(x: outPoint.x, y: outPoint.y)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; SE-0002 mentions the possibility of introducing Scala-style free-form partial implementation as a future step. This proposal requests that a Scala-style wildcard feature be adopted into Swift by introducing a form of automatic partial application.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://gist.github.com/erica/6327981d42eb9be6b4d2#detail-design&gt;Detail Design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The proposed design replaces a Swift 3 curried signature like this: <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public func projectFunctionToCoordinateSystem(function f: FunctionType) -&gt; (p0: CGPoint, p1: CGPoint) -&gt; (x: CGFloat) -&gt; CGPoint<br>&gt;&gt;&gt; with a non-curried, fully qualified call like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public func projectFunctionToCoordinateSystem(function f: FunctionType, p0: CGPoint, p1: CGPoint, x: CGFloat) -&gt; CGPoint<br>&gt;&gt;&gt; When called with wildcard tokens, the function is partially applied using the supplied arguments. For example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let partial1 = projectFunctionToCoordinateSystem(function: mySinFunction, p0: p0, p1: p1, x: _)<br>&gt;&gt;&gt; // partial1(x: xValue)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let partial2 = projectFunctionToCoordinateSystem(function: mySinFunction, p0: .zero, p1: _, x: _)<br>&gt;&gt;&gt; // partial2(p1: p1Value, x: xValue) <br>&gt;&gt;&gt; // or<br>&gt;&gt;&gt; // let partial3 = partial2(p1: p1Value, x: _); partial3(x: 0.25)<br>&gt;&gt; In the SE-0021 acceptance rationale at <br>&gt;&gt; <br>&gt;&gt; 	http://article.gmane.org/gmane.comp.lang.swift.evolution/3961/match=accepted+0021 &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/3961/match=accepted+0021&gt;<br>&gt;&gt; <br>&gt;&gt; Joe Groff sayeth:<br>&gt;&gt; <br>&gt;&gt; A number of contributors proposed an alternative syntax, using a placeholder in the argument value position:<br>&gt;&gt; <br>&gt;&gt; let x = Foo.bar(_, bas: _)<br>&gt;&gt; <br>&gt;&gt; with the idea that this could potentially generalize to partial application syntax. We don&#39;t think this is a good direction for Swift for a couple of reasons. Swift already has fairly compact syntax for forming closures over partially applied functions, { Foo.bar($0, bas: $1) }. It may not be everyone&#39;s aesthetic cup of tea, but this notation has several important advantages. The braces unambiguously delineate the boundaries of the closure, which is a subtle problem with Scala-like approaches. The braces also provide a visual cue that capture is occurring. The $n placeholders are also more general since they allow for reordering of arguments. &#39;_&#39; in particular is also a poor choice of placeholder, since in other contexts where it&#39;s used, it&#39;s meant as a &quot;black hole&quot; for value binding in patterns rather than as a placeholder for a meaningful bound value.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/38a23f0b/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
