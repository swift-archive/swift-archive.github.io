<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Proposal] Change guarantee for GeneratorType.next() to always return nil past end</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>March  5, 2016 at 09:00:00pm</p></header><div class="content"><p>on Sat Mar 05 2016, Kevin Ballard &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Thu, Mar 3, 2016, at 03:24 AM, Patrick Pijnappel via swift-evolution wrote:<br>&gt;&gt; Hmm I see.<br>&gt;&gt;<br>&gt;&gt; Do we have any example cases where returning nil repeatedly would<br>&gt;&gt; require extra branches or state?<br>&gt;<br>&gt; Yes. My proposed .takeWhile() and .dropWhile() sequence adaptors<br>&gt; (https://github.com/apple/swift-evolution/pull/95) would hit this case.<br>&gt; Both of those adaptors would need to keep around extra state and in<br>&gt; order to keep returning nil.<br></p><p>Are there realistic cases where this state and check would produce<br>measurable overhead?<br></p><p>Do you have an implementation somewhere I could look at?<br></p><p>&gt; My preferred solution for this case is to add a new Generator adaptor<br>&gt; called a FuseGenerator, with a convenience method .fuse(). All this<br>&gt; adaptor does is include the extra state in order to ensure it keeps<br>&gt; returning nil forever. This way Generators don&#39;t have to keep the state<br>&gt; for that guarantee, and the majority case where client codes doesn&#39;t<br>&gt; rely on this guarantee doesn&#39;t need the check either, and in the rare<br>&gt; case where this guarantee is important all the user has to do is call<br>&gt; .fuse() on the generator and use the result of that instead.<br></p><p>Between the lack of predictability being addressed here and the addition<br>of a rarely-used additional component, that&#39;s a lot of complexity in the<br>library; is there a clear benefit?<br></p><p>&gt; All that said, I would be strongly in favor of dropping the language<br>&gt; about triggering a precondition failure. I&#39;d prefer to leave it as implementation-<br>&gt; defined behavior, which an encouragement to keep returning nil if it&#39;s<br>&gt; easy to do so. A benefit of this is Generators could opt to explicitly<br>&gt; define their post-nil behavior, e.g. TakeWhileGenerator could explicitly<br>&gt; document that after it has returned nil, subsequent calls to .next()<br>&gt; will continue to consume the underlying generator and return another<br>&gt; stream of elements terminating in `nil` (with the caveat that if the<br>&gt; underlying generator is exhausted then behavior depends on the<br>&gt; underlying generator&#39;s post-nil behavior). Granted, this probably isn&#39;t<br>&gt; useful in most cases, but it could be useful upon occasion as a way to<br>&gt; lazily split a sequence without building intermediate data structures<br>&gt; (assuming that the underlying generator is fused or defines its post-nil<br>&gt; behavior as returning nil forever).<br></p><p>TakeWhileGenerator could also provide a method that returns the<br>TakeWhileGenerator for the next segment.  Since you have to know that<br>you&#39;ve got a TakeWhileGenerator to take advantage of this special<br>behavior, a different interface is just as useful and probably results<br>in clearer code.  <br></p><p>&gt; FWIW, Rust uses precisely the solution I&#39;ve described here (and in fact<br>&gt; I&#39;m responsible for its std::iter::Fuse iterator). It defines<br>&gt; Iterator::next() such that calling .next() after it has returned None<br>&gt; may or may not return more elements (but Iterators are not supposed to<br>&gt; assert in this case, they should always return something). And it has<br>&gt; the .fuse() convenience method that returns a std::iter::Fuse iterator<br>&gt; that provides the always-returns-None guarantee. And in practice, almost<br>&gt; nobody ever has to actually use .fuse(), since almost nobody writes<br>&gt; algorithms that cares about the behavior after next() returns None (and<br>&gt; in the rare case where they do, they&#39;re typically using some concrete<br>&gt; Iterator that has defined behavior, as opposed to working on arbitrary<br>&gt; Iterators).<br></p><p>This is about balancing performance, flexibility, simplicity of<br>specification, and predictability.  Rust has a very C++-like approach to<br>zero-overhead abstractions, in the sense that it&#39;s willing to introduce<br>many small wrinkles to avoid even the theoretical possibility of a<br>performance penalty.  Having cut my language/library-design teeth in the<br>C++ world, I understand that approach really well, but I have also seen<br>it do some damage (some of which I was personally responsible for!) and<br>I want to be more conservative with Swift.  In short, I&#39;m still leaning<br>towards specifying post-nil behavior, and I&#39;d want to have more evidence of<br>the value of leaving it unspecified before doing so.<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Proposal] Change guarantee for GeneratorType.next() to always return nil past end</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>March  6, 2016 at 05:00:00pm</p></header><div class="content"><p>On Sat, Mar 5, 2016, at 09:12 PM, Dave Abrahams via swift-evolution wrote:<br>&gt; <br>&gt; on Sat Mar 05 2016, Kevin Ballard &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; &gt; On Thu, Mar 3, 2016, at 03:24 AM, Patrick Pijnappel via swift-evolution wrote:<br>&gt; &gt;&gt; Hmm I see.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Do we have any example cases where returning nil repeatedly would<br>&gt; &gt;&gt; require extra branches or state?<br>&gt; &gt;<br>&gt; &gt; Yes. My proposed .takeWhile() and .dropWhile() sequence adaptors<br>&gt; &gt; (https://github.com/apple/swift-evolution/pull/95) would hit this case.<br>&gt; &gt; Both of those adaptors would need to keep around extra state and in<br>&gt; &gt; order to keep returning nil.<br>&gt; <br>&gt; Are there realistic cases where this state and check would produce<br>&gt; measurable overhead?<br></p><p>I don&#39;t know, but at a bare minimum this is extra complexity on the implementation side.<br></p><p>&gt; Do you have an implementation somewhere I could look at?<br></p><p>No I don&#39;t. I didn&#39;t want to spend the time implementing this when I wasn&#39;t sure if the proposal would even be accepted.<br></p><p>&gt; &gt; My preferred solution for this case is to add a new Generator adaptor<br>&gt; &gt; called a FuseGenerator, with a convenience method .fuse(). All this<br>&gt; &gt; adaptor does is include the extra state in order to ensure it keeps<br>&gt; &gt; returning nil forever. This way Generators don&#39;t have to keep the state<br>&gt; &gt; for that guarantee, and the majority case where client codes doesn&#39;t<br>&gt; &gt; rely on this guarantee doesn&#39;t need the check either, and in the rare<br>&gt; &gt; case where this guarantee is important all the user has to do is call<br>&gt; &gt; .fuse() on the generator and use the result of that instead.<br>&gt; <br>&gt; Between the lack of predictability being addressed here and the addition<br>&gt; of a rarely-used additional component, that&#39;s a lot of complexity in the<br>&gt; library; is there a clear benefit?<br></p><p>The added complexity is just a single extra GeneratorType adaptor and corresponding method. But it reduces complexity elsewhere, as GeneratorType implementations no longer have to worry about their post-nil behavior (unless the type itself wishes to make specific guarantees about that). Many generators won&#39;t notice because they&#39;ll naturally hit a fixed point when they return nil (e.g. indexing generators won&#39;t increment their index at that point), but generator adaptors, or generators that represent some external source of data, won&#39;t have to keep around the extra state to track this anymore.<br></p><p>And on the caller side, my claim is that there are very few people who end up writing code that invokes post-nil behavior to begin with (I believe the most common way to hit this case is when writing your own GeneratorType, where you have to decide what your generator&#39;s post-nil behavior is). The callers who care about getting nil forever can just use the `.fuse()` adaptor, and leaving this as implementation-defined gives the flexibility of providing other behaviors. Not only is this more flexible for existing generators, but it may allow other generator-like types to adopt the GeneratorType protocol when they couldn&#39;t have easily done so otherwise (e.g. my previously-mentioned idea of a FIFO queue that explicitly doesn&#39;t want to return nil forever could adopt GeneratorType, but if generators must return nil forever then the FIFO queue can&#39;t adopt it, and the author may choose to not go through the effort of writing a separate generator on the off chance that someone wants to use the FIFO queue in a context that needs a generator).<br></p><p>&gt; &gt; All that said, I would be strongly in favor of dropping the language<br>&gt; &gt; about triggering a precondition failure. I&#39;d prefer to leave it as implementation-<br>&gt; &gt; defined behavior, which an encouragement to keep returning nil if it&#39;s<br>&gt; &gt; easy to do so. A benefit of this is Generators could opt to explicitly<br>&gt; &gt; define their post-nil behavior, e.g. TakeWhileGenerator could explicitly<br>&gt; &gt; document that after it has returned nil, subsequent calls to .next()<br>&gt; &gt; will continue to consume the underlying generator and return another<br>&gt; &gt; stream of elements terminating in `nil` (with the caveat that if the<br>&gt; &gt; underlying generator is exhausted then behavior depends on the<br>&gt; &gt; underlying generator&#39;s post-nil behavior). Granted, this probably isn&#39;t<br>&gt; &gt; useful in most cases, but it could be useful upon occasion as a way to<br>&gt; &gt; lazily split a sequence without building intermediate data structures<br>&gt; &gt; (assuming that the underlying generator is fused or defines its post-nil<br>&gt; &gt; behavior as returning nil forever).<br>&gt; <br>&gt; TakeWhileGenerator could also provide a method that returns the<br>&gt; TakeWhileGenerator for the next segment.  Since you have to know that<br>&gt; you&#39;ve got a TakeWhileGenerator to take advantage of this special<br>&gt; behavior, a different interface is just as useful and probably results<br>&gt; in clearer code.  <br></p><p>Clever, but it&#39;s still additional complexity. I rather like the fact that this described behavior just naturally occurs with the TakeWhileGenerator when implemented in the simplest way possible.<br></p><p>&gt; &gt; FWIW, Rust uses precisely the solution I&#39;ve described here (and in fact<br>&gt; &gt; I&#39;m responsible for its std::iter::Fuse iterator). It defines<br>&gt; &gt; Iterator::next() such that calling .next() after it has returned None<br>&gt; &gt; may or may not return more elements (but Iterators are not supposed to<br>&gt; &gt; assert in this case, they should always return something). And it has<br>&gt; &gt; the .fuse() convenience method that returns a std::iter::Fuse iterator<br>&gt; &gt; that provides the always-returns-None guarantee. And in practice, almost<br>&gt; &gt; nobody ever has to actually use .fuse(), since almost nobody writes<br>&gt; &gt; algorithms that cares about the behavior after next() returns None (and<br>&gt; &gt; in the rare case where they do, they&#39;re typically using some concrete<br>&gt; &gt; Iterator that has defined behavior, as opposed to working on arbitrary<br>&gt; &gt; Iterators).<br>&gt; <br>&gt; This is about balancing performance, flexibility, simplicity of<br>&gt; specification, and predictability.  Rust has a very C++-like approach to<br>&gt; zero-overhead abstractions, in the sense that it&#39;s willing to introduce<br>&gt; many small wrinkles to avoid even the theoretical possibility of a<br>&gt; performance penalty.  Having cut my language/library-design teeth in the<br>&gt; C++ world, I understand that approach really well, but I have also seen<br>&gt; it do some damage (some of which I was personally responsible for!) and<br>&gt; I want to be more conservative with Swift.  In short, I&#39;m still leaning<br>&gt; towards specifying post-nil behavior, and I&#39;d want to have more evidence of<br>&gt; the value of leaving it unspecified before doing so.<br></p><p>That&#39;s a fair point. But I think the important sentence from my comparison to Rust is &quot;And in practice, almost nobody ever has to actually use .fuse(), …&quot;. In my experience, very few people ever write code that invokes post-nil behavior, and so I don&#39;t like the fact that everyone has to pay for the cost involved in tracking the extra state needed for post-nil behavior.<br></p><p>-Kevin Ballard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Proposal] Change guarantee for GeneratorType.next() to always return nil past end</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>March  8, 2016 at 11:00:00am</p></header><div class="content"><p>On Sun, Mar 6, 2016 at 5:58 PM, Kevin Ballard via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; That&#39;s a fair point. But I think the important sentence from my comparison to Rust is &quot;And in practice, almost nobody ever has to actually use .fuse(), …&quot;.<br></p><p>The concern is that people who do need to invoke .fuse(), won&#39;t,<br>because all generators they are likely to try in practice will &#39;just<br>work&#39; and return a continuous stream of nils.<br></p><p>I think what this really comes down to is the trade off between a<br>subtle correctness issue and a small performance win for a small<br>number of data types (which can be even non-existent as Patrick<br>Pijnappel shows).  Given the general direction of Swift, I&#39;m inclined<br>to choose correctness here.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Proposal] Change guarantee for GeneratorType.next() to always return nil past end</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>March  8, 2016 at 12:00:00pm</p></header><div class="content"><p>On Tue, Mar 8, 2016, at 11:42 AM, Dmitri Gribenko wrote:<br>&gt; On Sun, Mar 6, 2016 at 5:58 PM, Kevin Ballard via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; That&#39;s a fair point. But I think the important sentence from my comparison to Rust is &quot;And in practice, almost nobody ever has to actually use .fuse(), …&quot;.<br>&gt; <br>&gt; The concern is that people who do need to invoke .fuse(), won&#39;t,<br>&gt; because all generators they are likely to try in practice will &#39;just<br>&gt; work&#39; and return a continuous stream of nils.<br>&gt; <br>&gt; I think what this really comes down to is the trade off between a<br>&gt; subtle correctness issue and a small performance win for a small<br>&gt; number of data types (which can be even non-existent as Patrick<br>&gt; Pijnappel shows).  Given the general direction of Swift, I&#39;m inclined<br>&gt; to choose correctness here.<br></p><p>Anyone who uses Generators directly has to understand their behavior and has to understand their requirements. The prohibition on not copying a Generator and invoking next() on both copies I think is actually more of a potential problem than handling post-nil behavior. In my personal experience, I&#39;ve accidentally violated the copy prohibition before, but I&#39;ve never even had to think about post-nil behavior except when implementing my own Generator. And allowing post-nil behavior to be implementation-defined is potentially useful behavior. In addition, even if the optimizer can get rid of the cost of tracking this state (and even with the limitation removed I don&#39;t think you can assume that will necessarily be the case, especially once you end up with an AnyGenerator wrapper in the mix), it&#39;s still extra burden on people implementing new Generators for something that very few clients are even going to care about. If we define post-nil behavior as needing to return nil forever, I suspect it&#39;s actually more likely for implementors of new Generators to screw up and not enforce this requirement than it is for clients to even notice it.<br></p><p>As a side note, I just tested (using Xcode 7.3 beta 5) and AnyGenerator doesn&#39;t currently track this state itself. You can easily pass a closure to AnyGenerator() that causes it to return non-nil values after a previous call to next() has returned nil. Trivial example:<br></p><p>var base = someSeq.generate()<br>return AnyGenerator {<br>    guard let next = base.next() else { return nil }<br>    return next % 3 == 0 ? nil : next * 2<br>}<br></p><p>With this example, if `someSeq` is `1..&lt;10`, the resulting elements from the generator are [2, 4, nil, 8, 10, nil, 14 , 16, nil, nil, ...]. And of course the whole point of AnyGenerator is to hide the implementation details from the caller, so if state is added to AnyGenerator to track this, it definitely won&#39;t get optimized away. And if the AnyGenerator is used to wrap an underlying generator, this state tracking is very likely to end up being redundantly performed in both AnyGenerator and the underlying generator.<br></p><p>-Kevin Ballard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Proposal] Change guarantee for GeneratorType.next() to always return nil past end</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>March  8, 2016 at 04:00:00pm</p></header><div class="content"><p>On Tue, Mar 8, 2016 at 12:16 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; On Tue, Mar 8, 2016, at 11:42 AM, Dmitri Gribenko wrote:<br>&gt;&gt; On Sun, Mar 6, 2016 at 5:58 PM, Kevin Ballard via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt; That&#39;s a fair point. But I think the important sentence from my comparison to Rust is &quot;And in practice, almost nobody ever has to actually use .fuse(), …&quot;.<br>&gt;&gt;<br>&gt;&gt; The concern is that people who do need to invoke .fuse(), won&#39;t,<br>&gt;&gt; because all generators they are likely to try in practice will &#39;just<br>&gt;&gt; work&#39; and return a continuous stream of nils.<br>&gt;&gt;<br>&gt;&gt; I think what this really comes down to is the trade off between a<br>&gt;&gt; subtle correctness issue and a small performance win for a small<br>&gt;&gt; number of data types (which can be even non-existent as Patrick<br>&gt;&gt; Pijnappel shows).  Given the general direction of Swift, I&#39;m inclined<br>&gt;&gt; to choose correctness here.<br>&gt;<br>&gt; Anyone who uses Generators directly has to understand their behavior and has to understand their requirements. The prohibition on not copying a Generator and invoking next() on both copies I think is actually more of a potential problem than handling post-nil behavior.<br></p><p>And that is another problem that we need to fix.  I don&#39;t think it is<br>acceptable to say that we won&#39;t fix one problem because there is<br>another anyway.<br></p><p>&gt; If we define post-nil behavior as needing to return nil forever, I suspect it&#39;s actually more likely for implementors of new Generators to screw up and not enforce this requirement than it is for clients to even notice it.<br></p><p>I disagree.  Most people just use the default IndexingGenerator.<br></p><p>&gt; As a side note, I just tested (using Xcode 7.3 beta 5) and AnyGenerator doesn&#39;t currently track this state itself. You can easily pass a closure to AnyGenerator() that causes it to return non-nil values after a previous call to next() has returned nil.<br></p><p>AnyGenerator is used to abstract away implementation details, but it<br>can&#39;t fix broken implementations.  Any time you conform to a protocol,<br>you are making a statement about semantics.  If the semantics are not<br>implemented correctly, then there are no guarantees about correctness<br>for things that build on top.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Proposal] Change guarantee for GeneratorType.next() to always return nil past end</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>March  8, 2016 at 04:00:00pm</p></header><div class="content"><p>On Tue, Mar 8, 2016, at 04:41 PM, Dmitri Gribenko wrote:<br>&gt; On Tue, Mar 8, 2016 at 12:16 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; &gt; On Tue, Mar 8, 2016, at 11:42 AM, Dmitri Gribenko wrote:<br>&gt; &gt;&gt; On Sun, Mar 6, 2016 at 5:58 PM, Kevin Ballard via swift-evolution<br>&gt; &gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt; &gt; That&#39;s a fair point. But I think the important sentence from my comparison to Rust is &quot;And in practice, almost nobody ever has to actually use .fuse(), …&quot;.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; The concern is that people who do need to invoke .fuse(), won&#39;t,<br>&gt; &gt;&gt; because all generators they are likely to try in practice will &#39;just<br>&gt; &gt;&gt; work&#39; and return a continuous stream of nils.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I think what this really comes down to is the trade off between a<br>&gt; &gt;&gt; subtle correctness issue and a small performance win for a small<br>&gt; &gt;&gt; number of data types (which can be even non-existent as Patrick<br>&gt; &gt;&gt; Pijnappel shows).  Given the general direction of Swift, I&#39;m inclined<br>&gt; &gt;&gt; to choose correctness here.<br>&gt; &gt;<br>&gt; &gt; Anyone who uses Generators directly has to understand their behavior and has to understand their requirements. The prohibition on not copying a Generator and invoking next() on both copies I think is actually more of a potential problem than handling post-nil behavior.<br>&gt; <br>&gt; And that is another problem that we need to fix.  I don&#39;t think it is<br>&gt; acceptable to say that we won&#39;t fix one problem because there is<br>&gt; another anyway.<br>&gt; <br>&gt; &gt; If we define post-nil behavior as needing to return nil forever, I suspect it&#39;s actually more likely for implementors of new Generators to screw up and not enforce this requirement than it is for clients to even notice it.<br>&gt; <br>&gt; I disagree.  Most people just use the default IndexingGenerator.<br></p><p>And most people never even try to invoke next() on a Generator after it&#39;s returned nil.<br></p><p>I have yet to see anyone actually offer any evidence to show that this is a real problem people are hitting.<br></p><p>&gt; &gt; As a side note, I just tested (using Xcode 7.3 beta 5) and AnyGenerator doesn&#39;t currently track this state itself. You can easily pass a closure to AnyGenerator() that causes it to return non-nil values after a previous call to next() has returned nil.<br>&gt; <br>&gt; AnyGenerator is used to abstract away implementation details, but it<br>&gt; can&#39;t fix broken implementations.  Any time you conform to a protocol,<br>&gt; you are making a statement about semantics.  If the semantics are not<br>&gt; implemented correctly, then there are no guarantees about correctness<br>&gt; for things that build on top.<br></p><p>The point was that it&#39;s pretty easy to accidentally violate the post-nil requirement using AnyGenerator. People writing new GeneratorType implementations should hopefully pay particular attention to the requirements, but people creating ad-hoc generators with AnyGenerator are more likely to not realize that what they&#39;ve written can violate the post-nil requirement. And in fact since most users of Generators don&#39;t even attempt to message a Generator after it&#39;s returned nil, they probably won&#39;t notice the problem, until such time as they happen to pass it to code that does make assumptions about the post-nil behavior of Generators.<br></p><p>Which is to say, if I&#39;m writing code that accepts arbitrary Generators and wants to be resilient, and if I want to be able to message a generator after it returns nil (and get nil again), I may end up using something like FuseGenerator anyway so that way my Generator works even when the input Generator was written sloppily.<br></p><p>Another way to put this is the prohibition against using copies of generators is something that clients are responsible for, but defining post-nil behavior as always returning nil is something that the GeneratorType implementation itself must handle. In fact, it&#39;s the only requirement not enforced by the type system that a GeneratorType implementation must conform to. And since most clients don&#39;t even invoke post-nil behavior, it&#39;s likely that people will violate this requirement without realizing it.<br></p><p>-Kevin Ballard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Proposal] Change guarantee for GeneratorType.next() to always return nil past end</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>March  8, 2016 at 05:00:00pm</p></header><div class="content"><p>On Tue, Mar 8, 2016 at 4:50 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; In fact, it&#39;s the only requirement not enforced by the type system that a GeneratorType implementation must conform to.<br></p><p>That&#39;s not true.  Once you start putting generators into a larger<br>context, you have:<br></p><p>- collection&#39;s generator should generate the same elements as<br>subscripting would produce;<br></p><p>- a generator for a sequence should produce at least<br>`underestimatedCount` elements;<br></p><p>- a generator for a sequence should produce the same elements as the<br>`forEach` method;<br></p><p>- lots and lots of similar high-level relationships.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Proposal] Change guarantee for GeneratorType.next() to always return nil past end</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>March  8, 2016 at 05:00:00pm</p></header><div class="content"><p>On Tue, Mar 8, 2016, at 05:03 PM, Dmitri Gribenko wrote:<br>&gt; On Tue, Mar 8, 2016 at 4:50 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; &gt; In fact, it&#39;s the only requirement not enforced by the type system that a GeneratorType implementation must conform to.<br>&gt; <br>&gt; That&#39;s not true.  Once you start putting generators into a larger<br>&gt; context, you have:<br>&gt; <br>&gt; - collection&#39;s generator should generate the same elements as<br>&gt; subscripting would produce;<br>&gt; <br>&gt; - a generator for a sequence should produce at least<br>&gt; `underestimatedCount` elements;<br>&gt; <br>&gt; - a generator for a sequence should produce the same elements as the<br>&gt; `forEach` method;<br>&gt; <br>&gt; - lots and lots of similar high-level relationships.<br></p><p>Those are requirements for collections/sequences, I was talking strictly about GeneratorType implementations. If you want to talk about sequences/collections, then we&#39;ve already bypassed the whole post-nil discussion because anyone working with sequences/collections instead of generators has already lost the ability to invoke next() after it has returned nil.<br></p><p>-Kevin Ballard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Proposal] Change guarantee for GeneratorType.next() to always return nil past end</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>March  8, 2016 at 06:00:00pm</p></header><div class="content"><p>One minor change to what I&#39;ve been proposing: Instead of merely saying that it&#39;s implementation-defined, we should expressly say that invoking next() after it has previously returned nil may return nil or it may return an implementation-defined value, but it should not fatalError() (unless some other GeneratorType requirement has been violated). Which is to say, after a GeneratorType has returned nil from next(), it should always be safe to invoke next() again, it&#39;s just up to the particular implementation to determine what value I get by doing that.<br></p><p>-Kevin Ballard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bce64da43e291f2ce30987a83780502c?s=50"></div><header><strong>[Proposal] Change guarantee for GeneratorType.next() to always return nil past end</strong> from <string>Patrick Pijnappel</string> &lt;patrickpijnappel at gmail.com&gt;<p>March 17, 2016 at 12:00:00am</p></header><div class="content"><p>Proposal: https://github.com/apple/swift-evolution/pull/213<br></p><p>On Wed, Mar 9, 2016 at 1:29 PM, Kevin Ballard via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; One minor change to what I&#39;ve been proposing: Instead of merely saying<br>&gt; that it&#39;s implementation-defined, we should expressly say that invoking<br>&gt; next() after it has previously returned nil may return nil or it may return<br>&gt; an implementation-defined value, but it should not fatalError() (unless<br>&gt; some other GeneratorType requirement has been violated). Which is to say,<br>&gt; after a GeneratorType has returned nil from next(), it should always be<br>&gt; safe to invoke next() again, it&#39;s just up to the particular implementation<br>&gt; to determine what value I get by doing that.<br>&gt;<br>&gt; -Kevin Ballard<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160317/e015c482/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal] Change guarantee for GeneratorType.next() to always return nil past end</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March 16, 2016 at 09:00:00am</p></header><div class="content"><p>On Mar 8, 2016, at 7:29 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; One minor change to what I&#39;ve been proposing: Instead of merely saying that it&#39;s implementation-defined, we should expressly say that invoking next() after it has previously returned nil may return nil or it may return an implementation-defined value, but it should not fatalError() (unless some other GeneratorType requirement has been violated). Which is to say, after a GeneratorType has returned nil from next(), it should always be safe to invoke next() again, it&#39;s just up to the particular implementation to determine what value I get by doing that.<br>&gt; <br>&gt; -Kevin Ballard<br></p><p>I&#39;m torn about sequences that end with nil and should continue always return nil thereafter and <br>(pulling a name out of the air) &quot;samples&quot; that may return nil or non-nil values over time. I&#39;d prefer there<br> to be two distinct contracts between an iterator and another construct that may return an implementation-defined<br>value after nil.<br></p><p>Otherwise, I&#39;m agreed that there should not be a precondition or fatal error (unless another<br>requirement was violated.)<br></p><p>-- Erica<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Change guarantee for GeneratorType.next() to always return nil past end</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March 16, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Mar 16, 2016, at 8:24 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Mar 8, 2016, at 7:29 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; One minor change to what I&#39;ve been proposing: Instead of merely saying that it&#39;s implementation-defined, we should expressly say that invoking next() after it has previously returned nil may return nil or it may return an implementation-defined value, but it should not fatalError() (unless some other GeneratorType requirement has been violated). Which is to say, after a GeneratorType has returned nil from next(), it should always be safe to invoke next() again, it&#39;s just up to the particular implementation to determine what value I get by doing that.<br>&gt;&gt; <br>&gt;&gt; -Kevin Ballard<br>&gt; <br>&gt; I&#39;m torn about sequences that end with nil and should continue always return nil thereafter and <br>&gt; (pulling a name out of the air) &quot;samples&quot; that may return nil or non-nil values over time. I&#39;d prefer there<br>&gt; to be two distinct contracts between an iterator and another construct that may return an implementation-defined<br>&gt; value after nil.<br></p><p>If your sequence produces optional values, then the result of its generator should be double-optional. If next() returns `.some(nil)`, that would be a nil value in the sequence; if it returns `nil`, that&#39;s the end.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal] Change guarantee for GeneratorType.next() to always return nil past end</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March 16, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Mar 16, 2016, at 10:41 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Mar 16, 2016, at 8:24 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Mar 8, 2016, at 7:29 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One minor change to what I&#39;ve been proposing: Instead of merely saying that it&#39;s implementation-defined, we should expressly say that invoking next() after it has previously returned nil may return nil or it may return an implementation-defined value, but it should not fatalError() (unless some other GeneratorType requirement has been violated). Which is to say, after a GeneratorType has returned nil from next(), it should always be safe to invoke next() again, it&#39;s just up to the particular implementation to determine what value I get by doing that.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt; <br>&gt;&gt; I&#39;m torn about sequences that end with nil and should continue always return nil thereafter and <br>&gt;&gt; (pulling a name out of the air) &quot;samples&quot; that may return nil or non-nil values over time. I&#39;d prefer there<br>&gt;&gt; to be two distinct contracts between an iterator and another construct that may return an implementation-defined<br>&gt;&gt; value after nil.<br>&gt; <br>&gt; If your sequence produces optional values, then the result of its generator should be double-optional. If next() returns `.some(nil)`, that would be a nil value in the sequence; if it returns `nil`, that&#39;s the end.<br>&gt; <br>&gt; -Joe<br></p><p>The use case I was thinking of was real-world sampling, where there was actually a value available or not. <br>Using double-optionals as a sequence would work for that. Since that approach might be intuitively<br>obvious, maybe should be clarified through documentation?<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160316/9da5e509/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Change guarantee for GeneratorType.next() to always return nil past end</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March 16, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Mar 16, 2016, at 9:59 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Mar 16, 2016, at 10:41 AM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Mar 16, 2016, at 8:24 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Mar 8, 2016, at 7:29 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One minor change to what I&#39;ve been proposing: Instead of merely saying that it&#39;s implementation-defined, we should expressly say that invoking next() after it has previously returned nil may return nil or it may return an implementation-defined value, but it should not fatalError() (unless some other GeneratorType requirement has been violated). Which is to say, after a GeneratorType has returned nil from next(), it should always be safe to invoke next() again, it&#39;s just up to the particular implementation to determine what value I get by doing that.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m torn about sequences that end with nil and should continue always return nil thereafter and <br>&gt;&gt;&gt; (pulling a name out of the air) &quot;samples&quot; that may return nil or non-nil values over time. I&#39;d prefer there<br>&gt;&gt;&gt; to be two distinct contracts between an iterator and another construct that may return an implementation-defined<br>&gt;&gt;&gt; value after nil.<br>&gt;&gt; <br>&gt;&gt; If your sequence produces optional values, then the result of its generator should be double-optional. If next() returns `.some(nil)`, that would be a nil value in the sequence; if it returns `nil`, that&#39;s the end.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt; <br>&gt; The use case I was thinking of was real-world sampling, where there was actually a value available or not. <br>&gt; Using double-optionals as a sequence would work for that. Since that approach might be intuitively<br>&gt; obvious, maybe should be clarified through documentation?<br></p><p>The sequence itself would have a singly-optional element type—it&#39;s only next() that adds optionality on top of that. For most use cases, next() is just an implementation detail.<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160316/1b98438d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal] Change guarantee for GeneratorType.next() to always return nil past end</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March 16, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Mar 16, 2016, at 12:05 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; One minor change to what I&#39;ve been proposing: Instead of merely saying that it&#39;s implementation-defined, we should expressly say that invoking next() after it has previously returned nil may return nil or it may return an implementation-defined value, but it should not fatalError() (unless some other GeneratorType requirement has been violated). Which is to say, after a GeneratorType has returned nil from next(), it should always be safe to invoke next() again, it&#39;s just up to the particular implementation to determine what value I get by doing that.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m torn about sequences that end with nil and should continue always return nil thereafter and <br>&gt;&gt;&gt;&gt; (pulling a name out of the air) &quot;samples&quot; that may return nil or non-nil values over time. I&#39;d prefer there<br>&gt;&gt;&gt;&gt; to be two distinct contracts between an iterator and another construct that may return an implementation-defined<br>&gt;&gt;&gt;&gt; value after nil.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If your sequence produces optional values, then the result of its generator should be double-optional. If next() returns `.some(nil)`, that would be a nil value in the sequence; if it returns `nil`, that&#39;s the end.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt; The use case I was thinking of was real-world sampling, where there was actually a value available or not. <br>&gt;&gt; Using double-optionals as a sequence would work for that. Since that approach might be intuitively<br>&gt;&gt; obvious, maybe should be clarified through documentation?<br>&gt; <br>&gt; The sequence itself would have a singly-optional element type—it&#39;s only next() that adds optionality on top of that. For most use cases, next() is just an implementation detail.<br>&gt; <br>&gt; -Joe<br></p><p>I meant, in the stdlib docs for GeneratorType / public mutating func next() -&gt; Self.Element?<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160316/19bfc187/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Proposal] Change guarantee for GeneratorType.next() to always return nil past end</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>March 17, 2016 at 12:00:00am</p></header><div class="content"><p>On Wed, Mar 16, 2016, at 09:59 AM, Erica Sadun wrote:<br>&gt;<br>&gt;&gt; On Mar 16, 2016, at 10:41 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Mar 16, 2016, at 8:24 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Mar 8, 2016, at 7:29 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; One minor change to what I&#39;ve been proposing: Instead of merely saying that it&#39;s implementation-defined, we should expressly say that invoking next() after it has previously returned nil may return nil or it may return an implementation-defined value, but it should not fatalError() (unless some other GeneratorType requirement has been violated). Which is to say, after a GeneratorType has returned nil from next(), it should always be safe to invoke next() again, it&#39;s just up to the particular implementation to determine what value I get by doing that.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;m torn about sequences that end with nil and should continue<br>&gt;&gt;&gt; always return nil thereafter and<br>&gt;&gt;&gt; (pulling a name out of the air) &quot;samples&quot; that may return nil or non-<br>&gt;&gt;&gt; nil values over time. I&#39;d prefer there<br>&gt;&gt;&gt; to be two distinct contracts between an iterator and another<br>&gt;&gt;&gt; construct that may return an implementation-defined<br>&gt;&gt;&gt; value after nil.<br>&gt;&gt;<br>&gt;&gt; If your sequence produces optional values, then the result of its<br>&gt;&gt; generator should be double-optional. If next() returns `.some(nil)`,<br>&gt;&gt; that would be a nil value in the sequence; if it returns `nil`,<br>&gt;&gt; that&#39;s the end.<br>&gt;&gt;<br>&gt;&gt; -Joe<br>&gt;<br>&gt; The use case I was thinking of was real-world sampling, where there<br>&gt; was actually a value available or not.<br>&gt; Using double-optionals as a sequence would work for that. Since that<br>&gt; approach might be intuitively<br>&gt; obvious, maybe should be clarified through documentation?<br> <br>Double-optionals makes this pattern useless. The whole point of using<br>the Generator pattern here is so you can easily process all of the currently-<br>available &quot;samples&quot; and then hit nil and stop, and then later when you<br>try again you may or may not get more values. Using a generator that<br>returns a double-optional value, the generator would never actually<br>return nil directly, it would always return a .Some (either .Some(nil)<br>or .Some(value)), and at this point there&#39;s no reason to be using a<br>Generator at all over just having a method that samples it.<br> <br>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160317/05c2027e/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
