<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/dd033b3ed46d65c7d7394eab52d53e6b?s=50"></div><header><strong>[Draft Proposal] A simplified notation for avoiding the weak/strong dance with closure capture lists</strong> from <string>Evan Maloney</string> &lt;emaloney at gilt.com&gt;<p>February  6, 2016 at 12:00:00am</p></header><div class="content"><p>Hello,<br></p><p>This draft proposal is a follow-up to the previous threads: &quot;Wanted: syntactic sugar for [weak self] callbacks&quot; and &quot;Allowing guard let self = self else { … } for weakly captured self in a closure.&quot;<br></p><p>A gist for this draft exists here &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440&gt;.<br></p><p>Comments welcome!<br></p><p>E.<br></p><p>---<br></p><p>Simplified notation for avoiding the [weak self]/strongSelf dance with closures<br></p><p>Proposal: TBD<br>Author: Evan Maloney &lt;https://github.com/emaloney&gt;<br>Status: Draft<br>Review manager: TBD<br> &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#introduction&gt;Introduction<br></p><p>Frequently, closures are used as completion callbacks for asynchronous operations, such as when dealing with network requests. It is quite common to model these sorts of operations in such a way that an object instance represents a request/response transaction, for example:<br></p><p>protocol NetworkTransaction: class<br>{<br>    enum Result {<br>        case Succeeded(NSData)<br>        case Failed(ErrorType)<br>    }<br></p><p>    func execute(completion: (Result) -&gt; Void)<br>}<br>Here, the NetworkTransaction protocol declares the interface by which an asynchronous transaction occurs. The user of a NetworkTransaction calls the execute() function, passing in a completion function that is called at some time in the future, when the transaction completes.<br></p><p>For example, imagine a hypothetical DataConsumer class that uses a transaction to try to fetch some network data and process it:<br></p><p>class DataConsumer<br>{<br>    let transaction: NetworkTransaction<br></p><p>    init(transaction: NetworkTransaction)<br>    {<br>        self.transaction = transaction<br>    }<br></p><p>    func fetchData()<br>    {<br>        transaction.execute() { [weak self] result in<br>            guard let strongSelf = self else { return }<br></p><p>            switch result {<br>            case .Succeeded(let data):<br>                strongSelf.processData(data)<br></p><p>            case .Failed(let err):<br>                strongSelf.handleError(err)<br>            }<br>        }<br>    }<br></p><p>    func processData(data: NSData) <br>    {<br>        // process the data<br>    }<br></p><p>    func handleError(error: ErrorType)<br>    {<br>        // handle the error<br>    }<br>}<br>You&#39;ll notice the [weak self]/strongSelf dance in the fetchData() function. This is a common pattern with asynchronously-executed closures, and it signals the possibility that a closure might outlive its usefulness.<br></p><p>Because the NetworkTransaction may complete at any time, it is possible that the closure will execute after the DataConsumer that initiated the transaction has been deallocated. Perhaps the user has navigated elsewhere in the application and whatever data was to be fetched by DataConsumer is no longer needed.<br></p><p>In this case, after a DataConsumer instance goes away, we don&#39;t really want the closure doing anything. So, we capture self weakly to ensure that the closure doesn&#39;t hold a reference to the owning DataConsumer. That prevents a reference cycle and ensures that DataConsumer can be deallocated when no longer in use.<br></p><p>When it comes time to execute the closure, the guard statement effectively asks the question, &quot;Is self still alive?&quot; If the answer is no, the guard forces a return and the rest of the closure does not execute.<br></p><p>If self is still alive, then the weakly-captured self will be non-nil and it will be converted into a strong reference held by strongSelf for the duration of the closure&#39;s execution.<br></p><p>When the closure is done executing, strongSelf goes away, once again making the DataConsumer eligible for deallocation when no other references are held.<br></p><p> &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#the-problem&gt;The Problem<br></p><p>The [weak self]/strongSelf dance requires common boilerplate wherever it is used, and the fact that a self-like variable with an arbitrary name adds noise within the closure. The more strongSelf is needed within the closure, the more noise there is.<br></p><p>Further, using a consistent name like strongSelf is by convention only; it can&#39;t be enforced by the compiler, so searching your codebase for a given keyword won&#39;t be exhaustive if team members use different names.<br></p><p> &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#proposed-solution&gt;Proposed Solution<br></p><p>The proposed solution adds a new capture type by repurposing the guard keyword for another use, which would look like:<br></p><p>transaction.execute() { [guard self] result in<br>    switch result {<br>    case .Succeeded(let data):<br>        self.processData(data)<br></p><p>    case .Failed(let err):<br>        self.handleError(err)<br>    }<br>}<br>Here, the [guard self] capture list serves as a signal that the compiler should handle the weak/strong dance itself. When encountering [guard self], the compiler should emit code that does the following:<br></p><p>Captures self in a weak reference on behalf of the closure<br>Whenever the closure is about to be executed, the weak reference is checked to see if self is still alive<br>If self is not alive, the closure returns immediately and nothing within the braces is executed<br>If self is alive, it is upgraded to a strong reference for the lifetime of the closure&#39;s execution. Within the closure, self is non-optional, unlike how it would be with a [weak self] capture. When the closure is done executing, the strong reference will be cleared and only the weak reference will be held on behalf of the closure.<br> &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#closures-with-return-values&gt;Closures with Return Values<br></p><p>For closures with a Void return type, the notation is simple, because no explicit value is expected as a result of executing the closure.<br></p><p>Closures with a return value will require an else clause:<br></p><p>let pollHappiness: () -&gt; Bool = { [guard self else false] in<br>    return self.isHealthy &amp;&amp; !self.isHungry &amp;&amp; !self.isFearful &amp;&amp; self.hasLove<br>}<br>Here, the else clause provides a value to return in cases where self has gone away and the guard fails.<br></p><p>In this example, if you call pollHappiness() after self has been deallocated, false will always be returned.<br></p><p> &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#capturing-other-references&gt;Capturing Other References<br></p><p>This notation is not limited to handling self. These capture lists are valid, too:<br></p><p>let capturingTwo = { [guard self, button] in<br>    // weakly capture self and button<br>    // but execute the closure with strong references<br>    // if and only if self and button still exist<br>    // when the closure is about to execute<br>}<br></p><p>let captureWithReturn: () -&gt; UIView = {<br>    [guard button, window = button!.window else nil] in ...<br></p><p>    // window is captured and stored weakly at the time the<br>    // closure declaration is encountered during execution;<br>    // button is guaranteed to be non-nil at that time, but<br>    // it may go away later, so we guard on button too<br>} <br> &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#caveats&gt;Caveats<br></p><p>This notation is not intended to be a full-fledged replacement for guard statements within the closure. We are only using guard here as a way to declare a specific memory-management behavior for references.<br></p><p>As a result, we are not attempting to support a where clause or boolean expressions within this notation. <br></p><p>Rather, we&#39;re simply adding a new capture behavior and providing a means to specify an early exit if the behavior couldn&#39;t be fulfilled because one or more of the required objects was deallocated before the closure was executed.<br></p><p> &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#impact-on-existing-code&gt;Impact on Existing Code<br></p><p>None, since this does not affect any existing constructs. Implementation of this proposal will not result in any code breakage.<br></p><p> &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#alternatives-considered&gt;Alternatives Considered<br></p><p> &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#status-quo&gt;Status Quo<br></p><p>The primary alternative is to do nothing, requiring developers to add boilerplate guard code and handle upgrading the weak-to-strong references manually.<br></p><p>As stated above, this leads to needless boilerplate that can easily be factored out by the compiler. Also, the use of a self-like variable with an arbitrary name makes it more difficult to exhaustively find such uses in large projects. With this proposal, searching for the text &quot;[guard&quot; is all that&#39;s necessary to find all instances of this memory management technique.<br></p><p>Finally, the need to declare and use alternate names to capture values that already have existing names adds visual clutter to code and serves to obscure the code&#39;s original intent, making it harder to reason about.<br></p><p> &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#alternate-notations&gt;Alternate Notations<br></p><p>The notation proposed above was chosen for concision. Two variations were considered, but rejected, because they add words to the statements without adding meaning.<br></p><p> &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#requiring-weak-after-guard&gt;Requiring weak after guard<br></p><p>This alternate notation used a weak keyword after the guard keyword in the capture list, eg. [guard weak self] instead of [guard self].<br></p><p>The use of the weak keyword did not modify behavior in any way, so it was removed from the proposal to be less verbose.<br></p><p> &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#requiring-return-after-else&gt;Requiring return after else<br></p><p>A longer notation requiring the return keyword for closures specifying return values was considered, but rejected, for similar reasons.<br></p><p>Such a notation would make [guard self else nil] look like [guard self else return nil].<br></p><p> &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#requiring-both&gt;Requiring both<br></p><p>If both keywords above were required, the verbiage would become quite unwieldy in the closure&#39;s capture list, which often appears on the same line after the opening parenthesis, which itself is often indented:<br></p><p>let toggleHappyButton: () -&gt; Bool? = { [guard weak self, button else return nil] in<br>    let state = button.highlighted<br>    button.highlighted = self.pollHappiness()<br>    return state<br>}<br>That seems longer than necessary.<br></p><p>For the reasons above, the two keywords above were not included in this proposal.<br></p><p> &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#citations&gt;Citations<br></p><p>Variations on this proposal were discussed earlier in the swift-evolution threads &quot;Wanted: syntactic sugar for [weak self] callbacks &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160201/008713.html&gt;&quot; and &quot;Allowing guard let self = self else { … } for weakly captured self in a closure. &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160201/009023.html&gt;&quot;.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160206/8a182715/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a32f0c9071fd24f75322395496dc6a32?s=50"></div><header><strong>[Draft Proposal] A simplified notation for avoiding the weak/strong dance with closure capture lists</strong> from <string>Eugene Gubin</string> &lt;hemet.mail at gmail.com&gt;<p>February  6, 2016 at 12:00:00pm</p></header><div class="content"><p>I liked this proposal until the capture list took another resposibility to<br>be a fast path for a closure :)<br>Is it such common situation when we want return value in any case without<br>ensuring lifetime of closure&#39; context? For me if closure depends on<br>anything which is deallocated, then result could not be computed so it is<br>&#39;nil&#39;. Caller side could decide what to do with that &#39;nil&#39;.<br></p><p>2016-02-06 8:17 GMT+03:00 Evan Maloney via swift-evolution &lt;<br>swift-evolution at swift.org&gt;:<br></p><p>&gt; Hello,<br>&gt;<br>&gt; This draft proposal is a follow-up to the previous threads: &quot;Wanted:<br>&gt; syntactic sugar for [weak self] callbacks&quot; and &quot;Allowing guard let self =<br>&gt; self else { … } for weakly captured self in a closure.&quot;<br>&gt;<br>&gt; A gist for this draft exists here<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440&gt;.<br>&gt;<br>&gt; Comments welcome!<br>&gt;<br>&gt; E.<br>&gt;<br>&gt; ---<br>&gt;<br>&gt; Simplified notation for avoiding the [weak self]/strongSelf dance with<br>&gt; closures<br>&gt;<br>&gt;    - Proposal: TBD<br>&gt;    - Author: Evan Maloney &lt;https://github.com/emaloney&gt;<br>&gt;    - Status: *Draft*<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; Frequently, closures are used as completion callbacks for asynchronous<br>&gt; operations, such as when dealing with network requests. It is quite common<br>&gt; to model these sorts of operations in such a way that an object instance<br>&gt; represents a request/response transaction, for example:<br>&gt;<br>&gt; protocol NetworkTransaction: class<br>&gt; {<br>&gt;     enum Result {<br>&gt;         case Succeeded(NSData)<br>&gt;         case Failed(ErrorType)<br>&gt;     }<br>&gt;<br>&gt;     func execute(completion: (Result) -&gt; Void)<br>&gt; }<br>&gt;<br>&gt; Here, the NetworkTransaction protocol declares the interface by which an<br>&gt; asynchronous transaction occurs. The user of a NetworkTransaction calls<br>&gt; the execute() function, passing in a completion function that is called<br>&gt; at some time in the future, when the transaction completes.<br>&gt;<br>&gt; For example, imagine a hypothetical DataConsumer class that uses a<br>&gt; transaction to try to fetch some network data and process it:<br>&gt;<br>&gt; class DataConsumer<br>&gt; {<br>&gt;     let transaction: NetworkTransaction<br>&gt;<br>&gt;     init(transaction: NetworkTransaction)<br>&gt;     {<br>&gt;         self.transaction = transaction<br>&gt;     }<br>&gt;<br>&gt;     func fetchData()<br>&gt;     {<br>&gt;         transaction.execute() { [weak self] result in<br>&gt;             guard let strongSelf = self else { return }<br>&gt;<br>&gt;             switch result {<br>&gt;             case .Succeeded(let data):<br>&gt;                 strongSelf.processData(data)<br>&gt;<br>&gt;             case .Failed(let err):<br>&gt;                 strongSelf.handleError(err)<br>&gt;             }<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt;     func processData(data: NSData)<br>&gt;     {<br>&gt;         // process the data<br>&gt;     }<br>&gt;<br>&gt;     func handleError(error: ErrorType)<br>&gt;     {<br>&gt;         // handle the error<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; You&#39;ll notice the [weak self]/strongSelf dance in the fetchData() function.<br>&gt; This is a common pattern with asynchronously-executed closures, and it<br>&gt; signals the possibility that a closure might outlive its usefulness.<br>&gt;<br>&gt; Because the NetworkTransaction may complete at any time, it is possible<br>&gt; that the closure will execute after the DataConsumer that initiated the<br>&gt; transaction has been deallocated. Perhaps the user has navigated elsewhere<br>&gt; in the application and whatever data was to be fetched by DataConsumer is<br>&gt; no longer needed.<br>&gt;<br>&gt; In this case, after a DataConsumer instance goes away, we don&#39;t really<br>&gt; want the closure doing anything. So, we capture self weakly to ensure<br>&gt; that the closure doesn&#39;t hold a reference to the owning DataConsumer.<br>&gt; That prevents a reference cycle and ensures that DataConsumer can be<br>&gt; deallocated when no longer in use.<br>&gt;<br>&gt; When it comes time to execute the closure, the guard statement<br>&gt; effectively asks the question, &quot;Is self still alive?&quot; If the answer is<br>&gt; no, the guard forces a return and the rest of the closure does not execute.<br>&gt;<br>&gt; If self *is* still alive, then the weakly-captured self will be non-nil and<br>&gt; it will be converted into a strong reference held by strongSelf for the<br>&gt; duration of the closure&#39;s execution.<br>&gt;<br>&gt; When the closure is done executing, strongSelf goes away, once again<br>&gt; making the DataConsumer eligible for deallocation when no other<br>&gt; references are held.<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#the-problem&gt;The<br>&gt; Problem<br>&gt;<br>&gt; The [weak self]/strongSelf dance requires common boilerplate wherever it<br>&gt; is used, and the fact that a self-like variable with an arbitrary name<br>&gt; adds noise within the closure. The more strongSelf is needed within the<br>&gt; closure, the more noise there is.<br>&gt;<br>&gt; Further, using a consistent name like strongSelf is by convention only;<br>&gt; it can&#39;t be enforced by the compiler, so searching your codebase for a<br>&gt; given keyword won&#39;t be exhaustive if team members use different names.<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#proposed-solution&gt;Proposed<br>&gt; Solution<br>&gt;<br>&gt; The proposed solution adds a new capture type by repurposing the guard keyword<br>&gt; for another use, which would look like:<br>&gt;<br>&gt; transaction.execute() { [guard self] result in<br>&gt;     switch result {<br>&gt;     case .Succeeded(let data):<br>&gt;         self.processData(data)<br>&gt;<br>&gt;     case .Failed(let err):<br>&gt;         self.handleError(err)<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; Here, the [guard self] capture list serves as a signal that the compiler<br>&gt; should handle the weak/strong dance itself. When encountering [guard self],<br>&gt; the compiler should emit code that does the following:<br>&gt;<br>&gt;    - Captures self in a weak reference on behalf of the closure<br>&gt;    - Whenever the closure is about to be executed, the weak reference is<br>&gt;    checked to see if self is still alive<br>&gt;       - If self is not alive, the closure returns immediately and nothing<br>&gt;       within the braces is executed<br>&gt;       - If self is alive, it is upgraded to a strong reference for the<br>&gt;       lifetime of the closure&#39;s execution. Within the closure, self is<br>&gt;       non-optional, unlike how it would be with a [weak self] capture.<br>&gt;       When the closure is done executing, the strong reference will be cleared<br>&gt;       and only the weak reference will be held on behalf of the closure.<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#closures-with-return-values&gt;Closures<br>&gt; with Return Values<br>&gt;<br>&gt; For closures with a Void return type, the notation is simple, because no<br>&gt; explicit value is expected as a result of executing the closure.<br>&gt;<br>&gt; Closures with a return value will require an else clause:<br>&gt;<br>&gt; let pollHappiness: () -&gt; Bool = { [guard self else false] in<br>&gt;     return self.isHealthy &amp;&amp; !self.isHungry &amp;&amp; !self.isFearful &amp;&amp; self.hasLove<br>&gt; }<br>&gt;<br>&gt; Here, the else clause provides a value to return in cases where self has<br>&gt; gone away and the guard fails.<br>&gt;<br>&gt; In this example, if you call pollHappiness() after self has been<br>&gt; deallocated, false will always be returned.<br>&gt;<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#capturing-other-references&gt;Capturing<br>&gt; Other References<br>&gt;<br>&gt; This notation is not limited to handling self. These capture lists are<br>&gt; valid, too:<br>&gt;<br>&gt; let capturingTwo = { [guard self, button] in<br>&gt;     // weakly capture self and button<br>&gt;     // but execute the closure with strong references<br>&gt;     // if and only if self and button still exist<br>&gt;     // when the closure is about to execute<br>&gt; }<br>&gt; let captureWithReturn: () -&gt; UIView = {<br>&gt;     [guard button, window = button!.window else nil] in ...<br>&gt;<br>&gt;     // window is captured and stored weakly at the time the<br>&gt;     // closure declaration is encountered during execution;<br>&gt;     // button is guaranteed to be non-nil at that time, but<br>&gt;     // it may go away later, so we guard on button too<br>&gt; }<br>&gt;<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#caveats&gt;Caveats<br>&gt;<br>&gt; This notation is not intended to be a full-fledged replacement for guard<br>&gt; statements within the closure. We are only using guard here as a way to<br>&gt; declare a specific memory-management behavior for references.<br>&gt;<br>&gt; As a result, we are not attempting to support a where clause or boolean<br>&gt; expressions within this notation.<br>&gt;<br>&gt; Rather, we&#39;re simply adding a new capture behavior and providing a means<br>&gt; to specify an early exit if the behavior couldn&#39;t be fulfilled because one<br>&gt; or more of the required objects was deallocated before the closure was<br>&gt; executed.<br>&gt;<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#impact-on-existing-code&gt;Impact<br>&gt; on Existing Code<br>&gt;<br>&gt; None, since this does not affect any existing constructs. Implementation<br>&gt; of this proposal will not result in any code breakage.<br>&gt;<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#alternatives-considered&gt;Alternatives<br>&gt; Considered<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#status-quo&gt;Status<br>&gt; Quo<br>&gt;<br>&gt; The primary alternative is to do nothing, requiring developers to add<br>&gt; boilerplate guard code and handle upgrading the weak-to-strong references<br>&gt; manually.<br>&gt;<br>&gt; As stated above, this leads to needless boilerplate that can easily be<br>&gt; factored out by the compiler. Also, the use of a self-like variable with<br>&gt; an arbitrary name makes it more difficult to exhaustively find such uses in<br>&gt; large projects. With this proposal, searching for the text &quot;[guard&quot; is<br>&gt; all that&#39;s necessary to find all instances of this memory management<br>&gt; technique.<br>&gt;<br>&gt; Finally, the need to declare and use alternate names to capture values<br>&gt; that already have existing names adds visual clutter to code and serves to<br>&gt; obscure the code&#39;s original intent, making it harder to reason about.<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#alternate-notations&gt;Alternate<br>&gt; Notations<br>&gt;<br>&gt; The notation proposed above was chosen for concision. Two variations were<br>&gt; considered, but rejected, because they add words to the statements without<br>&gt; adding meaning.<br>&gt;<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#requiring-weak-after-guard&gt;<br>&gt; Requiring weak after guard<br>&gt;<br>&gt; This alternate notation used a weak keyword after the guard keyword in<br>&gt; the capture list, eg. [guard weak self] instead of [guard self].<br>&gt;<br>&gt; The use of the weak keyword did not modify behavior in any way, so it was<br>&gt; removed from the proposal to be less verbose.<br>&gt;<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#requiring-return-after-else&gt;<br>&gt; Requiring return after else<br>&gt;<br>&gt; A longer notation requiring the return keyword for closures specifying<br>&gt; return values was considered, but rejected, for similar reasons.<br>&gt;<br>&gt; Such a notation would make [guard self else nil] look like [guard self<br>&gt; else return nil].<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#requiring-both&gt;Requiring<br>&gt; both<br>&gt;<br>&gt; If both keywords above were required, the verbiage would become quite<br>&gt; unwieldy in the closure&#39;s capture list, which often appears on the same<br>&gt; line after the opening parenthesis, which itself is often indented:<br>&gt;<br>&gt; let toggleHappyButton: () -&gt; Bool? = { [guard weak self, button else return nil] in<br>&gt;     let state = button.highlighted<br>&gt;     button.highlighted = self.pollHappiness()<br>&gt;     return state<br>&gt; }<br>&gt;<br>&gt; That seems longer than necessary.<br>&gt;<br>&gt; For the reasons above, the two keywords above were not included in this<br>&gt; proposal.<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#citations&gt;Citations<br>&gt; Variations on this proposal were discussed earlier in the swift-evolution<br>&gt; threads &quot;Wanted: syntactic sugar for [weak self] callbacks<br>&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160201/008713.html&gt;&quot;<br>&gt; and &quot;Allowing guard let self = self else { … } for weakly captured self<br>&gt; in a closure.<br>&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160201/009023.html&gt;<br>&gt; &quot;.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160206/72546c5f/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>[Draft Proposal] A simplified notation for avoiding the weak/strong dance with closure capture lists</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>February  6, 2016 at 11:00:00am</p></header><div class="content"><p>I much prefer being allowed to re-bind self with `if let self = self { … }` or `guard let self = self else { … }`. This would not introduce any new syntax, be useful in a much broader range of situations than the narrow use cases of `[guard self]`, `[guard self else …]` etc.<br></p><p>&gt; Le 6 févr. 2016 à 06:17, Evan Maloney via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Hello,<br>&gt; <br>&gt; This draft proposal is a follow-up to the previous threads: &quot;Wanted: syntactic sugar for [weak self] callbacks&quot; and &quot;Allowing guard let self = self else { … } for weakly captured self in a closure.&quot;<br>&gt; <br>&gt; A gist for this draft exists here &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440&gt;.<br>&gt; <br>&gt; Comments welcome!<br>&gt; <br>&gt; E.<br>&gt; <br>&gt; ---<br>&gt; <br>&gt; Simplified notation for avoiding the [weak self]/strongSelf dance with closures<br>&gt; <br>&gt; Proposal: TBD<br>&gt; Author: Evan Maloney &lt;https://github.com/emaloney&gt;<br>&gt; Status: Draft<br>&gt; Review manager: TBD<br>&gt;  &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#introduction&gt;Introduction<br>&gt; <br>&gt; Frequently, closures are used as completion callbacks for asynchronous operations, such as when dealing with network requests. It is quite common to model these sorts of operations in such a way that an object instance represents a request/response transaction, for example:<br>&gt; <br>&gt; protocol NetworkTransaction: class<br>&gt; {<br>&gt;     enum Result {<br>&gt;         case Succeeded(NSData)<br>&gt;         case Failed(ErrorType)<br>&gt;     }<br>&gt; <br>&gt;     func execute(completion: (Result) -&gt; Void)<br>&gt; }<br>&gt; Here, the NetworkTransaction protocol declares the interface by which an asynchronous transaction occurs. The user of a NetworkTransaction calls the execute() function, passing in a completion function that is called at some time in the future, when the transaction completes.<br>&gt; <br>&gt; For example, imagine a hypothetical DataConsumer class that uses a transaction to try to fetch some network data and process it:<br>&gt; <br>&gt; class DataConsumer<br>&gt; {<br>&gt;     let transaction: NetworkTransaction<br>&gt; <br>&gt;     init(transaction: NetworkTransaction)<br>&gt;     {<br>&gt;         self.transaction = transaction<br>&gt;     }<br>&gt; <br>&gt;     func fetchData()<br>&gt;     {<br>&gt;         transaction.execute() { [weak self] result in<br>&gt;             guard let strongSelf = self else { return }<br>&gt; <br>&gt;             switch result {<br>&gt;             case .Succeeded(let data):<br>&gt;                 strongSelf.processData(data)<br>&gt; <br>&gt;             case .Failed(let err):<br>&gt;                 strongSelf.handleError(err)<br>&gt;             }<br>&gt;         }<br>&gt;     }<br>&gt; <br>&gt;     func processData(data: NSData) <br>&gt;     {<br>&gt;         // process the data<br>&gt;     }<br>&gt; <br>&gt;     func handleError(error: ErrorType)<br>&gt;     {<br>&gt;         // handle the error<br>&gt;     }<br>&gt; }<br>&gt; You&#39;ll notice the [weak self]/strongSelf dance in the fetchData() function. This is a common pattern with asynchronously-executed closures, and it signals the possibility that a closure might outlive its usefulness.<br>&gt; <br>&gt; Because the NetworkTransaction may complete at any time, it is possible that the closure will execute after the DataConsumer that initiated the transaction has been deallocated. Perhaps the user has navigated elsewhere in the application and whatever data was to be fetched by DataConsumer is no longer needed.<br>&gt; <br>&gt; In this case, after a DataConsumer instance goes away, we don&#39;t really want the closure doing anything. So, we capture self weakly to ensure that the closure doesn&#39;t hold a reference to the owning DataConsumer. That prevents a reference cycle and ensures that DataConsumer can be deallocated when no longer in use.<br>&gt; <br>&gt; When it comes time to execute the closure, the guard statement effectively asks the question, &quot;Is self still alive?&quot; If the answer is no, the guard forces a return and the rest of the closure does not execute.<br>&gt; <br>&gt; If self is still alive, then the weakly-captured self will be non-nil and it will be converted into a strong reference held by strongSelf for the duration of the closure&#39;s execution.<br>&gt; <br>&gt; When the closure is done executing, strongSelf goes away, once again making the DataConsumer eligible for deallocation when no other references are held.<br>&gt; <br>&gt;  &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#the-problem&gt;The Problem<br>&gt; <br>&gt; The [weak self]/strongSelf dance requires common boilerplate wherever it is used, and the fact that a self-like variable with an arbitrary name adds noise within the closure. The more strongSelf is needed within the closure, the more noise there is.<br>&gt; <br>&gt; Further, using a consistent name like strongSelf is by convention only; it can&#39;t be enforced by the compiler, so searching your codebase for a given keyword won&#39;t be exhaustive if team members use different names.<br>&gt; <br>&gt;  &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#proposed-solution&gt;Proposed Solution<br>&gt; <br>&gt; The proposed solution adds a new capture type by repurposing the guard keyword for another use, which would look like:<br>&gt; <br>&gt; transaction.execute() { [guard self] result in<br>&gt;     switch result {<br>&gt;     case .Succeeded(let data):<br>&gt;         self.processData(data)<br>&gt; <br>&gt;     case .Failed(let err):<br>&gt;         self.handleError(err)<br>&gt;     }<br>&gt; }<br>&gt; Here, the [guard self] capture list serves as a signal that the compiler should handle the weak/strong dance itself. When encountering [guard self], the compiler should emit code that does the following:<br>&gt; <br>&gt; Captures self in a weak reference on behalf of the closure<br>&gt; Whenever the closure is about to be executed, the weak reference is checked to see if self is still alive<br>&gt; If self is not alive, the closure returns immediately and nothing within the braces is executed<br>&gt; If self is alive, it is upgraded to a strong reference for the lifetime of the closure&#39;s execution. Within the closure, self is non-optional, unlike how it would be with a [weak self] capture. When the closure is done executing, the strong reference will be cleared and only the weak reference will be held on behalf of the closure.<br>&gt;  &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#closures-with-return-values&gt;Closures with Return Values<br>&gt; <br>&gt; For closures with a Void return type, the notation is simple, because no explicit value is expected as a result of executing the closure.<br>&gt; <br>&gt; Closures with a return value will require an else clause:<br>&gt; <br>&gt; let pollHappiness: () -&gt; Bool = { [guard self else false] in<br>&gt;     return self.isHealthy &amp;&amp; !self.isHungry &amp;&amp; !self.isFearful &amp;&amp; self.hasLove<br>&gt; }<br>&gt; Here, the else clause provides a value to return in cases where self has gone away and the guard fails.<br>&gt; <br>&gt; In this example, if you call pollHappiness() after self has been deallocated, false will always be returned.<br>&gt; <br>&gt;  &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#capturing-other-references&gt;Capturing Other References<br>&gt; <br>&gt; This notation is not limited to handling self. These capture lists are valid, too:<br>&gt; <br>&gt; let capturingTwo = { [guard self, button] in<br>&gt;     // weakly capture self and button<br>&gt;     // but execute the closure with strong references<br>&gt;     // if and only if self and button still exist<br>&gt;     // when the closure is about to execute<br>&gt; }<br>&gt; <br>&gt; let captureWithReturn: () -&gt; UIView = {<br>&gt;     [guard button, window = button!.window else nil] in ...<br>&gt; <br>&gt;     // window is captured and stored weakly at the time the<br>&gt;     // closure declaration is encountered during execution;<br>&gt;     // button is guaranteed to be non-nil at that time, but<br>&gt;     // it may go away later, so we guard on button too<br>&gt; } <br>&gt;  &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#caveats&gt;Caveats<br>&gt; <br>&gt; This notation is not intended to be a full-fledged replacement for guard statements within the closure. We are only using guard here as a way to declare a specific memory-management behavior for references.<br>&gt; <br>&gt; As a result, we are not attempting to support a where clause or boolean expressions within this notation. <br>&gt; <br>&gt; Rather, we&#39;re simply adding a new capture behavior and providing a means to specify an early exit if the behavior couldn&#39;t be fulfilled because one or more of the required objects was deallocated before the closure was executed.<br>&gt; <br>&gt;  &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#impact-on-existing-code&gt;Impact on Existing Code<br>&gt; <br>&gt; None, since this does not affect any existing constructs. Implementation of this proposal will not result in any code breakage.<br>&gt; <br>&gt;  &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#alternatives-considered&gt;Alternatives Considered<br>&gt; <br>&gt;  &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#status-quo&gt;Status Quo<br>&gt; <br>&gt; The primary alternative is to do nothing, requiring developers to add boilerplate guard code and handle upgrading the weak-to-strong references manually.<br>&gt; <br>&gt; As stated above, this leads to needless boilerplate that can easily be factored out by the compiler. Also, the use of a self-like variable with an arbitrary name makes it more difficult to exhaustively find such uses in large projects. With this proposal, searching for the text &quot;[guard&quot; is all that&#39;s necessary to find all instances of this memory management technique.<br>&gt; <br>&gt; Finally, the need to declare and use alternate names to capture values that already have existing names adds visual clutter to code and serves to obscure the code&#39;s original intent, making it harder to reason about.<br>&gt; <br>&gt;  &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#alternate-notations&gt;Alternate Notations<br>&gt; <br>&gt; The notation proposed above was chosen for concision. Two variations were considered, but rejected, because they add words to the statements without adding meaning.<br>&gt; <br>&gt;  &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#requiring-weak-after-guard&gt;Requiring weak after guard<br>&gt; <br>&gt; This alternate notation used a weak keyword after the guard keyword in the capture list, eg. [guard weak self] instead of [guard self].<br>&gt; <br>&gt; The use of the weak keyword did not modify behavior in any way, so it was removed from the proposal to be less verbose.<br>&gt; <br>&gt;  &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#requiring-return-after-else&gt;Requiring return after else<br>&gt; <br>&gt; A longer notation requiring the return keyword for closures specifying return values was considered, but rejected, for similar reasons.<br>&gt; <br>&gt; Such a notation would make [guard self else nil] look like [guard self else return nil].<br>&gt; <br>&gt;  &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#requiring-both&gt;Requiring both<br>&gt; <br>&gt; If both keywords above were required, the verbiage would become quite unwieldy in the closure&#39;s capture list, which often appears on the same line after the opening parenthesis, which itself is often indented:<br>&gt; <br>&gt; let toggleHappyButton: () -&gt; Bool? = { [guard weak self, button else return nil] in<br>&gt;     let state = button.highlighted<br>&gt;     button.highlighted = self.pollHappiness()<br>&gt;     return state<br>&gt; }<br>&gt; That seems longer than necessary.<br>&gt; <br>&gt; For the reasons above, the two keywords above were not included in this proposal.<br>&gt; <br>&gt;  &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#citations&gt;Citations<br>&gt; <br>&gt; Variations on this proposal were discussed earlier in the swift-evolution threads &quot;Wanted: syntactic sugar for [weak self] callbacks &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160201/008713.html&gt;&quot; and &quot;Allowing guard let self = self else { … } for weakly captured self in a closure. &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160201/009023.html&gt;&quot;.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160206/2a73d8ed/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>[Draft Proposal] A simplified notation for avoiding the weak/strong dance with closure capture lists</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>February  6, 2016 at 12:00:00pm</p></header><div class="content"><p>I agree with Gwendal. The problem this proposal attempts to address is significant and important, but I don’t like the fact that the solution is even more situational syntax. Using an explicit guard statement is not that much more difficult, has clear semantics and is much more flexible (e.g. also in terms of return values). So yes, the best solution IMO would be if one could “redefine&quot; self in this particular context. Its still “magic”, but its quite reasonable magic. In that sense, the original suggestion by Hoon H. is what would get my vote. <br></p><p>In principle, a more general solution would be provided by closure contracts/preconditions. But that is what the guard statement does already, in essence, so why not use it?<br></p><p>— Taras<br></p><p>&gt; On 06 Feb 2016, at 11:48, Gwendal Roué via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I much prefer being allowed to re-bind self with `if let self = self { … }` or `guard let self = self else { … }`. This would not introduce any new syntax, be useful in a much broader range of situations than the narrow use cases of `[guard self]`, `[guard self else …]` etc.<br>&gt; <br>&gt;&gt; Le 6 févr. 2016 à 06:17, Evan Maloney via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; Hello,<br>&gt;&gt; <br>&gt;&gt; This draft proposal is a follow-up to the previous threads: &quot;Wanted: syntactic sugar for [weak self] callbacks&quot; and &quot;Allowing guard let self = self else { … } for weakly captured self in a closure.&quot;<br>&gt;&gt; <br>&gt;&gt; A gist for this draft exists here &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440&gt;.<br>&gt;&gt; <br>&gt;&gt; Comments welcome!<br>&gt;&gt; <br>&gt;&gt; E.<br>&gt;&gt; <br>&gt;&gt; ---<br>&gt;&gt; <br>&gt;&gt; Simplified notation for avoiding the [weak self]/strongSelf dance with closures<br>&gt;&gt; <br>&gt;&gt; Proposal: TBD<br>&gt;&gt; Author: Evan Maloney &lt;https://github.com/emaloney&gt;<br>&gt;&gt; Status: Draft<br>&gt;&gt; Review manager: TBD<br>&gt;&gt;  &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#introduction&gt;Introduction<br>&gt;&gt; <br>&gt;&gt; Frequently, closures are used as completion callbacks for asynchronous operations, such as when dealing with network requests. It is quite common to model these sorts of operations in such a way that an object instance represents a request/response transaction, for example:<br>&gt;&gt; <br>&gt;&gt; protocol NetworkTransaction: class<br>&gt;&gt; {<br>&gt;&gt;     enum Result {<br>&gt;&gt;         case Succeeded(NSData)<br>&gt;&gt;         case Failed(ErrorType)<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     func execute(completion: (Result) -&gt; Void)<br>&gt;&gt; }<br>&gt;&gt; Here, the NetworkTransaction protocol declares the interface by which an asynchronous transaction occurs. The user of a NetworkTransaction calls the execute() function, passing in a completion function that is called at some time in the future, when the transaction completes.<br>&gt;&gt; <br>&gt;&gt; For example, imagine a hypothetical DataConsumer class that uses a transaction to try to fetch some network data and process it:<br>&gt;&gt; <br>&gt;&gt; class DataConsumer<br>&gt;&gt; {<br>&gt;&gt;     let transaction: NetworkTransaction<br>&gt;&gt; <br>&gt;&gt;     init(transaction: NetworkTransaction)<br>&gt;&gt;     {<br>&gt;&gt;         self.transaction = transaction<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     func fetchData()<br>&gt;&gt;     {<br>&gt;&gt;         transaction.execute() { [weak self] result in<br>&gt;&gt;             guard let strongSelf = self else { return }<br>&gt;&gt; <br>&gt;&gt;             switch result {<br>&gt;&gt;             case .Succeeded(let data):<br>&gt;&gt;                 strongSelf.processData(data)<br>&gt;&gt; <br>&gt;&gt;             case .Failed(let err):<br>&gt;&gt;                 strongSelf.handleError(err)<br>&gt;&gt;             }<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     func processData(data: NSData) <br>&gt;&gt;     {<br>&gt;&gt;         // process the data<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     func handleError(error: ErrorType)<br>&gt;&gt;     {<br>&gt;&gt;         // handle the error<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; You&#39;ll notice the [weak self]/strongSelf dance in the fetchData() function. This is a common pattern with asynchronously-executed closures, and it signals the possibility that a closure might outlive its usefulness.<br>&gt;&gt; <br>&gt;&gt; Because the NetworkTransaction may complete at any time, it is possible that the closure will execute after the DataConsumer that initiated the transaction has been deallocated. Perhaps the user has navigated elsewhere in the application and whatever data was to be fetched by DataConsumer is no longer needed.<br>&gt;&gt; <br>&gt;&gt; In this case, after a DataConsumer instance goes away, we don&#39;t really want the closure doing anything. So, we capture self weakly to ensure that the closure doesn&#39;t hold a reference to the owning DataConsumer. That prevents a reference cycle and ensures that DataConsumer can be deallocated when no longer in use.<br>&gt;&gt; <br>&gt;&gt; When it comes time to execute the closure, the guard statement effectively asks the question, &quot;Is self still alive?&quot; If the answer is no, the guard forces a return and the rest of the closure does not execute.<br>&gt;&gt; <br>&gt;&gt; If self is still alive, then the weakly-captured self will be non-nil and it will be converted into a strong reference held by strongSelf for the duration of the closure&#39;s execution.<br>&gt;&gt; <br>&gt;&gt; When the closure is done executing, strongSelf goes away, once again making the DataConsumer eligible for deallocation when no other references are held.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#the-problem&gt;The Problem<br>&gt;&gt; <br>&gt;&gt; The [weak self]/strongSelf dance requires common boilerplate wherever it is used, and the fact that a self-like variable with an arbitrary name adds noise within the closure. The more strongSelf is needed within the closure, the more noise there is.<br>&gt;&gt; <br>&gt;&gt; Further, using a consistent name like strongSelf is by convention only; it can&#39;t be enforced by the compiler, so searching your codebase for a given keyword won&#39;t be exhaustive if team members use different names.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#proposed-solution&gt;Proposed Solution<br>&gt;&gt; <br>&gt;&gt; The proposed solution adds a new capture type by repurposing the guard keyword for another use, which would look like:<br>&gt;&gt; <br>&gt;&gt; transaction.execute() { [guard self] result in<br>&gt;&gt;     switch result {<br>&gt;&gt;     case .Succeeded(let data):<br>&gt;&gt;         self.processData(data)<br>&gt;&gt; <br>&gt;&gt;     case .Failed(let err):<br>&gt;&gt;         self.handleError(err)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; Here, the [guard self] capture list serves as a signal that the compiler should handle the weak/strong dance itself. When encountering [guard self], the compiler should emit code that does the following:<br>&gt;&gt; <br>&gt;&gt; Captures self in a weak reference on behalf of the closure<br>&gt;&gt; Whenever the closure is about to be executed, the weak reference is checked to see if self is still alive<br>&gt;&gt; If self is not alive, the closure returns immediately and nothing within the braces is executed<br>&gt;&gt; If self is alive, it is upgraded to a strong reference for the lifetime of the closure&#39;s execution. Within the closure, self is non-optional, unlike how it would be with a [weak self] capture. When the closure is done executing, the strong reference will be cleared and only the weak reference will be held on behalf of the closure.<br>&gt;&gt;  &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#closures-with-return-values&gt;Closures with Return Values<br>&gt;&gt; <br>&gt;&gt; For closures with a Void return type, the notation is simple, because no explicit value is expected as a result of executing the closure.<br>&gt;&gt; <br>&gt;&gt; Closures with a return value will require an else clause:<br>&gt;&gt; <br>&gt;&gt; let pollHappiness: () -&gt; Bool = { [guard self else false] in<br>&gt;&gt;     return self.isHealthy &amp;&amp; !self.isHungry &amp;&amp; !self.isFearful &amp;&amp; self.hasLove<br>&gt;&gt; }<br>&gt;&gt; Here, the else clause provides a value to return in cases where self has gone away and the guard fails.<br>&gt;&gt; <br>&gt;&gt; In this example, if you call pollHappiness() after self has been deallocated, false will always be returned.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#capturing-other-references&gt;Capturing Other References<br>&gt;&gt; <br>&gt;&gt; This notation is not limited to handling self. These capture lists are valid, too:<br>&gt;&gt; <br>&gt;&gt; let capturingTwo = { [guard self, button] in<br>&gt;&gt;     // weakly capture self and button<br>&gt;&gt;     // but execute the closure with strong references<br>&gt;&gt;     // if and only if self and button still exist<br>&gt;&gt;     // when the closure is about to execute<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let captureWithReturn: () -&gt; UIView = {<br>&gt;&gt;     [guard button, window = button!.window else nil] in ...<br>&gt;&gt; <br>&gt;&gt;     // window is captured and stored weakly at the time the<br>&gt;&gt;     // closure declaration is encountered during execution;<br>&gt;&gt;     // button is guaranteed to be non-nil at that time, but<br>&gt;&gt;     // it may go away later, so we guard on button too<br>&gt;&gt; } <br>&gt;&gt;  &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#caveats&gt;Caveats<br>&gt;&gt; <br>&gt;&gt; This notation is not intended to be a full-fledged replacement for guard statements within the closure. We are only using guard here as a way to declare a specific memory-management behavior for references.<br>&gt;&gt; <br>&gt;&gt; As a result, we are not attempting to support a where clause or boolean expressions within this notation. <br>&gt;&gt; <br>&gt;&gt; Rather, we&#39;re simply adding a new capture behavior and providing a means to specify an early exit if the behavior couldn&#39;t be fulfilled because one or more of the required objects was deallocated before the closure was executed.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#impact-on-existing-code&gt;Impact on Existing Code<br>&gt;&gt; <br>&gt;&gt; None, since this does not affect any existing constructs. Implementation of this proposal will not result in any code breakage.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#alternatives-considered&gt;Alternatives Considered<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#status-quo&gt;Status Quo<br>&gt;&gt; <br>&gt;&gt; The primary alternative is to do nothing, requiring developers to add boilerplate guard code and handle upgrading the weak-to-strong references manually.<br>&gt;&gt; <br>&gt;&gt; As stated above, this leads to needless boilerplate that can easily be factored out by the compiler. Also, the use of a self-like variable with an arbitrary name makes it more difficult to exhaustively find such uses in large projects. With this proposal, searching for the text &quot;[guard&quot; is all that&#39;s necessary to find all instances of this memory management technique.<br>&gt;&gt; <br>&gt;&gt; Finally, the need to declare and use alternate names to capture values that already have existing names adds visual clutter to code and serves to obscure the code&#39;s original intent, making it harder to reason about.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#alternate-notations&gt;Alternate Notations<br>&gt;&gt; <br>&gt;&gt; The notation proposed above was chosen for concision. Two variations were considered, but rejected, because they add words to the statements without adding meaning.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#requiring-weak-after-guard&gt;Requiring weak after guard<br>&gt;&gt; <br>&gt;&gt; This alternate notation used a weak keyword after the guard keyword in the capture list, eg. [guard weak self] instead of [guard self].<br>&gt;&gt; <br>&gt;&gt; The use of the weak keyword did not modify behavior in any way, so it was removed from the proposal to be less verbose.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#requiring-return-after-else&gt;Requiring return after else<br>&gt;&gt; <br>&gt;&gt; A longer notation requiring the return keyword for closures specifying return values was considered, but rejected, for similar reasons.<br>&gt;&gt; <br>&gt;&gt; Such a notation would make [guard self else nil] look like [guard self else return nil].<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#requiring-both&gt;Requiring both<br>&gt;&gt; <br>&gt;&gt; If both keywords above were required, the verbiage would become quite unwieldy in the closure&#39;s capture list, which often appears on the same line after the opening parenthesis, which itself is often indented:<br>&gt;&gt; <br>&gt;&gt; let toggleHappyButton: () -&gt; Bool? = { [guard weak self, button else return nil] in<br>&gt;&gt;     let state = button.highlighted<br>&gt;&gt;     button.highlighted = self.pollHappiness()<br>&gt;&gt;     return state<br>&gt;&gt; }<br>&gt;&gt; That seems longer than necessary.<br>&gt;&gt; <br>&gt;&gt; For the reasons above, the two keywords above were not included in this proposal.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#citations&gt;Citations<br>&gt;&gt; <br>&gt;&gt; Variations on this proposal were discussed earlier in the swift-evolution threads &quot;Wanted: syntactic sugar for [weak self] callbacks &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160201/008713.html&gt;&quot; and &quot;Allowing guard let self = self else { … } for weakly captured self in a closure. &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160201/009023.html&gt;&quot;.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160206/413ab94d/attachment-0001.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e01e37acbfad671da1b94a61cf819d82?s=50"></div><header><strong>[Draft Proposal] A simplified notation for avoiding the weak/strong dance with closure capture lists</strong> from <string>Kenny Leung</string> &lt;kenny_leung at pobox.com&gt;<p>February  7, 2016 at 11:00:00am</p></header><div class="content"><p>By the time you’ve written something like this:<br></p><p>[guard button, window = button!.window else nil]<br></p><p>your shortcut has turned into a longcut.<br></p><p>I would prefer something a lot simpler syntactically that would handle 80% of the cases. For the rest of the cases that don’t fit, it’s probably cleaner and more understandable to just write regular guard statements.<br></p><p>I propose <br></p><p>doit { [weak self, other]? in<br>    doing some stuff...<br>}<br></p><p>If any of the capture list evaluates to nil, the block is not executed. If the block signature has an optional return value, nil is returned. Anything else, you’re on your own.<br></p><p>-Kenny<br></p><p><br>&gt; On Feb 5, 2016, at 9:17 PM, Evan Maloney via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello,<br>&gt; <br>&gt; This draft proposal is a follow-up to the previous threads: &quot;Wanted: syntactic sugar for [weak self] callbacks&quot; and &quot;Allowing guard let self = self else { … } for weakly captured self in a closure.&quot;<br>&gt; <br>&gt; A gist for this draft exists here.<br>&gt; <br>&gt; Comments welcome!<br>&gt; <br>&gt; E.<br>&gt; <br>&gt; ---<br>&gt; <br>&gt; Simplified notation for avoiding the [weak self]/strongSelf dance with closures<br>&gt; <br>&gt; 	• Proposal: TBD<br>&gt; 	• Author: Evan Maloney<br>&gt; 	• Status: Draft<br>&gt; 	• Review manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; Frequently, closures are used as completion callbacks for asynchronous operations, such as when dealing with network requests. It is quite common to model these sorts of operations in such a way that an object instance represents a request/response transaction, for example:<br>&gt; <br>&gt; protocol NetworkTransaction: class<br>&gt; <br>&gt; {<br>&gt;     <br>&gt; enum<br>&gt;  Result {<br>&gt;         <br>&gt; case<br>&gt;  Succeeded(NSData)<br>&gt;         <br>&gt; case Failed(ErrorType<br>&gt; )<br>&gt;     }<br>&gt; <br>&gt;     <br>&gt; func execute(completion: (Result) -&gt; Void<br>&gt; )<br>&gt; }<br>&gt; <br>&gt; Here, the NetworkTransaction protocol declares the interface by which an asynchronous transaction occurs. The user of a NetworkTransaction calls the execute() function, passing in a completion function that is called at some time in the future, when the transaction completes.<br>&gt; <br>&gt; For example, imagine a hypothetical DataConsumer class that uses a transaction to try to fetch some network data and process it:<br>&gt; <br>&gt; class<br>&gt;  DataConsumer<br>&gt; {<br>&gt;     <br>&gt; let<br>&gt;  transaction: NetworkTransaction<br>&gt; <br>&gt;     <br>&gt; init<br>&gt; (transaction: NetworkTransaction)<br>&gt;     {<br>&gt;         <br>&gt; self.transaction =<br>&gt;  transaction<br>&gt;     }<br>&gt; <br>&gt;     <br>&gt; func fetchData<br>&gt; ()<br>&gt;     {<br>&gt;         transaction<br>&gt; .execute() { [weak self] result in<br>&gt; <br>&gt;             <br>&gt; guard let strongSelf = self else { return<br>&gt;  }<br>&gt; <br>&gt;             <br>&gt; switch<br>&gt;  result {<br>&gt;             <br>&gt; case .Succeeded(let<br>&gt;  data):<br>&gt;                 strongSelf<br>&gt; .<br>&gt; processData(data)<br>&gt; <br>&gt;             <br>&gt; case .Failed(let<br>&gt;  err):<br>&gt;                 strongSelf<br>&gt; .<br>&gt; handleError(err)<br>&gt;             }<br>&gt;         }<br>&gt;     }<br>&gt; <br>&gt;     <br>&gt; func processData<br>&gt; (data: NSData) <br>&gt;     {<br>&gt;         <br>&gt; // process the data<br>&gt; <br>&gt;     }<br>&gt; <br>&gt;     <br>&gt; func handleError(error: ErrorType<br>&gt; )<br>&gt;     {<br>&gt;         <br>&gt; // handle the error<br>&gt; <br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; You&#39;ll notice the [weak self]/strongSelf dance in the fetchData() function. This is a common pattern with asynchronously-executed closures, and it signals the possibility that a closure might outlive its usefulness.<br>&gt; <br>&gt; Because the NetworkTransaction may complete at any time, it is possible that the closure will execute after the DataConsumer that initiated the transaction has been deallocated. Perhaps the user has navigated elsewhere in the application and whatever data was to be fetched by DataConsumer is no longer needed.<br>&gt; <br>&gt; In this case, after a DataConsumer instance goes away, we don&#39;t really want the closure doing anything. So, we capture self weakly to ensure that the closure doesn&#39;t hold a reference to the owning DataConsumer. That prevents a reference cycle and ensures that DataConsumer can be deallocated when no longer in use.<br>&gt; <br>&gt; When it comes time to execute the closure, the guard statement effectively asks the question, &quot;Is self still alive?&quot; If the answer is no, the guard forces a return and the rest of the closure does not execute.<br>&gt; <br>&gt; If self is still alive, then the weakly-captured self will be non-nil and it will be converted into a strong reference held by strongSelf for the duration of the closure&#39;s execution.<br>&gt; <br>&gt; When the closure is done executing, strongSelf goes away, once again making the DataConsumer eligible for deallocation when no other references are held.<br>&gt; <br>&gt; The Problem<br>&gt; <br>&gt; The [weak self]/strongSelf dance requires common boilerplate wherever it is used, and the fact that a self-like variable with an arbitrary name adds noise within the closure. The more strongSelf is needed within the closure, the more noise there is.<br>&gt; <br>&gt; Further, using a consistent name like strongSelf is by convention only; it can&#39;t be enforced by the compiler, so searching your codebase for a given keyword won&#39;t be exhaustive if team members use different names.<br>&gt; <br>&gt; Proposed Solution<br>&gt; <br>&gt; The proposed solution adds a new capture type by repurposing the guard keyword for another use, which would look like:<br>&gt; <br>&gt; transaction.execute() { [guard self] result in<br>&gt; <br>&gt;     <br>&gt; switch<br>&gt;  result {<br>&gt;     <br>&gt; case .Succeeded(let<br>&gt;  data):<br>&gt;         <br>&gt; self.<br>&gt; processData(data)<br>&gt; <br>&gt;     <br>&gt; case .Failed(let<br>&gt;  err):<br>&gt;         <br>&gt; self.<br>&gt; handleError(err)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Here, the [guard self] capture list serves as a signal that the compiler should handle the weak/strong dance itself. When encountering [guard self], the compiler should emit code that does the following:<br>&gt; <br>&gt; 	• Captures self in a weak reference on behalf of the closure<br>&gt; 	• Whenever the closure is about to be executed, the weak reference is checked to see if self is still alive<br>&gt; 		• If self is not alive, the closure returns immediately and nothing within the braces is executed<br>&gt; 		• If self is alive, it is upgraded to a strong reference for the lifetime of the closure&#39;s execution. Within the closure, self is non-optional, unlike how it would be with a [weak self] capture. When the closure is done executing, the strong reference will be cleared and only the weak reference will be held on behalf of the closure.<br>&gt; Closures with Return Values<br>&gt; <br>&gt; For closures with a Void return type, the notation is simple, because no explicit value is expected as a result of executing the closure.<br>&gt; <br>&gt; Closures with a return value will require an else clause:<br>&gt; <br>&gt; let pollHappiness: () -&gt; Bool = { [guard self else false] in<br>&gt; <br>&gt;     <br>&gt; return self.isHealthy &amp;&amp; !self.isHungry &amp;&amp; !self.isFearful &amp;&amp; self.<br>&gt; hasLove<br>&gt; }<br>&gt; <br>&gt; Here, the else clause provides a value to return in cases where self has gone away and the guard fails.<br>&gt; <br>&gt; In this example, if you call pollHappiness() after self has been deallocated, false will always be returned.<br>&gt; <br>&gt; Capturing Other References<br>&gt; <br>&gt; This notation is not limited to handling self. These capture lists are valid, too:<br>&gt; <br>&gt; let capturingTwo = { [guard self, button] in<br>&gt; <br>&gt;     <br>&gt; // weakly capture self and button<br>&gt; <br>&gt;     <br>&gt; // but execute the closure with strong references<br>&gt; <br>&gt;     <br>&gt; // if and only if self and button still exist<br>&gt; <br>&gt;     <br>&gt; // when the closure is about to execute<br>&gt; <br>&gt; }<br>&gt; <br>&gt; <br>&gt; let captureWithReturn: () -&gt; UIView =<br>&gt;  {<br>&gt;     [<br>&gt; guard button, window = button!.window else nil] in ...<br>&gt; <br>&gt; <br>&gt;     <br>&gt; // window is captured and stored weakly at the time the<br>&gt; <br>&gt;     <br>&gt; // closure declaration is encountered during execution;<br>&gt; <br>&gt;     <br>&gt; // button is guaranteed to be non-nil at that time, but<br>&gt; <br>&gt;     <br>&gt; // it may go away later, so we guard on button too<br>&gt; <br>&gt; } <br>&gt; <br>&gt; Caveats<br>&gt; <br>&gt; This notation is not intended to be a full-fledged replacement for guard statements within the closure. We are only using guard here as a way to declare a specific memory-management behavior for references.<br>&gt; <br>&gt; As a result, we are not attempting to support a where clause or boolean expressions within this notation. <br>&gt; <br>&gt; Rather, we&#39;re simply adding a new capture behavior and providing a means to specify an early exit if the behavior couldn&#39;t be fulfilled because one or more of the required objects was deallocated before the closure was executed.<br>&gt; <br>&gt; Impact on Existing Code<br>&gt; <br>&gt; None, since this does not affect any existing constructs. Implementation of this proposal will not result in any code breakage.<br>&gt; <br>&gt; Alternatives Considered<br>&gt; <br>&gt; Status Quo<br>&gt; <br>&gt; The primary alternative is to do nothing, requiring developers to add boilerplate guard code and handle upgrading the weak-to-strong references manually.<br>&gt; <br>&gt; As stated above, this leads to needless boilerplate that can easily be factored out by the compiler. Also, the use of a self-like variable with an arbitrary name makes it more difficult to exhaustively find such uses in large projects. With this proposal, searching for the text &quot;[guard&quot; is all that&#39;s necessary to find all instances of this memory management technique.<br>&gt; <br>&gt; Finally, the need to declare and use alternate names to capture values that already have existing names adds visual clutter to code and serves to obscure the code&#39;s original intent, making it harder to reason about.<br>&gt; <br>&gt; Alternate Notations<br>&gt; <br>&gt; The notation proposed above was chosen for concision. Two variations were considered, but rejected, because they add words to the statements without adding meaning.<br>&gt; <br>&gt; Requiring weak after guard<br>&gt; <br>&gt; This alternate notation used a weak keyword after the guard keyword in the capture list, eg. [guard weak self] instead of [guard self].<br>&gt; <br>&gt; The use of the weak keyword did not modify behavior in any way, so it was removed from the proposal to be less verbose.<br>&gt; <br>&gt; Requiring return after else<br>&gt; <br>&gt; A longer notation requiring the return keyword for closures specifying return values was considered, but rejected, for similar reasons.<br>&gt; <br>&gt; Such a notation would make [guard self else nil] look like [guard self else return nil].<br>&gt; <br>&gt; Requiring both<br>&gt; <br>&gt; If both keywords above were required, the verbiage would become quite unwieldy in the closure&#39;s capture list, which often appears on the same line after the opening parenthesis, which itself is often indented:<br>&gt; <br>&gt; let toggleHappyButton: () -&gt; Bool? = { [guard weak self, button else return nil] in<br>&gt; <br>&gt;     <br>&gt; let state = button.<br>&gt; highlighted<br>&gt;     button<br>&gt; .highlighted = self.<br>&gt; pollHappiness()<br>&gt;     <br>&gt; return<br>&gt;  state<br>&gt; }<br>&gt; <br>&gt; That seems longer than necessary.<br>&gt; <br>&gt; For the reasons above, the two keywords above were not included in this proposal.<br>&gt; <br>&gt; Citations<br>&gt; <br>&gt; Variations on this proposal were discussed earlier in the swift-evolution threads &quot;Wanted: syntactic sugar for [weak self] callbacks&quot; and &quot;Allowing guard let self = self else { … } for weakly captured self in a closure.&quot;.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/27ca9066ad05bd8aa9ec366115f3cd38?s=50"></div><header><strong>[Draft Proposal] A simplified notation for avoiding the weak/strong dance with closure capture lists</strong> from <string>Kurt Werle</string> &lt;kurt at circlew.org&gt;<p>February  8, 2016 at 11:00:00am</p></header><div class="content"><p>On Sun, Feb 7, 2016 at 11:05 AM, Kenny Leung via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I propose<br>&gt;<br>&gt; doit { [weak self, other]? in<br>&gt;     doing some stuff...<br>&gt; }<br>&gt;<br>&gt; If any of the capture list evaluates to nil, the block is not executed. If<br>&gt; the block signature has an optional return value, nil is returned. Anything<br>&gt; else, you’re on your own.<br></p><p><br>On reflection, I have to say that I like this solution best.  It is very<br>similar in flavor to<br></p><p>maybeNilObject?.someMethod()<br></p><p>I might even argue that it should only be used for Void return types, just<br>like that method call becomes essentially void if the object is nil.<br></p><p>Kurt<br>-- <br>kurt at CircleW.org<br>http://www.CircleW.org/kurt/<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160208/471ad559/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
