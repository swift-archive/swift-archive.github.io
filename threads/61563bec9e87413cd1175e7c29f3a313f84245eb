<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/caa7226ca750e974668243476ffbafd5?s=50"></div><header><strong>Question about implementation of closure capture lists</strong> from <string>Greg Titus</string> &lt;greg at omnigroup.com&gt;<p>December  9, 2015 at 08:00:00am</p></header><div class="content"><p>Hi all,<br></p><p>I thought I’d take a look at SR-153 &quot;Bad fix suggestion for changing value of capture list constants&quot; &lt;https://bugs.swift.org/browse/SR-153&gt;, and I’d really appreciate it if someone more familiar with the code could check my thoughts, rather than me jumping straight to submitting a pull request that might be going in the wrong direction.<br></p><p>First, an entry in a capture list should always be semantically a constant, correct? Right now, the VarDecl ‘isLet’ flag is being set to ownershipKind != Ownership::Weak, which means that a capture of [a] is treated as constant by the type checker, but a capture of [weak a] is not. Thus, this code compiles without error (and prints “nil” and “A&quot; when run), which is certainly unexpected behavior to me:<br></p><p>class A {}<br>var a = A()<br>let f = {<br>    [weak a] in<br>    a = A()<br>    print(a)<br>}<br>f()<br>print(a)<br></p><p>I can imagine there being a good reason why a weak var shouldn’t be marked as isLet for optimization purposes, etc, since you can’t assume that it won’t change, but surely the programmer shouldn’t be explicitly using it as an lvalue, right?<br></p><p>I think the solution here is to add a VarDecl flag bit for InClosureCaptureList, set that when setting up the VarDecl in ParseExpr, and then return false from isSettable() (to fix the issue shown here), and early return from emitLetToVarNoteIfSimple() (to fix the original issue 153). These would be similar and in the same places as the existing isa&lt;ParamDecl&gt; checks.<br></p><p>Does all that sound okay?<br></p><p>Thanks!<br>	- Greg<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Question about implementation of closure capture lists</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December  9, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 9, 2015, at 8:57 AM, Greg Titus via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; I thought I’d take a look at SR-153 &quot;Bad fix suggestion for changing value of capture list constants&quot; &lt;https://bugs.swift.org/browse/SR-153&gt;, and I’d really appreciate it if someone more familiar with the code could check my thoughts, rather than me jumping straight to submitting a pull request that might be going in the wrong direction.<br>&gt; <br>&gt; First, an entry in a capture list should always be semantically a constant, correct? Right now, the VarDecl ‘isLet’ flag is being set to ownershipKind != Ownership::Weak, which means that a capture of [a] is treated as constant by the type checker, but a capture of [weak a] is not. Thus, this code compiles without error (and prints “nil” and “A&quot; when run), which is certainly unexpected behavior to me:<br>&gt; <br>&gt; class A {}<br>&gt; var a = A()<br>&gt; let f = {<br>&gt;    [weak a] in<br>&gt;    a = A()<br>&gt;    print(a)<br>&gt; }<br>&gt; f()<br>&gt; print(a)<br></p><p>Yes, this is not the right behavior.  We have to do this, because weak values can actually be mutated at runtime (by the pointee being deallocated, and thus dropping to nil).<br></p><p>The issue here is that (at a pretty deep level) the compiler has conflated two different concepts into the single “isLet” bit: 1) can be mutated at runtime, and 2) can be assigned to.  Two examples that violate this: &quot;lazy lets” and “weak lets”.  Both of these things can be mutated at the “bits” level, but neither can be assigned to within their current scope.<br></p><p>&gt; I can imagine there being a good reason why a weak var shouldn’t be marked as isLet for optimization purposes, etc, since you can’t assume that it won’t change, but surely the programmer shouldn’t be explicitly using it as an lvalue, right?<br></p><p>Right.<br></p><p>&gt; I think the solution here is to add a VarDecl flag bit for InClosureCaptureList, set that when setting up the VarDecl in ParseExpr, and then return false from isSettable() (to fix the issue shown here), and early return from emitLetToVarNoteIfSimple() (to fix the original issue 153). These would be similar and in the same places as the existing isa&lt;ParamDecl&gt; checks.<br></p><p>This isn’t specific to capture lists.  I’d rather see the isLet bit generalized in one of two ways.  Either:<br></p><p>1) Turn it into a three state enum, capturing the ideas of “var” and “let, but can change at runtime” and “let”.<br>2) Separate these two concepts into two bools.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/caa7226ca750e974668243476ffbafd5?s=50"></div><header><strong>Question about implementation of closure capture lists</strong> from <string>Greg Titus</string> &lt;greg at omnigroup.com&gt;<p>December  9, 2015 at 07:00:00pm</p></header><div class="content"><p>&gt; On Dec 9, 2015, at 2:39 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 9, 2015, at 8:57 AM, Greg Titus via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; I thought I’d take a look at SR-153 &quot;Bad fix suggestion for changing value of capture list constants&quot; &lt;https://bugs.swift.org/browse/SR-153&gt;, and I’d really appreciate it if someone more familiar with the code could check my thoughts, rather than me jumping straight to submitting a pull request that might be going in the wrong direction.<br>&gt;&gt; <br>&gt;&gt; First, an entry in a capture list should always be semantically a constant, correct? Right now, the VarDecl ‘isLet’ flag is being set to ownershipKind != Ownership::Weak, which means that a capture of [a] is treated as constant by the type checker, but a capture of [weak a] is not. Thus, this code compiles without error (and prints “nil” and “A&quot; when run), which is certainly unexpected behavior to me:<br>&gt;&gt; <br>&gt;&gt; class A {}<br>&gt;&gt; var a = A()<br>&gt;&gt; let f = {<br>&gt;&gt;   [weak a] in<br>&gt;&gt;   a = A()<br>&gt;&gt;   print(a)<br>&gt;&gt; }<br>&gt;&gt; f()<br>&gt;&gt; print(a)<br>&gt; <br>&gt; Yes, this is not the right behavior.  We have to do this, because weak values can actually be mutated at runtime (by the pointee being deallocated, and thus dropping to nil).<br>&gt; <br>&gt; The issue here is that (at a pretty deep level) the compiler has conflated two different concepts into the single “isLet” bit: 1) can be mutated at runtime, and 2) can be assigned to.  Two examples that violate this: &quot;lazy lets” and “weak lets”.  Both of these things can be mutated at the “bits” level, but neither can be assigned to within their current scope.<br></p><p>Is there a way that I’m not seeing to get these sorts of constructs right now, or are these constructs planned? Both “lazy&quot; and “weak” yield compiler errors if they are used with “let” instead of “var” at the moment. <br></p><p>&gt;&gt; I can imagine there being a good reason why a weak var shouldn’t be marked as isLet for optimization purposes, etc, since you can’t assume that it won’t change, but surely the programmer shouldn’t be explicitly using it as an lvalue, right?<br>&gt; <br>&gt; Right.<br>&gt; <br>&gt;&gt; I think the solution here is to add a VarDecl flag bit for InClosureCaptureList, set that when setting up the VarDecl in ParseExpr, and then return false from isSettable() (to fix the issue shown here), and early return from emitLetToVarNoteIfSimple() (to fix the original issue 153). These would be similar and in the same places as the existing isa&lt;ParamDecl&gt; checks.<br>&gt; <br>&gt; This isn’t specific to capture lists.  I’d rather see the isLet bit generalized in one of two ways.  Either:<br>&gt; <br>&gt; 1) Turn it into a three state enum, capturing the ideas of “var” and “let, but can change at runtime” and “let”.<br>&gt; 2) Separate these two concepts into two bools.<br>&gt; <br></p><p>Makes sense. I’ve gone with what I think is the lowest impact change for now, which is to add a second bool named “IsUserAssignable&quot;:<br></p><p>“var&quot;: IsLet = false, IsUserAssignable = true<br>&quot;let but can change at runtime” i.e. mutable but not by the programmer: IsLet = false, IsUserAssignable = false<br>“let&quot;: IsLet = true, IsUserAssignable = true (since the user can assign to it exactly once)<br></p><p>Submitted as &lt;https://github.com/apple/swift/pull/386&gt;. <br></p><p>Thanks for the input!<br>	- Greg<br></p><p>&gt; -Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20151209/1298da97/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
