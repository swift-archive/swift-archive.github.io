<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8def0d36f56d3e6720a44e41bf6f9a71?s=50"></div><header><strong>Pitch: Soft unwrapping of optionals</strong> from <string>Basem Emara</string> &lt;contact at basememara.com&gt;<p>May 11, 2016 at 08:00:00am</p></header><div class="content"><p>Forcing unwrapping of optionals is bad practice, but safely unwrapping can be tedious. I’m hoping for something in between that would that would provide soft unwrapping using a syntax like: myVar?!<br></p><p>For example, currently we have to do this:<br></p><p>let temp = (myString ?? “”); print(“\(temp)”)<br>if (myString ?? “”).isEmpty {…}<br>if myBool ?? false {…}<br>if (myInt ?? 0) &gt; otherInt {…}<br></p><p>To something like this instead:<br></p><p>print(“\(temp?!)”)<br>if myString?!.isEmpty {…}<br>if myBool?! {…}<br>if myInt?! &gt; otherInt {…}<br></p><p>What this is implying is that it will attempt to unwrap or use the default of the type.<br></p><p>Of course, this will only work with primitive types and leverage their implicit default values which would go a long way with tedious code and more safety (less forced unwrapping in the world). Otherwise it will produce a compile error if doing something like: myCustomType?!. What do you think?<br></p><p>Basem<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>Pitch: Soft unwrapping of optionals</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May 11, 2016 at 10:00:00pm</p></header><div class="content"><p>I actually think this is less safe. It depends on the situation for what value the default should be. Sometimes it will be false, other times it will be true. So far better to explicitly show what the default is.<br></p><p><br>&gt; On 11 May 2016, at 10:16 PM, Basem Emara via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Forcing unwrapping of optionals is bad practice, but safely unwrapping can be tedious. I’m hoping for something in between that would that would provide soft unwrapping using a syntax like: myVar?!<br>&gt; <br>&gt; For example, currently we have to do this:<br>&gt; <br>&gt; let temp = (myString ?? “”); print(“\(temp)”)<br>&gt; if (myString ?? “”).isEmpty {…}<br>&gt; if myBool ?? false {…}<br>&gt; if (myInt ?? 0) &gt; otherInt {…}<br>&gt; <br>&gt; To something like this instead:<br>&gt; <br>&gt; print(“\(temp?!)”)<br>&gt; if myString?!.isEmpty {…}<br>&gt; if myBool?! {…}<br>&gt; if myInt?! &gt; otherInt {…}<br>&gt; <br>&gt; What this is implying is that it will attempt to unwrap or use the default of the type.<br>&gt; <br>&gt; Of course, this will only work with primitive types and leverage their implicit default values which would go a long way with tedious code and more safety (less forced unwrapping in the world). Otherwise it will produce a compile error if doing something like: myCustomType?!. What do you think?<br>&gt; <br>&gt; Basem<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8def0d36f56d3e6720a44e41bf6f9a71?s=50"></div><header><strong>Pitch: Soft unwrapping of optionals</strong> from <string>Basem Emara</string> &lt;contact at basememara.com&gt;<p>May 11, 2016 at 08:00:00am</p></header><div class="content"><p>Maybe I’m missing something, but aren’t these the default values of primitives deep in the language?<br>String = “”<br>Int = 0<br>Boolean = false<br></p><p>So if you needed a different default value for your code, you’d do:<br>if !myBool?! {…} //Default to true in my app<br></p><p>You can still do which is better:<br>if myBool ?? true {…}<br></p><p>Probably booleans is not a clear gain, but for strings it would have vast conveniences.<br></p><p>&gt; On May 11, 2016, at 8:20 AM, Patrick Smith &lt;pgwsmith at gmail.com&gt; wrote:<br>&gt; <br>&gt; I actually think this is less safe. It depends on the situation for what value the default should be. Sometimes it will be false, other times it will be true. So far better to explicitly show what the default is.<br>&gt; <br>&gt; <br>&gt;&gt; On 11 May 2016, at 10:16 PM, Basem Emara via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Forcing unwrapping of optionals is bad practice, but safely unwrapping can be tedious. I’m hoping for something in between that would that would provide soft unwrapping using a syntax like: myVar?!<br>&gt;&gt; <br>&gt;&gt; For example, currently we have to do this:<br>&gt;&gt; <br>&gt;&gt; let temp = (myString ?? “”); print(“\(temp)”)<br>&gt;&gt; if (myString ?? “”).isEmpty {…}<br>&gt;&gt; if myBool ?? false {…}<br>&gt;&gt; if (myInt ?? 0) &gt; otherInt {…}<br>&gt;&gt; <br>&gt;&gt; To something like this instead:<br>&gt;&gt; <br>&gt;&gt; print(“\(temp?!)”)<br>&gt;&gt; if myString?!.isEmpty {…}<br>&gt;&gt; if myBool?! {…}<br>&gt;&gt; if myInt?! &gt; otherInt {…}<br>&gt;&gt; <br>&gt;&gt; What this is implying is that it will attempt to unwrap or use the default of the type.<br>&gt;&gt; <br>&gt;&gt; Of course, this will only work with primitive types and leverage their implicit default values which would go a long way with tedious code and more safety (less forced unwrapping in the world). Otherwise it will produce a compile error if doing something like: myCustomType?!. What do you think?<br>&gt;&gt; <br>&gt;&gt; Basem<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>Pitch: Soft unwrapping of optionals</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>May 11, 2016 at 11:00:00pm</p></header><div class="content"><p>I think what you’re referring to as default values would be what you get if you initialize the type directly.<br></p><p>eg:<br>let integer = Int()       // integer = 0<br>let string	 = String() // string = “”<br>let bool 	 = Bool() 	 // bool = false<br></p><p>That said, I’m going to -1 this proposal as well.<br></p><p>The issue I see here is that the proposal conflates a reasonable initialization value with a “go-to default”, which is part of what Swift very deliberately did away with from Objective-C.<br></p><p>Optional should not imply any internal value to the type. It’s the nature of them to be an internal unknown value, or nil, that must be unwrapped deliberately for the protection of your code’s logic. This seems to me to be a slippery slope to the very thing optionals are trying to avoid: default values based on the “zero / bool” conflation.<br></p><p>Additionally, what would that pattern mean for types that cannot be initialised without parameters? If your proposal cannot support anything well beyond the most primitive types, I suspect it doesn’t scale well and shouldn’t come into the language.<br></p><p>If you wish to use defaulting values, it’s best that you specify them instead of hoping the language specifies the one that you assume it will. Do this with the nil coalescing operator (??):<br></p><p>print(temp ?? “”)<br>if myString?.isEmpty ?? true {…}<br>if myBool ?? false {…}<br>if (myInt ?? 0) &gt; otherInt {…}<br></p><p>This is only slightly more code, but it removes all your assumptions, and means you are now the specifier in your code’s logic. You can see from the code exactly what nil will do, and what effect it had on your code.<br></p><p>- Rod<br></p><p><br></p><p>&gt; On 11 May 2016, at 10:26 PM, Basem Emara via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Maybe I’m missing something, but aren’t these the default values of primitives deep in the language?<br>&gt; String = “”<br>&gt; Int = 0<br>&gt; Boolean = false<br>&gt; <br>&gt; So if you needed a different default value for your code, you’d do:<br>&gt; if !myBool?! {…} //Default to true in my app<br>&gt; <br>&gt; You can still do which is better:<br>&gt; if myBool ?? true {…}<br>&gt; <br>&gt; Probably booleans is not a clear gain, but for strings it would have vast conveniences.<br>&gt; <br>&gt;&gt; On May 11, 2016, at 8:20 AM, Patrick Smith &lt;pgwsmith at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I actually think this is less safe. It depends on the situation for what value the default should be. Sometimes it will be false, other times it will be true. So far better to explicitly show what the default is.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 11 May 2016, at 10:16 PM, Basem Emara via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Forcing unwrapping of optionals is bad practice, but safely unwrapping can be tedious. I’m hoping for something in between that would that would provide soft unwrapping using a syntax like: myVar?!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For example, currently we have to do this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let temp = (myString ?? “”); print(“\(temp)”)<br>&gt;&gt;&gt; if (myString ?? “”).isEmpty {…}<br>&gt;&gt;&gt; if myBool ?? false {…}<br>&gt;&gt;&gt; if (myInt ?? 0) &gt; otherInt {…}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To something like this instead:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; print(“\(temp?!)”)<br>&gt;&gt;&gt; if myString?!.isEmpty {…}<br>&gt;&gt;&gt; if myBool?! {…}<br>&gt;&gt;&gt; if myInt?! &gt; otherInt {…}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What this is implying is that it will attempt to unwrap or use the default of the type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Of course, this will only work with primitive types and leverage their implicit default values which would go a long way with tedious code and more safety (less forced unwrapping in the world). Otherwise it will produce a compile error if doing something like: myCustomType?!. What do you think?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Basem<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8def0d36f56d3e6720a44e41bf6f9a71?s=50"></div><header><strong>Pitch: Soft unwrapping of optionals</strong> from <string>Basem Emara</string> &lt;contact at basememara.com&gt;<p>May 11, 2016 at 09:00:00am</p></header><div class="content"><p>Thanks for the input everybody, and for the deeper analysis, Rod.<br></p><p>It’s set straight in my mind now and have even a greater appreciation of optionals than before thanks to this discussion. Let’s scrape this pitch :)<br></p><p>Happy coding! -Basem<br></p><p>&gt; On May 11, 2016, at 9:10 AM, Rod Brown &lt;rodney.brown6 at icloud.com&gt; wrote:<br>&gt; <br>&gt; I think what you’re referring to as default values would be what you get if you initialize the type directly.<br>&gt; <br>&gt; eg:<br>&gt; let integer = Int()       // integer = 0<br>&gt; let string	 = String() // string = “”<br>&gt; let bool 	 = Bool() 	 // bool = false<br>&gt; <br>&gt; That said, I’m going to -1 this proposal as well.<br>&gt; <br>&gt; The issue I see here is that the proposal conflates a reasonable initialization value with a “go-to default”, which is part of what Swift very deliberately did away with from Objective-C.<br>&gt; <br>&gt; Optional should not imply any internal value to the type. It’s the nature of them to be an internal unknown value, or nil, that must be unwrapped deliberately for the protection of your code’s logic. This seems to me to be a slippery slope to the very thing optionals are trying to avoid: default values based on the “zero / bool” conflation.<br>&gt; <br>&gt; Additionally, what would that pattern mean for types that cannot be initialised without parameters? If your proposal cannot support anything well beyond the most primitive types, I suspect it doesn’t scale well and shouldn’t come into the language.<br>&gt; <br>&gt; If you wish to use defaulting values, it’s best that you specify them instead of hoping the language specifies the one that you assume it will. Do this with the nil coalescing operator (??):<br>&gt; <br>&gt; print(temp ?? “”)<br>&gt; if myString?.isEmpty ?? true {…}<br>&gt; if myBool ?? false {…}<br>&gt; if (myInt ?? 0) &gt; otherInt {…}<br>&gt; <br>&gt; This is only slightly more code, but it removes all your assumptions, and means you are now the specifier in your code’s logic. You can see from the code exactly what nil will do, and what effect it had on your code.<br>&gt; <br>&gt; - Rod<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On 11 May 2016, at 10:26 PM, Basem Emara via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Maybe I’m missing something, but aren’t these the default values of primitives deep in the language?<br>&gt;&gt; String = “”<br>&gt;&gt; Int = 0<br>&gt;&gt; Boolean = false<br>&gt;&gt; <br>&gt;&gt; So if you needed a different default value for your code, you’d do:<br>&gt;&gt; if !myBool?! {…} //Default to true in my app<br>&gt;&gt; <br>&gt;&gt; You can still do which is better:<br>&gt;&gt; if myBool ?? true {…}<br>&gt;&gt; <br>&gt;&gt; Probably booleans is not a clear gain, but for strings it would have vast conveniences.<br>&gt;&gt; <br>&gt;&gt;&gt; On May 11, 2016, at 8:20 AM, Patrick Smith &lt;pgwsmith at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I actually think this is less safe. It depends on the situation for what value the default should be. Sometimes it will be false, other times it will be true. So far better to explicitly show what the default is.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 11 May 2016, at 10:16 PM, Basem Emara via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Forcing unwrapping of optionals is bad practice, but safely unwrapping can be tedious. I’m hoping for something in between that would that would provide soft unwrapping using a syntax like: myVar?!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For example, currently we have to do this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let temp = (myString ?? “”); print(“\(temp)”)<br>&gt;&gt;&gt;&gt; if (myString ?? “”).isEmpty {…}<br>&gt;&gt;&gt;&gt; if myBool ?? false {…}<br>&gt;&gt;&gt;&gt; if (myInt ?? 0) &gt; otherInt {…}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; To something like this instead:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; print(“\(temp?!)”)<br>&gt;&gt;&gt;&gt; if myString?!.isEmpty {…}<br>&gt;&gt;&gt;&gt; if myBool?! {…}<br>&gt;&gt;&gt;&gt; if myInt?! &gt; otherInt {…}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What this is implying is that it will attempt to unwrap or use the default of the type.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Of course, this will only work with primitive types and leverage their implicit default values which would go a long way with tedious code and more safety (less forced unwrapping in the world). Otherwise it will produce a compile error if doing something like: myCustomType?!. What do you think?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Basem<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>Pitch: Soft unwrapping of optionals</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May 11, 2016 at 11:00:00pm</p></header><div class="content"><p>Ha great stuff Basem! Glad we could help :) Look forward to your next proposal!<br></p><p>&gt; On 11 May 2016, at 11:17 PM, Basem Emara &lt;contact at basememara.com&gt; wrote:<br>&gt; <br>&gt; Thanks for the input everybody, and for the deeper analysis, Rod.<br>&gt; <br>&gt; It’s set straight in my mind now and have even a greater appreciation of optionals than before thanks to this discussion. Let’s scrape this pitch :)<br>&gt; <br>&gt; Happy coding! -Basem<br>&gt; <br>&gt;&gt; On May 11, 2016, at 9:10 AM, Rod Brown &lt;rodney.brown6 at icloud.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I think what you’re referring to as default values would be what you get if you initialize the type directly.<br>&gt;&gt; <br>&gt;&gt; eg:<br>&gt;&gt; let integer = Int()       // integer = 0<br>&gt;&gt; let string	 = String() // string = “”<br>&gt;&gt; let bool 	 = Bool() 	 // bool = false<br>&gt;&gt; <br>&gt;&gt; That said, I’m going to -1 this proposal as well.<br>&gt;&gt; <br>&gt;&gt; The issue I see here is that the proposal conflates a reasonable initialization value with a “go-to default”, which is part of what Swift very deliberately did away with from Objective-C.<br>&gt;&gt; <br>&gt;&gt; Optional should not imply any internal value to the type. It’s the nature of them to be an internal unknown value, or nil, that must be unwrapped deliberately for the protection of your code’s logic. This seems to me to be a slippery slope to the very thing optionals are trying to avoid: default values based on the “zero / bool” conflation.<br>&gt;&gt; <br>&gt;&gt; Additionally, what would that pattern mean for types that cannot be initialised without parameters? If your proposal cannot support anything well beyond the most primitive types, I suspect it doesn’t scale well and shouldn’t come into the language.<br>&gt;&gt; <br>&gt;&gt; If you wish to use defaulting values, it’s best that you specify them instead of hoping the language specifies the one that you assume it will. Do this with the nil coalescing operator (??):<br>&gt;&gt; <br>&gt;&gt; print(temp ?? “”)<br>&gt;&gt; if myString?.isEmpty ?? true {…}<br>&gt;&gt; if myBool ?? false {…}<br>&gt;&gt; if (myInt ?? 0) &gt; otherInt {…}<br>&gt;&gt; <br>&gt;&gt; This is only slightly more code, but it removes all your assumptions, and means you are now the specifier in your code’s logic. You can see from the code exactly what nil will do, and what effect it had on your code.<br>&gt;&gt; <br>&gt;&gt; - Rod<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 11 May 2016, at 10:26 PM, Basem Emara via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Maybe I’m missing something, but aren’t these the default values of primitives deep in the language?<br>&gt;&gt;&gt; String = “”<br>&gt;&gt;&gt; Int = 0<br>&gt;&gt;&gt; Boolean = false<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So if you needed a different default value for your code, you’d do:<br>&gt;&gt;&gt; if !myBool?! {…} //Default to true in my app<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You can still do which is better:<br>&gt;&gt;&gt; if myBool ?? true {…}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Probably booleans is not a clear gain, but for strings it would have vast conveniences.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 11, 2016, at 8:20 AM, Patrick Smith &lt;pgwsmith at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I actually think this is less safe. It depends on the situation for what value the default should be. Sometimes it will be false, other times it will be true. So far better to explicitly show what the default is.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 11 May 2016, at 10:16 PM, Basem Emara via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Forcing unwrapping of optionals is bad practice, but safely unwrapping can be tedious. I’m hoping for something in between that would that would provide soft unwrapping using a syntax like: myVar?!<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; For example, currently we have to do this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let temp = (myString ?? “”); print(“\(temp)”)<br>&gt;&gt;&gt;&gt;&gt; if (myString ?? “”).isEmpty {…}<br>&gt;&gt;&gt;&gt;&gt; if myBool ?? false {…}<br>&gt;&gt;&gt;&gt;&gt; if (myInt ?? 0) &gt; otherInt {…}<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; To something like this instead:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; print(“\(temp?!)”)<br>&gt;&gt;&gt;&gt;&gt; if myString?!.isEmpty {…}<br>&gt;&gt;&gt;&gt;&gt; if myBool?! {…}<br>&gt;&gt;&gt;&gt;&gt; if myInt?! &gt; otherInt {…}<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; What this is implying is that it will attempt to unwrap or use the default of the type.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Of course, this will only work with primitive types and leverage their implicit default values which would go a long way with tedious code and more safety (less forced unwrapping in the world). Otherwise it will produce a compile error if doing something like: myCustomType?!. What do you think?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Basem<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>Pitch: Soft unwrapping of optionals</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>May 11, 2016 at 12:00:00pm</p></header><div class="content"><p>I too agree the unwrapping process can be tedious but I believe this is<br>best because it forces us to check we&#39;re doing the right thing in code and<br>prevents a lot of errors we have to keep on checking in more dynamic<br>languages. -1 from me too.<br></p><p>- Leonardo<br></p><p>On 11 May 2016 at 10:19, Patrick Smith via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Ha great stuff Basem! Glad we could help :) Look forward to your next<br>&gt; proposal!<br>&gt;<br>&gt; &gt; On 11 May 2016, at 11:17 PM, Basem Emara &lt;contact at basememara.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Thanks for the input everybody, and for the deeper analysis, Rod.<br>&gt; &gt;<br>&gt; &gt; It’s set straight in my mind now and have even a greater appreciation of<br>&gt; optionals than before thanks to this discussion. Let’s scrape this pitch :)<br>&gt; &gt;<br>&gt; &gt; Happy coding! -Basem<br>&gt; &gt;<br>&gt; &gt;&gt; On May 11, 2016, at 9:10 AM, Rod Brown &lt;rodney.brown6 at icloud.com&gt;<br>&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I think what you’re referring to as default values would be what you<br>&gt; get if you initialize the type directly.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; eg:<br>&gt; &gt;&gt; let integer = Int()       // integer = 0<br>&gt; &gt;&gt; let string    = String() // string = “”<br>&gt; &gt;&gt; let bool      = Bool()        // bool = false<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; That said, I’m going to -1 this proposal as well.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; The issue I see here is that the proposal conflates a reasonable<br>&gt; initialization value with a “go-to default”, which is part of what Swift<br>&gt; very deliberately did away with from Objective-C.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Optional should not imply any internal value to the type. It’s the<br>&gt; nature of them to be an internal unknown value, or nil, that must be<br>&gt; unwrapped deliberately for the protection of your code’s logic. This seems<br>&gt; to me to be a slippery slope to the very thing optionals are trying to<br>&gt; avoid: default values based on the “zero / bool” conflation.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Additionally, what would that pattern mean for types that cannot be<br>&gt; initialised without parameters? If your proposal cannot support anything<br>&gt; well beyond the most primitive types, I suspect it doesn’t scale well and<br>&gt; shouldn’t come into the language.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; If you wish to use defaulting values, it’s best that you specify them<br>&gt; instead of hoping the language specifies the one that you assume it will.<br>&gt; Do this with the nil coalescing operator (??):<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; print(temp ?? “”)<br>&gt; &gt;&gt; if myString?.isEmpty ?? true {…}<br>&gt; &gt;&gt; if myBool ?? false {…}<br>&gt; &gt;&gt; if (myInt ?? 0) &gt; otherInt {…}<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; This is only slightly more code, but it removes all your assumptions,<br>&gt; and means you are now the specifier in your code’s logic. You can see from<br>&gt; the code exactly what nil will do, and what effect it had on your code.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; - Rod<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On 11 May 2016, at 10:26 PM, Basem Emara via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Maybe I’m missing something, but aren’t these the default values of<br>&gt; primitives deep in the language?<br>&gt; &gt;&gt;&gt; String = “”<br>&gt; &gt;&gt;&gt; Int = 0<br>&gt; &gt;&gt;&gt; Boolean = false<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; So if you needed a different default value for your code, you’d do:<br>&gt; &gt;&gt;&gt; if !myBool?! {…} //Default to true in my app<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; You can still do which is better:<br>&gt; &gt;&gt;&gt; if myBool ?? true {…}<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Probably booleans is not a clear gain, but for strings it would have<br>&gt; vast conveniences.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; On May 11, 2016, at 8:20 AM, Patrick Smith &lt;pgwsmith at gmail.com&gt;<br>&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; I actually think this is less safe. It depends on the situation for<br>&gt; what value the default should be. Sometimes it will be false, other times<br>&gt; it will be true. So far better to explicitly show what the default is.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; On 11 May 2016, at 10:16 PM, Basem Emara via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Forcing unwrapping of optionals is bad practice, but safely<br>&gt; unwrapping can be tedious. I’m hoping for something in between that would<br>&gt; that would provide soft unwrapping using a syntax like: myVar?!<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; For example, currently we have to do this:<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; let temp = (myString ?? “”); print(“\(temp)”)<br>&gt; &gt;&gt;&gt;&gt;&gt; if (myString ?? “”).isEmpty {…}<br>&gt; &gt;&gt;&gt;&gt;&gt; if myBool ?? false {…}<br>&gt; &gt;&gt;&gt;&gt;&gt; if (myInt ?? 0) &gt; otherInt {…}<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; To something like this instead:<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; print(“\(temp?!)”)<br>&gt; &gt;&gt;&gt;&gt;&gt; if myString?!.isEmpty {…}<br>&gt; &gt;&gt;&gt;&gt;&gt; if myBool?! {…}<br>&gt; &gt;&gt;&gt;&gt;&gt; if myInt?! &gt; otherInt {…}<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; What this is implying is that it will attempt to unwrap or use the<br>&gt; default of the type.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Of course, this will only work with primitive types and leverage<br>&gt; their implicit default values which would go a long way with tedious code<br>&gt; and more safety (less forced unwrapping in the world). Otherwise it will<br>&gt; produce a compile error if doing something like: myCustomType?!. What do<br>&gt; you think?<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Basem<br>&gt; &gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;<br>&gt; &gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160511/abfd1741/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d172fa3c47108d84ee35a68e8d675c1?s=50"></div><header><strong>Pitch: Soft unwrapping of optionals</strong> from <string>Ross O&#39;Brien</string> &lt;narrativium+swift at gmail.com&gt;<p>May 11, 2016 at 01:00:00pm</p></header><div class="content"><p>The immediate problem I see with your suggestion is the reason why<br>optionals in Swift are pretty damned awesome: Swift doesn&#39;t have default<br>values. A Bool is not false by default; the Swift compiler will complain if<br>you don&#39;t initialise a Bool variable with a value, one way or the other.<br></p><p>The idea of combining an &#39;if&#39; with a &#39;soft unwrap&#39; such that if the unwrap<br>is nil, the &#39;if&#39; fails, though - that may have merit.<br></p><p>On Wed, May 11, 2016 at 1:16 PM, Basem Emara via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Forcing unwrapping of optionals is bad practice, but safely unwrapping can<br>&gt; be tedious. I’m hoping for something in between that would that would<br>&gt; provide soft unwrapping using a syntax like: myVar?!<br>&gt;<br>&gt; For example, currently we have to do this:<br>&gt;<br>&gt; let temp = (myString ?? “”); print(“\(temp)”)<br>&gt; if (myString ?? “”).isEmpty {…}<br>&gt; if myBool ?? false {…}<br>&gt; if (myInt ?? 0) &gt; otherInt {…}<br>&gt;<br>&gt; To something like this instead:<br>&gt;<br>&gt; print(“\(temp?!)”)<br>&gt; if myString?!.isEmpty {…}<br>&gt; if myBool?! {…}<br>&gt; if myInt?! &gt; otherInt {…}<br>&gt;<br>&gt; What this is implying is that it will attempt to unwrap or use the default<br>&gt; of the type.<br>&gt;<br>&gt; Of course, this will only work with primitive types and leverage their<br>&gt; implicit default values which would go a long way with tedious code and<br>&gt; more safety (less forced unwrapping in the world). Otherwise it will<br>&gt; produce a compile error if doing something like: myCustomType?!. What do<br>&gt; you think?<br>&gt;<br>&gt; Basem<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160511/cdcf0b78/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
