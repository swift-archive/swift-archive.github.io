<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f6b7154fd1d6a470d0b521a2e484bffc?s=50"></div><header><strong>[Review] SE-0110: Distinguish between single-tuple and multiple-argument function types</strong> from <string>Daniel Duan</string> &lt;daniel at duan.org&gt;<p>July  2, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; Vladimir.S via swift-evolution &lt;swift-evolution at ...&gt; writes:<br></p><p>Following your conclusion, should this be legal as well?<br></p><p>let f: () -&gt; Void = { x in print(x) } // f() prints &quot;()&quot;<br>let f: (Int) -&gt; Void = { x in print(x) } // f(5) prints &quot;5&quot;<br></p><p>In other words, &quot;0 argument&quot; is an impossible scenario?<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Review] SE-0110: Distinguish between single-tuple and multiple-argument function types</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>July  3, 2016 at 03:00:00pm</p></header><div class="content"><p>On 02.07.2016 4:20, Daniel Duan via swift-evolution wrote:<br>&gt;&gt; Vladimir.S via swift-evolution &lt;swift-evolution at ...&gt; writes:<br>&gt;<br>&gt; Following your conclusion, should this be legal as well?<br>&gt;<br>&gt; let f: () -&gt; Void = { x in print(x) } // f() prints &quot;()&quot;<br>&gt; let f: (Int) -&gt; Void = { x in print(x) } // f(5) prints &quot;5&quot;<br>&gt;<br>&gt; In other words, &quot;0 argument&quot; is an impossible scenario?<br></p><p>I don&#39;t see problems here. ()-&gt;Void means (Void)-&gt;Void, there *is* one <br>parameter of Void type, which we can omitted as it is empty tuple. So, if <br>you want you can write f(()) or or let z = (); f(z); or just f(), so in <br>closure definition you can have one argument or can have 0 defined <br>arguments if the only argument is of type Void.<br></p><p>It is not the same as be able to accept non-empty tuple when a list of <br>parameters are expected or vice-versa.<br></p><p>I don&#39;t think we should move away(if it is possible at all) from <br>representing zero-argument by empty tuple(Void). This looks like good and <br>useful thing in Swift, especially in functional programming and when <br>working with generics (we can pass parameter(of type void) even when call <br>function with 0 defined arguments).<br></p><p>I actually wonder what should be a type of such function:<br></p><p>func f1() {}<br>print(f1.dynamicType)<br></p><p>Now it is `(()) -&gt; ()`. Should it be `() -&gt; ()`? Seems like no - it <br>actually take 1 argument(empty tuple, Void) and returns empty tuple. So the <br>`() -&gt; ()` *declaration* just still be just an alias for real type `(()) -&gt; <br>()`. IMO.<br></p><p>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Review] SE-0110: Distinguish between single-tuple and multiple-argument function types</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>July  3, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On 3 Jul 2016, at 13:02, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On 02.07.2016 4:20, Daniel Duan via swift-evolution wrote:<br>&gt;&gt;&gt; Vladimir.S via swift-evolution &lt;swift-evolution at ...&gt; writes:<br>&gt;&gt; <br>&gt;&gt; Following your conclusion, should this be legal as well?<br>&gt;&gt; <br>&gt;&gt; let f: () -&gt; Void = { x in print(x) } // f() prints &quot;()&quot;<br>&gt;&gt; let f: (Int) -&gt; Void = { x in print(x) } // f(5) prints &quot;5&quot;<br>&gt;&gt; <br>&gt;&gt; In other words, &quot;0 argument&quot; is an impossible scenario?<br>&gt; <br>&gt; I don&#39;t see problems here. ()-&gt;Void means (Void)-&gt;Void, there *is* one parameter of Void type, which we can omitted as it is empty tuple. So, if you want you can write f(()) or or let z = (); f(z); or just f(), so in closure definition you can have one argument or can have 0 defined arguments if the only argument is of type Void.<br>&gt; <br>&gt; It is not the same as be able to accept non-empty tuple when a list of parameters are expected or vice-versa.<br>&gt; <br>&gt; I don&#39;t think we should move away(if it is possible at all) from representing zero-argument by empty tuple(Void). This looks like good and useful thing in Swift, especially in functional programming and when working with generics (we can pass parameter(of type void) even when call function with 0 defined arguments).<br>&gt; <br>&gt; I actually wonder what should be a type of such function:<br>&gt; <br>&gt; func f1() {}<br>&gt; print(f1.dynamicType)<br>&gt; <br>&gt; Now it is `(()) -&gt; ()`. Should it be `() -&gt; ()`? Seems like no - it actually take 1 argument(empty tuple, Void) and returns empty tuple. So the `() -&gt; ()` *declaration* just still be just an alias for real type `(()) -&gt; ()`. IMO.<br></p><p>I think the issue is that it&#39;s unexpected; I would expect () -&gt; Void to mean no arguments at all, rather than one argument that is Void, as I can&#39;t really envision any cases where I&#39;d need the latter. I think it&#39;s reasonable that for those who can, that they use (()) -&gt; Void to clarify that this is the case, which I think fits well with Swift&#39;s general philosophy of avoiding mistakes, even if this is probably a minor one, it removes an area of confusion or inconsistency.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Review] SE-0110: Distinguish between single-tuple and multiple-argument function types</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>July  3, 2016 at 10:00:00pm</p></header><div class="content"><p>On 03.07.2016 19:48, Haravikk wrote:<br>&gt;<br>&gt;&gt; On 3 Jul 2016, at 13:02, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On 02.07.2016 4:20, Daniel Duan via swift-evolution wrote:<br>&gt;&gt;&gt;&gt; Vladimir.S via swift-evolution &lt;swift-evolution at ...&gt; writes:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Following your conclusion, should this be legal as well?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let f: () -&gt; Void = { x in print(x) } // f() prints &quot;()&quot;<br>&gt;&gt;&gt; let f: (Int) -&gt; Void = { x in print(x) } // f(5) prints &quot;5&quot;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In other words, &quot;0 argument&quot; is an impossible scenario?<br>&gt;&gt;<br>&gt;&gt; I don&#39;t see problems here. ()-&gt;Void means (Void)-&gt;Void, there *is* one parameter of Void type, which we can omitted as it is empty tuple. So, if you want you can write f(()) or or let z = (); f(z); or just f(), so in closure definition you can have one argument or can have 0 defined arguments if the only argument is of type Void.<br>&gt;&gt;<br>&gt;&gt; It is not the same as be able to accept non-empty tuple when a list of parameters are expected or vice-versa.<br>&gt;&gt;<br>&gt;&gt; I don&#39;t think we should move away(if it is possible at all) from representing zero-argument by empty tuple(Void). This looks like good and useful thing in Swift, especially in functional programming and when working with generics (we can pass parameter(of type void) even when call function with 0 defined arguments).<br>&gt;&gt;<br>&gt;&gt; I actually wonder what should be a type of such function:<br>&gt;&gt;<br>&gt;&gt; func f1() {}<br>&gt;&gt; print(f1.dynamicType)<br>&gt;&gt;<br>&gt;&gt; Now it is `(()) -&gt; ()`. Should it be `() -&gt; ()`? Seems like no - it actually take 1 argument(empty tuple, Void) and returns empty tuple. So the `() -&gt; ()` *declaration* just still be just an alias for real type `(()) -&gt; ()`. IMO.<br>&gt;<br>&gt; I think the issue is that it&#39;s unexpected; I would expect () -&gt; Void to<br>mean no arguments at all, rather than one argument that is Void, as I can&#39;t<br>really envision any cases where I&#39;d need the latter. I think it&#39;s<br>reasonable that for those who can, that they use (()) -&gt; Void to clarify<br>that this is the case, which I think fits well with Swift&#39;s general<br>philosophy of avoiding mistakes, even if this is probably a minor one, it<br>removes an area of confusion or inconsistency.<br>&gt;<br></p><p>Well.. according to thread &quot;[Pre-proposal] Fix function type grammar&quot; - it <br>is decided to *not* allow () as parameter to 0 argument function. You&#39;ll <br>need to explicitly allow Void argument definition in function if you need <br>this. So as I understand this question is closed.<br></p><p>As for use-cases, actually I was thinking about functional programming and <br>generics: when you can pass result of previous func to next (in case of <br>()-&gt;() it is Void as now) or use Void as generic type to be able to call <br>()-&gt;() func. Otherwise you&#39;ll need wrappers f2(())-&gt;() {f1(); return ()} <br>and so on. But probably this is not a problem and I&#39;m just missing something.<br></p><p>But, then, regarding the consistency and confusion, I have a question: is <br>it expected that func f() {..} will *return* `Void` ? I believe it is not <br>expected exactly at the same level as Void in parameter for 0 argument <br>function. I.e. should `-&gt; ()` still means &quot;returns Void&quot; or &quot;returns nothing&quot; ?<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Review] SE-0110: Distinguish between single-tuple and multiple-argument function types</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>July  3, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On 3 Jul 2016, at 20:03, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt; <br>&gt; But, then, regarding the consistency and confusion, I have a question: is it expected that func f() {..} will *return* `Void` ? I believe it is not expected exactly at the same level as Void in parameter for 0 argument function. I.e. should `-&gt; ()` still means &quot;returns Void&quot; or &quot;returns nothing&quot; ?<br></p><p>Fair question, personally I never use () to indicate void on the return side, and always specify the return type, so there&#39;s never any doubt what I meant, but that&#39;s just convention at the moment. I wouldn&#39;t mind seeing one style of void return being forced for consistency, but that&#39;s probably out of scope for this issue. It seems vaguely familiar though, has an issue already come up about removing the redundancy?<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Review] SE-0110: Distinguish between single-tuple and multiple-argument function types</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July  3, 2016 at 08:00:00pm</p></header><div class="content"><p>The issue of Void and () has definitely been brought up before.<br></p><p>On Sun, Jul 3, 2016 at 15:04 Haravikk via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On 3 Jul 2016, at 20:03, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; But, then, regarding the consistency and confusion, I have a question:<br>&gt; is it expected that func f() {..} will *return* `Void` ? I believe it is<br>&gt; not expected exactly at the same level as Void in parameter for 0 argument<br>&gt; function. I.e. should `-&gt; ()` still means &quot;returns Void&quot; or &quot;returns<br>&gt; nothing&quot; ?<br>&gt;<br>&gt; Fair question, personally I never use () to indicate void on the return<br>&gt; side, and always specify the return type, so there&#39;s never any doubt what I<br>&gt; meant, but that&#39;s just convention at the moment. I wouldn&#39;t mind seeing one<br>&gt; style of void return being forced for consistency, but that&#39;s probably out<br>&gt; of scope for this issue. It seems vaguely familiar though, has an issue<br>&gt; already come up about removing the redundancy?<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160703/7a8c8175/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Review] SE-0110: Distinguish between single-tuple and multiple-argument function types</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>July  4, 2016 at 12:00:00am</p></header><div class="content"><p>On 03.07.2016 23:04, Haravikk wrote:<br>&gt;<br>&gt;&gt; On 3 Jul 2016, at 20:03, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; But, then, regarding the consistency and confusion, I have a question:<br>&gt;&gt; is it expected that func f() {..} will *return* `Void` ? I believe it<br>&gt;&gt; is not expected exactly at the same level as Void in parameter for 0<br>&gt;&gt; argument function. I.e. should `-&gt; ()` still means &quot;returns Void&quot; or<br>&gt;&gt; &quot;returns nothing&quot; ?<br>&gt;<br>&gt; Fair question, personally I never use () to indicate void on the return<br>&gt; side, and always specify the return type, so there&#39;s never any doubt<br>&gt; what I meant, but that&#39;s just convention at the moment. I wouldn&#39;t mind<br>&gt; seeing one style of void return being forced for consistency, but that&#39;s<br>&gt; probably out of scope for this issue. It seems vaguely familiar though,<br>&gt; has an issue already come up about removing the redundancy?<br>&gt;<br></p><p>As stated in another thread, there will be no changes regarding meaning of <br>`func f(){}` and `-&gt;()` - the same implicit(or explicit, as one wish) Void <br>result.<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Review] SE-0110: Distinguish between single-tuple and multiple-argument function types</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>July  5, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jul 3, 2016, at 5:02, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On 02.07.2016 4:20, Daniel Duan via swift-evolution wrote:<br>&gt;&gt;&gt; Vladimir.S via swift-evolution &lt;swift-evolution at ...&gt; writes:<br>&gt;&gt; <br>&gt;&gt; Following your conclusion, should this be legal as well?<br>&gt;&gt; <br>&gt;&gt; let f: () -&gt; Void = { x in print(x) } // f() prints &quot;()&quot;<br>&gt;&gt; let f: (Int) -&gt; Void = { x in print(x) } // f(5) prints &quot;5&quot;<br>&gt;&gt; <br>&gt;&gt; In other words, &quot;0 argument&quot; is an impossible scenario?<br>&gt; <br>&gt; I don&#39;t see problems here. ()-&gt;Void means (Void)-&gt;Void, there *is* one parameter of Void type, which we can omitted as it is empty tuple. So, if you want you can write f(()) or or let z = (); f(z); or just f(), so in closure definition you can have one argument or can have 0 defined arguments if the only argument is of type Void.<br></p><p>I already said this on the bug you filed, but I disagree quite strongly with this interpretation, based on SE-0029 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0029-remove-implicit-tuple-splat.md&gt;SE-002 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0029-remove-implicit-tuple-splat.md&gt;9. IMO, going from (()) to () is a form of tuple splat.<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160705/c9765914/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f6b7154fd1d6a470d0b521a2e484bffc?s=50"></div><header><strong>[Review] SE-0110: Distinguish between single-tuple and multiple-argument function types</strong> from <string>Daniel Duan</string> &lt;daniel at duan.org&gt;<p>July  5, 2016 at 04:00:00pm</p></header><div class="content"><p>I have a patch that implements this proposal *except* this part. (aka () -&gt; Void means 0 argument therefore { _ in } is a mismatch).<br></p><p>If we were to interpret tuple and the outer paren as described in this proposal, it should be consistent everywhere, therefore requires more consideration (separate proposal) and bigger change in the compiler.<br></p><p>Daniel Duan<br>Sent from my iPhone<br></p><p>&gt; On Jul 5, 2016, at 2:07 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 3, 2016, at 5:02, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On 02.07.2016 4:20, Daniel Duan via swift-evolution wrote:<br>&gt;&gt;&gt;&gt; Vladimir.S via swift-evolution &lt;swift-evolution at ...&gt; writes:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Following your conclusion, should this be legal as well?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let f: () -&gt; Void = { x in print(x) } // f() prints &quot;()&quot;<br>&gt;&gt;&gt; let f: (Int) -&gt; Void = { x in print(x) } // f(5) prints &quot;5&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In other words, &quot;0 argument&quot; is an impossible scenario?<br>&gt;&gt; <br>&gt;&gt; I don&#39;t see problems here. ()-&gt;Void means (Void)-&gt;Void, there *is* one parameter of Void type, which we can omitted as it is empty tuple. So, if you want you can write f(()) or or let z = (); f(z); or just f(), so in closure definition you can have one argument or can have 0 defined arguments if the only argument is of type Void.<br>&gt; <br>&gt; I already said this on the bug you filed, but I disagree quite strongly with this interpretation, based on SE-0029. IMO, going from (()) to () is a form of tuple splat.<br>&gt; <br>&gt; Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160705/45919b95/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Review] SE-0110: Distinguish between single-tuple and multiple-argument function types</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>July  6, 2016 at 05:00:00pm</p></header><div class="content"><p>On 06.07.2016 0:07, Jordan Rose wrote:<br>&gt;<br>&gt;&gt; On Jul 3, 2016, at 5:02, Vladimir.S via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On 02.07.2016 4:20, Daniel Duan via swift-evolution wrote:<br>&gt;&gt;&gt;&gt; Vladimir.S via swift-evolution &lt;swift-evolution at ...&gt; writes:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Following your conclusion, should this be legal as well?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let f: () -&gt; Void = { x in print(x) } // f() prints &quot;()&quot;<br>&gt;&gt;&gt; let f: (Int) -&gt; Void = { x in print(x) } // f(5) prints &quot;5&quot;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In other words, &quot;0 argument&quot; is an impossible scenario?<br>&gt;&gt;<br>&gt;&gt; I don&#39;t see problems here. ()-&gt;Void means (Void)-&gt;Void, there *is* one<br>&gt;&gt; parameter of Void type, which we can omitted as it is empty tuple. So, if<br>&gt;&gt; you want you can write f(()) or or let z = (); f(z); or just f(), so in<br>&gt;&gt; closure definition you can have one argument or can have 0 defined<br>&gt;&gt; arguments if the only argument is of type Void.<br>&gt;<br>&gt; I already said this on the bug you filed, but I disagree quite strongly<br>&gt; with this interpretation, based<br>&gt; on &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0029-remove-implicit-tuple-splat.md&gt;SE-002<br>&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0029-remove-implicit-tuple-splat.md&gt;9.<br>&gt; IMO, going from (()) to () is a form of tuple splat.<br></p><p>I believe this is not my &quot;interpretation&quot; but how the Swift 3.0 works right <br>now and going from (()) to () is an edge case that we should discuss <br>separately.<br></p><p>I understand your opinion, and probably you have correct interpretation of <br>SE-0029, and probably current behavior of ()-&gt;Void vs (Void)-&gt;Void is just <br>a long-running bug, but all that I want to achieve from this discussion - <br>is to get clear reply regarding this question from core team / community <br>like &quot;yes, it is clearly decided and consensus was found, that current <br>behavior is a bug and in Swift 3.0 it is will be not possible to send &#39;()&#39; <br>aka Void to function defined as emtpy-parameters function. If you need to <br>pass emtpy tuple to func - you&#39;ll need to define it as (Void)-&gt;Something&quot;.<br></p><p>&gt;<br>&gt; Jordan<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
