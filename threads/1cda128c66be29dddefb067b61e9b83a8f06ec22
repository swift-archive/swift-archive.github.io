<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6ff404e5928c7aeb05ee97fd4109bf38?s=50"></div><header><strong>Proposal: newtype feature for creating brand new types from existing types</strong> from <string>tuuranton at tutanota.de</string> &lt;tuuranton at tutanota.de&gt;<p>December 11, 2015 at 08:00:00pm</p></header><div class="content"><p>//Existing typealias feature.//Foo acts exactly the same way as Double. It&#39;s <br>the same thing.//Double can be used instead of Foo anywhere.typealias Foo = <br>Double<br>//Proposed newtype feature.//Bar acts exactly the same way as Double and  is <br>the same//thing behind the scenes (until we extend it; see below).//Trying to <br>use Double instead of Bar will result in a compile-time error.newtype Bar = <br>Double<br>Of course, after creating Bar - a &quot;copy&quot; of the type Double, so to speak - I <br>can extend Bar independenly of Double as one would expect.<br>This would be highly useful.<br>Your thoughts?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/1cdaec22/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>Proposal: newtype feature for creating brand new types from existing types</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>December 11, 2015 at 09:00:00pm</p></header><div class="content"><p>Considering the number of times I’ve read about this topic in other languages, I must agree :-)<br></p><p>Yet there are two difficulties:<br></p><p>First, what does Bar get from Double ?<br></p><p>When you say &quot;after creating Bar, I can extend Bar independenly of Double&quot;, the problem lies in the meaning of &quot;after&quot;. In a language like Ruby, there is an &quot;after&quot;, but there is no such clear thing in Swift: modules/packages are compiled as a whole, and module A can extend a type defined the the module B.<br></p><p>More, let’s see what happens below:<br></p><p>1	let d: Double = 1.0<br>2	let b: Bar = d			// Compiler error, I presume.<br>3	let b: Bar = Bar(d)		// Mandatory so that Bar can be put to any use<br>4	let b: Bar = 1.0<br></p><p>That point 4 is tricky.<br></p><p>If it is not an error, then 2. should succeed as well, don’t you think?<br>If it is an error, then one may want to add FloatLiteralConvertible to Bar. Oops, Double already implements it.<br></p><p>Hm. I’m afraid I haven’t found the solution :-)<br></p><p>Gwendal Roué<br></p><p>&gt; Le 11 déc. 2015 à 21:09, Tuur Anton via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; //Existing typealias feature.<br>&gt; //Foo acts exactly the same way as Double. It&#39;s the same thing.<br>&gt; //Double can be used instead of Foo anywhere.<br>&gt; typealias Foo = Double<br>&gt; <br>&gt; //Proposed newtype feature.<br>&gt; //Bar acts exactly the same way as Double and  is the same<br>&gt; //thing behind the scenes (until we extend it; see below).<br>&gt; //Trying to use Double instead of Bar will result in a compile-time error.<br>&gt; newtype Bar = Double<br>&gt; <br>&gt; Of course, after creating Bar - a &quot;copy&quot; of the type Double, so to speak - I can extend Bar independenly of Double as one would expect.<br>&gt; <br>&gt; This would be highly useful.<br>&gt; <br>&gt; Your thoughts?<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/05abb7bb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/33536e304f2318595dbd6104fdb0bd4a?s=50"></div><header><strong>Proposal: newtype feature for creating brand new types from existing types</strong> from <string>Alejandro Martinez</string> &lt;alexito4 at gmail.com&gt;<p>December 11, 2015 at 08:00:00pm</p></header><div class="content"><p>A similar thing has been already mentioned in the list. <br>I can remember the topic &quot;[swift-evolution] protocol based invocation forwarding&quot; which could resolve in a similar feature.<br>As I said in there I would be really interested to see this in the language as will allow us to be more type safe with types that are commonly described as strings or numbers, but that are more than that. <br>Cheers,<br></p><p><br>&gt; El 11 dic 2015, a las 20:30, Gwendal Roué via swift-evolution &lt;swift-evolution at swift.org&gt; escribió:<br>&gt; <br>&gt; Considering the number of times I’ve read about this topic in other languages, I must agree :-)<br>&gt; <br>&gt; Yet there are two difficulties:<br>&gt; <br>&gt; First, what does Bar get from Double ?<br>&gt; <br>&gt; When you say &quot;after creating Bar, I can extend Bar independenly of Double&quot;, the problem lies in the meaning of &quot;after&quot;. In a language like Ruby, there is an &quot;after&quot;, but there is no such clear thing in Swift: modules/packages are compiled as a whole, and module A can extend a type defined the the module B.<br>&gt; <br>&gt; More, let’s see what happens below:<br>&gt; <br>&gt; 1	let d: Double = 1.0<br>&gt; 2	let b: Bar = d			// Compiler error, I presume.<br>&gt; 3	let b: Bar = Bar(d)		// Mandatory so that Bar can be put to any use<br>&gt; 4	let b: Bar = 1.0<br>&gt; <br>&gt; That point 4 is tricky.<br>&gt; <br>&gt; If it is not an error, then 2. should succeed as well, don’t you think?<br>&gt; If it is an error, then one may want to add FloatLiteralConvertible to Bar. Oops, Double already implements it.<br>&gt; <br>&gt; Hm. I’m afraid I haven’t found the solution :-)<br>&gt; <br>&gt; Gwendal Roué<br>&gt; <br>&gt;&gt; Le 11 déc. 2015 à 21:09, Tuur Anton via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; //Existing typealias feature.<br>&gt;&gt; //Foo acts exactly the same way as Double. It&#39;s the same thing.<br>&gt;&gt; //Double can be used instead of Foo anywhere.<br>&gt;&gt; typealias Foo = Double<br>&gt;&gt; <br>&gt;&gt; //Proposed newtype feature.<br>&gt;&gt; //Bar acts exactly the same way as Double and  is the same<br>&gt;&gt; //thing behind the scenes (until we extend it; see below).<br>&gt;&gt; //Trying to use Double instead of Bar will result in a compile-time error.<br>&gt;&gt; newtype Bar = Double<br>&gt;&gt; <br>&gt;&gt; Of course, after creating Bar - a &quot;copy&quot; of the type Double, so to speak - I can extend Bar independenly of Double as one would expect.<br>&gt;&gt; <br>&gt;&gt; This would be highly useful.<br>&gt;&gt; <br>&gt;&gt; Your thoughts?<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/d992c677/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/265868676ac8f12472cc3cc0fc59d827?s=50"></div><header><strong>Proposal: newtype feature for creating brand new types from existing types</strong> from <string>Nicky Gerritsen</string> &lt;nickygerritsen at me.com&gt;<p>December 11, 2015 at 09:00:00pm</p></header><div class="content"><p>&gt; On 11 dec. 2015, at 21:30, Gwendal Roué via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Considering the number of times I’ve read about this topic in other languages, I must agree :-)<br>&gt; <br>&gt; Yet there are two difficulties:<br>&gt; <br>&gt; First, what does Bar get from Double ?<br>&gt; <br>&gt; When you say &quot;after creating Bar, I can extend Bar independenly of Double&quot;, the problem lies in the meaning of &quot;after&quot;. In a language like Ruby, there is an &quot;after&quot;, but there is no such clear thing in Swift: modules/packages are compiled as a whole, and module A can extend a type defined the the module B.<br>&gt; <br>&gt; More, let’s see what happens below:<br>&gt; <br>&gt; 1	let d: Double = 1.0<br>&gt; 2	let b: Bar = d			// Compiler error, I presume.<br>&gt; 3	let b: Bar = Bar(d)		// Mandatory so that Bar can be put to any use<br>&gt; 4	let b: Bar = 1.0<br>&gt; <br>&gt; That point 4 is tricky.<br>&gt; <br>&gt; If it is not an error, then 2. should succeed as well, don’t you think?<br>&gt; If it is an error, then one may want to add FloatLiteralConvertible to Bar. Oops, Double already implements it.<br>But that is not true. Take this example:<br></p><p>let x: Int = 3 // Type added for clarity<br>let y: Double = x // error<br>let z: Double = 3 // ok<br></p><p>This is exactly why it is Float_Literal_Convertible, it can only convert literals ;).<br></p><p>Anyway, about the general thing: isn’t this just inheritance, but then for struct types?<br>i.e.<br></p><p>struct Bar : Double {}<br></p><p>— Nicky<br>&gt; <br>&gt; Hm. I’m afraid I haven’t found the solution :-)<br>&gt; <br>&gt; Gwendal Roué<br>&gt; <br>&gt;&gt; Le 11 déc. 2015 à 21:09, Tuur Anton via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; //Existing typealias feature.<br>&gt;&gt; //Foo acts exactly the same way as Double. It&#39;s the same thing.<br>&gt;&gt; //Double can be used instead of Foo anywhere.<br>&gt;&gt; typealias Foo = Double<br>&gt;&gt; <br>&gt;&gt; //Proposed newtype feature.<br>&gt;&gt; //Bar acts exactly the same way as Double and  is the same<br>&gt;&gt; //thing behind the scenes (until we extend it; see below).<br>&gt;&gt; //Trying to use Double instead of Bar will result in a compile-time error.<br>&gt;&gt; newtype Bar = Double<br>&gt;&gt; <br>&gt;&gt; Of course, after creating Bar - a &quot;copy&quot; of the type Double, so to speak - I can extend Bar independenly of Double as one would expect.<br>&gt;&gt; <br>&gt;&gt; This would be highly useful.<br>&gt;&gt; <br>&gt;&gt; Your thoughts?<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/8590ebbd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/33536e304f2318595dbd6104fdb0bd4a?s=50"></div><header><strong>Proposal: newtype feature for creating brand new types from existing types</strong> from <string>Alejandro Martinez</string> &lt;alexito4 at gmail.com&gt;<p>December 11, 2015 at 08:00:00pm</p></header><div class="content"><p>&gt; Anyway, about the general thing: isn’t this just inheritance, but then for struct types?<br>&gt; i.e.<br>&gt; <br>&gt; struct Bar : Double {}<br></p><p><br>Not exactly as inheritance will let you use Bar in any place where do you expect Double. <br>Presumably newtype does not. <br></p><p><br>&gt; El 11 dic 2015, a las 20:34, Nicky Gerritsen via swift-evolution &lt;swift-evolution at swift.org&gt; escribió:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On 11 dec. 2015, at 21:30, Gwendal Roué via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Considering the number of times I’ve read about this topic in other languages, I must agree :-)<br>&gt;&gt; <br>&gt;&gt; Yet there are two difficulties:<br>&gt;&gt; <br>&gt;&gt; First, what does Bar get from Double ?<br>&gt;&gt; <br>&gt;&gt; When you say &quot;after creating Bar, I can extend Bar independenly of Double&quot;, the problem lies in the meaning of &quot;after&quot;. In a language like Ruby, there is an &quot;after&quot;, but there is no such clear thing in Swift: modules/packages are compiled as a whole, and module A can extend a type defined the the module B.<br>&gt;&gt; <br>&gt;&gt; More, let’s see what happens below:<br>&gt;&gt; <br>&gt;&gt; 1	let d: Double = 1.0<br>&gt;&gt; 2	let b: Bar = d			// Compiler error, I presume.<br>&gt;&gt; 3	let b: Bar = Bar(d)		// Mandatory so that Bar can be put to any use<br>&gt;&gt; 4	let b: Bar = 1.0<br>&gt;&gt; <br>&gt;&gt; That point 4 is tricky.<br>&gt;&gt; <br>&gt;&gt; If it is not an error, then 2. should succeed as well, don’t you think?<br>&gt;&gt; If it is an error, then one may want to add FloatLiteralConvertible to Bar. Oops, Double already implements it.<br>&gt; But that is not true. Take this example:<br>&gt; <br>&gt; let x: Int = 3 // Type added for clarity<br>&gt; let y: Double = x // error<br>&gt; let z: Double = 3 // ok<br>&gt; <br>&gt; This is exactly why it is Float_Literal_Convertible, it can only convert literals ;).<br>&gt; <br>&gt; Anyway, about the general thing: isn’t this just inheritance, but then for struct types?<br>&gt; i.e.<br>&gt; <br>&gt; struct Bar : Double {}<br>&gt; <br>&gt; — Nicky<br>&gt;&gt; <br>&gt;&gt; Hm. I’m afraid I haven’t found the solution :-)<br>&gt;&gt; <br>&gt;&gt; Gwendal Roué<br>&gt;&gt; <br>&gt;&gt;&gt; Le 11 déc. 2015 à 21:09, Tuur Anton via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; //Existing typealias feature.<br>&gt;&gt;&gt; //Foo acts exactly the same way as Double. It&#39;s the same thing.<br>&gt;&gt;&gt; //Double can be used instead of Foo anywhere.<br>&gt;&gt;&gt; typealias Foo = Double<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; //Proposed newtype feature.<br>&gt;&gt;&gt; //Bar acts exactly the same way as Double and  is the same<br>&gt;&gt;&gt; //thing behind the scenes (until we extend it; see below).<br>&gt;&gt;&gt; //Trying to use Double instead of Bar will result in a compile-time error.<br>&gt;&gt;&gt; newtype Bar = Double<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Of course, after creating Bar - a &quot;copy&quot; of the type Double, so to speak - I can extend Bar independenly of Double as one would expect.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This would be highly useful.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Your thoughts?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/23bf6519/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>Proposal: newtype feature for creating brand new types from existing types</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>December 14, 2015 at 11:00:00pm</p></header><div class="content"><p>My assumption is that the proposed newtype simply adopts the storage and<br>any available functions, operators, and extensions available on the<br>original type.<br></p><p>Extensions on Double are available to Double and Bar. Extensions explicitly<br>on Bar are only available on Bar.<br></p><p>That said, I&#39;m not sure this is worth the complexity when you can just wrap<br>a Double inside your own struct Bar {} and get most of the benefits.<br></p><p><br>Russ Bishop<br>russbishop.net<br></p><p><br>On Fri, Dec 11, 2015 at 12:30 PM, Gwendal Roué &lt;swift-evolution at swift.org&gt;<br>wrote:<br></p><p>&gt; Considering the number of times I’ve read about this topic in other<br>&gt; languages, I must agree :-)<br>&gt;<br>&gt; Yet there are two difficulties:<br>&gt;<br>&gt; First, what does Bar get from Double ?<br>&gt;<br>&gt; When you say &quot;after creating Bar, I can extend Bar independenly of<br>&gt; Double&quot;, the problem lies in the meaning of &quot;after&quot;. In a language like<br>&gt; Ruby, there is an &quot;after&quot;, but there is no such clear thing in Swift:<br>&gt; modules/packages are compiled as a whole, and module A can extend a type<br>&gt; defined the the module B.<br>&gt;<br>&gt; More, let’s see what happens below:<br>&gt;<br>&gt; 1 let d: Double = 1.0<br>&gt; 2 let b: Bar = d // Compiler error, I presume.<br>&gt; 3 let b: Bar = Bar(d) // Mandatory so that Bar can be put to any use<br>&gt; 4 let b: Bar = 1.0<br>&gt;<br>&gt; That point 4 is tricky.<br>&gt;<br>&gt; If it is not an error, then 2. should succeed as well, don’t you think?<br>&gt; If it is an error, then one may want to add FloatLiteralConvertible to<br>&gt; Bar. Oops, Double already implements it.<br>&gt;<br>&gt; Hm. I’m afraid I haven’t found the solution :-)<br>&gt;<br>&gt; Gwendal Roué<br>&gt;<br>&gt; Le 11 déc. 2015 à 21:09, Tuur Anton via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;<br>&gt; //Existing typealias feature.<br>&gt; //Foo acts exactly the same way as Double. It&#39;s the same thing.<br>&gt; //Double can be used instead of Foo anywhere.<br>&gt; typealias Foo = Double<br>&gt;<br>&gt; //Proposed newtype feature.<br>&gt; //Bar acts exactly the same way as Double and  is the same<br>&gt; //thing behind the scenes (until we extend it; see below).<br>&gt; //Trying to use Double instead of Bar will result in a compile-time error.<br>&gt; newtype Bar = Double<br>&gt;<br>&gt; Of course, after creating Bar - a &quot;copy&quot; of the type Double, so to speak -<br>&gt; I can extend Bar independenly of Double as one would expect.<br>&gt;<br>&gt; This would be highly useful.<br>&gt;<br>&gt; Your thoughts?<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/7f4bb779/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
