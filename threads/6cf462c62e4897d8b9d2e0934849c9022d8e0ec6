<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[discussion] Change the behavior of @objc on a class?</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>June 27, 2016 at 01:00:00pm</p></header><div class="content"><p>Hey, all. An engineer at Apple noticed the following behavior:<br></p><p>1. class Foo: NSObject → exposed to Objective-C, Swift-style (mangled) runtime name<br>2. @objc class Foo: NSObject → exposed to Objective-C, Swift-style (mangled) runtime name<br>3. @objc(Foo) class Foo: NSObject → exposed to Objective-C, unmangled runtime name<br></p><p>(and 4. @objc class Foo → illegal, classes must have ObjC heritage to be @objc.)<br></p><p>They specifically observed that (1) and (2) have the same behavior, and suggested that maybe (2) should be shorthand for (3).<br></p><p>Pros:<br>- There aren&#39;t two ways to spell (1).<br>- Removing the mangling (and module uniquing) from the runtime name is probably one of the most common uses of @objc on a class.<br></p><p>Cons:<br>- It&#39;s a source-breaking change, for all that the &quot;@objc&quot; in (2) is redundant.<br>- For protocols, (1) and (2) are not equivalent, because @objc isn&#39;t inherited there.<br>- Mangling is used to namespace class names at run time; if you drop that, the ObjC name should probably have a prefix. (This applies more to frameworks than apps, though.)<br></p><p>There are probably people who say that last con applies to the generated header as well: we shouldn&#39;t put (1) or (2) into the generated header because the ObjC name might conflict with another class at compile time. This is valid, but probably too drastic a change at this point.<br></p><p>So, what does everyone think? I&#39;m leaning towards &quot;no change&quot; because it&#39;s a bit subtle and not a big enough win, but if there&#39;s widespread support for this I&#39;ll pull it into a proposal.<br></p><p>Jordan<br></p><p>P.S. This is rdar://problem/22296436 for anyone else at Apple.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/6cf40ec6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>[discussion] Change the behavior of @objc on a class?</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>June 27, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jun 27, 2016, at 1:26 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hey, all. An engineer at Apple noticed the following behavior:<br>&gt; <br>&gt; 1. class Foo: NSObject → exposed to Objective-C, Swift-style (mangled) runtime name<br>&gt; 2. @objc class Foo: NSObject → exposed to Objective-C, Swift-style (mangled) runtime name<br>&gt; 3. @objc(Foo) class Foo: NSObject → exposed to Objective-C, unmangled runtime name<br>&gt; <br>&gt; (and 4. @objc class Foo → illegal, classes must have ObjC heritage to be @objc.)<br>&gt; <br>&gt; They specifically observed that (1) and (2) have the same behavior, and suggested that maybe (2) should be shorthand for (3).<br></p><p>I actually wonder why NSObject subclasses magically appear in the generated header when they aren’t marked @objc. If anything I’d say we should remove that behavior.<br></p><p><br>&gt; <br>&gt; Pros:<br>&gt; - There aren&#39;t two ways to spell (1).<br>&gt; - Removing the mangling (and module uniquing) from the runtime name is probably one of the most common uses of @objc on a class.<br></p><p>Another really common case (at least in our mixed codebase) is bridging to give the class a “private” name in Swift but a sensible name in Objective-C because we have a sensible struct or generic type in Swift, don’t want Swift consumers to use the @objc type, yet need to provide a bridged interface to Objective-C. We do the same with methods too.<br></p><p>@objc(Tile)<br>public class _objc_Tile: NSObject { }<br></p><p><br></p><p>&gt; <br>&gt; Cons:<br>&gt; - It&#39;s a source-breaking change, for all that the &quot;@objc&quot; in (2) is redundant.<br>&gt; - For protocols, (1) and (2) are not equivalent, because @objc isn&#39;t inherited there.<br></p><p>I’d favor consistency even if (1) and (2) are redundant.<br></p><p>&gt; - Mangling is used to namespace class names at run time; if you drop that, the ObjC name should probably have a prefix. (This applies more to frameworks than apps, though.)<br>&gt; <br>&gt; There are probably people who say that last con applies to the generated header as well: we shouldn&#39;t put (1) or (2) into the generated header because the ObjC name might conflict with another class at compile time. This is valid, but probably too drastic a change at this point.<br>&gt; <br>&gt; So, what does everyone think? I&#39;m leaning towards &quot;no change&quot; because it&#39;s a bit subtle and not a big enough win, but if there&#39;s widespread support for this I&#39;ll pull it into a proposal.<br>&gt; <br>&gt; Jordan<br></p><p>Given other priorities I’d lean toward no change.<br></p><p>Russ<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/a5fa1a6b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[discussion] Change the behavior of @objc on a class?</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>June 28, 2016 at 06:00:00am</p></header><div class="content"><p>Do you know how would this affect e.g. XIB files or CoreData models where you have the class name + module? If the class was previously marked @objc and now it would be implicitely @objc(ClassName), would it require all XIB files to be updated, or would the XIB compiler be able to deal with it? If the former, than it&#39;s a big no for me.<br></p><p>I&#39;m not a big fan of a change on any account either, though, since it&#39;s absolutely not clear that @objc would have this side-effect.<br></p><p>&gt; On Jun 27, 2016, at 10:26 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hey, all. An engineer at Apple noticed the following behavior:<br>&gt; <br>&gt; 1. class Foo: NSObject → exposed to Objective-C, Swift-style (mangled) runtime name<br>&gt; 2. @objc class Foo: NSObject → exposed to Objective-C, Swift-style (mangled) runtime name<br>&gt; 3. @objc(Foo) class Foo: NSObject → exposed to Objective-C, unmangled runtime name<br>&gt; <br>&gt; (and 4. @objc class Foo → illegal, classes must have ObjC heritage to be @objc.)<br>&gt; <br>&gt; They specifically observed that (1) and (2) have the same behavior, and suggested that maybe (2) should be shorthand for (3).<br>&gt; <br>&gt; Pros:<br>&gt; - There aren&#39;t two ways to spell (1).<br>&gt; - Removing the mangling (and module uniquing) from the runtime name is probably one of the most common uses of @objc on a class.<br>&gt; <br>&gt; Cons:<br>&gt; - It&#39;s a source-breaking change, for all that the &quot;@objc&quot; in (2) is redundant.<br>&gt; - For protocols, (1) and (2) are not equivalent, because @objc isn&#39;t inherited there.<br>&gt; - Mangling is used to namespace class names at run time; if you drop that, the ObjC name should probably have a prefix. (This applies more to frameworks than apps, though.)<br>&gt; <br>&gt; There are probably people who say that last con applies to the generated header as well: we shouldn&#39;t put (1) or (2) into the generated header because the ObjC name might conflict with another class at compile time. This is valid, but probably too drastic a change at this point.<br>&gt; <br>&gt; So, what does everyone think? I&#39;m leaning towards &quot;no change&quot; because it&#39;s a bit subtle and not a big enough win, but if there&#39;s widespread support for this I&#39;ll pull it into a proposal.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; P.S. This is rdar://problem/22296436 &lt;rdar://problem/22296436&gt; for anyone else at Apple.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/9027913d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/73a38bb7bc9528e31098defe30e68ea4?s=50"></div><header><strong>[discussion] Change the behavior of @objc on a class?</strong> from <string>Jean-Daniel Dupas</string> &lt;mailing at xenonium.com&gt;<p>June 28, 2016 at 08:00:00am</p></header><div class="content"><p>As the IB compiler is able to compile xib into nib without knowledge of the actual code, I hardly see how it would guess that a class named Foo in Module Bar should now be compiled as Foo and no longer be mangled as Bar.Foo.<br></p><p>Maybe that issue can be mitigated by allowing a @objc(Bar.Foo) annotation and use it when migrating existing code.<br></p><p>&gt; Le 28 juin 2016 à 06:56, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Do you know how would this affect e.g. XIB files or CoreData models where you have the class name + module? If the class was previously marked @objc and now it would be implicitely @objc(ClassName), would it require all XIB files to be updated, or would the XIB compiler be able to deal with it? If the former, than it&#39;s a big no for me.<br>&gt; <br>&gt; I&#39;m not a big fan of a change on any account either, though, since it&#39;s absolutely not clear that @objc would have this side-effect.<br>&gt; <br>&gt;&gt; On Jun 27, 2016, at 10:26 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hey, all. An engineer at Apple noticed the following behavior:<br>&gt;&gt; <br>&gt;&gt; 1. class Foo: NSObject → exposed to Objective-C, Swift-style (mangled) runtime name<br>&gt;&gt; 2. @objc class Foo: NSObject → exposed to Objective-C, Swift-style (mangled) runtime name<br>&gt;&gt; 3. @objc(Foo) class Foo: NSObject → exposed to Objective-C, unmangled runtime name<br>&gt;&gt; <br>&gt;&gt; (and 4. @objc class Foo → illegal, classes must have ObjC heritage to be @objc.)<br>&gt;&gt; <br>&gt;&gt; They specifically observed that (1) and (2) have the same behavior, and suggested that maybe (2) should be shorthand for (3).<br>&gt;&gt; <br>&gt;&gt; Pros:<br>&gt;&gt; - There aren&#39;t two ways to spell (1).<br>&gt;&gt; - Removing the mangling (and module uniquing) from the runtime name is probably one of the most common uses of @objc on a class.<br>&gt;&gt; <br>&gt;&gt; Cons:<br>&gt;&gt; - It&#39;s a source-breaking change, for all that the &quot;@objc&quot; in (2) is redundant.<br>&gt;&gt; - For protocols, (1) and (2) are not equivalent, because @objc isn&#39;t inherited there.<br>&gt;&gt; - Mangling is used to namespace class names at run time; if you drop that, the ObjC name should probably have a prefix. (This applies more to frameworks than apps, though.)<br>&gt;&gt; <br>&gt;&gt; There are probably people who say that last con applies to the generated header as well: we shouldn&#39;t put (1) or (2) into the generated header because the ObjC name might conflict with another class at compile time. This is valid, but probably too drastic a change at this point.<br>&gt;&gt; <br>&gt;&gt; So, what does everyone think? I&#39;m leaning towards &quot;no change&quot; because it&#39;s a bit subtle and not a big enough win, but if there&#39;s widespread support for this I&#39;ll pull it into a proposal.<br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt; P.S. This is rdar://problem/22296436 &lt;rdar://problem/22296436&gt; for anyone else at Apple.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/2e645e24/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[discussion] Change the behavior of @objc on a class?</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>June 28, 2016 at 01:00:00pm</p></header><div class="content"><p>Xcode plans are a little beyond the scope of the Swift project, so I can&#39;t promise that there would be any such autoupdating. If there were such a feature, I&#39;d expect it to be in the form of a one-time migration, probably triggered along with the Swift 3 migrator…but the IB team might have other ideas, or decide they have more important things to finish for this release. So I guess the answer is &quot;don&#39;t count on it&quot;.<br></p><p>Jordan<br></p><p><br>&gt; On Jun 27, 2016, at 21:56, Charlie Monroe &lt;charlie at charliemonroe.net&gt; wrote:<br>&gt; <br>&gt; Do you know how would this affect e.g. XIB files or CoreData models where you have the class name + module? If the class was previously marked @objc and now it would be implicitely @objc(ClassName), would it require all XIB files to be updated, or would the XIB compiler be able to deal with it? If the former, than it&#39;s a big no for me.<br>&gt; <br>&gt; I&#39;m not a big fan of a change on any account either, though, since it&#39;s absolutely not clear that @objc would have this side-effect.<br>&gt; <br>&gt;&gt; On Jun 27, 2016, at 10:26 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hey, all. An engineer at Apple noticed the following behavior:<br>&gt;&gt; <br>&gt;&gt; 1. class Foo: NSObject → exposed to Objective-C, Swift-style (mangled) runtime name<br>&gt;&gt; 2. @objc class Foo: NSObject → exposed to Objective-C, Swift-style (mangled) runtime name<br>&gt;&gt; 3. @objc(Foo) class Foo: NSObject → exposed to Objective-C, unmangled runtime name<br>&gt;&gt; <br>&gt;&gt; (and 4. @objc class Foo → illegal, classes must have ObjC heritage to be @objc.)<br>&gt;&gt; <br>&gt;&gt; They specifically observed that (1) and (2) have the same behavior, and suggested that maybe (2) should be shorthand for (3).<br>&gt;&gt; <br>&gt;&gt; Pros:<br>&gt;&gt; - There aren&#39;t two ways to spell (1).<br>&gt;&gt; - Removing the mangling (and module uniquing) from the runtime name is probably one of the most common uses of @objc on a class.<br>&gt;&gt; <br>&gt;&gt; Cons:<br>&gt;&gt; - It&#39;s a source-breaking change, for all that the &quot;@objc&quot; in (2) is redundant.<br>&gt;&gt; - For protocols, (1) and (2) are not equivalent, because @objc isn&#39;t inherited there.<br>&gt;&gt; - Mangling is used to namespace class names at run time; if you drop that, the ObjC name should probably have a prefix. (This applies more to frameworks than apps, though.)<br>&gt;&gt; <br>&gt;&gt; There are probably people who say that last con applies to the generated header as well: we shouldn&#39;t put (1) or (2) into the generated header because the ObjC name might conflict with another class at compile time. This is valid, but probably too drastic a change at this point.<br>&gt;&gt; <br>&gt;&gt; So, what does everyone think? I&#39;m leaning towards &quot;no change&quot; because it&#39;s a bit subtle and not a big enough win, but if there&#39;s widespread support for this I&#39;ll pull it into a proposal.<br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt; P.S. This is rdar://problem/22296436 &lt;rdar://problem/22296436&gt; for anyone else at Apple.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/dd70d59c/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[discussion] Change the behavior of @objc on a class?</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>June 28, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jun 27, 2016, at 1:26 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hey, all. An engineer at Apple noticed the following behavior:<br>&gt; <br>&gt; 1. class Foo: NSObject → exposed to Objective-C, Swift-style (mangled) runtime name<br>&gt; 2. @objc class Foo: NSObject → exposed to Objective-C, Swift-style (mangled) runtime name<br>&gt; 3. @objc(Foo) class Foo: NSObject → exposed to Objective-C, unmangled runtime name<br>&gt; <br>&gt; (and 4. @objc class Foo → illegal, classes must have ObjC heritage to be @objc.)<br>&gt; <br>&gt; They specifically observed that (1) and (2) have the same behavior, and suggested that maybe (2) should be shorthand for (3).<br>&gt; <br>&gt; Pros:<br>&gt; - There aren&#39;t two ways to spell (1).<br>&gt; - Removing the mangling (and module uniquing) from the runtime name is probably one of the most common uses of @objc on a class.<br>&gt; <br>&gt; Cons:<br>&gt; - It&#39;s a source-breaking change, for all that the &quot;@objc&quot; in (2) is redundant.<br>&gt; - For protocols, (1) and (2) are not equivalent, because @objc isn&#39;t inherited there.<br>&gt; - Mangling is used to namespace class names at run time; if you drop that, the ObjC name should probably have a prefix. (This applies more to frameworks than apps, though.)<br></p><p>I’m -1 on this, because bare “@objc” in other contexts means “make sure this is exposed to Objective-C, but I don’t want to be explicit about the name” while “@objc(something)” means “make sure this is exposed to Objective-C, and ‘something’ is the name”. <br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/5fb650f1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[discussion] Change the behavior of @objc on a class?</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June 29, 2016 at 06:00:00am</p></header><div class="content"><p>Regards<br>LM<br>(From mobile)<br></p><p>&gt; On Jun 28, 2016, at 8:04 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 27, 2016, at 1:26 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hey, all. An engineer at Apple noticed the following behavior:<br>&gt;&gt; <br>&gt;&gt; 1. class Foo: NSObject → exposed to Objective-C, Swift-style (mangled) runtime name<br>&gt;&gt; 2. @objc class Foo: NSObject → exposed to Objective-C, Swift-style (mangled) runtime name<br>&gt;&gt; 3. @objc(Foo) class Foo: NSObject → exposed to Objective-C, unmangled runtime name<br>&gt;&gt; <br>&gt;&gt; (and 4. @objc class Foo → illegal, classes must have ObjC heritage to be @objc.)<br>&gt;&gt; <br>&gt;&gt; They specifically observed that (1) and (2) have the same behavior, and suggested that maybe (2) should be shorthand for (3).<br>&gt;&gt; <br>&gt;&gt; Pros:<br>&gt;&gt; - There aren&#39;t two ways to spell (1).<br>&gt;&gt; - Removing the mangling (and module uniquing) from the runtime name is probably one of the most common uses of @objc on a class.<br>&gt;&gt; <br>&gt;&gt; Cons:<br>&gt;&gt; - It&#39;s a source-breaking change, for all that the &quot;@objc&quot; in (2) is redundant.<br>&gt;&gt; - For protocols, (1) and (2) are not equivalent, because @objc isn&#39;t inherited there.<br>&gt;&gt; - Mangling is used to namespace class names at run time; if you drop that, the ObjC name should probably have a prefix. (This applies more to frameworks than apps, though.)<br>&gt; <br>&gt; I’m -1 on this, because bare “@objc” in other contexts means “make sure this is exposed to Objective-C, but I don’t want to be explicit about the name” while “@objc(something)” means “make sure this is exposed to Objective-C, and ‘something’ is the name”. <br>&gt; <br></p><p>-1 <br>Please&#39;o&#39;please ... I find it useful for complexifying simple swift names into the kind that typically exists on the objc side.<br></p><p><br>&gt; 	- Doug<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/4aa529e0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[discussion] Change the behavior of @objc on a class?</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>June 29, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jun 28, 2016, at 21:50, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Regards<br>&gt; LM<br>&gt; (From mobile)<br>&gt; <br>&gt; On Jun 28, 2016, at 8:04 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 27, 2016, at 1:26 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hey, all. An engineer at Apple noticed the following behavior:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. class Foo: NSObject → exposed to Objective-C, Swift-style (mangled) runtime name<br>&gt;&gt;&gt; 2. @objc class Foo: NSObject → exposed to Objective-C, Swift-style (mangled) runtime name<br>&gt;&gt;&gt; 3. @objc(Foo) class Foo: NSObject → exposed to Objective-C, unmangled runtime name<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (and 4. @objc class Foo → illegal, classes must have ObjC heritage to be @objc.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; They specifically observed that (1) and (2) have the same behavior, and suggested that maybe (2) should be shorthand for (3).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Pros:<br>&gt;&gt;&gt; - There aren&#39;t two ways to spell (1).<br>&gt;&gt;&gt; - Removing the mangling (and module uniquing) from the runtime name is probably one of the most common uses of @objc on a class.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Cons:<br>&gt;&gt;&gt; - It&#39;s a source-breaking change, for all that the &quot;@objc&quot; in (2) is redundant.<br>&gt;&gt;&gt; - For protocols, (1) and (2) are not equivalent, because @objc isn&#39;t inherited there.<br>&gt;&gt;&gt; - Mangling is used to namespace class names at run time; if you drop that, the ObjC name should probably have a prefix. (This applies more to frameworks than apps, though.)<br>&gt;&gt; <br>&gt;&gt; I’m -1 on this, because bare “@objc” in other contexts means “make sure this is exposed to Objective-C, but I don’t want to be explicit about the name” while “@objc(something)” means “make sure this is exposed to Objective-C, and ‘something’ is the name”. <br>&gt;&gt; <br>&gt; <br>&gt; -1 <br>&gt; Please&#39;o&#39;please ... I find it useful for complexifying simple swift names into the kind that typically exists on the objc side.<br></p><p>To be clear, the argument form wouldn’t change, but it seems like there’s enough negative feedback on this that we shouldn’t do it. Thanks, everyone!<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/d215a5a5/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
