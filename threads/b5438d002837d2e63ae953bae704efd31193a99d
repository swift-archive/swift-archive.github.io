<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Manifesto] Completing Generics</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>March  2, 2016 at 05:00:00pm</p></header><div class="content"><p>Hi all,<br></p><p>Introduction<br></p><p>The “Complete Generics” goal for Swift 3 has been fairly ill-defined thus fair, with just this short blurb in the list of goals:<br></p><p>Complete generics: Generics are used pervasively in a number of Swift libraries, especially the standard library. However, there are a number of generics features the standard library requires to fully realize its vision, including recursive protocol constraints, the ability to make a constrained extension conform to a new protocol (i.e., an array of Equatable elements is Equatable), and so on. Swift 3.0 should provide those generics features needed by the standard library, because they affect the standard library&#39;s ABI.<br>This message expands upon the notion of “completing generics”. It is not a plan for Swift 3, nor an official core team communication, but it collects the results of numerous discussions among the core team and Swift developers, both of the compiler and the standard library. I hope to achieve several things:<br></p><p>Communicate a vision for Swift generics, building on the original generics design document &lt;https://github.com/apple/swift/blob/master/docs/Generics.rst&gt;, so we have something concrete and comprehensive to discuss.<br>Establish some terminology that the Swift developers have been using for these features, so our discussions can be more productive (“oh, you’re proposing what we refer to as ‘conditional conformances’; go look over at this thread”).<br>Engage more of the community in discussions of specific generics features, so we can coalesce around designs for public review. And maybe even get some of them implemented.<br></p><p>A message like this can easily turn into a centithread &lt;http://www.urbandictionary.com/define.php?term=centithread&gt;. To separate concerns in our discussion, I ask that replies to this specific thread be limited to discussions of the vision as a whole: how the pieces fit together, what pieces are missing, whether this is the right long-term vision for Swift, and so on. For discussions of specific language features, e.g., to work out the syntax and semantics of conditional conformances or discuss the implementation in compiler or use in the standard library, please start a new thread based on the feature names I’m using.<br></p><p>This message covers a lot of ground; I’ve attempted a rough categorization of the various features, and kept the descriptions brief to limit the overall length. Most of these aren’t my ideas, and any syntax I’m providing is simply a way to express these ideas in code and is subject to change. Not all of these features will happen, either soon or ever, but they are intended to be a fairly complete whole that should mesh together. I’ve put a * next to features that I think are important in the nearer term vs. being interesting “some day”. Mostly, the *’s reflect features that will have a significant impact on the Swift standard library’s design and implementation.<br></p><p>Enough with the disclaimers; it’s time to talk features.<br></p><p>Removing unnecessary restrictions<br></p><p>There are a number of restrictions to the use of generics that fall out of the implementation in the Swift compiler. Removal of these restrictions is a matter of implementation only; one need not introduce new syntax or semantics to realize them. I’m listing them for two reasons: first, it’s an acknowledgment that these features are intended to exist in the model we have today, and, second, we’d love help with the implementation of these features.<br></p><p><br>*Recursive protocol constraints<br></p><p>Currently, an associated type cannot be required to conform to its enclosing protocol (or any protocol that inherits that protocol). For example, in the standard library SubSequence type of a Sequence should itself be a Sequence:<br></p><p>protocol Sequence {<br>  associatedtype Iterator : IteratorProtocol<br>  …<br>  associatedtype SubSequence : Sequence   // currently ill-formed, but should be possible<br>}<br></p><p>The compiler currently rejects this protocol, which is unfortunate: it effectively pushes the SubSequence-must-be-a-Sequence requirement into every consumer of SubSequence, and does not communicate the intent of this abstraction well.<br></p><p>Nested generics<br></p><p>Currently, a generic type cannot be nested within another generic type, e.g.<br></p><p>struct X&lt;T&gt; {<br>  struct Y&lt;U&gt; { }  // currently ill-formed, but should be possible<br>}<br></p><p>There isn’t much to say about this: the compiler simply needs to be improved to handle nested generics throughout.<br></p><p><br>Concrete same-type requirements<br></p><p>Currently, a constrained extension cannot use a same-type constraint to make a type parameter equivalent to a concrete type. For example:<br></p><p>extension Array where Element == String {<br>  func makeSentence() -&gt; String {<br>    // uppercase first string, concatenate with spaces, add a period, whatever<br>  }<br>}<br></p><p>This is a highly-requested feature that fits into the existing syntax and semantics. Note that one could imagine introducing new syntax, e.g., extending “Array&lt;String&gt;”, which gets into new-feature territory: see the section on “Parameterized extensions”.<br></p><p>Parameterizing other declarations<br></p><p>There are a number of Swift declarations that currently cannot have generic parameters; some of those have fairly natural extensions to generic forms that maintain their current syntax and semantics, but become more powerful when made generic.<br></p><p>Generic typealiases<br></p><p>Typealiases could be allowed to carry generic parameters. They would still be aliases (i.e., they would not introduce new types). For example:<br></p><p>typealias StringDictionary&lt;Value&gt; = Dictionary&lt;String, Value&gt;<br></p><p>var d1 = StringDictionary&lt;Int&gt;()<br>var d2: Dictionary&lt;String, Int&gt; = d1 // okay: d1 and d2 have the same type, Dictionary&lt;String, Int&gt;<br></p><p><br>Generic subscripts<br></p><p>Subscripts could be allowed to have generic parameters. For example, we could introduce a generic subscript on a Collection that allows us to pull out the values at an arbitrary set of indices:<br></p><p>extension Collection {<br>  subscript&lt;Indices: Sequence where Indices.Iterator.Element == Index&gt;(indices: Indices) -&gt; [Iterator.Element] {<br>    get {<br>      var result = [Iterator.Element]()<br>      for index in indices {<br>        result.append(self[index])<br>      }<br></p><p>      return result<br>    }<br></p><p>    set {<br>      for (index, value) in zip(indices, newValue) {<br>        self[index] = value<br>      }<br>    }<br>  }<br>}<br></p><p><br>Generic constants<br></p><p>let constants could be allowed to have generic parameters, such that they produce differently-typed values depending on how they are used. For example, this is particularly useful for named literal values, e.g.,<br></p><p>let π&lt;T : FloatLiteralConvertible&gt;: T = 3.141592653589793238462643383279502884197169399<br></p><p>The Clang importer could make particularly good use of this when importing macros.<br></p><p><br>Parameterized extensions<br></p><p>Extensions themselves could be parameterized, which would allow some structural pattern matching on types. For example, this would permit one to extend an array of optional values, e.g.,<br></p><p>extension&lt;T&gt; Array where Element == T? {<br>  var someValues: [T] {<br>    var result = [T]()<br>    for opt in self {<br>      if let value = opt { result.append(value) }<br>    }<br>   return result<br>  }<br>}<br></p><p>We can generalize this to a protocol extensions:<br></p><p>extension&lt;T&gt; Sequence where Element == T? {<br>  var someValues: [T] {<br>    var result = [T]()<br>    for opt in self {<br>      if let value = opt { result.append(value) }<br>    }<br>   return result<br>  }<br>}<br></p><p>Note that when one is extending nominal types, we could simplify the syntax somewhat to make the same-type constraint implicit in the syntax:<br></p><p>extension&lt;T&gt; Array&lt;T?&gt; {<br>  var someValues: [T] {<br>    var result = [T]()<br>    for opt in self {<br>      if let value = opt { result.append(value) }<br>    }<br>   return result<br>  }<br>}<br></p><p>When we’re working with concrete types, we can use that syntax to improve the extension of concrete versions of generic types (per “Concrete same-type requirements”, above), e.g.,<br></p><p>extension Array&lt;String&gt; {<br>  func makeSentence() -&gt; String {<br>    // uppercase first string, concatenate with spaces, add a period, whatever<br>  }<br>}<br></p><p><br>Minor extensions<br></p><p>There are a number of minor extensions we can make to the generics system that don’t fundamentally change what one can express in Swift, but which can improve its expressivity.<br></p><p>*Arbitrary requirements in protocols<br></p><p>Currently, a new protocol can inherit from other protocols, introduce new associated types, and add new conformance constraints to associated types (by redeclaring an associated type from an inherited protocol). However, one cannot express more general constraints. Building on the example from “Recursive protocol constraints”, we really want the element type of a Sequence’s SubSequence to be the same as the element type of the Sequence, e.g.,<br></p><p>protocol Sequence {<br>  associatedtype Iterator : IteratorProtocol<br>  …<br>  associatedtype SubSequence : Sequence where SubSequence.Iterator.Element == Iterator.Element<br>}<br></p><p>Hanging the where clause off the associated type is protocol not ideal, but that’s a discussion for another thread.<br></p><p><br>*Typealiases in protocols and protocol extensions<br></p><p>Now that associated types have their own keyword (thanks!), it’s reasonable to bring back “typealias”. Again with the Sequence protocol:<br></p><p>protocol Sequence {<br>  associatedtype Iterator : IteratorProtocol<br>  typealias Element = Iterator.Element   // rejoice! now we can refer to SomeSequence.Element rather than SomeSequence.Iterator.Element<br>}<br></p><p><br>Default generic arguments <br></p><p>Generic parameters could be given the ability to provide default arguments, which would be used in cases where the type argument is not specified and type inference could not determine the type argument. For example:<br></p><p>public final class Promise&lt;Value, Reason=Error&gt; { … }<br></p><p>func getRandomPromise() -&gt; Promise&lt;Int, ErrorProtocol&gt; { … }<br></p><p>var p1: Promise&lt;Int&gt; = …<br>var p2: Promise&lt;Int, Error&gt; = p1     // okay: p1 and p2 have the same type Promise&lt;Int, Error&gt;<br>var p3: Promise = getRandomPromise() // p3 has type Promise&lt;Int, ErrorProtocol&gt; due to type inference<br></p><p><br>Generalized “class” constraints<br></p><p>The “class” constraint can currently only be used for defining protocols. We could generalize it to associated type and type parameter declarations, e.g.,<br></p><p>protocol P {<br>  associatedtype A : class<br>}<br></p><p>func foo&lt;T : class&gt;(t: T) { }<br></p><p>As part of this, the magical AnyObject protocol could be replaced with an existential with a class bound, so that it becomes a typealias:<br></p><p>typealias AnyObject = protocol&lt;class&gt;<br></p><p>See the “Existentials” section, particularly “Generalized existentials”, for more information.<br></p><p><br>*Allowing subclasses to override requirements satisfied by defaults<br></p><p>When a superclass conforms to a protocol and has one of the protocol’s requirements satisfied by a member of a protocol extension, that member currently cannot be overridden by a subclass. For example:<br></p><p>protocol P {<br>  func foo()<br>}<br></p><p>extension P {<br>  func foo() { print(“P”) }<br>}<br></p><p>class C : P {<br>  // gets the protocol extension’s <br>}<br></p><p>class D : C {<br>  /*override not allowed!*/ func foo() { print(“D”) }<br>}<br></p><p>let p: P = D()<br>p.foo() // gotcha: prints “P” rather than “D”!<br></p><p>D.foo should be required to specify “override” and should be called dynamically.<br></p><p><br>Major extensions to the generics model<br></p><p>Unlike the minor extensions, major extensions to the generics model provide more expressivity in the Swift generics system and, generally, have a much more significant design and implementation cost.<br></p><p><br>*Conditional conformances<br></p><p>Conditional conformances express the notion that a generic type will conform to a particular protocol only under certain circumstances. For example, Array is Equatable only when its elements are Equatable:<br></p><p>extension Array : Equatable where Element : Equatable { }<br></p><p>func ==&lt;T : Equatable&gt;(lhs: Array&lt;T&gt;, rhs: Array&lt;T&gt;) -&gt; Bool { … }<br></p><p>Conditional conformances are a potentially very powerful feature. One important aspect of this feature is how deal with or avoid overlapping conformances. For example, imagine an adaptor over a Sequence that has conditional conformances to Collection and MutableCollection:<br></p><p>struct SequenceAdaptor&lt;S: Sequence&gt; : Sequence { }<br>extension SequenceAdaptor : Collection where S: Collection { … }<br>extension SequenceAdaptor : MutableCollection where S: MutableCollection { }<br></p><p>This should almost certainly be permitted, but we need to cope with or reject “overlapping” conformances:<br></p><p>extension SequenceAdaptor : Collection where S: SomeOtherProtocolSimilarToCollection { } // trouble: two ways for SequenceAdaptor to conform to Collection<br></p><p>See the section on “Private conformances” for more about the issues with having the same type conform to the same protocol multiple times.<br></p><p><br>Variadic generics<br></p><p>Currently, a generic parameter list contains a fixed number of generic parameters. If one has a type that could generalize to any number of generic parameters, the only real way to deal with it today involves creating a set of types. For example, consider the standard library’s “zip” function. It returns one of these when provided with two arguments to zip together:<br></p><p>public struct Zip2Sequence&lt;Sequence1 : Sequence,<br>                           Sequence2 : Sequence&gt; : Sequence { … }<br></p><p>public func zip&lt;Sequence1 : Sequence, Sequence2 : Sequence&gt;(<br>              sequence1: Sequence1, _ sequence2: Sequence2)<br>            -&gt; Zip2Sequence&lt;Sequence1, Sequence2&gt; { … }<br></p><p>Supporting three arguments would require copy-paste of those of those:<br></p><p>public struct Zip3Sequence&lt;Sequence1 : Sequence,<br>                           Sequence2 : Sequence,<br>                           Sequence3 : Sequence&gt; : Sequence { … }<br></p><p>public func zip&lt;Sequence1 : Sequence, Sequence2 : Sequence, Sequence3 : Sequence&gt;(<br>              sequence1: Sequence1, _ sequence2: Sequence2, _ sequence3: sequence3)<br>            -&gt; Zip3Sequence&lt;Sequence1, Sequence2, Sequence3&gt; { … }<br></p><p>Variadic generics would allow us to abstract over a set of generic parameters. The syntax below is hopelessly influenced by C++11 variadic templates &lt;http://www.jot.fm/issues/issue_2008_02/article2/&gt; (sorry), where putting an ellipsis (“…”) to the left of a declaration makes it a “parameter pack” containing zero or more parameters and putting an ellipsis to the right of a type/expression/etc. expands the parameter packs within that type/expression into separate arguments. The important part is that we be able to meaningfully abstract over zero or more generic parameters, e.g.:<br></p><p>public struct ZipIterator&lt;... Iterators : IteratorProtocol&gt; : Iterator {  // zero or more type parameters, each of which conforms to IteratorProtocol<br>  public typealias Element = (Iterators.Element...)                       // a tuple containing the element types of each iterator in Iterators<br></p><p>  var (...iterators): (Iterators...)    // zero or more stored properties, one for each type in Iterators <br>  var reachedEnd: Bool = false<br></p><p>  public mutating func next() -&gt; Element? {<br>    if reachedEnd { return nil }<br></p><p>    guard let values = (iterators.next()...) {   // call “next” on each of the iterators, put the results into a tuple named “values&quot;<br>      reachedEnd = true<br>      return nil<br>    }<br></p><p>    return values<br>  }<br>}<br></p><p>public struct ZipSequence&lt;...Sequences : Sequence&gt; : Sequence {<br>  public typealias Iterator = ZipIterator&lt;Sequences.Iterator...&gt;   // get the zip iterator with the iterator types of our Sequences<br></p><p>  var (...sequences): (Sequences...)    // zero or more stored properties, one for each type in Sequences <br></p><p>  // details ...<br>}<br></p><p>Such a design could also work for function parameters, so we can pack together multiple function arguments with different types, e.g.,<br></p><p>public func zip&lt;... Sequences : SequenceType&gt;(... sequences: Sequences...) <br>            -&gt; ZipSequence&lt;Sequences...&gt; {<br>  return ZipSequence(sequences...)<br>}<br></p><p>Finally, this could tie into the discussions about a tuple “splat” operator. For example:<br></p><p>func apply&lt;... Args, Result&gt;(fn: (Args...) -&gt; Result,    // function taking some number of arguments and producing Result<br>                           args: (Args...)) -&gt; Result {  // tuple of arguments<br>  return fn(args...)                                     // expand the arguments in the tuple “args” into separate arguments<br>}<br></p><p><br>Extensions of structural types<br></p><p>Currently, only nominal types (classes, structs, enums, protocols) can be extended. One could imagine extending structural types—particularly tuple types—to allow them to, e.g., conform to protocols. For example, pulling together variadic generics, parameterized extensions, and conditional conformances, one could express “a tuple type is Equatable if all of its element types are Equatable”:<br></p><p>extension&lt;...Elements : Equatable&gt; (Elements...) : Equatable {   // extending the tuple type “(Elements…)” to be Equatable<br>}<br></p><p>There are some natural bounds here: one would need to have actual structural types. One would not be able to extend every type:<br></p><p>extension&lt;T&gt; T { // error: neither a structural nor a nominal type<br>}<br></p><p>And before you think you’re cleverly making it possible to have a conditional conformance that makes every type T that conforms to protocol P also conform to protocol Q, see the section &quot;Conditional conformances via protocol extensions”, below:<br></p><p>extension&lt;T : P&gt; T : Q { // error: neither a structural nor a nominal type<br>}<br></p><p><br>Syntactic improvements<br></p><p>There are a number of potential improvements we could make to the generics syntax. Such a list could go on for a very long time, so I’ll only highlight some obvious ones that have been discussed by the Swift developers.<br></p><p>*Default implementations in protocols<br></p><p>Currently, protocol members can never have implementations. We could allow one to provide such implementations to be used as the default if a conforming type does not supply an implementation, e.g.,<br></p><p>protocol Bag {<br>  associatedtype Element : Equatable<br>  func contains(element: Element) -&gt; Bool<br></p><p>  func containsAll&lt;S: Sequence where Sequence.Iterator.Element == Element&gt;(elements: S) -&gt; Bool {<br>    for x in elements {<br>      if contains(x) { return true }<br>    }<br>    return false<br>  }<br>}<br></p><p>struct IntBag : Bag {<br>  typealias Element = Int<br>  func contains(element: Int) -&gt; Bool { ... }<br></p><p>  // okay: containsAll requirement is satisfied by Bag’s default implementation<br>}<br></p><p>One can get this effect with protocol extensions today, hence the classification of this feature as a (mostly) syntactic improvement:<br></p><p>protocol Bag {<br>  associatedtype Element : Equatable<br>  func contains(element: Element) -&gt; Bool<br></p><p>  func containsAll&lt;S: Sequence where Sequence.Iterator.Element == Element&gt;(elements: S) -&gt; Bool<br>}<br></p><p>extension Bag {<br>  func containsAll&lt;S: Sequence where Sequence.Iterator.Element == Element&gt;(elements: S) -&gt; Bool {<br>    for x in elements {<br>      if contains(x) { return true }<br>    }<br>    return false<br>  }<br>}<br></p><p><br>*Moving the where clause outside of the angle brackets<br></p><p>The “where” clause of generic functions comes very early in the declaration, although it is generally of much less concern to the client than the function parameters and result type that follow it. This is one of the things that contributes to “angle bracket blindness”. For example, consider the containsAll signature above:<br></p><p>func containsAll&lt;S: Sequence where Sequence.Iterator.Element == Element&gt;(elements: S) -&gt; Bool<br></p><p>One could move the “where” clause to the end of the signature, so that the most important parts—name, generic parameter, parameters, result type—precede it:<br></p><p>func containsAll&lt;S: Sequence&gt;(elements: S) -&gt; Bool <br>       where Sequence.Iterator.Element == Element<br></p><p><br>*Renaming “protocol&lt;…&gt;” to “Any&lt;…&gt;”.<br></p><p>The “protocol&lt;…&gt;” syntax is a bit of an oddity in Swift. It is used to compose protocols together, mostly to create values of existential type, e.g.,<br></p><p>var x: protocol&lt;NSCoding, NSCopying&gt;<br></p><p>It’s weird that it’s a type name that starts with a lowercase letter, and most Swift developers probably never deal with this feature unless they happen to look at the definition of Any:<br></p><p>typealias Any = protocol&lt;&gt;<br></p><p>“Any” might be a better name for this functionality. “Any” without brackets could be a keyword for “any type”, and “Any” followed by brackets could take the role of “protocol&lt;&gt;” today:<br></p><p>var x: Any&lt;NSCoding, NSCopying&gt;<br></p><p>That reads much better: “Any type that conforms to NSCoding and NSCopying”. See the section &quot;Generalized existentials” for additional features in this space.<br></p><p>Maybe<br></p><p>There are a number of features that get discussed from time-to-time, while they could fit into Swift’s generics system, it’s not clear that they belong in Swift at all. The important question for any feature in this category is not “can it be done” or “are there cool things we can express”, but “how can everyday Swift developers benefit from the addition of such a feature?”. Without strong motivating examples, none of these “maybes” will move further along.<br></p><p>Dynamic dispatch for members of protocol extensions<br></p><p>Only the requirements of protocols currently use dynamic dispatch, which can lead to surprises:<br></p><p>protocol P {<br>  func foo()<br>}<br></p><p>extension P {<br>  func foo() { print(“P.foo()”)<br>  func bar() { print(“P.bar()”)<br>}<br></p><p>struct X : P {<br>  func foo() { print(“X.foo()”)<br>  func bar() { print(“X.bar()”)<br>}<br></p><p>let x = X()<br>x.foo() // X.foo()<br>x.bar() // X.bar()<br></p><p>let p: P = X()<br>p.foo() // X.foo()<br>p.bar() // P.bar()<br></p><p>Swift could adopt a model where members of protocol extensions are dynamically dispatched.<br></p><p>Named generic parameters<br></p><p>When specifying generic arguments for a generic type, the arguments are always positional: Dictionary&lt;String, Int&gt; is a Dictionary whose Key type is String and whose Value type is Int, by convention. One could permit the arguments to be labeled, e.g.,<br></p><p>var d: Dictionary&lt;Key: String, Value: Int&gt;<br></p><p>Such a feature makes more sense if Swift gains default generic arguments, because generic argument labels would allow one to skip defaulted arguments.<br></p><p>Generic value parameters<br></p><p>Currently, Swift’s generic parameters are always types. One could imagine allowing generic parameters that are values, e.g.,<br></p><p>struct MultiArray&lt;T, let Dimensions: Int&gt; { // specify the number of dimensions to the array<br>  subscript (indices: Int...) -&gt; T {<br>    get {<br>      require(indices.count == Dimensions)<br>      // ...<br>    }<br>}<br></p><p>A suitably general feature might allow us to express fixed-length array or vector types as a standard library component, and perhaps also allow one to implement a useful dimensional analysis library. Tackling this feature potentially means determining what it is for an expression to be a “constant expression” and diving into dependent-typing, hence the “maybe”.<br></p><p>Higher-kinded types<br></p><p>Higher-kinded types allow one to express the relationship between two different specializations of the same nominal type within a protocol. For example, if we think of the Self type in a protocol as really being “Self&lt;T&gt;”, it allows us to talk about the relationship between “Self&lt;T&gt;” and “Self&lt;U&gt;” for some other type U. For example, it could allow the “map” operation on a collection to return a collection of the same kind but with a different operation, e.g.,<br></p><p>let intArray: Array&lt;Int&gt; = …<br>intArray.map { String($0) } // produces Array&lt;String&gt;<br>let intSet: Set&lt;Int&gt; = …<br>intSet.map { String($0) }   // produces Set&lt;String&gt;<br></p><p><br>Potential syntax borrowed from one thread on higher-kinded types &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002736.html&gt; uses ~= as a “similarity” constraint to describe a Functor protocol:<br></p><p>protocol Functor {<br>  associatedtype A<br>  func fmap&lt;FB where FB ~= Self&gt;(f: A -&gt; FB.A) -&gt; FB<br>}<br></p><p><br>Specifying type arguments for uses of generic functions<br></p><p>The type arguments of a generic function are always determined via type inference. For example, given:<br></p><p>func f&lt;T&gt;(t: T)<br></p><p>one cannot directly specify T: either one calls “f” (and T is determined via the argument’s type) or one uses “f” in a context where it is given a particular function type (e.g., “let x: (Int) -&gt; Void = f”  would infer T = Int). We could permit explicit specialization here, e.g.,<br></p><p>let x = f&lt;Int&gt; // x has type (Int) -&gt; Void<br></p><p><br>Unlikely<br></p><p>Features in this category have been requested at various times, but they don’t fit well with Swift’s generics system because they cause some part of the model to become overly complicated, have unacceptable implementation limitations, or overlap significantly with existing features.<br></p><p>Generic protocols<br></p><p>One of the most commonly requested features is the ability to parameterize protocols themselves. For example, a protocol that indicates that the Self type can be constructed from some specified type T:<br></p><p>protocol ConstructibleFromValue&lt;T&gt; {<br>  init(_ value: T)<br>}<br></p><p>Implicit in this feature is the ability for a given type to conform to the protocol in two different ways. A “Real” type might be constructible from both Float and Double, e.g.,<br></p><p>struct Real { … }<br>extension Real : ConstructibleFrom&lt;Float&gt; {<br>  init(_ value: Float) { … }<br>}<br>extension Real : ConstructibleFrom&lt;Double&gt; {<br>  init(_ value: Double) { … }<br>}<br></p><p>Most of the requests for this feature actually want a different feature. They tend to use a parameterized Sequence as an example, e.g.,<br></p><p>protocol Sequence&lt;Element&gt; { … }<br></p><p>func foo(strings: Sequence&lt;String&gt;) {  /// works on any sequence containing Strings<br>  // ...<br>}<br></p><p>The actual requested feature here 	is the ability to say “Any type that conforms to Sequence whose Element type is String”, which is covered by the section on “Generalized existentials”, below.<br></p><p>More importantly, modeling Sequence with generic parameters rather than associated types is tantalizing but wrong: you don’t want a type conforming to Sequence in multiple ways, or (among other things) your for..in loops stop working, and you lose the ability to dynamically cast down to an existential “Sequence” without binding the Element type (again, see “Generalized existentials”). Use cases similar to the ConstructibleFromValue protocol above seem too few to justify the potential for confusion between associated types and generic parameters of protocols; we’re better off not having the latter.<br></p><p><br>Private conformances <br></p><p>Right now, a protocol conformance can be no less visible than the minimum of the conforming type’s access and the protocol’s access. Therefore, a public type conforming to a public protocol must provide the conformance publicly. One could imagine removing that restriction, so that one could introduce a private conformance:<br></p><p>public protocol P { }<br>public struct X { }<br>extension X : internal P { … } // X conforms to P, but only within this module<br></p><p>The main problem with private conformances is the interaction with dynamic casting. If I have this code:<br></p><p>func foo(value: Any) {<br>  if let x = value as? P { print(“P”) }<br>}<br></p><p>foo(X())<br></p><p>Under what circumstances should it print “P”? If foo() is defined within the same module as the conformance of X to P? If the call is defined within the same module as the conformance of X to P? Never? Either of the first two answers requires significant complications in the dynamic casting infrastructure to take into account the module in which a particular dynamic cast occurred (the first option) or where an existential was formed (the second option), while the third answer breaks the link between the static and dynamic type systems—none of which is an acceptable result.<br></p><p>Conditional conformances via protocol extensions<br></p><p>We often get requests to make a protocol conform to another protocol. This is, effectively, the expansion of the notion of “Conditional conformances” to protocol extensions. For example:<br></p><p>protocol P {<br>  func foo()<br>}<br></p><p>protocol Q {<br>  func bar()<br>}<br></p><p>extension Q : P { // every type that conforms to Q also conforms to P<br>  func foo() {    // implement “foo” requirement in terms of “bar&quot;<br>    bar()<br>  }<br>}<br></p><p>func f&lt;T: P&gt;(t: T) { … }<br></p><p>struct X : Q {<br>  func bar() { … }<br>}<br></p><p>f(X()) // okay: X conforms to P through the conformance of Q to P<br></p><p>This is an extremely powerful feature: is allows one to map the abstractions of one domain into another domain (e.g., every Matrix is a Graph). However, similar to private conformances, it puts a major burden on the dynamic-casting runtime to chase down arbitrarily long and potentially cyclic chains of conformances, which makes efficient implementation nearly impossible.<br></p><p>Potential removals<br></p><p>The generics system doesn’t seem like a good candidate for a reduction in scope; most of its features do get used fairly pervasively in the standard library, and few feel overly anachronistic. However...<br></p><p>Associated type inference<br></p><p>Associated type inference is the process by which we infer the type bindings for associated types from other requirements. For example:<br></p><p>protocol IteratorProtocol {<br>  associatedtype Element<br>  mutating func next() -&gt; Element?<br>}<br></p><p>struct IntIterator : IteratorProtocol {<br>  mutating func next() -&gt; Int? { … }  // use this to infer Element = Int<br>}<br></p><p>Associated type inference is a useful feature. It’s used throughout the standard library, and it helps keep associated types less visible to types that simply want to conform to a protocol. On the other hand, associated type inference is the only place in Swift where we have a global type inference problem: it has historically been a major source of bugs, and implementing it fully and correctly requires a drastically different architecture to the type checker. Is the value of this feature worth keeping global type inference in the Swift language, when we have deliberatively avoided global type inference elsewhere in the language?<br></p><p><br>Existentials<br></p><p>Existentials aren’t really generics per se, but the two systems are closely intertwined due to their mutable dependence on protocols.<br></p><p>*Generalized existentials<br></p><p>The restrictions on existential types came from an implementation limitation, but it is reasonable to allow a value of protocol type even when the protocol has Self constraints or associated types. For example, consider IteratorProtocol again and how it could be used as an existential:<br></p><p>protocol IteratorProtocol {<br>  associatedtype Element<br>  mutating func next() -&gt; Element?<br>}<br></p><p>let it: IteratorProtocol = …<br>it.next()   // if this is permitted, it could return an “Any?”, i.e., the existential that wraps the actual element<br></p><p>Additionally, it is reasonable to want to constrain the associated types of an existential, e.g., “a Sequence whose element type is String” could be expressed by putting a where clause into “protocol&lt;…&gt;” or “Any&lt;…&gt;” (per “Renaming protocol&lt;…&gt; to Any&lt;…&gt;”):<br></p><p>let strings: Any&lt;Sequence where .Iterator.Element == String&gt; = [“a”, “b”, “c”]<br></p><p>The leading “.” indicates that we’re talking about the dynamic type, i.e., the “Self” type that’s conforming to the Sequence protocol. There’s no reason why we cannot support arbitrary “where” clauses within the “Any&lt;…&gt;”. This very-general syntax is a bit unwieldy, but common cases can easily be wrapped up in a generic typealias (see the section “Generic typealiases” above):<br></p><p>typealias AnySequence&lt;Element&gt; = Any&lt;Sequence where .Iterator.Element == Element&gt;<br>let strings: AnySequence&lt;String&gt; = [“a”, “b”, “c”]<br></p><p><br>Opening existentials<br></p><p>Generalized existentials as described above will still have trouble with protocol requirements that involve Self or associated types in function parameters. For example, let’s try to use Equatable as an existential:<br></p><p>protocol Equatable {<br>  func ==(lhs: Self, rhs: Self) -&gt; Bool<br>  func !=(lhs: Self, rhs: Self) -&gt; Bool<br>}<br></p><p>let e1: Equatable = …<br>let e2: Equatable = …<br>if e1 == e2 { … } // error: e1 and e2 don’t necessarily have the same dynamic type<br></p><p>One explicit way to allow such operations in a type-safe manner is to introduce an “open existential” operation of some sort, which extracts and gives a name to the dynamic type stored inside an existential. For example:<br></p><p>	 <br>if let storedInE1 = e1 openas T {     // T is a the type of storedInE1, a copy of the value stored in e1<br>  if let storedInE2 = e2 as? T {      // is e2 also a T?<br>    if storedInE1 == storedInE2 { … } // okay: storedInT1 and storedInE2 are both of type T, which we know is Equatable<br>  }<br>}<br></p><p>Thoughts?<br></p><p>	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160302/b543a99d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Manifesto] Completing Generics</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March  2, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Mar 2, 2016, at 5:22 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Private conformances <br>&gt; <br>&gt; Right now, a protocol conformance can be no less visible than the minimum of the conforming type’s access and the protocol’s access. Therefore, a public type conforming to a public protocol must provide the conformance publicly. One could imagine removing that restriction, so that one could introduce a private conformance:<br>&gt; <br>&gt; public protocol P { }<br>&gt; public struct X { }<br>&gt; extension X : internal P { … } // X conforms to P, but only within this module<br>&gt; <br>&gt; The main problem with private conformances is the interaction with dynamic casting. If I have this code:<br>&gt; <br>&gt; func foo(value: Any) {<br>&gt;   if let x = value as? P { print(“P”) }<br>&gt; }<br>&gt; <br>&gt; foo(X())<br>&gt; <br>&gt; Under what circumstances should it print “P”? If foo() is defined within the same module as the conformance of X to P? If the call is defined within the same module as the conformance of X to P? Never? Either of the first two answers requires significant complications in the dynamic casting infrastructure to take into account the module in which a particular dynamic cast occurred (the first option) or where an existential was formed (the second option), while the third answer breaks the link between the static and dynamic type systems—none of which is an acceptable result.<br></p><p>You don&#39;t need private conformances to introduce these coherence problems with dynamic casting. You only need two modules that independently extend a common type to conform to a common protocol. As Jordan discussed in his resilience manifesto, a publicly-subclassable base class that adopts a new protocol has the potential to create a conflicting conformance with external subclasses that may have already adopted that protocol. This seems to me like poor grounds for rejecting the ability to have private conformances. I think they&#39;re a really useful feature.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160302/deec434e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Completing Generics] Private and multiple conformances</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>March  2, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Mar 2, 2016, at 5:38 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 2, 2016, at 5:22 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Private conformances <br>&gt;&gt; <br>&gt;&gt; Right now, a protocol conformance can be no less visible than the minimum of the conforming type’s access and the protocol’s access. Therefore, a public type conforming to a public protocol must provide the conformance publicly. One could imagine removing that restriction, so that one could introduce a private conformance:<br>&gt;&gt; <br>&gt;&gt; public protocol P { }<br>&gt;&gt; public struct X { }<br>&gt;&gt; extension X : internal P { … } // X conforms to P, but only within this module<br>&gt;&gt; <br>&gt;&gt; The main problem with private conformances is the interaction with dynamic casting. If I have this code:<br>&gt;&gt; <br>&gt;&gt; func foo(value: Any) {<br>&gt;&gt;   if let x = value as? P { print(“P”) }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; foo(X())<br>&gt;&gt; <br>&gt;&gt; Under what circumstances should it print “P”? If foo() is defined within the same module as the conformance of X to P? If the call is defined within the same module as the conformance of X to P? Never? Either of the first two answers requires significant complications in the dynamic casting infrastructure to take into account the module in which a particular dynamic cast occurred (the first option) or where an existential was formed (the second option), while the third answer breaks the link between the static and dynamic type systems—none of which is an acceptable result.<br>&gt; <br>&gt; You don&#39;t need private conformances to introduce these coherence problems with dynamic casting. You only need two modules that independently extend a common type to conform to a common protocol. As Jordan discussed in his resilience manifesto, a publicly-subclassable base class that adopts a new protocol has the potential to create a conflicting conformance with external subclasses that may have already adopted that protocol.<br></p><p>Right, multiple conformances do happen in our current model. Personally, I think that the occurrence of multiple conformances should effectively be an error at runtime unless the conformances are effectively identical (same type witnesses with the same conformances may be a reasonable approximation), and even then it’s worthy of a diagnostic as early as we can produce one, because the amount of infrastructure one needs to handle multiple conformances is significant.<br></p><p>&gt; This seems to me like poor grounds for rejecting the ability to have private conformances. I think they&#39;re a really useful feature.<br></p><p>With what semantics? Truly embracing private and multiple conformances means embedding it in type identity:<br></p><p>// Module A<br>public protocol P {<br>  associatedtype A<br>}<br>public struct X&lt;T : P&gt; { }<br></p><p>// Module B<br>struct Y { }<br></p><p>// Module C<br>import A<br>import B<br>extension Y : private P {<br>  typealias A = Int<br>}<br></p><p>public func f() -&gt; Any { return X&lt;Y&gt;() }<br></p><p>// Module D<br>import A<br>import B<br>extension Y : private P {<br>  typealias A = Double<br>}<br></p><p>public func g(x: Any) {<br>  if let y = x as? X&lt;Y&gt; { /* do we get here? */ }<br>}<br></p><p>// Module E<br>import A<br>import B<br>import C<br>import D<br>g(f())<br></p><p>It’s not that we can’t make this behave correctly—the answer is “no”, we don’t get into the “then” block, because modules D and E effectively have different types X&lt;Y&gt; due to the differing conformances—but that making this behave correctly has a nontrivial runtime cost (uniquing via protocol conformances) and can cause major confusion (wait, X&lt;Y&gt; isn’t a single thing?), for what I suspect is a fairly rare occurrence.<br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160302/1b57efbd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Completing Generics] Private and multiple conformances</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March  2, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Mar 2, 2016, at 8:26 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 2, 2016, at 5:38 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 2, 2016, at 5:22 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Private conformances <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Right now, a protocol conformance can be no less visible than the minimum of the conforming type’s access and the protocol’s access. Therefore, a public type conforming to a public protocol must provide the conformance publicly. One could imagine removing that restriction, so that one could introduce a private conformance:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public protocol P { }<br>&gt;&gt;&gt; public struct X { }<br>&gt;&gt;&gt; extension X : internal P { … } // X conforms to P, but only within this module<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The main problem with private conformances is the interaction with dynamic casting. If I have this code:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func foo(value: Any) {<br>&gt;&gt;&gt;   if let x = value as? P { print(“P”) }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; foo(X())<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Under what circumstances should it print “P”? If foo() is defined within the same module as the conformance of X to P? If the call is defined within the same module as the conformance of X to P? Never? Either of the first two answers requires significant complications in the dynamic casting infrastructure to take into account the module in which a particular dynamic cast occurred (the first option) or where an existential was formed (the second option), while the third answer breaks the link between the static and dynamic type systems—none of which is an acceptable result.<br>&gt;&gt; <br>&gt;&gt; You don&#39;t need private conformances to introduce these coherence problems with dynamic casting. You only need two modules that independently extend a common type to conform to a common protocol. As Jordan discussed in his resilience manifesto, a publicly-subclassable base class that adopts a new protocol has the potential to create a conflicting conformance with external subclasses that may have already adopted that protocol.<br>&gt; <br>&gt; Right, multiple conformances do happen in our current model. Personally, I think that the occurrence of multiple conformances should effectively be an error at runtime unless the conformances are effectively identical (same type witnesses with the same conformances may be a reasonable approximation), and even then it’s worthy of a diagnostic as early as we can produce one, because the amount of infrastructure one needs to handle multiple conformances is significant.<br></p><p>If it&#39;s a runtime error, that&#39;s a huge resilience liability, since any library adding a conformance would potentially be causing its users to start crashing at load time.<br></p><p>&gt;&gt; This seems to me like poor grounds for rejecting the ability to have private conformances. I think they&#39;re a really useful feature.<br>&gt; <br>&gt; With what semantics? Truly embracing private and multiple conformances means embedding it in type identity:<br>&gt; <br>&gt; // Module A<br>&gt; public protocol P {<br>&gt;   associatedtype A<br>&gt; }<br>&gt; public struct X&lt;T : P&gt; { }<br>&gt; <br>&gt; // Module B<br>&gt; struct Y { }<br>&gt; <br>&gt; // Module C<br>&gt; import A<br>&gt; import B<br>&gt; extension Y : private P {<br>&gt;   typealias A = Int<br>&gt; }<br>&gt; <br>&gt; public func f() -&gt; Any { return X&lt;Y&gt;() }<br>&gt; <br>&gt; // Module D<br>&gt; import A<br>&gt; import B<br>&gt; extension Y : private P {<br>&gt;   typealias A = Double<br>&gt; }<br>&gt; <br>&gt; public func g(x: Any) {<br>&gt;   if let y = x as? X&lt;Y&gt; { /* do we get here? */ }<br>&gt; }<br>&gt; <br>&gt; // Module E<br>&gt; import A<br>&gt; import B<br>&gt; import C<br>&gt; import D<br>&gt; g(f())<br>&gt; <br>&gt; It’s not that we can’t make this behave correctly—the answer is “no”, we don’t get into the “then” block, because modules D and E effectively have different types X&lt;Y&gt; due to the differing conformances—but that making this behave correctly has a nontrivial runtime cost (uniquing via protocol conformances) and can cause major confusion (wait, X&lt;Y&gt; isn’t a single thing?), for what I suspect is a fairly rare occurrence.<br></p><p>Yeah, I suspect the overlap of dynamic casting and use cases for private conformances is small, so it seems unfortunate to me to hobble the language around the needs of dynamic casts. A workable rule might be to say that private or internal conformances aren&#39;t exposed to runtime lookup, so are never found by as? casts. We could then statically reject the `as? X&lt;Y&gt;` cast here since the X&lt;Y&gt; instantiation depends on a runtime-invisible conformance.<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160302/70038277/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>[Completing Generics] Private and multiple conformances</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>March  2, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Mar 2, 2016, at 9:12 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Yeah, I suspect the overlap of dynamic casting and use cases for private conformances is small, so it seems unfortunate to me to hobble the language around the needs of dynamic casts. A workable rule might be to say that private or internal conformances aren&#39;t exposed to runtime lookup, so are never found by as? casts. We could then statically reject the `as? X&lt;Y&gt;` cast here since the X&lt;Y&gt; instantiation depends on a runtime-invisible conformance.<br>&gt; <br></p><p>I feel like we talked about this in person a while back but I don’t remember the conclusion. What if dynamic cast lookup was lexically scoped to the conformances visible from the lookup location? I’m not quite sure how you would represent this at runtime but it seems feasible. <br></p><p>&gt; -Joe<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160302/bc8bbd3e/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Completing Generics] Private and multiple conformances</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>March  2, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Mar 2, 2016, at 9:12 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Mar 2, 2016, at 8:26 PM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 2, 2016, at 5:38 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mar 2, 2016, at 5:22 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Private conformances <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Right now, a protocol conformance can be no less visible than the minimum of the conforming type’s access and the protocol’s access. Therefore, a public type conforming to a public protocol must provide the conformance publicly. One could imagine removing that restriction, so that one could introduce a private conformance:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; public protocol P { }<br>&gt;&gt;&gt;&gt; public struct X { }<br>&gt;&gt;&gt;&gt; extension X : internal P { … } // X conforms to P, but only within this module<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The main problem with private conformances is the interaction with dynamic casting. If I have this code:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func foo(value: Any) {<br>&gt;&gt;&gt;&gt;   if let x = value as? P { print(“P”) }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; foo(X())<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Under what circumstances should it print “P”? If foo() is defined within the same module as the conformance of X to P? If the call is defined within the same module as the conformance of X to P? Never? Either of the first two answers requires significant complications in the dynamic casting infrastructure to take into account the module in which a particular dynamic cast occurred (the first option) or where an existential was formed (the second option), while the third answer breaks the link between the static and dynamic type systems—none of which is an acceptable result.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You don&#39;t need private conformances to introduce these coherence problems with dynamic casting. You only need two modules that independently extend a common type to conform to a common protocol. As Jordan discussed in his resilience manifesto, a publicly-subclassable base class that adopts a new protocol has the potential to create a conflicting conformance with external subclasses that may have already adopted that protocol. <br>&gt;&gt; <br>&gt;&gt; Right, multiple conformances do happen in our current model. Personally, I think that the occurrence of multiple conformances should effectively be an error at runtime unless the conformances are effectively identical (same type witnesses with the same conformances may be a reasonable approximation), and even then it’s worthy of a diagnostic as early as we can produce one, because the amount of infrastructure one needs to handle multiple conformances is significant.<br>&gt; <br>&gt; If it&#39;s a runtime error, that&#39;s a huge resilience liability, since any library adding a conformance would potentially be causing its users to start crashing at load time.<br></p><p>My hope is that we could limit the failure mode to the case where the conflicting conformances are different in a way that affects soundness, e.g., different type witnesses for the same associated type. I certainly agree that we’re creating both a resilience liability and a liability when composing libraries (the author of library E below did nothing wrong, but observes weird behavior), but the alternatives seem so much worse.<br></p><p>&gt; <br>&gt;&gt;&gt; This seems to me like poor grounds for rejecting the ability to have private conformances. I think they&#39;re a really useful feature.<br>&gt;&gt; <br>&gt;&gt; With what semantics? Truly embracing private and multiple conformances means embedding it in type identity:<br>&gt;&gt; <br>&gt;&gt; // Module A<br>&gt;&gt; public protocol P {<br>&gt;&gt;   associatedtype A<br>&gt;&gt; }<br>&gt;&gt; public struct X&lt;T : P&gt; { }<br>&gt;&gt; <br>&gt;&gt; // Module B<br>&gt;&gt; struct Y { }<br>&gt;&gt; <br>&gt;&gt; // Module C<br>&gt;&gt; import A<br>&gt;&gt; import B<br>&gt;&gt; extension Y : private P {<br>&gt;&gt;   typealias A = Int<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; public func f() -&gt; Any { return X&lt;Y&gt;() }<br>&gt;&gt; <br>&gt;&gt; // Module D<br>&gt;&gt; import A<br>&gt;&gt; import B<br>&gt;&gt; extension Y : private P {<br>&gt;&gt;   typealias A = Double<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; public func g(x: Any) {<br>&gt;&gt;   if let y = x as? X&lt;Y&gt; { /* do we get here? */ }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // Module E<br>&gt;&gt; import A<br>&gt;&gt; import B<br>&gt;&gt; import C<br>&gt;&gt; import D<br>&gt;&gt; g(f())<br>&gt;&gt; <br>&gt;&gt; It’s not that we can’t make this behave correctly—the answer is “no”, we don’t get into the “then” block, because modules D and E effectively have different types X&lt;Y&gt; due to the differing conformances—but that making this behave correctly has a nontrivial runtime cost (uniquing via protocol conformances) and can cause major confusion (wait, X&lt;Y&gt; isn’t a single thing?), for what I suspect is a fairly rare occurrence.<br>&gt; <br>&gt; Yeah, I suspect the overlap of dynamic casting and use cases for private conformances is small, so it seems unfortunate to me to hobble the language around the needs of dynamic casts. A workable rule might be to say that private or internal conformances aren&#39;t exposed to runtime lookup, so are never found by as? casts. We could then statically reject the `as? X&lt;Y&gt;` cast here since the X&lt;Y&gt; instantiation depends on a runtime-invisible conformance.<br></p><p>It’s a workable rule. However, to me, it feels like the use cases for private conformances are sparse enough that I’d rather ban it than give it semantics that are different from those of non-private conformances. However, I’ve thought far more about the implementation challenges than about the use cases for private conformances [*].<br></p><p>	- Doug<br></p><p>[*] In my defense, that’s because I tend to think more about the other sources of multiple conformances.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160302/f8325f75/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Completing Generics] Private and multiple conformances</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March  2, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Mar 2, 2016, at 9:32 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Mar 2, 2016, at 9:12 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Mar 2, 2016, at 8:26 PM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mar 2, 2016, at 5:38 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Mar 2, 2016, at 5:22 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Private conformances <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Right now, a protocol conformance can be no less visible than the minimum of the conforming type’s access and the protocol’s access. Therefore, a public type conforming to a public protocol must provide the conformance publicly. One could imagine removing that restriction, so that one could introduce a private conformance:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; public protocol P { }<br>&gt;&gt;&gt;&gt;&gt; public struct X { }<br>&gt;&gt;&gt;&gt;&gt; extension X : internal P { … } // X conforms to P, but only within this module<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The main problem with private conformances is the interaction with dynamic casting. If I have this code:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func foo(value: Any) {<br>&gt;&gt;&gt;&gt;&gt;   if let x = value as? P { print(“P”) }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; foo(X())<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Under what circumstances should it print “P”? If foo() is defined within the same module as the conformance of X to P? If the call is defined within the same module as the conformance of X to P? Never? Either of the first two answers requires significant complications in the dynamic casting infrastructure to take into account the module in which a particular dynamic cast occurred (the first option) or where an existential was formed (the second option), while the third answer breaks the link between the static and dynamic type systems—none of which is an acceptable result.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You don&#39;t need private conformances to introduce these coherence problems with dynamic casting. You only need two modules that independently extend a common type to conform to a common protocol. As Jordan discussed in his resilience manifesto, a publicly-subclassable base class that adopts a new protocol has the potential to create a conflicting conformance with external subclasses that may have already adopted that protocol. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Right, multiple conformances do happen in our current model. Personally, I think that the occurrence of multiple conformances should effectively be an error at runtime unless the conformances are effectively identical (same type witnesses with the same conformances may be a reasonable approximation), and even then it’s worthy of a diagnostic as early as we can produce one, because the amount of infrastructure one needs to handle multiple conformances is significant.<br>&gt;&gt; <br>&gt;&gt; If it&#39;s a runtime error, that&#39;s a huge resilience liability, since any library adding a conformance would potentially be causing its users to start crashing at load time.<br>&gt; <br>&gt; My hope is that we could limit the failure mode to the case where the conflicting conformances are different in a way that affects soundness, e.g., different type witnesses for the same associated type.<br></p><p>I don&#39;t think we can reliably tell. As currently implemented, we generate a fresh set of witness thunks for every conformance, so the function pointers in the two modules&#39; conformances would look different to the runtime.<br></p><p>&gt; I certainly agree that we’re creating both a resilience liability and a liability when composing libraries (the author of library E below did nothing wrong, but observes weird behavior), but the alternatives seem so much worse.<br></p><p>The only place I can see where we rely on coherence is in the runtime, as you&#39;ve mentioned. We&#39;re pretty good about statically maintaining conformance identity through the stack, so we ought to be able to catch static conformance mismatches in types and maybe even give reasonable error messages. It wouldn&#39;t be hard for the runtime to notice when it has a key collision in its conformance table and log a warning either—that would be consistent with what the ObjC runtime does with class or category collisions between images.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160302/1420a1f5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Completing Generics] Private and multiple conformances</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>March  2, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Mar 2, 2016, at 9:42 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Mar 2, 2016, at 9:32 PM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Mar 2, 2016, at 9:12 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mar 2, 2016, at 8:26 PM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Mar 2, 2016, at 5:38 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Mar 2, 2016, at 5:22 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Private conformances <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Right now, a protocol conformance can be no less visible than the minimum of the conforming type’s access and the protocol’s access. Therefore, a public type conforming to a public protocol must provide the conformance publicly. One could imagine removing that restriction, so that one could introduce a private conformance:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; public protocol P { }<br>&gt;&gt;&gt;&gt;&gt;&gt; public struct X { }<br>&gt;&gt;&gt;&gt;&gt;&gt; extension X : internal P { … } // X conforms to P, but only within this module<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The main problem with private conformances is the interaction with dynamic casting. If I have this code:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func foo(value: Any) {<br>&gt;&gt;&gt;&gt;&gt;&gt;   if let x = value as? P { print(“P”) }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; foo(X())<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Under what circumstances should it print “P”? If foo() is defined within the same module as the conformance of X to P? If the call is defined within the same module as the conformance of X to P? Never? Either of the first two answers requires significant complications in the dynamic casting infrastructure to take into account the module in which a particular dynamic cast occurred (the first option) or where an existential was formed (the second option), while the third answer breaks the link between the static and dynamic type systems—none of which is an acceptable result.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; You don&#39;t need private conformances to introduce these coherence problems with dynamic casting. You only need two modules that independently extend a common type to conform to a common protocol. As Jordan discussed in his resilience manifesto, a publicly-subclassable base class that adopts a new protocol has the potential to create a conflicting conformance with external subclasses that may have already adopted that protocol. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Right, multiple conformances do happen in our current model. Personally, I think that the occurrence of multiple conformances should effectively be an error at runtime unless the conformances are effectively identical (same type witnesses with the same conformances may be a reasonable approximation), and even then it’s worthy of a diagnostic as early as we can produce one, because the amount of infrastructure one needs to handle multiple conformances is significant.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If it&#39;s a runtime error, that&#39;s a huge resilience liability, since any library adding a conformance would potentially be causing its users to start crashing at load time.<br>&gt;&gt; <br>&gt;&gt; My hope is that we could limit the failure mode to the case where the conflicting conformances are different in a way that affects soundness, e.g., different type witnesses for the same associated type.<br>&gt; <br>&gt; I don&#39;t think we can reliably tell. As currently implemented, we generate a fresh set of witness thunks for every conformance, so the function pointers in the two modules&#39; conformances would look different to the runtime.<br></p><p>I was thinking we only “have” to compare the type witnesses and any conformances they carry with them, because that’s what we need to ensure type soundness.<br></p><p>&gt;&gt; I certainly agree that we’re creating both a resilience liability and a liability when composing libraries (the author of library E below did nothing wrong, but observes weird behavior), but the alternatives seem so much worse.<br>&gt; <br>&gt; The only place I can see where we rely on coherence is in the runtime, as you&#39;ve mentioned. We&#39;re pretty good about statically maintaining conformance identity through the stack, so we ought to be able to catch static conformance mismatches in types and maybe even give reasonable error messages. It wouldn&#39;t be hard for the runtime to notice when it has a key collision in its conformance table and log a warning either—that would be consistent with what the ObjC runtime does with class or category collisions between images.<br></p><p>Right. My concern is that, in the case where we’ve lost soundness, we need to trap to avoid introducing undefined behavior. Perhaps I’m worrying overmuch.<br></p><p>	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160302/82934731/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Completing Generics] Private and multiple conformances</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March  3, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Mar 2, 2016, at 10:10 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Mar 2, 2016, at 9:42 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Mar 2, 2016, at 9:32 PM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mar 2, 2016, at 9:12 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Mar 2, 2016, at 8:26 PM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Mar 2, 2016, at 5:38 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 2, 2016, at 5:22 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Private conformances <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Right now, a protocol conformance can be no less visible than the minimum of the conforming type’s access and the protocol’s access. Therefore, a public type conforming to a public protocol must provide the conformance publicly. One could imagine removing that restriction, so that one could introduce a private conformance:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; public protocol P { }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; public struct X { }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; extension X : internal P { … } // X conforms to P, but only within this module<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The main problem with private conformances is the interaction with dynamic casting. If I have this code:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; func foo(value: Any) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   if let x = value as? P { print(“P”) }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; foo(X())<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Under what circumstances should it print “P”? If foo() is defined within the same module as the conformance of X to P? If the call is defined within the same module as the conformance of X to P? Never? Either of the first two answers requires significant complications in the dynamic casting infrastructure to take into account the module in which a particular dynamic cast occurred (the first option) or where an existential was formed (the second option), while the third answer breaks the link between the static and dynamic type systems—none of which is an acceptable result.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; You don&#39;t need private conformances to introduce these coherence problems with dynamic casting. You only need two modules that independently extend a common type to conform to a common protocol. As Jordan discussed in his resilience manifesto, a publicly-subclassable base class that adopts a new protocol has the potential to create a conflicting conformance with external subclasses that may have already adopted that protocol. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Right, multiple conformances do happen in our current model. Personally, I think that the occurrence of multiple conformances should effectively be an error at runtime unless the conformances are effectively identical (same type witnesses with the same conformances may be a reasonable approximation), and even then it’s worthy of a diagnostic as early as we can produce one, because the amount of infrastructure one needs to handle multiple conformances is significant.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If it&#39;s a runtime error, that&#39;s a huge resilience liability, since any library adding a conformance would potentially be causing its users to start crashing at load time.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My hope is that we could limit the failure mode to the case where the conflicting conformances are different in a way that affects soundness, e.g., different type witnesses for the same associated type.<br>&gt;&gt; <br>&gt;&gt; I don&#39;t think we can reliably tell. As currently implemented, we generate a fresh set of witness thunks for every conformance, so the function pointers in the two modules&#39; conformances would look different to the runtime.<br>&gt; <br>&gt; I was thinking we only “have” to compare the type witnesses and any conformances they carry with them, because that’s what we need to ensure type soundness.<br>&gt; <br>&gt;&gt;&gt; I certainly agree that we’re creating both a resilience liability and a liability when composing libraries (the author of library E below did nothing wrong, but observes weird behavior), but the alternatives seem so much worse.<br>&gt;&gt; <br>&gt;&gt; The only place I can see where we rely on coherence is in the runtime, as you&#39;ve mentioned. We&#39;re pretty good about statically maintaining conformance identity through the stack, so we ought to be able to catch static conformance mismatches in types and maybe even give reasonable error messages. It wouldn&#39;t be hard for the runtime to notice when it has a key collision in its conformance table and log a warning either—that would be consistent with what the ObjC runtime does with class or category collisions between images.<br>&gt; <br>&gt; Right. My concern is that, in the case where we’ve lost soundness, we need to trap to avoid introducing undefined behavior. Perhaps I’m worrying overmuch.<br></p><p>I don&#39;t think we&#39;d introduce undefined behavior. We&#39;d have dynamic casts that fail for hard-to-explain reasons, at worst.<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160303/c7003d21/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Manifesto] Completing Generics</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March  2, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Mar 2, 2016, at 5:22 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; *Generalized existentials<br>&gt; <br>&gt; The restrictions on existential types came from an implementation limitation, but it is reasonable to allow a value of protocol type even when the protocol has Self constraints or associated types. For example, consider IteratorProtocol again and how it could be used as an existential:<br>&gt; <br>&gt; protocol IteratorProtocol {<br>&gt;   associatedtype Element<br>&gt;   mutating func next() -&gt; Element?<br>&gt; }<br>&gt; <br>&gt; let it: IteratorProtocol = …<br>&gt; it.next()   // if this is permitted, it could return an “Any?”, i.e., the existential that wraps the actual element<br>&gt; <br>&gt; Additionally, it is reasonable to want to constrain the associated types of an existential, e.g., “a Sequence whose element type is String” could be expressed by putting a where clause into “protocol&lt;…&gt;” or “Any&lt;…&gt;” (per “Renaming protocol&lt;…&gt; to Any&lt;…&gt;”):<br>&gt; <br>&gt; let strings: Any&lt;Sequence where .Iterator.Element == String&gt; = [“a”, “b”, “c”]<br>&gt; <br>&gt; The leading “.” indicates that we’re talking about the dynamic type, i.e., the “Self” type that’s conforming to the Sequence protocol. There’s no reason why we cannot support arbitrary “where” clauses within the “Any&lt;…&gt;”. This very-general syntax is a bit unwieldy, but common cases can easily be wrapped up in a generic typealias (see the section “Generic typealiases” above):<br>&gt; <br>&gt; typealias AnySequence&lt;Element&gt; = Any&lt;Sequence where .Iterator.Element == Element&gt;<br>&gt; let strings: AnySequence&lt;String&gt; = [“a”, “b”, “c”]<br></p><p>Something else to consider: Maybe we should require Any&lt;...&gt; to refer to all existential types, including single-protocol existentials (so you&#39;d have to say var x: Any&lt;Drawable&gt; instead of var x: Drawable). Between static method requirements, init requirements, and contravariant self and associated type constraints, there are a lot of ways our protocols can diverge in their capabilities as constraints and dynamic types. And with resilience, *no* public protocol type can be assumed to resilient implicitly conform to its protocol, since new versions may introduce new requirements that break the self-conformance. If protocols are namespaced separately from types, you could still do something like:<br></p><p>typealias Drawable: Drawable = Any&lt;Drawable&gt;<br></p><p>if you intend to use the protocol type primarily as a dynamic type (and assert that it&#39;s self-conforming).<br></p><p>&gt; Opening existentials<br>&gt; <br>&gt; Generalized existentials as described above will still have trouble with protocol requirements that involve Self or associated types in function parameters. For example, let’s try to use Equatable as an existential:<br>&gt; <br>&gt; protocol Equatable {<br>&gt;   func ==(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;   func !=(lhs: Self, rhs: Self) -&gt; Bool<br>&gt; }<br>&gt; <br>&gt; let e1: Equatable = …<br>&gt; let e2: Equatable = …<br>&gt; if e1 == e2 { … } // error: e1 and e2 don’t necessarily have the same dynamic type<br>&gt; <br>&gt; One explicit way to allow such operations in a type-safe manner is to introduce an “open existential” operation of some sort, which extracts and gives a name to the dynamic type stored inside an existential. For example:<br>&gt; <br>&gt; 	 <br>&gt; if let storedInE1 = e1 openas T {     // T is a the type of storedInE1, a copy of the value stored in e1<br>&gt;   if let storedInE2 = e2 as? T {      // is e2 also a T?<br>&gt;     if storedInE1 == storedInE2 { … } // okay: storedInT1 and storedInE2 are both of type T, which we know is Equatable<br>&gt;   }<br>&gt; }<br></p><p>Another possibility here is to allow for path-dependent types based on a &#39;let&#39; binding:<br></p><p>let e1: Any&lt;Equatable&gt; = ...<br>let e2: Any&lt;Equatable&gt; = ...<br>// Is e2 the same static type as e1?<br>if let e3 = e2 as? e1.Self {<br>  return e1 == e3<br>}<br></p><p>let s1: Any&lt;Sequence&gt; = ...<br>let s2: Any&lt;Sequence&gt; = ...<br>// Are the sequences of the same type? If so, concatenate them.<br>var x: [s1.Element] = []<br>if let s3 = s2 as? Any&lt;Sequence where Element == s1.Element&gt; {<br>  x += s1<br>  x += s3<br>}<br></p><p>A close kin to angle-bracket blindness is type variable blindness. It&#39;d be nice to avoid having to introduce explicit local type variables.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160302/8e009637/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Manifesto] Completing Generics</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March  2, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Mar 2, 2016, at 5:50 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; If protocols are namespaced separately from types, you could still do something like:<br>&gt; <br>&gt; typealias Drawable: Drawable = Any&lt;Drawable&gt;<br>&gt; <br>&gt; if you intend to use the protocol type primarily as a dynamic type (and assert that it&#39;s self-conforming).<br></p><p>…and along similar lines, you might also want to extend an existential type to conform to itself (or other protocols) when it doesn&#39;t naturally do so by type erasure. For instance, the `Any*Collection` want to type-erase their contained collection&#39;s associated Index type; this is statically unsound since the Index requirement in Collection is contravariant, but is allowed by the dynamic semantics of Index, which require as a precondition that indexes only be applied to their originating collection. There&#39;s also our oft-lamented inability to have heterogeneous Sets of protocol type; if you could extend an existential to conform to Hashable, instead of forcing the protocol to refine Hashable, that would give you the ability to use it with Set in the obvious way.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160302/93238f27/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Manifesto] Completing Generics</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>March  2, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Mar 2, 2016, at 5:50 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 2, 2016, at 5:22 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; *Generalized existentials<br>&gt;&gt; <br>&gt;&gt; The restrictions on existential types came from an implementation limitation, but it is reasonable to allow a value of protocol type even when the protocol has Self constraints or associated types. For example, consider IteratorProtocol again and how it could be used as an existential:<br>&gt;&gt; <br>&gt;&gt; protocol IteratorProtocol {<br>&gt;&gt;   associatedtype Element<br>&gt;&gt;   mutating func next() -&gt; Element?<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let it: IteratorProtocol = …<br>&gt;&gt; it.next()   // if this is permitted, it could return an “Any?”, i.e., the existential that wraps the actual element<br>&gt;&gt; <br>&gt;&gt; Additionally, it is reasonable to want to constrain the associated types of an existential, e.g., “a Sequence whose element type is String” could be expressed by putting a where clause into “protocol&lt;…&gt;” or “Any&lt;…&gt;” (per “Renaming protocol&lt;…&gt; to Any&lt;…&gt;”):<br>&gt;&gt; <br>&gt;&gt; let strings: Any&lt;Sequence where .Iterator.Element == String&gt; = [“a”, “b”, “c”]<br>&gt;&gt; <br>&gt;&gt; The leading “.” indicates that we’re talking about the dynamic type, i.e., the “Self” type that’s conforming to the Sequence protocol. There’s no reason why we cannot support arbitrary “where” clauses within the “Any&lt;…&gt;”. This very-general syntax is a bit unwieldy, but common cases can easily be wrapped up in a generic typealias (see the section “Generic typealiases” above):<br>&gt;&gt; <br>&gt;&gt; typealias AnySequence&lt;Element&gt; = Any&lt;Sequence where .Iterator.Element == Element&gt;<br>&gt;&gt; let strings: AnySequence&lt;String&gt; = [“a”, “b”, “c”]<br>&gt; <br>&gt; Something else to consider: Maybe we should require Any&lt;...&gt; to refer to all existential types, including single-protocol existentials (so you&#39;d have to say var x: Any&lt;Drawable&gt; instead of var x: Drawable). Between static method requirements, init requirements, and contravariant self and associated type constraints, there are a lot of ways our protocols can diverge in their capabilities as constraints and dynamic types. And with resilience, *no* public protocol type can be assumed to resilient implicitly conform to its protocol, since new versions may introduce new requirements that break the self-conformance. If protocols are namespaced separately from types, you could still do something like:<br>&gt; <br>&gt; typealias Drawable: Drawable = Any&lt;Drawable&gt;<br>&gt; <br>&gt; if you intend to use the protocol type primarily as a dynamic type (and assert that it&#39;s self-conforming).<br></p><p>Yes, that’s a good point: making the use of existential types more intentional might make the distinction between generics capabilities and existential capabilities clearer, and make the transition to “Any&lt;…&gt;” less jarring.<br></p><p>Also, I completely skipped discussions of self-conformance and its impact on the generic/existential interaction.<br></p><p>&gt; <br>&gt;&gt; Opening existentials<br>&gt;&gt; <br>&gt;&gt; Generalized existentials as described above will still have trouble with protocol requirements that involve Self or associated types in function parameters. For example, let’s try to use Equatable as an existential:<br>&gt;&gt; <br>&gt;&gt; protocol Equatable {<br>&gt;&gt;   func ==(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;   func !=(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let e1: Equatable = …<br>&gt;&gt; let e2: Equatable = …<br>&gt;&gt; if e1 == e2 { … } // error: e1 and e2 don’t necessarily have the same dynamic type<br>&gt;&gt; <br>&gt;&gt; One explicit way to allow such operations in a type-safe manner is to introduce an “open existential” operation of some sort, which extracts and gives a name to the dynamic type stored inside an existential. For example:<br>&gt;&gt; <br>&gt;&gt; 	 <br>&gt;&gt; if let storedInE1 = e1 openas T {     // T is a the type of storedInE1, a copy of the value stored in e1<br>&gt;&gt;   if let storedInE2 = e2 as? T {      // is e2 also a T?<br>&gt;&gt;     if storedInE1 == storedInE2 { … } // okay: storedInT1 and storedInE2 are both of type T, which we know is Equatable<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt; <br>&gt; Another possibility here is to allow for path-dependent types based on a &#39;let&#39; binding:<br>&gt; <br>&gt; let e1: Any&lt;Equatable&gt; = ...<br>&gt; let e2: Any&lt;Equatable&gt; = ...<br>&gt; // Is e2 the same static type as e1?<br>&gt; if let e3 = e2 as? e1.Self {<br>&gt;   return e1 == e3<br>&gt; }<br>&gt; <br>&gt; let s1: Any&lt;Sequence&gt; = ...<br>&gt; let s2: Any&lt;Sequence&gt; = ...<br>&gt; // Are the sequences of the same type? If so, concatenate them.<br>&gt; var x: [s1.Element] = []<br>&gt; if let s3 = s2 as? Any&lt;Sequence where Element == s1.Element&gt; {<br>&gt;   x += s1<br>&gt;   x += s3<br>&gt; }<br>&gt; <br>&gt; A close kin to angle-bracket blindness is type variable blindness. It&#39;d be nice to avoid having to introduce explicit local type variables.<br></p><p>Yeah. I love that this eliminates the ugly “openas” operation and its inherent scoping. I think developers will understand the need to pull a value into a let binding, operate on it, then push it back rather than working with the nested types of a variable directly.<br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160302/3636ea80/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Completing Generics] Any&lt;&gt; syntax, base class constraints, and existential metatypes</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March  4, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Mar 2, 2016, at 5:50 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Something else to consider: Maybe we should require Any&lt;...&gt; to refer to all existential types, including single-protocol existentials (so you&#39;d have to say var x: Any&lt;Drawable&gt; instead of var x: Drawable). Between static method requirements, init requirements, and contravariant self and associated type constraints, there are a lot of ways our protocols can diverge in their capabilities as constraints and dynamic types. And with resilience, *no* public protocol type can be assumed to resilient implicitly conform to its protocol, since new versions may introduce new requirements that break the self-conformance. If protocols are namespaced separately from types, you could still do something like:<br>&gt; <br>&gt; typealias Drawable: Drawable = Any&lt;Drawable&gt;<br>&gt; <br>&gt; if you intend to use the protocol type primarily as a dynamic type (and assert that it&#39;s self-conforming).<br></p><p>Any&lt;&gt; syntax also allows for a few useful extensions and syntax refinements:<br></p><p>- We could gain back the often-missed ability from ObjC to express a type that both inherits a base class and implements a protocol, spelling that Any&lt;BaseClass, Protocol&gt;. That&#39;s less weird than using protocol&lt;...&gt; to refer to class constraints.<br>- We can make our syntax for existential metatypes (some dynamic type that conforms to P, &quot;exists T: P. (T.Type)&quot;) and metatypes-of-existentials (the exact type of the existential, &quot;(exists T: P. T).Type&quot;. Currently we spell the former as `P.Type` and the latter as `P.Protocol`, and people writing generics occasionally get caught out when substituting `T = P` into `T.Type` gives them `P.Protocol`. It would make sense to me to put `.Type` inside the Any&lt;&gt; brackets for existential metatypes, Any&lt;P.Type&gt; (today&#39;s P.Type), and have Any&lt;P&gt;.Type refer to the exact type `Any&lt;P&gt;` (today&#39;s P.Protocol).<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160304/12dc3512/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ece55ca3fe50dca9c70bcd914acb48a5?s=50"></div><header><strong>[Completing Generics] Any&lt;&gt; syntax, base class constraints, and existential metatypes</strong> from <string>Matthew Judge</string> &lt;matthew.judge at gmail.com&gt;<p>March  5, 2016 at 10:00:00am</p></header><div class="content"><p>I may be a bit off in my thinking here, but extension P vs. extension Any&lt;P&gt; seems like it might offer a pretty straightforward implementation (at least syntactically and conceptually) for static vs. dynamic dispatch.<br></p><p><br>&gt; On Mar 4, 2016, at 14:16, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 2, 2016, at 5:50 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Something else to consider: Maybe we should require Any&lt;...&gt; to refer to all existential types, including single-protocol existentials (so you&#39;d have to say var x: Any&lt;Drawable&gt; instead of var x: Drawable). Between static method requirements, init requirements, and contravariant self and associated type constraints, there are a lot of ways our protocols can diverge in their capabilities as constraints and dynamic types. And with resilience, *no* public protocol type can be assumed to resilient implicitly conform to its protocol, since new versions may introduce new requirements that break the self-conformance. If protocols are namespaced separately from types, you could still do something like:<br>&gt;&gt; <br>&gt;&gt; typealias Drawable: Drawable = Any&lt;Drawable&gt;<br>&gt;&gt; <br>&gt;&gt; if you intend to use the protocol type primarily as a dynamic type (and assert that it&#39;s self-conforming).<br>&gt; <br>&gt; Any&lt;&gt; syntax also allows for a few useful extensions and syntax refinements:<br>&gt; <br>&gt; - We could gain back the often-missed ability from ObjC to express a type that both inherits a base class and implements a protocol, spelling that Any&lt;BaseClass, Protocol&gt;. That&#39;s less weird than using protocol&lt;...&gt; to refer to class constraints.<br>&gt; - We can make our syntax for existential metatypes (some dynamic type that conforms to P, &quot;exists T: P. (T.Type)&quot;) and metatypes-of-existentials (the exact type of the existential, &quot;(exists T: P. T).Type&quot;. Currently we spell the former as `P.Type` and the latter as `P.Protocol`, and people writing generics occasionally get caught out when substituting `T = P` into `T.Type` gives them `P.Protocol`. It would make sense to me to put `.Type` inside the Any&lt;&gt; brackets for existential metatypes, Any&lt;P.Type&gt; (today&#39;s P.Type), and have Any&lt;P&gt;.Type refer to the exact type `Any&lt;P&gt;` (today&#39;s P.Protocol).<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160305/b15f1bf8/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[Manifesto] Completing Generics</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>March  2, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; Existentials<br>&gt; <br>&gt; Opening existentials<br>&gt; <br>&gt; Generalized existentials as described above will still have trouble with protocol requirements that involve Self or associated types in function parameters. For example, let’s try to use Equatable as an existential:<br>&gt; <br>&gt; protocol Equatable {<br>&gt;   func ==(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;   func !=(lhs: Self, rhs: Self) -&gt; Bool<br>&gt; }<br>&gt; <br>&gt; let e1: Equatable = …<br>&gt; let e2: Equatable = …<br>&gt; if e1 == e2 { … } // error: e1 and e2 don’t necessarily have the same dynamic type<br>&gt; <br>&gt; One explicit way to allow such operations in a type-safe manner is to introduce an “open existential” operation of some sort, which extracts and gives a name to the dynamic type stored inside an existential. For example:<br>&gt; <br>&gt; 	 <br>&gt; if let storedInE1 = e1 openas T {     // T is a the type of storedInE1, a copy of the value stored in e1<br>&gt;   if let storedInE2 = e2 as? T {      // is e2 also a T?<br>&gt;     if storedInE1 == storedInE2 { … } // okay: storedInT1 and storedInE2 are both of type T, which we know is Equatable<br>&gt;   }<br>&gt; }<br></p><p>Isn&#39;t &quot;open existential&quot; code for &quot;casting ∃ to ∀&quot;? Dispatch on the underlying type is brittle and anti-modular.  I should know, I tried to recover GADTs under the old system!  I shudder to think of what further horrors I could concoct with this pattern formalized in the language.<br></p><p>~ Robert Widmann<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160302/57ad145c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Manifesto] Completing Generics</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March  2, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Mar 2, 2016, at 7:57 PM, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Existentials<br>&gt;&gt; <br>&gt;&gt; Opening existentials<br>&gt;&gt; <br>&gt;&gt; Generalized existentials as described above will still have trouble with protocol requirements that involve Self or associated types in function parameters. For example, let’s try to use Equatable as an existential:<br>&gt;&gt; <br>&gt;&gt; protocol Equatable {<br>&gt;&gt;   func ==(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;   func !=(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let e1: Equatable = …<br>&gt;&gt; let e2: Equatable = …<br>&gt;&gt; if e1 == e2 { … } // error: e1 and e2 don’t necessarily have the same dynamic type<br>&gt;&gt; <br>&gt;&gt; One explicit way to allow such operations in a type-safe manner is to introduce an “open existential” operation of some sort, which extracts and gives a name to the dynamic type stored inside an existential. For example:<br>&gt;&gt; <br>&gt;&gt; 	 <br>&gt;&gt; if let storedInE1 = e1 openas T {     // T is a the type of storedInE1, a copy of the value stored in e1<br>&gt;&gt;   if let storedInE2 = e2 as? T {      // is e2 also a T?<br>&gt;&gt;     if storedInE1 == storedInE2 { … } // okay: storedInT1 and storedInE2 are both of type T, which we know is Equatable<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt; <br>&gt; Isn&#39;t &quot;open existential&quot; code for &quot;casting ∃ to ∀&quot;? Dispatch on the underlying type is brittle and anti-modular.<br></p><p>I&#39;m not sure exactly what you&#39;re referring to, but our existential type representation captures the type and protocol conformance metadata that was statically available when the existential value was constructed, so I don&#39;t think there&#39;s a modularity problem. This operation would rebind that metadata to a type conforming to the protocol in the scope where the type binding is introduced.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160302/7e8744e3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[Manifesto] Completing Generics</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>March  2, 2016 at 11:00:00pm</p></header><div class="content"><p>Anti-modular as in it requires intimate knowledge of the underlying types and isn&#39;t trivially extensible.  For example, the GADT thing was essentially a sealed hierarchy where each instance of the common protocol declared a constructor and parameters.  Methods dispatched by casting as here.  Difference is, Swift was able to, rightly, complain about certain twisty casts, especially generic ones, being invalid under that scheme.  I&#39;m worried this will introduce a new type variable and allow the user to arbitrarily &quot;bind&quot; it by special casing like that.  Unless I&#39;m misunderstanding something about the original example.<br></p><p>~Robert Widmann<br></p><p>2016/03/02 23:22、Joe Groff &lt;jgroff at apple.com&gt; のメッセージ:<br></p><p>&gt; <br>&gt;&gt;&gt; On Mar 2, 2016, at 7:57 PM, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Existentials<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Opening existentials<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Generalized existentials as described above will still have trouble with protocol requirements that involve Self or associated types in function parameters. For example, let’s try to use Equatable as an existential:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol Equatable {<br>&gt;&gt;&gt;   func ==(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;&gt;   func !=(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let e1: Equatable = …<br>&gt;&gt;&gt; let e2: Equatable = …<br>&gt;&gt;&gt; if e1 == e2 { … } // error: e1 and e2 don’t necessarily have the same dynamic type<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One explicit way to allow such operations in a type-safe manner is to introduce an “open existential” operation of some sort, which extracts and gives a name to the dynamic type stored inside an existential. For example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	 <br>&gt;&gt;&gt; if let storedInE1 = e1 openas T {     // T is a the type of storedInE1, a copy of the value stored in e1<br>&gt;&gt;&gt;   if let storedInE2 = e2 as? T {      // is e2 also a T?<br>&gt;&gt;&gt;     if storedInE1 == storedInE2 { … } // okay: storedInT1 and storedInE2 are both of type T, which we know is Equatable<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Isn&#39;t &quot;open existential&quot; code for &quot;casting ∃ to ∀&quot;? Dispatch on the underlying type is brittle and anti-modular.<br>&gt; <br>&gt; I&#39;m not sure exactly what you&#39;re referring to, but our existential type representation captures the type and protocol conformance metadata that was statically available when the existential value was constructed, so I don&#39;t think there&#39;s a modularity problem. This operation would rebind that metadata to a type conforming to the protocol in the scope where the type binding is introduced.<br>&gt; <br>&gt; -Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160302/24c9723d/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>[Manifesto] Completing Generics</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>March  2, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Mar 2, 2016, at 7:57 PM, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Isn&#39;t &quot;open existential&quot; code for &quot;casting ∃ to ∀&quot;? Dispatch on the underlying type is brittle and anti-modular.  I should know, I tried to recover GADTs under the old system!  I shudder to think of what further horrors I could concoct with this pattern formalized in the language.<br></p><p>Think of it more as “casting P to a new generic type parameter T : P”, where P is a protocol type. Your code will not have static knowledge of the concrete type bound to T — you just know it’s some type that conforms to P.<br></p><p>It’s interesting that protocol extensions today get you some of the way there — the existential is effectively opened to a special generic type parameter “Self&quot; inside the body of a protocol extension method:<br></p><p>protocol P {<br>	…<br>}<br></p><p>func doSomething&lt;T : P&gt;(t: T) {<br>	… do stuff with T<br>}<br></p><p>extension P {<br>	func doSomething() {<br>		doSomething(self)<br>	}<br>}<br></p><p>let p: P = …<br>p.doSomething()<br></p><p>Slava<br></p><p>&gt; <br>&gt; ~ Robert Widmann<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7ba3c93f9350613c243eeb87c602935e?s=50"></div><header><strong>[Manifesto] Completing Generics</strong> from <string>David Smith</string> &lt;david_smith at apple.com&gt;<p>March  2, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Mar 2, 2016, at 5:22 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; Introduction<br>&gt; <br>&gt; The “Complete Generics” goal for Swift 3 has been fairly ill-defined thus fair, with just this short blurb in the list of goals:<br>&gt; <br>&gt; Complete generics: Generics are used pervasively in a number of Swift libraries, especially the standard library. However, there are a number of generics features the standard library requires to fully realize its vision, including recursive protocol constraints, the ability to make a constrained extension conform to a new protocol (i.e., an array of Equatable elements is Equatable), and so on. Swift 3.0 should provide those generics features needed by the standard library, because they affect the standard library&#39;s ABI.<br>&gt; This message expands upon the notion of “completing generics”. It is not a plan for Swift 3, nor an official core team communication, but it collects the results of numerous discussions among the core team and Swift developers, both of the compiler and the standard library. I hope to achieve several things:<br>&gt; <br>&gt; Communicate a vision for Swift generics, building on the original generics design document &lt;https://github.com/apple/swift/blob/master/docs/Generics.rst&gt;, so we have something concrete and comprehensive to discuss.<br>&gt; Establish some terminology that the Swift developers have been using for these features, so our discussions can be more productive (“oh, you’re proposing what we refer to as ‘conditional conformances’; go look over at this thread”).<br>&gt; Engage more of the community in discussions of specific generics features, so we can coalesce around designs for public review. And maybe even get some of them implemented.<br>&gt; <br>&gt; A message like this can easily turn into a centithread &lt;http://www.urbandictionary.com/define.php?term=centithread&gt;. To separate concerns in our discussion, I ask that replies to this specific thread be limited to discussions of the vision as a whole: how the pieces fit together, what pieces are missing, whether this is the right long-term vision for Swift, and so on. For discussions of specific language features, e.g., to work out the syntax and semantics of conditional conformances or discuss the implementation in compiler or use in the standard library, please start a new thread based on the feature names I’m using.<br>&gt; <br>&gt; This message covers a lot of ground; I’ve attempted a rough categorization of the various features, and kept the descriptions brief to limit the overall length. Most of these aren’t my ideas, and any syntax I’m providing is simply a way to express these ideas in code and is subject to change. Not all of these features will happen, either soon or ever, but they are intended to be a fairly complete whole that should mesh together. I’ve put a * next to features that I think are important in the nearer term vs. being interesting “some day”. Mostly, the *’s reflect features that will have a significant impact on the Swift standard library’s design and implementation.<br>&gt; <br>&gt; Enough with the disclaimers; it’s time to talk features.<br>&gt; <br>&gt; Removing unnecessary restrictions<br>&gt; <br>&gt; There are a number of restrictions to the use of generics that fall out of the implementation in the Swift compiler. Removal of these restrictions is a matter of implementation only; one need not introduce new syntax or semantics to realize them. I’m listing them for two reasons: first, it’s an acknowledgment that these features are intended to exist in the model we have today, and, second, we’d love help with the implementation of these features.<br>&gt; <br>&gt; <br>&gt; *Recursive protocol constraints<br>&gt; <br>&gt; Currently, an associated type cannot be required to conform to its enclosing protocol (or any protocol that inherits that protocol). For example, in the standard library SubSequence type of a Sequence should itself be a Sequence:<br>&gt; <br>&gt; protocol Sequence {<br>&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;   …<br>&gt;   associatedtype SubSequence : Sequence   // currently ill-formed, but should be possible<br>&gt; }<br>&gt; <br>&gt; The compiler currently rejects this protocol, which is unfortunate: it effectively pushes the SubSequence-must-be-a-Sequence requirement into every consumer of SubSequence, and does not communicate the intent of this abstraction well.<br>&gt; <br>&gt; Nested generics<br>&gt; <br>&gt; Currently, a generic type cannot be nested within another generic type, e.g.<br>&gt; <br>&gt; struct X&lt;T&gt; {<br>&gt;   struct Y&lt;U&gt; { }  // currently ill-formed, but should be possible<br>&gt; }<br>&gt; <br>&gt; There isn’t much to say about this: the compiler simply needs to be improved to handle nested generics throughout.<br>&gt; <br>&gt; <br>&gt; Concrete same-type requirements<br>&gt; <br>&gt; Currently, a constrained extension cannot use a same-type constraint to make a type parameter equivalent to a concrete type. For example:<br>&gt; <br>&gt; extension Array where Element == String {<br>&gt;   func makeSentence() -&gt; String {<br>&gt;     // uppercase first string, concatenate with spaces, add a period, whatever<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; This is a highly-requested feature that fits into the existing syntax and semantics. Note that one could imagine introducing new syntax, e.g., extending “Array&lt;String&gt;”, which gets into new-feature territory: see the section on “Parameterized extensions”.<br>&gt; <br>&gt; Parameterizing other declarations<br>&gt; <br>&gt; There are a number of Swift declarations that currently cannot have generic parameters; some of those have fairly natural extensions to generic forms that maintain their current syntax and semantics, but become more powerful when made generic.<br>&gt; <br>&gt; Generic typealiases<br>&gt; <br>&gt; Typealiases could be allowed to carry generic parameters. They would still be aliases (i.e., they would not introduce new types). For example:<br>&gt; <br>&gt; typealias StringDictionary&lt;Value&gt; = Dictionary&lt;String, Value&gt;<br>&gt; <br>&gt; var d1 = StringDictionary&lt;Int&gt;()<br>&gt; var d2: Dictionary&lt;String, Int&gt; = d1 // okay: d1 and d2 have the same type, Dictionary&lt;String, Int&gt;<br>&gt; <br>&gt; <br>&gt; Generic subscripts<br>&gt; <br>&gt; Subscripts could be allowed to have generic parameters. For example, we could introduce a generic subscript on a Collection that allows us to pull out the values at an arbitrary set of indices:<br>&gt; <br>&gt; extension Collection {<br>&gt;   subscript&lt;Indices: Sequence where Indices.Iterator.Element == Index&gt;(indices: Indices) -&gt; [Iterator.Element] {<br>&gt;     get {<br>&gt;       var result = [Iterator.Element]()<br>&gt;       for index in indices {<br>&gt;         result.append(self[index])<br>&gt;       }<br>&gt; <br>&gt;       return result<br>&gt;     }<br>&gt; <br>&gt;     set {<br>&gt;       for (index, value) in zip(indices, newValue) {<br>&gt;         self[index] = value<br>&gt;       }<br>&gt;     }<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; Generic constants<br>&gt; <br>&gt; let constants could be allowed to have generic parameters, such that they produce differently-typed values depending on how they are used. For example, this is particularly useful for named literal values, e.g.,<br>&gt; <br>&gt; let π&lt;T : FloatLiteralConvertible&gt;: T = 3.141592653589793238462643383279502884197169399<br>&gt; <br>&gt; The Clang importer could make particularly good use of this when importing macros.<br>&gt; <br>&gt; <br>&gt; Parameterized extensions<br>&gt; <br>&gt; Extensions themselves could be parameterized, which would allow some structural pattern matching on types. For example, this would permit one to extend an array of optional values, e.g.,<br>&gt; <br>&gt; extension&lt;T&gt; Array where Element == T? {<br>&gt;   var someValues: [T] {<br>&gt;     var result = [T]()<br>&gt;     for opt in self {<br>&gt;       if let value = opt { result.append(value) }<br>&gt;     }<br>&gt;    return result<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; We can generalize this to a protocol extensions:<br>&gt; <br>&gt; extension&lt;T&gt; Sequence where Element == T? {<br>&gt;   var someValues: [T] {<br>&gt;     var result = [T]()<br>&gt;     for opt in self {<br>&gt;       if let value = opt { result.append(value) }<br>&gt;     }<br>&gt;    return result<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; Note that when one is extending nominal types, we could simplify the syntax somewhat to make the same-type constraint implicit in the syntax:<br>&gt; <br>&gt; extension&lt;T&gt; Array&lt;T?&gt; {<br>&gt;   var someValues: [T] {<br>&gt;     var result = [T]()<br>&gt;     for opt in self {<br>&gt;       if let value = opt { result.append(value) }<br>&gt;     }<br>&gt;    return result<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; When we’re working with concrete types, we can use that syntax to improve the extension of concrete versions of generic types (per “Concrete same-type requirements”, above), e.g.,<br>&gt; <br>&gt; extension Array&lt;String&gt; {<br>&gt;   func makeSentence() -&gt; String {<br>&gt;     // uppercase first string, concatenate with spaces, add a period, whatever<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; Minor extensions<br>&gt; <br>&gt; There are a number of minor extensions we can make to the generics system that don’t fundamentally change what one can express in Swift, but which can improve its expressivity.<br>&gt; <br>&gt; *Arbitrary requirements in protocols<br>&gt; <br>&gt; Currently, a new protocol can inherit from other protocols, introduce new associated types, and add new conformance constraints to associated types (by redeclaring an associated type from an inherited protocol). However, one cannot express more general constraints. Building on the example from “Recursive protocol constraints”, we really want the element type of a Sequence’s SubSequence to be the same as the element type of the Sequence, e.g.,<br>&gt; <br>&gt; protocol Sequence {<br>&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;   …<br>&gt;   associatedtype SubSequence : Sequence where SubSequence.Iterator.Element == Iterator.Element<br>&gt; }<br>&gt; <br>&gt; Hanging the where clause off the associated type is protocol not ideal, but that’s a discussion for another thread.<br>&gt; <br>&gt; <br>&gt; *Typealiases in protocols and protocol extensions<br>&gt; <br>&gt; Now that associated types have their own keyword (thanks!), it’s reasonable to bring back “typealias”. Again with the Sequence protocol:<br>&gt; <br>&gt; protocol Sequence {<br>&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;   typealias Element = Iterator.Element   // rejoice! now we can refer to SomeSequence.Element rather than SomeSequence.Iterator.Element<br>&gt; }<br>&gt; <br>&gt; <br>&gt; Default generic arguments <br>&gt; <br>&gt; Generic parameters could be given the ability to provide default arguments, which would be used in cases where the type argument is not specified and type inference could not determine the type argument. For example:<br>&gt; <br>&gt; public final class Promise&lt;Value, Reason=Error&gt; { … }<br>&gt; <br>&gt; func getRandomPromise() -&gt; Promise&lt;Int, ErrorProtocol&gt; { … }<br>&gt; <br>&gt; var p1: Promise&lt;Int&gt; = …<br>&gt; var p2: Promise&lt;Int, Error&gt; = p1     // okay: p1 and p2 have the same type Promise&lt;Int, Error&gt;<br>&gt; var p3: Promise = getRandomPromise() // p3 has type Promise&lt;Int, ErrorProtocol&gt; due to type inference<br>&gt; <br>&gt; <br>&gt; Generalized “class” constraints<br>&gt; <br>&gt; The “class” constraint can currently only be used for defining protocols. We could generalize it to associated type and type parameter declarations, e.g.,<br>&gt; <br>&gt; protocol P {<br>&gt;   associatedtype A : class<br>&gt; }<br>&gt; <br>&gt; func foo&lt;T : class&gt;(t: T) { }<br>&gt; <br>&gt; As part of this, the magical AnyObject protocol could be replaced with an existential with a class bound, so that it becomes a typealias:<br>&gt; <br>&gt; typealias AnyObject = protocol&lt;class&gt;<br>&gt; <br>&gt; See the “Existentials” section, particularly “Generalized existentials”, for more information.<br>&gt; <br>&gt; <br>&gt; *Allowing subclasses to override requirements satisfied by defaults<br>&gt; <br>&gt; When a superclass conforms to a protocol and has one of the protocol’s requirements satisfied by a member of a protocol extension, that member currently cannot be overridden by a subclass. For example:<br>&gt; <br>&gt; protocol P {<br>&gt;   func foo()<br>&gt; }<br>&gt; <br>&gt; extension P {<br>&gt;   func foo() { print(“P”) }<br>&gt; }<br>&gt; <br>&gt; class C : P {<br>&gt;   // gets the protocol extension’s <br>&gt; }<br>&gt; <br>&gt; class D : C {<br>&gt;   /*override not allowed!*/ func foo() { print(“D”) }<br>&gt; }<br>&gt; <br>&gt; let p: P = D()<br>&gt; p.foo() // gotcha: prints “P” rather than “D”!<br>&gt; <br>&gt; D.foo should be required to specify “override” and should be called dynamically.<br>&gt; <br>&gt; <br>&gt; Major extensions to the generics model<br>&gt; <br>&gt; Unlike the minor extensions, major extensions to the generics model provide more expressivity in the Swift generics system and, generally, have a much more significant design and implementation cost.<br>&gt; <br>&gt; <br>&gt; *Conditional conformances<br>&gt; <br>&gt; Conditional conformances express the notion that a generic type will conform to a particular protocol only under certain circumstances. For example, Array is Equatable only when its elements are Equatable:<br>&gt; <br>&gt; extension Array : Equatable where Element : Equatable { }<br>&gt; <br>&gt; func ==&lt;T : Equatable&gt;(lhs: Array&lt;T&gt;, rhs: Array&lt;T&gt;) -&gt; Bool { … }<br>&gt; <br>&gt; Conditional conformances are a potentially very powerful feature. One important aspect of this feature is how deal with or avoid overlapping conformances. For example, imagine an adaptor over a Sequence that has conditional conformances to Collection and MutableCollection:<br>&gt; <br>&gt; struct SequenceAdaptor&lt;S: Sequence&gt; : Sequence { }<br>&gt; extension SequenceAdaptor : Collection where S: Collection { … }<br>&gt; extension SequenceAdaptor : MutableCollection where S: MutableCollection { }<br>&gt; <br>&gt; This should almost certainly be permitted, but we need to cope with or reject “overlapping” conformances:<br>&gt; <br>&gt; extension SequenceAdaptor : Collection where S: SomeOtherProtocolSimilarToCollection { } // trouble: two ways for SequenceAdaptor to conform to Collection<br>&gt; <br>&gt; See the section on “Private conformances” for more about the issues with having the same type conform to the same protocol multiple times.<br>&gt; <br>&gt; <br>&gt; Variadic generics<br>&gt; <br>&gt; Currently, a generic parameter list contains a fixed number of generic parameters. If one has a type that could generalize to any number of generic parameters, the only real way to deal with it today involves creating a set of types. For example, consider the standard library’s “zip” function. It returns one of these when provided with two arguments to zip together:<br>&gt; <br>&gt; public struct Zip2Sequence&lt;Sequence1 : Sequence,<br>&gt;                            Sequence2 : Sequence&gt; : Sequence { … }<br>&gt; <br>&gt; public func zip&lt;Sequence1 : Sequence, Sequence2 : Sequence&gt;(<br>&gt;               sequence1: Sequence1, _ sequence2: Sequence2)<br>&gt;             -&gt; Zip2Sequence&lt;Sequence1, Sequence2&gt; { … }<br>&gt; <br>&gt; Supporting three arguments would require copy-paste of those of those:<br>&gt; <br>&gt; public struct Zip3Sequence&lt;Sequence1 : Sequence,<br>&gt;                            Sequence2 : Sequence,<br>&gt;                            Sequence3 : Sequence&gt; : Sequence { … }<br>&gt; <br>&gt; public func zip&lt;Sequence1 : Sequence, Sequence2 : Sequence, Sequence3 : Sequence&gt;(<br>&gt;               sequence1: Sequence1, _ sequence2: Sequence2, _ sequence3: sequence3)<br>&gt;             -&gt; Zip3Sequence&lt;Sequence1, Sequence2, Sequence3&gt; { … }<br>&gt; <br>&gt; Variadic generics would allow us to abstract over a set of generic parameters. The syntax below is hopelessly influenced by C++11 variadic templates &lt;http://www.jot.fm/issues/issue_2008_02/article2/&gt; (sorry), where putting an ellipsis (“…”) to the left of a declaration makes it a “parameter pack” containing zero or more parameters and putting an ellipsis to the right of a type/expression/etc. expands the parameter packs within that type/expression into separate arguments. The important part is that we be able to meaningfully abstract over zero or more generic parameters, e.g.:<br>&gt; <br>&gt; public struct ZipIterator&lt;... Iterators : IteratorProtocol&gt; : Iterator {  // zero or more type parameters, each of which conforms to IteratorProtocol<br>&gt;   public typealias Element = (Iterators.Element...)                       // a tuple containing the element types of each iterator in Iterators<br>&gt; <br>&gt;   var (...iterators): (Iterators...)    // zero or more stored properties, one for each type in Iterators <br>&gt;   var reachedEnd: Bool = false<br>&gt; <br>&gt;   public mutating func next() -&gt; Element? {<br>&gt;     if reachedEnd { return nil }<br>&gt; <br>&gt;     guard let values = (iterators.next()...) {   // call “next” on each of the iterators, put the results into a tuple named “values&quot;<br>&gt;       reachedEnd = true<br>&gt;       return nil<br>&gt;     }<br>&gt; <br>&gt;     return values<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; public struct ZipSequence&lt;...Sequences : Sequence&gt; : Sequence {<br>&gt;   public typealias Iterator = ZipIterator&lt;Sequences.Iterator...&gt;   // get the zip iterator with the iterator types of our Sequences<br>&gt; <br>&gt;   var (...sequences): (Sequences...)    // zero or more stored properties, one for each type in Sequences <br>&gt; <br>&gt;   // details ...<br>&gt; }<br>&gt; <br>&gt; Such a design could also work for function parameters, so we can pack together multiple function arguments with different types, e.g.,<br>&gt; <br>&gt; public func zip&lt;... Sequences : SequenceType&gt;(... sequences: Sequences...) <br>&gt;             -&gt; ZipSequence&lt;Sequences...&gt; {<br>&gt;   return ZipSequence(sequences...)<br>&gt; }<br>&gt; <br>&gt; Finally, this could tie into the discussions about a tuple “splat” operator. For example:<br>&gt; <br>&gt; func apply&lt;... Args, Result&gt;(fn: (Args...) -&gt; Result,    // function taking some number of arguments and producing Result<br>&gt;                            args: (Args...)) -&gt; Result {  // tuple of arguments<br>&gt;   return fn(args...)                                     // expand the arguments in the tuple “args” into separate arguments<br>&gt; }<br>&gt; <br>&gt; <br>&gt; Extensions of structural types<br>&gt; <br>&gt; Currently, only nominal types (classes, structs, enums, protocols) can be extended. One could imagine extending structural types—particularly tuple types—to allow them to, e.g., conform to protocols. For example, pulling together variadic generics, parameterized extensions, and conditional conformances, one could express “a tuple type is Equatable if all of its element types are Equatable”:<br>&gt; <br>&gt; extension&lt;...Elements : Equatable&gt; (Elements...) : Equatable {   // extending the tuple type “(Elements…)” to be Equatable<br>&gt; }<br>&gt; <br>&gt; There are some natural bounds here: one would need to have actual structural types. One would not be able to extend every type:<br>&gt; <br>&gt; extension&lt;T&gt; T { // error: neither a structural nor a nominal type<br>&gt; }<br>&gt; <br>&gt; And before you think you’re cleverly making it possible to have a conditional conformance that makes every type T that conforms to protocol P also conform to protocol Q, see the section &quot;Conditional conformances via protocol extensions”, below:<br>&gt; <br>&gt; extension&lt;T : P&gt; T : Q { // error: neither a structural nor a nominal type<br>&gt; }<br>&gt; <br>&gt; <br>&gt; Syntactic improvements<br>&gt; <br>&gt; There are a number of potential improvements we could make to the generics syntax. Such a list could go on for a very long time, so I’ll only highlight some obvious ones that have been discussed by the Swift developers.<br>&gt; <br>&gt; *Default implementations in protocols<br>&gt; <br>&gt; Currently, protocol members can never have implementations. We could allow one to provide such implementations to be used as the default if a conforming type does not supply an implementation, e.g.,<br>&gt; <br>&gt; protocol Bag {<br>&gt;   associatedtype Element : Equatable<br>&gt;   func contains(element: Element) -&gt; Bool<br>&gt; <br>&gt;   func containsAll&lt;S: Sequence where Sequence.Iterator.Element == Element&gt;(elements: S) -&gt; Bool {<br>&gt;     for x in elements {<br>&gt;       if contains(x) { return true }<br>&gt;     }<br>&gt;     return false<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; struct IntBag : Bag {<br>&gt;   typealias Element = Int<br>&gt;   func contains(element: Int) -&gt; Bool { ... }<br>&gt; <br>&gt;   // okay: containsAll requirement is satisfied by Bag’s default implementation<br>&gt; }<br>&gt; <br>&gt; One can get this effect with protocol extensions today, hence the classification of this feature as a (mostly) syntactic improvement:<br>&gt; <br>&gt; protocol Bag {<br>&gt;   associatedtype Element : Equatable<br>&gt;   func contains(element: Element) -&gt; Bool<br>&gt; <br>&gt;   func containsAll&lt;S: Sequence where Sequence.Iterator.Element == Element&gt;(elements: S) -&gt; Bool<br>&gt; }<br>&gt; <br>&gt; extension Bag {<br>&gt;   func containsAll&lt;S: Sequence where Sequence.Iterator.Element == Element&gt;(elements: S) -&gt; Bool {<br>&gt;     for x in elements {<br>&gt;       if contains(x) { return true }<br>&gt;     }<br>&gt;     return false<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; *Moving the where clause outside of the angle brackets<br>&gt; <br>&gt; The “where” clause of generic functions comes very early in the declaration, although it is generally of much less concern to the client than the function parameters and result type that follow it. This is one of the things that contributes to “angle bracket blindness”. For example, consider the containsAll signature above:<br>&gt; <br>&gt; func containsAll&lt;S: Sequence where Sequence.Iterator.Element == Element&gt;(elements: S) -&gt; Bool<br>&gt; <br>&gt; One could move the “where” clause to the end of the signature, so that the most important parts—name, generic parameter, parameters, result type—precede it:<br>&gt; <br>&gt; func containsAll&lt;S: Sequence&gt;(elements: S) -&gt; Bool <br>&gt;        where Sequence.Iterator.Element == Element<br>&gt; <br>&gt; <br>&gt; *Renaming “protocol&lt;…&gt;” to “Any&lt;…&gt;”.<br>&gt; <br>&gt; The “protocol&lt;…&gt;” syntax is a bit of an oddity in Swift. It is used to compose protocols together, mostly to create values of existential type, e.g.,<br>&gt; <br>&gt; var x: protocol&lt;NSCoding, NSCopying&gt;<br>&gt; <br>&gt; It’s weird that it’s a type name that starts with a lowercase letter, and most Swift developers probably never deal with this feature unless they happen to look at the definition of Any:<br>&gt; <br>&gt; typealias Any = protocol&lt;&gt;<br>&gt; <br>&gt; “Any” might be a better name for this functionality. “Any” without brackets could be a keyword for “any type”, and “Any” followed by brackets could take the role of “protocol&lt;&gt;” today:<br>&gt; <br>&gt; var x: Any&lt;NSCoding, NSCopying&gt;<br>&gt; <br>&gt; That reads much better: “Any type that conforms to NSCoding and NSCopying”. See the section &quot;Generalized existentials” for additional features in this space.<br>&gt; <br>&gt; Maybe<br>&gt; <br>&gt; There are a number of features that get discussed from time-to-time, while they could fit into Swift’s generics system, it’s not clear that they belong in Swift at all. The important question for any feature in this category is not “can it be done” or “are there cool things we can express”, but “how can everyday Swift developers benefit from the addition of such a feature?”. Without strong motivating examples, none of these “maybes” will move further along.<br>&gt; <br>&gt; Dynamic dispatch for members of protocol extensions<br>&gt; <br>&gt; Only the requirements of protocols currently use dynamic dispatch, which can lead to surprises:<br>&gt; <br>&gt; protocol P {<br>&gt;   func foo()<br>&gt; }<br>&gt; <br>&gt; extension P {<br>&gt;   func foo() { print(“P.foo()”)<br>&gt;   func bar() { print(“P.bar()”)<br>&gt; }<br>&gt; <br>&gt; struct X : P {<br>&gt;   func foo() { print(“X.foo()”)<br>&gt;   func bar() { print(“X.bar()”)<br>&gt; }<br>&gt; <br>&gt; let x = X()<br>&gt; x.foo() // X.foo()<br>&gt; x.bar() // X.bar()<br>&gt; <br>&gt; let p: P = X()<br>&gt; p.foo() // X.foo()<br>&gt; p.bar() // P.bar()<br>&gt; <br>&gt; Swift could adopt a model where members of protocol extensions are dynamically dispatched.<br>&gt; <br>&gt; Named generic parameters<br>&gt; <br>&gt; When specifying generic arguments for a generic type, the arguments are always positional: Dictionary&lt;String, Int&gt; is a Dictionary whose Key type is String and whose Value type is Int, by convention. One could permit the arguments to be labeled, e.g.,<br>&gt; <br>&gt; var d: Dictionary&lt;Key: String, Value: Int&gt;<br>&gt; <br>&gt; Such a feature makes more sense if Swift gains default generic arguments, because generic argument labels would allow one to skip defaulted arguments.<br>&gt; <br>&gt; Generic value parameters<br>&gt; <br>&gt; Currently, Swift’s generic parameters are always types. One could imagine allowing generic parameters that are values, e.g.,<br>&gt; <br>&gt; struct MultiArray&lt;T, let Dimensions: Int&gt; { // specify the number of dimensions to the array<br>&gt;   subscript (indices: Int...) -&gt; T {<br>&gt;     get {<br>&gt;       require(indices.count == Dimensions)<br>&gt;       // ...<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; A suitably general feature might allow us to express fixed-length array or vector types as a standard library component, and perhaps also allow one to implement a useful dimensional analysis library. Tackling this feature potentially means determining what it is for an expression to be a “constant expression” and diving into dependent-typing, hence the “maybe”.<br>&gt; <br>&gt; Higher-kinded types<br>&gt; <br>&gt; Higher-kinded types allow one to express the relationship between two different specializations of the same nominal type within a protocol. For example, if we think of the Self type in a protocol as really being “Self&lt;T&gt;”, it allows us to talk about the relationship between “Self&lt;T&gt;” and “Self&lt;U&gt;” for some other type U. For example, it could allow the “map” operation on a collection to return a collection of the same kind but with a different operation, e.g.,<br>&gt; <br>&gt; let intArray: Array&lt;Int&gt; = …<br>&gt; intArray.map { String($0) } // produces Array&lt;String&gt;<br>&gt; let intSet: Set&lt;Int&gt; = …<br>&gt; intSet.map { String($0) }   // produces Set&lt;String&gt;<br>&gt; <br>&gt; <br>&gt; Potential syntax borrowed from one thread on higher-kinded types &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002736.html&gt; uses ~= as a “similarity” constraint to describe a Functor protocol:<br>&gt; <br>&gt; protocol Functor {<br>&gt;   associatedtype A<br>&gt;   func fmap&lt;FB where FB ~= Self&gt;(f: A -&gt; FB.A) -&gt; FB<br>&gt; }<br>&gt; <br>&gt; <br>&gt; Specifying type arguments for uses of generic functions<br>&gt; <br>&gt; The type arguments of a generic function are always determined via type inference. For example, given:<br>&gt; <br>&gt; func f&lt;T&gt;(t: T)<br>&gt; <br>&gt; one cannot directly specify T: either one calls “f” (and T is determined via the argument’s type) or one uses “f” in a context where it is given a particular function type (e.g., “let x: (Int) -&gt; Void = f”  would infer T = Int). We could permit explicit specialization here, e.g.,<br>&gt; <br>&gt; let x = f&lt;Int&gt; // x has type (Int) -&gt; Void<br>&gt; <br>&gt; <br>&gt; Unlikely<br>&gt; <br>&gt; Features in this category have been requested at various times, but they don’t fit well with Swift’s generics system because they cause some part of the model to become overly complicated, have unacceptable implementation limitations, or overlap significantly with existing features.<br>&gt; <br>&gt; Generic protocols<br>&gt; <br>&gt; One of the most commonly requested features is the ability to parameterize protocols themselves. For example, a protocol that indicates that the Self type can be constructed from some specified type T:<br>&gt; <br>&gt; protocol ConstructibleFromValue&lt;T&gt; {<br>&gt;   init(_ value: T)<br>&gt; }<br>&gt; <br>&gt; Implicit in this feature is the ability for a given type to conform to the protocol in two different ways. A “Real” type might be constructible from both Float and Double, e.g.,<br>&gt; <br>&gt; struct Real { … }<br>&gt; extension Real : ConstructibleFrom&lt;Float&gt; {<br>&gt;   init(_ value: Float) { … }<br>&gt; }<br>&gt; extension Real : ConstructibleFrom&lt;Double&gt; {<br>&gt;   init(_ value: Double) { … }<br>&gt; }<br>&gt; <br>&gt; Most of the requests for this feature actually want a different feature. They tend to use a parameterized Sequence as an example, e.g.,<br>&gt; <br>&gt; protocol Sequence&lt;Element&gt; { … }<br>&gt; <br>&gt; func foo(strings: Sequence&lt;String&gt;) {  /// works on any sequence containing Strings<br>&gt;   // ...<br>&gt; }<br>&gt; <br>&gt; The actual requested feature here 	is the ability to say “Any type that conforms to Sequence whose Element type is String”, which is covered by the section on “Generalized existentials”, below.<br>&gt; <br>&gt; More importantly, modeling Sequence with generic parameters rather than associated types is tantalizing but wrong: you don’t want a type conforming to Sequence in multiple ways, or (among other things) your for..in loops stop working, and you lose the ability to dynamically cast down to an existential “Sequence” without binding the Element type (again, see “Generalized existentials”). Use cases similar to the ConstructibleFromValue protocol above seem too few to justify the potential for confusion between associated types and generic parameters of protocols; we’re better off not having the latter.<br>&gt; <br>&gt; <br>&gt; Private conformances <br>&gt; <br>&gt; Right now, a protocol conformance can be no less visible than the minimum of the conforming type’s access and the protocol’s access. Therefore, a public type conforming to a public protocol must provide the conformance publicly. One could imagine removing that restriction, so that one could introduce a private conformance:<br>&gt; <br>&gt; public protocol P { }<br>&gt; public struct X { }<br>&gt; extension X : internal P { … } // X conforms to P, but only within this module<br>&gt; <br>&gt; The main problem with private conformances is the interaction with dynamic casting. If I have this code:<br>&gt; <br>&gt; func foo(value: Any) {<br>&gt;   if let x = value as? P { print(“P”) }<br>&gt; }<br>&gt; <br>&gt; foo(X())<br>&gt; <br>&gt; Under what circumstances should it print “P”? If foo() is defined within the same module as the conformance of X to P? If the call is defined within the same module as the conformance of X to P? Never? Either of the first two answers requires significant complications in the dynamic casting infrastructure to take into account the module in which a particular dynamic cast occurred (the first option) or where an existential was formed (the second option), while the third answer breaks the link between the static and dynamic type systems—none of which is an acceptable result.<br>&gt; <br>&gt; Conditional conformances via protocol extensions<br>&gt; <br>&gt; We often get requests to make a protocol conform to another protocol. This is, effectively, the expansion of the notion of “Conditional conformances” to protocol extensions. For example:<br>&gt; <br>&gt; protocol P {<br>&gt;   func foo()<br>&gt; }<br>&gt; <br>&gt; protocol Q {<br>&gt;   func bar()<br>&gt; }<br>&gt; <br>&gt; extension Q : P { // every type that conforms to Q also conforms to P<br>&gt;   func foo() {    // implement “foo” requirement in terms of “bar&quot;<br>&gt;     bar()<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; func f&lt;T: P&gt;(t: T) { … }<br>&gt; <br>&gt; struct X : Q {<br>&gt;   func bar() { … }<br>&gt; }<br>&gt; <br>&gt; f(X()) // okay: X conforms to P through the conformance of Q to P<br>&gt; <br>&gt; This is an extremely powerful feature: is allows one to map the abstractions of one domain into another domain (e.g., every Matrix is a Graph). However, similar to private conformances, it puts a major burden on the dynamic-casting runtime to chase down arbitrarily long and potentially cyclic chains of conformances, which makes efficient implementation nearly impossible.<br>&gt; <br>&gt; Potential removals<br>&gt; <br>&gt; The generics system doesn’t seem like a good candidate for a reduction in scope; most of its features do get used fairly pervasively in the standard library, and few feel overly anachronistic. However...<br>&gt; <br>&gt; Associated type inference<br>&gt; <br>&gt; Associated type inference is the process by which we infer the type bindings for associated types from other requirements. For example:<br>&gt; <br>&gt; protocol IteratorProtocol {<br>&gt;   associatedtype Element<br>&gt;   mutating func next() -&gt; Element?<br>&gt; }<br>&gt; <br>&gt; struct IntIterator : IteratorProtocol {<br>&gt;   mutating func next() -&gt; Int? { … }  // use this to infer Element = Int<br>&gt; }<br>&gt; <br>&gt; Associated type inference is a useful feature. It’s used throughout the standard library, and it helps keep associated types less visible to types that simply want to conform to a protocol. On the other hand, associated type inference is the only place in Swift where we have a global type inference problem: it has historically been a major source of bugs, and implementing it fully and correctly requires a drastically different architecture to the type checker. Is the value of this feature worth keeping global type inference in the Swift language, when we have deliberatively avoided global type inference elsewhere in the language?<br>&gt; <br>&gt; <br>&gt; Existentials<br>&gt; <br>&gt; Existentials aren’t really generics per se, but the two systems are closely intertwined due to their mutable dependence on protocols.<br>&gt; <br>&gt; *Generalized existentials<br>&gt; <br>&gt; The restrictions on existential types came from an implementation limitation, but it is reasonable to allow a value of protocol type even when the protocol has Self constraints or associated types. For example, consider IteratorProtocol again and how it could be used as an existential:<br>&gt; <br>&gt; protocol IteratorProtocol {<br>&gt;   associatedtype Element<br>&gt;   mutating func next() -&gt; Element?<br>&gt; }<br>&gt; <br>&gt; let it: IteratorProtocol = …<br>&gt; it.next()   // if this is permitted, it could return an “Any?”, i.e., the existential that wraps the actual element<br>&gt; <br>&gt; Additionally, it is reasonable to want to constrain the associated types of an existential, e.g., “a Sequence whose element type is String” could be expressed by putting a where clause into “protocol&lt;…&gt;” or “Any&lt;…&gt;” (per “Renaming protocol&lt;…&gt; to Any&lt;…&gt;”):<br>&gt; <br>&gt; let strings: Any&lt;Sequence where .Iterator.Element == String&gt; = [“a”, “b”, “c”]<br>&gt; <br>&gt; The leading “.” indicates that we’re talking about the dynamic type, i.e., the “Self” type that’s conforming to the Sequence protocol. There’s no reason why we cannot support arbitrary “where” clauses within the “Any&lt;…&gt;”. This very-general syntax is a bit unwieldy, but common cases can easily be wrapped up in a generic typealias (see the section “Generic typealiases” above):<br>&gt; <br>&gt; typealias AnySequence&lt;Element&gt; = Any&lt;Sequence where .Iterator.Element == Element&gt;<br>&gt; let strings: AnySequence&lt;String&gt; = [“a”, “b”, “c”]<br>&gt; <br>&gt; <br>&gt; Opening existentials<br>&gt; <br>&gt; Generalized existentials as described above will still have trouble with protocol requirements that involve Self or associated types in function parameters. For example, let’s try to use Equatable as an existential:<br>&gt; <br>&gt; protocol Equatable {<br>&gt;   func ==(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;   func !=(lhs: Self, rhs: Self) -&gt; Bool<br>&gt; }<br>&gt; <br>&gt; let e1: Equatable = …<br>&gt; let e2: Equatable = …<br>&gt; if e1 == e2 { … } // error: e1 and e2 don’t necessarily have the same dynamic type<br>&gt; <br>&gt; One explicit way to allow such operations in a type-safe manner is to introduce an “open existential” operation of some sort, which extracts and gives a name to the dynamic type stored inside an existential. For example:<br>&gt; <br>&gt; 	 <br>&gt; if let storedInE1 = e1 openas T {     // T is a the type of storedInE1, a copy of the value stored in e1<br>&gt;   if let storedInE2 = e2 as? T {      // is e2 also a T?<br>&gt;     if storedInE1 == storedInE2 { … } // okay: storedInT1 and storedInE2 are both of type T, which we know is Equatable<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; 	- Doug<br>&gt; <br></p><p>Thanks for sending this out! A lot of the stuff here looks amazingly useful, and I&#39;m excited to see it being discussed.<br></p><p>The choice of Equatable as an example for opening existentials is an interesting one here, because it&#39;s one of the few cases I can think of where differing dynamic types is actually fully defined: they&#39;re not equal. In ObjC we express that by starting every -isEqual: implementation with if (![other isKindOfClass:[self class]]) { return NO; }, which while clunky and easy to forget, does neatly express the desired semantics with no burden at the callsite. <br></p><p>My first thought for how to express that in Swift was &quot;ok, provide an == for (Any, Any) that just always says false&quot;, but that would defeat the ability to say something just doesn&#39;t make sense to compare with ==, which is a nice feature and prevents bugs.<br></p><p>Next thought for expressing it cleanly was:<br></p><p>protocol Equatable {<br>    func ==(lhs: Self, rhs: Self) -&gt; Bool<br>    func !=(lhs: Self, rhs: Self) -&gt; Bool<br>    func ==(lhs: Self, rhs: !Self) -&gt; Bool { return false }<br>    func !=(lhs: Self, rhs: !Self) -&gt; Bool { return true }<br>}<br></p><p>and I guess another equivalent way of writing it that doesn&#39;t require a new syntactic construct would be:<br></p><p>protocol Equatable {<br>    func ==(lhs: Self, rhs: Self) -&gt; Bool<br>    func !=(lhs: Self, rhs: Self) -&gt; Bool<br>    func ==&lt;Other:Equatable where Other != Self&gt;(lhs: Self, rhs: Other) -&gt; Bool { return false }<br>    func !=&lt;Other:Equatable where Other != Self&gt;(lhs: Self, rhs: Other) -&gt; Bool { return true }<br>}<br></p><p>which would make this idea a minor extension of the &quot;Concrete Same-Type Requirements&quot; section.<br></p><p>However, this still has a similar flaw to the first idea I had, which is that it introduces a valid == operator for things that never make sense to compare, when what we actually want is one that will only be accepted if there&#39;s insufficient information to determine whether it&#39;s valid (i.e. Equatable existentials). I suppose there&#39;s a relatively obvious syntax to express that directly:<br></p><p>protocol Equatable {<br>    func ==(lhs: Self, rhs: Self) -&gt; Bool<br>    func !=(lhs: Self, rhs: Self) -&gt; Bool<br>    func ==&lt;Other:Equatable where Other ?= Self&gt;(lhs: Self, rhs: Other) -&gt; Bool { return false }<br>    func !=&lt;Other:Equatable where Other ?= Self&gt;(lhs: Self, rhs: Other) -&gt; Bool { return true }<br>}<br></p><p>Where &quot;?=&quot; would be read as &quot;might be equal to&quot;. It&#39;s not clear to me if this sort of &quot;default implementation for non-matching existentials&quot; concept is applicable beyond Equatable though, and if not it seems like a lot of machinery to add for one case.<br></p><p>	David<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160302/38a40969/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Manifesto] Completing Generics</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March  2, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Mar 2, 2016, at 6:20 PM, David Smith via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Mar 2, 2016, at 5:22 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; The “Complete Generics” goal for Swift 3 has been fairly ill-defined thus fair, with just this short blurb in the list of goals:<br>&gt;&gt; <br>&gt;&gt; Complete generics: Generics are used pervasively in a number of Swift libraries, especially the standard library. However, there are a number of generics features the standard library requires to fully realize its vision, including recursive protocol constraints, the ability to make a constrained extension conform to a new protocol (i.e., an array of Equatable elements is Equatable), and so on. Swift 3.0 should provide those generics features needed by the standard library, because they affect the standard library&#39;s ABI.<br>&gt;&gt; This message expands upon the notion of “completing generics”. It is not a plan for Swift 3, nor an official core team communication, but it collects the results of numerous discussions among the core team and Swift developers, both of the compiler and the standard library. I hope to achieve several things:<br>&gt;&gt; <br>&gt;&gt; Communicate a vision for Swift generics, building on the original generics design document &lt;https://github.com/apple/swift/blob/master/docs/Generics.rst&gt;, so we have something concrete and comprehensive to discuss.<br>&gt;&gt; Establish some terminology that the Swift developers have been using for these features, so our discussions can be more productive (“oh, you’re proposing what we refer to as ‘conditional conformances’; go look over at this thread”).<br>&gt;&gt; Engage more of the community in discussions of specific generics features, so we can coalesce around designs for public review. And maybe even get some of them implemented.<br>&gt;&gt; <br>&gt;&gt; A message like this can easily turn into a centithread &lt;http://www.urbandictionary.com/define.php?term=centithread&gt;. To separate concerns in our discussion, I ask that replies to this specific thread be limited to discussions of the vision as a whole: how the pieces fit together, what pieces are missing, whether this is the right long-term vision for Swift, and so on. For discussions of specific language features, e.g., to work out the syntax and semantics of conditional conformances or discuss the implementation in compiler or use in the standard library, please start a new thread based on the feature names I’m using.<br>&gt;&gt; <br>&gt;&gt; This message covers a lot of ground; I’ve attempted a rough categorization of the various features, and kept the descriptions brief to limit the overall length. Most of these aren’t my ideas, and any syntax I’m providing is simply a way to express these ideas in code and is subject to change. Not all of these features will happen, either soon or ever, but they are intended to be a fairly complete whole that should mesh together. I’ve put a * next to features that I think are important in the nearer term vs. being interesting “some day”. Mostly, the *’s reflect features that will have a significant impact on the Swift standard library’s design and implementation.<br>&gt;&gt; <br>&gt;&gt; Enough with the disclaimers; it’s time to talk features.<br>&gt;&gt; <br>&gt;&gt; Removing unnecessary restrictions<br>&gt;&gt; <br>&gt;&gt; There are a number of restrictions to the use of generics that fall out of the implementation in the Swift compiler. Removal of these restrictions is a matter of implementation only; one need not introduce new syntax or semantics to realize them. I’m listing them for two reasons: first, it’s an acknowledgment that these features are intended to exist in the model we have today, and, second, we’d love help with the implementation of these features.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; *Recursive protocol constraints<br>&gt;&gt; <br>&gt;&gt; Currently, an associated type cannot be required to conform to its enclosing protocol (or any protocol that inherits that protocol). For example, in the standard library SubSequence type of a Sequence should itself be a Sequence:<br>&gt;&gt; <br>&gt;&gt; protocol Sequence {<br>&gt;&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;&gt;   …<br>&gt;&gt;   associatedtype SubSequence : Sequence   // currently ill-formed, but should be possible<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The compiler currently rejects this protocol, which is unfortunate: it effectively pushes the SubSequence-must-be-a-Sequence requirement into every consumer of SubSequence, and does not communicate the intent of this abstraction well.<br>&gt;&gt; <br>&gt;&gt; Nested generics<br>&gt;&gt; <br>&gt;&gt; Currently, a generic type cannot be nested within another generic type, e.g.<br>&gt;&gt; <br>&gt;&gt; struct X&lt;T&gt; {<br>&gt;&gt;   struct Y&lt;U&gt; { }  // currently ill-formed, but should be possible<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; There isn’t much to say about this: the compiler simply needs to be improved to handle nested generics throughout.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Concrete same-type requirements<br>&gt;&gt; <br>&gt;&gt; Currently, a constrained extension cannot use a same-type constraint to make a type parameter equivalent to a concrete type. For example:<br>&gt;&gt; <br>&gt;&gt; extension Array where Element == String {<br>&gt;&gt;   func makeSentence() -&gt; String {<br>&gt;&gt;     // uppercase first string, concatenate with spaces, add a period, whatever<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This is a highly-requested feature that fits into the existing syntax and semantics. Note that one could imagine introducing new syntax, e.g., extending “Array&lt;String&gt;”, which gets into new-feature territory: see the section on “Parameterized extensions”.<br>&gt;&gt; <br>&gt;&gt; Parameterizing other declarations<br>&gt;&gt; <br>&gt;&gt; There are a number of Swift declarations that currently cannot have generic parameters; some of those have fairly natural extensions to generic forms that maintain their current syntax and semantics, but become more powerful when made generic.<br>&gt;&gt; <br>&gt;&gt; Generic typealiases<br>&gt;&gt; <br>&gt;&gt; Typealiases could be allowed to carry generic parameters. They would still be aliases (i.e., they would not introduce new types). For example:<br>&gt;&gt; <br>&gt;&gt; typealias StringDictionary&lt;Value&gt; = Dictionary&lt;String, Value&gt;<br>&gt;&gt; <br>&gt;&gt; var d1 = StringDictionary&lt;Int&gt;()<br>&gt;&gt; var d2: Dictionary&lt;String, Int&gt; = d1 // okay: d1 and d2 have the same type, Dictionary&lt;String, Int&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Generic subscripts<br>&gt;&gt; <br>&gt;&gt; Subscripts could be allowed to have generic parameters. For example, we could introduce a generic subscript on a Collection that allows us to pull out the values at an arbitrary set of indices:<br>&gt;&gt; <br>&gt;&gt; extension Collection {<br>&gt;&gt;   subscript&lt;Indices: Sequence where Indices.Iterator.Element == Index&gt;(indices: Indices) -&gt; [Iterator.Element] {<br>&gt;&gt;     get {<br>&gt;&gt;       var result = [Iterator.Element]()<br>&gt;&gt;       for index in indices {<br>&gt;&gt;         result.append(self[index])<br>&gt;&gt;       }<br>&gt;&gt; <br>&gt;&gt;       return result<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     set {<br>&gt;&gt;       for (index, value) in zip(indices, newValue) {<br>&gt;&gt;         self[index] = value<br>&gt;&gt;       }<br>&gt;&gt;     }<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Generic constants<br>&gt;&gt; <br>&gt;&gt; let constants could be allowed to have generic parameters, such that they produce differently-typed values depending on how they are used. For example, this is particularly useful for named literal values, e.g.,<br>&gt;&gt; <br>&gt;&gt; let π&lt;T : FloatLiteralConvertible&gt;: T = 3.141592653589793238462643383279502884197169399<br>&gt;&gt; <br>&gt;&gt; The Clang importer could make particularly good use of this when importing macros.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Parameterized extensions<br>&gt;&gt; <br>&gt;&gt; Extensions themselves could be parameterized, which would allow some structural pattern matching on types. For example, this would permit one to extend an array of optional values, e.g.,<br>&gt;&gt; <br>&gt;&gt; extension&lt;T&gt; Array where Element == T? {<br>&gt;&gt;   var someValues: [T] {<br>&gt;&gt;     var result = [T]()<br>&gt;&gt;     for opt in self {<br>&gt;&gt;       if let value = opt { result.append(value) }<br>&gt;&gt;     }<br>&gt;&gt;    return result<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; We can generalize this to a protocol extensions:<br>&gt;&gt; <br>&gt;&gt; extension&lt;T&gt; Sequence where Element == T? {<br>&gt;&gt;   var someValues: [T] {<br>&gt;&gt;     var result = [T]()<br>&gt;&gt;     for opt in self {<br>&gt;&gt;       if let value = opt { result.append(value) }<br>&gt;&gt;     }<br>&gt;&gt;    return result<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Note that when one is extending nominal types, we could simplify the syntax somewhat to make the same-type constraint implicit in the syntax:<br>&gt;&gt; <br>&gt;&gt; extension&lt;T&gt; Array&lt;T?&gt; {<br>&gt;&gt;   var someValues: [T] {<br>&gt;&gt;     var result = [T]()<br>&gt;&gt;     for opt in self {<br>&gt;&gt;       if let value = opt { result.append(value) }<br>&gt;&gt;     }<br>&gt;&gt;    return result<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; When we’re working with concrete types, we can use that syntax to improve the extension of concrete versions of generic types (per “Concrete same-type requirements”, above), e.g.,<br>&gt;&gt; <br>&gt;&gt; extension Array&lt;String&gt; {<br>&gt;&gt;   func makeSentence() -&gt; String {<br>&gt;&gt;     // uppercase first string, concatenate with spaces, add a period, whatever<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Minor extensions<br>&gt;&gt; <br>&gt;&gt; There are a number of minor extensions we can make to the generics system that don’t fundamentally change what one can express in Swift, but which can improve its expressivity.<br>&gt;&gt; <br>&gt;&gt; *Arbitrary requirements in protocols<br>&gt;&gt; <br>&gt;&gt; Currently, a new protocol can inherit from other protocols, introduce new associated types, and add new conformance constraints to associated types (by redeclaring an associated type from an inherited protocol). However, one cannot express more general constraints. Building on the example from “Recursive protocol constraints”, we really want the element type of a Sequence’s SubSequence to be the same as the element type of the Sequence, e.g.,<br>&gt;&gt; <br>&gt;&gt; protocol Sequence {<br>&gt;&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;&gt;   …<br>&gt;&gt;   associatedtype SubSequence : Sequence where SubSequence.Iterator.Element == Iterator.Element<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Hanging the where clause off the associated type is protocol not ideal, but that’s a discussion for another thread.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; *Typealiases in protocols and protocol extensions<br>&gt;&gt; <br>&gt;&gt; Now that associated types have their own keyword (thanks!), it’s reasonable to bring back “typealias”. Again with the Sequence protocol:<br>&gt;&gt; <br>&gt;&gt; protocol Sequence {<br>&gt;&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;&gt;   typealias Element = Iterator.Element   // rejoice! now we can refer to SomeSequence.Element rather than SomeSequence.Iterator.Element<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Default generic arguments <br>&gt;&gt; <br>&gt;&gt; Generic parameters could be given the ability to provide default arguments, which would be used in cases where the type argument is not specified and type inference could not determine the type argument. For example:<br>&gt;&gt; <br>&gt;&gt; public final class Promise&lt;Value, Reason=Error&gt; { … }<br>&gt;&gt; <br>&gt;&gt; func getRandomPromise() -&gt; Promise&lt;Int, ErrorProtocol&gt; { … }<br>&gt;&gt; <br>&gt;&gt; var p1: Promise&lt;Int&gt; = …<br>&gt;&gt; var p2: Promise&lt;Int, Error&gt; = p1     // okay: p1 and p2 have the same type Promise&lt;Int, Error&gt;<br>&gt;&gt; var p3: Promise = getRandomPromise() // p3 has type Promise&lt;Int, ErrorProtocol&gt; due to type inference<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Generalized “class” constraints<br>&gt;&gt; <br>&gt;&gt; The “class” constraint can currently only be used for defining protocols. We could generalize it to associated type and type parameter declarations, e.g.,<br>&gt;&gt; <br>&gt;&gt; protocol P {<br>&gt;&gt;   associatedtype A : class<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func foo&lt;T : class&gt;(t: T) { }<br>&gt;&gt; <br>&gt;&gt; As part of this, the magical AnyObject protocol could be replaced with an existential with a class bound, so that it becomes a typealias:<br>&gt;&gt; <br>&gt;&gt; typealias AnyObject = protocol&lt;class&gt;<br>&gt;&gt; <br>&gt;&gt; See the “Existentials” section, particularly “Generalized existentials”, for more information.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; *Allowing subclasses to override requirements satisfied by defaults<br>&gt;&gt; <br>&gt;&gt; When a superclass conforms to a protocol and has one of the protocol’s requirements satisfied by a member of a protocol extension, that member currently cannot be overridden by a subclass. For example:<br>&gt;&gt; <br>&gt;&gt; protocol P {<br>&gt;&gt;   func foo()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension P {<br>&gt;&gt;   func foo() { print(“P”) }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class C : P {<br>&gt;&gt;   // gets the protocol extension’s <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class D : C {<br>&gt;&gt;   /*override not allowed!*/ func foo() { print(“D”) }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let p: P = D()<br>&gt;&gt; p.foo() // gotcha: prints “P” rather than “D”!<br>&gt;&gt; <br>&gt;&gt; D.foo should be required to specify “override” and should be called dynamically.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Major extensions to the generics model<br>&gt;&gt; <br>&gt;&gt; Unlike the minor extensions, major extensions to the generics model provide more expressivity in the Swift generics system and, generally, have a much more significant design and implementation cost.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; *Conditional conformances<br>&gt;&gt; <br>&gt;&gt; Conditional conformances express the notion that a generic type will conform to a particular protocol only under certain circumstances. For example, Array is Equatable only when its elements are Equatable:<br>&gt;&gt; <br>&gt;&gt; extension Array : Equatable where Element : Equatable { }<br>&gt;&gt; <br>&gt;&gt; func ==&lt;T : Equatable&gt;(lhs: Array&lt;T&gt;, rhs: Array&lt;T&gt;) -&gt; Bool { … }<br>&gt;&gt; <br>&gt;&gt; Conditional conformances are a potentially very powerful feature. One important aspect of this feature is how deal with or avoid overlapping conformances. For example, imagine an adaptor over a Sequence that has conditional conformances to Collection and MutableCollection:<br>&gt;&gt; <br>&gt;&gt; struct SequenceAdaptor&lt;S: Sequence&gt; : Sequence { }<br>&gt;&gt; extension SequenceAdaptor : Collection where S: Collection { … }<br>&gt;&gt; extension SequenceAdaptor : MutableCollection where S: MutableCollection { }<br>&gt;&gt; <br>&gt;&gt; This should almost certainly be permitted, but we need to cope with or reject “overlapping” conformances:<br>&gt;&gt; <br>&gt;&gt; extension SequenceAdaptor : Collection where S: SomeOtherProtocolSimilarToCollection { } // trouble: two ways for SequenceAdaptor to conform to Collection<br>&gt;&gt; <br>&gt;&gt; See the section on “Private conformances” for more about the issues with having the same type conform to the same protocol multiple times.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Variadic generics<br>&gt;&gt; <br>&gt;&gt; Currently, a generic parameter list contains a fixed number of generic parameters. If one has a type that could generalize to any number of generic parameters, the only real way to deal with it today involves creating a set of types. For example, consider the standard library’s “zip” function. It returns one of these when provided with two arguments to zip together:<br>&gt;&gt; <br>&gt;&gt; public struct Zip2Sequence&lt;Sequence1 : Sequence,<br>&gt;&gt;                            Sequence2 : Sequence&gt; : Sequence { … }<br>&gt;&gt; <br>&gt;&gt; public func zip&lt;Sequence1 : Sequence, Sequence2 : Sequence&gt;(<br>&gt;&gt;               sequence1: Sequence1, _ sequence2: Sequence2)<br>&gt;&gt;             -&gt; Zip2Sequence&lt;Sequence1, Sequence2&gt; { … }<br>&gt;&gt; <br>&gt;&gt; Supporting three arguments would require copy-paste of those of those:<br>&gt;&gt; <br>&gt;&gt; public struct Zip3Sequence&lt;Sequence1 : Sequence,<br>&gt;&gt;                            Sequence2 : Sequence,<br>&gt;&gt;                            Sequence3 : Sequence&gt; : Sequence { … }<br>&gt;&gt; <br>&gt;&gt; public func zip&lt;Sequence1 : Sequence, Sequence2 : Sequence, Sequence3 : Sequence&gt;(<br>&gt;&gt;               sequence1: Sequence1, _ sequence2: Sequence2, _ sequence3: sequence3)<br>&gt;&gt;             -&gt; Zip3Sequence&lt;Sequence1, Sequence2, Sequence3&gt; { … }<br>&gt;&gt; <br>&gt;&gt; Variadic generics would allow us to abstract over a set of generic parameters. The syntax below is hopelessly influenced by C++11 variadic templates &lt;http://www.jot.fm/issues/issue_2008_02/article2/&gt; (sorry), where putting an ellipsis (“…”) to the left of a declaration makes it a “parameter pack” containing zero or more parameters and putting an ellipsis to the right of a type/expression/etc. expands the parameter packs within that type/expression into separate arguments. The important part is that we be able to meaningfully abstract over zero or more generic parameters, e.g.:<br>&gt;&gt; <br>&gt;&gt; public struct ZipIterator&lt;... Iterators : IteratorProtocol&gt; : Iterator {  // zero or more type parameters, each of which conforms to IteratorProtocol<br>&gt;&gt;   public typealias Element = (Iterators.Element...)                       // a tuple containing the element types of each iterator in Iterators<br>&gt;&gt; <br>&gt;&gt;   var (...iterators): (Iterators...)    // zero or more stored properties, one for each type in Iterators <br>&gt;&gt;   var reachedEnd: Bool = false<br>&gt;&gt; <br>&gt;&gt;   public mutating func next() -&gt; Element? {<br>&gt;&gt;     if reachedEnd { return nil }<br>&gt;&gt; <br>&gt;&gt;     guard let values = (iterators.next()...) {   // call “next” on each of the iterators, put the results into a tuple named “values&quot;<br>&gt;&gt;       reachedEnd = true<br>&gt;&gt;       return nil<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     return values<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; public struct ZipSequence&lt;...Sequences : Sequence&gt; : Sequence {<br>&gt;&gt;   public typealias Iterator = ZipIterator&lt;Sequences.Iterator...&gt;   // get the zip iterator with the iterator types of our Sequences<br>&gt;&gt; <br>&gt;&gt;   var (...sequences): (Sequences...)    // zero or more stored properties, one for each type in Sequences <br>&gt;&gt; <br>&gt;&gt;   // details ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Such a design could also work for function parameters, so we can pack together multiple function arguments with different types, e.g.,<br>&gt;&gt; <br>&gt;&gt; public func zip&lt;... Sequences : SequenceType&gt;(... sequences: Sequences...) <br>&gt;&gt;             -&gt; ZipSequence&lt;Sequences...&gt; {<br>&gt;&gt;   return ZipSequence(sequences...)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Finally, this could tie into the discussions about a tuple “splat” operator. For example:<br>&gt;&gt; <br>&gt;&gt; func apply&lt;... Args, Result&gt;(fn: (Args...) -&gt; Result,    // function taking some number of arguments and producing Result<br>&gt;&gt;                            args: (Args...)) -&gt; Result {  // tuple of arguments<br>&gt;&gt;   return fn(args...)                                     // expand the arguments in the tuple “args” into separate arguments<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Extensions of structural types<br>&gt;&gt; <br>&gt;&gt; Currently, only nominal types (classes, structs, enums, protocols) can be extended. One could imagine extending structural types—particularly tuple types—to allow them to, e.g., conform to protocols. For example, pulling together variadic generics, parameterized extensions, and conditional conformances, one could express “a tuple type is Equatable if all of its element types are Equatable”:<br>&gt;&gt; <br>&gt;&gt; extension&lt;...Elements : Equatable&gt; (Elements...) : Equatable {   // extending the tuple type “(Elements…)” to be Equatable<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; There are some natural bounds here: one would need to have actual structural types. One would not be able to extend every type:<br>&gt;&gt; <br>&gt;&gt; extension&lt;T&gt; T { // error: neither a structural nor a nominal type<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; And before you think you’re cleverly making it possible to have a conditional conformance that makes every type T that conforms to protocol P also conform to protocol Q, see the section &quot;Conditional conformances via protocol extensions”, below:<br>&gt;&gt; <br>&gt;&gt; extension&lt;T : P&gt; T : Q { // error: neither a structural nor a nominal type<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Syntactic improvements<br>&gt;&gt; <br>&gt;&gt; There are a number of potential improvements we could make to the generics syntax. Such a list could go on for a very long time, so I’ll only highlight some obvious ones that have been discussed by the Swift developers.<br>&gt;&gt; <br>&gt;&gt; *Default implementations in protocols<br>&gt;&gt; <br>&gt;&gt; Currently, protocol members can never have implementations. We could allow one to provide such implementations to be used as the default if a conforming type does not supply an implementation, e.g.,<br>&gt;&gt; <br>&gt;&gt; protocol Bag {<br>&gt;&gt;   associatedtype Element : Equatable<br>&gt;&gt;   func contains(element: Element) -&gt; Bool<br>&gt;&gt; <br>&gt;&gt;   func containsAll&lt;S: Sequence where Sequence.Iterator.Element == Element&gt;(elements: S) -&gt; Bool {<br>&gt;&gt;     for x in elements {<br>&gt;&gt;       if contains(x) { return true }<br>&gt;&gt;     }<br>&gt;&gt;     return false<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct IntBag : Bag {<br>&gt;&gt;   typealias Element = Int<br>&gt;&gt;   func contains(element: Int) -&gt; Bool { ... }<br>&gt;&gt; <br>&gt;&gt;   // okay: containsAll requirement is satisfied by Bag’s default implementation<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; One can get this effect with protocol extensions today, hence the classification of this feature as a (mostly) syntactic improvement:<br>&gt;&gt; <br>&gt;&gt; protocol Bag {<br>&gt;&gt;   associatedtype Element : Equatable<br>&gt;&gt;   func contains(element: Element) -&gt; Bool<br>&gt;&gt; <br>&gt;&gt;   func containsAll&lt;S: Sequence where Sequence.Iterator.Element == Element&gt;(elements: S) -&gt; Bool<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension Bag {<br>&gt;&gt;   func containsAll&lt;S: Sequence where Sequence.Iterator.Element == Element&gt;(elements: S) -&gt; Bool {<br>&gt;&gt;     for x in elements {<br>&gt;&gt;       if contains(x) { return true }<br>&gt;&gt;     }<br>&gt;&gt;     return false<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; *Moving the where clause outside of the angle brackets<br>&gt;&gt; <br>&gt;&gt; The “where” clause of generic functions comes very early in the declaration, although it is generally of much less concern to the client than the function parameters and result type that follow it. This is one of the things that contributes to “angle bracket blindness”. For example, consider the containsAll signature above:<br>&gt;&gt; <br>&gt;&gt; func containsAll&lt;S: Sequence where Sequence.Iterator.Element == Element&gt;(elements: S) -&gt; Bool<br>&gt;&gt; <br>&gt;&gt; One could move the “where” clause to the end of the signature, so that the most important parts—name, generic parameter, parameters, result type—precede it:<br>&gt;&gt; <br>&gt;&gt; func containsAll&lt;S: Sequence&gt;(elements: S) -&gt; Bool <br>&gt;&gt;        where Sequence.Iterator.Element == Element<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; *Renaming “protocol&lt;…&gt;” to “Any&lt;…&gt;”.<br>&gt;&gt; <br>&gt;&gt; The “protocol&lt;…&gt;” syntax is a bit of an oddity in Swift. It is used to compose protocols together, mostly to create values of existential type, e.g.,<br>&gt;&gt; <br>&gt;&gt; var x: protocol&lt;NSCoding, NSCopying&gt;<br>&gt;&gt; <br>&gt;&gt; It’s weird that it’s a type name that starts with a lowercase letter, and most Swift developers probably never deal with this feature unless they happen to look at the definition of Any:<br>&gt;&gt; <br>&gt;&gt; typealias Any = protocol&lt;&gt;<br>&gt;&gt; <br>&gt;&gt; “Any” might be a better name for this functionality. “Any” without brackets could be a keyword for “any type”, and “Any” followed by brackets could take the role of “protocol&lt;&gt;” today:<br>&gt;&gt; <br>&gt;&gt; var x: Any&lt;NSCoding, NSCopying&gt;<br>&gt;&gt; <br>&gt;&gt; That reads much better: “Any type that conforms to NSCoding and NSCopying”. See the section &quot;Generalized existentials” for additional features in this space.<br>&gt;&gt; <br>&gt;&gt; Maybe<br>&gt;&gt; <br>&gt;&gt; There are a number of features that get discussed from time-to-time, while they could fit into Swift’s generics system, it’s not clear that they belong in Swift at all. The important question for any feature in this category is not “can it be done” or “are there cool things we can express”, but “how can everyday Swift developers benefit from the addition of such a feature?”. Without strong motivating examples, none of these “maybes” will move further along.<br>&gt;&gt; <br>&gt;&gt; Dynamic dispatch for members of protocol extensions<br>&gt;&gt; <br>&gt;&gt; Only the requirements of protocols currently use dynamic dispatch, which can lead to surprises:<br>&gt;&gt; <br>&gt;&gt; protocol P {<br>&gt;&gt;   func foo()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension P {<br>&gt;&gt;   func foo() { print(“P.foo()”)<br>&gt;&gt;   func bar() { print(“P.bar()”)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct X : P {<br>&gt;&gt;   func foo() { print(“X.foo()”)<br>&gt;&gt;   func bar() { print(“X.bar()”)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let x = X()<br>&gt;&gt; x.foo() // X.foo()<br>&gt;&gt; x.bar() // X.bar()<br>&gt;&gt; <br>&gt;&gt; let p: P = X()<br>&gt;&gt; p.foo() // X.foo()<br>&gt;&gt; p.bar() // P.bar()<br>&gt;&gt; <br>&gt;&gt; Swift could adopt a model where members of protocol extensions are dynamically dispatched.<br>&gt;&gt; <br>&gt;&gt; Named generic parameters<br>&gt;&gt; <br>&gt;&gt; When specifying generic arguments for a generic type, the arguments are always positional: Dictionary&lt;String, Int&gt; is a Dictionary whose Key type is String and whose Value type is Int, by convention. One could permit the arguments to be labeled, e.g.,<br>&gt;&gt; <br>&gt;&gt; var d: Dictionary&lt;Key: String, Value: Int&gt;<br>&gt;&gt; <br>&gt;&gt; Such a feature makes more sense if Swift gains default generic arguments, because generic argument labels would allow one to skip defaulted arguments.<br>&gt;&gt; <br>&gt;&gt; Generic value parameters<br>&gt;&gt; <br>&gt;&gt; Currently, Swift’s generic parameters are always types. One could imagine allowing generic parameters that are values, e.g.,<br>&gt;&gt; <br>&gt;&gt; struct MultiArray&lt;T, let Dimensions: Int&gt; { // specify the number of dimensions to the array<br>&gt;&gt;   subscript (indices: Int...) -&gt; T {<br>&gt;&gt;     get {<br>&gt;&gt;       require(indices.count == Dimensions)<br>&gt;&gt;       // ...<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; A suitably general feature might allow us to express fixed-length array or vector types as a standard library component, and perhaps also allow one to implement a useful dimensional analysis library. Tackling this feature potentially means determining what it is for an expression to be a “constant expression” and diving into dependent-typing, hence the “maybe”.<br>&gt;&gt; <br>&gt;&gt; Higher-kinded types<br>&gt;&gt; <br>&gt;&gt; Higher-kinded types allow one to express the relationship between two different specializations of the same nominal type within a protocol. For example, if we think of the Self type in a protocol as really being “Self&lt;T&gt;”, it allows us to talk about the relationship between “Self&lt;T&gt;” and “Self&lt;U&gt;” for some other type U. For example, it could allow the “map” operation on a collection to return a collection of the same kind but with a different operation, e.g.,<br>&gt;&gt; <br>&gt;&gt; let intArray: Array&lt;Int&gt; = …<br>&gt;&gt; intArray.map { String($0) } // produces Array&lt;String&gt;<br>&gt;&gt; let intSet: Set&lt;Int&gt; = …<br>&gt;&gt; intSet.map { String($0) }   // produces Set&lt;String&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Potential syntax borrowed from one thread on higher-kinded types &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002736.html&gt; uses ~= as a “similarity” constraint to describe a Functor protocol:<br>&gt;&gt; <br>&gt;&gt; protocol Functor {<br>&gt;&gt;   associatedtype A<br>&gt;&gt;   func fmap&lt;FB where FB ~= Self&gt;(f: A -&gt; FB.A) -&gt; FB<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Specifying type arguments for uses of generic functions<br>&gt;&gt; <br>&gt;&gt; The type arguments of a generic function are always determined via type inference. For example, given:<br>&gt;&gt; <br>&gt;&gt; func f&lt;T&gt;(t: T)<br>&gt;&gt; <br>&gt;&gt; one cannot directly specify T: either one calls “f” (and T is determined via the argument’s type) or one uses “f” in a context where it is given a particular function type (e.g., “let x: (Int) -&gt; Void = f”  would infer T = Int). We could permit explicit specialization here, e.g.,<br>&gt;&gt; <br>&gt;&gt; let x = f&lt;Int&gt; // x has type (Int) -&gt; Void<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Unlikely<br>&gt;&gt; <br>&gt;&gt; Features in this category have been requested at various times, but they don’t fit well with Swift’s generics system because they cause some part of the model to become overly complicated, have unacceptable implementation limitations, or overlap significantly with existing features.<br>&gt;&gt; <br>&gt;&gt; Generic protocols<br>&gt;&gt; <br>&gt;&gt; One of the most commonly requested features is the ability to parameterize protocols themselves. For example, a protocol that indicates that the Self type can be constructed from some specified type T:<br>&gt;&gt; <br>&gt;&gt; protocol ConstructibleFromValue&lt;T&gt; {<br>&gt;&gt;   init(_ value: T)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Implicit in this feature is the ability for a given type to conform to the protocol in two different ways. A “Real” type might be constructible from both Float and Double, e.g.,<br>&gt;&gt; <br>&gt;&gt; struct Real { … }<br>&gt;&gt; extension Real : ConstructibleFrom&lt;Float&gt; {<br>&gt;&gt;   init(_ value: Float) { … }<br>&gt;&gt; }<br>&gt;&gt; extension Real : ConstructibleFrom&lt;Double&gt; {<br>&gt;&gt;   init(_ value: Double) { … }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Most of the requests for this feature actually want a different feature. They tend to use a parameterized Sequence as an example, e.g.,<br>&gt;&gt; <br>&gt;&gt; protocol Sequence&lt;Element&gt; { … }<br>&gt;&gt; <br>&gt;&gt; func foo(strings: Sequence&lt;String&gt;) {  /// works on any sequence containing Strings<br>&gt;&gt;   // ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The actual requested feature here 	is the ability to say “Any type that conforms to Sequence whose Element type is String”, which is covered by the section on “Generalized existentials”, below.<br>&gt;&gt; <br>&gt;&gt; More importantly, modeling Sequence with generic parameters rather than associated types is tantalizing but wrong: you don’t want a type conforming to Sequence in multiple ways, or (among other things) your for..in loops stop working, and you lose the ability to dynamically cast down to an existential “Sequence” without binding the Element type (again, see “Generalized existentials”). Use cases similar to the ConstructibleFromValue protocol above seem too few to justify the potential for confusion between associated types and generic parameters of protocols; we’re better off not having the latter.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Private conformances <br>&gt;&gt; <br>&gt;&gt; Right now, a protocol conformance can be no less visible than the minimum of the conforming type’s access and the protocol’s access. Therefore, a public type conforming to a public protocol must provide the conformance publicly. One could imagine removing that restriction, so that one could introduce a private conformance:<br>&gt;&gt; <br>&gt;&gt; public protocol P { }<br>&gt;&gt; public struct X { }<br>&gt;&gt; extension X : internal P { … } // X conforms to P, but only within this module<br>&gt;&gt; <br>&gt;&gt; The main problem with private conformances is the interaction with dynamic casting. If I have this code:<br>&gt;&gt; <br>&gt;&gt; func foo(value: Any) {<br>&gt;&gt;   if let x = value as? P { print(“P”) }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; foo(X())<br>&gt;&gt; <br>&gt;&gt; Under what circumstances should it print “P”? If foo() is defined within the same module as the conformance of X to P? If the call is defined within the same module as the conformance of X to P? Never? Either of the first two answers requires significant complications in the dynamic casting infrastructure to take into account the module in which a particular dynamic cast occurred (the first option) or where an existential was formed (the second option), while the third answer breaks the link between the static and dynamic type systems—none of which is an acceptable result.<br>&gt;&gt; <br>&gt;&gt; Conditional conformances via protocol extensions<br>&gt;&gt; <br>&gt;&gt; We often get requests to make a protocol conform to another protocol. This is, effectively, the expansion of the notion of “Conditional conformances” to protocol extensions. For example:<br>&gt;&gt; <br>&gt;&gt; protocol P {<br>&gt;&gt;   func foo()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; protocol Q {<br>&gt;&gt;   func bar()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension Q : P { // every type that conforms to Q also conforms to P<br>&gt;&gt;   func foo() {    // implement “foo” requirement in terms of “bar&quot;<br>&gt;&gt;     bar()<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func f&lt;T: P&gt;(t: T) { … }<br>&gt;&gt; <br>&gt;&gt; struct X : Q {<br>&gt;&gt;   func bar() { … }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; f(X()) // okay: X conforms to P through the conformance of Q to P<br>&gt;&gt; <br>&gt;&gt; This is an extremely powerful feature: is allows one to map the abstractions of one domain into another domain (e.g., every Matrix is a Graph). However, similar to private conformances, it puts a major burden on the dynamic-casting runtime to chase down arbitrarily long and potentially cyclic chains of conformances, which makes efficient implementation nearly impossible.<br>&gt;&gt; <br>&gt;&gt; Potential removals<br>&gt;&gt; <br>&gt;&gt; The generics system doesn’t seem like a good candidate for a reduction in scope; most of its features do get used fairly pervasively in the standard library, and few feel overly anachronistic. However...<br>&gt;&gt; <br>&gt;&gt; Associated type inference<br>&gt;&gt; <br>&gt;&gt; Associated type inference is the process by which we infer the type bindings for associated types from other requirements. For example:<br>&gt;&gt; <br>&gt;&gt; protocol IteratorProtocol {<br>&gt;&gt;   associatedtype Element<br>&gt;&gt;   mutating func next() -&gt; Element?<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct IntIterator : IteratorProtocol {<br>&gt;&gt;   mutating func next() -&gt; Int? { … }  // use this to infer Element = Int<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Associated type inference is a useful feature. It’s used throughout the standard library, and it helps keep associated types less visible to types that simply want to conform to a protocol. On the other hand, associated type inference is the only place in Swift where we have a global type inference problem: it has historically been a major source of bugs, and implementing it fully and correctly requires a drastically different architecture to the type checker. Is the value of this feature worth keeping global type inference in the Swift language, when we have deliberatively avoided global type inference elsewhere in the language?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Existentials<br>&gt;&gt; <br>&gt;&gt; Existentials aren’t really generics per se, but the two systems are closely intertwined due to their mutable dependence on protocols.<br>&gt;&gt; <br>&gt;&gt; *Generalized existentials<br>&gt;&gt; <br>&gt;&gt; The restrictions on existential types came from an implementation limitation, but it is reasonable to allow a value of protocol type even when the protocol has Self constraints or associated types. For example, consider IteratorProtocol again and how it could be used as an existential:<br>&gt;&gt; <br>&gt;&gt; protocol IteratorProtocol {<br>&gt;&gt;   associatedtype Element<br>&gt;&gt;   mutating func next() -&gt; Element?<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let it: IteratorProtocol = …<br>&gt;&gt; it.next()   // if this is permitted, it could return an “Any?”, i.e., the existential that wraps the actual element<br>&gt;&gt; <br>&gt;&gt; Additionally, it is reasonable to want to constrain the associated types of an existential, e.g., “a Sequence whose element type is String” could be expressed by putting a where clause into “protocol&lt;…&gt;” or “Any&lt;…&gt;” (per “Renaming protocol&lt;…&gt; to Any&lt;…&gt;”):<br>&gt;&gt; <br>&gt;&gt; let strings: Any&lt;Sequence where .Iterator.Element == String&gt; = [“a”, “b”, “c”]<br>&gt;&gt; <br>&gt;&gt; The leading “.” indicates that we’re talking about the dynamic type, i.e., the “Self” type that’s conforming to the Sequence protocol. There’s no reason why we cannot support arbitrary “where” clauses within the “Any&lt;…&gt;”. This very-general syntax is a bit unwieldy, but common cases can easily be wrapped up in a generic typealias (see the section “Generic typealiases” above):<br>&gt;&gt; <br>&gt;&gt; typealias AnySequence&lt;Element&gt; = Any&lt;Sequence where .Iterator.Element == Element&gt;<br>&gt;&gt; let strings: AnySequence&lt;String&gt; = [“a”, “b”, “c”]<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Opening existentials<br>&gt;&gt; <br>&gt;&gt; Generalized existentials as described above will still have trouble with protocol requirements that involve Self or associated types in function parameters. For example, let’s try to use Equatable as an existential:<br>&gt;&gt; <br>&gt;&gt; protocol Equatable {<br>&gt;&gt;   func ==(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;   func !=(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let e1: Equatable = …<br>&gt;&gt; let e2: Equatable = …<br>&gt;&gt; if e1 == e2 { … } // error: e1 and e2 don’t necessarily have the same dynamic type<br>&gt;&gt; <br>&gt;&gt; One explicit way to allow such operations in a type-safe manner is to introduce an “open existential” operation of some sort, which extracts and gives a name to the dynamic type stored inside an existential. For example:<br>&gt;&gt; <br>&gt;&gt; 	 <br>&gt;&gt; if let storedInE1 = e1 openas T {     // T is a the type of storedInE1, a copy of the value stored in e1<br>&gt;&gt;   if let storedInE2 = e2 as? T {      // is e2 also a T?<br>&gt;&gt;     if storedInE1 == storedInE2 { … } // okay: storedInT1 and storedInE2 are both of type T, which we know is Equatable<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Thoughts?<br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt; <br>&gt; Thanks for sending this out! A lot of the stuff here looks amazingly useful, and I&#39;m excited to see it being discussed.<br>&gt; <br>&gt; The choice of Equatable as an example for opening existentials is an interesting one here, because it&#39;s one of the few cases I can think of where differing dynamic types is actually fully defined: they&#39;re not equal. In ObjC we express that by starting every -isEqual: implementation with if (![other isKindOfClass:[self class]]) { return NO; }, which while clunky and easy to forget, does neatly express the desired semantics with no burden at the callsite. <br>&gt; <br>&gt; My first thought for how to express that in Swift was &quot;ok, provide an == for (Any, Any) that just always says false&quot;, but that would defeat the ability to say something just doesn&#39;t make sense to compare with ==, which is a nice feature and prevents bugs.<br>&gt; <br>&gt; Next thought for expressing it cleanly was:<br>&gt; <br>&gt; protocol Equatable {<br>&gt;     func ==(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;     func !=(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;     func ==(lhs: Self, rhs: !Self) -&gt; Bool { return false }<br>&gt;     func !=(lhs: Self, rhs: !Self) -&gt; Bool { return true }<br>&gt; }<br>&gt; <br>&gt; and I guess another equivalent way of writing it that doesn&#39;t require a new syntactic construct would be:<br>&gt; <br>&gt; protocol Equatable {<br>&gt;     func ==(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;     func !=(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;     func ==&lt;Other:Equatable where Other != Self&gt;(lhs: Self, rhs: Other) -&gt; Bool { return false }<br>&gt;     func !=&lt;Other:Equatable where Other != Self&gt;(lhs: Self, rhs: Other) -&gt; Bool { return true }<br>&gt; }<br></p><p>My thinking is that this could be expressed as extending the existential type to conform to the protocol:<br></p><p>extension Any&lt;Equatable&gt;: Equatable {<br>  func ==(lhs: Any&lt;Equatable&gt;, rhs: Any&lt;Equatable&gt;) -&gt; Bool {<br>    if let lrhs = rhs as? lhs.Self {<br>      return lhs == rlhs<br>    }<br>    return false<br>  }<br>}<br></p><p>&gt; which would make this idea a minor extension of the &quot;Concrete Same-Type Requirements&quot; section.<br>&gt; <br>&gt; However, this still has a similar flaw to the first idea I had, which is that it introduces a valid == operator for things that never make sense to compare, when what we actually want is one that will only be accepted if there&#39;s insufficient information to determine whether it&#39;s valid (i.e. Equatable existentials). I suppose there&#39;s a relatively obvious syntax to express that directly:<br>&gt; <br>&gt; protocol Equatable {<br>&gt;     func ==(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;     func !=(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;     func ==&lt;Other:Equatable where Other ?= Self&gt;(lhs: Self, rhs: Other) -&gt; Bool { return false }<br>&gt;     func !=&lt;Other:Equatable where Other ?= Self&gt;(lhs: Self, rhs: Other) -&gt; Bool { return true }<br>&gt; }<br>&gt; <br>&gt; Where &quot;?=&quot; would be read as &quot;might be equal to&quot;. It&#39;s not clear to me if this sort of &quot;default implementation for non-matching existentials&quot; concept is applicable beyond Equatable though, and if not it seems like a lot of machinery to add for one case.<br></p><p>The &quot;introducing an == operator for things that never make sense to compare&quot; problem could be avoided by a type system rule that, when we bind a generic parameter from multiple value parameter, we don&#39;t upconvert to a type that neither parameter statically has. Since `==` is `&lt;Self&gt; (Self, Self) -&gt; Bool`, that would prevent us from picking `Self == Any&lt;Equatable&gt;` if you called `Int == Float`, but would allow it if one or the other parameter was already Any&lt;Equatable&gt;.<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160302/7f9b6e45/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Completing Generics] Universal conformances</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March  2, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Mar 2, 2016, at 5:22 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; There are some natural bounds here: one would need to have actual structural types. One would not be able to extend every type:<br>&gt; <br>&gt; extension&lt;T&gt; T { // error: neither a structural nor a nominal type<br>&gt; }<br>&gt; <br>&gt; And before you think you’re cleverly making it possible to have a conditional conformance that makes every type T that conforms to protocol P also conform to protocol Q, see the section &quot;Conditional conformances via protocol extensions”, below:<br>&gt; <br>&gt; extension&lt;T : P&gt; T : Q { // error: neither a structural nor a nominal type<br>&gt; }<br></p><p>Though definitely a &quot;power&quot; feature that should be used sparingly, I think there are legitimate use cases for universal conformances. If nothing else, the language imposes de-facto universal members on things, including T.Type and x.dynamicType, and it would be nice if those could be implemented in the standard library and given back as reserved words.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160302/2b4546fe/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Completing Generics] Universal conformances</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March  2, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Mar 2, 2016, at 9:15 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Though definitely a &quot;power&quot; feature that should be used sparingly, I think there are legitimate use cases for universal conformances. If nothing else, the language imposes de-facto universal members on things, including T.Type and x.dynamicType, and it would be nice if those could be implemented in the standard library and given back as reserved words.<br></p><p>(It occurs to me that if we go the path-dependent types route, then `x.dynamicType` could be subsumed by `x.Self`...)<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160302/7f0d7c11/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>[Manifesto] Completing Generics</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>March  2, 2016 at 09:00:00pm</p></header><div class="content"><p>Hi Doug,<br></p><p>I’m really happy to see this written up. I’m wondering if adding a bit more detail on some of the bigger items would help scope the work.<br></p><p>&gt; On Mar 2, 2016, at 5:22 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Nested generics<br>&gt; <br>&gt; Currently, a generic type cannot be nested within another generic type, e.g.<br>&gt; <br>&gt; struct X&lt;T&gt; {<br>&gt;   struct Y&lt;U&gt; { }  // currently ill-formed, but should be possible<br>&gt; }<br>&gt; <br>&gt; There isn’t much to say about this: the compiler simply needs to be improved to handle nested generics throughout.<br></p><p>Yes! :-)<br></p><p>For nested generic functions, the only limitation today is that nested functions cannot capture values from an outer scope if they also have a generic signature of their own. I have some patches implementing this but I haven’t had a chance to work on them for a while.<br></p><p>Nested generic types require some runtime support but I believe Sema mostly models them correctly — we recently fixed a lot of compiler crashes related to this. Shouldn’t be too much work to get both of these into Swift 3 :)<br></p><p>However there are a crazier things we should figure out:<br></p><p>a) Generic types nested inside generic functions have been a source of compiler_crashers because the inner generic signature has more primary parameters than the bound generic type, due to “captures&quot;. For example, if you have something like:<br></p><p>func foo&lt;T&gt;() {<br>	struct S&lt;U&gt; {<br>		let p: (T, U)<br>	}<br>}<br></p><p>The metatype for S&lt;U&gt; should also “capture” the type parameter T. In particular it seems that invocations of foo() with different concrete types bound to T will produce distinct S types. Sema doesn’t really model this well right now, I think — it just has some hacks to avoid crashing. Also I wonder what this means if S conforms to a protocol. There might be representational issues with the conformance in the runtime, or at least the captured type has to be stashed somewhere.<br></p><p>b) There’s also the case of types nested inside protocols. Do we ever want to allow this (my opinion is ’no’), and if so, what does it mean exactly?<br></p><p>protocol Collection {<br>	associatedtype ElementType<br></p><p>	struct Iterator {<br>		let e: ElementType<br>	}<br>}<br></p><p>c) Protocols nested inside functions and other types should probably never be allowed. There might be some latent crashes because of Sema assumptions that the Self type is at depth 0, or cases where diagnostics are not emitted.<br></p><p>&gt; <br>&gt; <br>&gt; Concrete same-type requirements<br>&gt; <br>&gt; Currently, a constrained extension cannot use a same-type constraint to make a type parameter equivalent to a concrete type. For example:<br>&gt; <br>&gt; extension Array where Element == String {<br>&gt;   func makeSentence() -&gt; String {<br>&gt;     // uppercase first string, concatenate with spaces, add a period, whatever<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; This is a highly-requested feature that fits into the existing syntax and semantics. Note that one could imagine introducing new syntax, e.g., extending “Array&lt;String&gt;”, which gets into new-feature territory: see the section on “Parameterized extensions”.<br></p><p>Do we already support same-type constraints between two primary generic parameters or should this be added in as well?<br></p><p>&gt; *Typealiases in protocols and protocol extensions<br>&gt; <br>&gt; Now that associated types have their own keyword (thanks!), it’s reasonable to bring back “typealias”. Again with the Sequence protocol:<br>&gt; <br>&gt; protocol Sequence {<br>&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;   typealias Element = Iterator.Element   // rejoice! now we can refer to SomeSequence.Element rather than SomeSequence.Iterator.Element<br>&gt; }<br></p><p>If we decide to pass ‘Element’ as a top-level metadata parameter, this could be used an optimization hint, and would also have resilience implications.<br></p><p>&gt; Conditional conformances are a potentially very powerful feature. One important aspect of this feature is how deal with or avoid overlapping conformances. For example, imagine an adaptor over a Sequence that has conditional conformances to Collection and MutableCollection:<br></p><p>Would it be enough to prohibit defining multiple conditional conformances to the same protocol for the same base type but with different ‘where’ clauses?<br></p><p>&gt; <br>&gt; public struct ZipIterator&lt;... Iterators : IteratorProtocol&gt; : Iterator {  // zero or more type parameters, each of which conforms to IteratorProtocol<br></p><p>Would this make sense too:<br></p><p>struct ZipIterator&lt;… Iterators where Iterators : IteratorProtocol&gt;<br></p><p>I’m wondering if we can replace current varargs with a desugaring along the lines of:<br></p><p>func vararg(let a: A…) {<br></p><p>}<br></p><p>func vararg&lt;… T where T == A&gt;(let a: (T…)) { … }<br></p><p>Currently, varargs have a static number of arguments at the call site — instead of constructing an array, they could be passed as a tuple value, which would presumably be stack allocated at the call site. Together with a runtime entry point to get tuple metadata from a single element type repeated N times, this might be more efficient than varargs are now, where as far as I understand the array is allocated on the heap by the caller.<br></p><p><br>&gt; There are some natural bounds here: one would need to have actual structural types. One would not be able to extend every type:<br>&gt; <br>&gt; extension&lt;T&gt; T { // error: neither a structural nor a nominal type<br>&gt; }<br></p><p>Extending Any or AnyObject doesn’t seem too far-fetched, though, and almost feels like an artificial restriction at this point. Has nobody ever wanted this?<br></p><p>&gt; <br>&gt; And before you think you’re cleverly making it possible to have a conditional conformance that makes every type T that conforms to protocol P also conform to protocol Q, see the section &quot;Conditional conformances via protocol extensions”, below:<br></p><p>What about self-conforming protocols? I’m willing to bet most people don’t use static methods in protocols, so it seems unnatural that a protocol type cannot be bound to a generic parameter constrained to that protocol type. Today on Twitter we had someone doing something like this:<br></p><p>protocol BaseProto {}<br>protocol RefinedProto : BaseProto {}<br></p><p>func doStuff&lt;T : BaseProto&gt;(let a: [T]) {}<br></p><p>getRefined() -&gt; [RefinedProto]<br></p><p>doStuff(getRefined()) // doesn’t type check!<br></p><p>Of course the underlying reason is that BaseProto does not conform to _itself_, which has nothing to do with RefinedProto.<br></p><p>There are tricky representational issues with self-conforming protocols, especially class-constrained ones — we expect an instance of a class-constrained generic parameter to be a single retainable pointer, which is not the case if it is an existential with an associated witness table. But if we can figure this out, it would smooth over a sharp edge in the language that confuses people who are not intimately familiar with how existential types are represented (ie, everybody except for us :) ).<br></p><p>This is different from opening existentials, because here we’re binding T to RefinedProto and cannot simultaneously open everything in the array…<br></p><p>&gt; Specifying type arguments for uses of generic functions<br>&gt; <br>&gt; The type arguments of a generic function are always determined via type inference. For example, given:<br>&gt; <br>&gt; func f&lt;T&gt;(t: T)<br>&gt; <br>&gt; one cannot directly specify T: either one calls “f” (and T is determined via the argument’s type) or one uses “f” in a context where it is given a particular function type (e.g., “let x: (Int) -&gt; Void = f”  would infer T = Int). We could permit explicit specialization here, e.g.,<br>&gt; <br>&gt; let x = f&lt;Int&gt; // x has type (Int) -&gt; Void<br></p><p>Are higher-kinded function values worth discussing too?<br></p><p>&gt; <br>&gt; if let storedInE1 = e1 openas T {     // T is a the type of storedInE1, a copy of the value stored in e1<br>&gt;   if let storedInE2 = e2 as? T {      // is e2 also a T?<br>&gt;     if storedInE1 == storedInE2 { … } // okay: storedInT1 and storedInE2 are both of type T, which we know is Equatable<br>&gt;   }<br>&gt; }<br></p><p>I’m worried that this is not really correct with inheritance. If e1 is an instance of SubClass, and e2 is an instance of SuperClass with SubClass : SuperClass, then your operation is no longer symmetric. Heterogeneous equality just seems like a pain in general.<br></p><p>Slava<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160302/c4fcb2cb/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Manifesto] Completing Generics</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>March  2, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Mar 2, 2016, at 9:24 PM, Slava Pestov &lt;spestov at apple.com&gt; wrote:<br>&gt; <br>&gt; Hi Doug,<br>&gt; <br>&gt; I’m really happy to see this written up. I’m wondering if adding a bit more detail on some of the bigger items would help scope the work.<br>&gt; <br>&gt;&gt; On Mar 2, 2016, at 5:22 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Nested generics<br>&gt;&gt; <br>&gt;&gt; Currently, a generic type cannot be nested within another generic type, e.g.<br>&gt;&gt; <br>&gt;&gt; struct X&lt;T&gt; {<br>&gt;&gt;   struct Y&lt;U&gt; { }  // currently ill-formed, but should be possible<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; There isn’t much to say about this: the compiler simply needs to be improved to handle nested generics throughout.<br>&gt; <br>&gt; Yes! :-)<br>&gt; <br>&gt; For nested generic functions, the only limitation today is that nested functions cannot capture values from an outer scope if they also have a generic signature of their own. I have some patches implementing this but I haven’t had a chance to work on them for a while.<br>&gt; <br>&gt; Nested generic types require some runtime support but I believe Sema mostly models them correctly — we recently fixed a lot of compiler crashes related to this. Shouldn’t be too much work to get both of these into Swift 3 :)<br>&gt; <br>&gt; However there are a crazier things we should figure out:<br>&gt; <br>&gt; a) Generic types nested inside generic functions have been a source of compiler_crashers because the inner generic signature has more primary parameters than the bound generic type, due to “captures&quot;. For example, if you have something like:<br>&gt; <br>&gt; func foo&lt;T&gt;() {<br>&gt; 	struct S&lt;U&gt; {<br>&gt; 		let p: (T, U)<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; The metatype for S&lt;U&gt; should also “capture” the type parameter T. In particular it seems that invocations of foo() with different concrete types bound to T will produce distinct S types. Sema doesn’t really model this well right now, I think — it just has some hacks to avoid crashing. Also I wonder what this means if S conforms to a protocol. There might be representational issues with the conformance in the runtime, or at least the captured type has to be stashed somewhere.<br></p><p>Right. Our modeling for this is to essentially pretend that T isn’t part of the generic signature of S, which is wrong. Rather, we want T to be part of the generic signature, but that it’s bound to a particular type within the context.<br></p><p>&gt; <br>&gt; b) There’s also the case of types nested inside protocols. Do we ever want to allow this (my opinion is ’no’), and if so, what does it mean exactly?<br>&gt; <br>&gt; protocol Collection {<br>&gt; 	associatedtype ElementType<br>&gt; <br>&gt; 	struct Iterator {<br>&gt; 		let e: ElementType<br>&gt; 	}<br>&gt; }<br></p><p>Presumably you get a different Iterator for each type that conforms to Collection, but I agree that we probably don’t want this.<br></p><p>&gt; c) Protocols nested inside functions and other types should probably never be allowed. There might be some latent crashes because of Sema assumptions that the Self type is at depth 0, or cases where diagnostics are not emitted.<br></p><p>Agreed. Protocols nested within anything should be banned.<br></p><p><br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Concrete same-type requirements<br>&gt;&gt; <br>&gt;&gt; Currently, a constrained extension cannot use a same-type constraint to make a type parameter equivalent to a concrete type. For example:<br>&gt;&gt; <br>&gt;&gt; extension Array where Element == String {<br>&gt;&gt;   func makeSentence() -&gt; String {<br>&gt;&gt;     // uppercase first string, concatenate with spaces, add a period, whatever<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This is a highly-requested feature that fits into the existing syntax and semantics. Note that one could imagine introducing new syntax, e.g., extending “Array&lt;String&gt;”, which gets into new-feature territory: see the section on “Parameterized extensions”.<br>&gt; <br>&gt; Do we already support same-type constraints between two primary generic parameters or should this be added in as well?<br></p><p>That could also be added as part of this.<br></p><p>&gt;&gt; *Typealiases in protocols and protocol extensions<br>&gt;&gt; <br>&gt;&gt; Now that associated types have their own keyword (thanks!), it’s reasonable to bring back “typealias”. Again with the Sequence protocol:<br>&gt;&gt; <br>&gt;&gt; protocol Sequence {<br>&gt;&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;&gt;   typealias Element = Iterator.Element   // rejoice! now we can refer to SomeSequence.Element rather than SomeSequence.Iterator.Element<br>&gt;&gt; }<br>&gt; <br>&gt; If we decide to pass ‘Element’ as a top-level metadata parameter, this could be used an optimization hint, and would also have resilience implications.<br></p><p>By top-level metadata parameter, you mean create an entry for Element in the witness table? That would eliminate one hop when accessing the metadata,<br></p><p>&gt;&gt; Conditional conformances are a potentially very powerful feature. One important aspect of this feature is how deal with or avoid overlapping conformances. For example, imagine an adaptor over a Sequence that has conditional conformances to Collection and MutableCollection:<br>&gt; <br>&gt; Would it be enough to prohibit defining multiple conditional conformances to the same protocol for the same base type but with different ‘where’ clauses?<br></p><p>It’s more nuanced than that, because we need to consider the implied conformances as well.<br></p><p>protocol A { }<br>protocol B : A { }<br>protocol C : A { }<br></p><p>struct X&lt;T&gt; { }<br>extension X : B where T : B { } // implies a conformance to A<br>extension X : C where T : C { } // problem: also implies a conformance to A<br></p><p>Neither conformance to A is clearly “better”, because these constrained extensions are disjoint. The fix for this is actually to *add* an explicit conformance:<br></p><p>extension X : A where T : A { } // okay: here’s where the conformance to A lives<br></p><p>The important part here is that both the “”B” and “C” extensions have requirements that subsume the requirements of A, so rather than introduce their own implied conformances to A, they leverage the existing conformance from the less-specialized constrained extension.<br></p><p>&gt;&gt; <br>&gt;&gt; public struct ZipIterator&lt;... Iterators : IteratorProtocol&gt; : Iterator {  // zero or more type parameters, each of which conforms to IteratorProtocol<br>&gt; <br>&gt; Would this make sense too:<br>&gt; <br>&gt; struct ZipIterator&lt;… Iterators where Iterators : IteratorProtocol&gt;<br>&gt; <br>&gt; I’m wondering if we can replace current varargs with a desugaring along the lines of:<br>&gt; <br>&gt; func vararg(let a: A…) {<br>&gt; <br>&gt; }<br>&gt; <br>&gt; func vararg&lt;… T where T == A&gt;(let a: (T…)) { … }<br></p><p>We could treat it that way.<br></p><p>&gt; <br>&gt; Currently, varargs have a static number of arguments at the call site — instead of constructing an array, they could be passed as a tuple value, which would presumably be stack allocated at the call site. Together with a runtime entry point to get tuple metadata from a single element type repeated N times, this might be more efficient than varargs are now, where as far as I understand the array is allocated on the heap by the caller.<br></p><p>We could just decide that the “array” we get in the callee is only really materialized to the heap if it’s going to escape somewhere, and optimize for the common case where we can do stack allocation in the caller and the callee just directly consumes the result. In other words, I suspect we can optimize this case well (possibly better) without the desugaring. And it might affect our calling convention, so I’d want to make that decision long before we would get variadic generics.<br></p><p>&gt;&gt; There are some natural bounds here: one would need to have actual structural types. One would not be able to extend every type:<br>&gt;&gt; <br>&gt;&gt; extension&lt;T&gt; T { // error: neither a structural nor a nominal type<br>&gt;&gt; }<br>&gt; <br>&gt; Extending Any or AnyObject doesn’t seem too far-fetched, though, and almost feels like an artificial restriction at this point. Has nobody ever wanted this?<br></p><p>It’s been requested. Perhaps I shouldn’t be so quick to dismiss it.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; And before you think you’re cleverly making it possible to have a conditional conformance that makes every type T that conforms to protocol P also conform to protocol Q, see the section &quot;Conditional conformances via protocol extensions”, below:<br>&gt; <br>&gt; What about self-conforming protocols? I’m willing to bet most people don’t use static methods in protocols, so it seems unnatural that a protocol type cannot be bound to a generic parameter constrained to that protocol type. Today on Twitter we had someone doing something like this:<br>&gt; <br>&gt; protocol BaseProto {}<br>&gt; protocol RefinedProto : BaseProto {}<br>&gt; <br>&gt; func doStuff&lt;T : BaseProto&gt;(let a: [T]) {}<br>&gt; <br>&gt; getRefined() -&gt; [RefinedProto]<br>&gt; <br>&gt; doStuff(getRefined()) // doesn’t type check!<br>&gt; <br>&gt; Of course the underlying reason is that BaseProto does not conform to _itself_, which has nothing to do with RefinedProto.<br>&gt; <br>&gt; There are tricky representational issues with self-conforming protocols, especially class-constrained ones — we expect an instance of a class-constrained generic parameter to be a single retainable pointer, which is not the case if it is an existential with an associated witness table. But if we can figure this out, it would smooth over a sharp edge in the language that confuses people who are not intimately familiar with how existential types are represented (ie, everybody except for us :) ).<br>&gt; <br>&gt; This is different from opening existentials, because here we’re binding T to RefinedProto and cannot simultaneously open everything in the array…<br></p><p>Right. <br></p><p>&gt; <br>&gt;&gt; Specifying type arguments for uses of generic functions<br>&gt;&gt; <br>&gt;&gt; The type arguments of a generic function are always determined via type inference. For example, given:<br>&gt;&gt; <br>&gt;&gt; func f&lt;T&gt;(t: T)<br>&gt;&gt; <br>&gt;&gt; one cannot directly specify T: either one calls “f” (and T is determined via the argument’s type) or one uses “f” in a context where it is given a particular function type (e.g., “let x: (Int) -&gt; Void = f”  would infer T = Int). We could permit explicit specialization here, e.g.,<br>&gt;&gt; <br>&gt;&gt; let x = f&lt;Int&gt; // x has type (Int) -&gt; Void<br>&gt; <br>&gt; Are higher-kinded function values worth discussing too?<br></p><p>I’m not particularly motivated by them.<br></p><p>&gt;&gt; if let storedInE1 = e1 openas T {     // T is a the type of storedInE1, a copy of the value stored in e1<br>&gt;&gt;   if let storedInE2 = e2 as? T {      // is e2 also a T?<br>&gt;&gt;     if storedInE1 == storedInE2 { … } // okay: storedInT1 and storedInE2 are both of type T, which we know is Equatable<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt; <br>&gt; I’m worried that this is not really correct with inheritance. If e1 is an instance of SubClass, and e2 is an instance of SuperClass with SubClass : SuperClass, then your operation is no longer symmetric. Heterogeneous equality just seems like a pain in general.<br></p><p>Indeed, this is a problem with my example! We would have to check in both directions: e1 could contain a subclass of e2 or vice versa.<br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160302/53ed9273/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Manifesto] Completing Generics</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March  2, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt;&gt; if let storedInE1 = e1 openas T {     // T is a the type of storedInE1, a copy of the value stored in e1<br>&gt;&gt;   if let storedInE2 = e2 as? T {      // is e2 also a T?<br>&gt;&gt;     if storedInE1 == storedInE2 { … } // okay: storedInT1 and storedInE2 are both of type T, which we know is Equatable<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt; <br>&gt; I’m worried that this is not really correct with inheritance. If e1 is an instance of SubClass, and e2 is an instance of SuperClass with SubClass : SuperClass, then your operation is no longer symmetric. Heterogeneous equality just seems like a pain in general.<br></p><p>Following from the generic constants mentioned earlier, perhaps this is expressed with some kind of generic `if let`?<br></p><p>	func == (e1: Any&lt;Equatable&gt;, e2: Any&lt;Equatable&gt;) -&gt; Bool {<br>		guard let concreteE1&lt;T: Equatable&gt; = e1 as? T, concreteE2 = e2 as? T else {<br>			return false<br>		}<br>		<br>		// If we made it through that `guard`, there is some `Equatable` type `T` which `e1` <br>		// and `e2` both contain.<br>		// (However, I&#39;m not sure why this type couldn&#39;t be `Any&lt;Equatable&gt;`.)<br>		<br>		return concreteE1 == concreteE2<br>	}<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>[Manifesto] Completing Generics</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>March  2, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Mar 2, 2016, at 10:45 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; if let storedInE1 = e1 openas T {     // T is a the type of storedInE1, a copy of the value stored in e1<br>&gt;&gt;&gt;  if let storedInE2 = e2 as? T {      // is e2 also a T?<br>&gt;&gt;&gt;    if storedInE1 == storedInE2 { … } // okay: storedInT1 and storedInE2 are both of type T, which we know is Equatable<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I’m worried that this is not really correct with inheritance. If e1 is an instance of SubClass, and e2 is an instance of SuperClass with SubClass : SuperClass, then your operation is no longer symmetric. Heterogeneous equality just seems like a pain in general.<br>&gt; <br>&gt; Following from the generic constants mentioned earlier, perhaps this is expressed with some kind of generic `if let`?<br>&gt; <br>&gt; 	func == (e1: Any&lt;Equatable&gt;, e2: Any&lt;Equatable&gt;) -&gt; Bool {<br>&gt; 		guard let concreteE1&lt;T: Equatable&gt; = e1 as? T, concreteE2 = e2 as? T else {<br></p><p>I think here the generic signature should really come first before any patterns, so more like ‘guard let &lt;T : Equatable&gt; …&#39;.<br></p><p>But this is rather complicated. I fear. Perhaps a well-crafted one-off language feature to handle heterogeneous equality is better.<br></p><p>Here’s a really not-serious proposal: it seems we could implement GADTs if we allowed enum cases to have generic parameter lists, and extended pattern matching as above.<br></p><p>enum Foo {<br>	case Something&lt;T&gt;(T)<br>	case Nothing<br>}<br></p><p>let a: [Foo] // could contain many different Something types<br></p><p>Slava<br></p><p>&gt; 			return false<br>&gt; 		}<br>&gt; 		<br>&gt; 		// If we made it through that `guard`, there is some `Equatable` type `T` which `e1` <br>&gt; 		// and `e2` both contain.<br>&gt; 		// (However, I&#39;m not sure why this type couldn&#39;t be `Any&lt;Equatable&gt;`.)<br>&gt; 		<br>&gt; 		return concreteE1 == concreteE2<br>&gt; 	}<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Manifesto] Completing Generics</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March  3, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Mar 2, 2016, at 10:59 PM, Slava Pestov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Mar 2, 2016, at 10:45 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; if let storedInE1 = e1 openas T {     // T is a the type of storedInE1, a copy of the value stored in e1<br>&gt;&gt;&gt;&gt; if let storedInE2 = e2 as? T {      // is e2 also a T?<br>&gt;&gt;&gt;&gt;   if storedInE1 == storedInE2 { … } // okay: storedInT1 and storedInE2 are both of type T, which we know is Equatable<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m worried that this is not really correct with inheritance. If e1 is an instance of SubClass, and e2 is an instance of SuperClass with SubClass : SuperClass, then your operation is no longer symmetric. Heterogeneous equality just seems like a pain in general.<br>&gt;&gt; <br>&gt;&gt; Following from the generic constants mentioned earlier, perhaps this is expressed with some kind of generic `if let`?<br>&gt;&gt; <br>&gt;&gt; 	func == (e1: Any&lt;Equatable&gt;, e2: Any&lt;Equatable&gt;) -&gt; Bool {<br>&gt;&gt; 		guard let concreteE1&lt;T: Equatable&gt; = e1 as? T, concreteE2 = e2 as? T else {<br>&gt; <br>&gt; I think here the generic signature should really come first before any patterns, so more like ‘guard let &lt;T : Equatable&gt; …&#39;.<br>&gt; <br>&gt; But this is rather complicated. I fear. Perhaps a well-crafted one-off language feature to handle heterogeneous equality is better.<br>&gt; <br>&gt; Here’s a really not-serious proposal: it seems we could implement GADTs if we allowed enum cases to have generic parameter lists, and extended pattern matching as above.<br>&gt; <br>&gt; enum Foo {<br>&gt; 	case Something&lt;T&gt;(T)<br>&gt; 	case Nothing<br>&gt; }<br>&gt; <br>&gt; let a: [Foo] // could contain many different Something types<br></p><p>And then we introduce higher-order &#39;protocol&#39; constraints, and implement &#39;Any&#39; in the library!<br></p><p>enum Any&lt;Constraints: protocol&gt; {<br>  case Value&lt;T: Constraints&gt;(T)<br>}<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160303/9a23b99c/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Manifesto] Completing Generics</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>March  3, 2016 at 07:00:00am</p></header><div class="content"><p>Thanks for publishing the manifesto; for the most part everything seems reasonable and logical extensions that would “complete&quot; the current system.<br></p><p>I do have a few remarks and I’m going to put them each in a separate email (they don’t relate to each other).<br></p><p># Comment: Variadic Generics “Need” Structural Union Types<br></p><p>Disclaimer: I’m not 100% sure on the terminology; I’m using “structural union” here to mean an “anonymous enum” (like “A | B | C | D”) wherein both (a) the order matters (e.g. `(A | B | C | D)` and `(D | C | B | A)` are different types) and also (b) types can repeated (e.g. `(Int | Int | Int)` exists and isn’t just `Int`). If that’s not a &quot;structural union” I apologize for the inappropriate terminology.<br></p><p>Content: I think variadic generics will wind up being rather limited in their utility w/out a correspondingly-variadic form of “structural union”; the reason is that for many type-combinators the right representation for some of the resulting associated types is a sum. <br></p><p>Here’s a motivating example: a read-only collection acts as the concatenation of its `n` input collections. Today this requires a family of types (one per `n` you wish to support) and would superficially seem like a good place to use variadic generics...but it’s not so straightforward:<br></p><p>// non-variadic version:<br>struct ChainCollection3&lt;A:Collection,B:Collection,C:Collection&gt; : Collection {<br>  let a = A<br>  let b = B<br>  let c = C<br>}<br></p><p>enum ChainCollection3Index&lt;A:Collection,B:Collection,C:Collection&gt; : ForwardIndex {<br>  case IndexA(A.Index) // &lt;- can’t be just `A` due to name collision!<br>  case IndexB(B.Index) //<br>  case IndexC(C.Index) //<br>}<br></p><p>// showing the index in use:<br>extension ChainCollection3 {<br></p><p>  associatedtype Index = ChainCollection3Index&lt;A,B,C&gt;<br></p><p>  var startIndex: Index { return .IndexA(a.startIndex) }<br>  var endIndex: Index { return .IndexC(c.endIndex) }<br></p><p>  // the below isn’t actually correct b/c it doesn’t<br>  // properly handle the case when one of the constituent<br>  // collections is empty…also assuming collections-move-indices:<br>  func successorFor(index: Index) -&gt; Index {<br>    switch (index) {<br>      case let .IndexA(aIndex):<br>        return aIndex == a.endIndex ? .IndexB(b.startIndex) : .IndexA(a.successorFor(aIndex))<br>      case let .IndexB(bIndex):<br>        return bIndex == b.endIndex ? .IndexC(c.startIndex) : .IndexB(b.successorFor(bIndex))<br>      case let .IndexC(cIndex):<br>        precondition(cIndex != c.endIndex)<br>        return .IndexC(c.successorFor(cIndex))       <br>    }<br>  }<br></p><p>  // and so on, mostly obvious boilerplate<br></p><p>}<br></p><p>…and although a good variadic generics system could eliminate the need for the family like ChainCollection*, it’s hard to see how you could implement an `Index` type in the variadic setting—without which you are “capped” at the `Sequence` level—w/out also having *variadic* structural unions (I think the best you could *maybe* do is manually implement the equivalent of that enum as e.g. a managed buffer with a type tag and a lot of casting, but you wouldn’t *want* to do that...).<br></p><p>Perhaps I’m missing a trick here, but if I’m not it does seem like the lack of variadic structural unions places a pretty low ceiling on what you could build using variadic generics.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Manifesto] Completing Generics</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>March  3, 2016 at 08:00:00am</p></header><div class="content"><p># Missing Idea: Protocols Restricted to Specific Classes<br></p><p>This has come up on the list somewhat often (cf the current abstract class thread).<br></p><p>The idea is being able to write the below:<br></p><p>// expectation is we are defining a protocol that can only be adopted by classes<br>// that are subclasses of `UIViewController`<br>protocol SpecializedViewController : UIViewController {<br>}<br></p><p>…the absence of which is something that *can* be worked-around today, but it’d be nice not to have to work around it (or to have it added to the “unlikely” category if there’s a deep reason this isn’t feasible).<br></p><p>Also, it’s possible that this *may* be addressed already (e.g. perhaps this is implicit in “generic typealiases”?).<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Manifesto] Completing Generics</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>March  3, 2016 at 08:00:00am</p></header><div class="content"><p># Missing Idea: &quot;Type Predicates”<br></p><p>This is another way of attacking the “where clauses get too long” problem; it may already be implicitly part of “generic typealiases”.<br></p><p>Consider being able to write a declaration like this:<br></p><p>protocol SpecializedContainer {<br></p><p>  associatedtype Element: Comparable<br>  <br>  // potential declaration:<br>  typepredicate Compatible(S:SequenceType) = S.Generator.Element == Element<br></p><p>  // potential use syntaxes (tbd):<br>  func insertContentsOf&lt;S:SequenceType where Compatible(S)&gt;(elements: S)<br>  func insertContentsOf&lt;Compatible(S)&gt;(elements: S) // &lt;- potential shorthand<br>  <br>}<br></p><p>…which isn’t the strongest motivating example on its own, but if you start to consider use cases where we will wind up having longer “where” clauses (and I think we will, over time) it may start paying its own way.<br></p><p>This probably falls under “minor feature” (and if added I’d hope the implementation picks a simple semantics for it), but something along these lines may do a decent job of addressing some of the same issues that motivate request to be able to write `Sequence&lt;T&gt;`.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Manifesto] Completing Generics</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>March  3, 2016 at 08:00:00am</p></header><div class="content"><p>Nested generic types are definitely a big +1 from me. In particular if I can use them to fulfil associated type requirements, for example:<br></p><p>	protocol FooType {<br>		typealias Element<br>		typealias Index<br>	}<br></p><p>	struct Foo&lt;E&gt; : FooType {<br>		typealias Element = E<br>		struct Index { … }<br>	}<br></p><p>The other thing I’d like to see for generics isn’t really a new feature, but I’d like to be able to define protocol generics in the same format as for types, i.e- I could rewrite the above protocol as:<br></p><p>	protocol FooType&lt;Element, Index&gt; {}<br></p><p>Likewise when placing constraints on methods etc.:<br></p><p>	func myMethod(someFoo:FooType&lt;String, Int&gt;) { … }<br></p><p>Even if behind the scenes these are still unwrapped into associated types and where clauses, it’s just much, much easier to work with in the majority of cases (where clauses would still exist for the more complex ones).<br></p><p>The other capabilities you’ve described all seem very useful, but it’s probably going to take a day or two to get my head around all of them!<br></p><p>&gt; On 3 Mar 2016, at 01:22, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; Introduction<br>&gt; <br>&gt; The “Complete Generics” goal for Swift 3 has been fairly ill-defined thus fair, with just this short blurb in the list of goals:<br>&gt; <br>&gt; Complete generics: Generics are used pervasively in a number of Swift libraries, especially the standard library. However, there are a number of generics features the standard library requires to fully realize its vision, including recursive protocol constraints, the ability to make a constrained extension conform to a new protocol (i.e., an array of Equatable elements is Equatable), and so on. Swift 3.0 should provide those generics features needed by the standard library, because they affect the standard library&#39;s ABI.<br>&gt; This message expands upon the notion of “completing generics”. It is not a plan for Swift 3, nor an official core team communication, but it collects the results of numerous discussions among the core team and Swift developers, both of the compiler and the standard library. I hope to achieve several things:<br>&gt; <br>&gt; Communicate a vision for Swift generics, building on the original generics design document &lt;https://github.com/apple/swift/blob/master/docs/Generics.rst&gt;, so we have something concrete and comprehensive to discuss.<br>&gt; Establish some terminology that the Swift developers have been using for these features, so our discussions can be more productive (“oh, you’re proposing what we refer to as ‘conditional conformances’; go look over at this thread”).<br>&gt; Engage more of the community in discussions of specific generics features, so we can coalesce around designs for public review. And maybe even get some of them implemented.<br>&gt; <br>&gt; A message like this can easily turn into a centithread &lt;http://www.urbandictionary.com/define.php?term=centithread&gt;. To separate concerns in our discussion, I ask that replies to this specific thread be limited to discussions of the vision as a whole: how the pieces fit together, what pieces are missing, whether this is the right long-term vision for Swift, and so on. For discussions of specific language features, e.g., to work out the syntax and semantics of conditional conformances or discuss the implementation in compiler or use in the standard library, please start a new thread based on the feature names I’m using.<br>&gt; <br>&gt; This message covers a lot of ground; I’ve attempted a rough categorization of the various features, and kept the descriptions brief to limit the overall length. Most of these aren’t my ideas, and any syntax I’m providing is simply a way to express these ideas in code and is subject to change. Not all of these features will happen, either soon or ever, but they are intended to be a fairly complete whole that should mesh together. I’ve put a * next to features that I think are important in the nearer term vs. being interesting “some day”. Mostly, the *’s reflect features that will have a significant impact on the Swift standard library’s design and implementation.<br>&gt; <br>&gt; Enough with the disclaimers; it’s time to talk features.<br>&gt; <br>&gt; Removing unnecessary restrictions<br>&gt; <br>&gt; There are a number of restrictions to the use of generics that fall out of the implementation in the Swift compiler. Removal of these restrictions is a matter of implementation only; one need not introduce new syntax or semantics to realize them. I’m listing them for two reasons: first, it’s an acknowledgment that these features are intended to exist in the model we have today, and, second, we’d love help with the implementation of these features.<br>&gt; <br>&gt; <br>&gt; *Recursive protocol constraints<br>&gt; <br>&gt; Currently, an associated type cannot be required to conform to its enclosing protocol (or any protocol that inherits that protocol). For example, in the standard library SubSequence type of a Sequence should itself be a Sequence:<br>&gt; <br>&gt; protocol Sequence {<br>&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;   …<br>&gt;   associatedtype SubSequence : Sequence   // currently ill-formed, but should be possible<br>&gt; }<br>&gt; <br>&gt; The compiler currently rejects this protocol, which is unfortunate: it effectively pushes the SubSequence-must-be-a-Sequence requirement into every consumer of SubSequence, and does not communicate the intent of this abstraction well.<br>&gt; <br>&gt; Nested generics<br>&gt; <br>&gt; Currently, a generic type cannot be nested within another generic type, e.g.<br>&gt; <br>&gt; struct X&lt;T&gt; {<br>&gt;   struct Y&lt;U&gt; { }  // currently ill-formed, but should be possible<br>&gt; }<br>&gt; <br>&gt; There isn’t much to say about this: the compiler simply needs to be improved to handle nested generics throughout.<br>&gt; <br>&gt; <br>&gt; Concrete same-type requirements<br>&gt; <br>&gt; Currently, a constrained extension cannot use a same-type constraint to make a type parameter equivalent to a concrete type. For example:<br>&gt; <br>&gt; extension Array where Element == String {<br>&gt;   func makeSentence() -&gt; String {<br>&gt;     // uppercase first string, concatenate with spaces, add a period, whatever<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; This is a highly-requested feature that fits into the existing syntax and semantics. Note that one could imagine introducing new syntax, e.g., extending “Array&lt;String&gt;”, which gets into new-feature territory: see the section on “Parameterized extensions”.<br>&gt; <br>&gt; Parameterizing other declarations<br>&gt; <br>&gt; There are a number of Swift declarations that currently cannot have generic parameters; some of those have fairly natural extensions to generic forms that maintain their current syntax and semantics, but become more powerful when made generic.<br>&gt; <br>&gt; Generic typealiases<br>&gt; <br>&gt; Typealiases could be allowed to carry generic parameters. They would still be aliases (i.e., they would not introduce new types). For example:<br>&gt; <br>&gt; typealias StringDictionary&lt;Value&gt; = Dictionary&lt;String, Value&gt;<br>&gt; <br>&gt; var d1 = StringDictionary&lt;Int&gt;()<br>&gt; var d2: Dictionary&lt;String, Int&gt; = d1 // okay: d1 and d2 have the same type, Dictionary&lt;String, Int&gt;<br>&gt; <br>&gt; <br>&gt; Generic subscripts<br>&gt; <br>&gt; Subscripts could be allowed to have generic parameters. For example, we could introduce a generic subscript on a Collection that allows us to pull out the values at an arbitrary set of indices:<br>&gt; <br>&gt; extension Collection {<br>&gt;   subscript&lt;Indices: Sequence where Indices.Iterator.Element == Index&gt;(indices: Indices) -&gt; [Iterator.Element] {<br>&gt;     get {<br>&gt;       var result = [Iterator.Element]()<br>&gt;       for index in indices {<br>&gt;         result.append(self[index])<br>&gt;       }<br>&gt; <br>&gt;       return result<br>&gt;     }<br>&gt; <br>&gt;     set {<br>&gt;       for (index, value) in zip(indices, newValue) {<br>&gt;         self[index] = value<br>&gt;       }<br>&gt;     }<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; Generic constants<br>&gt; <br>&gt; let constants could be allowed to have generic parameters, such that they produce differently-typed values depending on how they are used. For example, this is particularly useful for named literal values, e.g.,<br>&gt; <br>&gt; let π&lt;T : FloatLiteralConvertible&gt;: T = 3.141592653589793238462643383279502884197169399<br>&gt; <br>&gt; The Clang importer could make particularly good use of this when importing macros.<br>&gt; <br>&gt; <br>&gt; Parameterized extensions<br>&gt; <br>&gt; Extensions themselves could be parameterized, which would allow some structural pattern matching on types. For example, this would permit one to extend an array of optional values, e.g.,<br>&gt; <br>&gt; extension&lt;T&gt; Array where Element == T? {<br>&gt;   var someValues: [T] {<br>&gt;     var result = [T]()<br>&gt;     for opt in self {<br>&gt;       if let value = opt { result.append(value) }<br>&gt;     }<br>&gt;    return result<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; We can generalize this to a protocol extensions:<br>&gt; <br>&gt; extension&lt;T&gt; Sequence where Element == T? {<br>&gt;   var someValues: [T] {<br>&gt;     var result = [T]()<br>&gt;     for opt in self {<br>&gt;       if let value = opt { result.append(value) }<br>&gt;     }<br>&gt;    return result<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; Note that when one is extending nominal types, we could simplify the syntax somewhat to make the same-type constraint implicit in the syntax:<br>&gt; <br>&gt; extension&lt;T&gt; Array&lt;T?&gt; {<br>&gt;   var someValues: [T] {<br>&gt;     var result = [T]()<br>&gt;     for opt in self {<br>&gt;       if let value = opt { result.append(value) }<br>&gt;     }<br>&gt;    return result<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; When we’re working with concrete types, we can use that syntax to improve the extension of concrete versions of generic types (per “Concrete same-type requirements”, above), e.g.,<br>&gt; <br>&gt; extension Array&lt;String&gt; {<br>&gt;   func makeSentence() -&gt; String {<br>&gt;     // uppercase first string, concatenate with spaces, add a period, whatever<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; Minor extensions<br>&gt; <br>&gt; There are a number of minor extensions we can make to the generics system that don’t fundamentally change what one can express in Swift, but which can improve its expressivity.<br>&gt; <br>&gt; *Arbitrary requirements in protocols<br>&gt; <br>&gt; Currently, a new protocol can inherit from other protocols, introduce new associated types, and add new conformance constraints to associated types (by redeclaring an associated type from an inherited protocol). However, one cannot express more general constraints. Building on the example from “Recursive protocol constraints”, we really want the element type of a Sequence’s SubSequence to be the same as the element type of the Sequence, e.g.,<br>&gt; <br>&gt; protocol Sequence {<br>&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;   …<br>&gt;   associatedtype SubSequence : Sequence where SubSequence.Iterator.Element == Iterator.Element<br>&gt; }<br>&gt; <br>&gt; Hanging the where clause off the associated type is protocol not ideal, but that’s a discussion for another thread.<br>&gt; <br>&gt; <br>&gt; *Typealiases in protocols and protocol extensions<br>&gt; <br>&gt; Now that associated types have their own keyword (thanks!), it’s reasonable to bring back “typealias”. Again with the Sequence protocol:<br>&gt; <br>&gt; protocol Sequence {<br>&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;   typealias Element = Iterator.Element   // rejoice! now we can refer to SomeSequence.Element rather than SomeSequence.Iterator.Element<br>&gt; }<br>&gt; <br>&gt; <br>&gt; Default generic arguments <br>&gt; <br>&gt; Generic parameters could be given the ability to provide default arguments, which would be used in cases where the type argument is not specified and type inference could not determine the type argument. For example:<br>&gt; <br>&gt; public final class Promise&lt;Value, Reason=Error&gt; { … }<br>&gt; <br>&gt; func getRandomPromise() -&gt; Promise&lt;Int, ErrorProtocol&gt; { … }<br>&gt; <br>&gt; var p1: Promise&lt;Int&gt; = …<br>&gt; var p2: Promise&lt;Int, Error&gt; = p1     // okay: p1 and p2 have the same type Promise&lt;Int, Error&gt;<br>&gt; var p3: Promise = getRandomPromise() // p3 has type Promise&lt;Int, ErrorProtocol&gt; due to type inference<br>&gt; <br>&gt; <br>&gt; Generalized “class” constraints<br>&gt; <br>&gt; The “class” constraint can currently only be used for defining protocols. We could generalize it to associated type and type parameter declarations, e.g.,<br>&gt; <br>&gt; protocol P {<br>&gt;   associatedtype A : class<br>&gt; }<br>&gt; <br>&gt; func foo&lt;T : class&gt;(t: T) { }<br>&gt; <br>&gt; As part of this, the magical AnyObject protocol could be replaced with an existential with a class bound, so that it becomes a typealias:<br>&gt; <br>&gt; typealias AnyObject = protocol&lt;class&gt;<br>&gt; <br>&gt; See the “Existentials” section, particularly “Generalized existentials”, for more information.<br>&gt; <br>&gt; <br>&gt; *Allowing subclasses to override requirements satisfied by defaults<br>&gt; <br>&gt; When a superclass conforms to a protocol and has one of the protocol’s requirements satisfied by a member of a protocol extension, that member currently cannot be overridden by a subclass. For example:<br>&gt; <br>&gt; protocol P {<br>&gt;   func foo()<br>&gt; }<br>&gt; <br>&gt; extension P {<br>&gt;   func foo() { print(“P”) }<br>&gt; }<br>&gt; <br>&gt; class C : P {<br>&gt;   // gets the protocol extension’s <br>&gt; }<br>&gt; <br>&gt; class D : C {<br>&gt;   /*override not allowed!*/ func foo() { print(“D”) }<br>&gt; }<br>&gt; <br>&gt; let p: P = D()<br>&gt; p.foo() // gotcha: prints “P” rather than “D”!<br>&gt; <br>&gt; D.foo should be required to specify “override” and should be called dynamically.<br>&gt; <br>&gt; <br>&gt; Major extensions to the generics model<br>&gt; <br>&gt; Unlike the minor extensions, major extensions to the generics model provide more expressivity in the Swift generics system and, generally, have a much more significant design and implementation cost.<br>&gt; <br>&gt; <br>&gt; *Conditional conformances<br>&gt; <br>&gt; Conditional conformances express the notion that a generic type will conform to a particular protocol only under certain circumstances. For example, Array is Equatable only when its elements are Equatable:<br>&gt; <br>&gt; extension Array : Equatable where Element : Equatable { }<br>&gt; <br>&gt; func ==&lt;T : Equatable&gt;(lhs: Array&lt;T&gt;, rhs: Array&lt;T&gt;) -&gt; Bool { … }<br>&gt; <br>&gt; Conditional conformances are a potentially very powerful feature. One important aspect of this feature is how deal with or avoid overlapping conformances. For example, imagine an adaptor over a Sequence that has conditional conformances to Collection and MutableCollection:<br>&gt; <br>&gt; struct SequenceAdaptor&lt;S: Sequence&gt; : Sequence { }<br>&gt; extension SequenceAdaptor : Collection where S: Collection { … }<br>&gt; extension SequenceAdaptor : MutableCollection where S: MutableCollection { }<br>&gt; <br>&gt; This should almost certainly be permitted, but we need to cope with or reject “overlapping” conformances:<br>&gt; <br>&gt; extension SequenceAdaptor : Collection where S: SomeOtherProtocolSimilarToCollection { } // trouble: two ways for SequenceAdaptor to conform to Collection<br>&gt; <br>&gt; See the section on “Private conformances” for more about the issues with having the same type conform to the same protocol multiple times.<br>&gt; <br>&gt; <br>&gt; Variadic generics<br>&gt; <br>&gt; Currently, a generic parameter list contains a fixed number of generic parameters. If one has a type that could generalize to any number of generic parameters, the only real way to deal with it today involves creating a set of types. For example, consider the standard library’s “zip” function. It returns one of these when provided with two arguments to zip together:<br>&gt; <br>&gt; public struct Zip2Sequence&lt;Sequence1 : Sequence,<br>&gt;                            Sequence2 : Sequence&gt; : Sequence { … }<br>&gt; <br>&gt; public func zip&lt;Sequence1 : Sequence, Sequence2 : Sequence&gt;(<br>&gt;               sequence1: Sequence1, _ sequence2: Sequence2)<br>&gt;             -&gt; Zip2Sequence&lt;Sequence1, Sequence2&gt; { … }<br>&gt; <br>&gt; Supporting three arguments would require copy-paste of those of those:<br>&gt; <br>&gt; public struct Zip3Sequence&lt;Sequence1 : Sequence,<br>&gt;                            Sequence2 : Sequence,<br>&gt;                            Sequence3 : Sequence&gt; : Sequence { … }<br>&gt; <br>&gt; public func zip&lt;Sequence1 : Sequence, Sequence2 : Sequence, Sequence3 : Sequence&gt;(<br>&gt;               sequence1: Sequence1, _ sequence2: Sequence2, _ sequence3: sequence3)<br>&gt;             -&gt; Zip3Sequence&lt;Sequence1, Sequence2, Sequence3&gt; { … }<br>&gt; <br>&gt; Variadic generics would allow us to abstract over a set of generic parameters. The syntax below is hopelessly influenced by C++11 variadic templates &lt;http://www.jot.fm/issues/issue_2008_02/article2/&gt; (sorry), where putting an ellipsis (“…”) to the left of a declaration makes it a “parameter pack” containing zero or more parameters and putting an ellipsis to the right of a type/expression/etc. expands the parameter packs within that type/expression into separate arguments. The important part is that we be able to meaningfully abstract over zero or more generic parameters, e.g.:<br>&gt; <br>&gt; public struct ZipIterator&lt;... Iterators : IteratorProtocol&gt; : Iterator {  // zero or more type parameters, each of which conforms to IteratorProtocol<br>&gt;   public typealias Element = (Iterators.Element...)                       // a tuple containing the element types of each iterator in Iterators<br>&gt; <br>&gt;   var (...iterators): (Iterators...)    // zero or more stored properties, one for each type in Iterators <br>&gt;   var reachedEnd: Bool = false<br>&gt; <br>&gt;   public mutating func next() -&gt; Element? {<br>&gt;     if reachedEnd { return nil }<br>&gt; <br>&gt;     guard let values = (iterators.next()...) {   // call “next” on each of the iterators, put the results into a tuple named “values&quot;<br>&gt;       reachedEnd = true<br>&gt;       return nil<br>&gt;     }<br>&gt; <br>&gt;     return values<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; public struct ZipSequence&lt;...Sequences : Sequence&gt; : Sequence {<br>&gt;   public typealias Iterator = ZipIterator&lt;Sequences.Iterator...&gt;   // get the zip iterator with the iterator types of our Sequences<br>&gt; <br>&gt;   var (...sequences): (Sequences...)    // zero or more stored properties, one for each type in Sequences <br>&gt; <br>&gt;   // details ...<br>&gt; }<br>&gt; <br>&gt; Such a design could also work for function parameters, so we can pack together multiple function arguments with different types, e.g.,<br>&gt; <br>&gt; public func zip&lt;... Sequences : SequenceType&gt;(... sequences: Sequences...) <br>&gt;             -&gt; ZipSequence&lt;Sequences...&gt; {<br>&gt;   return ZipSequence(sequences...)<br>&gt; }<br>&gt; <br>&gt; Finally, this could tie into the discussions about a tuple “splat” operator. For example:<br>&gt; <br>&gt; func apply&lt;... Args, Result&gt;(fn: (Args...) -&gt; Result,    // function taking some number of arguments and producing Result<br>&gt;                            args: (Args...)) -&gt; Result {  // tuple of arguments<br>&gt;   return fn(args...)                                     // expand the arguments in the tuple “args” into separate arguments<br>&gt; }<br>&gt; <br>&gt; <br>&gt; Extensions of structural types<br>&gt; <br>&gt; Currently, only nominal types (classes, structs, enums, protocols) can be extended. One could imagine extending structural types—particularly tuple types—to allow them to, e.g., conform to protocols. For example, pulling together variadic generics, parameterized extensions, and conditional conformances, one could express “a tuple type is Equatable if all of its element types are Equatable”:<br>&gt; <br>&gt; extension&lt;...Elements : Equatable&gt; (Elements...) : Equatable {   // extending the tuple type “(Elements…)” to be Equatable<br>&gt; }<br>&gt; <br>&gt; There are some natural bounds here: one would need to have actual structural types. One would not be able to extend every type:<br>&gt; <br>&gt; extension&lt;T&gt; T { // error: neither a structural nor a nominal type<br>&gt; }<br>&gt; <br>&gt; And before you think you’re cleverly making it possible to have a conditional conformance that makes every type T that conforms to protocol P also conform to protocol Q, see the section &quot;Conditional conformances via protocol extensions”, below:<br>&gt; <br>&gt; extension&lt;T : P&gt; T : Q { // error: neither a structural nor a nominal type<br>&gt; }<br>&gt; <br>&gt; <br>&gt; Syntactic improvements<br>&gt; <br>&gt; There are a number of potential improvements we could make to the generics syntax. Such a list could go on for a very long time, so I’ll only highlight some obvious ones that have been discussed by the Swift developers.<br>&gt; <br>&gt; *Default implementations in protocols<br>&gt; <br>&gt; Currently, protocol members can never have implementations. We could allow one to provide such implementations to be used as the default if a conforming type does not supply an implementation, e.g.,<br>&gt; <br>&gt; protocol Bag {<br>&gt;   associatedtype Element : Equatable<br>&gt;   func contains(element: Element) -&gt; Bool<br>&gt; <br>&gt;   func containsAll&lt;S: Sequence where Sequence.Iterator.Element == Element&gt;(elements: S) -&gt; Bool {<br>&gt;     for x in elements {<br>&gt;       if contains(x) { return true }<br>&gt;     }<br>&gt;     return false<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; struct IntBag : Bag {<br>&gt;   typealias Element = Int<br>&gt;   func contains(element: Int) -&gt; Bool { ... }<br>&gt; <br>&gt;   // okay: containsAll requirement is satisfied by Bag’s default implementation<br>&gt; }<br>&gt; <br>&gt; One can get this effect with protocol extensions today, hence the classification of this feature as a (mostly) syntactic improvement:<br>&gt; <br>&gt; protocol Bag {<br>&gt;   associatedtype Element : Equatable<br>&gt;   func contains(element: Element) -&gt; Bool<br>&gt; <br>&gt;   func containsAll&lt;S: Sequence where Sequence.Iterator.Element == Element&gt;(elements: S) -&gt; Bool<br>&gt; }<br>&gt; <br>&gt; extension Bag {<br>&gt;   func containsAll&lt;S: Sequence where Sequence.Iterator.Element == Element&gt;(elements: S) -&gt; Bool {<br>&gt;     for x in elements {<br>&gt;       if contains(x) { return true }<br>&gt;     }<br>&gt;     return false<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; *Moving the where clause outside of the angle brackets<br>&gt; <br>&gt; The “where” clause of generic functions comes very early in the declaration, although it is generally of much less concern to the client than the function parameters and result type that follow it. This is one of the things that contributes to “angle bracket blindness”. For example, consider the containsAll signature above:<br>&gt; <br>&gt; func containsAll&lt;S: Sequence where Sequence.Iterator.Element == Element&gt;(elements: S) -&gt; Bool<br>&gt; <br>&gt; One could move the “where” clause to the end of the signature, so that the most important parts—name, generic parameter, parameters, result type—precede it:<br>&gt; <br>&gt; func containsAll&lt;S: Sequence&gt;(elements: S) -&gt; Bool <br>&gt;        where Sequence.Iterator.Element == Element<br>&gt; <br>&gt; <br>&gt; *Renaming “protocol&lt;…&gt;” to “Any&lt;…&gt;”.<br>&gt; <br>&gt; The “protocol&lt;…&gt;” syntax is a bit of an oddity in Swift. It is used to compose protocols together, mostly to create values of existential type, e.g.,<br>&gt; <br>&gt; var x: protocol&lt;NSCoding, NSCopying&gt;<br>&gt; <br>&gt; It’s weird that it’s a type name that starts with a lowercase letter, and most Swift developers probably never deal with this feature unless they happen to look at the definition of Any:<br>&gt; <br>&gt; typealias Any = protocol&lt;&gt;<br>&gt; <br>&gt; “Any” might be a better name for this functionality. “Any” without brackets could be a keyword for “any type”, and “Any” followed by brackets could take the role of “protocol&lt;&gt;” today:<br>&gt; <br>&gt; var x: Any&lt;NSCoding, NSCopying&gt;<br>&gt; <br>&gt; That reads much better: “Any type that conforms to NSCoding and NSCopying”. See the section &quot;Generalized existentials” for additional features in this space.<br>&gt; <br>&gt; Maybe<br>&gt; <br>&gt; There are a number of features that get discussed from time-to-time, while they could fit into Swift’s generics system, it’s not clear that they belong in Swift at all. The important question for any feature in this category is not “can it be done” or “are there cool things we can express”, but “how can everyday Swift developers benefit from the addition of such a feature?”. Without strong motivating examples, none of these “maybes” will move further along.<br>&gt; <br>&gt; Dynamic dispatch for members of protocol extensions<br>&gt; <br>&gt; Only the requirements of protocols currently use dynamic dispatch, which can lead to surprises:<br>&gt; <br>&gt; protocol P {<br>&gt;   func foo()<br>&gt; }<br>&gt; <br>&gt; extension P {<br>&gt;   func foo() { print(“P.foo()”)<br>&gt;   func bar() { print(“P.bar()”)<br>&gt; }<br>&gt; <br>&gt; struct X : P {<br>&gt;   func foo() { print(“X.foo()”)<br>&gt;   func bar() { print(“X.bar()”)<br>&gt; }<br>&gt; <br>&gt; let x = X()<br>&gt; x.foo() // X.foo()<br>&gt; x.bar() // X.bar()<br>&gt; <br>&gt; let p: P = X()<br>&gt; p.foo() // X.foo()<br>&gt; p.bar() // P.bar()<br>&gt; <br>&gt; Swift could adopt a model where members of protocol extensions are dynamically dispatched.<br>&gt; <br>&gt; Named generic parameters<br>&gt; <br>&gt; When specifying generic arguments for a generic type, the arguments are always positional: Dictionary&lt;String, Int&gt; is a Dictionary whose Key type is String and whose Value type is Int, by convention. One could permit the arguments to be labeled, e.g.,<br>&gt; <br>&gt; var d: Dictionary&lt;Key: String, Value: Int&gt;<br>&gt; <br>&gt; Such a feature makes more sense if Swift gains default generic arguments, because generic argument labels would allow one to skip defaulted arguments.<br>&gt; <br>&gt; Generic value parameters<br>&gt; <br>&gt; Currently, Swift’s generic parameters are always types. One could imagine allowing generic parameters that are values, e.g.,<br>&gt; <br>&gt; struct MultiArray&lt;T, let Dimensions: Int&gt; { // specify the number of dimensions to the array<br>&gt;   subscript (indices: Int...) -&gt; T {<br>&gt;     get {<br>&gt;       require(indices.count == Dimensions)<br>&gt;       // ...<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; A suitably general feature might allow us to express fixed-length array or vector types as a standard library component, and perhaps also allow one to implement a useful dimensional analysis library. Tackling this feature potentially means determining what it is for an expression to be a “constant expression” and diving into dependent-typing, hence the “maybe”.<br>&gt; <br>&gt; Higher-kinded types<br>&gt; <br>&gt; Higher-kinded types allow one to express the relationship between two different specializations of the same nominal type within a protocol. For example, if we think of the Self type in a protocol as really being “Self&lt;T&gt;”, it allows us to talk about the relationship between “Self&lt;T&gt;” and “Self&lt;U&gt;” for some other type U. For example, it could allow the “map” operation on a collection to return a collection of the same kind but with a different operation, e.g.,<br>&gt; <br>&gt; let intArray: Array&lt;Int&gt; = …<br>&gt; intArray.map { String($0) } // produces Array&lt;String&gt;<br>&gt; let intSet: Set&lt;Int&gt; = …<br>&gt; intSet.map { String($0) }   // produces Set&lt;String&gt;<br>&gt; <br>&gt; <br>&gt; Potential syntax borrowed from one thread on higher-kinded types &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002736.html&gt; uses ~= as a “similarity” constraint to describe a Functor protocol:<br>&gt; <br>&gt; protocol Functor {<br>&gt;   associatedtype A<br>&gt;   func fmap&lt;FB where FB ~= Self&gt;(f: A -&gt; FB.A) -&gt; FB<br>&gt; }<br>&gt; <br>&gt; <br>&gt; Specifying type arguments for uses of generic functions<br>&gt; <br>&gt; The type arguments of a generic function are always determined via type inference. For example, given:<br>&gt; <br>&gt; func f&lt;T&gt;(t: T)<br>&gt; <br>&gt; one cannot directly specify T: either one calls “f” (and T is determined via the argument’s type) or one uses “f” in a context where it is given a particular function type (e.g., “let x: (Int) -&gt; Void = f”  would infer T = Int). We could permit explicit specialization here, e.g.,<br>&gt; <br>&gt; let x = f&lt;Int&gt; // x has type (Int) -&gt; Void<br>&gt; <br>&gt; <br>&gt; Unlikely<br>&gt; <br>&gt; Features in this category have been requested at various times, but they don’t fit well with Swift’s generics system because they cause some part of the model to become overly complicated, have unacceptable implementation limitations, or overlap significantly with existing features.<br>&gt; <br>&gt; Generic protocols<br>&gt; <br>&gt; One of the most commonly requested features is the ability to parameterize protocols themselves. For example, a protocol that indicates that the Self type can be constructed from some specified type T:<br>&gt; <br>&gt; protocol ConstructibleFromValue&lt;T&gt; {<br>&gt;   init(_ value: T)<br>&gt; }<br>&gt; <br>&gt; Implicit in this feature is the ability for a given type to conform to the protocol in two different ways. A “Real” type might be constructible from both Float and Double, e.g.,<br>&gt; <br>&gt; struct Real { … }<br>&gt; extension Real : ConstructibleFrom&lt;Float&gt; {<br>&gt;   init(_ value: Float) { … }<br>&gt; }<br>&gt; extension Real : ConstructibleFrom&lt;Double&gt; {<br>&gt;   init(_ value: Double) { … }<br>&gt; }<br>&gt; <br>&gt; Most of the requests for this feature actually want a different feature. They tend to use a parameterized Sequence as an example, e.g.,<br>&gt; <br>&gt; protocol Sequence&lt;Element&gt; { … }<br>&gt; <br>&gt; func foo(strings: Sequence&lt;String&gt;) {  /// works on any sequence containing Strings<br>&gt;   // ...<br>&gt; }<br>&gt; <br>&gt; The actual requested feature here 	is the ability to say “Any type that conforms to Sequence whose Element type is String”, which is covered by the section on “Generalized existentials”, below.<br>&gt; <br>&gt; More importantly, modeling Sequence with generic parameters rather than associated types is tantalizing but wrong: you don’t want a type conforming to Sequence in multiple ways, or (among other things) your for..in loops stop working, and you lose the ability to dynamically cast down to an existential “Sequence” without binding the Element type (again, see “Generalized existentials”). Use cases similar to the ConstructibleFromValue protocol above seem too few to justify the potential for confusion between associated types and generic parameters of protocols; we’re better off not having the latter.<br>&gt; <br>&gt; <br>&gt; Private conformances <br>&gt; <br>&gt; Right now, a protocol conformance can be no less visible than the minimum of the conforming type’s access and the protocol’s access. Therefore, a public type conforming to a public protocol must provide the conformance publicly. One could imagine removing that restriction, so that one could introduce a private conformance:<br>&gt; <br>&gt; public protocol P { }<br>&gt; public struct X { }<br>&gt; extension X : internal P { … } // X conforms to P, but only within this module<br>&gt; <br>&gt; The main problem with private conformances is the interaction with dynamic casting. If I have this code:<br>&gt; <br>&gt; func foo(value: Any) {<br>&gt;   if let x = value as? P { print(“P”) }<br>&gt; }<br>&gt; <br>&gt; foo(X())<br>&gt; <br>&gt; Under what circumstances should it print “P”? If foo() is defined within the same module as the conformance of X to P? If the call is defined within the same module as the conformance of X to P? Never? Either of the first two answers requires significant complications in the dynamic casting infrastructure to take into account the module in which a particular dynamic cast occurred (the first option) or where an existential was formed (the second option), while the third answer breaks the link between the static and dynamic type systems—none of which is an acceptable result.<br>&gt; <br>&gt; Conditional conformances via protocol extensions<br>&gt; <br>&gt; We often get requests to make a protocol conform to another protocol. This is, effectively, the expansion of the notion of “Conditional conformances” to protocol extensions. For example:<br>&gt; <br>&gt; protocol P {<br>&gt;   func foo()<br>&gt; }<br>&gt; <br>&gt; protocol Q {<br>&gt;   func bar()<br>&gt; }<br>&gt; <br>&gt; extension Q : P { // every type that conforms to Q also conforms to P<br>&gt;   func foo() {    // implement “foo” requirement in terms of “bar&quot;<br>&gt;     bar()<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; func f&lt;T: P&gt;(t: T) { … }<br>&gt; <br>&gt; struct X : Q {<br>&gt;   func bar() { … }<br>&gt; }<br>&gt; <br>&gt; f(X()) // okay: X conforms to P through the conformance of Q to P<br>&gt; <br>&gt; This is an extremely powerful feature: is allows one to map the abstractions of one domain into another domain (e.g., every Matrix is a Graph). However, similar to private conformances, it puts a major burden on the dynamic-casting runtime to chase down arbitrarily long and potentially cyclic chains of conformances, which makes efficient implementation nearly impossible.<br>&gt; <br>&gt; Potential removals<br>&gt; <br>&gt; The generics system doesn’t seem like a good candidate for a reduction in scope; most of its features do get used fairly pervasively in the standard library, and few feel overly anachronistic. However...<br>&gt; <br>&gt; Associated type inference<br>&gt; <br>&gt; Associated type inference is the process by which we infer the type bindings for associated types from other requirements. For example:<br>&gt; <br>&gt; protocol IteratorProtocol {<br>&gt;   associatedtype Element<br>&gt;   mutating func next() -&gt; Element?<br>&gt; }<br>&gt; <br>&gt; struct IntIterator : IteratorProtocol {<br>&gt;   mutating func next() -&gt; Int? { … }  // use this to infer Element = Int<br>&gt; }<br>&gt; <br>&gt; Associated type inference is a useful feature. It’s used throughout the standard library, and it helps keep associated types less visible to types that simply want to conform to a protocol. On the other hand, associated type inference is the only place in Swift where we have a global type inference problem: it has historically been a major source of bugs, and implementing it fully and correctly requires a drastically different architecture to the type checker. Is the value of this feature worth keeping global type inference in the Swift language, when we have deliberatively avoided global type inference elsewhere in the language?<br>&gt; <br>&gt; <br>&gt; Existentials<br>&gt; <br>&gt; Existentials aren’t really generics per se, but the two systems are closely intertwined due to their mutable dependence on protocols.<br>&gt; <br>&gt; *Generalized existentials<br>&gt; <br>&gt; The restrictions on existential types came from an implementation limitation, but it is reasonable to allow a value of protocol type even when the protocol has Self constraints or associated types. For example, consider IteratorProtocol again and how it could be used as an existential:<br>&gt; <br>&gt; protocol IteratorProtocol {<br>&gt;   associatedtype Element<br>&gt;   mutating func next() -&gt; Element?<br>&gt; }<br>&gt; <br>&gt; let it: IteratorProtocol = …<br>&gt; it.next()   // if this is permitted, it could return an “Any?”, i.e., the existential that wraps the actual element<br>&gt; <br>&gt; Additionally, it is reasonable to want to constrain the associated types of an existential, e.g., “a Sequence whose element type is String” could be expressed by putting a where clause into “protocol&lt;…&gt;” or “Any&lt;…&gt;” (per “Renaming protocol&lt;…&gt; to Any&lt;…&gt;”):<br>&gt; <br>&gt; let strings: Any&lt;Sequence where .Iterator.Element == String&gt; = [“a”, “b”, “c”]<br>&gt; <br>&gt; The leading “.” indicates that we’re talking about the dynamic type, i.e., the “Self” type that’s conforming to the Sequence protocol. There’s no reason why we cannot support arbitrary “where” clauses within the “Any&lt;…&gt;”. This very-general syntax is a bit unwieldy, but common cases can easily be wrapped up in a generic typealias (see the section “Generic typealiases” above):<br>&gt; <br>&gt; typealias AnySequence&lt;Element&gt; = Any&lt;Sequence where .Iterator.Element == Element&gt;<br>&gt; let strings: AnySequence&lt;String&gt; = [“a”, “b”, “c”]<br>&gt; <br>&gt; <br>&gt; Opening existentials<br>&gt; <br>&gt; Generalized existentials as described above will still have trouble with protocol requirements that involve Self or associated types in function parameters. For example, let’s try to use Equatable as an existential:<br>&gt; <br>&gt; protocol Equatable {<br>&gt;   func ==(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;   func !=(lhs: Self, rhs: Self) -&gt; Bool<br>&gt; }<br>&gt; <br>&gt; let e1: Equatable = …<br>&gt; let e2: Equatable = …<br>&gt; if e1 == e2 { … } // error: e1 and e2 don’t necessarily have the same dynamic type<br>&gt; <br>&gt; One explicit way to allow such operations in a type-safe manner is to introduce an “open existential” operation of some sort, which extracts and gives a name to the dynamic type stored inside an existential. For example:<br>&gt; <br>&gt; 	 <br>&gt; if let storedInE1 = e1 openas T {     // T is a the type of storedInE1, a copy of the value stored in e1<br>&gt;   if let storedInE2 = e2 as? T {      // is e2 also a T?<br>&gt;     if storedInE1 == storedInE2 { … } // okay: storedInT1 and storedInE2 are both of type T, which we know is Equatable<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160303/ca0ff256/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Manifesto] Completing Generics</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>March  8, 2016 at 11:00:00am</p></header><div class="content"><p>I have seen a couple of areas where generics seem lacking to me:<br></p><p>  1. Declaring associated types with where clauses<br>  2. Declaring generic arguments for calculated properties<br>  3. Similar to above, declaring generic properties for subscripts<br></p><p>Examples of 1 and 2:<br></p><p>protocol IterableCollection {<br></p><p>    associated type Element<br></p><p><br>    /// ...<br></p><p><br>    /// Would prefer:<br></p><p>    ///   `var lazy&lt;L: LazyNextableCollection where L.Element == Element&gt;:<br>L { get }` // Point 2 above<br></p><p>    /// Or:<br></p><p>    ///   `associatedtype L: LazyNextableCollection where L.Element ==<br>Element` // Point 1 above<br></p><p>    ///   `var lazy: L { get }`<br></p><p>    /// But nearest possible is a function :(.<br></p><p>    func lazy&lt;L: LazyNextableCollection where L.Element == Element&gt;() -&gt; L //<br>Best I seem to be able to do<br></p><p>}<br></p><p>Example of 3:<br></p><p>protocol SubstriptableCollection {<br></p><p>    associatedtype Index: Rangeable<br></p><p>    associatedtype Element<br></p><p><br>    /// ...<br></p><p><br>    /// Ideally would write:<br></p><p>    ///   `subscript&lt;S: SubstriptableCollection, R: SubstriptableCollection<br>where S.Element == Element, R.Element == Index&gt;(range: R) -&gt; S { get set }`<br>// Point 3 above<br></p><p>    /// However nearest in Swift is seperate get and set methods :(.<br></p><p>    func getSubscript&lt;S: SubstriptableCollection, R: SubstriptableCollection<br>where S.Element == Element, R.Element == Index&gt;(range: R) -&gt; S<br></p><p>}<br></p><p><br>  -- Howard.<br></p><p>On 3 March 2016 at 19:34, Haravikk via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Nested generic types are definitely a big +1 from me. In particular if I<br>&gt; can use them to fulfil associated type requirements, for example:<br>&gt;<br>&gt; protocol FooType {<br>&gt; typealias Element<br>&gt; typealias Index<br>&gt; }<br>&gt;<br>&gt; struct Foo&lt;E&gt; : FooType {<br>&gt; typealias Element = E<br>&gt; struct Index { … }<br>&gt; }<br>&gt;<br>&gt; The other thing I’d like to see for generics isn’t really a new feature,<br>&gt; but I’d like to be able to define protocol generics in the same format as<br>&gt; for types, i.e- I could rewrite the above protocol as:<br>&gt;<br>&gt; protocol FooType&lt;Element, Index&gt; {}<br>&gt;<br>&gt; Likewise when placing constraints on methods etc.:<br>&gt;<br>&gt; func myMethod(someFoo:FooType&lt;String, Int&gt;) { … }<br>&gt;<br>&gt; Even if behind the scenes these are still unwrapped into associated types<br>&gt; and where clauses, it’s just much, much easier to work with in the majority<br>&gt; of cases (where clauses would still exist for the more complex ones).<br>&gt;<br>&gt; The other capabilities you’ve described all seem very useful, but it’s<br>&gt; probably going to take a day or two to get my head around all of them!<br>&gt;<br>&gt; On 3 Mar 2016, at 01:22, Douglas Gregor via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Hi all,<br>&gt;<br>&gt; *Introduction*<br>&gt;<br>&gt; The “Complete Generics” goal for Swift 3 has been fairly ill-defined thus<br>&gt; fair, with just this short blurb in the list of goals:<br>&gt;<br>&gt;<br>&gt;    - *Complete generics*: Generics are used pervasively in a number of<br>&gt;    Swift libraries, especially the standard library. However, there are a<br>&gt;    number of generics features the standard library requires to fully realize<br>&gt;    its vision, including recursive protocol constraints, the ability to make a<br>&gt;    constrained extension conform to a new protocol (i.e., an array of<br>&gt;    Equatable elements is Equatable), and so on. Swift 3.0 should provide<br>&gt;    those generics features needed by the standard library, because they affect<br>&gt;    the standard library&#39;s ABI.<br>&gt;<br>&gt; This message expands upon the notion of “completing generics”. It is not a<br>&gt; plan for Swift 3, nor an official core team communication, but it collects<br>&gt; the results of numerous discussions among the core team and Swift<br>&gt; developers, both of the compiler and the standard library. I hope to<br>&gt; achieve several things:<br>&gt;<br>&gt;<br>&gt;    - Communicate a vision for Swift generics, building on the original<br>&gt;    generics design document<br>&gt;    &lt;https://github.com/apple/swift/blob/master/docs/Generics.rst&gt;, so we<br>&gt;    have something concrete and comprehensive to discuss.<br>&gt;    - Establish some terminology that the Swift developers have been using<br>&gt;    for these features, so our discussions can be more productive (“oh, you’re<br>&gt;    proposing what we refer to as ‘conditional conformances’; go look over at<br>&gt;    this thread”).<br>&gt;    - Engage more of the community in discussions of specific generics<br>&gt;    features, so we can coalesce around designs for public review. And maybe<br>&gt;    even get some of them implemented.<br>&gt;<br>&gt;<br>&gt; A message like this can easily turn into a centithread<br>&gt; &lt;http://www.urbandictionary.com/define.php?term=centithread&gt;. To separate<br>&gt; concerns in our discussion, I ask that replies to this specific thread be<br>&gt; limited to discussions of the vision as a whole: how the pieces fit<br>&gt; together, what pieces are missing, whether this is the right long-term<br>&gt; vision for Swift, and so on. For discussions of specific language features,<br>&gt; e.g., to work out the syntax and semantics of conditional conformances or<br>&gt; discuss the implementation in compiler or use in the standard library,<br>&gt; please start a new thread based on the feature names I’m using.<br>&gt;<br>&gt; This message covers a lot of ground; I’ve attempted a rough categorization<br>&gt; of the various features, and kept the descriptions brief to limit the<br>&gt; overall length. Most of these aren’t my ideas, and any syntax I’m providing<br>&gt; is simply a way to express these ideas in code and is subject to change.<br>&gt; Not all of these features will happen, either soon or ever, but they are<br>&gt; intended to be a fairly complete whole that should mesh together. I’ve put<br>&gt; a * next to features that I think are important in the nearer term vs.<br>&gt; being interesting “some day”. Mostly, the *’s reflect features that will<br>&gt; have a significant impact on the Swift standard library’s design and<br>&gt; implementation.<br>&gt;<br>&gt; Enough with the disclaimers; it’s time to talk features.<br>&gt;<br>&gt; *Removing unnecessary restrictions*<br>&gt;<br>&gt; There are a number of restrictions to the use of generics that fall out of<br>&gt; the implementation in the Swift compiler. Removal of these restrictions is<br>&gt; a matter of implementation only; one need not introduce new syntax or<br>&gt; semantics to realize them. I’m listing them for two reasons: first, it’s an<br>&gt; acknowledgment that these features are intended to exist in the model we<br>&gt; have today, and, second, we’d love help with the implementation of these<br>&gt; features.<br>&gt;<br>&gt;<br>&gt; **Recursive protocol constraints*<br>&gt;<br>&gt; Currently, an associated type cannot be required to conform to its<br>&gt; enclosing protocol (or any protocol that inherits that protocol). For<br>&gt; example, in the standard library SubSequence type of a Sequence should<br>&gt; itself be a Sequence:<br>&gt;<br>&gt; protocol Sequence {<br>&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;   …<br>&gt;   associatedtype SubSequence *: Sequence   **// currently ill-formed, but<br>&gt; should be possible*<br>&gt; }<br>&gt;<br>&gt;<br>&gt; The compiler currently rejects this protocol, which is unfortunate: it<br>&gt; effectively pushes the SubSequence-must-be-a-Sequence requirement into<br>&gt; every consumer of SubSequence, and does not communicate the intent of this<br>&gt; abstraction well.<br>&gt;<br>&gt; *Nested generics*<br>&gt;<br>&gt; Currently, a generic type cannot be nested within another generic type,<br>&gt; e.g.<br>&gt;<br>&gt; struct X&lt;T&gt; {<br>&gt;   struct Y&lt;U&gt; { }  *// currently ill-formed, but should be possible*<br>&gt; }<br>&gt;<br>&gt;<br>&gt; There isn’t much to say about this: the compiler simply needs to be<br>&gt; improved to handle nested generics throughout.<br>&gt;<br>&gt;<br>&gt; *Concrete same-type requirements*<br>&gt;<br>&gt; Currently, a constrained extension cannot use a same-type constraint to<br>&gt; make a type parameter equivalent to a concrete type. For example:<br>&gt;<br>&gt; extension Array *where Element == String* {<br>&gt;   func makeSentence() -&gt; String {<br>&gt;     // uppercase first string, concatenate with spaces, add a period,<br>&gt; whatever<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; This is a highly-requested feature that fits into the existing syntax and<br>&gt; semantics. Note that one could imagine introducing new syntax, e.g.,<br>&gt; extending “Array&lt;String&gt;”, which gets into new-feature territory: see the<br>&gt; section on “Parameterized extensions”.<br>&gt;<br>&gt; *Parameterizing other declarations*<br>&gt;<br>&gt; There are a number of Swift declarations that currently cannot have<br>&gt; generic parameters; some of those have fairly natural extensions to generic<br>&gt; forms that maintain their current syntax and semantics, but become more<br>&gt; powerful when made generic.<br>&gt;<br>&gt;<br>&gt; *Generic typealiases*<br>&gt; Typealiases could be allowed to carry generic parameters. They would still<br>&gt; be aliases (i.e., they would not introduce new types). For example:<br>&gt;<br>&gt; typealias StringDictionary&lt;Value&gt; = Dictionary&lt;String, Value&gt;<br>&gt;<br>&gt; var d1 = StringDictionary&lt;Int&gt;()<br>&gt; var d2: Dictionary&lt;String, Int&gt; = d1 // okay: d1 and d2 have the same<br>&gt; type, Dictionary&lt;String, Int&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; *Generic subscripts*<br>&gt;<br>&gt; Subscripts could be allowed to have generic parameters. For example, we<br>&gt; could introduce a generic subscript on a Collection that allows us to pull<br>&gt; out the values at an arbitrary set of indices:<br>&gt;<br>&gt; extension Collection {<br>&gt;   subscript*&lt;Indices: Sequence where Indices.Iterator.Element == Index&gt;*(indices:<br>&gt; Indices) -&gt; [Iterator.Element] {<br>&gt;     get {<br>&gt;       var result = [Iterator.Element]()<br>&gt;       for index in indices {<br>&gt;         result.append(self[index])<br>&gt;       }<br>&gt;<br>&gt;       return result<br>&gt;     }<br>&gt;<br>&gt;     set {<br>&gt;       for (index, value) in zip(indices, newValue) {<br>&gt;         self[index] = value<br>&gt;       }<br>&gt;     }<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt;<br>&gt;<br>&gt; *Generic constants*<br>&gt;<br>&gt; let constants could be allowed to have generic parameters, such that they<br>&gt; produce differently-typed values depending on how they are used. For<br>&gt; example, this is particularly useful for named literal values, e.g.,<br>&gt;<br>&gt; let π&lt;T : FloatLiteralConvertible&gt;: T<br>&gt; = 3.141592653589793238462643383279502884197169399<br>&gt;<br>&gt;<br>&gt; The Clang importer could make particularly good use of this when importing<br>&gt; macros.<br>&gt;<br>&gt;<br>&gt; *Parameterized extensions*<br>&gt;<br>&gt; Extensions themselves could be parameterized, which would allow some<br>&gt; structural pattern matching on types. For example, this would permit one to<br>&gt; extend an array of optional values, e.g.,<br>&gt;<br>&gt; extension*&lt;T&gt;* Array *where Element == T?* {<br>&gt;   var someValues: [T] {<br>&gt;     var result = [T]()<br>&gt;     for opt in self {<br>&gt;       if let value = opt { result.append(value) }<br>&gt;     }<br>&gt;    return result<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; We can generalize this to a protocol extensions:<br>&gt;<br>&gt; extension*&lt;T&gt;* Sequence *where Element == T?* {<br>&gt;   var someValues: [T] {<br>&gt;     var result = [T]()<br>&gt;     for opt in self {<br>&gt;       if let value = opt { result.append(value) }<br>&gt;     }<br>&gt;    return result<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Note that when one is extending nominal types, we could simplify the<br>&gt; syntax somewhat to make the same-type constraint implicit in the syntax:<br>&gt;<br>&gt; extension*&lt;T&gt;* Array*&lt;T?&gt;* {<br>&gt;   var someValues: [T] {<br>&gt;     var result = [T]()<br>&gt;     for opt in self {<br>&gt;       if let value = opt { result.append(value) }<br>&gt;     }<br>&gt;    return result<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; When we’re working with concrete types, we can use that syntax to improve<br>&gt; the extension of concrete versions of generic types (per “Concrete<br>&gt; same-type requirements”, above), e.g.,<br>&gt;<br>&gt; extension Array*&lt;String&gt;* {<br>&gt;   func makeSentence() -&gt; String {<br>&gt;     // uppercase first string, concatenate with spaces, add a period,<br>&gt; whatever<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; *Minor extensions*<br>&gt;<br>&gt; There are a number of minor extensions we can make to the generics system<br>&gt; that don’t fundamentally change what one can express in Swift, but which<br>&gt; can improve its expressivity.<br>&gt;<br>&gt;<br>&gt; **Arbitrary requirements in protocols*<br>&gt;<br>&gt; Currently, a new protocol can inherit from other protocols, introduce new<br>&gt; associated types, and add new conformance constraints to associated types<br>&gt; (by redeclaring an associated type from an inherited protocol). However,<br>&gt; one cannot express more general constraints. Building on the example from<br>&gt; “Recursive protocol constraints”, we really want the element type of a<br>&gt; Sequence’s SubSequence to be the same as the element type of the Sequence,<br>&gt; e.g.,<br>&gt;<br>&gt; protocol Sequence {<br>&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;   …<br>&gt;   associatedtype SubSequence : Sequence* where<br>&gt; SubSequence.Iterator.Element == Iterator.Element*<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Hanging the where clause off the associated type is protocol not ideal,<br>&gt; but that’s a discussion for another thread.<br>&gt;<br>&gt;<br>&gt;<br>&gt; **Typealiases in protocols and protocol extensions*<br>&gt;<br>&gt; Now that associated types have their own keyword (thanks!), it’s<br>&gt; reasonable to bring back “typealias”. Again with the Sequence protocol:<br>&gt;<br>&gt; protocol Sequence {<br>&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;   typealias Element = Iterator.Element   // rejoice! now we can refer to<br>&gt; SomeSequence.Element rather than SomeSequence.Iterator.Element<br>&gt; }<br>&gt;<br>&gt;<br>&gt;<br>&gt; *Default generic arguments *<br>&gt;<br>&gt; Generic parameters could be given the ability to provide default<br>&gt; arguments, which would be used in cases where the type argument is not<br>&gt; specified and type inference could not determine the type argument. For<br>&gt; example:<br>&gt;<br>&gt; public final class Promise&lt;Value, Reason=Error&gt; { … }<br>&gt;<br>&gt; func getRandomPromise() -&gt; Promise&lt;Int, ErrorProtocol&gt; { … }<br>&gt;<br>&gt; var p1: Promise&lt;Int&gt; = …<br>&gt; var p2: Promise&lt;Int, Error&gt; = p1     *// okay: p1 and p2 have the same<br>&gt; type Promise&lt;Int, Error&gt;*<br>&gt; var p3: Promise = getRandomPromise() *// p3 has type **Promise&lt;Int,<br>&gt; ErrorProtocol&gt; due to type inference*<br>&gt;<br>&gt;<br>&gt;<br>&gt; *Generalized “class” constraints*<br>&gt;<br>&gt; The “class” constraint can currently only be used for defining protocols.<br>&gt; We could generalize it to associated type and type parameter declarations,<br>&gt; e.g.,<br>&gt;<br>&gt; protocol P {<br>&gt;   associatedtype A : class<br>&gt; }<br>&gt;<br>&gt; func foo&lt;T : class&gt;(t: T) { }<br>&gt;<br>&gt;<br>&gt; As part of this, the magical AnyObject protocol could be replaced with an<br>&gt; existential with a class bound, so that it becomes a typealias:<br>&gt;<br>&gt; typealias AnyObject = protocol&lt;class&gt;<br>&gt;<br>&gt;<br>&gt; See the “Existentials” section, particularly “Generalized existentials”,<br>&gt; for more information.<br>&gt;<br>&gt;<br>&gt; **Allowing subclasses to override requirements satisfied by defaults*<br>&gt;<br>&gt; When a superclass conforms to a protocol and has one of the protocol’s<br>&gt; requirements satisfied by a member of a protocol extension, that member<br>&gt; currently cannot be overridden by a subclass. For example:<br>&gt;<br>&gt; protocol P {<br>&gt;   func foo()<br>&gt; }<br>&gt;<br>&gt; extension P {<br>&gt;   func foo() { print(“P”) }<br>&gt; }<br>&gt;<br>&gt; class C : P {<br>&gt;   // gets the protocol extension’s<br>&gt; }<br>&gt;<br>&gt; class D : C {<br>&gt;   /*override not allowed!*/ func foo() { print(“D”) }<br>&gt; }<br>&gt;<br>&gt; let p: P = D()<br>&gt; p.foo() // gotcha: prints “P” rather than “D”!<br>&gt;<br>&gt;<br>&gt; D.foo should be required to specify “override” and should be called<br>&gt; dynamically.<br>&gt;<br>&gt;<br>&gt; *Major extensions to the generics model*<br>&gt;<br>&gt; Unlike the minor extensions, major extensions to the generics model<br>&gt; provide more expressivity in the Swift generics system and, generally, have<br>&gt; a much more significant design and implementation cost.<br>&gt;<br>&gt;<br>&gt;<br>&gt; **Conditional conformances*<br>&gt;<br>&gt; Conditional conformances express the notion that a generic type will<br>&gt; conform to a particular protocol only under certain circumstances. For<br>&gt; example, Array is Equatable only when its elements are Equatable:<br>&gt;<br>&gt; extension Array *: Equatable where Element : Equatable* { }<br>&gt;<br>&gt; func ==&lt;T : Equatable&gt;(lhs: Array&lt;T&gt;, rhs: Array&lt;T&gt;) -&gt; Bool { … }<br>&gt;<br>&gt;<br>&gt; Conditional conformances are a potentially very powerful feature. One<br>&gt; important aspect of this feature is how deal with or avoid overlapping<br>&gt; conformances. For example, imagine an adaptor over a Sequence that has<br>&gt; conditional conformances to Collection and MutableCollection:<br>&gt;<br>&gt; struct SequenceAdaptor&lt;S: Sequence&gt; : Sequence { }<br>&gt; extension SequenceAdaptor : Collection where S: Collection { … }<br>&gt; extension SequenceAdaptor : MutableCollection where S: MutableCollection {<br>&gt; }<br>&gt;<br>&gt;<br>&gt; This should almost certainly be permitted, but we need to cope with or<br>&gt; reject “overlapping” conformances:<br>&gt;<br>&gt; extension SequenceAdaptor : Collection where S:<br>&gt; SomeOtherProtocolSimilarToCollection { } *// trouble: two ways for<br>&gt; SequenceAdaptor to conform to Collection*<br>&gt;<br>&gt;<br>&gt; See the section on “Private conformances” for more about the issues with<br>&gt; having the same type conform to the same protocol multiple times.<br>&gt;<br>&gt;<br>&gt; *Variadic generics*<br>&gt;<br>&gt; Currently, a generic parameter list contains a fixed number of generic<br>&gt; parameters. If one has a type that could generalize to any number of<br>&gt; generic parameters, the only real way to deal with it today involves<br>&gt; creating a set of types. For example, consider the standard library’s “zip”<br>&gt; function. It returns one of these when provided with two arguments to zip<br>&gt; together:<br>&gt;<br>&gt; public struct Zip2Sequence&lt;Sequence1 : Sequence,<br>&gt;                            Sequence2 : Sequence&gt; : Sequence { … }<br>&gt;<br>&gt; public func zip&lt;Sequence1 : Sequence, Sequence2 : Sequence&gt;(<br>&gt;               sequence1: Sequence1, _ sequence2: Sequence2)<br>&gt;             -&gt; Zip2Sequence&lt;Sequence1, Sequence2&gt; { … }<br>&gt;<br>&gt;<br>&gt; Supporting three arguments would require copy-paste of those of those:<br>&gt;<br>&gt; public struct Zip3Sequence&lt;Sequence1 : Sequence,<br>&gt;                            Sequence2 : Sequence,<br>&gt;                            Sequence3 : Sequence&gt; : Sequence { … }<br>&gt;<br>&gt; public func zip&lt;Sequence1 : Sequence, Sequence2 : Sequence, Sequence3 :<br>&gt; Sequence&gt;(<br>&gt;               sequence1: Sequence1, _ sequence2: Sequence2, _ sequence3:<br>&gt; sequence3)<br>&gt;             -&gt; Zip3Sequence&lt;Sequence1, Sequence2, Sequence3&gt; { … }<br>&gt;<br>&gt;<br>&gt; Variadic generics would allow us to abstract over a set of generic<br>&gt; parameters. The syntax below is hopelessly influenced by C++11 variadic<br>&gt; templates &lt;http://www.jot.fm/issues/issue_2008_02/article2/&gt; (sorry),<br>&gt; where putting an ellipsis (“…”) to the left of a declaration makes it a<br>&gt; “parameter pack” containing zero or more parameters and putting an ellipsis<br>&gt; to the right of a type/expression/etc. expands the parameter packs within<br>&gt; that type/expression into separate arguments. The important part is that we<br>&gt; be able to meaningfully abstract over zero or more generic parameters, e.g.:<br>&gt;<br>&gt; public struct ZipIterator&lt;... *Iterators* : IteratorProtocol&gt; : Iterator<br>&gt; {  *// zero or more type parameters, each of which conforms to<br>&gt; IteratorProtocol*<br>&gt;   public typealias Element = (*Iterators.Element...*)<br>&gt;   *// a tuple containing the element types of each iterator in Iterators*<br>&gt;<br>&gt;   var (*...iterators*): (*Iterators...*)    *// zero or more stored<br>&gt; properties, one for each type in Iterators*<br>&gt;   var reachedEnd: Bool = false<br>&gt;<br>&gt;<br>&gt;   public mutating func next() -&gt; Element? {<br>&gt;<br>&gt;     if reachedEnd { return nil }<br>&gt;<br>&gt;<br>&gt;     guard let values = (*iterators.next()...*) {   *// call “next” on<br>&gt; each of the iterators, put the results into a tuple named “values&quot;*<br>&gt;<br>&gt;       reachedEnd = true<br>&gt;<br>&gt;       return nil<br>&gt;<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;     return values<br>&gt;<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; public struct ZipSequence&lt;*...Sequences* : Sequence&gt; : Sequence {<br>&gt;   public typealias Iterator = ZipIterator&lt;*Sequences.Iterator...*&gt;   *//<br>&gt; get the zip iterator with the iterator types of our Sequences*<br>&gt;<br>&gt;   var (...*sequences*): (*Sequences**...*)    *// zero or more stored<br>&gt; properties, one for each type in Sequences*<br>&gt;<br>&gt;   *// details ...*<br>&gt; }<br>&gt;<br>&gt; Such a design could also work for function parameters, so we can pack<br>&gt; together multiple function arguments with different types, e.g.,<br>&gt;<br>&gt; public func zip&lt;*... Sequences : SequenceType*&gt;(*... sequences:<br>&gt; Sequences...*)<br>&gt;             -&gt; ZipSequence&lt;*Sequences...*&gt; {<br>&gt;   return ZipSequence(*sequences...*)<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Finally, this could tie into the discussions about a tuple “splat”<br>&gt; operator. For example:<br>&gt;<br>&gt; func apply&lt;... Args, Result&gt;(fn: (Args...) -&gt; Result,    *// function<br>&gt; taking some number of arguments and producing Result*<br>&gt;                            args: (Args...)) -&gt; Result {  *// tuple of<br>&gt; arguments*<br>&gt;   return fn(*args...*)                                     // expand the<br>&gt; arguments in the tuple “args” into separate arguments<br>&gt; }<br>&gt;<br>&gt;<br>&gt;<br>&gt; *Extensions of structural types*<br>&gt;<br>&gt; Currently, only nominal types (classes, structs, enums, protocols) can be<br>&gt; extended. One could imagine extending structural types—particularly tuple<br>&gt; types—to allow them to, e.g., conform to protocols. For example, pulling<br>&gt; together variadic generics, parameterized extensions, and conditional<br>&gt; conformances, one could express “a tuple type is Equatable if all of its<br>&gt; element types are Equatable”:<br>&gt;<br>&gt; extension&lt;...Elements : Equatable&gt; *(Elements...)* : Equatable {   *//<br>&gt; extending the tuple type “(Elements…)” to be Equatable*<br>&gt; }<br>&gt;<br>&gt;<br>&gt; There are some natural bounds here: one would need to have actual<br>&gt; structural types. One would not be able to extend every type:<br>&gt;<br>&gt; extension&lt;T&gt; T { *// error: neither a structural nor a nominal type*<br>&gt; }<br>&gt;<br>&gt;<br>&gt; And before you think you’re cleverly making it possible to have a<br>&gt; conditional conformance that makes every type T that conforms to protocol P<br>&gt; also conform to protocol Q, see the section &quot;Conditional conformances via<br>&gt; protocol extensions”, below:<br>&gt;<br>&gt; extension&lt;T : P&gt; T : Q { *// error: neither a structural nor a nominal<br>&gt; type*<br>&gt; }<br>&gt;<br>&gt;<br>&gt;<br>&gt; *Syntactic improvements*<br>&gt;<br>&gt; There are a number of potential improvements we could make to the generics<br>&gt; syntax. Such a list could go on for a very long time, so I’ll only<br>&gt; highlight some obvious ones that have been discussed by the Swift<br>&gt; developers.<br>&gt;<br>&gt; **Default implementations in protocols*<br>&gt;<br>&gt; Currently, protocol members can never have implementations. We could allow<br>&gt; one to provide such implementations to be used as the default if a<br>&gt; conforming type does not supply an implementation, e.g.,<br>&gt;<br>&gt; protocol Bag {<br>&gt;   associatedtype Element : Equatable<br>&gt;   func contains(element: Element) -&gt; Bool<br>&gt;<br>&gt;   func containsAll&lt;S: Sequence where Sequence.Iterator.Element ==<br>&gt; Element&gt;(elements: S) -&gt; Bool {<br>&gt;     for x in elements {<br>&gt;       if contains(x) { return true }<br>&gt;     }<br>&gt;     return false<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; struct IntBag : Bag {<br>&gt;   typealias Element = Int<br>&gt;   func contains(element: Int) -&gt; Bool { ... }<br>&gt;<br>&gt;   // okay: containsAll requirement is satisfied by Bag’s default<br>&gt; implementation<br>&gt; }<br>&gt;<br>&gt; One can get this effect with protocol extensions today, hence the<br>&gt; classification of this feature as a (mostly) syntactic improvement:<br>&gt;<br>&gt; protocol Bag {<br>&gt;   associatedtype Element : Equatable<br>&gt;   func contains(element: Element) -&gt; Bool<br>&gt;<br>&gt;   func containsAll&lt;S: Sequence where Sequence.Iterator.Element ==<br>&gt; Element&gt;(elements: S) -&gt; Bool<br>&gt; }<br>&gt;<br>&gt; extension Bag {<br>&gt;   func containsAll&lt;S: Sequence where Sequence.Iterator.Element ==<br>&gt; Element&gt;(elements: S) -&gt; Bool {<br>&gt;     for x in elements {<br>&gt;       if contains(x) { return true }<br>&gt;     }<br>&gt;     return false<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; **Moving the where clause outside of the angle brackets*<br>&gt;<br>&gt; The “where” clause of generic functions comes very early in the<br>&gt; declaration, although it is generally of much less concern to the client<br>&gt; than the function parameters and result type that follow it. This is one of<br>&gt; the things that contributes to “angle bracket blindness”. For example,<br>&gt; consider the containsAll signature above:<br>&gt;<br>&gt; func containsAll&lt;S: Sequence where Sequence.Iterator.Element ==<br>&gt; Element&gt;(elements: S) -&gt; Bool<br>&gt;<br>&gt;<br>&gt; One could move the “where” clause to the end of the signature, so that the<br>&gt; most important parts—name, generic parameter, parameters, result<br>&gt; type—precede it:<br>&gt;<br>&gt; func containsAll&lt;S: Sequence&gt;(elements: S) -&gt; Bool<br>&gt;<br>&gt;        where Sequence.Iterator.Element == Element<br>&gt;<br>&gt;<br>&gt;<br>&gt; **Renaming “protocol&lt;…&gt;” to “Any&lt;…&gt;”.*<br>&gt;<br>&gt; The “protocol&lt;…&gt;” syntax is a bit of an oddity in Swift. It is used to<br>&gt; compose protocols together, mostly to create values of existential type,<br>&gt; e.g.,<br>&gt;<br>&gt; var x: protocol&lt;NSCoding, NSCopying&gt;<br>&gt;<br>&gt;<br>&gt; It’s weird that it’s a type name that starts with a lowercase letter, and<br>&gt; most Swift developers probably never deal with this feature unless they<br>&gt; happen to look at the definition of Any:<br>&gt;<br>&gt; typealias Any = protocol&lt;&gt;<br>&gt;<br>&gt;<br>&gt; “Any” might be a better name for this functionality. “Any” without<br>&gt; brackets could be a keyword for “any type”, and “Any” followed by brackets<br>&gt; could take the role of “protocol&lt;&gt;” today:<br>&gt;<br>&gt; var x: Any&lt;NSCoding, NSCopying&gt;<br>&gt;<br>&gt;<br>&gt; That reads much better: “Any type that conforms to NSCoding and<br>&gt; NSCopying”. See the section &quot;Generalized existentials” for additional<br>&gt; features in this space.<br>&gt;<br>&gt; *Maybe*<br>&gt;<br>&gt; There are a number of features that get discussed from time-to-time, while<br>&gt; they could fit into Swift’s generics system, it’s not clear that they<br>&gt; belong in Swift at all. The important question for any feature in this<br>&gt; category is not “can it be done” or “are there cool things we can express”,<br>&gt; but “how can everyday Swift developers benefit from the addition of such a<br>&gt; feature?”. Without strong motivating examples, none of these “maybes” will<br>&gt; move further along.<br>&gt;<br>&gt; *Dynamic dispatch for members of protocol extensions*<br>&gt;<br>&gt; Only the requirements of protocols currently use dynamic dispatch, which<br>&gt; can lead to surprises:<br>&gt;<br>&gt; protocol P {<br>&gt;   func foo()<br>&gt; }<br>&gt;<br>&gt; extension P {<br>&gt;   func foo() { print(“P.foo()”)<br>&gt;   func bar() { print(“P.bar()”)<br>&gt; }<br>&gt;<br>&gt; struct X : P {<br>&gt;   func foo() { print(“X.foo()”)<br>&gt;   func bar() { print(“X.bar()”)<br>&gt; }<br>&gt;<br>&gt; let x = X()<br>&gt; x.foo() // X.foo()<br>&gt; x.bar() // X.bar()<br>&gt;<br>&gt; let p: P = X()<br>&gt; p.foo() // X.foo()<br>&gt; p.bar() // P.bar()<br>&gt;<br>&gt;<br>&gt; Swift could adopt a model where members of protocol extensions are<br>&gt; dynamically dispatched.<br>&gt;<br>&gt;<br>&gt; *Named generic parameters*<br>&gt;<br>&gt; When specifying generic arguments for a generic type, the arguments are<br>&gt; always positional: Dictionary&lt;String, Int&gt; is a Dictionary whose Key type<br>&gt; is String and whose Value type is Int, by convention. One could permit the<br>&gt; arguments to be labeled, e.g.,<br>&gt;<br>&gt; var d: Dictionary&lt;*Key:* String, *Value:* Int&gt;<br>&gt;<br>&gt;<br>&gt; Such a feature makes more sense if Swift gains default generic arguments,<br>&gt; because generic argument labels would allow one to skip defaulted arguments.<br>&gt;<br>&gt;<br>&gt; *Generic value parameters*<br>&gt;<br>&gt; Currently, Swift’s generic parameters are always types. One could imagine<br>&gt; allowing generic parameters that are values, e.g.,<br>&gt;<br>&gt; struct MultiArray&lt;T,* let Dimensions: Int*&gt; { *// specify the number of<br>&gt; dimensions to the array*<br>&gt;   subscript (indices: Int...) -&gt; T {<br>&gt;     get {<br>&gt;       require(indices.count == *Dimensions*)<br>&gt;       // ...<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; A suitably general feature might allow us to express fixed-length array or<br>&gt; vector types as a standard library component, and perhaps also allow one to<br>&gt; implement a useful dimensional analysis library. Tackling this feature<br>&gt; potentially means determining what it is for an expression to be a<br>&gt; “constant expression” and diving into dependent-typing, hence the “maybe”.<br>&gt;<br>&gt;<br>&gt; *Higher-kinded types*<br>&gt;<br>&gt; Higher-kinded types allow one to express the relationship between two<br>&gt; different specializations of the same nominal type within a protocol. For<br>&gt; example, if we think of the Self type in a protocol as really being<br>&gt; “Self&lt;T&gt;”, it allows us to talk about the relationship between “Self&lt;T&gt;”<br>&gt; and “Self&lt;U&gt;” for some other type U. For example, it could allow the “map”<br>&gt; operation on a collection to return a collection of the same kind but with<br>&gt; a different operation, e.g.,<br>&gt;<br>&gt; let intArray: Array&lt;Int&gt; = …<br>&gt; intArray.map { String($0) } *// produces Array&lt;String&gt;*<br>&gt; let intSet: Set&lt;Int&gt; = …<br>&gt; intSet.map { String($0) }   *// produces Set&lt;String&gt;*<br>&gt;<br>&gt;<br>&gt;<br>&gt; Potential syntax borrowed from one thread on higher-kinded types<br>&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002736.html&gt; uses<br>&gt; ~= as a “similarity” constraint to describe a Functor protocol:<br>&gt;<br>&gt; protocol Functor {<br>&gt;   associatedtype A<br>&gt;   func fmap&lt;FB where *FB ~= Self*&gt;(f: A -&gt; FB.A) -&gt; FB<br>&gt; }<br>&gt;<br>&gt;<br>&gt;<br>&gt; *Specifying type arguments for uses of generic functions*<br>&gt;<br>&gt; The type arguments of a generic function are always determined via type<br>&gt; inference. For example, given:<br>&gt;<br>&gt; func f&lt;T&gt;(t: T)<br>&gt;<br>&gt;<br>&gt; one cannot directly specify T: either one calls “f” (and T is determined<br>&gt; via the argument’s type) or one uses “f” in a context where it is given a<br>&gt; particular function type (e.g., “let x: (Int) -&gt; Void = f”  would infer T =<br>&gt; Int). We could permit explicit specialization here, e.g.,<br>&gt;<br>&gt; let x = f&lt;Int&gt; // x has type (Int) -&gt; Void<br>&gt;<br>&gt;<br>&gt;<br>&gt; *Unlikely*<br>&gt;<br>&gt; Features in this category have been requested at various times, but they<br>&gt; don’t fit well with Swift’s generics system because they cause some part of<br>&gt; the model to become overly complicated, have unacceptable implementation<br>&gt; limitations, or overlap significantly with existing features.<br>&gt;<br>&gt; *Generic protocols*<br>&gt;<br>&gt; One of the most commonly requested features is the ability to parameterize<br>&gt; protocols themselves. For example, a protocol that indicates that the Self<br>&gt; type can be constructed from some specified type T:<br>&gt;<br>&gt; protocol ConstructibleFromValue*&lt;T&gt;* {<br>&gt;   init(_ value: T)<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Implicit in this feature is the ability for a given type to conform to the<br>&gt; protocol in two different ways. A “Real” type might be constructible from<br>&gt; both Float and Double, e.g.,<br>&gt;<br>&gt; struct Real { … }<br>&gt; extension Real : ConstructibleFrom&lt;Float&gt; {<br>&gt;   init(_ value: Float) { … }<br>&gt; }<br>&gt; extension Real : ConstructibleFrom&lt;Double&gt; {<br>&gt;   init(_ value: Double) { … }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Most of the requests for this feature actually want a different feature.<br>&gt; They tend to use a parameterized Sequence as an example, e.g.,<br>&gt;<br>&gt; protocol Sequence&lt;Element&gt; { … }<br>&gt;<br>&gt; func foo(strings: Sequence&lt;String&gt;) {  /// works on any sequence<br>&gt; containing Strings<br>&gt;   // ...<br>&gt; }<br>&gt;<br>&gt;<br>&gt; The actual requested feature here  is the ability to say “Any type that<br>&gt; conforms to Sequence whose Element type is String”, which is covered by the<br>&gt; section on “Generalized existentials”, below.<br>&gt;<br>&gt; More importantly, modeling Sequence with generic parameters rather than<br>&gt; associated types is tantalizing but wrong: you don’t want a type conforming<br>&gt; to Sequence in multiple ways, or (among other things) your for..in loops<br>&gt; stop working, and you lose the ability to dynamically cast down to an<br>&gt; existential “Sequence” without binding the Element type (again, see<br>&gt; “Generalized existentials”). Use cases similar to the<br>&gt; ConstructibleFromValue protocol above seem too few to justify the potential<br>&gt; for confusion between associated types and generic parameters of protocols;<br>&gt; we’re better off not having the latter.<br>&gt;<br>&gt;<br>&gt; *Private conformances *<br>&gt;<br>&gt; Right now, a protocol conformance can be no less visible than the minimum<br>&gt; of the conforming type’s access and the protocol’s access. Therefore, a<br>&gt; public type conforming to a public protocol must provide the conformance<br>&gt; publicly. One could imagine removing that restriction, so that one could<br>&gt; introduce a private conformance:<br>&gt;<br>&gt; public protocol P { }<br>&gt; public struct X { }<br>&gt; extension X : *internal P* { … } // X conforms to P, but only within this<br>&gt; module<br>&gt;<br>&gt;<br>&gt; The main problem with private conformances is the interaction with dynamic<br>&gt; casting. If I have this code:<br>&gt;<br>&gt; func foo(value: Any) {<br>&gt;   if let x = value as? P { print(“P”) }<br>&gt; }<br>&gt;<br>&gt; foo(X())<br>&gt;<br>&gt;<br>&gt; Under what circumstances should it print “P”? If foo() is defined within<br>&gt; the same module as the conformance of X to P? If the call is defined within<br>&gt; the same module as the conformance of X to P? Never? Either of the first<br>&gt; two answers requires significant complications in the dynamic casting<br>&gt; infrastructure to take into account the module in which a particular<br>&gt; dynamic cast occurred (the first option) or where an existential was formed<br>&gt; (the second option), while the third answer breaks the link between the<br>&gt; static and dynamic type systems—none of which is an acceptable result.<br>&gt;<br>&gt;<br>&gt; *Conditional conformances via protocol extensions*<br>&gt;<br>&gt; We often get requests to make a protocol conform to another protocol. This<br>&gt; is, effectively, the expansion of the notion of “Conditional conformances”<br>&gt; to protocol extensions. For example:<br>&gt;<br>&gt; protocol P {<br>&gt;   func foo()<br>&gt; }<br>&gt;<br>&gt; protocol Q {<br>&gt;   func bar()<br>&gt; }<br>&gt;<br>&gt; extension *Q : P* { *// every type that conforms to Q also conforms to P*<br>&gt;   func foo() {    *// implement “foo” requirement in terms of “bar&quot;*<br>&gt;     bar()<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; func f&lt;T: P&gt;(t: T) { … }<br>&gt;<br>&gt; struct X : Q {<br>&gt;   func bar() { … }<br>&gt; }<br>&gt;<br>&gt; f(X()) // okay: X conforms to P through the conformance of Q to P<br>&gt;<br>&gt;<br>&gt; This is an extremely powerful feature: is allows one to map the<br>&gt; abstractions of one domain into another domain (e.g., every Matrix is a<br>&gt; Graph). However, similar to private conformances, it puts a major burden on<br>&gt; the dynamic-casting runtime to chase down arbitrarily long and potentially<br>&gt; cyclic chains of conformances, which makes efficient implementation nearly<br>&gt; impossible.<br>&gt;<br>&gt; *Potential removals*<br>&gt;<br>&gt; The generics system doesn’t seem like a good candidate for a reduction in<br>&gt; scope; most of its features do get used fairly pervasively in the standard<br>&gt; library, and few feel overly anachronistic. However...<br>&gt;<br>&gt; *Associated type inference*<br>&gt;<br>&gt; Associated type inference is the process by which we infer the type<br>&gt; bindings for associated types from other requirements. For example:<br>&gt;<br>&gt; protocol IteratorProtocol {<br>&gt;   associatedtype Element<br>&gt;   mutating func next() -&gt; Element?<br>&gt; }<br>&gt;<br>&gt; struct IntIterator : IteratorProtocol {<br>&gt;   mutating func next() -&gt; Int? { … }  // use this to infer Element = Int<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Associated type inference is a useful feature. It’s used throughout the<br>&gt; standard library, and it helps keep associated types less visible to types<br>&gt; that simply want to conform to a protocol. On the other hand, associated<br>&gt; type inference is the only place in Swift where we have a *global* type<br>&gt; inference problem: it has historically been a major source of bugs, and<br>&gt; implementing it fully and correctly requires a drastically different<br>&gt; architecture to the type checker. Is the value of this feature worth<br>&gt; keeping global type inference in the Swift language, when we have<br>&gt; deliberatively avoided global type inference elsewhere in the language?<br>&gt;<br>&gt;<br>&gt; *Existentials*<br>&gt;<br>&gt; Existentials aren’t really generics per se, but the two systems are<br>&gt; closely intertwined due to their mutable dependence on protocols.<br>&gt;<br>&gt; **Generalized existentials*<br>&gt;<br>&gt; The restrictions on existential types came from an implementation<br>&gt; limitation, but it is reasonable to allow a value of protocol type even<br>&gt; when the protocol has Self constraints or associated types. For example,<br>&gt; consider IteratorProtocol again and how it could be used as an existential:<br>&gt;<br>&gt; protocol IteratorProtocol {<br>&gt;   associatedtype Element<br>&gt;   mutating func next() -&gt; Element?<br>&gt; }<br>&gt;<br>&gt; let it: IteratorProtocol = …<br>&gt; it.next()   // if this is permitted, it could return an “Any?”, i.e., the<br>&gt; existential that wraps the actual element<br>&gt;<br>&gt;<br>&gt; Additionally, it is reasonable to want to constrain the associated types<br>&gt; of an existential, e.g., “a Sequence whose element type is String” could be<br>&gt; expressed by putting a where clause into “protocol&lt;…&gt;” or “Any&lt;…&gt;” (per<br>&gt; “Renaming protocol&lt;…&gt; to Any&lt;…&gt;”):<br>&gt;<br>&gt; let strings: Any&lt;Sequence* where .Iterator.Element == String*&gt; = [“a”,<br>&gt; “b”, “c”]<br>&gt;<br>&gt;<br>&gt; The leading “.” indicates that we’re talking about the dynamic type, i.e.,<br>&gt; the “Self” type that’s conforming to the Sequence protocol. There’s no<br>&gt; reason why we cannot support arbitrary “where” clauses within the “Any&lt;…&gt;”.<br>&gt; This very-general syntax is a bit unwieldy, but common cases can easily be<br>&gt; wrapped up in a generic typealias (see the section “Generic typealiases”<br>&gt; above):<br>&gt;<br>&gt; typealias AnySequence&lt;Element&gt; = *Any&lt;Sequence where .Iterator.Element ==<br>&gt; Element&gt;*<br>&gt; let strings: AnySequence&lt;String&gt; = [“a”, “b”, “c”]<br>&gt;<br>&gt;<br>&gt;<br>&gt; *Opening existentials*<br>&gt;<br>&gt; Generalized existentials as described above will still have trouble with<br>&gt; protocol requirements that involve Self or associated types in function<br>&gt; parameters. For example, let’s try to use Equatable as an existential:<br>&gt;<br>&gt; protocol Equatable {<br>&gt;   func ==(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;   func !=(lhs: Self, rhs: Self) -&gt; Bool<br>&gt; }<br>&gt;<br>&gt; let e1: Equatable = …<br>&gt; let e2: Equatable = …<br>&gt; if e1 == e2 { … } *// error:* e1 and e2 don’t necessarily have the same<br>&gt; dynamic type<br>&gt;<br>&gt;<br>&gt; One explicit way to allow such operations in a type-safe manner is to<br>&gt; introduce an “open existential” operation of some sort, which extracts and<br>&gt; gives a name to the dynamic type stored inside an existential. For example:<br>&gt;<br>&gt;<br>&gt;<br>&gt; if let storedInE1 = e1 openas T {     // T is a the type of storedInE1, a<br>&gt; copy of the value stored in e1<br>&gt;<br>&gt;   if let storedInE2 = e2 as? T {      // is e2 also a T?<br>&gt;<br>&gt;     if storedInE1 == storedInE2 { … } // okay: storedInT1 and storedInE2<br>&gt; are both of type T, which we know is Equatable<br>&gt;<br>&gt;   }<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Thoughts?<br>&gt;<br>&gt; - Doug<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160308/2451aaf2/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Manifesto] Completing Generics</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>March  8, 2016 at 04:00:00pm</p></header><div class="content"><p>Another area I have seen a problem is trying to return protocols with<br>associated types, e.g. given:<br></p><p>protocol LazyNextableCollection {<br></p><p>    associated type Element<br></p><p><br>    @warn_unused_result mutating func next() throws -&gt; Element?<br></p><p><br>    mutating func map&lt;Mapped, Output: LazyNextableCollection where<br>Output.Element<br>== Mapped&gt;(mapper: (Element) throws -&gt; Mapped) -&gt; Output<br></p><p>}<br></p><p><br>and<br></p><p>struct AsLazyNextable&lt;Element&gt;: LazyNextableCollection {<br></p><p>    private let nextable: () throws -&gt; Element?<br></p><p><br>    @warn_unused_result mutating func next() throws -&gt; Element? {<br></p><p>        return try nextable()<br></p><p>    }<br></p><p>}<br></p><p><br>The following fails:<br></p><p>extension LazyNextableCollection {<br></p><p>    mutating func map&lt;Mapped, Output: LazyNextableCollection where<br>Output.Element<br>== Mapped&gt;(mapper: (Element) throws -&gt; Mapped) -&gt; Output {<br></p><p>        return AsLazyNextable&lt;Mapped&gt; {<br></p><p>            let element = try self.next()<br></p><p>            guard let e = element else { return nil }<br></p><p>            return try mapper(e)<br></p><p>        }<br></p><p>    }<br>}<br></p><p><br>The compiler says that AsLazyNextable&lt;Mapped&gt; is not the same type as<br>Output.<br></p><p>  -- Howard.<br></p><p>On 8 March 2016 at 11:18, Howard Lovatt &lt;howard.lovatt at gmail.com&gt; wrote:<br></p><p>&gt; I have seen a couple of areas where generics seem lacking to me:<br>&gt;<br>&gt;   1. Declaring associated types with where clauses<br>&gt;   2. Declaring generic arguments for calculated properties<br>&gt;   3. Similar to above, declaring generic properties for subscripts<br>&gt;<br>&gt; Examples of 1 and 2:<br>&gt;<br>&gt; protocol IterableCollection {<br>&gt;<br>&gt;     associated type Element<br>&gt;<br>&gt;<br>&gt;     /// ...<br>&gt;<br>&gt;<br>&gt;     /// Would prefer:<br>&gt;<br>&gt;     ///   `var lazy&lt;L: LazyNextableCollection where L.Element ==<br>&gt; Element&gt;: L { get }` // Point 2 above<br>&gt;<br>&gt;     /// Or:<br>&gt;<br>&gt;     ///   `associatedtype L: LazyNextableCollection where L.Element ==<br>&gt; Element` // Point 1 above<br>&gt;<br>&gt;     ///   `var lazy: L { get }`<br>&gt;<br>&gt;     /// But nearest possible is a function :(.<br>&gt;<br>&gt;     func lazy&lt;L: LazyNextableCollection where L.Element == Element&gt;() -&gt; L<br>&gt;  // Best I seem to be able to do<br>&gt;<br>&gt; }<br>&gt;<br>&gt; Example of 3:<br>&gt;<br>&gt; protocol SubstriptableCollection {<br>&gt;<br>&gt;     associatedtype Index: Rangeable<br>&gt;<br>&gt;     associatedtype Element<br>&gt;<br>&gt;<br>&gt;     /// ...<br>&gt;<br>&gt;<br>&gt;     /// Ideally would write:<br>&gt;<br>&gt;     ///   `subscript&lt;S: SubstriptableCollection, R:<br>&gt; SubstriptableCollection where S.Element == Element, R.Element ==<br>&gt; Index&gt;(range: R) -&gt; S { get set }` // Point 3 above<br>&gt;<br>&gt;     /// However nearest in Swift is seperate get and set methods :(.<br>&gt;<br>&gt;     func getSubscript&lt;S: SubstriptableCollection, R:<br>&gt; SubstriptableCollection where S.Element == Element, R.Element ==<br>&gt; Index&gt;(range: R) -&gt; S<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt;   -- Howard.<br>&gt;<br>&gt; On 3 March 2016 at 19:34, Haravikk via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Nested generic types are definitely a big +1 from me. In particular if I<br>&gt;&gt; can use them to fulfil associated type requirements, for example:<br>&gt;&gt;<br>&gt;&gt; protocol FooType {<br>&gt;&gt; typealias Element<br>&gt;&gt; typealias Index<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; struct Foo&lt;E&gt; : FooType {<br>&gt;&gt; typealias Element = E<br>&gt;&gt; struct Index { … }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; The other thing I’d like to see for generics isn’t really a new feature,<br>&gt;&gt; but I’d like to be able to define protocol generics in the same format as<br>&gt;&gt; for types, i.e- I could rewrite the above protocol as:<br>&gt;&gt;<br>&gt;&gt; protocol FooType&lt;Element, Index&gt; {}<br>&gt;&gt;<br>&gt;&gt; Likewise when placing constraints on methods etc.:<br>&gt;&gt;<br>&gt;&gt; func myMethod(someFoo:FooType&lt;String, Int&gt;) { … }<br>&gt;&gt;<br>&gt;&gt; Even if behind the scenes these are still unwrapped into associated types<br>&gt;&gt; and where clauses, it’s just much, much easier to work with in the majority<br>&gt;&gt; of cases (where clauses would still exist for the more complex ones).<br>&gt;&gt;<br>&gt;&gt; The other capabilities you’ve described all seem very useful, but it’s<br>&gt;&gt; probably going to take a day or two to get my head around all of them!<br>&gt;&gt;<br>&gt;&gt; On 3 Mar 2016, at 01:22, Douglas Gregor via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Hi all,<br>&gt;&gt;<br>&gt;&gt; *Introduction*<br>&gt;&gt;<br>&gt;&gt; The “Complete Generics” goal for Swift 3 has been fairly ill-defined thus<br>&gt;&gt; fair, with just this short blurb in the list of goals:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;    - *Complete generics*: Generics are used pervasively in a number of<br>&gt;&gt;    Swift libraries, especially the standard library. However, there are a<br>&gt;&gt;    number of generics features the standard library requires to fully realize<br>&gt;&gt;    its vision, including recursive protocol constraints, the ability to make a<br>&gt;&gt;    constrained extension conform to a new protocol (i.e., an array of<br>&gt;&gt;    Equatable elements is Equatable), and so on. Swift 3.0 should provide<br>&gt;&gt;    those generics features needed by the standard library, because they affect<br>&gt;&gt;    the standard library&#39;s ABI.<br>&gt;&gt;<br>&gt;&gt; This message expands upon the notion of “completing generics”. It is not<br>&gt;&gt; a plan for Swift 3, nor an official core team communication, but it<br>&gt;&gt; collects the results of numerous discussions among the core team and Swift<br>&gt;&gt; developers, both of the compiler and the standard library. I hope to<br>&gt;&gt; achieve several things:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;    - Communicate a vision for Swift generics, building on the original<br>&gt;&gt;    generics design document<br>&gt;&gt;    &lt;https://github.com/apple/swift/blob/master/docs/Generics.rst&gt;, so we<br>&gt;&gt;    have something concrete and comprehensive to discuss.<br>&gt;&gt;    - Establish some terminology that the Swift developers have been<br>&gt;&gt;    using for these features, so our discussions can be more productive (“oh,<br>&gt;&gt;    you’re proposing what we refer to as ‘conditional conformances’; go look<br>&gt;&gt;    over at this thread”).<br>&gt;&gt;    - Engage more of the community in discussions of specific generics<br>&gt;&gt;    features, so we can coalesce around designs for public review. And maybe<br>&gt;&gt;    even get some of them implemented.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; A message like this can easily turn into a centithread<br>&gt;&gt; &lt;http://www.urbandictionary.com/define.php?term=centithread&gt;. To<br>&gt;&gt; separate concerns in our discussion, I ask that replies to this specific<br>&gt;&gt; thread be limited to discussions of the vision as a whole: how the pieces<br>&gt;&gt; fit together, what pieces are missing, whether this is the right long-term<br>&gt;&gt; vision for Swift, and so on. For discussions of specific language features,<br>&gt;&gt; e.g., to work out the syntax and semantics of conditional conformances or<br>&gt;&gt; discuss the implementation in compiler or use in the standard library,<br>&gt;&gt; please start a new thread based on the feature names I’m using.<br>&gt;&gt;<br>&gt;&gt; This message covers a lot of ground; I’ve attempted a rough<br>&gt;&gt; categorization of the various features, and kept the descriptions brief to<br>&gt;&gt; limit the overall length. Most of these aren’t my ideas, and any syntax I’m<br>&gt;&gt; providing is simply a way to express these ideas in code and is subject to<br>&gt;&gt; change. Not all of these features will happen, either soon or ever, but<br>&gt;&gt; they are intended to be a fairly complete whole that should mesh together.<br>&gt;&gt; I’ve put a * next to features that I think are important in the nearer term<br>&gt;&gt; vs. being interesting “some day”. Mostly, the *’s reflect features that<br>&gt;&gt; will have a significant impact on the Swift standard library’s design and<br>&gt;&gt; implementation.<br>&gt;&gt;<br>&gt;&gt; Enough with the disclaimers; it’s time to talk features.<br>&gt;&gt;<br>&gt;&gt; *Removing unnecessary restrictions*<br>&gt;&gt;<br>&gt;&gt; There are a number of restrictions to the use of generics that fall out<br>&gt;&gt; of the implementation in the Swift compiler. Removal of these restrictions<br>&gt;&gt; is a matter of implementation only; one need not introduce new syntax or<br>&gt;&gt; semantics to realize them. I’m listing them for two reasons: first, it’s an<br>&gt;&gt; acknowledgment that these features are intended to exist in the model we<br>&gt;&gt; have today, and, second, we’d love help with the implementation of these<br>&gt;&gt; features.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; **Recursive protocol constraints*<br>&gt;&gt;<br>&gt;&gt; Currently, an associated type cannot be required to conform to its<br>&gt;&gt; enclosing protocol (or any protocol that inherits that protocol). For<br>&gt;&gt; example, in the standard library SubSequence type of a Sequence should<br>&gt;&gt; itself be a Sequence:<br>&gt;&gt;<br>&gt;&gt; protocol Sequence {<br>&gt;&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;&gt;   …<br>&gt;&gt;   associatedtype SubSequence *: Sequence   **// currently ill-formed,<br>&gt;&gt; but should be possible*<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; The compiler currently rejects this protocol, which is unfortunate: it<br>&gt;&gt; effectively pushes the SubSequence-must-be-a-Sequence requirement into<br>&gt;&gt; every consumer of SubSequence, and does not communicate the intent of this<br>&gt;&gt; abstraction well.<br>&gt;&gt;<br>&gt;&gt; *Nested generics*<br>&gt;&gt;<br>&gt;&gt; Currently, a generic type cannot be nested within another generic type,<br>&gt;&gt; e.g.<br>&gt;&gt;<br>&gt;&gt; struct X&lt;T&gt; {<br>&gt;&gt;   struct Y&lt;U&gt; { }  *// currently ill-formed, but should be possible*<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; There isn’t much to say about this: the compiler simply needs to be<br>&gt;&gt; improved to handle nested generics throughout.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *Concrete same-type requirements*<br>&gt;&gt;<br>&gt;&gt; Currently, a constrained extension cannot use a same-type constraint to<br>&gt;&gt; make a type parameter equivalent to a concrete type. For example:<br>&gt;&gt;<br>&gt;&gt; extension Array *where Element == String* {<br>&gt;&gt;   func makeSentence() -&gt; String {<br>&gt;&gt;     // uppercase first string, concatenate with spaces, add a period,<br>&gt;&gt; whatever<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; This is a highly-requested feature that fits into the existing syntax and<br>&gt;&gt; semantics. Note that one could imagine introducing new syntax, e.g.,<br>&gt;&gt; extending “Array&lt;String&gt;”, which gets into new-feature territory: see the<br>&gt;&gt; section on “Parameterized extensions”.<br>&gt;&gt;<br>&gt;&gt; *Parameterizing other declarations*<br>&gt;&gt;<br>&gt;&gt; There are a number of Swift declarations that currently cannot have<br>&gt;&gt; generic parameters; some of those have fairly natural extensions to generic<br>&gt;&gt; forms that maintain their current syntax and semantics, but become more<br>&gt;&gt; powerful when made generic.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *Generic typealiases*<br>&gt;&gt; Typealiases could be allowed to carry generic parameters. They would<br>&gt;&gt; still be aliases (i.e., they would not introduce new types). For example:<br>&gt;&gt;<br>&gt;&gt; typealias StringDictionary&lt;Value&gt; = Dictionary&lt;String, Value&gt;<br>&gt;&gt;<br>&gt;&gt; var d1 = StringDictionary&lt;Int&gt;()<br>&gt;&gt; var d2: Dictionary&lt;String, Int&gt; = d1 // okay: d1 and d2 have the same<br>&gt;&gt; type, Dictionary&lt;String, Int&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *Generic subscripts*<br>&gt;&gt;<br>&gt;&gt; Subscripts could be allowed to have generic parameters. For example, we<br>&gt;&gt; could introduce a generic subscript on a Collection that allows us to pull<br>&gt;&gt; out the values at an arbitrary set of indices:<br>&gt;&gt;<br>&gt;&gt; extension Collection {<br>&gt;&gt;   subscript*&lt;Indices: Sequence where Indices.Iterator.Element == Index&gt;*(indices:<br>&gt;&gt; Indices) -&gt; [Iterator.Element] {<br>&gt;&gt;     get {<br>&gt;&gt;       var result = [Iterator.Element]()<br>&gt;&gt;       for index in indices {<br>&gt;&gt;         result.append(self[index])<br>&gt;&gt;       }<br>&gt;&gt;<br>&gt;&gt;       return result<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;     set {<br>&gt;&gt;       for (index, value) in zip(indices, newValue) {<br>&gt;&gt;         self[index] = value<br>&gt;&gt;       }<br>&gt;&gt;     }<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *Generic constants*<br>&gt;&gt;<br>&gt;&gt; let constants could be allowed to have generic parameters, such that they<br>&gt;&gt; produce differently-typed values depending on how they are used. For<br>&gt;&gt; example, this is particularly useful for named literal values, e.g.,<br>&gt;&gt;<br>&gt;&gt; let π&lt;T : FloatLiteralConvertible&gt;: T<br>&gt;&gt; = 3.141592653589793238462643383279502884197169399<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; The Clang importer could make particularly good use of this when<br>&gt;&gt; importing macros.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *Parameterized extensions*<br>&gt;&gt;<br>&gt;&gt; Extensions themselves could be parameterized, which would allow some<br>&gt;&gt; structural pattern matching on types. For example, this would permit one to<br>&gt;&gt; extend an array of optional values, e.g.,<br>&gt;&gt;<br>&gt;&gt; extension*&lt;T&gt;* Array *where Element == T?* {<br>&gt;&gt;   var someValues: [T] {<br>&gt;&gt;     var result = [T]()<br>&gt;&gt;     for opt in self {<br>&gt;&gt;       if let value = opt { result.append(value) }<br>&gt;&gt;     }<br>&gt;&gt;    return result<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; We can generalize this to a protocol extensions:<br>&gt;&gt;<br>&gt;&gt; extension*&lt;T&gt;* Sequence *where Element == T?* {<br>&gt;&gt;   var someValues: [T] {<br>&gt;&gt;     var result = [T]()<br>&gt;&gt;     for opt in self {<br>&gt;&gt;       if let value = opt { result.append(value) }<br>&gt;&gt;     }<br>&gt;&gt;    return result<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Note that when one is extending nominal types, we could simplify the<br>&gt;&gt; syntax somewhat to make the same-type constraint implicit in the syntax:<br>&gt;&gt;<br>&gt;&gt; extension*&lt;T&gt;* Array*&lt;T?&gt;* {<br>&gt;&gt;   var someValues: [T] {<br>&gt;&gt;     var result = [T]()<br>&gt;&gt;     for opt in self {<br>&gt;&gt;       if let value = opt { result.append(value) }<br>&gt;&gt;     }<br>&gt;&gt;    return result<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; When we’re working with concrete types, we can use that syntax to improve<br>&gt;&gt; the extension of concrete versions of generic types (per “Concrete<br>&gt;&gt; same-type requirements”, above), e.g.,<br>&gt;&gt;<br>&gt;&gt; extension Array*&lt;String&gt;* {<br>&gt;&gt;   func makeSentence() -&gt; String {<br>&gt;&gt;     // uppercase first string, concatenate with spaces, add a period,<br>&gt;&gt; whatever<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *Minor extensions*<br>&gt;&gt;<br>&gt;&gt; There are a number of minor extensions we can make to the generics system<br>&gt;&gt; that don’t fundamentally change what one can express in Swift, but which<br>&gt;&gt; can improve its expressivity.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; **Arbitrary requirements in protocols*<br>&gt;&gt;<br>&gt;&gt; Currently, a new protocol can inherit from other protocols, introduce new<br>&gt;&gt; associated types, and add new conformance constraints to associated types<br>&gt;&gt; (by redeclaring an associated type from an inherited protocol). However,<br>&gt;&gt; one cannot express more general constraints. Building on the example from<br>&gt;&gt; “Recursive protocol constraints”, we really want the element type of a<br>&gt;&gt; Sequence’s SubSequence to be the same as the element type of the Sequence,<br>&gt;&gt; e.g.,<br>&gt;&gt;<br>&gt;&gt; protocol Sequence {<br>&gt;&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;&gt;   …<br>&gt;&gt;   associatedtype SubSequence : Sequence* where<br>&gt;&gt; SubSequence.Iterator.Element == Iterator.Element*<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Hanging the where clause off the associated type is protocol not ideal,<br>&gt;&gt; but that’s a discussion for another thread.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; **Typealiases in protocols and protocol extensions*<br>&gt;&gt;<br>&gt;&gt; Now that associated types have their own keyword (thanks!), it’s<br>&gt;&gt; reasonable to bring back “typealias”. Again with the Sequence protocol:<br>&gt;&gt;<br>&gt;&gt; protocol Sequence {<br>&gt;&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;&gt;   typealias Element = Iterator.Element   // rejoice! now we can refer to<br>&gt;&gt; SomeSequence.Element rather than SomeSequence.Iterator.Element<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *Default generic arguments *<br>&gt;&gt;<br>&gt;&gt; Generic parameters could be given the ability to provide default<br>&gt;&gt; arguments, which would be used in cases where the type argument is not<br>&gt;&gt; specified and type inference could not determine the type argument. For<br>&gt;&gt; example:<br>&gt;&gt;<br>&gt;&gt; public final class Promise&lt;Value, Reason=Error&gt; { … }<br>&gt;&gt;<br>&gt;&gt; func getRandomPromise() -&gt; Promise&lt;Int, ErrorProtocol&gt; { … }<br>&gt;&gt;<br>&gt;&gt; var p1: Promise&lt;Int&gt; = …<br>&gt;&gt; var p2: Promise&lt;Int, Error&gt; = p1     *// okay: p1 and p2 have the same<br>&gt;&gt; type Promise&lt;Int, Error&gt;*<br>&gt;&gt; var p3: Promise = getRandomPromise() *// p3 has type **Promise&lt;Int,<br>&gt;&gt; ErrorProtocol&gt; due to type inference*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *Generalized “class” constraints*<br>&gt;&gt;<br>&gt;&gt; The “class” constraint can currently only be used for defining protocols.<br>&gt;&gt; We could generalize it to associated type and type parameter declarations,<br>&gt;&gt; e.g.,<br>&gt;&gt;<br>&gt;&gt; protocol P {<br>&gt;&gt;   associatedtype A : class<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; func foo&lt;T : class&gt;(t: T) { }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; As part of this, the magical AnyObject protocol could be replaced with<br>&gt;&gt; an existential with a class bound, so that it becomes a typealias:<br>&gt;&gt;<br>&gt;&gt; typealias AnyObject = protocol&lt;class&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; See the “Existentials” section, particularly “Generalized existentials”,<br>&gt;&gt; for more information.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; **Allowing subclasses to override requirements satisfied by defaults*<br>&gt;&gt;<br>&gt;&gt; When a superclass conforms to a protocol and has one of the protocol’s<br>&gt;&gt; requirements satisfied by a member of a protocol extension, that member<br>&gt;&gt; currently cannot be overridden by a subclass. For example:<br>&gt;&gt;<br>&gt;&gt; protocol P {<br>&gt;&gt;   func foo()<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; extension P {<br>&gt;&gt;   func foo() { print(“P”) }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; class C : P {<br>&gt;&gt;   // gets the protocol extension’s<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; class D : C {<br>&gt;&gt;   /*override not allowed!*/ func foo() { print(“D”) }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; let p: P = D()<br>&gt;&gt; p.foo() // gotcha: prints “P” rather than “D”!<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; D.foo should be required to specify “override” and should be called<br>&gt;&gt; dynamically.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *Major extensions to the generics model*<br>&gt;&gt;<br>&gt;&gt; Unlike the minor extensions, major extensions to the generics model<br>&gt;&gt; provide more expressivity in the Swift generics system and, generally, have<br>&gt;&gt; a much more significant design and implementation cost.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; **Conditional conformances*<br>&gt;&gt;<br>&gt;&gt; Conditional conformances express the notion that a generic type will<br>&gt;&gt; conform to a particular protocol only under certain circumstances. For<br>&gt;&gt; example, Array is Equatable only when its elements are Equatable:<br>&gt;&gt;<br>&gt;&gt; extension Array *: Equatable where Element : Equatable* { }<br>&gt;&gt;<br>&gt;&gt; func ==&lt;T : Equatable&gt;(lhs: Array&lt;T&gt;, rhs: Array&lt;T&gt;) -&gt; Bool { … }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Conditional conformances are a potentially very powerful feature. One<br>&gt;&gt; important aspect of this feature is how deal with or avoid overlapping<br>&gt;&gt; conformances. For example, imagine an adaptor over a Sequence that has<br>&gt;&gt; conditional conformances to Collection and MutableCollection:<br>&gt;&gt;<br>&gt;&gt; struct SequenceAdaptor&lt;S: Sequence&gt; : Sequence { }<br>&gt;&gt; extension SequenceAdaptor : Collection where S: Collection { … }<br>&gt;&gt; extension SequenceAdaptor : MutableCollection where S: MutableCollection<br>&gt;&gt; { }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; This should almost certainly be permitted, but we need to cope with or<br>&gt;&gt; reject “overlapping” conformances:<br>&gt;&gt;<br>&gt;&gt; extension SequenceAdaptor : Collection where S:<br>&gt;&gt; SomeOtherProtocolSimilarToCollection { } *// trouble: two ways for<br>&gt;&gt; SequenceAdaptor to conform to Collection*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; See the section on “Private conformances” for more about the issues with<br>&gt;&gt; having the same type conform to the same protocol multiple times.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *Variadic generics*<br>&gt;&gt;<br>&gt;&gt; Currently, a generic parameter list contains a fixed number of generic<br>&gt;&gt; parameters. If one has a type that could generalize to any number of<br>&gt;&gt; generic parameters, the only real way to deal with it today involves<br>&gt;&gt; creating a set of types. For example, consider the standard library’s “zip”<br>&gt;&gt; function. It returns one of these when provided with two arguments to zip<br>&gt;&gt; together:<br>&gt;&gt;<br>&gt;&gt; public struct Zip2Sequence&lt;Sequence1 : Sequence,<br>&gt;&gt;                            Sequence2 : Sequence&gt; : Sequence { … }<br>&gt;&gt;<br>&gt;&gt; public func zip&lt;Sequence1 : Sequence, Sequence2 : Sequence&gt;(<br>&gt;&gt;               sequence1: Sequence1, _ sequence2: Sequence2)<br>&gt;&gt;             -&gt; Zip2Sequence&lt;Sequence1, Sequence2&gt; { … }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Supporting three arguments would require copy-paste of those of those:<br>&gt;&gt;<br>&gt;&gt; public struct Zip3Sequence&lt;Sequence1 : Sequence,<br>&gt;&gt;                            Sequence2 : Sequence,<br>&gt;&gt;                            Sequence3 : Sequence&gt; : Sequence { … }<br>&gt;&gt;<br>&gt;&gt; public func zip&lt;Sequence1 : Sequence, Sequence2 : Sequence, Sequence3 :<br>&gt;&gt; Sequence&gt;(<br>&gt;&gt;               sequence1: Sequence1, _ sequence2: Sequence2, _ sequence3:<br>&gt;&gt; sequence3)<br>&gt;&gt;             -&gt; Zip3Sequence&lt;Sequence1, Sequence2, Sequence3&gt; { … }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Variadic generics would allow us to abstract over a set of generic<br>&gt;&gt; parameters. The syntax below is hopelessly influenced by C++11 variadic<br>&gt;&gt; templates &lt;http://www.jot.fm/issues/issue_2008_02/article2/&gt; (sorry),<br>&gt;&gt; where putting an ellipsis (“…”) to the left of a declaration makes it a<br>&gt;&gt; “parameter pack” containing zero or more parameters and putting an ellipsis<br>&gt;&gt; to the right of a type/expression/etc. expands the parameter packs within<br>&gt;&gt; that type/expression into separate arguments. The important part is that we<br>&gt;&gt; be able to meaningfully abstract over zero or more generic parameters, e.g.:<br>&gt;&gt;<br>&gt;&gt; public struct ZipIterator&lt;... *Iterators* : IteratorProtocol&gt; : Iterator<br>&gt;&gt; {  *// zero or more type parameters, each of which conforms to<br>&gt;&gt; IteratorProtocol*<br>&gt;&gt;   public typealias Element = (*Iterators.Element...*)<br>&gt;&gt;     *// a tuple containing the element types of each iterator in<br>&gt;&gt; Iterators*<br>&gt;&gt;<br>&gt;&gt;   var (*...iterators*): (*Iterators...*)    *// zero or more stored<br>&gt;&gt; properties, one for each type in Iterators*<br>&gt;&gt;   var reachedEnd: Bool = false<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;   public mutating func next() -&gt; Element? {<br>&gt;&gt;<br>&gt;&gt;     if reachedEnd { return nil }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     guard let values = (*iterators.next()...*) {   *// call “next” on<br>&gt;&gt; each of the iterators, put the results into a tuple named “values&quot;*<br>&gt;&gt;<br>&gt;&gt;       reachedEnd = true<br>&gt;&gt;<br>&gt;&gt;       return nil<br>&gt;&gt;<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     return values<br>&gt;&gt;<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; public struct ZipSequence&lt;*...Sequences* : Sequence&gt; : Sequence {<br>&gt;&gt;   public typealias Iterator = ZipIterator&lt;*Sequences.Iterator...*&gt;   *//<br>&gt;&gt; get the zip iterator with the iterator types of our Sequences*<br>&gt;&gt;<br>&gt;&gt;   var (...*sequences*): (*Sequences**...*)    *// zero or more stored<br>&gt;&gt; properties, one for each type in Sequences*<br>&gt;&gt;<br>&gt;&gt;   *// details ...*<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Such a design could also work for function parameters, so we can pack<br>&gt;&gt; together multiple function arguments with different types, e.g.,<br>&gt;&gt;<br>&gt;&gt; public func zip&lt;*... Sequences : SequenceType*&gt;(*... sequences:<br>&gt;&gt; Sequences...*)<br>&gt;&gt;             -&gt; ZipSequence&lt;*Sequences...*&gt; {<br>&gt;&gt;   return ZipSequence(*sequences...*)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Finally, this could tie into the discussions about a tuple “splat”<br>&gt;&gt; operator. For example:<br>&gt;&gt;<br>&gt;&gt; func apply&lt;... Args, Result&gt;(fn: (Args...) -&gt; Result,    *// function<br>&gt;&gt; taking some number of arguments and producing Result*<br>&gt;&gt;                            args: (Args...)) -&gt; Result {  *// tuple of<br>&gt;&gt; arguments*<br>&gt;&gt;   return fn(*args...*)                                     // expand the<br>&gt;&gt; arguments in the tuple “args” into separate arguments<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *Extensions of structural types*<br>&gt;&gt;<br>&gt;&gt; Currently, only nominal types (classes, structs, enums, protocols) can be<br>&gt;&gt; extended. One could imagine extending structural types—particularly tuple<br>&gt;&gt; types—to allow them to, e.g., conform to protocols. For example, pulling<br>&gt;&gt; together variadic generics, parameterized extensions, and conditional<br>&gt;&gt; conformances, one could express “a tuple type is Equatable if all of its<br>&gt;&gt; element types are Equatable”:<br>&gt;&gt;<br>&gt;&gt; extension&lt;...Elements : Equatable&gt; *(Elements...)* : Equatable {   *//<br>&gt;&gt; extending the tuple type “(Elements…)” to be Equatable*<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; There are some natural bounds here: one would need to have actual<br>&gt;&gt; structural types. One would not be able to extend every type:<br>&gt;&gt;<br>&gt;&gt; extension&lt;T&gt; T { *// error: neither a structural nor a nominal type*<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; And before you think you’re cleverly making it possible to have a<br>&gt;&gt; conditional conformance that makes every type T that conforms to protocol P<br>&gt;&gt; also conform to protocol Q, see the section &quot;Conditional conformances via<br>&gt;&gt; protocol extensions”, below:<br>&gt;&gt;<br>&gt;&gt; extension&lt;T : P&gt; T : Q { *// error: neither a structural nor a nominal<br>&gt;&gt; type*<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *Syntactic improvements*<br>&gt;&gt;<br>&gt;&gt; There are a number of potential improvements we could make to the<br>&gt;&gt; generics syntax. Such a list could go on for a very long time, so I’ll only<br>&gt;&gt; highlight some obvious ones that have been discussed by the Swift<br>&gt;&gt; developers.<br>&gt;&gt;<br>&gt;&gt; **Default implementations in protocols*<br>&gt;&gt;<br>&gt;&gt; Currently, protocol members can never have implementations. We could<br>&gt;&gt; allow one to provide such implementations to be used as the default if a<br>&gt;&gt; conforming type does not supply an implementation, e.g.,<br>&gt;&gt;<br>&gt;&gt; protocol Bag {<br>&gt;&gt;   associatedtype Element : Equatable<br>&gt;&gt;   func contains(element: Element) -&gt; Bool<br>&gt;&gt;<br>&gt;&gt;   func containsAll&lt;S: Sequence where Sequence.Iterator.Element ==<br>&gt;&gt; Element&gt;(elements: S) -&gt; Bool {<br>&gt;&gt;     for x in elements {<br>&gt;&gt;       if contains(x) { return true }<br>&gt;&gt;     }<br>&gt;&gt;     return false<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; struct IntBag : Bag {<br>&gt;&gt;   typealias Element = Int<br>&gt;&gt;   func contains(element: Int) -&gt; Bool { ... }<br>&gt;&gt;<br>&gt;&gt;   // okay: containsAll requirement is satisfied by Bag’s default<br>&gt;&gt; implementation<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; One can get this effect with protocol extensions today, hence the<br>&gt;&gt; classification of this feature as a (mostly) syntactic improvement:<br>&gt;&gt;<br>&gt;&gt; protocol Bag {<br>&gt;&gt;   associatedtype Element : Equatable<br>&gt;&gt;   func contains(element: Element) -&gt; Bool<br>&gt;&gt;<br>&gt;&gt;   func containsAll&lt;S: Sequence where Sequence.Iterator.Element ==<br>&gt;&gt; Element&gt;(elements: S) -&gt; Bool<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; extension Bag {<br>&gt;&gt;   func containsAll&lt;S: Sequence where Sequence.Iterator.Element ==<br>&gt;&gt; Element&gt;(elements: S) -&gt; Bool {<br>&gt;&gt;     for x in elements {<br>&gt;&gt;       if contains(x) { return true }<br>&gt;&gt;     }<br>&gt;&gt;     return false<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; **Moving the where clause outside of the angle brackets*<br>&gt;&gt;<br>&gt;&gt; The “where” clause of generic functions comes very early in the<br>&gt;&gt; declaration, although it is generally of much less concern to the client<br>&gt;&gt; than the function parameters and result type that follow it. This is one of<br>&gt;&gt; the things that contributes to “angle bracket blindness”. For example,<br>&gt;&gt; consider the containsAll signature above:<br>&gt;&gt;<br>&gt;&gt; func containsAll&lt;S: Sequence where Sequence.Iterator.Element ==<br>&gt;&gt; Element&gt;(elements: S) -&gt; Bool<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; One could move the “where” clause to the end of the signature, so that<br>&gt;&gt; the most important parts—name, generic parameter, parameters, result<br>&gt;&gt; type—precede it:<br>&gt;&gt;<br>&gt;&gt; func containsAll&lt;S: Sequence&gt;(elements: S) -&gt; Bool<br>&gt;&gt;<br>&gt;&gt;        where Sequence.Iterator.Element == Element<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; **Renaming “protocol&lt;…&gt;” to “Any&lt;…&gt;”.*<br>&gt;&gt;<br>&gt;&gt; The “protocol&lt;…&gt;” syntax is a bit of an oddity in Swift. It is used to<br>&gt;&gt; compose protocols together, mostly to create values of existential type,<br>&gt;&gt; e.g.,<br>&gt;&gt;<br>&gt;&gt; var x: protocol&lt;NSCoding, NSCopying&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; It’s weird that it’s a type name that starts with a lowercase letter, and<br>&gt;&gt; most Swift developers probably never deal with this feature unless they<br>&gt;&gt; happen to look at the definition of Any:<br>&gt;&gt;<br>&gt;&gt; typealias Any = protocol&lt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; “Any” might be a better name for this functionality. “Any” without<br>&gt;&gt; brackets could be a keyword for “any type”, and “Any” followed by brackets<br>&gt;&gt; could take the role of “protocol&lt;&gt;” today:<br>&gt;&gt;<br>&gt;&gt; var x: Any&lt;NSCoding, NSCopying&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; That reads much better: “Any type that conforms to NSCoding and<br>&gt;&gt; NSCopying”. See the section &quot;Generalized existentials” for additional<br>&gt;&gt; features in this space.<br>&gt;&gt;<br>&gt;&gt; *Maybe*<br>&gt;&gt;<br>&gt;&gt; There are a number of features that get discussed from time-to-time,<br>&gt;&gt; while they could fit into Swift’s generics system, it’s not clear that they<br>&gt;&gt; belong in Swift at all. The important question for any feature in this<br>&gt;&gt; category is not “can it be done” or “are there cool things we can express”,<br>&gt;&gt; but “how can everyday Swift developers benefit from the addition of such a<br>&gt;&gt; feature?”. Without strong motivating examples, none of these “maybes” will<br>&gt;&gt; move further along.<br>&gt;&gt;<br>&gt;&gt; *Dynamic dispatch for members of protocol extensions*<br>&gt;&gt;<br>&gt;&gt; Only the requirements of protocols currently use dynamic dispatch, which<br>&gt;&gt; can lead to surprises:<br>&gt;&gt;<br>&gt;&gt; protocol P {<br>&gt;&gt;   func foo()<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; extension P {<br>&gt;&gt;   func foo() { print(“P.foo()”)<br>&gt;&gt;   func bar() { print(“P.bar()”)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; struct X : P {<br>&gt;&gt;   func foo() { print(“X.foo()”)<br>&gt;&gt;   func bar() { print(“X.bar()”)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; let x = X()<br>&gt;&gt; x.foo() // X.foo()<br>&gt;&gt; x.bar() // X.bar()<br>&gt;&gt;<br>&gt;&gt; let p: P = X()<br>&gt;&gt; p.foo() // X.foo()<br>&gt;&gt; p.bar() // P.bar()<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Swift could adopt a model where members of protocol extensions are<br>&gt;&gt; dynamically dispatched.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *Named generic parameters*<br>&gt;&gt;<br>&gt;&gt; When specifying generic arguments for a generic type, the arguments are<br>&gt;&gt; always positional: Dictionary&lt;String, Int&gt; is a Dictionary whose Key type<br>&gt;&gt; is String and whose Value type is Int, by convention. One could permit the<br>&gt;&gt; arguments to be labeled, e.g.,<br>&gt;&gt;<br>&gt;&gt; var d: Dictionary&lt;*Key:* String, *Value:* Int&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Such a feature makes more sense if Swift gains default generic arguments,<br>&gt;&gt; because generic argument labels would allow one to skip defaulted arguments.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *Generic value parameters*<br>&gt;&gt;<br>&gt;&gt; Currently, Swift’s generic parameters are always types. One could imagine<br>&gt;&gt; allowing generic parameters that are values, e.g.,<br>&gt;&gt;<br>&gt;&gt; struct MultiArray&lt;T,* let Dimensions: Int*&gt; { *// specify the number of<br>&gt;&gt; dimensions to the array*<br>&gt;&gt;   subscript (indices: Int...) -&gt; T {<br>&gt;&gt;     get {<br>&gt;&gt;       require(indices.count == *Dimensions*)<br>&gt;&gt;       // ...<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; A suitably general feature might allow us to express fixed-length array<br>&gt;&gt; or vector types as a standard library component, and perhaps also allow one<br>&gt;&gt; to implement a useful dimensional analysis library. Tackling this feature<br>&gt;&gt; potentially means determining what it is for an expression to be a<br>&gt;&gt; “constant expression” and diving into dependent-typing, hence the “maybe”.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *Higher-kinded types*<br>&gt;&gt;<br>&gt;&gt; Higher-kinded types allow one to express the relationship between two<br>&gt;&gt; different specializations of the same nominal type within a protocol. For<br>&gt;&gt; example, if we think of the Self type in a protocol as really being<br>&gt;&gt; “Self&lt;T&gt;”, it allows us to talk about the relationship between “Self&lt;T&gt;”<br>&gt;&gt; and “Self&lt;U&gt;” for some other type U. For example, it could allow the “map”<br>&gt;&gt; operation on a collection to return a collection of the same kind but with<br>&gt;&gt; a different operation, e.g.,<br>&gt;&gt;<br>&gt;&gt; let intArray: Array&lt;Int&gt; = …<br>&gt;&gt; intArray.map { String($0) } *// produces Array&lt;String&gt;*<br>&gt;&gt; let intSet: Set&lt;Int&gt; = …<br>&gt;&gt; intSet.map { String($0) }   *// produces Set&lt;String&gt;*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Potential syntax borrowed from one thread on higher-kinded types<br>&gt;&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002736.html&gt; uses<br>&gt;&gt; ~= as a “similarity” constraint to describe a Functor protocol:<br>&gt;&gt;<br>&gt;&gt; protocol Functor {<br>&gt;&gt;   associatedtype A<br>&gt;&gt;   func fmap&lt;FB where *FB ~= Self*&gt;(f: A -&gt; FB.A) -&gt; FB<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *Specifying type arguments for uses of generic functions*<br>&gt;&gt;<br>&gt;&gt; The type arguments of a generic function are always determined via type<br>&gt;&gt; inference. For example, given:<br>&gt;&gt;<br>&gt;&gt; func f&lt;T&gt;(t: T)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; one cannot directly specify T: either one calls “f” (and T is determined<br>&gt;&gt; via the argument’s type) or one uses “f” in a context where it is given a<br>&gt;&gt; particular function type (e.g., “let x: (Int) -&gt; Void = f”  would infer T =<br>&gt;&gt; Int). We could permit explicit specialization here, e.g.,<br>&gt;&gt;<br>&gt;&gt; let x = f&lt;Int&gt; // x has type (Int) -&gt; Void<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *Unlikely*<br>&gt;&gt;<br>&gt;&gt; Features in this category have been requested at various times, but they<br>&gt;&gt; don’t fit well with Swift’s generics system because they cause some part of<br>&gt;&gt; the model to become overly complicated, have unacceptable implementation<br>&gt;&gt; limitations, or overlap significantly with existing features.<br>&gt;&gt;<br>&gt;&gt; *Generic protocols*<br>&gt;&gt;<br>&gt;&gt; One of the most commonly requested features is the ability to<br>&gt;&gt; parameterize protocols themselves. For example, a protocol that indicates<br>&gt;&gt; that the Self type can be constructed from some specified type T:<br>&gt;&gt;<br>&gt;&gt; protocol ConstructibleFromValue*&lt;T&gt;* {<br>&gt;&gt;   init(_ value: T)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Implicit in this feature is the ability for a given type to conform to<br>&gt;&gt; the protocol in two different ways. A “Real” type might be constructible<br>&gt;&gt; from both Float and Double, e.g.,<br>&gt;&gt;<br>&gt;&gt; struct Real { … }<br>&gt;&gt; extension Real : ConstructibleFrom&lt;Float&gt; {<br>&gt;&gt;   init(_ value: Float) { … }<br>&gt;&gt; }<br>&gt;&gt; extension Real : ConstructibleFrom&lt;Double&gt; {<br>&gt;&gt;   init(_ value: Double) { … }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Most of the requests for this feature actually want a different feature.<br>&gt;&gt; They tend to use a parameterized Sequence as an example, e.g.,<br>&gt;&gt;<br>&gt;&gt; protocol Sequence&lt;Element&gt; { … }<br>&gt;&gt;<br>&gt;&gt; func foo(strings: Sequence&lt;String&gt;) {  /// works on any sequence<br>&gt;&gt; containing Strings<br>&gt;&gt;   // ...<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; The actual requested feature here  is the ability to say “Any type that<br>&gt;&gt; conforms to Sequence whose Element type is String”, which is covered by the<br>&gt;&gt; section on “Generalized existentials”, below.<br>&gt;&gt;<br>&gt;&gt; More importantly, modeling Sequence with generic parameters rather than<br>&gt;&gt; associated types is tantalizing but wrong: you don’t want a type conforming<br>&gt;&gt; to Sequence in multiple ways, or (among other things) your for..in loops<br>&gt;&gt; stop working, and you lose the ability to dynamically cast down to an<br>&gt;&gt; existential “Sequence” without binding the Element type (again, see<br>&gt;&gt; “Generalized existentials”). Use cases similar to the<br>&gt;&gt; ConstructibleFromValue protocol above seem too few to justify the potential<br>&gt;&gt; for confusion between associated types and generic parameters of protocols;<br>&gt;&gt; we’re better off not having the latter.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *Private conformances *<br>&gt;&gt;<br>&gt;&gt; Right now, a protocol conformance can be no less visible than the minimum<br>&gt;&gt; of the conforming type’s access and the protocol’s access. Therefore, a<br>&gt;&gt; public type conforming to a public protocol must provide the conformance<br>&gt;&gt; publicly. One could imagine removing that restriction, so that one could<br>&gt;&gt; introduce a private conformance:<br>&gt;&gt;<br>&gt;&gt; public protocol P { }<br>&gt;&gt; public struct X { }<br>&gt;&gt; extension X : *internal P* { … } // X conforms to P, but only within<br>&gt;&gt; this module<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; The main problem with private conformances is the interaction with<br>&gt;&gt; dynamic casting. If I have this code:<br>&gt;&gt;<br>&gt;&gt; func foo(value: Any) {<br>&gt;&gt;   if let x = value as? P { print(“P”) }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; foo(X())<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Under what circumstances should it print “P”? If foo() is defined within<br>&gt;&gt; the same module as the conformance of X to P? If the call is defined within<br>&gt;&gt; the same module as the conformance of X to P? Never? Either of the first<br>&gt;&gt; two answers requires significant complications in the dynamic casting<br>&gt;&gt; infrastructure to take into account the module in which a particular<br>&gt;&gt; dynamic cast occurred (the first option) or where an existential was formed<br>&gt;&gt; (the second option), while the third answer breaks the link between the<br>&gt;&gt; static and dynamic type systems—none of which is an acceptable result.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *Conditional conformances via protocol extensions*<br>&gt;&gt;<br>&gt;&gt; We often get requests to make a protocol conform to another protocol.<br>&gt;&gt; This is, effectively, the expansion of the notion of “Conditional<br>&gt;&gt; conformances” to protocol extensions. For example:<br>&gt;&gt;<br>&gt;&gt; protocol P {<br>&gt;&gt;   func foo()<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; protocol Q {<br>&gt;&gt;   func bar()<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; extension *Q : P* { *// every type that conforms to Q also conforms to P*<br>&gt;&gt;   func foo() {    *// implement “foo” requirement in terms of “bar&quot;*<br>&gt;&gt;     bar()<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; func f&lt;T: P&gt;(t: T) { … }<br>&gt;&gt;<br>&gt;&gt; struct X : Q {<br>&gt;&gt;   func bar() { … }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; f(X()) // okay: X conforms to P through the conformance of Q to P<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; This is an extremely powerful feature: is allows one to map the<br>&gt;&gt; abstractions of one domain into another domain (e.g., every Matrix is a<br>&gt;&gt; Graph). However, similar to private conformances, it puts a major burden on<br>&gt;&gt; the dynamic-casting runtime to chase down arbitrarily long and potentially<br>&gt;&gt; cyclic chains of conformances, which makes efficient implementation nearly<br>&gt;&gt; impossible.<br>&gt;&gt;<br>&gt;&gt; *Potential removals*<br>&gt;&gt;<br>&gt;&gt; The generics system doesn’t seem like a good candidate for a reduction in<br>&gt;&gt; scope; most of its features do get used fairly pervasively in the standard<br>&gt;&gt; library, and few feel overly anachronistic. However...<br>&gt;&gt;<br>&gt;&gt; *Associated type inference*<br>&gt;&gt;<br>&gt;&gt; Associated type inference is the process by which we infer the type<br>&gt;&gt; bindings for associated types from other requirements. For example:<br>&gt;&gt;<br>&gt;&gt; protocol IteratorProtocol {<br>&gt;&gt;   associatedtype Element<br>&gt;&gt;   mutating func next() -&gt; Element?<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; struct IntIterator : IteratorProtocol {<br>&gt;&gt;   mutating func next() -&gt; Int? { … }  // use this to infer Element = Int<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Associated type inference is a useful feature. It’s used throughout the<br>&gt;&gt; standard library, and it helps keep associated types less visible to types<br>&gt;&gt; that simply want to conform to a protocol. On the other hand, associated<br>&gt;&gt; type inference is the only place in Swift where we have a *global* type<br>&gt;&gt; inference problem: it has historically been a major source of bugs, and<br>&gt;&gt; implementing it fully and correctly requires a drastically different<br>&gt;&gt; architecture to the type checker. Is the value of this feature worth<br>&gt;&gt; keeping global type inference in the Swift language, when we have<br>&gt;&gt; deliberatively avoided global type inference elsewhere in the language?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *Existentials*<br>&gt;&gt;<br>&gt;&gt; Existentials aren’t really generics per se, but the two systems are<br>&gt;&gt; closely intertwined due to their mutable dependence on protocols.<br>&gt;&gt;<br>&gt;&gt; **Generalized existentials*<br>&gt;&gt;<br>&gt;&gt; The restrictions on existential types came from an implementation<br>&gt;&gt; limitation, but it is reasonable to allow a value of protocol type even<br>&gt;&gt; when the protocol has Self constraints or associated types. For example,<br>&gt;&gt; consider IteratorProtocol again and how it could be used as an existential:<br>&gt;&gt;<br>&gt;&gt; protocol IteratorProtocol {<br>&gt;&gt;   associatedtype Element<br>&gt;&gt;   mutating func next() -&gt; Element?<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; let it: IteratorProtocol = …<br>&gt;&gt; it.next()   // if this is permitted, it could return an “Any?”, i.e., the<br>&gt;&gt; existential that wraps the actual element<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Additionally, it is reasonable to want to constrain the associated types<br>&gt;&gt; of an existential, e.g., “a Sequence whose element type is String” could be<br>&gt;&gt; expressed by putting a where clause into “protocol&lt;…&gt;” or “Any&lt;…&gt;” (per<br>&gt;&gt; “Renaming protocol&lt;…&gt; to Any&lt;…&gt;”):<br>&gt;&gt;<br>&gt;&gt; let strings: Any&lt;Sequence* where .Iterator.Element == String*&gt; = [“a”,<br>&gt;&gt; “b”, “c”]<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; The leading “.” indicates that we’re talking about the dynamic type,<br>&gt;&gt; i.e., the “Self” type that’s conforming to the Sequence protocol. There’s<br>&gt;&gt; no reason why we cannot support arbitrary “where” clauses within the<br>&gt;&gt; “Any&lt;…&gt;”. This very-general syntax is a bit unwieldy, but common cases can<br>&gt;&gt; easily be wrapped up in a generic typealias (see the section “Generic<br>&gt;&gt; typealiases” above):<br>&gt;&gt;<br>&gt;&gt; typealias AnySequence&lt;Element&gt; = *Any&lt;Sequence where .Iterator.Element<br>&gt;&gt; == Element&gt;*<br>&gt;&gt; let strings: AnySequence&lt;String&gt; = [“a”, “b”, “c”]<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *Opening existentials*<br>&gt;&gt;<br>&gt;&gt; Generalized existentials as described above will still have trouble with<br>&gt;&gt; protocol requirements that involve Self or associated types in function<br>&gt;&gt; parameters. For example, let’s try to use Equatable as an existential:<br>&gt;&gt;<br>&gt;&gt; protocol Equatable {<br>&gt;&gt;   func ==(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;   func !=(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; let e1: Equatable = …<br>&gt;&gt; let e2: Equatable = …<br>&gt;&gt; if e1 == e2 { … } *// error:* e1 and e2 don’t necessarily have the same<br>&gt;&gt; dynamic type<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; One explicit way to allow such operations in a type-safe manner is to<br>&gt;&gt; introduce an “open existential” operation of some sort, which extracts and<br>&gt;&gt; gives a name to the dynamic type stored inside an existential. For example:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; if let storedInE1 = e1 openas T {     // T is a the type of storedInE1, a<br>&gt;&gt; copy of the value stored in e1<br>&gt;&gt;<br>&gt;&gt;   if let storedInE2 = e2 as? T {      // is e2 also a T?<br>&gt;&gt;<br>&gt;&gt;     if storedInE1 == storedInE2 { … } // okay: storedInT1 and storedInE2<br>&gt;&gt; are both of type T, which we know is Equatable<br>&gt;&gt;<br>&gt;&gt;   }<br>&gt;&gt;<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Thoughts?<br>&gt;&gt;<br>&gt;&gt; - Doug<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160308/5fb74108/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Manifesto] Completing Generics</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March  8, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Mar 7, 2016, at 9:02 PM, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Another area I have seen a problem is trying to return protocols with associated types, e.g. given:<br>&gt; <br>&gt; protocol LazyNextableCollection {<br>&gt;     associated type Element<br>&gt; <br>&gt;     @warn_unused_result mutating func next() throws -&gt; Element?<br>&gt; <br>&gt;     mutating func map&lt;Mapped, Output: LazyNextableCollection where Output.Element == Mapped&gt;(mapper: (Element) throws -&gt; Mapped) -&gt; Output<br>&gt; }<br>&gt; <br>&gt; and<br>&gt; <br>&gt; struct AsLazyNextable&lt;Element&gt;: LazyNextableCollection {<br>&gt;     private let nextable: () throws -&gt; Element?<br>&gt; <br>&gt;     @warn_unused_result mutating func next() throws -&gt; Element? {<br>&gt;         return try nextable()<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; The following fails:<br>&gt; <br>&gt; extension LazyNextableCollection {<br>&gt;     mutating func map&lt;Mapped, Output: LazyNextableCollection where Output.Element == Mapped&gt;(mapper: (Element) throws -&gt; Mapped) -&gt; Output {<br>&gt;         return AsLazyNextable&lt;Mapped&gt; {<br>&gt;             let element = try self.next()<br>&gt;             guard let e = element else { return nil }<br>&gt;             return try mapper(e)<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; The compiler says that AsLazyNextable&lt;Mapped&gt; is not the same type as Output.<br></p><p>That&#39;s because it isn&#39;t. You&#39;re claiming that `map` is able to return *all* `Output` types a caller might ask for, when really you want to say it might return *any* LazyNextableCollection, but the caller doesn&#39;t get to know what it is. You&#39;d use an existential type for this:<br></p><p>mutating func map&lt;Mapped&gt;(mapper: (Element) throws -&gt; Mapped) -&gt; Any&lt;LazyNextableCollection where Element == Mapped&gt; { ... }<br></p><p>-Joe<br></p><p>&gt; <br>&gt;   -- Howard.<br>&gt; <br>&gt; On 8 March 2016 at 11:18, Howard Lovatt &lt;howard.lovatt at gmail.com &lt;mailto:howard.lovatt at gmail.com&gt;&gt; wrote:<br>&gt; I have seen a couple of areas where generics seem lacking to me:<br>&gt; <br>&gt;   1. Declaring associated types with where clauses<br>&gt;   2. Declaring generic arguments for calculated properties<br>&gt;   3. Similar to above, declaring generic properties for subscripts<br>&gt; <br>&gt; Examples of 1 and 2:<br>&gt; <br>&gt; protocol IterableCollection {<br>&gt;     associated type Element<br>&gt; <br>&gt;     /// ...<br>&gt; <br>&gt;     /// Would prefer:<br>&gt;     ///   `var lazy&lt;L: LazyNextableCollection where L.Element == Element&gt;: L { get }` // Point 2 above<br>&gt;     /// Or:<br>&gt;     ///   `associatedtype L: LazyNextableCollection where L.Element == Element` // Point 1 above<br>&gt;     ///   `var lazy: L { get }`<br>&gt;     /// But nearest possible is a function :(.<br>&gt;     func lazy&lt;L: LazyNextableCollection where L.Element == Element&gt;() -&gt; L // Best I seem to be able to do<br>&gt; }<br>&gt; <br>&gt; Example of 3:<br>&gt; <br>&gt; protocol SubstriptableCollection {<br>&gt;     associatedtype Index: Rangeable<br>&gt;     associatedtype Element<br>&gt; <br>&gt;     /// ...<br>&gt; <br>&gt;     /// Ideally would write:<br>&gt;     ///   `subscript&lt;S: SubstriptableCollection, R: SubstriptableCollection where S.Element == Element, R.Element == Index&gt;(range: R) -&gt; S { get set }` // Point 3 above<br>&gt;     /// However nearest in Swift is seperate get and set methods :(.<br>&gt;     func getSubscript&lt;S: SubstriptableCollection, R: SubstriptableCollection where S.Element == Element, R.Element == Index&gt;(range: R) -&gt; S<br>&gt; }<br>&gt; <br>&gt; <br>&gt;   -- Howard.<br>&gt; <br>&gt; On 3 March 2016 at 19:34, Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Nested generic types are definitely a big +1 from me. In particular if I can use them to fulfil associated type requirements, for example:<br>&gt; <br>&gt; 	protocol FooType {<br>&gt; 		typealias Element<br>&gt; 		typealias Index<br>&gt; 	}<br>&gt; <br>&gt; 	struct Foo&lt;E&gt; : FooType {<br>&gt; 		typealias Element = E<br>&gt; 		struct Index { … }<br>&gt; 	}<br>&gt; <br>&gt; The other thing I’d like to see for generics isn’t really a new feature, but I’d like to be able to define protocol generics in the same format as for types, i.e- I could rewrite the above protocol as:<br>&gt; <br>&gt; 	protocol FooType&lt;Element, Index&gt; {}<br>&gt; <br>&gt; Likewise when placing constraints on methods etc.:<br>&gt; <br>&gt; 	func myMethod(someFoo:FooType&lt;String, Int&gt;) { … }<br>&gt; <br>&gt; Even if behind the scenes these are still unwrapped into associated types and where clauses, it’s just much, much easier to work with in the majority of cases (where clauses would still exist for the more complex ones).<br>&gt; <br>&gt; The other capabilities you’ve described all seem very useful, but it’s probably going to take a day or two to get my head around all of them!<br>&gt; <br>&gt;&gt; On 3 Mar 2016, at 01:22, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; The “Complete Generics” goal for Swift 3 has been fairly ill-defined thus fair, with just this short blurb in the list of goals:<br>&gt;&gt; <br>&gt;&gt; Complete generics: Generics are used pervasively in a number of Swift libraries, especially the standard library. However, there are a number of generics features the standard library requires to fully realize its vision, including recursive protocol constraints, the ability to make a constrained extension conform to a new protocol (i.e., an array of Equatable elements is Equatable), and so on. Swift 3.0 should provide those generics features needed by the standard library, because they affect the standard library&#39;s ABI.<br>&gt;&gt; This message expands upon the notion of “completing generics”. It is not a plan for Swift 3, nor an official core team communication, but it collects the results of numerous discussions among the core team and Swift developers, both of the compiler and the standard library. I hope to achieve several things:<br>&gt;&gt; <br>&gt;&gt; Communicate a vision for Swift generics, building on the original generics design document &lt;https://github.com/apple/swift/blob/master/docs/Generics.rst&gt;, so we have something concrete and comprehensive to discuss.<br>&gt;&gt; Establish some terminology that the Swift developers have been using for these features, so our discussions can be more productive (“oh, you’re proposing what we refer to as ‘conditional conformances’; go look over at this thread”).<br>&gt;&gt; Engage more of the community in discussions of specific generics features, so we can coalesce around designs for public review. And maybe even get some of them implemented.<br>&gt;&gt; <br>&gt;&gt; A message like this can easily turn into a centithread &lt;http://www.urbandictionary.com/define.php?term=centithread&gt;. To separate concerns in our discussion, I ask that replies to this specific thread be limited to discussions of the vision as a whole: how the pieces fit together, what pieces are missing, whether this is the right long-term vision for Swift, and so on. For discussions of specific language features, e.g., to work out the syntax and semantics of conditional conformances or discuss the implementation in compiler or use in the standard library, please start a new thread based on the feature names I’m using.<br>&gt;&gt; <br>&gt;&gt; This message covers a lot of ground; I’ve attempted a rough categorization of the various features, and kept the descriptions brief to limit the overall length. Most of these aren’t my ideas, and any syntax I’m providing is simply a way to express these ideas in code and is subject to change. Not all of these features will happen, either soon or ever, but they are intended to be a fairly complete whole that should mesh together. I’ve put a * next to features that I think are important in the nearer term vs. being interesting “some day”. Mostly, the *’s reflect features that will have a significant impact on the Swift standard library’s design and implementation.<br>&gt;&gt; <br>&gt;&gt; Enough with the disclaimers; it’s time to talk features.<br>&gt;&gt; <br>&gt;&gt; Removing unnecessary restrictions<br>&gt;&gt; <br>&gt;&gt; There are a number of restrictions to the use of generics that fall out of the implementation in the Swift compiler. Removal of these restrictions is a matter of implementation only; one need not introduce new syntax or semantics to realize them. I’m listing them for two reasons: first, it’s an acknowledgment that these features are intended to exist in the model we have today, and, second, we’d love help with the implementation of these features.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; *Recursive protocol constraints<br>&gt;&gt; <br>&gt;&gt; Currently, an associated type cannot be required to conform to its enclosing protocol (or any protocol that inherits that protocol). For example, in the standard library SubSequence type of a Sequence should itself be a Sequence:<br>&gt;&gt; <br>&gt;&gt; protocol Sequence {<br>&gt;&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;&gt;   …<br>&gt;&gt;   associatedtype SubSequence : Sequence   // currently ill-formed, but should be possible<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The compiler currently rejects this protocol, which is unfortunate: it effectively pushes the SubSequence-must-be-a-Sequence requirement into every consumer of SubSequence, and does not communicate the intent of this abstraction well.<br>&gt;&gt; <br>&gt;&gt; Nested generics<br>&gt;&gt; <br>&gt;&gt; Currently, a generic type cannot be nested within another generic type, e.g.<br>&gt;&gt; <br>&gt;&gt; struct X&lt;T&gt; {<br>&gt;&gt;   struct Y&lt;U&gt; { }  // currently ill-formed, but should be possible<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; There isn’t much to say about this: the compiler simply needs to be improved to handle nested generics throughout.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Concrete same-type requirements<br>&gt;&gt; <br>&gt;&gt; Currently, a constrained extension cannot use a same-type constraint to make a type parameter equivalent to a concrete type. For example:<br>&gt;&gt; <br>&gt;&gt; extension Array where Element == String {<br>&gt;&gt;   func makeSentence() -&gt; String {<br>&gt;&gt;     // uppercase first string, concatenate with spaces, add a period, whatever<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This is a highly-requested feature that fits into the existing syntax and semantics. Note that one could imagine introducing new syntax, e.g., extending “Array&lt;String&gt;”, which gets into new-feature territory: see the section on “Parameterized extensions”.<br>&gt;&gt; <br>&gt;&gt; Parameterizing other declarations<br>&gt;&gt; <br>&gt;&gt; There are a number of Swift declarations that currently cannot have generic parameters; some of those have fairly natural extensions to generic forms that maintain their current syntax and semantics, but become more powerful when made generic.<br>&gt;&gt; <br>&gt;&gt; Generic typealiases<br>&gt;&gt; <br>&gt;&gt; Typealiases could be allowed to carry generic parameters. They would still be aliases (i.e., they would not introduce new types). For example:<br>&gt;&gt; <br>&gt;&gt; typealias StringDictionary&lt;Value&gt; = Dictionary&lt;String, Value&gt;<br>&gt;&gt; <br>&gt;&gt; var d1 = StringDictionary&lt;Int&gt;()<br>&gt;&gt; var d2: Dictionary&lt;String, Int&gt; = d1 // okay: d1 and d2 have the same type, Dictionary&lt;String, Int&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Generic subscripts<br>&gt;&gt; <br>&gt;&gt; Subscripts could be allowed to have generic parameters. For example, we could introduce a generic subscript on a Collection that allows us to pull out the values at an arbitrary set of indices:<br>&gt;&gt; <br>&gt;&gt; extension Collection {<br>&gt;&gt;   subscript&lt;Indices: Sequence where Indices.Iterator.Element == Index&gt;(indices: Indices) -&gt; [Iterator.Element] {<br>&gt;&gt;     get {<br>&gt;&gt;       var result = [Iterator.Element]()<br>&gt;&gt;       for index in indices {<br>&gt;&gt;         result.append(self[index])<br>&gt;&gt;       }<br>&gt;&gt; <br>&gt;&gt;       return result<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     set {<br>&gt;&gt;       for (index, value) in zip(indices, newValue) {<br>&gt;&gt;         self[index] = value<br>&gt;&gt;       }<br>&gt;&gt;     }<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Generic constants<br>&gt;&gt; <br>&gt;&gt; let constants could be allowed to have generic parameters, such that they produce differently-typed values depending on how they are used. For example, this is particularly useful for named literal values, e.g.,<br>&gt;&gt; <br>&gt;&gt; let π&lt;T : FloatLiteralConvertible&gt;: T = 3.141592653589793238462643383279502884197169399<br>&gt;&gt; <br>&gt;&gt; The Clang importer could make particularly good use of this when importing macros.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Parameterized extensions<br>&gt;&gt; <br>&gt;&gt; Extensions themselves could be parameterized, which would allow some structural pattern matching on types. For example, this would permit one to extend an array of optional values, e.g.,<br>&gt;&gt; <br>&gt;&gt; extension&lt;T&gt; Array where Element == T? {<br>&gt;&gt;   var someValues: [T] {<br>&gt;&gt;     var result = [T]()<br>&gt;&gt;     for opt in self {<br>&gt;&gt;       if let value = opt { result.append(value) }<br>&gt;&gt;     }<br>&gt;&gt;    return result<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; We can generalize this to a protocol extensions:<br>&gt;&gt; <br>&gt;&gt; extension&lt;T&gt; Sequence where Element == T? {<br>&gt;&gt;   var someValues: [T] {<br>&gt;&gt;     var result = [T]()<br>&gt;&gt;     for opt in self {<br>&gt;&gt;       if let value = opt { result.append(value) }<br>&gt;&gt;     }<br>&gt;&gt;    return result<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Note that when one is extending nominal types, we could simplify the syntax somewhat to make the same-type constraint implicit in the syntax:<br>&gt;&gt; <br>&gt;&gt; extension&lt;T&gt; Array&lt;T?&gt; {<br>&gt;&gt;   var someValues: [T] {<br>&gt;&gt;     var result = [T]()<br>&gt;&gt;     for opt in self {<br>&gt;&gt;       if let value = opt { result.append(value) }<br>&gt;&gt;     }<br>&gt;&gt;    return result<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; When we’re working with concrete types, we can use that syntax to improve the extension of concrete versions of generic types (per “Concrete same-type requirements”, above), e.g.,<br>&gt;&gt; <br>&gt;&gt; extension Array&lt;String&gt; {<br>&gt;&gt;   func makeSentence() -&gt; String {<br>&gt;&gt;     // uppercase first string, concatenate with spaces, add a period, whatever<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Minor extensions<br>&gt;&gt; <br>&gt;&gt; There are a number of minor extensions we can make to the generics system that don’t fundamentally change what one can express in Swift, but which can improve its expressivity.<br>&gt;&gt; <br>&gt;&gt; *Arbitrary requirements in protocols<br>&gt;&gt; <br>&gt;&gt; Currently, a new protocol can inherit from other protocols, introduce new associated types, and add new conformance constraints to associated types (by redeclaring an associated type from an inherited protocol). However, one cannot express more general constraints. Building on the example from “Recursive protocol constraints”, we really want the element type of a Sequence’s SubSequence to be the same as the element type of the Sequence, e.g.,<br>&gt;&gt; <br>&gt;&gt; protocol Sequence {<br>&gt;&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;&gt;   …<br>&gt;&gt;   associatedtype SubSequence : Sequence where SubSequence.Iterator.Element == Iterator.Element<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Hanging the where clause off the associated type is protocol not ideal, but that’s a discussion for another thread.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; *Typealiases in protocols and protocol extensions<br>&gt;&gt; <br>&gt;&gt; Now that associated types have their own keyword (thanks!), it’s reasonable to bring back “typealias”. Again with the Sequence protocol:<br>&gt;&gt; <br>&gt;&gt; protocol Sequence {<br>&gt;&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;&gt;   typealias Element = Iterator.Element   // rejoice! now we can refer to SomeSequence.Element rather than SomeSequence.Iterator.Element<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Default generic arguments <br>&gt;&gt; <br>&gt;&gt; Generic parameters could be given the ability to provide default arguments, which would be used in cases where the type argument is not specified and type inference could not determine the type argument. For example:<br>&gt;&gt; <br>&gt;&gt; public final class Promise&lt;Value, Reason=Error&gt; { … }<br>&gt;&gt; <br>&gt;&gt; func getRandomPromise() -&gt; Promise&lt;Int, ErrorProtocol&gt; { … }<br>&gt;&gt; <br>&gt;&gt; var p1: Promise&lt;Int&gt; = …<br>&gt;&gt; var p2: Promise&lt;Int, Error&gt; = p1     // okay: p1 and p2 have the same type Promise&lt;Int, Error&gt;<br>&gt;&gt; var p3: Promise = getRandomPromise() // p3 has type Promise&lt;Int, ErrorProtocol&gt; due to type inference<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Generalized “class” constraints<br>&gt;&gt; <br>&gt;&gt; The “class” constraint can currently only be used for defining protocols. We could generalize it to associated type and type parameter declarations, e.g.,<br>&gt;&gt; <br>&gt;&gt; protocol P {<br>&gt;&gt;   associatedtype A : class<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func foo&lt;T : class&gt;(t: T) { }<br>&gt;&gt; <br>&gt;&gt; As part of this, the magical AnyObject protocol could be replaced with an existential with a class bound, so that it becomes a typealias:<br>&gt;&gt; <br>&gt;&gt; typealias AnyObject = protocol&lt;class&gt;<br>&gt;&gt; <br>&gt;&gt; See the “Existentials” section, particularly “Generalized existentials”, for more information.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; *Allowing subclasses to override requirements satisfied by defaults<br>&gt;&gt; <br>&gt;&gt; When a superclass conforms to a protocol and has one of the protocol’s requirements satisfied by a member of a protocol extension, that member currently cannot be overridden by a subclass. For example:<br>&gt;&gt; <br>&gt;&gt; protocol P {<br>&gt;&gt;   func foo()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension P {<br>&gt;&gt;   func foo() { print(“P”) }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class C : P {<br>&gt;&gt;   // gets the protocol extension’s <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class D : C {<br>&gt;&gt;   /*override not allowed!*/ func foo() { print(“D”) }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let p: P = D()<br>&gt;&gt; p.foo() // gotcha: prints “P” rather than “D”!<br>&gt;&gt; <br>&gt;&gt; D.foo should be required to specify “override” and should be called dynamically.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Major extensions to the generics model<br>&gt;&gt; <br>&gt;&gt; Unlike the minor extensions, major extensions to the generics model provide more expressivity in the Swift generics system and, generally, have a much more significant design and implementation cost.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; *Conditional conformances<br>&gt;&gt; <br>&gt;&gt; Conditional conformances express the notion that a generic type will conform to a particular protocol only under certain circumstances. For example, Array is Equatable only when its elements are Equatable:<br>&gt;&gt; <br>&gt;&gt; extension Array : Equatable where Element : Equatable { }<br>&gt;&gt; <br>&gt;&gt; func ==&lt;T : Equatable&gt;(lhs: Array&lt;T&gt;, rhs: Array&lt;T&gt;) -&gt; Bool { … }<br>&gt;&gt; <br>&gt;&gt; Conditional conformances are a potentially very powerful feature. One important aspect of this feature is how deal with or avoid overlapping conformances. For example, imagine an adaptor over a Sequence that has conditional conformances to Collection and MutableCollection:<br>&gt;&gt; <br>&gt;&gt; struct SequenceAdaptor&lt;S: Sequence&gt; : Sequence { }<br>&gt;&gt; extension SequenceAdaptor : Collection where S: Collection { … }<br>&gt;&gt; extension SequenceAdaptor : MutableCollection where S: MutableCollection { }<br>&gt;&gt; <br>&gt;&gt; This should almost certainly be permitted, but we need to cope with or reject “overlapping” conformances:<br>&gt;&gt; <br>&gt;&gt; extension SequenceAdaptor : Collection where S: SomeOtherProtocolSimilarToCollection { } // trouble: two ways for SequenceAdaptor to conform to Collection<br>&gt;&gt; <br>&gt;&gt; See the section on “Private conformances” for more about the issues with having the same type conform to the same protocol multiple times.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Variadic generics<br>&gt;&gt; <br>&gt;&gt; Currently, a generic parameter list contains a fixed number of generic parameters. If one has a type that could generalize to any number of generic parameters, the only real way to deal with it today involves creating a set of types. For example, consider the standard library’s “zip” function. It returns one of these when provided with two arguments to zip together:<br>&gt;&gt; <br>&gt;&gt; public struct Zip2Sequence&lt;Sequence1 : Sequence,<br>&gt;&gt;                            Sequence2 : Sequence&gt; : Sequence { … }<br>&gt;&gt; <br>&gt;&gt; public func zip&lt;Sequence1 : Sequence, Sequence2 : Sequence&gt;(<br>&gt;&gt;               sequence1: Sequence1, _ sequence2: Sequence2)<br>&gt;&gt;             -&gt; Zip2Sequence&lt;Sequence1, Sequence2&gt; { … }<br>&gt;&gt; <br>&gt;&gt; Supporting three arguments would require copy-paste of those of those:<br>&gt;&gt; <br>&gt;&gt; public struct Zip3Sequence&lt;Sequence1 : Sequence,<br>&gt;&gt;                            Sequence2 : Sequence,<br>&gt;&gt;                            Sequence3 : Sequence&gt; : Sequence { … }<br>&gt;&gt; <br>&gt;&gt; public func zip&lt;Sequence1 : Sequence, Sequence2 : Sequence, Sequence3 : Sequence&gt;(<br>&gt;&gt;               sequence1: Sequence1, _ sequence2: Sequence2, _ sequence3: sequence3)<br>&gt;&gt;             -&gt; Zip3Sequence&lt;Sequence1, Sequence2, Sequence3&gt; { … }<br>&gt;&gt; <br>&gt;&gt; Variadic generics would allow us to abstract over a set of generic parameters. The syntax below is hopelessly influenced by C++11 variadic templates &lt;http://www.jot.fm/issues/issue_2008_02/article2/&gt; (sorry), where putting an ellipsis (“…”) to the left of a declaration makes it a “parameter pack” containing zero or more parameters and putting an ellipsis to the right of a type/expression/etc. expands the parameter packs within that type/expression into separate arguments. The important part is that we be able to meaningfully abstract over zero or more generic parameters, e.g.:<br>&gt;&gt; <br>&gt;&gt; public struct ZipIterator&lt;... Iterators : IteratorProtocol&gt; : Iterator {  // zero or more type parameters, each of which conforms to IteratorProtocol<br>&gt;&gt;   public typealias Element = (Iterators.Element...)                       // a tuple containing the element types of each iterator in Iterators<br>&gt;&gt; <br>&gt;&gt;   var (...iterators): (Iterators...)    // zero or more stored properties, one for each type in Iterators <br>&gt;&gt;   var reachedEnd: Bool = false<br>&gt;&gt; <br>&gt;&gt;   public mutating func next() -&gt; Element? {<br>&gt;&gt;     if reachedEnd { return nil }<br>&gt;&gt; <br>&gt;&gt;     guard let values = (iterators.next()...) {   // call “next” on each of the iterators, put the results into a tuple named “values&quot;<br>&gt;&gt;       reachedEnd = true<br>&gt;&gt;       return nil<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     return values<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; public struct ZipSequence&lt;...Sequences : Sequence&gt; : Sequence {<br>&gt;&gt;   public typealias Iterator = ZipIterator&lt;Sequences.Iterator...&gt;   // get the zip iterator with the iterator types of our Sequences<br>&gt;&gt; <br>&gt;&gt;   var (...sequences): (Sequences...)    // zero or more stored properties, one for each type in Sequences <br>&gt;&gt; <br>&gt;&gt;   // details ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Such a design could also work for function parameters, so we can pack together multiple function arguments with different types, e.g.,<br>&gt;&gt; <br>&gt;&gt; public func zip&lt;... Sequences : SequenceType&gt;(... sequences: Sequences...) <br>&gt;&gt;             -&gt; ZipSequence&lt;Sequences...&gt; {<br>&gt;&gt;   return ZipSequence(sequences...)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Finally, this could tie into the discussions about a tuple “splat” operator. For example:<br>&gt;&gt; <br>&gt;&gt; func apply&lt;... Args, Result&gt;(fn: (Args...) -&gt; Result,    // function taking some number of arguments and producing Result<br>&gt;&gt;                            args: (Args...)) -&gt; Result {  // tuple of arguments<br>&gt;&gt;   return fn(args...)                                     // expand the arguments in the tuple “args” into separate arguments<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Extensions of structural types<br>&gt;&gt; <br>&gt;&gt; Currently, only nominal types (classes, structs, enums, protocols) can be extended. One could imagine extending structural types—particularly tuple types—to allow them to, e.g., conform to protocols. For example, pulling together variadic generics, parameterized extensions, and conditional conformances, one could express “a tuple type is Equatable if all of its element types are Equatable”:<br>&gt;&gt; <br>&gt;&gt; extension&lt;...Elements : Equatable&gt; (Elements...) : Equatable {   // extending the tuple type “(Elements…)” to be Equatable<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; There are some natural bounds here: one would need to have actual structural types. One would not be able to extend every type:<br>&gt;&gt; <br>&gt;&gt; extension&lt;T&gt; T { // error: neither a structural nor a nominal type<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; And before you think you’re cleverly making it possible to have a conditional conformance that makes every type T that conforms to protocol P also conform to protocol Q, see the section &quot;Conditional conformances via protocol extensions”, below:<br>&gt;&gt; <br>&gt;&gt; extension&lt;T : P&gt; T : Q { // error: neither a structural nor a nominal type<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Syntactic improvements<br>&gt;&gt; <br>&gt;&gt; There are a number of potential improvements we could make to the generics syntax. Such a list could go on for a very long time, so I’ll only highlight some obvious ones that have been discussed by the Swift developers.<br>&gt;&gt; <br>&gt;&gt; *Default implementations in protocols<br>&gt;&gt; <br>&gt;&gt; Currently, protocol members can never have implementations. We could allow one to provide such implementations to be used as the default if a conforming type does not supply an implementation, e.g.,<br>&gt;&gt; <br>&gt;&gt; protocol Bag {<br>&gt;&gt;   associatedtype Element : Equatable<br>&gt;&gt;   func contains(element: Element) -&gt; Bool<br>&gt;&gt; <br>&gt;&gt;   func containsAll&lt;S: Sequence where Sequence.Iterator.Element == Element&gt;(elements: S) -&gt; Bool {<br>&gt;&gt;     for x in elements {<br>&gt;&gt;       if contains(x) { return true }<br>&gt;&gt;     }<br>&gt;&gt;     return false<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct IntBag : Bag {<br>&gt;&gt;   typealias Element = Int<br>&gt;&gt;   func contains(element: Int) -&gt; Bool { ... }<br>&gt;&gt; <br>&gt;&gt;   // okay: containsAll requirement is satisfied by Bag’s default implementation<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; One can get this effect with protocol extensions today, hence the classification of this feature as a (mostly) syntactic improvement:<br>&gt;&gt; <br>&gt;&gt; protocol Bag {<br>&gt;&gt;   associatedtype Element : Equatable<br>&gt;&gt;   func contains(element: Element) -&gt; Bool<br>&gt;&gt; <br>&gt;&gt;   func containsAll&lt;S: Sequence where Sequence.Iterator.Element == Element&gt;(elements: S) -&gt; Bool<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension Bag {<br>&gt;&gt;   func containsAll&lt;S: Sequence where Sequence.Iterator.Element == Element&gt;(elements: S) -&gt; Bool {<br>&gt;&gt;     for x in elements {<br>&gt;&gt;       if contains(x) { return true }<br>&gt;&gt;     }<br>&gt;&gt;     return false<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; *Moving the where clause outside of the angle brackets<br>&gt;&gt; <br>&gt;&gt; The “where” clause of generic functions comes very early in the declaration, although it is generally of much less concern to the client than the function parameters and result type that follow it. This is one of the things that contributes to “angle bracket blindness”. For example, consider the containsAll signature above:<br>&gt;&gt; <br>&gt;&gt; func containsAll&lt;S: Sequence where Sequence.Iterator.Element == Element&gt;(elements: S) -&gt; Bool<br>&gt;&gt; <br>&gt;&gt; One could move the “where” clause to the end of the signature, so that the most important parts—name, generic parameter, parameters, result type—precede it:<br>&gt;&gt; <br>&gt;&gt; func containsAll&lt;S: Sequence&gt;(elements: S) -&gt; Bool <br>&gt;&gt;        where Sequence.Iterator.Element == Element<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; *Renaming “protocol&lt;…&gt;” to “Any&lt;…&gt;”.<br>&gt;&gt; <br>&gt;&gt; The “protocol&lt;…&gt;” syntax is a bit of an oddity in Swift. It is used to compose protocols together, mostly to create values of existential type, e.g.,<br>&gt;&gt; <br>&gt;&gt; var x: protocol&lt;NSCoding, NSCopying&gt;<br>&gt;&gt; <br>&gt;&gt; It’s weird that it’s a type name that starts with a lowercase letter, and most Swift developers probably never deal with this feature unless they happen to look at the definition of Any:<br>&gt;&gt; <br>&gt;&gt; typealias Any = protocol&lt;&gt;<br>&gt;&gt; <br>&gt;&gt; “Any” might be a better name for this functionality. “Any” without brackets could be a keyword for “any type”, and “Any” followed by brackets could take the role of “protocol&lt;&gt;” today:<br>&gt;&gt; <br>&gt;&gt; var x: Any&lt;NSCoding, NSCopying&gt;<br>&gt;&gt; <br>&gt;&gt; That reads much better: “Any type that conforms to NSCoding and NSCopying”. See the section &quot;Generalized existentials” for additional features in this space.<br>&gt;&gt; <br>&gt;&gt; Maybe<br>&gt;&gt; <br>&gt;&gt; There are a number of features that get discussed from time-to-time, while they could fit into Swift’s generics system, it’s not clear that they belong in Swift at all. The important question for any feature in this category is not “can it be done” or “are there cool things we can express”, but “how can everyday Swift developers benefit from the addition of such a feature?”. Without strong motivating examples, none of these “maybes” will move further along.<br>&gt;&gt; <br>&gt;&gt; Dynamic dispatch for members of protocol extensions<br>&gt;&gt; <br>&gt;&gt; Only the requirements of protocols currently use dynamic dispatch, which can lead to surprises:<br>&gt;&gt; <br>&gt;&gt; protocol P {<br>&gt;&gt;   func foo()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension P {<br>&gt;&gt;   func foo() { print(“P.foo()”)<br>&gt;&gt;   func bar() { print(“P.bar()”)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct X : P {<br>&gt;&gt;   func foo() { print(“X.foo()”)<br>&gt;&gt;   func bar() { print(“X.bar()”)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let x = X()<br>&gt;&gt; x.foo() // X.foo()<br>&gt;&gt; x.bar() // X.bar()<br>&gt;&gt; <br>&gt;&gt; let p: P = X()<br>&gt;&gt; p.foo() // X.foo()<br>&gt;&gt; p.bar() // P.bar()<br>&gt;&gt; <br>&gt;&gt; Swift could adopt a model where members of protocol extensions are dynamically dispatched.<br>&gt;&gt; <br>&gt;&gt; Named generic parameters<br>&gt;&gt; <br>&gt;&gt; When specifying generic arguments for a generic type, the arguments are always positional: Dictionary&lt;String, Int&gt; is a Dictionary whose Key type is String and whose Value type is Int, by convention. One could permit the arguments to be labeled, e.g.,<br>&gt;&gt; <br>&gt;&gt; var d: Dictionary&lt;Key: String, Value: Int&gt;<br>&gt;&gt; <br>&gt;&gt; Such a feature makes more sense if Swift gains default generic arguments, because generic argument labels would allow one to skip defaulted arguments.<br>&gt;&gt; <br>&gt;&gt; Generic value parameters<br>&gt;&gt; <br>&gt;&gt; Currently, Swift’s generic parameters are always types. One could imagine allowing generic parameters that are values, e.g.,<br>&gt;&gt; <br>&gt;&gt; struct MultiArray&lt;T, let Dimensions: Int&gt; { // specify the number of dimensions to the array<br>&gt;&gt;   subscript (indices: Int...) -&gt; T {<br>&gt;&gt;     get {<br>&gt;&gt;       require(indices.count == Dimensions)<br>&gt;&gt;       // ...<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; A suitably general feature might allow us to express fixed-length array or vector types as a standard library component, and perhaps also allow one to implement a useful dimensional analysis library. Tackling this feature potentially means determining what it is for an expression to be a “constant expression” and diving into dependent-typing, hence the “maybe”.<br>&gt;&gt; <br>&gt;&gt; Higher-kinded types<br>&gt;&gt; <br>&gt;&gt; Higher-kinded types allow one to express the relationship between two different specializations of the same nominal type within a protocol. For example, if we think of the Self type in a protocol as really being “Self&lt;T&gt;”, it allows us to talk about the relationship between “Self&lt;T&gt;” and “Self&lt;U&gt;” for some other type U. For example, it could allow the “map” operation on a collection to return a collection of the same kind but with a different operation, e.g.,<br>&gt;&gt; <br>&gt;&gt; let intArray: Array&lt;Int&gt; = …<br>&gt;&gt; intArray.map { String($0) } // produces Array&lt;String&gt;<br>&gt;&gt; let intSet: Set&lt;Int&gt; = …<br>&gt;&gt; intSet.map { String($0) }   // produces Set&lt;String&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Potential syntax borrowed from one thread on higher-kinded types &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002736.html&gt; uses ~= as a “similarity” constraint to describe a Functor protocol:<br>&gt;&gt; <br>&gt;&gt; protocol Functor {<br>&gt;&gt;   associatedtype A<br>&gt;&gt;   func fmap&lt;FB where FB ~= Self&gt;(f: A -&gt; FB.A) -&gt; FB<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Specifying type arguments for uses of generic functions<br>&gt;&gt; <br>&gt;&gt; The type arguments of a generic function are always determined via type inference. For example, given:<br>&gt;&gt; <br>&gt;&gt; func f&lt;T&gt;(t: T)<br>&gt;&gt; <br>&gt;&gt; one cannot directly specify T: either one calls “f” (and T is determined via the argument’s type) or one uses “f” in a context where it is given a particular function type (e.g., “let x: (Int) -&gt; Void = f”  would infer T = Int). We could permit explicit specialization here, e.g.,<br>&gt;&gt; <br>&gt;&gt; let x = f&lt;Int&gt; // x has type (Int) -&gt; Void<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Unlikely<br>&gt;&gt; <br>&gt;&gt; Features in this category have been requested at various times, but they don’t fit well with Swift’s generics system because they cause some part of the model to become overly complicated, have unacceptable implementation limitations, or overlap significantly with existing features.<br>&gt;&gt; <br>&gt;&gt; Generic protocols<br>&gt;&gt; <br>&gt;&gt; One of the most commonly requested features is the ability to parameterize protocols themselves. For example, a protocol that indicates that the Self type can be constructed from some specified type T:<br>&gt;&gt; <br>&gt;&gt; protocol ConstructibleFromValue&lt;T&gt; {<br>&gt;&gt;   init(_ value: T)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Implicit in this feature is the ability for a given type to conform to the protocol in two different ways. A “Real” type might be constructible from both Float and Double, e.g.,<br>&gt;&gt; <br>&gt;&gt; struct Real { … }<br>&gt;&gt; extension Real : ConstructibleFrom&lt;Float&gt; {<br>&gt;&gt;   init(_ value: Float) { … }<br>&gt;&gt; }<br>&gt;&gt; extension Real : ConstructibleFrom&lt;Double&gt; {<br>&gt;&gt;   init(_ value: Double) { … }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Most of the requests for this feature actually want a different feature. They tend to use a parameterized Sequence as an example, e.g.,<br>&gt;&gt; <br>&gt;&gt; protocol Sequence&lt;Element&gt; { … }<br>&gt;&gt; <br>&gt;&gt; func foo(strings: Sequence&lt;String&gt;) {  /// works on any sequence containing Strings<br>&gt;&gt;   // ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The actual requested feature here 	is the ability to say “Any type that conforms to Sequence whose Element type is String”, which is covered by the section on “Generalized existentials”, below.<br>&gt;&gt; <br>&gt;&gt; More importantly, modeling Sequence with generic parameters rather than associated types is tantalizing but wrong: you don’t want a type conforming to Sequence in multiple ways, or (among other things) your for..in loops stop working, and you lose the ability to dynamically cast down to an existential “Sequence” without binding the Element type (again, see “Generalized existentials”). Use cases similar to the ConstructibleFromValue protocol above seem too few to justify the potential for confusion between associated types and generic parameters of protocols; we’re better off not having the latter.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Private conformances <br>&gt;&gt; <br>&gt;&gt; Right now, a protocol conformance can be no less visible than the minimum of the conforming type’s access and the protocol’s access. Therefore, a public type conforming to a public protocol must provide the conformance publicly. One could imagine removing that restriction, so that one could introduce a private conformance:<br>&gt;&gt; <br>&gt;&gt; public protocol P { }<br>&gt;&gt; public struct X { }<br>&gt;&gt; extension X : internal P { … } // X conforms to P, but only within this module<br>&gt;&gt; <br>&gt;&gt; The main problem with private conformances is the interaction with dynamic casting. If I have this code:<br>&gt;&gt; <br>&gt;&gt; func foo(value: Any) {<br>&gt;&gt;   if let x = value as? P { print(“P”) }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; foo(X())<br>&gt;&gt; <br>&gt;&gt; Under what circumstances should it print “P”? If foo() is defined within the same module as the conformance of X to P? If the call is defined within the same module as the conformance of X to P? Never? Either of the first two answers requires significant complications in the dynamic casting infrastructure to take into account the module in which a particular dynamic cast occurred (the first option) or where an existential was formed (the second option), while the third answer breaks the link between the static and dynamic type systems—none of which is an acceptable result.<br>&gt;&gt; <br>&gt;&gt; Conditional conformances via protocol extensions<br>&gt;&gt; <br>&gt;&gt; We often get requests to make a protocol conform to another protocol. This is, effectively, the expansion of the notion of “Conditional conformances” to protocol extensions. For example:<br>&gt;&gt; <br>&gt;&gt; protocol P {<br>&gt;&gt;   func foo()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; protocol Q {<br>&gt;&gt;   func bar()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension Q : P { // every type that conforms to Q also conforms to P<br>&gt;&gt;   func foo() {    // implement “foo” requirement in terms of “bar&quot;<br>&gt;&gt;     bar()<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func f&lt;T: P&gt;(t: T) { … }<br>&gt;&gt; <br>&gt;&gt; struct X : Q {<br>&gt;&gt;   func bar() { … }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; f(X()) // okay: X conforms to P through the conformance of Q to P<br>&gt;&gt; <br>&gt;&gt; This is an extremely powerful feature: is allows one to map the abstractions of one domain into another domain (e.g., every Matrix is a Graph). However, similar to private conformances, it puts a major burden on the dynamic-casting runtime to chase down arbitrarily long and potentially cyclic chains of conformances, which makes efficient implementation nearly impossible.<br>&gt;&gt; <br>&gt;&gt; Potential removals<br>&gt;&gt; <br>&gt;&gt; The generics system doesn’t seem like a good candidate for a reduction in scope; most of its features do get used fairly pervasively in the standard library, and few feel overly anachronistic. However...<br>&gt;&gt; <br>&gt;&gt; Associated type inference<br>&gt;&gt; <br>&gt;&gt; Associated type inference is the process by which we infer the type bindings for associated types from other requirements. For example:<br>&gt;&gt; <br>&gt;&gt; protocol IteratorProtocol {<br>&gt;&gt;   associatedtype Element<br>&gt;&gt;   mutating func next() -&gt; Element?<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct IntIterator : IteratorProtocol {<br>&gt;&gt;   mutating func next() -&gt; Int? { … }  // use this to infer Element = Int<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Associated type inference is a useful feature. It’s used throughout the standard library, and it helps keep associated types less visible to types that simply want to conform to a protocol. On the other hand, associated type inference is the only place in Swift where we have a global type inference problem: it has historically been a major source of bugs, and implementing it fully and correctly requires a drastically different architecture to the type checker. Is the value of this feature worth keeping global type inference in the Swift language, when we have deliberatively avoided global type inference elsewhere in the language?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Existentials<br>&gt;&gt; <br>&gt;&gt; Existentials aren’t really generics per se, but the two systems are closely intertwined due to their mutable dependence on protocols.<br>&gt;&gt; <br>&gt;&gt; *Generalized existentials<br>&gt;&gt; <br>&gt;&gt; The restrictions on existential types came from an implementation limitation, but it is reasonable to allow a value of protocol type even when the protocol has Self constraints or associated types. For example, consider IteratorProtocol again and how it could be used as an existential:<br>&gt;&gt; <br>&gt;&gt; protocol IteratorProtocol {<br>&gt;&gt;   associatedtype Element<br>&gt;&gt;   mutating func next() -&gt; Element?<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let it: IteratorProtocol = …<br>&gt;&gt; it.next()   // if this is permitted, it could return an “Any?”, i.e., the existential that wraps the actual element<br>&gt;&gt; <br>&gt;&gt; Additionally, it is reasonable to want to constrain the associated types of an existential, e.g., “a Sequence whose element type is String” could be expressed by putting a where clause into “protocol&lt;…&gt;” or “Any&lt;…&gt;” (per “Renaming protocol&lt;…&gt; to Any&lt;…&gt;”):<br>&gt;&gt; <br>&gt;&gt; let strings: Any&lt;Sequence where .Iterator.Element == String&gt; = [“a”, “b”, “c”]<br>&gt;&gt; <br>&gt;&gt; The leading “.” indicates that we’re talking about the dynamic type, i.e., the “Self” type that’s conforming to the Sequence protocol. There’s no reason why we cannot support arbitrary “where” clauses within the “Any&lt;…&gt;”. This very-general syntax is a bit unwieldy, but common cases can easily be wrapped up in a generic typealias (see the section “Generic typealiases” above):<br>&gt;&gt; <br>&gt;&gt; typealias AnySequence&lt;Element&gt; = Any&lt;Sequence where .Iterator.Element == Element&gt;<br>&gt;&gt; let strings: AnySequence&lt;String&gt; = [“a”, “b”, “c”]<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Opening existentials<br>&gt;&gt; <br>&gt;&gt; Generalized existentials as described above will still have trouble with protocol requirements that involve Self or associated types in function parameters. For example, let’s try to use Equatable as an existential:<br>&gt;&gt; <br>&gt;&gt; protocol Equatable {<br>&gt;&gt;   func ==(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;   func !=(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let e1: Equatable = …<br>&gt;&gt; let e2: Equatable = …<br>&gt;&gt; if e1 == e2 { … } // error: e1 and e2 don’t necessarily have the same dynamic type<br>&gt;&gt; <br>&gt;&gt; One explicit way to allow such operations in a type-safe manner is to introduce an “open existential” operation of some sort, which extracts and gives a name to the dynamic type stored inside an existential. For example:<br>&gt;&gt; <br>&gt;&gt; 	 <br>&gt;&gt; if let storedInE1 = e1 openas T {     // T is a the type of storedInE1, a copy of the value stored in e1<br>&gt;&gt;   if let storedInE2 = e2 as? T {      // is e2 also a T?<br>&gt;&gt;     if storedInE1 == storedInE2 { … } // okay: storedInT1 and storedInE2 are both of type T, which we know is Equatable<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Thoughts?<br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160308/bb06e447/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Manifesto] Completing Generics</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>March 10, 2016 at 01:00:00pm</p></header><div class="content"><p>Wow, I would never have guessed that syntax :)<br></p><p>It makes no sense to me to interpret a generic constraint as meaning all<br>instead of any. How could anything either accept or return all possible<br>implementations of something simultaneously, surely it only ever accepts or<br>returns one of all the possible implementations at a time.<br></p><p>If the interpretation for output is that at time 1 it returns one of all<br>the possible implementations at at time 2  returns another - then that is<br>what I want. However I would describe that as returning one of the possible<br>implementations, not all.<br></p><p>But no doubt you are correct, since you probably wrote that bit of the<br>compiler :(<br></p><p>More practical points<br></p><p> 1. My compiler, 7.3 beta (7D152p), rejects the syntax, it doesn&#39;t like<br>where inside Any&lt;&gt; saying it expects &gt; to complete generic argument list.<br>When will this be available, so that I can try it out?<br> 2. Will the declarations inside protocols also change to the Any&lt;...&gt; form<br>or will all the generics remain following the function name rather in a<br>returned Any&lt;...&gt;? Currently -&gt; Any&lt;...&gt; doesn&#39;t work in protocols for me.<br> 3. In the construct Any&lt;Protocol where Type == Type&gt;, i.e. same type name<br>used in protocol and enclosing struct/class/extension, does the left Type<br>refer to the protocol or the enclosing struct/class/extension?<br> 4. Is there any documentation of all of this?<br></p><p>  -- Howard.<br></p><p>On 9 March 2016 at 04:48, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Mar 7, 2016, at 9:02 PM, Howard Lovatt via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Another area I have seen a problem is trying to return protocols with<br>&gt; associated types, e.g. given:<br>&gt;<br>&gt; protocol LazyNextableCollection {<br>&gt;     associated type Element<br>&gt;<br>&gt;     @warn_unused_result mutating func next() throws -&gt; Element?<br>&gt;<br>&gt;     mutating func map&lt;Mapped, Output: LazyNextableCollection where Output.Element<br>&gt; == Mapped&gt;(mapper: (Element) throws -&gt; Mapped) -&gt; Output<br>&gt; }<br>&gt;<br>&gt;<br>&gt; and<br>&gt;<br>&gt; struct AsLazyNextable&lt;Element&gt;: LazyNextableCollection {<br>&gt;     private let nextable: () throws -&gt; Element?<br>&gt;<br>&gt;     @warn_unused_result mutating func next() throws -&gt; Element? {<br>&gt;         return try nextable()<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; The following fails:<br>&gt;<br>&gt; extension LazyNextableCollection {<br>&gt;     mutating func map&lt;Mapped, Output: LazyNextableCollection where Output.Element<br>&gt; == Mapped&gt;(mapper: (Element) throws -&gt; Mapped) -&gt; Output {<br>&gt;         return AsLazyNextable&lt;Mapped&gt; {<br>&gt;             let element = try self.next()<br>&gt;             guard let e = element else { return nil }<br>&gt;             return try mapper(e)<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; The compiler says that AsLazyNextable&lt;Mapped&gt; is not the same type as<br>&gt; Output.<br>&gt;<br>&gt;<br>&gt; That&#39;s because it isn&#39;t. You&#39;re claiming that `map` is able to return<br>&gt; *all* `Output` types a caller might ask for, when really you want to say it<br>&gt; might return *any* LazyNextableCollection, but the caller doesn&#39;t get to<br>&gt; know what it is. You&#39;d use an existential type for this:<br>&gt;<br>&gt; mutating func map&lt;Mapped&gt;(mapper: (Element) throws -&gt; Mapped) -&gt;<br>&gt; Any&lt;LazyNextableCollection where Element == Mapped&gt; { ... }<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt;<br>&gt;   -- Howard.<br>&gt;<br>&gt; On 8 March 2016 at 11:18, Howard Lovatt &lt;howard.lovatt at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; I have seen a couple of areas where generics seem lacking to me:<br>&gt;&gt;<br>&gt;&gt;   1. Declaring associated types with where clauses<br>&gt;&gt;   2. Declaring generic arguments for calculated properties<br>&gt;&gt;   3. Similar to above, declaring generic properties for subscripts<br>&gt;&gt;<br>&gt;&gt; Examples of 1 and 2:<br>&gt;&gt;<br>&gt;&gt; protocol IterableCollection {<br>&gt;&gt;     associated type Element<br>&gt;&gt;<br>&gt;&gt;     /// ...<br>&gt;&gt;<br>&gt;&gt;     /// Would prefer:<br>&gt;&gt;     ///   `var lazy&lt;L: LazyNextableCollection where L.Element ==<br>&gt;&gt; Element&gt;: L { get }` // Point 2 above<br>&gt;&gt;     /// Or:<br>&gt;&gt;     ///   `associatedtype L: LazyNextableCollection where L.Element ==<br>&gt;&gt; Element` // Point 1 above<br>&gt;&gt;     ///   `var lazy: L { get }`<br>&gt;&gt;     /// But nearest possible is a function :(.<br>&gt;&gt;     func lazy&lt;L: LazyNextableCollection where L.Element == Element&gt;() -&gt;<br>&gt;&gt; L // Best I seem to be able to do<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Example of 3:<br>&gt;&gt;<br>&gt;&gt; protocol SubstriptableCollection {<br>&gt;&gt;     associatedtype Index: Rangeable<br>&gt;&gt;     associatedtype Element<br>&gt;&gt;<br>&gt;&gt;     /// ...<br>&gt;&gt;<br>&gt;&gt;     /// Ideally would write:<br>&gt;&gt;     ///   `subscript&lt;S: SubstriptableCollection, R:<br>&gt;&gt; SubstriptableCollection where S.Element == Element, R.Element ==<br>&gt;&gt; Index&gt;(range: R) -&gt; S { get set }` // Point 3 above<br>&gt;&gt;     /// However nearest in Swift is seperate get and set methods :(.<br>&gt;&gt;     func getSubscript&lt;S: SubstriptableCollection, R:<br>&gt;&gt; SubstriptableCollection where S.Element == Element, R.Element ==<br>&gt;&gt; Index&gt;(range: R) -&gt; S<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;   -- Howard.<br>&gt;&gt;<br>&gt;&gt; On 3 March 2016 at 19:34, Haravikk via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Nested generic types are definitely a big +1 from me. In particular if I<br>&gt;&gt;&gt; can use them to fulfil associated type requirements, for example:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol FooType {<br>&gt;&gt;&gt; typealias Element<br>&gt;&gt;&gt; typealias Index<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; struct Foo&lt;E&gt; : FooType {<br>&gt;&gt;&gt; typealias Element = E<br>&gt;&gt;&gt; struct Index { … }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The other thing I’d like to see for generics isn’t really a new feature,<br>&gt;&gt;&gt; but I’d like to be able to define protocol generics in the same format as<br>&gt;&gt;&gt; for types, i.e- I could rewrite the above protocol as:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol FooType&lt;Element, Index&gt; {}<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Likewise when placing constraints on methods etc.:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func myMethod(someFoo:FooType&lt;String, Int&gt;) { … }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Even if behind the scenes these are still unwrapped into associated<br>&gt;&gt;&gt; types and where clauses, it’s just much, much easier to work with in the<br>&gt;&gt;&gt; majority of cases (where clauses would still exist for the more complex<br>&gt;&gt;&gt; ones).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The other capabilities you’ve described all seem very useful, but it’s<br>&gt;&gt;&gt; probably going to take a day or two to get my head around all of them!<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 3 Mar 2016, at 01:22, Douglas Gregor via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *Introduction*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The “Complete Generics” goal for Swift 3 has been fairly ill-defined<br>&gt;&gt;&gt; thus fair, with just this short blurb in the list of goals:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    - *Complete generics*: Generics are used pervasively in a number of<br>&gt;&gt;&gt;    Swift libraries, especially the standard library. However, there are a<br>&gt;&gt;&gt;    number of generics features the standard library requires to fully realize<br>&gt;&gt;&gt;    its vision, including recursive protocol constraints, the ability to make a<br>&gt;&gt;&gt;    constrained extension conform to a new protocol (i.e., an array of<br>&gt;&gt;&gt;    Equatable elements is Equatable), and so on. Swift 3.0 should<br>&gt;&gt;&gt;    provide those generics features needed by the standard library, because<br>&gt;&gt;&gt;    they affect the standard library&#39;s ABI.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This message expands upon the notion of “completing generics”. It is not<br>&gt;&gt;&gt; a plan for Swift 3, nor an official core team communication, but it<br>&gt;&gt;&gt; collects the results of numerous discussions among the core team and Swift<br>&gt;&gt;&gt; developers, both of the compiler and the standard library. I hope to<br>&gt;&gt;&gt; achieve several things:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    - Communicate a vision for Swift generics, building on the original<br>&gt;&gt;&gt;    generics design document<br>&gt;&gt;&gt;    &lt;https://github.com/apple/swift/blob/master/docs/Generics.rst&gt;, so<br>&gt;&gt;&gt;    we have something concrete and comprehensive to discuss.<br>&gt;&gt;&gt;    - Establish some terminology that the Swift developers have been<br>&gt;&gt;&gt;    using for these features, so our discussions can be more productive (“oh,<br>&gt;&gt;&gt;    you’re proposing what we refer to as ‘conditional conformances’; go look<br>&gt;&gt;&gt;    over at this thread”).<br>&gt;&gt;&gt;    - Engage more of the community in discussions of specific generics<br>&gt;&gt;&gt;    features, so we can coalesce around designs for public review. And maybe<br>&gt;&gt;&gt;    even get some of them implemented.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; A message like this can easily turn into a centithread<br>&gt;&gt;&gt; &lt;http://www.urbandictionary.com/define.php?term=centithread&gt;. To<br>&gt;&gt;&gt; separate concerns in our discussion, I ask that replies to this specific<br>&gt;&gt;&gt; thread be limited to discussions of the vision as a whole: how the pieces<br>&gt;&gt;&gt; fit together, what pieces are missing, whether this is the right long-term<br>&gt;&gt;&gt; vision for Swift, and so on. For discussions of specific language features,<br>&gt;&gt;&gt; e.g., to work out the syntax and semantics of conditional conformances or<br>&gt;&gt;&gt; discuss the implementation in compiler or use in the standard library,<br>&gt;&gt;&gt; please start a new thread based on the feature names I’m using.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This message covers a lot of ground; I’ve attempted a rough<br>&gt;&gt;&gt; categorization of the various features, and kept the descriptions brief to<br>&gt;&gt;&gt; limit the overall length. Most of these aren’t my ideas, and any syntax I’m<br>&gt;&gt;&gt; providing is simply a way to express these ideas in code and is subject to<br>&gt;&gt;&gt; change. Not all of these features will happen, either soon or ever, but<br>&gt;&gt;&gt; they are intended to be a fairly complete whole that should mesh together.<br>&gt;&gt;&gt; I’ve put a * next to features that I think are important in the nearer term<br>&gt;&gt;&gt; vs. being interesting “some day”. Mostly, the *’s reflect features that<br>&gt;&gt;&gt; will have a significant impact on the Swift standard library’s design and<br>&gt;&gt;&gt; implementation.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Enough with the disclaimers; it’s time to talk features.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *Removing unnecessary restrictions*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; There are a number of restrictions to the use of generics that fall out<br>&gt;&gt;&gt; of the implementation in the Swift compiler. Removal of these restrictions<br>&gt;&gt;&gt; is a matter of implementation only; one need not introduce new syntax or<br>&gt;&gt;&gt; semantics to realize them. I’m listing them for two reasons: first, it’s an<br>&gt;&gt;&gt; acknowledgment that these features are intended to exist in the model we<br>&gt;&gt;&gt; have today, and, second, we’d love help with the implementation of these<br>&gt;&gt;&gt; features.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; **Recursive protocol constraints*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Currently, an associated type cannot be required to conform to its<br>&gt;&gt;&gt; enclosing protocol (or any protocol that inherits that protocol). For<br>&gt;&gt;&gt; example, in the standard library SubSequence type of a Sequence should<br>&gt;&gt;&gt; itself be a Sequence:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol Sequence {<br>&gt;&gt;&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;&gt;&gt;   …<br>&gt;&gt;&gt;   associatedtype SubSequence *: Sequence   **// currently ill-formed,<br>&gt;&gt;&gt; but should be possible*<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The compiler currently rejects this protocol, which is unfortunate: it<br>&gt;&gt;&gt; effectively pushes the SubSequence-must-be-a-Sequence requirement into<br>&gt;&gt;&gt; every consumer of SubSequence, and does not communicate the intent of this<br>&gt;&gt;&gt; abstraction well.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *Nested generics*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Currently, a generic type cannot be nested within another generic type,<br>&gt;&gt;&gt; e.g.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; struct X&lt;T&gt; {<br>&gt;&gt;&gt;   struct Y&lt;U&gt; { }  *// currently ill-formed, but should be possible*<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; There isn’t much to say about this: the compiler simply needs to be<br>&gt;&gt;&gt; improved to handle nested generics throughout.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *Concrete same-type requirements*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Currently, a constrained extension cannot use a same-type constraint to<br>&gt;&gt;&gt; make a type parameter equivalent to a concrete type. For example:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; extension Array *where Element == String* {<br>&gt;&gt;&gt;   func makeSentence() -&gt; String {<br>&gt;&gt;&gt;     // uppercase first string, concatenate with spaces, add a period,<br>&gt;&gt;&gt; whatever<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This is a highly-requested feature that fits into the existing syntax<br>&gt;&gt;&gt; and semantics. Note that one could imagine introducing new syntax, e.g.,<br>&gt;&gt;&gt; extending “Array&lt;String&gt;”, which gets into new-feature territory: see the<br>&gt;&gt;&gt; section on “Parameterized extensions”.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *Parameterizing other declarations*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; There are a number of Swift declarations that currently cannot have<br>&gt;&gt;&gt; generic parameters; some of those have fairly natural extensions to generic<br>&gt;&gt;&gt; forms that maintain their current syntax and semantics, but become more<br>&gt;&gt;&gt; powerful when made generic.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *Generic typealiases*<br>&gt;&gt;&gt; Typealiases could be allowed to carry generic parameters. They would<br>&gt;&gt;&gt; still be aliases (i.e., they would not introduce new types). For example:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; typealias StringDictionary&lt;Value&gt; = Dictionary&lt;String, Value&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; var d1 = StringDictionary&lt;Int&gt;()<br>&gt;&gt;&gt; var d2: Dictionary&lt;String, Int&gt; = d1 // okay: d1 and d2 have the same<br>&gt;&gt;&gt; type, Dictionary&lt;String, Int&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *Generic subscripts*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Subscripts could be allowed to have generic parameters. For example, we<br>&gt;&gt;&gt; could introduce a generic subscript on a Collection that allows us to pull<br>&gt;&gt;&gt; out the values at an arbitrary set of indices:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; extension Collection {<br>&gt;&gt;&gt;   subscript*&lt;Indices: Sequence where Indices.Iterator.Element == Index&gt;*(indices:<br>&gt;&gt;&gt; Indices) -&gt; [Iterator.Element] {<br>&gt;&gt;&gt;     get {<br>&gt;&gt;&gt;       var result = [Iterator.Element]()<br>&gt;&gt;&gt;       for index in indices {<br>&gt;&gt;&gt;         result.append(self[index])<br>&gt;&gt;&gt;       }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;       return result<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     set {<br>&gt;&gt;&gt;       for (index, value) in zip(indices, newValue) {<br>&gt;&gt;&gt;         self[index] = value<br>&gt;&gt;&gt;       }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *Generic constants*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let constants could be allowed to have generic parameters, such that<br>&gt;&gt;&gt; they produce differently-typed values depending on how they are used. For<br>&gt;&gt;&gt; example, this is particularly useful for named literal values, e.g.,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let π&lt;T : FloatLiteralConvertible&gt;: T<br>&gt;&gt;&gt; = 3.141592653589793238462643383279502884197169399<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The Clang importer could make particularly good use of this when<br>&gt;&gt;&gt; importing macros.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *Parameterized extensions*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Extensions themselves could be parameterized, which would allow some<br>&gt;&gt;&gt; structural pattern matching on types. For example, this would permit one to<br>&gt;&gt;&gt; extend an array of optional values, e.g.,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; extension*&lt;T&gt;* Array *where Element == T?* {<br>&gt;&gt;&gt;   var someValues: [T] {<br>&gt;&gt;&gt;     var result = [T]()<br>&gt;&gt;&gt;     for opt in self {<br>&gt;&gt;&gt;       if let value = opt { result.append(value) }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;    return result<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; We can generalize this to a protocol extensions:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; extension*&lt;T&gt;* Sequence *where Element == T?* {<br>&gt;&gt;&gt;   var someValues: [T] {<br>&gt;&gt;&gt;     var result = [T]()<br>&gt;&gt;&gt;     for opt in self {<br>&gt;&gt;&gt;       if let value = opt { result.append(value) }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;    return result<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Note that when one is extending nominal types, we could simplify the<br>&gt;&gt;&gt; syntax somewhat to make the same-type constraint implicit in the syntax:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; extension*&lt;T&gt;* Array*&lt;T?&gt;* {<br>&gt;&gt;&gt;   var someValues: [T] {<br>&gt;&gt;&gt;     var result = [T]()<br>&gt;&gt;&gt;     for opt in self {<br>&gt;&gt;&gt;       if let value = opt { result.append(value) }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;    return result<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; When we’re working with concrete types, we can use that syntax to<br>&gt;&gt;&gt; improve the extension of concrete versions of generic types (per “Concrete<br>&gt;&gt;&gt; same-type requirements”, above), e.g.,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; extension Array*&lt;String&gt;* {<br>&gt;&gt;&gt;   func makeSentence() -&gt; String {<br>&gt;&gt;&gt;     // uppercase first string, concatenate with spaces, add a period,<br>&gt;&gt;&gt; whatever<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *Minor extensions*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; There are a number of minor extensions we can make to the generics<br>&gt;&gt;&gt; system that don’t fundamentally change what one can express in Swift, but<br>&gt;&gt;&gt; which can improve its expressivity.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; **Arbitrary requirements in protocols*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Currently, a new protocol can inherit from other protocols, introduce<br>&gt;&gt;&gt; new associated types, and add new conformance constraints to associated<br>&gt;&gt;&gt; types (by redeclaring an associated type from an inherited protocol).<br>&gt;&gt;&gt; However, one cannot express more general constraints. Building on the<br>&gt;&gt;&gt; example from “Recursive protocol constraints”, we really want the element<br>&gt;&gt;&gt; type of a Sequence’s SubSequence to be the same as the element type of the<br>&gt;&gt;&gt; Sequence, e.g.,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol Sequence {<br>&gt;&gt;&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;&gt;&gt;   …<br>&gt;&gt;&gt;   associatedtype SubSequence : Sequence* where<br>&gt;&gt;&gt; SubSequence.Iterator.Element == Iterator.Element*<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Hanging the where clause off the associated type is protocol not ideal,<br>&gt;&gt;&gt; but that’s a discussion for another thread.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; **Typealiases in protocols and protocol extensions*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Now that associated types have their own keyword (thanks!), it’s<br>&gt;&gt;&gt; reasonable to bring back “typealias”. Again with the Sequence protocol:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol Sequence {<br>&gt;&gt;&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;&gt;&gt;   typealias Element = Iterator.Element   // rejoice! now we can refer to<br>&gt;&gt;&gt; SomeSequence.Element rather than SomeSequence.Iterator.Element<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *Default generic arguments *<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Generic parameters could be given the ability to provide default<br>&gt;&gt;&gt; arguments, which would be used in cases where the type argument is not<br>&gt;&gt;&gt; specified and type inference could not determine the type argument. For<br>&gt;&gt;&gt; example:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; public final class Promise&lt;Value, Reason=Error&gt; { … }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func getRandomPromise() -&gt; Promise&lt;Int, ErrorProtocol&gt; { … }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; var p1: Promise&lt;Int&gt; = …<br>&gt;&gt;&gt; var p2: Promise&lt;Int, Error&gt; = p1     *// okay: p1 and p2 have the same<br>&gt;&gt;&gt; type Promise&lt;Int, Error&gt;*<br>&gt;&gt;&gt; var p3: Promise = getRandomPromise() *// p3 has type **Promise&lt;Int,<br>&gt;&gt;&gt; ErrorProtocol&gt; due to type inference*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *Generalized “class” constraints*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The “class” constraint can currently only be used for defining<br>&gt;&gt;&gt; protocols. We could generalize it to associated type and type parameter<br>&gt;&gt;&gt; declarations, e.g.,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;   associatedtype A : class<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func foo&lt;T : class&gt;(t: T) { }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; As part of this, the magical AnyObject protocol could be replaced with<br>&gt;&gt;&gt; an existential with a class bound, so that it becomes a typealias:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; typealias AnyObject = protocol&lt;class&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; See the “Existentials” section, particularly “Generalized existentials”,<br>&gt;&gt;&gt; for more information.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; **Allowing subclasses to override requirements satisfied by defaults*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; When a superclass conforms to a protocol and has one of the protocol’s<br>&gt;&gt;&gt; requirements satisfied by a member of a protocol extension, that member<br>&gt;&gt;&gt; currently cannot be overridden by a subclass. For example:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;   func foo()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; extension P {<br>&gt;&gt;&gt;   func foo() { print(“P”) }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; class C : P {<br>&gt;&gt;&gt;   // gets the protocol extension’s<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; class D : C {<br>&gt;&gt;&gt;   /*override not allowed!*/ func foo() { print(“D”) }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let p: P = D()<br>&gt;&gt;&gt; p.foo() // gotcha: prints “P” rather than “D”!<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; D.foo should be required to specify “override” and should be called<br>&gt;&gt;&gt; dynamically.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *Major extensions to the generics model*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Unlike the minor extensions, major extensions to the generics model<br>&gt;&gt;&gt; provide more expressivity in the Swift generics system and, generally, have<br>&gt;&gt;&gt; a much more significant design and implementation cost.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; **Conditional conformances*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Conditional conformances express the notion that a generic type will<br>&gt;&gt;&gt; conform to a particular protocol only under certain circumstances. For<br>&gt;&gt;&gt; example, Array is Equatable only when its elements are Equatable:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; extension Array *: Equatable where Element : Equatable* { }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func ==&lt;T : Equatable&gt;(lhs: Array&lt;T&gt;, rhs: Array&lt;T&gt;) -&gt; Bool { … }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Conditional conformances are a potentially very powerful feature. One<br>&gt;&gt;&gt; important aspect of this feature is how deal with or avoid overlapping<br>&gt;&gt;&gt; conformances. For example, imagine an adaptor over a Sequence that has<br>&gt;&gt;&gt; conditional conformances to Collection and MutableCollection:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; struct SequenceAdaptor&lt;S: Sequence&gt; : Sequence { }<br>&gt;&gt;&gt; extension SequenceAdaptor : Collection where S: Collection { … }<br>&gt;&gt;&gt; extension SequenceAdaptor : MutableCollection where S: MutableCollection<br>&gt;&gt;&gt; { }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This should almost certainly be permitted, but we need to cope with or<br>&gt;&gt;&gt; reject “overlapping” conformances:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; extension SequenceAdaptor : Collection where S:<br>&gt;&gt;&gt; SomeOtherProtocolSimilarToCollection { } *// trouble: two ways for<br>&gt;&gt;&gt; SequenceAdaptor to conform to Collection*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; See the section on “Private conformances” for more about the issues with<br>&gt;&gt;&gt; having the same type conform to the same protocol multiple times.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *Variadic generics*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Currently, a generic parameter list contains a fixed number of generic<br>&gt;&gt;&gt; parameters. If one has a type that could generalize to any number of<br>&gt;&gt;&gt; generic parameters, the only real way to deal with it today involves<br>&gt;&gt;&gt; creating a set of types. For example, consider the standard library’s “zip”<br>&gt;&gt;&gt; function. It returns one of these when provided with two arguments to zip<br>&gt;&gt;&gt; together:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; public struct Zip2Sequence&lt;Sequence1 : Sequence,<br>&gt;&gt;&gt;                            Sequence2 : Sequence&gt; : Sequence { … }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; public func zip&lt;Sequence1 : Sequence, Sequence2 : Sequence&gt;(<br>&gt;&gt;&gt;               sequence1: Sequence1, _ sequence2: Sequence2)<br>&gt;&gt;&gt;             -&gt; Zip2Sequence&lt;Sequence1, Sequence2&gt; { … }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Supporting three arguments would require copy-paste of those of those:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; public struct Zip3Sequence&lt;Sequence1 : Sequence,<br>&gt;&gt;&gt;                            Sequence2 : Sequence,<br>&gt;&gt;&gt;                            Sequence3 : Sequence&gt; : Sequence { … }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; public func zip&lt;Sequence1 : Sequence, Sequence2 : Sequence, Sequence3 :<br>&gt;&gt;&gt; Sequence&gt;(<br>&gt;&gt;&gt;               sequence1: Sequence1, _ sequence2: Sequence2, _ sequence3:<br>&gt;&gt;&gt; sequence3)<br>&gt;&gt;&gt;             -&gt; Zip3Sequence&lt;Sequence1, Sequence2, Sequence3&gt; { … }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Variadic generics would allow us to abstract over a set of generic<br>&gt;&gt;&gt; parameters. The syntax below is hopelessly influenced by C++11 variadic<br>&gt;&gt;&gt; templates &lt;http://www.jot.fm/issues/issue_2008_02/article2/&gt; (sorry),<br>&gt;&gt;&gt; where putting an ellipsis (“…”) to the left of a declaration makes it a<br>&gt;&gt;&gt; “parameter pack” containing zero or more parameters and putting an ellipsis<br>&gt;&gt;&gt; to the right of a type/expression/etc. expands the parameter packs within<br>&gt;&gt;&gt; that type/expression into separate arguments. The important part is that we<br>&gt;&gt;&gt; be able to meaningfully abstract over zero or more generic parameters, e.g.:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; public struct ZipIterator&lt;... *Iterators* : IteratorProtocol&gt; :<br>&gt;&gt;&gt; Iterator {  *// zero or more type parameters, each of which conforms to<br>&gt;&gt;&gt; IteratorProtocol*<br>&gt;&gt;&gt;   public typealias Element = (*Iterators.Element...*)<br>&gt;&gt;&gt;     *// a tuple containing the element types of each iterator in<br>&gt;&gt;&gt; Iterators*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   var (*...iterators*): (*Iterators...*)    *// zero or more stored<br>&gt;&gt;&gt; properties, one for each type in Iterators*<br>&gt;&gt;&gt;   var reachedEnd: Bool = false<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   public mutating func next() -&gt; Element? {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     if reachedEnd { return nil }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     guard let values = (*iterators.next()...*) {   *// call “next” on<br>&gt;&gt;&gt; each of the iterators, put the results into a tuple named “values&quot;*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;       reachedEnd = true<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;       return nil<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     return values<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; public struct ZipSequence&lt;*...Sequences* : Sequence&gt; : Sequence {<br>&gt;&gt;&gt;   public typealias Iterator = ZipIterator&lt;*Sequences.Iterator...*&gt;   *//<br>&gt;&gt;&gt; get the zip iterator with the iterator types of our Sequences*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   var (...*sequences*): (*Sequences**...*)    *// zero or more stored<br>&gt;&gt;&gt; properties, one for each type in Sequences*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   *// details ...*<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Such a design could also work for function parameters, so we can pack<br>&gt;&gt;&gt; together multiple function arguments with different types, e.g.,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; public func zip&lt;*... Sequences : SequenceType*&gt;(*... sequences:<br>&gt;&gt;&gt; Sequences...*)<br>&gt;&gt;&gt;             -&gt; ZipSequence&lt;*Sequences...*&gt; {<br>&gt;&gt;&gt;   return ZipSequence(*sequences...*)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Finally, this could tie into the discussions about a tuple “splat”<br>&gt;&gt;&gt; operator. For example:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func apply&lt;... Args, Result&gt;(fn: (Args...) -&gt; Result,    *// function<br>&gt;&gt;&gt; taking some number of arguments and producing Result*<br>&gt;&gt;&gt;                            args: (Args...)) -&gt; Result {  *// tuple of<br>&gt;&gt;&gt; arguments*<br>&gt;&gt;&gt;   return fn(*args...*)                                     // expand<br>&gt;&gt;&gt; the arguments in the tuple “args” into separate arguments<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *Extensions of structural types*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Currently, only nominal types (classes, structs, enums, protocols) can<br>&gt;&gt;&gt; be extended. One could imagine extending structural types—particularly<br>&gt;&gt;&gt; tuple types—to allow them to, e.g., conform to protocols. For example,<br>&gt;&gt;&gt; pulling together variadic generics, parameterized extensions, and<br>&gt;&gt;&gt; conditional conformances, one could express “a tuple type is Equatable if<br>&gt;&gt;&gt; all of its element types are Equatable”:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; extension&lt;...Elements : Equatable&gt; *(Elements...)* : Equatable {   *//<br>&gt;&gt;&gt; extending the tuple type “(Elements…)” to be Equatable*<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; There are some natural bounds here: one would need to have actual<br>&gt;&gt;&gt; structural types. One would not be able to extend every type:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; extension&lt;T&gt; T { *// error: neither a structural nor a nominal type*<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; And before you think you’re cleverly making it possible to have a<br>&gt;&gt;&gt; conditional conformance that makes every type T that conforms to protocol P<br>&gt;&gt;&gt; also conform to protocol Q, see the section &quot;Conditional conformances via<br>&gt;&gt;&gt; protocol extensions”, below:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; extension&lt;T : P&gt; T : Q { *// error: neither a structural nor a nominal<br>&gt;&gt;&gt; type*<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *Syntactic improvements*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; There are a number of potential improvements we could make to the<br>&gt;&gt;&gt; generics syntax. Such a list could go on for a very long time, so I’ll only<br>&gt;&gt;&gt; highlight some obvious ones that have been discussed by the Swift<br>&gt;&gt;&gt; developers.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; **Default implementations in protocols*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Currently, protocol members can never have implementations. We could<br>&gt;&gt;&gt; allow one to provide such implementations to be used as the default if a<br>&gt;&gt;&gt; conforming type does not supply an implementation, e.g.,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol Bag {<br>&gt;&gt;&gt;   associatedtype Element : Equatable<br>&gt;&gt;&gt;   func contains(element: Element) -&gt; Bool<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   func containsAll&lt;S: Sequence where Sequence.Iterator.Element ==<br>&gt;&gt;&gt; Element&gt;(elements: S) -&gt; Bool {<br>&gt;&gt;&gt;     for x in elements {<br>&gt;&gt;&gt;       if contains(x) { return true }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     return false<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; struct IntBag : Bag {<br>&gt;&gt;&gt;   typealias Element = Int<br>&gt;&gt;&gt;   func contains(element: Int) -&gt; Bool { ... }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   // okay: containsAll requirement is satisfied by Bag’s default<br>&gt;&gt;&gt; implementation<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; One can get this effect with protocol extensions today, hence the<br>&gt;&gt;&gt; classification of this feature as a (mostly) syntactic improvement:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol Bag {<br>&gt;&gt;&gt;   associatedtype Element : Equatable<br>&gt;&gt;&gt;   func contains(element: Element) -&gt; Bool<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   func containsAll&lt;S: Sequence where Sequence.Iterator.Element ==<br>&gt;&gt;&gt; Element&gt;(elements: S) -&gt; Bool<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; extension Bag {<br>&gt;&gt;&gt;   func containsAll&lt;S: Sequence where Sequence.Iterator.Element ==<br>&gt;&gt;&gt; Element&gt;(elements: S) -&gt; Bool {<br>&gt;&gt;&gt;     for x in elements {<br>&gt;&gt;&gt;       if contains(x) { return true }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     return false<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; **Moving the where clause outside of the angle brackets*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The “where” clause of generic functions comes very early in the<br>&gt;&gt;&gt; declaration, although it is generally of much less concern to the client<br>&gt;&gt;&gt; than the function parameters and result type that follow it. This is one of<br>&gt;&gt;&gt; the things that contributes to “angle bracket blindness”. For example,<br>&gt;&gt;&gt; consider the containsAll signature above:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func containsAll&lt;S: Sequence where Sequence.Iterator.Element ==<br>&gt;&gt;&gt; Element&gt;(elements: S) -&gt; Bool<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; One could move the “where” clause to the end of the signature, so that<br>&gt;&gt;&gt; the most important parts—name, generic parameter, parameters, result<br>&gt;&gt;&gt; type—precede it:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func containsAll&lt;S: Sequence&gt;(elements: S) -&gt; Bool<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;        where Sequence.Iterator.Element == Element<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; **Renaming “protocol&lt;…&gt;” to “Any&lt;…&gt;”.*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The “protocol&lt;…&gt;” syntax is a bit of an oddity in Swift. It is used to<br>&gt;&gt;&gt; compose protocols together, mostly to create values of existential type,<br>&gt;&gt;&gt; e.g.,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; var x: protocol&lt;NSCoding, NSCopying&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It’s weird that it’s a type name that starts with a lowercase letter,<br>&gt;&gt;&gt; and most Swift developers probably never deal with this feature unless they<br>&gt;&gt;&gt; happen to look at the definition of Any:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; typealias Any = protocol&lt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; “Any” might be a better name for this functionality. “Any” without<br>&gt;&gt;&gt; brackets could be a keyword for “any type”, and “Any” followed by brackets<br>&gt;&gt;&gt; could take the role of “protocol&lt;&gt;” today:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; var x: Any&lt;NSCoding, NSCopying&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; That reads much better: “Any type that conforms to NSCoding and<br>&gt;&gt;&gt; NSCopying”. See the section &quot;Generalized existentials” for additional<br>&gt;&gt;&gt; features in this space.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *Maybe*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; There are a number of features that get discussed from time-to-time,<br>&gt;&gt;&gt; while they could fit into Swift’s generics system, it’s not clear that they<br>&gt;&gt;&gt; belong in Swift at all. The important question for any feature in this<br>&gt;&gt;&gt; category is not “can it be done” or “are there cool things we can express”,<br>&gt;&gt;&gt; but “how can everyday Swift developers benefit from the addition of such a<br>&gt;&gt;&gt; feature?”. Without strong motivating examples, none of these “maybes” will<br>&gt;&gt;&gt; move further along.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *Dynamic dispatch for members of protocol extensions*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Only the requirements of protocols currently use dynamic dispatch, which<br>&gt;&gt;&gt; can lead to surprises:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;   func foo()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; extension P {<br>&gt;&gt;&gt;   func foo() { print(“P.foo()”)<br>&gt;&gt;&gt;   func bar() { print(“P.bar()”)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; struct X : P {<br>&gt;&gt;&gt;   func foo() { print(“X.foo()”)<br>&gt;&gt;&gt;   func bar() { print(“X.bar()”)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let x = X()<br>&gt;&gt;&gt; x.foo() // X.foo()<br>&gt;&gt;&gt; x.bar() // X.bar()<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let p: P = X()<br>&gt;&gt;&gt; p.foo() // X.foo()<br>&gt;&gt;&gt; p.bar() // P.bar()<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Swift could adopt a model where members of protocol extensions are<br>&gt;&gt;&gt; dynamically dispatched.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *Named generic parameters*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; When specifying generic arguments for a generic type, the arguments are<br>&gt;&gt;&gt; always positional: Dictionary&lt;String, Int&gt; is a Dictionary whose Key type<br>&gt;&gt;&gt; is String and whose Value type is Int, by convention. One could permit the<br>&gt;&gt;&gt; arguments to be labeled, e.g.,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; var d: Dictionary&lt;*Key:* String, *Value:* Int&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Such a feature makes more sense if Swift gains default generic<br>&gt;&gt;&gt; arguments, because generic argument labels would allow one to skip<br>&gt;&gt;&gt; defaulted arguments.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *Generic value parameters*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Currently, Swift’s generic parameters are always types. One could<br>&gt;&gt;&gt; imagine allowing generic parameters that are values, e.g.,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; struct MultiArray&lt;T,* let Dimensions: Int*&gt; { *// specify the number of<br>&gt;&gt;&gt; dimensions to the array*<br>&gt;&gt;&gt;   subscript (indices: Int...) -&gt; T {<br>&gt;&gt;&gt;     get {<br>&gt;&gt;&gt;       require(indices.count == *Dimensions*)<br>&gt;&gt;&gt;       // ...<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; A suitably general feature might allow us to express fixed-length array<br>&gt;&gt;&gt; or vector types as a standard library component, and perhaps also allow one<br>&gt;&gt;&gt; to implement a useful dimensional analysis library. Tackling this feature<br>&gt;&gt;&gt; potentially means determining what it is for an expression to be a<br>&gt;&gt;&gt; “constant expression” and diving into dependent-typing, hence the “maybe”.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *Higher-kinded types*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Higher-kinded types allow one to express the relationship between two<br>&gt;&gt;&gt; different specializations of the same nominal type within a protocol. For<br>&gt;&gt;&gt; example, if we think of the Self type in a protocol as really being<br>&gt;&gt;&gt; “Self&lt;T&gt;”, it allows us to talk about the relationship between “Self&lt;T&gt;”<br>&gt;&gt;&gt; and “Self&lt;U&gt;” for some other type U. For example, it could allow the “map”<br>&gt;&gt;&gt; operation on a collection to return a collection of the same kind but with<br>&gt;&gt;&gt; a different operation, e.g.,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let intArray: Array&lt;Int&gt; = …<br>&gt;&gt;&gt; intArray.map { String($0) } *// produces Array&lt;String&gt;*<br>&gt;&gt;&gt; let intSet: Set&lt;Int&gt; = …<br>&gt;&gt;&gt; intSet.map { String($0) }   *// produces Set&lt;String&gt;*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Potential syntax borrowed from one thread on higher-kinded types<br>&gt;&gt;&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002736.html&gt; uses<br>&gt;&gt;&gt; ~= as a “similarity” constraint to describe a Functor protocol:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol Functor {<br>&gt;&gt;&gt;   associatedtype A<br>&gt;&gt;&gt;   func fmap&lt;FB where *FB ~= Self*&gt;(f: A -&gt; FB.A) -&gt; FB<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *Specifying type arguments for uses of generic functions*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The type arguments of a generic function are always determined via type<br>&gt;&gt;&gt; inference. For example, given:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func f&lt;T&gt;(t: T)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; one cannot directly specify T: either one calls “f” (and T is determined<br>&gt;&gt;&gt; via the argument’s type) or one uses “f” in a context where it is given a<br>&gt;&gt;&gt; particular function type (e.g., “let x: (Int) -&gt; Void = f”  would infer T =<br>&gt;&gt;&gt; Int). We could permit explicit specialization here, e.g.,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let x = f&lt;Int&gt; // x has type (Int) -&gt; Void<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *Unlikely*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Features in this category have been requested at various times, but they<br>&gt;&gt;&gt; don’t fit well with Swift’s generics system because they cause some part of<br>&gt;&gt;&gt; the model to become overly complicated, have unacceptable implementation<br>&gt;&gt;&gt; limitations, or overlap significantly with existing features.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *Generic protocols*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; One of the most commonly requested features is the ability to<br>&gt;&gt;&gt; parameterize protocols themselves. For example, a protocol that indicates<br>&gt;&gt;&gt; that the Self type can be constructed from some specified type T:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol ConstructibleFromValue*&lt;T&gt;* {<br>&gt;&gt;&gt;   init(_ value: T)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Implicit in this feature is the ability for a given type to conform to<br>&gt;&gt;&gt; the protocol in two different ways. A “Real” type might be constructible<br>&gt;&gt;&gt; from both Float and Double, e.g.,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; struct Real { … }<br>&gt;&gt;&gt; extension Real : ConstructibleFrom&lt;Float&gt; {<br>&gt;&gt;&gt;   init(_ value: Float) { … }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; extension Real : ConstructibleFrom&lt;Double&gt; {<br>&gt;&gt;&gt;   init(_ value: Double) { … }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Most of the requests for this feature actually want a different feature.<br>&gt;&gt;&gt; They tend to use a parameterized Sequence as an example, e.g.,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol Sequence&lt;Element&gt; { … }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func foo(strings: Sequence&lt;String&gt;) {  /// works on any sequence<br>&gt;&gt;&gt; containing Strings<br>&gt;&gt;&gt;   // ...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The actual requested feature here  is the ability to say “Any type that<br>&gt;&gt;&gt; conforms to Sequence whose Element type is String”, which is covered by the<br>&gt;&gt;&gt; section on “Generalized existentials”, below.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; More importantly, modeling Sequence with generic parameters rather than<br>&gt;&gt;&gt; associated types is tantalizing but wrong: you don’t want a type conforming<br>&gt;&gt;&gt; to Sequence in multiple ways, or (among other things) your for..in loops<br>&gt;&gt;&gt; stop working, and you lose the ability to dynamically cast down to an<br>&gt;&gt;&gt; existential “Sequence” without binding the Element type (again, see<br>&gt;&gt;&gt; “Generalized existentials”). Use cases similar to the<br>&gt;&gt;&gt; ConstructibleFromValue protocol above seem too few to justify the potential<br>&gt;&gt;&gt; for confusion between associated types and generic parameters of protocols;<br>&gt;&gt;&gt; we’re better off not having the latter.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *Private conformances *<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Right now, a protocol conformance can be no less visible than the<br>&gt;&gt;&gt; minimum of the conforming type’s access and the protocol’s access.<br>&gt;&gt;&gt; Therefore, a public type conforming to a public protocol must provide the<br>&gt;&gt;&gt; conformance publicly. One could imagine removing that restriction, so that<br>&gt;&gt;&gt; one could introduce a private conformance:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; public protocol P { }<br>&gt;&gt;&gt; public struct X { }<br>&gt;&gt;&gt; extension X : *internal P* { … } // X conforms to P, but only within<br>&gt;&gt;&gt; this module<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The main problem with private conformances is the interaction with<br>&gt;&gt;&gt; dynamic casting. If I have this code:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func foo(value: Any) {<br>&gt;&gt;&gt;   if let x = value as? P { print(“P”) }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; foo(X())<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Under what circumstances should it print “P”? If foo() is defined within<br>&gt;&gt;&gt; the same module as the conformance of X to P? If the call is defined within<br>&gt;&gt;&gt; the same module as the conformance of X to P? Never? Either of the first<br>&gt;&gt;&gt; two answers requires significant complications in the dynamic casting<br>&gt;&gt;&gt; infrastructure to take into account the module in which a particular<br>&gt;&gt;&gt; dynamic cast occurred (the first option) or where an existential was formed<br>&gt;&gt;&gt; (the second option), while the third answer breaks the link between the<br>&gt;&gt;&gt; static and dynamic type systems—none of which is an acceptable result.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *Conditional conformances via protocol extensions*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; We often get requests to make a protocol conform to another protocol.<br>&gt;&gt;&gt; This is, effectively, the expansion of the notion of “Conditional<br>&gt;&gt;&gt; conformances” to protocol extensions. For example:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;   func foo()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol Q {<br>&gt;&gt;&gt;   func bar()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; extension *Q : P* { *// every type that conforms to Q also conforms to<br>&gt;&gt;&gt; P*<br>&gt;&gt;&gt;   func foo() {    *// implement “foo” requirement in terms of “bar&quot;*<br>&gt;&gt;&gt;     bar()<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func f&lt;T: P&gt;(t: T) { … }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; struct X : Q {<br>&gt;&gt;&gt;   func bar() { … }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; f(X()) // okay: X conforms to P through the conformance of Q to P<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This is an extremely powerful feature: is allows one to map the<br>&gt;&gt;&gt; abstractions of one domain into another domain (e.g., every Matrix is a<br>&gt;&gt;&gt; Graph). However, similar to private conformances, it puts a major burden on<br>&gt;&gt;&gt; the dynamic-casting runtime to chase down arbitrarily long and potentially<br>&gt;&gt;&gt; cyclic chains of conformances, which makes efficient implementation nearly<br>&gt;&gt;&gt; impossible.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *Potential removals*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The generics system doesn’t seem like a good candidate for a reduction<br>&gt;&gt;&gt; in scope; most of its features do get used fairly pervasively in the<br>&gt;&gt;&gt; standard library, and few feel overly anachronistic. However...<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *Associated type inference*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Associated type inference is the process by which we infer the type<br>&gt;&gt;&gt; bindings for associated types from other requirements. For example:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol IteratorProtocol {<br>&gt;&gt;&gt;   associatedtype Element<br>&gt;&gt;&gt;   mutating func next() -&gt; Element?<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; struct IntIterator : IteratorProtocol {<br>&gt;&gt;&gt;   mutating func next() -&gt; Int? { … }  // use this to infer Element = Int<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Associated type inference is a useful feature. It’s used throughout the<br>&gt;&gt;&gt; standard library, and it helps keep associated types less visible to types<br>&gt;&gt;&gt; that simply want to conform to a protocol. On the other hand, associated<br>&gt;&gt;&gt; type inference is the only place in Swift where we have a *global* type<br>&gt;&gt;&gt; inference problem: it has historically been a major source of bugs, and<br>&gt;&gt;&gt; implementing it fully and correctly requires a drastically different<br>&gt;&gt;&gt; architecture to the type checker. Is the value of this feature worth<br>&gt;&gt;&gt; keeping global type inference in the Swift language, when we have<br>&gt;&gt;&gt; deliberatively avoided global type inference elsewhere in the language?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *Existentials*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Existentials aren’t really generics per se, but the two systems are<br>&gt;&gt;&gt; closely intertwined due to their mutable dependence on protocols.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; **Generalized existentials*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The restrictions on existential types came from an implementation<br>&gt;&gt;&gt; limitation, but it is reasonable to allow a value of protocol type even<br>&gt;&gt;&gt; when the protocol has Self constraints or associated types. For example,<br>&gt;&gt;&gt; consider IteratorProtocol again and how it could be used as an existential:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol IteratorProtocol {<br>&gt;&gt;&gt;   associatedtype Element<br>&gt;&gt;&gt;   mutating func next() -&gt; Element?<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let it: IteratorProtocol = …<br>&gt;&gt;&gt; it.next()   // if this is permitted, it could return an “Any?”, i.e.,<br>&gt;&gt;&gt; the existential that wraps the actual element<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Additionally, it is reasonable to want to constrain the associated types<br>&gt;&gt;&gt; of an existential, e.g., “a Sequence whose element type is String” could be<br>&gt;&gt;&gt; expressed by putting a where clause into “protocol&lt;…&gt;” or “Any&lt;…&gt;” (per<br>&gt;&gt;&gt; “Renaming protocol&lt;…&gt; to Any&lt;…&gt;”):<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let strings: Any&lt;Sequence* where .Iterator.Element == String*&gt; = [“a”,<br>&gt;&gt;&gt; “b”, “c”]<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The leading “.” indicates that we’re talking about the dynamic type,<br>&gt;&gt;&gt; i.e., the “Self” type that’s conforming to the Sequence protocol. There’s<br>&gt;&gt;&gt; no reason why we cannot support arbitrary “where” clauses within the<br>&gt;&gt;&gt; “Any&lt;…&gt;”. This very-general syntax is a bit unwieldy, but common cases can<br>&gt;&gt;&gt; easily be wrapped up in a generic typealias (see the section “Generic<br>&gt;&gt;&gt; typealiases” above):<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; typealias AnySequence&lt;Element&gt; = *Any&lt;Sequence where .Iterator.Element<br>&gt;&gt;&gt; == Element&gt;*<br>&gt;&gt;&gt; let strings: AnySequence&lt;String&gt; = [“a”, “b”, “c”]<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *Opening existentials*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Generalized existentials as described above will still have trouble with<br>&gt;&gt;&gt; protocol requirements that involve Self or associated types in function<br>&gt;&gt;&gt; parameters. For example, let’s try to use Equatable as an existential:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol Equatable {<br>&gt;&gt;&gt;   func ==(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;&gt;   func !=(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let e1: Equatable = …<br>&gt;&gt;&gt; let e2: Equatable = …<br>&gt;&gt;&gt; if e1 == e2 { … } *// error:* e1 and e2 don’t necessarily have the same<br>&gt;&gt;&gt; dynamic type<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; One explicit way to allow such operations in a type-safe manner is to<br>&gt;&gt;&gt; introduce an “open existential” operation of some sort, which extracts and<br>&gt;&gt;&gt; gives a name to the dynamic type stored inside an existential. For example:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; if let storedInE1 = e1 openas T {     // T is a the type of storedInE1,<br>&gt;&gt;&gt; a copy of the value stored in e1<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   if let storedInE2 = e2 as? T {      // is e2 also a T?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     if storedInE1 == storedInE2 { … } // okay: storedInT1 and storedInE2<br>&gt;&gt;&gt; are both of type T, which we know is Equatable<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - Doug<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160310/37089342/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Manifesto] Completing Generics</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>March  7, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Mar 7, 2016, at 4:18 PM, Howard Lovatt &lt;howard.lovatt at gmail.com&gt; wrote:<br>&gt; <br>&gt; I have seen a couple of areas where generics seem lacking to me:<br>&gt; <br>&gt;   1. Declaring associated types with where clauses<br>&gt;   2. Declaring generic arguments for calculated properties<br>&gt;   3. Similar to above, declaring generic properties for subscripts<br></p><p>#1 and #3 were on the list I posted, and #2 looks like it might by handled by generic constants.<br></p><p>	- Doug<br></p><p><br>&gt; <br>&gt; Examples of 1 and 2:<br>&gt; <br>&gt; protocol IterableCollection {<br>&gt;     associated type Element<br>&gt; <br>&gt;     /// ...<br>&gt; <br>&gt;     /// Would prefer:<br>&gt;     ///   `var lazy&lt;L: LazyNextableCollection where L.Element == Element&gt;: L { get }` // Point 2 above<br>&gt;     /// Or:<br>&gt;     ///   `associatedtype L: LazyNextableCollection where L.Element == Element` // Point 1 above<br>&gt;     ///   `var lazy: L { get }`<br>&gt;     /// But nearest possible is a function :(.<br>&gt;     func lazy&lt;L: LazyNextableCollection where L.Element == Element&gt;() -&gt; L // Best I seem to be able to do<br>&gt; }<br>&gt; <br>&gt; Example of 3:<br>&gt; <br>&gt; protocol SubstriptableCollection {<br>&gt;     associatedtype Index: Rangeable<br>&gt;     associatedtype Element<br>&gt; <br>&gt;     /// ...<br>&gt; <br>&gt;     /// Ideally would write:<br>&gt;     ///   `subscript&lt;S: SubstriptableCollection, R: SubstriptableCollection where S.Element == Element, R.Element == Index&gt;(range: R) -&gt; S { get set }` // Point 3 above<br>&gt;     /// However nearest in Swift is seperate get and set methods :(.<br>&gt;     func getSubscript&lt;S: SubstriptableCollection, R: SubstriptableCollection where S.Element == Element, R.Element == Index&gt;(range: R) -&gt; S<br>&gt; }<br>&gt; <br>&gt; <br>&gt;   -- Howard.<br>&gt; <br>&gt; On 3 March 2016 at 19:34, Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Nested generic types are definitely a big +1 from me. In particular if I can use them to fulfil associated type requirements, for example:<br>&gt; <br>&gt; 	protocol FooType {<br>&gt; 		typealias Element<br>&gt; 		typealias Index<br>&gt; 	}<br>&gt; <br>&gt; 	struct Foo&lt;E&gt; : FooType {<br>&gt; 		typealias Element = E<br>&gt; 		struct Index { … }<br>&gt; 	}<br>&gt; <br>&gt; The other thing I’d like to see for generics isn’t really a new feature, but I’d like to be able to define protocol generics in the same format as for types, i.e- I could rewrite the above protocol as:<br>&gt; <br>&gt; 	protocol FooType&lt;Element, Index&gt; {}<br>&gt; <br>&gt; Likewise when placing constraints on methods etc.:<br>&gt; <br>&gt; 	func myMethod(someFoo:FooType&lt;String, Int&gt;) { … }<br>&gt; <br>&gt; Even if behind the scenes these are still unwrapped into associated types and where clauses, it’s just much, much easier to work with in the majority of cases (where clauses would still exist for the more complex ones).<br>&gt; <br>&gt; The other capabilities you’ve described all seem very useful, but it’s probably going to take a day or two to get my head around all of them!<br>&gt; <br>&gt;&gt; On 3 Mar 2016, at 01:22, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; The “Complete Generics” goal for Swift 3 has been fairly ill-defined thus fair, with just this short blurb in the list of goals:<br>&gt;&gt; <br>&gt;&gt; Complete generics: Generics are used pervasively in a number of Swift libraries, especially the standard library. However, there are a number of generics features the standard library requires to fully realize its vision, including recursive protocol constraints, the ability to make a constrained extension conform to a new protocol (i.e., an array of Equatable elements is Equatable), and so on. Swift 3.0 should provide those generics features needed by the standard library, because they affect the standard library&#39;s ABI.<br>&gt;&gt; This message expands upon the notion of “completing generics”. It is not a plan for Swift 3, nor an official core team communication, but it collects the results of numerous discussions among the core team and Swift developers, both of the compiler and the standard library. I hope to achieve several things:<br>&gt;&gt; <br>&gt;&gt; Communicate a vision for Swift generics, building on the original generics design document &lt;https://github.com/apple/swift/blob/master/docs/Generics.rst&gt;, so we have something concrete and comprehensive to discuss.<br>&gt;&gt; Establish some terminology that the Swift developers have been using for these features, so our discussions can be more productive (“oh, you’re proposing what we refer to as ‘conditional conformances’; go look over at this thread”).<br>&gt;&gt; Engage more of the community in discussions of specific generics features, so we can coalesce around designs for public review. And maybe even get some of them implemented.<br>&gt;&gt; <br>&gt;&gt; A message like this can easily turn into a centithread &lt;http://www.urbandictionary.com/define.php?term=centithread&gt;. To separate concerns in our discussion, I ask that replies to this specific thread be limited to discussions of the vision as a whole: how the pieces fit together, what pieces are missing, whether this is the right long-term vision for Swift, and so on. For discussions of specific language features, e.g., to work out the syntax and semantics of conditional conformances or discuss the implementation in compiler or use in the standard library, please start a new thread based on the feature names I’m using.<br>&gt;&gt; <br>&gt;&gt; This message covers a lot of ground; I’ve attempted a rough categorization of the various features, and kept the descriptions brief to limit the overall length. Most of these aren’t my ideas, and any syntax I’m providing is simply a way to express these ideas in code and is subject to change. Not all of these features will happen, either soon or ever, but they are intended to be a fairly complete whole that should mesh together. I’ve put a * next to features that I think are important in the nearer term vs. being interesting “some day”. Mostly, the *’s reflect features that will have a significant impact on the Swift standard library’s design and implementation.<br>&gt;&gt; <br>&gt;&gt; Enough with the disclaimers; it’s time to talk features.<br>&gt;&gt; <br>&gt;&gt; Removing unnecessary restrictions<br>&gt;&gt; <br>&gt;&gt; There are a number of restrictions to the use of generics that fall out of the implementation in the Swift compiler. Removal of these restrictions is a matter of implementation only; one need not introduce new syntax or semantics to realize them. I’m listing them for two reasons: first, it’s an acknowledgment that these features are intended to exist in the model we have today, and, second, we’d love help with the implementation of these features.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; *Recursive protocol constraints<br>&gt;&gt; <br>&gt;&gt; Currently, an associated type cannot be required to conform to its enclosing protocol (or any protocol that inherits that protocol). For example, in the standard library SubSequence type of a Sequence should itself be a Sequence:<br>&gt;&gt; <br>&gt;&gt; protocol Sequence {<br>&gt;&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;&gt;   …<br>&gt;&gt;   associatedtype SubSequence : Sequence   // currently ill-formed, but should be possible<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The compiler currently rejects this protocol, which is unfortunate: it effectively pushes the SubSequence-must-be-a-Sequence requirement into every consumer of SubSequence, and does not communicate the intent of this abstraction well.<br>&gt;&gt; <br>&gt;&gt; Nested generics<br>&gt;&gt; <br>&gt;&gt; Currently, a generic type cannot be nested within another generic type, e.g.<br>&gt;&gt; <br>&gt;&gt; struct X&lt;T&gt; {<br>&gt;&gt;   struct Y&lt;U&gt; { }  // currently ill-formed, but should be possible<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; There isn’t much to say about this: the compiler simply needs to be improved to handle nested generics throughout.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Concrete same-type requirements<br>&gt;&gt; <br>&gt;&gt; Currently, a constrained extension cannot use a same-type constraint to make a type parameter equivalent to a concrete type. For example:<br>&gt;&gt; <br>&gt;&gt; extension Array where Element == String {<br>&gt;&gt;   func makeSentence() -&gt; String {<br>&gt;&gt;     // uppercase first string, concatenate with spaces, add a period, whatever<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This is a highly-requested feature that fits into the existing syntax and semantics. Note that one could imagine introducing new syntax, e.g., extending “Array&lt;String&gt;”, which gets into new-feature territory: see the section on “Parameterized extensions”.<br>&gt;&gt; <br>&gt;&gt; Parameterizing other declarations<br>&gt;&gt; <br>&gt;&gt; There are a number of Swift declarations that currently cannot have generic parameters; some of those have fairly natural extensions to generic forms that maintain their current syntax and semantics, but become more powerful when made generic.<br>&gt;&gt; <br>&gt;&gt; Generic typealiases<br>&gt;&gt; <br>&gt;&gt; Typealiases could be allowed to carry generic parameters. They would still be aliases (i.e., they would not introduce new types). For example:<br>&gt;&gt; <br>&gt;&gt; typealias StringDictionary&lt;Value&gt; = Dictionary&lt;String, Value&gt;<br>&gt;&gt; <br>&gt;&gt; var d1 = StringDictionary&lt;Int&gt;()<br>&gt;&gt; var d2: Dictionary&lt;String, Int&gt; = d1 // okay: d1 and d2 have the same type, Dictionary&lt;String, Int&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Generic subscripts<br>&gt;&gt; <br>&gt;&gt; Subscripts could be allowed to have generic parameters. For example, we could introduce a generic subscript on a Collection that allows us to pull out the values at an arbitrary set of indices:<br>&gt;&gt; <br>&gt;&gt; extension Collection {<br>&gt;&gt;   subscript&lt;Indices: Sequence where Indices.Iterator.Element == Index&gt;(indices: Indices) -&gt; [Iterator.Element] {<br>&gt;&gt;     get {<br>&gt;&gt;       var result = [Iterator.Element]()<br>&gt;&gt;       for index in indices {<br>&gt;&gt;         result.append(self[index])<br>&gt;&gt;       }<br>&gt;&gt; <br>&gt;&gt;       return result<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     set {<br>&gt;&gt;       for (index, value) in zip(indices, newValue) {<br>&gt;&gt;         self[index] = value<br>&gt;&gt;       }<br>&gt;&gt;     }<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Generic constants<br>&gt;&gt; <br>&gt;&gt; let constants could be allowed to have generic parameters, such that they produce differently-typed values depending on how they are used. For example, this is particularly useful for named literal values, e.g.,<br>&gt;&gt; <br>&gt;&gt; let π&lt;T : FloatLiteralConvertible&gt;: T = 3.141592653589793238462643383279502884197169399<br>&gt;&gt; <br>&gt;&gt; The Clang importer could make particularly good use of this when importing macros.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Parameterized extensions<br>&gt;&gt; <br>&gt;&gt; Extensions themselves could be parameterized, which would allow some structural pattern matching on types. For example, this would permit one to extend an array of optional values, e.g.,<br>&gt;&gt; <br>&gt;&gt; extension&lt;T&gt; Array where Element == T? {<br>&gt;&gt;   var someValues: [T] {<br>&gt;&gt;     var result = [T]()<br>&gt;&gt;     for opt in self {<br>&gt;&gt;       if let value = opt { result.append(value) }<br>&gt;&gt;     }<br>&gt;&gt;    return result<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; We can generalize this to a protocol extensions:<br>&gt;&gt; <br>&gt;&gt; extension&lt;T&gt; Sequence where Element == T? {<br>&gt;&gt;   var someValues: [T] {<br>&gt;&gt;     var result = [T]()<br>&gt;&gt;     for opt in self {<br>&gt;&gt;       if let value = opt { result.append(value) }<br>&gt;&gt;     }<br>&gt;&gt;    return result<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Note that when one is extending nominal types, we could simplify the syntax somewhat to make the same-type constraint implicit in the syntax:<br>&gt;&gt; <br>&gt;&gt; extension&lt;T&gt; Array&lt;T?&gt; {<br>&gt;&gt;   var someValues: [T] {<br>&gt;&gt;     var result = [T]()<br>&gt;&gt;     for opt in self {<br>&gt;&gt;       if let value = opt { result.append(value) }<br>&gt;&gt;     }<br>&gt;&gt;    return result<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; When we’re working with concrete types, we can use that syntax to improve the extension of concrete versions of generic types (per “Concrete same-type requirements”, above), e.g.,<br>&gt;&gt; <br>&gt;&gt; extension Array&lt;String&gt; {<br>&gt;&gt;   func makeSentence() -&gt; String {<br>&gt;&gt;     // uppercase first string, concatenate with spaces, add a period, whatever<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Minor extensions<br>&gt;&gt; <br>&gt;&gt; There are a number of minor extensions we can make to the generics system that don’t fundamentally change what one can express in Swift, but which can improve its expressivity.<br>&gt;&gt; <br>&gt;&gt; *Arbitrary requirements in protocols<br>&gt;&gt; <br>&gt;&gt; Currently, a new protocol can inherit from other protocols, introduce new associated types, and add new conformance constraints to associated types (by redeclaring an associated type from an inherited protocol). However, one cannot express more general constraints. Building on the example from “Recursive protocol constraints”, we really want the element type of a Sequence’s SubSequence to be the same as the element type of the Sequence, e.g.,<br>&gt;&gt; <br>&gt;&gt; protocol Sequence {<br>&gt;&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;&gt;   …<br>&gt;&gt;   associatedtype SubSequence : Sequence where SubSequence.Iterator.Element == Iterator.Element<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Hanging the where clause off the associated type is protocol not ideal, but that’s a discussion for another thread.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; *Typealiases in protocols and protocol extensions<br>&gt;&gt; <br>&gt;&gt; Now that associated types have their own keyword (thanks!), it’s reasonable to bring back “typealias”. Again with the Sequence protocol:<br>&gt;&gt; <br>&gt;&gt; protocol Sequence {<br>&gt;&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;&gt;   typealias Element = Iterator.Element   // rejoice! now we can refer to SomeSequence.Element rather than SomeSequence.Iterator.Element<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Default generic arguments <br>&gt;&gt; <br>&gt;&gt; Generic parameters could be given the ability to provide default arguments, which would be used in cases where the type argument is not specified and type inference could not determine the type argument. For example:<br>&gt;&gt; <br>&gt;&gt; public final class Promise&lt;Value, Reason=Error&gt; { … }<br>&gt;&gt; <br>&gt;&gt; func getRandomPromise() -&gt; Promise&lt;Int, ErrorProtocol&gt; { … }<br>&gt;&gt; <br>&gt;&gt; var p1: Promise&lt;Int&gt; = …<br>&gt;&gt; var p2: Promise&lt;Int, Error&gt; = p1     // okay: p1 and p2 have the same type Promise&lt;Int, Error&gt;<br>&gt;&gt; var p3: Promise = getRandomPromise() // p3 has type Promise&lt;Int, ErrorProtocol&gt; due to type inference<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Generalized “class” constraints<br>&gt;&gt; <br>&gt;&gt; The “class” constraint can currently only be used for defining protocols. We could generalize it to associated type and type parameter declarations, e.g.,<br>&gt;&gt; <br>&gt;&gt; protocol P {<br>&gt;&gt;   associatedtype A : class<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func foo&lt;T : class&gt;(t: T) { }<br>&gt;&gt; <br>&gt;&gt; As part of this, the magical AnyObject protocol could be replaced with an existential with a class bound, so that it becomes a typealias:<br>&gt;&gt; <br>&gt;&gt; typealias AnyObject = protocol&lt;class&gt;<br>&gt;&gt; <br>&gt;&gt; See the “Existentials” section, particularly “Generalized existentials”, for more information.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; *Allowing subclasses to override requirements satisfied by defaults<br>&gt;&gt; <br>&gt;&gt; When a superclass conforms to a protocol and has one of the protocol’s requirements satisfied by a member of a protocol extension, that member currently cannot be overridden by a subclass. For example:<br>&gt;&gt; <br>&gt;&gt; protocol P {<br>&gt;&gt;   func foo()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension P {<br>&gt;&gt;   func foo() { print(“P”) }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class C : P {<br>&gt;&gt;   // gets the protocol extension’s <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class D : C {<br>&gt;&gt;   /*override not allowed!*/ func foo() { print(“D”) }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let p: P = D()<br>&gt;&gt; p.foo() // gotcha: prints “P” rather than “D”!<br>&gt;&gt; <br>&gt;&gt; D.foo should be required to specify “override” and should be called dynamically.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Major extensions to the generics model<br>&gt;&gt; <br>&gt;&gt; Unlike the minor extensions, major extensions to the generics model provide more expressivity in the Swift generics system and, generally, have a much more significant design and implementation cost.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; *Conditional conformances<br>&gt;&gt; <br>&gt;&gt; Conditional conformances express the notion that a generic type will conform to a particular protocol only under certain circumstances. For example, Array is Equatable only when its elements are Equatable:<br>&gt;&gt; <br>&gt;&gt; extension Array : Equatable where Element : Equatable { }<br>&gt;&gt; <br>&gt;&gt; func ==&lt;T : Equatable&gt;(lhs: Array&lt;T&gt;, rhs: Array&lt;T&gt;) -&gt; Bool { … }<br>&gt;&gt; <br>&gt;&gt; Conditional conformances are a potentially very powerful feature. One important aspect of this feature is how deal with or avoid overlapping conformances. For example, imagine an adaptor over a Sequence that has conditional conformances to Collection and MutableCollection:<br>&gt;&gt; <br>&gt;&gt; struct SequenceAdaptor&lt;S: Sequence&gt; : Sequence { }<br>&gt;&gt; extension SequenceAdaptor : Collection where S: Collection { … }<br>&gt;&gt; extension SequenceAdaptor : MutableCollection where S: MutableCollection { }<br>&gt;&gt; <br>&gt;&gt; This should almost certainly be permitted, but we need to cope with or reject “overlapping” conformances:<br>&gt;&gt; <br>&gt;&gt; extension SequenceAdaptor : Collection where S: SomeOtherProtocolSimilarToCollection { } // trouble: two ways for SequenceAdaptor to conform to Collection<br>&gt;&gt; <br>&gt;&gt; See the section on “Private conformances” for more about the issues with having the same type conform to the same protocol multiple times.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Variadic generics<br>&gt;&gt; <br>&gt;&gt; Currently, a generic parameter list contains a fixed number of generic parameters. If one has a type that could generalize to any number of generic parameters, the only real way to deal with it today involves creating a set of types. For example, consider the standard library’s “zip” function. It returns one of these when provided with two arguments to zip together:<br>&gt;&gt; <br>&gt;&gt; public struct Zip2Sequence&lt;Sequence1 : Sequence,<br>&gt;&gt;                            Sequence2 : Sequence&gt; : Sequence { … }<br>&gt;&gt; <br>&gt;&gt; public func zip&lt;Sequence1 : Sequence, Sequence2 : Sequence&gt;(<br>&gt;&gt;               sequence1: Sequence1, _ sequence2: Sequence2)<br>&gt;&gt;             -&gt; Zip2Sequence&lt;Sequence1, Sequence2&gt; { … }<br>&gt;&gt; <br>&gt;&gt; Supporting three arguments would require copy-paste of those of those:<br>&gt;&gt; <br>&gt;&gt; public struct Zip3Sequence&lt;Sequence1 : Sequence,<br>&gt;&gt;                            Sequence2 : Sequence,<br>&gt;&gt;                            Sequence3 : Sequence&gt; : Sequence { … }<br>&gt;&gt; <br>&gt;&gt; public func zip&lt;Sequence1 : Sequence, Sequence2 : Sequence, Sequence3 : Sequence&gt;(<br>&gt;&gt;               sequence1: Sequence1, _ sequence2: Sequence2, _ sequence3: sequence3)<br>&gt;&gt;             -&gt; Zip3Sequence&lt;Sequence1, Sequence2, Sequence3&gt; { … }<br>&gt;&gt; <br>&gt;&gt; Variadic generics would allow us to abstract over a set of generic parameters. The syntax below is hopelessly influenced by C++11 variadic templates &lt;http://www.jot.fm/issues/issue_2008_02/article2/&gt; (sorry), where putting an ellipsis (“…”) to the left of a declaration makes it a “parameter pack” containing zero or more parameters and putting an ellipsis to the right of a type/expression/etc. expands the parameter packs within that type/expression into separate arguments. The important part is that we be able to meaningfully abstract over zero or more generic parameters, e.g.:<br>&gt;&gt; <br>&gt;&gt; public struct ZipIterator&lt;... Iterators : IteratorProtocol&gt; : Iterator {  // zero or more type parameters, each of which conforms to IteratorProtocol<br>&gt;&gt;   public typealias Element = (Iterators.Element...)                       // a tuple containing the element types of each iterator in Iterators<br>&gt;&gt; <br>&gt;&gt;   var (...iterators): (Iterators...)    // zero or more stored properties, one for each type in Iterators <br>&gt;&gt;   var reachedEnd: Bool = false<br>&gt;&gt; <br>&gt;&gt;   public mutating func next() -&gt; Element? {<br>&gt;&gt;     if reachedEnd { return nil }<br>&gt;&gt; <br>&gt;&gt;     guard let values = (iterators.next()...) {   // call “next” on each of the iterators, put the results into a tuple named “values&quot;<br>&gt;&gt;       reachedEnd = true<br>&gt;&gt;       return nil<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     return values<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; public struct ZipSequence&lt;...Sequences : Sequence&gt; : Sequence {<br>&gt;&gt;   public typealias Iterator = ZipIterator&lt;Sequences.Iterator...&gt;   // get the zip iterator with the iterator types of our Sequences<br>&gt;&gt; <br>&gt;&gt;   var (...sequences): (Sequences...)    // zero or more stored properties, one for each type in Sequences <br>&gt;&gt; <br>&gt;&gt;   // details ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Such a design could also work for function parameters, so we can pack together multiple function arguments with different types, e.g.,<br>&gt;&gt; <br>&gt;&gt; public func zip&lt;... Sequences : SequenceType&gt;(... sequences: Sequences...) <br>&gt;&gt;             -&gt; ZipSequence&lt;Sequences...&gt; {<br>&gt;&gt;   return ZipSequence(sequences...)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Finally, this could tie into the discussions about a tuple “splat” operator. For example:<br>&gt;&gt; <br>&gt;&gt; func apply&lt;... Args, Result&gt;(fn: (Args...) -&gt; Result,    // function taking some number of arguments and producing Result<br>&gt;&gt;                            args: (Args...)) -&gt; Result {  // tuple of arguments<br>&gt;&gt;   return fn(args...)                                     // expand the arguments in the tuple “args” into separate arguments<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Extensions of structural types<br>&gt;&gt; <br>&gt;&gt; Currently, only nominal types (classes, structs, enums, protocols) can be extended. One could imagine extending structural types—particularly tuple types—to allow them to, e.g., conform to protocols. For example, pulling together variadic generics, parameterized extensions, and conditional conformances, one could express “a tuple type is Equatable if all of its element types are Equatable”:<br>&gt;&gt; <br>&gt;&gt; extension&lt;...Elements : Equatable&gt; (Elements...) : Equatable {   // extending the tuple type “(Elements…)” to be Equatable<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; There are some natural bounds here: one would need to have actual structural types. One would not be able to extend every type:<br>&gt;&gt; <br>&gt;&gt; extension&lt;T&gt; T { // error: neither a structural nor a nominal type<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; And before you think you’re cleverly making it possible to have a conditional conformance that makes every type T that conforms to protocol P also conform to protocol Q, see the section &quot;Conditional conformances via protocol extensions”, below:<br>&gt;&gt; <br>&gt;&gt; extension&lt;T : P&gt; T : Q { // error: neither a structural nor a nominal type<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Syntactic improvements<br>&gt;&gt; <br>&gt;&gt; There are a number of potential improvements we could make to the generics syntax. Such a list could go on for a very long time, so I’ll only highlight some obvious ones that have been discussed by the Swift developers.<br>&gt;&gt; <br>&gt;&gt; *Default implementations in protocols<br>&gt;&gt; <br>&gt;&gt; Currently, protocol members can never have implementations. We could allow one to provide such implementations to be used as the default if a conforming type does not supply an implementation, e.g.,<br>&gt;&gt; <br>&gt;&gt; protocol Bag {<br>&gt;&gt;   associatedtype Element : Equatable<br>&gt;&gt;   func contains(element: Element) -&gt; Bool<br>&gt;&gt; <br>&gt;&gt;   func containsAll&lt;S: Sequence where Sequence.Iterator.Element == Element&gt;(elements: S) -&gt; Bool {<br>&gt;&gt;     for x in elements {<br>&gt;&gt;       if contains(x) { return true }<br>&gt;&gt;     }<br>&gt;&gt;     return false<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct IntBag : Bag {<br>&gt;&gt;   typealias Element = Int<br>&gt;&gt;   func contains(element: Int) -&gt; Bool { ... }<br>&gt;&gt; <br>&gt;&gt;   // okay: containsAll requirement is satisfied by Bag’s default implementation<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; One can get this effect with protocol extensions today, hence the classification of this feature as a (mostly) syntactic improvement:<br>&gt;&gt; <br>&gt;&gt; protocol Bag {<br>&gt;&gt;   associatedtype Element : Equatable<br>&gt;&gt;   func contains(element: Element) -&gt; Bool<br>&gt;&gt; <br>&gt;&gt;   func containsAll&lt;S: Sequence where Sequence.Iterator.Element == Element&gt;(elements: S) -&gt; Bool<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension Bag {<br>&gt;&gt;   func containsAll&lt;S: Sequence where Sequence.Iterator.Element == Element&gt;(elements: S) -&gt; Bool {<br>&gt;&gt;     for x in elements {<br>&gt;&gt;       if contains(x) { return true }<br>&gt;&gt;     }<br>&gt;&gt;     return false<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; *Moving the where clause outside of the angle brackets<br>&gt;&gt; <br>&gt;&gt; The “where” clause of generic functions comes very early in the declaration, although it is generally of much less concern to the client than the function parameters and result type that follow it. This is one of the things that contributes to “angle bracket blindness”. For example, consider the containsAll signature above:<br>&gt;&gt; <br>&gt;&gt; func containsAll&lt;S: Sequence where Sequence.Iterator.Element == Element&gt;(elements: S) -&gt; Bool<br>&gt;&gt; <br>&gt;&gt; One could move the “where” clause to the end of the signature, so that the most important parts—name, generic parameter, parameters, result type—precede it:<br>&gt;&gt; <br>&gt;&gt; func containsAll&lt;S: Sequence&gt;(elements: S) -&gt; Bool <br>&gt;&gt;        where Sequence.Iterator.Element == Element<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; *Renaming “protocol&lt;…&gt;” to “Any&lt;…&gt;”.<br>&gt;&gt; <br>&gt;&gt; The “protocol&lt;…&gt;” syntax is a bit of an oddity in Swift. It is used to compose protocols together, mostly to create values of existential type, e.g.,<br>&gt;&gt; <br>&gt;&gt; var x: protocol&lt;NSCoding, NSCopying&gt;<br>&gt;&gt; <br>&gt;&gt; It’s weird that it’s a type name that starts with a lowercase letter, and most Swift developers probably never deal with this feature unless they happen to look at the definition of Any:<br>&gt;&gt; <br>&gt;&gt; typealias Any = protocol&lt;&gt;<br>&gt;&gt; <br>&gt;&gt; “Any” might be a better name for this functionality. “Any” without brackets could be a keyword for “any type”, and “Any” followed by brackets could take the role of “protocol&lt;&gt;” today:<br>&gt;&gt; <br>&gt;&gt; var x: Any&lt;NSCoding, NSCopying&gt;<br>&gt;&gt; <br>&gt;&gt; That reads much better: “Any type that conforms to NSCoding and NSCopying”. See the section &quot;Generalized existentials” for additional features in this space.<br>&gt;&gt; <br>&gt;&gt; Maybe<br>&gt;&gt; <br>&gt;&gt; There are a number of features that get discussed from time-to-time, while they could fit into Swift’s generics system, it’s not clear that they belong in Swift at all. The important question for any feature in this category is not “can it be done” or “are there cool things we can express”, but “how can everyday Swift developers benefit from the addition of such a feature?”. Without strong motivating examples, none of these “maybes” will move further along.<br>&gt;&gt; <br>&gt;&gt; Dynamic dispatch for members of protocol extensions<br>&gt;&gt; <br>&gt;&gt; Only the requirements of protocols currently use dynamic dispatch, which can lead to surprises:<br>&gt;&gt; <br>&gt;&gt; protocol P {<br>&gt;&gt;   func foo()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension P {<br>&gt;&gt;   func foo() { print(“P.foo()”)<br>&gt;&gt;   func bar() { print(“P.bar()”)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct X : P {<br>&gt;&gt;   func foo() { print(“X.foo()”)<br>&gt;&gt;   func bar() { print(“X.bar()”)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let x = X()<br>&gt;&gt; x.foo() // X.foo()<br>&gt;&gt; x.bar() // X.bar()<br>&gt;&gt; <br>&gt;&gt; let p: P = X()<br>&gt;&gt; p.foo() // X.foo()<br>&gt;&gt; p.bar() // P.bar()<br>&gt;&gt; <br>&gt;&gt; Swift could adopt a model where members of protocol extensions are dynamically dispatched.<br>&gt;&gt; <br>&gt;&gt; Named generic parameters<br>&gt;&gt; <br>&gt;&gt; When specifying generic arguments for a generic type, the arguments are always positional: Dictionary&lt;String, Int&gt; is a Dictionary whose Key type is String and whose Value type is Int, by convention. One could permit the arguments to be labeled, e.g.,<br>&gt;&gt; <br>&gt;&gt; var d: Dictionary&lt;Key: String, Value: Int&gt;<br>&gt;&gt; <br>&gt;&gt; Such a feature makes more sense if Swift gains default generic arguments, because generic argument labels would allow one to skip defaulted arguments.<br>&gt;&gt; <br>&gt;&gt; Generic value parameters<br>&gt;&gt; <br>&gt;&gt; Currently, Swift’s generic parameters are always types. One could imagine allowing generic parameters that are values, e.g.,<br>&gt;&gt; <br>&gt;&gt; struct MultiArray&lt;T, let Dimensions: Int&gt; { // specify the number of dimensions to the array<br>&gt;&gt;   subscript (indices: Int...) -&gt; T {<br>&gt;&gt;     get {<br>&gt;&gt;       require(indices.count == Dimensions)<br>&gt;&gt;       // ...<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; A suitably general feature might allow us to express fixed-length array or vector types as a standard library component, and perhaps also allow one to implement a useful dimensional analysis library. Tackling this feature potentially means determining what it is for an expression to be a “constant expression” and diving into dependent-typing, hence the “maybe”.<br>&gt;&gt; <br>&gt;&gt; Higher-kinded types<br>&gt;&gt; <br>&gt;&gt; Higher-kinded types allow one to express the relationship between two different specializations of the same nominal type within a protocol. For example, if we think of the Self type in a protocol as really being “Self&lt;T&gt;”, it allows us to talk about the relationship between “Self&lt;T&gt;” and “Self&lt;U&gt;” for some other type U. For example, it could allow the “map” operation on a collection to return a collection of the same kind but with a different operation, e.g.,<br>&gt;&gt; <br>&gt;&gt; let intArray: Array&lt;Int&gt; = …<br>&gt;&gt; intArray.map { String($0) } // produces Array&lt;String&gt;<br>&gt;&gt; let intSet: Set&lt;Int&gt; = …<br>&gt;&gt; intSet.map { String($0) }   // produces Set&lt;String&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Potential syntax borrowed from one thread on higher-kinded types &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002736.html&gt; uses ~= as a “similarity” constraint to describe a Functor protocol:<br>&gt;&gt; <br>&gt;&gt; protocol Functor {<br>&gt;&gt;   associatedtype A<br>&gt;&gt;   func fmap&lt;FB where FB ~= Self&gt;(f: A -&gt; FB.A) -&gt; FB<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Specifying type arguments for uses of generic functions<br>&gt;&gt; <br>&gt;&gt; The type arguments of a generic function are always determined via type inference. For example, given:<br>&gt;&gt; <br>&gt;&gt; func f&lt;T&gt;(t: T)<br>&gt;&gt; <br>&gt;&gt; one cannot directly specify T: either one calls “f” (and T is determined via the argument’s type) or one uses “f” in a context where it is given a particular function type (e.g., “let x: (Int) -&gt; Void = f”  would infer T = Int). We could permit explicit specialization here, e.g.,<br>&gt;&gt; <br>&gt;&gt; let x = f&lt;Int&gt; // x has type (Int) -&gt; Void<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Unlikely<br>&gt;&gt; <br>&gt;&gt; Features in this category have been requested at various times, but they don’t fit well with Swift’s generics system because they cause some part of the model to become overly complicated, have unacceptable implementation limitations, or overlap significantly with existing features.<br>&gt;&gt; <br>&gt;&gt; Generic protocols<br>&gt;&gt; <br>&gt;&gt; One of the most commonly requested features is the ability to parameterize protocols themselves. For example, a protocol that indicates that the Self type can be constructed from some specified type T:<br>&gt;&gt; <br>&gt;&gt; protocol ConstructibleFromValue&lt;T&gt; {<br>&gt;&gt;   init(_ value: T)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Implicit in this feature is the ability for a given type to conform to the protocol in two different ways. A “Real” type might be constructible from both Float and Double, e.g.,<br>&gt;&gt; <br>&gt;&gt; struct Real { … }<br>&gt;&gt; extension Real : ConstructibleFrom&lt;Float&gt; {<br>&gt;&gt;   init(_ value: Float) { … }<br>&gt;&gt; }<br>&gt;&gt; extension Real : ConstructibleFrom&lt;Double&gt; {<br>&gt;&gt;   init(_ value: Double) { … }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Most of the requests for this feature actually want a different feature. They tend to use a parameterized Sequence as an example, e.g.,<br>&gt;&gt; <br>&gt;&gt; protocol Sequence&lt;Element&gt; { … }<br>&gt;&gt; <br>&gt;&gt; func foo(strings: Sequence&lt;String&gt;) {  /// works on any sequence containing Strings<br>&gt;&gt;   // ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The actual requested feature here 	is the ability to say “Any type that conforms to Sequence whose Element type is String”, which is covered by the section on “Generalized existentials”, below.<br>&gt;&gt; <br>&gt;&gt; More importantly, modeling Sequence with generic parameters rather than associated types is tantalizing but wrong: you don’t want a type conforming to Sequence in multiple ways, or (among other things) your for..in loops stop working, and you lose the ability to dynamically cast down to an existential “Sequence” without binding the Element type (again, see “Generalized existentials”). Use cases similar to the ConstructibleFromValue protocol above seem too few to justify the potential for confusion between associated types and generic parameters of protocols; we’re better off not having the latter.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Private conformances <br>&gt;&gt; <br>&gt;&gt; Right now, a protocol conformance can be no less visible than the minimum of the conforming type’s access and the protocol’s access. Therefore, a public type conforming to a public protocol must provide the conformance publicly. One could imagine removing that restriction, so that one could introduce a private conformance:<br>&gt;&gt; <br>&gt;&gt; public protocol P { }<br>&gt;&gt; public struct X { }<br>&gt;&gt; extension X : internal P { … } // X conforms to P, but only within this module<br>&gt;&gt; <br>&gt;&gt; The main problem with private conformances is the interaction with dynamic casting. If I have this code:<br>&gt;&gt; <br>&gt;&gt; func foo(value: Any) {<br>&gt;&gt;   if let x = value as? P { print(“P”) }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; foo(X())<br>&gt;&gt; <br>&gt;&gt; Under what circumstances should it print “P”? If foo() is defined within the same module as the conformance of X to P? If the call is defined within the same module as the conformance of X to P? Never? Either of the first two answers requires significant complications in the dynamic casting infrastructure to take into account the module in which a particular dynamic cast occurred (the first option) or where an existential was formed (the second option), while the third answer breaks the link between the static and dynamic type systems—none of which is an acceptable result.<br>&gt;&gt; <br>&gt;&gt; Conditional conformances via protocol extensions<br>&gt;&gt; <br>&gt;&gt; We often get requests to make a protocol conform to another protocol. This is, effectively, the expansion of the notion of “Conditional conformances” to protocol extensions. For example:<br>&gt;&gt; <br>&gt;&gt; protocol P {<br>&gt;&gt;   func foo()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; protocol Q {<br>&gt;&gt;   func bar()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension Q : P { // every type that conforms to Q also conforms to P<br>&gt;&gt;   func foo() {    // implement “foo” requirement in terms of “bar&quot;<br>&gt;&gt;     bar()<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func f&lt;T: P&gt;(t: T) { … }<br>&gt;&gt; <br>&gt;&gt; struct X : Q {<br>&gt;&gt;   func bar() { … }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; f(X()) // okay: X conforms to P through the conformance of Q to P<br>&gt;&gt; <br>&gt;&gt; This is an extremely powerful feature: is allows one to map the abstractions of one domain into another domain (e.g., every Matrix is a Graph). However, similar to private conformances, it puts a major burden on the dynamic-casting runtime to chase down arbitrarily long and potentially cyclic chains of conformances, which makes efficient implementation nearly impossible.<br>&gt;&gt; <br>&gt;&gt; Potential removals<br>&gt;&gt; <br>&gt;&gt; The generics system doesn’t seem like a good candidate for a reduction in scope; most of its features do get used fairly pervasively in the standard library, and few feel overly anachronistic. However...<br>&gt;&gt; <br>&gt;&gt; Associated type inference<br>&gt;&gt; <br>&gt;&gt; Associated type inference is the process by which we infer the type bindings for associated types from other requirements. For example:<br>&gt;&gt; <br>&gt;&gt; protocol IteratorProtocol {<br>&gt;&gt;   associatedtype Element<br>&gt;&gt;   mutating func next() -&gt; Element?<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct IntIterator : IteratorProtocol {<br>&gt;&gt;   mutating func next() -&gt; Int? { … }  // use this to infer Element = Int<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Associated type inference is a useful feature. It’s used throughout the standard library, and it helps keep associated types less visible to types that simply want to conform to a protocol. On the other hand, associated type inference is the only place in Swift where we have a global type inference problem: it has historically been a major source of bugs, and implementing it fully and correctly requires a drastically different architecture to the type checker. Is the value of this feature worth keeping global type inference in the Swift language, when we have deliberatively avoided global type inference elsewhere in the language?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Existentials<br>&gt;&gt; <br>&gt;&gt; Existentials aren’t really generics per se, but the two systems are closely intertwined due to their mutable dependence on protocols.<br>&gt;&gt; <br>&gt;&gt; *Generalized existentials<br>&gt;&gt; <br>&gt;&gt; The restrictions on existential types came from an implementation limitation, but it is reasonable to allow a value of protocol type even when the protocol has Self constraints or associated types. For example, consider IteratorProtocol again and how it could be used as an existential:<br>&gt;&gt; <br>&gt;&gt; protocol IteratorProtocol {<br>&gt;&gt;   associatedtype Element<br>&gt;&gt;   mutating func next() -&gt; Element?<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let it: IteratorProtocol = …<br>&gt;&gt; it.next()   // if this is permitted, it could return an “Any?”, i.e., the existential that wraps the actual element<br>&gt;&gt; <br>&gt;&gt; Additionally, it is reasonable to want to constrain the associated types of an existential, e.g., “a Sequence whose element type is String” could be expressed by putting a where clause into “protocol&lt;…&gt;” or “Any&lt;…&gt;” (per “Renaming protocol&lt;…&gt; to Any&lt;…&gt;”):<br>&gt;&gt; <br>&gt;&gt; let strings: Any&lt;Sequence where .Iterator.Element == String&gt; = [“a”, “b”, “c”]<br>&gt;&gt; <br>&gt;&gt; The leading “.” indicates that we’re talking about the dynamic type, i.e., the “Self” type that’s conforming to the Sequence protocol. There’s no reason why we cannot support arbitrary “where” clauses within the “Any&lt;…&gt;”. This very-general syntax is a bit unwieldy, but common cases can easily be wrapped up in a generic typealias (see the section “Generic typealiases” above):<br>&gt;&gt; <br>&gt;&gt; typealias AnySequence&lt;Element&gt; = Any&lt;Sequence where .Iterator.Element == Element&gt;<br>&gt;&gt; let strings: AnySequence&lt;String&gt; = [“a”, “b”, “c”]<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Opening existentials<br>&gt;&gt; <br>&gt;&gt; Generalized existentials as described above will still have trouble with protocol requirements that involve Self or associated types in function parameters. For example, let’s try to use Equatable as an existential:<br>&gt;&gt; <br>&gt;&gt; protocol Equatable {<br>&gt;&gt;   func ==(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;   func !=(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let e1: Equatable = …<br>&gt;&gt; let e2: Equatable = …<br>&gt;&gt; if e1 == e2 { … } // error: e1 and e2 don’t necessarily have the same dynamic type<br>&gt;&gt; <br>&gt;&gt; One explicit way to allow such operations in a type-safe manner is to introduce an “open existential” operation of some sort, which extracts and gives a name to the dynamic type stored inside an existential. For example:<br>&gt;&gt; <br>&gt;&gt; 	 <br>&gt;&gt; if let storedInE1 = e1 openas T {     // T is a the type of storedInE1, a copy of the value stored in e1<br>&gt;&gt;   if let storedInE2 = e2 as? T {      // is e2 also a T?<br>&gt;&gt;     if storedInE1 == storedInE2 { … } // okay: storedInT1 and storedInE2 are both of type T, which we know is Equatable<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Thoughts?<br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160307/9593bbe0/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2b19ddab2d7de4523412c875c258e278?s=50"></div><header><strong>[Manifesto] Completing Generics</strong> from <string>Matt Whiteside</string> &lt;mwhiteside.dev at gmail.com&gt;<p>March  8, 2016 at 05:00:00pm</p></header><div class="content"><p>I’m really looking forward to the features on this list.<br></p><p>The following is one that I’ve come across the need for a couple times already, even with the limited amount of swift I have written:<br></p><p>&gt; On Mar 2, 2016, at 17:22, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; extension Array&lt;String&gt; {<br>&gt;   func makeSentence() -&gt; String {<br>&gt;     // uppercase first string, concatenate with spaces, add a period, whatever<br>&gt;   }<br>&gt; }<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160308/492418f2/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Completing Generics] Generic value parameters</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>March  9, 2016 at 12:00:00pm</p></header><div class="content"><p>I proposed adding generic value parameters under the label &quot;compile time parameters&quot;, and stopped working on it because it is out of scope for Swift 3 — yet I&#39;m still very eager to see this added in the future.<br>My draft most likely had no impact on &quot;Completing Generics&quot;, but as I favored the same syntax, I take this match as an indication that the choice is somewhat natural.<br>Introduction<br></p><p>Generics are often seen as &quot;simplified templates&quot;: They are not as powerful, but have the benefit of being less complicated and dangerous. The feature illustrated here should not only make Swift more powerful, but also safer by adding basic datatypes like fixed-size arrays.<br></p><p> &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#motivation&gt;Motivation<br></p><p>Right now, we can have something like let m = Matrix(rows: 3, columns: 4) easily. There&#39;s just the problem that the compiler cannot deduce which matrices are &quot;compatible&quot;, as there is only one Matrix-type. If we had a way to tell the compiler that &quot;rows&quot; and &quot;columns&quot; have an effect on the type, errors due to dimension mismatches could be eliminated (vector math, but also functions like zip would benefit from this).<br></p><p>Additionally, the proposal would make it possible to create unit systems, so that calculations are checked for matching quantities (so you cannot add a force to a velocity without causing an error).<br></p><p>Currently, there is no elegant way to declare a C-type array of a fixed size; this is a fundamental problem that could be solved with the syntax presented here.<br></p><p> &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#proposed-solution&gt;Proposed solution<br></p><p>The basic idea is quite simple: We just need a way to tell the compile that there are some parameters that have impact on their type. On possible syntax would be<br></p><p>struct Matrix&lt;T: ScalarType, let rows: UInt, let columns: UInt&gt; {<br>...<br>subscript(row: UInt, column: UInt) -&gt; T {<br>    set(value) {<br>        if row &lt; rows &amp;&amp; column &lt; columns {<br>            // set the entry<br>        } else {<br>            // out of bounds - that is not allowed<br>        }<br>    }<br>...<br>}<br> &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#detailed-design&gt;Detailed design<br></p><p>I think its easy to grasp with the example: In addition to type parameters, we introduce constants that are defined in a similar way:<br></p><p>let [identifier]: [type]<br></p><p>e.g.<br></p><p>struct FloatVector&lt;let dimensions: UInt&gt;...<br></p><p>Unlike templates, compile-time parameters (as the name already suggests) could live inside libs, without disclosing details about their implementation.<br></p><p>From the inside of the parametrized object, compile-time parameters would be used like normal let-parameters/members.<br></p><p> &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#instantiation&gt;Instantiation<br></p><p>The behavior should be similar to generics, so the position of each parameter in the list is fixed. To make things clearer, I suggest to accept (optional) labels, so that the two following statements are valid:<br></p><p>let force: FloatVector&lt;dimensions: 3&gt;<br></p><p>let impulse: FloatVector&lt;3&gt;<br></p><p> &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#limitations-for-parameter-values&gt;Limitations for parameter values<br></p><p>Although integer-type parameters are most likely the only ones with a broad use case, any type implementing one of the ...LiteralCovertible protocols could be used. Enums and other entities could make sense as well, but this is beyond the scope of this proposal.<br></p><p> &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#possible-extension-limitations&gt;Possible extension: Limitations<br></p><p>It would nice to have where-clauses on the parameters to disallow certain values or value-combinations.<br></p><p> &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#impact-on-existing-code&gt;Impact on existing code<br></p><p>None, it&#39;s a new feature that does not affect existing code - but it might be a good opportunity to improve the generics syntax as well: There have also been wishes for labeled type parameters, and as far as I can see, those should be allowed, too.<br></p><p>To further increase consistency, the generics-syntax could be changed (struct Array&lt;type T&gt;... or struct Array&lt;T: type where ...&gt;), but that is not coupled with this proposal.<br></p><p> &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#alternatives-considered&gt;Alternatives considered<br></p><p>Actually, the let-syntax is not my preferred choice - but there is a collision with generics, and relying on capitalization to distinguish MyClass&lt;size: Int&gt; and MyClass&lt;V: UIView&gt; seems strange. It could still be possible to drop let without confusing the compiler, but I&#39;m concerned about confusing the user:<br></p><p>It makes no sense to declare a generic parameter that is restricted to a subtype of something that is final, but that isn&#39;t obvious to a human reader.<br></p><p> &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#marked-parameters&gt;Marked parameters<br></p><p>It would be possible to keep the parameters in the initializer (or function) and mark them with a keyword: init(static dimensions: Int) {...<br></p><p>Especially for types, this would be cumbersome, as you can have many initializers.<br></p><p> &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#different-kind-of-braces&gt;Different kind of braces<br></p><p>Instead of grouping value parameters with type parameters, they could be separated:<br></p><p>class Test[Size: Int]&lt;T&gt; or class Test(size: Int)&lt;T&gt;<br></p><p>The benefit would be that let isn&#39;t needed anymore, but as compile-time parameters are very similar to generics, it would be nice to resemble that in the syntax. Especially the square-braces have a very different, established meaning (array subscript), so I&#39;d strongly advice not to consider them.<br></p><p>Normal parenthesis don&#39;t have that problem at the declaration site, but lack an obvious instantiation syntax that doesn&#39;t collide with init parameters.<br></p><p> &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#separate-types&gt;Separate types<br></p><p>The current &quot;solution&quot; is declaring a type for every case you want to cover.<br></p><p>This approach works good enough in simple situations (e.g. Vector4), but it scales badly:<br></p><p>It is tedious to declare new variants, and the only way to express their tight resemblance is a coherent naming scheme that isn&#39;t enforced.<br></p><p> &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#macros-and-preprocessors&gt;Macros and preprocessors<br></p><p>It is possible to generate distinct types using macros - but as there is no build-in support for those, this is quite cumbersome.<br></p><p> &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#tuples&gt;Tuples<br></p><p>There has been a discussion about a shorthand to declare tuples with a fixed number of elements.<br></p><p>This solution would have the benefit of automatic compatibility with C-structs - but the downside of not having the power of Swift structs (and classes): Tuples can&#39;t have methods, and this is a major drawback.<br></p><p>So, the tuple-extension is no real alternative, but both ideas would fit together without redundancy.<br></p><p><br>In general, I think a Wiki-Page would be a nice helper to discuss comprehensive topics like generics (things like concurrency and compile-time evaluation imho are good candidates for a Wiki as well).<br></p><p><br>- Tino<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160309/64091b77/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7c09deb834fdd886e8c9d28ff9679719?s=50"></div><header><strong>[Completing Generics]</strong> from <string>Erik Verbruggen</string> &lt;erik.verbruggen at me.com&gt;<p>March  9, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; Generic constants<br>&gt; <br>&gt; let constants could be allowed to have generic parameters, such that they produce differently-typed values depending on how they are used. For example, this is particularly useful for named literal values, e.g.,<br>&gt; <br>&gt; let π&lt;T : FloatLiteralConvertible&gt;: T = 3.141592653589793238462643383279502884197169399<br>&gt; <br>&gt; The Clang importer could make particularly good use of this when importing macros.<br></p><p>I assume the following will fall under &quot;constant expression&quot;:<br></p><p>	let 2π = 2 * π<br></p><p>Also, how does the clang-importer handle:<br></p><p>	#define M_DOUBLE_PI (2 * M_PI)<br></p><p>Or rephrasing, this is specifically for the case where the initialiser only consists of a single literal token?<br></p><p>-- Erik.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160309/8d717641/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Completing Generics]</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>March  9, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Mar 9, 2016, at 4:28 AM, Erik Verbruggen &lt;erik.verbruggen at me.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Generic constants<br>&gt;&gt; <br>&gt;&gt; let constants could be allowed to have generic parameters, such that they produce differently-typed values depending on how they are used. For example, this is particularly useful for named literal values, e.g.,<br>&gt;&gt; <br>&gt;&gt; let π&lt;T : FloatLiteralConvertible&gt;: T = 3.141592653589793238462643383279502884197169399<br>&gt;&gt; <br>&gt;&gt; The Clang importer could make particularly good use of this when importing macros.<br>&gt; <br>&gt; I assume the following will fall under &quot;constant expression&quot;:<br>&gt; <br>&gt; 	let 2π = 2 * π<br></p><p>That would involve inferring that 2π is a generic constant… could certainly be something to explore, but it’s somewhat new territory. <br></p><p>&gt; <br>&gt; Also, how does the clang-importer handle:<br>&gt; <br>&gt; 	#define M_DOUBLE_PI (2 * M_PI)<br>&gt; <br>&gt; Or rephrasing, this is specifically for the case where the initialiser only consists of a single literal token?<br></p><p>I was thinking of it in terms of a single literal token, but I’m pointing out the feature as a possibility, not doing the detailed design work that would be involved in making it real. It’s possible we could make the importer smarter in this regard.<br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160309/384587c5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Completing Generics]</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March  9, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt;&gt; I assume the following will fall under &quot;constant expression&quot;:<br>&gt;&gt; <br>&gt;&gt; 	let 2π = 2 * π<br>&gt; <br>&gt; That would involve inferring that 2π is a generic constant… could certainly be something to explore, but it’s somewhat new territory. <br></p><p>It seems to me that the same logic would make this:<br></p><p>	let range = 1.0...5.0<br></p><p>Into something like this:<br></p><p>	let range&lt;T: Comparable, FloatLiteralType&gt;: ClosedInterval&lt;T&gt; = 1.0...5.0<br></p><p>Which strikes me as a bridge too far.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc045f9bdc3bd1885767f2a2ba8af458?s=50"></div><header><strong>[Manifesto] Completing Generics</strong> from <string>Jonathan Tang</string> &lt;jonathan.d.tang at gmail.com&gt;<p>March 10, 2016 at 12:00:00am</p></header><div class="content"><p>Going through my code comments &amp; notes now to see where the ideas here<br>could&#39;ve helped avoid some nasty hacks.  I&#39;ll try to keep this mostly to<br>(missing) features I&#39;ve found problematic but haven&#39;t seen mentioned here<br>and quick votes with comments that I think won&#39;t be responded to, and then<br>fork off deeper discussions into their own threads as suggested.<br></p><p>*Missing feature: How do protocols interact with the package system?*<br></p><p>Javascript had an unfortunate situation a couple years ago where there were<br>about a dozen competing Promise implementations.  The leading libraries all<br>got together and came up with the Promises/A+ spec.  Because Javascript is<br>dynamically typed, the spec mandates that anything with a then() method is<br>&quot;Promise-like&quot;, and can be chained into existing promises.  As a result,<br>you can take a library that uses Bluebird promises, pass them to a library<br>that uses the es6-promise Polyfill, and then use the native implementation<br>of Promise.all and everything will just work.<br></p><p>Swift is not dynamically typed - to indicate a common set of functionality,<br>you need to define a protocol.  What happens when multiple frameworks<br>define a protocol that other frameworks wish to use?  I know of at least 3<br>different mutually-incompatible Promise implementations for Swift, but<br>assuming they managed to reconcile their differences and come up with a<br>common API - how would a library wanting to use this spec ensure that it&#39;s<br>compatible with other libraries using the spec?  If I include<br>promises.swift in my project which defines &quot;public protocol Promise { ...<br>}&quot;, will the compiler know that it&#39;s the same protocol as the identical<br>promises.swift in AlamoFire or RethinkDB?  If not - how could it be<br>packaged up on its own so that everyone can be good citizens and<br>interoperate with each other?  Will app developers using these libraries<br>need to install a long chain of dependencies, or can they just get their<br>leaf dependencies and trust that everything will work together?  What<br>happens if there are versioning inconsistencies behind the protocols that<br>library dependencies use?<br></p><p>*Missing feature: &quot;protocol can only be used as a generic constraint&quot;*<br></p><p>This error message pops up whenever you try to use a protocol that has<br>associated types or Self (in a non-return position) as a type.  Instead of<br>being able to write &quot;func doSomething(obj: MyProtocol)&quot;, you now have to<br>write &quot;func doSomething&lt;T: MyProtocol&gt;(obj: T)&quot;, and you can forget about<br>being able to store objects of these protocols in data structures.  As I<br>understand it, this is because of conceptional confusion on the part of the<br>dev: when a protocol has associated types, it&#39;s no longer a *type*, but a *type<br>family*, and so it doesn&#39;t make sense to use it as you would a type.  The<br>compiler would have to enforce invariants that it doesn&#39;t have the<br>information to enforce.<br></p><p>That said, is there anyway to reduce the impact of this error message<br>(which, based on several Google searches and a bunch of encounters with it<br>myself, seems to happen quite frequently)?<br></p><p>In my experience, this error seems to pop up most often in two common<br>circumstances:<br></p><p>- Adopting Equatable or Hashable in a protocol<br></p><p>Solved by existentials - the usage of the protocol becomes an existential.<br>In particular, &quot;opening existentials&quot; is usually what you&#39;d want to do for<br>==; I&#39;m not really sure I like the syntax proposed here but this thread<br>isn&#39;t for bikeshedding. :-)<br></p><p>- Making a protocol inherit from a collection<br></p><p>Examples of this might include having a Message object behave like<br>[String:AnyObject], having an Amazon S3 interface behave like<br>[String:NSData], or having a File behave like [String] (like in Python).<br>Assume that concrete adopting classes cannot change the associated types.<br></p><p>The interesting thing about this case is that all of the associated types<br>are nailed down, and their usage can be limited to default method<br>implementations that don&#39;t vary between the concrete types adopting the<br>protocol.  So in such a File, the Generator implementation would always<br>delegate to self.readLine(), the SubSequence type is always [String], and<br>the only time these types are referenced is on default methods on File<br>which themselves delegate to the protocol methods witnessed by adopting<br>types.<br></p><p>IIUC, the compiler should have enough information available to generate all<br>code required by a File parameter, right?  It knows the associated types of<br>the collection, and it knows the methods that generate them.<br></p><p>Could this special case be fixed?<br></p><p>*Missing feature: How does toll-free bridging with Foundation interact with<br>protocol extensions?*<br></p><p>Last time I checked, an Array is-a NSArray and vice versa; they satisfy<br>is/as checks, they can be used interchangeably, and methods on one are<br>available on the other.  Except for with protocol extensions.  When you<br>extend Array to conform to a protocol, you don&#39;t automatically get NSArray<br>as well.  You have to explicitly define a conformance for NSArray as well,<br>which often has exactly the same code.<br></p><p>This is more a source of head-scratching &amp; annoyance than a fundamental<br>limitation, since you can always duplicate the code and factor the logic<br>out to a common helper.  But it&#39;s one that&#39;s likely to be propagated<br>through the library ecosystem, as library authors who grow up on Swift<br>forget about NSArray/NSDictionary/etc. and then their code just doesn&#39;t<br>work for people switching over an Objective-C app.<br></p><p>On Wed, Mar 2, 2016 at 5:22 PM, Douglas Gregor via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p><br>&gt; **Conditional conformances*<br>&gt;<br>&gt;<br>Big +1.  This is necessary for any sort of extensible tree structure.<br>Think about JSON serialization, for example: an array or dictionary is JSON<br>serializable only if all of its elements are JSON serializable, and the<br>algorithm used to serialize it depends on a call to serialize its members.<br>It comes up in many UI areas as well: a UI component might be Persistable<br>iff all of its subviews are Persistable.<br></p><p>The lack of this prevents app code from being able to easily extend<br>functionality provided in a library, eg. I may be able to easily come up<br>with a JSON serialization of a CLLocation or CNContact, but SwiftyJSON will<br>be unable to serialize an array of these objects using my mechanism.<br></p><p>*Concrete same-type requirements*<br>&gt;<br>&gt;<br>Big +1 on this as well.  It seems like it&#39;s pretty uncontroversial, but<br>this is widely applicable across a number of domains.  Basically any time<br>you need to operate on a generic collection with operations that only make<br>sense on a particular element type.<br></p><p>This would also increase the usefulness of &quot;Generic typealiases&quot; - the two<br>proposals together let you define new generic types just by adding<br>extensions to existing generic types.  Good way to prototype, and then if<br>the extension gets too complicated, you can always take what you&#39;ve learned<br>and make a real type.<br></p><p><br></p><p>&gt;<br>&gt; *Parameterized extensions*<br>&gt;<br>&gt;<br>&gt; **Arbitrary requirements in protocols*<br>&gt;<br></p><p>These two both seem nifty, but I&#39;m having trouble thinking of a concrete<br>use-case where they&#39;d be critical.  The &quot;arbitrary requirements in<br>protocols&quot; in particular seems to be going down the path of &quot;let&#39;s embed a<br>constraint solver in the Swift compiler&quot;, which seems like it&#39;d lead to<br>some fun webpages a la type arithmetics<br>&lt;http://okmij.org/ftp/Computation/type-arithmetics.html&gt;, but not something<br>you&#39;d want to see in your coworker&#39;s code.<br></p><p><br></p><p>&gt; *Default generic arguments *<br>&gt;<br>&gt;<br> Is it within Swift&#39;s scope to support compile-time polymorphism for high<br>performance computing?  This is a common technique in C++: you want a<br>generic algorithm that must be specialized in one or two places, but can&#39;t<br>afford the run-time overhead of dynamic dispatch.  So you create a template<br>parameter with a functor type.  STL allocators are a good example.<br></p><p>I don&#39;t personally do much HPC and dunno if it fits within Apple&#39;s vision<br>for Swift, but there are few other options if you do, and default generic<br>args make this tactic much more convenient.  Also fits well with &quot;Named<br>generic parameters&quot; and &quot;Generic value parameters&quot;.  Might combine<br>awkwardly with &quot;Variadic generics&quot; and &quot;Moving the where clause out of the<br>angle brackets&quot; (would the default be specified inside the angle brackets<br>or outside?).<br></p><p><br>&gt; **Allowing subclasses to override requirements satisfied by defaults*<br>&gt;<br>&gt;<br>&gt;<br>Necessary for &quot;Dynamic dispatch of protocol extensions&quot; and &quot;default<br>implementations in protocols&quot; to make sense, right?  +1 to all three, it<br>seems like this is a cluster of related improvements that would make things<br>more uniform &amp; understandable.<br></p><p><br>&gt;<br>&gt; *Variadic generics*<br>&gt;<br>&gt;<br>&gt;<br>I&#39;ll fork off a thread on this...I&#39;ve got some thoughts specifically<br>related to use with function types.<br></p><p><br>&gt;<br>&gt; **Default implementations in protocols*<br>&gt;<br>&gt;<br>&gt;<br>+1.  It&#39;s cosmetic only, but the &quot;use an extension to provide default<br>members of a protocol&quot; idiom can be very confusing to newcomers.<br></p><p><br>&gt; **Renaming “protocol&lt;…&gt;” to “Any&lt;…&gt;”.*<br>&gt;<br>&gt;<br>+1.  protocol&lt;&gt; always struck me as weird.  Any&lt;...&gt; is pretty similar to<br>equivalent concepts in other languages, like union types in Dylan.<br></p><p><br>&gt; **Moving the where clause outside of the angle brackets*<br>&gt;<br></p><p>-1.  Haskell does it this way (and pretty much has to because of MPTCs with<br>fundeps).  I found it was one of the hard parts of learning Haskell - I&#39;m<br>used to thinking of a type as a unit.  Adding generics to that unit isn&#39;t<br>too hard to wrap my head around.  Adding constraints to those generics<br>isn&#39;t that hard, although at that point the type signatures are getting<br>really long.  (The proposals for &quot;Generic typealiases&quot; and &quot;Typealiases in<br>protocols and protocol extensions&quot; could help ameliorate this.  Is it<br>possible to typealias constraints as well?)  Wondering what the hell this<br>&quot;where&quot; clause is and how it relates to these generic things and why it&#39;s<br>at the end of the function signature can get pretty confusing.<br></p><p>Also, how does this interact with generic constraints on class/structs?<br>Would it go after the full struct definition, or just after the class name?<br></p><p><br></p><p>&gt;<br>&gt; *Dynamic dispatch for members of protocol extensions*<br>&gt;<br>&gt;<br>&gt;<br>Static dispatch is very confusing here.  The whole point of protocols is to<br>get ad-hoc polymorphism, so when a protocol default message is called<br>instead of the overridden version just because of the static type signature<br>of the variable, it&#39;s likely to result in much head-scratching.<br></p><p><br></p><p>&gt;<br>&gt;<br>&gt; *Potential removals*<br>&gt;<br>&gt; The generics system doesn’t seem like a good candidate for a reduction in<br>&gt; scope; most of its features do get used fairly pervasively in the standard<br>&gt; library, and few feel overly anachronistic. However...<br>&gt;<br>&gt; *Associated type inference*<br>&gt;<br>&gt;<br>The consequence of its removal is just that classes/structs that conform to<br>IteratorProtocol will now have to say &quot;associatedtype Element = Int&quot;?  I<br>don&#39;t view that as a major hurdle.  It&#39;s a bit of an annoyance, but if it<br>makes the typechecker significantly simpler and allows implementation of<br>some of the other ideas here, I think it&#39;s worth it.  It would be more<br>problematic if it required extra declarations at the call site; functions<br>are called orders of magnitude more times than classes &amp; structs are<br>declared.<br></p><p><br>&gt;<br>&gt; *Existentials*<br>&gt;<br>&gt; Existentials aren’t really generics per se, but the two systems are<br>&gt; closely intertwined due to their mutable dependence on protocols.<br>&gt;<br>&gt; **Generalized existentials*<br>&gt;<br>&gt; *Opening existentials*<br>&gt;<br>&gt;<br>&gt;<br>+1 on both of these.  I remember writing a Haskell tutorial<br>&lt;https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours&gt; several<br>years ago, and it was amazing how quickly you needed existentials.  It&#39;s<br>not uncommon to want a heterogenous collection of objects that all<br>implement a single protocol; generics don&#39;t give you this.<br></p><p>There&#39;s an existing thread on this, so I&#39;ll send comments on the syntax &amp;<br>usage of this over that way.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160310/2ba81102/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>[Manifesto] Completing Generics</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>April  4, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Mar 2, 2016, at 5:22 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Removing unnecessary restrictions<br>&gt; <br>&gt; Concrete same-type requirements<br>&gt; <br>&gt; Currently, a constrained extension cannot use a same-type constraint to make a type parameter equivalent to a concrete type. For example:<br>&gt; <br>&gt; extension Array where Element == String {<br>&gt;   func makeSentence() -&gt; String {<br>&gt;     // uppercase first string, concatenate with spaces, add a period, whatever<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; This is a highly-requested feature that fits into the existing syntax and semantics. Note that one could imagine introducing new syntax, e.g., extending “Array&lt;String&gt;”, which gets into new-feature territory: see the section on “Parameterized extensions”.<br></p><p>Seems useful.<br></p><p><br>&gt; <br>&gt; Parameterizing other declarations<br>&gt; <br>&gt; <br>&gt; Parameterized extensions<br>&gt; <br>&gt; Extensions themselves could be parameterized, which would allow some structural pattern matching on types. For example, this would permit one to extend an array of optional values, e.g.,<br>&gt; <br>&gt; extension&lt;T&gt; Array where Element == T? {<br>&gt;   var someValues: [T] {<br>&gt;     var result = [T]()<br>&gt;     for opt in self {<br>&gt;       if let value = opt { result.append(value) }<br>&gt;     }<br>&gt;    return result<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; We can generalize this to a protocol extensions:<br>&gt; <br>&gt; extension&lt;T&gt; Sequence where Element == T? {<br>&gt;   var someValues: [T] {<br>&gt;     var result = [T]()<br>&gt;     for opt in self {<br>&gt;       if let value = opt { result.append(value) }<br>&gt;     }<br>&gt;    return result<br>&gt;   }<br>&gt; }<br></p><p>This would be fantastic. I’ve run into it a number of times.<br></p><p><br></p><p>&gt; <br>&gt; Minor extensions<br>&gt; <br>&gt; There are a number of minor extensions we can make to the generics system that don’t fundamentally change what one can express in Swift, but which can improve its expressivity.<br>&gt; <br>&gt; *Arbitrary requirements in protocols<br>&gt; <br>&gt; Currently, a new protocol can inherit from other protocols, introduce new associated types, and add new conformance constraints to associated types (by redeclaring an associated type from an inherited protocol). However, one cannot express more general constraints. Building on the example from “Recursive protocol constraints”, we really want the element type of a Sequence’s SubSequence to be the same as the element type of the Sequence, e.g.,<br>&gt; <br>&gt; protocol Sequence {<br>&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;   …<br>&gt;   associatedtype SubSequence : Sequence where SubSequence.Iterator.Element == Iterator.Element<br>&gt; }<br>&gt; <br>&gt; Hanging the where clause off the associated type is protocol not ideal, but that’s a discussion for another thread.<br></p><p>Definitely run into this one before.<br></p><p><br>&gt; <br>&gt; <br>&gt; Default generic arguments <br>&gt; <br>&gt; Generic parameters could be given the ability to provide default arguments, which would be used in cases where the type argument is not specified and type inference could not determine the type argument. For example:<br>&gt; <br>&gt; public final class Promise&lt;Value, Reason=Error&gt; { … }<br>&gt; <br>&gt; func getRandomPromise() -&gt; Promise&lt;Int, ErrorProtocol&gt; { … }<br>&gt; <br>&gt; var p1: Promise&lt;Int&gt; = …<br>&gt; var p2: Promise&lt;Int, Error&gt; = p1     // okay: p1 and p2 have the same type Promise&lt;Int, Error&gt;<br>&gt; var p3: Promise = getRandomPromise() // p3 has type Promise&lt;Int, ErrorProtocol&gt; due to type inference<br>&gt; <br></p><p>Also quite useful in eliminating boilerplate.<br></p><p><br>&gt; <br>&gt; Generalized “class” constraints<br>&gt; <br>&gt; The “class” constraint can currently only be used for defining protocols. We could generalize it to associated type and type parameter declarations, e.g.,<br>&gt; <br>&gt; protocol P {<br>&gt;   associatedtype A : class<br>&gt; }<br>&gt; <br>&gt; func foo&lt;T : class&gt;(t: T) { }<br>&gt; <br>&gt; As part of this, the magical AnyObject protocol could be replaced with an existential with a class bound, so that it becomes a typealias:<br>&gt; <br>&gt; typealias AnyObject = protocol&lt;class&gt;<br>&gt; <br>&gt; See the “Existentials” section, particularly “Generalized existentials”, for more information.<br></p><p>Another +1. <br></p><p><br>&gt; <br>&gt; Major extensions to the generics model<br>&gt; <br>&gt; Unlike the minor extensions, major extensions to the generics model provide more expressivity in the Swift generics system and, generally, have a much more significant design and implementation cost.<br>&gt; <br>&gt; <br>&gt; *Conditional conformances<br>&gt; <br>&gt; <br></p><p>This one seems extremely important and has immediate utility IMHO.<br></p><p><br>&gt; <br>&gt; Syntactic improvements<br>&gt; <br>&gt; <br>&gt; <br>&gt; Maybe<br>&gt; <br>&gt; <br>&gt; Higher-kinded types<br>&gt; <br>&gt; Higher-kinded types allow one to express the relationship between two different specializations of the same nominal type within a protocol. For example, if we think of the Self type in a protocol as really being “Self&lt;T&gt;”, it allows us to talk about the relationship between “Self&lt;T&gt;” and “Self&lt;U&gt;” for some other type U. For example, it could allow the “map” operation on a collection to return a collection of the same kind but with a different operation, e.g.,<br>&gt; <br>&gt; let intArray: Array&lt;Int&gt; = …<br>&gt; intArray.map { String($0) } // produces Array&lt;String&gt;<br>&gt; let intSet: Set&lt;Int&gt; = …<br>&gt; intSet.map { String($0) }   // produces Set&lt;String&gt;<br>&gt; <br>&gt; <br>&gt; Potential syntax borrowed from one thread on higher-kinded types &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002736.html&gt; uses ~= as a “similarity” constraint to describe a Functor protocol:<br>&gt; <br>&gt; protocol Functor {<br>&gt;   associatedtype A<br>&gt;   func fmap&lt;FB where FB ~= Self&gt;(f: A -&gt; FB.A) -&gt; FB<br>&gt; }<br>&gt; <br></p><p>I don’t think everyday Swift developers will find much use for this feature, but I do think it enables library authors to do some really powerful things with less boilerplate… though your `map` example is actually compelling in and of itself. My own SequenceTypes get map for free, but only the one that returns an array. That’s a bummer.<br></p><p><br>&gt; <br>&gt; Specifying type arguments for uses of generic functions<br>&gt; <br>&gt; The type arguments of a generic function are always determined via type inference. For example, given:<br>&gt; <br>&gt; func f&lt;T&gt;(t: T)<br>&gt; <br>&gt; one cannot directly specify T: either one calls “f” (and T is determined via the argument’s type) or one uses “f” in a context where it is given a particular function type (e.g., “let x: (Int) -&gt; Void = f”  would infer T = Int). We could permit explicit specialization here, e.g.,<br>&gt; <br>&gt; let x = f&lt;Int&gt; // x has type (Int) -&gt; Void<br></p><p>This is one of those annoying little things that can be really helpful and it seems odd that constructors allow specialization but function calls don’t. It’s also a much cleaner way of resolving ambiguity if the compiler is confused.<br></p><p><br></p><p>&gt; <br>&gt; Potential removals<br>&gt; <br>&gt; Associated type inference<br>&gt; <br>&gt; Associated type inference is the process by which we infer the type bindings for associated types from other requirements. For example:<br>&gt; <br>&gt; protocol IteratorProtocol {<br>&gt;   associatedtype Element<br>&gt;   mutating func next() -&gt; Element?<br>&gt; }<br>&gt; <br>&gt; struct IntIterator : IteratorProtocol {<br>&gt;   mutating func next() -&gt; Int? { … }  // use this to infer Element = Int<br>&gt; }<br>&gt; <br>&gt; Associated type inference is a useful feature. It’s used throughout the standard library, and it helps keep associated types less visible to types that simply want to conform to a protocol. On the other hand, associated type inference is the only place in Swift where we have a global type inference problem: it has historically been a major source of bugs, and implementing it fully and correctly requires a drastically different architecture to the type checker. Is the value of this feature worth keeping global type inference in the Swift language, when we have deliberatively avoided global type inference elsewhere in the language?<br></p><p>I’m totally fine to see it go away. I’ve already gotten into the habit of specifying the types explicitly (due to nonsense errors thrown when the compiler can’t properly infer it). It feels slightly strange because the type inference is spooky action at a distance (especially if the protocol conformance happens in an extension).<br></p><p><br>&gt; <br>&gt; Existentials<br>&gt; <br>&gt; Existentials aren’t really generics per se, but the two systems are closely intertwined due to their mutable dependence on protocols.<br>&gt; <br>&gt; *Generalized existentials<br>&gt; <br>&gt; The restrictions on existential types came from an implementation limitation, but it is reasonable to allow a value of protocol type even when the protocol has Self constraints or associated types. For example, consider IteratorProtocol again and how it could be used as an existential:<br>&gt; <br>&gt; protocol IteratorProtocol {<br>&gt;   associatedtype Element<br>&gt;   mutating func next() -&gt; Element?<br>&gt; }<br>&gt; <br>&gt; let it: IteratorProtocol = …<br>&gt; it.next()   // if this is permitted, it could return an “Any?”, i.e., the existential that wraps the actual element<br>&gt; <br>&gt; Additionally, it is reasonable to want to constrain the associated types of an existential, e.g., “a Sequence whose element type is String” could be expressed by putting a where clause into “protocol&lt;…&gt;” or “Any&lt;…&gt;” (per “Renaming protocol&lt;…&gt; to Any&lt;…&gt;”):<br>&gt; <br>&gt; let strings: Any&lt;Sequence where .Iterator.Element == String&gt; = [“a”, “b”, “c”]<br>&gt; <br>&gt; The leading “.” indicates that we’re talking about the dynamic type, i.e., the “Self” type that’s conforming to the Sequence protocol. There’s no reason why we cannot support arbitrary “where” clauses within the “Any&lt;…&gt;”. This very-general syntax is a bit unwieldy, but common cases can easily be wrapped up in a generic typealias (see the section “Generic typealiases” above):<br>&gt; <br>&gt; typealias AnySequence&lt;Element&gt; = Any&lt;Sequence where .Iterator.Element == Element&gt;<br>&gt; let strings: AnySequence&lt;String&gt; = [“a”, “b”, “c”]<br>&gt; <br></p><p>Free opinions on the internet are worth what you pay for them, but I’ll just say that if I were in charge of the Swift 3 schedule it wouldn’t ship without this feature. I feel extremely strongly that this is necessary to round out generics support. Trying to write an app that is heavily protocol-oriented and makes use of lots of generics runs into existential (ha!) walls constantly. It forces you to choose 100% anything-goes-dynamic (ala Objective-C) or jump through tons of hoops to get type safety.<br></p><p><br>&gt; <br>&gt; Opening existentials<br>&gt; <br>&gt; Generalized existentials as described above will still have trouble with protocol requirements that involve Self or associated types in function parameters. For example, let’s try to use Equatable as an existential:<br>&gt; <br>&gt; protocol Equatable {<br>&gt;   func ==(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;   func !=(lhs: Self, rhs: Self) -&gt; Bool<br>&gt; }<br>&gt; <br>&gt; let e1: Equatable = …<br>&gt; let e2: Equatable = …<br>&gt; if e1 == e2 { … } // error: e1 and e2 don’t necessarily have the same dynamic type<br>&gt; <br>&gt; One explicit way to allow such operations in a type-safe manner is to introduce an “open existential” operation of some sort, which extracts and gives a name to the dynamic type stored inside an existential. For example:<br>&gt; <br>&gt; 	 <br>&gt; if let storedInE1 = e1 openas T {     // T is a the type of storedInE1, a copy of the value stored in e1<br>&gt;   if let storedInE2 = e2 as? T {      // is e2 also a T?<br>&gt;     if storedInE1 == storedInE2 { … } // okay: storedInT1 and storedInE2 are both of type T, which we know is Equatable<br>&gt;   }<br>&gt; }<br></p><p>Everything on existentials gets a huge +1 from me.<br></p><p><br></p><p>Overall I’d rate conditional conformance, parameterized extensions, and generalized existentials as the highest priority items. <br></p><p>Generalized existentials have no effective workarounds and they have a huge impact on the design of API contracts and even how you use protocols themselves so they are a big pain point for me personally.<br></p><p><br>Russ<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160404/0a22d55b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Manifesto] Completing Generics</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>May  3, 2016 at 12:00:00am</p></header><div class="content"><p>I’d like to continue moving Completing Generics forward for Swift 3 with proposals. Can Douglas, or someone from the core team, tell me if the topics mentioned in Removing unnecessary restrictions require proposals or if bug reports should be opened for them instead?<br></p><p>&gt; On 03 Mar 2016, at 02:22, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; Introduction<br>&gt; <br>&gt; The “Complete Generics” goal for Swift 3 has been fairly ill-defined thus fair, with just this short blurb in the list of goals:<br>&gt; <br>&gt; Complete generics: Generics are used pervasively in a number of Swift libraries, especially the standard library. However, there are a number of generics features the standard library requires to fully realize its vision, including recursive protocol constraints, the ability to make a constrained extension conform to a new protocol (i.e., an array of Equatable elements is Equatable), and so on. Swift 3.0 should provide those generics features needed by the standard library, because they affect the standard library&#39;s ABI.<br>&gt; This message expands upon the notion of “completing generics”. It is not a plan for Swift 3, nor an official core team communication, but it collects the results of numerous discussions among the core team and Swift developers, both of the compiler and the standard library. I hope to achieve several things:<br>&gt; <br>&gt; Communicate a vision for Swift generics, building on the original generics design document &lt;https://github.com/apple/swift/blob/master/docs/Generics.rst&gt;, so we have something concrete and comprehensive to discuss.<br>&gt; Establish some terminology that the Swift developers have been using for these features, so our discussions can be more productive (“oh, you’re proposing what we refer to as ‘conditional conformances’; go look over at this thread”).<br>&gt; Engage more of the community in discussions of specific generics features, so we can coalesce around designs for public review. And maybe even get some of them implemented.<br>&gt; <br>&gt; A message like this can easily turn into a centithread &lt;http://www.urbandictionary.com/define.php?term=centithread&gt;. To separate concerns in our discussion, I ask that replies to this specific thread be limited to discussions of the vision as a whole: how the pieces fit together, what pieces are missing, whether this is the right long-term vision for Swift, and so on. For discussions of specific language features, e.g., to work out the syntax and semantics of conditional conformances or discuss the implementation in compiler or use in the standard library, please start a new thread based on the feature names I’m using.<br>&gt; <br>&gt; This message covers a lot of ground; I’ve attempted a rough categorization of the various features, and kept the descriptions brief to limit the overall length. Most of these aren’t my ideas, and any syntax I’m providing is simply a way to express these ideas in code and is subject to change. Not all of these features will happen, either soon or ever, but they are intended to be a fairly complete whole that should mesh together. I’ve put a * next to features that I think are important in the nearer term vs. being interesting “some day”. Mostly, the *’s reflect features that will have a significant impact on the Swift standard library’s design and implementation.<br>&gt; <br>&gt; Enough with the disclaimers; it’s time to talk features.<br>&gt; <br>&gt; Removing unnecessary restrictions<br>&gt; <br>&gt; There are a number of restrictions to the use of generics that fall out of the implementation in the Swift compiler. Removal of these restrictions is a matter of implementation only; one need not introduce new syntax or semantics to realize them. I’m listing them for two reasons: first, it’s an acknowledgment that these features are intended to exist in the model we have today, and, second, we’d love help with the implementation of these features.<br>&gt; <br>&gt; <br>&gt; *Recursive protocol constraints<br>&gt; <br>&gt; Currently, an associated type cannot be required to conform to its enclosing protocol (or any protocol that inherits that protocol). For example, in the standard library SubSequence type of a Sequence should itself be a Sequence:<br>&gt; <br>&gt; protocol Sequence {<br>&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;   …<br>&gt;   associatedtype SubSequence : Sequence   // currently ill-formed, but should be possible<br>&gt; }<br>&gt; <br>&gt; The compiler currently rejects this protocol, which is unfortunate: it effectively pushes the SubSequence-must-be-a-Sequence requirement into every consumer of SubSequence, and does not communicate the intent of this abstraction well.<br>&gt; <br>&gt; Nested generics<br>&gt; <br>&gt; Currently, a generic type cannot be nested within another generic type, e.g.<br>&gt; <br>&gt; struct X&lt;T&gt; {<br>&gt;   struct Y&lt;U&gt; { }  // currently ill-formed, but should be possible<br>&gt; }<br>&gt; <br>&gt; There isn’t much to say about this: the compiler simply needs to be improved to handle nested generics throughout.<br>&gt; <br>&gt; <br>&gt; Concrete same-type requirements<br>&gt; <br>&gt; Currently, a constrained extension cannot use a same-type constraint to make a type parameter equivalent to a concrete type. For example:<br>&gt; <br>&gt; extension Array where Element == String {<br>&gt;   func makeSentence() -&gt; String {<br>&gt;     // uppercase first string, concatenate with spaces, add a period, whatever<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; This is a highly-requested feature that fits into the existing syntax and semantics. Note that one could imagine introducing new syntax, e.g., extending “Array&lt;String&gt;”, which gets into new-feature territory: see the section on “Parameterized extensions”.<br>&gt; <br>&gt; Parameterizing other declarations<br>&gt; <br>&gt; There are a number of Swift declarations that currently cannot have generic parameters; some of those have fairly natural extensions to generic forms that maintain their current syntax and semantics, but become more powerful when made generic.<br>&gt; <br>&gt; Generic typealiases<br>&gt; <br>&gt; Typealiases could be allowed to carry generic parameters. They would still be aliases (i.e., they would not introduce new types). For example:<br>&gt; <br>&gt; typealias StringDictionary&lt;Value&gt; = Dictionary&lt;String, Value&gt;<br>&gt; <br>&gt; var d1 = StringDictionary&lt;Int&gt;()<br>&gt; var d2: Dictionary&lt;String, Int&gt; = d1 // okay: d1 and d2 have the same type, Dictionary&lt;String, Int&gt;<br>&gt; <br>&gt; <br>&gt; Generic subscripts<br>&gt; <br>&gt; Subscripts could be allowed to have generic parameters. For example, we could introduce a generic subscript on a Collection that allows us to pull out the values at an arbitrary set of indices:<br>&gt; <br>&gt; extension Collection {<br>&gt;   subscript&lt;Indices: Sequence where Indices.Iterator.Element == Index&gt;(indices: Indices) -&gt; [Iterator.Element] {<br>&gt;     get {<br>&gt;       var result = [Iterator.Element]()<br>&gt;       for index in indices {<br>&gt;         result.append(self[index])<br>&gt;       }<br>&gt; <br>&gt;       return result<br>&gt;     }<br>&gt; <br>&gt;     set {<br>&gt;       for (index, value) in zip(indices, newValue) {<br>&gt;         self[index] = value<br>&gt;       }<br>&gt;     }<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; Generic constants<br>&gt; <br>&gt; let constants could be allowed to have generic parameters, such that they produce differently-typed values depending on how they are used. For example, this is particularly useful for named literal values, e.g.,<br>&gt; <br>&gt; let π&lt;T : FloatLiteralConvertible&gt;: T = 3.141592653589793238462643383279502884197169399<br>&gt; <br>&gt; The Clang importer could make particularly good use of this when importing macros.<br>&gt; <br>&gt; <br>&gt; Parameterized extensions<br>&gt; <br>&gt; Extensions themselves could be parameterized, which would allow some structural pattern matching on types. For example, this would permit one to extend an array of optional values, e.g.,<br>&gt; <br>&gt; extension&lt;T&gt; Array where Element == T? {<br>&gt;   var someValues: [T] {<br>&gt;     var result = [T]()<br>&gt;     for opt in self {<br>&gt;       if let value = opt { result.append(value) }<br>&gt;     }<br>&gt;    return result<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; We can generalize this to a protocol extensions:<br>&gt; <br>&gt; extension&lt;T&gt; Sequence where Element == T? {<br>&gt;   var someValues: [T] {<br>&gt;     var result = [T]()<br>&gt;     for opt in self {<br>&gt;       if let value = opt { result.append(value) }<br>&gt;     }<br>&gt;    return result<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; Note that when one is extending nominal types, we could simplify the syntax somewhat to make the same-type constraint implicit in the syntax:<br>&gt; <br>&gt; extension&lt;T&gt; Array&lt;T?&gt; {<br>&gt;   var someValues: [T] {<br>&gt;     var result = [T]()<br>&gt;     for opt in self {<br>&gt;       if let value = opt { result.append(value) }<br>&gt;     }<br>&gt;    return result<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; When we’re working with concrete types, we can use that syntax to improve the extension of concrete versions of generic types (per “Concrete same-type requirements”, above), e.g.,<br>&gt; <br>&gt; extension Array&lt;String&gt; {<br>&gt;   func makeSentence() -&gt; String {<br>&gt;     // uppercase first string, concatenate with spaces, add a period, whatever<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; Minor extensions<br>&gt; <br>&gt; There are a number of minor extensions we can make to the generics system that don’t fundamentally change what one can express in Swift, but which can improve its expressivity.<br>&gt; <br>&gt; *Arbitrary requirements in protocols<br>&gt; <br>&gt; Currently, a new protocol can inherit from other protocols, introduce new associated types, and add new conformance constraints to associated types (by redeclaring an associated type from an inherited protocol). However, one cannot express more general constraints. Building on the example from “Recursive protocol constraints”, we really want the element type of a Sequence’s SubSequence to be the same as the element type of the Sequence, e.g.,<br>&gt; <br>&gt; protocol Sequence {<br>&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;   …<br>&gt;   associatedtype SubSequence : Sequence where SubSequence.Iterator.Element == Iterator.Element<br>&gt; }<br>&gt; <br>&gt; Hanging the where clause off the associated type is protocol not ideal, but that’s a discussion for another thread.<br>&gt; <br>&gt; <br>&gt; *Typealiases in protocols and protocol extensions<br>&gt; <br>&gt; Now that associated types have their own keyword (thanks!), it’s reasonable to bring back “typealias”. Again with the Sequence protocol:<br>&gt; <br>&gt; protocol Sequence {<br>&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;   typealias Element = Iterator.Element   // rejoice! now we can refer to SomeSequence.Element rather than SomeSequence.Iterator.Element<br>&gt; }<br>&gt; <br>&gt; <br>&gt; Default generic arguments <br>&gt; <br>&gt; Generic parameters could be given the ability to provide default arguments, which would be used in cases where the type argument is not specified and type inference could not determine the type argument. For example:<br>&gt; <br>&gt; public final class Promise&lt;Value, Reason=Error&gt; { … }<br>&gt; <br>&gt; func getRandomPromise() -&gt; Promise&lt;Int, ErrorProtocol&gt; { … }<br>&gt; <br>&gt; var p1: Promise&lt;Int&gt; = …<br>&gt; var p2: Promise&lt;Int, Error&gt; = p1     // okay: p1 and p2 have the same type Promise&lt;Int, Error&gt;<br>&gt; var p3: Promise = getRandomPromise() // p3 has type Promise&lt;Int, ErrorProtocol&gt; due to type inference<br>&gt; <br>&gt; <br>&gt; Generalized “class” constraints<br>&gt; <br>&gt; The “class” constraint can currently only be used for defining protocols. We could generalize it to associated type and type parameter declarations, e.g.,<br>&gt; <br>&gt; protocol P {<br>&gt;   associatedtype A : class<br>&gt; }<br>&gt; <br>&gt; func foo&lt;T : class&gt;(t: T) { }<br>&gt; <br>&gt; As part of this, the magical AnyObject protocol could be replaced with an existential with a class bound, so that it becomes a typealias:<br>&gt; <br>&gt; typealias AnyObject = protocol&lt;class&gt;<br>&gt; <br>&gt; See the “Existentials” section, particularly “Generalized existentials”, for more information.<br>&gt; <br>&gt; <br>&gt; *Allowing subclasses to override requirements satisfied by defaults<br>&gt; <br>&gt; When a superclass conforms to a protocol and has one of the protocol’s requirements satisfied by a member of a protocol extension, that member currently cannot be overridden by a subclass. For example:<br>&gt; <br>&gt; protocol P {<br>&gt;   func foo()<br>&gt; }<br>&gt; <br>&gt; extension P {<br>&gt;   func foo() { print(“P”) }<br>&gt; }<br>&gt; <br>&gt; class C : P {<br>&gt;   // gets the protocol extension’s <br>&gt; }<br>&gt; <br>&gt; class D : C {<br>&gt;   /*override not allowed!*/ func foo() { print(“D”) }<br>&gt; }<br>&gt; <br>&gt; let p: P = D()<br>&gt; p.foo() // gotcha: prints “P” rather than “D”!<br>&gt; <br>&gt; D.foo should be required to specify “override” and should be called dynamically.<br>&gt; <br>&gt; <br>&gt; Major extensions to the generics model<br>&gt; <br>&gt; Unlike the minor extensions, major extensions to the generics model provide more expressivity in the Swift generics system and, generally, have a much more significant design and implementation cost.<br>&gt; <br>&gt; <br>&gt; *Conditional conformances<br>&gt; <br>&gt; Conditional conformances express the notion that a generic type will conform to a particular protocol only under certain circumstances. For example, Array is Equatable only when its elements are Equatable:<br>&gt; <br>&gt; extension Array : Equatable where Element : Equatable { }<br>&gt; <br>&gt; func ==&lt;T : Equatable&gt;(lhs: Array&lt;T&gt;, rhs: Array&lt;T&gt;) -&gt; Bool { … }<br>&gt; <br>&gt; Conditional conformances are a potentially very powerful feature. One important aspect of this feature is how deal with or avoid overlapping conformances. For example, imagine an adaptor over a Sequence that has conditional conformances to Collection and MutableCollection:<br>&gt; <br>&gt; struct SequenceAdaptor&lt;S: Sequence&gt; : Sequence { }<br>&gt; extension SequenceAdaptor : Collection where S: Collection { … }<br>&gt; extension SequenceAdaptor : MutableCollection where S: MutableCollection { }<br>&gt; <br>&gt; This should almost certainly be permitted, but we need to cope with or reject “overlapping” conformances:<br>&gt; <br>&gt; extension SequenceAdaptor : Collection where S: SomeOtherProtocolSimilarToCollection { } // trouble: two ways for SequenceAdaptor to conform to Collection<br>&gt; <br>&gt; See the section on “Private conformances” for more about the issues with having the same type conform to the same protocol multiple times.<br>&gt; <br>&gt; <br>&gt; Variadic generics<br>&gt; <br>&gt; Currently, a generic parameter list contains a fixed number of generic parameters. If one has a type that could generalize to any number of generic parameters, the only real way to deal with it today involves creating a set of types. For example, consider the standard library’s “zip” function. It returns one of these when provided with two arguments to zip together:<br>&gt; <br>&gt; public struct Zip2Sequence&lt;Sequence1 : Sequence,<br>&gt;                            Sequence2 : Sequence&gt; : Sequence { … }<br>&gt; <br>&gt; public func zip&lt;Sequence1 : Sequence, Sequence2 : Sequence&gt;(<br>&gt;               sequence1: Sequence1, _ sequence2: Sequence2)<br>&gt;             -&gt; Zip2Sequence&lt;Sequence1, Sequence2&gt; { … }<br>&gt; <br>&gt; Supporting three arguments would require copy-paste of those of those:<br>&gt; <br>&gt; public struct Zip3Sequence&lt;Sequence1 : Sequence,<br>&gt;                            Sequence2 : Sequence,<br>&gt;                            Sequence3 : Sequence&gt; : Sequence { … }<br>&gt; <br>&gt; public func zip&lt;Sequence1 : Sequence, Sequence2 : Sequence, Sequence3 : Sequence&gt;(<br>&gt;               sequence1: Sequence1, _ sequence2: Sequence2, _ sequence3: sequence3)<br>&gt;             -&gt; Zip3Sequence&lt;Sequence1, Sequence2, Sequence3&gt; { … }<br>&gt; <br>&gt; Variadic generics would allow us to abstract over a set of generic parameters. The syntax below is hopelessly influenced by C++11 variadic templates &lt;http://www.jot.fm/issues/issue_2008_02/article2/&gt; (sorry), where putting an ellipsis (“…”) to the left of a declaration makes it a “parameter pack” containing zero or more parameters and putting an ellipsis to the right of a type/expression/etc. expands the parameter packs within that type/expression into separate arguments. The important part is that we be able to meaningfully abstract over zero or more generic parameters, e.g.:<br>&gt; <br>&gt; public struct ZipIterator&lt;... Iterators : IteratorProtocol&gt; : Iterator {  // zero or more type parameters, each of which conforms to IteratorProtocol<br>&gt;   public typealias Element = (Iterators.Element...)                       // a tuple containing the element types of each iterator in Iterators<br>&gt; <br>&gt;   var (...iterators): (Iterators...)    // zero or more stored properties, one for each type in Iterators <br>&gt;   var reachedEnd: Bool = false<br>&gt; <br>&gt;   public mutating func next() -&gt; Element? {<br>&gt;     if reachedEnd { return nil }<br>&gt; <br>&gt;     guard let values = (iterators.next()...) {   // call “next” on each of the iterators, put the results into a tuple named “values&quot;<br>&gt;       reachedEnd = true<br>&gt;       return nil<br>&gt;     }<br>&gt; <br>&gt;     return values<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; public struct ZipSequence&lt;...Sequences : Sequence&gt; : Sequence {<br>&gt;   public typealias Iterator = ZipIterator&lt;Sequences.Iterator...&gt;   // get the zip iterator with the iterator types of our Sequences<br>&gt; <br>&gt;   var (...sequences): (Sequences...)    // zero or more stored properties, one for each type in Sequences <br>&gt; <br>&gt;   // details ...<br>&gt; }<br>&gt; <br>&gt; Such a design could also work for function parameters, so we can pack together multiple function arguments with different types, e.g.,<br>&gt; <br>&gt; public func zip&lt;... Sequences : SequenceType&gt;(... sequences: Sequences...) <br>&gt;             -&gt; ZipSequence&lt;Sequences...&gt; {<br>&gt;   return ZipSequence(sequences...)<br>&gt; }<br>&gt; <br>&gt; Finally, this could tie into the discussions about a tuple “splat” operator. For example:<br>&gt; <br>&gt; func apply&lt;... Args, Result&gt;(fn: (Args...) -&gt; Result,    // function taking some number of arguments and producing Result<br>&gt;                            args: (Args...)) -&gt; Result {  // tuple of arguments<br>&gt;   return fn(args...)                                     // expand the arguments in the tuple “args” into separate arguments<br>&gt; }<br>&gt; <br>&gt; <br>&gt; Extensions of structural types<br>&gt; <br>&gt; Currently, only nominal types (classes, structs, enums, protocols) can be extended. One could imagine extending structural types—particularly tuple types—to allow them to, e.g., conform to protocols. For example, pulling together variadic generics, parameterized extensions, and conditional conformances, one could express “a tuple type is Equatable if all of its element types are Equatable”:<br>&gt; <br>&gt; extension&lt;...Elements : Equatable&gt; (Elements...) : Equatable {   // extending the tuple type “(Elements…)” to be Equatable<br>&gt; }<br>&gt; <br>&gt; There are some natural bounds here: one would need to have actual structural types. One would not be able to extend every type:<br>&gt; <br>&gt; extension&lt;T&gt; T { // error: neither a structural nor a nominal type<br>&gt; }<br>&gt; <br>&gt; And before you think you’re cleverly making it possible to have a conditional conformance that makes every type T that conforms to protocol P also conform to protocol Q, see the section &quot;Conditional conformances via protocol extensions”, below:<br>&gt; <br>&gt; extension&lt;T : P&gt; T : Q { // error: neither a structural nor a nominal type<br>&gt; }<br>&gt; <br>&gt; <br>&gt; Syntactic improvements<br>&gt; <br>&gt; There are a number of potential improvements we could make to the generics syntax. Such a list could go on for a very long time, so I’ll only highlight some obvious ones that have been discussed by the Swift developers.<br>&gt; <br>&gt; *Default implementations in protocols<br>&gt; <br>&gt; Currently, protocol members can never have implementations. We could allow one to provide such implementations to be used as the default if a conforming type does not supply an implementation, e.g.,<br>&gt; <br>&gt; protocol Bag {<br>&gt;   associatedtype Element : Equatable<br>&gt;   func contains(element: Element) -&gt; Bool<br>&gt; <br>&gt;   func containsAll&lt;S: Sequence where Sequence.Iterator.Element == Element&gt;(elements: S) -&gt; Bool {<br>&gt;     for x in elements {<br>&gt;       if contains(x) { return true }<br>&gt;     }<br>&gt;     return false<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; struct IntBag : Bag {<br>&gt;   typealias Element = Int<br>&gt;   func contains(element: Int) -&gt; Bool { ... }<br>&gt; <br>&gt;   // okay: containsAll requirement is satisfied by Bag’s default implementation<br>&gt; }<br>&gt; <br>&gt; One can get this effect with protocol extensions today, hence the classification of this feature as a (mostly) syntactic improvement:<br>&gt; <br>&gt; protocol Bag {<br>&gt;   associatedtype Element : Equatable<br>&gt;   func contains(element: Element) -&gt; Bool<br>&gt; <br>&gt;   func containsAll&lt;S: Sequence where Sequence.Iterator.Element == Element&gt;(elements: S) -&gt; Bool<br>&gt; }<br>&gt; <br>&gt; extension Bag {<br>&gt;   func containsAll&lt;S: Sequence where Sequence.Iterator.Element == Element&gt;(elements: S) -&gt; Bool {<br>&gt;     for x in elements {<br>&gt;       if contains(x) { return true }<br>&gt;     }<br>&gt;     return false<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; *Moving the where clause outside of the angle brackets<br>&gt; <br>&gt; The “where” clause of generic functions comes very early in the declaration, although it is generally of much less concern to the client than the function parameters and result type that follow it. This is one of the things that contributes to “angle bracket blindness”. For example, consider the containsAll signature above:<br>&gt; <br>&gt; func containsAll&lt;S: Sequence where Sequence.Iterator.Element == Element&gt;(elements: S) -&gt; Bool<br>&gt; <br>&gt; One could move the “where” clause to the end of the signature, so that the most important parts—name, generic parameter, parameters, result type—precede it:<br>&gt; <br>&gt; func containsAll&lt;S: Sequence&gt;(elements: S) -&gt; Bool <br>&gt;        where Sequence.Iterator.Element == Element<br>&gt; <br>&gt; <br>&gt; *Renaming “protocol&lt;…&gt;” to “Any&lt;…&gt;”.<br>&gt; <br>&gt; The “protocol&lt;…&gt;” syntax is a bit of an oddity in Swift. It is used to compose protocols together, mostly to create values of existential type, e.g.,<br>&gt; <br>&gt; var x: protocol&lt;NSCoding, NSCopying&gt;<br>&gt; <br>&gt; It’s weird that it’s a type name that starts with a lowercase letter, and most Swift developers probably never deal with this feature unless they happen to look at the definition of Any:<br>&gt; <br>&gt; typealias Any = protocol&lt;&gt;<br>&gt; <br>&gt; “Any” might be a better name for this functionality. “Any” without brackets could be a keyword for “any type”, and “Any” followed by brackets could take the role of “protocol&lt;&gt;” today:<br>&gt; <br>&gt; var x: Any&lt;NSCoding, NSCopying&gt;<br>&gt; <br>&gt; That reads much better: “Any type that conforms to NSCoding and NSCopying”. See the section &quot;Generalized existentials” for additional features in this space.<br>&gt; <br>&gt; Maybe<br>&gt; <br>&gt; There are a number of features that get discussed from time-to-time, while they could fit into Swift’s generics system, it’s not clear that they belong in Swift at all. The important question for any feature in this category is not “can it be done” or “are there cool things we can express”, but “how can everyday Swift developers benefit from the addition of such a feature?”. Without strong motivating examples, none of these “maybes” will move further along.<br>&gt; <br>&gt; Dynamic dispatch for members of protocol extensions<br>&gt; <br>&gt; Only the requirements of protocols currently use dynamic dispatch, which can lead to surprises:<br>&gt; <br>&gt; protocol P {<br>&gt;   func foo()<br>&gt; }<br>&gt; <br>&gt; extension P {<br>&gt;   func foo() { print(“P.foo()”)<br>&gt;   func bar() { print(“P.bar()”)<br>&gt; }<br>&gt; <br>&gt; struct X : P {<br>&gt;   func foo() { print(“X.foo()”)<br>&gt;   func bar() { print(“X.bar()”)<br>&gt; }<br>&gt; <br>&gt; let x = X()<br>&gt; x.foo() // X.foo()<br>&gt; x.bar() // X.bar()<br>&gt; <br>&gt; let p: P = X()<br>&gt; p.foo() // X.foo()<br>&gt; p.bar() // P.bar()<br>&gt; <br>&gt; Swift could adopt a model where members of protocol extensions are dynamically dispatched.<br>&gt; <br>&gt; Named generic parameters<br>&gt; <br>&gt; When specifying generic arguments for a generic type, the arguments are always positional: Dictionary&lt;String, Int&gt; is a Dictionary whose Key type is String and whose Value type is Int, by convention. One could permit the arguments to be labeled, e.g.,<br>&gt; <br>&gt; var d: Dictionary&lt;Key: String, Value: Int&gt;<br>&gt; <br>&gt; Such a feature makes more sense if Swift gains default generic arguments, because generic argument labels would allow one to skip defaulted arguments.<br>&gt; <br>&gt; Generic value parameters<br>&gt; <br>&gt; Currently, Swift’s generic parameters are always types. One could imagine allowing generic parameters that are values, e.g.,<br>&gt; <br>&gt; struct MultiArray&lt;T, let Dimensions: Int&gt; { // specify the number of dimensions to the array<br>&gt;   subscript (indices: Int...) -&gt; T {<br>&gt;     get {<br>&gt;       require(indices.count == Dimensions)<br>&gt;       // ...<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; A suitably general feature might allow us to express fixed-length array or vector types as a standard library component, and perhaps also allow one to implement a useful dimensional analysis library. Tackling this feature potentially means determining what it is for an expression to be a “constant expression” and diving into dependent-typing, hence the “maybe”.<br>&gt; <br>&gt; Higher-kinded types<br>&gt; <br>&gt; Higher-kinded types allow one to express the relationship between two different specializations of the same nominal type within a protocol. For example, if we think of the Self type in a protocol as really being “Self&lt;T&gt;”, it allows us to talk about the relationship between “Self&lt;T&gt;” and “Self&lt;U&gt;” for some other type U. For example, it could allow the “map” operation on a collection to return a collection of the same kind but with a different operation, e.g.,<br>&gt; <br>&gt; let intArray: Array&lt;Int&gt; = …<br>&gt; intArray.map { String($0) } // produces Array&lt;String&gt;<br>&gt; let intSet: Set&lt;Int&gt; = …<br>&gt; intSet.map { String($0) }   // produces Set&lt;String&gt;<br>&gt; <br>&gt; <br>&gt; Potential syntax borrowed from one thread on higher-kinded types &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002736.html&gt; uses ~= as a “similarity” constraint to describe a Functor protocol:<br>&gt; <br>&gt; protocol Functor {<br>&gt;   associatedtype A<br>&gt;   func fmap&lt;FB where FB ~= Self&gt;(f: A -&gt; FB.A) -&gt; FB<br>&gt; }<br>&gt; <br>&gt; <br>&gt; Specifying type arguments for uses of generic functions<br>&gt; <br>&gt; The type arguments of a generic function are always determined via type inference. For example, given:<br>&gt; <br>&gt; func f&lt;T&gt;(t: T)<br>&gt; <br>&gt; one cannot directly specify T: either one calls “f” (and T is determined via the argument’s type) or one uses “f” in a context where it is given a particular function type (e.g., “let x: (Int) -&gt; Void = f”  would infer T = Int). We could permit explicit specialization here, e.g.,<br>&gt; <br>&gt; let x = f&lt;Int&gt; // x has type (Int) -&gt; Void<br>&gt; <br>&gt; <br>&gt; Unlikely<br>&gt; <br>&gt; Features in this category have been requested at various times, but they don’t fit well with Swift’s generics system because they cause some part of the model to become overly complicated, have unacceptable implementation limitations, or overlap significantly with existing features.<br>&gt; <br>&gt; Generic protocols<br>&gt; <br>&gt; One of the most commonly requested features is the ability to parameterize protocols themselves. For example, a protocol that indicates that the Self type can be constructed from some specified type T:<br>&gt; <br>&gt; protocol ConstructibleFromValue&lt;T&gt; {<br>&gt;   init(_ value: T)<br>&gt; }<br>&gt; <br>&gt; Implicit in this feature is the ability for a given type to conform to the protocol in two different ways. A “Real” type might be constructible from both Float and Double, e.g.,<br>&gt; <br>&gt; struct Real { … }<br>&gt; extension Real : ConstructibleFrom&lt;Float&gt; {<br>&gt;   init(_ value: Float) { … }<br>&gt; }<br>&gt; extension Real : ConstructibleFrom&lt;Double&gt; {<br>&gt;   init(_ value: Double) { … }<br>&gt; }<br>&gt; <br>&gt; Most of the requests for this feature actually want a different feature. They tend to use a parameterized Sequence as an example, e.g.,<br>&gt; <br>&gt; protocol Sequence&lt;Element&gt; { … }<br>&gt; <br>&gt; func foo(strings: Sequence&lt;String&gt;) {  /// works on any sequence containing Strings<br>&gt;   // ...<br>&gt; }<br>&gt; <br>&gt; The actual requested feature here 	is the ability to say “Any type that conforms to Sequence whose Element type is String”, which is covered by the section on “Generalized existentials”, below.<br>&gt; <br>&gt; More importantly, modeling Sequence with generic parameters rather than associated types is tantalizing but wrong: you don’t want a type conforming to Sequence in multiple ways, or (among other things) your for..in loops stop working, and you lose the ability to dynamically cast down to an existential “Sequence” without binding the Element type (again, see “Generalized existentials”). Use cases similar to the ConstructibleFromValue protocol above seem too few to justify the potential for confusion between associated types and generic parameters of protocols; we’re better off not having the latter.<br>&gt; <br>&gt; <br>&gt; Private conformances <br>&gt; <br>&gt; Right now, a protocol conformance can be no less visible than the minimum of the conforming type’s access and the protocol’s access. Therefore, a public type conforming to a public protocol must provide the conformance publicly. One could imagine removing that restriction, so that one could introduce a private conformance:<br>&gt; <br>&gt; public protocol P { }<br>&gt; public struct X { }<br>&gt; extension X : internal P { … } // X conforms to P, but only within this module<br>&gt; <br>&gt; The main problem with private conformances is the interaction with dynamic casting. If I have this code:<br>&gt; <br>&gt; func foo(value: Any) {<br>&gt;   if let x = value as? P { print(“P”) }<br>&gt; }<br>&gt; <br>&gt; foo(X())<br>&gt; <br>&gt; Under what circumstances should it print “P”? If foo() is defined within the same module as the conformance of X to P? If the call is defined within the same module as the conformance of X to P? Never? Either of the first two answers requires significant complications in the dynamic casting infrastructure to take into account the module in which a particular dynamic cast occurred (the first option) or where an existential was formed (the second option), while the third answer breaks the link between the static and dynamic type systems—none of which is an acceptable result.<br>&gt; <br>&gt; Conditional conformances via protocol extensions<br>&gt; <br>&gt; We often get requests to make a protocol conform to another protocol. This is, effectively, the expansion of the notion of “Conditional conformances” to protocol extensions. For example:<br>&gt; <br>&gt; protocol P {<br>&gt;   func foo()<br>&gt; }<br>&gt; <br>&gt; protocol Q {<br>&gt;   func bar()<br>&gt; }<br>&gt; <br>&gt; extension Q : P { // every type that conforms to Q also conforms to P<br>&gt;   func foo() {    // implement “foo” requirement in terms of “bar&quot;<br>&gt;     bar()<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; func f&lt;T: P&gt;(t: T) { … }<br>&gt; <br>&gt; struct X : Q {<br>&gt;   func bar() { … }<br>&gt; }<br>&gt; <br>&gt; f(X()) // okay: X conforms to P through the conformance of Q to P<br>&gt; <br>&gt; This is an extremely powerful feature: is allows one to map the abstractions of one domain into another domain (e.g., every Matrix is a Graph). However, similar to private conformances, it puts a major burden on the dynamic-casting runtime to chase down arbitrarily long and potentially cyclic chains of conformances, which makes efficient implementation nearly impossible.<br>&gt; <br>&gt; Potential removals<br>&gt; <br>&gt; The generics system doesn’t seem like a good candidate for a reduction in scope; most of its features do get used fairly pervasively in the standard library, and few feel overly anachronistic. However...<br>&gt; <br>&gt; Associated type inference<br>&gt; <br>&gt; Associated type inference is the process by which we infer the type bindings for associated types from other requirements. For example:<br>&gt; <br>&gt; protocol IteratorProtocol {<br>&gt;   associatedtype Element<br>&gt;   mutating func next() -&gt; Element?<br>&gt; }<br>&gt; <br>&gt; struct IntIterator : IteratorProtocol {<br>&gt;   mutating func next() -&gt; Int? { … }  // use this to infer Element = Int<br>&gt; }<br>&gt; <br>&gt; Associated type inference is a useful feature. It’s used throughout the standard library, and it helps keep associated types less visible to types that simply want to conform to a protocol. On the other hand, associated type inference is the only place in Swift where we have a global type inference problem: it has historically been a major source of bugs, and implementing it fully and correctly requires a drastically different architecture to the type checker. Is the value of this feature worth keeping global type inference in the Swift language, when we have deliberatively avoided global type inference elsewhere in the language?<br>&gt; <br>&gt; <br>&gt; Existentials<br>&gt; <br>&gt; Existentials aren’t really generics per se, but the two systems are closely intertwined due to their mutable dependence on protocols.<br>&gt; <br>&gt; *Generalized existentials<br>&gt; <br>&gt; The restrictions on existential types came from an implementation limitation, but it is reasonable to allow a value of protocol type even when the protocol has Self constraints or associated types. For example, consider IteratorProtocol again and how it could be used as an existential:<br>&gt; <br>&gt; protocol IteratorProtocol {<br>&gt;   associatedtype Element<br>&gt;   mutating func next() -&gt; Element?<br>&gt; }<br>&gt; <br>&gt; let it: IteratorProtocol = …<br>&gt; it.next()   // if this is permitted, it could return an “Any?”, i.e., the existential that wraps the actual element<br>&gt; <br>&gt; Additionally, it is reasonable to want to constrain the associated types of an existential, e.g., “a Sequence whose element type is String” could be expressed by putting a where clause into “protocol&lt;…&gt;” or “Any&lt;…&gt;” (per “Renaming protocol&lt;…&gt; to Any&lt;…&gt;”):<br>&gt; <br>&gt; let strings: Any&lt;Sequence where .Iterator.Element == String&gt; = [“a”, “b”, “c”]<br>&gt; <br>&gt; The leading “.” indicates that we’re talking about the dynamic type, i.e., the “Self” type that’s conforming to the Sequence protocol. There’s no reason why we cannot support arbitrary “where” clauses within the “Any&lt;…&gt;”. This very-general syntax is a bit unwieldy, but common cases can easily be wrapped up in a generic typealias (see the section “Generic typealiases” above):<br>&gt; <br>&gt; typealias AnySequence&lt;Element&gt; = Any&lt;Sequence where .Iterator.Element == Element&gt;<br>&gt; let strings: AnySequence&lt;String&gt; = [“a”, “b”, “c”]<br>&gt; <br>&gt; <br>&gt; Opening existentials<br>&gt; <br>&gt; Generalized existentials as described above will still have trouble with protocol requirements that involve Self or associated types in function parameters. For example, let’s try to use Equatable as an existential:<br>&gt; <br>&gt; protocol Equatable {<br>&gt;   func ==(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;   func !=(lhs: Self, rhs: Self) -&gt; Bool<br>&gt; }<br>&gt; <br>&gt; let e1: Equatable = …<br>&gt; let e2: Equatable = …<br>&gt; if e1 == e2 { … } // error: e1 and e2 don’t necessarily have the same dynamic type<br>&gt; <br>&gt; One explicit way to allow such operations in a type-safe manner is to introduce an “open existential” operation of some sort, which extracts and gives a name to the dynamic type stored inside an existential. For example:<br>&gt; <br>&gt; 	 <br>&gt; if let storedInE1 = e1 openas T {     // T is a the type of storedInE1, a copy of the value stored in e1<br>&gt;   if let storedInE2 = e2 as? T {      // is e2 also a T?<br>&gt;     if storedInE1 == storedInE2 { … } // okay: storedInT1 and storedInE2 are both of type T, which we know is Equatable<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160503/1580dce5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Manifesto] Completing Generics</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>May  3, 2016 at 12:00:00am</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On May 2, 2016, at 3:58 PM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt; <br>&gt; I’d like to continue moving Completing Generics forward for Swift 3 with proposals. Can Douglas, or someone from the core team, tell me if the topics mentioned in Removing unnecessary restrictions require proposals or if bug reports should be opened for them instead?<br></p><p>I&#39;d classify everything in that section as a bug, so long as we&#39;re restricting ourselves to the syntax already present in the language. Syntactic improvements (e.g., for same-type-to-concrete constraints) would require a proposal. <br></p><p>  - Doug<br></p><p><br>&gt; <br>&gt;&gt; On 03 Mar 2016, at 02:22, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; The “Complete Generics” goal for Swift 3 has been fairly ill-defined thus fair, with just this short blurb in the list of goals:<br>&gt;&gt; <br>&gt;&gt; Complete generics: Generics are used pervasively in a number of Swift libraries, especially the standard library. However, there are a number of generics features the standard library requires to fully realize its vision, including recursive protocol constraints, the ability to make a constrained extension conform to a new protocol (i.e., an array of Equatable elements is Equatable), and so on. Swift 3.0 should provide those generics features needed by the standard library, because they affect the standard library&#39;s ABI.<br>&gt;&gt; This message expands upon the notion of “completing generics”. It is not a plan for Swift 3, nor an official core team communication, but it collects the results of numerous discussions among the core team and Swift developers, both of the compiler and the standard library. I hope to achieve several things:<br>&gt;&gt; <br>&gt;&gt; Communicate a vision for Swift generics, building on the original generics design document, so we have something concrete and comprehensive to discuss.<br>&gt;&gt; Establish some terminology that the Swift developers have been using for these features, so our discussions can be more productive (“oh, you’re proposing what we refer to as ‘conditional conformances’; go look over at this thread”).<br>&gt;&gt; Engage more of the community in discussions of specific generics features, so we can coalesce around designs for public review. And maybe even get some of them implemented.<br>&gt;&gt; <br>&gt;&gt; A message like this can easily turn into a centithread. To separate concerns in our discussion, I ask that replies to this specific thread be limited to discussions of the vision as a whole: how the pieces fit together, what pieces are missing, whether this is the right long-term vision for Swift, and so on. For discussions of specific language features, e.g., to work out the syntax and semantics of conditional conformances or discuss the implementation in compiler or use in the standard library, please start a new thread based on the feature names I’m using.<br>&gt;&gt; <br>&gt;&gt; This message covers a lot of ground; I’ve attempted a rough categorization of the various features, and kept the descriptions brief to limit the overall length. Most of these aren’t my ideas, and any syntax I’m providing is simply a way to express these ideas in code and is subject to change. Not all of these features will happen, either soon or ever, but they are intended to be a fairly complete whole that should mesh together. I’ve put a * next to features that I think are important in the nearer term vs. being interesting “some day”. Mostly, the *’s reflect features that will have a significant impact on the Swift standard library’s design and implementation.<br>&gt;&gt; <br>&gt;&gt; Enough with the disclaimers; it’s time to talk features.<br>&gt;&gt; <br>&gt;&gt; Removing unnecessary restrictions<br>&gt;&gt; <br>&gt;&gt; There are a number of restrictions to the use of generics that fall out of the implementation in the Swift compiler. Removal of these restrictions is a matter of implementation only; one need not introduce new syntax or semantics to realize them. I’m listing them for two reasons: first, it’s an acknowledgment that these features are intended to exist in the model we have today, and, second, we’d love help with the implementation of these features.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; *Recursive protocol constraints<br>&gt;&gt; <br>&gt;&gt; Currently, an associated type cannot be required to conform to its enclosing protocol (or any protocol that inherits that protocol). For example, in the standard library SubSequence type of a Sequence should itself be a Sequence:<br>&gt;&gt; <br>&gt;&gt; protocol Sequence {<br>&gt;&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;&gt;   …<br>&gt;&gt;   associatedtype SubSequence : Sequence   // currently ill-formed, but should be possible<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The compiler currently rejects this protocol, which is unfortunate: it effectively pushes the SubSequence-must-be-a-Sequence requirement into every consumer of SubSequence, and does not communicate the intent of this abstraction well.<br>&gt;&gt; <br>&gt;&gt; Nested generics<br>&gt;&gt; <br>&gt;&gt; Currently, a generic type cannot be nested within another generic type, e.g.<br>&gt;&gt; <br>&gt;&gt; struct X&lt;T&gt; {<br>&gt;&gt;   struct Y&lt;U&gt; { }  // currently ill-formed, but should be possible<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; There isn’t much to say about this: the compiler simply needs to be improved to handle nested generics throughout.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Concrete same-type requirements<br>&gt;&gt; <br>&gt;&gt; Currently, a constrained extension cannot use a same-type constraint to make a type parameter equivalent to a concrete type. For example:<br>&gt;&gt; <br>&gt;&gt; extension Array where Element == String {<br>&gt;&gt;   func makeSentence() -&gt; String {<br>&gt;&gt;     // uppercase first string, concatenate with spaces, add a period, whatever<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This is a highly-requested feature that fits into the existing syntax and semantics. Note that one could imagine introducing new syntax, e.g., extending “Array&lt;String&gt;”, which gets into new-feature territory: see the section on “Parameterized extensions”.<br>&gt;&gt; <br>&gt;&gt; Parameterizing other declarations<br>&gt;&gt; <br>&gt;&gt; There are a number of Swift declarations that currently cannot have generic parameters; some of those have fairly natural extensions to generic forms that maintain their current syntax and semantics, but become more powerful when made generic.<br>&gt;&gt; <br>&gt;&gt; Generic typealiases<br>&gt;&gt; <br>&gt;&gt; Typealiases could be allowed to carry generic parameters. They would still be aliases (i.e., they would not introduce new types). For example:<br>&gt;&gt; <br>&gt;&gt; typealias StringDictionary&lt;Value&gt; = Dictionary&lt;String, Value&gt;<br>&gt;&gt; <br>&gt;&gt; var d1 = StringDictionary&lt;Int&gt;()<br>&gt;&gt; var d2: Dictionary&lt;String, Int&gt; = d1 // okay: d1 and d2 have the same type, Dictionary&lt;String, Int&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Generic subscripts<br>&gt;&gt; <br>&gt;&gt; Subscripts could be allowed to have generic parameters. For example, we could introduce a generic subscript on a Collection that allows us to pull out the values at an arbitrary set of indices:<br>&gt;&gt; <br>&gt;&gt; extension Collection {<br>&gt;&gt;   subscript&lt;Indices: Sequence where Indices.Iterator.Element == Index&gt;(indices: Indices) -&gt; [Iterator.Element] {<br>&gt;&gt;     get {<br>&gt;&gt;       var result = [Iterator.Element]()<br>&gt;&gt;       for index in indices {<br>&gt;&gt;         result.append(self[index])<br>&gt;&gt;       }<br>&gt;&gt; <br>&gt;&gt;       return result<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     set {<br>&gt;&gt;       for (index, value) in zip(indices, newValue) {<br>&gt;&gt;         self[index] = value<br>&gt;&gt;       }<br>&gt;&gt;     }<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Generic constants<br>&gt;&gt; <br>&gt;&gt; let constants could be allowed to have generic parameters, such that they produce differently-typed values depending on how they are used. For example, this is particularly useful for named literal values, e.g.,<br>&gt;&gt; <br>&gt;&gt; let π&lt;T : FloatLiteralConvertible&gt;: T = 3.141592653589793238462643383279502884197169399<br>&gt;&gt; <br>&gt;&gt; The Clang importer could make particularly good use of this when importing macros.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Parameterized extensions<br>&gt;&gt; <br>&gt;&gt; Extensions themselves could be parameterized, which would allow some structural pattern matching on types. For example, this would permit one to extend an array of optional values, e.g.,<br>&gt;&gt; <br>&gt;&gt; extension&lt;T&gt; Array where Element == T? {<br>&gt;&gt;   var someValues: [T] {<br>&gt;&gt;     var result = [T]()<br>&gt;&gt;     for opt in self {<br>&gt;&gt;       if let value = opt { result.append(value) }<br>&gt;&gt;     }<br>&gt;&gt;    return result<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; We can generalize this to a protocol extensions:<br>&gt;&gt; <br>&gt;&gt; extension&lt;T&gt; Sequence where Element == T? {<br>&gt;&gt;   var someValues: [T] {<br>&gt;&gt;     var result = [T]()<br>&gt;&gt;     for opt in self {<br>&gt;&gt;       if let value = opt { result.append(value) }<br>&gt;&gt;     }<br>&gt;&gt;    return result<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Note that when one is extending nominal types, we could simplify the syntax somewhat to make the same-type constraint implicit in the syntax:<br>&gt;&gt; <br>&gt;&gt; extension&lt;T&gt; Array&lt;T?&gt; {<br>&gt;&gt;   var someValues: [T] {<br>&gt;&gt;     var result = [T]()<br>&gt;&gt;     for opt in self {<br>&gt;&gt;       if let value = opt { result.append(value) }<br>&gt;&gt;     }<br>&gt;&gt;    return result<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; When we’re working with concrete types, we can use that syntax to improve the extension of concrete versions of generic types (per “Concrete same-type requirements”, above), e.g.,<br>&gt;&gt; <br>&gt;&gt; extension Array&lt;String&gt; {<br>&gt;&gt;   func makeSentence() -&gt; String {<br>&gt;&gt;     // uppercase first string, concatenate with spaces, add a period, whatever<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Minor extensions<br>&gt;&gt; <br>&gt;&gt; There are a number of minor extensions we can make to the generics system that don’t fundamentally change what one can express in Swift, but which can improve its expressivity.<br>&gt;&gt; <br>&gt;&gt; *Arbitrary requirements in protocols<br>&gt;&gt; <br>&gt;&gt; Currently, a new protocol can inherit from other protocols, introduce new associated types, and add new conformance constraints to associated types (by redeclaring an associated type from an inherited protocol). However, one cannot express more general constraints. Building on the example from “Recursive protocol constraints”, we really want the element type of a Sequence’s SubSequence to be the same as the element type of the Sequence, e.g.,<br>&gt;&gt; <br>&gt;&gt; protocol Sequence {<br>&gt;&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;&gt;   …<br>&gt;&gt;   associatedtype SubSequence : Sequence where SubSequence.Iterator.Element == Iterator.Element<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Hanging the where clause off the associated type is protocol not ideal, but that’s a discussion for another thread.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; *Typealiases in protocols and protocol extensions<br>&gt;&gt; <br>&gt;&gt; Now that associated types have their own keyword (thanks!), it’s reasonable to bring back “typealias”. Again with the Sequence protocol:<br>&gt;&gt; <br>&gt;&gt; protocol Sequence {<br>&gt;&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;&gt;   typealias Element = Iterator.Element   // rejoice! now we can refer to SomeSequence.Element rather than SomeSequence.Iterator.Element<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Default generic arguments <br>&gt;&gt; <br>&gt;&gt; Generic parameters could be given the ability to provide default arguments, which would be used in cases where the type argument is not specified and type inference could not determine the type argument. For example:<br>&gt;&gt; <br>&gt;&gt; public final class Promise&lt;Value, Reason=Error&gt; { … }<br>&gt;&gt; <br>&gt;&gt; func getRandomPromise() -&gt; Promise&lt;Int, ErrorProtocol&gt; { … }<br>&gt;&gt; <br>&gt;&gt; var p1: Promise&lt;Int&gt; = …<br>&gt;&gt; var p2: Promise&lt;Int, Error&gt; = p1     // okay: p1 and p2 have the same type Promise&lt;Int, Error&gt;<br>&gt;&gt; var p3: Promise = getRandomPromise() // p3 has type Promise&lt;Int, ErrorProtocol&gt; due to type inference<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Generalized “class” constraints<br>&gt;&gt; <br>&gt;&gt; The “class” constraint can currently only be used for defining protocols. We could generalize it to associated type and type parameter declarations, e.g.,<br>&gt;&gt; <br>&gt;&gt; protocol P {<br>&gt;&gt;   associatedtype A : class<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func foo&lt;T : class&gt;(t: T) { }<br>&gt;&gt; <br>&gt;&gt; As part of this, the magical AnyObject protocol could be replaced with an existential with a class bound, so that it becomes a typealias:<br>&gt;&gt; <br>&gt;&gt; typealias AnyObject = protocol&lt;class&gt;<br>&gt;&gt; <br>&gt;&gt; See the “Existentials” section, particularly “Generalized existentials”, for more information.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; *Allowing subclasses to override requirements satisfied by defaults<br>&gt;&gt; <br>&gt;&gt; When a superclass conforms to a protocol and has one of the protocol’s requirements satisfied by a member of a protocol extension, that member currently cannot be overridden by a subclass. For example:<br>&gt;&gt; <br>&gt;&gt; protocol P {<br>&gt;&gt;   func foo()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension P {<br>&gt;&gt;   func foo() { print(“P”) }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class C : P {<br>&gt;&gt;   // gets the protocol extension’s <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class D : C {<br>&gt;&gt;   /*override not allowed!*/ func foo() { print(“D”) }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let p: P = D()<br>&gt;&gt; p.foo() // gotcha: prints “P” rather than “D”!<br>&gt;&gt; <br>&gt;&gt; D.foo should be required to specify “override” and should be called dynamically.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Major extensions to the generics model<br>&gt;&gt; <br>&gt;&gt; Unlike the minor extensions, major extensions to the generics model provide more expressivity in the Swift generics system and, generally, have a much more significant design and implementation cost.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; *Conditional conformances<br>&gt;&gt; <br>&gt;&gt; Conditional conformances express the notion that a generic type will conform to a particular protocol only under certain circumstances. For example, Array is Equatable only when its elements are Equatable:<br>&gt;&gt; <br>&gt;&gt; extension Array : Equatable where Element : Equatable { }<br>&gt;&gt; <br>&gt;&gt; func ==&lt;T : Equatable&gt;(lhs: Array&lt;T&gt;, rhs: Array&lt;T&gt;) -&gt; Bool { … }<br>&gt;&gt; <br>&gt;&gt; Conditional conformances are a potentially very powerful feature. One important aspect of this feature is how deal with or avoid overlapping conformances. For example, imagine an adaptor over a Sequence that has conditional conformances to Collection and MutableCollection:<br>&gt;&gt; <br>&gt;&gt; struct SequenceAdaptor&lt;S: Sequence&gt; : Sequence { }<br>&gt;&gt; extension SequenceAdaptor : Collection where S: Collection { … }<br>&gt;&gt; extension SequenceAdaptor : MutableCollection where S: MutableCollection { }<br>&gt;&gt; <br>&gt;&gt; This should almost certainly be permitted, but we need to cope with or reject “overlapping” conformances:<br>&gt;&gt; <br>&gt;&gt; extension SequenceAdaptor : Collection where S: SomeOtherProtocolSimilarToCollection { } // trouble: two ways for SequenceAdaptor to conform to Collection<br>&gt;&gt; <br>&gt;&gt; See the section on “Private conformances” for more about the issues with having the same type conform to the same protocol multiple times.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Variadic generics<br>&gt;&gt; <br>&gt;&gt; Currently, a generic parameter list contains a fixed number of generic parameters. If one has a type that could generalize to any number of generic parameters, the only real way to deal with it today involves creating a set of types. For example, consider the standard library’s “zip” function. It returns one of these when provided with two arguments to zip together:<br>&gt;&gt; <br>&gt;&gt; public struct Zip2Sequence&lt;Sequence1 : Sequence,<br>&gt;&gt;                            Sequence2 : Sequence&gt; : Sequence { … }<br>&gt;&gt; <br>&gt;&gt; public func zip&lt;Sequence1 : Sequence, Sequence2 : Sequence&gt;(<br>&gt;&gt;               sequence1: Sequence1, _ sequence2: Sequence2)<br>&gt;&gt;             -&gt; Zip2Sequence&lt;Sequence1, Sequence2&gt; { … }<br>&gt;&gt; <br>&gt;&gt; Supporting three arguments would require copy-paste of those of those:<br>&gt;&gt; <br>&gt;&gt; public struct Zip3Sequence&lt;Sequence1 : Sequence,<br>&gt;&gt;                            Sequence2 : Sequence,<br>&gt;&gt;                            Sequence3 : Sequence&gt; : Sequence { … }<br>&gt;&gt; <br>&gt;&gt; public func zip&lt;Sequence1 : Sequence, Sequence2 : Sequence, Sequence3 : Sequence&gt;(<br>&gt;&gt;               sequence1: Sequence1, _ sequence2: Sequence2, _ sequence3: sequence3)<br>&gt;&gt;             -&gt; Zip3Sequence&lt;Sequence1, Sequence2, Sequence3&gt; { … }<br>&gt;&gt; <br>&gt;&gt; Variadic generics would allow us to abstract over a set of generic parameters. The syntax below is hopelessly influenced by C++11 variadic templates (sorry), where putting an ellipsis (“…”) to the left of a declaration makes it a “parameter pack” containing zero or more parameters and putting an ellipsis to the right of a type/expression/etc. expands the parameter packs within that type/expression into separate arguments. The important part is that we be able to meaningfully abstract over zero or more generic parameters, e.g.:<br>&gt;&gt; <br>&gt;&gt; public struct ZipIterator&lt;... Iterators : IteratorProtocol&gt; : Iterator {  // zero or more type parameters, each of which conforms to IteratorProtocol<br>&gt;&gt;   public typealias Element = (Iterators.Element...)                       // a tuple containing the element types of each iterator in Iterators<br>&gt;&gt; <br>&gt;&gt;   var (...iterators): (Iterators...)    // zero or more stored properties, one for each type in Iterators <br>&gt;&gt;   var reachedEnd: Bool = false<br>&gt;&gt; <br>&gt;&gt;   public mutating func next() -&gt; Element? {<br>&gt;&gt;     if reachedEnd { return nil }<br>&gt;&gt; <br>&gt;&gt;     guard let values = (iterators.next()...) {   // call “next” on each of the iterators, put the results into a tuple named “values&quot;<br>&gt;&gt;       reachedEnd = true<br>&gt;&gt;       return nil<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     return values<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; public struct ZipSequence&lt;...Sequences : Sequence&gt; : Sequence {<br>&gt;&gt;   public typealias Iterator = ZipIterator&lt;Sequences.Iterator...&gt;   // get the zip iterator with the iterator types of our Sequences<br>&gt;&gt; <br>&gt;&gt;   var (...sequences): (Sequences...)    // zero or more stored properties, one for each type in Sequences <br>&gt;&gt; <br>&gt;&gt;   // details ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Such a design could also work for function parameters, so we can pack together multiple function arguments with different types, e.g.,<br>&gt;&gt; <br>&gt;&gt; public func zip&lt;... Sequences : SequenceType&gt;(... sequences: Sequences...) <br>&gt;&gt;             -&gt; ZipSequence&lt;Sequences...&gt; {<br>&gt;&gt;   return ZipSequence(sequences...)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Finally, this could tie into the discussions about a tuple “splat” operator. For example:<br>&gt;&gt; <br>&gt;&gt; func apply&lt;... Args, Result&gt;(fn: (Args...) -&gt; Result,    // function taking some number of arguments and producing Result<br>&gt;&gt;                            args: (Args...)) -&gt; Result {  // tuple of arguments<br>&gt;&gt;   return fn(args...)                                     // expand the arguments in the tuple “args” into separate arguments<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Extensions of structural types<br>&gt;&gt; <br>&gt;&gt; Currently, only nominal types (classes, structs, enums, protocols) can be extended. One could imagine extending structural types—particularly tuple types—to allow them to, e.g., conform to protocols. For example, pulling together variadic generics, parameterized extensions, and conditional conformances, one could express “a tuple type is Equatable if all of its element types are Equatable”:<br>&gt;&gt; <br>&gt;&gt; extension&lt;...Elements : Equatable&gt; (Elements...) : Equatable {   // extending the tuple type “(Elements…)” to be Equatable<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; There are some natural bounds here: one would need to have actual structural types. One would not be able to extend every type:<br>&gt;&gt; <br>&gt;&gt; extension&lt;T&gt; T { // error: neither a structural nor a nominal type<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; And before you think you’re cleverly making it possible to have a conditional conformance that makes every type T that conforms to protocol P also conform to protocol Q, see the section &quot;Conditional conformances via protocol extensions”, below:<br>&gt;&gt; <br>&gt;&gt; extension&lt;T : P&gt; T : Q { // error: neither a structural nor a nominal type<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Syntactic improvements<br>&gt;&gt; <br>&gt;&gt; There are a number of potential improvements we could make to the generics syntax. Such a list could go on for a very long time, so I’ll only highlight some obvious ones that have been discussed by the Swift developers.<br>&gt;&gt; <br>&gt;&gt; *Default implementations in protocols<br>&gt;&gt; <br>&gt;&gt; Currently, protocol members can never have implementations. We could allow one to provide such implementations to be used as the default if a conforming type does not supply an implementation, e.g.,<br>&gt;&gt; <br>&gt;&gt; protocol Bag {<br>&gt;&gt;   associatedtype Element : Equatable<br>&gt;&gt;   func contains(element: Element) -&gt; Bool<br>&gt;&gt; <br>&gt;&gt;   func containsAll&lt;S: Sequence where Sequence.Iterator.Element == Element&gt;(elements: S) -&gt; Bool {<br>&gt;&gt;     for x in elements {<br>&gt;&gt;       if contains(x) { return true }<br>&gt;&gt;     }<br>&gt;&gt;     return false<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct IntBag : Bag {<br>&gt;&gt;   typealias Element = Int<br>&gt;&gt;   func contains(element: Int) -&gt; Bool { ... }<br>&gt;&gt; <br>&gt;&gt;   // okay: containsAll requirement is satisfied by Bag’s default implementation<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; One can get this effect with protocol extensions today, hence the classification of this feature as a (mostly) syntactic improvement:<br>&gt;&gt; <br>&gt;&gt; protocol Bag {<br>&gt;&gt;   associatedtype Element : Equatable<br>&gt;&gt;   func contains(element: Element) -&gt; Bool<br>&gt;&gt; <br>&gt;&gt;   func containsAll&lt;S: Sequence where Sequence.Iterator.Element == Element&gt;(elements: S) -&gt; Bool<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension Bag {<br>&gt;&gt;   func containsAll&lt;S: Sequence where Sequence.Iterator.Element == Element&gt;(elements: S) -&gt; Bool {<br>&gt;&gt;     for x in elements {<br>&gt;&gt;       if contains(x) { return true }<br>&gt;&gt;     }<br>&gt;&gt;     return false<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; *Moving the where clause outside of the angle brackets<br>&gt;&gt; <br>&gt;&gt; The “where” clause of generic functions comes very early in the declaration, although it is generally of much less concern to the client than the function parameters and result type that follow it. This is one of the things that contributes to “angle bracket blindness”. For example, consider the containsAll signature above:<br>&gt;&gt; <br>&gt;&gt; func containsAll&lt;S: Sequence where Sequence.Iterator.Element == Element&gt;(elements: S) -&gt; Bool<br>&gt;&gt; <br>&gt;&gt; One could move the “where” clause to the end of the signature, so that the most important parts—name, generic parameter, parameters, result type—precede it:<br>&gt;&gt; <br>&gt;&gt; func containsAll&lt;S: Sequence&gt;(elements: S) -&gt; Bool <br>&gt;&gt;        where Sequence.Iterator.Element == Element<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; *Renaming “protocol&lt;…&gt;” to “Any&lt;…&gt;”.<br>&gt;&gt; <br>&gt;&gt; The “protocol&lt;…&gt;” syntax is a bit of an oddity in Swift. It is used to compose protocols together, mostly to create values of existential type, e.g.,<br>&gt;&gt; <br>&gt;&gt; var x: protocol&lt;NSCoding, NSCopying&gt;<br>&gt;&gt; <br>&gt;&gt; It’s weird that it’s a type name that starts with a lowercase letter, and most Swift developers probably never deal with this feature unless they happen to look at the definition of Any:<br>&gt;&gt; <br>&gt;&gt; typealias Any = protocol&lt;&gt;<br>&gt;&gt; <br>&gt;&gt; “Any” might be a better name for this functionality. “Any” without brackets could be a keyword for “any type”, and “Any” followed by brackets could take the role of “protocol&lt;&gt;” today:<br>&gt;&gt; <br>&gt;&gt; var x: Any&lt;NSCoding, NSCopying&gt;<br>&gt;&gt; <br>&gt;&gt; That reads much better: “Any type that conforms to NSCoding and NSCopying”. See the section &quot;Generalized existentials” for additional features in this space.<br>&gt;&gt; <br>&gt;&gt; Maybe<br>&gt;&gt; <br>&gt;&gt; There are a number of features that get discussed from time-to-time, while they could fit into Swift’s generics system, it’s not clear that they belong in Swift at all. The important question for any feature in this category is not “can it be done” or “are there cool things we can express”, but “how can everyday Swift developers benefit from the addition of such a feature?”. Without strong motivating examples, none of these “maybes” will move further along.<br>&gt;&gt; <br>&gt;&gt; Dynamic dispatch for members of protocol extensions<br>&gt;&gt; <br>&gt;&gt; Only the requirements of protocols currently use dynamic dispatch, which can lead to surprises:<br>&gt;&gt; <br>&gt;&gt; protocol P {<br>&gt;&gt;   func foo()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension P {<br>&gt;&gt;   func foo() { print(“P.foo()”)<br>&gt;&gt;   func bar() { print(“P.bar()”)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct X : P {<br>&gt;&gt;   func foo() { print(“X.foo()”)<br>&gt;&gt;   func bar() { print(“X.bar()”)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let x = X()<br>&gt;&gt; x.foo() // X.foo()<br>&gt;&gt; x.bar() // X.bar()<br>&gt;&gt; <br>&gt;&gt; let p: P = X()<br>&gt;&gt; p.foo() // X.foo()<br>&gt;&gt; p.bar() // P.bar()<br>&gt;&gt; <br>&gt;&gt; Swift could adopt a model where members of protocol extensions are dynamically dispatched.<br>&gt;&gt; <br>&gt;&gt; Named generic parameters<br>&gt;&gt; <br>&gt;&gt; When specifying generic arguments for a generic type, the arguments are always positional: Dictionary&lt;String, Int&gt; is a Dictionary whose Key type is String and whose Value type is Int, by convention. One could permit the arguments to be labeled, e.g.,<br>&gt;&gt; <br>&gt;&gt; var d: Dictionary&lt;Key: String, Value: Int&gt;<br>&gt;&gt; <br>&gt;&gt; Such a feature makes more sense if Swift gains default generic arguments, because generic argument labels would allow one to skip defaulted arguments.<br>&gt;&gt; <br>&gt;&gt; Generic value parameters<br>&gt;&gt; <br>&gt;&gt; Currently, Swift’s generic parameters are always types. One could imagine allowing generic parameters that are values, e.g.,<br>&gt;&gt; <br>&gt;&gt; struct MultiArray&lt;T, let Dimensions: Int&gt; { // specify the number of dimensions to the array<br>&gt;&gt;   subscript (indices: Int...) -&gt; T {<br>&gt;&gt;     get {<br>&gt;&gt;       require(indices.count == Dimensions)<br>&gt;&gt;       // ...<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; A suitably general feature might allow us to express fixed-length array or vector types as a standard library component, and perhaps also allow one to implement a useful dimensional analysis library. Tackling this feature potentially means determining what it is for an expression to be a “constant expression” and diving into dependent-typing, hence the “maybe”.<br>&gt;&gt; <br>&gt;&gt; Higher-kinded types<br>&gt;&gt; <br>&gt;&gt; Higher-kinded types allow one to express the relationship between two different specializations of the same nominal type within a protocol. For example, if we think of the Self type in a protocol as really being “Self&lt;T&gt;”, it allows us to talk about the relationship between “Self&lt;T&gt;” and “Self&lt;U&gt;” for some other type U. For example, it could allow the “map” operation on a collection to return a collection of the same kind but with a different operation, e.g.,<br>&gt;&gt; <br>&gt;&gt; let intArray: Array&lt;Int&gt; = …<br>&gt;&gt; intArray.map { String($0) } // produces Array&lt;String&gt;<br>&gt;&gt; let intSet: Set&lt;Int&gt; = …<br>&gt;&gt; intSet.map { String($0) }   // produces Set&lt;String&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Potential syntax borrowed from one thread on higher-kinded types uses ~= as a “similarity” constraint to describe a Functor protocol:<br>&gt;&gt; <br>&gt;&gt; protocol Functor {<br>&gt;&gt;   associatedtype A<br>&gt;&gt;   func fmap&lt;FB where FB ~= Self&gt;(f: A -&gt; FB.A) -&gt; FB<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Specifying type arguments for uses of generic functions<br>&gt;&gt; <br>&gt;&gt; The type arguments of a generic function are always determined via type inference. For example, given:<br>&gt;&gt; <br>&gt;&gt; func f&lt;T&gt;(t: T)<br>&gt;&gt; <br>&gt;&gt; one cannot directly specify T: either one calls “f” (and T is determined via the argument’s type) or one uses “f” in a context where it is given a particular function type (e.g., “let x: (Int) -&gt; Void = f”  would infer T = Int). We could permit explicit specialization here, e.g.,<br>&gt;&gt; <br>&gt;&gt; let x = f&lt;Int&gt; // x has type (Int) -&gt; Void<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Unlikely<br>&gt;&gt; <br>&gt;&gt; Features in this category have been requested at various times, but they don’t fit well with Swift’s generics system because they cause some part of the model to become overly complicated, have unacceptable implementation limitations, or overlap significantly with existing features.<br>&gt;&gt; <br>&gt;&gt; Generic protocols<br>&gt;&gt; <br>&gt;&gt; One of the most commonly requested features is the ability to parameterize protocols themselves. For example, a protocol that indicates that the Self type can be constructed from some specified type T:<br>&gt;&gt; <br>&gt;&gt; protocol ConstructibleFromValue&lt;T&gt; {<br>&gt;&gt;   init(_ value: T)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Implicit in this feature is the ability for a given type to conform to the protocol in two different ways. A “Real” type might be constructible from both Float and Double, e.g.,<br>&gt;&gt; <br>&gt;&gt; struct Real { … }<br>&gt;&gt; extension Real : ConstructibleFrom&lt;Float&gt; {<br>&gt;&gt;   init(_ value: Float) { … }<br>&gt;&gt; }<br>&gt;&gt; extension Real : ConstructibleFrom&lt;Double&gt; {<br>&gt;&gt;   init(_ value: Double) { … }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Most of the requests for this feature actually want a different feature. They tend to use a parameterized Sequence as an example, e.g.,<br>&gt;&gt; <br>&gt;&gt; protocol Sequence&lt;Element&gt; { … }<br>&gt;&gt; <br>&gt;&gt; func foo(strings: Sequence&lt;String&gt;) {  /// works on any sequence containing Strings<br>&gt;&gt;   // ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The actual requested feature here 	is the ability to say “Any type that conforms to Sequence whose Element type is String”, which is covered by the section on “Generalized existentials”, below.<br>&gt;&gt; <br>&gt;&gt; More importantly, modeling Sequence with generic parameters rather than associated types is tantalizing but wrong: you don’t want a type conforming to Sequence in multiple ways, or (among other things) your for..in loops stop working, and you lose the ability to dynamically cast down to an existential “Sequence” without binding the Element type (again, see “Generalized existentials”). Use cases similar to the ConstructibleFromValue protocol above seem too few to justify the potential for confusion between associated types and generic parameters of protocols; we’re better off not having the latter.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Private conformances <br>&gt;&gt; <br>&gt;&gt; Right now, a protocol conformance can be no less visible than the minimum of the conforming type’s access and the protocol’s access. Therefore, a public type conforming to a public protocol must provide the conformance publicly. One could imagine removing that restriction, so that one could introduce a private conformance:<br>&gt;&gt; <br>&gt;&gt; public protocol P { }<br>&gt;&gt; public struct X { }<br>&gt;&gt; extension X : internal P { … } // X conforms to P, but only within this module<br>&gt;&gt; <br>&gt;&gt; The main problem with private conformances is the interaction with dynamic casting. If I have this code:<br>&gt;&gt; <br>&gt;&gt; func foo(value: Any) {<br>&gt;&gt;   if let x = value as? P { print(“P”) }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; foo(X())<br>&gt;&gt; <br>&gt;&gt; Under what circumstances should it print “P”? If foo() is defined within the same module as the conformance of X to P? If the call is defined within the same module as the conformance of X to P? Never? Either of the first two answers requires significant complications in the dynamic casting infrastructure to take into account the module in which a particular dynamic cast occurred (the first option) or where an existential was formed (the second option), while the third answer breaks the link between the static and dynamic type systems—none of which is an acceptable result.<br>&gt;&gt; <br>&gt;&gt; Conditional conformances via protocol extensions<br>&gt;&gt; <br>&gt;&gt; We often get requests to make a protocol conform to another protocol. This is, effectively, the expansion of the notion of “Conditional conformances” to protocol extensions. For example:<br>&gt;&gt; <br>&gt;&gt; protocol P {<br>&gt;&gt;   func foo()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; protocol Q {<br>&gt;&gt;   func bar()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension Q : P { // every type that conforms to Q also conforms to P<br>&gt;&gt;   func foo() {    // implement “foo” requirement in terms of “bar&quot;<br>&gt;&gt;     bar()<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func f&lt;T: P&gt;(t: T) { … }<br>&gt;&gt; <br>&gt;&gt; struct X : Q {<br>&gt;&gt;   func bar() { … }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; f(X()) // okay: X conforms to P through the conformance of Q to P<br>&gt;&gt; <br>&gt;&gt; This is an extremely powerful feature: is allows one to map the abstractions of one domain into another domain (e.g., every Matrix is a Graph). However, similar to private conformances, it puts a major burden on the dynamic-casting runtime to chase down arbitrarily long and potentially cyclic chains of conformances, which makes efficient implementation nearly impossible.<br>&gt;&gt; <br>&gt;&gt; Potential removals<br>&gt;&gt; <br>&gt;&gt; The generics system doesn’t seem like a good candidate for a reduction in scope; most of its features do get used fairly pervasively in the standard library, and few feel overly anachronistic. However...<br>&gt;&gt; <br>&gt;&gt; Associated type inference<br>&gt;&gt; <br>&gt;&gt; Associated type inference is the process by which we infer the type bindings for associated types from other requirements. For example:<br>&gt;&gt; <br>&gt;&gt; protocol IteratorProtocol {<br>&gt;&gt;   associatedtype Element<br>&gt;&gt;   mutating func next() -&gt; Element?<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct IntIterator : IteratorProtocol {<br>&gt;&gt;   mutating func next() -&gt; Int? { … }  // use this to infer Element = Int<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Associated type inference is a useful feature. It’s used throughout the standard library, and it helps keep associated types less visible to types that simply want to conform to a protocol. On the other hand, associated type inference is the only place in Swift where we have a global type inference problem: it has historically been a major source of bugs, and implementing it fully and correctly requires a drastically different architecture to the type checker. Is the value of this feature worth keeping global type inference in the Swift language, when we have deliberatively avoided global type inference elsewhere in the language?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Existentials<br>&gt;&gt; <br>&gt;&gt; Existentials aren’t really generics per se, but the two systems are closely intertwined due to their mutable dependence on protocols.<br>&gt;&gt; <br>&gt;&gt; *Generalized existentials<br>&gt;&gt; <br>&gt;&gt; The restrictions on existential types came from an implementation limitation, but it is reasonable to allow a value of protocol type even when the protocol has Self constraints or associated types. For example, consider IteratorProtocol again and how it could be used as an existential:<br>&gt;&gt; <br>&gt;&gt; protocol IteratorProtocol {<br>&gt;&gt;   associatedtype Element<br>&gt;&gt;   mutating func next() -&gt; Element?<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let it: IteratorProtocol = …<br>&gt;&gt; it.next()   // if this is permitted, it could return an “Any?”, i.e., the existential that wraps the actual element<br>&gt;&gt; <br>&gt;&gt; Additionally, it is reasonable to want to constrain the associated types of an existential, e.g., “a Sequence whose element type is String” could be expressed by putting a where clause into “protocol&lt;…&gt;” or “Any&lt;…&gt;” (per “Renaming protocol&lt;…&gt; to Any&lt;…&gt;”):<br>&gt;&gt; <br>&gt;&gt; let strings: Any&lt;Sequence where .Iterator.Element == String&gt; = [“a”, “b”, “c”]<br>&gt;&gt; <br>&gt;&gt; The leading “.” indicates that we’re talking about the dynamic type, i.e., the “Self” type that’s conforming to the Sequence protocol. There’s no reason why we cannot support arbitrary “where” clauses within the “Any&lt;…&gt;”. This very-general syntax is a bit unwieldy, but common cases can easily be wrapped up in a generic typealias (see the section “Generic typealiases” above):<br>&gt;&gt; <br>&gt;&gt; typealias AnySequence&lt;Element&gt; = Any&lt;Sequence where .Iterator.Element == Element&gt;<br>&gt;&gt; let strings: AnySequence&lt;String&gt; = [“a”, “b”, “c”]<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Opening existentials<br>&gt;&gt; <br>&gt;&gt; Generalized existentials as described above will still have trouble with protocol requirements that involve Self or associated types in function parameters. For example, let’s try to use Equatable as an existential:<br>&gt;&gt; <br>&gt;&gt; protocol Equatable {<br>&gt;&gt;   func ==(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;   func !=(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let e1: Equatable = …<br>&gt;&gt; let e2: Equatable = …<br>&gt;&gt; if e1 == e2 { … } // error: e1 and e2 don’t necessarily have the same dynamic type<br>&gt;&gt; <br>&gt;&gt; One explicit way to allow such operations in a type-safe manner is to introduce an “open existential” operation of some sort, which extracts and gives a name to the dynamic type stored inside an existential. For example:<br>&gt;&gt; <br>&gt;&gt; 	 <br>&gt;&gt; if let storedInE1 = e1 openas T {     // T is a the type of storedInE1, a copy of the value stored in e1<br>&gt;&gt;   if let storedInE2 = e2 as? T {      // is e2 also a T?<br>&gt;&gt;     if storedInE1 == storedInE2 { … } // okay: storedInT1 and storedInE2 are both of type T, which we know is Equatable<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Thoughts?<br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160503/4899807e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Manifesto] Completing Generics</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>May  8, 2016 at 11:00:00pm</p></header><div class="content"><p>I created two bug requests for Recursive protocol constraints and Nested generics and will write a proposal for Concrete same-type requirements.<br></p><p>[SR-1445] Recursive protocol constraints &lt;https://bugs.swift.org/browse/SR-1445&gt;<br></p><p>[SR-1446] Nested generics &lt;https://bugs.swift.org/browse/SR-1446&gt;<br>&gt; On 03 May 2016, at 09:58, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt; On May 2, 2016, at 3:58 PM, David Hart &lt;david at hartbit.com &lt;mailto:david at hartbit.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; I’d like to continue moving Completing Generics forward for Swift 3 with proposals. Can Douglas, or someone from the core team, tell me if the topics mentioned in Removing unnecessary restrictions require proposals or if bug reports should be opened for them instead?<br>&gt; <br>&gt; I&#39;d classify everything in that section as a bug, so long as we&#39;re restricting ourselves to the syntax already present in the language. Syntactic improvements (e.g., for same-type-to-concrete constraints) would require a proposal. <br>&gt; <br>&gt;   - Doug<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 03 Mar 2016, at 02:22, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The “Complete Generics” goal for Swift 3 has been fairly ill-defined thus fair, with just this short blurb in the list of goals:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Complete generics: Generics are used pervasively in a number of Swift libraries, especially the standard library. However, there are a number of generics features the standard library requires to fully realize its vision, including recursive protocol constraints, the ability to make a constrained extension conform to a new protocol (i.e., an array of Equatable elements is Equatable), and so on. Swift 3.0 should provide those generics features needed by the standard library, because they affect the standard library&#39;s ABI.<br>&gt;&gt;&gt; This message expands upon the notion of “completing generics”. It is not a plan for Swift 3, nor an official core team communication, but it collects the results of numerous discussions among the core team and Swift developers, both of the compiler and the standard library. I hope to achieve several things:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Communicate a vision for Swift generics, building on the original generics design document &lt;https://github.com/apple/swift/blob/master/docs/Generics.rst&gt;, so we have something concrete and comprehensive to discuss.<br>&gt;&gt;&gt; Establish some terminology that the Swift developers have been using for these features, so our discussions can be more productive (“oh, you’re proposing what we refer to as ‘conditional conformances’; go look over at this thread”).<br>&gt;&gt;&gt; Engage more of the community in discussions of specific generics features, so we can coalesce around designs for public review. And maybe even get some of them implemented.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A message like this can easily turn into a centithread &lt;http://www.urbandictionary.com/define.php?term=centithread&gt;. To separate concerns in our discussion, I ask that replies to this specific thread be limited to discussions of the vision as a whole: how the pieces fit together, what pieces are missing, whether this is the right long-term vision for Swift, and so on. For discussions of specific language features, e.g., to work out the syntax and semantics of conditional conformances or discuss the implementation in compiler or use in the standard library, please start a new thread based on the feature names I’m using.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This message covers a lot of ground; I’ve attempted a rough categorization of the various features, and kept the descriptions brief to limit the overall length. Most of these aren’t my ideas, and any syntax I’m providing is simply a way to express these ideas in code and is subject to change. Not all of these features will happen, either soon or ever, but they are intended to be a fairly complete whole that should mesh together. I’ve put a * next to features that I think are important in the nearer term vs. being interesting “some day”. Mostly, the *’s reflect features that will have a significant impact on the Swift standard library’s design and implementation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Enough with the disclaimers; it’s time to talk features.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Removing unnecessary restrictions<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are a number of restrictions to the use of generics that fall out of the implementation in the Swift compiler. Removal of these restrictions is a matter of implementation only; one need not introduce new syntax or semantics to realize them. I’m listing them for two reasons: first, it’s an acknowledgment that these features are intended to exist in the model we have today, and, second, we’d love help with the implementation of these features.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; *Recursive protocol constraints<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Currently, an associated type cannot be required to conform to its enclosing protocol (or any protocol that inherits that protocol). For example, in the standard library SubSequence type of a Sequence should itself be a Sequence:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol Sequence {<br>&gt;&gt;&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;&gt;&gt;   …<br>&gt;&gt;&gt;   associatedtype SubSequence : Sequence   // currently ill-formed, but should be possible<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The compiler currently rejects this protocol, which is unfortunate: it effectively pushes the SubSequence-must-be-a-Sequence requirement into every consumer of SubSequence, and does not communicate the intent of this abstraction well.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Nested generics<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Currently, a generic type cannot be nested within another generic type, e.g.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct X&lt;T&gt; {<br>&gt;&gt;&gt;   struct Y&lt;U&gt; { }  // currently ill-formed, but should be possible<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There isn’t much to say about this: the compiler simply needs to be improved to handle nested generics throughout.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Concrete same-type requirements<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Currently, a constrained extension cannot use a same-type constraint to make a type parameter equivalent to a concrete type. For example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Array where Element == String {<br>&gt;&gt;&gt;   func makeSentence() -&gt; String {<br>&gt;&gt;&gt;     // uppercase first string, concatenate with spaces, add a period, whatever<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a highly-requested feature that fits into the existing syntax and semantics. Note that one could imagine introducing new syntax, e.g., extending “Array&lt;String&gt;”, which gets into new-feature territory: see the section on “Parameterized extensions”.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Parameterizing other declarations<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are a number of Swift declarations that currently cannot have generic parameters; some of those have fairly natural extensions to generic forms that maintain their current syntax and semantics, but become more powerful when made generic.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Generic typealiases<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Typealiases could be allowed to carry generic parameters. They would still be aliases (i.e., they would not introduce new types). For example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; typealias StringDictionary&lt;Value&gt; = Dictionary&lt;String, Value&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var d1 = StringDictionary&lt;Int&gt;()<br>&gt;&gt;&gt; var d2: Dictionary&lt;String, Int&gt; = d1 // okay: d1 and d2 have the same type, Dictionary&lt;String, Int&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Generic subscripts<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Subscripts could be allowed to have generic parameters. For example, we could introduce a generic subscript on a Collection that allows us to pull out the values at an arbitrary set of indices:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Collection {<br>&gt;&gt;&gt;   subscript&lt;Indices: Sequence where Indices.Iterator.Element == Index&gt;(indices: Indices) -&gt; [Iterator.Element] {<br>&gt;&gt;&gt;     get {<br>&gt;&gt;&gt;       var result = [Iterator.Element]()<br>&gt;&gt;&gt;       for index in indices {<br>&gt;&gt;&gt;         result.append(self[index])<br>&gt;&gt;&gt;       }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       return result<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     set {<br>&gt;&gt;&gt;       for (index, value) in zip(indices, newValue) {<br>&gt;&gt;&gt;         self[index] = value<br>&gt;&gt;&gt;       }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Generic constants<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let constants could be allowed to have generic parameters, such that they produce differently-typed values depending on how they are used. For example, this is particularly useful for named literal values, e.g.,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let π&lt;T : FloatLiteralConvertible&gt;: T = 3.141592653589793238462643383279502884197169399<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The Clang importer could make particularly good use of this when importing macros.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Parameterized extensions<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Extensions themselves could be parameterized, which would allow some structural pattern matching on types. For example, this would permit one to extend an array of optional values, e.g.,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension&lt;T&gt; Array where Element == T? {<br>&gt;&gt;&gt;   var someValues: [T] {<br>&gt;&gt;&gt;     var result = [T]()<br>&gt;&gt;&gt;     for opt in self {<br>&gt;&gt;&gt;       if let value = opt { result.append(value) }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;    return result<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We can generalize this to a protocol extensions:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension&lt;T&gt; Sequence where Element == T? {<br>&gt;&gt;&gt;   var someValues: [T] {<br>&gt;&gt;&gt;     var result = [T]()<br>&gt;&gt;&gt;     for opt in self {<br>&gt;&gt;&gt;       if let value = opt { result.append(value) }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;    return result<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Note that when one is extending nominal types, we could simplify the syntax somewhat to make the same-type constraint implicit in the syntax:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension&lt;T&gt; Array&lt;T?&gt; {<br>&gt;&gt;&gt;   var someValues: [T] {<br>&gt;&gt;&gt;     var result = [T]()<br>&gt;&gt;&gt;     for opt in self {<br>&gt;&gt;&gt;       if let value = opt { result.append(value) }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;    return result<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When we’re working with concrete types, we can use that syntax to improve the extension of concrete versions of generic types (per “Concrete same-type requirements”, above), e.g.,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Array&lt;String&gt; {<br>&gt;&gt;&gt;   func makeSentence() -&gt; String {<br>&gt;&gt;&gt;     // uppercase first string, concatenate with spaces, add a period, whatever<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Minor extensions<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are a number of minor extensions we can make to the generics system that don’t fundamentally change what one can express in Swift, but which can improve its expressivity.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; *Arbitrary requirements in protocols<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Currently, a new protocol can inherit from other protocols, introduce new associated types, and add new conformance constraints to associated types (by redeclaring an associated type from an inherited protocol). However, one cannot express more general constraints. Building on the example from “Recursive protocol constraints”, we really want the element type of a Sequence’s SubSequence to be the same as the element type of the Sequence, e.g.,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol Sequence {<br>&gt;&gt;&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;&gt;&gt;   …<br>&gt;&gt;&gt;   associatedtype SubSequence : Sequence where SubSequence.Iterator.Element == Iterator.Element<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hanging the where clause off the associated type is protocol not ideal, but that’s a discussion for another thread.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; *Typealiases in protocols and protocol extensions<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now that associated types have their own keyword (thanks!), it’s reasonable to bring back “typealias”. Again with the Sequence protocol:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol Sequence {<br>&gt;&gt;&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;&gt;&gt;   typealias Element = Iterator.Element   // rejoice! now we can refer to SomeSequence.Element rather than SomeSequence.Iterator.Element<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Default generic arguments <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Generic parameters could be given the ability to provide default arguments, which would be used in cases where the type argument is not specified and type inference could not determine the type argument. For example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public final class Promise&lt;Value, Reason=Error&gt; { … }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func getRandomPromise() -&gt; Promise&lt;Int, ErrorProtocol&gt; { … }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var p1: Promise&lt;Int&gt; = …<br>&gt;&gt;&gt; var p2: Promise&lt;Int, Error&gt; = p1     // okay: p1 and p2 have the same type Promise&lt;Int, Error&gt;<br>&gt;&gt;&gt; var p3: Promise = getRandomPromise() // p3 has type Promise&lt;Int, ErrorProtocol&gt; due to type inference<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Generalized “class” constraints<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The “class” constraint can currently only be used for defining protocols. We could generalize it to associated type and type parameter declarations, e.g.,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;   associatedtype A : class<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func foo&lt;T : class&gt;(t: T) { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As part of this, the magical AnyObject protocol could be replaced with an existential with a class bound, so that it becomes a typealias:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; typealias AnyObject = protocol&lt;class&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; See the “Existentials” section, particularly “Generalized existentials”, for more information.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; *Allowing subclasses to override requirements satisfied by defaults<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When a superclass conforms to a protocol and has one of the protocol’s requirements satisfied by a member of a protocol extension, that member currently cannot be overridden by a subclass. For example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;   func foo()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension P {<br>&gt;&gt;&gt;   func foo() { print(“P”) }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class C : P {<br>&gt;&gt;&gt;   // gets the protocol extension’s <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class D : C {<br>&gt;&gt;&gt;   /*override not allowed!*/ func foo() { print(“D”) }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let p: P = D()<br>&gt;&gt;&gt; p.foo() // gotcha: prints “P” rather than “D”!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; D.foo should be required to specify “override” and should be called dynamically.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Major extensions to the generics model<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Unlike the minor extensions, major extensions to the generics model provide more expressivity in the Swift generics system and, generally, have a much more significant design and implementation cost.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; *Conditional conformances<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Conditional conformances express the notion that a generic type will conform to a particular protocol only under certain circumstances. For example, Array is Equatable only when its elements are Equatable:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Array : Equatable where Element : Equatable { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func ==&lt;T : Equatable&gt;(lhs: Array&lt;T&gt;, rhs: Array&lt;T&gt;) -&gt; Bool { … }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Conditional conformances are a potentially very powerful feature. One important aspect of this feature is how deal with or avoid overlapping conformances. For example, imagine an adaptor over a Sequence that has conditional conformances to Collection and MutableCollection:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct SequenceAdaptor&lt;S: Sequence&gt; : Sequence { }<br>&gt;&gt;&gt; extension SequenceAdaptor : Collection where S: Collection { … }<br>&gt;&gt;&gt; extension SequenceAdaptor : MutableCollection where S: MutableCollection { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This should almost certainly be permitted, but we need to cope with or reject “overlapping” conformances:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension SequenceAdaptor : Collection where S: SomeOtherProtocolSimilarToCollection { } // trouble: two ways for SequenceAdaptor to conform to Collection<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; See the section on “Private conformances” for more about the issues with having the same type conform to the same protocol multiple times.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Variadic generics<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Currently, a generic parameter list contains a fixed number of generic parameters. If one has a type that could generalize to any number of generic parameters, the only real way to deal with it today involves creating a set of types. For example, consider the standard library’s “zip” function. It returns one of these when provided with two arguments to zip together:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public struct Zip2Sequence&lt;Sequence1 : Sequence,<br>&gt;&gt;&gt;                            Sequence2 : Sequence&gt; : Sequence { … }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public func zip&lt;Sequence1 : Sequence, Sequence2 : Sequence&gt;(<br>&gt;&gt;&gt;               sequence1: Sequence1, _ sequence2: Sequence2)<br>&gt;&gt;&gt;             -&gt; Zip2Sequence&lt;Sequence1, Sequence2&gt; { … }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Supporting three arguments would require copy-paste of those of those:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public struct Zip3Sequence&lt;Sequence1 : Sequence,<br>&gt;&gt;&gt;                            Sequence2 : Sequence,<br>&gt;&gt;&gt;                            Sequence3 : Sequence&gt; : Sequence { … }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public func zip&lt;Sequence1 : Sequence, Sequence2 : Sequence, Sequence3 : Sequence&gt;(<br>&gt;&gt;&gt;               sequence1: Sequence1, _ sequence2: Sequence2, _ sequence3: sequence3)<br>&gt;&gt;&gt;             -&gt; Zip3Sequence&lt;Sequence1, Sequence2, Sequence3&gt; { … }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Variadic generics would allow us to abstract over a set of generic parameters. The syntax below is hopelessly influenced by C++11 variadic templates &lt;http://www.jot.fm/issues/issue_2008_02/article2/&gt; (sorry), where putting an ellipsis (“…”) to the left of a declaration makes it a “parameter pack” containing zero or more parameters and putting an ellipsis to the right of a type/expression/etc. expands the parameter packs within that type/expression into separate arguments. The important part is that we be able to meaningfully abstract over zero or more generic parameters, e.g.:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public struct ZipIterator&lt;... Iterators : IteratorProtocol&gt; : Iterator {  // zero or more type parameters, each of which conforms to IteratorProtocol<br>&gt;&gt;&gt;   public typealias Element = (Iterators.Element...)                       // a tuple containing the element types of each iterator in Iterators<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   var (...iterators): (Iterators...)    // zero or more stored properties, one for each type in Iterators <br>&gt;&gt;&gt;   var reachedEnd: Bool = false<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   public mutating func next() -&gt; Element? {<br>&gt;&gt;&gt;     if reachedEnd { return nil }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     guard let values = (iterators.next()...) {   // call “next” on each of the iterators, put the results into a tuple named “values&quot;<br>&gt;&gt;&gt;       reachedEnd = true<br>&gt;&gt;&gt;       return nil<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     return values<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public struct ZipSequence&lt;...Sequences : Sequence&gt; : Sequence {<br>&gt;&gt;&gt;   public typealias Iterator = ZipIterator&lt;Sequences.Iterator...&gt;   // get the zip iterator with the iterator types of our Sequences<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   var (...sequences): (Sequences...)    // zero or more stored properties, one for each type in Sequences <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   // details ...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Such a design could also work for function parameters, so we can pack together multiple function arguments with different types, e.g.,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public func zip&lt;... Sequences : SequenceType&gt;(... sequences: Sequences...) <br>&gt;&gt;&gt;             -&gt; ZipSequence&lt;Sequences...&gt; {<br>&gt;&gt;&gt;   return ZipSequence(sequences...)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Finally, this could tie into the discussions about a tuple “splat” operator. For example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func apply&lt;... Args, Result&gt;(fn: (Args...) -&gt; Result,    // function taking some number of arguments and producing Result<br>&gt;&gt;&gt;                            args: (Args...)) -&gt; Result {  // tuple of arguments<br>&gt;&gt;&gt;   return fn(args...)                                     // expand the arguments in the tuple “args” into separate arguments<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Extensions of structural types<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Currently, only nominal types (classes, structs, enums, protocols) can be extended. One could imagine extending structural types—particularly tuple types—to allow them to, e.g., conform to protocols. For example, pulling together variadic generics, parameterized extensions, and conditional conformances, one could express “a tuple type is Equatable if all of its element types are Equatable”:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension&lt;...Elements : Equatable&gt; (Elements...) : Equatable {   // extending the tuple type “(Elements…)” to be Equatable<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are some natural bounds here: one would need to have actual structural types. One would not be able to extend every type:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension&lt;T&gt; T { // error: neither a structural nor a nominal type<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And before you think you’re cleverly making it possible to have a conditional conformance that makes every type T that conforms to protocol P also conform to protocol Q, see the section &quot;Conditional conformances via protocol extensions”, below:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension&lt;T : P&gt; T : Q { // error: neither a structural nor a nominal type<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Syntactic improvements<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are a number of potential improvements we could make to the generics syntax. Such a list could go on for a very long time, so I’ll only highlight some obvious ones that have been discussed by the Swift developers.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; *Default implementations in protocols<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Currently, protocol members can never have implementations. We could allow one to provide such implementations to be used as the default if a conforming type does not supply an implementation, e.g.,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol Bag {<br>&gt;&gt;&gt;   associatedtype Element : Equatable<br>&gt;&gt;&gt;   func contains(element: Element) -&gt; Bool<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   func containsAll&lt;S: Sequence where Sequence.Iterator.Element == Element&gt;(elements: S) -&gt; Bool {<br>&gt;&gt;&gt;     for x in elements {<br>&gt;&gt;&gt;       if contains(x) { return true }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     return false<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct IntBag : Bag {<br>&gt;&gt;&gt;   typealias Element = Int<br>&gt;&gt;&gt;   func contains(element: Int) -&gt; Bool { ... }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   // okay: containsAll requirement is satisfied by Bag’s default implementation<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One can get this effect with protocol extensions today, hence the classification of this feature as a (mostly) syntactic improvement:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol Bag {<br>&gt;&gt;&gt;   associatedtype Element : Equatable<br>&gt;&gt;&gt;   func contains(element: Element) -&gt; Bool<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   func containsAll&lt;S: Sequence where Sequence.Iterator.Element == Element&gt;(elements: S) -&gt; Bool<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Bag {<br>&gt;&gt;&gt;   func containsAll&lt;S: Sequence where Sequence.Iterator.Element == Element&gt;(elements: S) -&gt; Bool {<br>&gt;&gt;&gt;     for x in elements {<br>&gt;&gt;&gt;       if contains(x) { return true }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     return false<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; *Moving the where clause outside of the angle brackets<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The “where” clause of generic functions comes very early in the declaration, although it is generally of much less concern to the client than the function parameters and result type that follow it. This is one of the things that contributes to “angle bracket blindness”. For example, consider the containsAll signature above:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func containsAll&lt;S: Sequence where Sequence.Iterator.Element == Element&gt;(elements: S) -&gt; Bool<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One could move the “where” clause to the end of the signature, so that the most important parts—name, generic parameter, parameters, result type—precede it:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func containsAll&lt;S: Sequence&gt;(elements: S) -&gt; Bool <br>&gt;&gt;&gt;        where Sequence.Iterator.Element == Element<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; *Renaming “protocol&lt;…&gt;” to “Any&lt;…&gt;”.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The “protocol&lt;…&gt;” syntax is a bit of an oddity in Swift. It is used to compose protocols together, mostly to create values of existential type, e.g.,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var x: protocol&lt;NSCoding, NSCopying&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It’s weird that it’s a type name that starts with a lowercase letter, and most Swift developers probably never deal with this feature unless they happen to look at the definition of Any:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; typealias Any = protocol&lt;&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; “Any” might be a better name for this functionality. “Any” without brackets could be a keyword for “any type”, and “Any” followed by brackets could take the role of “protocol&lt;&gt;” today:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var x: Any&lt;NSCoding, NSCopying&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That reads much better: “Any type that conforms to NSCoding and NSCopying”. See the section &quot;Generalized existentials” for additional features in this space.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Maybe<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are a number of features that get discussed from time-to-time, while they could fit into Swift’s generics system, it’s not clear that they belong in Swift at all. The important question for any feature in this category is not “can it be done” or “are there cool things we can express”, but “how can everyday Swift developers benefit from the addition of such a feature?”. Without strong motivating examples, none of these “maybes” will move further along.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Dynamic dispatch for members of protocol extensions<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Only the requirements of protocols currently use dynamic dispatch, which can lead to surprises:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;   func foo()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension P {<br>&gt;&gt;&gt;   func foo() { print(“P.foo()”)<br>&gt;&gt;&gt;   func bar() { print(“P.bar()”)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct X : P {<br>&gt;&gt;&gt;   func foo() { print(“X.foo()”)<br>&gt;&gt;&gt;   func bar() { print(“X.bar()”)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let x = X()<br>&gt;&gt;&gt; x.foo() // X.foo()<br>&gt;&gt;&gt; x.bar() // X.bar()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let p: P = X()<br>&gt;&gt;&gt; p.foo() // X.foo()<br>&gt;&gt;&gt; p.bar() // P.bar()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift could adopt a model where members of protocol extensions are dynamically dispatched.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Named generic parameters<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When specifying generic arguments for a generic type, the arguments are always positional: Dictionary&lt;String, Int&gt; is a Dictionary whose Key type is String and whose Value type is Int, by convention. One could permit the arguments to be labeled, e.g.,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var d: Dictionary&lt;Key: String, Value: Int&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Such a feature makes more sense if Swift gains default generic arguments, because generic argument labels would allow one to skip defaulted arguments.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Generic value parameters<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Currently, Swift’s generic parameters are always types. One could imagine allowing generic parameters that are values, e.g.,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct MultiArray&lt;T, let Dimensions: Int&gt; { // specify the number of dimensions to the array<br>&gt;&gt;&gt;   subscript (indices: Int...) -&gt; T {<br>&gt;&gt;&gt;     get {<br>&gt;&gt;&gt;       require(indices.count == Dimensions)<br>&gt;&gt;&gt;       // ...<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A suitably general feature might allow us to express fixed-length array or vector types as a standard library component, and perhaps also allow one to implement a useful dimensional analysis library. Tackling this feature potentially means determining what it is for an expression to be a “constant expression” and diving into dependent-typing, hence the “maybe”.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Higher-kinded types<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Higher-kinded types allow one to express the relationship between two different specializations of the same nominal type within a protocol. For example, if we think of the Self type in a protocol as really being “Self&lt;T&gt;”, it allows us to talk about the relationship between “Self&lt;T&gt;” and “Self&lt;U&gt;” for some other type U. For example, it could allow the “map” operation on a collection to return a collection of the same kind but with a different operation, e.g.,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let intArray: Array&lt;Int&gt; = …<br>&gt;&gt;&gt; intArray.map { String($0) } // produces Array&lt;String&gt;<br>&gt;&gt;&gt; let intSet: Set&lt;Int&gt; = …<br>&gt;&gt;&gt; intSet.map { String($0) }   // produces Set&lt;String&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Potential syntax borrowed from one thread on higher-kinded types &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002736.html&gt; uses ~= as a “similarity” constraint to describe a Functor protocol:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol Functor {<br>&gt;&gt;&gt;   associatedtype A<br>&gt;&gt;&gt;   func fmap&lt;FB where FB ~= Self&gt;(f: A -&gt; FB.A) -&gt; FB<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Specifying type arguments for uses of generic functions<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The type arguments of a generic function are always determined via type inference. For example, given:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func f&lt;T&gt;(t: T)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; one cannot directly specify T: either one calls “f” (and T is determined via the argument’s type) or one uses “f” in a context where it is given a particular function type (e.g., “let x: (Int) -&gt; Void = f”  would infer T = Int). We could permit explicit specialization here, e.g.,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let x = f&lt;Int&gt; // x has type (Int) -&gt; Void<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Unlikely<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Features in this category have been requested at various times, but they don’t fit well with Swift’s generics system because they cause some part of the model to become overly complicated, have unacceptable implementation limitations, or overlap significantly with existing features.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Generic protocols<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One of the most commonly requested features is the ability to parameterize protocols themselves. For example, a protocol that indicates that the Self type can be constructed from some specified type T:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol ConstructibleFromValue&lt;T&gt; {<br>&gt;&gt;&gt;   init(_ value: T)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Implicit in this feature is the ability for a given type to conform to the protocol in two different ways. A “Real” type might be constructible from both Float and Double, e.g.,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Real { … }<br>&gt;&gt;&gt; extension Real : ConstructibleFrom&lt;Float&gt; {<br>&gt;&gt;&gt;   init(_ value: Float) { … }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; extension Real : ConstructibleFrom&lt;Double&gt; {<br>&gt;&gt;&gt;   init(_ value: Double) { … }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Most of the requests for this feature actually want a different feature. They tend to use a parameterized Sequence as an example, e.g.,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol Sequence&lt;Element&gt; { … }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func foo(strings: Sequence&lt;String&gt;) {  /// works on any sequence containing Strings<br>&gt;&gt;&gt;   // ...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The actual requested feature here 	is the ability to say “Any type that conforms to Sequence whose Element type is String”, which is covered by the section on “Generalized existentials”, below.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; More importantly, modeling Sequence with generic parameters rather than associated types is tantalizing but wrong: you don’t want a type conforming to Sequence in multiple ways, or (among other things) your for..in loops stop working, and you lose the ability to dynamically cast down to an existential “Sequence” without binding the Element type (again, see “Generalized existentials”). Use cases similar to the ConstructibleFromValue protocol above seem too few to justify the potential for confusion between associated types and generic parameters of protocols; we’re better off not having the latter.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Private conformances <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Right now, a protocol conformance can be no less visible than the minimum of the conforming type’s access and the protocol’s access. Therefore, a public type conforming to a public protocol must provide the conformance publicly. One could imagine removing that restriction, so that one could introduce a private conformance:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public protocol P { }<br>&gt;&gt;&gt; public struct X { }<br>&gt;&gt;&gt; extension X : internal P { … } // X conforms to P, but only within this module<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The main problem with private conformances is the interaction with dynamic casting. If I have this code:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func foo(value: Any) {<br>&gt;&gt;&gt;   if let x = value as? P { print(“P”) }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; foo(X())<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Under what circumstances should it print “P”? If foo() is defined within the same module as the conformance of X to P? If the call is defined within the same module as the conformance of X to P? Never? Either of the first two answers requires significant complications in the dynamic casting infrastructure to take into account the module in which a particular dynamic cast occurred (the first option) or where an existential was formed (the second option), while the third answer breaks the link between the static and dynamic type systems—none of which is an acceptable result.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Conditional conformances via protocol extensions<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We often get requests to make a protocol conform to another protocol. This is, effectively, the expansion of the notion of “Conditional conformances” to protocol extensions. For example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;   func foo()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol Q {<br>&gt;&gt;&gt;   func bar()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Q : P { // every type that conforms to Q also conforms to P<br>&gt;&gt;&gt;   func foo() {    // implement “foo” requirement in terms of “bar&quot;<br>&gt;&gt;&gt;     bar()<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func f&lt;T: P&gt;(t: T) { … }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct X : Q {<br>&gt;&gt;&gt;   func bar() { … }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; f(X()) // okay: X conforms to P through the conformance of Q to P<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is an extremely powerful feature: is allows one to map the abstractions of one domain into another domain (e.g., every Matrix is a Graph). However, similar to private conformances, it puts a major burden on the dynamic-casting runtime to chase down arbitrarily long and potentially cyclic chains of conformances, which makes efficient implementation nearly impossible.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Potential removals<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The generics system doesn’t seem like a good candidate for a reduction in scope; most of its features do get used fairly pervasively in the standard library, and few feel overly anachronistic. However...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Associated type inference<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Associated type inference is the process by which we infer the type bindings for associated types from other requirements. For example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol IteratorProtocol {<br>&gt;&gt;&gt;   associatedtype Element<br>&gt;&gt;&gt;   mutating func next() -&gt; Element?<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct IntIterator : IteratorProtocol {<br>&gt;&gt;&gt;   mutating func next() -&gt; Int? { … }  // use this to infer Element = Int<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Associated type inference is a useful feature. It’s used throughout the standard library, and it helps keep associated types less visible to types that simply want to conform to a protocol. On the other hand, associated type inference is the only place in Swift where we have a global type inference problem: it has historically been a major source of bugs, and implementing it fully and correctly requires a drastically different architecture to the type checker. Is the value of this feature worth keeping global type inference in the Swift language, when we have deliberatively avoided global type inference elsewhere in the language?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Existentials<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Existentials aren’t really generics per se, but the two systems are closely intertwined due to their mutable dependence on protocols.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; *Generalized existentials<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The restrictions on existential types came from an implementation limitation, but it is reasonable to allow a value of protocol type even when the protocol has Self constraints or associated types. For example, consider IteratorProtocol again and how it could be used as an existential:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol IteratorProtocol {<br>&gt;&gt;&gt;   associatedtype Element<br>&gt;&gt;&gt;   mutating func next() -&gt; Element?<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let it: IteratorProtocol = …<br>&gt;&gt;&gt; it.next()   // if this is permitted, it could return an “Any?”, i.e., the existential that wraps the actual element<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Additionally, it is reasonable to want to constrain the associated types of an existential, e.g., “a Sequence whose element type is String” could be expressed by putting a where clause into “protocol&lt;…&gt;” or “Any&lt;…&gt;” (per “Renaming protocol&lt;…&gt; to Any&lt;…&gt;”):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let strings: Any&lt;Sequence where .Iterator.Element == String&gt; = [“a”, “b”, “c”]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The leading “.” indicates that we’re talking about the dynamic type, i.e., the “Self” type that’s conforming to the Sequence protocol. There’s no reason why we cannot support arbitrary “where” clauses within the “Any&lt;…&gt;”. This very-general syntax is a bit unwieldy, but common cases can easily be wrapped up in a generic typealias (see the section “Generic typealiases” above):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; typealias AnySequence&lt;Element&gt; = Any&lt;Sequence where .Iterator.Element == Element&gt;<br>&gt;&gt;&gt; let strings: AnySequence&lt;String&gt; = [“a”, “b”, “c”]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Opening existentials<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Generalized existentials as described above will still have trouble with protocol requirements that involve Self or associated types in function parameters. For example, let’s try to use Equatable as an existential:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol Equatable {<br>&gt;&gt;&gt;   func ==(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;&gt;   func !=(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let e1: Equatable = …<br>&gt;&gt;&gt; let e2: Equatable = …<br>&gt;&gt;&gt; if e1 == e2 { … } // error: e1 and e2 don’t necessarily have the same dynamic type<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One explicit way to allow such operations in a type-safe manner is to introduce an “open existential” operation of some sort, which extracts and gives a name to the dynamic type stored inside an existential. For example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	 <br>&gt;&gt;&gt; if let storedInE1 = e1 openas T {     // T is a the type of storedInE1, a copy of the value stored in e1<br>&gt;&gt;&gt;   if let storedInE2 = e2 as? T {      // is e2 also a T?<br>&gt;&gt;&gt;     if storedInE1 == storedInE2 { … } // okay: storedInT1 and storedInE2 are both of type T, which we know is Equatable<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160508/0ed72b30/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Manifesto] Completing Generics</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>May  8, 2016 at 11:00:00pm</p></header><div class="content"><p>Sorry, I misunderstood that you meant that the version of Concrete same-type requirement that does not introduce new syntax could be sent through as a bug request. It’s now done:<br></p><p>[SR-1447] Concrete same-type requirements &lt;https://bugs.swift.org/browse/SR-1447&gt;<br></p><p>&gt; On 08 May 2016, at 23:17, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I created two bug requests for Recursive protocol constraints and Nested generics and will write a proposal for Concrete same-type requirements.<br>&gt; <br>&gt; [SR-1445] Recursive protocol constraints &lt;https://bugs.swift.org/browse/SR-1445&gt;<br>&gt; <br>&gt; [SR-1446] Nested generics &lt;https://bugs.swift.org/browse/SR-1446&gt;<br>&gt;&gt; On 03 May 2016, at 09:58, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt; On May 2, 2016, at 3:58 PM, David Hart &lt;david at hartbit.com &lt;mailto:david at hartbit.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; I’d like to continue moving Completing Generics forward for Swift 3 with proposals. Can Douglas, or someone from the core team, tell me if the topics mentioned in Removing unnecessary restrictions require proposals or if bug reports should be opened for them instead?<br>&gt;&gt; <br>&gt;&gt; I&#39;d classify everything in that section as a bug, so long as we&#39;re restricting ourselves to the syntax already present in the language. Syntactic improvements (e.g., for same-type-to-concrete constraints) would require a proposal. <br>&gt;&gt; <br>&gt;&gt;   - Doug<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 03 Mar 2016, at 02:22, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The “Complete Generics” goal for Swift 3 has been fairly ill-defined thus fair, with just this short blurb in the list of goals:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Complete generics: Generics are used pervasively in a number of Swift libraries, especially the standard library. However, there are a number of generics features the standard library requires to fully realize its vision, including recursive protocol constraints, the ability to make a constrained extension conform to a new protocol (i.e., an array of Equatable elements is Equatable), and so on. Swift 3.0 should provide those generics features needed by the standard library, because they affect the standard library&#39;s ABI.<br>&gt;&gt;&gt;&gt; This message expands upon the notion of “completing generics”. It is not a plan for Swift 3, nor an official core team communication, but it collects the results of numerous discussions among the core team and Swift developers, both of the compiler and the standard library. I hope to achieve several things:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Communicate a vision for Swift generics, building on the original generics design document &lt;https://github.com/apple/swift/blob/master/docs/Generics.rst&gt;, so we have something concrete and comprehensive to discuss.<br>&gt;&gt;&gt;&gt; Establish some terminology that the Swift developers have been using for these features, so our discussions can be more productive (“oh, you’re proposing what we refer to as ‘conditional conformances’; go look over at this thread”).<br>&gt;&gt;&gt;&gt; Engage more of the community in discussions of specific generics features, so we can coalesce around designs for public review. And maybe even get some of them implemented.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A message like this can easily turn into a centithread &lt;http://www.urbandictionary.com/define.php?term=centithread&gt;. To separate concerns in our discussion, I ask that replies to this specific thread be limited to discussions of the vision as a whole: how the pieces fit together, what pieces are missing, whether this is the right long-term vision for Swift, and so on. For discussions of specific language features, e.g., to work out the syntax and semantics of conditional conformances or discuss the implementation in compiler or use in the standard library, please start a new thread based on the feature names I’m using.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This message covers a lot of ground; I’ve attempted a rough categorization of the various features, and kept the descriptions brief to limit the overall length. Most of these aren’t my ideas, and any syntax I’m providing is simply a way to express these ideas in code and is subject to change. Not all of these features will happen, either soon or ever, but they are intended to be a fairly complete whole that should mesh together. I’ve put a * next to features that I think are important in the nearer term vs. being interesting “some day”. Mostly, the *’s reflect features that will have a significant impact on the Swift standard library’s design and implementation.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Enough with the disclaimers; it’s time to talk features.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Removing unnecessary restrictions<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are a number of restrictions to the use of generics that fall out of the implementation in the Swift compiler. Removal of these restrictions is a matter of implementation only; one need not introduce new syntax or semantics to realize them. I’m listing them for two reasons: first, it’s an acknowledgment that these features are intended to exist in the model we have today, and, second, we’d love help with the implementation of these features.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; *Recursive protocol constraints<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Currently, an associated type cannot be required to conform to its enclosing protocol (or any protocol that inherits that protocol). For example, in the standard library SubSequence type of a Sequence should itself be a Sequence:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol Sequence {<br>&gt;&gt;&gt;&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;&gt;&gt;&gt;   …<br>&gt;&gt;&gt;&gt;   associatedtype SubSequence : Sequence   // currently ill-formed, but should be possible<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The compiler currently rejects this protocol, which is unfortunate: it effectively pushes the SubSequence-must-be-a-Sequence requirement into every consumer of SubSequence, and does not communicate the intent of this abstraction well.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Nested generics<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Currently, a generic type cannot be nested within another generic type, e.g.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct X&lt;T&gt; {<br>&gt;&gt;&gt;&gt;   struct Y&lt;U&gt; { }  // currently ill-formed, but should be possible<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There isn’t much to say about this: the compiler simply needs to be improved to handle nested generics throughout.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Concrete same-type requirements<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Currently, a constrained extension cannot use a same-type constraint to make a type parameter equivalent to a concrete type. For example:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension Array where Element == String {<br>&gt;&gt;&gt;&gt;   func makeSentence() -&gt; String {<br>&gt;&gt;&gt;&gt;     // uppercase first string, concatenate with spaces, add a period, whatever<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is a highly-requested feature that fits into the existing syntax and semantics. Note that one could imagine introducing new syntax, e.g., extending “Array&lt;String&gt;”, which gets into new-feature territory: see the section on “Parameterized extensions”.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Parameterizing other declarations<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are a number of Swift declarations that currently cannot have generic parameters; some of those have fairly natural extensions to generic forms that maintain their current syntax and semantics, but become more powerful when made generic.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Generic typealiases<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Typealiases could be allowed to carry generic parameters. They would still be aliases (i.e., they would not introduce new types). For example:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; typealias StringDictionary&lt;Value&gt; = Dictionary&lt;String, Value&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var d1 = StringDictionary&lt;Int&gt;()<br>&gt;&gt;&gt;&gt; var d2: Dictionary&lt;String, Int&gt; = d1 // okay: d1 and d2 have the same type, Dictionary&lt;String, Int&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Generic subscripts<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Subscripts could be allowed to have generic parameters. For example, we could introduce a generic subscript on a Collection that allows us to pull out the values at an arbitrary set of indices:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension Collection {<br>&gt;&gt;&gt;&gt;   subscript&lt;Indices: Sequence where Indices.Iterator.Element == Index&gt;(indices: Indices) -&gt; [Iterator.Element] {<br>&gt;&gt;&gt;&gt;     get {<br>&gt;&gt;&gt;&gt;       var result = [Iterator.Element]()<br>&gt;&gt;&gt;&gt;       for index in indices {<br>&gt;&gt;&gt;&gt;         result.append(self[index])<br>&gt;&gt;&gt;&gt;       }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       return result<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     set {<br>&gt;&gt;&gt;&gt;       for (index, value) in zip(indices, newValue) {<br>&gt;&gt;&gt;&gt;         self[index] = value<br>&gt;&gt;&gt;&gt;       }<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Generic constants<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let constants could be allowed to have generic parameters, such that they produce differently-typed values depending on how they are used. For example, this is particularly useful for named literal values, e.g.,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let π&lt;T : FloatLiteralConvertible&gt;: T = 3.141592653589793238462643383279502884197169399<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The Clang importer could make particularly good use of this when importing macros.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Parameterized extensions<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Extensions themselves could be parameterized, which would allow some structural pattern matching on types. For example, this would permit one to extend an array of optional values, e.g.,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension&lt;T&gt; Array where Element == T? {<br>&gt;&gt;&gt;&gt;   var someValues: [T] {<br>&gt;&gt;&gt;&gt;     var result = [T]()<br>&gt;&gt;&gt;&gt;     for opt in self {<br>&gt;&gt;&gt;&gt;       if let value = opt { result.append(value) }<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;    return result<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We can generalize this to a protocol extensions:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension&lt;T&gt; Sequence where Element == T? {<br>&gt;&gt;&gt;&gt;   var someValues: [T] {<br>&gt;&gt;&gt;&gt;     var result = [T]()<br>&gt;&gt;&gt;&gt;     for opt in self {<br>&gt;&gt;&gt;&gt;       if let value = opt { result.append(value) }<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;    return result<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Note that when one is extending nominal types, we could simplify the syntax somewhat to make the same-type constraint implicit in the syntax:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension&lt;T&gt; Array&lt;T?&gt; {<br>&gt;&gt;&gt;&gt;   var someValues: [T] {<br>&gt;&gt;&gt;&gt;     var result = [T]()<br>&gt;&gt;&gt;&gt;     for opt in self {<br>&gt;&gt;&gt;&gt;       if let value = opt { result.append(value) }<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;    return result<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; When we’re working with concrete types, we can use that syntax to improve the extension of concrete versions of generic types (per “Concrete same-type requirements”, above), e.g.,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension Array&lt;String&gt; {<br>&gt;&gt;&gt;&gt;   func makeSentence() -&gt; String {<br>&gt;&gt;&gt;&gt;     // uppercase first string, concatenate with spaces, add a period, whatever<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Minor extensions<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are a number of minor extensions we can make to the generics system that don’t fundamentally change what one can express in Swift, but which can improve its expressivity.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; *Arbitrary requirements in protocols<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Currently, a new protocol can inherit from other protocols, introduce new associated types, and add new conformance constraints to associated types (by redeclaring an associated type from an inherited protocol). However, one cannot express more general constraints. Building on the example from “Recursive protocol constraints”, we really want the element type of a Sequence’s SubSequence to be the same as the element type of the Sequence, e.g.,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol Sequence {<br>&gt;&gt;&gt;&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;&gt;&gt;&gt;   …<br>&gt;&gt;&gt;&gt;   associatedtype SubSequence : Sequence where SubSequence.Iterator.Element == Iterator.Element<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hanging the where clause off the associated type is protocol not ideal, but that’s a discussion for another thread.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; *Typealiases in protocols and protocol extensions<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Now that associated types have their own keyword (thanks!), it’s reasonable to bring back “typealias”. Again with the Sequence protocol:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol Sequence {<br>&gt;&gt;&gt;&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;&gt;&gt;&gt;   typealias Element = Iterator.Element   // rejoice! now we can refer to SomeSequence.Element rather than SomeSequence.Iterator.Element<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Default generic arguments <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Generic parameters could be given the ability to provide default arguments, which would be used in cases where the type argument is not specified and type inference could not determine the type argument. For example:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; public final class Promise&lt;Value, Reason=Error&gt; { … }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func getRandomPromise() -&gt; Promise&lt;Int, ErrorProtocol&gt; { … }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var p1: Promise&lt;Int&gt; = …<br>&gt;&gt;&gt;&gt; var p2: Promise&lt;Int, Error&gt; = p1     // okay: p1 and p2 have the same type Promise&lt;Int, Error&gt;<br>&gt;&gt;&gt;&gt; var p3: Promise = getRandomPromise() // p3 has type Promise&lt;Int, ErrorProtocol&gt; due to type inference<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Generalized “class” constraints<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The “class” constraint can currently only be used for defining protocols. We could generalize it to associated type and type parameter declarations, e.g.,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;&gt;   associatedtype A : class<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func foo&lt;T : class&gt;(t: T) { }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As part of this, the magical AnyObject protocol could be replaced with an existential with a class bound, so that it becomes a typealias:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; typealias AnyObject = protocol&lt;class&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; See the “Existentials” section, particularly “Generalized existentials”, for more information.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; *Allowing subclasses to override requirements satisfied by defaults<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; When a superclass conforms to a protocol and has one of the protocol’s requirements satisfied by a member of a protocol extension, that member currently cannot be overridden by a subclass. For example:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;&gt;   func foo()<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension P {<br>&gt;&gt;&gt;&gt;   func foo() { print(“P”) }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class C : P {<br>&gt;&gt;&gt;&gt;   // gets the protocol extension’s <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class D : C {<br>&gt;&gt;&gt;&gt;   /*override not allowed!*/ func foo() { print(“D”) }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let p: P = D()<br>&gt;&gt;&gt;&gt; p.foo() // gotcha: prints “P” rather than “D”!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; D.foo should be required to specify “override” and should be called dynamically.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Major extensions to the generics model<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Unlike the minor extensions, major extensions to the generics model provide more expressivity in the Swift generics system and, generally, have a much more significant design and implementation cost.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; *Conditional conformances<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Conditional conformances express the notion that a generic type will conform to a particular protocol only under certain circumstances. For example, Array is Equatable only when its elements are Equatable:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension Array : Equatable where Element : Equatable { }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func ==&lt;T : Equatable&gt;(lhs: Array&lt;T&gt;, rhs: Array&lt;T&gt;) -&gt; Bool { … }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Conditional conformances are a potentially very powerful feature. One important aspect of this feature is how deal with or avoid overlapping conformances. For example, imagine an adaptor over a Sequence that has conditional conformances to Collection and MutableCollection:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct SequenceAdaptor&lt;S: Sequence&gt; : Sequence { }<br>&gt;&gt;&gt;&gt; extension SequenceAdaptor : Collection where S: Collection { … }<br>&gt;&gt;&gt;&gt; extension SequenceAdaptor : MutableCollection where S: MutableCollection { }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This should almost certainly be permitted, but we need to cope with or reject “overlapping” conformances:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension SequenceAdaptor : Collection where S: SomeOtherProtocolSimilarToCollection { } // trouble: two ways for SequenceAdaptor to conform to Collection<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; See the section on “Private conformances” for more about the issues with having the same type conform to the same protocol multiple times.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Variadic generics<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Currently, a generic parameter list contains a fixed number of generic parameters. If one has a type that could generalize to any number of generic parameters, the only real way to deal with it today involves creating a set of types. For example, consider the standard library’s “zip” function. It returns one of these when provided with two arguments to zip together:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; public struct Zip2Sequence&lt;Sequence1 : Sequence,<br>&gt;&gt;&gt;&gt;                            Sequence2 : Sequence&gt; : Sequence { … }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; public func zip&lt;Sequence1 : Sequence, Sequence2 : Sequence&gt;(<br>&gt;&gt;&gt;&gt;               sequence1: Sequence1, _ sequence2: Sequence2)<br>&gt;&gt;&gt;&gt;             -&gt; Zip2Sequence&lt;Sequence1, Sequence2&gt; { … }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Supporting three arguments would require copy-paste of those of those:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; public struct Zip3Sequence&lt;Sequence1 : Sequence,<br>&gt;&gt;&gt;&gt;                            Sequence2 : Sequence,<br>&gt;&gt;&gt;&gt;                            Sequence3 : Sequence&gt; : Sequence { … }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; public func zip&lt;Sequence1 : Sequence, Sequence2 : Sequence, Sequence3 : Sequence&gt;(<br>&gt;&gt;&gt;&gt;               sequence1: Sequence1, _ sequence2: Sequence2, _ sequence3: sequence3)<br>&gt;&gt;&gt;&gt;             -&gt; Zip3Sequence&lt;Sequence1, Sequence2, Sequence3&gt; { … }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Variadic generics would allow us to abstract over a set of generic parameters. The syntax below is hopelessly influenced by C++11 variadic templates &lt;http://www.jot.fm/issues/issue_2008_02/article2/&gt; (sorry), where putting an ellipsis (“…”) to the left of a declaration makes it a “parameter pack” containing zero or more parameters and putting an ellipsis to the right of a type/expression/etc. expands the parameter packs within that type/expression into separate arguments. The important part is that we be able to meaningfully abstract over zero or more generic parameters, e.g.:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; public struct ZipIterator&lt;... Iterators : IteratorProtocol&gt; : Iterator {  // zero or more type parameters, each of which conforms to IteratorProtocol<br>&gt;&gt;&gt;&gt;   public typealias Element = (Iterators.Element...)                       // a tuple containing the element types of each iterator in Iterators<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   var (...iterators): (Iterators...)    // zero or more stored properties, one for each type in Iterators <br>&gt;&gt;&gt;&gt;   var reachedEnd: Bool = false<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   public mutating func next() -&gt; Element? {<br>&gt;&gt;&gt;&gt;     if reachedEnd { return nil }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     guard let values = (iterators.next()...) {   // call “next” on each of the iterators, put the results into a tuple named “values&quot;<br>&gt;&gt;&gt;&gt;       reachedEnd = true<br>&gt;&gt;&gt;&gt;       return nil<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     return values<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; public struct ZipSequence&lt;...Sequences : Sequence&gt; : Sequence {<br>&gt;&gt;&gt;&gt;   public typealias Iterator = ZipIterator&lt;Sequences.Iterator...&gt;   // get the zip iterator with the iterator types of our Sequences<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   var (...sequences): (Sequences...)    // zero or more stored properties, one for each type in Sequences <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   // details ...<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Such a design could also work for function parameters, so we can pack together multiple function arguments with different types, e.g.,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; public func zip&lt;... Sequences : SequenceType&gt;(... sequences: Sequences...) <br>&gt;&gt;&gt;&gt;             -&gt; ZipSequence&lt;Sequences...&gt; {<br>&gt;&gt;&gt;&gt;   return ZipSequence(sequences...)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Finally, this could tie into the discussions about a tuple “splat” operator. For example:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func apply&lt;... Args, Result&gt;(fn: (Args...) -&gt; Result,    // function taking some number of arguments and producing Result<br>&gt;&gt;&gt;&gt;                            args: (Args...)) -&gt; Result {  // tuple of arguments<br>&gt;&gt;&gt;&gt;   return fn(args...)                                     // expand the arguments in the tuple “args” into separate arguments<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Extensions of structural types<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Currently, only nominal types (classes, structs, enums, protocols) can be extended. One could imagine extending structural types—particularly tuple types—to allow them to, e.g., conform to protocols. For example, pulling together variadic generics, parameterized extensions, and conditional conformances, one could express “a tuple type is Equatable if all of its element types are Equatable”:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension&lt;...Elements : Equatable&gt; (Elements...) : Equatable {   // extending the tuple type “(Elements…)” to be Equatable<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are some natural bounds here: one would need to have actual structural types. One would not be able to extend every type:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension&lt;T&gt; T { // error: neither a structural nor a nominal type<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And before you think you’re cleverly making it possible to have a conditional conformance that makes every type T that conforms to protocol P also conform to protocol Q, see the section &quot;Conditional conformances via protocol extensions”, below:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension&lt;T : P&gt; T : Q { // error: neither a structural nor a nominal type<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Syntactic improvements<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are a number of potential improvements we could make to the generics syntax. Such a list could go on for a very long time, so I’ll only highlight some obvious ones that have been discussed by the Swift developers.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; *Default implementations in protocols<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Currently, protocol members can never have implementations. We could allow one to provide such implementations to be used as the default if a conforming type does not supply an implementation, e.g.,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol Bag {<br>&gt;&gt;&gt;&gt;   associatedtype Element : Equatable<br>&gt;&gt;&gt;&gt;   func contains(element: Element) -&gt; Bool<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   func containsAll&lt;S: Sequence where Sequence.Iterator.Element == Element&gt;(elements: S) -&gt; Bool {<br>&gt;&gt;&gt;&gt;     for x in elements {<br>&gt;&gt;&gt;&gt;       if contains(x) { return true }<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;     return false<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct IntBag : Bag {<br>&gt;&gt;&gt;&gt;   typealias Element = Int<br>&gt;&gt;&gt;&gt;   func contains(element: Int) -&gt; Bool { ... }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   // okay: containsAll requirement is satisfied by Bag’s default implementation<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One can get this effect with protocol extensions today, hence the classification of this feature as a (mostly) syntactic improvement:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol Bag {<br>&gt;&gt;&gt;&gt;   associatedtype Element : Equatable<br>&gt;&gt;&gt;&gt;   func contains(element: Element) -&gt; Bool<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   func containsAll&lt;S: Sequence where Sequence.Iterator.Element == Element&gt;(elements: S) -&gt; Bool<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension Bag {<br>&gt;&gt;&gt;&gt;   func containsAll&lt;S: Sequence where Sequence.Iterator.Element == Element&gt;(elements: S) -&gt; Bool {<br>&gt;&gt;&gt;&gt;     for x in elements {<br>&gt;&gt;&gt;&gt;       if contains(x) { return true }<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;     return false<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; *Moving the where clause outside of the angle brackets<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The “where” clause of generic functions comes very early in the declaration, although it is generally of much less concern to the client than the function parameters and result type that follow it. This is one of the things that contributes to “angle bracket blindness”. For example, consider the containsAll signature above:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func containsAll&lt;S: Sequence where Sequence.Iterator.Element == Element&gt;(elements: S) -&gt; Bool<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One could move the “where” clause to the end of the signature, so that the most important parts—name, generic parameter, parameters, result type—precede it:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func containsAll&lt;S: Sequence&gt;(elements: S) -&gt; Bool <br>&gt;&gt;&gt;&gt;        where Sequence.Iterator.Element == Element<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; *Renaming “protocol&lt;…&gt;” to “Any&lt;…&gt;”.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The “protocol&lt;…&gt;” syntax is a bit of an oddity in Swift. It is used to compose protocols together, mostly to create values of existential type, e.g.,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var x: protocol&lt;NSCoding, NSCopying&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It’s weird that it’s a type name that starts with a lowercase letter, and most Swift developers probably never deal with this feature unless they happen to look at the definition of Any:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; typealias Any = protocol&lt;&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; “Any” might be a better name for this functionality. “Any” without brackets could be a keyword for “any type”, and “Any” followed by brackets could take the role of “protocol&lt;&gt;” today:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var x: Any&lt;NSCoding, NSCopying&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That reads much better: “Any type that conforms to NSCoding and NSCopying”. See the section &quot;Generalized existentials” for additional features in this space.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Maybe<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are a number of features that get discussed from time-to-time, while they could fit into Swift’s generics system, it’s not clear that they belong in Swift at all. The important question for any feature in this category is not “can it be done” or “are there cool things we can express”, but “how can everyday Swift developers benefit from the addition of such a feature?”. Without strong motivating examples, none of these “maybes” will move further along.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Dynamic dispatch for members of protocol extensions<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Only the requirements of protocols currently use dynamic dispatch, which can lead to surprises:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;&gt;   func foo()<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension P {<br>&gt;&gt;&gt;&gt;   func foo() { print(“P.foo()”)<br>&gt;&gt;&gt;&gt;   func bar() { print(“P.bar()”)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct X : P {<br>&gt;&gt;&gt;&gt;   func foo() { print(“X.foo()”)<br>&gt;&gt;&gt;&gt;   func bar() { print(“X.bar()”)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let x = X()<br>&gt;&gt;&gt;&gt; x.foo() // X.foo()<br>&gt;&gt;&gt;&gt; x.bar() // X.bar()<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let p: P = X()<br>&gt;&gt;&gt;&gt; p.foo() // X.foo()<br>&gt;&gt;&gt;&gt; p.bar() // P.bar()<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Swift could adopt a model where members of protocol extensions are dynamically dispatched.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Named generic parameters<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; When specifying generic arguments for a generic type, the arguments are always positional: Dictionary&lt;String, Int&gt; is a Dictionary whose Key type is String and whose Value type is Int, by convention. One could permit the arguments to be labeled, e.g.,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var d: Dictionary&lt;Key: String, Value: Int&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Such a feature makes more sense if Swift gains default generic arguments, because generic argument labels would allow one to skip defaulted arguments.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Generic value parameters<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Currently, Swift’s generic parameters are always types. One could imagine allowing generic parameters that are values, e.g.,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct MultiArray&lt;T, let Dimensions: Int&gt; { // specify the number of dimensions to the array<br>&gt;&gt;&gt;&gt;   subscript (indices: Int...) -&gt; T {<br>&gt;&gt;&gt;&gt;     get {<br>&gt;&gt;&gt;&gt;       require(indices.count == Dimensions)<br>&gt;&gt;&gt;&gt;       // ...<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A suitably general feature might allow us to express fixed-length array or vector types as a standard library component, and perhaps also allow one to implement a useful dimensional analysis library. Tackling this feature potentially means determining what it is for an expression to be a “constant expression” and diving into dependent-typing, hence the “maybe”.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Higher-kinded types<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Higher-kinded types allow one to express the relationship between two different specializations of the same nominal type within a protocol. For example, if we think of the Self type in a protocol as really being “Self&lt;T&gt;”, it allows us to talk about the relationship between “Self&lt;T&gt;” and “Self&lt;U&gt;” for some other type U. For example, it could allow the “map” operation on a collection to return a collection of the same kind but with a different operation, e.g.,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let intArray: Array&lt;Int&gt; = …<br>&gt;&gt;&gt;&gt; intArray.map { String($0) } // produces Array&lt;String&gt;<br>&gt;&gt;&gt;&gt; let intSet: Set&lt;Int&gt; = …<br>&gt;&gt;&gt;&gt; intSet.map { String($0) }   // produces Set&lt;String&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Potential syntax borrowed from one thread on higher-kinded types &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002736.html&gt; uses ~= as a “similarity” constraint to describe a Functor protocol:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol Functor {<br>&gt;&gt;&gt;&gt;   associatedtype A<br>&gt;&gt;&gt;&gt;   func fmap&lt;FB where FB ~= Self&gt;(f: A -&gt; FB.A) -&gt; FB<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Specifying type arguments for uses of generic functions<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The type arguments of a generic function are always determined via type inference. For example, given:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func f&lt;T&gt;(t: T)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; one cannot directly specify T: either one calls “f” (and T is determined via the argument’s type) or one uses “f” in a context where it is given a particular function type (e.g., “let x: (Int) -&gt; Void = f”  would infer T = Int). We could permit explicit specialization here, e.g.,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let x = f&lt;Int&gt; // x has type (Int) -&gt; Void<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Unlikely<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Features in this category have been requested at various times, but they don’t fit well with Swift’s generics system because they cause some part of the model to become overly complicated, have unacceptable implementation limitations, or overlap significantly with existing features.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Generic protocols<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One of the most commonly requested features is the ability to parameterize protocols themselves. For example, a protocol that indicates that the Self type can be constructed from some specified type T:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol ConstructibleFromValue&lt;T&gt; {<br>&gt;&gt;&gt;&gt;   init(_ value: T)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Implicit in this feature is the ability for a given type to conform to the protocol in two different ways. A “Real” type might be constructible from both Float and Double, e.g.,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct Real { … }<br>&gt;&gt;&gt;&gt; extension Real : ConstructibleFrom&lt;Float&gt; {<br>&gt;&gt;&gt;&gt;   init(_ value: Float) { … }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; extension Real : ConstructibleFrom&lt;Double&gt; {<br>&gt;&gt;&gt;&gt;   init(_ value: Double) { … }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Most of the requests for this feature actually want a different feature. They tend to use a parameterized Sequence as an example, e.g.,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol Sequence&lt;Element&gt; { … }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func foo(strings: Sequence&lt;String&gt;) {  /// works on any sequence containing Strings<br>&gt;&gt;&gt;&gt;   // ...<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The actual requested feature here 	is the ability to say “Any type that conforms to Sequence whose Element type is String”, which is covered by the section on “Generalized existentials”, below.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; More importantly, modeling Sequence with generic parameters rather than associated types is tantalizing but wrong: you don’t want a type conforming to Sequence in multiple ways, or (among other things) your for..in loops stop working, and you lose the ability to dynamically cast down to an existential “Sequence” without binding the Element type (again, see “Generalized existentials”). Use cases similar to the ConstructibleFromValue protocol above seem too few to justify the potential for confusion between associated types and generic parameters of protocols; we’re better off not having the latter.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Private conformances <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Right now, a protocol conformance can be no less visible than the minimum of the conforming type’s access and the protocol’s access. Therefore, a public type conforming to a public protocol must provide the conformance publicly. One could imagine removing that restriction, so that one could introduce a private conformance:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; public protocol P { }<br>&gt;&gt;&gt;&gt; public struct X { }<br>&gt;&gt;&gt;&gt; extension X : internal P { … } // X conforms to P, but only within this module<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The main problem with private conformances is the interaction with dynamic casting. If I have this code:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func foo(value: Any) {<br>&gt;&gt;&gt;&gt;   if let x = value as? P { print(“P”) }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; foo(X())<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Under what circumstances should it print “P”? If foo() is defined within the same module as the conformance of X to P? If the call is defined within the same module as the conformance of X to P? Never? Either of the first two answers requires significant complications in the dynamic casting infrastructure to take into account the module in which a particular dynamic cast occurred (the first option) or where an existential was formed (the second option), while the third answer breaks the link between the static and dynamic type systems—none of which is an acceptable result.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Conditional conformances via protocol extensions<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We often get requests to make a protocol conform to another protocol. This is, effectively, the expansion of the notion of “Conditional conformances” to protocol extensions. For example:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;&gt;   func foo()<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol Q {<br>&gt;&gt;&gt;&gt;   func bar()<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension Q : P { // every type that conforms to Q also conforms to P<br>&gt;&gt;&gt;&gt;   func foo() {    // implement “foo” requirement in terms of “bar&quot;<br>&gt;&gt;&gt;&gt;     bar()<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func f&lt;T: P&gt;(t: T) { … }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct X : Q {<br>&gt;&gt;&gt;&gt;   func bar() { … }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; f(X()) // okay: X conforms to P through the conformance of Q to P<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is an extremely powerful feature: is allows one to map the abstractions of one domain into another domain (e.g., every Matrix is a Graph). However, similar to private conformances, it puts a major burden on the dynamic-casting runtime to chase down arbitrarily long and potentially cyclic chains of conformances, which makes efficient implementation nearly impossible.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Potential removals<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The generics system doesn’t seem like a good candidate for a reduction in scope; most of its features do get used fairly pervasively in the standard library, and few feel overly anachronistic. However...<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Associated type inference<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Associated type inference is the process by which we infer the type bindings for associated types from other requirements. For example:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol IteratorProtocol {<br>&gt;&gt;&gt;&gt;   associatedtype Element<br>&gt;&gt;&gt;&gt;   mutating func next() -&gt; Element?<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct IntIterator : IteratorProtocol {<br>&gt;&gt;&gt;&gt;   mutating func next() -&gt; Int? { … }  // use this to infer Element = Int<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Associated type inference is a useful feature. It’s used throughout the standard library, and it helps keep associated types less visible to types that simply want to conform to a protocol. On the other hand, associated type inference is the only place in Swift where we have a global type inference problem: it has historically been a major source of bugs, and implementing it fully and correctly requires a drastically different architecture to the type checker. Is the value of this feature worth keeping global type inference in the Swift language, when we have deliberatively avoided global type inference elsewhere in the language?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Existentials<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Existentials aren’t really generics per se, but the two systems are closely intertwined due to their mutable dependence on protocols.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; *Generalized existentials<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The restrictions on existential types came from an implementation limitation, but it is reasonable to allow a value of protocol type even when the protocol has Self constraints or associated types. For example, consider IteratorProtocol again and how it could be used as an existential:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol IteratorProtocol {<br>&gt;&gt;&gt;&gt;   associatedtype Element<br>&gt;&gt;&gt;&gt;   mutating func next() -&gt; Element?<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let it: IteratorProtocol = …<br>&gt;&gt;&gt;&gt; it.next()   // if this is permitted, it could return an “Any?”, i.e., the existential that wraps the actual element<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Additionally, it is reasonable to want to constrain the associated types of an existential, e.g., “a Sequence whose element type is String” could be expressed by putting a where clause into “protocol&lt;…&gt;” or “Any&lt;…&gt;” (per “Renaming protocol&lt;…&gt; to Any&lt;…&gt;”):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let strings: Any&lt;Sequence where .Iterator.Element == String&gt; = [“a”, “b”, “c”]<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The leading “.” indicates that we’re talking about the dynamic type, i.e., the “Self” type that’s conforming to the Sequence protocol. There’s no reason why we cannot support arbitrary “where” clauses within the “Any&lt;…&gt;”. This very-general syntax is a bit unwieldy, but common cases can easily be wrapped up in a generic typealias (see the section “Generic typealiases” above):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; typealias AnySequence&lt;Element&gt; = Any&lt;Sequence where .Iterator.Element == Element&gt;<br>&gt;&gt;&gt;&gt; let strings: AnySequence&lt;String&gt; = [“a”, “b”, “c”]<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Opening existentials<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Generalized existentials as described above will still have trouble with protocol requirements that involve Self or associated types in function parameters. For example, let’s try to use Equatable as an existential:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol Equatable {<br>&gt;&gt;&gt;&gt;   func ==(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;&gt;&gt;   func !=(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let e1: Equatable = …<br>&gt;&gt;&gt;&gt; let e2: Equatable = …<br>&gt;&gt;&gt;&gt; if e1 == e2 { … } // error: e1 and e2 don’t necessarily have the same dynamic type<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One explicit way to allow such operations in a type-safe manner is to introduce an “open existential” operation of some sort, which extracts and gives a name to the dynamic type stored inside an existential. For example:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	 <br>&gt;&gt;&gt;&gt; if let storedInE1 = e1 openas T {     // T is a the type of storedInE1, a copy of the value stored in e1<br>&gt;&gt;&gt;&gt;   if let storedInE2 = e2 as? T {      // is e2 also a T?<br>&gt;&gt;&gt;&gt;     if storedInE1 == storedInE2 { … } // okay: storedInT1 and storedInE2 are both of type T, which we know is Equatable<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160508/6dbf5a14/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Manifesto] Completing Generics</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May  8, 2016 at 03:00:00pm</p></header><div class="content"><p>Is the plan to eventually support &quot;multiple&quot; forms of concrete same-type<br>requirement syntax - the existing &quot;where Element == SomeConcreteType&quot; and<br>the generic parameterized extensions described elsewhere? If not, the<br>syntax should probably be discussed as part of a pre-proposal thread before<br>anything else happens.<br></p><p>Also, I think it would be valuable to add &quot;covariant and contravariant<br>generic parameters&quot; to the &quot;unlikely&quot; list (there&#39;s now a copy in the docs/<br>directory), as those have come up several times in the past and the core<br>team has expressed that they are pretty dead set against that feature.<br></p><p>Best,<br>Austin<br></p><p>On Sun, May 8, 2016 at 2:37 PM, David Hart via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Sorry, I misunderstood that you meant that the version of Concrete<br>&gt; same-type requirement that does not introduce new syntax could be sent<br>&gt; through as a bug request. It’s now done:<br>&gt;<br>&gt; [SR-1447] Concrete same-type requirements<br>&gt; &lt;https://bugs.swift.org/browse/SR-1447&gt;<br>&gt;<br>&gt; On 08 May 2016, at 23:17, David Hart via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I created two bug requests for Recursive protocol constraints and Nested<br>&gt; generics and will write a proposal for Concrete same-type requirements.<br>&gt;<br>&gt; [SR-1445] Recursive protocol constraints<br>&gt; &lt;https://bugs.swift.org/browse/SR-1445&gt;<br>&gt;<br>&gt; [SR-1446] Nested generics &lt;https://bugs.swift.org/browse/SR-1446&gt;<br>&gt;<br>&gt; On 03 May 2016, at 09:58, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt;<br>&gt; Sent from my iPhone<br>&gt;<br>&gt; On May 2, 2016, at 3:58 PM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;<br>&gt; I’d like to continue moving Completing Generics forward for Swift 3 with<br>&gt; proposals. Can Douglas, or someone from the core team, tell me if the<br>&gt; topics mentioned in *Removing unnecessary restrictions* require proposals<br>&gt; or if bug reports should be opened for them instead?<br>&gt;<br>&gt;<br>&gt; I&#39;d classify everything in that section as a bug, so long as we&#39;re<br>&gt; restricting ourselves to the syntax already present in the language.<br>&gt; Syntactic improvements (e.g., for same-type-to-concrete constraints) would<br>&gt; require a proposal.<br>&gt;<br>&gt;   - Doug<br>&gt;<br>&gt;<br>&gt;<br>&gt; On 03 Mar 2016, at 02:22, Douglas Gregor via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Hi all,<br>&gt;<br>&gt; *Introduction*<br>&gt;<br>&gt; The “Complete Generics” goal for Swift 3 has been fairly ill-defined thus<br>&gt; fair, with just this short blurb in the list of goals:<br>&gt;<br>&gt;<br>&gt;    - *Complete generics*: Generics are used pervasively in a number of<br>&gt;    Swift libraries, especially the standard library. However, there are a<br>&gt;    number of generics features the standard library requires to fully realize<br>&gt;    its vision, including recursive protocol constraints, the ability to make a<br>&gt;    constrained extension conform to a new protocol (i.e., an array of<br>&gt;    Equatable elements is Equatable), and so on. Swift 3.0 should provide<br>&gt;    those generics features needed by the standard library, because they affect<br>&gt;    the standard library&#39;s ABI.<br>&gt;<br>&gt; This message expands upon the notion of “completing generics”. It is not a<br>&gt; plan for Swift 3, nor an official core team communication, but it collects<br>&gt; the results of numerous discussions among the core team and Swift<br>&gt; developers, both of the compiler and the standard library. I hope to<br>&gt; achieve several things:<br>&gt;<br>&gt;<br>&gt;    - Communicate a vision for Swift generics, building on the original<br>&gt;    generics design document<br>&gt;    &lt;https://github.com/apple/swift/blob/master/docs/Generics.rst&gt;, so we<br>&gt;    have something concrete and comprehensive to discuss.<br>&gt;    - Establish some terminology that the Swift developers have been using<br>&gt;    for these features, so our discussions can be more productive (“oh, you’re<br>&gt;    proposing what we refer to as ‘conditional conformances’; go look over at<br>&gt;    this thread”).<br>&gt;    - Engage more of the community in discussions of specific generics<br>&gt;    features, so we can coalesce around designs for public review. And maybe<br>&gt;    even get some of them implemented.<br>&gt;<br>&gt;<br>&gt; A message like this can easily turn into a centithread<br>&gt; &lt;http://www.urbandictionary.com/define.php?term=centithread&gt;. To separate<br>&gt; concerns in our discussion, I ask that replies to this specific thread be<br>&gt; limited to discussions of the vision as a whole: how the pieces fit<br>&gt; together, what pieces are missing, whether this is the right long-term<br>&gt; vision for Swift, and so on. For discussions of specific language features,<br>&gt; e.g., to work out the syntax and semantics of conditional conformances or<br>&gt; discuss the implementation in compiler or use in the standard library,<br>&gt; please start a new thread based on the feature names I’m using.<br>&gt;<br>&gt; This message covers a lot of ground; I’ve attempted a rough categorization<br>&gt; of the various features, and kept the descriptions brief to limit the<br>&gt; overall length. Most of these aren’t my ideas, and any syntax I’m providing<br>&gt; is simply a way to express these ideas in code and is subject to change.<br>&gt; Not all of these features will happen, either soon or ever, but they are<br>&gt; intended to be a fairly complete whole that should mesh together. I’ve put<br>&gt; a * next to features that I think are important in the nearer term vs.<br>&gt; being interesting “some day”. Mostly, the *’s reflect features that will<br>&gt; have a significant impact on the Swift standard library’s design and<br>&gt; implementation.<br>&gt;<br>&gt; Enough with the disclaimers; it’s time to talk features.<br>&gt;<br>&gt; *Removing unnecessary restrictions*<br>&gt;<br>&gt; There are a number of restrictions to the use of generics that fall out of<br>&gt; the implementation in the Swift compiler. Removal of these restrictions is<br>&gt; a matter of implementation only; one need not introduce new syntax or<br>&gt; semantics to realize them. I’m listing them for two reasons: first, it’s an<br>&gt; acknowledgment that these features are intended to exist in the model we<br>&gt; have today, and, second, we’d love help with the implementation of these<br>&gt; features.<br>&gt;<br>&gt;<br>&gt; **Recursive protocol constraints*<br>&gt;<br>&gt; Currently, an associated type cannot be required to conform to its<br>&gt; enclosing protocol (or any protocol that inherits that protocol). For<br>&gt; example, in the standard library SubSequence type of a Sequence should<br>&gt; itself be a Sequence:<br>&gt;<br>&gt; protocol Sequence {<br>&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;   …<br>&gt;   associatedtype SubSequence *: Sequence   **// currently ill-formed, but<br>&gt; should be possible*<br>&gt; }<br>&gt;<br>&gt;<br>&gt; The compiler currently rejects this protocol, which is unfortunate: it<br>&gt; effectively pushes the SubSequence-must-be-a-Sequence requirement into<br>&gt; every consumer of SubSequence, and does not communicate the intent of this<br>&gt; abstraction well.<br>&gt;<br>&gt; *Nested generics*<br>&gt;<br>&gt; Currently, a generic type cannot be nested within another generic type,<br>&gt; e.g.<br>&gt;<br>&gt; struct X&lt;T&gt; {<br>&gt;   struct Y&lt;U&gt; { }  *// currently ill-formed, but should be possible*<br>&gt; }<br>&gt;<br>&gt;<br>&gt; There isn’t much to say about this: the compiler simply needs to be<br>&gt; improved to handle nested generics throughout.<br>&gt;<br>&gt;<br>&gt; *Concrete same-type requirements*<br>&gt;<br>&gt; Currently, a constrained extension cannot use a same-type constraint to<br>&gt; make a type parameter equivalent to a concrete type. For example:<br>&gt;<br>&gt; extension Array *where Element == String* {<br>&gt;   func makeSentence() -&gt; String {<br>&gt;     // uppercase first string, concatenate with spaces, add a period,<br>&gt; whatever<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; This is a highly-requested feature that fits into the existing syntax and<br>&gt; semantics. Note that one could imagine introducing new syntax, e.g.,<br>&gt; extending “Array&lt;String&gt;”, which gets into new-feature territory: see the<br>&gt; section on “Parameterized extensions”.<br>&gt;<br>&gt; *Parameterizing other declarations*<br>&gt;<br>&gt; There are a number of Swift declarations that currently cannot have<br>&gt; generic parameters; some of those have fairly natural extensions to generic<br>&gt; forms that maintain their current syntax and semantics, but become more<br>&gt; powerful when made generic.<br>&gt;<br>&gt;<br>&gt; *Generic typealiases*<br>&gt; Typealiases could be allowed to carry generic parameters. They would still<br>&gt; be aliases (i.e., they would not introduce new types). For example:<br>&gt;<br>&gt; typealias StringDictionary&lt;Value&gt; = Dictionary&lt;String, Value&gt;<br>&gt;<br>&gt; var d1 = StringDictionary&lt;Int&gt;()<br>&gt; var d2: Dictionary&lt;String, Int&gt; = d1 // okay: d1 and d2 have the same<br>&gt; type, Dictionary&lt;String, Int&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; *Generic subscripts*<br>&gt;<br>&gt; Subscripts could be allowed to have generic parameters. For example, we<br>&gt; could introduce a generic subscript on a Collection that allows us to pull<br>&gt; out the values at an arbitrary set of indices:<br>&gt;<br>&gt; extension Collection {<br>&gt;   subscript*&lt;Indices: Sequence where Indices.Iterator.Element == Index&gt;*(indices:<br>&gt; Indices) -&gt; [Iterator.Element] {<br>&gt;     get {<br>&gt;       var result = [Iterator.Element]()<br>&gt;       for index in indices {<br>&gt;         result.append(self[index])<br>&gt;       }<br>&gt;<br>&gt;       return result<br>&gt;     }<br>&gt;<br>&gt;     set {<br>&gt;       for (index, value) in zip(indices, newValue) {<br>&gt;         self[index] = value<br>&gt;       }<br>&gt;     }<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt;<br>&gt;<br>&gt; *Generic constants*<br>&gt;<br>&gt; let constants could be allowed to have generic parameters, such that they<br>&gt; produce differently-typed values depending on how they are used. For<br>&gt; example, this is particularly useful for named literal values, e.g.,<br>&gt;<br>&gt; let π&lt;T : FloatLiteralConvertible&gt;: T<br>&gt; = 3.141592653589793238462643383279502884197169399<br>&gt;<br>&gt;<br>&gt; The Clang importer could make particularly good use of this when importing<br>&gt; macros.<br>&gt;<br>&gt;<br>&gt; *Parameterized extensions*<br>&gt;<br>&gt; Extensions themselves could be parameterized, which would allow some<br>&gt; structural pattern matching on types. For example, this would permit one to<br>&gt; extend an array of optional values, e.g.,<br>&gt;<br>&gt; extension*&lt;T&gt;* Array *where Element == T?* {<br>&gt;   var someValues: [T] {<br>&gt;     var result = [T]()<br>&gt;     for opt in self {<br>&gt;       if let value = opt { result.append(value) }<br>&gt;     }<br>&gt;    return result<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; We can generalize this to a protocol extensions:<br>&gt;<br>&gt; extension*&lt;T&gt;* Sequence *where Element == T?* {<br>&gt;   var someValues: [T] {<br>&gt;     var result = [T]()<br>&gt;     for opt in self {<br>&gt;       if let value = opt { result.append(value) }<br>&gt;     }<br>&gt;    return result<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Note that when one is extending nominal types, we could simplify the<br>&gt; syntax somewhat to make the same-type constraint implicit in the syntax:<br>&gt;<br>&gt; extension*&lt;T&gt;* Array*&lt;T?&gt;* {<br>&gt;   var someValues: [T] {<br>&gt;     var result = [T]()<br>&gt;     for opt in self {<br>&gt;       if let value = opt { result.append(value) }<br>&gt;     }<br>&gt;    return result<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; When we’re working with concrete types, we can use that syntax to improve<br>&gt; the extension of concrete versions of generic types (per “Concrete<br>&gt; same-type requirements”, above), e.g.,<br>&gt;<br>&gt; extension Array*&lt;String&gt;* {<br>&gt;   func makeSentence() -&gt; String {<br>&gt;     // uppercase first string, concatenate with spaces, add a period,<br>&gt; whatever<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; *Minor extensions*<br>&gt;<br>&gt; There are a number of minor extensions we can make to the generics system<br>&gt; that don’t fundamentally change what one can express in Swift, but which<br>&gt; can improve its expressivity.<br>&gt;<br>&gt;<br>&gt; **Arbitrary requirements in protocols*<br>&gt;<br>&gt; Currently, a new protocol can inherit from other protocols, introduce new<br>&gt; associated types, and add new conformance constraints to associated types<br>&gt; (by redeclaring an associated type from an inherited protocol). However,<br>&gt; one cannot express more general constraints. Building on the example from<br>&gt; “Recursive protocol constraints”, we really want the element type of a<br>&gt; Sequence’s SubSequence to be the same as the element type of the Sequence,<br>&gt; e.g.,<br>&gt;<br>&gt; protocol Sequence {<br>&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;   …<br>&gt;   associatedtype SubSequence : Sequence* where<br>&gt; SubSequence.Iterator.Element == Iterator.Element*<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Hanging the where clause off the associated type is protocol not ideal,<br>&gt; but that’s a discussion for another thread.<br>&gt;<br>&gt;<br>&gt;<br>&gt; **Typealiases in protocols and protocol extensions*<br>&gt;<br>&gt; Now that associated types have their own keyword (thanks!), it’s<br>&gt; reasonable to bring back “typealias”. Again with the Sequence protocol:<br>&gt;<br>&gt; protocol Sequence {<br>&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;   typealias Element = Iterator.Element   // rejoice! now we can refer to<br>&gt; SomeSequence.Element rather than SomeSequence.Iterator.Element<br>&gt; }<br>&gt;<br>&gt;<br>&gt;<br>&gt; *Default generic arguments *<br>&gt;<br>&gt; Generic parameters could be given the ability to provide default<br>&gt; arguments, which would be used in cases where the type argument is not<br>&gt; specified and type inference could not determine the type argument. For<br>&gt; example:<br>&gt;<br>&gt; public final class Promise&lt;Value, Reason=Error&gt; { … }<br>&gt;<br>&gt; func getRandomPromise() -&gt; Promise&lt;Int, ErrorProtocol&gt; { … }<br>&gt;<br>&gt; var p1: Promise&lt;Int&gt; = …<br>&gt; var p2: Promise&lt;Int, Error&gt; = p1     *// okay: p1 and p2 have the same<br>&gt; type Promise&lt;Int, Error&gt;*<br>&gt; var p3: Promise = getRandomPromise() *// p3 has type **Promise&lt;Int,<br>&gt; ErrorProtocol&gt; due to type inference*<br>&gt;<br>&gt;<br>&gt;<br>&gt; *Generalized “class” constraints*<br>&gt;<br>&gt; The “class” constraint can currently only be used for defining protocols.<br>&gt; We could generalize it to associated type and type parameter declarations,<br>&gt; e.g.,<br>&gt;<br>&gt; protocol P {<br>&gt;   associatedtype A : class<br>&gt; }<br>&gt;<br>&gt; func foo&lt;T : class&gt;(t: T) { }<br>&gt;<br>&gt;<br>&gt; As part of this, the magical AnyObject protocol could be replaced with an<br>&gt; existential with a class bound, so that it becomes a typealias:<br>&gt;<br>&gt; typealias AnyObject = protocol&lt;class&gt;<br>&gt;<br>&gt;<br>&gt; See the “Existentials” section, particularly “Generalized existentials”,<br>&gt; for more information.<br>&gt;<br>&gt;<br>&gt; **Allowing subclasses to override requirements satisfied by defaults*<br>&gt;<br>&gt; When a superclass conforms to a protocol and has one of the protocol’s<br>&gt; requirements satisfied by a member of a protocol extension, that member<br>&gt; currently cannot be overridden by a subclass. For example:<br>&gt;<br>&gt; protocol P {<br>&gt;   func foo()<br>&gt; }<br>&gt;<br>&gt; extension P {<br>&gt;   func foo() { print(“P”) }<br>&gt; }<br>&gt;<br>&gt; class C : P {<br>&gt;   // gets the protocol extension’s<br>&gt; }<br>&gt;<br>&gt; class D : C {<br>&gt;   /*override not allowed!*/ func foo() { print(“D”) }<br>&gt; }<br>&gt;<br>&gt; let p: P = D()<br>&gt; p.foo() // gotcha: prints “P” rather than “D”!<br>&gt;<br>&gt;<br>&gt; D.foo should be required to specify “override” and should be called<br>&gt; dynamically.<br>&gt;<br>&gt;<br>&gt; *Major extensions to the generics model*<br>&gt;<br>&gt; Unlike the minor extensions, major extensions to the generics model<br>&gt; provide more expressivity in the Swift generics system and, generally, have<br>&gt; a much more significant design and implementation cost.<br>&gt;<br>&gt;<br>&gt;<br>&gt; **Conditional conformances*<br>&gt;<br>&gt; Conditional conformances express the notion that a generic type will<br>&gt; conform to a particular protocol only under certain circumstances. For<br>&gt; example, Array is Equatable only when its elements are Equatable:<br>&gt;<br>&gt; extension Array *: Equatable where Element : Equatable* { }<br>&gt;<br>&gt; func ==&lt;T : Equatable&gt;(lhs: Array&lt;T&gt;, rhs: Array&lt;T&gt;) -&gt; Bool { … }<br>&gt;<br>&gt;<br>&gt; Conditional conformances are a potentially very powerful feature. One<br>&gt; important aspect of this feature is how deal with or avoid overlapping<br>&gt; conformances. For example, imagine an adaptor over a Sequence that has<br>&gt; conditional conformances to Collection and MutableCollection:<br>&gt;<br>&gt; struct SequenceAdaptor&lt;S: Sequence&gt; : Sequence { }<br>&gt; extension SequenceAdaptor : Collection where S: Collection { … }<br>&gt; extension SequenceAdaptor : MutableCollection where S: MutableCollection {<br>&gt; }<br>&gt;<br>&gt;<br>&gt; This should almost certainly be permitted, but we need to cope with or<br>&gt; reject “overlapping” conformances:<br>&gt;<br>&gt; extension SequenceAdaptor : Collection where S:<br>&gt; SomeOtherProtocolSimilarToCollection { } *// trouble: two ways for<br>&gt; SequenceAdaptor to conform to Collection*<br>&gt;<br>&gt;<br>&gt; See the section on “Private conformances” for more about the issues with<br>&gt; having the same type conform to the same protocol multiple times.<br>&gt;<br>&gt;<br>&gt; *Variadic generics*<br>&gt;<br>&gt; Currently, a generic parameter list contains a fixed number of generic<br>&gt; parameters. If one has a type that could generalize to any number of<br>&gt; generic parameters, the only real way to deal with it today involves<br>&gt; creating a set of types. For example, consider the standard library’s “zip”<br>&gt; function. It returns one of these when provided with two arguments to zip<br>&gt; together:<br>&gt;<br>&gt; public struct Zip2Sequence&lt;Sequence1 : Sequence,<br>&gt;                            Sequence2 : Sequence&gt; : Sequence { … }<br>&gt;<br>&gt; public func zip&lt;Sequence1 : Sequence, Sequence2 : Sequence&gt;(<br>&gt;               sequence1: Sequence1, _ sequence2: Sequence2)<br>&gt;             -&gt; Zip2Sequence&lt;Sequence1, Sequence2&gt; { … }<br>&gt;<br>&gt;<br>&gt; Supporting three arguments would require copy-paste of those of those:<br>&gt;<br>&gt; public struct Zip3Sequence&lt;Sequence1 : Sequence,<br>&gt;                            Sequence2 : Sequence,<br>&gt;                            Sequence3 : Sequence&gt; : Sequence { … }<br>&gt;<br>&gt; public func zip&lt;Sequence1 : Sequence, Sequence2 : Sequence, Sequence3 :<br>&gt; Sequence&gt;(<br>&gt;               sequence1: Sequence1, _ sequence2: Sequence2, _ sequence3:<br>&gt; sequence3)<br>&gt;             -&gt; Zip3Sequence&lt;Sequence1, Sequence2, Sequence3&gt; { … }<br>&gt;<br>&gt;<br>&gt; Variadic generics would allow us to abstract over a set of generic<br>&gt; parameters. The syntax below is hopelessly influenced by C++11 variadic<br>&gt; templates &lt;http://www.jot.fm/issues/issue_2008_02/article2/&gt; (sorry),<br>&gt; where putting an ellipsis (“…”) to the left of a declaration makes it a<br>&gt; “parameter pack” containing zero or more parameters and putting an ellipsis<br>&gt; to the right of a type/expression/etc. expands the parameter packs within<br>&gt; that type/expression into separate arguments. The important part is that we<br>&gt; be able to meaningfully abstract over zero or more generic parameters, e.g.:<br>&gt;<br>&gt; public struct ZipIterator&lt;... *Iterators* : IteratorProtocol&gt; : Iterator<br>&gt; {  *// zero or more type parameters, each of which conforms to<br>&gt; IteratorProtocol*<br>&gt;   public typealias Element = (*Iterators.Element...*)<br>&gt;   *// a tuple containing the element types of each iterator in Iterators*<br>&gt;<br>&gt;   var (*...iterators*): (*Iterators...*)    *// zero or more stored<br>&gt; properties, one for each type in Iterators*<br>&gt;   var reachedEnd: Bool = false<br>&gt;<br>&gt;<br>&gt;   public mutating func next() -&gt; Element? {<br>&gt;<br>&gt;     if reachedEnd { return nil }<br>&gt;<br>&gt;<br>&gt;     guard let values = (*iterators.next()...*) {   *// call “next” on<br>&gt; each of the iterators, put the results into a tuple named “values&quot;*<br>&gt;<br>&gt;       reachedEnd = true<br>&gt;<br>&gt;       return nil<br>&gt;<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;     return values<br>&gt;<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; public struct ZipSequence&lt;*...Sequences* : Sequence&gt; : Sequence {<br>&gt;   public typealias Iterator = ZipIterator&lt;*Sequences.Iterator...*&gt;   *//<br>&gt; get the zip iterator with the iterator types of our Sequences*<br>&gt;<br>&gt;   var (...*sequences*): (*Sequences**...*)    *// zero or more stored<br>&gt; properties, one for each type in Sequences*<br>&gt;<br>&gt;   *// details ...*<br>&gt; }<br>&gt;<br>&gt; Such a design could also work for function parameters, so we can pack<br>&gt; together multiple function arguments with different types, e.g.,<br>&gt;<br>&gt; public func zip&lt;*... Sequences : SequenceType*&gt;(*... sequences:<br>&gt; Sequences...*)<br>&gt;             -&gt; ZipSequence&lt;*Sequences...*&gt; {<br>&gt;   return ZipSequence(*sequences...*)<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Finally, this could tie into the discussions about a tuple “splat”<br>&gt; operator. For example:<br>&gt;<br>&gt; func apply&lt;... Args, Result&gt;(fn: (Args...) -&gt; Result,    *// function<br>&gt; taking some number of arguments and producing Result*<br>&gt;                            args: (Args...)) -&gt; Result {  *// tuple of<br>&gt; arguments*<br>&gt;   return fn(*args...*)                                     // expand the<br>&gt; arguments in the tuple “args” into separate arguments<br>&gt; }<br>&gt;<br>&gt;<br>&gt;<br>&gt; *Extensions of structural types*<br>&gt;<br>&gt; Currently, only nominal types (classes, structs, enums, protocols) can be<br>&gt; extended. One could imagine extending structural types—particularly tuple<br>&gt; types—to allow them to, e.g., conform to protocols. For example, pulling<br>&gt; together variadic generics, parameterized extensions, and conditional<br>&gt; conformances, one could express “a tuple type is Equatable if all of its<br>&gt; element types are Equatable”:<br>&gt;<br>&gt; extension&lt;...Elements : Equatable&gt; *(Elements...)* : Equatable {   *//<br>&gt; extending the tuple type “(Elements…)” to be Equatable*<br>&gt; }<br>&gt;<br>&gt;<br>&gt; There are some natural bounds here: one would need to have actual<br>&gt; structural types. One would not be able to extend every type:<br>&gt;<br>&gt; extension&lt;T&gt; T { *// error: neither a structural nor a nominal type*<br>&gt; }<br>&gt;<br>&gt;<br>&gt; And before you think you’re cleverly making it possible to have a<br>&gt; conditional conformance that makes every type T that conforms to protocol P<br>&gt; also conform to protocol Q, see the section &quot;Conditional conformances via<br>&gt; protocol extensions”, below:<br>&gt;<br>&gt; extension&lt;T : P&gt; T : Q { *// error: neither a structural nor a nominal<br>&gt; type*<br>&gt; }<br>&gt;<br>&gt;<br>&gt;<br>&gt; *Syntactic improvements*<br>&gt;<br>&gt; There are a number of potential improvements we could make to the generics<br>&gt; syntax. Such a list could go on for a very long time, so I’ll only<br>&gt; highlight some obvious ones that have been discussed by the Swift<br>&gt; developers.<br>&gt;<br>&gt; **Default implementations in protocols*<br>&gt;<br>&gt; Currently, protocol members can never have implementations. We could allow<br>&gt; one to provide such implementations to be used as the default if a<br>&gt; conforming type does not supply an implementation, e.g.,<br>&gt;<br>&gt; protocol Bag {<br>&gt;   associatedtype Element : Equatable<br>&gt;   func contains(element: Element) -&gt; Bool<br>&gt;<br>&gt;   func containsAll&lt;S: Sequence where Sequence.Iterator.Element ==<br>&gt; Element&gt;(elements: S) -&gt; Bool {<br>&gt;     for x in elements {<br>&gt;       if contains(x) { return true }<br>&gt;     }<br>&gt;     return false<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; struct IntBag : Bag {<br>&gt;   typealias Element = Int<br>&gt;   func contains(element: Int) -&gt; Bool { ... }<br>&gt;<br>&gt;   // okay: containsAll requirement is satisfied by Bag’s default<br>&gt; implementation<br>&gt; }<br>&gt;<br>&gt; One can get this effect with protocol extensions today, hence the<br>&gt; classification of this feature as a (mostly) syntactic improvement:<br>&gt;<br>&gt; protocol Bag {<br>&gt;   associatedtype Element : Equatable<br>&gt;   func contains(element: Element) -&gt; Bool<br>&gt;<br>&gt;   func containsAll&lt;S: Sequence where Sequence.Iterator.Element ==<br>&gt; Element&gt;(elements: S) -&gt; Bool<br>&gt; }<br>&gt;<br>&gt; extension Bag {<br>&gt;   func containsAll&lt;S: Sequence where Sequence.Iterator.Element ==<br>&gt; Element&gt;(elements: S) -&gt; Bool {<br>&gt;     for x in elements {<br>&gt;       if contains(x) { return true }<br>&gt;     }<br>&gt;     return false<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; **Moving the where clause outside of the angle brackets*<br>&gt;<br>&gt; The “where” clause of generic functions comes very early in the<br>&gt; declaration, although it is generally of much less concern to the client<br>&gt; than the function parameters and result type that follow it. This is one of<br>&gt; the things that contributes to “angle bracket blindness”. For example,<br>&gt; consider the containsAll signature above:<br>&gt;<br>&gt; func containsAll&lt;S: Sequence where Sequence.Iterator.Element ==<br>&gt; Element&gt;(elements: S) -&gt; Bool<br>&gt;<br>&gt;<br>&gt; One could move the “where” clause to the end of the signature, so that the<br>&gt; most important parts—name, generic parameter, parameters, result<br>&gt; type—precede it:<br>&gt;<br>&gt; func containsAll&lt;S: Sequence&gt;(elements: S) -&gt; Bool<br>&gt;<br>&gt;        where Sequence.Iterator.Element == Element<br>&gt;<br>&gt;<br>&gt;<br>&gt; **Renaming “protocol&lt;…&gt;” to “Any&lt;…&gt;”.*<br>&gt;<br>&gt; The “protocol&lt;…&gt;” syntax is a bit of an oddity in Swift. It is used to<br>&gt; compose protocols together, mostly to create values of existential type,<br>&gt; e.g.,<br>&gt;<br>&gt; var x: protocol&lt;NSCoding, NSCopying&gt;<br>&gt;<br>&gt;<br>&gt; It’s weird that it’s a type name that starts with a lowercase letter, and<br>&gt; most Swift developers probably never deal with this feature unless they<br>&gt; happen to look at the definition of Any:<br>&gt;<br>&gt; typealias Any = protocol&lt;&gt;<br>&gt;<br>&gt;<br>&gt; “Any” might be a better name for this functionality. “Any” without<br>&gt; brackets could be a keyword for “any type”, and “Any” followed by brackets<br>&gt; could take the role of “protocol&lt;&gt;” today:<br>&gt;<br>&gt; var x: Any&lt;NSCoding, NSCopying&gt;<br>&gt;<br>&gt;<br>&gt; That reads much better: “Any type that conforms to NSCoding and<br>&gt; NSCopying”. See the section &quot;Generalized existentials” for additional<br>&gt; features in this space.<br>&gt;<br>&gt; *Maybe*<br>&gt;<br>&gt; There are a number of features that get discussed from time-to-time, while<br>&gt; they could fit into Swift’s generics system, it’s not clear that they<br>&gt; belong in Swift at all. The important question for any feature in this<br>&gt; category is not “can it be done” or “are there cool things we can express”,<br>&gt; but “how can everyday Swift developers benefit from the addition of such a<br>&gt; feature?”. Without strong motivating examples, none of these “maybes” will<br>&gt; move further along.<br>&gt;<br>&gt; *Dynamic dispatch for members of protocol extensions*<br>&gt;<br>&gt; Only the requirements of protocols currently use dynamic dispatch, which<br>&gt; can lead to surprises:<br>&gt;<br>&gt; protocol P {<br>&gt;   func foo()<br>&gt; }<br>&gt;<br>&gt; extension P {<br>&gt;   func foo() { print(“P.foo()”)<br>&gt;   func bar() { print(“P.bar()”)<br>&gt; }<br>&gt;<br>&gt; struct X : P {<br>&gt;   func foo() { print(“X.foo()”)<br>&gt;   func bar() { print(“X.bar()”)<br>&gt; }<br>&gt;<br>&gt; let x = X()<br>&gt; x.foo() // X.foo()<br>&gt; x.bar() // X.bar()<br>&gt;<br>&gt; let p: P = X()<br>&gt; p.foo() // X.foo()<br>&gt; p.bar() // P.bar()<br>&gt;<br>&gt;<br>&gt; Swift could adopt a model where members of protocol extensions are<br>&gt; dynamically dispatched.<br>&gt;<br>&gt;<br>&gt; *Named generic parameters*<br>&gt;<br>&gt; When specifying generic arguments for a generic type, the arguments are<br>&gt; always positional: Dictionary&lt;String, Int&gt; is a Dictionary whose Key type<br>&gt; is String and whose Value type is Int, by convention. One could permit the<br>&gt; arguments to be labeled, e.g.,<br>&gt;<br>&gt; var d: Dictionary&lt;*Key:* String, *Value:* Int&gt;<br>&gt;<br>&gt;<br>&gt; Such a feature makes more sense if Swift gains default generic arguments,<br>&gt; because generic argument labels would allow one to skip defaulted arguments.<br>&gt;<br>&gt;<br>&gt; *Generic value parameters*<br>&gt;<br>&gt; Currently, Swift’s generic parameters are always types. One could imagine<br>&gt; allowing generic parameters that are values, e.g.,<br>&gt;<br>&gt; struct MultiArray&lt;T,* let Dimensions: Int*&gt; { *// specify the number of<br>&gt; dimensions to the array*<br>&gt;   subscript (indices: Int...) -&gt; T {<br>&gt;     get {<br>&gt;       require(indices.count == *Dimensions*)<br>&gt;       // ...<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; A suitably general feature might allow us to express fixed-length array or<br>&gt; vector types as a standard library component, and perhaps also allow one to<br>&gt; implement a useful dimensional analysis library. Tackling this feature<br>&gt; potentially means determining what it is for an expression to be a<br>&gt; “constant expression” and diving into dependent-typing, hence the “maybe”.<br>&gt;<br>&gt;<br>&gt; *Higher-kinded types*<br>&gt;<br>&gt; Higher-kinded types allow one to express the relationship between two<br>&gt; different specializations of the same nominal type within a protocol. For<br>&gt; example, if we think of the Self type in a protocol as really being<br>&gt; “Self&lt;T&gt;”, it allows us to talk about the relationship between “Self&lt;T&gt;”<br>&gt; and “Self&lt;U&gt;” for some other type U. For example, it could allow the “map”<br>&gt; operation on a collection to return a collection of the same kind but with<br>&gt; a different operation, e.g.,<br>&gt;<br>&gt; let intArray: Array&lt;Int&gt; = …<br>&gt; intArray.map { String($0) } *// produces Array&lt;String&gt;*<br>&gt; let intSet: Set&lt;Int&gt; = …<br>&gt; intSet.map { String($0) }   *// produces Set&lt;String&gt;*<br>&gt;<br>&gt;<br>&gt;<br>&gt; Potential syntax borrowed from one thread on higher-kinded types<br>&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002736.html&gt; uses<br>&gt; ~= as a “similarity” constraint to describe a Functor protocol:<br>&gt;<br>&gt; protocol Functor {<br>&gt;   associatedtype A<br>&gt;   func fmap&lt;FB where *FB ~= Self*&gt;(f: A -&gt; FB.A) -&gt; FB<br>&gt; }<br>&gt;<br>&gt;<br>&gt;<br>&gt; *Specifying type arguments for uses of generic functions*<br>&gt;<br>&gt; The type arguments of a generic function are always determined via type<br>&gt; inference. For example, given:<br>&gt;<br>&gt; func f&lt;T&gt;(t: T)<br>&gt;<br>&gt;<br>&gt; one cannot directly specify T: either one calls “f” (and T is determined<br>&gt; via the argument’s type) or one uses “f” in a context where it is given a<br>&gt; particular function type (e.g., “let x: (Int) -&gt; Void = f”  would infer T =<br>&gt; Int). We could permit explicit specialization here, e.g.,<br>&gt;<br>&gt; let x = f&lt;Int&gt; // x has type (Int) -&gt; Void<br>&gt;<br>&gt;<br>&gt;<br>&gt; *Unlikely*<br>&gt;<br>&gt; Features in this category have been requested at various times, but they<br>&gt; don’t fit well with Swift’s generics system because they cause some part of<br>&gt; the model to become overly complicated, have unacceptable implementation<br>&gt; limitations, or overlap significantly with existing features.<br>&gt;<br>&gt; *Generic protocols*<br>&gt;<br>&gt; One of the most commonly requested features is the ability to parameterize<br>&gt; protocols themselves. For example, a protocol that indicates that the Self<br>&gt; type can be constructed from some specified type T:<br>&gt;<br>&gt; protocol ConstructibleFromValue*&lt;T&gt;* {<br>&gt;   init(_ value: T)<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Implicit in this feature is the ability for a given type to conform to the<br>&gt; protocol in two different ways. A “Real” type might be constructible from<br>&gt; both Float and Double, e.g.,<br>&gt;<br>&gt; struct Real { … }<br>&gt; extension Real : ConstructibleFrom&lt;Float&gt; {<br>&gt;   init(_ value: Float) { … }<br>&gt; }<br>&gt; extension Real : ConstructibleFrom&lt;Double&gt; {<br>&gt;   init(_ value: Double) { … }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Most of the requests for this feature actually want a different feature.<br>&gt; They tend to use a parameterized Sequence as an example, e.g.,<br>&gt;<br>&gt; protocol Sequence&lt;Element&gt; { … }<br>&gt;<br>&gt; func foo(strings: Sequence&lt;String&gt;) {  /// works on any sequence<br>&gt; containing Strings<br>&gt;   // ...<br>&gt; }<br>&gt;<br>&gt;<br>&gt; The actual requested feature here  is the ability to say “Any type that<br>&gt; conforms to Sequence whose Element type is String”, which is covered by the<br>&gt; section on “Generalized existentials”, below.<br>&gt;<br>&gt; More importantly, modeling Sequence with generic parameters rather than<br>&gt; associated types is tantalizing but wrong: you don’t want a type conforming<br>&gt; to Sequence in multiple ways, or (among other things) your for..in loops<br>&gt; stop working, and you lose the ability to dynamically cast down to an<br>&gt; existential “Sequence” without binding the Element type (again, see<br>&gt; “Generalized existentials”). Use cases similar to the<br>&gt; ConstructibleFromValue protocol above seem too few to justify the potential<br>&gt; for confusion between associated types and generic parameters of protocols;<br>&gt; we’re better off not having the latter.<br>&gt;<br>&gt;<br>&gt; *Private conformances *<br>&gt;<br>&gt; Right now, a protocol conformance can be no less visible than the minimum<br>&gt; of the conforming type’s access and the protocol’s access. Therefore, a<br>&gt; public type conforming to a public protocol must provide the conformance<br>&gt; publicly. One could imagine removing that restriction, so that one could<br>&gt; introduce a private conformance:<br>&gt;<br>&gt; public protocol P { }<br>&gt; public struct X { }<br>&gt; extension X : *internal P* { … } // X conforms to P, but only within this<br>&gt; module<br>&gt;<br>&gt;<br>&gt; The main problem with private conformances is the interaction with dynamic<br>&gt; casting. If I have this code:<br>&gt;<br>&gt; func foo(value: Any) {<br>&gt;   if let x = value as? P { print(“P”) }<br>&gt; }<br>&gt;<br>&gt; foo(X())<br>&gt;<br>&gt;<br>&gt; Under what circumstances should it print “P”? If foo() is defined within<br>&gt; the same module as the conformance of X to P? If the call is defined within<br>&gt; the same module as the conformance of X to P? Never? Either of the first<br>&gt; two answers requires significant complications in the dynamic casting<br>&gt; infrastructure to take into account the module in which a particular<br>&gt; dynamic cast occurred (the first option) or where an existential was formed<br>&gt; (the second option), while the third answer breaks the link between the<br>&gt; static and dynamic type systems—none of which is an acceptable result.<br>&gt;<br>&gt;<br>&gt; *Conditional conformances via protocol extensions*<br>&gt;<br>&gt; We often get requests to make a protocol conform to another protocol. This<br>&gt; is, effectively, the expansion of the notion of “Conditional conformances”<br>&gt; to protocol extensions. For example:<br>&gt;<br>&gt; protocol P {<br>&gt;   func foo()<br>&gt; }<br>&gt;<br>&gt; protocol Q {<br>&gt;   func bar()<br>&gt; }<br>&gt;<br>&gt; extension *Q : P* { *// every type that conforms to Q also conforms to P*<br>&gt;   func foo() {    *// implement “foo” requirement in terms of “bar&quot;*<br>&gt;     bar()<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; func f&lt;T: P&gt;(t: T) { … }<br>&gt;<br>&gt; struct X : Q {<br>&gt;   func bar() { … }<br>&gt; }<br>&gt;<br>&gt; f(X()) // okay: X conforms to P through the conformance of Q to P<br>&gt;<br>&gt;<br>&gt; This is an extremely powerful feature: is allows one to map the<br>&gt; abstractions of one domain into another domain (e.g., every Matrix is a<br>&gt; Graph). However, similar to private conformances, it puts a major burden on<br>&gt; the dynamic-casting runtime to chase down arbitrarily long and potentially<br>&gt; cyclic chains of conformances, which makes efficient implementation nearly<br>&gt; impossible.<br>&gt;<br>&gt; *Potential removals*<br>&gt;<br>&gt; The generics system doesn’t seem like a good candidate for a reduction in<br>&gt; scope; most of its features do get used fairly pervasively in the standard<br>&gt; library, and few feel overly anachronistic. However...<br>&gt;<br>&gt; *Associated type inference*<br>&gt;<br>&gt; Associated type inference is the process by which we infer the type<br>&gt; bindings for associated types from other requirements. For example:<br>&gt;<br>&gt; protocol IteratorProtocol {<br>&gt;   associatedtype Element<br>&gt;   mutating func next() -&gt; Element?<br>&gt; }<br>&gt;<br>&gt; struct IntIterator : IteratorProtocol {<br>&gt;   mutating func next() -&gt; Int? { … }  // use this to infer Element = Int<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Associated type inference is a useful feature. It’s used throughout the<br>&gt; standard library, and it helps keep associated types less visible to types<br>&gt; that simply want to conform to a protocol. On the other hand, associated<br>&gt; type inference is the only place in Swift where we have a *global* type<br>&gt; inference problem: it has historically been a major source of bugs, and<br>&gt; implementing it fully and correctly requires a drastically different<br>&gt; architecture to the type checker. Is the value of this feature worth<br>&gt; keeping global type inference in the Swift language, when we have<br>&gt; deliberatively avoided global type inference elsewhere in the language?<br>&gt;<br>&gt;<br>&gt; *Existentials*<br>&gt;<br>&gt; Existentials aren’t really generics per se, but the two systems are<br>&gt; closely intertwined due to their mutable dependence on protocols.<br>&gt;<br>&gt; **Generalized existentials*<br>&gt;<br>&gt; The restrictions on existential types came from an implementation<br>&gt; limitation, but it is reasonable to allow a value of protocol type even<br>&gt; when the protocol has Self constraints or associated types. For example,<br>&gt; consider IteratorProtocol again and how it could be used as an existential:<br>&gt;<br>&gt; protocol IteratorProtocol {<br>&gt;   associatedtype Element<br>&gt;   mutating func next() -&gt; Element?<br>&gt; }<br>&gt;<br>&gt; let it: IteratorProtocol = …<br>&gt; it.next()   // if this is permitted, it could return an “Any?”, i.e., the<br>&gt; existential that wraps the actual element<br>&gt;<br>&gt;<br>&gt; Additionally, it is reasonable to want to constrain the associated types<br>&gt; of an existential, e.g., “a Sequence whose element type is String” could be<br>&gt; expressed by putting a where clause into “protocol&lt;…&gt;” or “Any&lt;…&gt;” (per<br>&gt; “Renaming protocol&lt;…&gt; to Any&lt;…&gt;”):<br>&gt;<br>&gt; let strings: Any&lt;Sequence* where .Iterator.Element == String*&gt; = [“a”,<br>&gt; “b”, “c”]<br>&gt;<br>&gt;<br>&gt; The leading “.” indicates that we’re talking about the dynamic type, i.e.,<br>&gt; the “Self” type that’s conforming to the Sequence protocol. There’s no<br>&gt; reason why we cannot support arbitrary “where” clauses within the “Any&lt;…&gt;”.<br>&gt; This very-general syntax is a bit unwieldy, but common cases can easily be<br>&gt; wrapped up in a generic typealias (see the section “Generic typealiases”<br>&gt; above):<br>&gt;<br>&gt; typealias AnySequence&lt;Element&gt; = *Any&lt;Sequence where .Iterator.Element ==<br>&gt; Element&gt;*<br>&gt; let strings: AnySequence&lt;String&gt; = [“a”, “b”, “c”]<br>&gt;<br>&gt;<br>&gt;<br>&gt; *Opening existentials*<br>&gt;<br>&gt; Generalized existentials as described above will still have trouble with<br>&gt; protocol requirements that involve Self or associated types in function<br>&gt; parameters. For example, let’s try to use Equatable as an existential:<br>&gt;<br>&gt; protocol Equatable {<br>&gt;   func ==(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;   func !=(lhs: Self, rhs: Self) -&gt; Bool<br>&gt; }<br>&gt;<br>&gt; let e1: Equatable = …<br>&gt; let e2: Equatable = …<br>&gt; if e1 == e2 { … } *// error:* e1 and e2 don’t necessarily have the same<br>&gt; dynamic type<br>&gt;<br>&gt;<br>&gt; One explicit way to allow such operations in a type-safe manner is to<br>&gt; introduce an “open existential” operation of some sort, which extracts and<br>&gt; gives a name to the dynamic type stored inside an existential. For example:<br>&gt;<br>&gt;<br>&gt;<br>&gt; if let storedInE1 = e1 openas T {     // T is a the type of storedInE1, a<br>&gt; copy of the value stored in e1<br>&gt;<br>&gt;   if let storedInE2 = e2 as? T {      // is e2 also a T?<br>&gt;<br>&gt;     if storedInE1 == storedInE2 { … } // okay: storedInT1 and storedInE2<br>&gt; are both of type T, which we know is Equatable<br>&gt;<br>&gt;   }<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Thoughts?<br>&gt;<br>&gt; - Doug<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160508/f0e1fe66/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Manifesto] Completing Generics</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>May  9, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On 09 May 2016, at 00:38, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; Is the plan to eventually support &quot;multiple&quot; forms of concrete same-type requirement syntax - the existing &quot;where Element == SomeConcreteType&quot; and the generic parameterized extensions described elsewhere? If not, the syntax should probably be discussed as part of a pre-proposal thread before anything else happens.<br></p><p>The way modifications have gone through swift-evolution, it seems like it would be more logical to implement it with no syntax change first and only then propose and discuss generic parameterised extensions.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160509/51fe2739/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Manifesto] Completing Generics</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May  8, 2016 at 03:00:00pm</p></header><div class="content"><p>That seems reasonable. Onward ho!<br></p><p>On Sun, May 8, 2016 at 3:46 PM, David Hart &lt;david at hartbit.com&gt; wrote:<br></p><p>&gt;<br>&gt; On 09 May 2016, at 00:38, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;<br>&gt; Is the plan to eventually support &quot;multiple&quot; forms of concrete same-type<br>&gt; requirement syntax - the existing &quot;where Element == SomeConcreteType&quot; and<br>&gt; the generic parameterized extensions described elsewhere? If not, the<br>&gt; syntax should probably be discussed as part of a pre-proposal thread before<br>&gt; anything else happens.<br>&gt;<br>&gt;<br>&gt; The way modifications have gone through swift-evolution, it seems like it<br>&gt; would be more logical to implement it with no syntax change first and only<br>&gt; then propose and discuss generic parameterised extensions.<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160508/c46506b6/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
