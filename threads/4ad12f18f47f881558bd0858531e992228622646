<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>[Idea] How to eliminate &#39;optional&#39; protocol requirements</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>April  8, 2016 at 05:00:00am</p></header><div class="content"><p>Interesting proposal, but I wanted to mention a couple of potential issues off the top of my head.  I know when I was using optional requirements in Objective C, I would often use the presence/lack of the method (not just whether it returned nil) in the logic of my program.  I used the presence of a method as a way for the implementor of a delegate to naturally communicate whether they wanted a more advanced feature.  The absence of the method itself is information which can be utilized, not just whether it returns nil, and I believe that is part of what people are asking for when they say they want optional methods in Swift.<br></p><p><br>Let me try to give a simplified example which I am not sure how you would work around in this proposal:<br></p><p>Let’s say there is a datasource protocol which optionally asks for an image associated with a particular piece of data (imagine a table or collection view type custom control).  If the method is not implemented in the data source, then a different view is shown for each data point that doesn’t have a place for images at all.  If the method is implemented, but returns nil, then a default image is used as a placeholder instead (in a view which has a place for images).<br></p><p>tl;dr: Optional methods are often used as customization points, and the methods, if implemented, may also have another meaning/use for nil.<br></p><p><br>Similarly, a different back-end implementation may be used in the case where an optional method is not implemented.  Let’s say you have something like a tableview with an optional method giving rowHeights.  If that method is unimplemented, it is possible to have a much more efficient layout algorithm… and in some cases, you may check for the existence of the optional method when the delegate is set, and swap out a different layout object based on which customizations are needed (and again nil might mean that a height/etc... should be automatically calculated).  This is the ability I miss the most.<br></p><p><br>Not saying the proposal is unworkable, just wanted to add some food for thought.  I know I really miss optional methods in Swift.  In some areas Swift is a lot more powerful, but there are lots of things I used to do in Obj C that I haven’t figured out how to do in Swift yet (if they are even possible).  I am kind of disturbed by the trend/desire to get rid of the smalltalk-ness, as opposed to finding new and safer ways to support that flexibility/expressiveness.  I would really like to see swift deliver on it’s promise of being a more modern alternative to ObjC (which it isn’t yet, IMHO) instead of just a more modern alternative to C++/Java.<br></p><p>Thanks,<br>Jon<br></p><p>&gt; Proposed Solution: Caller-side default implementations<br>&gt; <br>&gt; Default implementations and optional requirements differ most on the caller side. For example, let’s use NSTableView delegate as it’s imported today:<br>&gt; <br>&gt; func useDelegate(delegate: NSTableViewDelegate) {<br>&gt;   if let getView = delegate.tableView(_:viewFor:row:) { // since the requirement is optional, a reference to the method produces a value of optional function type<br>&gt;     // I can call getView here<br>&gt;   }<br>&gt; <br>&gt;   if let getHeight = delegate.tableView(_:heightOfRow:) {<br>&gt;     // I can call getHeight here<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; With my proposal, we’d have some compiler-synthesized attribute (let’s call it @__caller_default_implementation) that gets places on Objective-C optional requirements when they get imported, e.g.,<br>&gt; <br>&gt; @objc protocol NSTableViewDelegate {<br>&gt;   @__caller_default_implementation func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView?<br>&gt;   @__caller_default_implementation func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat<br>&gt; }<br>&gt; <br>&gt; And “optional” disappears from the language. Now, there’s no optionality left, so our useDelegate example tries to just do correct calls:<br>&gt; <br>&gt; func useDelegate(delegate: NSTableViewDelegate) -&gt; NSView? {<br>&gt;   let view = delegate.tableView(tableView, viewFor: column, row: row)<br>&gt;   let height = delegate.tableView(tableView, heightOfRow: row)<br>&gt; }<br>&gt; <br>&gt; Of course, the code above will fail if the actual delegate doesn’t implement both methods. We need some kind of default implementation to fall back on in that case. I propose that the code above produce a compiler error on both lines *unless* there is a “default implementation” visible. So, to make the code above compile without error, one would have to add:<br>&gt; <br>&gt; extension NSTableViewDelegate {<br>&gt;   @nonobjc func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView? { return nil }<br>&gt;   <br>&gt;   @nonobjc func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat { return 17 }<br>&gt; } <br>&gt; <br>&gt; Now, the useDelegate example compiles. If the actual delegate implements the optional requirement, we’ll use that implementation. Otherwise, the caller will use the default (Swift-only) implementation it sees. From an implementation standpoint, the compiler would effectively produce the following for the first of these calls:<br>&gt; <br>&gt; if delegate.responds(to: #selector(NSTableViewDelegate.tableView(_:viewFor:row:))) {<br>&gt;   // call the @objc instance method with the selector tableView:viewForTableColumn:row:<br>&gt; } else {<br>&gt;   // call the Swift-only implementation of tableView(_:viewFor:row:) in the protocol extension above<br>&gt; }<br>&gt; <br>&gt; There are a number of reasons why I like this approach:<br>&gt; <br>&gt; 1) It eliminates the notion of ‘optional’ requirements from the language. For classes that are adopting the NSTableViewDelegate protocol, it is as if these requirements had default implementations.<br>&gt; <br>&gt; 2) Only the callers to these requirements have to deal with the lack of default implementations. This was already the case for optional requirements, so it’s not an extra burden in principle, and it’s generally going to be easier to write one defaulted implementation than deal with it in several different places. Additionally, most of these callers are probably in the Cocoa frameworks, not application code, so the overall impact should be small.<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; 	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160408/4ad12646/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76eb9711d45c1c9a71c0f24004072a22?s=50"></div><header><strong>[Idea] How to eliminate &#39;optional&#39; protocol requirements</strong> from <string>Zach Waldowski</string> &lt;zach at waldowski.me&gt;<p>April  8, 2016 at 11:00:00am</p></header><div class="content"><p>Table view semantics were discussed at length on a prior version of the<br>thread. That pattern is less than ideal; it essentially creates magic<br>behavior that&#39;s only described by documentation… or, worse, completely<br>forgotten about in documentation; something changing from version to<br>version of the framework; etc. I can not tell you how many times this<br>has tripped up members of my teams. Over in Cocoa proper, similar<br>behavior changes also arise (usually performance optimizations) from<br>whether or not you *override* a method, and it&#39;s even more confusing.<br> <br>Such a practice should not be a cornerstone of a modern language; as<br>discussed in the prior thread, the different semantics of the measuring<br>methods (the current return values, as well as the implicit one from not<br>overriding) should be captured explicitly in an enum, with a clear<br>default return value. This is in line with the spirit of Swift. Your API<br>contract with the user is clear, and the introduction of default<br>implementations is versioned as a matter of public API.<br> <br>It&#39;s interesting that you use the phrase &quot;customization points&quot;. Our<br>text for teaching protocol extensions in Swift uses it heavily - that<br>*is* the behavior of protocols with default implementations in Swift<br>today. You delegate something out, but give it a default implementation<br>with logic you specify. That&#39;s a customization point, too.<br> <br>Cheers!<br>Zachary Waldowski<br>zach at waldowski.me<br> <br> <br>On Fri, Apr 8, 2016, at 08:47 AM, Jonathan Hull via swift-evolution wrote:<br>&gt; Interesting proposal, but I wanted to mention a couple of potential<br>&gt; issues off the top of my head.  I know when I was using optional<br>&gt; requirements in Objective C, I would often use the presence/lack of<br>&gt; the method (not just whether it returned nil) in the logic of my<br>&gt; program.  I used the presence of a method as a way for the implementor<br>&gt; of a delegate to naturally communicate whether they wanted a more<br>&gt; advanced feature.  The absence of the method itself is information<br>&gt; which can be utilized, not just whether it returns nil, and I believe<br>&gt; that is part of what people are asking for when they say they want<br>&gt; optional methods in Swift.<br>&gt;<br>&gt;<br>&gt; Let me try to give a simplified example which I am not sure how you<br>&gt; would work around in this proposal:<br>&gt;<br>&gt; Let’s say there is a datasource protocol which optionally asks for an<br>&gt; image associated with a particular piece of data (imagine a table or<br>&gt; collection view type custom control).  If the method is not<br>&gt; implemented in the data source, then a different view is shown for<br>&gt; each data point that doesn’t have a place for images at all.  If the<br>&gt; method is implemented, but returns nil, then a default image is used<br>&gt; as a placeholder instead (in a view which has a place for images).<br>&gt;<br>&gt; tl;dr: Optional methods are often used as customization points,<br>&gt; and the methods, if implemented, may also have another meaning/use<br>&gt; for nil.<br>&gt;<br>&gt;<br>&gt; Similarly, a different back-end implementation may be used in the case<br>&gt; where an optional method is not implemented.  Let’s say you have<br>&gt; something like a tableview with an optional method giving rowHeights.<br>&gt; If that method is unimplemented, it is possible to have a much more<br>&gt; efficient layout algorithm… and in some cases, you may check for the<br>&gt; existence of the optional method when the delegate is set, and swap<br>&gt; out a different layout object based on which customizations are needed<br>&gt; (and again nil might mean that a height/etc... should be automatically<br>&gt; calculated).  This is the ability I miss the most.<br>&gt;<br>&gt;<br>&gt; Not saying the proposal is unworkable, just wanted to add some food<br>&gt; for thought.  I know I really miss optional methods in Swift.  In some<br>&gt; areas Swift is a lot more powerful, but there are lots of things I<br>&gt; used to do in Obj C that I haven’t figured out how to do in Swift yet<br>&gt; (if they are even possible).  I am kind of disturbed by the<br>&gt; trend/desire to get rid of the smalltalk-ness, as opposed to finding<br>&gt; new and safer ways to support that flexibility/expressiveness.  I<br>&gt; would really like to see swift deliver on it’s promise of being a more<br>&gt; modern alternative to ObjC (which it isn’t yet, IMHO) instead of just<br>&gt; a more modern alternative to C++/Java.<br>&gt;<br>&gt; Thanks,<br>&gt; Jon<br>&gt;<br>&gt;&gt; Proposed Solution: Caller-side default implementations  Default<br>&gt;&gt; implementations and optional requirements differ most on the caller<br>&gt;&gt; side. For example, let’s use NSTableView delegate as it’s imported<br>&gt;&gt; today:  func useDelegate(delegate: NSTableViewDelegate) { if let<br>&gt;&gt; getView = delegate.tableView(_:viewFor:row:) { // since the<br>&gt;&gt; requirement is optional, a reference to the method produces a value<br>&gt;&gt; of optional function type // I can call getView here }  if let<br>&gt;&gt; getHeight = delegate.tableView(_:heightOfRow:) { // I can call<br>&gt;&gt; getHeight here } }  With my proposal, we’d have some compiler-<br>&gt;&gt; synthesized attribute (let’s call it<br>&gt;&gt; @__caller_default_implementation) that gets places on Objective-C<br>&gt;&gt; optional requirements when they get imported, e.g.,  @objc protocol<br>&gt;&gt; NSTableViewDelegate { @__caller_default_implementation func<br>&gt;&gt; tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt;<br>&gt;&gt; NSView? @__caller_default_implementation func tableView(_:<br>&gt;&gt; NSTableView, heightOfRow: Int) -&gt; CGFloat }  And “optional”<br>&gt;&gt; disappears from the language. Now, there’s no optionality left, so<br>&gt;&gt; our useDelegate example tries to just do correct calls:  func<br>&gt;&gt; useDelegate(delegate: NSTableViewDelegate) -&gt; NSView? { let view =<br>&gt;&gt; delegate.tableView(tableView, viewFor: column, row: row) let height =<br>&gt;&gt; delegate.tableView(tableView, heightOfRow: row) }  Of course, the<br>&gt;&gt; code above will fail if the actual delegate doesn’t implement both<br>&gt;&gt; methods. We need some kind of default implementation to fall back on<br>&gt;&gt; in that case. I propose that the code above produce a compiler error<br>&gt;&gt; on both lines *unless* there is a “default implementation” visible.<br>&gt;&gt; So, to make the code above compile without error, one would have to<br>&gt;&gt; add:  extension NSTableViewDelegate { @nonobjc func tableView(_:<br>&gt;&gt; NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView? { return<br>&gt;&gt; nil }  @nonobjc func tableView(_: NSTableView, heightOfRow: Int) -&gt;<br>&gt;&gt; CGFloat { return 17 } }  Now, the useDelegate example compiles. If<br>&gt;&gt; the actual delegate implements the optional requirement, we’ll use<br>&gt;&gt; that implementation. Otherwise, the caller will use the default (Swift-<br>&gt;&gt; only) implementation it sees. From an implementation standpoint, the<br>&gt;&gt; compiler would effectively produce the following for the first of<br>&gt;&gt; these calls:  if delegate.responds(to:<br>&gt;&gt; #selector(NSTableViewDelegate.tableView(_:viewFor:row:))) { // call<br>&gt;&gt; the @objc instance method with the selector<br>&gt;&gt; tableView:viewForTableColumn:row: } else { // call the Swift-only<br>&gt;&gt; implementation of tableView(_:viewFor:row:) in the protocol extension<br>&gt;&gt; above }  There are a number of reasons why I like this approach:  1)<br>&gt;&gt; It eliminates the notion of ‘optional’ requirements from the<br>&gt;&gt; language. For classes that are adopting the NSTableViewDelegate<br>&gt;&gt; protocol, it is as if these requirements had default implementations.<br>&gt;&gt; 2) Only the callers to these requirements have to deal with the lack<br>&gt;&gt; of default implementations. This was already the case for optional<br>&gt;&gt; requirements, so it’s not an extra burden in principle, and it’s<br>&gt;&gt; generally going to be easier to write one defaulted implementation<br>&gt;&gt; than deal with it in several different places. Additionally, most of<br>&gt;&gt; these callers are probably in the Cocoa frameworks, not application<br>&gt;&gt; code, so the overall impact should be small.  Thoughts?   - Doug<br>&gt;<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br> <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160408/1281d02b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5af07e950f10c7c1df1c44bed055c1eb?s=50"></div><header><strong>[Idea] How to eliminate &#39;optional&#39; protocol requirements</strong> from <string>Daniel Steinberg</string> &lt;daniel at dimsumthinking.com&gt;<p>April 10, 2016 at 07:00:00am</p></header><div class="content"><p>In this case, I would think you would move the optional method into a separate protocol. If the user implemented the method they would have to explicitly conform to this specific protocol in which case they would be treated differently. <br></p><p>Instead of having to check whether someone implemented an optional method in a protocol, you would check if they conformed to the protocol that now contains it. This is a much stronger contract that is more easily understood by both sides.<br></p><p>Daniel <br></p><p>&gt; On Apr 8, 2016, at 8:47 AM, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Interesting proposal, but I wanted to mention a couple of potential issues off the top of my head.  I know when I was using optional requirements in Objective C, I would often use the presence/lack of the method (not just whether it returned nil) in the logic of my program.  I used the presence of a method as a way for the implementor of a delegate to naturally communicate whether they wanted a more advanced feature.  The absence of the method itself is information which can be utilized, not just whether it returns nil, and I believe that is part of what people are asking for when they say they want optional methods in Swift.<br>&gt; <br>&gt; <br>&gt; Let me try to give a simplified example which I am not sure how you would work around in this proposal:<br>&gt; <br>&gt; Let’s say there is a datasource protocol which optionally asks for an image associated with a particular piece of data (imagine a table or collection view type custom control).  If the method is not implemented in the data source, then a different view is shown for each data point that doesn’t have a place for images at all.  If the method is implemented, but returns nil, then a default image is used as a placeholder instead (in a view which has a place for images).<br>&gt; <br>&gt; tl;dr: Optional methods are often used as customization points, and the methods, if implemented, may also have another meaning/use for nil.<br>&gt; <br>&gt; <br>&gt; Similarly, a different back-end implementation may be used in the case where an optional method is not implemented.  Let’s say you have something like a tableview with an optional method giving rowHeights.  If that method is unimplemented, it is possible to have a much more efficient layout algorithm… and in some cases, you may check for the existence of the optional method when the delegate is set, and swap out a different layout object based on which customizations are needed (and again nil might mean that a height/etc... should be automatically calculated).  This is the ability I miss the most.<br>&gt; <br>&gt; <br>&gt; Not saying the proposal is unworkable, just wanted to add some food for thought.  I know I really miss optional methods in Swift.  In some areas Swift is a lot more powerful, but there are lots of things I used to do in Obj C that I haven’t figured out how to do in Swift yet (if they are even possible).  I am kind of disturbed by the trend/desire to get rid of the smalltalk-ness, as opposed to finding new and safer ways to support that flexibility/expressiveness.  I would really like to see swift deliver on it’s promise of being a more modern alternative to ObjC (which it isn’t yet, IMHO) instead of just a more modern alternative to C++/Java.<br>&gt; <br>&gt; Thanks,<br>&gt; Jon<br>&gt; <br>&gt;&gt; Proposed Solution: Caller-side default implementations<br>&gt;&gt; <br>&gt;&gt; Default implementations and optional requirements differ most on the caller side. For example, let’s use NSTableView delegate as it’s imported today:<br>&gt;&gt; <br>&gt;&gt; func useDelegate(delegate: NSTableViewDelegate) {<br>&gt;&gt;   if let getView = delegate.tableView(_:viewFor:row:) { // since the requirement is optional, a reference to the method produces a value of optional function type<br>&gt;&gt;     // I can call getView here<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   if let getHeight = delegate.tableView(_:heightOfRow:) {<br>&gt;&gt;     // I can call getHeight here<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; With my proposal, we’d have some compiler-synthesized attribute (let’s call it @__caller_default_implementation) that gets places on Objective-C optional requirements when they get imported, e.g.,<br>&gt;&gt; <br>&gt;&gt; @objc protocol NSTableViewDelegate {<br>&gt;&gt;   @__caller_default_implementation func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView?<br>&gt;&gt;   @__caller_default_implementation func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; And “optional” disappears from the language. Now, there’s no optionality left, so our useDelegate example tries to just do correct calls:<br>&gt;&gt; <br>&gt;&gt; func useDelegate(delegate: NSTableViewDelegate) -&gt; NSView? {<br>&gt;&gt;   let view = delegate.tableView(tableView, viewFor: column, row: row)<br>&gt;&gt;   let height = delegate.tableView(tableView, heightOfRow: row)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Of course, the code above will fail if the actual delegate doesn’t implement both methods. We need some kind of default implementation to fall back on in that case. I propose that the code above produce a compiler error on both lines *unless* there is a “default implementation” visible. So, to make the code above compile without error, one would have to add:<br>&gt;&gt; <br>&gt;&gt; extension NSTableViewDelegate {<br>&gt;&gt;   @nonobjc func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView? { return nil }<br>&gt;&gt;   <br>&gt;&gt;   @nonobjc func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat { return 17 }<br>&gt;&gt; } <br>&gt;&gt; <br>&gt;&gt; Now, the useDelegate example compiles. If the actual delegate implements the optional requirement, we’ll use that implementation. Otherwise, the caller will use the default (Swift-only) implementation it sees. From an implementation standpoint, the compiler would effectively produce the following for the first of these calls:<br>&gt;&gt; <br>&gt;&gt; if delegate.responds(to: #selector(NSTableViewDelegate.tableView(_:viewFor:row:))) {<br>&gt;&gt;   // call the @objc instance method with the selector tableView:viewForTableColumn:row:<br>&gt;&gt; } else {<br>&gt;&gt;   // call the Swift-only implementation of tableView(_:viewFor:row:) in the protocol extension above<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; There are a number of reasons why I like this approach:<br>&gt;&gt; <br>&gt;&gt; 1) It eliminates the notion of ‘optional’ requirements from the language. For classes that are adopting the NSTableViewDelegate protocol, it is as if these requirements had default implementations.<br>&gt;&gt; <br>&gt;&gt; 2) Only the callers to these requirements have to deal with the lack of default implementations. This was already the case for optional requirements, so it’s not an extra burden in principle, and it’s generally going to be easier to write one defaulted implementation than deal with it in several different places. Additionally, most of these callers are probably in the Cocoa frameworks, not application code, so the overall impact should be small.<br>&gt;&gt; <br>&gt;&gt; Thoughts?<br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160410/f3887c61/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>[Idea] How to eliminate &#39;optional&#39; protocol requirements</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>April 10, 2016 at 10:00:00pm</p></header><div class="content"><p>I agree, separate protocols is preferable. I think it needs some more<br>thought though, some UIKit protocols have several optional methods, I&#39;m not<br>sure if a protocol for each would be very clean.<br></p><p>The other thing that needs consideration is whether it&#39;s possible to<br>automatically convert objc with optional methods to Swift without them. For<br>example, it would need to be compatible with checks for protocol<br>conformance, I&#39;m not sure what edge cases will arise if the optional<br>methods are broken out into other protocols.<br></p><p>On Sunday, 10 April 2016, Daniel Steinberg via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; In this case, I would think you would move the optional method into a<br>&gt; separate protocol. If the user implemented the method they would have to<br>&gt; explicitly conform to this specific protocol in which case they would be<br>&gt; treated differently.<br>&gt;<br>&gt; Instead of having to check whether someone implemented an optional method<br>&gt; in a protocol, you would check if they conformed to the protocol that now<br>&gt; contains it. This is a much stronger contract that is more easily<br>&gt; understood by both sides.<br>&gt;<br>&gt; Daniel<br>&gt;<br>&gt; On Apr 8, 2016, at 8:47 AM, Jonathan Hull via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt; Interesting proposal, but I wanted to mention a couple of potential issues<br>&gt; off the top of my head.  I know when I was using optional requirements in<br>&gt; Objective C, I would often use the presence/lack of the method (not just<br>&gt; whether it returned nil) in the logic of my program.  I used the presence<br>&gt; of a method as a way for the implementor of a delegate to naturally<br>&gt; communicate whether they wanted a more advanced feature.  The absence of<br>&gt; the method itself is information which can be utilized, not just whether it<br>&gt; returns nil, and I believe that is part of what people are asking for when<br>&gt; they say they want optional methods in Swift.<br>&gt;<br>&gt;<br>&gt; Let me try to give a simplified example which I am not sure how you would<br>&gt; work around in this proposal:<br>&gt;<br>&gt; Let’s say there is a datasource protocol which optionally asks for an<br>&gt; image associated with a particular piece of data (imagine a table or<br>&gt; collection view type custom control).  If the method is not implemented in<br>&gt; the data source, then a different view is shown for each data point that<br>&gt; doesn’t have a place for images at all.  If the method is implemented, but<br>&gt; returns nil, then a default image is used as a placeholder instead (in a<br>&gt; view which has a place for images).<br>&gt;<br>&gt; tl;dr: Optional methods are often used as customization points, and the<br>&gt; methods, if implemented, may also have another meaning/use for nil.<br>&gt;<br>&gt;<br>&gt; Similarly, a different back-end implementation may be used in the case<br>&gt; where an optional method is not implemented.  Let’s say you have something<br>&gt; like a tableview with an optional method giving rowHeights.  If that method<br>&gt; is unimplemented, it is possible to have a much more efficient layout<br>&gt; algorithm… and in some cases, you may check for the existence of the<br>&gt; optional method when the delegate is set, and swap out a different layout<br>&gt; object based on which customizations are needed (and again nil might mean<br>&gt; that a height/etc... should be automatically calculated).  This is the<br>&gt; ability I miss the most.<br>&gt;<br>&gt;<br>&gt; Not saying the proposal is unworkable, just wanted to add some food for<br>&gt; thought.  I know I really miss optional methods in Swift.  In some areas<br>&gt; Swift is a lot more powerful, but there are lots of things I used to do in<br>&gt; Obj C that I haven’t figured out how to do in Swift yet (if they are even<br>&gt; possible).  I am kind of disturbed by the trend/desire to get rid of the<br>&gt; smalltalk-ness, as opposed to finding new and safer ways to support that<br>&gt; flexibility/expressiveness.  I would really like to see swift deliver on<br>&gt; it’s promise of being a more modern alternative to ObjC (which it isn’t<br>&gt; yet, IMHO) instead of just a more modern alternative to C++/Java.<br>&gt;<br>&gt; Thanks,<br>&gt; Jon<br>&gt;<br>&gt; Proposed Solution: Caller-side default implementations<br>&gt;<br>&gt; Default implementations and optional requirements differ most on the caller side. For example, let’s use NSTableView delegate as it’s imported today:<br>&gt;<br>&gt; func useDelegate(delegate: NSTableViewDelegate) {<br>&gt;   if let getView = delegate.tableView(_:viewFor:row:) { // since the requirement is optional, a reference to the method produces a value of optional function type<br>&gt;     // I can call getView here<br>&gt;   }<br>&gt;<br>&gt;   if let getHeight = delegate.tableView(_:heightOfRow:) {<br>&gt;     // I can call getHeight here<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; With my proposal, we’d have some compiler-synthesized attribute (let’s call it @__caller_default_implementation) that gets places on Objective-C optional requirements when they get imported, e.g.,<br>&gt;<br>&gt; @objc protocol NSTableViewDelegate {<br>&gt;   @__caller_default_implementation func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView?<br>&gt;   @__caller_default_implementation func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat<br>&gt; }<br>&gt;<br>&gt; And “optional” disappears from the language. Now, there’s no optionality left, so our useDelegate example tries to just do correct calls:<br>&gt;<br>&gt; func useDelegate(delegate: NSTableViewDelegate) -&gt; NSView? {<br>&gt;   let view = delegate.tableView(tableView, viewFor: column, row: row)<br>&gt;   let height = delegate.tableView(tableView, heightOfRow: row)<br>&gt; }<br>&gt;<br>&gt; Of course, the code above will fail if the actual delegate doesn’t implement both methods. We need some kind of default implementation to fall back on in that case. I propose that the code above produce a compiler error on both lines *unless* there is a “default implementation” visible. So, to make the code above compile without error, one would have to add:<br>&gt;<br>&gt; extension NSTableViewDelegate {<br>&gt;   @nonobjc func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView? { return nil }<br>&gt;<br>&gt;   @nonobjc func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat { return 17 }<br>&gt; }<br>&gt;<br>&gt; Now, the useDelegate example compiles. If the actual delegate implements the optional requirement, we’ll use that implementation. Otherwise, the caller will use the default (Swift-only) implementation it sees. From an implementation standpoint, the compiler would effectively produce the following for the first of these calls:<br>&gt;<br>&gt; if delegate.responds(to: #selector(NSTableViewDelegate.tableView(_:viewFor:row:))) {<br>&gt;   // call the @objc instance method with the selector tableView:viewForTableColumn:row:<br>&gt; } else {<br>&gt;   // call the Swift-only implementation of tableView(_:viewFor:row:) in the protocol extension above<br>&gt; }<br>&gt;<br>&gt; There are a number of reasons why I like this approach:<br>&gt;<br>&gt; 1) It eliminates the notion of ‘optional’ requirements from the language. For classes that are adopting the NSTableViewDelegate protocol, it is as if these requirements had default implementations.<br>&gt;<br>&gt; 2) Only the callers to these requirements have to deal with the lack of default implementations. This was already the case for optional requirements, so it’s not an extra burden in principle, and it’s generally going to be easier to write one defaulted implementation than deal with it in several different places. Additionally, most of these callers are probably in the Cocoa frameworks, not application code, so the overall impact should be small.<br>&gt;<br>&gt; Thoughts?<br>&gt;<br>&gt; 	- Doug<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160410/97076f0b/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>[Idea] How to eliminate &#39;optional&#39; protocol requirements</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>April 10, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; Le 8 avr. 2016 à 14:47, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Interesting proposal, but I wanted to mention a couple of potential issues off the top of my head.  I know when I was using optional requirements in Objective C, I would often use the presence/lack of the method (not just whether it returned nil) in the logic of my program.  I used the presence of a method as a way for the implementor of a delegate to naturally communicate whether they wanted a more advanced feature.  The absence of the method itself is information which can be utilized, not just whether it returns nil, and I believe that is part of what people are asking for when they say they want optional methods in Swift.<br>&gt; <br></p><p>Couldn’t agree more.<br></p><p>An telling example is NSFetchedResultsControllerDelegate.controller(_:didChangeObject:atIndexPath:forChangeType:newIndexPath:).<br></p><p>When this method is not implemented, the NSFetchedResultsController does not have to perform the heavy computations of individual changes in a Core Data fetch request, since nobody is listening to them.<br></p><p>In today’s Swift, this lazy behavior requires an extra configuration flag.<br></p><p>Gwendal Roué<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160410/fc308334/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
