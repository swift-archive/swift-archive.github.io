<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January 24, 2016 at 05:00:00pm</p></header><div class="content"><p>on Sun Jan 24 2016, Paul Cantrell &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I really like the general spirit of these guidelines. I particularly<br>&gt; appreciate their emphasis on clarity at the point of use, and their<br>&gt; recognition that both brevity and verbosity can be the enemy of<br>&gt; clarity.<br>&gt;<br>&gt; Some of the particulars of the guidelines haven’t worked well for me<br>&gt; in practice — and I see from this thread that others have hit some of<br>&gt; the same problems. The guidelines as they stand feel like they’ve<br>&gt; mostly been vetted against a bunch of ADTs (which is probably true —<br>&gt; stdlib?), and could use exposure to a broader range of libraries.<br></p><p>They&#39;ve been vetted against all of Cocoa (to the best of our<br>ability—it&#39;s huge) and against a couple of sample projects, Lister and<br>DemoBots.  This was a major effort and we endeavored to cover all the<br>bases.  However, we recognize that there&#39;s a lot more code out there<br>than we can possibly look at, so we&#39;re very happy to get more input from<br>the community.<br></p><p>&gt; Immediately after the guidelines were published, before this review<br>&gt; began, I tried applying them to Siesta. The project has 244 public<br>&gt; declarations, of which I found 28 that the guidelines seemed to<br>&gt; recommend changing. Of those 28, after much reflection and discussion,<br>&gt; I ended up changing only 7 to match the guidelines (and also cleaning<br>&gt; up several others, but in a non-guideline-compliant way).<br>&gt;<br>&gt; In short, in a real-world project, pre-guidelines code agreed with the<br>&gt; guidelines 89% of the time, but where it disagreed, the guidelines<br>&gt; achieved only a 25% acceptance rate with the curmudgeonly developers.<br>&gt;<br>&gt; You can follow that discussion here:<br>&gt;<br>&gt; 	https://gist.github.com/pcantrell/22a6564ca7d22789315b<br>&gt; &lt;https://gist.github.com/pcantrell/22a6564ca7d22789315b&gt;<br>&gt; 	https://github.com/bustoutsolutions/siesta/issues/15<br>&gt; &lt;https://github.com/bustoutsolutions/siesta/issues/15&gt;<br>&gt;<br>&gt; Several places where we rejected the guidelines relate to the raging<br>&gt; debate about first argument labels.  Here’s a rundown of those<br>&gt; particular cases. (Since this message will be a long one, I’ll share<br>&gt; in a separate message some notes on the other places where we rejected<br>&gt; the guidelines on questions other than the first arg label.)<br>&gt;<br>&gt; Hopefully some more concrete examples can be useful in informing the<br>&gt; discussion.<br>&gt;<br>&gt; _____________________________<br>&gt;<br>&gt; Quick context: there are things called resources. Resources can have<br>&gt; observers. Observers are either self-owned or have an external owner<br>&gt; object. Observers can either conform to a protocol or be closures; if<br>&gt; the the latter, then they _must_ have an external owner (because<br>&gt; closures aren’t objects).<br>&gt;<br>&gt; There are thus three different methods to add observers to a resource<br>&gt; — though they all cover the same underlying notion of “observer” (and<br>&gt; in fact all boil down to the same thing internally):<br>&gt;<br>&gt;     resource.addObserver(foo)<br>&gt;<br>&gt;     resource.addObserver(fancyIndicator, owner: foo)<br>&gt;<br>&gt;     resource.addObserver(owner: foo) {<br>&gt;         resource, event in<br>&gt;         updateStuff(resource.latestData)<br>&gt;     }<br></p><p>Oh, that&#39;s an interesting API.  I think it&#39;s pretty unusual that the<br>direct object of the method is a trailing closure, and IMO inventing<br>some conventions for handling this kind of API in your own code would be<br>perfectly appropriate.<br></p><p>&gt; The API guidelines as stated would have us change that last one to:<br>&gt;<br>&gt;     resource.addObserverWithOwner(foo) {<br>&gt;         resource, event in<br>&gt;         updateStuff(resource.latestData)<br>&gt;     }<br>&gt;<br>&gt; However, this incorrectly implies that there is a distinct kind of<br>&gt; thing that is an “observer with owner,” and that we will get one only<br>&gt; from the third flavor of the method. That implication is wrong.<br></p><p>Yes, one of the complaints I have about the guidelines trying so hard to<br>avoid initial argument labels is that it causes some things to be read<br>as closely-associated when they should not be. The guidelines prevent us<br>from using that opening parenthesis to express a lack of association.<br></p><p>This comes up especially with Bool parameters, e.g.<br></p><p>  dismissAnimated(false)<br></p><p>where &quot;animated&quot; is essentially a parameter tuning the behavior of the<br>basic functionality, &quot;dismiss,&quot; rather than an intrinsic part of that<br>functionality.<br></p><p>Others developing the API guidelines felt that the parenthesis was not<br>significant enough to be meaningful to people reading the call, and that<br>any increased expressivity was not paid for by the fact that the surface<br>of our APIs would be less-consistent (a more even balance of APIs with<br>and without initial labels is less consistent than having initial labels<br>be quite rare).<br></p><p>&gt; The consistency in the original of the “addObserver” name and the<br>&gt; “owner:” label make the correct implication: all three methods serve<br>&gt; the same purpose, observers are observers, and “owner” means the same<br>&gt; thing in the two places it appears. I certainly think the<br>&gt; non-compliant version of the code reads better.<br></p><p>+1<br></p><p>&gt; There was extensive discussion around another family of methods that<br>&gt; return a resource given either a path fragment or an absolute<br>&gt; URL. This is where we ended up:<br>&gt;<br>&gt;     service.resource(&quot;/foo&quot;)<br>&gt;     service.resource(absoluteURL: &quot;http://bar.com&quot;)<br>&gt;     service.resource(absoluteURL: NSURL(string: &quot;http://bar.com&quot;))<br>&gt;<br>&gt; (The first is by far the most common, the “standard” flavor.)<br></p><p>Sorry, perhaps it should be obvious, but why do you need the label at<br>all here?  Seems to me you could do this with two overloads, since it&#39;s<br>easy to detect when a string is an absolute URL.<br></p><p>&gt; The guidelines would have had us do this:<br>&gt;<br>&gt;     service.resourceWithPathFragment(&quot;/foo&quot;)<br>&gt;     service.resourceWithAbsoluteURL(&quot;http://bar.com&quot;)<br>&gt;     service.resourceWithAbsoluteURL(NSURL(string: &quot;http://bar.com&quot;))<br>&gt;<br>&gt; To my eyes, this crosses the line into verbosity that impedes clarity,<br></p><p>+1<br></p><p>&gt; but there’s an even more serious problem: it wrongly implies that<br>&gt; there’s a distinction between “resources with path fragments” and<br>&gt; “resources with absolute URLs.” That’s dangerously wrong. One of the<br>&gt; central conceits of the whole library is that _all_ resources get a<br>&gt; canonicalized absolute URL, and there’s a uniqueness guarantee for<br>&gt; that URL no matter whether it was constructed for a path fragment, an<br>&gt; absolute URL, or resource-relative navigation.<br></p><p>Yep, that&#39;s the &quot;can&#39;t use ( to disassociate&quot; problem again.<br></p><p>&gt; In the cases of both addObserver(…) and service.resource(…), the<br>&gt; guidelines would have us actively mislead users.<br>&gt;<br>&gt; Another trickier example of the same issue is the much-discussed<br>&gt; typedContent method, which downcasts based on inferred type and<br>&gt; returns a default value if content is either missing or of the wrong<br>&gt; type:<br>&gt;<br>&gt;     var image: UIImage?<br>&gt;     ...<br>&gt;     image = imageResource.typedContent(ifNone: placeholderImage)<br>&gt;<br>&gt; How to make this conform to the guidelines? The obvious fix is<br>&gt; terrible:<br>&gt;<br>&gt;     image = imageResource.typedContentIfNone(placeholderImage)<br>&gt;<br>&gt; This implies … what? That the method only returns typed content if<br>&gt; there is none of the placeholder image? <br></p><p>Very similar to dismissAnimated.<br></p><p>&gt; No, clearly a rephrasing is necessary:<br>&gt;<br>&gt;     image = imageResource.typedContentWithDefault(placeholderImage)<br>&gt;<br>&gt; But again we have this problem of determining whether “with default”<br>&gt; describes the method’s behavior, its result, or its first<br>&gt; argument. Are we attaching content with the default somehow attached<br>&gt; to it? (No.) Are we returning some content, or a default value if<br>&gt; there is none? (Yes.) So maybe this is better:<br>&gt;<br>&gt;     image = imageResource.typedContentOrDefault(placeholderImage)<br>&gt;<br>&gt; But now my brain is having parsing problems. What is the LHS of that<br>&gt; “or?” It just doesn’t read naturally. OK, maybe even more words can<br>&gt; save us:<br>&gt;<br>&gt;     image =<br>&gt; imageResource.typedContentOrDefaultIfNone(placeholderImage)<br>&gt;<br>&gt; Yuck. At this point, we might as well stuff the entire method abstract<br>&gt; in the name:<br>&gt;<br>&gt;     image =<br>&gt; imageResource.typedContentOrDefaultIfNoneOrMismatchedType(placeholderImage)<br>&gt;<br>&gt; Yuck squared. The original is so much clearer:<br>&gt;<br>&gt;     image = imageResource.typedContent(ifNone: placeholderImage)<br></p><p>Point taken, but if you let go of determining the return type by type<br>inference (pretty close to overloading on return type) you might be<br>better off.<br></p><p>      i = Image(foundIn: resource, default: placeholder)<br></p><p>&gt; IMO, there’s nothing wrong with leaning on programming language syntax<br>&gt; to help segment and clarify English syntax.<br></p><p>+1.<br></p><p>&gt; _______________________________<br>&gt;<br>&gt; What’s the better guideline on first argument labels?<br>&gt;<br>&gt; Radek had a nice thought in the aforementioned Gihub thread:<br>&gt;<br>&gt;&gt; The rationale being, ifNone doesn&#39;t really describe the method … it<br>&gt;&gt; describes the parameter. Most of the time, the job of the method<br>&gt;&gt; makes the first parameter obvious (hence the guideline), but here, it<br>&gt;&gt; doesn&#39;t. So the parameter makes sense.<br></p><p>That echoes many of my thoughts.<br></p><p>&gt; I’ll give a +1 for these two recommendations from Erica, which run<br>&gt; along the same lines as Radek’s thought, but in more thorough detail:<br>&gt;<br>&gt;&gt; On Jan 23, 2016, at 6:33 PM, Erica Sadun via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Prefer external names for the first parameter when the natural<br>&gt;&gt; semantic relationship between the parameters is stronger than their<br>&gt;&gt; relation to the operation. <br>&gt;&gt; <br>&gt;&gt; For example, the following calls use labels for the first parameter:<br>&gt;&gt; <br>&gt;&gt; login(userName: &quot;blah&quot;, password: &quot;...&quot;)<br>&gt;&gt; moveTo(x: 50.0, y: 30.0)<br>&gt;&gt; <br>&gt;&gt; This example is contrary to Swift&#39;s normal naming scheme which<br>&gt;&gt; integrates the first argument into the function or method name, for<br>&gt;&gt; example:<br>&gt;&gt; <br>&gt;&gt; loginWithUserName(&quot;blah&quot;, password: &quot;...&quot;)<br>&gt;&gt; moveToX(50.0, y: 30.0)<br>&gt;&gt; <br>&gt;&gt; The coupling between x and y, username and password, (and yes it is a<br>&gt;&gt; judgement call) should be considered as a reason to employ an<br>&gt;&gt; external label.<br>&gt; …<br>&gt;&gt; <br>&gt;&gt; Differentiate related calls whose implementations are distinguished<br>&gt;&gt; by their parameters, as you would with initializers, using first<br>&gt;&gt; parameter labels.<br>&gt;&gt; <br>&gt;&gt; Instead of loginWithUserName(&quot;blah&quot;, password: &quot;...&quot;) and<br>&gt;&gt; loginWithCredential(myCredential),<br>&gt;&gt; prefer:<br>&gt;&gt; <br>&gt;&gt; login(userName: &quot;blah&quot;, password: &quot;...&quot;)<br>&gt;&gt; login(credential: myCredential)<br>&gt;<br>&gt; I’m not sure we’ve found the perfect, crisp way of saying all this —<br>&gt; but I strongly agree that the existing guidelines are too rigid on the<br>&gt; question of the first arg label, and Erica’s wording comes the closest<br>&gt; I’ve seen to being a viable replacement.<br></p><p>I have a few problems with the above wording, but I&#39;m all for loosening<br>the restriction.  Unfortunately, getting the wording right isn&#39;t the big<br>challenge; the challenge is convincing the people that matter that the<br>increased expressivity of allowing first argument labels in more places<br>is worth the increased non-uniformity of APIs.  Having examples like the<br>ones you&#39;ve presented here should be very helpful.<br></p><p>Thanks,<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>January 24, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jan 24, 2016, at 7:25 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Sun Jan 24 2016, Paul Cantrell &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; The guidelines as they stand feel like they’ve<br>&gt;&gt; mostly been vetted against a bunch of ADTs (which is probably true —<br>&gt;&gt; stdlib?), and could use exposure to a broader range of libraries.<br>&gt; <br>&gt; They&#39;ve been vetted against all of Cocoa (to the best of our<br>&gt; ability—it&#39;s huge) and against a couple of sample projects, Lister and<br>&gt; DemoBots.  This was a major effort and we endeavored to cover all the<br>&gt; bases.<br></p><p>Well, my mistake then! Always dangerous to speculate on the thoughts and experiences of other people.<br></p><p>&gt;&gt;    resource.addObserver(foo)<br>&gt;&gt; <br>&gt;&gt;    resource.addObserver(fancyIndicator, owner: foo)<br>&gt;&gt; <br>&gt;&gt;    resource.addObserver(owner: foo) {<br>&gt;&gt;        resource, event in<br>&gt;&gt;        updateStuff(resource.latestData)<br>&gt;&gt;    }<br>&gt; <br>&gt; Oh, that&#39;s an interesting API.  I think it&#39;s pretty unusual that the<br>&gt; direct object of the method is a trailing closure, and IMO inventing<br>&gt; some conventions for handling this kind of API in your own code would be<br>&gt; perfectly appropriate.<br></p><p>Yes, “direct object is a trailing closure” is a very good way of summarizing the problem here. And I did in fact think about making the closure the first arg, but the obvious hideous consequences when the closure gets long steered me away from that. Swift is right to give special deference to trailing closures, IMO.<br></p><p>You may have hit on an underlying principle with your “direct object of the method” observation: many of the cases we’re talking about where the first arg wants a label are ones where the method is a verb and its direct object is not the first arg alone, either because (1) the direct object is something other than the first arg, (2) the direct object is several args taken together, or (3) the verb is not transitive.<br></p><p>Could that lead to an improvement in the guidelines?<br></p><p>Case (1) covers the trailing closure above, and also typedContent below, whose direct object is implicit. Case (2) covers moveTo(x:y:) and arguably also covers logInWith(username:password:). (Aside: “login” is a noun and “log in” is a verb, dang it, and the method should be “logIn” … but we never do that because it looks ridiculous. Grammar…!) Case (3) covers dismissAnimated.<br></p><p>&gt; Yes, one of the complaints I have about the guidelines trying so hard to<br>&gt; avoid initial argument labels is that it causes some things to be read<br>&gt; as closely-associated when they should not be.<br></p><p>You’ve hit the nail on the head there. Decision-makers take note! Gratuitous Unicode for emphasis! ✮✮✮✮✮✮<br></p><p>&gt; Others developing the API guidelines felt that the parenthesis was not<br>&gt; significant enough to be meaningful to people reading the call, and that<br>&gt; any increased expressivity was not paid for by the fact that the surface<br>&gt; of our APIs would be less-consistent (a more even balance of APIs with<br>&gt; and without initial labels is less consistent than having initial labels<br>&gt; be quite rare).<br></p><p>I don’t think this is the case. The paren seems significant to my eyes — more and more so the less I grow accustomed to Obj-C, with all its syntactic noise — and we have ever-better autocomplete, compiler fixits, and online docs to help discover when initial args are needed.<br></p><p>&gt;&gt;    service.resource(&quot;/foo&quot;)<br>&gt;&gt;    service.resource(absoluteURL: &quot;http://bar.com&quot;)<br>&gt;&gt;    service.resource(absoluteURL: NSURL(string: &quot;http://bar.com&quot;))<br>&gt;&gt; <br>&gt;&gt; (The first is by far the most common, the “standard” flavor.)<br>&gt; <br>&gt; Sorry, perhaps it should be obvious, but why do you need the label at<br>&gt; all here?  Seems to me you could do this with two overloads, since it&#39;s<br>&gt; easy to detect when a string is an absolute URL.<br></p><p>An excellent question, and I’ll try to answer it without going too far off topic:<br></p><p>It’s a security feature. Because of how the first flavor (path fragment) works, it’s likely that unsanitized user input will creep into it, e.g. &quot;/user/\(userTextField.text)&quot;. (This is doubly true of its counterpart resource.child(…).) Auto-detecting absolute URLs would be dangerous: it could cause problems such as leaking credentials or posting sensitive data to a malicious server. The flavor that takes absolute URLs, on the other hand, is typically traversing intra-API hrefs returned by the API itself. I wanted to keep those use cases well separated.<br></p><p>I considered disallowing the second flavor (absolute URL string), and distinguishing the remaining two on a string vs. NSURL basis. However, having an absolute URL string is a far more common case than having an NSURL, and letting the library do the string → NSURL conversion lets it produce more useful debugging / diagnostic info for malformed URLs.<br></p><p>&gt;&gt; Yuck squared. The original is so much clearer:<br>&gt;&gt; <br>&gt;&gt;    image = imageResource.typedContent(ifNone: placeholderImage)<br>&gt; <br>&gt; Point taken, but if you let go of determining the return type by type<br>&gt; inference (pretty close to overloading on return type) you might be<br>&gt; better off.<br>&gt; <br>&gt;      i = Image(foundIn: resource, default: placeholder)<br></p><p>That’s a really nice thought, and a reminder that I’m still thinking inside the boxes of other languages.<br></p><p>&gt;&gt; I’m not sure we’ve found the perfect, crisp way of saying all this —<br>&gt;&gt; but I strongly agree that the existing guidelines are too rigid on the<br>&gt;&gt; question of the first arg label, and Erica’s wording comes the closest<br>&gt;&gt; I’ve seen to being a viable replacement.<br>&gt; <br>&gt; I have a few problems with the above wording, but I&#39;m all for loosening<br>&gt; the restriction.<br></p><p>Erica’s wording isn’t perfect, but I feel like it’s getting warm. Certainly the best effort at a specific revision I’ve seen.<br></p><p>&gt; the challenge is convincing the people that matter that the<br>&gt; increased expressivity of allowing first argument labels in more places<br>&gt; is worth the increased non-uniformity of APIs.<br></p><p>Consistency is always in tension with expressivity, and it’s a hard balance to strike.<br></p><p>The problem for those of us outside Apple is not that we’re bound by the guidelines; it’s that we aren’t. If the guidelines get in the way too much, people will just ignore them, and they’ll lose their value. If they’re too loose, they lose their value. It’s a tricky middle ground.<br></p><p>Cheers,<br></p><p>Paul<br></p><p><br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160124/6a5db798/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January 24, 2016 at 09:00:00pm</p></header><div class="content"><p>on Sun Jan 24 2016, Paul Cantrell &lt;cantrell-AT-pobox.com&gt; wrote:<br></p><p>&gt;&gt; On Jan 24, 2016, at 7:25 PM, Dave Abrahams via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Sun Jan 24 2016, Paul Cantrell &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; The guidelines as they stand feel like they’ve<br>&gt;&gt;&gt; mostly been vetted against a bunch of ADTs (which is probably true —<br>&gt;&gt;&gt; stdlib?), and could use exposure to a broader range of libraries.<br>&gt;&gt; <br>&gt;&gt; They&#39;ve been vetted against all of Cocoa (to the best of our<br>&gt;&gt; ability—it&#39;s huge) and against a couple of sample projects, Lister<br>&gt;&gt; and DemoBots.  This was a major effort and we endeavored to cover all<br>&gt;&gt; the bases.<br>&gt;<br>&gt; Well, my mistake then! Always dangerous to speculate on the thoughts<br>&gt; and experiences of other people.<br>&gt;<br>&gt;&gt;&gt;    resource.addObserver(foo)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    resource.addObserver(fancyIndicator, owner: foo)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    resource.addObserver(owner: foo) {<br>&gt;&gt;&gt;        resource, event in<br>&gt;&gt;&gt;        updateStuff(resource.latestData)<br>&gt;&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; Oh, that&#39;s an interesting API.  I think it&#39;s pretty unusual that the<br>&gt;&gt; direct object of the method is a trailing closure, and IMO inventing<br>&gt;&gt; some conventions for handling this kind of API in your own code would be<br>&gt;&gt; perfectly appropriate.<br>&gt;<br>&gt; Yes, “direct object is a trailing closure” is a very good way of<br>&gt; summarizing the problem here. And I did in fact think about making the<br>&gt; closure the first arg, but the obvious hideous consequences when the<br>&gt; closure gets long steered me away from that. Swift is right to give<br>&gt; special deference to trailing closures, IMO.<br>&gt;<br>&gt; You may have hit on an underlying principle with your “direct object<br>&gt; of the method” observation: many of the cases we’re talking about<br>&gt; where the first arg wants a label are ones where the method is a verb<br>&gt; and its direct object is not the first arg alone, either because (1)<br>&gt; the direct object is something other than the first arg, (2) the<br>&gt; direct object is several args taken together, or (3) the verb is not<br>&gt; transitive.<br>&gt;<br>&gt; Could that lead to an improvement in the guidelines?<br></p><p>I think it&#39;s very promising; we&#39;ll have to see how well it flies.<br></p><p>&gt; Case (1) covers the trailing closure above, and also typedContent<br>&gt; below, whose direct object is implicit. Case (2) covers moveTo(x:y:)<br>&gt; and arguably also covers logInWith(username:password:). (Aside:<br>&gt; “login” is a noun and “log in” is a verb, dang it, and the method<br>&gt; should be “logIn” … but we never do that because it looks<br>&gt; ridiculous. Grammar…!) Case (3) covers dismissAnimated.<br></p><p>Nice!<br></p><p><br>&gt;&gt; Yes, one of the complaints I have about the guidelines trying so hard to<br>&gt;&gt; avoid initial argument labels is that it causes some things to be read<br>&gt;&gt; as closely-associated when they should not be.<br>&gt;<br>&gt; You’ve hit the nail on the head there. Decision-makers take note!<br>&gt; Gratuitous Unicode for emphasis! ✮✮✮✮✮✮<br>&gt;<br>&gt;&gt; Others developing the API guidelines felt that the parenthesis was not<br>&gt;&gt; significant enough to be meaningful to people reading the call, and that<br>&gt;&gt; any increased expressivity was not paid for by the fact that the surface<br>&gt;&gt; of our APIs would be less-consistent (a more even balance of APIs with<br>&gt;&gt; and without initial labels is less consistent than having initial labels<br>&gt;&gt; be quite rare).<br>&gt;<br>&gt; I don’t think this is the case. The paren seems significant to my eyes<br>&gt; — more and more so the less I grow accustomed to Obj-C, with all its<br>&gt; syntactic noise — and we have ever-better autocomplete, compiler<br>&gt; fixits, and online docs to help discover when initial args are needed.<br>&gt;<br>&gt;&gt;&gt;    service.resource(&quot;/foo&quot;)<br>&gt;&gt;&gt;    service.resource(absoluteURL: &quot;http://bar.com&quot;)<br>&gt;&gt;&gt;    service.resource(absoluteURL: NSURL(string: &quot;http://bar.com&quot;))<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (The first is by far the most common, the “standard” flavor.)<br>&gt;&gt; <br>&gt;&gt; Sorry, perhaps it should be obvious, but why do you need the label at<br>&gt;&gt; all here?  Seems to me you could do this with two overloads, since it&#39;s<br>&gt;&gt; easy to detect when a string is an absolute URL.<br>&gt;<br>&gt; An excellent question, and I’ll try to answer it without going too far<br>&gt; off topic:<br>&gt;<br>&gt; It’s a security feature. Because of how the first flavor (path<br>&gt; fragment) works, it’s likely that unsanitized user input will creep<br>&gt; into it, e.g. &quot;/user/\(userTextField.text)&quot;. (This is doubly true of<br>&gt; its counterpart resource.child(…).) Auto-detecting absolute URLs would<br>&gt; be dangerous: it could cause problems such as leaking credentials or<br>&gt; posting sensitive data to a malicious server. The flavor that takes<br>&gt; absolute URLs, on the other hand, is typically traversing intra-API<br>&gt; hrefs returned by the API itself. I wanted to keep those use cases<br>&gt; well separated.<br></p><p>I&#39;ll take your word for it; it definitely sounds like you know what<br>you&#39;re doing in this area.<br></p><p>&gt; I considered disallowing the second flavor (absolute URL string), and<br>&gt; distinguishing the remaining two on a string vs. NSURL basis. However,<br>&gt; having an absolute URL string is a far more common case than having an<br>&gt; NSURL, and letting the library do the string → NSURL conversion lets<br>&gt; it produce more useful debugging / diagnostic info for malformed URLs.<br>&gt;<br>&gt;&gt;&gt; Yuck squared. The original is so much clearer:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    image = imageResource.typedContent(ifNone: placeholderImage)<br>&gt;&gt; <br>&gt;&gt; Point taken, but if you let go of determining the return type by type<br>&gt;&gt; inference (pretty close to overloading on return type) you might be<br>&gt;&gt; better off.<br>&gt;&gt; <br>&gt;&gt;      i = Image(foundIn: resource, default: placeholder)<br>&gt;<br>&gt; That’s a really nice thought, and a reminder that I’m still thinking<br>&gt; inside the boxes of other languages.<br>&gt;<br>&gt;&gt;&gt; I’m not sure we’ve found the perfect, crisp way of saying all this —<br>&gt;&gt;&gt; but I strongly agree that the existing guidelines are too rigid on the<br>&gt;&gt;&gt; question of the first arg label, and Erica’s wording comes the closest<br>&gt;&gt;&gt; I’ve seen to being a viable replacement.<br>&gt;&gt; <br>&gt;&gt; I have a few problems with the above wording, but I&#39;m all for loosening<br>&gt;&gt; the restriction.<br>&gt;<br>&gt; Erica’s wording isn’t perfect, but I feel like it’s getting<br>&gt; warm. Certainly the best effort at a specific revision I’ve seen.<br>&gt;<br>&gt;&gt; the challenge is convincing the people that matter that the<br>&gt;&gt; increased expressivity of allowing first argument labels in more places<br>&gt;&gt; is worth the increased non-uniformity of APIs.<br>&gt;<br>&gt; Consistency is always in tension with expressivity, and it’s a hard<br>&gt; balance to strike.<br>&gt;<br>&gt; The problem for those of us outside Apple is not that we’re bound by<br>&gt; the guidelines; it’s that we aren’t. If the guidelines get in the way<br>&gt; too much, people will just ignore them, and they’ll lose their<br>&gt; value. If they’re too loose, they lose their value. It’s a tricky<br>&gt; middle ground.<br></p><p>Don&#39;t worry, we&#39;re aware of these risks.  We want these guidelines to be<br>widely adopted outside Apple and lead to more overall uniformity in how<br>Swift code is written: that&#39;s good for everybody concerned.  If they<br>aren&#39;t acceptable to our customers, we&#39;ll have failed.<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>January 26, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 24, 2016, at 11:49 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; on Sun Jan 24 2016, Paul Cantrell &lt;cantrell-AT-pobox.com&gt; wrote:<br>&gt; <br>&gt;&gt; You may have hit on an underlying principle with your “direct object<br>&gt;&gt; of the method” observation: many of the cases we’re talking about<br>&gt;&gt; where the first arg wants a label are ones where the method is a verb<br>&gt;&gt; and its direct object is not the first arg alone, either because (1)<br>&gt;&gt; the direct object is something other than the first arg, (2) the<br>&gt;&gt; direct object is several args taken together, or (3) the verb is not<br>&gt;&gt; transitive.<br>&gt;&gt; <br>&gt;&gt; Could that lead to an improvement in the guidelines?<br>&gt; <br>&gt; I think it&#39;s very promising; we&#39;ll have to see how well it flies.<br>&gt; <br>&gt;&gt; Case (1) covers the trailing closure above, and also typedContent<br>&gt;&gt; below, whose direct object is implicit. Case (2) covers moveTo(x:y:)<br>&gt;&gt; and arguably also covers logInWith(username:password:). (Aside:<br>&gt;&gt; “login” is a noun and “log in” is a verb, dang it, and the method<br>&gt;&gt; should be “logIn” … but we never do that because it looks<br>&gt;&gt; ridiculous. Grammar…!) Case (3) covers dismissAnimated.<br>&gt; <br>&gt; Nice!<br></p><p>In the search for the better guideline that eases the widespread concerns about the “first arg” rule, it seems like there are several promising options:<br></p><p>1. Erica &amp; Radek’s razor that a word should move to the first arg label if its meaning is more tightly coupled to the argument than to the method as a whole.<br></p><p>2. The related razor that a word should move to the first arg label if it would create the misleading impression of an association with words from the method name (e.g. “resourceWithPathFragment” when _all_ resources have absolute URLs, and it’s the arg that is a path fragment).<br></p><p>3. My notion above that it might have to do with whether the first arg along is the direct object of the method name.<br></p><p>4. A more open-ended loosening of the guidelines that leaves a little more room for judgement, which might be as simple as replacing the phrase “There are only a few exceptions” with “Common exceptions include” in the guidelines.<br></p><p>I’d loosely prefer those options in that order, but all seem plausible to me.<br></p><p><br>&gt;&gt;&gt;&gt;   service.resource(&quot;/foo&quot;)<br>&gt;&gt;&gt;&gt;   service.resource(absoluteURL: &quot;http://bar.com&quot;)<br>&gt;&gt;&gt;&gt;   service.resource(absoluteURL: NSURL(string: &quot;http://bar.com&quot;))<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sorry, perhaps it should be obvious, but why do you need the label at<br>&gt;&gt;&gt; all here?  Seems to me you could do this with two overloads, since it&#39;s<br>&gt;&gt;&gt; easy to detect when a string is an absolute URL.<br>&gt;&gt; <br>&gt;&gt; An excellent question, and I’ll try to answer it without going too far<br>&gt;&gt; off topic:<br>&gt;&gt; <br>&gt;&gt; It’s a security feature. Because of how the first flavor (path<br>&gt;&gt; fragment) works, it’s likely that unsanitized user input will creep<br>&gt;&gt; into it, e.g. &quot;/user/\(userTextField.text)&quot;. (This is doubly true of<br>&gt;&gt; its counterpart resource.child(…).) Auto-detecting absolute URLs would<br>&gt;&gt; be dangerous: it could cause problems such as leaking credentials or<br>&gt;&gt; posting sensitive data to a malicious server. The flavor that takes<br>&gt;&gt; absolute URLs, on the other hand, is typically traversing intra-API<br>&gt;&gt; hrefs returned by the API itself. I wanted to keep those use cases<br>&gt;&gt; well separated.<br>&gt; <br>&gt; I&#39;ll take your word for it; it definitely sounds like you know what<br>&gt; you&#39;re doing in this area.<br></p><p>Well, I’ve thought hard about it … though that’s hardly the same thing!<br></p><p><br>&gt;&gt; Consistency is always in tension with expressivity, and it’s a hard<br>&gt;&gt; balance to strike.<br>&gt;&gt; <br>&gt;&gt; The problem for those of us outside Apple is not that we’re bound by<br>&gt;&gt; the guidelines; it’s that we aren’t. If the guidelines get in the way<br>&gt;&gt; too much, people will just ignore them, and they’ll lose their<br>&gt;&gt; value. If they’re too loose, they lose their value. It’s a tricky<br>&gt;&gt; middle ground.<br>&gt; <br>&gt; Don&#39;t worry, we&#39;re aware of these risks.  We want these guidelines to be<br>&gt; widely adopted outside Apple and lead to more overall uniformity in how<br>&gt; Swift code is written: that&#39;s good for everybody concerned.  If they<br>&gt; aren&#39;t acceptable to our customers, we&#39;ll have failed.<br></p><p>I meant that not so much as a worry as a statement of appreciation for your dilemma. As with all these questions, my inclination is to dump as much opinion and useful info as I can, then trust the core team to digest it all and make a wise decision. “Discussion by committee, design by small group” is a good model.<br></p><p>Cheers,<br></p><p>Paul<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
