<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>ExpressibleByStringInterpolation vs. String re-evaluation vs. Regex</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>July 30, 2016 at 10:00:00pm</p></header><div class="content"><p>In the past, there has been some interest in refining the behavior of<br>ExpressibleByStringInterpolation (née StringInterpolationConvertible), for<br>example:<br></p><p>- Ability to *restrict the types that can be used* as interpolation segments<br>- Ability to *distinguish the string-literal segments* from interpolation<br>segments whose type is String<br></p><p>Some prior discussions:<br>- &quot;StringInterpolationConvertible and StringLiteralConvertible inheritance&quot;<br>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160516/017654.html<br>- Sub-discussion in &quot;Allow multiple conformances to the same protocol&quot;<br>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160606/020746.html<br>- &quot;StringInterpolationConvertible: can&#39;t distinguish between literal<br>components and String arguments&quot;  https://bugs.swift.org/browse/SR-1260<br>/ rdar://problem/19800456&amp;18681780<br>- &quot;Proposal: Deprecate optionals in string interpolation&quot;<br>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160516/018000.html<br></p><p><br>About Swift 4, Chris wrote:<br></p><p>&gt;  - *String re-evaluation:* String is one of the most important<br>&gt; fundamental types in the language.  The standard library leads have<br>&gt; numerous ideas of how to improve the programming model for it, without<br>&gt; jeopardizing the goals of providing a unicode-correct-by-default model.<br>&gt; Our goal is to be better at string processing than Perl!<br></p><p><br>I&#39;d be interested in any more detail the team can provide on this. I&#39;d like<br>to talk about string interpolation improvements, but it wouldn&#39;t be wise to<br>do so without keeping an eye towards possible regex/pattern-binding syntax,<br>and the String refinements that the stdlib team has in mind, if there&#39;s a<br>chance they would affect interpolation.<br></p><p>Discuss!<br></p><p>-Jacob<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160730/4f302947/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>ExpressibleByStringInterpolation vs. String re-evaluation vs. Regex</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>August  2, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jul 30, 2016, at 10:35 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; In the past, there has been some interest in refining the behavior of ExpressibleByStringInterpolation (née StringInterpolationConvertible), for example:<br>&gt; <br>&gt; - Ability to restrict the types that can be used as interpolation segments<br>&gt; - Ability to distinguish the string-literal segments from interpolation segments whose type is String<br>&gt; <br>&gt; Some prior discussions: <br>&gt; - &quot;StringInterpolationConvertible and	StringLiteralConvertible inheritance&quot; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160516/017654.html<br>&gt; - Sub-discussion in &quot;Allow multiple conformances to the same protocol&quot; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160606/020746.html<br>&gt; - &quot;StringInterpolationConvertible: can&#39;t distinguish between literal components and String arguments&quot;  https://bugs.swift.org/browse/SR-1260 / rdar://problem/19800456&amp;18681780<br>&gt; - &quot;Proposal: Deprecate optionals in string interpolation&quot; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160516/018000.html<br>&gt; <br>&gt; <br>&gt; About Swift 4, Chris wrote:<br>&gt;  - String re-evaluation: String is one of the most important fundamental types in the language.  The standard library leads have numerous ideas of how to improve the programming model for it, without jeopardizing the goals of providing a unicode-correct-by-default model.  Our goal is to be better at string processing than Perl!<br>&gt; <br>&gt; I&#39;d be interested in any more detail the team can provide on this. I&#39;d like to talk about string interpolation improvements, but it wouldn&#39;t be wise to do so without keeping an eye towards possible regex/pattern-binding syntax, and the String refinements that the stdlib team has in mind, if there&#39;s a chance they would affect interpolation.<br>&gt; <br>&gt; Discuss!<br></p><p>I&#39;m not one of the core team, so all I can really provide is a use case.<br></p><p>Given a LocalizedString type like:<br></p><p>    /// Conforming types can be included in a LocalizedString.<br>    protocol LocalizedStringConvertible {<br>        /// The format to use for this instance. This format string will be included in the key when<br>	/// this type is interpolated into a LocalizedString.<br>        var localizedStringFormat: String { get }<br>    <br>        /// The arguments to use when formatting to represent this instance.<br>        var localizedStringArguments: [CVarArg] { get }<br>    }<br></p><p>    extension NSString: LocalizedStringConvertible {…}<br>    extension String: LocalizedStringConvertible {…}<br>    extension LocalizedString: LocalizedStringConvertible {…}<br>    <br>    extension Int: LocalizedStringConvertible {…}<br>    // etc.<br></p><p>    struct LocalizedString {<br>        /// Initializes a LocalizedString by applying the `arguments` to the format string with the <br>        /// indicated `key` using `String.init(format:arguments:)`.<br>        /// <br>        /// If the `key` does not exist in the localized string file, the `key` itself will be used as <br>        /// the format string.<br>        init(key: String, formattedWith arguments: [CVarArg]) {…}<br>    }<br>    <br>    extension String {<br>        init(_ localizedString: LocalizedString) {<br>            self.init(describing: localizedString)<br>        }<br>    }<br></p><p>    extension LocalizedString {<br>        /// Initializes a LocalizedString with no arguments which uses the indicated `key`. `%` <br>        /// characters in the `key` will be converted to `%%`.<br>        /// <br>        /// If the `key` does not exist in the localized string file, the `key` itself will be used as <br>        /// the string.<br>        init(key: String) {…}<br>    <br>        /// Initializes a LocalizedString to represent the indicated `value`.<br>        init(_ value: LocalizedStringConvertible) {…}<br>    <br>        /// Initializes a LocalizedString to represent the empty string.<br>        init() {…}<br>    }<br></p><p>    extension LocalizedString: CustomStringConvertible {…}<br>    <br>    extension LocalizedString: ExpressibleByStringLiteral {<br>        init(stringLiteral value: String) {<br>            self.init(key: value)<br>        }<br>        …<br>    }<br></p><p>The current ExpressibleByStringInterpolation protocol has a number of defects.<br></p><p>	1. We want to only permit LocalizedStringConvertible types, or at least *use* the LocalizedStringConvertible conformance; neither of these appears to be possible. (`is` and `as?` casts always fail, overloads don&#39;t seem to be called, etc.)<br></p><p>	2. The literal parts of the string are interpreted using `String`&#39;s `ExpressibleByStringLiteral` conformance; we really want them to use `LocalizedString`&#39;s instead. <br></p><p>	3. We don&#39;t want the literal parts of the string to pass through `init(stringInterpolationSegment:)`, because we want to treat interpolation and literal segments differnetly.<br></p><p>In other words, we want to be able to write something like this:<br></p><p>	extension LocalizedString: ExpressibleByStringInterpolation {<br>		typealias StringInterpolatableType = LocalizedStringConvertible<br>		<br>		init(stringInterpolation segments: LocalizedString) {<br>			self.init()<br>			for segment in segments {<br>				formatKey += segment.formatKey<br>				arguments += segment.arguments<br>			}<br>		}<br>		<br>		init(stringInterpolationSegment expr: LocalizedStringConvertible) {<br>			self.init(expr)<br>		}<br>	}<br></p><p>And change the code generated by the compiler from (given the statement `&quot;foo \(bar) baz&quot; as LocalizedString`) this:<br></p><p>	LocalizedString(stringInterpolation:<br>		LocalizedString(stringInterpolationSegment: String(stringLiteral: &quot;foo &quot;)),<br>		LocalizedString(stringInterpolationSegment: bar),<br>		LocalizedString(stringInterpolationSegment: String(stringLiteral: &quot; baz&quot;))<br>	)<br></p><p>To this:<br></p><p>	LocalizedString(stringInterpolation:<br>		LocalizedString(stringLiteral: &quot;foo &quot;),<br>		LocalizedString(stringInterpolationSegment: bar),<br>		LocalizedString(stringLiteral: &quot; baz&quot;)<br>	)<br></p><p>This would obviously require a few changes to the ExpressibleAsStringInterpolation protocol:<br></p><p>	// You cannot accept interpolations unless you can also be a plain literal.<br>	// Necessary for literal segments.<br>	protocol ExpressibleByStringInterpolation: ExpressibleByStringLiteral {<br>		// An associated type for the type of a permitted interpolation<br>		associatedtype StringInterpolatableType = Any<br>		<br>		// No changes here<br>		init(stringInterpolation segments: Self...)<br>		<br>		// No longer generic; instead uses StringInterpolatableType existentials.<br>		// Also a semantic change: this is only called for the actual interpolations.<br>		// init(stringLiteral:) is called for literal segments.<br>		init(stringInterpolationSegment expr: StringInterpolatableType)<br>		<br>		// Given the change in roles, we might want to consider renaming the initializers:<br>		// <br>		// init(stringInterpolation:) =&gt; init(combinedStringLiteral:) or init(stringInterpolationSegments:)<br>		// init(stringInterpolationSegment:) =&gt; init(stringInterpolation:)<br>	}<br></p><p>Or perhaps we would hoist the combining initializer up into ExpressibleAsStringLiteral, and generate an `init(combinedStringLiteral:)` call every time string literals are used.<br></p><p>	protocol ExpressibleByStringLiteral {<br>		associatedtype StringLiteralType: _ExpressibleByBuiltinStringLiteral = String<br>		<br>		init(stringLiteralSegments segments: Self...)<br>		init(stringLiteral value: StringLiteralType)<br>	}<br></p><p>	protocol ExpressibleByStringInterpolation: ExpressibleByStringLiteral {<br>		associatedtype StringInterpolatableType = Any<br>		<br>		init(stringInterpolation expr: StringInterpolatableType)<br>	}<br></p><p>	// &quot;foo&quot; as LocalizedString<br>	LocalizedString(stringLiteralSegments:<br>		LocalizedString(stringLiteral: &quot;foo&quot;)<br>	)<br>	<br>	// &quot;foo \(bar) baz&quot; as LocalizedString<br>	LocalizedString(stringInterpolation:<br>		LocalizedString(stringLiteral: &quot;foo &quot;),<br>		LocalizedString(stringInterpolation: bar),<br>		LocalizedString(stringLiteral: &quot; baz&quot;)<br>	)<br></p><p>Now, it&#39;s quite possible--perhaps even likely--that there are really good reasons for the current design. But I&#39;ve been thinking about this for two years and I don&#39;t know what they are yet; nor can I find much relevant design documentation. I, too, would love to find out why the current design was selected.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>ExpressibleByStringInterpolation vs. String re-evaluation vs. Regex</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>August  3, 2016 at 08:00:00pm</p></header><div class="content"><p>Here&#39;s another example use case: Auto Layout visual format strings.<br></p><p>https://gist.github.com/jtbandes/9c1c25ee4996d2554375#file-constraintcollection-swift-L85-L87<br></p><p>Since only views and numeric types are supported, the generic init&lt;T&gt; has<br>to be a run-time error. Ideally it could be a compile-time error.<br></p><p>On Tue, Aug 2, 2016 at 6:10 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>wrote:<br></p><p>&gt; &gt; On Jul 30, 2016, at 10:35 PM, Jacob Bandes-Storch via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; In the past, there has been some interest in refining the behavior of<br>&gt; ExpressibleByStringInterpolation (née StringInterpolationConvertible), for<br>&gt; example:<br>&gt; &gt;<br>&gt; &gt; - Ability to restrict the types that can be used as interpolation<br>&gt; segments<br>&gt; &gt; - Ability to distinguish the string-literal segments from interpolation<br>&gt; segments whose type is String<br>&gt; &gt;<br>&gt; &gt; Some prior discussions:<br>&gt; &gt; - &quot;StringInterpolationConvertible and StringLiteralConvertible<br>&gt; inheritance&quot;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160516/017654.html<br>&gt; &gt; - Sub-discussion in &quot;Allow multiple conformances to the same protocol&quot;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160606/020746.html<br>&gt; &gt; - &quot;StringInterpolationConvertible: can&#39;t distinguish between literal<br>&gt; components and String arguments&quot;  https://bugs.swift.org/browse/SR-1260 /<br>&gt; rdar://problem/19800456&amp;18681780<br>&gt; &gt; - &quot;Proposal: Deprecate optionals in string interpolation&quot;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160516/018000.html<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; About Swift 4, Chris wrote:<br>&gt; &gt;  - String re-evaluation: String is one of the most important fundamental<br>&gt; types in the language.  The standard library leads have numerous ideas of<br>&gt; how to improve the programming model for it, without jeopardizing the goals<br>&gt; of providing a unicode-correct-by-default model.  Our goal is to be better<br>&gt; at string processing than Perl!<br>&gt; &gt;<br>&gt; &gt; I&#39;d be interested in any more detail the team can provide on this. I&#39;d<br>&gt; like to talk about string interpolation improvements, but it wouldn&#39;t be<br>&gt; wise to do so without keeping an eye towards possible regex/pattern-binding<br>&gt; syntax, and the String refinements that the stdlib team has in mind, if<br>&gt; there&#39;s a chance they would affect interpolation.<br>&gt; &gt;<br>&gt; &gt; Discuss!<br>&gt;<br>&gt; I&#39;m not one of the core team, so all I can really provide is a use case.<br>&gt;<br>&gt; Given a LocalizedString type like:<br>&gt;<br>&gt;     /// Conforming types can be included in a LocalizedString.<br>&gt;     protocol LocalizedStringConvertible {<br>&gt;         /// The format to use for this instance. This format string will<br>&gt; be included in the key when<br>&gt;         /// this type is interpolated into a LocalizedString.<br>&gt;         var localizedStringFormat: String { get }<br>&gt;<br>&gt;         /// The arguments to use when formatting to represent this<br>&gt; instance.<br>&gt;         var localizedStringArguments: [CVarArg] { get }<br>&gt;     }<br>&gt;<br>&gt;     extension NSString: LocalizedStringConvertible {…}<br>&gt;     extension String: LocalizedStringConvertible {…}<br>&gt;     extension LocalizedString: LocalizedStringConvertible {…}<br>&gt;<br>&gt;     extension Int: LocalizedStringConvertible {…}<br>&gt;     // etc.<br>&gt;<br>&gt;     struct LocalizedString {<br>&gt;         /// Initializes a LocalizedString by applying the `arguments` to<br>&gt; the format string with the<br>&gt;         /// indicated `key` using `String.init(format:arguments:)`.<br>&gt;         ///<br>&gt;         /// If the `key` does not exist in the localized string file, the<br>&gt; `key` itself will be used as<br>&gt;         /// the format string.<br>&gt;         init(key: String, formattedWith arguments: [CVarArg]) {…}<br>&gt;     }<br>&gt;<br>&gt;     extension String {<br>&gt;         init(_ localizedString: LocalizedString) {<br>&gt;             self.init(describing: localizedString)<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt;     extension LocalizedString {<br>&gt;         /// Initializes a LocalizedString with no arguments which uses the<br>&gt; indicated `key`. `%`<br>&gt;         /// characters in the `key` will be converted to `%%`.<br>&gt;         ///<br>&gt;         /// If the `key` does not exist in the localized string file, the<br>&gt; `key` itself will be used as<br>&gt;         /// the string.<br>&gt;         init(key: String) {…}<br>&gt;<br>&gt;         /// Initializes a LocalizedString to represent the indicated<br>&gt; `value`.<br>&gt;         init(_ value: LocalizedStringConvertible) {…}<br>&gt;<br>&gt;         /// Initializes a LocalizedString to represent the empty string.<br>&gt;         init() {…}<br>&gt;     }<br>&gt;<br>&gt;     extension LocalizedString: CustomStringConvertible {…}<br>&gt;<br>&gt;     extension LocalizedString: ExpressibleByStringLiteral {<br>&gt;         init(stringLiteral value: String) {<br>&gt;             self.init(key: value)<br>&gt;         }<br>&gt;         …<br>&gt;     }<br>&gt;<br>&gt; The current ExpressibleByStringInterpolation protocol has a number of<br>&gt; defects.<br>&gt;<br>&gt;         1. We want to only permit LocalizedStringConvertible types, or at<br>&gt; least *use* the LocalizedStringConvertible conformance; neither of these<br>&gt; appears to be possible. (`is` and `as?` casts always fail, overloads don&#39;t<br>&gt; seem to be called, etc.)<br>&gt;<br>&gt;         2. The literal parts of the string are interpreted using<br>&gt; `String`&#39;s `ExpressibleByStringLiteral` conformance; we really want them to<br>&gt; use `LocalizedString`&#39;s instead.<br>&gt;<br>&gt;         3. We don&#39;t want the literal parts of the string to pass through<br>&gt; `init(stringInterpolationSegment:)`, because we want to treat interpolation<br>&gt; and literal segments differnetly.<br>&gt;<br></p><p>Yep, this is what I filed https://bugs.swift.org/browse/SR-1260 for.<br></p><p><br>&gt;<br>&gt; In other words, we want to be able to write something like this:<br>&gt;<br>&gt;         extension LocalizedString: ExpressibleByStringInterpolation {<br>&gt;                 typealias StringInterpolatableType =<br>&gt; LocalizedStringConvertible<br>&gt;<br>&gt;                 init(stringInterpolation segments: LocalizedString) {<br>&gt;                         self.init()<br>&gt;                         for segment in segments {<br>&gt;                                 formatKey += segment.formatKey<br>&gt;                                 arguments += segment.arguments<br>&gt;                         }<br>&gt;                 }<br>&gt;<br>&gt;                 init(stringInterpolationSegment expr:<br>&gt; LocalizedStringConvertible) {<br>&gt;                         self.init(expr)<br>&gt;                 }<br>&gt;         }<br>&gt;<br>&gt; And change the code generated by the compiler from (given the statement<br>&gt; `&quot;foo \(bar) baz&quot; as LocalizedString`) this:<br>&gt;<br>&gt;         LocalizedString(stringInterpolation:<br>&gt;                 LocalizedString(stringInterpolationSegment:<br>&gt; String(stringLiteral: &quot;foo &quot;)),<br>&gt;                 LocalizedString(stringInterpolationSegment: bar),<br>&gt;                 LocalizedString(stringInterpolationSegment:<br>&gt; String(stringLiteral: &quot; baz&quot;))<br>&gt;         )<br>&gt;<br>&gt; To this:<br>&gt;<br>&gt;         LocalizedString(stringInterpolation:<br>&gt;                 LocalizedString(stringLiteral: &quot;foo &quot;),<br>&gt;                 LocalizedString(stringInterpolationSegment: bar),<br>&gt;                 LocalizedString(stringLiteral: &quot; baz&quot;)<br>&gt;         )<br>&gt;<br>&gt; This would obviously require a few changes to the<br>&gt; ExpressibleAsStringInterpolation protocol:<br>&gt;<br>&gt;         // You cannot accept interpolations unless you can also be a plain<br>&gt; literal.<br>&gt;         // Necessary for literal segments.<br>&gt;         protocol ExpressibleByStringInterpolation:<br>&gt; ExpressibleByStringLiteral {<br>&gt;                 // An associated type for the type of a permitted<br>&gt; interpolation<br>&gt;                 associatedtype StringInterpolatableType = Any<br>&gt;<br>&gt;                 // No changes here<br>&gt;                 init(stringInterpolation segments: Self...)<br>&gt;<br>&gt;                 // No longer generic; instead uses<br>&gt; StringInterpolatableType existentials.<br>&gt;                 // Also a semantic change: this is only called for the<br>&gt; actual interpolations.<br>&gt;                 // init(stringLiteral:) is called for literal segments.<br>&gt;                 init(stringInterpolationSegment expr:<br>&gt; StringInterpolatableType)<br>&gt;<br>&gt;                 // Given the change in roles, we might want to consider<br>&gt; renaming the initializers:<br>&gt;                 //<br>&gt;                 // init(stringInterpolation:) =&gt;<br>&gt; init(combinedStringLiteral:) or init(stringInterpolationSegments:)<br>&gt;                 // init(stringInterpolationSegment:) =&gt;<br>&gt; init(stringInterpolation:)<br>&gt;         }<br>&gt;<br>&gt; Or perhaps we would hoist the combining initializer up into<br>&gt; ExpressibleAsStringLiteral, and generate an `init(combinedStringLiteral:)`<br>&gt; call every time string literals are used.<br>&gt;<br>&gt;         protocol ExpressibleByStringLiteral {<br>&gt;                 associatedtype StringLiteralType:<br>&gt; _ExpressibleByBuiltinStringLiteral = String<br>&gt;<br>&gt;                 init(stringLiteralSegments segments: Self...)<br>&gt;                 init(stringLiteral value: StringLiteralType)<br>&gt;         }<br>&gt;<br>&gt;         protocol ExpressibleByStringInterpolation:<br>&gt; ExpressibleByStringLiteral {<br>&gt;                 associatedtype StringInterpolatableType = Any<br>&gt;<br>&gt;                 init(stringInterpolation expr: StringInterpolatableType)<br>&gt;         }<br>&gt;<br>&gt;         // &quot;foo&quot; as LocalizedString<br>&gt;         LocalizedString(stringLiteralSegments:<br>&gt;                 LocalizedString(stringLiteral: &quot;foo&quot;)<br>&gt;         )<br>&gt;<br>&gt;         // &quot;foo \(bar) baz&quot; as LocalizedString<br>&gt;         LocalizedString(stringInterpolation:<br>&gt;                 LocalizedString(stringLiteral: &quot;foo &quot;),<br>&gt;                 LocalizedString(stringInterpolation: bar),<br>&gt;                 LocalizedString(stringLiteral: &quot; baz&quot;)<br>&gt;         )<br>&gt;<br>&gt; Now, it&#39;s quite possible--perhaps even likely--that there are really good<br>&gt; reasons for the current design. But I&#39;ve been thinking about this for two<br>&gt; years and I don&#39;t know what they are yet; nor can I find much relevant<br>&gt; design documentation. I, too, would love to find out why the current design<br>&gt; was selected.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160803/2fe56ec8/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
