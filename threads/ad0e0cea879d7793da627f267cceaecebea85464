<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/458cc4059a92afaf1bfec9ddb54c450c?s=50"></div><header><strong>[Proposal] Add Binary Search functions to SequenceType</strong> from <string>Lorenzo Racca</string> &lt;lorenzo.racca at live.it&gt;<p>March 15, 2016 at 03:00:00pm</p></header><div class="content"><p>Hi all, <br></p><p>Using the library for an app with wide sorted arrays I’ve found out that Swift doesn’t (yet) have binary search functions.<br>Standing on the fact that C++, Java and .NET all have Binary Search functions in their standard libs, and given the notorious difficulty to create the algorithm (hence the need of developers to trust the library function) I’m proposing to adopt these. <br>I worked out some code, recalling the C++ functions binary_search, lower_bound and upper_bound. <br>I’ve tested them and they seem all right. <br></p><p>Also, they all return the `Index` of a found element (say, in an Array), so that they can be implemented to return either a boolean value, or the element itself. They either return nil or -1 if not any or if the predicate isn’t matched, but they all could surely be arranged to return nil.<br>The code for binarySearch is : <br></p><p>extension CollectionType where Generator.Element : Comparable {<br>    /// Returns `element.Index` if `element` is in `self`.<br>    /// If `element` is not in `self`, returns nil.<br>    @warn_unused_result<br>    public func binarySearch(element: Generator.Element) -&gt; Index? {<br>        <br>        var left = startIndex<br>        var right = endIndex<br>        <br>        while (left != right) {<br>            let mid = left.advancedBy(left.distanceTo(right) / 2)<br>            let value = self[mid]<br>            <br>            if (value == element) {<br>                return mid<br>            }<br>            if (value &lt; element) {<br>                left = mid.advancedBy(1)<br>            }<br>            if (value &gt; element) {<br>                right = mid<br>            }<br>        }<br>        return nil<br>    }<br>}<br></p><p>lowerBound and upperBound:<br></p><p>extension CollectionType where Generator.Element : Comparable {<br>    /// Returns the Index of the smallest element in collection matching `predicate`.<br>    /// If none, returns -1.<br>    @warn_unused_result<br>    func lowerBound(predicate: Generator.Element -&gt; Bool) -&gt; Index {<br>        var result = self.startIndex.advancedBy(-1)<br>        var low = self.startIndex<br>        var hi = self.endIndex<br>        <br>        while low != hi {<br>            let mid = low.advancedBy(low.distanceTo(hi) / 2)<br>            <br>            if predicate(self[mid]) {<br>                result = mid<br>                hi = mid<br>            } else {<br>                low = mid.advancedBy(1)<br>            }<br>        }<br>        return result<br>    }<br>}<br></p><p>extension CollectionType where Generator.Element : Comparable {<br>    /// Returns the Index of the biggest element in collection matching `predicate`.<br>    /// If none, returns -1.<br>    func upperBound(predicate: Generator.Element -&gt; Bool) -&gt; Index {<br>        var result = startIndex.advancedBy(-1)<br>        var low = startIndex<br>        var hi = endIndex<br>        <br>        while low != hi {<br>            let mid = low.advancedBy(low.distanceTo(hi) / 2)<br>            <br>            if predicate(self[mid]) {<br>                result = mid<br>                low = mid.advancedBy(1)<br>            } else {<br>                hi = mid<br>            }<br>        }<br>        return result<br>    }<br>}<br></p><p>If you wish to try them, usage is :<br>var array : Array = [1,2,3,4,5]<br></p><p>let a = array.upperBound{$0 &lt; 3} //array[a] = 2<br>let b = array.lowerBound{$0 &gt; 3} //array[b] = 4<br></p><p>What do you think? Should I commit a new file to proposals?<br>Should they be added to CollectionType or SequenceType?<br>It’s obviously open to discussion and change.<br></p><p>Thank you. <br></p><p>Best, <br></p><p>Lorenzo Racca<br>+39 345 9294756<br>lorenzo.racca at live.it<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160315/ad0e5464/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Proposal] Add Binary Search functions to SequenceType</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>March 15, 2016 at 03:00:00pm</p></header><div class="content"><p>I’m not sure the documentation matches the .lowerBound() and .upperBound() behaviours accurately enough; it suggests that a bound will be found for a predicate “match”, however if my predicate is { $0 == foo } then these won’t actually work at all unless I get lucky and the middle element is a match, to me this means that they will only work with comparison predicates such as { $0 &gt; foo }, but in that case the lower bound is for the first element that is not greater than foo, but I wouldn’t call it a “match” until I can also test it for equality.<br></p><p><br>I’ve been doing some work recently on a sorted collection and I implemented a binary search a bit differently. My method returns the nearest index given an isOrderedBefore predicate, returning .endIndex if nothing matches. Implementation below:<br></p><p>	@warn_unused_result<br>	public func binarySearch(withinRange theRange:Range&lt;Index&gt;?=nil, isOrderedBefore:(Generator.Element) -&gt; Bool) -&gt; Index {<br>		var low:Index, high:Index<br>		if let theSpecifiedRange = theRange { low = theSpecifiedRange.startIndex; high = theSpecifiedRange.endIndex }<br>		else { low = self.startIndex; high = self.endIndex }<br>		<br>		while low != high {<br>			let mid = low.advancedBy(low.distanceTo(high) / 2)<br>			if isOrderedBefore(self[mid]) { low = mid.successor() }<br>			else { high = mid }<br>		}<br>		return low<br>	}<br></p><p>What this gives me is really an insertion index, however I can implement searching for a specific element like so:<br></p><p>    let isOrderedBefore:(Generator.Element, Generator.Element) -&gt; Bool<br>    func indexOf(theElement:Equatable) -&gt; Index? {<br>        let theNearestIndex = self.binarySearch(){ self.isOrderedBefore($0, theElement) }<br>        if theNearestIndex &lt; self.endIndex &amp;&amp; self[theNearestIndex] == theElement { return theNearestIndex }<br>        return nil<br>    }<br></p><p>I can also do things like a generic insert() method like so:<br></p><p>    func insert(theElement:Comparable) { self.insert(theElement, atIndex: self.binarySearch(){ self.isOrderedBefore($0, theElement) }) }<br></p><p>(note I’ve simplified these as examples as they won’t go into CollectionType as-is, it’s just to give you the idea).<br></p><p>Anyway, it seems to me that this enables simple matching of both an exact element and the lower bound (this is what the .indexOf() above should return), while also giving a useful value if the element isn’t found, though it does require testing the result to be sure. When it comes to matching a specific element, the above actually eliminates tests for equality during the search, only having to test once at the end to confirm the result is a match.<br></p><p>I also added a variable starting range, as I had to handle merging two sorted collections, in which case it’s useful to restrict the search range as you go since there’s no point revisiting indices that you’ve passed already if the elements are sorted properly.<br></p><p>The above can also perform an upper bound search by passing in a predicate such as { $0 &lt;= foo }, though in that case you’re performing all the extra comparisons plus a check at the end, so there might still be an argument for two methods, e.g nearestLowerBound() and nearestUpperBound().<br></p><p><br>Lastly, in my case I’ve defined the above method on CollectionType directly, rather than requiring Comparable; since it takes a predicate its only requirement is the collection is sorted prior to search it. In fact, constraining the method to Comparable doesn’t guarantee that the collection is sorted, only that its elements can be compared in isolation.<br></p><p>&gt; On 15 Mar 2016, at 14:28, Lorenzo Racca via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi all, <br>&gt; <br>&gt; Using the library for an app with wide sorted arrays I’ve found out that Swift doesn’t (yet) have binary search functions.<br>&gt; Standing on the fact that C++, Java and .NET all have Binary Search functions in their standard libs, and given the notorious difficulty to create the algorithm (hence the need of developers to trust the library function) I’m proposing to adopt these. <br>&gt; I worked out some code, recalling the C++ functions binary_search, lower_bound and upper_bound. <br>&gt; I’ve tested them and they seem all right. <br>&gt; <br>&gt; Also, they all return the `Index` of a found element (say, in an Array), so that they can be implemented to return either a boolean value, or the element itself. They either return nil or -1 if not any or if the predicate isn’t matched, but they all could surely be arranged to return nil.<br>&gt; The code for binarySearch is : <br>&gt; <br>&gt; extension CollectionType where Generator.Element : Comparable {<br>&gt;     /// Returns `element.Index` if `element` is in `self`.<br>&gt;     /// If `element` is not in `self`, returns nil.<br>&gt;     @warn_unused_result<br>&gt;     public func binarySearch(element: Generator.Element) -&gt; Index? {<br>&gt;         <br>&gt;         var left = startIndex<br>&gt;         var right = endIndex<br>&gt;         <br>&gt;         while (left != right) {<br>&gt;             let mid = left.advancedBy(left.distanceTo(right) / 2)<br>&gt;             let value = self[mid]<br>&gt;             <br>&gt;             if (value == element) {<br>&gt;                 return mid<br>&gt;             }<br>&gt;             if (value &lt; element) {<br>&gt;                 left = mid.advancedBy(1)<br>&gt;             }<br>&gt;             if (value &gt; element) {<br>&gt;                 right = mid<br>&gt;             }<br>&gt;         }<br>&gt;         return nil<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; lowerBound and upperBound:<br>&gt; <br>&gt; extension CollectionType where Generator.Element : Comparable {<br>&gt;     /// Returns the Index of the smallest element in collection matching `predicate`.<br>&gt;     /// If none, returns -1.<br>&gt;     @warn_unused_result<br>&gt;     func lowerBound(predicate: Generator.Element -&gt; Bool) -&gt; Index {<br>&gt;         var result = self.startIndex.advancedBy(-1)<br>&gt;         var low = self.startIndex<br>&gt;         var hi = self.endIndex<br>&gt;         <br>&gt;         while low != hi {<br>&gt;             let mid = low.advancedBy(low.distanceTo(hi) / 2)<br>&gt;             <br>&gt;             if predicate(self[mid]) {<br>&gt;                 result = mid<br>&gt;                 hi = mid<br>&gt;             } else {<br>&gt;                 low = mid.advancedBy(1)<br>&gt;             }<br>&gt;         }<br>&gt;         return result<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; extension CollectionType where Generator.Element : Comparable {<br>&gt;     /// Returns the Index of the biggest element in collection matching `predicate`.<br>&gt;     /// If none, returns -1.<br>&gt;     func upperBound(predicate: Generator.Element -&gt; Bool) -&gt; Index {<br>&gt;         var result = startIndex.advancedBy(-1)<br>&gt;         var low = startIndex<br>&gt;         var hi = endIndex<br>&gt;         <br>&gt;         while low != hi {<br>&gt;             let mid = low.advancedBy(low.distanceTo(hi) / 2)<br>&gt;             <br>&gt;             if predicate(self[mid]) {<br>&gt;                 result = mid<br>&gt;                 low = mid.advancedBy(1)<br>&gt;             } else {<br>&gt;                 hi = mid<br>&gt;             }<br>&gt;         }<br>&gt;         return result<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; If you wish to try them, usage is :<br>&gt; var array : Array = [1,2,3,4,5]<br>&gt; <br>&gt; let a = array.upperBound{$0 &lt; 3} //array[a] = 2<br>&gt; let b = array.lowerBound{$0 &gt; 3} //array[b] = 4<br>&gt; <br>&gt; What do you think? Should I commit a new file to proposals?<br>&gt; Should they be added to CollectionType or SequenceType?<br>&gt; It’s obviously open to discussion and change.<br>&gt; <br>&gt; Thank you. <br>&gt; <br>&gt; Best, <br>&gt; <br>&gt; Lorenzo Racca<br>&gt; +39 345 9294756<br>&gt; lorenzo.racca at live.it &lt;mailto:lorenzo.racca at live.it&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160315/dff74053/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/458cc4059a92afaf1bfec9ddb54c450c?s=50"></div><header><strong>[Proposal] Add Binary Search functions to SequenceType</strong> from <string>Lorenzo Racca</string> &lt;lorenzo.racca at live.it&gt;<p>March 15, 2016 at 04:00:00pm</p></header><div class="content"><p>Thank you Haraviik,<br></p><p>I already knew the impossibility of applying such a predicate as “$0 == 3” and I actually couldn’t quite figure out a solution. Honestly, I’m quite new to Swift :)<br></p><p>Actually at first I thought that no one would use it, as the same result could be achieved using the main binarySearch function. <br>If the elements to be matched have to be equal it makes no difference whether we retrieve the smallest or greatest, unless the array had multiple entries with same value. <br>In that case, you are right, my functions do not work properly, but your code seems to be working fine in these situations! <br>Would you want to cooperate for the proposal? <br></p><p>Lorenzo Racca<br>+39 345 9294756<br>lorenzo.racca at live.it<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/30e4ca9ef73f6a84d52c26952c180bcd?s=50"></div><header><strong>[Proposal] Add Binary Search functions to SequenceType</strong> from <string>Jeff Hajewski</string> &lt;jeff.hajewski at gmail.com&gt;<p>March 15, 2016 at 01:00:00pm</p></header><div class="content"><p>This is something I&#39;ve been working on as well. The issue I&#39;ve been stuck<br>on is how we define the predicate and match the definitions of lower_bound<br>and upper_bound from C++. It seems to me that the focus should be on these<br>implementations, since once we have these a simple binary_search follows.<br>Specifically, the issue I&#39;m encountering at the moment is handling<br>`!predicate`. If `predicate` is sorting on a rule like $0 &lt; 3, for example,<br>then the complement is $0 &gt;= 3, which has the effect of creating an upper<br>bound inclusive of 3. To be consistent with the C++ implementation, the<br>upper bound should be strictly greater than 3. In C++ they are able to get<br>around this issue by swapping the indices within the `comp` function (our<br>`predicate`) to eliminate the equality case (e.g.,  looking at `comp(i,j)`<br>and `comp(j,i)`). I don&#39;t see a way to easily do this in our case if we<br>want keep `predicate` of the form `Generator.Element -&gt; Bool`.<br></p><p>The following implementations are as far as I&#39;ve gotten so far.<br></p><p>extension CollectionType {<br></p><p>    /// Returns an index such that each element at or above the index is<br>partitioned from below by the partition predicate<br></p><p>  ///<br></p><p>  /// - Parameter partitionPredicate: The partioning predicate returns<br>`true` for elements in the collection that are<br></p><p>  ///                                 ordered below, with respet to the<br>partitioning predicate.<br></p><p>    /// - Complexity: O(lg(n))<br></p><p>    ///<br></p><p>  /// - Returns: An index such that each element at or above the returned<br>index evaluates as `false` with respect to `partitionPredicate(_:)`<br></p><p>  @warn_unused_result<br></p><p>    func lowerBound(@noescape partitionPredicate: Self.Generator.Element -&gt;<br>Bool) -&gt; Index {<br></p><p>        var len = self.startIndex.distanceTo(self.endIndex)<br></p><p>        var firstIndex = self.startIndex<br></p><p>        while len &gt; 0 {<br></p><p>            let half = len/2<br></p><p>            let middle = firstIndex.advancedBy(half)<br></p><p>            if partitionPredicate(self[middle]) {<br></p><p>                firstIndex = middle.advancedBy(1)<br></p><p>                len -= half + 1<br></p><p>            } else {<br></p><p>                len = half<br></p><p>            }<br></p><p>        }<br></p><p>        return firstIndex<br></p><p>  }<br></p><p>  /// Returns an index such that each element below the index is strictly<br>less than the partition predicate<br></p><p>  ///<br></p><p>    /// - Parameter partitionPredicate: The partioning predicate. Returns<br>`true` for elements in the collection that are<br></p><p>    ///                             ordered below, with respet to the<br>partitioning predicate.<br></p><p>  /// - Complexity: O(lg(n))<br></p><p>    ///<br></p><p>  /// - Returns: An index such that each element evaluates as `false` with<br>respect to `partitionPredicate(_:)`<br></p><p>  @warn_unused_result<br></p><p>  func upperBound(@noescape partitionPredicate:Self.Generator.Element -&gt;<br>Bool) -&gt; Index {<br></p><p>        var len = self.startIndex.distanceTo(self.endIndex)<br></p><p>        var firstIndex = self.startIndex<br></p><p>        while len &gt; 0 {<br></p><p>            let half = len/2<br></p><p>            let middle = firstIndex.advancedBy(half)<br></p><p>            if !partitionPredicate(self[middle]) {<br></p><p>                len = half<br></p><p>            } else {<br></p><p>                firstIndex = middle.advancedBy(1)<br></p><p>                len -= half + 1<br></p><p>            }<br></p><p>        }<br></p><p>        return firstIndex<br></p><p>  }<br></p><p><br></p><p>    /// Returns `true` if element is in Collection, `false` otherwise<br></p><p>    @warn_unused_result<br></p><p>    func binarySearch(@noescape partitionPredicate:Self.Generator.Element<br>-&gt; Bool) -&gt; Bool {<br></p><p>        let lb = lowerBound(partitionPredicate)<br></p><p>        return (lb != self.endIndex) &amp;&amp; !partitionPredicate(self[lb])<br></p><p>    }<br></p><p><br></p><p>}<br></p><p>Again, `upperBound` isn&#39;t working like it should, mainly because I&#39;m<br>looking at the complement of `predicate`. The only way I see getting around<br>this is making `predicate` take the form `(Generator.Element,<br>Generator.Element) -&gt; Bool`, but this comes at the cost of some added<br>complexity on the user end as you can&#39;t simply pass a closure like `{ $0 &lt;<br>3 }`. I suspect there is an easy solution here and I&#39;m just having a mental<br>block...<br></p><p>Jeff<br></p><p>On Tue, Mar 15, 2016 at 11:37 AM, Haravikk via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I’m not sure the documentation matches the .lowerBound() and .upperBound()<br>&gt; behaviours accurately enough; it suggests that a bound will be found for a<br>&gt; predicate “match”, however if my predicate is { $0 == foo } then these<br>&gt; won’t actually work at all unless I get lucky and the middle element is a<br>&gt; match, to me this means that they will only work with comparison predicates<br>&gt; such as { $0 &gt; foo }, but in that case the lower bound is for the first<br>&gt; element that is not greater than foo, but I wouldn’t call it a “match”<br>&gt; until I can also test it for equality.<br>&gt;<br>&gt;<br>&gt; I’ve been doing some work recently on a sorted collection and I<br>&gt; implemented a binary search a bit differently. My method returns the<br>&gt; nearest index given an isOrderedBefore predicate, returning .endIndex if<br>&gt; nothing matches. Implementation below:<br>&gt;<br>&gt; @warn_unused_result<br>&gt; public func binarySearch(withinRange theRange:Range&lt;Index&gt;?=nil,<br>&gt; isOrderedBefore:(Generator.Element) -&gt; Bool) -&gt; Index {<br>&gt; var low:Index, high:Index<br>&gt; if let theSpecifiedRange = theRange { low = theSpecifiedRange.startIndex;<br>&gt; high = theSpecifiedRange.endIndex }<br>&gt; else { low = self.startIndex; high = self.endIndex }<br>&gt;<br>&gt;<br>&gt; while low != high {<br>&gt; let mid = low.advancedBy(low.distanceTo(high) / 2)<br>&gt; if isOrderedBefore(self[mid]) { low = mid.successor() }<br>&gt; else { high = mid }<br>&gt; }<br>&gt; return low<br>&gt; }<br>&gt;<br>&gt; What this gives me is really an insertion index, however I can implement<br>&gt; searching for a specific element like so:<br>&gt;<br>&gt;     let isOrderedBefore:(Generator.Element, Generator.Element) -&gt; Bool<br>&gt;     func indexOf(theElement:Equatable) -&gt; Index? {<br>&gt;         let theNearestIndex = self.binarySearch(){ self.isOrderedBefore($0,<br>&gt; theElement) }<br>&gt;         if theNearestIndex &lt; self.endIndex &amp;&amp; self[theNearestIndex] ==<br>&gt; theElement { return theNearestIndex }<br>&gt;         return nil<br>&gt;     }<br>&gt;<br>&gt; I can also do things like a generic insert() method like so:<br>&gt;<br>&gt;     func insert(theElement:Comparable) { self.insert(theElement, atIndex:<br>&gt; self.binarySearch(){ self.isOrderedBefore($0, theElement) }) }<br>&gt;<br>&gt; (note I’ve simplified these as examples as they won’t go into<br>&gt; CollectionType as-is, it’s just to give you the idea).<br>&gt;<br>&gt; Anyway, it seems to me that this enables simple matching of both an exact<br>&gt; element and the lower bound (this is what the .indexOf() above should<br>&gt; return), while also giving a useful value if the element isn’t found,<br>&gt; though it does require testing the result to be sure. When it comes to<br>&gt; matching a specific element, the above actually eliminates tests for<br>&gt; equality during the search, only having to test once at the end to confirm<br>&gt; the result is a match.<br>&gt;<br>&gt; I also added a variable starting range, as I had to handle merging two<br>&gt; sorted collections, in which case it’s useful to restrict the search range<br>&gt; as you go since there’s no point revisiting indices that you’ve passed<br>&gt; already if the elements are sorted properly.<br>&gt;<br>&gt; The above can also perform an upper bound search by passing in a predicate<br>&gt; such as { $0 &lt;= foo }, though in that case you’re performing all the extra<br>&gt; comparisons *plus* a check at the end, so there might still be an<br>&gt; argument for two methods, e.g nearestLowerBound() and nearestUpperBound().<br>&gt;<br>&gt;<br>&gt; Lastly, in my case I’ve defined the above method on CollectionType<br>&gt; directly, rather than requiring Comparable; since it takes a predicate its<br>&gt; only requirement is the collection is sorted prior to search it. In fact,<br>&gt; constraining the method to Comparable doesn’t guarantee that the collection<br>&gt; is sorted, only that its elements can be compared in isolation.<br>&gt;<br>&gt; On 15 Mar 2016, at 14:28, Lorenzo Racca via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Hi all,<br>&gt;<br>&gt; Using the library for an app with wide sorted arrays I’ve found out that<br>&gt; Swift doesn’t (yet) have binary search functions.<br>&gt; Standing on the fact that C++, Java and .NET all have Binary Search<br>&gt; functions in their standard libs, and given the notorious difficulty to<br>&gt; create the algorithm (hence the need of developers to trust the library<br>&gt; function) I’m proposing to adopt these.<br>&gt; I worked out some code, recalling the C++ functions binary_search,<br>&gt; lower_bound and upper_bound.<br>&gt; I’ve tested them and they seem all right.<br>&gt;<br>&gt; Also, they all return the `Index` of a found element (say, in an Array),<br>&gt; so that they can be implemented to return either a boolean value, or the<br>&gt; element itself. They either return nil or -1 if not any or if the predicate<br>&gt; isn’t matched, but they all could surely be arranged to return nil.<br>&gt; The code for binarySearch is :<br>&gt;<br>&gt; extension CollectionType where Generator.Element : Comparable {<br>&gt;     /// Returns `element.Index` if `element` is in `self`.<br>&gt;     /// If `element` is not in `self`, returns nil.<br>&gt;     @warn_unused_result<br>&gt;     public func binarySearch(element: Generator.Element) -&gt; Index? {<br>&gt;<br>&gt;         var left = startIndex<br>&gt;         var right = endIndex<br>&gt;<br>&gt;         while (left != right) {<br>&gt;             let mid = left.advancedBy(left.distanceTo(right) / 2)<br>&gt;             let value = self[mid]<br>&gt;<br>&gt;             if (value == element) {<br>&gt;                 return mid<br>&gt;             }<br>&gt;             if (value &lt; element) {<br>&gt;                 left = mid.advancedBy(1)<br>&gt;             }<br>&gt;             if (value &gt; element) {<br>&gt;                 right = mid<br>&gt;             }<br>&gt;         }<br>&gt;         return nil<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; lowerBound and upperBound:<br>&gt;<br>&gt; extension CollectionType where Generator.Element : Comparable {<br>&gt;     /// Returns the Index of the smallest element in collection matching<br>&gt; `predicate`.<br>&gt;     /// If none, returns -1.<br>&gt;     @warn_unused_result<br>&gt;     func lowerBound(predicate: Generator.Element -&gt; Bool) -&gt; Index {<br>&gt;         var result = self.startIndex.advancedBy(-1)<br>&gt;         var low = self.startIndex<br>&gt;         var hi = self.endIndex<br>&gt;<br>&gt;         while low != hi {<br>&gt;             let mid = low.advancedBy(low.distanceTo(hi) / 2)<br>&gt;<br>&gt;             if predicate(self[mid]) {<br>&gt;                 result = mid<br>&gt;                 hi = mid<br>&gt;             } else {<br>&gt;                 low = mid.advancedBy(1)<br>&gt;             }<br>&gt;         }<br>&gt;         return result<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; extension CollectionType where Generator.Element : Comparable {<br>&gt;     /// Returns the Index of the biggest element in collection matching<br>&gt; `predicate`.<br>&gt;     /// If none, returns -1.<br>&gt;     func upperBound(predicate: Generator.Element -&gt; Bool) -&gt; Index {<br>&gt;         var result = startIndex.advancedBy(-1)<br>&gt;         var low = startIndex<br>&gt;         var hi = endIndex<br>&gt;<br>&gt;         while low != hi {<br>&gt;             let mid = low.advancedBy(low.distanceTo(hi) / 2)<br>&gt;<br>&gt;             if predicate(self[mid]) {<br>&gt;                 result = mid<br>&gt;                 low = mid.advancedBy(1)<br>&gt;             } else {<br>&gt;                 hi = mid<br>&gt;             }<br>&gt;         }<br>&gt;         return result<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; If you wish to try them, usage is :<br>&gt; var array : Array = [1,2,3,4,5]<br>&gt;<br>&gt; let a = array.upperBound{$0 &lt; 3} //array[a] = 2<br>&gt; let b = array.lowerBound{$0 &gt; 3} //array[b] = 4<br>&gt;<br>&gt; What do you think? Should I commit a new file to proposals?<br>&gt; Should they be added to CollectionType or SequenceType?<br>&gt; It’s obviously open to discussion and change.<br>&gt;<br>&gt; Thank you.<br>&gt;<br>&gt; Best,<br>&gt;<br>&gt; Lorenzo Racca<br>&gt; +39 345 9294756<br>&gt; lorenzo.racca at live.it<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160315/9fd09460/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Proposal] Add Binary Search functions to SequenceType</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>March 15, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On 15 Mar 2016, at 15:48, Lorenzo Racca &lt;lorenzo.racca at live.it&gt; wrote:<br>&gt; <br>&gt; I already knew the impossibility of applying such a predicate as “$0 == 3” and I actually couldn’t quite figure out a solution.<br></p><p>I thought so, and I don’t think there is a way to do it, my point was really just that your swift doc comments weren’t clear on that point, then I went off at a bit of a tangent ;)<br></p><p>&gt; On 15 Mar 2016, at 17:07, Jeff Hajewski &lt;jeff.hajewski at gmail.com&gt; wrote:<br>&gt; <br>&gt;     /// Returns an index such that each element at or above the index is partitioned from below by the partition predicate<br>&gt;     ///<br>&gt;     /// - Parameter partitionPredicate: The partioning predicate returns `true` for elements in the collection that are<br>&gt;     ///                                 ordered below, with respet to the partitioning predicate.<br>&gt;     /// - Complexity: O(lg(n))<br>&gt;     ///<br>&gt;     /// - Returns: An index such that each element at or above the returned index evaluates as `false` with respect to `partitionPredicate(_:)`<br>&gt;     @warn_unused_result<br>&gt;     func lowerBound(@noescape partitionPredicate: Self.Generator.Element -&gt; Bool) -&gt; Index {<br></p><p>Should probably have &quot;requires: Collection is sorted&quot; or such, as a binary search can’t really guarantee correct behaviour otherwise, no matter what your predicate is. I also kind of prefer a name of isOrderedBefore for the predicate; it matches .sort() and is very specific about what it does.<br></p><p>&gt; 	<br>&gt;     /// Returns an index such that each element below the index is strictly less than the partition predicate<br>&gt;     ///<br>&gt;     /// - Parameter partitionPredicate: The partioning predicate. Returns `true` for elements in the collection that are<br>&gt;     ///                             ordered below, with respet to the partitioning predicate.<br>&gt;     /// - Complexity: O(lg(n))<br>&gt;     ///<br>&gt;     /// - Returns: An index such that each element evaluates as `false` with respect to `partitionPredicate(_:)`<br>&gt;     @warn_unused_result<br>&gt;     func upperBound(@noescape partitionPredicate:Self.Generator.Element -&gt; Bool) -&gt; Index {<br></p><p>Did you mean “each element above the returned index evaluates as false&quot;?<br></p><p><br>Implementation wise they seem fine, but I think that for correctness you should be using .successor() and .advancedBy(), as not all indexes are numeric.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160315/cba8f938/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/458cc4059a92afaf1bfec9ddb54c450c?s=50"></div><header><strong>[Proposal] Add Binary Search functions to SequenceType</strong> from <string>Lorenzo Racca</string> &lt;lorenzo.racca at live.it&gt;<p>March 15, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Mar 15, 2016, at 6:49 PM, Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br>&gt; <br>&gt;&gt; On 15 Mar 2016, at 15:48, Lorenzo Racca &lt;lorenzo.racca at live.it &lt;mailto:lorenzo.racca at live.it&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I already knew the impossibility of applying such a predicate as “$0 == 3” and I actually couldn’t quite figure out a solution.<br>&gt; <br>&gt; I thought so, and I don’t think there is a way to do it, my point was really just that your swift doc comments weren’t clear on that point, then I went off at a bit of a tangent ;)<br>&gt; <br>No problem! What I am trying to figure out here is how we should implement the lowerBound and upperBound functions. Should they exactly reflect their C++ counterparts? <br>Anyway, it seems all of our implementations have the same problem, that they cannot be univocally called with any predicate whatsoever, (or at least it seemed to me during some tests with the implementations :) ), so I don’t really know how we should act. I am a little blocked.<br>Does anyone have ideas on how that could work no matter what predicate is given? Especially, an upperBound() function, which is a little trickier. <br></p><p>&gt;&gt; On Mar 15, 2016, at 6:07 PM, Jeff Hajewski  &lt;jeff.hajewski at gmail.come&gt; wrote:<br>&gt;&gt; I suspect there is an easy solution here and I&#39;m just having a mental block...<br></p><p><br>Jeff, I really do feel you, I’m in the same situation! <br>I think your solution could be applicable though, just in a little more complicated way than C++ did, which is to extract the complement of the predicate and act differently upon that. <br>As of now I don’t have the time to put down some code (time zone sucks) but will try asap.<br></p><p>Lorenzo<br></p><p>Lorenzo Racca<br>+39 345 9294756<br>lorenzo.racca at live.it<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160315/c7a60b11/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5f463dd4e7af28b64ad8f0e032ee82dc?s=50"></div><header><strong>[Proposal] Add Binary Search functions to SequenceType</strong> from <string>Nate Cook</string> &lt;natecook at gmail.com&gt;<p>March 16, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; On Mar 15, 2016, at 1:58 PM, Lorenzo Racca via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Mar 15, 2016, at 6:49 PM, Haravikk &lt;swift-evolution at haravikk.me &lt;mailto:swift-evolution at haravikk.me&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On 15 Mar 2016, at 15:48, Lorenzo Racca &lt;lorenzo.racca at live.it &lt;mailto:lorenzo.racca at live.it&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I already knew the impossibility of applying such a predicate as “$0 == 3” and I actually couldn’t quite figure out a solution.<br>&gt;&gt; <br>&gt;&gt; I thought so, and I don’t think there is a way to do it, my point was really just that your swift doc comments weren’t clear on that point, then I went off at a bit of a tangent ;)<br>&gt;&gt; <br>&gt; No problem! What I am trying to figure out here is how we should implement the lowerBound and upperBound functions. Should they exactly reflect their C++ counterparts? <br>&gt; Anyway, it seems all of our implementations have the same problem, that they cannot be univocally called with any predicate whatsoever, (or at least it seemed to me during some tests with the implementations :) ), so I don’t really know how we should act. I am a little blocked.<br>&gt; Does anyone have ideas on how that could work no matter what predicate is given? Especially, an upperBound() function, which is a little trickier. <br></p><p>The key is to use a binary predicate (as used in sort and partition) instead of a unary predicate. Then you can use the predicate as is for lowerBound or with the arguments &quot;reversed&quot; for upperBound. The methods would have a similar signature to indexOf—one that just takes a value for comparable collections and one that takes a value and a predicate.<br></p><p>The binary search method can be implemented by finding the lower bound, which is by definition not less than the given value, then using the same predicate to check whether the value is not less than the lower bound. If neither is less than the other, you&#39;ve found the value.<br></p><p>Nate<br></p><p>&gt;&gt;&gt; On Mar 15, 2016, at 6:07 PM, Jeff Hajewski  &lt;jeff.hajewski at gmail.come &lt;mailto:jeff.hajewski at gmail.come&gt;&gt; wrote:<br>&gt;&gt;&gt; I suspect there is an easy solution here and I&#39;m just having a mental block...<br>&gt; <br>&gt; <br>&gt; Jeff, I really do feel you, I’m in the same situation! <br>&gt; I think your solution could be applicable though, just in a little more complicated way than C++ did, which is to extract the complement of the predicate and act differently upon that. <br>&gt; As of now I don’t have the time to put down some code (time zone sucks) but will try asap.<br>&gt; <br>&gt; Lorenzo<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160316/cf729076/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/30e4ca9ef73f6a84d52c26952c180bcd?s=50"></div><header><strong>[Proposal] Add Binary Search functions to SequenceType</strong> from <string>Jeff Hajewski</string> &lt;jeff.hajewski at gmail.com&gt;<p>March 16, 2016 at 01:00:00pm</p></header><div class="content"><p>Nate - I suppose that&#39;s really the crux of the matter here. I agree a<br>binary predicate solves the problem, but is that the route we want to go? I<br>think it makes sense, but is there a reason we should stick with a unary<br>predicate? For some reason I had it in my mind that there was mention of<br>preferring a unary predicate but now that I&#39;m looking back I can&#39;t find<br>anything to that end.<br></p><p>I&#39;ll work on a binary predicate implementation and see what the group<br>thinks.<br></p><p>Thanks!<br>Jeff<br></p><p>On Wed, Mar 16, 2016 at 2:17 AM, Nate Cook via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Mar 15, 2016, at 1:58 PM, Lorenzo Racca via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Mar 15, 2016, at 6:49 PM, Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br>&gt;<br>&gt; On 15 Mar 2016, at 15:48, Lorenzo Racca &lt;lorenzo.racca at live.it&gt; wrote:<br>&gt;<br>&gt; I already knew the impossibility of applying such a predicate as “$0 == 3”<br>&gt; and I actually couldn’t quite figure out a solution.<br>&gt;<br>&gt;<br>&gt; I thought so, and I don’t think there is a way to do it, my point was<br>&gt; really just that your swift doc comments weren’t clear on that point, then<br>&gt; I went off at a bit of a tangent ;)<br>&gt;<br>&gt; No problem! What I am trying to figure out here is how we should implement<br>&gt; the lowerBound and upperBound functions. Should they exactly reflect their<br>&gt; C++ counterparts?<br>&gt; Anyway, it seems all of our implementations have the same problem, that<br>&gt; they cannot be univocally called with any predicate whatsoever, (or at<br>&gt; least it seemed to me during some tests with the implementations :) ), so I<br>&gt; don’t really know how we should act. I am a little blocked.<br>&gt; Does anyone have ideas on how that could work no matter what predicate is<br>&gt; given? Especially, an upperBound() function, which is a little trickier.<br>&gt;<br>&gt;<br>&gt; The key is to use a binary predicate (as used in sort and partition)<br>&gt; instead of a unary predicate. Then you can use the predicate as is for<br>&gt; lowerBound or with the arguments &quot;reversed&quot; for upperBound. The methods<br>&gt; would have a similar signature to indexOf—one that just takes a value for<br>&gt; comparable collections and one that takes a value and a predicate.<br>&gt;<br>&gt; The binary search method can be implemented by finding the lower bound,<br>&gt; which is by definition not less than the given value, then using the same<br>&gt; predicate to check whether the value is not less than the lower bound. If<br>&gt; neither is less than the other, you&#39;ve found the value.<br>&gt;<br>&gt; Nate<br>&gt;<br>&gt; On Mar 15, 2016, at 6:07 PM, Jeff Hajewski  &lt;jeff.hajewski at gmail.come&gt;<br>&gt; wrote:<br>&gt;<br>&gt; I suspect there is an easy solution here and I&#39;m just having a mental<br>&gt; block...<br>&gt;<br>&gt;<br>&gt; Jeff, I really do feel you, I’m in the same situation!<br>&gt; I think your solution could be applicable though, just in a little more<br>&gt; complicated way than C++ did, which is to extract the complement of the<br>&gt; predicate and act differently upon that.<br>&gt; As of now I don’t have the time to put down some code (time zone sucks)<br>&gt; but will try asap.<br>&gt;<br>&gt; Lorenzo<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160316/8ae0ab79/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
