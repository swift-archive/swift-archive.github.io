<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>Swift Initializer Generics</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>January 18, 2016 at 04:00:00pm</p></header><div class="content"><p>Hi everyone,<br></p><p>I was wondering if there was a trick to get the following thing accomplished within the framework of Swift generics. I am using Surge &lt;https://github.com/mattt/Surge&gt;, a very nice and useful wrapper for the Accelerate framework. The problem is that I would like to extend the functionality of Surge in my own graphics library to include geometric constructs and I’ve run into an issue.<br></p><p>In order to use the appropriate Accelerate function call, Surge duplicates each function on the parameter types, either Float or Double. Ideally, I think there should be a better way to accomplish this with Swift generics, but perhaps that is a separate discussion. As an example consider dot product of Arrays (Vectors).<br></p><p>public func dot(x: [Float], y: [Float]) -&gt; Float {<br>    precondition(x.count == y.count, &quot;Vectors must have equal count&quot;)<br></p><p>    var result: Float = 0.0<br>    vDSP_dotpr(x, 1, y, 1, &amp;result, vDSP_Length(x.count))<br></p><p>    return result<br>}<br></p><p><br>public func dot(x: [Double], y: [Double]) -&gt; Double {<br>    precondition(x.count == y.count, &quot;Vectors must have equal count&quot;)<br></p><p>    var result: Double = 0.0<br>    vDSP_dotprD(x, 1, y, 1, &amp;result, vDSP_Length(x.count))<br></p><p>    return result<br>}<br></p><p>Consider, now, that I want to make a new function that uses one of these Surge functions. Am I correct in saying that I must define two functions, one for Float and one for Double? <br></p><p>func normalized(x: [Float]) -&gt; [Float] {<br>    return x / sum(x)<br>}<br></p><p>func normalized(x: [Double]) -&gt; [Double] {<br>    return x / sum(x)<br>}<br></p><p>Is there no way to get this done with generics? Writing the function with generic parameters yields the following error:<br></p><p>func normalized&lt;T where T: FloatingPointType, T: FloatLiteralConvertible&gt;(x: [T]) -&gt; [T] {<br>    return x / sum(x) // Error: Cannot invoke &#39;sum&#39; with an argument list of type &#39;([T])&#39;<br>}<br></p><p>Let’s assume, however that I go ahead and create two ‘normalized’ functions. I then want to create a new struct type call Plane. I would like to be able to construct a Plane using a normal vector and a point. Like so:<br></p><p>struct Plane&lt;T where T: FloatingPointType, T: FloatLiteralConvertible&gt; {<br>    let normal: [T]<br>    let distance: T<br>    <br>    init(normal: [T], point: [T]) {<br>        self.normal = normalized(normal) // Error: Ambiguous reference to member &#39;normalized&#39;<br>        self.distance = dot(normal, y: point) // Error: Cannot invoke &#39;dot&#39; with an argument list of type &#39;([T], y: [T])&#39;<br>    }<br>}<br></p><p>Yet as you can see there are still errors. In fact, as far as I can figure there is no way I can accomplish this last bit, no matter how much duplication I’m willing to tolerate. <br></p><p>Any help that anyone can provide would be much appreciated. Sorry for the duplicate email, I was off-list before.<br></p><p>Thanks!<br></p><p>Tyler<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160118/8b59f67d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Swift Initializer Generics</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>January 18, 2016 at 04:00:00pm</p></header><div class="content"><p>On Mon, Jan 18, 2016 at 4:23 PM, Tyler Fleming Cloutier via<br>swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; Is there no way to get this done with generics? Writing the function with<br>&gt; generic parameters yields the following error:<br>&gt;<br>&gt; func normalized&lt;T where T: FloatingPointType, T: FloatLiteralConvertible&gt;(x:<br>&gt; [T]) -&gt; [T] {<br>&gt;     return x / sum(x) // Error: Cannot invoke &#39;sum&#39; with an argument list of<br>&gt; type &#39;([T])&#39;<br>&gt; }<br></p><p>Fixing this essentially requires a redesign of Surge to be centered<br>around protocols, I think.  You would need to make sure that every<br>entry point that is implemented differently for Floats and Doubles is<br>called through a protocol requirement.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7321934b88ca8da079d7b89926501a9c?s=50"></div><header><strong>Swift Initializer Generics</strong> from <string>David Turnbull</string> &lt;dturnbull at gmail.com&gt;<p>January 18, 2016 at 05:00:00pm</p></header><div class="content"><p>How about this...<br></p><p>public func dot&lt;genType:FloatingPointVectorType&gt;(x:genType, _ y:genType) -&gt;<br>genType.Element {<br></p><p>    let a = genType(x, y, *)<br></p><p>    return a.reduce(genType.Element(0)) { $0 + ($1 as! genType.Element) }<br></p><p>}<br></p><p><br>and this...<br></p><p><br>public func normalize&lt;genType:FloatingPointVectorType&gt;(x:genType) -&gt; genType<br>{<br></p><p>    return x / length(x)<br></p><p>}<br></p><p><br>These are the actual implementations from SwiftGL. Here&#39;s what your Plane<br>looks like in SwiftGL:<br></p><p>struct Plane&lt;T:FloatingPointScalarType&gt; {<br></p><p>    let normal: Vector3&lt;T&gt;<br></p><p>    let distance: T<br></p><p><br>    init(normal: Vector3&lt;T&gt;, point: Vector3&lt;T&gt;) {<br></p><p>        self.normal = normalize(normal)<br></p><p>        self.distance = dot(normal, point)<br></p><p>    }<br></p><p>}<br></p><p>So not only is it possible, it&#39;s been done. There&#39;s no &quot;trick&quot; to this. It<br>works because I put a lot of time into making it work.<br></p><p>https://github.com/AE9RB/SwiftGL<br></p><p>-david<br></p><p>On Mon, Jan 18, 2016 at 4:23 PM, Tyler Fleming Cloutier via swift-users &lt;<br>swift-users at swift.org&gt; wrote:<br></p><p>&gt; Hi everyone,<br>&gt;<br>&gt; I was wondering if there was a trick to get the following thing<br>&gt; accomplished within the framework of Swift generics. I am using Surge<br>&gt; &lt;https://github.com/mattt/Surge&gt;, a very nice and useful wrapper for the<br>&gt; Accelerate framework. The problem is that I would like to extend the<br>&gt; functionality of Surge in my own graphics library to include geometric<br>&gt; constructs and I’ve run into an issue.<br>&gt;<br>&gt; In order to use the appropriate Accelerate function call, Surge duplicates<br>&gt; each function on the parameter types, either Float or Double. Ideally, I<br>&gt; think there should be a better way to accomplish this with Swift generics,<br>&gt; but perhaps that is a separate discussion. As an example consider dot<br>&gt; product of Arrays (Vectors).<br>&gt;<br>&gt; public func dot(x: [Float], y: [Float]) -&gt; Float {<br>&gt;     precondition(x.count == y.count, &quot;Vectors must have equal count&quot;)<br>&gt;<br>&gt;     var result: Float = 0.0<br>&gt;     vDSP_dotpr(x, 1, y, 1, &amp;result, vDSP_Length(x.count))<br>&gt;<br>&gt;     return result<br>&gt; }<br>&gt;<br>&gt;<br>&gt; public func dot(x: [Double], y: [Double]) -&gt; Double {<br>&gt;     precondition(x.count == y.count, &quot;Vectors must have equal count&quot;)<br>&gt;<br>&gt;     var result: Double = 0.0<br>&gt;     vDSP_dotprD(x, 1, y, 1, &amp;result, vDSP_Length(x.count))<br>&gt;<br>&gt;     return result<br>&gt; }<br>&gt;<br>&gt; Consider, now, that I want to make a new function that uses one of these<br>&gt; Surge functions. Am I correct in saying that I must define two functions,<br>&gt; one for Float and one for Double?<br>&gt;<br>&gt; func normalized(x: [Float]) -&gt; [Float] {<br>&gt;     return x / sum(x)<br>&gt; }<br>&gt;<br>&gt; func normalized(x: [Double]) -&gt; [Double] {<br>&gt;     return x / sum(x)<br>&gt; }<br>&gt;<br>&gt; Is there no way to get this done with generics? Writing the function with<br>&gt; generic parameters yields the following error:<br>&gt;<br>&gt; func normalized&lt;T where T: FloatingPointType, T:<br>&gt; FloatLiteralConvertible&gt;(x: [T]) -&gt; [T] {<br>&gt;     return x / sum(x) // Error: Cannot invoke &#39;sum&#39; with an argument list<br>&gt; of type &#39;([T])&#39;<br>&gt; }<br>&gt;<br>&gt; Let’s assume, however that I go ahead and create two ‘normalized’<br>&gt; functions. I then want to create a new struct type call Plane. I would like<br>&gt; to be able to construct a Plane using a normal vector and a point. Like so:<br>&gt;<br>&gt; struct Plane&lt;T where T: FloatingPointType, T: FloatLiteralConvertible&gt; {<br>&gt;     let normal: [T]<br>&gt;     let distance: T<br>&gt;<br>&gt;     init(normal: [T], point: [T]) {<br>&gt;         self.normal = normalized(normal) // Error: Ambiguous reference to<br>&gt; member &#39;normalized&#39;<br>&gt;         self.distance = dot(normal, y: point) // Error: Cannot invoke<br>&gt; &#39;dot&#39; with an argument list of type &#39;([T], y: [T])&#39;<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; Yet as you can see there are still errors. In fact, as far as I can figure<br>&gt; there is no way I can accomplish this last bit, no matter how much<br>&gt; duplication I’m willing to tolerate.<br>&gt;<br>&gt; Any help that anyone can provide would be much appreciated. Sorry for the<br>&gt; duplicate email, I was off-list before.<br>&gt;<br>&gt; Thanks!<br>&gt;<br>&gt; Tyler<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160118/ee9e97bd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Swift Initializer Generics</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>January 18, 2016 at 05:00:00pm</p></header><div class="content"><p>On Mon, Jan 18, 2016 at 5:06 PM, David Turnbull via swift-users<br>&lt;swift-users at swift.org&gt; wrote:<br>&gt; How about this...<br>&gt;<br>&gt; public func dot&lt;genType:FloatingPointVectorType&gt;(x:genType, _ y:genType) -&gt;<br>&gt; genType.Element {<br>&gt;<br>&gt;     let a = genType(x, y, *)<br>&gt;<br>&gt;     return a.reduce(genType.Element(0)) { $0 + ($1 as! genType.Element) }<br>&gt;<br>&gt; }<br></p><p>This won&#39;t be calling into Accelerate.  The assumption is that<br>Accelerate is manually-optimized and heavily tuned, and it will be<br>faster than a naive Swift implementation.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7321934b88ca8da079d7b89926501a9c?s=50"></div><header><strong>Swift Initializer Generics</strong> from <string>David Turnbull</string> &lt;dturnbull at gmail.com&gt;<p>January 18, 2016 at 05:00:00pm</p></header><div class="content"><p>SwiftGL isn&#39;t &quot;naive Swift&quot; except where it can&#39;t use the SIMD module.<br></p><p>-david<br></p><p>On Mon, Jan 18, 2016 at 5:09 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt;<br>wrote:<br></p><p>&gt; On Mon, Jan 18, 2016 at 5:06 PM, David Turnbull via swift-users<br>&gt; &lt;swift-users at swift.org&gt; wrote:<br>&gt; &gt; How about this...<br>&gt; &gt;<br>&gt; &gt; public func dot&lt;genType:FloatingPointVectorType&gt;(x:genType, _ y:genType)<br>&gt; -&gt;<br>&gt; &gt; genType.Element {<br>&gt; &gt;<br>&gt; &gt;     let a = genType(x, y, *)<br>&gt; &gt;<br>&gt; &gt;     return a.reduce(genType.Element(0)) { $0 + ($1 as! genType.Element) }<br>&gt; &gt;<br>&gt; &gt; }<br>&gt;<br>&gt; This won&#39;t be calling into Accelerate.  The assumption is that<br>&gt; Accelerate is manually-optimized and heavily tuned, and it will be<br>&gt; faster than a naive Swift implementation.<br>&gt;<br>&gt; Dmitri<br>&gt;<br>&gt; --<br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160118/1541c310/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>Swift Initializer Generics</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>January 18, 2016 at 06:00:00pm</p></header><div class="content"><p>Thanks for your responses!<br></p><p>Yes, it is true that I would like to use the Accelerate framework as much as possible. And since Surge is just a thin wrapper for that I wanted to reuse that functionality.<br></p><p>Dmitri, your suggestion is interesting regarding protocols, but I was giving it a try and I’m not sure exactly how you could accomplish it. For example, I tried the following.<br></p><p>protocol Summable: ArrayLiteralConvertible, CollectionType, _DestructorSafeContainer {<br>    typealias T: FloatingPointType, FloatLiteralConvertible<br>    func sum() -&gt; T<br>}<br></p><p>extension Summable {<br>    func sum() -&gt; T {<br>        var result: T = 0.0<br>        vDSP_sve(self, 1, &amp;result, vDSP_Length(self.count)) // Cannot convert value of type &#39;Self&#39; to expected argument type &#39;UnsafePointer&lt;Float&gt;&#39;<br>        return result<br>    }<br>}<br></p><p>Well not only did that produce an error, but it doesn’t really makes sense or accomplish the goal because I haven’t distinguished between Float and Double. Neither does the following which has a vague error message.<br></p><p>protocol Summable: CollectionType {<br>    typealias Element: FloatingPointType, FloatLiteralConvertible<br>    func sum() -&gt; Element<br>}<br></p><p>extension Array: Summable { // Type &#39;Array&lt;Element&gt;&#39; does not conform to protocol &#39;Summable&#39;<br>    func sum() -&gt; Element {<br>        var result: Element = 0.0<br>        vDSP_sve(self, 1, &amp;result, vDSP_Length(self.count))<br>        return result<br>    }<br>}<br></p><p>I suspect I’m misunderstanding your suggestion since I can’t quite work out how to do this. I’ve been wrangling the type checker here for a while, but I don’t know what the devil to do. With the different syntax for associated types, generic parameters, and constraints it’s a bit difficult to explore different without knowing exactly what to do.<br></p><p>Thanks,<br></p><p>Tyler<br></p><p><br>&gt; On Jan 18, 2016, at 5:09 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Mon, Jan 18, 2016 at 5:06 PM, David Turnbull via swift-users<br>&gt; &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; How about this...<br>&gt;&gt; <br>&gt;&gt; public func dot&lt;genType:FloatingPointVectorType&gt;(x:genType, _ y:genType) -&gt;<br>&gt;&gt; genType.Element {<br>&gt;&gt; <br>&gt;&gt;    let a = genType(x, y, *)<br>&gt;&gt; <br>&gt;&gt;    return a.reduce(genType.Element(0)) { $0 + ($1 as! genType.Element) }<br>&gt;&gt; <br>&gt;&gt; }<br>&gt; <br>&gt; This won&#39;t be calling into Accelerate.  The assumption is that<br>&gt; Accelerate is manually-optimized and heavily tuned, and it will be<br>&gt; faster than a naive Swift implementation.<br>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160118/620db29a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Swift Initializer Generics</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>January 18, 2016 at 06:00:00pm</p></header><div class="content"><p>On Mon, Jan 18, 2016 at 6:34 PM, Tyler Fleming Cloutier<br>&lt;cloutiertyler at aol.com&gt; wrote:<br>&gt; I suspect I’m misunderstanding your suggestion since I can’t quite work out<br>&gt; how to do this. I’ve been wrangling the type checker here for a while, but I<br>&gt; don’t know what the devil to do. With the different syntax for associated<br>&gt; types, generic parameters, and constraints it’s a bit difficult to explore<br>&gt; different without knowing exactly what to do.<br></p><p>Here&#39;s a sketch.<br></p><p>//<br>// Mock of the Accelerate library.<br>//<br></p><p>// For exposition only, use the Accelerate function instead.<br>func fastDotProductOfDoubles(<br>  lhs: UnsafeBufferPointer&lt;Double&gt;,<br>  _ rhs: UnsafeBufferPointer&lt;Double&gt;<br>) -&gt; Double {<br>  fatalError(&quot;call vDSP_dotprD&quot;)<br>}<br></p><p>// For exposition only, use the Accelerate function instead.<br>func fastDotProductOfFloats(<br>  lhs: UnsafeBufferPointer&lt;Float&gt;,<br>  _ rhs: UnsafeBufferPointer&lt;Float&gt;<br>) -&gt; Float {<br>  fatalError(&quot;call vDSP_dotpr&quot;)<br>}<br></p><p>// For exposition only, use the Accelerate function instead.<br>func fastSumOfDoubles(data: UnsafeBufferPointer&lt;Double&gt;) -&gt; Double {<br>  fatalError(&quot;call Accelerate&quot;)<br>}<br></p><p>// For exposition only, use the Accelerate function instead.<br>func fastSumOfFloats(data: UnsafeBufferPointer&lt;Float&gt;) -&gt; Float {<br>  fatalError(&quot;call Accelerate&quot;)<br>}<br></p><p>//<br>// Swift wrapper for the Accelerate library.<br>//<br></p><p>protocol AccelerateFloatingPoint {<br>  static func _dot(<br>    lhs: UnsafeBufferPointer&lt;Self&gt;,<br>    _ rhs: UnsafeBufferPointer&lt;Self&gt;<br>  ) -&gt; Self<br></p><p>  static func _sum(data: UnsafeBufferPointer&lt;Self&gt;) -&gt; Self<br>}<br></p><p>extension Float : AccelerateFloatingPoint {<br>  static func _dot(<br>    lhs: UnsafeBufferPointer&lt;Float&gt;,<br>    _ rhs: UnsafeBufferPointer&lt;Float&gt;<br>  ) -&gt; Float {<br>    return fastDotProductOfFloats(lhs, rhs)<br>  }<br></p><p>  static func _sum(data: UnsafeBufferPointer&lt;Float&gt;) -&gt; Float {<br>    return fastSumOfFloats(data)<br>  }<br>}<br></p><p>extension Double : AccelerateFloatingPoint {<br>  static func _dot(<br>    lhs: UnsafeBufferPointer&lt;Double&gt;,<br>    _ rhs: UnsafeBufferPointer&lt;Double&gt;<br>  ) -&gt; Double {<br>    return fastDotProductOfDoubles(lhs, rhs)<br>  }<br></p><p>  static func _sum(data: UnsafeBufferPointer&lt;Double&gt;) -&gt; Double {<br>    return fastSumOfDoubles(data)<br>  }<br>}<br></p><p>func dot&lt;T : AccelerateFloatingPoint&gt;(lhs: [T], _ rhs: [T]) -&gt; T {<br>  return lhs.withUnsafeBufferPointer {<br>    (lhs) in<br>    return rhs.withUnsafeBufferPointer {<br>      (rhs) in<br>      return T._dot(lhs, rhs)<br>    }<br>  }<br>}<br></p><p>func sum&lt;T : AccelerateFloatingPoint&gt;(data: [T]) -&gt; T {<br>  return data.withUnsafeBufferPointer {<br>    (data) in<br>    return T._sum(data)<br>  }<br>}<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>Swift Initializer Generics</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>January 18, 2016 at 07:00:00pm</p></header><div class="content"><p>I will be damned! And that was a fast response too! I absolutely would not ever have thought of extending Float and Double to do this. That is crafty indeed. Is there a reason to convert to the array to an UnsafeBufferPointer before passing it into the Accelerate function? <br></p><p>Are you aware of any Swift 3.0 generics improvements that might make this more obvious?<br></p><p>Thanks for the help!<br></p><p>Tyler<br></p><p><br>&gt; On Jan 18, 2016, at 6:47 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Mon, Jan 18, 2016 at 6:34 PM, Tyler Fleming Cloutier<br>&gt; &lt;cloutiertyler at aol.com&gt; wrote:<br>&gt;&gt; I suspect I’m misunderstanding your suggestion since I can’t quite work out<br>&gt;&gt; how to do this. I’ve been wrangling the type checker here for a while, but I<br>&gt;&gt; don’t know what the devil to do. With the different syntax for associated<br>&gt;&gt; types, generic parameters, and constraints it’s a bit difficult to explore<br>&gt;&gt; different without knowing exactly what to do.<br>&gt; <br>&gt; Here&#39;s a sketch.<br>&gt; <br>&gt; //<br>&gt; // Mock of the Accelerate library.<br>&gt; //<br>&gt; <br>&gt; // For exposition only, use the Accelerate function instead.<br>&gt; func fastDotProductOfDoubles(<br>&gt;  lhs: UnsafeBufferPointer&lt;Double&gt;,<br>&gt;  _ rhs: UnsafeBufferPointer&lt;Double&gt;<br>&gt; ) -&gt; Double {<br>&gt;  fatalError(&quot;call vDSP_dotprD&quot;)<br>&gt; }<br>&gt; <br>&gt; // For exposition only, use the Accelerate function instead.<br>&gt; func fastDotProductOfFloats(<br>&gt;  lhs: UnsafeBufferPointer&lt;Float&gt;,<br>&gt;  _ rhs: UnsafeBufferPointer&lt;Float&gt;<br>&gt; ) -&gt; Float {<br>&gt;  fatalError(&quot;call vDSP_dotpr&quot;)<br>&gt; }<br>&gt; <br>&gt; // For exposition only, use the Accelerate function instead.<br>&gt; func fastSumOfDoubles(data: UnsafeBufferPointer&lt;Double&gt;) -&gt; Double {<br>&gt;  fatalError(&quot;call Accelerate&quot;)<br>&gt; }<br>&gt; <br>&gt; // For exposition only, use the Accelerate function instead.<br>&gt; func fastSumOfFloats(data: UnsafeBufferPointer&lt;Float&gt;) -&gt; Float {<br>&gt;  fatalError(&quot;call Accelerate&quot;)<br>&gt; }<br>&gt; <br>&gt; //<br>&gt; // Swift wrapper for the Accelerate library.<br>&gt; //<br>&gt; <br>&gt; protocol AccelerateFloatingPoint {<br>&gt;  static func _dot(<br>&gt;    lhs: UnsafeBufferPointer&lt;Self&gt;,<br>&gt;    _ rhs: UnsafeBufferPointer&lt;Self&gt;<br>&gt;  ) -&gt; Self<br>&gt; <br>&gt;  static func _sum(data: UnsafeBufferPointer&lt;Self&gt;) -&gt; Self<br>&gt; }<br>&gt; <br>&gt; extension Float : AccelerateFloatingPoint {<br>&gt;  static func _dot(<br>&gt;    lhs: UnsafeBufferPointer&lt;Float&gt;,<br>&gt;    _ rhs: UnsafeBufferPointer&lt;Float&gt;<br>&gt;  ) -&gt; Float {<br>&gt;    return fastDotProductOfFloats(lhs, rhs)<br>&gt;  }<br>&gt; <br>&gt;  static func _sum(data: UnsafeBufferPointer&lt;Float&gt;) -&gt; Float {<br>&gt;    return fastSumOfFloats(data)<br>&gt;  }<br>&gt; }<br>&gt; <br>&gt; extension Double : AccelerateFloatingPoint {<br>&gt;  static func _dot(<br>&gt;    lhs: UnsafeBufferPointer&lt;Double&gt;,<br>&gt;    _ rhs: UnsafeBufferPointer&lt;Double&gt;<br>&gt;  ) -&gt; Double {<br>&gt;    return fastDotProductOfDoubles(lhs, rhs)<br>&gt;  }<br>&gt; <br>&gt;  static func _sum(data: UnsafeBufferPointer&lt;Double&gt;) -&gt; Double {<br>&gt;    return fastSumOfDoubles(data)<br>&gt;  }<br>&gt; }<br>&gt; <br>&gt; func dot&lt;T : AccelerateFloatingPoint&gt;(lhs: [T], _ rhs: [T]) -&gt; T {<br>&gt;  return lhs.withUnsafeBufferPointer {<br>&gt;    (lhs) in<br>&gt;    return rhs.withUnsafeBufferPointer {<br>&gt;      (rhs) in<br>&gt;      return T._dot(lhs, rhs)<br>&gt;    }<br>&gt;  }<br>&gt; }<br>&gt; <br>&gt; func sum&lt;T : AccelerateFloatingPoint&gt;(data: [T]) -&gt; T {<br>&gt;  return data.withUnsafeBufferPointer {<br>&gt;    (data) in<br>&gt;    return T._sum(data)<br>&gt;  }<br>&gt; }<br>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Swift Initializer Generics</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>January 18, 2016 at 07:00:00pm</p></header><div class="content"><p>On Mon, Jan 18, 2016 at 7:14 PM, Tyler Fleming Cloutier<br>&lt;cloutiertyler at aol.com&gt; wrote:<br>&gt; I will be damned! And that was a fast response too! I absolutely would not ever have thought of extending Float and Double to do this.<br></p><p>The idea is that with Swift generics in most cases you need to find<br>the set of types that vary among your calls, and then hang a protocol<br>onto those types.<br></p><p>&gt; That is crafty indeed. Is there a reason to convert to the array to an UnsafeBufferPointer before passing it into the Accelerate function?<br></p><p>Just so that we don&#39;t get extra reference counting while passing the<br>array through layers of wrapping.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
