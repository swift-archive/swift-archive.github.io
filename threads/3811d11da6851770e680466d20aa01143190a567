<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f7d3036e2eaf1283f20f43d62472a29f?s=50"></div><header><strong>Reconsidering SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>David Farler</string> &lt;dfarler at apple.com&gt;<p>January 22, 2016 at 09:00:00am</p></header><div class="content"><p>Hello everyone,<br></p><p>I&#39;d like to reconsider SE-0003 for Swift 3 and propose cancelling the change in its entirety. After collecting feedback since Swift&#39;s open source launch, I no longer feel this is a good move and there are a few reasons why.<br></p><p>There are two main patterns that the removal penalizes:<br></p><p>- Get-Modify-Reassign<br>- Get-Modify-Return<br></p><p>I&#39;ve found that many of the problems with this proposal stem from the uses before and after the &quot;Modify&quot; part, before returning or reassigning with the new value.<br></p><p>I&#39;ve seen a few common responses to the var removal. Consider a `Rectangle` struct:<br></p><p><br>struct Rectangle {<br> var origin: (x: Double, y: Double)<br> var size: (width: Double, height: Double)<br>}<br></p><p><br>Even with mutable variables `origin` and `size`, this pattern would be impossible:<br></p><p><br>var selection = getRectangularSelection()<br>if var rect = selection?.rect {<br> // Mutate `rect` ...<br> selection.rect = rect<br>}<br></p><p><br>So, one might shadow the variable, which is not ideal:<br></p><p><br>var selection = getRectangularSelection()<br>if let rect = selection?.rect {<br> var rect = rect // Not so great<br> // Mutate `rect` ...<br> selection.rect = rect<br>}<br></p><p><br>Or, you might make a transformation function on `Rect`:<br></p><p><br>struct Rectangle {<br> var origin: (x: Double, y: Double)<br> var size: (width: Double, height: Double)<br> func withOrigin(x: Double, y: Double) -&gt; Rect {<br>   var r = self<br>   r.origin = (x, y)<br>   return r<br> }<br>}<br></p><p><br>This is a much better solution than shadowing but you would need one of these for any property that you want to mutate and I think you&#39;ll agree that it doesn&#39;t scale with the language we have today. This response begs for a kind of initializer that takes all of the fields of the original struct except any that you want to override:<br></p><p><br>if let rect = selection?.rect.with(origin: newOrigin) {<br> // ...<br>}<br></p><p><br>Straw syntax, but maybe you&#39;ll see something along these lines on swift-evolution in the future, which would provide a clear alternative to direct mutation patterns. Even then, I think having complementary patterns in the language isn&#39;t a bad thing.<br></p><p>These problems come up with the other variable bindings but the one that ended up bothering me the most was `guard var`:<br></p><p><br>func transform(selection: Rect?) {<br> guard let rect = selection else { return }<br> var _rect = rect<br> // Mutate `_rect` ...<br>}<br></p><p><br>One of the guard statement&#39;s main purposes is to conditionally bind a value as a peer in its own scope, not an inner scope like if statements. Not having var makes the guard statement much weaker.<br></p><p>There is certainly a bit of confusion about the nuances between value and reference semantics, who owns a value and when, how effects are propagated back to values, but I think we can attack the problem with more finesse.<br></p><p>Value types are one of the attractive features of Swift – because of their semantics, mutating algorithms are written in a familiar style but keeping effects limited to your unique reference. I don&#39;t think we should give that up now to address confusion about semantics, out of principle, or in anticipation of new language features. I propose cancelling this change for Swift 3 and continue to allow `var` in the grammar everywhere it occurs in Swift 2.2.<br></p><p>Regards,<br>David<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Reconsidering SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 22, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jan 22, 2016, at 9:26 AM, David Farler via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello everyone,<br>&gt; <br>&gt; I&#39;d like to reconsider SE-0003 for Swift 3 and propose cancelling the change in its entirety. After collecting feedback since Swift&#39;s open source launch, I no longer feel this is a good move and there are a few reasons why.<br>&gt; <br>&gt; There are two main patterns that the removal penalizes:<br>&gt; <br>&gt; - Get-Modify-Reassign<br>&gt; - Get-Modify-Return<br>&gt; <br>&gt; I&#39;ve found that many of the problems with this proposal stem from the uses before and after the &quot;Modify&quot; part, before returning or reassigning with the new value.<br>&gt; <br>&gt; I&#39;ve seen a few common responses to the var removal. Consider a `Rectangle` struct:<br>&gt; <br>&gt; <br>&gt; struct Rectangle {<br>&gt; var origin: (x: Double, y: Double)<br>&gt; var size: (width: Double, height: Double)<br>&gt; }<br>&gt; <br>&gt; <br>&gt; Even with mutable variables `origin` and `size`, this pattern would be impossible:<br>&gt; <br>&gt; <br>&gt; var selection = getRectangularSelection()<br>&gt; if var rect = selection?.rect {<br>&gt; // Mutate `rect` ...<br>&gt; selection.rect = rect<br>&gt; }<br></p><p>These examples don&#39;t make sense to me. None of them mutate the &#39;if var rect&#39; binding at all. Are you sure this is what you meant?<br></p><p>&gt; <br>&gt; <br>&gt; So, one might shadow the variable, which is not ideal:<br>&gt; <br>&gt; <br>&gt; var selection = getRectangularSelection()<br>&gt; if let rect = selection?.rect {<br>&gt; var rect = rect // Not so great<br>&gt; // Mutate `rect` ...<br>&gt; selection.rect = rect<br>&gt; }<br>&gt; <br>&gt; <br>&gt; Or, you might make a transformation function on `Rect`:<br>&gt; <br>&gt; <br>&gt; struct Rectangle {<br>&gt; var origin: (x: Double, y: Double)<br>&gt; var size: (width: Double, height: Double)<br>&gt; func withOrigin(x: Double, y: Double) -&gt; Rect {<br>&gt;   var r = self<br>&gt;   r.origin = (x, y)<br>&gt;   return r<br>&gt; }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; This is a much better solution than shadowing but you would need one of these for any property that you want to mutate and I think you&#39;ll agree that it doesn&#39;t scale with the language we have today. This response begs for a kind of initializer that takes all of the fields of the original struct except any that you want to override:<br>&gt; <br>&gt; <br>&gt; if let rect = selection?.rect.with(origin: newOrigin) {<br>&gt; // ...<br>&gt; }<br></p><p>You can approximate this today without any new language features:<br></p><p>protocol Updatable {}<br>extension Updatable {<br>  func with&lt;T&gt;(change: (inout T) -&gt; ()) -&gt; T {<br>    var update = value<br>    change(&amp;update)<br>    return update<br>  }<br>}<br></p><p>if let rect =  selection?.rect.with { $0.origin = newOrigin } {<br>}<br></p><p>I think this approach generally leads to cleaner code, since it&#39;s not forcing you to bind names to otherwise uninteresting intermediate values.<br></p><p>&gt; <br>&gt; <br>&gt; Straw syntax, but maybe you&#39;ll see something along these lines on swift-evolution in the future, which would provide a clear alternative to direct mutation patterns. Even then, I think having complementary patterns in the language isn&#39;t a bad thing.<br>&gt; <br>&gt; These problems come up with the other variable bindings but the one that ended up bothering me the most was `guard var`:<br>&gt; <br>&gt; <br>&gt; func transform(selection: Rect?) {<br>&gt; guard let rect = selection else { return }<br>&gt; var _rect = rect<br>&gt; // Mutate `_rect` ...<br>&gt; }<br>&gt; <br>&gt; <br>&gt; One of the guard statement&#39;s main purposes is to conditionally bind a value as a peer in its own scope, not an inner scope like if statements. Not having var makes the guard statement much weaker.<br>&gt; <br>&gt; There is certainly a bit of confusion about the nuances between value and reference semantics, who owns a value and when, how effects are propagated back to values, but I think we can attack the problem with more finesse.<br>&gt; <br>&gt; Value types are one of the attractive features of Swift – because of their semantics, mutating algorithms are written in a familiar style but keeping effects limited to your unique reference. I don&#39;t think we should give that up now to address confusion about semantics, out of principle, or in anticipation of new language features. I propose cancelling this change for Swift 3 and continue to allow `var` in the grammar everywhere it occurs in Swift 2.2.<br></p><p>I disagree. We have a lot of evidence that &#39;if var&#39; confuses people—a lot of users think that &#39;if var&#39; and &#39;var&#39; bindings in case patterns will write back to the original value when this isn&#39;t the case. Classes make this worse, since &#39;if var&#39; *will* seem to work that way when projecting through optional class references, and the value vs reference semantics divide is confusing enough as it is. Those of us who do understand the semantics don&#39;t save anything either—I at least have to mentally audit any code I see using &#39;if var&#39; to ensure that writeback wasn&#39;t intended by the original author. Code is read and maintained more often than it&#39;s written, and it&#39;s written by more novices than experts, and &#39;if var&#39; and its friends feel like very expert-writer-centric features to me.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4a300fb6ff17dc07df9be5e863e0c98a?s=50"></div><header><strong>Reconsidering SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Nate Birkholz</string> &lt;nbirkholz at gmail.com&gt;<p>January 22, 2016 at 10:00:00am</p></header><div class="content"><p>How *long* is it confusing, though? I feel like removing the utility and<br>especially the fluid expressiveness of &quot;if var&quot; or var parameters for<br>something that people will learn pretty quickly seems a bit spiteful to the<br>face.<br></p><p>On Fri, Jan 22, 2016 at 9:45 AM, Joe Groff via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Jan 22, 2016, at 9:26 AM, David Farler via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Hello everyone,<br>&gt; &gt;<br>&gt; &gt; I&#39;d like to reconsider SE-0003 for Swift 3 and propose cancelling the<br>&gt; change in its entirety. After collecting feedback since Swift&#39;s open source<br>&gt; launch, I no longer feel this is a good move and there are a few reasons<br>&gt; why.<br>&gt; &gt;<br>&gt; &gt; There are two main patterns that the removal penalizes:<br>&gt; &gt;<br>&gt; &gt; - Get-Modify-Reassign<br>&gt; &gt; - Get-Modify-Return<br>&gt; &gt;<br>&gt; &gt; I&#39;ve found that many of the problems with this proposal stem from the<br>&gt; uses before and after the &quot;Modify&quot; part, before returning or reassigning<br>&gt; with the new value.<br>&gt; &gt;<br>&gt; &gt; I&#39;ve seen a few common responses to the var removal. Consider a<br>&gt; `Rectangle` struct:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; struct Rectangle {<br>&gt; &gt; var origin: (x: Double, y: Double)<br>&gt; &gt; var size: (width: Double, height: Double)<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Even with mutable variables `origin` and `size`, this pattern would be<br>&gt; impossible:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; var selection = getRectangularSelection()<br>&gt; &gt; if var rect = selection?.rect {<br>&gt; &gt; // Mutate `rect` ...<br>&gt; &gt; selection.rect = rect<br>&gt; &gt; }<br>&gt;<br>&gt; These examples don&#39;t make sense to me. None of them mutate the &#39;if var<br>&gt; rect&#39; binding at all. Are you sure this is what you meant?<br>&gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; So, one might shadow the variable, which is not ideal:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; var selection = getRectangularSelection()<br>&gt; &gt; if let rect = selection?.rect {<br>&gt; &gt; var rect = rect // Not so great<br>&gt; &gt; // Mutate `rect` ...<br>&gt; &gt; selection.rect = rect<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Or, you might make a transformation function on `Rect`:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; struct Rectangle {<br>&gt; &gt; var origin: (x: Double, y: Double)<br>&gt; &gt; var size: (width: Double, height: Double)<br>&gt; &gt; func withOrigin(x: Double, y: Double) -&gt; Rect {<br>&gt; &gt;   var r = self<br>&gt; &gt;   r.origin = (x, y)<br>&gt; &gt;   return r<br>&gt; &gt; }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; This is a much better solution than shadowing but you would need one of<br>&gt; these for any property that you want to mutate and I think you&#39;ll agree<br>&gt; that it doesn&#39;t scale with the language we have today. This response begs<br>&gt; for a kind of initializer that takes all of the fields of the original<br>&gt; struct except any that you want to override:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; if let rect = selection?.rect.with(origin: newOrigin) {<br>&gt; &gt; // ...<br>&gt; &gt; }<br>&gt;<br>&gt; You can approximate this today without any new language features:<br>&gt;<br>&gt; protocol Updatable {}<br>&gt; extension Updatable {<br>&gt;   func with&lt;T&gt;(change: (inout T) -&gt; ()) -&gt; T {<br>&gt;     var update = value<br>&gt;     change(&amp;update)<br>&gt;     return update<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; if let rect =  selection?.rect.with { $0.origin = newOrigin } {<br>&gt; }<br>&gt;<br>&gt; I think this approach generally leads to cleaner code, since it&#39;s not<br>&gt; forcing you to bind names to otherwise uninteresting intermediate values.<br>&gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Straw syntax, but maybe you&#39;ll see something along these lines on<br>&gt; swift-evolution in the future, which would provide a clear alternative to<br>&gt; direct mutation patterns. Even then, I think having complementary patterns<br>&gt; in the language isn&#39;t a bad thing.<br>&gt; &gt;<br>&gt; &gt; These problems come up with the other variable bindings but the one that<br>&gt; ended up bothering me the most was `guard var`:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; func transform(selection: Rect?) {<br>&gt; &gt; guard let rect = selection else { return }<br>&gt; &gt; var _rect = rect<br>&gt; &gt; // Mutate `_rect` ...<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; One of the guard statement&#39;s main purposes is to conditionally bind a<br>&gt; value as a peer in its own scope, not an inner scope like if statements.<br>&gt; Not having var makes the guard statement much weaker.<br>&gt; &gt;<br>&gt; &gt; There is certainly a bit of confusion about the nuances between value<br>&gt; and reference semantics, who owns a value and when, how effects are<br>&gt; propagated back to values, but I think we can attack the problem with more<br>&gt; finesse.<br>&gt; &gt;<br>&gt; &gt; Value types are one of the attractive features of Swift – because of<br>&gt; their semantics, mutating algorithms are written in a familiar style but<br>&gt; keeping effects limited to your unique reference. I don&#39;t think we should<br>&gt; give that up now to address confusion about semantics, out of principle, or<br>&gt; in anticipation of new language features. I propose cancelling this change<br>&gt; for Swift 3 and continue to allow `var` in the grammar everywhere it occurs<br>&gt; in Swift 2.2.<br>&gt;<br>&gt; I disagree. We have a lot of evidence that &#39;if var&#39; confuses people—a lot<br>&gt; of users think that &#39;if var&#39; and &#39;var&#39; bindings in case patterns will write<br>&gt; back to the original value when this isn&#39;t the case. Classes make this<br>&gt; worse, since &#39;if var&#39; *will* seem to work that way when projecting through<br>&gt; optional class references, and the value vs reference semantics divide is<br>&gt; confusing enough as it is. Those of us who do understand the semantics<br>&gt; don&#39;t save anything either—I at least have to mentally audit any code I see<br>&gt; using &#39;if var&#39; to ensure that writeback wasn&#39;t intended by the original<br>&gt; author. Code is read and maintained more often than it&#39;s written, and it&#39;s<br>&gt; written by more novices than experts, and &#39;if var&#39; and its friends feel<br>&gt; like very expert-writer-centric features to me.<br>&gt;<br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br></p><p>-- <br>Nate Birkholz<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/acc4c1c2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/34b9659227ea084bb09a8ba4a450a162?s=50"></div><header><strong>Reconsidering SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Jessy Catterwaul</string> &lt;mr.jessy at gmail.com&gt;<p>January 22, 2016 at 01:00:00pm</p></header><div class="content"><p>Disallowing var where inout is allowed is not the same as if var and guard var. I suspect that as a beginner, it could be confusing that sometimes you can use var where you can use let, but other times, you may not. I suspect that I myself might be confused about it for the foreseeable future. <br></p><p>&gt; On Jan 22, 2016, at 1:05 PM, Nate Birkholz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; How *long* is it confusing, though? I feel like removing the utility and especially the fluid expressiveness of &quot;if var&quot; or var parameters for something that people will learn pretty quickly seems a bit spiteful to the face. <br>&gt; <br>&gt; On Fri, Jan 22, 2016 at 9:45 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; &gt; On Jan 22, 2016, at 9:26 AM, David Farler via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Hello everyone,<br>&gt; &gt;<br>&gt; &gt; I&#39;d like to reconsider SE-0003 for Swift 3 and propose cancelling the change in its entirety. After collecting feedback since Swift&#39;s open source launch, I no longer feel this is a good move and there are a few reasons why.<br>&gt; &gt;<br>&gt; &gt; There are two main patterns that the removal penalizes:<br>&gt; &gt;<br>&gt; &gt; - Get-Modify-Reassign<br>&gt; &gt; - Get-Modify-Return<br>&gt; &gt;<br>&gt; &gt; I&#39;ve found that many of the problems with this proposal stem from the uses before and after the &quot;Modify&quot; part, before returning or reassigning with the new value.<br>&gt; &gt;<br>&gt; &gt; I&#39;ve seen a few common responses to the var removal. Consider a `Rectangle` struct:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; struct Rectangle {<br>&gt; &gt; var origin: (x: Double, y: Double)<br>&gt; &gt; var size: (width: Double, height: Double)<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Even with mutable variables `origin` and `size`, this pattern would be impossible:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; var selection = getRectangularSelection()<br>&gt; &gt; if var rect = selection?.rect {<br>&gt; &gt; // Mutate `rect` ...<br>&gt; &gt; selection.rect = rect<br>&gt; &gt; }<br>&gt; <br>&gt; These examples don&#39;t make sense to me. None of them mutate the &#39;if var rect&#39; binding at all. Are you sure this is what you meant?<br>&gt; <br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; So, one might shadow the variable, which is not ideal:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; var selection = getRectangularSelection()<br>&gt; &gt; if let rect = selection?.rect {<br>&gt; &gt; var rect = rect // Not so great<br>&gt; &gt; // Mutate `rect` ...<br>&gt; &gt; selection.rect = rect<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Or, you might make a transformation function on `Rect`:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; struct Rectangle {<br>&gt; &gt; var origin: (x: Double, y: Double)<br>&gt; &gt; var size: (width: Double, height: Double)<br>&gt; &gt; func withOrigin(x: Double, y: Double) -&gt; Rect {<br>&gt; &gt;   var r = self<br>&gt; &gt;   r.origin = (x, y)<br>&gt; &gt;   return r<br>&gt; &gt; }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; This is a much better solution than shadowing but you would need one of these for any property that you want to mutate and I think you&#39;ll agree that it doesn&#39;t scale with the language we have today. This response begs for a kind of initializer that takes all of the fields of the original struct except any that you want to override:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; if let rect = selection?.rect.with(origin: newOrigin) {<br>&gt; &gt; // ...<br>&gt; &gt; }<br>&gt; <br>&gt; You can approximate this today without any new language features:<br>&gt; <br>&gt; protocol Updatable {}<br>&gt; extension Updatable {<br>&gt;   func with&lt;T&gt;(change: (inout T) -&gt; ()) -&gt; T {<br>&gt;     var update = value<br>&gt;     change(&amp;update)<br>&gt;     return update<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; if let rect =  selection?.rect.with { $0.origin = newOrigin } {<br>&gt; }<br>&gt; <br>&gt; I think this approach generally leads to cleaner code, since it&#39;s not forcing you to bind names to otherwise uninteresting intermediate values.<br>&gt; <br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Straw syntax, but maybe you&#39;ll see something along these lines on swift-evolution in the future, which would provide a clear alternative to direct mutation patterns. Even then, I think having complementary patterns in the language isn&#39;t a bad thing.<br>&gt; &gt;<br>&gt; &gt; These problems come up with the other variable bindings but the one that ended up bothering me the most was `guard var`:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; func transform(selection: Rect?) {<br>&gt; &gt; guard let rect = selection else { return }<br>&gt; &gt; var _rect = rect<br>&gt; &gt; // Mutate `_rect` ...<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; One of the guard statement&#39;s main purposes is to conditionally bind a value as a peer in its own scope, not an inner scope like if statements. Not having var makes the guard statement much weaker.<br>&gt; &gt;<br>&gt; &gt; There is certainly a bit of confusion about the nuances between value and reference semantics, who owns a value and when, how effects are propagated back to values, but I think we can attack the problem with more finesse.<br>&gt; &gt;<br>&gt; &gt; Value types are one of the attractive features of Swift – because of their semantics, mutating algorithms are written in a familiar style but keeping effects limited to your unique reference. I don&#39;t think we should give that up now to address confusion about semantics, out of principle, or in anticipation of new language features. I propose cancelling this change for Swift 3 and continue to allow `var` in the grammar everywhere it occurs in Swift 2.2.<br>&gt; <br>&gt; I disagree. We have a lot of evidence that &#39;if var&#39; confuses people—a lot of users think that &#39;if var&#39; and &#39;var&#39; bindings in case patterns will write back to the original value when this isn&#39;t the case. Classes make this worse, since &#39;if var&#39; *will* seem to work that way when projecting through optional class references, and the value vs reference semantics divide is confusing enough as it is. Those of us who do understand the semantics don&#39;t save anything either—I at least have to mentally audit any code I see using &#39;if var&#39; to ensure that writeback wasn&#39;t intended by the original author. Code is read and maintained more often than it&#39;s written, and it&#39;s written by more novices than experts, and &#39;if var&#39; and its friends feel like very expert-writer-centric features to me.<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Nate Birkholz<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/d20b9af1/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecb50a99bf3b4cc0249312945dce7115?s=50"></div><header><strong>Reconsidering SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Ben Langmuir</string> &lt;blangmuir at apple.com&gt;<p>January 22, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 22, 2016, at 9:45 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 22, 2016, at 9:26 AM, David Farler via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello everyone,<br>&gt;&gt; <br>&gt;&gt; I&#39;d like to reconsider SE-0003 for Swift 3 and propose cancelling the change in its entirety. After collecting feedback since Swift&#39;s open source launch, I no longer feel this is a good move and there are a few reasons why.<br>&gt;&gt; <br>&gt;&gt; There are two main patterns that the removal penalizes:<br>&gt;&gt; <br>&gt;&gt; - Get-Modify-Reassign<br>&gt;&gt; - Get-Modify-Return<br>&gt;&gt; <br>&gt;&gt; I&#39;ve found that many of the problems with this proposal stem from the uses before and after the &quot;Modify&quot; part, before returning or reassigning with the new value.<br>&gt;&gt; <br>&gt;&gt; I&#39;ve seen a few common responses to the var removal. Consider a `Rectangle` struct:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; struct Rectangle {<br>&gt;&gt; var origin: (x: Double, y: Double)<br>&gt;&gt; var size: (width: Double, height: Double)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Even with mutable variables `origin` and `size`, this pattern would be impossible:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; var selection = getRectangularSelection()<br>&gt;&gt; if var rect = selection?.rect {<br>&gt;&gt; // Mutate `rect` ...<br>&gt;&gt; selection.rect = rect<br>&gt;&gt; }<br>&gt; <br>&gt; These examples don&#39;t make sense to me. None of them mutate the &#39;if var rect&#39; binding at all. Are you sure this is what you meant?<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; So, one might shadow the variable, which is not ideal:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; var selection = getRectangularSelection()<br>&gt;&gt; if let rect = selection?.rect {<br>&gt;&gt; var rect = rect // Not so great<br>&gt;&gt; // Mutate `rect` ...<br>&gt;&gt; selection.rect = rect<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Or, you might make a transformation function on `Rect`:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; struct Rectangle {<br>&gt;&gt; var origin: (x: Double, y: Double)<br>&gt;&gt; var size: (width: Double, height: Double)<br>&gt;&gt; func withOrigin(x: Double, y: Double) -&gt; Rect {<br>&gt;&gt;  var r = self<br>&gt;&gt;  r.origin = (x, y)<br>&gt;&gt;  return r<br>&gt;&gt; }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; This is a much better solution than shadowing but you would need one of these for any property that you want to mutate and I think you&#39;ll agree that it doesn&#39;t scale with the language we have today. This response begs for a kind of initializer that takes all of the fields of the original struct except any that you want to override:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; if let rect = selection?.rect.with(origin: newOrigin) {<br>&gt;&gt; // ...<br>&gt;&gt; }<br>&gt; <br>&gt; You can approximate this today without any new language features:<br>&gt; <br>&gt; protocol Updatable {}<br>&gt; extension Updatable {<br>&gt;  func with&lt;T&gt;(change: (inout T) -&gt; ()) -&gt; T {<br>&gt;    var update = value<br>&gt;    change(&amp;update)<br>&gt;    return update<br>&gt;  }<br>&gt; }<br>&gt; <br>&gt; if let rect =  selection?.rect.with { $0.origin = newOrigin } {<br>&gt; }<br>&gt; <br>&gt; I think this approach generally leads to cleaner code, since it&#39;s not forcing you to bind names to otherwise uninteresting intermediate values.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Straw syntax, but maybe you&#39;ll see something along these lines on swift-evolution in the future, which would provide a clear alternative to direct mutation patterns. Even then, I think having complementary patterns in the language isn&#39;t a bad thing.<br>&gt;&gt; <br>&gt;&gt; These problems come up with the other variable bindings but the one that ended up bothering me the most was `guard var`:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; func transform(selection: Rect?) {<br>&gt;&gt; guard let rect = selection else { return }<br>&gt;&gt; var _rect = rect<br>&gt;&gt; // Mutate `_rect` ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; One of the guard statement&#39;s main purposes is to conditionally bind a value as a peer in its own scope, not an inner scope like if statements. Not having var makes the guard statement much weaker.<br>&gt;&gt; <br>&gt;&gt; There is certainly a bit of confusion about the nuances between value and reference semantics, who owns a value and when, how effects are propagated back to values, but I think we can attack the problem with more finesse.<br>&gt;&gt; <br>&gt;&gt; Value types are one of the attractive features of Swift – because of their semantics, mutating algorithms are written in a familiar style but keeping effects limited to your unique reference. I don&#39;t think we should give that up now to address confusion about semantics, out of principle, or in anticipation of new language features. I propose cancelling this change for Swift 3 and continue to allow `var` in the grammar everywhere it occurs in Swift 2.2.<br>&gt; <br>&gt; I disagree. We have a lot of evidence that &#39;if var&#39; confuses people—a lot of users think that &#39;if var&#39; and &#39;var&#39; bindings in case patterns will write back to the original value when this isn&#39;t the case. Classes make this worse, since &#39;if var&#39; *will* seem to work that way when projecting through optional class references, and the value vs reference semantics divide is confusing enough as it is.<br>&gt; Those of us who do understand the semantics don&#39;t save anything either—I at least have to mentally audit any code I see using &#39;if var&#39; to ensure that writeback wasn&#39;t intended by the original author.<br></p><p>Anecdata: I also find myself auditing every non-trivial use of ‘var’.<br></p><p>&gt; Code is read and maintained more often than it&#39;s written, and it&#39;s written by more novices than experts, and &#39;if var&#39; and its friends feel like very expert-writer-centric features to me.<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/a9578d28/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f7d3036e2eaf1283f20f43d62472a29f?s=50"></div><header><strong>Reconsidering SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>David Farler</string> &lt;dfarler at apple.com&gt;<p>January 22, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 22, 2016, at 9:45 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 22, 2016, at 9:26 AM, David Farler via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello everyone,<br>&gt;&gt; <br>&gt;&gt; I&#39;d like to reconsider SE-0003 for Swift 3 and propose cancelling the change in its entirety. After collecting feedback since Swift&#39;s open source launch, I no longer feel this is a good move and there are a few reasons why.<br>&gt;&gt; <br>&gt;&gt; There are two main patterns that the removal penalizes:<br>&gt;&gt; <br>&gt;&gt; - Get-Modify-Reassign<br>&gt;&gt; - Get-Modify-Return<br>&gt;&gt; <br>&gt;&gt; I&#39;ve found that many of the problems with this proposal stem from the uses before and after the &quot;Modify&quot; part, before returning or reassigning with the new value.<br>&gt;&gt; <br>&gt;&gt; I&#39;ve seen a few common responses to the var removal. Consider a `Rectangle` struct:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; struct Rectangle {<br>&gt;&gt; var origin: (x: Double, y: Double)<br>&gt;&gt; var size: (width: Double, height: Double)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Even with mutable variables `origin` and `size`, this pattern would be impossible:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; var selection = getRectangularSelection()<br>&gt;&gt; if var rect = selection?.rect {<br>&gt;&gt; // Mutate `rect` ...<br>&gt;&gt; selection.rect = rect<br>&gt;&gt; }<br>&gt; <br>&gt; These examples don&#39;t make sense to me. None of them mutate the &#39;if var rect&#39; binding at all. Are you sure this is what you meant?<br></p><p>I abbreviated there with // Mutate `rect.<br></p><p>&gt;&gt; So, one might shadow the variable, which is not ideal:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; var selection = getRectangularSelection()<br>&gt;&gt; if let rect = selection?.rect {<br>&gt;&gt; var rect = rect // Not so great<br>&gt;&gt; // Mutate `rect` ...<br>&gt;&gt; selection.rect = rect<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Or, you might make a transformation function on `Rect`:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; struct Rectangle {<br>&gt;&gt; var origin: (x: Double, y: Double)<br>&gt;&gt; var size: (width: Double, height: Double)<br>&gt;&gt; func withOrigin(x: Double, y: Double) -&gt; Rect {<br>&gt;&gt;  var r = self<br>&gt;&gt;  r.origin = (x, y)<br>&gt;&gt;  return r<br>&gt;&gt; }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; This is a much better solution than shadowing but you would need one of these for any property that you want to mutate and I think you&#39;ll agree that it doesn&#39;t scale with the language we have today. This response begs for a kind of initializer that takes all of the fields of the original struct except any that you want to override:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; if let rect = selection?.rect.with(origin: newOrigin) {<br>&gt;&gt; // ...<br>&gt;&gt; }<br>&gt; <br>&gt; You can approximate this today without any new language features:<br>&gt; <br>&gt; protocol Updatable {}<br>&gt; extension Updatable {<br>&gt;  func with&lt;T&gt;(change: (inout T) -&gt; ()) -&gt; T {<br>&gt;    var update = value<br>&gt;    change(&amp;update)<br>&gt;    return update<br>&gt;  }<br>&gt; }<br>&gt; <br>&gt; if let rect =  selection?.rect.with { $0.origin = newOrigin } {<br>&gt; }<br>&gt; <br>&gt; I think this approach generally leads to cleaner code, since it&#39;s not forcing you to bind names to otherwise uninteresting intermediate values.<br></p><p>It&#39;s definitely more explicit but I don&#39;t know if I agree that it&#39;s cleaner with respect to the mutations themselves – it has a lot of the same shape. I also worry about performance with this pattern as is.<br></p><p>&gt;&gt; Straw syntax, but maybe you&#39;ll see something along these lines on swift-evolution in the future, which would provide a clear alternative to direct mutation patterns. Even then, I think having complementary patterns in the language isn&#39;t a bad thing.<br>&gt;&gt; <br>&gt;&gt; These problems come up with the other variable bindings but the one that ended up bothering me the most was `guard var`:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; func transform(selection: Rect?) {<br>&gt;&gt; guard let rect = selection else { return }<br>&gt;&gt; var _rect = rect<br>&gt;&gt; // Mutate `_rect` ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; One of the guard statement&#39;s main purposes is to conditionally bind a value as a peer in its own scope, not an inner scope like if statements. Not having var makes the guard statement much weaker.<br>&gt;&gt; <br>&gt;&gt; There is certainly a bit of confusion about the nuances between value and reference semantics, who owns a value and when, how effects are propagated back to values, but I think we can attack the problem with more finesse.<br>&gt;&gt; <br>&gt;&gt; Value types are one of the attractive features of Swift – because of their semantics, mutating algorithms are written in a familiar style but keeping effects limited to your unique reference. I don&#39;t think we should give that up now to address confusion about semantics, out of principle, or in anticipation of new language features. I propose cancelling this change for Swift 3 and continue to allow `var` in the grammar everywhere it occurs in Swift 2.2.<br>&gt; <br>&gt; I disagree. We have a lot of evidence that &#39;if var&#39; confuses people—a lot of users think that &#39;if var&#39; and &#39;var&#39; bindings in case patterns will write back to the original value when this isn&#39;t the case. Classes make this worse, since &#39;if var&#39; *will* seem to work that way when projecting through optional class references, and the value vs reference semantics divide is confusing enough as it is.<br></p><p>I totally agree that the subtlety of the semantics easily gets lost but I think we can come up with better ways to make them clearer without blowing away a whole class of syntax. I see this confusion as more of a holistic indictment of how we express the semantics rather than just the syntax of `var`. I just don&#39;t feel like removing this now is a slam dunk.<br></p><p>&gt; Those of us who do understand the semantics don&#39;t save anything either—I at least have to mentally audit any code I see using &#39;if var&#39; to ensure that writeback wasn&#39;t intended by the original author. Code is read and maintained more often than it&#39;s written, and it&#39;s written by more novices than experts, and &#39;if var&#39; and its friends feel like very expert-writer-centric features to me.<br>&gt; <br>&gt; -Joe<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/61f57b22/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Reconsidering SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 22, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 22, 2016, at 10:21 AM, David Farler &lt;dfarler at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 22, 2016, at 9:45 AM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 22, 2016, at 9:26 AM, David Farler via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello everyone,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;d like to reconsider SE-0003 for Swift 3 and propose cancelling the change in its entirety. After collecting feedback since Swift&#39;s open source launch, I no longer feel this is a good move and there are a few reasons why.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are two main patterns that the removal penalizes:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Get-Modify-Reassign<br>&gt;&gt;&gt; - Get-Modify-Return<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;ve found that many of the problems with this proposal stem from the uses before and after the &quot;Modify&quot; part, before returning or reassigning with the new value.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;ve seen a few common responses to the var removal. Consider a `Rectangle` struct:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Rectangle {<br>&gt;&gt;&gt; var origin: (x: Double, y: Double)<br>&gt;&gt;&gt; var size: (width: Double, height: Double)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Even with mutable variables `origin` and `size`, this pattern would be impossible:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var selection = getRectangularSelection()<br>&gt;&gt;&gt; if var rect = selection?.rect {<br>&gt;&gt;&gt; // Mutate `rect` ...<br>&gt;&gt;&gt; selection.rect = rect<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; These examples don&#39;t make sense to me. None of them mutate the &#39;if var rect&#39; binding at all. Are you sure this is what you meant?<br>&gt; <br>&gt; I abbreviated there with // Mutate `rect.<br>&gt; <br>&gt;&gt;&gt; So, one might shadow the variable, which is not ideal:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var selection = getRectangularSelection()<br>&gt;&gt;&gt; if let rect = selection?.rect {<br>&gt;&gt;&gt; var rect = rect // Not so great<br>&gt;&gt;&gt; // Mutate `rect` ...<br>&gt;&gt;&gt; selection.rect = rect<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Or, you might make a transformation function on `Rect`:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Rectangle {<br>&gt;&gt;&gt; var origin: (x: Double, y: Double)<br>&gt;&gt;&gt; var size: (width: Double, height: Double)<br>&gt;&gt;&gt; func withOrigin(x: Double, y: Double) -&gt; Rect {<br>&gt;&gt;&gt;  var r = self<br>&gt;&gt;&gt;  r.origin = (x, y)<br>&gt;&gt;&gt;  return r<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a much better solution than shadowing but you would need one of these for any property that you want to mutate and I think you&#39;ll agree that it doesn&#39;t scale with the language we have today. This response begs for a kind of initializer that takes all of the fields of the original struct except any that you want to override:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; if let rect = selection?.rect.with(origin: newOrigin) {<br>&gt;&gt;&gt; // ...<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; You can approximate this today without any new language features:<br>&gt;&gt; <br>&gt;&gt; protocol Updatable {}<br>&gt;&gt; extension Updatable {<br>&gt;&gt;  func with&lt;T&gt;(change: (inout T) -&gt; ()) -&gt; T {<br>&gt;&gt;    var update = value<br>&gt;&gt;    change(&amp;update)<br>&gt;&gt;    return update<br>&gt;&gt;  }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; if let rect =  selection?.rect.with { $0.origin = newOrigin } {<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I think this approach generally leads to cleaner code, since it&#39;s not forcing you to bind names to otherwise uninteresting intermediate values.<br>&gt; <br>&gt; It&#39;s definitely more explicit but I don&#39;t know if I agree that it&#39;s cleaner with respect to the mutations themselves – it has a lot of the same shape. I also worry about performance with this pattern as is.<br></p><p>I wouldn&#39;t expect performance to be an issue, at least in optimized code. If &#39;with&#39; is inlineable and you&#39;re applying &#39;with&#39; to a temporary value, as in this case, the optimizer ought to be able to forward all the copies and ultimately apply the change in-place on the temporary. I agree that the purely library-based approach isn&#39;t beautiful, but I do think there&#39;s a hole here we should address. Assignments and mutating operations are definitely great and notationally familiar for updating values, but I feel like &#39;var&#39; shouldn&#39;t be your only gateway to that notation—it ought to be easier to apply updates in otherwise immutable expressions too.<br></p><p>-Joe<br></p><p>&gt; <br>&gt;&gt;&gt; Straw syntax, but maybe you&#39;ll see something along these lines on swift-evolution in the future, which would provide a clear alternative to direct mutation patterns. Even then, I think having complementary patterns in the language isn&#39;t a bad thing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; These problems come up with the other variable bindings but the one that ended up bothering me the most was `guard var`:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func transform(selection: Rect?) {<br>&gt;&gt;&gt; guard let rect = selection else { return }<br>&gt;&gt;&gt; var _rect = rect<br>&gt;&gt;&gt; // Mutate `_rect` ...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One of the guard statement&#39;s main purposes is to conditionally bind a value as a peer in its own scope, not an inner scope like if statements. Not having var makes the guard statement much weaker.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There is certainly a bit of confusion about the nuances between value and reference semantics, who owns a value and when, how effects are propagated back to values, but I think we can attack the problem with more finesse.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Value types are one of the attractive features of Swift – because of their semantics, mutating algorithms are written in a familiar style but keeping effects limited to your unique reference. I don&#39;t think we should give that up now to address confusion about semantics, out of principle, or in anticipation of new language features. I propose cancelling this change for Swift 3 and continue to allow `var` in the grammar everywhere it occurs in Swift 2.2.<br>&gt;&gt; <br>&gt;&gt; I disagree. We have a lot of evidence that &#39;if var&#39; confuses people—a lot of users think that &#39;if var&#39; and &#39;var&#39; bindings in case patterns will write back to the original value when this isn&#39;t the case. Classes make this worse, since &#39;if var&#39; *will* seem to work that way when projecting through optional class references, and the value vs reference semantics divide is confusing enough as it is.<br>&gt; <br>&gt; I totally agree that the subtlety of the semantics easily gets lost but I think we can come up with better ways to make them clearer without blowing away a whole class of syntax. I see this confusion as more of a holistic indictment of how we express the semantics rather than just the syntax of `var`. I just don&#39;t feel like removing this now is a slam dunk.<br>&gt; <br>&gt;&gt; Those of us who do understand the semantics don&#39;t save anything either—I at least have to mentally audit any code I see using &#39;if var&#39; to ensure that writeback wasn&#39;t intended by the original author. Code is read and maintained more often than it&#39;s written, and it&#39;s written by more novices than experts, and &#39;if var&#39; and its friends feel like very expert-writer-centric features to me.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/5bb94101/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Reconsidering SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 22, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 22, 2016, at 10:21 AM, David Farler &lt;dfarler at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 22, 2016, at 9:45 AM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 22, 2016, at 9:26 AM, David Farler via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello everyone,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;d like to reconsider SE-0003 for Swift 3 and propose cancelling the change in its entirety. After collecting feedback since Swift&#39;s open source launch, I no longer feel this is a good move and there are a few reasons why.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are two main patterns that the removal penalizes:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Get-Modify-Reassign<br>&gt;&gt;&gt; - Get-Modify-Return<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;ve found that many of the problems with this proposal stem from the uses before and after the &quot;Modify&quot; part, before returning or reassigning with the new value.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;ve seen a few common responses to the var removal. Consider a `Rectangle` struct:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Rectangle {<br>&gt;&gt;&gt; var origin: (x: Double, y: Double)<br>&gt;&gt;&gt; var size: (width: Double, height: Double)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Even with mutable variables `origin` and `size`, this pattern would be impossible:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var selection = getRectangularSelection()<br>&gt;&gt;&gt; if var rect = selection?.rect {<br>&gt;&gt;&gt; // Mutate `rect` ...<br>&gt;&gt;&gt; selection.rect = rect<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; These examples don&#39;t make sense to me. None of them mutate the &#39;if var rect&#39; binding at all. Are you sure this is what you meant?<br>&gt; <br>&gt; I abbreviated there with // Mutate `rect.<br></p><p>Ah, sorry, missed that. Years of bad documentation have trained my brain to blank out comments.<br></p><p>-Joe<br></p><p>&gt; <br>&gt;&gt;&gt; So, one might shadow the variable, which is not ideal:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var selection = getRectangularSelection()<br>&gt;&gt;&gt; if let rect = selection?.rect {<br>&gt;&gt;&gt; var rect = rect // Not so great<br>&gt;&gt;&gt; // Mutate `rect` ...<br>&gt;&gt;&gt; selection.rect = rect<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Or, you might make a transformation function on `Rect`:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Rectangle {<br>&gt;&gt;&gt; var origin: (x: Double, y: Double)<br>&gt;&gt;&gt; var size: (width: Double, height: Double)<br>&gt;&gt;&gt; func withOrigin(x: Double, y: Double) -&gt; Rect {<br>&gt;&gt;&gt;  var r = self<br>&gt;&gt;&gt;  r.origin = (x, y)<br>&gt;&gt;&gt;  return r<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a much better solution than shadowing but you would need one of these for any property that you want to mutate and I think you&#39;ll agree that it doesn&#39;t scale with the language we have today. This response begs for a kind of initializer that takes all of the fields of the original struct except any that you want to override:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; if let rect = selection?.rect.with(origin: newOrigin) {<br>&gt;&gt;&gt; // ...<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; You can approximate this today without any new language features:<br>&gt;&gt; <br>&gt;&gt; protocol Updatable {}<br>&gt;&gt; extension Updatable {<br>&gt;&gt;  func with&lt;T&gt;(change: (inout T) -&gt; ()) -&gt; T {<br>&gt;&gt;    var update = value<br>&gt;&gt;    change(&amp;update)<br>&gt;&gt;    return update<br>&gt;&gt;  }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; if let rect =  selection?.rect.with { $0.origin = newOrigin } {<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I think this approach generally leads to cleaner code, since it&#39;s not forcing you to bind names to otherwise uninteresting intermediate values.<br>&gt; <br>&gt; It&#39;s definitely more explicit but I don&#39;t know if I agree that it&#39;s cleaner with respect to the mutations themselves – it has a lot of the same shape. I also worry about performance with this pattern as is.<br>&gt; <br>&gt;&gt;&gt; Straw syntax, but maybe you&#39;ll see something along these lines on swift-evolution in the future, which would provide a clear alternative to direct mutation patterns. Even then, I think having complementary patterns in the language isn&#39;t a bad thing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; These problems come up with the other variable bindings but the one that ended up bothering me the most was `guard var`:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func transform(selection: Rect?) {<br>&gt;&gt;&gt; guard let rect = selection else { return }<br>&gt;&gt;&gt; var _rect = rect<br>&gt;&gt;&gt; // Mutate `_rect` ...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One of the guard statement&#39;s main purposes is to conditionally bind a value as a peer in its own scope, not an inner scope like if statements. Not having var makes the guard statement much weaker.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There is certainly a bit of confusion about the nuances between value and reference semantics, who owns a value and when, how effects are propagated back to values, but I think we can attack the problem with more finesse.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Value types are one of the attractive features of Swift – because of their semantics, mutating algorithms are written in a familiar style but keeping effects limited to your unique reference. I don&#39;t think we should give that up now to address confusion about semantics, out of principle, or in anticipation of new language features. I propose cancelling this change for Swift 3 and continue to allow `var` in the grammar everywhere it occurs in Swift 2.2.<br>&gt;&gt; <br>&gt;&gt; I disagree. We have a lot of evidence that &#39;if var&#39; confuses people—a lot of users think that &#39;if var&#39; and &#39;var&#39; bindings in case patterns will write back to the original value when this isn&#39;t the case. Classes make this worse, since &#39;if var&#39; *will* seem to work that way when projecting through optional class references, and the value vs reference semantics divide is confusing enough as it is. <br>&gt; <br>&gt; I totally agree that the subtlety of the semantics easily gets lost but I think we can come up with better ways to make them clearer without blowing away a whole class of syntax. I see this confusion as more of a holistic indictment of how we express the semantics rather than just the syntax of `var`. I just don&#39;t feel like removing this now is a slam dunk.<br>&gt; <br>&gt;&gt; Those of us who do understand the semantics don&#39;t save anything either—I at least have to mentally audit any code I see using &#39;if var&#39; to ensure that writeback wasn&#39;t intended by the original author. Code is read and maintained more often than it&#39;s written, and it&#39;s written by more novices than experts, and &#39;if var&#39; and its friends feel like very expert-writer-centric features to me.<br>&gt;&gt; <br>&gt;&gt; -Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/672398dd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>Reconsidering SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>January 22, 2016 at 07:00:00pm</p></header><div class="content"><p>+1 for the reversal. Removing var introduces inconsistencies. I never use<br>var in these contexts, but it&#39;s good to have the option.<br>On Fri, Jan 22, 2016 at 1:27 PM Joe Groff via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Jan 22, 2016, at 10:21 AM, David Farler &lt;dfarler at apple.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Jan 22, 2016, at 9:45 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Jan 22, 2016, at 9:26 AM, David Farler via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Hello everyone,<br>&gt;<br>&gt; I&#39;d like to reconsider SE-0003 for Swift 3 and propose cancelling the<br>&gt; change in its entirety. After collecting feedback since Swift&#39;s open source<br>&gt; launch, I no longer feel this is a good move and there are a few reasons<br>&gt; why.<br>&gt;<br>&gt; There are two main patterns that the removal penalizes:<br>&gt;<br>&gt; - Get-Modify-Reassign<br>&gt; - Get-Modify-Return<br>&gt;<br>&gt; I&#39;ve found that many of the problems with this proposal stem from the uses<br>&gt; before and after the &quot;Modify&quot; part, before returning or reassigning with<br>&gt; the new value.<br>&gt;<br>&gt; I&#39;ve seen a few common responses to the var removal. Consider a<br>&gt; `Rectangle` struct:<br>&gt;<br>&gt;<br>&gt; struct Rectangle {<br>&gt; var origin: (x: Double, y: Double)<br>&gt; var size: (width: Double, height: Double)<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Even with mutable variables `origin` and `size`, this pattern would be<br>&gt; impossible:<br>&gt;<br>&gt;<br>&gt; var selection = getRectangularSelection()<br>&gt; if var rect = selection?.rect {<br>&gt; // Mutate `rect` ...<br>&gt; selection.rect = rect<br>&gt; }<br>&gt;<br>&gt;<br>&gt; These examples don&#39;t make sense to me. None of them mutate the &#39;if var<br>&gt; rect&#39; binding at all. Are you sure this is what you meant?<br>&gt;<br>&gt;<br>&gt; I abbreviated there with // Mutate `rect.<br>&gt;<br>&gt;<br>&gt; Ah, sorry, missed that. Years of bad documentation have trained my brain<br>&gt; to blank out comments.<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt;<br>&gt; So, one might shadow the variable, which is not ideal:<br>&gt;<br>&gt;<br>&gt; var selection = getRectangularSelection()<br>&gt; if let rect = selection?.rect {<br>&gt; var rect = rect // Not so great<br>&gt; // Mutate `rect` ...<br>&gt; selection.rect = rect<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Or, you might make a transformation function on `Rect`:<br>&gt;<br>&gt;<br>&gt; struct Rectangle {<br>&gt; var origin: (x: Double, y: Double)<br>&gt; var size: (width: Double, height: Double)<br>&gt; func withOrigin(x: Double, y: Double) -&gt; Rect {<br>&gt;  var r = self<br>&gt;  r.origin = (x, y)<br>&gt;  return r<br>&gt; }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; This is a much better solution than shadowing but you would need one of<br>&gt; these for any property that you want to mutate and I think you&#39;ll agree<br>&gt; that it doesn&#39;t scale with the language we have today. This response begs<br>&gt; for a kind of initializer that takes all of the fields of the original<br>&gt; struct except any that you want to override:<br>&gt;<br>&gt;<br>&gt; if let rect = selection?.rect.with(origin: newOrigin) {<br>&gt; // ...<br>&gt; }<br>&gt;<br>&gt;<br>&gt; You can approximate this today without any new language features:<br>&gt;<br>&gt; protocol Updatable {}<br>&gt; extension Updatable {<br>&gt;  func with&lt;T&gt;(change: (inout T) -&gt; ()) -&gt; T {<br>&gt;    var update = value<br>&gt;    change(&amp;update)<br>&gt;    return update<br>&gt;  }<br>&gt; }<br>&gt;<br>&gt; if let rect =  selection?.rect.with { $0.origin = newOrigin } {<br>&gt; }<br>&gt;<br>&gt; I think this approach generally leads to cleaner code, since it&#39;s not<br>&gt; forcing you to bind names to otherwise uninteresting intermediate values.<br>&gt;<br>&gt;<br>&gt; It&#39;s definitely more explicit but I don&#39;t know if I agree that it&#39;s<br>&gt; cleaner with respect to the mutations themselves – it has a lot of the same<br>&gt; shape. I also worry about performance with this pattern as is.<br>&gt;<br>&gt; Straw syntax, but maybe you&#39;ll see something along these lines on<br>&gt; swift-evolution in the future, which would provide a clear alternative to<br>&gt; direct mutation patterns. Even then, I think having complementary patterns<br>&gt; in the language isn&#39;t a bad thing.<br>&gt;<br>&gt; These problems come up with the other variable bindings but the one that<br>&gt; ended up bothering me the most was `guard var`:<br>&gt;<br>&gt;<br>&gt; func transform(selection: Rect?) {<br>&gt; guard let rect = selection else { return }<br>&gt; var _rect = rect<br>&gt; // Mutate `_rect` ...<br>&gt; }<br>&gt;<br>&gt;<br>&gt; One of the guard statement&#39;s main purposes is to conditionally bind a<br>&gt; value as a peer in its own scope, not an inner scope like if statements.<br>&gt; Not having var makes the guard statement much weaker.<br>&gt;<br>&gt; There is certainly a bit of confusion about the nuances between value and<br>&gt; reference semantics, who owns a value and when, how effects are propagated<br>&gt; back to values, but I think we can attack the problem with more finesse.<br>&gt;<br>&gt; Value types are one of the attractive features of Swift – because of their<br>&gt; semantics, mutating algorithms are written in a familiar style but keeping<br>&gt; effects limited to your unique reference. I don&#39;t think we should give that<br>&gt; up now to address confusion about semantics, out of principle, or in<br>&gt; anticipation of new language features. I propose cancelling this change for<br>&gt; Swift 3 and continue to allow `var` in the grammar everywhere it occurs in<br>&gt; Swift 2.2.<br>&gt;<br>&gt;<br>&gt; I disagree. We have a lot of evidence that &#39;if var&#39; confuses people—a lot<br>&gt; of users think that &#39;if var&#39; and &#39;var&#39; bindings in case patterns will write<br>&gt; back to the original value when this isn&#39;t the case. Classes make this<br>&gt; worse, since &#39;if var&#39; *will* seem to work that way when projecting through<br>&gt; optional class references, and the value vs reference semantics divide is<br>&gt; confusing enough as it is.<br>&gt;<br>&gt;<br>&gt; I totally agree that the subtlety of the semantics easily gets lost but I<br>&gt; think we can come up with better ways to make them clearer without blowing<br>&gt; away a whole class of syntax. I see this confusion as more of a holistic<br>&gt; indictment of how we express the semantics rather than just the syntax of<br>&gt; `var`. I just don&#39;t feel like removing this now is a slam dunk.<br>&gt;<br>&gt; Those of us who do understand the semantics don&#39;t save anything either—I<br>&gt; at least have to mentally audit any code I see using &#39;if var&#39; to ensure<br>&gt; that writeback wasn&#39;t intended by the original author. Code is read and<br>&gt; maintained more often than it&#39;s written, and it&#39;s written by more novices<br>&gt; than experts, and &#39;if var&#39; and its friends feel like very<br>&gt; expert-writer-centric features to me.<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/e7c5aacc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Reconsidering SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>January 22, 2016 at 01:00:00pm</p></header><div class="content"><p>-1 for the reversal, because I have been burned by this myself.<br></p><p>The var parameters, cases, and “if var” could all be interpreted as either making a copy or having inout semantics. The problem is that the syntax doesn’t make the behavior explicit. IMHO you should be striving not for a reversal but for a counterproposal.<br></p><p>-DW<br></p><p>&gt; On Jan 22, 2016, at 12:31 PM, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1 for the reversal. Removing var introduces inconsistencies. I never use var in these contexts, but it&#39;s good to have the option.<br>&gt; On Fri, Jan 22, 2016 at 1:27 PM Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; On Jan 22, 2016, at 10:21 AM, David Farler &lt;dfarler at apple.com &lt;mailto:dfarler at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 22, 2016, at 9:45 AM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 22, 2016, at 9:26 AM, David Farler via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hello everyone,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;d like to reconsider SE-0003 for Swift 3 and propose cancelling the change in its entirety. After collecting feedback since Swift&#39;s open source launch, I no longer feel this is a good move and there are a few reasons why.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are two main patterns that the removal penalizes:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Get-Modify-Reassign<br>&gt;&gt;&gt;&gt; - Get-Modify-Return<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;ve found that many of the problems with this proposal stem from the uses before and after the &quot;Modify&quot; part, before returning or reassigning with the new value.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;ve seen a few common responses to the var removal. Consider a `Rectangle` struct:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct Rectangle {<br>&gt;&gt;&gt;&gt; var origin: (x: Double, y: Double)<br>&gt;&gt;&gt;&gt; var size: (width: Double, height: Double)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Even with mutable variables `origin` and `size`, this pattern would be impossible:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var selection = getRectangularSelection()<br>&gt;&gt;&gt;&gt; if var rect = selection?.rect {<br>&gt;&gt;&gt;&gt; // Mutate `rect` ...<br>&gt;&gt;&gt;&gt; selection.rect = rect<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; These examples don&#39;t make sense to me. None of them mutate the &#39;if var rect&#39; binding at all. Are you sure this is what you meant?<br>&gt;&gt; <br>&gt;&gt; I abbreviated there with // Mutate `rect.<br>&gt; <br>&gt; Ah, sorry, missed that. Years of bad documentation have trained my brain to blank out comments.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; So, one might shadow the variable, which is not ideal:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var selection = getRectangularSelection()<br>&gt;&gt;&gt;&gt; if let rect = selection?.rect {<br>&gt;&gt;&gt;&gt; var rect = rect // Not so great<br>&gt;&gt;&gt;&gt; // Mutate `rect` ...<br>&gt;&gt;&gt;&gt; selection.rect = rect<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Or, you might make a transformation function on `Rect`:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct Rectangle {<br>&gt;&gt;&gt;&gt; var origin: (x: Double, y: Double)<br>&gt;&gt;&gt;&gt; var size: (width: Double, height: Double)<br>&gt;&gt;&gt;&gt; func withOrigin(x: Double, y: Double) -&gt; Rect {<br>&gt;&gt;&gt;&gt;  var r = self<br>&gt;&gt;&gt;&gt;  r.origin = (x, y)<br>&gt;&gt;&gt;&gt;  return r<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is a much better solution than shadowing but you would need one of these for any property that you want to mutate and I think you&#39;ll agree that it doesn&#39;t scale with the language we have today. This response begs for a kind of initializer that takes all of the fields of the original struct except any that you want to override:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; if let rect = selection?.rect.with(origin: newOrigin) {<br>&gt;&gt;&gt;&gt; // ...<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You can approximate this today without any new language features:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol Updatable {}<br>&gt;&gt;&gt; extension Updatable {<br>&gt;&gt;&gt;  func with&lt;T&gt;(change: (inout T) -&gt; ()) -&gt; T {<br>&gt;&gt;&gt;    var update = value<br>&gt;&gt;&gt;    change(&amp;update)<br>&gt;&gt;&gt;    return update<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; if let rect =  selection?.rect.with { $0.origin = newOrigin } {<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think this approach generally leads to cleaner code, since it&#39;s not forcing you to bind names to otherwise uninteresting intermediate values.<br>&gt;&gt; <br>&gt;&gt; It&#39;s definitely more explicit but I don&#39;t know if I agree that it&#39;s cleaner with respect to the mutations themselves – it has a lot of the same shape. I also worry about performance with this pattern as is.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; Straw syntax, but maybe you&#39;ll see something along these lines on swift-evolution in the future, which would provide a clear alternative to direct mutation patterns. Even then, I think having complementary patterns in the language isn&#39;t a bad thing.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; These problems come up with the other variable bindings but the one that ended up bothering me the most was `guard var`:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func transform(selection: Rect?) {<br>&gt;&gt;&gt;&gt; guard let rect = selection else { return }<br>&gt;&gt;&gt;&gt; var _rect = rect<br>&gt;&gt;&gt;&gt; // Mutate `_rect` ...<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One of the guard statement&#39;s main purposes is to conditionally bind a value as a peer in its own scope, not an inner scope like if statements. Not having var makes the guard statement much weaker.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There is certainly a bit of confusion about the nuances between value and reference semantics, who owns a value and when, how effects are propagated back to values, but I think we can attack the problem with more finesse.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Value types are one of the attractive features of Swift – because of their semantics, mutating algorithms are written in a familiar style but keeping effects limited to your unique reference. I don&#39;t think we should give that up now to address confusion about semantics, out of principle, or in anticipation of new language features. I propose cancelling this change for Swift 3 and continue to allow `var` in the grammar everywhere it occurs in Swift 2.2.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I disagree. We have a lot of evidence that &#39;if var&#39; confuses people—a lot of users think that &#39;if var&#39; and &#39;var&#39; bindings in case patterns will write back to the original value when this isn&#39;t the case. Classes make this worse, since &#39;if var&#39; *will* seem to work that way when projecting through optional class references, and the value vs reference semantics divide is confusing enough as it is. <br>&gt;&gt; <br>&gt;&gt; I totally agree that the subtlety of the semantics easily gets lost but I think we can come up with better ways to make them clearer without blowing away a whole class of syntax. I see this confusion as more of a holistic indictment of how we express the semantics rather than just the syntax of `var`. I just don&#39;t feel like removing this now is a slam dunk.<br>&gt;&gt; <br>&gt;&gt;&gt; Those of us who do understand the semantics don&#39;t save anything either—I at least have to mentally audit any code I see using &#39;if var&#39; to ensure that writeback wasn&#39;t intended by the original author. Code is read and maintained more often than it&#39;s written, and it&#39;s written by more novices than experts, and &#39;if var&#39; and its friends feel like very expert-writer-centric features to me.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/493b99c9/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Reconsidering SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January 25, 2016 at 06:00:00pm</p></header><div class="content"><p>-1 for me. I think it is clearer if people have to manually copy into a var that copy semantics are in use.<br></p><p>Sent from my iPad<br></p><p>&gt; On 23 Jan 2016, at 5:27 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Jan 22, 2016, at 10:21 AM, David Farler &lt;dfarler at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 22, 2016, at 9:45 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 22, 2016, at 9:26 AM, David Farler via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hello everyone,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;d like to reconsider SE-0003 for Swift 3 and propose cancelling the change in its entirety. After collecting feedback since Swift&#39;s open source launch, I no longer feel this is a good move and there are a few reasons why.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are two main patterns that the removal penalizes:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Get-Modify-Reassign<br>&gt;&gt;&gt;&gt; - Get-Modify-Return<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;ve found that many of the problems with this proposal stem from the uses before and after the &quot;Modify&quot; part, before returning or reassigning with the new value.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;ve seen a few common responses to the var removal. Consider a `Rectangle` struct:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct Rectangle {<br>&gt;&gt;&gt;&gt; var origin: (x: Double, y: Double)<br>&gt;&gt;&gt;&gt; var size: (width: Double, height: Double)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Even with mutable variables `origin` and `size`, this pattern would be impossible:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var selection = getRectangularSelection()<br>&gt;&gt;&gt;&gt; if var rect = selection?.rect {<br>&gt;&gt;&gt;&gt; // Mutate `rect` ...<br>&gt;&gt;&gt;&gt; selection.rect = rect<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; These examples don&#39;t make sense to me. None of them mutate the &#39;if var rect&#39; binding at all. Are you sure this is what you meant?<br>&gt;&gt; <br>&gt;&gt; I abbreviated there with // Mutate `rect.<br>&gt; <br>&gt; Ah, sorry, missed that. Years of bad documentation have trained my brain to blank out comments.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; So, one might shadow the variable, which is not ideal:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var selection = getRectangularSelection()<br>&gt;&gt;&gt;&gt; if let rect = selection?.rect {<br>&gt;&gt;&gt;&gt; var rect = rect // Not so great<br>&gt;&gt;&gt;&gt; // Mutate `rect` ...<br>&gt;&gt;&gt;&gt; selection.rect = rect<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Or, you might make a transformation function on `Rect`:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct Rectangle {<br>&gt;&gt;&gt;&gt; var origin: (x: Double, y: Double)<br>&gt;&gt;&gt;&gt; var size: (width: Double, height: Double)<br>&gt;&gt;&gt;&gt; func withOrigin(x: Double, y: Double) -&gt; Rect {<br>&gt;&gt;&gt;&gt;  var r = self<br>&gt;&gt;&gt;&gt;  r.origin = (x, y)<br>&gt;&gt;&gt;&gt;  return r<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is a much better solution than shadowing but you would need one of these for any property that you want to mutate and I think you&#39;ll agree that it doesn&#39;t scale with the language we have today. This response begs for a kind of initializer that takes all of the fields of the original struct except any that you want to override:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; if let rect = selection?.rect.with(origin: newOrigin) {<br>&gt;&gt;&gt;&gt; // ...<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You can approximate this today without any new language features:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol Updatable {}<br>&gt;&gt;&gt; extension Updatable {<br>&gt;&gt;&gt;  func with&lt;T&gt;(change: (inout T) -&gt; ()) -&gt; T {<br>&gt;&gt;&gt;    var update = value<br>&gt;&gt;&gt;    change(&amp;update)<br>&gt;&gt;&gt;    return update<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; if let rect =  selection?.rect.with { $0.origin = newOrigin } {<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think this approach generally leads to cleaner code, since it&#39;s not forcing you to bind names to otherwise uninteresting intermediate values.<br>&gt;&gt; <br>&gt;&gt; It&#39;s definitely more explicit but I don&#39;t know if I agree that it&#39;s cleaner with respect to the mutations themselves – it has a lot of the same shape. I also worry about performance with this pattern as is.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; Straw syntax, but maybe you&#39;ll see something along these lines on swift-evolution in the future, which would provide a clear alternative to direct mutation patterns. Even then, I think having complementary patterns in the language isn&#39;t a bad thing.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; These problems come up with the other variable bindings but the one that ended up bothering me the most was `guard var`:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func transform(selection: Rect?) {<br>&gt;&gt;&gt;&gt; guard let rect = selection else { return }<br>&gt;&gt;&gt;&gt; var _rect = rect<br>&gt;&gt;&gt;&gt; // Mutate `_rect` ...<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One of the guard statement&#39;s main purposes is to conditionally bind a value as a peer in its own scope, not an inner scope like if statements. Not having var makes the guard statement much weaker.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There is certainly a bit of confusion about the nuances between value and reference semantics, who owns a value and when, how effects are propagated back to values, but I think we can attack the problem with more finesse.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Value types are one of the attractive features of Swift – because of their semantics, mutating algorithms are written in a familiar style but keeping effects limited to your unique reference. I don&#39;t think we should give that up now to address confusion about semantics, out of principle, or in anticipation of new language features. I propose cancelling this change for Swift 3 and continue to allow `var` in the grammar everywhere it occurs in Swift 2.2.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I disagree. We have a lot of evidence that &#39;if var&#39; confuses people—a lot of users think that &#39;if var&#39; and &#39;var&#39; bindings in case patterns will write back to the original value when this isn&#39;t the case. Classes make this worse, since &#39;if var&#39; *will* seem to work that way when projecting through optional class references, and the value vs reference semantics divide is confusing enough as it is. <br>&gt;&gt; <br>&gt;&gt; I totally agree that the subtlety of the semantics easily gets lost but I think we can come up with better ways to make them clearer without blowing away a whole class of syntax. I see this confusion as more of a holistic indictment of how we express the semantics rather than just the syntax of `var`. I just don&#39;t feel like removing this now is a slam dunk.<br>&gt;&gt; <br>&gt;&gt;&gt; Those of us who do understand the semantics don&#39;t save anything either—I at least have to mentally audit any code I see using &#39;if var&#39; to ensure that writeback wasn&#39;t intended by the original author. Code is read and maintained more often than it&#39;s written, and it&#39;s written by more novices than experts, and &#39;if var&#39; and its friends feel like very expert-writer-centric features to me.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160125/cfe15567/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Reconsidering SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January 28, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; We have a lot of evidence that &#39;if var&#39; confuses people—a lot of users think that &#39;if var&#39; and &#39;var&#39; bindings in case patterns will write back to the original value when this isn&#39;t the case.<br></p><p>Can we address this with a diagnostic?<br></p><p>	var bar: Int? = 1<br>	if var foo = bar {<br>		foo += 1	// Warning: Value is never used after modification (foo is a copy, not an alias)<br>	}<br>	print(bar)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Reconsidering SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 28, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 28, 2016, at 12:43 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; We have a lot of evidence that &#39;if var&#39; confuses people—a lot of users think that &#39;if var&#39; and &#39;var&#39; bindings in case patterns will write back to the original value when this isn&#39;t the case.<br>&gt; <br>&gt; Can we address this with a diagnostic?<br>&gt; <br>&gt; 	var bar: Int? = 1<br>&gt; 	if var foo = bar {<br>&gt; 		foo += 1	// Warning: Value is never used after modification (foo is a copy, not an alias)<br>&gt; 	}<br>&gt; 	print(bar)<br></p><p>Good idea.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Reconsidering SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>January 28, 2016 at 11:00:00am</p></header><div class="content"><p>Do you realize how much confusion it would save if Swift just went with<br></p><p>if bind foo = bar {...}<br></p><p>with let semantics? <br></p><p>-- Erica<br></p><p>&gt; On Jan 28, 2016, at 11:03 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 28, 2016, at 12:43 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; We have a lot of evidence that &#39;if var&#39; confuses people—a lot of users think that &#39;if var&#39; and &#39;var&#39; bindings in case patterns will write back to the original value when this isn&#39;t the case.<br>&gt;&gt; <br>&gt;&gt; Can we address this with a diagnostic?<br>&gt;&gt; <br>&gt;&gt; 	var bar: Int? = 1<br>&gt;&gt; 	if var foo = bar {<br>&gt;&gt; 		foo += 1	// Warning: Value is never used after modification (foo is a copy, not an alias)<br>&gt;&gt; 	}<br>&gt;&gt; 	print(bar)<br>&gt; <br>&gt; Good idea.<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Reconsidering SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>January 28, 2016 at 10:00:00am</p></header><div class="content"><p>if bind foo {<br>       // foo is non-optional in here<br>   }<br></p><p>   somethingAsync { [weak self] in<br>       guard bind self else { return }<br>       // ...<br>   }<br></p><p>Elegant when you want to rebind the same name!<br></p><p>Jacob<br></p><p>On Thu, Jan 28, 2016 at 10:05 AM, Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Do you realize how much confusion it would save if Swift just went with<br>&gt;<br>&gt; if bind foo = bar {...}<br>&gt;<br>&gt; with let semantics?<br>&gt;<br>&gt; -- Erica<br>&gt;<br>&gt; &gt; On Jan 28, 2016, at 11:03 AM, Joe Groff via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On Jan 28, 2016, at 12:43 AM, Brent Royal-Gordon &lt;<br>&gt; brent at architechies.com&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; We have a lot of evidence that &#39;if var&#39; confuses people—a lot of users<br>&gt; think that &#39;if var&#39; and &#39;var&#39; bindings in case patterns will write back to<br>&gt; the original value when this isn&#39;t the case.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Can we address this with a diagnostic?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;      var bar: Int? = 1<br>&gt; &gt;&gt;      if var foo = bar {<br>&gt; &gt;&gt;              foo += 1        // Warning: Value is never used after<br>&gt; modification (foo is a copy, not an alias)<br>&gt; &gt;&gt;      }<br>&gt; &gt;&gt;      print(bar)<br>&gt; &gt;<br>&gt; &gt; Good idea.<br>&gt; &gt;<br>&gt; &gt; -Joe<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/5ee5e272/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Reconsidering SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January 29, 2016 at 06:00:00am</p></header><div class="content"><p>This is called flow typing in Ceylon and they are using &quot;exists&quot; for that case but testing for conformance with &quot;is&quot; works just the same way there. The latter is of importance because the common use of union types in Ceylon.<br></p><p>if exists foo {<br>        // foo is non-optional here<br>}<br></p><p>if foo is String {<br>        // foo is of type String here<br>}<br></p><p>-Thorsten<br></p><p>&gt; Am 28.01.2016 um 19:08 schrieb Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt;    if bind foo {<br>&gt;        // foo is non-optional in here<br>&gt;    }<br>&gt; <br>&gt;    somethingAsync { [weak self] in<br>&gt;        guard bind self else { return }<br>&gt;        // ...<br>&gt;    }<br>&gt; <br>&gt; Elegant when you want to rebind the same name!<br>&gt; <br>&gt; Jacob<br>&gt; <br>&gt;&gt; On Thu, Jan 28, 2016 at 10:05 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Do you realize how much confusion it would save if Swift just went with<br>&gt;&gt; <br>&gt;&gt; if bind foo = bar {...}<br>&gt;&gt; <br>&gt;&gt; with let semantics?<br>&gt;&gt; <br>&gt;&gt; -- Erica<br>&gt;&gt; <br>&gt;&gt; &gt; On Jan 28, 2016, at 11:03 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; On Jan 28, 2016, at 12:43 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; We have a lot of evidence that &#39;if var&#39; confuses people—a lot of users think that &#39;if var&#39; and &#39;var&#39; bindings in case patterns will write back to the original value when this isn&#39;t the case.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Can we address this with a diagnostic?<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;      var bar: Int? = 1<br>&gt;&gt; &gt;&gt;      if var foo = bar {<br>&gt;&gt; &gt;&gt;              foo += 1        // Warning: Value is never used after modification (foo is a copy, not an alias)<br>&gt;&gt; &gt;&gt;      }<br>&gt;&gt; &gt;&gt;      print(bar)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Good idea.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; -Joe<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/f46eb47c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>Reconsidering SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>January 29, 2016 at 01:00:00pm</p></header><div class="content"><p>I prefer this style over “if let” &amp; “if var”.   I don’t know it is my aversion to “let” because it brings back memories of a language I would prefer to forget (BASIC), but I find the scattering of lets in other statements/expressions to a we bit annoying (especially in pattern matching).  <br></p><p><br>&gt; On 2016-01-29, at 12:54:12, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This is called flow typing in Ceylon and they are using &quot;exists&quot; for that case but testing for conformance with &quot;is&quot; works just the same way there. The latter is of importance because the common use of union types in Ceylon.<br>&gt; <br>&gt; if exists foo {<br>&gt;         // foo is non-optional here<br>&gt; }<br>&gt; <br>&gt; if foo is String {<br>&gt;         // foo is of type String here<br>&gt; }<br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; Am 28.01.2016 um 19:08 schrieb Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; <br>&gt;&gt;    if bind foo {<br>&gt;&gt;        // foo is non-optional in here<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    somethingAsync { [weak self] in<br>&gt;&gt;        guard bind self else { return }<br>&gt;&gt;        // ...<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; Elegant when you want to rebind the same name!<br>&gt;&gt; <br>&gt;&gt; Jacob<br>&gt;&gt; <br>&gt;&gt; On Thu, Jan 28, 2016 at 10:05 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Do you realize how much confusion it would save if Swift just went with<br>&gt;&gt; <br>&gt;&gt; if bind foo = bar {...}<br>&gt;&gt; <br>&gt;&gt; with let semantics?<br>&gt;&gt; <br>&gt;&gt; -- Erica<br>&gt;&gt; <br>&gt;&gt; &gt; On Jan 28, 2016, at 11:03 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; On Jan 28, 2016, at 12:43 AM, Brent Royal-Gordon &lt;brent at architechies.com &lt;mailto:brent at architechies.com&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; We have a lot of evidence that &#39;if var&#39; confuses people—a lot of users think that &#39;if var&#39; and &#39;var&#39; bindings in case patterns will write back to the original value when this isn&#39;t the case.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Can we address this with a diagnostic?<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;      var bar: Int? = 1<br>&gt;&gt; &gt;&gt;      if var foo = bar {<br>&gt;&gt; &gt;&gt;              foo += 1        // Warning: Value is never used after modification (foo is a copy, not an alias)<br>&gt;&gt; &gt;&gt;      }<br>&gt;&gt; &gt;&gt;      print(bar)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Good idea.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; -Joe<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/7bf8990e/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>Reconsidering SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>January 29, 2016 at 07:00:00pm</p></header><div class="content"><p>I think my last response was vague and not in response to this email but I really like this formatting better (though it is probably too late).   <br></p><p>If you really want to hack in mutable state in the inner part — then it would be a matter of <br></p><p>if exists foo {<br>	var bar = foo // non-optional<br>	...<br>}<br></p><p>But I don’t think I would write new code like that anyways.<br></p><p><br></p><p>&gt; On 2016-01-29, at 12:54:12, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This is called flow typing in Ceylon and they are using &quot;exists&quot; for that case but testing for conformance with &quot;is&quot; works just the same way there. The latter is of importance because the common use of union types in Ceylon.<br>&gt; <br>&gt; if exists foo {<br>&gt;         // foo is non-optional here<br>&gt; }<br>&gt; <br>&gt; if foo is String {<br>&gt;         // foo is of type String here<br>&gt; }<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/68d61402/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Reconsidering SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 28, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 28, 2016, at 10:05 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; Do you realize how much confusion it would save if Swift just went with<br>&gt; <br>&gt; if bind foo = bar {...}<br>&gt; <br>&gt; with let semantics? <br></p><p>I don&#39;t see how changing the keyword changes anything, no.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Reconsidering SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>January 28, 2016 at 11:00:00am</p></header><div class="content"><p>Only in conditional binding, to clearly differentiate it from non-conditional binding. One of these things unwraps optionals. One of these does not. They both use the same keyword. It&#39;s a stumbling block for a lot of new devs.<br></p><p>And I like where Jacob took it too.<br></p><p>-- E<br></p><p>&gt; On Jan 28, 2016, at 11:09 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 28, 2016, at 10:05 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Do you realize how much confusion it would save if Swift just went with<br>&gt;&gt; <br>&gt;&gt; if bind foo = bar {...}<br>&gt;&gt; <br>&gt;&gt; with let semantics? <br>&gt; <br>&gt; I don&#39;t see how changing the keyword changes anything, no.<br>&gt; <br>&gt; -Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Reconsidering SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 28, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 28, 2016, at 10:25 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; Only in conditional binding, to clearly differentiate it from non-conditional binding. One of these things unwraps optionals. One of these does not. They both use the same keyword. It&#39;s a stumbling block for a lot of new devs.<br>&gt; <br>&gt; And I like where Jacob took it too.<br></p><p>Maybe. Were &#39;if let&#39; not already drilled into developers&#39; minds, IMO it&#39;d be nice to replace it by &#39;if case _?&#39;. We had tried that internally and got a lot of backlash though.<br></p><p>-Joe<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Reconsidering SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January 31, 2016 at 12:00:00pm</p></header><div class="content"><p>+1 for `bind`. I dislike the use of the same keyword for two different<br>purposes. Also `if let x = x` is confusing for beginners (by beginners I<br>mean beginners to Swift not to programming) since:<br></p><p>  1. `let x = x` is, outside of binding, an error.<br>  2. Beginners quite rightly say &quot;`x` already equals `x`!&quot;.<br></p><p>On Friday, 29 January 2016, Joe Groff via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Jan 28, 2016, at 10:05 AM, Erica Sadun &lt;erica at ericasadun.com<br>&gt; &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Do you realize how much confusion it would save if Swift just went with<br>&gt; &gt;<br>&gt; &gt; if bind foo = bar {...}<br>&gt; &gt;<br>&gt; &gt; with let semantics?<br>&gt;<br>&gt; I don&#39;t see how changing the keyword changes anything, no.<br>&gt;<br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160131/b4be7abe/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ab486d7597af4cfe0be33a762150848?s=50"></div><header><strong>Reconsidering SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Dany St-Amant</string> &lt;dsa.mls at icloud.com&gt;<p>January 30, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; Le 30 janv. 2016 à 20:50, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; +1 for `bind`. I dislike the use of the same keyword for two different purposes. Also `if let x = x` is confusing for beginners (by beginners I mean beginners to Swift not to programming) since:<br>&gt; <br>&gt;   1. `let x = x` is, outside of binding, an error. <br>&gt;   2. Beginners quite rightly say &quot;`x` already equals `x`!&quot;.<br></p><p>For me, the keyword bind should not be limited to this kind of nil check. but act a bit like an alias. Unfortunately, I cannot come up with nice Swift example; and not sure yet if an aliasing concept is applicable to Swift. For example in C, it is quite common to do:<br></p><p>myStructType *myStruct = (*myStruct) someVoidPtr;<br></p><p>Or you can do<br></p><p>myStructType *myStruct = &amp;nested.structs.array[index];<br></p><p>So that you can use the short name for the heavy work. For read-only operation, the let keyword can be used in that way; but there’s seems to be no easy way if one want to mutate the original data (you are welcome to prove me wrong, my Swiftness is limited)<br></p><p>On the &quot;let x = x&quot; being illegal outside binding, maybe we should make it illegal too for optional binding, especially that the optional binding with var will be reintroduced. This shadowing make it simple when you change your variable from non-optional to optional, as you just wrap the code in the &quot;if let x=x&quot;, re-indent the code and voilà; if prohibited one will need to rename all the x by y inside the re-indented code. But such shadowing   as its detractor, after all troubles hide in the shadow. But I’ll leave this to be discuss in another thread if someone fells like starting a long and painful discussion, with three battle camps: should allow let x=x, should be an error, should be a warning.<br></p><p>Dany<br></p><p>&gt; On Friday, 29 January 2016, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; &gt; On Jan 28, 2016, at 10:05 AM, Erica Sadun &lt;erica at ericasadun.com &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Do you realize how much confusion it would save if Swift just went with<br>&gt; &gt;<br>&gt; &gt; if bind foo = bar {...}<br>&gt; &gt;<br>&gt; &gt; with let semantics?<br>&gt; <br>&gt; I don&#39;t see how changing the keyword changes anything, no.<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; -- <br>&gt;   -- Howard.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160130/6e35f273/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Reconsidering SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>January 31, 2016 at 12:00:00pm</p></header><div class="content"><p>-1 on “bind” for two reasons:<br></p><p>(1) Right now, variable/property declarations always use the word “let” or “var” (with the exception of the for loop iterator). That’s a nice consistency.<br></p><p>(2) It’s not clear on reading whether “bind” means “new declaration” or “alias.” It vaguely suggests I might expect this to work:<br></p><p>	let x = 1<br>	bind y = x<br>	y += 10<br>	// x == 11<br></p><p>I do also find “if let” a bit awkward because ungrammatical of it how is — and this is doubly so for “if case” — but I don’t find “if bind&quot; any better on this front. Ultimately, despite their English grammar illogic, “if let” and even “if let x = x” make enough programming language sense that I accepted them, took them as a Swift idioms, and got comfortable with them pretty quickly.<br></p><p>Cheers, P<br></p><p><br>&gt; On Jan 30, 2016, at 7:50 PM, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1 for `bind`. I dislike the use of the same keyword for two different purposes. Also `if let x = x` is confusing for beginners (by beginners I mean beginners to Swift not to programming) since:<br>&gt; <br>&gt;   1. `let x = x` is, outside of binding, an error. <br>&gt;   2. Beginners quite rightly say &quot;`x` already equals `x`!&quot;.<br>&gt; <br>&gt; On Friday, 29 January 2016, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; &gt; On Jan 28, 2016, at 10:05 AM, Erica Sadun &lt;erica at ericasadun.com &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Do you realize how much confusion it would save if Swift just went with<br>&gt; &gt;<br>&gt; &gt; if bind foo = bar {...}<br>&gt; &gt;<br>&gt; &gt; with let semantics?<br>&gt; <br>&gt; I don&#39;t see how changing the keyword changes anything, no.<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; -- <br>&gt;   -- Howard.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160131/415dadb1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Reconsidering SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>January 31, 2016 at 11:00:00pm</p></header><div class="content"><p>I would expect that something called &quot;bind&quot; wouldn&#39;t have the same meaning as var/let:<br></p><p>bind x = a.property.with.a.long.path<br>x = 42<br>// a.property.with.a.long.path == 42 =&gt; true<br></p><p>That would actually be useful, especially as there is no obvious way to create references to structs… but renaming var/let does not make sense to me.<br></p><p>Tino<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Reconsidering SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February  1, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jan 30, 2016, at 5:50 PM, Howard Lovatt &lt;howard.lovatt at gmail.com&gt; wrote:<br>&gt; <br>&gt; +1 for `bind`. I dislike the use of the same keyword for two different purposes. Also `if let x = x` is confusing for beginners (by beginners I mean beginners to Swift not to programming) since:<br>&gt; <br>&gt;   1. `let x = x` is, outside of binding, an error. <br>&gt;   2. Beginners quite rightly say &quot;`x` already equals `x`!&quot;.<br></p><p>If you all are serious about this, I think you should start a new thread about it.<br></p><p>-Joe<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d9dbc0dfeb74eab8dd9bbd9cbd84680?s=50"></div><header><strong>Reconsidering SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Jose Cheyo Jimenez</string> &lt;cheyo at masters3d.com&gt;<p>January 22, 2016 at 10:00:00am</p></header><div class="content"><p>+1<br></p><p>I had filed SR-534 to add shadow variables so that code would compile. The<br>problem is more apparent when the code uses structs heavily, in my<br>mind, forcing only let binding, might even encourage the use of classes so<br>that the let binding works for mutation. In an if let binding I already use<br>the same name for the binding and adding a shadow variable makes code sort<br>of ugly and repetitive for value optional types.<br></p><p>If let foo = foo, bar = bar {<br>    var foo = foo // don&#39;t need for classes<br>    var bar = bar //<br>         foo.mutare()<br>         bar.mutate()<br>}<br></p><p><br></p><p>On Friday, January 22, 2016, David Farler via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hello everyone,<br>&gt;<br>&gt; I&#39;d like to reconsider SE-0003 for Swift 3 and propose cancelling the<br>&gt; change in its entirety. After collecting feedback since Swift&#39;s open source<br>&gt; launch, I no longer feel this is a good move and there are a few reasons<br>&gt; why.<br>&gt;<br>&gt; There are two main patterns that the removal penalizes:<br>&gt;<br>&gt; - Get-Modify-Reassign<br>&gt; - Get-Modify-Return<br>&gt;<br>&gt; I&#39;ve found that many of the problems with this proposal stem from the uses<br>&gt; before and after the &quot;Modify&quot; part, before returning or reassigning with<br>&gt; the new value.<br>&gt;<br>&gt; I&#39;ve seen a few common responses to the var removal. Consider a<br>&gt; `Rectangle` struct:<br>&gt;<br>&gt;<br>&gt; struct Rectangle {<br>&gt;  var origin: (x: Double, y: Double)<br>&gt;  var size: (width: Double, height: Double)<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Even with mutable variables `origin` and `size`, this pattern would be<br>&gt; impossible:<br>&gt;<br>&gt;<br>&gt; var selection = getRectangularSelection()<br>&gt; if var rect = selection?.rect {<br>&gt;  // Mutate `rect` ...<br>&gt;  selection.rect = rect<br>&gt; }<br>&gt;<br>&gt;<br>&gt; So, one might shadow the variable, which is not ideal:<br>&gt;<br>&gt;<br>&gt; var selection = getRectangularSelection()<br>&gt; if let rect = selection?.rect {<br>&gt;  var rect = rect // Not so great<br>&gt;  // Mutate `rect` ...<br>&gt;  selection.rect = rect<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Or, you might make a transformation function on `Rect`:<br>&gt;<br>&gt;<br>&gt; struct Rectangle {<br>&gt;  var origin: (x: Double, y: Double)<br>&gt;  var size: (width: Double, height: Double)<br>&gt;  func withOrigin(x: Double, y: Double) -&gt; Rect {<br>&gt;    var r = self<br>&gt;    r.origin = (x, y)<br>&gt;    return r<br>&gt;  }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; This is a much better solution than shadowing but you would need one of<br>&gt; these for any property that you want to mutate and I think you&#39;ll agree<br>&gt; that it doesn&#39;t scale with the language we have today. This response begs<br>&gt; for a kind of initializer that takes all of the fields of the original<br>&gt; struct except any that you want to override:<br>&gt;<br>&gt;<br>&gt; if let rect = selection?.rect.with(origin: newOrigin) {<br>&gt;  // ...<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Straw syntax, but maybe you&#39;ll see something along these lines on<br>&gt; swift-evolution in the future, which would provide a clear alternative to<br>&gt; direct mutation patterns. Even then, I think having complementary patterns<br>&gt; in the language isn&#39;t a bad thing.<br>&gt;<br>&gt; These problems come up with the other variable bindings but the one that<br>&gt; ended up bothering me the most was `guard var`:<br>&gt;<br>&gt;<br>&gt; func transform(selection: Rect?) {<br>&gt;  guard let rect = selection else { return }<br>&gt;  var _rect = rect<br>&gt;  // Mutate `_rect` ...<br>&gt; }<br>&gt;<br>&gt;<br>&gt; One of the guard statement&#39;s main purposes is to conditionally bind a<br>&gt; value as a peer in its own scope, not an inner scope like if statements.<br>&gt; Not having var makes the guard statement much weaker.<br>&gt;<br>&gt; There is certainly a bit of confusion about the nuances between value and<br>&gt; reference semantics, who owns a value and when, how effects are propagated<br>&gt; back to values, but I think we can attack the problem with more finesse.<br>&gt;<br>&gt; Value types are one of the attractive features of Swift – because of their<br>&gt; semantics, mutating algorithms are written in a familiar style but keeping<br>&gt; effects limited to your unique reference. I don&#39;t think we should give that<br>&gt; up now to address confusion about semantics, out of principle, or in<br>&gt; anticipation of new language features. I propose cancelling this change for<br>&gt; Swift 3 and continue to allow `var` in the grammar everywhere it occurs in<br>&gt; Swift 2.2.<br>&gt;<br>&gt; Regards,<br>&gt; David<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/1f59769c/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cf2e4441943974c6550424bb9fa45d6b?s=50"></div><header><strong>Reconsidering SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Susan Cheng</string> &lt;susan.doggie at gmail.com&gt;<p>January 23, 2016 at 09:00:00am</p></header><div class="content"><p>+1<br></p><p>have a look with my library:<br>https://github.com/SusanDoggie/Doggie/tree/master/Doggie/Accelerate<br></p><p>public func Add&lt;T: IntegerType&gt;(count: Int, var _ left: UnsafePointer&lt;T&gt;, _<br> left_stride: Int, var _ right: UnsafePointer&lt;T&gt;, _ right_stride: Int, var _<br>output: UnsafeMutablePointer&lt;T&gt;, _ out_stride: Int) {<br></p><p>    for _ in 0..&lt;count {<br></p><p>        output.memory = left.memory + right.memory<br></p><p>        left += left_stride<br></p><p>        right += right_stride<br></p><p>        output += out_stride<br></p><p>    }<br></p><p>}<br></p><p>There are lots of code moving pointers by modifying the shadow copy of<br>pointer type. This move will add plenty of redundant code lines.<br></p><p>2016-01-22 19:26 GMT+08:00 David Farler &lt;dfarler at apple.com&gt;:<br></p><p>&gt; Hello everyone,<br>&gt;<br>&gt; I&#39;d like to reconsider SE-0003 for Swift 3 and propose cancelling the<br>&gt; change in its entirety. After collecting feedback since Swift&#39;s open source<br>&gt; launch, I no longer feel this is a good move and there are a few reasons<br>&gt; why.<br>&gt;<br>&gt; There are two main patterns that the removal penalizes:<br>&gt;<br>&gt; - Get-Modify-Reassign<br>&gt; - Get-Modify-Return<br>&gt;<br>&gt; I&#39;ve found that many of the problems with this proposal stem from the uses<br>&gt; before and after the &quot;Modify&quot; part, before returning or reassigning with<br>&gt; the new value.<br>&gt;<br>&gt; I&#39;ve seen a few common responses to the var removal. Consider a<br>&gt; `Rectangle` struct:<br>&gt;<br>&gt;<br>&gt; struct Rectangle {<br>&gt;  var origin: (x: Double, y: Double)<br>&gt;  var size: (width: Double, height: Double)<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Even with mutable variables `origin` and `size`, this pattern would be<br>&gt; impossible:<br>&gt;<br>&gt;<br>&gt; var selection = getRectangularSelection()<br>&gt; if var rect = selection?.rect {<br>&gt;  // Mutate `rect` ...<br>&gt;  selection.rect = rect<br>&gt; }<br>&gt;<br>&gt;<br>&gt; So, one might shadow the variable, which is not ideal:<br>&gt;<br>&gt;<br>&gt; var selection = getRectangularSelection()<br>&gt; if let rect = selection?.rect {<br>&gt;  var rect = rect // Not so great<br>&gt;  // Mutate `rect` ...<br>&gt;  selection.rect = rect<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Or, you might make a transformation function on `Rect`:<br>&gt;<br>&gt;<br>&gt; struct Rectangle {<br>&gt;  var origin: (x: Double, y: Double)<br>&gt;  var size: (width: Double, height: Double)<br>&gt;  func withOrigin(x: Double, y: Double) -&gt; Rect {<br>&gt;    var r = self<br>&gt;    r.origin = (x, y)<br>&gt;    return r<br>&gt;  }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; This is a much better solution than shadowing but you would need one of<br>&gt; these for any property that you want to mutate and I think you&#39;ll agree<br>&gt; that it doesn&#39;t scale with the language we have today. This response begs<br>&gt; for a kind of initializer that takes all of the fields of the original<br>&gt; struct except any that you want to override:<br>&gt;<br>&gt;<br>&gt; if let rect = selection?.rect.with(origin: newOrigin) {<br>&gt;  // ...<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Straw syntax, but maybe you&#39;ll see something along these lines on<br>&gt; swift-evolution in the future, which would provide a clear alternative to<br>&gt; direct mutation patterns. Even then, I think having complementary patterns<br>&gt; in the language isn&#39;t a bad thing.<br>&gt;<br>&gt; These problems come up with the other variable bindings but the one that<br>&gt; ended up bothering me the most was `guard var`:<br>&gt;<br>&gt;<br>&gt; func transform(selection: Rect?) {<br>&gt;  guard let rect = selection else { return }<br>&gt;  var _rect = rect<br>&gt;  // Mutate `_rect` ...<br>&gt; }<br>&gt;<br>&gt;<br>&gt; One of the guard statement&#39;s main purposes is to conditionally bind a<br>&gt; value as a peer in its own scope, not an inner scope like if statements.<br>&gt; Not having var makes the guard statement much weaker.<br>&gt;<br>&gt; There is certainly a bit of confusion about the nuances between value and<br>&gt; reference semantics, who owns a value and when, how effects are propagated<br>&gt; back to values, but I think we can attack the problem with more finesse.<br>&gt;<br>&gt; Value types are one of the attractive features of Swift – because of their<br>&gt; semantics, mutating algorithms are written in a familiar style but keeping<br>&gt; effects limited to your unique reference. I don&#39;t think we should give that<br>&gt; up now to address confusion about semantics, out of principle, or in<br>&gt; anticipation of new language features. I propose cancelling this change for<br>&gt; Swift 3 and continue to allow `var` in the grammar everywhere it occurs in<br>&gt; Swift 2.2.<br>&gt;<br>&gt; Regards,<br>&gt; David<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/e81922be/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>Reconsidering SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>January 23, 2016 at 11:00:00am</p></header><div class="content"><p>Scanning through our iOS project with ~600 Swift files we barely use `var`<br>for function parameters or for if/guard statements.<br></p><p>I think the problems you outline should not be solved by using `var` but by<br>making the code&#39;s intent much clearer by using distinct variable names.<br></p><p>In your example it is not clear what the purpose of the shadowed `rect`<br>variable is. The same is true if you use `if var rect = …`:<br></p><p>var selection = getRectangularSelection()<br>if let rect = selection?.rect {<br>  var rect = rect // what is rect used for? the variable name is quite<br>generic<br>  // mutate `rect` ...<br>  // probably a lot of code<br>  // …<br></p><p>  selection.rect = rect // what rect again?<br>}<br></p><p>A better solution is to name the variables differently and make their<br>intent very clear:<br></p><p>var selection = getRectangularSelection()<br>if let currentRect = selection?.rect {<br>  var expandedRect = currentRect // intent becomes clear now<br>  // expand `expandedRect` ...<br>  // probably a lot of code<br>  // …<br></p><p>  selection.rect = expandedRect // ah, THAT rect!<br>}<br></p><p>So `if var` is really not necessary and causes more harm than good due to<br>reduced clarity.<br></p><p>-1 for reversing the proposal from me.<br></p><p>On Fri, Jan 22, 2016 at 6:26 PM, David Farler via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hello everyone,<br>&gt;<br>&gt; I&#39;d like to reconsider SE-0003 for Swift 3 and propose cancelling the<br>&gt; change in its entirety. After collecting feedback since Swift&#39;s open source<br>&gt; launch, I no longer feel this is a good move and there are a few reasons<br>&gt; why.<br>&gt;<br>&gt; There are two main patterns that the removal penalizes:<br>&gt;<br>&gt; - Get-Modify-Reassign<br>&gt; - Get-Modify-Return<br>&gt;<br>&gt; I&#39;ve found that many of the problems with this proposal stem from the uses<br>&gt; before and after the &quot;Modify&quot; part, before returning or reassigning with<br>&gt; the new value.<br>&gt;<br>&gt; I&#39;ve seen a few common responses to the var removal. Consider a<br>&gt; `Rectangle` struct:<br>&gt;<br>&gt;<br>&gt; struct Rectangle {<br>&gt;  var origin: (x: Double, y: Double)<br>&gt;  var size: (width: Double, height: Double)<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Even with mutable variables `origin` and `size`, this pattern would be<br>&gt; impossible:<br>&gt;<br>&gt;<br>&gt; var selection = getRectangularSelection()<br>&gt; if var rect = selection?.rect {<br>&gt;  // Mutate `rect` ...<br>&gt;  selection.rect = rect<br>&gt; }<br>&gt;<br>&gt;<br>&gt; So, one might shadow the variable, which is not ideal:<br>&gt;<br>&gt;<br>&gt; var selection = getRectangularSelection()<br>&gt; if let rect = selection?.rect {<br>&gt;  var rect = rect // Not so great<br>&gt;  // Mutate `rect` ...<br>&gt;  selection.rect = rect<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Or, you might make a transformation function on `Rect`:<br>&gt;<br>&gt;<br>&gt; struct Rectangle {<br>&gt;  var origin: (x: Double, y: Double)<br>&gt;  var size: (width: Double, height: Double)<br>&gt;  func withOrigin(x: Double, y: Double) -&gt; Rect {<br>&gt;    var r = self<br>&gt;    r.origin = (x, y)<br>&gt;    return r<br>&gt;  }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; This is a much better solution than shadowing but you would need one of<br>&gt; these for any property that you want to mutate and I think you&#39;ll agree<br>&gt; that it doesn&#39;t scale with the language we have today. This response begs<br>&gt; for a kind of initializer that takes all of the fields of the original<br>&gt; struct except any that you want to override:<br>&gt;<br>&gt;<br>&gt; if let rect = selection?.rect.with(origin: newOrigin) {<br>&gt;  // ...<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Straw syntax, but maybe you&#39;ll see something along these lines on<br>&gt; swift-evolution in the future, which would provide a clear alternative to<br>&gt; direct mutation patterns. Even then, I think having complementary patterns<br>&gt; in the language isn&#39;t a bad thing.<br>&gt;<br>&gt; These problems come up with the other variable bindings but the one that<br>&gt; ended up bothering me the most was `guard var`:<br>&gt;<br>&gt;<br>&gt; func transform(selection: Rect?) {<br>&gt;  guard let rect = selection else { return }<br>&gt;  var _rect = rect<br>&gt;  // Mutate `_rect` ...<br>&gt; }<br>&gt;<br>&gt;<br>&gt; One of the guard statement&#39;s main purposes is to conditionally bind a<br>&gt; value as a peer in its own scope, not an inner scope like if statements.<br>&gt; Not having var makes the guard statement much weaker.<br>&gt;<br>&gt; There is certainly a bit of confusion about the nuances between value and<br>&gt; reference semantics, who owns a value and when, how effects are propagated<br>&gt; back to values, but I think we can attack the problem with more finesse.<br>&gt;<br>&gt; Value types are one of the attractive features of Swift – because of their<br>&gt; semantics, mutating algorithms are written in a familiar style but keeping<br>&gt; effects limited to your unique reference. I don&#39;t think we should give that<br>&gt; up now to address confusion about semantics, out of principle, or in<br>&gt; anticipation of new language features. I propose cancelling this change for<br>&gt; Swift 3 and continue to allow `var` in the grammar everywhere it occurs in<br>&gt; Swift 2.2.<br>&gt;<br>&gt; Regards,<br>&gt; David<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/cd93a061/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d9dbc0dfeb74eab8dd9bbd9cbd84680?s=50"></div><header><strong>Reconsidering SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Jose Cheyo Jimenez</string> &lt;cheyo at masters3d.com&gt;<p>January 23, 2016 at 05:00:00am</p></header><div class="content"><p>if let currentRect = selection?.rect {<br>  var expandedRect = currentRect<br></p><p>VS<br></p><p>if var expandedRec = selection?.rect {<br></p><p>If let is perfectly fine if most of the code base is with classes. Perhaps<br>I can see the argument on why pattern matching and even why functions<br>should only allow let but for guard and if binding, the uses of var are<br>more practical and less boiler plate specially when dealing with mutable<br>value types.<br></p><p>On Saturday, January 23, 2016, Marc Knaup via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Scanning through our iOS project with ~600 Swift files we barely use `var`<br>&gt; for function parameters or for if/guard statements.<br>&gt;<br>&gt; I think the problems you outline should not be solved by using `var` but<br>&gt; by making the code&#39;s intent much clearer by using distinct variable names.<br>&gt;<br>&gt; In your example it is not clear what the purpose of the shadowed `rect`<br>&gt; variable is. The same is true if you use `if var rect = …`:<br>&gt;<br>&gt; var selection = getRectangularSelection()<br>&gt; if let rect = selection?.rect {<br>&gt;   var rect = rect // what is rect used for? the variable name is quite<br>&gt; generic<br>&gt;   // mutate `rect` ...<br>&gt;   // probably a lot of code<br>&gt;   // …<br>&gt;<br>&gt;   selection.rect = rect // what rect again?<br>&gt; }<br>&gt;<br>&gt; A better solution is to name the variables differently and make their<br>&gt; intent very clear:<br>&gt;<br>&gt; var selection = getRectangularSelection()<br>&gt; if let currentRect = selection?.rect {<br>&gt;   var expandedRect = currentRect // intent becomes clear now<br>&gt;   // expand `expandedRect` ...<br>&gt;   // probably a lot of code<br>&gt;   // …<br>&gt;<br>&gt;   selection.rect = expandedRect // ah, THAT rect!<br>&gt; }<br>&gt;<br>&gt; So `if var` is really not necessary and causes more harm than good due to<br>&gt; reduced clarity.<br>&gt;<br>&gt; -1 for reversing the proposal from me.<br>&gt;<br>&gt; On Fri, Jan 22, 2016 at 6:26 PM, David Farler via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt;&gt; Hello everyone,<br>&gt;&gt;<br>&gt;&gt; I&#39;d like to reconsider SE-0003 for Swift 3 and propose cancelling the<br>&gt;&gt; change in its entirety. After collecting feedback since Swift&#39;s open source<br>&gt;&gt; launch, I no longer feel this is a good move and there are a few reasons<br>&gt;&gt; why.<br>&gt;&gt;<br>&gt;&gt; There are two main patterns that the removal penalizes:<br>&gt;&gt;<br>&gt;&gt; - Get-Modify-Reassign<br>&gt;&gt; - Get-Modify-Return<br>&gt;&gt;<br>&gt;&gt; I&#39;ve found that many of the problems with this proposal stem from the<br>&gt;&gt; uses before and after the &quot;Modify&quot; part, before returning or reassigning<br>&gt;&gt; with the new value.<br>&gt;&gt;<br>&gt;&gt; I&#39;ve seen a few common responses to the var removal. Consider a<br>&gt;&gt; `Rectangle` struct:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; struct Rectangle {<br>&gt;&gt;  var origin: (x: Double, y: Double)<br>&gt;&gt;  var size: (width: Double, height: Double)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Even with mutable variables `origin` and `size`, this pattern would be<br>&gt;&gt; impossible:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; var selection = getRectangularSelection()<br>&gt;&gt; if var rect = selection?.rect {<br>&gt;&gt;  // Mutate `rect` ...<br>&gt;&gt;  selection.rect = rect<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; So, one might shadow the variable, which is not ideal:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; var selection = getRectangularSelection()<br>&gt;&gt; if let rect = selection?.rect {<br>&gt;&gt;  var rect = rect // Not so great<br>&gt;&gt;  // Mutate `rect` ...<br>&gt;&gt;  selection.rect = rect<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Or, you might make a transformation function on `Rect`:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; struct Rectangle {<br>&gt;&gt;  var origin: (x: Double, y: Double)<br>&gt;&gt;  var size: (width: Double, height: Double)<br>&gt;&gt;  func withOrigin(x: Double, y: Double) -&gt; Rect {<br>&gt;&gt;    var r = self<br>&gt;&gt;    r.origin = (x, y)<br>&gt;&gt;    return r<br>&gt;&gt;  }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; This is a much better solution than shadowing but you would need one of<br>&gt;&gt; these for any property that you want to mutate and I think you&#39;ll agree<br>&gt;&gt; that it doesn&#39;t scale with the language we have today. This response begs<br>&gt;&gt; for a kind of initializer that takes all of the fields of the original<br>&gt;&gt; struct except any that you want to override:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; if let rect = selection?.rect.with(origin: newOrigin) {<br>&gt;&gt;  // ...<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Straw syntax, but maybe you&#39;ll see something along these lines on<br>&gt;&gt; swift-evolution in the future, which would provide a clear alternative to<br>&gt;&gt; direct mutation patterns. Even then, I think having complementary patterns<br>&gt;&gt; in the language isn&#39;t a bad thing.<br>&gt;&gt;<br>&gt;&gt; These problems come up with the other variable bindings but the one that<br>&gt;&gt; ended up bothering me the most was `guard var`:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; func transform(selection: Rect?) {<br>&gt;&gt;  guard let rect = selection else { return }<br>&gt;&gt;  var _rect = rect<br>&gt;&gt;  // Mutate `_rect` ...<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; One of the guard statement&#39;s main purposes is to conditionally bind a<br>&gt;&gt; value as a peer in its own scope, not an inner scope like if statements.<br>&gt;&gt; Not having var makes the guard statement much weaker.<br>&gt;&gt;<br>&gt;&gt; There is certainly a bit of confusion about the nuances between value and<br>&gt;&gt; reference semantics, who owns a value and when, how effects are propagated<br>&gt;&gt; back to values, but I think we can attack the problem with more finesse.<br>&gt;&gt;<br>&gt;&gt; Value types are one of the attractive features of Swift – because of<br>&gt;&gt; their semantics, mutating algorithms are written in a familiar style but<br>&gt;&gt; keeping effects limited to your unique reference. I don&#39;t think we should<br>&gt;&gt; give that up now to address confusion about semantics, out of principle, or<br>&gt;&gt; in anticipation of new language features. I propose cancelling this change<br>&gt;&gt; for Swift 3 and continue to allow `var` in the grammar everywhere it occurs<br>&gt;&gt; in Swift 2.2.<br>&gt;&gt;<br>&gt;&gt; Regards,<br>&gt;&gt; David<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/d20014fa/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>Reconsidering SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>January 24, 2016 at 08:00:00am</p></header><div class="content"><p>Removing var from function params, I get that. But the if-binding is unfortunate. It&#39;s literally a line of code for the sole purpose of making the compiler happy. <br></p><p>Working with optionals is already clumsy enough, we really don&#39;t need to make it more so. <br></p><p>-David<br></p><p>&gt; On Jan 23, 2016, at 5:03 AM, J. Cheyo Jimenez via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; if let currentRect = selection?.rect {<br>&gt;   var expandedRect = currentRect <br>&gt; <br>&gt; VS<br>&gt; <br>&gt; if var expandedRec = selection?.rect {<br>&gt; <br>&gt; If let is perfectly fine if most of the code base is with classes. Perhaps I can see the argument on why pattern matching and even why functions should only allow let but for guard and if binding, the uses of var are more practical and less boiler plate specially when dealing with mutable value types. <br>&gt; <br>&gt;&gt; On Saturday, January 23, 2016, Marc Knaup via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Scanning through our iOS project with ~600 Swift files we barely use `var` for function parameters or for if/guard statements.<br>&gt;&gt; <br>&gt;&gt; I think the problems you outline should not be solved by using `var` but by making the code&#39;s intent much clearer by using distinct variable names.<br>&gt;&gt; <br>&gt;&gt; In your example it is not clear what the purpose of the shadowed `rect` variable is. The same is true if you use `if var rect = …`:<br>&gt;&gt; <br>&gt;&gt; var selection = getRectangularSelection()<br>&gt;&gt; if let rect = selection?.rect {<br>&gt;&gt;   var rect = rect // what is rect used for? the variable name is quite generic<br>&gt;&gt;   // mutate `rect` ...<br>&gt;&gt;   // probably a lot of code<br>&gt;&gt;   // …<br>&gt;&gt; <br>&gt;&gt;   selection.rect = rect // what rect again?<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; A better solution is to name the variables differently and make their intent very clear:<br>&gt;&gt; <br>&gt;&gt; var selection = getRectangularSelection()<br>&gt;&gt; if let currentRect = selection?.rect {<br>&gt;&gt;   var expandedRect = currentRect // intent becomes clear now<br>&gt;&gt;   // expand `expandedRect` ...<br>&gt;&gt;   // probably a lot of code<br>&gt;&gt;   // …<br>&gt;&gt;  <br>&gt;&gt;   selection.rect = expandedRect // ah, THAT rect!<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; So `if var` is really not necessary and causes more harm than good due to reduced clarity.<br>&gt;&gt; <br>&gt;&gt; -1 for reversing the proposal from me.<br>&gt;&gt; <br>&gt;&gt;&gt; On Fri, Jan 22, 2016 at 6:26 PM, David Farler via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; Hello everyone,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;d like to reconsider SE-0003 for Swift 3 and propose cancelling the change in its entirety. After collecting feedback since Swift&#39;s open source launch, I no longer feel this is a good move and there are a few reasons why.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are two main patterns that the removal penalizes:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Get-Modify-Reassign<br>&gt;&gt;&gt; - Get-Modify-Return<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;ve found that many of the problems with this proposal stem from the uses before and after the &quot;Modify&quot; part, before returning or reassigning with the new value.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;ve seen a few common responses to the var removal. Consider a `Rectangle` struct:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Rectangle {<br>&gt;&gt;&gt;  var origin: (x: Double, y: Double)<br>&gt;&gt;&gt;  var size: (width: Double, height: Double)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Even with mutable variables `origin` and `size`, this pattern would be impossible:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var selection = getRectangularSelection()<br>&gt;&gt;&gt; if var rect = selection?.rect {<br>&gt;&gt;&gt;  // Mutate `rect` ...<br>&gt;&gt;&gt;  selection.rect = rect<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So, one might shadow the variable, which is not ideal:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var selection = getRectangularSelection()<br>&gt;&gt;&gt; if let rect = selection?.rect {<br>&gt;&gt;&gt;  var rect = rect // Not so great<br>&gt;&gt;&gt;  // Mutate `rect` ...<br>&gt;&gt;&gt;  selection.rect = rect<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Or, you might make a transformation function on `Rect`:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Rectangle {<br>&gt;&gt;&gt;  var origin: (x: Double, y: Double)<br>&gt;&gt;&gt;  var size: (width: Double, height: Double)<br>&gt;&gt;&gt;  func withOrigin(x: Double, y: Double) -&gt; Rect {<br>&gt;&gt;&gt;    var r = self<br>&gt;&gt;&gt;    r.origin = (x, y)<br>&gt;&gt;&gt;    return r<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a much better solution than shadowing but you would need one of these for any property that you want to mutate and I think you&#39;ll agree that it doesn&#39;t scale with the language we have today. This response begs for a kind of initializer that takes all of the fields of the original struct except any that you want to override:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; if let rect = selection?.rect.with(origin: newOrigin) {<br>&gt;&gt;&gt;  // ...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Straw syntax, but maybe you&#39;ll see something along these lines on swift-evolution in the future, which would provide a clear alternative to direct mutation patterns. Even then, I think having complementary patterns in the language isn&#39;t a bad thing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; These problems come up with the other variable bindings but the one that ended up bothering me the most was `guard var`:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func transform(selection: Rect?) {<br>&gt;&gt;&gt;  guard let rect = selection else { return }<br>&gt;&gt;&gt;  var _rect = rect<br>&gt;&gt;&gt;  // Mutate `_rect` ...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One of the guard statement&#39;s main purposes is to conditionally bind a value as a peer in its own scope, not an inner scope like if statements. Not having var makes the guard statement much weaker.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There is certainly a bit of confusion about the nuances between value and reference semantics, who owns a value and when, how effects are propagated back to values, but I think we can attack the problem with more finesse.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Value types are one of the attractive features of Swift – because of their semantics, mutating algorithms are written in a familiar style but keeping effects limited to your unique reference. I don&#39;t think we should give that up now to address confusion about semantics, out of principle, or in anticipation of new language features. I propose cancelling this change for Swift 3 and continue to allow `var` in the grammar everywhere it occurs in Swift 2.2.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Regards,<br>&gt;&gt;&gt; David<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160124/908b57c4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Reconsidering SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>January 24, 2016 at 02:00:00pm</p></header><div class="content"><p>I tend to agree with David here: there’s a lot more confusion inherent in a “var” parameter than “if var.”<br></p><p>P<br></p><p>&gt; On Jan 24, 2016, at 10:58 AM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Removing var from function params, I get that. But the if-binding is unfortunate. It&#39;s literally a line of code for the sole purpose of making the compiler happy. <br>&gt; <br>&gt; Working with optionals is already clumsy enough, we really don&#39;t need to make it more so. <br>&gt; <br>&gt; -David<br>&gt; <br>&gt; On Jan 23, 2016, at 5:03 AM, J. Cheyo Jimenez via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; if let currentRect = selection?.rect {<br>&gt;&gt;   var expandedRect = currentRect <br>&gt;&gt; <br>&gt;&gt; VS<br>&gt;&gt; <br>&gt;&gt; if var expandedRec = selection?.rect {<br>&gt;&gt; <br>&gt;&gt; If let is perfectly fine if most of the code base is with classes. Perhaps I can see the argument on why pattern matching and even why functions should only allow let but for guard and if binding, the uses of var are more practical and less boiler plate specially when dealing with mutable value types. <br>&gt;&gt; <br>&gt;&gt; On Saturday, January 23, 2016, Marc Knaup via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Scanning through our iOS project with ~600 Swift files we barely use `var` for function parameters or for if/guard statements.<br>&gt;&gt; <br>&gt;&gt; I think the problems you outline should not be solved by using `var` but by making the code&#39;s intent much clearer by using distinct variable names.<br>&gt;&gt; <br>&gt;&gt; In your example it is not clear what the purpose of the shadowed `rect` variable is. The same is true if you use `if var rect = …`:<br>&gt;&gt; <br>&gt;&gt; var selection = getRectangularSelection()<br>&gt;&gt; if let rect = selection?.rect {<br>&gt;&gt;   var rect = rect // what is rect used for? the variable name is quite generic<br>&gt;&gt;   // mutate `rect` ...<br>&gt;&gt;   // probably a lot of code<br>&gt;&gt;   // …<br>&gt;&gt; <br>&gt;&gt;   selection.rect = rect // what rect again?<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; A better solution is to name the variables differently and make their intent very clear:<br>&gt;&gt; <br>&gt;&gt; var selection = getRectangularSelection()<br>&gt;&gt; if let currentRect = selection?.rect {<br>&gt;&gt;   var expandedRect = currentRect // intent becomes clear now<br>&gt;&gt;   // expand `expandedRect` ...<br>&gt;&gt;   // probably a lot of code<br>&gt;&gt;   // …<br>&gt;&gt;  <br>&gt;&gt;   selection.rect = expandedRect // ah, THAT rect!<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; So `if var` is really not necessary and causes more harm than good due to reduced clarity.<br>&gt;&gt; <br>&gt;&gt; -1 for reversing the proposal from me.<br>&gt;&gt; <br>&gt;&gt; On Fri, Jan 22, 2016 at 6:26 PM, David Farler via swift-evolution &lt;swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;&gt; Hello everyone,<br>&gt;&gt; <br>&gt;&gt; I&#39;d like to reconsider SE-0003 for Swift 3 and propose cancelling the change in its entirety. After collecting feedback since Swift&#39;s open source launch, I no longer feel this is a good move and there are a few reasons why.<br>&gt;&gt; <br>&gt;&gt; There are two main patterns that the removal penalizes:<br>&gt;&gt; <br>&gt;&gt; - Get-Modify-Reassign<br>&gt;&gt; - Get-Modify-Return<br>&gt;&gt; <br>&gt;&gt; I&#39;ve found that many of the problems with this proposal stem from the uses before and after the &quot;Modify&quot; part, before returning or reassigning with the new value.<br>&gt;&gt; <br>&gt;&gt; I&#39;ve seen a few common responses to the var removal. Consider a `Rectangle` struct:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; struct Rectangle {<br>&gt;&gt;  var origin: (x: Double, y: Double)<br>&gt;&gt;  var size: (width: Double, height: Double)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Even with mutable variables `origin` and `size`, this pattern would be impossible:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; var selection = getRectangularSelection()<br>&gt;&gt; if var rect = selection?.rect {<br>&gt;&gt;  // Mutate `rect` ...<br>&gt;&gt;  selection.rect = rect<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; So, one might shadow the variable, which is not ideal:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; var selection = getRectangularSelection()<br>&gt;&gt; if let rect = selection?.rect {<br>&gt;&gt;  var rect = rect // Not so great<br>&gt;&gt;  // Mutate `rect` ...<br>&gt;&gt;  selection.rect = rect<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Or, you might make a transformation function on `Rect`:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; struct Rectangle {<br>&gt;&gt;  var origin: (x: Double, y: Double)<br>&gt;&gt;  var size: (width: Double, height: Double)<br>&gt;&gt;  func withOrigin(x: Double, y: Double) -&gt; Rect {<br>&gt;&gt;    var r = self<br>&gt;&gt;    r.origin = (x, y)<br>&gt;&gt;    return r<br>&gt;&gt;  }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; This is a much better solution than shadowing but you would need one of these for any property that you want to mutate and I think you&#39;ll agree that it doesn&#39;t scale with the language we have today. This response begs for a kind of initializer that takes all of the fields of the original struct except any that you want to override:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; if let rect = selection?.rect.with(origin: newOrigin) {<br>&gt;&gt;  // ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Straw syntax, but maybe you&#39;ll see something along these lines on swift-evolution in the future, which would provide a clear alternative to direct mutation patterns. Even then, I think having complementary patterns in the language isn&#39;t a bad thing.<br>&gt;&gt; <br>&gt;&gt; These problems come up with the other variable bindings but the one that ended up bothering me the most was `guard var`:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; func transform(selection: Rect?) {<br>&gt;&gt;  guard let rect = selection else { return }<br>&gt;&gt;  var _rect = rect<br>&gt;&gt;  // Mutate `_rect` ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; One of the guard statement&#39;s main purposes is to conditionally bind a value as a peer in its own scope, not an inner scope like if statements. Not having var makes the guard statement much weaker.<br>&gt;&gt; <br>&gt;&gt; There is certainly a bit of confusion about the nuances between value and reference semantics, who owns a value and when, how effects are propagated back to values, but I think we can attack the problem with more finesse.<br>&gt;&gt; <br>&gt;&gt; Value types are one of the attractive features of Swift – because of their semantics, mutating algorithms are written in a familiar style but keeping effects limited to your unique reference. I don&#39;t think we should give that up now to address confusion about semantics, out of principle, or in anticipation of new language features. I propose cancelling this change for Swift 3 and continue to allow `var` in the grammar everywhere it occurs in Swift 2.2.<br>&gt;&gt; <br>&gt;&gt; Regards,<br>&gt;&gt; David<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160124/0d4d04a5/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Reconsidering SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>January 24, 2016 at 03:00:00pm</p></header><div class="content"><p>+1<br></p><p>Aside from forcing the use of temporary ‘let’ variables whose only purpose is to be immediately assigned to a var, I feel that “var works in these places where you can have let, but not these other places” is confusing. The more consistent the language is, the easier it is to wrap one’s head around. You may not see “if var” as often as “if let” in code, but if you understand what “if let” means, and what “var” means, it makes perfect sense what the combination of the two will do.<br></p><p>Charles<br></p><p>&gt; On Jan 22, 2016, at 11:26 AM, David Farler via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello everyone,<br>&gt; <br>&gt; I&#39;d like to reconsider SE-0003 for Swift 3 and propose cancelling the change in its entirety. After collecting feedback since Swift&#39;s open source launch, I no longer feel this is a good move and there are a few reasons why.<br>&gt; <br>&gt; There are two main patterns that the removal penalizes:<br>&gt; <br>&gt; - Get-Modify-Reassign<br>&gt; - Get-Modify-Return<br>&gt; <br>&gt; I&#39;ve found that many of the problems with this proposal stem from the uses before and after the &quot;Modify&quot; part, before returning or reassigning with the new value.<br>&gt; <br>&gt; I&#39;ve seen a few common responses to the var removal. Consider a `Rectangle` struct:<br>&gt; <br>&gt; <br>&gt; struct Rectangle {<br>&gt; var origin: (x: Double, y: Double)<br>&gt; var size: (width: Double, height: Double)<br>&gt; }<br>&gt; <br>&gt; <br>&gt; Even with mutable variables `origin` and `size`, this pattern would be impossible:<br>&gt; <br>&gt; <br>&gt; var selection = getRectangularSelection()<br>&gt; if var rect = selection?.rect {<br>&gt; // Mutate `rect` ...<br>&gt; selection.rect = rect<br>&gt; }<br>&gt; <br>&gt; <br>&gt; So, one might shadow the variable, which is not ideal:<br>&gt; <br>&gt; <br>&gt; var selection = getRectangularSelection()<br>&gt; if let rect = selection?.rect {<br>&gt; var rect = rect // Not so great<br>&gt; // Mutate `rect` ...<br>&gt; selection.rect = rect<br>&gt; }<br>&gt; <br>&gt; <br>&gt; Or, you might make a transformation function on `Rect`:<br>&gt; <br>&gt; <br>&gt; struct Rectangle {<br>&gt; var origin: (x: Double, y: Double)<br>&gt; var size: (width: Double, height: Double)<br>&gt; func withOrigin(x: Double, y: Double) -&gt; Rect {<br>&gt;   var r = self<br>&gt;   r.origin = (x, y)<br>&gt;   return r<br>&gt; }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; This is a much better solution than shadowing but you would need one of these for any property that you want to mutate and I think you&#39;ll agree that it doesn&#39;t scale with the language we have today. This response begs for a kind of initializer that takes all of the fields of the original struct except any that you want to override:<br>&gt; <br>&gt; <br>&gt; if let rect = selection?.rect.with(origin: newOrigin) {<br>&gt; // ...<br>&gt; }<br>&gt; <br>&gt; <br>&gt; Straw syntax, but maybe you&#39;ll see something along these lines on swift-evolution in the future, which would provide a clear alternative to direct mutation patterns. Even then, I think having complementary patterns in the language isn&#39;t a bad thing.<br>&gt; <br>&gt; These problems come up with the other variable bindings but the one that ended up bothering me the most was `guard var`:<br>&gt; <br>&gt; <br>&gt; func transform(selection: Rect?) {<br>&gt; guard let rect = selection else { return }<br>&gt; var _rect = rect<br>&gt; // Mutate `_rect` ...<br>&gt; }<br>&gt; <br>&gt; <br>&gt; One of the guard statement&#39;s main purposes is to conditionally bind a value as a peer in its own scope, not an inner scope like if statements. Not having var makes the guard statement much weaker.<br>&gt; <br>&gt; There is certainly a bit of confusion about the nuances between value and reference semantics, who owns a value and when, how effects are propagated back to values, but I think we can attack the problem with more finesse.<br>&gt; <br>&gt; Value types are one of the attractive features of Swift – because of their semantics, mutating algorithms are written in a familiar style but keeping effects limited to your unique reference. I don&#39;t think we should give that up now to address confusion about semantics, out of principle, or in anticipation of new language features. I propose cancelling this change for Swift 3 and continue to allow `var` in the grammar everywhere it occurs in Swift 2.2.<br>&gt; <br>&gt; Regards,<br>&gt; David<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76eb9711d45c1c9a71c0f24004072a22?s=50"></div><header><strong>Reconsidering SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Zach Waldowski</string> &lt;zach at waldowski.me&gt;<p>January 24, 2016 at 10:00:00pm</p></header><div class="content"><p>-1<br></p><p>Having already adopted the syntax in my projects in anticipation of 2.2,<br>the increase in clarity at the expense of terseness is appreciated. A<br>proposal should not be discussing an alternative, not a rollback.<br></p><p>Cheers!<br>Zachary Waldowski<br>zach at waldowski.me<br></p><p>On Fri, Jan 22, 2016, at 12:26 PM, David Farler via swift-evolution<br>wrote:<br>&gt; Hello everyone,<br>&gt; <br>&gt; I&#39;d like to reconsider SE-0003 for Swift 3 and propose cancelling the<br>&gt; change in its entirety. After collecting feedback since Swift&#39;s open<br>&gt; source launch, I no longer feel this is a good move and there are a few<br>&gt; reasons why.<br>&gt; <br>&gt; There are two main patterns that the removal penalizes:<br>&gt; <br>&gt; - Get-Modify-Reassign<br>&gt; - Get-Modify-Return<br>&gt; <br>&gt; I&#39;ve found that many of the problems with this proposal stem from the<br>&gt; uses before and after the &quot;Modify&quot; part, before returning or reassigning<br>&gt; with the new value.<br>&gt; <br>&gt; I&#39;ve seen a few common responses to the var removal. Consider a<br>&gt; `Rectangle` struct:<br>&gt; <br>&gt; <br>&gt; struct Rectangle {<br>&gt;  var origin: (x: Double, y: Double)<br>&gt;  var size: (width: Double, height: Double)<br>&gt; }<br>&gt; <br>&gt; <br>&gt; Even with mutable variables `origin` and `size`, this pattern would be<br>&gt; impossible:<br>&gt; <br>&gt; <br>&gt; var selection = getRectangularSelection()<br>&gt; if var rect = selection?.rect {<br>&gt;  // Mutate `rect` ...<br>&gt;  selection.rect = rect<br>&gt; }<br>&gt; <br>&gt; <br>&gt; So, one might shadow the variable, which is not ideal:<br>&gt; <br>&gt; <br>&gt; var selection = getRectangularSelection()<br>&gt; if let rect = selection?.rect {<br>&gt;  var rect = rect // Not so great<br>&gt;  // Mutate `rect` ...<br>&gt;  selection.rect = rect<br>&gt; }<br>&gt; <br>&gt; <br>&gt; Or, you might make a transformation function on `Rect`:<br>&gt; <br>&gt; <br>&gt; struct Rectangle {<br>&gt;  var origin: (x: Double, y: Double)<br>&gt;  var size: (width: Double, height: Double)<br>&gt;  func withOrigin(x: Double, y: Double) -&gt; Rect {<br>&gt;    var r = self<br>&gt;    r.origin = (x, y)<br>&gt;    return r<br>&gt;  }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; This is a much better solution than shadowing but you would need one of<br>&gt; these for any property that you want to mutate and I think you&#39;ll agree<br>&gt; that it doesn&#39;t scale with the language we have today. This response begs<br>&gt; for a kind of initializer that takes all of the fields of the original<br>&gt; struct except any that you want to override:<br>&gt; <br>&gt; <br>&gt; if let rect = selection?.rect.with(origin: newOrigin) {<br>&gt;  // ...<br>&gt; }<br>&gt; <br>&gt; <br>&gt; Straw syntax, but maybe you&#39;ll see something along these lines on<br>&gt; swift-evolution in the future, which would provide a clear alternative to<br>&gt; direct mutation patterns. Even then, I think having complementary<br>&gt; patterns in the language isn&#39;t a bad thing.<br>&gt; <br>&gt; These problems come up with the other variable bindings but the one that<br>&gt; ended up bothering me the most was `guard var`:<br>&gt; <br>&gt; <br>&gt; func transform(selection: Rect?) {<br>&gt;  guard let rect = selection else { return }<br>&gt;  var _rect = rect<br>&gt;  // Mutate `_rect` ...<br>&gt; }<br>&gt; <br>&gt; <br>&gt; One of the guard statement&#39;s main purposes is to conditionally bind a<br>&gt; value as a peer in its own scope, not an inner scope like if statements.<br>&gt; Not having var makes the guard statement much weaker.<br>&gt; <br>&gt; There is certainly a bit of confusion about the nuances between value and<br>&gt; reference semantics, who owns a value and when, how effects are<br>&gt; propagated back to values, but I think we can attack the problem with<br>&gt; more finesse.<br>&gt; <br>&gt; Value types are one of the attractive features of Swift – because of<br>&gt; their semantics, mutating algorithms are written in a familiar style but<br>&gt; keeping effects limited to your unique reference. I don&#39;t think we should<br>&gt; give that up now to address confusion about semantics, out of principle,<br>&gt; or in anticipation of new language features. I propose cancelling this<br>&gt; change for Swift 3 and continue to allow `var` in the grammar everywhere<br>&gt; it occurs in Swift 2.2.<br>&gt; <br>&gt; Regards,<br>&gt; David<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f7d3036e2eaf1283f20f43d62472a29f?s=50"></div><header><strong>Reconsidering SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>David Farler</string> &lt;dfarler at apple.com&gt;<p>January 25, 2016 at 10:00:00am</p></header><div class="content"><p>An alternative would certainly be interesting but I would prefer to take it one step at a time and avoid being hasty so we can come up with something really great. What did most of your var fixes look like, by the way? Did you end up changing the layout of your value types or did you decide to add more vars?<br></p><p>David<br></p><p>&gt; On Jan 24, 2016, at 7:19 PM, Zach Waldowski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; -1<br>&gt; <br>&gt; Having already adopted the syntax in my projects in anticipation of 2.2,<br>&gt; the increase in clarity at the expense of terseness is appreciated. A<br>&gt; proposal should not be discussing an alternative, not a rollback.<br>&gt; <br>&gt; Cheers!<br>&gt; Zachary Waldowski<br>&gt; zach at waldowski.me<br>&gt; <br>&gt; On Fri, Jan 22, 2016, at 12:26 PM, David Farler via swift-evolution<br>&gt; wrote:<br>&gt;&gt; Hello everyone,<br>&gt;&gt; <br>&gt;&gt; I&#39;d like to reconsider SE-0003 for Swift 3 and propose cancelling the<br>&gt;&gt; change in its entirety. After collecting feedback since Swift&#39;s open<br>&gt;&gt; source launch, I no longer feel this is a good move and there are a few<br>&gt;&gt; reasons why.<br>&gt;&gt; <br>&gt;&gt; There are two main patterns that the removal penalizes:<br>&gt;&gt; <br>&gt;&gt; - Get-Modify-Reassign<br>&gt;&gt; - Get-Modify-Return<br>&gt;&gt; <br>&gt;&gt; I&#39;ve found that many of the problems with this proposal stem from the<br>&gt;&gt; uses before and after the &quot;Modify&quot; part, before returning or reassigning<br>&gt;&gt; with the new value.<br>&gt;&gt; <br>&gt;&gt; I&#39;ve seen a few common responses to the var removal. Consider a<br>&gt;&gt; `Rectangle` struct:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; struct Rectangle {<br>&gt;&gt; var origin: (x: Double, y: Double)<br>&gt;&gt; var size: (width: Double, height: Double)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Even with mutable variables `origin` and `size`, this pattern would be<br>&gt;&gt; impossible:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; var selection = getRectangularSelection()<br>&gt;&gt; if var rect = selection?.rect {<br>&gt;&gt; // Mutate `rect` ...<br>&gt;&gt; selection.rect = rect<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; So, one might shadow the variable, which is not ideal:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; var selection = getRectangularSelection()<br>&gt;&gt; if let rect = selection?.rect {<br>&gt;&gt; var rect = rect // Not so great<br>&gt;&gt; // Mutate `rect` ...<br>&gt;&gt; selection.rect = rect<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Or, you might make a transformation function on `Rect`:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; struct Rectangle {<br>&gt;&gt; var origin: (x: Double, y: Double)<br>&gt;&gt; var size: (width: Double, height: Double)<br>&gt;&gt; func withOrigin(x: Double, y: Double) -&gt; Rect {<br>&gt;&gt;   var r = self<br>&gt;&gt;   r.origin = (x, y)<br>&gt;&gt;   return r<br>&gt;&gt; }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; This is a much better solution than shadowing but you would need one of<br>&gt;&gt; these for any property that you want to mutate and I think you&#39;ll agree<br>&gt;&gt; that it doesn&#39;t scale with the language we have today. This response begs<br>&gt;&gt; for a kind of initializer that takes all of the fields of the original<br>&gt;&gt; struct except any that you want to override:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; if let rect = selection?.rect.with(origin: newOrigin) {<br>&gt;&gt; // ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Straw syntax, but maybe you&#39;ll see something along these lines on<br>&gt;&gt; swift-evolution in the future, which would provide a clear alternative to<br>&gt;&gt; direct mutation patterns. Even then, I think having complementary<br>&gt;&gt; patterns in the language isn&#39;t a bad thing.<br>&gt;&gt; <br>&gt;&gt; These problems come up with the other variable bindings but the one that<br>&gt;&gt; ended up bothering me the most was `guard var`:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; func transform(selection: Rect?) {<br>&gt;&gt; guard let rect = selection else { return }<br>&gt;&gt; var _rect = rect<br>&gt;&gt; // Mutate `_rect` ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; One of the guard statement&#39;s main purposes is to conditionally bind a<br>&gt;&gt; value as a peer in its own scope, not an inner scope like if statements.<br>&gt;&gt; Not having var makes the guard statement much weaker.<br>&gt;&gt; <br>&gt;&gt; There is certainly a bit of confusion about the nuances between value and<br>&gt;&gt; reference semantics, who owns a value and when, how effects are<br>&gt;&gt; propagated back to values, but I think we can attack the problem with<br>&gt;&gt; more finesse.<br>&gt;&gt; <br>&gt;&gt; Value types are one of the attractive features of Swift – because of<br>&gt;&gt; their semantics, mutating algorithms are written in a familiar style but<br>&gt;&gt; keeping effects limited to your unique reference. I don&#39;t think we should<br>&gt;&gt; give that up now to address confusion about semantics, out of principle,<br>&gt;&gt; or in anticipation of new language features. I propose cancelling this<br>&gt;&gt; change for Swift 3 and continue to allow `var` in the grammar everywhere<br>&gt;&gt; it occurs in Swift 2.2.<br>&gt;&gt; <br>&gt;&gt; Regards,<br>&gt;&gt; David<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Reconsidering SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>January 28, 2016 at 01:00:00pm</p></header><div class="content"><p>Although I think &quot;if var&quot; should stay (probably just because of symmetry with &quot;if let&quot;), I have minor concerns with this proposal, as it brings up a more fundamental issue in the evolution process:<br>When is a decision final?<br></p><p>I guess it&#39;s hard to find the balance between discussing the same things over and over vs. stubborn insisting on a idea that is not as good as expected, but independent from this particular proposal, I think revising a decision should be done with caution, and that it is good that this discussion was started by a member of the Swift team…<br>Maybe it&#39;s possible to formalize the process so that an accepted proposal will not automatically be included in a future release, but rather has to pass a &quot;veto-phase&quot; after it has been implemented in a beta and people got a chance play with it (cancellation should stay an exception, though).<br></p><p>Back to the topic, I don&#39;t think &quot;if var&quot; and &quot;guard var&quot; brings more confusion than, for example, the difference between struct and class:<br>var and let always introduce a new value, and never change properties of something that already exists.<br>Additionally, I think<br>if let x = x {<br>	var x = x<br>looks rather ugly with all those x-assignments.<br>Thinking of my own source, I mostly use &quot;if let&quot; with return values of functions, so there is no confusion at all.<br></p><p>The argument of symmetry doesn&#39;t apply to function parameters, and I&#39;m not really opposed to remove the &quot;var-option&quot; there — although afaics, most languages don&#39;t enforce const on parameters (which has the benefit that struct and class are treated the same way… and const has no advantage in a narrow scope)<br></p><p>Tino<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/24d88708/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Reconsidering SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 28, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jan 28, 2016, at 4:40 AM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Although I think &quot;if var&quot; should stay (probably just because of symmetry with &quot;if let&quot;), I have minor concerns with this proposal, as it brings up a more fundamental issue in the evolution process:<br>&gt; When is a decision final?<br>&gt; <br>&gt; I guess it&#39;s hard to find the balance between discussing the same things over and over vs. stubborn insisting on a idea that is not as good as expected, but independent from this particular proposal, I think revising a decision should be done with caution, and that it is good that this discussion was started by a member of the Swift team…<br>&gt; Maybe it&#39;s possible to formalize the process so that an accepted proposal will not automatically be included in a future release, but rather has to pass a &quot;veto-phase&quot; after it has been implemented in a beta and people got a chance play with it (cancellation should stay an exception, though).<br></p><p><br>We certainly don’t want open-ended rehashing of past decisions, and I’d like to have the baseline rule be something very close to “the core team’s decisions are final” both to prevent such rehashing and also to emphasize the seriousness of the public review process: the public review is the point at which we need to gather widespread feedback on the direction of the language. Determining that there is a problem “after we shipped it” is a failure of the evolution process.<br></p><p>The evolution process has a number of stages (idea/proposal draft/public review/core team), where each new stage brings additional scrutiny of the proposal. The hope is that this scrutiny is enough to prevent us from making poor decisions that may need to be overturned, and that the swift-evolution community is representative enough of the larger Swift community to provide that scrutiny. SE-0003 is somewhat special because it’s one of a few changes for Swift 3 that were decided prior to open-sourcing Swift: it didn’t go through the whole evolution process, so it didn’t have as many eyes on it as language changes do now.<br></p><p>So, overall, I’d say that the core team’s decisions should be considered effectively final. If something gets through the entire evolution process and then we later find out it was a bad decision—e.g., due to massive negative feedback when it reaches the wider Swift community or unforeseen difficulties in implementation/rollout/etc.—the core team could bring up the idea of backing out the change. However, the evolution process *should* prevent this.<br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/85c96173/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Reconsidering SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 28, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jan 28, 2016, at 4:40 AM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Although I think &quot;if var&quot; should stay (probably just because of symmetry with &quot;if let&quot;), I have minor concerns with this proposal, as it brings up a more fundamental issue in the evolution process:<br>&gt; When is a decision final?<br></p><p>The core team met to discuss this, taking input from this thread among other things.  I will post a follow-up on a new thread.<br></p><p>-Chris<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Reconsidering SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>January 28, 2016 at 11:00:00am</p></header><div class="content"><p>Oh man, huge +1 from me here.<br></p><p>Apparently I never actually read that proposal. I was under the impression it only removed var from function parameters. And while I find that mildly annoying, I was ok with it because of the argument for removing as many keywords as possible from function parameter lists (e.g. to open up those keywords to be used as external parameter names). Though I&#39;d really prefer to keep var anyway.<br></p><p>But I didn&#39;t realize until now that it also prohibits `var` from _all_ pattern matching, such as if-let, guard-let, etc. And I find that incredibly restrictive. I am not ok at all with that restriction. It makes no sense to me, and it makes a lot of very clean code become much messier by the addition of completely spurious `var foo = foo` lines everywhere. What&#39;s more, you can&#39;t even add lines like that everywhere because of Swift&#39;s prohibition from shadowing variables from the same scope (e.g. you can&#39;t shadow the variable bound from `guard let` because it&#39;s in the same scope).<br></p><p>I see Dave Abrahams arguing that this feature is tripping some people up. But I don&#39;t see that as appropriate grounds for removing it from the language. If people don&#39;t understand `if var` or `for var x in` then they can just not write code that uses that feature. And if the argument is that people might have to read other code that uses that, well, there&#39;s plenty of stuff in Swift that you have to actually learn about before you can understand how it works, and using `var` in patterns does not seem like one of the trickiest things. And if the confusion stems from not understanding the difference between `var` and `inout`, I don&#39;t see how preventing someone from writing `if var` will solve that confusion, because the same person would presumably have the same confusion about `var foo = bar`.<br></p><p>-Kevin Ballard<br></p><p>On Fri, Jan 22, 2016, at 09:26 AM, David Farler via swift-evolution wrote:<br>&gt; Hello everyone,<br>&gt; <br>&gt; I&#39;d like to reconsider SE-0003 for Swift 3 and propose cancelling the change in its entirety. After collecting feedback since Swift&#39;s open source launch, I no longer feel this is a good move and there are a few reasons why.<br>&gt; <br>&gt; There are two main patterns that the removal penalizes:<br>&gt; <br>&gt; - Get-Modify-Reassign<br>&gt; - Get-Modify-Return<br>&gt; <br>&gt; I&#39;ve found that many of the problems with this proposal stem from the uses before and after the &quot;Modify&quot; part, before returning or reassigning with the new value.<br>&gt; <br>&gt; I&#39;ve seen a few common responses to the var removal. Consider a `Rectangle` struct:<br>&gt; <br>&gt; <br>&gt; struct Rectangle {<br>&gt;  var origin: (x: Double, y: Double)<br>&gt;  var size: (width: Double, height: Double)<br>&gt; }<br>&gt; <br>&gt; <br>&gt; Even with mutable variables `origin` and `size`, this pattern would be impossible:<br>&gt; <br>&gt; <br>&gt; var selection = getRectangularSelection()<br>&gt; if var rect = selection?.rect {<br>&gt;  // Mutate `rect` ...<br>&gt;  selection.rect = rect<br>&gt; }<br>&gt; <br>&gt; <br>&gt; So, one might shadow the variable, which is not ideal:<br>&gt; <br>&gt; <br>&gt; var selection = getRectangularSelection()<br>&gt; if let rect = selection?.rect {<br>&gt;  var rect = rect // Not so great<br>&gt;  // Mutate `rect` ...<br>&gt;  selection.rect = rect<br>&gt; }<br>&gt; <br>&gt; <br>&gt; Or, you might make a transformation function on `Rect`:<br>&gt; <br>&gt; <br>&gt; struct Rectangle {<br>&gt;  var origin: (x: Double, y: Double)<br>&gt;  var size: (width: Double, height: Double)<br>&gt;  func withOrigin(x: Double, y: Double) -&gt; Rect {<br>&gt;    var r = self<br>&gt;    r.origin = (x, y)<br>&gt;    return r<br>&gt;  }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; This is a much better solution than shadowing but you would need one of these for any property that you want to mutate and I think you&#39;ll agree that it doesn&#39;t scale with the language we have today. This response begs for a kind of initializer that takes all of the fields of the original struct except any that you want to override:<br>&gt; <br>&gt; <br>&gt; if let rect = selection?.rect.with(origin: newOrigin) {<br>&gt;  // ...<br>&gt; }<br>&gt; <br>&gt; <br>&gt; Straw syntax, but maybe you&#39;ll see something along these lines on swift-evolution in the future, which would provide a clear alternative to direct mutation patterns. Even then, I think having complementary patterns in the language isn&#39;t a bad thing.<br>&gt; <br>&gt; These problems come up with the other variable bindings but the one that ended up bothering me the most was `guard var`:<br>&gt; <br>&gt; <br>&gt; func transform(selection: Rect?) {<br>&gt;  guard let rect = selection else { return }<br>&gt;  var _rect = rect<br>&gt;  // Mutate `_rect` ...<br>&gt; }<br>&gt; <br>&gt; <br>&gt; One of the guard statement&#39;s main purposes is to conditionally bind a value as a peer in its own scope, not an inner scope like if statements. Not having var makes the guard statement much weaker.<br>&gt; <br>&gt; There is certainly a bit of confusion about the nuances between value and reference semantics, who owns a value and when, how effects are propagated back to values, but I think we can attack the problem with more finesse.<br>&gt; <br>&gt; Value types are one of the attractive features of Swift – because of their semantics, mutating algorithms are written in a familiar style but keeping effects limited to your unique reference. I don&#39;t think we should give that up now to address confusion about semantics, out of principle, or in anticipation of new language features. I propose cancelling this change for Swift 3 and continue to allow `var` in the grammar everywhere it occurs in Swift 2.2.<br>&gt; <br>&gt; Regards,<br>&gt; David<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d1bff9080a4237cc9b79c5751afb6f7?s=50"></div><header><strong>Reconsidering SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Jarod Long</string> &lt;swift at lng.la&gt;<p>January 28, 2016 at 01:00:00pm</p></header><div class="content"><p>I agree completely with Kevin. It doesn&#39;t seem intuitive to me that var in parameters and pattern matching is confusing. I actually see it the opposite way -- &quot;why can I use var here but not there?&quot;. Allowing var wherever let can be used increases consistency, which is rarely a bad thing.<br></p><p>I checked for functions that use var parameters in one of my larger projects and found 29 cases (roughly half of which are implementations of arithmetic operators for custom types, which is an area that benefits significantly from this feature). Most of those cases are functions that return a mutated version of a parameter, which I find to be a common and useful pattern. Less common, but still valuable, are cases where it&#39;s convenient and logical to track some internal state in one of the function&#39;s parameters. For example, a function that draws a list of items of variable height starting at some Y position passed as a parameter can naturally calculate the Y position of the next item by adding each item&#39;s height to the initial Y value as it is rendered.<br></p><p>As someone mentioned earlier, I also think that this is a pretty unfortunate pattern:<br></p><p>if let x = x {<br>	var x = x<br></p><p>Now there are three x&#39;s -- an optional one, an immutable one, and a mutable one, all with the same name. That seems to me to create more possibility for confusion than if var does. You can give each one a different name, but I&#39;ve found that more often than not, it&#39;s very difficult to come up with non-arbitrary distinct names in these kinds of situations, and using names like optionalX or mutableX is so off-putting as to be out of the question for me personally.<br></p><p>I agree that it&#39;s important to always weigh a feature&#39;s value vs. its complexity, but I believe this is a case where the value justifies the complexity.<br></p><p>Jarod<br></p><p>&gt; On Jan 28, 2016, at 11:19, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Oh man, huge +1 from me here.<br>&gt; <br>&gt; Apparently I never actually read that proposal. I was under the impression it only removed var from function parameters. And while I find that mildly annoying, I was ok with it because of the argument for removing as many keywords as possible from function parameter lists (e.g. to open up those keywords to be used as external parameter names). Though I&#39;d really prefer to keep var anyway.<br>&gt; <br>&gt; But I didn&#39;t realize until now that it also prohibits `var` from _all_ pattern matching, such as if-let, guard-let, etc. And I find that incredibly restrictive. I am not ok at all with that restriction. It makes no sense to me, and it makes a lot of very clean code become much messier by the addition of completely spurious `var foo = foo` lines everywhere. What&#39;s more, you can&#39;t even add lines like that everywhere because of Swift&#39;s prohibition from shadowing variables from the same scope (e.g. you can&#39;t shadow the variable bound from `guard let` because it&#39;s in the same scope).<br>&gt; <br>&gt; I see Dave Abrahams arguing that this feature is tripping some people up. But I don&#39;t see that as appropriate grounds for removing it from the language. If people don&#39;t understand `if var` or `for var x in` then they can just not write code that uses that feature. And if the argument is that people might have to read other code that uses that, well, there&#39;s plenty of stuff in Swift that you have to actually learn about before you can understand how it works, and using `var` in patterns does not seem like one of the trickiest things. And if the confusion stems from not understanding the difference between `var` and `inout`, I don&#39;t see how preventing someone from writing `if var` will solve that confusion, because the same person would presumably have the same confusion about `var foo = bar`.<br>&gt; <br>&gt; -Kevin Ballard<br>&gt; <br>&gt; On Fri, Jan 22, 2016, at 09:26 AM, David Farler via swift-evolution wrote:<br>&gt;&gt; Hello everyone,<br>&gt;&gt; <br>&gt;&gt; I&#39;d like to reconsider SE-0003 for Swift 3 and propose cancelling the change in its entirety. After collecting feedback since Swift&#39;s open source launch, I no longer feel this is a good move and there are a few reasons why.<br>&gt;&gt; <br>&gt;&gt; There are two main patterns that the removal penalizes:<br>&gt;&gt; <br>&gt;&gt; - Get-Modify-Reassign<br>&gt;&gt; - Get-Modify-Return<br>&gt;&gt; <br>&gt;&gt; I&#39;ve found that many of the problems with this proposal stem from the uses before and after the &quot;Modify&quot; part, before returning or reassigning with the new value.<br>&gt;&gt; <br>&gt;&gt; I&#39;ve seen a few common responses to the var removal. Consider a `Rectangle` struct:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; struct Rectangle {<br>&gt;&gt; var origin: (x: Double, y: Double)<br>&gt;&gt; var size: (width: Double, height: Double)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Even with mutable variables `origin` and `size`, this pattern would be impossible:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; var selection = getRectangularSelection()<br>&gt;&gt; if var rect = selection?.rect {<br>&gt;&gt; // Mutate `rect` ...<br>&gt;&gt; selection.rect = rect<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; So, one might shadow the variable, which is not ideal:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; var selection = getRectangularSelection()<br>&gt;&gt; if let rect = selection?.rect {<br>&gt;&gt; var rect = rect // Not so great<br>&gt;&gt; // Mutate `rect` ...<br>&gt;&gt; selection.rect = rect<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Or, you might make a transformation function on `Rect`:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; struct Rectangle {<br>&gt;&gt; var origin: (x: Double, y: Double)<br>&gt;&gt; var size: (width: Double, height: Double)<br>&gt;&gt; func withOrigin(x: Double, y: Double) -&gt; Rect {<br>&gt;&gt;   var r = self<br>&gt;&gt;   r.origin = (x, y)<br>&gt;&gt;   return r<br>&gt;&gt; }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; This is a much better solution than shadowing but you would need one of these for any property that you want to mutate and I think you&#39;ll agree that it doesn&#39;t scale with the language we have today. This response begs for a kind of initializer that takes all of the fields of the original struct except any that you want to override:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; if let rect = selection?.rect.with(origin: newOrigin) {<br>&gt;&gt; // ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Straw syntax, but maybe you&#39;ll see something along these lines on swift-evolution in the future, which would provide a clear alternative to direct mutation patterns. Even then, I think having complementary patterns in the language isn&#39;t a bad thing.<br>&gt;&gt; <br>&gt;&gt; These problems come up with the other variable bindings but the one that ended up bothering me the most was `guard var`:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; func transform(selection: Rect?) {<br>&gt;&gt; guard let rect = selection else { return }<br>&gt;&gt; var _rect = rect<br>&gt;&gt; // Mutate `_rect` ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; One of the guard statement&#39;s main purposes is to conditionally bind a value as a peer in its own scope, not an inner scope like if statements. Not having var makes the guard statement much weaker.<br>&gt;&gt; <br>&gt;&gt; There is certainly a bit of confusion about the nuances between value and reference semantics, who owns a value and when, how effects are propagated back to values, but I think we can attack the problem with more finesse.<br>&gt;&gt; <br>&gt;&gt; Value types are one of the attractive features of Swift – because of their semantics, mutating algorithms are written in a familiar style but keeping effects limited to your unique reference. I don&#39;t think we should give that up now to address confusion about semantics, out of principle, or in anticipation of new language features. I propose cancelling this change for Swift 3 and continue to allow `var` in the grammar everywhere it occurs in Swift 2.2.<br>&gt;&gt; <br>&gt;&gt; Regards,<br>&gt;&gt; David<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/b41ca475/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ab486d7597af4cfe0be33a762150848?s=50"></div><header><strong>Reconsidering SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Dany St-Amant</string> &lt;dsa.mls at icloud.com&gt;<p>January 29, 2016 at 07:00:00am</p></header><div class="content"><p>Neither for or agains the if var, I just wanted to comment on the generic example used in this discussion.<br></p><p>The vast majority of the example provided in this discussion use variable shadowing, and a brief context<br>if var x = x {<br>    x =+ x<br>    print(&quot;x is \(x)&quot;)<br>}<br></p><p>It is easy for the original code writer to fully know that the mutation on x is not visible outside the if<br>if var x = x {<br>    x =+ x<br>    print(&quot;x is \(x)&quot;) // Modified copy<br>}<br>print(&quot;x is \(x)&quot;) // Original copy<br></p><p>We can even say that the future code maintainer will quickly get it due to the short span of the code.<br></p><p>But as the code grows:<br>if var x = x {<br>    // some 25 lines of implementation<br>    x =+ x<br>    print(&quot;x is \(x)&quot;)<br>}<br>print(&quot;x is \(x)&quot;)<br></p><p>For the code maintainer, the if var can then easily fall outside his visual range, so the code look like:<br>    x =+ x<br>    print(&quot;x is \(x)&quot;)<br>}<br>print(&quot;x is \(x)&quot;)<br></p><p>The reason as to why the two print display different result can then be quite a head scratcher.<br></p><p>Having support for if var without shadowing might have its merit:<br>if var y = x { /*  */ }<br>which need to be currently one as<br>if let tmp = x {<br>    var y = tmp<br>}<br></p><p>But it seems that either way, the presence/need of if var, encourage people to use variable shadowing. Shadowing is a required evil in the world of name clashing, but in this if var concept it is a really bad habit.<br></p><p>Dany<br></p><p><br>&gt; Le 28 janv. 2016 à 16:45, Jarod Long via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; I agree completely with Kevin. It doesn&#39;t seem intuitive to me that var in parameters and pattern matching is confusing. I actually see it the opposite way -- &quot;why can I use var here but not there?&quot;. Allowing var wherever let can be used increases consistency, which is rarely a bad thing.<br>&gt; <br>&gt; I checked for functions that use var parameters in one of my larger projects and found 29 cases (roughly half of which are implementations of arithmetic operators for custom types, which is an area that benefits significantly from this feature). Most of those cases are functions that return a mutated version of a parameter, which I find to be a common and useful pattern. Less common, but still valuable, are cases where it&#39;s convenient and logical to track some internal state in one of the function&#39;s parameters. For example, a function that draws a list of items of variable height starting at some Y position passed as a parameter can naturally calculate the Y position of the next item by adding each item&#39;s height to the initial Y value as it is rendered.<br>&gt; <br>&gt; As someone mentioned earlier, I also think that this is a pretty unfortunate pattern:<br>&gt; <br>&gt; if let x = x {<br>&gt; 	var x = x<br>&gt; <br>&gt; Now there are three x&#39;s -- an optional one, an immutable one, and a mutable one, all with the same name. That seems to me to create more possibility for confusion than if var does. You can give each one a different name, but I&#39;ve found that more often than not, it&#39;s very difficult to come up with non-arbitrary distinct names in these kinds of situations, and using names like optionalX or mutableX is so off-putting as to be out of the question for me personally.<br>&gt; <br>&gt; I agree that it&#39;s important to always weigh a feature&#39;s value vs. its complexity, but I believe this is a case where the value justifies the complexity.<br>&gt; <br>&gt; Jarod<br>&gt; <br>&gt;&gt; On Jan 28, 2016, at 11:19, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Oh man, huge +1 from me here.<br>&gt;&gt; <br>&gt;&gt; Apparently I never actually read that proposal. I was under the impression it only removed var from function parameters. And while I find that mildly annoying, I was ok with it because of the argument for removing as many keywords as possible from function parameter lists (e.g. to open up those keywords to be used as external parameter names). Though I&#39;d really prefer to keep var anyway.<br>&gt;&gt; <br>&gt;&gt; But I didn&#39;t realize until now that it also prohibits `var` from _all_ pattern matching, such as if-let, guard-let, etc. And I find that incredibly restrictive. I am not ok at all with that restriction. It makes no sense to me, and it makes a lot of very clean code become much messier by the addition of completely spurious `var foo = foo` lines everywhere. What&#39;s more, you can&#39;t even add lines like that everywhere because of Swift&#39;s prohibition from shadowing variables from the same scope (e.g. you can&#39;t shadow the variable bound from `guard let` because it&#39;s in the same scope).<br>&gt;&gt; <br>&gt;&gt; I see Dave Abrahams arguing that this feature is tripping some people up. But I don&#39;t see that as appropriate grounds for removing it from the language. If people don&#39;t understand `if var` or `for var x in` then they can just not write code that uses that feature. And if the argument is that people might have to read other code that uses that, well, there&#39;s plenty of stuff in Swift that you have to actually learn about before you can understand how it works, and using `var` in patterns does not seem like one of the trickiest things. And if the confusion stems from not understanding the difference between `var` and `inout`, I don&#39;t see how preventing someone from writing `if var` will solve that confusion, because the same person would presumably have the same confusion about `var foo = bar`.<br>&gt;&gt; <br>&gt;&gt; -Kevin Ballard<br>&gt;&gt; <br>&gt;&gt; On Fri, Jan 22, 2016, at 09:26 AM, David Farler via swift-evolution wrote:<br>&gt;&gt;&gt; Hello everyone,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;d like to reconsider SE-0003 for Swift 3 and propose cancelling the change in its entirety. After collecting feedback since Swift&#39;s open source launch, I no longer feel this is a good move and there are a few reasons why.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are two main patterns that the removal penalizes:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Get-Modify-Reassign<br>&gt;&gt;&gt; - Get-Modify-Return<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;ve found that many of the problems with this proposal stem from the uses before and after the &quot;Modify&quot; part, before returning or reassigning with the new value.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;ve seen a few common responses to the var removal. Consider a `Rectangle` struct:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Rectangle {<br>&gt;&gt;&gt; var origin: (x: Double, y: Double)<br>&gt;&gt;&gt; var size: (width: Double, height: Double)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Even with mutable variables `origin` and `size`, this pattern would be impossible:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var selection = getRectangularSelection()<br>&gt;&gt;&gt; if var rect = selection?.rect {<br>&gt;&gt;&gt; // Mutate `rect` ...<br>&gt;&gt;&gt; selection.rect = rect<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So, one might shadow the variable, which is not ideal:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var selection = getRectangularSelection()<br>&gt;&gt;&gt; if let rect = selection?.rect {<br>&gt;&gt;&gt; var rect = rect // Not so great<br>&gt;&gt;&gt; // Mutate `rect` ...<br>&gt;&gt;&gt; selection.rect = rect<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Or, you might make a transformation function on `Rect`:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Rectangle {<br>&gt;&gt;&gt; var origin: (x: Double, y: Double)<br>&gt;&gt;&gt; var size: (width: Double, height: Double)<br>&gt;&gt;&gt; func withOrigin(x: Double, y: Double) -&gt; Rect {<br>&gt;&gt;&gt;   var r = self<br>&gt;&gt;&gt;   r.origin = (x, y)<br>&gt;&gt;&gt;   return r<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a much better solution than shadowing but you would need one of these for any property that you want to mutate and I think you&#39;ll agree that it doesn&#39;t scale with the language we have today. This response begs for a kind of initializer that takes all of the fields of the original struct except any that you want to override:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; if let rect = selection?.rect.with(origin: newOrigin) {<br>&gt;&gt;&gt; // ...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Straw syntax, but maybe you&#39;ll see something along these lines on swift-evolution in the future, which would provide a clear alternative to direct mutation patterns. Even then, I think having complementary patterns in the language isn&#39;t a bad thing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; These problems come up with the other variable bindings but the one that ended up bothering me the most was `guard var`:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func transform(selection: Rect?) {<br>&gt;&gt;&gt; guard let rect = selection else { return }<br>&gt;&gt;&gt; var _rect = rect<br>&gt;&gt;&gt; // Mutate `_rect` ...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One of the guard statement&#39;s main purposes is to conditionally bind a value as a peer in its own scope, not an inner scope like if statements. Not having var makes the guard statement much weaker.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There is certainly a bit of confusion about the nuances between value and reference semantics, who owns a value and when, how effects are propagated back to values, but I think we can attack the problem with more finesse.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Value types are one of the attractive features of Swift – because of their semantics, mutating algorithms are written in a familiar style but keeping effects limited to your unique reference. I don&#39;t think we should give that up now to address confusion about semantics, out of principle, or in anticipation of new language features. I propose cancelling this change for Swift 3 and continue to allow `var` in the grammar everywhere it occurs in Swift 2.2.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Regards,<br>&gt;&gt;&gt; David<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/d50c0684/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Reconsidering SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>January 29, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On 29 Jan 2016, at 12:25, Dany St-Amant via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Shadowing is a required evil in the world of name clashing, but in this if var concept it is a really bad habit.<br></p><p>Is it though? I mean, I can understand clashes occurring when you use the same local variable/parameter name as you do for a property, but this is easily solved by always using self. in front of usage of the actual property.<br></p><p>Other than that, in my experience at least, a lot of clashes come from poor variable naming; while I understand the appeal of short names for loop indices, it’s not as if we need them a lot thanks to the wealth of options available for accessing sequences so it’s not really a huge burden to use someIndex or whatever as a name. Besides which descriptive variable names are a huge benefit to maintenance in general. At lot the examples are let x = x, to which my first thought is “pick two actual names that tell me something&quot;<br></p><p>Personally I’d prefer to see shadowing of local variables eliminated entirely, as there should be no excuse for running out of names within the scope of a single function, because well designed function implementations shouldn’t be so long (or use so many variables) as to make that a possibility. The only shadowing I’m fine with is parameters over properties, but that’s only because everyone should (in my opinion) be using self. for properties all the time anyway (even when there’s no current naming conflict).<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e941adb360692446106cebd7f6d2a1a3?s=50"></div><header><strong>Reconsidering SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Charles Constant</string> &lt;charles at charlesism.com&gt;<p>January 29, 2016 at 04:00:00am</p></header><div class="content"><p>Im for keeping this<br></p><p><br>&gt; if var x = x {<br></p><p><br>Actually, I&#39;m hoping Swift allows us to group let/var/optional and<br>non-optional together. At the moment, a lot of my functions start out with<br>a couple groups of declarations, before I get to the &quot;meat&quot; of my function.<br>I&#39;m hoping someday  we can do this:<br></p><p><br>// set up, make sure we unwrap whatever needs unwrapping, and set up<br>whatever vars we&#39;ll use<br></p><p>guard<br>result_var = Gronk.init()<br>foo_const = arg.bar_opt,<br>baz_var = do_something( )<br>quux_const = 1567<br>else { return nil }<br></p><p>// the &quot;meat&quot; of my function<br></p><p>...<br></p><p>The reason I&#39;d like to arrange things this way is that I could spend more<br>time focusing on the logic side of my functions, instead of having to parse<br>though where my nil checks, and declarations end.<br></p><p>This might be obvious bad form to someone who&#39;s taken more CompSci classes<br>than I have. I realize that for example, having one point of failure for<br>several unrelated things is ambiguous, and that there would need to be more<br>syntax to specify what is being declared as let vs var.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/1e0f042b/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f7d3036e2eaf1283f20f43d62472a29f?s=50"></div><header><strong>Reconsidering SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>David Farler</string> &lt;dfarler at apple.com&gt;<p>January 28, 2016 at 02:00:00pm</p></header><div class="content"><p>Thanks for your feedback, Kevin. As it stands, for this proposal, I think that there is merit in making function parameters only either `let` or `inout` because of var/inout confusion but it doesn&#39;t map well onto the other kinds of pattern matching, IMO.<br></p><p>David<br></p><p>&gt; On Jan 28, 2016, at 11:19 AM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Oh man, huge +1 from me here.<br>&gt; <br>&gt; Apparently I never actually read that proposal. I was under the impression it only removed var from function parameters. And while I find that mildly annoying, I was ok with it because of the argument for removing as many keywords as possible from function parameter lists (e.g. to open up those keywords to be used as external parameter names). Though I&#39;d really prefer to keep var anyway.<br>&gt; <br>&gt; But I didn&#39;t realize until now that it also prohibits `var` from _all_ pattern matching, such as if-let, guard-let, etc. And I find that incredibly restrictive. I am not ok at all with that restriction. It makes no sense to me, and it makes a lot of very clean code become much messier by the addition of completely spurious `var foo = foo` lines everywhere. What&#39;s more, you can&#39;t even add lines like that everywhere because of Swift&#39;s prohibition from shadowing variables from the same scope (e.g. you can&#39;t shadow the variable bound from `guard let` because it&#39;s in the same scope).<br>&gt; <br>&gt; I see Dave Abrahams arguing that this feature is tripping some people up. But I don&#39;t see that as appropriate grounds for removing it from the language. If people don&#39;t understand `if var` or `for var x in` then they can just not write code that uses that feature. And if the argument is that people might have to read other code that uses that, well, there&#39;s plenty of stuff in Swift that you have to actually learn about before you can understand how it works, and using `var` in patterns does not seem like one of the trickiest things. And if the confusion stems from not understanding the difference between `var` and `inout`, I don&#39;t see how preventing someone from writing `if var` will solve that confusion, because the same person would presumably have the same confusion about `var foo = bar`.<br>&gt; <br>&gt; -Kevin Ballard<br>&gt; <br>&gt; On Fri, Jan 22, 2016, at 09:26 AM, David Farler via swift-evolution wrote:<br>&gt;&gt; Hello everyone,<br>&gt;&gt; <br>&gt;&gt; I&#39;d like to reconsider SE-0003 for Swift 3 and propose cancelling the change in its entirety. After collecting feedback since Swift&#39;s open source launch, I no longer feel this is a good move and there are a few reasons why.<br>&gt;&gt; <br>&gt;&gt; There are two main patterns that the removal penalizes:<br>&gt;&gt; <br>&gt;&gt; - Get-Modify-Reassign<br>&gt;&gt; - Get-Modify-Return<br>&gt;&gt; <br>&gt;&gt; I&#39;ve found that many of the problems with this proposal stem from the uses before and after the &quot;Modify&quot; part, before returning or reassigning with the new value.<br>&gt;&gt; <br>&gt;&gt; I&#39;ve seen a few common responses to the var removal. Consider a `Rectangle` struct:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; struct Rectangle {<br>&gt;&gt; var origin: (x: Double, y: Double)<br>&gt;&gt; var size: (width: Double, height: Double)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Even with mutable variables `origin` and `size`, this pattern would be impossible:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; var selection = getRectangularSelection()<br>&gt;&gt; if var rect = selection?.rect {<br>&gt;&gt; // Mutate `rect` ...<br>&gt;&gt; selection.rect = rect<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; So, one might shadow the variable, which is not ideal:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; var selection = getRectangularSelection()<br>&gt;&gt; if let rect = selection?.rect {<br>&gt;&gt; var rect = rect // Not so great<br>&gt;&gt; // Mutate `rect` ...<br>&gt;&gt; selection.rect = rect<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Or, you might make a transformation function on `Rect`:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; struct Rectangle {<br>&gt;&gt; var origin: (x: Double, y: Double)<br>&gt;&gt; var size: (width: Double, height: Double)<br>&gt;&gt; func withOrigin(x: Double, y: Double) -&gt; Rect {<br>&gt;&gt;   var r = self<br>&gt;&gt;   r.origin = (x, y)<br>&gt;&gt;   return r<br>&gt;&gt; }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; This is a much better solution than shadowing but you would need one of these for any property that you want to mutate and I think you&#39;ll agree that it doesn&#39;t scale with the language we have today. This response begs for a kind of initializer that takes all of the fields of the original struct except any that you want to override:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; if let rect = selection?.rect.with(origin: newOrigin) {<br>&gt;&gt; // ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Straw syntax, but maybe you&#39;ll see something along these lines on swift-evolution in the future, which would provide a clear alternative to direct mutation patterns. Even then, I think having complementary patterns in the language isn&#39;t a bad thing.<br>&gt;&gt; <br>&gt;&gt; These problems come up with the other variable bindings but the one that ended up bothering me the most was `guard var`:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; func transform(selection: Rect?) {<br>&gt;&gt; guard let rect = selection else { return }<br>&gt;&gt; var _rect = rect<br>&gt;&gt; // Mutate `_rect` ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; One of the guard statement&#39;s main purposes is to conditionally bind a value as a peer in its own scope, not an inner scope like if statements. Not having var makes the guard statement much weaker.<br>&gt;&gt; <br>&gt;&gt; There is certainly a bit of confusion about the nuances between value and reference semantics, who owns a value and when, how effects are propagated back to values, but I think we can attack the problem with more finesse.<br>&gt;&gt; <br>&gt;&gt; Value types are one of the attractive features of Swift – because of their semantics, mutating algorithms are written in a familiar style but keeping effects limited to your unique reference. I don&#39;t think we should give that up now to address confusion about semantics, out of principle, or in anticipation of new language features. I propose cancelling this change for Swift 3 and continue to allow `var` in the grammar everywhere it occurs in Swift 2.2.<br>&gt;&gt; <br>&gt;&gt; Regards,<br>&gt;&gt; David<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Reconsidering SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January 29, 2016 at 06:00:00am</p></header><div class="content"><p>I completely agree with Kevin, especially with the statement that people having problems understanding how &quot;if var&quot; works will replace it with &quot;if let&quot; followed by &quot;var x = x&quot; and having just the same problem.<br></p><p>-Thorsten <br></p><p>&gt; Am 28.01.2016 um 20:19 schrieb Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Oh man, huge +1 from me here.<br>&gt; <br>&gt; Apparently I never actually read that proposal. I was under the impression it only removed var from function parameters. And while I find that mildly annoying, I was ok with it because of the argument for removing as many keywords as possible from function parameter lists (e.g. to open up those keywords to be used as external parameter names). Though I&#39;d really prefer to keep var anyway.<br>&gt; <br>&gt; But I didn&#39;t realize until now that it also prohibits `var` from _all_ pattern matching, such as if-let, guard-let, etc. And I find that incredibly restrictive. I am not ok at all with that restriction. It makes no sense to me, and it makes a lot of very clean code become much messier by the addition of completely spurious `var foo = foo` lines everywhere. What&#39;s more, you can&#39;t even add lines like that everywhere because of Swift&#39;s prohibition from shadowing variables from the same scope (e.g. you can&#39;t shadow the variable bound from `guard let` because it&#39;s in the same scope).<br>&gt; <br>&gt; I see Dave Abrahams arguing that this feature is tripping some people up. But I don&#39;t see that as appropriate grounds for removing it from the language. If people don&#39;t understand `if var` or `for var x in` then they can just not write code that uses that feature. And if the argument is that people might have to read other code that uses that, well, there&#39;s plenty of stuff in Swift that you have to actually learn about before you can understand how it works, and using `var` in patterns does not seem like one of the trickiest things. And if the confusion stems from not understanding the difference between `var` and `inout`, I don&#39;t see how preventing someone from writing `if var` will solve that confusion, because the same person would presumably have the same confusion about `var foo = bar`.<br>&gt; <br>&gt; -Kevin Ballard<br>&gt; <br>&gt;&gt; On Fri, Jan 22, 2016, at 09:26 AM, David Farler via swift-evolution wrote:<br>&gt;&gt; Hello everyone,<br>&gt;&gt; <br>&gt;&gt; I&#39;d like to reconsider SE-0003 for Swift 3 and propose cancelling the change in its entirety. After collecting feedback since Swift&#39;s open source launch, I no longer feel this is a good move and there are a few reasons why.<br>&gt;&gt; <br>&gt;&gt; There are two main patterns that the removal penalizes:<br>&gt;&gt; <br>&gt;&gt; - Get-Modify-Reassign<br>&gt;&gt; - Get-Modify-Return<br>&gt;&gt; <br>&gt;&gt; I&#39;ve found that many of the problems with this proposal stem from the uses before and after the &quot;Modify&quot; part, before returning or reassigning with the new value.<br>&gt;&gt; <br>&gt;&gt; I&#39;ve seen a few common responses to the var removal. Consider a `Rectangle` struct:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; struct Rectangle {<br>&gt;&gt; var origin: (x: Double, y: Double)<br>&gt;&gt; var size: (width: Double, height: Double)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Even with mutable variables `origin` and `size`, this pattern would be impossible:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; var selection = getRectangularSelection()<br>&gt;&gt; if var rect = selection?.rect {<br>&gt;&gt; // Mutate `rect` ...<br>&gt;&gt; selection.rect = rect<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; So, one might shadow the variable, which is not ideal:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; var selection = getRectangularSelection()<br>&gt;&gt; if let rect = selection?.rect {<br>&gt;&gt; var rect = rect // Not so great<br>&gt;&gt; // Mutate `rect` ...<br>&gt;&gt; selection.rect = rect<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Or, you might make a transformation function on `Rect`:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; struct Rectangle {<br>&gt;&gt; var origin: (x: Double, y: Double)<br>&gt;&gt; var size: (width: Double, height: Double)<br>&gt;&gt; func withOrigin(x: Double, y: Double) -&gt; Rect {<br>&gt;&gt;   var r = self<br>&gt;&gt;   r.origin = (x, y)<br>&gt;&gt;   return r<br>&gt;&gt; }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; This is a much better solution than shadowing but you would need one of these for any property that you want to mutate and I think you&#39;ll agree that it doesn&#39;t scale with the language we have today. This response begs for a kind of initializer that takes all of the fields of the original struct except any that you want to override:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; if let rect = selection?.rect.with(origin: newOrigin) {<br>&gt;&gt; // ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Straw syntax, but maybe you&#39;ll see something along these lines on swift-evolution in the future, which would provide a clear alternative to direct mutation patterns. Even then, I think having complementary patterns in the language isn&#39;t a bad thing.<br>&gt;&gt; <br>&gt;&gt; These problems come up with the other variable bindings but the one that ended up bothering me the most was `guard var`:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; func transform(selection: Rect?) {<br>&gt;&gt; guard let rect = selection else { return }<br>&gt;&gt; var _rect = rect<br>&gt;&gt; // Mutate `_rect` ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; One of the guard statement&#39;s main purposes is to conditionally bind a value as a peer in its own scope, not an inner scope like if statements. Not having var makes the guard statement much weaker.<br>&gt;&gt; <br>&gt;&gt; There is certainly a bit of confusion about the nuances between value and reference semantics, who owns a value and when, how effects are propagated back to values, but I think we can attack the problem with more finesse.<br>&gt;&gt; <br>&gt;&gt; Value types are one of the attractive features of Swift – because of their semantics, mutating algorithms are written in a familiar style but keeping effects limited to your unique reference. I don&#39;t think we should give that up now to address confusion about semantics, out of principle, or in anticipation of new language features. I propose cancelling this change for Swift 3 and continue to allow `var` in the grammar everywhere it occurs in Swift 2.2.<br>&gt;&gt; <br>&gt;&gt; Regards,<br>&gt;&gt; David<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
