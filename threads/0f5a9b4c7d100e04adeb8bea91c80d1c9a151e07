<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/17411ddb51e17861ef4f8e2d866f7ab6?s=50"></div><header><strong>[Idea] Add @pure annotation or keyword to force pure functions</strong> from <string>Guido Marucci Blas</string> &lt;guidomb at gmail.com&gt;<p>September  8, 2016 at 03:00:00pm</p></header><div class="content"><p>Hi, I wanted to discussed an idea that I’ve been thinking for the last couple of weeks. First I want to give you a little bit of context. I am the technical leader  in the iOS project I am working on. We have been using Swift for almost one year and half. Most of the first part of the project was desinged by me. I am being trying to apply concepts from the functional paradigm and in particular we heavily depend on ReactiveCocoa. For the last year two less experienced developers joined the team. I was in charge of teaching them about iOS programming (this was the first time doing an iOS app for them), functional programming (they are still college student with a background in OOP) and the details of our code base.<br></p><p>Coming from a background in OOP and imperative programming makes the change to a more functional approach quite “interesting”. I really like Swift and its flexibility to be able to tackle both low level and high level problems. But some times this flexibility makes it more error prone when you try to apply functional programming concepts. For example I found my self reviewing and correcting pull request with things like “When you use functions like map or filter on a collection or a SignalProducer don’t inject side effects”.<br></p><p>This led me to the idea of introducing a @pure annotation for functions. Full disclosure: I have almost no background in compilers and the internals of the Swift language so I have no idea if this makes sense at all. Such a annotation (it could also be a keyword like override o mutating) will make the compiler check if the function is actually a pure function, where by Pure I mean<br></p><p>	- It doesn’t mutate any internal or global state <br>	- It doesn’t call any non-pure function<br>	- It must have a return type != from Void<br>	- It can access non mutable state<br></p><p>In this context a pure function is “stronger” than the mutating keyword in the sense that the pure function won’t allow any type of mutation even if you are calling a non-pure method (which performs a mutation or a side effect) on an object (reference type) instead of a struct. For example<br></p><p>final class Foo {<br>    <br>    <br>    private var count = 0<br>    <br>    func foo(x: Int) -&gt; Int {<br>        count += x<br>        return count<br>    }<br>    <br>}<br></p><p>struct Bar {<br>    <br>    var count: Int<br>    var foo: Foo<br>    <br>    // This method performs a mutation<br>    // even though is not marked as mutating<br>    // You could call it a &quot;transitive mutation&quot;.<br>    func bar(x: Int) -&gt; Int {<br>        return foo.foo(x)<br>    }<br>    <br>    mutating func baz(x: Int) -&gt; Int {<br>        count += x<br>        return count<br>    }<br>    <br>    <br>}<br></p><p><br>This could be extended to classes and structs. Adding “pure” to a class or structs makes all of its methods pure.<br></p><p>The benefit of such feature is that you could gradually add more functional code that is checked by the compiler and it is optional. I am most probably missing a lot issues here. This is just a rough idea but I wanted to share it with the community to better understand the tradeoffs.<br></p><p>If this has already been discussed can anyone point me to that discussion?<br></p><p>Thanks!<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160908/0f5a1e07/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[Idea] Add @pure annotation or keyword to force pure functions</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>September  9, 2016 at 12:00:00pm</p></header><div class="content"><p>It seems you&#39;ve been beaten to the punch! https://github.com/apple/swift/blob/master/docs/HighLevelSILOptimizations.rst#id12<br></p><p>Please don&#39;t use these attributes in production code.  They make things go fast, but they also destroy any hope of good debug info and can cause UB if used incorrectly.<br></p><p>~Robert Widmann<br></p><p>2016/09/08 14:19、Guido Marucci Blas via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br></p><p>&gt; Hi, I wanted to discussed an idea that I’ve been thinking for the last couple of weeks. First I want to give you a little bit of context. I am the technical leader  in the iOS project I am working on. We have been using Swift for almost one year and half. Most of the first part of the project was desinged by me. I am being trying to apply concepts from the functional paradigm and in particular we heavily depend on ReactiveCocoa. For the last year two less experienced developers joined the team. I was in charge of teaching them about iOS programming (this was the first time doing an iOS app for them), functional programming (they are still college student with a background in OOP) and the details of our code base.<br>&gt; <br>&gt; Coming from a background in OOP and imperative programming makes the change to a more functional approach quite “interesting”. I really like Swift and its flexibility to be able to tackle both low level and high level problems. But some times this flexibility makes it more error prone when you try to apply functional programming concepts. For example I found my self reviewing and correcting pull request with things like “When you use functions like map or filter on a collection or a SignalProducer don’t inject side effects”.<br>&gt; <br>&gt; This led me to the idea of introducing a @pure annotation for functions. Full disclosure: I have almost no background in compilers and the internals of the Swift language so I have no idea if this makes sense at all. Such a annotation (it could also be a keyword like override o mutating) will make the compiler check if the function is actually a pure function, where by Pure I mean<br>&gt; <br>&gt; 	- It doesn’t mutate any internal or global state <br>&gt; 	- It doesn’t call any non-pure function<br>&gt; 	- It must have a return type != from Void<br>&gt; 	- It can access non mutable state<br>&gt; <br>&gt; In this context a pure function is “stronger” than the mutating keyword in the sense that the pure function won’t allow any type of mutation even if you are calling a non-pure method (which performs a mutation or a side effect) on an object (reference type) instead of a struct. For example<br>&gt; <br>&gt; final class Foo {<br>&gt;     <br>&gt;     <br>&gt;     private var count = 0<br>&gt;     <br>&gt;     func foo(x: Int) -&gt; Int {<br>&gt;         count += x<br>&gt;         return count<br>&gt;     }<br>&gt;     <br>&gt; }<br>&gt; <br>&gt; struct Bar {<br>&gt;     <br>&gt;     var count: Int<br>&gt;     var foo: Foo<br>&gt;     <br>&gt;     // This method performs a mutation<br>&gt;     // even though is not marked as mutating<br>&gt;     // You could call it a &quot;transitive mutation&quot;.<br>&gt;     func bar(x: Int) -&gt; Int {<br>&gt;         return foo.foo(x)<br>&gt;     }<br>&gt;     <br>&gt;     mutating func baz(x: Int) -&gt; Int {<br>&gt;         count += x<br>&gt;         return count<br>&gt;     }<br>&gt;     <br>&gt;     <br>&gt; }<br>&gt; <br>&gt; <br>&gt; This could be extended to classes and structs. Adding “pure” to a class or structs makes all of its methods pure.<br>&gt; <br>&gt; The benefit of such feature is that you could gradually add more functional code that is checked by the compiler and it is optional. I am most probably missing a lot issues here. This is just a rough idea but I wanted to share it with the community to better understand the tradeoffs.<br>&gt; <br>&gt; If this has already been discussed can anyone point me to that discussion?<br>&gt; <br>&gt; Thanks!<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160909/97cba539/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/15ed660cd9d971062f9dd5084932a698?s=50"></div><header><strong>[Idea] Add @pure annotation or keyword to force pure functions</strong> from <string>David Rönnqvist</string> &lt;david.ronnqvist at gmail.com&gt;<p>September  9, 2016 at 09:00:00pm</p></header><div class="content"><p>It could be nice to have something similar to the @effects attribute, _but_ where the compiler could tell if the annotation was valid or not. Meaning that if I believe a function to be pure, I could annotate it as such. If the compiler notices that I&#39;m reading from some global state, that annotation would be an error (possibly even with fix-its to either change the annotation (to read only)  or to remove the line that is reading the global state).<br></p><p>One could make the argument that such an annotation should never be needed because if the compiler can tell that a function is pure, shouldn&#39;t it perform these optimizations anyway? But if a potential @pure annotation is used as a developer&#39;s way of verifying assumptions about their code (&quot;my intention here is for this function to be pure&quot;) rather than being used to enable optimizations, then I do feel that it could be useful. <br></p><p>I have on a few occasions wanted an attribute like that (both &quot;pure&quot; and &quot;read only&quot;). <br></p><p>- David <br></p><p>&gt; On 9 Sep 2016, at 18:22, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; It seems you&#39;ve been beaten to the punch! https://github.com/apple/swift/blob/master/docs/HighLevelSILOptimizations.rst#id12<br>&gt; <br>&gt; Please don&#39;t use these attributes in production code.  They make things go fast, but they also destroy any hope of good debug info and can cause UB if used incorrectly.<br>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt; 2016/09/08 14:19、Guido Marucci Blas via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br>&gt; <br>&gt;&gt; Hi, I wanted to discussed an idea that I’ve been thinking for the last couple of weeks. First I want to give you a little bit of context. I am the technical leader  in the iOS project I am working on. We have been using Swift for almost one year and half. Most of the first part of the project was desinged by me. I am being trying to apply concepts from the functional paradigm and in particular we heavily depend on ReactiveCocoa. For the last year two less experienced developers joined the team. I was in charge of teaching them about iOS programming (this was the first time doing an iOS app for them), functional programming (they are still college student with a background in OOP) and the details of our code base.<br>&gt;&gt; <br>&gt;&gt; Coming from a background in OOP and imperative programming makes the change to a more functional approach quite “interesting”. I really like Swift and its flexibility to be able to tackle both low level and high level problems. But some times this flexibility makes it more error prone when you try to apply functional programming concepts. For example I found my self reviewing and correcting pull request with things like “When you use functions like map or filter on a collection or a SignalProducer don’t inject side effects”.<br>&gt;&gt; <br>&gt;&gt; This led me to the idea of introducing a @pure annotation for functions. Full disclosure: I have almost no background in compilers and the internals of the Swift language so I have no idea if this makes sense at all. Such a annotation (it could also be a keyword like override o mutating) will make the compiler check if the function is actually a pure function, where by Pure I mean<br>&gt;&gt; <br>&gt;&gt; 	- It doesn’t mutate any internal or global state <br>&gt;&gt; 	- It doesn’t call any non-pure function<br>&gt;&gt; 	- It must have a return type != from Void<br>&gt;&gt; 	- It can access non mutable state<br>&gt;&gt; <br>&gt;&gt; In this context a pure function is “stronger” than the mutating keyword in the sense that the pure function won’t allow any type of mutation even if you are calling a non-pure method (which performs a mutation or a side effect) on an object (reference type) instead of a struct. For example<br>&gt;&gt; <br>&gt;&gt; final class Foo {<br>&gt;&gt;     <br>&gt;&gt;     <br>&gt;&gt;     private var count = 0<br>&gt;&gt;     <br>&gt;&gt;     func foo(x: Int) -&gt; Int {<br>&gt;&gt;         count += x<br>&gt;&gt;         return count<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct Bar {<br>&gt;&gt;     <br>&gt;&gt;     var count: Int<br>&gt;&gt;     var foo: Foo<br>&gt;&gt;     <br>&gt;&gt;     // This method performs a mutation<br>&gt;&gt;     // even though is not marked as mutating<br>&gt;&gt;     // You could call it a &quot;transitive mutation&quot;.<br>&gt;&gt;     func bar(x: Int) -&gt; Int {<br>&gt;&gt;         return foo.foo(x)<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     mutating func baz(x: Int) -&gt; Int {<br>&gt;&gt;         count += x<br>&gt;&gt;         return count<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; This could be extended to classes and structs. Adding “pure” to a class or structs makes all of its methods pure.<br>&gt;&gt; <br>&gt;&gt; The benefit of such feature is that you could gradually add more functional code that is checked by the compiler and it is optional. I am most probably missing a lot issues here. This is just a rough idea but I wanted to share it with the community to better understand the tradeoffs.<br>&gt;&gt; <br>&gt;&gt; If this has already been discussed can anyone point me to that discussion?<br>&gt;&gt; <br>&gt;&gt; Thanks!<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160909/7a2ad50b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/17411ddb51e17861ef4f8e2d866f7ab6?s=50"></div><header><strong>[Idea] Add @pure annotation or keyword to force pure functions</strong> from <string>Guido Marucci Blas</string> &lt;guidomb at gmail.com&gt;<p>September  9, 2016 at 05:00:00pm</p></header><div class="content"><p>Robert that is what I was thinking off. Scala does something similar to what you say with the tail recursive annotation.<br></p><p><br>&gt; On Sep 9, 2016, at 4:28 PM, David Rönnqvist &lt;david.ronnqvist at gmail.com&gt; wrote:<br>&gt; <br>&gt; It could be nice to have something similar to the @effects attribute, _but_ where the compiler could tell if the annotation was valid or not. Meaning that if I believe a function to be pure, I could annotate it as such. If the compiler notices that I&#39;m reading from some global state, that annotation would be an error (possibly even with fix-its to either change the annotation (to read only)  or to remove the line that is reading the global state).<br>&gt; <br>&gt; One could make the argument that such an annotation should never be needed because if the compiler can tell that a function is pure, shouldn&#39;t it perform these optimizations anyway? But if a potential @pure annotation is used as a developer&#39;s way of verifying assumptions about their code (&quot;my intention here is for this function to be pure&quot;) rather than being used to enable optimizations, then I do feel that it could be useful. <br>&gt; <br>&gt; I have on a few occasions wanted an attribute like that (both &quot;pure&quot; and &quot;read only&quot;). <br>&gt; <br>&gt; - David <br>&gt; <br>&gt; On 9 Sep 2016, at 18:22, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; It seems you&#39;ve been beaten to the punch! https://github.com/apple/swift/blob/master/docs/HighLevelSILOptimizations.rst#id12 &lt;https://github.com/apple/swift/blob/master/docs/HighLevelSILOptimizations.rst#id12&gt;<br>&gt;&gt; <br>&gt;&gt; Please don&#39;t use these attributes in production code.  They make things go fast, but they also destroy any hope of good debug info and can cause UB if used incorrectly.<br>&gt;&gt; <br>&gt;&gt; ~Robert Widmann<br>&gt;&gt; <br>&gt;&gt; 2016/09/08 14:19、Guido Marucci Blas via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; のメッセージ:<br>&gt;&gt; <br>&gt;&gt;&gt; Hi, I wanted to discussed an idea that I’ve been thinking for the last couple of weeks. First I want to give you a little bit of context. I am the technical leader  in the iOS project I am working on. We have been using Swift for almost one year and half. Most of the first part of the project was desinged by me. I am being trying to apply concepts from the functional paradigm and in particular we heavily depend on ReactiveCocoa. For the last year two less experienced developers joined the team. I was in charge of teaching them about iOS programming (this was the first time doing an iOS app for them), functional programming (they are still college student with a background in OOP) and the details of our code base.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Coming from a background in OOP and imperative programming makes the change to a more functional approach quite “interesting”. I really like Swift and its flexibility to be able to tackle both low level and high level problems. But some times this flexibility makes it more error prone when you try to apply functional programming concepts. For example I found my self reviewing and correcting pull request with things like “When you use functions like map or filter on a collection or a SignalProducer don’t inject side effects”.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This led me to the idea of introducing a @pure annotation for functions. Full disclosure: I have almost no background in compilers and the internals of the Swift language so I have no idea if this makes sense at all. Such a annotation (it could also be a keyword like override o mutating) will make the compiler check if the function is actually a pure function, where by Pure I mean<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	- It doesn’t mutate any internal or global state <br>&gt;&gt;&gt; 	- It doesn’t call any non-pure function<br>&gt;&gt;&gt; 	- It must have a return type != from Void<br>&gt;&gt;&gt; 	- It can access non mutable state<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In this context a pure function is “stronger” than the mutating keyword in the sense that the pure function won’t allow any type of mutation even if you are calling a non-pure method (which performs a mutation or a side effect) on an object (reference type) instead of a struct. For example<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; final class Foo {<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     private var count = 0<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     func foo(x: Int) -&gt; Int {<br>&gt;&gt;&gt;         count += x<br>&gt;&gt;&gt;         return count<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Bar {<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     var count: Int<br>&gt;&gt;&gt;     var foo: Foo<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     // This method performs a mutation<br>&gt;&gt;&gt;     // even though is not marked as mutating<br>&gt;&gt;&gt;     // You could call it a &quot;transitive mutation&quot;.<br>&gt;&gt;&gt;     func bar(x: Int) -&gt; Int {<br>&gt;&gt;&gt;         return foo.foo(x)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     mutating func baz(x: Int) -&gt; Int {<br>&gt;&gt;&gt;         count += x<br>&gt;&gt;&gt;         return count<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This could be extended to classes and structs. Adding “pure” to a class or structs makes all of its methods pure.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The benefit of such feature is that you could gradually add more functional code that is checked by the compiler and it is optional. I am most probably missing a lot issues here. This is just a rough idea but I wanted to share it with the community to better understand the tradeoffs.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If this has already been discussed can anyone point me to that discussion?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks!<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160909/7c4fc436/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Idea] Add @pure annotation or keyword to force pure functions</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>September  9, 2016 at 03:00:00pm</p></header><div class="content"><p>This has been proposed several times before on this list. For example:<br></p><p>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/003684.html<br></p><p>As I recall, in one of these previous threads, there was a very educational<br>discussion on highly technical details. It would be good to familiarize<br>oneself with that discussion. Unfortunately, I&#39;m not able to retrieve the<br>link to that particular thread at the moment.<br></p><p><br>On Fri, Sep 9, 2016 at 3:08 PM, Guido Marucci Blas via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Robert that is what I was thinking off. Scala does something similar to<br>&gt; what you say with the tail recursive annotation.<br>&gt;<br>&gt;<br>&gt; On Sep 9, 2016, at 4:28 PM, David Rönnqvist &lt;david.ronnqvist at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; It could be nice to have something similar to the @effects attribute,<br>&gt; _but_ where the compiler could tell if the annotation was valid or not.<br>&gt; Meaning that if I believe a function to be pure, I could annotate it as<br>&gt; such. If the compiler notices that I&#39;m reading from some global state, that<br>&gt; annotation would be an error (possibly even with fix-its to either change<br>&gt; the annotation (to read only)  or to remove the line that is reading the<br>&gt; global state).<br>&gt;<br>&gt; One could make the argument that such an annotation should never be needed<br>&gt; because if the compiler can tell that a function is pure, shouldn&#39;t it<br>&gt; perform these optimizations anyway? But if a potential @pure annotation is<br>&gt; used as a developer&#39;s way of verifying assumptions about their code (&quot;my<br>&gt; intention here is for this function to be pure&quot;) rather than being used to<br>&gt; enable optimizations, then I do feel that it could be useful.<br>&gt;<br>&gt; I have on a few occasions wanted an attribute like that (both &quot;pure&quot; and<br>&gt; &quot;read only&quot;).<br>&gt;<br>&gt; - David<br>&gt;<br>&gt; On 9 Sep 2016, at 18:22, Robert Widmann via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; It seems you&#39;ve been beaten to the punch! https://github.com/<br>&gt; apple/swift/blob/master/docs/HighLevelSILOptimizations.rst#id12<br>&gt;<br>&gt; Please don&#39;t use these attributes in production code.  They make things go<br>&gt; fast, but they also destroy any hope of good debug info and can cause UB if<br>&gt; used incorrectly.<br>&gt;<br>&gt; ~Robert Widmann<br>&gt;<br>&gt; 2016/09/08 14:19、Guido Marucci Blas via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; のメッセージ:<br>&gt;<br>&gt; Hi, I wanted to discussed an idea that I’ve been thinking for the last<br>&gt; couple of weeks. First I want to give you a little bit of context. I am the<br>&gt; technical leader  in the iOS project I am working on. We have been using<br>&gt; Swift for almost one year and half. Most of the first part of the project<br>&gt; was desinged by me. I am being trying to apply concepts from the functional<br>&gt; paradigm and in particular we heavily depend on ReactiveCocoa. For the last<br>&gt; year two less experienced developers joined the team. I was in charge of<br>&gt; teaching them about iOS programming (this was the first time doing an iOS<br>&gt; app for them), functional programming (they are still college student with<br>&gt; a background in OOP) and the details of our code base.<br>&gt;<br>&gt; Coming from a background in OOP and imperative programming makes the<br>&gt; change to a more functional approach quite “interesting”. I really like<br>&gt; Swift and its flexibility to be able to tackle both low level and high<br>&gt; level problems. But some times this flexibility makes it more error prone<br>&gt; when you try to apply functional programming concepts. For example I found<br>&gt; my self reviewing and correcting pull request with things like “When you<br>&gt; use functions like map or filter on a collection or a SignalProducer don’t<br>&gt; inject side effects”.<br>&gt;<br>&gt; This led me to the idea of introducing a @pure annotation for functions.<br>&gt; Full disclosure: I have almost no background in compilers and the internals<br>&gt; of the Swift language so I have no idea if this makes sense at all. Such a<br>&gt; annotation (it could also be a keyword like override o mutating) will make<br>&gt; the compiler check if the function is actually a pure function, where by<br>&gt; Pure I mean<br>&gt;<br>&gt; - It doesn’t mutate any internal or global state<br>&gt; - It doesn’t call any non-pure function<br>&gt; - It must have a return type != from Void<br>&gt; - It can access non mutable state<br>&gt;<br>&gt; In this context a pure function is “stronger” than the mutating keyword in<br>&gt; the sense that the pure function won’t allow any type of mutation even if<br>&gt; you are calling a non-pure method (which performs a mutation or a side<br>&gt; effect) on an object (reference type) instead of a struct. For example<br>&gt;<br>&gt; final class Foo {<br>&gt;<br>&gt;<br>&gt;     private var count = 0<br>&gt;<br>&gt;     func foo(x: Int) -&gt; Int {<br>&gt;         count += x<br>&gt;         return count<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt; struct Bar {<br>&gt;<br>&gt;     var count: Int<br>&gt;     var foo: Foo<br>&gt;<br>&gt;     // This method performs a mutation<br>&gt;     // even though is not marked as mutating<br>&gt;     // You could call it a &quot;transitive mutation&quot;.<br>&gt;     func bar(x: Int) -&gt; Int {<br>&gt;         return foo.foo(x)<br>&gt;     }<br>&gt;<br>&gt;     mutating func baz(x: Int) -&gt; Int {<br>&gt;         count += x<br>&gt;         return count<br>&gt;     }<br>&gt;<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; This could be extended to classes and structs. Adding “pure” to a class or<br>&gt; structs makes all of its methods pure.<br>&gt;<br>&gt; The benefit of such feature is that you could gradually add more<br>&gt; functional code that is checked by the compiler and it is optional. I am<br>&gt; most probably missing a lot issues here. This is just a rough idea but I<br>&gt; wanted to share it with the community to better understand the tradeoffs.<br>&gt;<br>&gt; If this has already been discussed can anyone point me to that discussion?<br>&gt;<br>&gt; Thanks!<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160909/5e712f20/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
