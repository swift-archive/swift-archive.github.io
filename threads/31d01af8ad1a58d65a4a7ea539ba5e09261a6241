<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85193613f539e3597a1e218f93481e18?s=50"></div><header><strong>isEqual to replace == Equatable Requirement</strong> from <string>Richard Fox</string> &lt;fox.ios.dev at gmail.com&gt;<p>December  8, 2015 at 10:00:00am</p></header><div class="content"><p>Hi all,<br></p><p>I would like to propose changing the Equatable protocol to use isEqual(to:Self)<br>-&gt; Bool, defined inside of a type to replace the currently used<br>operator == function,<br>which is defined outside of the type.<br>&lt;https://gist.github.com/Nadohs/308603afa65cbbfba07c#reasoning&gt;Reasoning:<br></p><p>   1. Having the conforming function defined inside of the type is more<br>   intuitive, since in general functions required for conformance are defined<br>   within the type. It feels like an unnecesary detail for learners of Swift<br>   to have to stumble through.<br></p><p>The implementation for this would look something like this:<br></p><p>     public protocol Equatable{<br>       ....<br></p><p>       /// Shortcut for defining `==` function inside type definition.<br>       @warn_unused_result<br>       func isEqual(to:Self) -&gt; Bool<br>     }<br></p><p>     @warn_unused_result<br>     public func == &lt;T : Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>         return lhs.isEqual(rhs)<br>     }<br></p><p>&lt;https://gist.github.com/Nadohs/308603afa65cbbfba07c#impact-on-existing-code&gt;Impact<br>on Existing Code:<br></p><p>This implementation would break existing code, but could be fixed with a<br>default protocol extension such as:<br></p><p>     /// Default `isEqual` function to satisfy other types only definiting<br>     /// `==` for equality.<br>     public extension Equatable{<br>         func isEqual(to:Self) -&gt; Bool{<br>             return self == to<br>         }<br>     }<br></p><p>Not adding the default function for isEqual makes more sense to me though,<br>since it would remove any strict requirement for Equatable conformance and<br>leave no warning for the loop you would create by implementing neither<br>isEqual nor ==.<br></p><p>Regards,<br>Rich Fox<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/31d06241/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/265868676ac8f12472cc3cc0fc59d827?s=50"></div><header><strong>isEqual to replace == Equatable Requirement</strong> from <string>Nicky Gerritsen</string> &lt;nickygerritsen at me.com&gt;<p>December  8, 2015 at 11:00:00am</p></header><div class="content"><p>Although I like the idea, I think it should be more general, as this <br>same reasoning also holds for other operators.<br>Wouldn&#39;t it be better to allow to define operators within a type? So <br>that we can just implement == in the type?<br></p><p>I do not know how hard it is to implement it or if this is even <br>possible. Probably it is hard, because otherwise it would already have <br>been done?<br></p><p>Regards,<br></p><p>Nicky<br></p><p>On 12/08/2015 11:01 AM, Richard Fox via swift-evolution wrote:<br>&gt;<br>&gt;<br>&gt;       Hi all,<br>&gt;<br>&gt; I would like to propose changing the Equatable protocol to use <br>&gt; |isEqual(to:Self) -&gt; Bool|, defined inside of a type to replace the <br>&gt; currently used operator |==| function, which is defined outside of the <br>&gt; type.<br>&gt;<br>&gt;<br>&gt;       &lt;https://gist.github.com/Nadohs/308603afa65cbbfba07c#reasoning&gt;Reasoning:<br>&gt;<br>&gt;  1. Having the conforming function defined inside of the type is more<br>&gt;     intuitive, since in general functions required for conformance are<br>&gt;     defined within the type. It feels like an unnecesary detail for<br>&gt;     learners of Swift to have to stumble through.<br>&gt;<br>&gt; The implementation for this would look something like this:<br>&gt;<br>&gt; |public protocol Equatable{ .... /// Shortcut for defining `==` <br>&gt; function inside type definition. @warn_unused_result func <br>&gt; isEqual(to:Self) -&gt; Bool } @warn_unused_result public func == &lt;T : <br>&gt; Equatable&gt;(lhs: T, rhs: T) -&gt; Bool { return lhs.isEqual(rhs) } |<br>&gt;<br>&gt;<br>&gt;       &lt;https://gist.github.com/Nadohs/308603afa65cbbfba07c#impact-on-existing-code&gt;Impact<br>&gt;       on Existing Code:<br>&gt;<br>&gt; This implementation would break existing code, but could be fixed with <br>&gt; a default protocol extension such as:<br>&gt;<br>&gt; |/// Default `isEqual` function to satisfy other types only definiting <br>&gt; /// `==` for equality. public extension Equatable{ func <br>&gt; isEqual(to:Self) -&gt; Bool{ return self == to } } |<br>&gt;<br>&gt; Not adding the default function for |isEqual| makes more sense to me <br>&gt; though, since it would remove any strict requirement for Equatable <br>&gt; conformance and leave no warning for the loop you would create by <br>&gt; implementing neither |isEqual| nor |==|.<br>&gt;<br>&gt; Regards,<br>&gt; Rich Fox<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/ab59f816/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>isEqual to replace == Equatable Requirement</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>December  8, 2015 at 02:00:00pm</p></header><div class="content"><p>Your proposition makes comparison code much less readable only for a small benefit at the point of definition. I&#39;d vote against.<br></p><p>&gt; On 08 Dec 2015, at 11:06, Nicky Gerritsen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Although I like the idea, I think it should be more general, as this same reasoning also holds for other operators.<br>&gt; Wouldn&#39;t it be better to allow to define operators within a type? So that we can just implement == in the type?<br>&gt; <br>&gt; I do not know how hard it is to implement it or if this is even possible. Probably it is hard, because otherwise it would already have been done?<br>&gt; Regards,<br>&gt; <br>&gt; Nicky<br>&gt;&gt; On 12/08/2015 11:01 AM, Richard Fox via swift-evolution wrote:<br>&gt;&gt; Hi all,<br>&gt;&gt; I would like to propose changing the Equatable protocol to use isEqual(to:Self) -&gt; Bool, defined inside of a type to replace the currently used operator == function, which is defined outside of the type.<br>&gt;&gt; <br>&gt;&gt; Reasoning:<br>&gt;&gt; <br>&gt;&gt; Having the conforming function defined inside of the type is more intuitive, since in general functions required for conformance are defined within the type. It feels like an unnecesary detail for learners of Swift to have to stumble through.<br>&gt;&gt; The implementation for this would look something like this:<br>&gt;&gt; <br>&gt;&gt;      public protocol Equatable{<br>&gt;&gt;        ....<br>&gt;&gt; <br>&gt;&gt;        /// Shortcut for defining `==` function inside type definition.<br>&gt;&gt;        @warn_unused_result<br>&gt;&gt;        func isEqual(to:Self) -&gt; Bool<br>&gt;&gt;      }<br>&gt;&gt; <br>&gt;&gt;      @warn_unused_result<br>&gt;&gt;      public func == &lt;T : Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;&gt;          return lhs.isEqual(rhs)<br>&gt;&gt;      }<br>&gt;&gt; Impact on Existing Code:<br>&gt;&gt; <br>&gt;&gt; This implementation would break existing code, but could be fixed with a default protocol extension such as:<br>&gt;&gt; <br>&gt;&gt;      /// Default `isEqual` function to satisfy other types only definiting<br>&gt;&gt;      /// `==` for equality.<br>&gt;&gt;      public extension Equatable{<br>&gt;&gt;          func isEqual(to:Self) -&gt; Bool{<br>&gt;&gt;              return self == to<br>&gt;&gt;          }<br>&gt;&gt;      }  <br>&gt;&gt; Not adding the default function for isEqual makes more sense to me though, since it would remove any strict requirement for Equatable conformance and leave no warning for the loop you would create by implementing neither isEqual nor ==.<br>&gt;&gt; <br>&gt;&gt; Regards,<br>&gt;&gt; Rich Fox<br>&gt;&gt; <br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/af5deebb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d68c97e8e2f1653b54c24493caf236ae?s=50"></div><header><strong>isEqual to replace == Equatable Requirement</strong> from <string>Stephen Celis</string> &lt;stephen.celis at gmail.com&gt;<p>December  8, 2015 at 10:00:00am</p></header><div class="content"><p>I&#39;d rather support defining operator functions inside the type:<br></p><p>    extension Foo: Equatable {<br>        func ==(rhs: Foo) -&gt; Bool {<br>            return self.bar == rhs.bar<br>        }<br>    }<br></p><p>Is there any reason this wouldn&#39;t work?<br></p><p>Stephen<br></p><p>On Tue, Dec 8, 2015 at 8:36 AM, David Hart via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Your proposition makes comparison code much less readable only for a small<br>&gt; benefit at the point of definition. I&#39;d vote against.<br>&gt;<br>&gt; On 08 Dec 2015, at 11:06, Nicky Gerritsen via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Although I like the idea, I think it should be more general, as this same<br>&gt; reasoning also holds for other operators.<br>&gt; Wouldn&#39;t it be better to allow to define operators within a type? So that<br>&gt; we can just implement == in the type?<br>&gt;<br>&gt; I do not know how hard it is to implement it or if this is even possible.<br>&gt; Probably it is hard, because otherwise it would already have been done?<br>&gt;<br>&gt; Regards,<br>&gt;<br>&gt; Nicky<br>&gt;<br>&gt; On 12/08/2015 11:01 AM, Richard Fox via swift-evolution wrote:<br>&gt;<br>&gt; Hi all,<br>&gt;<br>&gt; I would like to propose changing the Equatable protocol to use isEqual(to:Self)<br>&gt; -&gt; Bool, defined inside of a type to replace the currently used operator<br>&gt; == function, which is defined outside of the type.<br>&gt; &lt;https://gist.github.com/Nadohs/308603afa65cbbfba07c#reasoning&gt;Reasoning:<br>&gt;<br>&gt;    1. Having the conforming function defined inside of the type is more<br>&gt;    intuitive, since in general functions required for conformance are defined<br>&gt;    within the type. It feels like an unnecesary detail for learners of Swift<br>&gt;    to have to stumble through.<br>&gt;<br>&gt; The implementation for this would look something like this:<br>&gt;<br>&gt;      public protocol Equatable{<br>&gt;        ....<br>&gt;<br>&gt;        /// Shortcut for defining `==` function inside type definition.<br>&gt;        @warn_unused_result<br>&gt;        func isEqual(to:Self) -&gt; Bool<br>&gt;      }<br>&gt;<br>&gt;      @warn_unused_result<br>&gt;      public func == &lt;T : Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;          return lhs.isEqual(rhs)<br>&gt;      }<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/Nadohs/308603afa65cbbfba07c#impact-on-existing-code&gt;Impact<br>&gt; on Existing Code:<br>&gt;<br>&gt; This implementation would break existing code, but could be fixed with a<br>&gt; default protocol extension such as:<br>&gt;<br>&gt;      /// Default `isEqual` function to satisfy other types only definiting<br>&gt;      /// `==` for equality.<br>&gt;      public extension Equatable{<br>&gt;          func isEqual(to:Self) -&gt; Bool{<br>&gt;              return self == to<br>&gt;          }<br>&gt;      }<br>&gt;<br>&gt; Not adding the default function for isEqual makes more sense to me<br>&gt; though, since it would remove any strict requirement for Equatable<br>&gt; conformance and leave no warning for the loop you would create by<br>&gt; implementing neither isEqual nor ==.<br>&gt;<br>&gt; Regards,<br>&gt; Rich Fox<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing listswift-evolution at swift.orghttps://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/d096d06d/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85193613f539e3597a1e218f93481e18?s=50"></div><header><strong>isEqual to replace == Equatable Requirement</strong> from <string>Richard Fox</string> &lt;fox.ios.dev at gmail.com&gt;<p>December  8, 2015 at 05:00:00pm</p></header><div class="content"><p>I dont see how this makes it less readable, are you taking into<br>consideration that you still use == everywhere for comparison, after<br>defining with isEqual? As this method would be defined in the stdlib.<br></p><p>public func == &lt;T : Equatable&gt;(lhs: T, rhs: T) -&gt; Bool<br></p><p><br>On Tue, Dec 8, 2015 at 5:36 AM David Hart &lt;david at hartbit.com&gt; wrote:<br></p><p>&gt; Your proposition makes comparison code much less readable only for a small<br>&gt; benefit at the point of definition. I&#39;d vote against.<br>&gt;<br>&gt; On 08 Dec 2015, at 11:06, Nicky Gerritsen via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Although I like the idea, I think it should be more general, as this same<br>&gt; reasoning also holds for other operators.<br>&gt; Wouldn&#39;t it be better to allow to define operators within a type? So that<br>&gt; we can just implement == in the type?<br>&gt;<br>&gt; I do not know how hard it is to implement it or if this is even possible.<br>&gt; Probably it is hard, because otherwise it would already have been done?<br>&gt;<br>&gt; Regards,<br>&gt;<br>&gt; Nicky<br>&gt;<br>&gt; On 12/08/2015 11:01 AM, Richard Fox via swift-evolution wrote:<br>&gt;<br>&gt; Hi all,<br>&gt;<br>&gt; I would like to propose changing the Equatable protocol to use isEqual(to:Self)<br>&gt; -&gt; Bool, defined inside of a type to replace the currently used operator<br>&gt; == function, which is defined outside of the type.<br>&gt; &lt;https://gist.github.com/Nadohs/308603afa65cbbfba07c#reasoning&gt;Reasoning:<br>&gt;<br>&gt;    1. Having the conforming function defined inside of the type is more<br>&gt;    intuitive, since in general functions required for conformance are defined<br>&gt;    within the type. It feels like an unnecesary detail for learners of Swift<br>&gt;    to have to stumble through.<br>&gt;<br>&gt; The implementation for this would look something like this:<br>&gt;<br>&gt;      public protocol Equatable{<br>&gt;        ....<br>&gt;<br>&gt;        /// Shortcut for defining `==` function inside type definition.<br>&gt;        @warn_unused_result<br>&gt;        func isEqual(to:Self) -&gt; Bool<br>&gt;      }<br>&gt;<br>&gt;      @warn_unused_result<br>&gt;      public func == &lt;T : Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;          return lhs.isEqual(rhs)<br>&gt;      }<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/Nadohs/308603afa65cbbfba07c#impact-on-existing-code&gt;Impact<br>&gt; on Existing Code:<br>&gt;<br>&gt; This implementation would break existing code, but could be fixed with a<br>&gt; default protocol extension such as:<br>&gt;<br>&gt;      /// Default `isEqual` function to satisfy other types only definiting<br>&gt;      /// `==` for equality.<br>&gt;      public extension Equatable{<br>&gt;          func isEqual(to:Self) -&gt; Bool{<br>&gt;              return self == to<br>&gt;          }<br>&gt;      }<br>&gt;<br>&gt; Not adding the default function for isEqual makes more sense to me<br>&gt; though, since it would remove any strict requirement for Equatable<br>&gt; conformance and leave no warning for the loop you would create by<br>&gt; implementing neither isEqual nor ==.<br>&gt;<br>&gt; Regards,<br>&gt; Rich Fox<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing listswift-evolution at swift.orghttps://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/afdbb34d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>isEqual to replace == Equatable Requirement</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>December  8, 2015 at 06:00:00pm</p></header><div class="content"><p>Well in that case I find even more confusing that to implement equality you have to define a function which is different from the operator.<br></p><p>&gt; On 08 Dec 2015, at 18:43, Richard Fox &lt;fox.ios.dev at gmail.com&gt; wrote:<br>&gt; <br>&gt; I dont see how this makes it less readable, are you taking into consideration that you still use == everywhere for comparison, after defining with isEqual? As this method would be defined in the stdlib.<br>&gt;&gt;&gt; public func == &lt;T : Equatable&gt;(lhs: T, rhs: T) -&gt; Bool <br>&gt; <br>&gt;&gt; On Tue, Dec 8, 2015 at 5:36 AM David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;&gt; Your proposition makes comparison code much less readable only for a small benefit at the point of definition. I&#39;d vote against.<br>&gt;&gt; <br>&gt;&gt;&gt; On 08 Dec 2015, at 11:06, Nicky Gerritsen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Although I like the idea, I think it should be more general, as this same reasoning also holds for other operators.<br>&gt;&gt;&gt; Wouldn&#39;t it be better to allow to define operators within a type? So that we can just implement == in the type?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I do not know how hard it is to implement it or if this is even possible. Probably it is hard, because otherwise it would already have been done?<br>&gt;&gt;&gt; Regards,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Nicky<br>&gt;&gt;&gt;&gt; On 12/08/2015 11:01 AM, Richard Fox via swift-evolution wrote:<br>&gt;&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt;&gt; I would like to propose changing the Equatable protocol to use isEqual(to:Self) -&gt; Bool, defined inside of a type to replace the currently used operator == function, which is defined outside of the type.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Reasoning:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Having the conforming function defined inside of the type is more intuitive, since in general functions required for conformance are defined within the type. It feels like an unnecesary detail for learners of Swift to have to stumble through.<br>&gt;&gt;&gt;&gt; The implementation for this would look something like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;      public protocol Equatable{<br>&gt;&gt;&gt;&gt;        ....<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;        /// Shortcut for defining `==` function inside type definition.<br>&gt;&gt;&gt;&gt;        @warn_unused_result<br>&gt;&gt;&gt;&gt;        func isEqual(to:Self) -&gt; Bool<br>&gt;&gt;&gt;&gt;      }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;      @warn_unused_result<br>&gt;&gt;&gt;&gt;      public func == &lt;T : Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;&gt;&gt;&gt;          return lhs.isEqual(rhs)<br>&gt;&gt;&gt;&gt;      }<br>&gt;&gt;&gt;&gt; Impact on Existing Code:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This implementation would break existing code, but could be fixed with a default protocol extension such as:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;      /// Default `isEqual` function to satisfy other types only definiting<br>&gt;&gt;&gt;&gt;      /// `==` for equality.<br>&gt;&gt;&gt;&gt;      public extension Equatable{<br>&gt;&gt;&gt;&gt;          func isEqual(to:Self) -&gt; Bool{<br>&gt;&gt;&gt;&gt;              return self == to<br>&gt;&gt;&gt;&gt;          }<br>&gt;&gt;&gt;&gt;      }  <br>&gt;&gt;&gt;&gt; Not adding the default function for isEqual makes more sense to me though, since it would remove any strict requirement for Equatable conformance and leave no warning for the loop you would create by implementing neither isEqual nor ==.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Regards,<br>&gt;&gt;&gt;&gt; Rich Fox<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/7f58bfbd/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>isEqual to replace == Equatable Requirement</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December  8, 2015 at 09:00:00am</p></header><div class="content"><p>Long term we&#39;d like to make it so that operators can be methods of their operand types, either instead of or in addition to being globals. That seems like a better way of addressing these concerns.<br></p><p>-Joe<br></p><p>&gt; On Dec 8, 2015, at 2:01 AM, Richard Fox via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; I would like to propose changing the Equatable protocol to use isEqual(to:Self) -&gt; Bool, defined inside of a type to replace the currently used operator == function, which is defined outside of the type.<br>&gt; <br>&gt;  &lt;https://gist.github.com/Nadohs/308603afa65cbbfba07c#reasoning&gt;Reasoning:<br>&gt; <br>&gt; Having the conforming function defined inside of the type is more intuitive, since in general functions required for conformance are defined within the type. It feels like an unnecesary detail for learners of Swift to have to stumble through.<br>&gt; The implementation for this would look something like this:<br>&gt; <br>&gt;      public protocol Equatable{<br>&gt;        ....<br>&gt; <br>&gt;        /// Shortcut for defining `==` function inside type definition.<br>&gt;        @warn_unused_result<br>&gt;        func isEqual(to:Self) -&gt; Bool<br>&gt;      }<br>&gt; <br>&gt;      @warn_unused_result<br>&gt;      public func == &lt;T : Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;          return lhs.isEqual(rhs)<br>&gt;      }<br>&gt;  &lt;https://gist.github.com/Nadohs/308603afa65cbbfba07c#impact-on-existing-code&gt;Impact on Existing Code:<br>&gt; <br>&gt; This implementation would break existing code, but could be fixed with a default protocol extension such as:<br>&gt; <br>&gt;      /// Default `isEqual` function to satisfy other types only definiting<br>&gt;      /// `==` for equality.<br>&gt;      public extension Equatable{<br>&gt;          func isEqual(to:Self) -&gt; Bool{<br>&gt;              return self == to<br>&gt;          }<br>&gt;      }  <br>&gt; Not adding the default function for isEqual makes more sense to me though, since it would remove any strict requirement for Equatable conformance and leave no warning for the loop you would create by implementing neither isEqual nor ==.<br>&gt; <br>&gt; Regards,<br>&gt; Rich Fox<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/4947c232/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a726de03bed3104ddaecca3fdcf59e19?s=50"></div><header><strong>isEqual to replace == Equatable Requirement</strong> from <string>Ling Wang</string> &lt;an00na at gmail.com&gt;<p>December  9, 2015 at 01:00:00am</p></header><div class="content"><p>That&#39;ll be great!<br></p><p><br></p><p>    _____________________________<br>From: Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt;<br>Sent: Tuesday, December 8, 2015 11:57 AM<br>Subject: Re: [swift-evolution] isEqual to replace == Equatable Requirement<br>To: Richard Fox &lt;fox.ios.dev at gmail.com&gt;<br>Cc:  &lt;swift-evolution at swift.org&gt;<br></p><p><br>       Long term we&#39;d like to make it so that operators can be methods of their operand types, either instead of or in addition to being globals. That seems like a better way of addressing these concerns.     <br>       -Joe       <br>                  On Dec 8, 2015, at 2:01 AM, Richard Fox via swift-evolution &lt;      swift-evolution at swift.org&gt; wrote:          <br>                  Hi all,<br>       <br></p><p>I would like to propose changing the Equatable protocol to use isEqual(to:Self) -&gt; Bool, defined inside of a type to replace the currently used operator == function, which is defined outside of the type.       Reasoning:               Having the conforming function defined inside of the type is more intuitive, since in general functions required for conformance are defined within the type. It feels like an unnecesary detail for learners of Swift to have to stumble through.              <br></p><p>The implementation for this would look something like this:            public protocol Equatable{       ....       /// Shortcut for defining `==` function inside type definition.       @warn_unused_result       func isEqual(to:Self) -&gt; Bool     }     @warn_unused_result     public func == &lt;T : Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {         return lhs.isEqual(rhs)     }       Impact on Existing Code:       <br></p><p>This implementation would break existing code, but could be fixed with a default protocol extension such as:            /// Default `isEqual` function to satisfy other types only definiting     /// `==` for equality.     public extension Equatable{         func isEqual(to:Self) -&gt; Bool{             return self == to         }     }                 Not adding the default function for         isEqual makes more sense to me though, since it would remove any strict requirement for Equatable conformance and leave no warning for the loop you would create by implementing neither         isEqual nor         ==.        <br>        <br>Regards,        <br>Rich Fox                     _______________________________________________      <br>swift-evolution mailing list      <br>      swift-evolution at swift.org      <br>https://lists.swift.org/mailman/listinfo/swift-evolution      <br>               <br>        <br></p><p><br>  <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/9af56449/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
