<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d932a7cff4e614f7b268b11b3b362a7?s=50"></div><header><strong>rethrows as first-class type annotation</strong> from <string>Alexandre Lopoukhine</string> &lt;superlopuh at gmail.com&gt;<p>December 19, 2015 at 07:00:00pm</p></header><div class="content"><p>Hello all,<br></p><p>I’m not sure that I’ve expressed myself correctly, but essentially, I want the following type declaration to be legal: &quot;I rethrows -&gt; O”. I’ve looked through the mailing list and the proposals, and haven’t seen this mentioned, but I apologise if this has already been discussed.<br></p><p>The following example is rather specific, but I’m sure that the solution to this problem can be useful elsewhere. In playing around with the concept of pipes and combinations of functions, I thought that it would be nice to have an operator with the following property:<br>(Class.instanceFunction `operator` input)(instance) === instance.instanceFunction(input)<br>, which would allow me to pass the operator construct into “map”, and other higher-order operations.<br></p><p>I attempted to implement this with the following operator functions:<br></p><p>1)<br>public func |++|&lt;C,TI,TO,O&gt;(classFunc: C -&gt; (TI -&gt; TO) -&gt; O, transform: (TI -&gt; TO)) -&gt; C -&gt; O {<br>    return {classFunc($0)(transform)}<br>}<br></p><p>2)<br>public func |++|&lt;C,TI,TO,O&gt;(classFunc: C -&gt; (TI -&gt; TO) throws -&gt; O, transform: (TI -&gt; TO)) -&gt; C -&gt; O {<br>    return {try! classFunc($0)(transform)}<br>}<br></p><p>3)<br>public func |+++|&lt;C,TI,TO,O&gt;(classFunc: C -&gt; (TI throws -&gt; TO) throws -&gt; O, transform: (TI throws -&gt; TO)) -&gt; C throws -&gt; O {<br>    return {try classFunc($0)(transform)}<br>}<br></p><p>They can be used in the following way:<br></p><p><br>1) (Array.myMap |++| double)([1,2,3]) // Where myMap doesn’t accept a throwing function.<br></p><p>2) (Array.map |++| double)([1,2,3])<br></p><p>3) try? (Array.map |+++| throwIfEven)([1,2,3])<br></p><p><br>As you can see, this is rather messy. I think that the type system should be extended to have a true equivalent of the rethrows annotation in function declarations. It would then allow the following statement:<br></p><p>4)<br>public func |++|&lt;T,I,O&gt;(classFunc: T -&gt; I rethrows -&gt; O, input: I) -&gt; T rethrows -&gt; O {<br>    return {try classFunc($0)(input)}<br>}<br></p><p>T rethrows -&gt; O will then be able to be unified with a non-throwing function type <br>	iff the type of classFunc($0) unifies with a non-throwing function<br>	(iff input is a non-throwing function in the of Array.map)<br></p><p>Thus, all of the above uses should be legal, with the benefit of simpler unification.<br></p><p>My limited knowledge of compilers doesn’t doesn’t give me any reason to think that this isn’t possible, and my impression is that moving “rethrows” from a special annotation to a more general one would simplify the language.<br></p><p>What do you all think?<br></p><p>— Sasha<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>rethrows as first-class type annotation</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December 20, 2015 at 02:00:00am</p></header><div class="content"><p>Hi Alexandre,<br></p><p>I think for this use case we don&#39;t actually need &#39;rethrows&#39; to become<br>a part of the closure type, we just need the compiler to allow and<br>&quot;instantiate&quot; it in more places.<br></p><p>The case where we would need &#39;rethrows&#39; to become a first class part<br>of the type system is if we wanted &#39;rethrows&#39; to be a part of the<br>signature of the closure itself, for example:<br></p><p>(swift) let forEach = [ 10, 20, 30 ].forEach<br>// forEach : (@noescape (Int) throws -&gt; Void) throws -&gt; () = (Function)<br></p><p>Here, a more precise type would be (@noescape (Int) throws -&gt; Void)<br>rethrows -&gt; Void.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d932a7cff4e614f7b268b11b3b362a7?s=50"></div><header><strong>rethrows as first-class type annotation</strong> from <string>Alexandre Lopoukhine</string> &lt;superlopuh at gmail.com&gt;<p>December 20, 2015 at 01:00:00pm</p></header><div class="content"><p>Hi Dmitri,<br></p><p>This is a better example than any that I have come up with so far as to why “rethrows” should be a part of the signature. You shouldn’t have to use “try!” to apply a non-throwing function, like {print($0)} to “forEach”.<br></p><p>— Sasha<br></p><p><br>&gt; On 20 Dec 2015, at 13:37, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt; Hi Alexandre,<br>&gt; <br>&gt; I think for this use case we don&#39;t actually need &#39;rethrows&#39; to become<br>&gt; a part of the closure type, we just need the compiler to allow and<br>&gt; &quot;instantiate&quot; it in more places.<br>&gt; <br>&gt; The case where we would need &#39;rethrows&#39; to become a first class part<br>&gt; of the type system is if we wanted &#39;rethrows&#39; to be a part of the<br>&gt; signature of the closure itself, for example:<br>&gt; <br>&gt; (swift) let forEach = [ 10, 20, 30 ].forEach<br>&gt; // forEach : (@noescape (Int) throws -&gt; Void) throws -&gt; () = (Function)<br>&gt; <br>&gt; Here, a more precise type would be (@noescape (Int) throws -&gt; Void)<br>&gt; rethrows -&gt; Void.<br>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>rethrows as first-class type annotation</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>December 21, 2015 at 06:00:00pm</p></header><div class="content"><p>John, IIRC you had some reason why this wasn&#39;t a great idea, but I can&#39;t remember it. It seems useful to me too, if not something that comes up too often.<br></p><p>Jordan<br></p><p>&gt; On Dec 20, 2015, at 2:46 , Alexandre Lopoukhine via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi Dmitri,<br>&gt; <br>&gt; This is a better example than any that I have come up with so far as to why “rethrows” should be a part of the signature. You shouldn’t have to use “try!” to apply a non-throwing function, like {print($0)} to “forEach”.<br>&gt; <br>&gt; — Sasha<br>&gt; <br>&gt; <br>&gt;&gt; On 20 Dec 2015, at 13:37, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi Alexandre,<br>&gt;&gt; <br>&gt;&gt; I think for this use case we don&#39;t actually need &#39;rethrows&#39; to become<br>&gt;&gt; a part of the closure type, we just need the compiler to allow and<br>&gt;&gt; &quot;instantiate&quot; it in more places.<br>&gt;&gt; <br>&gt;&gt; The case where we would need &#39;rethrows&#39; to become a first class part<br>&gt;&gt; of the type system is if we wanted &#39;rethrows&#39; to be a part of the<br>&gt;&gt; signature of the closure itself, for example:<br>&gt;&gt; <br>&gt;&gt; (swift) let forEach = [ 10, 20, 30 ].forEach<br>&gt;&gt; // forEach : (@noescape (Int) throws -&gt; Void) throws -&gt; () = (Function)<br>&gt;&gt; <br>&gt;&gt; Here, a more precise type would be (@noescape (Int) throws -&gt; Void)<br>&gt;&gt; rethrows -&gt; Void.<br>&gt;&gt; <br>&gt;&gt; Dmitri<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/ce204321/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>rethrows as first-class type annotation</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>December 21, 2015 at 10:00:00pm</p></header><div class="content"><p>I don’t know what the compiler does internally. However, I look at a signature like<br></p><p>func forEach(fn:Element throws-&gt;()) rethrows<br></p><p>and imagine that conceptually this exposes two overloads for this “forEach” function:<br></p><p>a)	func forEach(fn:Element-&gt;())<br></p><p>b)	func forEach(fn:Element throws-&gt;()) throws<br></p><p>In fact, I expected the swift CLI to give me an error when I attempted to define all three of these as functions, but no such luck.<br></p><p>-DW<br></p><p><br>&gt; On Dec 21, 2015, at 7:09 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; John, IIRC you had some reason why this wasn&#39;t a great idea, but I can&#39;t remember it. It seems useful to me too, if not something that comes up too often.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt;&gt; On Dec 20, 2015, at 2:46 , Alexandre Lopoukhine via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi Dmitri,<br>&gt;&gt; <br>&gt;&gt; This is a better example than any that I have come up with so far as to why “rethrows” should be a part of the signature. You shouldn’t have to use “try!” to apply a non-throwing function, like {print($0)} to “forEach”.<br>&gt;&gt; <br>&gt;&gt; — Sasha<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 20 Dec 2015, at 13:37, Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi Alexandre,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think for this use case we don&#39;t actually need &#39;rethrows&#39; to become<br>&gt;&gt;&gt; a part of the closure type, we just need the compiler to allow and<br>&gt;&gt;&gt; &quot;instantiate&quot; it in more places.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The case where we would need &#39;rethrows&#39; to become a first class part<br>&gt;&gt;&gt; of the type system is if we wanted &#39;rethrows&#39; to be a part of the<br>&gt;&gt;&gt; signature of the closure itself, for example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (swift) let forEach = [ 10, 20, 30 ].forEach<br>&gt;&gt;&gt; // forEach : (@noescape (Int) throws -&gt; Void) throws -&gt; () = (Function)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here, a more precise type would be (@noescape (Int) throws -&gt; Void)<br>&gt;&gt;&gt; rethrows -&gt; Void.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Dmitri<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt;*/<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/d3102a9f/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>rethrows as first-class type annotation</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December 22, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 21, 2015, at 6:09 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; John, IIRC you had some reason why this wasn&#39;t a great idea, but I can&#39;t remember it. It seems useful to me too, if not something that comes up too often.<br></p><p>I don’t remember off-hand.  I think it’s theoretically supportable, but it adds extra complexity to the type system that I wanted to avoid if possible.<br></p><p>John.<br></p><p>&gt; <br>&gt; Jordan<br>&gt; <br>&gt;&gt; On Dec 20, 2015, at 2:46 , Alexandre Lopoukhine via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi Dmitri,<br>&gt;&gt; <br>&gt;&gt; This is a better example than any that I have come up with so far as to why “rethrows” should be a part of the signature. You shouldn’t have to use “try!” to apply a non-throwing function, like {print($0)} to “forEach”.<br>&gt;&gt; <br>&gt;&gt; — Sasha<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 20 Dec 2015, at 13:37, Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi Alexandre,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think for this use case we don&#39;t actually need &#39;rethrows&#39; to become<br>&gt;&gt;&gt; a part of the closure type, we just need the compiler to allow and<br>&gt;&gt;&gt; &quot;instantiate&quot; it in more places.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The case where we would need &#39;rethrows&#39; to become a first class part<br>&gt;&gt;&gt; of the type system is if we wanted &#39;rethrows&#39; to be a part of the<br>&gt;&gt;&gt; signature of the closure itself, for example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (swift) let forEach = [ 10, 20, 30 ].forEach<br>&gt;&gt;&gt; // forEach : (@noescape (Int) throws -&gt; Void) throws -&gt; () = (Function)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here, a more precise type would be (@noescape (Int) throws -&gt; Void)<br>&gt;&gt;&gt; rethrows -&gt; Void.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Dmitri<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt;*/<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/737d5b28/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d932a7cff4e614f7b268b11b3b362a7?s=50"></div><header><strong>rethrows as first-class type annotation</strong> from <string>Alexandre Lopoukhine</string> &lt;superlopuh at gmail.com&gt;<p>December 22, 2015 at 10:00:00pm</p></header><div class="content"><p>I definitely see where John is coming from, but my intuition (which I have to agree is of arguable worth) is telling me that it’s a good direction to explore. I believe that the current system is broken, even if the degree of this is not significant, and doesn’t affect most uses. As the language matures, and the use of error-throwing with a more functional style of programming becomes more prevalent, I think that some form of advance in the matching system will have to be made.<br></p><p><br>Here’s my perspective on this: (Disclaimer: I’m having a bit of trouble getting my head around the compiler, and exactly how “rethrows&quot; and type unification work.)<br></p><p>* I’m very fond of the availability of rethrows as a function declaration annotation, it’s very clear in its requirements and in its guarantees. By allowing it to be a type annotation, these same contracts can be used by the readers of the code, and by the compiler.<br>(For example, a function is throwing iff there is a reachable, uncaught, throwing expression; a function is rethrowing iff it is not throwing and there is a reachable, uncaught, call to a function, taken as input, that is marked as throwing. This may or may not be useful to the compiler, but it would definitely help me when dealing with throwing code.)<br></p><p>* Dmitri’s suggestion of making the compiler advanced enough to have the rethrows generated automatically doesn’t seem to be any less complicated than requiring the programmer to add it to the function type by hand. I’m also not entirely sure how it would work in a context where you declare that a function with rethrowing semantics is expected. Maybe I just missed the point of the comment entirely.<br></p><p><br>— Sasha<br></p><p>P.S.  Is there documentation somewhere of the rules by which types are unified today, and of the way that &quot;rethrows&quot; is currently handled, or should I just keep working at reading the code?<br></p><p><br>&gt; On 22 Dec 2015, at 20:41, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 21, 2015, at 6:09 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt; John, IIRC you had some reason why this wasn&#39;t a great idea, but I can&#39;t remember it. It seems useful to me too, if not something that comes up too often.<br>&gt; <br>&gt; I don’t remember off-hand.  I think it’s theoretically supportable, but it adds extra complexity to the type system that I wanted to avoid if possible.<br>&gt; <br>&gt; John.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 20, 2015, at 2:46 , Alexandre Lopoukhine via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi Dmitri,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a better example than any that I have come up with so far as to why “rethrows” should be a part of the signature. You shouldn’t have to use “try!” to apply a non-throwing function, like {print($0)} to “forEach”.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; — Sasha<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 20 Dec 2015, at 13:37, Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi Alexandre,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think for this use case we don&#39;t actually need &#39;rethrows&#39; to become<br>&gt;&gt;&gt;&gt; a part of the closure type, we just need the compiler to allow and<br>&gt;&gt;&gt;&gt; &quot;instantiate&quot; it in more places.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The case where we would need &#39;rethrows&#39; to become a first class part<br>&gt;&gt;&gt;&gt; of the type system is if we wanted &#39;rethrows&#39; to be a part of the<br>&gt;&gt;&gt;&gt; signature of the closure itself, for example:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (swift) let forEach = [ 10, 20, 30 ].forEach<br>&gt;&gt;&gt;&gt; // forEach : (@noescape (Int) throws -&gt; Void) throws -&gt; () = (Function)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here, a more precise type would be (@noescape (Int) throws -&gt; Void)<br>&gt;&gt;&gt;&gt; rethrows -&gt; Void.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Dmitri<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt;&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt;*/<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/179da47a/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
