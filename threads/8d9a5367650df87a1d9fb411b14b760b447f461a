<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eea54bf81503023f6ab5ef662c09f329?s=50"></div><header><strong>[Proposal] mapValues</strong> from <string>Miguel Angel Quinones</string> &lt;miguel at miqu.me&gt;<p>April 13, 2016 at 11:00:00am</p></header><div class="content"><p>I&#39;m +1 for adding mapValues. Very useful functionality and trivial to implement. <br></p><p>&gt; &gt; I.e. I suggest to implement and mapKeys() also. It could be also useful in some situations.<br>&gt; `mapKeys` is much more dangerous, because you could end up mapping many values into a single key. You kind of need to combine the values somehow. Perhaps:<br>&gt;  <br>&gt; extension Dictionary {<br>&gt; func mapValues(_ valueTransform: @noescape Value throws -&gt;OutValue) rethrows -&gt;[Key: OutValue] { … }<br>&gt;  <br>&gt; func mapKeys(_ keyTransform: @noescape Key throws -&gt;OutKey) rethrows -&gt;[OutKey: [Value]] { … }<br>&gt;  <br>&gt; // Possibly flatMap variants, too?<br>&gt; }<br>&gt;  <br>&gt; extension Dictionary where Value: Sequence {<br>&gt; func reduceValues(_ initial: OutValue, combine: @noescape (OutValue, Value.Iterator.Element) throws -&gt;OutValue) rethrows -&gt;[Key: OutValue] {<br>&gt; return mapValues { $0.reduce(initial, combine: combine) }<br>&gt; }<br>&gt; }<br>&gt;  <br>&gt; Which you would end up using like this:<br>&gt;  <br>&gt; let wordFrequencies: [String: Int] = …<br>&gt; let firstLetterFrequencies: [Character: Int] = wordFrequencies.mapKeys { $0.characters.first! }.reduceValues(0, combine: +)<br>&gt;  <br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;  <br>&gt;  <br>&gt;  <br>&gt;<br></p><p>-- <br>Miguel Angel Quinones<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160413/8d9a461a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d172fa3c47108d84ee35a68e8d675c1?s=50"></div><header><strong>[Proposal] mapValues</strong> from <string>Ross O&#39;Brien</string> &lt;narrativium+swift at gmail.com&gt;<p>April 13, 2016 at 11:00:00am</p></header><div class="content"><p>+1 on mapValues.<br></p><p>DictionaryLiteral already throws an exception if it includes duplicate<br>keys, so I&#39;d expect mapKeys to throw an error if multiple source keys<br>mapped to the same destination key.<br></p><p>On Wed, Apr 13, 2016 at 11:28 AM, Miguel Angel Quinones via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I&#39;m +1 for adding mapValues. Very useful functionality and trivial to<br>&gt; implement.<br>&gt;<br>&gt; &gt; &gt; I.e. I suggest to implement and mapKeys() also. It could be also<br>&gt; useful in some situations.<br>&gt; &gt; `mapKeys` is much more dangerous, because you could end up mapping many<br>&gt; values into a single key. You kind of need to combine the values somehow.<br>&gt; Perhaps:<br>&gt; &gt;<br>&gt; &gt; extension Dictionary {<br>&gt; &gt; func mapValues(_ valueTransform: @noescape Value throws -&gt;OutValue)<br>&gt; rethrows -&gt;[Key: OutValue] { … }<br>&gt; &gt;<br>&gt; &gt; func mapKeys(_ keyTransform: @noescape Key throws -&gt;OutKey) rethrows<br>&gt; -&gt;[OutKey: [Value]] { … }<br>&gt; &gt;<br>&gt; &gt; // Possibly flatMap variants, too?<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; extension Dictionary where Value: Sequence {<br>&gt; &gt; func reduceValues(_ initial: OutValue, combine: @noescape (OutValue,<br>&gt; Value.Iterator.Element) throws -&gt;OutValue) rethrows -&gt;[Key: OutValue] {<br>&gt; &gt; return mapValues { $0.reduce(initial, combine: combine) }<br>&gt; &gt; }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; Which you would end up using like this:<br>&gt; &gt;<br>&gt; &gt; let wordFrequencies: [String: Int] = …<br>&gt; &gt; let firstLetterFrequencies: [Character: Int] = wordFrequencies.mapKeys {<br>&gt; $0.characters.first! }.reduceValues(0, combine: +)<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Brent Royal-Gordon<br>&gt; &gt; Architechies<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt;<br>&gt; --<br>&gt; Miguel Angel Quinones<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160413/3c51d3c0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Proposal] mapValues</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>April 13, 2016 at 02:00:00pm</p></header><div class="content"><p>As for mapKeys and many values into a single key. I believe we should have <br>a choice - do we expect multiply values for the same key or not. Just like <br>&quot;+&quot; and integer overflow : by default it raises the error, but if &quot;&amp;+&quot; - we <br>expect the overflow. I can imagine situations when it is ok for me to have <br>different values for the same key(if I don&#39;t care which of values should be <br>for that key in result dictionary).<br>So my proposal is some additional mapKey(allowMultiplyValues: true) {...} <br>or in any other form/name.<br></p><p>On 13.04.2016 13:38, Ross O&#39;Brien via swift-evolution wrote:<br>&gt; +1 on mapValues.<br>&gt;<br>&gt; DictionaryLiteral already throws an exception if it includes duplicate<br>&gt; keys, so I&#39;d expect mapKeys to throw an error if multiple source keys<br>&gt; mapped to the same destination key.<br>&gt;<br>&gt; On Wed, Apr 13, 2016 at 11:28 AM, Miguel Angel Quinones via swift-evolution<br>&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;<br>&gt;     I&#39;m +1 for adding mapValues. Very useful functionality and trivial to<br>&gt;     implement.<br>&gt;<br>&gt;      &gt; &gt; I.e. I suggest to implement and mapKeys() also. It could be also<br>&gt;     useful in some situations.<br>&gt;     &gt; `mapKeys` is much more dangerous, because you could end up mapping many values into a single key. You kind of need to combine the values somehow. Perhaps:<br>&gt;     &gt;<br>&gt;     &gt; extension Dictionary {<br>&gt;      &gt; func mapValues__(_ valueTransform: @noescape Value throws<br>&gt;     -&gt;OutValue) rethrows -&gt;[Key: OutValue] { … }<br>&gt;      &gt;<br>&gt;      &gt; func mapKeys__(_ keyTransform: @noescape Key throws -&gt;OutKey)<br>&gt;     rethrows -&gt;[OutKey: [Value]] { … }<br>&gt;     &gt;<br>&gt;     &gt; // Possibly flatMap variants, too?<br>&gt;     &gt; }<br>&gt;     &gt;<br>&gt;     &gt; extension Dictionary where Value: Sequence {<br>&gt;      &gt; func reduceValues__(_ initial: OutValue, combine: @noescape<br>&gt;     (OutValue, Value.Iterator.Element) throws -&gt;OutValue) rethrows -&gt;[Key:<br>&gt;     OutValue] {<br>&gt;     &gt; return mapValues { $0.reduce(initial, combine: combine) }<br>&gt;     &gt; }<br>&gt;     &gt; }<br>&gt;     &gt;<br>&gt;     &gt; Which you would end up using like this:<br>&gt;     &gt;<br>&gt;     &gt; let wordFrequencies: [String: Int] = …<br>&gt;     &gt; let firstLetterFrequencies: [Character: Int] = wordFrequencies.mapKeys { $0.characters.first! }.reduceValues(0, combine: +)<br>&gt;     &gt;<br>&gt;     &gt; --<br>&gt;     &gt; Brent Royal-Gordon<br>&gt;     &gt; Architechies<br>&gt;     &gt;<br>&gt;     &gt;<br>&gt;     &gt;<br>&gt;     &gt;______<br>&gt;<br>&gt;     --<br>&gt;     Miguel Angel Quinones<br>&gt;<br>&gt;     _______________________________________________<br>&gt;     swift-evolution mailing list<br>&gt;     swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>[Proposal] mapValues</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>April 13, 2016 at 10:00:00am</p></header><div class="content"><p>To adhere to the API Design Guidelines, I think it should be named<br>&quot;mappingValues&quot;, right?<br></p><p>On Wed, Apr 13, 2016 at 4:23 AM, Vladimir.S via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; As for mapKeys and many values into a single key. I believe we should have<br>&gt; a choice - do we expect multiply values for the same key or not. Just like<br>&gt; &quot;+&quot; and integer overflow : by default it raises the error, but if &quot;&amp;+&quot; - we<br>&gt; expect the overflow. I can imagine situations when it is ok for me to have<br>&gt; different values for the same key(if I don&#39;t care which of values should be<br>&gt; for that key in result dictionary).<br>&gt; So my proposal is some additional mapKey(allowMultiplyValues: true) {...}<br>&gt; or in any other form/name.<br>&gt;<br>&gt; On 13.04.2016 13:38, Ross O&#39;Brien via swift-evolution wrote:<br>&gt;<br>&gt;&gt; +1 on mapValues.<br>&gt;&gt;<br>&gt;&gt; DictionaryLiteral already throws an exception if it includes duplicate<br>&gt;&gt; keys, so I&#39;d expect mapKeys to throw an error if multiple source keys<br>&gt;&gt; mapped to the same destination key.<br>&gt;&gt;<br>&gt;&gt; On Wed, Apr 13, 2016 at 11:28 AM, Miguel Angel Quinones via<br>&gt;&gt; swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;     I&#39;m +1 for adding mapValues. Very useful functionality and trivial to<br>&gt;&gt;     implement.<br>&gt;&gt;<br>&gt;&gt;      &gt; &gt; I.e. I suggest to implement and mapKeys() also. It could be also<br>&gt;&gt;     useful in some situations.<br>&gt;&gt;     &gt; `mapKeys` is much more dangerous, because you could end up mapping<br>&gt;&gt; many values into a single key. You kind of need to combine the values<br>&gt;&gt; somehow. Perhaps:<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt; extension Dictionary {<br>&gt;&gt;      &gt; func mapValues__(_ valueTransform: @noescape Value throws<br>&gt;&gt;     -&gt;OutValue) rethrows -&gt;[Key: OutValue] { … }<br>&gt;&gt;      &gt;<br>&gt;&gt;      &gt; func mapKeys__(_ keyTransform: @noescape Key throws -&gt;OutKey)<br>&gt;&gt;     rethrows -&gt;[OutKey: [Value]] { … }<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt; // Possibly flatMap variants, too?<br>&gt;&gt;     &gt; }<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt; extension Dictionary where Value: Sequence {<br>&gt;&gt;      &gt; func reduceValues__(_ initial: OutValue, combine: @noescape<br>&gt;&gt;     (OutValue, Value.Iterator.Element) throws -&gt;OutValue) rethrows -&gt;[Key:<br>&gt;&gt;     OutValue] {<br>&gt;&gt;     &gt; return mapValues { $0.reduce(initial, combine: combine) }<br>&gt;&gt;     &gt; }<br>&gt;&gt;     &gt; }<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt; Which you would end up using like this:<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt; let wordFrequencies: [String: Int] = …<br>&gt;&gt;     &gt; let firstLetterFrequencies: [Character: Int] =<br>&gt;&gt; wordFrequencies.mapKeys { $0.characters.first! }.reduceValues(0, combine: +)<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt; --<br>&gt;&gt;     &gt; Brent Royal-Gordon<br>&gt;&gt;     &gt; Architechies<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt;______<br>&gt;&gt;<br>&gt;&gt;     --<br>&gt;&gt;     Miguel Angel Quinones<br>&gt;&gt;<br>&gt;&gt;     _______________________________________________<br>&gt;&gt;     swift-evolution mailing list<br>&gt;&gt;     swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160413/2e855e88/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5f463dd4e7af28b64ad8f0e032ee82dc?s=50"></div><header><strong>[Proposal] mapValues</strong> from <string>Nate Cook</string> &lt;natecook at gmail.com&gt;<p>April 13, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Apr 13, 2016, at 12:02 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; To adhere to the API Design Guidelines, I think it should be named &quot;mappingValues&quot;, right?<br>&gt; <br>&gt; On Wed, Apr 13, 2016 at 4:23 AM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; As for mapKeys and many values into a single key. I believe we should have a choice - do we expect multiply values for the same key or not. Just like &quot;+&quot; and integer overflow : by default it raises the error, but if &quot;&amp;+&quot; - we expect the overflow. I can imagine situations when it is ok for me to have different values for the same key(if I don&#39;t care which of values should be for that key in result dictionary).<br>&gt; So my proposal is some additional mapKey(allowMultiplyValues: true) {...} or in any other form/name.<br></p><p>There&#39;s a proposal (awaiting merging) to add Dictionary initializers and methods that work with key/value pairs. These provide different ways of dealing with the duplicate key issue after a call to the regular Collection.map method.<br>https://github.com/natecook1000/swift-evolution/blob/natecook-dictionary-merge/proposals/0000-add-sequence-based-init-and-merge-to-dictionary.md<br></p><p>I&#39;d be interested in a `mapValues` or `transformValues` method that would modify values in place while leaving keys alone.<br></p><p>Another useful method (that could be used to build mapValues more efficiently) would be `Dictionary.updateValue(value: Value, at index: DictionaryIndex)`, so you could write:<br></p><p>var dict = [&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3]<br>if let i = dict.index(where: { $0.value == 3 }) {<br>    dict.updateValue(100, at: i)<br>}<br>// dict == [&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 100]<br></p><p>-Nate<br></p><p><br>&gt; On 13.04.2016 13:38, Ross O&#39;Brien via swift-evolution wrote:<br>&gt; +1 on mapValues.<br>&gt; <br>&gt; DictionaryLiteral already throws an exception if it includes duplicate<br>&gt; keys, so I&#39;d expect mapKeys to throw an error if multiple source keys<br>&gt; mapped to the same destination key.<br>&gt; <br>&gt; On Wed, Apr 13, 2016 at 11:28 AM, Miguel Angel Quinones via swift-evolution<br>&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt; <br>&gt;     I&#39;m +1 for adding mapValues. Very useful functionality and trivial to<br>&gt;     implement.<br>&gt; <br>&gt;      &gt; &gt; I.e. I suggest to implement and mapKeys() also. It could be also<br>&gt;     useful in some situations.<br>&gt;     &gt; `mapKeys` is much more dangerous, because you could end up mapping many values into a single key. You kind of need to combine the values somehow. Perhaps:<br>&gt;     &gt;<br>&gt;     &gt; extension Dictionary {<br>&gt;      &gt; func mapValues__(_ valueTransform: @noescape Value throws<br>&gt;     -&gt;OutValue) rethrows -&gt;[Key: OutValue] { … }<br>&gt;      &gt;<br>&gt;      &gt; func mapKeys__(_ keyTransform: @noescape Key throws -&gt;OutKey)<br>&gt;     rethrows -&gt;[OutKey: [Value]] { … }<br>&gt;     &gt;<br>&gt;     &gt; // Possibly flatMap variants, too?<br>&gt;     &gt; }<br>&gt;     &gt;<br>&gt;     &gt; extension Dictionary where Value: Sequence {<br>&gt;      &gt; func reduceValues__(_ initial: OutValue, combine: @noescape<br>&gt;     (OutValue, Value.Iterator.Element) throws -&gt;OutValue) rethrows -&gt;[Key:<br>&gt;     OutValue] {<br>&gt;     &gt; return mapValues { $0.reduce(initial, combine: combine) }<br>&gt;     &gt; }<br>&gt;     &gt; }<br>&gt;     &gt;<br>&gt;     &gt; Which you would end up using like this:<br>&gt;     &gt;<br>&gt;     &gt; let wordFrequencies: [String: Int] = …<br>&gt;     &gt; let firstLetterFrequencies: [Character: Int] = wordFrequencies.mapKeys { $0.characters.first! }.reduceValues(0, combine: +)<br>&gt;     &gt;<br>&gt;     &gt; --<br>&gt;     &gt; Brent Royal-Gordon<br>&gt;     &gt; Architechies<br>&gt;     &gt;<br>&gt;     &gt;<br>&gt;     &gt;<br>&gt;     &gt;______<br>&gt; <br>&gt;     --<br>&gt;     Miguel Angel Quinones<br>&gt; <br>&gt;     _______________________________________________<br>&gt;     swift-evolution mailing list<br>&gt;     swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160413/8c17814a/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
