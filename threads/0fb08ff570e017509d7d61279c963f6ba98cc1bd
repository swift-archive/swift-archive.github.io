<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/37ed623c7e539c1e991c5be604e4a7aa?s=50"></div><header><strong>inout params seem to have undefined behavior</strong> from <string>Karl Pickett</string> &lt;karl.pickett at gmail.com&gt;<p>June 11, 2016 at 12:00:00pm</p></header><div class="content"><p>I don&#39;t believe the (spartan) docs address this case:<br></p><p>func foo(inout a: [Int], inout b: Int) {<br>    let acopy = a<br>    a = [4, 5, 6]<br>    print(acopy)  // prints &quot;[1, 2, 3]&quot;<br>    b = 99<br>    print(a)   // prints &quot;[4, 5, 6]&quot;<br>    print(acopy)  // prints &quot;[1, 2, 99]&quot; (e.g. a let variable changed!)<br>}<br></p><p>var arr = [1,2,3]<br></p><p>foo(&amp;arr, b: &amp;arr[2])<br></p><p>print(arr)  // prints &quot;[4, 5, 6]&quot;<br></p><p><br>Is this code &quot;undefined&quot;, meaning the spec / doc doesn&#39;t specifically<br>say what should be happening?  For instance, I can&#39;t believe a let<br>variable gets changed.  The docs also say inout changes the original<br>value when the function ends, not in the middle as is happening here.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>inout params seem to have undefined behavior</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>June 11, 2016 at 01:00:00pm</p></header><div class="content"><p>You can’t pass a `let` as an `inout` argument. I’d guess that’s what’s happening is the `arr[2]` part is creating a temporary var to which the `&amp;` part then provides a reference. `b` is then dutifully modified in the function, but there’s no mechanism for copying it back into `arr` when `foo` returns, so the change isn’t reflected at the call site.<br></p><p>I *think* that the documentation you’re referring to in your last sentence is talking about when the value is updated at the call site. That is, `arr` itself isn’t updated until `foo` returns, but within `foo`, the argument `a` would have whatever value you assign it, whenever you assign it.<br></p><p>I think.<br></p><p>HTH (also, I hope I’m right… the only thing worse that no info is bad info)<br>- Dave Sweeris<br></p><p>&gt; On Jun 11, 2016, at 12:29 PM, Karl Pickett via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; I don&#39;t believe the (spartan) docs address this case:<br>&gt; <br>&gt; func foo(inout a: [Int], inout b: Int) {<br>&gt;    let acopy = a<br>&gt;    a = [4, 5, 6]<br>&gt;    print(acopy)  // prints &quot;[1, 2, 3]&quot;<br>&gt;    b = 99<br>&gt;    print(a)   // prints &quot;[4, 5, 6]&quot;<br>&gt;    print(acopy)  // prints &quot;[1, 2, 99]&quot; (e.g. a let variable changed!)<br>&gt; }<br>&gt; <br>&gt; var arr = [1,2,3]<br>&gt; <br>&gt; foo(&amp;arr, b: &amp;arr[2])<br>&gt; <br>&gt; print(arr)  // prints &quot;[4, 5, 6]&quot;<br>&gt; <br>&gt; <br>&gt; Is this code &quot;undefined&quot;, meaning the spec / doc doesn&#39;t specifically<br>&gt; say what should be happening?  For instance, I can&#39;t believe a let<br>&gt; variable gets changed.  The docs also say inout changes the original<br>&gt; value when the function ends, not in the middle as is happening here.<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160611/7cac7cd6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>inout params seem to have undefined behavior</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>June 11, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jun 11, 2016, at 11:57 AM, David Sweeris via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; You can’t pass a `let` as an `inout` argument. I’d guess that’s what’s happening is the `arr[2]` part is creating a temporary var to which the `&amp;` part then provides a reference.<br></p><p>But `arr` is a var, not a let.<br></p><p>&gt; `b` is then dutifully modified in the function, but there’s no mechanism for copying it back into `arr` when `foo` returns<br></p><p>No, it gets copied back using subscript assignment. Remember, `inout` isn’t really passing the address of the parameter (although the optimizer may reduce it to that.) It’s literally in-and-out: the caller passes the original value, the function returns the new value, the caller then stores the new value where the old value came from.<br></p><p>I am not a Swift guru, but I think the problem in this example is that there’s a sort of race condition in that last post-return stage: the function has returned new values for both `arr` and arr[2]`, both of which get stored back where they came from, but the ordering is significant because arr[2] will have a different value depending on which of those assignments happens first.<br></p><p>This smells like those C bugs where the result of an expression depends on the order in which subexpressions are evaluated — something like “x = i + (i++)”. The C standard formally declares this as undefined behavior.<br></p><p>The part I’m still confused by is how `acopy` got modified within the `foo` function, since it’s declared as `let`. After staring at this for a while longer, I’m forced to conclude that the compiler decided it could optimize the `b` parameter by actually passing a pointer to the Int and modifying it directly, and that this has the side effect of modifying the Array object that `acopy` is pointing to, even though it’s supposed to be immutable.<br></p><p>In other words, this looks like a compiler bug. I can reproduce it with Swift 2.2 (which is what my `swift` CLI tool says it is, even though I have Xcode 7.3.1 and I thought that was Swift 2.3?)<br></p><p>—Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160611/d2b1dffd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ccbc60826cca6a6f9c527b671cdad531?s=50"></div><header><strong>inout params seem to have undefined behavior</strong> from <string>Loïc Lecrenier</string> &lt;loiclecrenier at icloud.com&gt;<p>June 11, 2016 at 10:00:00pm</p></header><div class="content"><p>Hi,<br></p><p>I think what you said is correct. However, it is not a bug. We can&#39;t pass two inout arguments that alias each other because then the behaviour is undefined. It is documented in the Swift book somewhere. <br></p><p>Loïc<br></p><p>Sent from my iPad<br></p><p>&gt; On Jun 11, 2016, at 10:36 PM, Jens Alfke via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 11, 2016, at 11:57 AM, David Sweeris via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; You can’t pass a `let` as an `inout` argument. I’d guess that’s what’s happening is the `arr[2]` part is creating a temporary var to which the `&amp;` part then provides a reference.<br>&gt; <br>&gt; But `arr` is a var, not a let.<br>&gt; <br>&gt;&gt; `b` is then dutifully modified in the function, but there’s no mechanism for copying it back into `arr` when `foo` returns<br>&gt; <br>&gt; No, it gets copied back using subscript assignment. Remember, `inout` isn’t really passing the address of the parameter (although the optimizer may reduce it to that.) It’s literally in-and-out: the caller passes the original value, the function returns the new value, the caller then stores the new value where the old value came from.<br>&gt; <br>&gt; I am not a Swift guru, but I think the problem in this example is that there’s a sort of race condition in that last post-return stage: the function has returned new values for both `arr` and arr[2]`, both of which get stored back where they came from, but the ordering is significant because arr[2] will have a different value depending on which of those assignments happens first.<br>&gt; <br>&gt; This smells like those C bugs where the result of an expression depends on the order in which subexpressions are evaluated — something like “x = i + (i++)”. The C standard formally declares this as undefined behavior.<br>&gt; <br>&gt; The part I’m still confused by is how `acopy` got modified within the `foo` function, since it’s declared as `let`. After staring at this for a while longer, I’m forced to conclude that the compiler decided it could optimize the `b` parameter by actually passing a pointer to the Int and modifying it directly, and that this has the side effect of modifying the Array object that `acopy` is pointing to, even though it’s supposed to be immutable.<br>&gt; <br>&gt; In other words, this looks like a compiler bug. I can reproduce it with Swift 2.2 (which is what my `swift` CLI tool says it is, even though I have Xcode 7.3.1 and I thought that was Swift 2.3?)<br>&gt; <br>&gt; —Jens<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160611/dae29356/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ccbc60826cca6a6f9c527b671cdad531?s=50"></div><header><strong>inout params seem to have undefined behavior</strong> from <string>Loïc Lecrenier</string> &lt;loiclecrenier at icloud.com&gt;<p>June 12, 2016 at 12:00:00am</p></header><div class="content"><p>Sorry for the terse answer, I’ll try to expand a bit on my reasoning here.<br></p><p>In the Swift book, in “Language Reference” -&gt; “Declarations” -&gt; “In-Out Parameters”, it says:<br>“You can’t pass the same argument to multiple in-out parameters because the order in which the copies are written back is not well defined”.<br></p><p>Now, I am not 100% sure whether &amp;arr and &amp;arr[2] can be considered the same argument, but I would argue that they can because arr contains arr[2].<br>And because passing the same argument to two inout parameters is not allowed, the compiler can use an optimization like call-by-reference.<br></p><p>Here is an example, where the compiler assumes the arguments are not the same, and therefore uses call-by-reference instead of copy-in-copy-out:<br>struct S {<br>    var a: Int<br>}<br>func foo(inout s: S, _ a: inout Int) {<br>    a += 1<br>    s.a += 1<br>}<br></p><p>var s = S(a: 0)<br>foo(&amp;s, &amp;s.a)<br>print(s) // prints 2<br></p><p>So, to come back to the original example. Here is what I think is happening.<br>Even though arrays are value types, internally they use a reference-counted buffer. In order to mutate the array, the internal buffer must be uniquely referenced. If it is not, a new identical buffer is created.<br></p><p>So I’m going to follow the life of these internal buffers in the sample code:<br></p><p>var arr = [1,2,3]<br>// arr.buffer = buffer1 (new buffer)<br>// buffer1’s reference count: +1<br></p><p>foo(&amp;arr, b: &amp;arr[2])<br></p><p>func foo(inout a: [Int], inout b: Int) {<br>    // buffer1: +1<br>    <br>    let acopy = a<br>    // acopy.buffer = a.buffer (which is buffer1)<br>    // buffer1: +2<br>    <br>    a = [4, 5, 6]<br>    // a changes, but it has value semantics and a.buffer’s reference count is &gt; 1<br>    // Therefore a new buffer is created.<br>    // a.buffer = buffer2 (new buffer identical to buffer1)<br>    // Now:<br>    // buffer1: +1<br>    // buffer2: +1<br>    <br>    print(acopy)  // prints buffer1: &quot;[1, 2, 3]&quot;<br></p><p>    b = 99  // b points to address in buffer1 because of call-by-reference optimization<br>    // buffer1[2] = 99<br></p><p>    print(a)      // prints buffer2: &quot;[4, 5, 6]&quot;<br>    print(acopy)  // prints buffer1: &quot;[1, 2, 99]&quot;<br></p><p>    // Now a is returned -&gt; buffer2 is returned and stays alive<br>    // acopy not returned -&gt; buffer1’s reference count drops to zero -&gt; it is destroyed<br>}<br></p><p>print(arr)  // prints buffer2: &quot;[4, 5, 6]&quot;<br></p><p>I hope this helps and that I haven’t made any mistake 😊<br></p><p>Loïc<br></p><p><br>&gt; On Jun 11, 2016, at 10:52 PM, Loïc Lecrenier via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; I think what you said is correct. However, it is not a bug. We can&#39;t pass two inout arguments that alias each other because then the behaviour is undefined. It is documented in the Swift book somewhere. <br>&gt; <br>&gt; Loïc<br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On Jun 11, 2016, at 10:36 PM, Jens Alfke via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 11, 2016, at 11:57 AM, David Sweeris via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You can’t pass a `let` as an `inout` argument. I’d guess that’s what’s happening is the `arr[2]` part is creating a temporary var to which the `&amp;` part then provides a reference.<br>&gt;&gt; <br>&gt;&gt; But `arr` is a var, not a let.<br>&gt;&gt; <br>&gt;&gt;&gt; `b` is then dutifully modified in the function, but there’s no mechanism for copying it back into `arr` when `foo` returns<br>&gt;&gt; <br>&gt;&gt; No, it gets copied back using subscript assignment. Remember, `inout` isn’t really passing the address of the parameter (although the optimizer may reduce it to that.) It’s literally in-and-out: the caller passes the original value, the function returns the new value, the caller then stores the new value where the old value came from.<br>&gt;&gt; <br>&gt;&gt; I am not a Swift guru, but I think the problem in this example is that there’s a sort of race condition in that last post-return stage: the function has returned new values for both `arr` and arr[2]`, both of which get stored back where they came from, but the ordering is significant because arr[2] will have a different value depending on which of those assignments happens first.<br>&gt;&gt; <br>&gt;&gt; This smells like those C bugs where the result of an expression depends on the order in which subexpressions are evaluated — something like “x = i + (i++)”. The C standard formally declares this as undefined behavior.<br>&gt;&gt; <br>&gt;&gt; The part I’m still confused by is how `acopy` got modified within the `foo` function, since it’s declared as `let`. After staring at this for a while longer, I’m forced to conclude that the compiler decided it could optimize the `b` parameter by actually passing a pointer to the Int and modifying it directly, and that this has the side effect of modifying the Array object that `acopy` is pointing to, even though it’s supposed to be immutable.<br>&gt;&gt; <br>&gt;&gt; In other words, this looks like a compiler bug. I can reproduce it with Swift 2.2 (which is what my `swift` CLI tool says it is, even though I have Xcode 7.3.1 and I thought that was Swift 2.3?)<br>&gt;&gt; <br>&gt;&gt; —Jens<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160612/c948e1e1/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>inout params seem to have undefined behavior</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>June 11, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jun 11, 2016, at 3:36 PM, Jens Alfke &lt;jens at mooseyard.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 11, 2016, at 11:57 AM, David Sweeris via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; You can’t pass a `let` as an `inout` argument. I’d guess that’s what’s happening is the `arr[2]` part is creating a temporary var to which the `&amp;` part then provides a reference.<br>&gt; <br>&gt; But `arr` is a var, not a let.<br></p><p>I know. You’d said that you &quot;can&#39;t believe a let variable gets changed”. I was just pointing out that you’re correct, in that the compiler will complain if you try to pass one as an in-out argument.<br></p><p><br>&gt;&gt; `b` is then dutifully modified in the function, but there’s no mechanism for copying it back into `arr` when `foo` returns<br>&gt; <br>&gt; No, it gets copied back using subscript assignment. Remember, `inout` isn’t really passing the address of the parameter (although the optimizer may reduce it to that.) It’s literally in-and-out: the caller passes the original value, the function returns the new value, the caller then stores the new value where the old value came from.<br></p><p>I don’t think it can… My recollection is that in Swift the subscript operator (`arr[2]` in this case) can refer to the setter xor the getter, but not both within the same statement. If that’s correct, for there to be a value to pass to the function, `arr[2]` must be referring to the getter version, which means that there’s no setter to update the value when `foo` returns.<br></p><p><br>&gt; I am not a Swift guru, but I think the problem in this example is that there’s a sort of race condition in that last post-return stage: the function has returned new values for both `arr` and arr[2]`, both of which get stored back where they came from, but the ordering is significant because arr[2] will have a different value depending on which of those assignments happens first.<br>&gt; <br>&gt; This smells like those C bugs where the result of an expression depends on the order in which subexpressions are evaluated — something like “x = i + (i++)”. The C standard formally declares this as undefined behavior.<br>&gt; <br>&gt; The part I’m still confused by is how `acopy` got modified within the `foo` function, since it’s declared as `let`. After staring at this for a while longer, I’m forced to conclude that the compiler decided it could optimize the `b` parameter by actually passing a pointer to the Int and modifying it directly, and that this has the side effect of modifying the Array object that `acopy` is pointing to, even though it’s supposed to be immutable.<br>&gt; <br>&gt; In other words, this looks like a compiler bug. I can reproduce it with Swift 2.2 (which is what my `swift` CLI tool says it is, even though I have Xcode 7.3.1 and I thought that was Swift 2.3?)<br></p><p>Ah… I see what you mean about a `let` getting modified now… My mistake, I thought you were wondering why `arr` wasn’t `[4, 5, 99]` after foo returned. Yeah, I’m not sure about what’s happening within `foo`... Maybe someone who knows more will come along and provide an explanation, but at the moment I’m inclined to agree — both that you’ve found a bug, and with your guess and to how it’s happening. <br></p><p>- Dave Sweeris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160611/fcf5c428/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>inout params seem to have undefined behavior</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>June 11, 2016 at 04:00:00pm</p></header><div class="content"><p>Ack! “Karl”, not you. For some reason I thought you were the OP until right after I clicked send. Sorry for the confusion.<br></p><p>- Dave Sweeris<br></p><p>&gt; On Jun 11, 2016, at 4:06 PM, David Sweeris via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jun 11, 2016, at 3:36 PM, Jens Alfke &lt;jens at mooseyard.com &lt;mailto:jens at mooseyard.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 11, 2016, at 11:57 AM, David Sweeris via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You can’t pass a `let` as an `inout` argument. I’d guess that’s what’s happening is the `arr[2]` part is creating a temporary var to which the `&amp;` part then provides a reference. <br>&gt;&gt; <br>&gt;&gt; But `arr` is a var, not a let.<br>&gt; <br>&gt; I know. You’d said that you &quot;can&#39;t believe a let variable gets changed”. I was just pointing out that you’re correct, in that the compiler will complain if you try to pass one as an in-out argument.<br>&gt; <br>&gt; <br>&gt;&gt;&gt; `b` is then dutifully modified in the function, but there’s no mechanism for copying it back into `arr` when `foo` returns<br>&gt;&gt; <br>&gt;&gt; No, it gets copied back using subscript assignment. Remember, `inout` isn’t really passing the address of the parameter (although the optimizer may reduce it to that.) It’s literally in-and-out: the caller passes the original value, the function returns the new value, the caller then stores the new value where the old value came from.<br>&gt; <br>&gt; I don’t think it can… My recollection is that in Swift the subscript operator (`arr[2]` in this case) can refer to the setter xor the getter, but not both within the same statement. If that’s correct, for there to be a value to pass to the function, `arr[2]` must be referring to the getter version, which means that there’s no setter to update the value when `foo` returns.<br>&gt; <br>&gt; <br>&gt;&gt; I am not a Swift guru, but I think the problem in this example is that there’s a sort of race condition in that last post-return stage: the function has returned new values for both `arr` and arr[2]`, both of which get stored back where they came from, but the ordering is significant because arr[2] will have a different value depending on which of those assignments happens first.<br>&gt;&gt; <br>&gt;&gt; This smells like those C bugs where the result of an expression depends on the order in which subexpressions are evaluated — something like “x = i + (i++)”. The C standard formally declares this as undefined behavior.<br>&gt;&gt; <br>&gt;&gt; The part I’m still confused by is how `acopy` got modified within the `foo` function, since it’s declared as `let`. After staring at this for a while longer, I’m forced to conclude that the compiler decided it could optimize the `b` parameter by actually passing a pointer to the Int and modifying it directly, and that this has the side effect of modifying the Array object that `acopy` is pointing to, even though it’s supposed to be immutable.<br>&gt;&gt; <br>&gt;&gt; In other words, this looks like a compiler bug. I can reproduce it with Swift 2.2 (which is what my `swift` CLI tool says it is, even though I have Xcode 7.3.1 and I thought that was Swift 2.3?)<br>&gt; <br>&gt; Ah… I see what you mean about a `let` getting modified now… My mistake, I thought you were wondering why `arr` wasn’t `[4, 5, 99]` after foo returned. Yeah, I’m not sure about what’s happening within `foo`... Maybe someone who knows more will come along and provide an explanation, but at the moment I’m inclined to agree — both that you’ve found a bug, and with your guess and to how it’s happening. <br>&gt; <br>&gt; - Dave Sweeris<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160611/62db7aa6/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>inout params seem to have undefined behavior</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June 11, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; My recollection is that in Swift the subscript operator (`arr[2]` in this case) can refer to the setter xor the getter, but not both within the same statement.<br></p><p>Quite to the contrary. Rather than using the setter directly, Swift often uses `materializeForSet`, a combined get-and-set operation which is much more efficient, particularly when assigning directly into arrays. To keep from having to use very slow access all the time, it imposes a rule (which is not and cannot be enforced by the compiler) that you can&#39;t hold two mutable references to overlapping storage simultaneously, or they may do strange things like lose some of the writes you make.<br></p><p>Here&#39;s an old design document discussing some things in this area: &lt;https://github.com/apple/swift/blob/73841a643c087e854a2f62c7e073317bd43af310/docs/proposals/Accessors.rst&gt; I&#39;m not sure how authoritative it is, but it might give you an idea of what&#39;s going on.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/37ed623c7e539c1e991c5be604e4a7aa?s=50"></div><header><strong>inout params seem to have undefined behavior</strong> from <string>Karl Pickett</string> &lt;karl.pickett at gmail.com&gt;<p>June 11, 2016 at 08:00:00pm</p></header><div class="content"><p>Wow there are some real doozy inout code examples in there, showing<br>aliasing much more fun than my snippet.  Unfortunately I can&#39;t<br>understand anything else the doc is talking about.  I guess I&#39;ll just<br>say a prayer and throw salt over my shoulder if using inout.<br></p><p>On Sat, Jun 11, 2016 at 6:05 PM, Brent Royal-Gordon<br>&lt;brent at architechies.com&gt; wrote:<br>&gt;&gt; My recollection is that in Swift the subscript operator (`arr[2]` in this case) can refer to the setter xor the getter, but not both within the same statement.<br>&gt;<br>&gt; Quite to the contrary. Rather than using the setter directly, Swift often uses `materializeForSet`, a combined get-and-set operation which is much more efficient, particularly when assigning directly into arrays. To keep from having to use very slow access all the time, it imposes a rule (which is not and cannot be enforced by the compiler) that you can&#39;t hold two mutable references to overlapping storage simultaneously, or they may do strange things like lose some of the writes you make.<br>&gt;<br>&gt; Here&#39;s an old design document discussing some things in this area: &lt;https://github.com/apple/swift/blob/73841a643c087e854a2f62c7e073317bd43af310/docs/proposals/Accessors.rst&gt; I&#39;m not sure how authoritative it is, but it might give you an idea of what&#39;s going on.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/957b675456a66c394945a7361aedd51d?s=50"></div><header><strong>inout params seem to have undefined behavior</strong> from <string>Zhao Xin</string> &lt;owenzx at gmail.com&gt;<p>June 12, 2016 at 10:00:00am</p></header><div class="content"><p>inout says it will copy into the function and copy back after the function<br>is finished. But the order is unknown. So I think the example,<br></p><p>print(acopy)  // prints &quot;[1, 2, 99]&quot; (e.g. a let variable changed!)<br></p><p>i<br>​s a bug as the value changed inside of the function, before the function<br>returns.<br></p><p>​Swift doc:<br></p><p>​<br>“In-out parameters are passed as follows:<br></p><p>1<br>​. ​<br>When the function is called, the value of the argument is copied.<br>2<br>​. ​<br>In the body of the function, the copy is modified.<br>3<br>​ .​<br>When the function returns, the copy’s value is assigned to the original<br>argument.”<br></p><p>摘录来自: Apple Inc. “The Swift Programming Language (Swift 2.2)”。 iBooks.<br></p><p>Zhaoxin<br></p><p>On Sun, Jun 12, 2016 at 9:27 AM, Karl Pickett via swift-users &lt;<br>swift-users at swift.org&gt; wrote:<br></p><p>&gt; Wow there are some real doozy inout code examples in there, showing<br>&gt; aliasing much more fun than my snippet.  Unfortunately I can&#39;t<br>&gt; understand anything else the doc is talking about.  I guess I&#39;ll just<br>&gt; say a prayer and throw salt over my shoulder if using inout.<br>&gt;<br>&gt; On Sat, Jun 11, 2016 at 6:05 PM, Brent Royal-Gordon<br>&gt; &lt;brent at architechies.com&gt; wrote:<br>&gt; &gt;&gt; My recollection is that in Swift the subscript operator (`arr[2]` in<br>&gt; this case) can refer to the setter xor the getter, but not both within the<br>&gt; same statement.<br>&gt; &gt;<br>&gt; &gt; Quite to the contrary. Rather than using the setter directly, Swift<br>&gt; often uses `materializeForSet`, a combined get-and-set operation which is<br>&gt; much more efficient, particularly when assigning directly into arrays. To<br>&gt; keep from having to use very slow access all the time, it imposes a rule<br>&gt; (which is not and cannot be enforced by the compiler) that you can&#39;t hold<br>&gt; two mutable references to overlapping storage simultaneously, or they may<br>&gt; do strange things like lose some of the writes you make.<br>&gt; &gt;<br>&gt; &gt; Here&#39;s an old design document discussing some things in this area: &lt;<br>&gt; https://github.com/apple/swift/blob/73841a643c087e854a2f62c7e073317bd43af310/docs/proposals/Accessors.rst&gt;<br>&gt; I&#39;m not sure how authoritative it is, but it might give you an idea of<br>&gt; what&#39;s going on.<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Brent Royal-Gordon<br>&gt; &gt; Architechies<br>&gt; &gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160612/915201a9/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>inout params seem to have undefined behavior</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June 12, 2016 at 04:00:00am</p></header><div class="content"><p>&gt; Wow there are some real doozy inout code examples in there, showing<br>&gt; aliasing much more fun than my snippet.  Unfortunately I can&#39;t<br>&gt; understand anything else the doc is talking about.  I guess I&#39;ll just<br>&gt; say a prayer and throw salt over my shoulder if using inout.<br></p><p>Sorry! Here&#39;s the money quote from that document:<br></p><p>&gt; ##### If you didn&#39;t catch all that...<br>&gt; <br>&gt; That may have been a somewhat intense description, so here&#39;s a simple summary of the rule being proposed.<br>&gt; <br>&gt; If storage is passed to an inout argument, then any other simultaneous attempt to read or write to that storage, including to the storage containing it, will have unspecified behavior. Reads from it may see partially-updated values, or even values which will change as modifications are made to the original storage; and writes may be clobbered or simply disappear.<br>&gt; <br>&gt; But this only applies during the call with the inout argument: the evaluation of other arguments to the call will not be interfered with, and as soon as the call ends, all these modifications will resolve back to a quiescent state.<br>&gt; <br>&gt; And this unspecified behavior has limits. The storage may end up with an unexpected value, with only a subset of the writes made to it, and copies from it may unexpectedly reflect modifications made after they were copied. However, the program will otherwise remain in a consistent and uncorrupted state. This means that execution will be able to continue apace as long as these unexpected values don&#39;t trip up some higher-level invariant.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>inout params seem to have undefined behavior</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>June 12, 2016 at 02:00:00am</p></header><div class="content"><p>Oh, ok, I stand corrected. Thanks for the link :-)<br></p><p>Sent from my iPhone<br></p><p>On Jun 11, 2016, at 18:05, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br></p><p>&gt;&gt; My recollection is that in Swift the subscript operator (`arr[2]` in this case) can refer to the setter xor the getter, but not both within the same statement.<br>&gt; <br>&gt; Quite to the contrary. Rather than using the setter directly, Swift often uses `materializeForSet`, a combined get-and-set operation which is much more efficient, particularly when assigning directly into arrays. To keep from having to use very slow access all the time, it imposes a rule (which is not and cannot be enforced by the compiler) that you can&#39;t hold two mutable references to overlapping storage simultaneously, or they may do strange things like lose some of the writes you make.<br>&gt; <br>&gt; Here&#39;s an old design document discussing some things in this area: &lt;https://github.com/apple/swift/blob/73841a643c087e854a2f62c7e073317bd43af310/docs/proposals/Accessors.rst&gt; I&#39;m not sure how authoritative it is, but it might give you an idea of what&#39;s going on.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>inout params seem to have undefined behavior</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>June 13, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jun 11, 2016, at 10:29 AM, Karl Pickett via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; I don&#39;t believe the (spartan) docs address this case:<br>&gt; <br>&gt; func foo(inout a: [Int], inout b: Int) {<br>&gt;    let acopy = a<br>&gt;    a = [4, 5, 6]<br>&gt;    print(acopy)  // prints &quot;[1, 2, 3]&quot;<br>&gt;    b = 99<br>&gt;    print(a)   // prints &quot;[4, 5, 6]&quot;<br>&gt;    print(acopy)  // prints &quot;[1, 2, 99]&quot; (e.g. a let variable changed!)<br>&gt; }<br>&gt; <br>&gt; var arr = [1,2,3]<br>&gt; <br>&gt; foo(&amp;arr, b: &amp;arr[2])<br>&gt; <br>&gt; print(arr)  // prints &quot;[4, 5, 6]&quot;<br>&gt; <br>&gt; <br>&gt; Is this code &quot;undefined&quot;, meaning the spec / doc doesn&#39;t specifically<br>&gt; say what should be happening?  For instance, I can&#39;t believe a let<br>&gt; variable gets changed.  The docs also say inout changes the original<br>&gt; value when the function ends, not in the middle as is happening here.<br></p><p>It&#39;s not undefined behavior in that we try to ensure that memory safety is still preserved when inout parameters alias, but it is *unspecified* when updates to an inout parameter will be written back to the original argument. You should avoid aliasing inout parameters for this reason.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>inout params seem to have undefined behavior</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>June 13, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jun 13, 2016, at 9:45 AM, Joe Groff via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; It&#39;s not undefined behavior in that we try to ensure that memory safety is still preserved when inout parameters alias, but it is *unspecified* when updates to an inout parameter will be written back to the original argument.<br></p><p>But it seems that memory safety was broken in that an array assigned to a ‘let’ variable was mutated. Doesn’t that violate the contract of its immutability?<br></p><p>Edited version of the example:<br>&gt;&gt;   let acopy = a<br>&gt;&gt;  print(acopy)  // prints &quot;[1, 2, 3]&quot;<br>&gt;&gt;   b = 99<br>&gt;&gt;   print(acopy)  // prints &quot;[1, 2, 99]&quot; (e.g. a let variable changed!)<br></p><p><br>—Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160613/debd98db/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>inout params seem to have undefined behavior</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>June 13, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jun 13, 2016, at 1:39 PM, Jens Alfke &lt;jens at mooseyard.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 13, 2016, at 9:45 AM, Joe Groff via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; It&#39;s not undefined behavior in that we try to ensure that memory safety is still preserved when inout parameters alias, but it is *unspecified* when updates to an inout parameter will be written back to the original argument.<br>&gt; <br>&gt; But it seems that memory safety was broken in that an array assigned to a ‘let’ variable was mutated. Doesn’t that violate the contract of its immutability?<br></p><p>I see, missed that part. That&#39;s a bug—`acopy` should remain a distinct copy of `a`.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>inout params seem to have undefined behavior</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>June 13, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jun 13, 2016, at 1:43 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; I see, missed that part. That&#39;s a bug—`acopy` should remain a distinct copy of `a`.<br></p><p>I’m guessing that when `a` is copied into `acopy`, the same array contents are shared between them, then when `a` is mutated it gets a new copy of the contents. Then the assignment to `b` writes into the original array contents now held by `acopy`.<br></p><p>Still seems like it’s caused by having aliased `inout` variables, but the effect is nastier. I can imagine horrible bugs where `acopy` gets passed around somewhere else and then changes, breaking the something-else that’s holding it. It could be hard to track that back to its original cause, especially if there are two different codebases involved.<br></p><p>—Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160613/06439622/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/957b675456a66c394945a7361aedd51d?s=50"></div><header><strong>inout params seem to have undefined behavior</strong> from <string>Zhao Xin</string> &lt;owenzx at gmail.com&gt;<p>June 14, 2016 at 12:00:00pm</p></header><div class="content"><p>According to the latest Swift 3 docs<br></p><p>“As an optimization, when the argument is a value stored at a physical<br>address in memory, the same memory location is used both inside and outside<br>the function body. The optimized behavior is known as call by reference; it<br>satisfies all of the requirements of the copy-in copy-out model while<br>removing the overhead of copying. Write your code using the model given by<br>copy-in copy-out, without depending on the call-by-reference optimization,<br>so that it behaves correctly with or without the optimization.”<br></p><p>摘录来自: Apple Inc. “The Swift Programming Language (Swift 3)”。 iBooks.<br></p><p>​So the behavior is because of the optimization, which should not rely on.<br></p><p>Zhaoxin ​<br></p><p><br>On Tue, Jun 14, 2016 at 5:12 AM, Jens Alfke via swift-users &lt;<br>swift-users at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Jun 13, 2016, at 1:43 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;<br>&gt; I see, missed that part. That&#39;s a bug—`acopy` should remain a distinct<br>&gt; copy of `a`.<br>&gt;<br>&gt;<br>&gt; I’m guessing that when `a` is copied into `acopy`, the same array contents<br>&gt; are shared between them, then when `a` is mutated it gets a new copy of the<br>&gt; contents. Then the assignment to `b` writes into the original array<br>&gt; contents now held by `acopy`.<br>&gt;<br>&gt; Still seems like it’s caused by having aliased `inout` variables, but the<br>&gt; effect is nastier. I can imagine horrible bugs where `acopy` gets passed<br>&gt; around somewhere else and then changes, breaking the something-else that’s<br>&gt; holding it. It could be hard to track that back to its original cause,<br>&gt; especially if there are two different codebases involved.<br>&gt;<br>&gt; —Jens<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160614/6718a67e/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
