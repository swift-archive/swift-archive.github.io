<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/411a0fa16436bc975292f7044033a246?s=50"></div><header><strong>Allowing non-binding pattern matching as a Bool expression?</strong> from <string>Alex Lew</string> &lt;alexl.mail+swift at gmail.com&gt;<p>December  7, 2015 at 11:00:00pm</p></header><div class="content"><p>Hi all,<br></p><p>Curious to hear thoughts on allowing non-binding pattern matches to be used<br>as boolean values outside of an if, guard, for...in, while, switch, etc.<br>Something like:<br></p><p>enum List&lt;T&gt; {<br>     case Empty<br>     indirect case Link(T, List&lt;T&gt;)<br></p><p>     func isEmpty() -&gt; Bool {<br>          return case .Empty = self<br>     }<br>}<br></p><p>It gets rid of some boilerplate (explicit return true and return false),<br>and seems intuitive that it would work given that you can already do<br></p><p>if case .Empty = self {<br>     return true<br>} else {<br>     return false<br>}<br></p><p>I haven&#39;t really thought through all the implications here, so there&#39;s<br>probably something I&#39;m missing. It also may be useful only in such limited<br>situations that it&#39;s not worth the trouble to add.<br></p><p>-Alex<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/87481738/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Allowing non-binding pattern matching as a Bool expression?</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>December  8, 2015 at 09:00:00pm</p></header><div class="content"><p>I&#39;ve wanted similar too. Although it may be better, instead of Bool, to<br>have it as an optional tuple, the reason I suggest this is so that you can<br>get the associated type. For example:<br></p><p>case let .Link(value,link) = self<br></p><p>So your example could be written:<br></p><p>func isEmpty() -&gt; Bool {<br>    return (case .Empty = self) != nil<br>}<br></p><p>However I&#39;m not sure about this syntax, perhaps something like this:<br></p><p>func isEmpty() -&gt; Bool {<br>    return self is case .Empty<br>}<br></p><p>Alternatively if you want the value you could do:<br></p><p>let (value, link) = self as? case .Link<br></p><p><br>On Tue, Dec 8, 2015 at 3:05 PM, Alex Lew via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi all,<br>&gt;<br>&gt; Curious to hear thoughts on allowing non-binding pattern matches to be<br>&gt; used as boolean values outside of an if, guard, for...in, while, switch,<br>&gt; etc. Something like:<br>&gt;<br>&gt; enum List&lt;T&gt; {<br>&gt;      case Empty<br>&gt;      indirect case Link(T, List&lt;T&gt;)<br>&gt;<br>&gt;      func isEmpty() -&gt; Bool {<br>&gt;           return case .Empty = self<br>&gt;      }<br>&gt; }<br>&gt;<br>&gt; It gets rid of some boilerplate (explicit return true and return false),<br>&gt; and seems intuitive that it would work given that you can already do<br>&gt;<br>&gt; if case .Empty = self {<br>&gt;      return true<br>&gt; } else {<br>&gt;      return false<br>&gt; }<br>&gt;<br>&gt; I haven&#39;t really thought through all the implications here, so there&#39;s<br>&gt; probably something I&#39;m missing. It also may be useful only in such limited<br>&gt; situations that it&#39;s not worth the trouble to add.<br>&gt;<br>&gt; -Alex<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/6a63948e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bab03b11d4cd60804cf4a6ba68589430?s=50"></div><header><strong>Allowing non-binding pattern matching as a Bool expression?</strong> from <string>Kevin Lundberg</string> &lt;kevin at klundberg.com&gt;<p>December  8, 2015 at 09:00:00am</p></header><div class="content"><p>Adding additional behavior to is/as that doesn&#39;t deal directly with types seems confusing to me. Those operators I feel would be best left for checking and casting types, despite how much nicer this reads.<br></p><p>--<br>Kevin Lundberg<br></p><p>&gt; On Dec 8, 2015, at 5:31 AM, Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;ve wanted similar too. Although it may be better, instead of Bool, to have it as an optional tuple, the reason I suggest this is so that you can get the associated type. For example:<br>&gt; <br>&gt; case let .Link(value,link) = self<br>&gt; <br>&gt; So your example could be written:<br>&gt; <br>&gt; func isEmpty() -&gt; Bool {<br>&gt;     return (case .Empty = self) != nil<br>&gt; }<br>&gt; <br>&gt; However I&#39;m not sure about this syntax, perhaps something like this:<br>&gt; <br>&gt; func isEmpty() -&gt; Bool {<br>&gt;     return self is case .Empty<br>&gt; }<br>&gt; <br>&gt; Alternatively if you want the value you could do:<br>&gt; <br>&gt; let (value, link) = self as? case .Link<br>&gt; <br>&gt; <br>&gt;&gt; On Tue, Dec 8, 2015 at 3:05 PM, Alex Lew via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; Curious to hear thoughts on allowing non-binding pattern matches to be used as boolean values outside of an if, guard, for...in, while, switch, etc. Something like:<br>&gt;&gt; <br>&gt;&gt; enum List&lt;T&gt; {<br>&gt;&gt;      case Empty<br>&gt;&gt;      indirect case Link(T, List&lt;T&gt;)<br>&gt;&gt;      <br>&gt;&gt;      func isEmpty() -&gt; Bool {<br>&gt;&gt;           return case .Empty = self<br>&gt;&gt;      }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; It gets rid of some boilerplate (explicit return true and return false), and seems intuitive that it would work given that you can already do <br>&gt;&gt; <br>&gt;&gt; if case .Empty = self {<br>&gt;&gt;      return true<br>&gt;&gt; } else {<br>&gt;&gt;      return false<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I haven&#39;t really thought through all the implications here, so there&#39;s probably something I&#39;m missing. It also may be useful only in such limited situations that it&#39;s not worth the trouble to add.<br>&gt;&gt; <br>&gt;&gt; -Alex<br>&gt;&gt;  <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/1348adc6/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Allowing non-binding pattern matching as a Bool expression?</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December  8, 2015 at 09:00:00pm</p></header><div class="content"><p>&gt; On Dec 7, 2015, at 8:05 PM, Alex Lew via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; Curious to hear thoughts on allowing non-binding pattern matches to be used as boolean values outside of an if, guard, for...in, while, switch, etc. Something like:<br>&gt; <br>&gt; enum List&lt;T&gt; {<br>&gt;      case Empty<br>&gt;      indirect case Link(T, List&lt;T&gt;)<br>&gt;      <br>&gt;      func isEmpty() -&gt; Bool {<br>&gt;           return case .Empty = self<br>&gt;      }<br>&gt; }<br></p><p>I agree with you that this is a problem that we should solve, but I think it could be solved in a different way.  Imagine if:<br></p><p>enum Foo {<br>  case X(a : Float), Y, Z(a : Int)<br>}<br></p><p>automatically synthesized these members (the exact names are just a strawman proposal, not serious :-)<br></p><p>extension Foo {<br>  func isX() -&gt; Float? {…}<br>  func isY() -&gt; Bool {…}<br>  func isZ() -&gt; Int? {…}<br>}<br></p><p>This would tie into all of the mechanics we have for dealing with optionals, e.g. if/let and ??<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/411a0fa16436bc975292f7044033a246?s=50"></div><header><strong>Allowing non-binding pattern matching as a Bool expression?</strong> from <string>Alex Lew</string> &lt;alexl.mail+swift at gmail.com&gt;<p>December  9, 2015 at 01:00:00am</p></header><div class="content"><p>Thanks, Chris, for all the time you&#39;re putting into responding to these<br>proposals (and the kindness with which you&#39;re responding!). I really like<br>that solution.<br></p><p>Brainstorming some names for the auto-generated functions:<br></p><p>1. If a case has no associated values, isX() -&gt; Bool is generated, where X<br>is the case name.<br>    If a case has an associated value of type T, asX() -&gt; T? is generated,<br>where X is the case name.<br>    This mirrors is/as? operators, which return Bool / Optional<br>respectively.<br>2. projectX() -&gt; Bool / projectX() -&gt; T?<br>3. isX() -&gt; Bool / xValue() -&gt; T?<br></p><p>Another option (probably the wrong option, but it&#39;s worth putting out<br>there) is that instead of returning Bool in the no-associated-value case,<br>we return ()?. This would make me feel better about using the same naming<br>convention (asX(), projectX(), xValue(), etc.) for each case, and would<br>allow for != nil checks on all cases. But it would probably be a little<br>confusing for newcomers to the language.<br></p><p>One (potentially misguided) question. I noticed in proposal 0002 (on<br>removing function currying) that there are &quot;plans to move away from the<br>arguments-are-a-single-tuple model&quot; in the near future. Would this also<br>affect associated values of enums? That is, might<br></p><p>case Dog(name: String, age: Int, breed: String)<br></p><p>one day not have the semantics of a single associated value of type (name:<br>String, age: Int, breed: String)? Or is the de-ML-ification planned only<br>for function arguments?<br></p><p>-Alex<br></p><p>On Wed, Dec 9, 2015 at 12:45 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Dec 7, 2015, at 8:05 PM, Alex Lew via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Hi all,<br>&gt; &gt;<br>&gt; &gt; Curious to hear thoughts on allowing non-binding pattern matches to be<br>&gt; used as boolean values outside of an if, guard, for...in, while, switch,<br>&gt; etc. Something like:<br>&gt; &gt;<br>&gt; &gt; enum List&lt;T&gt; {<br>&gt; &gt;      case Empty<br>&gt; &gt;      indirect case Link(T, List&lt;T&gt;)<br>&gt; &gt;<br>&gt; &gt;      func isEmpty() -&gt; Bool {<br>&gt; &gt;           return case .Empty = self<br>&gt; &gt;      }<br>&gt; &gt; }<br>&gt;<br>&gt; I agree with you that this is a problem that we should solve, but I think<br>&gt; it could be solved in a different way.  Imagine if:<br>&gt;<br>&gt; enum Foo {<br>&gt;   case X(a : Float), Y, Z(a : Int)<br>&gt; }<br>&gt;<br>&gt; automatically synthesized these members (the exact names are just a<br>&gt; strawman proposal, not serious :-)<br>&gt;<br>&gt; extension Foo {<br>&gt;   func isX() -&gt; Float? {…}<br>&gt;   func isY() -&gt; Bool {…}<br>&gt;   func isZ() -&gt; Int? {…}<br>&gt; }<br>&gt;<br>&gt; This would tie into all of the mechanics we have for dealing with<br>&gt; optionals, e.g. if/let and ??<br>&gt;<br>&gt; -Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/b93e9491/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8a24682926961206ad452d8455b09457?s=50"></div><header><strong>Allowing non-binding pattern matching as a Bool expression?</strong> from <string>thorsten at portableinnovations.de</string> &lt;thorsten at portableinnovations.de&gt;<p>December  9, 2015 at 05:00:00pm</p></header><div class="content"><p>I would prefer if no &quot;magic&quot; methods would be generated automatically, but only when marked with @derivestandardmethods (fill in better name here).<br></p><p>As to naming I like the proposal #1 by Alex.<br></p><p>What about enums with more than one associated value?<br></p><p>-Thorsten<br></p><p>&gt; Am 09.12.2015 um 07:29 schrieb Alex Lew via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Thanks, Chris, for all the time you&#39;re putting into responding to these proposals (and the kindness with which you&#39;re responding!). I really like that solution.<br>&gt; <br>&gt; Brainstorming some names for the auto-generated functions:<br>&gt; <br>&gt; 1. If a case has no associated values, isX() -&gt; Bool is generated, where X is the case name.<br>&gt;     If a case has an associated value of type T, asX() -&gt; T? is generated, where X is the case name.<br>&gt;     This mirrors is/as? operators, which return Bool / Optional respectively.<br>&gt; 2. projectX() -&gt; Bool / projectX() -&gt; T?<br>&gt; 3. isX() -&gt; Bool / xValue() -&gt; T?<br>&gt; <br>&gt; Another option (probably the wrong option, but it&#39;s worth putting out there) is that instead of returning Bool in the no-associated-value case, we return ()?. This would make me feel better about using the same naming convention (asX(), projectX(), xValue(), etc.) for each case, and would allow for != nil checks on all cases. But it would probably be a little confusing for newcomers to the language.<br>&gt; <br>&gt; One (potentially misguided) question. I noticed in proposal 0002 (on removing function currying) that there are &quot;plans to move away from the arguments-are-a-single-tuple model&quot; in the near future. Would this also affect associated values of enums? That is, might<br>&gt; <br>&gt; case Dog(name: String, age: Int, breed: String)<br>&gt; <br>&gt; one day not have the semantics of a single associated value of type (name: String, age: Int, breed: String)? Or is the de-ML-ification planned only for function arguments?<br>&gt; <br>&gt; -Alex<br>&gt; <br>&gt;&gt; On Wed, Dec 9, 2015 at 12:45 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt; On Dec 7, 2015, at 8:05 PM, Alex Lew via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Hi all,<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Curious to hear thoughts on allowing non-binding pattern matches to be used as boolean values outside of an if, guard, for...in, while, switch, etc. Something like:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; enum List&lt;T&gt; {<br>&gt;&gt; &gt;      case Empty<br>&gt;&gt; &gt;      indirect case Link(T, List&lt;T&gt;)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;      func isEmpty() -&gt; Bool {<br>&gt;&gt; &gt;           return case .Empty = self<br>&gt;&gt; &gt;      }<br>&gt;&gt; &gt; }<br>&gt;&gt; <br>&gt;&gt; I agree with you that this is a problem that we should solve, but I think it could be solved in a different way.  Imagine if:<br>&gt;&gt; <br>&gt;&gt; enum Foo {<br>&gt;&gt;   case X(a : Float), Y, Z(a : Int)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; automatically synthesized these members (the exact names are just a strawman proposal, not serious :-)<br>&gt;&gt; <br>&gt;&gt; extension Foo {<br>&gt;&gt;   func isX() -&gt; Float? {…}<br>&gt;&gt;   func isY() -&gt; Bool {…}<br>&gt;&gt;   func isZ() -&gt; Int? {…}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This would tie into all of the mechanics we have for dealing with optionals, e.g. if/let and ??<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/300fb113/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/411a0fa16436bc975292f7044033a246?s=50"></div><header><strong>Allowing non-binding pattern matching as a Bool expression?</strong> from <string>Alex Lew</string> &lt;alexl.mail+swift at gmail.com&gt;<p>December  9, 2015 at 01:00:00pm</p></header><div class="content"><p>Semantically, I believe enums with more than one associated value are<br>actually just enums with one associated value, of tuple type.<br></p><p>I&#39;m not convinced it would be bad to do magic function generation, but it&#39;s<br>worth considering explicit syntax. If we were to use @ compile-time<br>attributes, maybe it could be a word before the case -- like @projectable<br>or @selectable (or some better name)?<br></p><p>enum List&lt;T&gt; {<br>     @projectable case Empty<br>     indirect case FirstAndRest(T, List&lt;T&gt;)<br>}<br></p><p>generates:<br>myList.isEmpty() -&gt; Bool<br></p><p>Another option: some sort of @reflectable attribute on the enum itself.<br></p><p>@reflectable enum Pet {<br>     case Cat(name: String, color: String)<br>     case Dog(name: String, breed: String)<br>     case Bear(name: String, isHibernating: Bool)<br>}<br></p><p>And one other option, in a very different direction, that seems weird but<br>maybe has its benefits:<br></p><p>What if we exposed an associatedValue computed property of type Any? (It<br>would be unit type for cases with no associated value.)<br></p><p>You could then do something like this:<br></p><p>enum Contact {<br>     case Person(String) // name<br>     case Business(String) // org name<br>     case FamilyMember(String) // relation name<br>     case RecentCall(Int) // a contact from caller id, only store the phone<br>number<br></p><p>     func name() -&gt; String {<br>          return associatedValue as? String ?? &quot;Unknown (\(associatedValue<br>as! Int))&quot;<br>     }<br>}<br></p><p>Essentially, it allows you to project out a relatively common associated<br>value (in this case a string) without much boilerplate. It&#39;s also just one<br>thing for the compiler to generate, instead of *n*. Not crazy about any of<br>these... just brainstorming. It may also be that a concise switch-like<br>control flow expression eliminates the need for this.<br></p><p>-Alex<br></p><p>On Wed, Dec 9, 2015 at 11:49 AM, thorsten at portableinnovations.de &lt;<br>thorsten at portableinnovations.de&gt; wrote:<br></p><p>&gt; I would prefer if no &quot;magic&quot; methods would be generated automatically, but<br>&gt; only when marked with @derivestandardmethods (fill in better name here).<br>&gt;<br>&gt; As to naming I like the proposal #1 by Alex.<br>&gt;<br>&gt; What about enums with more than one associated value?<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt; Am 09.12.2015 um 07:29 schrieb Alex Lew via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt;<br>&gt; Thanks, Chris, for all the time you&#39;re putting into responding to these<br>&gt; proposals (and the kindness with which you&#39;re responding!). I really like<br>&gt; that solution.<br>&gt;<br>&gt; Brainstorming some names for the auto-generated functions:<br>&gt;<br>&gt; 1. If a case has no associated values, isX() -&gt; Bool is generated, where X<br>&gt; is the case name.<br>&gt;     If a case has an associated value of type T, asX() -&gt; T? is generated,<br>&gt; where X is the case name.<br>&gt;     This mirrors is/as? operators, which return Bool / Optional<br>&gt; respectively.<br>&gt; 2. projectX() -&gt; Bool / projectX() -&gt; T?<br>&gt; 3. isX() -&gt; Bool / xValue() -&gt; T?<br>&gt;<br>&gt; Another option (probably the wrong option, but it&#39;s worth putting out<br>&gt; there) is that instead of returning Bool in the no-associated-value case,<br>&gt; we return ()?. This would make me feel better about using the same naming<br>&gt; convention (asX(), projectX(), xValue(), etc.) for each case, and would<br>&gt; allow for != nil checks on all cases. But it would probably be a little<br>&gt; confusing for newcomers to the language.<br>&gt;<br>&gt; One (potentially misguided) question. I noticed in proposal 0002 (on<br>&gt; removing function currying) that there are &quot;plans to move away from the<br>&gt; arguments-are-a-single-tuple model&quot; in the near future. Would this also<br>&gt; affect associated values of enums? That is, might<br>&gt;<br>&gt; case Dog(name: String, age: Int, breed: String)<br>&gt;<br>&gt; one day not have the semantics of a single associated value of type (name:<br>&gt; String, age: Int, breed: String)? Or is the de-ML-ification planned only<br>&gt; for function arguments?<br>&gt;<br>&gt; -Alex<br>&gt;<br>&gt; On Wed, Dec 9, 2015 at 12:45 AM, Chris Lattner &lt;clattner at apple.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; On Dec 7, 2015, at 8:05 PM, Alex Lew via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Hi all,<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Curious to hear thoughts on allowing non-binding pattern matches to be<br>&gt;&gt; used as boolean values outside of an if, guard, for...in, while, switch,<br>&gt;&gt; etc. Something like:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; enum List&lt;T&gt; {<br>&gt;&gt; &gt;      case Empty<br>&gt;&gt; &gt;      indirect case Link(T, List&lt;T&gt;)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;      func isEmpty() -&gt; Bool {<br>&gt;&gt; &gt;           return case .Empty = self<br>&gt;&gt; &gt;      }<br>&gt;&gt; &gt; }<br>&gt;&gt;<br>&gt;&gt; I agree with you that this is a problem that we should solve, but I think<br>&gt;&gt; it could be solved in a different way.  Imagine if:<br>&gt;&gt;<br>&gt;&gt; enum Foo {<br>&gt;&gt;   case X(a : Float), Y, Z(a : Int)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; automatically synthesized these members (the exact names are just a<br>&gt;&gt; strawman proposal, not serious :-)<br>&gt;&gt;<br>&gt;&gt; extension Foo {<br>&gt;&gt;   func isX() -&gt; Float? {…}<br>&gt;&gt;   func isY() -&gt; Bool {…}<br>&gt;&gt;   func isZ() -&gt; Int? {…}<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; This would tie into all of the mechanics we have for dealing with<br>&gt;&gt; optionals, e.g. if/let and ??<br>&gt;&gt;<br>&gt;&gt; -Chris<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; Untracked with Trackbuster &lt;https://trackbuster.com/?sig&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/f4d7a826/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Allowing non-binding pattern matching as a Bool expression?</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>December 10, 2015 at 08:00:00am</p></header><div class="content"><p>I really like this solution and perhaps you can also go<br>@projectable(&quot;empyValue&quot;) if the default name is a bad choice. See @obc for<br>similar usage.<br></p><p>On Thursday, 10 December 2015, Alex Lew via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Semantically, I believe enums with more than one associated value are<br>&gt; actually just enums with one associated value, of tuple type.<br>&gt;<br>&gt; I&#39;m not convinced it would be bad to do magic function generation, but<br>&gt; it&#39;s worth considering explicit syntax. If we were to use @ compile-time<br>&gt; attributes, maybe it could be a word before the case -- like @projectable<br>&gt; or @selectable (or some better name)?<br>&gt;<br>&gt; enum List&lt;T&gt; {<br>&gt;      @projectable case Empty<br>&gt;      indirect case FirstAndRest(T, List&lt;T&gt;)<br>&gt; }<br>&gt;<br>&gt; generates:<br>&gt; myList.isEmpty() -&gt; Bool<br>&gt;<br>&gt; Another option: some sort of @reflectable attribute on the enum itself.<br>&gt;<br>&gt; @reflectable enum Pet {<br>&gt;      case Cat(name: String, color: String)<br>&gt;      case Dog(name: String, breed: String)<br>&gt;      case Bear(name: String, isHibernating: Bool)<br>&gt; }<br>&gt;<br>&gt; And one other option, in a very different direction, that seems weird but<br>&gt; maybe has its benefits:<br>&gt;<br>&gt; What if we exposed an associatedValue computed property of type Any? (It<br>&gt; would be unit type for cases with no associated value.)<br>&gt;<br>&gt; You could then do something like this:<br>&gt;<br>&gt; enum Contact {<br>&gt;      case Person(String) // name<br>&gt;      case Business(String) // org name<br>&gt;      case FamilyMember(String) // relation name<br>&gt;      case RecentCall(Int) // a contact from caller id, only store the<br>&gt; phone number<br>&gt;<br>&gt;      func name() -&gt; String {<br>&gt;           return associatedValue as? String ?? &quot;Unknown (\(associatedValue<br>&gt; as! Int))&quot;<br>&gt;      }<br>&gt; }<br>&gt;<br>&gt; Essentially, it allows you to project out a relatively common associated<br>&gt; value (in this case a string) without much boilerplate. It&#39;s also just one<br>&gt; thing for the compiler to generate, instead of *n*. Not crazy about any<br>&gt; of these... just brainstorming. It may also be that a concise switch-like<br>&gt; control flow expression eliminates the need for this.<br>&gt;<br>&gt; -Alex<br>&gt;<br>&gt; On Wed, Dec 9, 2015 at 11:49 AM, thorsten at portableinnovations.de<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;thorsten at portableinnovations.de&#39;);&gt; &lt;<br>&gt; thorsten at portableinnovations.de<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;thorsten at portableinnovations.de&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt;&gt; I would prefer if no &quot;magic&quot; methods would be generated automatically,<br>&gt;&gt; but only when marked with @derivestandardmethods (fill in better name here).<br>&gt;&gt;<br>&gt;&gt; As to naming I like the proposal #1 by Alex.<br>&gt;&gt;<br>&gt;&gt; What about enums with more than one associated value?<br>&gt;&gt;<br>&gt;&gt; -Thorsten<br>&gt;&gt;<br>&gt;&gt; Am 09.12.2015 um 07:29 schrieb Alex Lew via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt;:<br>&gt;&gt;<br>&gt;&gt; Thanks, Chris, for all the time you&#39;re putting into responding to these<br>&gt;&gt; proposals (and the kindness with which you&#39;re responding!). I really like<br>&gt;&gt; that solution.<br>&gt;&gt;<br>&gt;&gt; Brainstorming some names for the auto-generated functions:<br>&gt;&gt;<br>&gt;&gt; 1. If a case has no associated values, isX() -&gt; Bool is generated, where<br>&gt;&gt; X is the case name.<br>&gt;&gt;     If a case has an associated value of type T, asX() -&gt; T? is<br>&gt;&gt; generated, where X is the case name.<br>&gt;&gt;     This mirrors is/as? operators, which return Bool / Optional<br>&gt;&gt; respectively.<br>&gt;&gt; 2. projectX() -&gt; Bool / projectX() -&gt; T?<br>&gt;&gt; 3. isX() -&gt; Bool / xValue() -&gt; T?<br>&gt;&gt;<br>&gt;&gt; Another option (probably the wrong option, but it&#39;s worth putting out<br>&gt;&gt; there) is that instead of returning Bool in the no-associated-value case,<br>&gt;&gt; we return ()?. This would make me feel better about using the same naming<br>&gt;&gt; convention (asX(), projectX(), xValue(), etc.) for each case, and would<br>&gt;&gt; allow for != nil checks on all cases. But it would probably be a little<br>&gt;&gt; confusing for newcomers to the language.<br>&gt;&gt;<br>&gt;&gt; One (potentially misguided) question. I noticed in proposal 0002 (on<br>&gt;&gt; removing function currying) that there are &quot;plans to move away from the<br>&gt;&gt; arguments-are-a-single-tuple model&quot; in the near future. Would this also<br>&gt;&gt; affect associated values of enums? That is, might<br>&gt;&gt;<br>&gt;&gt; case Dog(name: String, age: Int, breed: String)<br>&gt;&gt;<br>&gt;&gt; one day not have the semantics of a single associated value of type<br>&gt;&gt; (name: String, age: Int, breed: String)? Or is the de-ML-ification planned<br>&gt;&gt; only for function arguments?<br>&gt;&gt;<br>&gt;&gt; -Alex<br>&gt;&gt;<br>&gt;&gt; On Wed, Dec 9, 2015 at 12:45 AM, Chris Lattner &lt;clattner at apple.com<br>&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;clattner at apple.com&#39;);&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; On Dec 7, 2015, at 8:05 PM, Alex Lew via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Hi all,<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Curious to hear thoughts on allowing non-binding pattern matches to be<br>&gt;&gt;&gt; used as boolean values outside of an if, guard, for...in, while, switch,<br>&gt;&gt;&gt; etc. Something like:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; enum List&lt;T&gt; {<br>&gt;&gt;&gt; &gt;      case Empty<br>&gt;&gt;&gt; &gt;      indirect case Link(T, List&lt;T&gt;)<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;      func isEmpty() -&gt; Bool {<br>&gt;&gt;&gt; &gt;           return case .Empty = self<br>&gt;&gt;&gt; &gt;      }<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I agree with you that this is a problem that we should solve, but I<br>&gt;&gt;&gt; think it could be solved in a different way.  Imagine if:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; enum Foo {<br>&gt;&gt;&gt;   case X(a : Float), Y, Z(a : Int)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; automatically synthesized these members (the exact names are just a<br>&gt;&gt;&gt; strawman proposal, not serious :-)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; extension Foo {<br>&gt;&gt;&gt;   func isX() -&gt; Float? {…}<br>&gt;&gt;&gt;   func isY() -&gt; Bool {…}<br>&gt;&gt;&gt;   func isZ() -&gt; Int? {…}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This would tie into all of the mechanics we have for dealing with<br>&gt;&gt;&gt; optionals, e.g. if/let and ??<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -Chris<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; Untracked with Trackbuster &lt;https://trackbuster.com/?sig&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/5b4f3a13/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>Allowing non-binding pattern matching as a Bool expression?</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>December 10, 2015 at 09:00:00am</p></header><div class="content"><p>FWIW, as long as we’re asking for some compiler assistance generating useful enumeration-related boilerplate, I’d like to request that something along these lines be possible in some version of Swift:<br></p><p>@synthesize_case_enum<br>enum Example {<br></p><p>  case Foo(X)<br>  case Bar<br>  case Baz(Y)<br></p><p>}<br></p><p>…which would then by default expand to something like this:<br></p><p>enum ExampleCase : Int {<br>  <br>  case Foo<br>  case Bar<br>  case Baz<br></p><p>}<br></p><p>extension Example {<br> <br>  var enumerationCase: ExampleCase {<br>    get {<br>      switch self {<br>        case .Foo(_): return .Foo<br>        case .Bar(_): return .Bar<br>        case .Baz(_): return .Baz<br>      }<br>    }<br>  }  <br></p><p>}<br></p><p>…in the default case, but with some customization of the synthesized enumeration-case-enum’s details.<br></p><p>For the remaining proposals:<br></p><p>- `isX()` is nice (and should always `-&gt; Bool`, IMHO)<br>- `projectX()` is nice and should:<br>  - *not* be defined for enums w/out associated values<br>  - `-&gt; T?` for enums w/ a single associated value<br>  - -&gt; the full tuple, for enums w/ multiple associated values, e.g.:<br>    - `Foo(A,B)` yields `projectFoo() -&gt; (A,B)?<br>    - `Event(place: Place, time: Time)` -&gt; (place: Place, time: Time)?<br>    - (which is essentially the same as for the single-value case, just making it explicit)<br></p><p>…which has the benefit of predictability (and if you need more convenience, replace your tuples with actual classes-or-structs). <br></p><p>Finally, as convenient as the `associatedValue` proposal is down below, it seems better-served by some sort of generalized delegation construct; at a minimum, I don’t think it&#39;s that uncommon to have N cases all wrapping the same underlying type, and in such cases working with an `Any?` would feel rather clunky.<br></p><p>&gt; On Dec 9, 2015, at 3:00 PM, Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I really like this solution and perhaps you can also go @projectable(&quot;empyValue&quot;) if the default name is a bad choice. See @obc for similar usage.<br>&gt; <br>&gt; On Thursday, 10 December 2015, Alex Lew via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Semantically, I believe enums with more than one associated value are actually just enums with one associated value, of tuple type.<br>&gt; <br>&gt; I&#39;m not convinced it would be bad to do magic function generation, but it&#39;s worth considering explicit syntax. If we were to use @ compile-time attributes, maybe it could be a word before the case -- like @projectable or @selectable (or some better name)?<br>&gt; <br>&gt; enum List&lt;T&gt; {<br>&gt;      @projectable case Empty<br>&gt;      indirect case FirstAndRest(T, List&lt;T&gt;)<br>&gt; }<br>&gt; <br>&gt; generates:<br>&gt; myList.isEmpty() -&gt; Bool<br>&gt; <br>&gt; Another option: some sort of @reflectable attribute on the enum itself.<br>&gt; <br>&gt; @reflectable enum Pet {<br>&gt;      case Cat(name: String, color: String)<br>&gt;      case Dog(name: String, breed: String)<br>&gt;      case Bear(name: String, isHibernating: Bool)<br>&gt; }<br>&gt; <br>&gt; And one other option, in a very different direction, that seems weird but maybe has its benefits:<br>&gt; <br>&gt; What if we exposed an associatedValue computed property of type Any? (It would be unit type for cases with no associated value.)<br>&gt; <br>&gt; You could then do something like this:<br>&gt; <br>&gt; enum Contact {<br>&gt;      case Person(String) // name<br>&gt;      case Business(String) // org name<br>&gt;      case FamilyMember(String) // relation name<br>&gt;      case RecentCall(Int) // a contact from caller id, only store the phone number<br>&gt; <br>&gt;      func name() -&gt; String {<br>&gt;           return associatedValue as? String ?? &quot;Unknown (\(associatedValue as! Int))&quot;<br>&gt;      }<br>&gt; }<br>&gt; <br>&gt; Essentially, it allows you to project out a relatively common associated value (in this case a string) without much boilerplate. It&#39;s also just one thing for the compiler to generate, instead of n. Not crazy about any of these... just brainstorming. It may also be that a concise switch-like control flow expression eliminates the need for this.<br>&gt; <br>&gt; -Alex<br>&gt; <br>&gt; On Wed, Dec 9, 2015 at 11:49 AM, thorsten at portableinnovations.de &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;thorsten at portableinnovations.de&#39;);&gt; &lt;thorsten at portableinnovations.de &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;thorsten at portableinnovations.de&#39;);&gt;&gt; wrote:<br>&gt; I would prefer if no &quot;magic&quot; methods would be generated automatically, but only when marked with @derivestandardmethods (fill in better name here).<br>&gt; <br>&gt; As to naming I like the proposal #1 by Alex.<br>&gt; <br>&gt; What about enums with more than one associated value?<br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; Am 09.12.2015 um 07:29 schrieb Alex Lew via swift-evolution &lt; swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt;: <br>&gt; <br>&gt;&gt; Thanks, Chris, for all the time you&#39;re putting into responding to these proposals (and the kindness with which you&#39;re responding!). I really like that solution.<br>&gt;&gt; <br>&gt;&gt; Brainstorming some names for the auto-generated functions:<br>&gt;&gt; <br>&gt;&gt; 1. If a case has no associated values, isX() -&gt; Bool is generated, where X is the case name.<br>&gt;&gt;     If a case has an associated value of type T, asX() -&gt; T? is generated, where X is the case name.<br>&gt;&gt;     This mirrors is/as? operators, which return Bool / Optional respectively.<br>&gt;&gt; 2. projectX() -&gt; Bool / projectX() -&gt; T?<br>&gt;&gt; 3. isX() -&gt; Bool / xValue() -&gt; T?<br>&gt;&gt; <br>&gt;&gt; Another option (probably the wrong option, but it&#39;s worth putting out there) is that instead of returning Bool in the no-associated-value case, we return ()?. This would make me feel better about using the same naming convention (asX(), projectX(), xValue(), etc.) for each case, and would allow for != nil checks on all cases. But it would probably be a little confusing for newcomers to the language.<br>&gt;&gt; <br>&gt;&gt; One (potentially misguided) question. I noticed in proposal 0002 (on removing function currying) that there are &quot;plans to move away from the arguments-are-a-single-tuple model&quot; in the near future. Would this also affect associated values of enums? That is, might<br>&gt;&gt; <br>&gt;&gt; case Dog(name: String, age: Int, breed: String)<br>&gt;&gt; <br>&gt;&gt; one day not have the semantics of a single associated value of type (name: String, age: Int, breed: String)? Or is the de-ML-ification planned only for function arguments?<br>&gt;&gt; <br>&gt;&gt; -Alex<br>&gt;&gt; <br>&gt;&gt; On Wed, Dec 9, 2015 at 12:45 AM, Chris Lattner &lt;clattner at apple.com &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;clattner at apple.com&#39;);&gt;&gt; wrote: <br>&gt;&gt; <br>&gt;&gt; &gt; On Dec 7, 2015, at 8:05 PM, Alex Lew via swift-evolution &lt;swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Hi all,<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Curious to hear thoughts on allowing non-binding pattern matches to be used as boolean values outside of an if, guard, for...in, while, switch, etc. Something like:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; enum List&lt;T&gt; {<br>&gt;&gt; &gt;      case Empty<br>&gt;&gt; &gt;      indirect case Link(T, List&lt;T&gt;)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;      func isEmpty() -&gt; Bool {<br>&gt;&gt; &gt;           return case .Empty = self<br>&gt;&gt; &gt;      }<br>&gt;&gt; &gt; }<br>&gt;&gt; <br>&gt;&gt; I agree with you that this is a problem that we should solve, but I think it could be solved in a different way.  Imagine if: <br>&gt;&gt; <br>&gt;&gt; enum Foo { <br>&gt;&gt;   case X(a : Float), Y, Z(a : Int) <br>&gt;&gt; } <br>&gt;&gt; <br>&gt;&gt; automatically synthesized these members (the exact names are just a strawman proposal, not serious :-) <br>&gt;&gt; <br>&gt;&gt; extension Foo { <br>&gt;&gt;   func isX() -&gt; Float? {…} <br>&gt;&gt;   func isY() -&gt; Bool {…} <br>&gt;&gt;   func isZ() -&gt; Int? {…} <br>&gt;&gt; } <br>&gt;&gt; <br>&gt;&gt; This would tie into all of the mechanics we have for dealing with optionals, e.g. if/let and ?? <br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt; <br>&gt;&gt; _______________________________________________ <br>&gt;&gt; swift-evolution mailing list <br>&gt;&gt; swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt; <br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt; <br>&gt; Untracked with Trackbuster &lt;https://trackbuster.com/?sig&gt;<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/109c0260/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a59b0df1d55761e4d340da93232790ea?s=50"></div><header><strong>Allowing non-binding pattern matching as a Bool expression?</strong> from <string>Kevin Wooten</string> &lt;kdubb at me.com&gt;<p>December 10, 2015 at 08:00:00am</p></header><div class="content"><p>I get the gist of what you are requesting and I can see it might me useful but given that<br></p><p>if case .Foo(_) == ex {<br>}<br></p><p>Provides comparison, regardless of the # of associated values in .Foo, I’m not sure generating a second enum just to carry a diminished amount of information is worth it.<br></p><p><br>&gt; On Dec 10, 2015, at 8:24 AM, plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; FWIW, as long as we’re asking for some compiler assistance generating useful enumeration-related boilerplate, I’d like to request that something along these lines be possible in some version of Swift:<br>&gt; <br>&gt; @synthesize_case_enum<br>&gt; enum Example {<br>&gt; <br>&gt;   case Foo(X)<br>&gt;   case Bar<br>&gt;   case Baz(Y)<br>&gt; <br>&gt; }<br>&gt; <br>&gt; …which would then by default expand to something like this:<br>&gt; <br>&gt; enum ExampleCase : Int {<br>&gt;   <br>&gt;   case Foo<br>&gt;   case Bar<br>&gt;   case Baz<br>&gt; <br>&gt; }<br>&gt; <br>&gt; extension Example {<br>&gt;  <br>&gt;   var enumerationCase: ExampleCase {<br>&gt;     get {<br>&gt;       switch self {<br>&gt;         case .Foo(_): return .Foo<br>&gt;         case .Bar(_): return .Bar<br>&gt;         case .Baz(_): return .Baz<br>&gt;       }<br>&gt;     }<br>&gt;   }  <br>&gt; <br>&gt; }<br>&gt; <br>&gt; …in the default case, but with some customization of the synthesized enumeration-case-enum’s details.<br>&gt; <br>&gt; For the remaining proposals:<br>&gt; <br>&gt; - `isX()` is nice (and should always `-&gt; Bool`, IMHO)<br>&gt; - `projectX()` is nice and should:<br>&gt;   - *not* be defined for enums w/out associated values<br>&gt;   - `-&gt; T?` for enums w/ a single associated value<br>&gt;   - -&gt; the full tuple, for enums w/ multiple associated values, e.g.:<br>&gt;     - `Foo(A,B)` yields `projectFoo() -&gt; (A,B)?<br>&gt;     - `Event(place: Place, time: Time)` -&gt; (place: Place, time: Time)?<br>&gt;     - (which is essentially the same as for the single-value case, just making it explicit)<br>&gt; <br>&gt; …which has the benefit of predictability (and if you need more convenience, replace your tuples with actual classes-or-structs). <br>&gt; <br>&gt; Finally, as convenient as the `associatedValue` proposal is down below, it seems better-served by some sort of generalized delegation construct; at a minimum, I don’t think it&#39;s that uncommon to have N cases all wrapping the same underlying type, and in such cases working with an `Any?` would feel rather clunky.<br>&gt; <br>&gt;&gt; On Dec 9, 2015, at 3:00 PM, Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I really like this solution and perhaps you can also go @projectable(&quot;empyValue&quot;) if the default name is a bad choice. See @obc for similar usage.<br>&gt;&gt; <br>&gt;&gt; On Thursday, 10 December 2015, Alex Lew via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Semantically, I believe enums with more than one associated value are actually just enums with one associated value, of tuple type.<br>&gt;&gt; <br>&gt;&gt; I&#39;m not convinced it would be bad to do magic function generation, but it&#39;s worth considering explicit syntax. If we were to use @ compile-time attributes, maybe it could be a word before the case -- like @projectable or @selectable (or some better name)?<br>&gt;&gt; <br>&gt;&gt; enum List&lt;T&gt; {<br>&gt;&gt;      @projectable case Empty<br>&gt;&gt;      indirect case FirstAndRest(T, List&lt;T&gt;)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; generates:<br>&gt;&gt; myList.isEmpty() -&gt; Bool<br>&gt;&gt; <br>&gt;&gt; Another option: some sort of @reflectable attribute on the enum itself.<br>&gt;&gt; <br>&gt;&gt; @reflectable enum Pet {<br>&gt;&gt;      case Cat(name: String, color: String)<br>&gt;&gt;      case Dog(name: String, breed: String)<br>&gt;&gt;      case Bear(name: String, isHibernating: Bool)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; And one other option, in a very different direction, that seems weird but maybe has its benefits:<br>&gt;&gt; <br>&gt;&gt; What if we exposed an associatedValue computed property of type Any? (It would be unit type for cases with no associated value.)<br>&gt;&gt; <br>&gt;&gt; You could then do something like this:<br>&gt;&gt; <br>&gt;&gt; enum Contact {<br>&gt;&gt;      case Person(String) // name<br>&gt;&gt;      case Business(String) // org name<br>&gt;&gt;      case FamilyMember(String) // relation name<br>&gt;&gt;      case RecentCall(Int) // a contact from caller id, only store the phone number<br>&gt;&gt; <br>&gt;&gt;      func name() -&gt; String {<br>&gt;&gt;           return associatedValue as? String ?? &quot;Unknown (\(associatedValue as! Int))&quot;<br>&gt;&gt;      }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Essentially, it allows you to project out a relatively common associated value (in this case a string) without much boilerplate. It&#39;s also just one thing for the compiler to generate, instead of n. Not crazy about any of these... just brainstorming. It may also be that a concise switch-like control flow expression eliminates the need for this.<br>&gt;&gt; <br>&gt;&gt; -Alex<br>&gt;&gt; <br>&gt;&gt; On Wed, Dec 9, 2015 at 11:49 AM, thorsten at portableinnovations.de &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;thorsten at portableinnovations.de&#39;);&gt; &lt;thorsten at portableinnovations.de &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;thorsten at portableinnovations.de&#39;);&gt;&gt; wrote:<br>&gt;&gt; I would prefer if no &quot;magic&quot; methods would be generated automatically, but only when marked with @derivestandardmethods (fill in better name here).<br>&gt;&gt; <br>&gt;&gt; As to naming I like the proposal #1 by Alex.<br>&gt;&gt; <br>&gt;&gt; What about enums with more than one associated value?<br>&gt;&gt; <br>&gt;&gt; -Thorsten<br>&gt;&gt; <br>&gt;&gt; Am 09.12.2015 um 07:29 schrieb Alex Lew via swift-evolution &lt; swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt;: <br>&gt;&gt; <br>&gt;&gt;&gt; Thanks, Chris, for all the time you&#39;re putting into responding to these proposals (and the kindness with which you&#39;re responding!). I really like that solution.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Brainstorming some names for the auto-generated functions:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. If a case has no associated values, isX() -&gt; Bool is generated, where X is the case name.<br>&gt;&gt;&gt;     If a case has an associated value of type T, asX() -&gt; T? is generated, where X is the case name.<br>&gt;&gt;&gt;     This mirrors is/as? operators, which return Bool / Optional respectively.<br>&gt;&gt;&gt; 2. projectX() -&gt; Bool / projectX() -&gt; T?<br>&gt;&gt;&gt; 3. isX() -&gt; Bool / xValue() -&gt; T?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another option (probably the wrong option, but it&#39;s worth putting out there) is that instead of returning Bool in the no-associated-value case, we return ()?. This would make me feel better about using the same naming convention (asX(), projectX(), xValue(), etc.) for each case, and would allow for != nil checks on all cases. But it would probably be a little confusing for newcomers to the language.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One (potentially misguided) question. I noticed in proposal 0002 (on removing function currying) that there are &quot;plans to move away from the arguments-are-a-single-tuple model&quot; in the near future. Would this also affect associated values of enums? That is, might<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; case Dog(name: String, age: Int, breed: String)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; one day not have the semantics of a single associated value of type (name: String, age: Int, breed: String)? Or is the de-ML-ification planned only for function arguments?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Alex<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Wed, Dec 9, 2015 at 12:45 AM, Chris Lattner &lt;clattner at apple.com &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;clattner at apple.com&#39;);&gt;&gt; wrote: <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; On Dec 7, 2015, at 8:05 PM, Alex Lew via swift-evolution &lt;swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Hi all,<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Curious to hear thoughts on allowing non-binding pattern matches to be used as boolean values outside of an if, guard, for...in, while, switch, etc. Something like:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; enum List&lt;T&gt; {<br>&gt;&gt;&gt; &gt;      case Empty<br>&gt;&gt;&gt; &gt;      indirect case Link(T, List&lt;T&gt;)<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;      func isEmpty() -&gt; Bool {<br>&gt;&gt;&gt; &gt;           return case .Empty = self<br>&gt;&gt;&gt; &gt;      }<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree with you that this is a problem that we should solve, but I think it could be solved in a different way.  Imagine if: <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum Foo { <br>&gt;&gt;&gt;   case X(a : Float), Y, Z(a : Int) <br>&gt;&gt;&gt; } <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; automatically synthesized these members (the exact names are just a strawman proposal, not serious :-) <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Foo { <br>&gt;&gt;&gt;   func isX() -&gt; Float? {…} <br>&gt;&gt;&gt;   func isY() -&gt; Bool {…} <br>&gt;&gt;&gt;   func isZ() -&gt; Int? {…} <br>&gt;&gt;&gt; } <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This would tie into all of the mechanics we have for dealing with optionals, e.g. if/let and ?? <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________ <br>&gt;&gt;&gt; swift-evolution mailing list <br>&gt;&gt;&gt; swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt; <br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt; <br>&gt;&gt; Untracked with Trackbuster &lt;https://trackbuster.com/?sig&gt;<br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/e8e7ced6/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>Allowing non-binding pattern matching as a Bool expression?</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>December 10, 2015 at 09:00:00am</p></header><div class="content"><p>The motivating/most-common case for me is serialization:<br></p><p>coder.encodeInteger(self.enumerationCase.rawValue, forKey: “case&quot;)<br>switch self {<br>  case let .Foo(data): coder.encodeX(data, forKey: “data”)<br>  case let .Bar(data): coder.encodeY(data, forKey: “data”)<br>}<br></p><p>…etc., and the obvious use of the above when decoding (decode the case, switch on it, decode data).<br></p><p>Once you have it it’s occasionally handy in other contexts, but that’s by far the main motivation.<br></p><p>&gt; On Dec 10, 2015, at 9:35 AM, Kevin Wooten &lt;kdubb at me.com&gt; wrote:<br>&gt; <br>&gt; I get the gist of what you are requesting and I can see it might me useful but given that<br>&gt; <br>&gt; if case .Foo(_) == ex {<br>&gt; }<br>&gt; <br>&gt; Provides comparison, regardless of the # of associated values in .Foo, I’m not sure generating a second enum just to carry a diminished amount of information is worth it.<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 10, 2015, at 8:24 AM, plx via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; FWIW, as long as we’re asking for some compiler assistance generating useful enumeration-related boilerplate, I’d like to request that something along these lines be possible in some version of Swift:<br>&gt;&gt; <br>&gt;&gt; @synthesize_case_enum<br>&gt;&gt; enum Example {<br>&gt;&gt; <br>&gt;&gt;   case Foo(X)<br>&gt;&gt;   case Bar<br>&gt;&gt;   case Baz(Y)<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; …which would then by default expand to something like this:<br>&gt;&gt; <br>&gt;&gt; enum ExampleCase : Int {<br>&gt;&gt;   <br>&gt;&gt;   case Foo<br>&gt;&gt;   case Bar<br>&gt;&gt;   case Baz<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension Example {<br>&gt;&gt;  <br>&gt;&gt;   var enumerationCase: ExampleCase {<br>&gt;&gt;     get {<br>&gt;&gt;       switch self {<br>&gt;&gt;         case .Foo(_): return .Foo<br>&gt;&gt;         case .Bar(_): return .Bar<br>&gt;&gt;         case .Baz(_): return .Baz<br>&gt;&gt;       }<br>&gt;&gt;     }<br>&gt;&gt;   }  <br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; …in the default case, but with some customization of the synthesized enumeration-case-enum’s details.<br>&gt;&gt; <br>&gt;&gt; For the remaining proposals:<br>&gt;&gt; <br>&gt;&gt; - `isX()` is nice (and should always `-&gt; Bool`, IMHO)<br>&gt;&gt; - `projectX()` is nice and should:<br>&gt;&gt;   - *not* be defined for enums w/out associated values<br>&gt;&gt;   - `-&gt; T?` for enums w/ a single associated value<br>&gt;&gt;   - -&gt; the full tuple, for enums w/ multiple associated values, e.g.:<br>&gt;&gt;     - `Foo(A,B)` yields `projectFoo() -&gt; (A,B)?<br>&gt;&gt;     - `Event(place: Place, time: Time)` -&gt; (place: Place, time: Time)?<br>&gt;&gt;     - (which is essentially the same as for the single-value case, just making it explicit)<br>&gt;&gt; <br>&gt;&gt; …which has the benefit of predictability (and if you need more convenience, replace your tuples with actual classes-or-structs). <br>&gt;&gt; <br>&gt;&gt; Finally, as convenient as the `associatedValue` proposal is down below, it seems better-served by some sort of generalized delegation construct; at a minimum, I don’t think it&#39;s that uncommon to have N cases all wrapping the same underlying type, and in such cases working with an `Any?` would feel rather clunky.<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 9, 2015, at 3:00 PM, Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I really like this solution and perhaps you can also go @projectable(&quot;empyValue&quot;) if the default name is a bad choice. See @obc for similar usage.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Thursday, 10 December 2015, Alex Lew via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; Semantically, I believe enums with more than one associated value are actually just enums with one associated value, of tuple type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m not convinced it would be bad to do magic function generation, but it&#39;s worth considering explicit syntax. If we were to use @ compile-time attributes, maybe it could be a word before the case -- like @projectable or @selectable (or some better name)?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum List&lt;T&gt; {<br>&gt;&gt;&gt;      @projectable case Empty<br>&gt;&gt;&gt;      indirect case FirstAndRest(T, List&lt;T&gt;)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; generates:<br>&gt;&gt;&gt; myList.isEmpty() -&gt; Bool<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another option: some sort of @reflectable attribute on the enum itself.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; @reflectable enum Pet {<br>&gt;&gt;&gt;      case Cat(name: String, color: String)<br>&gt;&gt;&gt;      case Dog(name: String, breed: String)<br>&gt;&gt;&gt;      case Bear(name: String, isHibernating: Bool)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And one other option, in a very different direction, that seems weird but maybe has its benefits:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What if we exposed an associatedValue computed property of type Any? (It would be unit type for cases with no associated value.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You could then do something like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum Contact {<br>&gt;&gt;&gt;      case Person(String) // name<br>&gt;&gt;&gt;      case Business(String) // org name<br>&gt;&gt;&gt;      case FamilyMember(String) // relation name<br>&gt;&gt;&gt;      case RecentCall(Int) // a contact from caller id, only store the phone number<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;      func name() -&gt; String {<br>&gt;&gt;&gt;           return associatedValue as? String ?? &quot;Unknown (\(associatedValue as! Int))&quot;<br>&gt;&gt;&gt;      }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Essentially, it allows you to project out a relatively common associated value (in this case a string) without much boilerplate. It&#39;s also just one thing for the compiler to generate, instead of n. Not crazy about any of these... just brainstorming. It may also be that a concise switch-like control flow expression eliminates the need for this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Alex<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Wed, Dec 9, 2015 at 11:49 AM, thorsten at portableinnovations.de &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;thorsten at portableinnovations.de&#39;);&gt; &lt;thorsten at portableinnovations.de &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;thorsten at portableinnovations.de&#39;);&gt;&gt; wrote:<br>&gt;&gt;&gt; I would prefer if no &quot;magic&quot; methods would be generated automatically, but only when marked with @derivestandardmethods (fill in better name here).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As to naming I like the proposal #1 by Alex.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What about enums with more than one associated value?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 09.12.2015 um 07:29 schrieb Alex Lew via swift-evolution &lt; swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt;: <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks, Chris, for all the time you&#39;re putting into responding to these proposals (and the kindness with which you&#39;re responding!). I really like that solution.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Brainstorming some names for the auto-generated functions:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. If a case has no associated values, isX() -&gt; Bool is generated, where X is the case name.<br>&gt;&gt;&gt;&gt;     If a case has an associated value of type T, asX() -&gt; T? is generated, where X is the case name.<br>&gt;&gt;&gt;&gt;     This mirrors is/as? operators, which return Bool / Optional respectively.<br>&gt;&gt;&gt;&gt; 2. projectX() -&gt; Bool / projectX() -&gt; T?<br>&gt;&gt;&gt;&gt; 3. isX() -&gt; Bool / xValue() -&gt; T?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Another option (probably the wrong option, but it&#39;s worth putting out there) is that instead of returning Bool in the no-associated-value case, we return ()?. This would make me feel better about using the same naming convention (asX(), projectX(), xValue(), etc.) for each case, and would allow for != nil checks on all cases. But it would probably be a little confusing for newcomers to the language.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One (potentially misguided) question. I noticed in proposal 0002 (on removing function currying) that there are &quot;plans to move away from the arguments-are-a-single-tuple model&quot; in the near future. Would this also affect associated values of enums? That is, might<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; case Dog(name: String, age: Int, breed: String)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; one day not have the semantics of a single associated value of type (name: String, age: Int, breed: String)? Or is the de-ML-ification planned only for function arguments?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Alex<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Wed, Dec 9, 2015 at 12:45 AM, Chris Lattner &lt;clattner at apple.com &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;clattner at apple.com&#39;);&gt;&gt; wrote: <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt; On Dec 7, 2015, at 8:05 PM, Alex Lew via swift-evolution &lt;swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; Hi all,<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; Curious to hear thoughts on allowing non-binding pattern matches to be used as boolean values outside of an if, guard, for...in, while, switch, etc. Something like:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; enum List&lt;T&gt; {<br>&gt;&gt;&gt;&gt; &gt;      case Empty<br>&gt;&gt;&gt;&gt; &gt;      indirect case Link(T, List&lt;T&gt;)<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;      func isEmpty() -&gt; Bool {<br>&gt;&gt;&gt;&gt; &gt;           return case .Empty = self<br>&gt;&gt;&gt;&gt; &gt;      }<br>&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I agree with you that this is a problem that we should solve, but I think it could be solved in a different way.  Imagine if: <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; enum Foo { <br>&gt;&gt;&gt;&gt;   case X(a : Float), Y, Z(a : Int) <br>&gt;&gt;&gt;&gt; } <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; automatically synthesized these members (the exact names are just a strawman proposal, not serious :-) <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension Foo { <br>&gt;&gt;&gt;&gt;   func isX() -&gt; Float? {…} <br>&gt;&gt;&gt;&gt;   func isY() -&gt; Bool {…} <br>&gt;&gt;&gt;&gt;   func isZ() -&gt; Int? {…} <br>&gt;&gt;&gt;&gt; } <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This would tie into all of the mechanics we have for dealing with optionals, e.g. if/let and ?? <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________ <br>&gt;&gt;&gt;&gt; swift-evolution mailing list <br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt; <br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt; <br>&gt;&gt;&gt; Untracked with Trackbuster &lt;https://trackbuster.com/?sig&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/3c9a7be8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a59b0df1d55761e4d340da93232790ea?s=50"></div><header><strong>Allowing non-binding pattern matching as a Bool expression?</strong> from <string>Kevin Wooten</string> &lt;kdubb at me.com&gt;<p>December 10, 2015 at 08:00:00am</p></header><div class="content"><p>&gt; On Dec 10, 2015, at 8:42 AM, plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The motivating/most-common case for me is serialization:<br>&gt; <br>&gt; coder.encodeInteger(self.enumerationCase.rawValue, forKey: “case&quot;)<br>&gt; switch self {<br>&gt;   case let .Foo(data): coder.encodeX(data, forKey: “data”)<br>&gt;   case let .Bar(data): coder.encodeY(data, forKey: “data”)<br>&gt; }<br>&gt; <br></p><p>Solvable now via…<br></p><p>switch self {<br>  case let .Foo(data):<br>    coder.encodeInteger(…)<br>    coder.encodeX(..)<br>  case let .Bar(data):<br>    coder.encodeInteger(…)<br>    coder.encodeY(…)<br>}<br></p><p>It’s only missing an integer raw value assigned by the compiler.<br></p><p>&gt; …etc., and the obvious use of the above when decoding (decode the case, switch on it, decode data).<br>&gt; <br>&gt; Once you have it it’s occasionally handy in other contexts, but that’s by far the main motivation.<br>&gt; <br>&gt;&gt; On Dec 10, 2015, at 9:35 AM, Kevin Wooten &lt;kdubb at me.com &lt;mailto:kdubb at me.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I get the gist of what you are requesting and I can see it might me useful but given that<br>&gt;&gt; <br>&gt;&gt; if case .Foo(_) == ex {<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Provides comparison, regardless of the # of associated values in .Foo, I’m not sure generating a second enum just to carry a diminished amount of information is worth it.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 10, 2015, at 8:24 AM, plx via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; FWIW, as long as we’re asking for some compiler assistance generating useful enumeration-related boilerplate, I’d like to request that something along these lines be possible in some version of Swift:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; @synthesize_case_enum<br>&gt;&gt;&gt; enum Example {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   case Foo(X)<br>&gt;&gt;&gt;   case Bar<br>&gt;&gt;&gt;   case Baz(Y)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; …which would then by default expand to something like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum ExampleCase : Int {<br>&gt;&gt;&gt;   <br>&gt;&gt;&gt;   case Foo<br>&gt;&gt;&gt;   case Bar<br>&gt;&gt;&gt;   case Baz<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Example {<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;   var enumerationCase: ExampleCase {<br>&gt;&gt;&gt;     get {<br>&gt;&gt;&gt;       switch self {<br>&gt;&gt;&gt;         case .Foo(_): return .Foo<br>&gt;&gt;&gt;         case .Bar(_): return .Bar<br>&gt;&gt;&gt;         case .Baz(_): return .Baz<br>&gt;&gt;&gt;       }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;   }  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; …in the default case, but with some customization of the synthesized enumeration-case-enum’s details.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For the remaining proposals:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - `isX()` is nice (and should always `-&gt; Bool`, IMHO)<br>&gt;&gt;&gt; - `projectX()` is nice and should:<br>&gt;&gt;&gt;   - *not* be defined for enums w/out associated values<br>&gt;&gt;&gt;   - `-&gt; T?` for enums w/ a single associated value<br>&gt;&gt;&gt;   - -&gt; the full tuple, for enums w/ multiple associated values, e.g.:<br>&gt;&gt;&gt;     - `Foo(A,B)` yields `projectFoo() -&gt; (A,B)?<br>&gt;&gt;&gt;     - `Event(place: Place, time: Time)` -&gt; (place: Place, time: Time)?<br>&gt;&gt;&gt;     - (which is essentially the same as for the single-value case, just making it explicit)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; …which has the benefit of predictability (and if you need more convenience, replace your tuples with actual classes-or-structs). <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Finally, as convenient as the `associatedValue` proposal is down below, it seems better-served by some sort of generalized delegation construct; at a minimum, I don’t think it&#39;s that uncommon to have N cases all wrapping the same underlying type, and in such cases working with an `Any?` would feel rather clunky.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 9, 2015, at 3:00 PM, Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I really like this solution and perhaps you can also go @projectable(&quot;empyValue&quot;) if the default name is a bad choice. See @obc for similar usage.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Thursday, 10 December 2015, Alex Lew via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; Semantically, I believe enums with more than one associated value are actually just enums with one associated value, of tuple type.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m not convinced it would be bad to do magic function generation, but it&#39;s worth considering explicit syntax. If we were to use @ compile-time attributes, maybe it could be a word before the case -- like @projectable or @selectable (or some better name)?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; enum List&lt;T&gt; {<br>&gt;&gt;&gt;&gt;      @projectable case Empty<br>&gt;&gt;&gt;&gt;      indirect case FirstAndRest(T, List&lt;T&gt;)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; generates:<br>&gt;&gt;&gt;&gt; myList.isEmpty() -&gt; Bool<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Another option: some sort of @reflectable attribute on the enum itself.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; @reflectable enum Pet {<br>&gt;&gt;&gt;&gt;      case Cat(name: String, color: String)<br>&gt;&gt;&gt;&gt;      case Dog(name: String, breed: String)<br>&gt;&gt;&gt;&gt;      case Bear(name: String, isHibernating: Bool)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And one other option, in a very different direction, that seems weird but maybe has its benefits:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What if we exposed an associatedValue computed property of type Any? (It would be unit type for cases with no associated value.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You could then do something like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; enum Contact {<br>&gt;&gt;&gt;&gt;      case Person(String) // name<br>&gt;&gt;&gt;&gt;      case Business(String) // org name<br>&gt;&gt;&gt;&gt;      case FamilyMember(String) // relation name<br>&gt;&gt;&gt;&gt;      case RecentCall(Int) // a contact from caller id, only store the phone number<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;      func name() -&gt; String {<br>&gt;&gt;&gt;&gt;           return associatedValue as? String ?? &quot;Unknown (\(associatedValue as! Int))&quot;<br>&gt;&gt;&gt;&gt;      }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Essentially, it allows you to project out a relatively common associated value (in this case a string) without much boilerplate. It&#39;s also just one thing for the compiler to generate, instead of n. Not crazy about any of these... just brainstorming. It may also be that a concise switch-like control flow expression eliminates the need for this.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Alex<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Wed, Dec 9, 2015 at 11:49 AM, thorsten at portableinnovations.de &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;thorsten at portableinnovations.de&#39;);&gt; &lt;thorsten at portableinnovations.de &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;thorsten at portableinnovations.de&#39;);&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; I would prefer if no &quot;magic&quot; methods would be generated automatically, but only when marked with @derivestandardmethods (fill in better name here).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As to naming I like the proposal #1 by Alex.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What about enums with more than one associated value?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 09.12.2015 um 07:29 schrieb Alex Lew via swift-evolution &lt; swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt;: <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thanks, Chris, for all the time you&#39;re putting into responding to these proposals (and the kindness with which you&#39;re responding!). I really like that solution.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Brainstorming some names for the auto-generated functions:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1. If a case has no associated values, isX() -&gt; Bool is generated, where X is the case name.<br>&gt;&gt;&gt;&gt;&gt;     If a case has an associated value of type T, asX() -&gt; T? is generated, where X is the case name.<br>&gt;&gt;&gt;&gt;&gt;     This mirrors is/as? operators, which return Bool / Optional respectively.<br>&gt;&gt;&gt;&gt;&gt; 2. projectX() -&gt; Bool / projectX() -&gt; T?<br>&gt;&gt;&gt;&gt;&gt; 3. isX() -&gt; Bool / xValue() -&gt; T?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Another option (probably the wrong option, but it&#39;s worth putting out there) is that instead of returning Bool in the no-associated-value case, we return ()?. This would make me feel better about using the same naming convention (asX(), projectX(), xValue(), etc.) for each case, and would allow for != nil checks on all cases. But it would probably be a little confusing for newcomers to the language.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; One (potentially misguided) question. I noticed in proposal 0002 (on removing function currying) that there are &quot;plans to move away from the arguments-are-a-single-tuple model&quot; in the near future. Would this also affect associated values of enums? That is, might<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; case Dog(name: String, age: Int, breed: String)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; one day not have the semantics of a single associated value of type (name: String, age: Int, breed: String)? Or is the de-ML-ification planned only for function arguments?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Alex<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Wed, Dec 9, 2015 at 12:45 AM, Chris Lattner &lt;clattner at apple.com &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;clattner at apple.com&#39;);&gt;&gt; wrote: <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; On Dec 7, 2015, at 8:05 PM, Alex Lew via swift-evolution &lt;swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Hi all,<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Curious to hear thoughts on allowing non-binding pattern matches to be used as boolean values outside of an if, guard, for...in, while, switch, etc. Something like:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; enum List&lt;T&gt; {<br>&gt;&gt;&gt;&gt;&gt; &gt;      case Empty<br>&gt;&gt;&gt;&gt;&gt; &gt;      indirect case Link(T, List&lt;T&gt;)<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;      func isEmpty() -&gt; Bool {<br>&gt;&gt;&gt;&gt;&gt; &gt;           return case .Empty = self<br>&gt;&gt;&gt;&gt;&gt; &gt;      }<br>&gt;&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I agree with you that this is a problem that we should solve, but I think it could be solved in a different way.  Imagine if: <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; enum Foo { <br>&gt;&gt;&gt;&gt;&gt;   case X(a : Float), Y, Z(a : Int) <br>&gt;&gt;&gt;&gt;&gt; } <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; automatically synthesized these members (the exact names are just a strawman proposal, not serious :-) <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; extension Foo { <br>&gt;&gt;&gt;&gt;&gt;   func isX() -&gt; Float? {…} <br>&gt;&gt;&gt;&gt;&gt;   func isY() -&gt; Bool {…} <br>&gt;&gt;&gt;&gt;&gt;   func isZ() -&gt; Int? {…} <br>&gt;&gt;&gt;&gt;&gt; } <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This would tie into all of the mechanics we have for dealing with optionals, e.g. if/let and ?? <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________ <br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list <br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt; <br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt; <br>&gt;&gt;&gt;&gt; Untracked with Trackbuster &lt;https://trackbuster.com/?sig&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/2e11949d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>Allowing non-binding pattern matching as a Bool expression?</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>December 10, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 10, 2015, at 9:48 AM, Kevin Wooten &lt;kdubb at me.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 10, 2015, at 8:42 AM, plx via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The motivating/most-common case for me is serialization:<br>&gt;&gt; <br>&gt;&gt; coder.encodeInteger(self.enumerationCase.rawValue, forKey: “case&quot;)<br>&gt;&gt; switch self {<br>&gt;&gt;   case let .Foo(data): coder.encodeX(data, forKey: “data”)<br>&gt;&gt;   case let .Bar(data): coder.encodeY(data, forKey: “data”)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt; <br>&gt; Solvable now via…<br>&gt; <br>&gt; switch self {<br>&gt;   case let .Foo(data):<br>&gt;     coder.encodeInteger(…)<br>&gt;     coder.encodeX(..)<br>&gt;   case let .Bar(data):<br>&gt;     coder.encodeInteger(…)<br>&gt;     coder.encodeY(…)<br>&gt; }<br>&gt; <br>&gt; It’s only missing an integer raw value assigned by the compiler.<br></p><p>Well, it’s also missing:<br></p><p>- a compiler-enforced exhaustiveness check here:<br></p><p>guard let enumerationCase = EnumerationCase(rawValue: coder.decodeIntegerForKey(“case”)) else { return nil }<br>switch enumerationCase {<br>  case IntegerForFooCase: …<br>  case IntegerForBazCase: …<br>  // forgot about Bar! and Quux!<br>}<br></p><p>…along with compiler-enforced “no typo/no-duplicate/no-forget” checks here:<br></p><p>// in encode:<br>case let .Foo(data):<br>  coder.encodeInteger(1, ..)<br>  coder.encodeX(…)<br>case let .Bar(data):<br>  coder.encodeInteger(1, ..) // oopsie<br>  coder.encodeY(…)<br>case let .Baz(data):<br>  coder.encodeInteger(3, ..)<br>  coder.encodeZ(…)<br>case let .Quux(data):<br>  // oopsie! if only i didn’t have to repeat myself!<br>  coder.encodeW(…)<br></p><p>// in decode:<br>switch caseInteger {<br>  case 1: // try to decode Bar // oopsie<br>  case 2: // try to decode Foo // oopsie<br>  case 4: // try to decode Baz (//oopsie!)<br>    // oopsie, forgot about Quux<br>}<br></p><p>…and once I’m doing this:<br></p><p>extension Example {<br>  static let SerializationIntegerForFoo: Int = 1<br>  static let SerializationIntegerForBar: Int = 2<br>  // etc.<br></p><p>  var caseSerializationInteger: Int { <br>    get {<br>      switch self {<br>        case .Foo(_): return .SerializationIntegerForFoo // etc.<br>      }<br>    }<br>  }<br>}<br></p><p>…we’re back to the same boilerplate, just written manually and without, e.g., the benefit of exhaustiveness checks in our switch statements.<br></p><p>Outside serialization, the construct has some miscellaneous handiness, e.g.:<br></p><p>enum SomeStateMachineStateData&lt;A,B,C&gt; {<br>  case Initialized<br>  case StateA(A)<br>  case StateB(B)<br>  case StateC(C)<br>  case MixedAB(A,B)<br>}<br></p><p>// ^ *not* obj-c visible<br></p><p>@objc<br>enum SomeStateMachineState : Int {<br>  case Initialized<br>  case StateA<br>  case StateB<br>  case StateC<br>  case MixedAB<br>}<br></p><p>// ^ objc-visible<br></p><p>…(and similar) which makes it easier to, say, have an obj-c delegate protocol `SomeStateMachineDelegate` that can “follow along” with the associated state machine’s transitions.<br></p><p>Anyways, this isn’t a request that would make previously-unsolvable problems solvable, it’s merely a request for some compiler assistance reducing certain types of boilerplate, offered up in a discussion of other possible enumeration-related boilerplate reduction (isX(), projectX(), etc.).<br></p><p>On an importance scale from 1-10 it’s maybe a 3 for me personally, but I’d hate to see e.g. synthesis of `isX()` make it into the language without having at least seen if anyone else is interested on this one as well.<br></p><p>&gt; <br>&gt;&gt; …etc., and the obvious use of the above when decoding (decode the case, switch on it, decode data).<br>&gt;&gt; <br>&gt;&gt; Once you have it it’s occasionally handy in other contexts, but that’s by far the main motivation.<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 10, 2015, at 9:35 AM, Kevin Wooten &lt;kdubb at me.com &lt;mailto:kdubb at me.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I get the gist of what you are requesting and I can see it might me useful but given that<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; if case .Foo(_) == ex {<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Provides comparison, regardless of the # of associated values in .Foo, I’m not sure generating a second enum just to carry a diminished amount of information is worth it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 10, 2015, at 8:24 AM, plx via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; FWIW, as long as we’re asking for some compiler assistance generating useful enumeration-related boilerplate, I’d like to request that something along these lines be possible in some version of Swift:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; @synthesize_case_enum<br>&gt;&gt;&gt;&gt; enum Example {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   case Foo(X)<br>&gt;&gt;&gt;&gt;   case Bar<br>&gt;&gt;&gt;&gt;   case Baz(Y)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; …which would then by default expand to something like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; enum ExampleCase : Int {<br>&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;   case Foo<br>&gt;&gt;&gt;&gt;   case Bar<br>&gt;&gt;&gt;&gt;   case Baz<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension Example {<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;   var enumerationCase: ExampleCase {<br>&gt;&gt;&gt;&gt;     get {<br>&gt;&gt;&gt;&gt;       switch self {<br>&gt;&gt;&gt;&gt;         case .Foo(_): return .Foo<br>&gt;&gt;&gt;&gt;         case .Bar(_): return .Bar<br>&gt;&gt;&gt;&gt;         case .Baz(_): return .Baz<br>&gt;&gt;&gt;&gt;       }<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;   }  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; …in the default case, but with some customization of the synthesized enumeration-case-enum’s details.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For the remaining proposals:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - `isX()` is nice (and should always `-&gt; Bool`, IMHO)<br>&gt;&gt;&gt;&gt; - `projectX()` is nice and should:<br>&gt;&gt;&gt;&gt;   - *not* be defined for enums w/out associated values<br>&gt;&gt;&gt;&gt;   - `-&gt; T?` for enums w/ a single associated value<br>&gt;&gt;&gt;&gt;   - -&gt; the full tuple, for enums w/ multiple associated values, e.g.:<br>&gt;&gt;&gt;&gt;     - `Foo(A,B)` yields `projectFoo() -&gt; (A,B)?<br>&gt;&gt;&gt;&gt;     - `Event(place: Place, time: Time)` -&gt; (place: Place, time: Time)?<br>&gt;&gt;&gt;&gt;     - (which is essentially the same as for the single-value case, just making it explicit)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; …which has the benefit of predictability (and if you need more convenience, replace your tuples with actual classes-or-structs). <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Finally, as convenient as the `associatedValue` proposal is down below, it seems better-served by some sort of generalized delegation construct; at a minimum, I don’t think it&#39;s that uncommon to have N cases all wrapping the same underlying type, and in such cases working with an `Any?` would feel rather clunky.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 9, 2015, at 3:00 PM, Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I really like this solution and perhaps you can also go @projectable(&quot;empyValue&quot;) if the default name is a bad choice. See @obc for similar usage.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Thursday, 10 December 2015, Alex Lew via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; Semantically, I believe enums with more than one associated value are actually just enums with one associated value, of tuple type.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;m not convinced it would be bad to do magic function generation, but it&#39;s worth considering explicit syntax. If we were to use @ compile-time attributes, maybe it could be a word before the case -- like @projectable or @selectable (or some better name)?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; enum List&lt;T&gt; {<br>&gt;&gt;&gt;&gt;&gt;      @projectable case Empty<br>&gt;&gt;&gt;&gt;&gt;      indirect case FirstAndRest(T, List&lt;T&gt;)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; generates:<br>&gt;&gt;&gt;&gt;&gt; myList.isEmpty() -&gt; Bool<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Another option: some sort of @reflectable attribute on the enum itself.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; @reflectable enum Pet {<br>&gt;&gt;&gt;&gt;&gt;      case Cat(name: String, color: String)<br>&gt;&gt;&gt;&gt;&gt;      case Dog(name: String, breed: String)<br>&gt;&gt;&gt;&gt;&gt;      case Bear(name: String, isHibernating: Bool)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; And one other option, in a very different direction, that seems weird but maybe has its benefits:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; What if we exposed an associatedValue computed property of type Any? (It would be unit type for cases with no associated value.)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; You could then do something like this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; enum Contact {<br>&gt;&gt;&gt;&gt;&gt;      case Person(String) // name<br>&gt;&gt;&gt;&gt;&gt;      case Business(String) // org name<br>&gt;&gt;&gt;&gt;&gt;      case FamilyMember(String) // relation name<br>&gt;&gt;&gt;&gt;&gt;      case RecentCall(Int) // a contact from caller id, only store the phone number<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;      func name() -&gt; String {<br>&gt;&gt;&gt;&gt;&gt;           return associatedValue as? String ?? &quot;Unknown (\(associatedValue as! Int))&quot;<br>&gt;&gt;&gt;&gt;&gt;      }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Essentially, it allows you to project out a relatively common associated value (in this case a string) without much boilerplate. It&#39;s also just one thing for the compiler to generate, instead of n. Not crazy about any of these... just brainstorming. It may also be that a concise switch-like control flow expression eliminates the need for this.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Alex<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Wed, Dec 9, 2015 at 11:49 AM, thorsten at portableinnovations.de &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;thorsten at portableinnovations.de&#39;);&gt; &lt;thorsten at portableinnovations.de &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;thorsten at portableinnovations.de&#39;);&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; I would prefer if no &quot;magic&quot; methods would be generated automatically, but only when marked with @derivestandardmethods (fill in better name here).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; As to naming I like the proposal #1 by Alex.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; What about enums with more than one associated value?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 09.12.2015 um 07:29 schrieb Alex Lew via swift-evolution &lt; swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt;: <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Thanks, Chris, for all the time you&#39;re putting into responding to these proposals (and the kindness with which you&#39;re responding!). I really like that solution.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Brainstorming some names for the auto-generated functions:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 1. If a case has no associated values, isX() -&gt; Bool is generated, where X is the case name.<br>&gt;&gt;&gt;&gt;&gt;&gt;     If a case has an associated value of type T, asX() -&gt; T? is generated, where X is the case name.<br>&gt;&gt;&gt;&gt;&gt;&gt;     This mirrors is/as? operators, which return Bool / Optional respectively.<br>&gt;&gt;&gt;&gt;&gt;&gt; 2. projectX() -&gt; Bool / projectX() -&gt; T?<br>&gt;&gt;&gt;&gt;&gt;&gt; 3. isX() -&gt; Bool / xValue() -&gt; T?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Another option (probably the wrong option, but it&#39;s worth putting out there) is that instead of returning Bool in the no-associated-value case, we return ()?. This would make me feel better about using the same naming convention (asX(), projectX(), xValue(), etc.) for each case, and would allow for != nil checks on all cases. But it would probably be a little confusing for newcomers to the language.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; One (potentially misguided) question. I noticed in proposal 0002 (on removing function currying) that there are &quot;plans to move away from the arguments-are-a-single-tuple model&quot; in the near future. Would this also affect associated values of enums? That is, might<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; case Dog(name: String, age: Int, breed: String)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; one day not have the semantics of a single associated value of type (name: String, age: Int, breed: String)? Or is the de-ML-ification planned only for function arguments?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Alex<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Dec 9, 2015 at 12:45 AM, Chris Lattner &lt;clattner at apple.com &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;clattner at apple.com&#39;);&gt;&gt; wrote: <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; On Dec 7, 2015, at 8:05 PM, Alex Lew via swift-evolution &lt;swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Hi all,<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Curious to hear thoughts on allowing non-binding pattern matches to be used as boolean values outside of an if, guard, for...in, while, switch, etc. Something like:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; enum List&lt;T&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;      case Empty<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;      indirect case Link(T, List&lt;T&gt;)<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;      func isEmpty() -&gt; Bool {<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;           return case .Empty = self<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;      }<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I agree with you that this is a problem that we should solve, but I think it could be solved in a different way.  Imagine if: <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; enum Foo { <br>&gt;&gt;&gt;&gt;&gt;&gt;   case X(a : Float), Y, Z(a : Int) <br>&gt;&gt;&gt;&gt;&gt;&gt; } <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; automatically synthesized these members (the exact names are just a strawman proposal, not serious :-) <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; extension Foo { <br>&gt;&gt;&gt;&gt;&gt;&gt;   func isX() -&gt; Float? {…} <br>&gt;&gt;&gt;&gt;&gt;&gt;   func isY() -&gt; Bool {…} <br>&gt;&gt;&gt;&gt;&gt;&gt;   func isZ() -&gt; Int? {…} <br>&gt;&gt;&gt;&gt;&gt;&gt; } <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This would tie into all of the mechanics we have for dealing with optionals, e.g. if/let and ?? <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ <br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list <br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt; <br>&gt;&gt;&gt;&gt;&gt; Untracked with Trackbuster &lt;https://trackbuster.com/?sig&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/e1588275/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Allowing non-binding pattern matching as a Bool expression?</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 10, 2015 at 09:00:00pm</p></header><div class="content"><p>&gt; On Dec 9, 2015, at 8:49 AM, thorsten at portableinnovations.de wrote:<br>&gt; <br>&gt; I would prefer if no &quot;magic&quot; methods would be generated automatically, but only when marked with @derivestandardmethods (fill in better name here).<br></p><p>Yes, making it opt-in could make sense.<br></p><p>&gt; What about enums with more than one associated value?<br></p><p>It would return an optional tuple of the associated values, the tuple corresponds to the case parameter list.<br></p><p>-Chris<br></p><p><br></p><p>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; Am 09.12.2015 um 07:29 schrieb Alex Lew via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; <br>&gt;&gt; Thanks, Chris, for all the time you&#39;re putting into responding to these proposals (and the kindness with which you&#39;re responding!). I really like that solution.<br>&gt;&gt; <br>&gt;&gt; Brainstorming some names for the auto-generated functions:<br>&gt;&gt; <br>&gt;&gt; 1. If a case has no associated values, isX() -&gt; Bool is generated, where X is the case name.<br>&gt;&gt;     If a case has an associated value of type T, asX() -&gt; T? is generated, where X is the case name.<br>&gt;&gt;     This mirrors is/as? operators, which return Bool / Optional respectively.<br>&gt;&gt; 2. projectX() -&gt; Bool / projectX() -&gt; T?<br>&gt;&gt; 3. isX() -&gt; Bool / xValue() -&gt; T?<br>&gt;&gt; <br>&gt;&gt; Another option (probably the wrong option, but it&#39;s worth putting out there) is that instead of returning Bool in the no-associated-value case, we return ()?. This would make me feel better about using the same naming convention (asX(), projectX(), xValue(), etc.) for each case, and would allow for != nil checks on all cases. But it would probably be a little confusing for newcomers to the language.<br>&gt;&gt; <br>&gt;&gt; One (potentially misguided) question. I noticed in proposal 0002 (on removing function currying) that there are &quot;plans to move away from the arguments-are-a-single-tuple model&quot; in the near future. Would this also affect associated values of enums? That is, might<br>&gt;&gt; <br>&gt;&gt; case Dog(name: String, age: Int, breed: String)<br>&gt;&gt; <br>&gt;&gt; one day not have the semantics of a single associated value of type (name: String, age: Int, breed: String)? Or is the de-ML-ification planned only for function arguments?<br>&gt;&gt; <br>&gt;&gt; -Alex<br>&gt;&gt; <br>&gt;&gt; On Wed, Dec 9, 2015 at 12:45 AM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt; On Dec 7, 2015, at 8:05 PM, Alex Lew via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Hi all,<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Curious to hear thoughts on allowing non-binding pattern matches to be used as boolean values outside of an if, guard, for...in, while, switch, etc. Something like:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; enum List&lt;T&gt; {<br>&gt;&gt; &gt;      case Empty<br>&gt;&gt; &gt;      indirect case Link(T, List&lt;T&gt;)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;      func isEmpty() -&gt; Bool {<br>&gt;&gt; &gt;           return case .Empty = self<br>&gt;&gt; &gt;      }<br>&gt;&gt; &gt; }<br>&gt;&gt; <br>&gt;&gt; I agree with you that this is a problem that we should solve, but I think it could be solved in a different way.  Imagine if:<br>&gt;&gt; <br>&gt;&gt; enum Foo {<br>&gt;&gt;   case X(a : Float), Y, Z(a : Int)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; automatically synthesized these members (the exact names are just a strawman proposal, not serious :-)<br>&gt;&gt; <br>&gt;&gt; extension Foo {<br>&gt;&gt;   func isX() -&gt; Float? {…}<br>&gt;&gt;   func isY() -&gt; Bool {…}<br>&gt;&gt;   func isZ() -&gt; Int? {…}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This would tie into all of the mechanics we have for dealing with optionals, e.g. if/let and ??<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/f8c36536/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Allowing non-binding pattern matching as a Bool expression?</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 10, 2015 at 09:00:00pm</p></header><div class="content"><p>On Dec 8, 2015, at 10:29 PM, Alex Lew &lt;alexl.mail+swift at gmail.com&gt; wrote:<br>&gt; Thanks, Chris, for all the time you&#39;re putting into responding to these proposals (and the kindness with which you&#39;re responding!). I really like that solution.<br></p><p>Happy to help.<br></p><p>&gt; Brainstorming some names for the auto-generated functions:<br>&gt; <br>&gt; 1. If a case has no associated values, isX() -&gt; Bool is generated, where X is the case name.<br>&gt;     If a case has an associated value of type T, asX() -&gt; T? is generated, where X is the case name.<br>&gt;     This mirrors is/as? operators, which return Bool / Optional respectively.<br>&gt; 2. projectX() -&gt; Bool / projectX() -&gt; T?<br>&gt; 3. isX() -&gt; Bool / xValue() -&gt; T?<br></p><p>MHO, I like #1 with isX/asX - good idea.<br></p><p>&gt; Another option (probably the wrong option, but it&#39;s worth putting out there) is that instead of returning Bool in the no-associated-value case, we return ()?. This would make me feel better about using the same naming convention (asX(), projectX(), xValue(), etc.) for each case, and would allow for != nil checks on all cases. But it would probably be a little confusing for newcomers to the language.<br></p><p>I can see that argument, but I think it would both be surprising/weird but would also be less useful.  You’d have to do things like:<br>	if myEnum.asX() != nil {<br>instead of:<br>	if myEnum.isX() {<br></p><p>Similarly, the ??, if let, and other mechanics that work with optionals wouldn’t be helpful here, since you’d never want to bind the void value.<br></p><p>&gt; One (potentially misguided) question. I noticed in proposal 0002 (on removing function currying) that there are &quot;plans to move away from the arguments-are-a-single-tuple model&quot; in the near future. Would this also affect associated values of enums? That is, might<br>&gt; <br>&gt; case Dog(name: String, age: Int, breed: String)<br>&gt; <br>&gt; one day not have the semantics of a single associated value of type (name: String, age: Int, breed: String)? Or is the de-ML-ification planned only for function arguments?<br></p><p>No, enum cases should retain their argument lists.  It is not related.<br></p><p>-Chris<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
