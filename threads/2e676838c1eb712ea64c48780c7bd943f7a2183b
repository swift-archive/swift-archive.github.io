<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e01e37acbfad671da1b94a61cf819d82?s=50"></div><header><strong>[Pitch] Make NSNotification names a protocol like ErrorProtocol</strong> from <string>Kenny Leung</string> &lt;kenny_leung at pobox.com&gt;<p>June 29, 2016 at 04:00:00pm</p></header><div class="content"><p>Hi All.<br></p><p>While converting to Swift3, my biggest hurdle was figuring out what to do with a custom NSNotification. In Objective-C, it’s a plain NSString, and the same in Swift2.<br></p><p>I assumed in Swift3 that it worked like ErrorProtocol and errors as enums, but as it turns out, you need to create a custom instance of Notification.Name(“MyNotificationName”). This does not seem very Swifty, and I think it would work better if there was a NotificationNameProtocol and you could create enums with String raw values.<br></p><p>Magically, a string seems to compile in one area of the API, but not another:<br></p><p>// This compiles with either a string or instance of Notification.Name for name:<br>        NotificationCenter.default().addObserver(self, selector: #selector(Self._contextDidSave(notification:)), name: &quot;blah&quot;, object: managedObjectContext)<br></p><p>// This will only compile with an instance of Notification.Name:<br>                NotificationCenter.default().post(name: SomeNotificationObject, object: self)<br></p><p>-Kenny<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Pitch] Make NSNotification names a protocol like ErrorProtocol</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June 29, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; While converting to Swift3, my biggest hurdle was figuring out what to do with a custom NSNotification. In Objective-C, it’s a plain NSString, and the same in Swift2.<br>&gt; <br>&gt; I assumed in Swift3 that it worked like ErrorProtocol and errors as enums, but as it turns out, you need to create a custom instance of Notification.Name(“MyNotificationName”). This does not seem very Swifty, and I think it would work better if there was a NotificationNameProtocol and you could create enums with String raw values.<br></p><p>The migrator constructs the Notification.Name instances at the call site, but I believe the *actual* intent is that you should assign them to a constant—either one in your own type:<br></p><p>	// Old<br>	let MyClassWillFooNotificationName = &quot;MyClassWillFoo&quot;<br>	// New:<br>	class MyClass: … {<br>		static let WillFoo = Notification.Name(&quot;MyClass.WillFoo&quot;)<br>	}<br></p><p>Or in an extension to `Notification.Name` itself.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e01e37acbfad671da1b94a61cf819d82?s=50"></div><header><strong>[Pitch] Make NSNotification names a protocol like ErrorProtocol</strong> from <string>Kenny Leung</string> &lt;kenny_leung at pobox.com&gt;<p>June 29, 2016 at 06:00:00pm</p></header><div class="content"><p>Yes, this is the solution that I’m using, but:<br></p><p>1. I think following the pattern of ErrorProtocol would be better<br></p><p>2. It doesn’t explain why I can use String in one instance and not the other when they are both typed the same:<br></p><p>// Can use String or Notification.Name<br>    @nonobjc final public func addObserver(_ observer: AnyObject, selector aSelector: Selector, name aName: Name, object anObject: AnyObject?)<br>// Can only use Notification.Name<br>    public func post(name aName: NSNotification.Name, object anObject: AnyObject?)<br></p><p>-Kenny<br></p><p><br>&gt; On Jun 29, 2016, at 5:11 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; While converting to Swift3, my biggest hurdle was figuring out what to do with a custom NSNotification. In Objective-C, it’s a plain NSString, and the same in Swift2.<br>&gt;&gt; <br>&gt;&gt; I assumed in Swift3 that it worked like ErrorProtocol and errors as enums, but as it turns out, you need to create a custom instance of Notification.Name(“MyNotificationName”). This does not seem very Swifty, and I think it would work better if there was a NotificationNameProtocol and you could create enums with String raw values.<br>&gt; <br>&gt; The migrator constructs the Notification.Name instances at the call site, but I believe the *actual* intent is that you should assign them to a constant—either one in your own type:<br>&gt; <br>&gt; 	// Old<br>&gt; 	let MyClassWillFooNotificationName = &quot;MyClassWillFoo&quot;<br>&gt; 	// New:<br>&gt; 	class MyClass: … {<br>&gt; 		static let WillFoo = Notification.Name(&quot;MyClass.WillFoo&quot;)<br>&gt; 	}<br>&gt; <br>&gt; Or in an extension to `Notification.Name` itself.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Pitch] Make NSNotification names a protocol like ErrorProtocol</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June 29, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 6:07 PM, Kenny Leung via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; 1. I think following the pattern of ErrorProtocol would be better<br></p><p>I don&#39;t think so. ErrorProtocol bridging uses the `domain` to figure out which concrete ErrorProtocol type to use, but NSNotification names are just plain strings with no internal structure, so it wouldn&#39;t be possible to bridge them back in the same way. Nor do you typically receive a bunch of unrelated notifications in one place and then have to sort them out into broad buckets in the same way—usually NotificationCenter handles all the testing for you. The resemblance between error enums and notification name constants is superficial.<br></p><p>&gt; 2. It doesn’t explain why I can use String in one instance and not the other when they are both typed the same:<br>&gt; <br>&gt; // Can use String or Notification.Name<br>&gt;    @nonobjc final public func addObserver(_ observer: AnyObject, selector aSelector: Selector, name aName: Name, object anObject: AnyObject?)<br>&gt; // Can only use Notification.Name<br>&gt;    public func post(name aName: NSNotification.Name, object anObject: AnyObject?)<br></p><p>The generated headers show two overloads:<br></p><p>    public func addObserver(_ observer: AnyObject, selector aSelector: Selector, name aName: String?, object anObject: AnyObject?)<br>    @nonobjc final <br>    public func addObserver(_ observer: AnyObject, selector aSelector: Selector, name aName: Name, object anObject: AnyObject?)<br></p><p>This looks like a bug to me—there ought to be one method which takes an optional Name, with the String variant hidden using the NS_REFINED_FOR_SWIFT macro. I&#39;d file a radar if I were you.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Pitch] Make NSNotification names a protocol like ErrorProtocol</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>June 29, 2016 at 08:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>On Jun 29, 2016, at 6:51 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On Jun 29, 2016, at 6:07 PM, Kenny Leung via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; 1. I think following the pattern of ErrorProtocol would be better<br>&gt; <br>&gt; I don&#39;t think so. ErrorProtocol bridging uses the `domain` to figure out which concrete ErrorProtocol type to use, but NSNotification names are just plain strings with no internal structure, so it wouldn&#39;t be possible to bridge them back in the same way. Nor do you typically receive a bunch of unrelated notifications in one place and then have to sort them out into broad buckets in the same way—usually NotificationCenter handles all the testing for you. The resemblance between error enums and notification name constants is superficial.<br></p><p>Right. ErrorProtocol is deeply ties with the Swift error-handling model and its interoperability with Objective-C. <br></p><p>&gt; <br>&gt;&gt; 2. It doesn’t explain why I can use String in one instance and not the other when they are both typed the same:<br>&gt;&gt; <br>&gt;&gt; // Can use String or Notification.Name<br>&gt;&gt;   @nonobjc final public func addObserver(_ observer: AnyObject, selector aSelector: Selector, name aName: Name, object anObject: AnyObject?)<br>&gt;&gt; // Can only use Notification.Name<br>&gt;&gt;   public func post(name aName: NSNotification.Name, object anObject: AnyObject?)<br>&gt; <br>&gt; The generated headers show two overloads:<br>&gt; <br>&gt;    public func addObserver(_ observer: AnyObject, selector aSelector: Selector, name aName: String?, object anObject: AnyObject?)<br>&gt;    @nonobjc final <br>&gt;    public func addObserver(_ observer: AnyObject, selector aSelector: Selector, name aName: Name, object anObject: AnyObject?)<br>&gt; <br>&gt; This looks like a bug to me—there ought to be one method which takes an optional Name, with the String variant hidden using the NS_REFINED_FOR_SWIFT macro. I&#39;d file a radar if I were you.<br></p><p>This was an artifact of of an elaborate Foundation/Swift dance that didn&#39;t reach its conclusion for the first preview. It&#39;ll be fixed (with the string version going away and the other&#39;s name becoming optional).<br></p><p>  - Doug<br></p><p><br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
