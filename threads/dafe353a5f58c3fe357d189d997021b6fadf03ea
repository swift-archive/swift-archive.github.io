<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[DRAFT] Enhancing the Platform Configuration Test Suite for Conditional Compilation Blocks</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>June 16, 2016 at 10:00:00am</p></header><div class="content"><p>This is an omnibus conditional compilation block proposal. It is built out of Swift Evolution community requests and discussions dating back on various threads to the genesis of the list. <br></p><p>This draft does not include tests for debug conditions. That was pitched under separate cover using runtime functions instead of conditional compilation blocks.<br>This draft does not include tests for OS versions, as that seems to be better addressed using the existing availability tests.<br>This draft is rewritten with respect to Jordan Rose&#39;s &quot;Rename &quot;build configurations&quot; to &quot;conditional compilation blocks&quot;&quot; swift commit &lt;https://github.com/apple/swift/commit/6272941c5cba9581a5ee93d92a6ee66e28c1bf13&gt; from 12 February (rdar://problem/19812930 &lt;rdar://problem/19812930&gt;). <br>It is offered as an omnibus because all the tests fall under the same &quot;conditional compilation block&quot; umbrella. Using an omnibus reduces list traffic and demands on core team resources. It&#39;s understood that the proposal is likely to be accepted with modifications (or rejected as a whole) due to the multiple tests. <br></p><p>-- Erica<br></p><p>gist: https://gist.github.com/erica/c9c11b540a2439696b2f514c2ffc6298 &lt;https://gist.github.com/erica/c9c11b540a2439696b2f514c2ffc6298&gt;<br></p><p>Enhancing the Platform Configuration Test Suite for Conditional Compilation Blocks<br></p><p>Proposal: TBD<br>Author: Erica Sadun &lt;http://github.com/erica&gt;<br>Status: TBD<br>Review manager: TBD<br> &lt;https://gist.github.com/erica/c9c11b540a2439696b2f514c2ffc6298#introduction&gt;Introduction<br></p><p>This proposal introduces additional configuration tests to differentiate platform conditions in conditional compilation blocks.<br></p><p>This proposal was first discussed on-list in the [Draft] Introducing Build Configuration Tests for Platform Conditions &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/12140/focus=12267&gt; thread and then re-pitched in TBD &lt;https://gist.github.com/erica/TBD&gt;.<br></p><p> &lt;https://gist.github.com/erica/c9c11b540a2439696b2f514c2ffc6298#note&gt;Note<br></p><p>The term &quot;build configuration&quot; is subsumed by &quot;conditional compilation block&quot;. See this accepted patch &lt;https://github.com/apple/swift/commit/6272941c5cba9581a5ee93d92a6ee66e28c1bf13&gt;<br> &lt;https://gist.github.com/erica/c9c11b540a2439696b2f514c2ffc6298#motivation&gt;Motivation<br></p><p>Testing for platform conditions is a typical developer task. Although some built-in features like CFByteOrderGetCurrentexist, it seems a natural match for Swift to introduce conditional compilation blocks specific to common platform conditions.<br></p><p> &lt;https://gist.github.com/erica/c9c11b540a2439696b2f514c2ffc6298#current-art&gt;Current Art<br></p><p>Swift currently supports the following platform configuration tests, defined in lib/Basic/LangOptions.cpp.<br></p><p>The literals true and false<br>The os() function that tests for OSX, iOS, watchOS, tvOS, Linux, Windows, Android, and FreeBSD<br>The arch() function that tests for x86_64, arm, arm64, i386, powerpc64, s390x, and powerpc64le<br>The swift() function that tests for specific Swift language releases, e.g. swift(&gt;=2.2)<br>The following platform configuration test has been accepted in SE-0075 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0075-import-test.md&gt; but not yet implemented:<br></p><p>The canImport() function that tests whether specific modules can be imported.<br> &lt;https://gist.github.com/erica/c9c11b540a2439696b2f514c2ffc6298#detailed-design&gt;Detailed Design<br></p><p>This proposal introduces several platform condition tests for use in conditional compilation blocks: endianness, bitwidth, vendor, objc interop, and simulator.<br></p><p> &lt;https://gist.github.com/erica/c9c11b540a2439696b2f514c2ffc6298#endianness&gt;Endianness<br></p><p>Endianness refers to the byte order used in memory. This proposal exposes endian test conditions, promoting them from private underscored names to public developer-referencable ones.<br></p><p>// Set the &quot;_endian&quot; platform condition.<br>  switch (Target.getArch()) {<br>  case llvm::Triple::ArchType::arm:<br>  case llvm::Triple::ArchType::thumb:<br>    addPlatformConditionValue(&quot;_endian&quot;, &quot;little&quot;);<br>    break;<br>  case llvm::Triple::ArchType::aarch64:<br>    addPlatformConditionValue(&quot;_endian&quot;, &quot;little&quot;);<br>    break;<br>  case llvm::Triple::ArchType::ppc64:<br>    addPlatformConditionValue(&quot;_endian&quot;, &quot;big&quot;);<br>    break;<br>  case llvm::Triple::ArchType::ppc64le:<br>    addPlatformConditionValue(&quot;_endian&quot;, &quot;little&quot;);<br>    break;<br>  case llvm::Triple::ArchType::x86:<br>    addPlatformConditionValue(&quot;_endian&quot;, &quot;little&quot;);<br>    break;<br>  case llvm::Triple::ArchType::x86_64:<br>    addPlatformConditionValue(&quot;_endian&quot;, &quot;little&quot;);<br>    break;<br>  case llvm::Triple::ArchType::systemz:<br>    addPlatformConditionValue(&quot;_endian&quot;, &quot;big&quot;);<br>    break;<br>  default:<br>    llvm_unreachable(&quot;undefined architecture endianness&quot;);<br>Under this proposal _endian is renamed to endian and made a public API.<br></p><p>Use:<br></p><p>#if endian(big) <br>    // Big endian code<br>#endif<br> &lt;https://gist.github.com/erica/c9c11b540a2439696b2f514c2ffc6298#bitwidth&gt;Bitwidth<br></p><p>Bitwidth describes the number of bits used to represent a number. This proposal introduces a bitwidth test with two options: 32 and 64. <br></p><p>Use:<br></p><p>#if bitwidth(64) <br>    // 64-bit code<br>#endif<br>List members briefly discussed whether it was better to measure pointer width or the size of Int. William Dillon suggested renaming bitwidth to either intwidth or intsize. Brent Royal-Gordon suggests intbits. Alternatives include bitsand bitsize. This proposal avoids wordbits because of the way, for example, Intel ends up doing “dword”, “qword”, and so forth for backwards compatibility.<br></p><p> &lt;https://gist.github.com/erica/c9c11b540a2439696b2f514c2ffc6298#vendor&gt;Vendor<br></p><p>A vendor describes the corporate or other originator of a platform. This proposal introduces a test that returns platform vendor, with one option at this time: Apple. Apple deployment provides an umbrella case for wide range of coding norms that may not be available on non-Apple platforms. This &quot;family of targets&quot; provides a simpler test than looking for specific modules or listing individual operating systems, both of which provide fragile approaches to this requirement.<br></p><p>This call would be supported in Swift&#39;s source-code by the existing private getVendor() used in lib/Basic/LangOptions.cpp.<br></p><p>Use:<br></p><p>#if vendor(Apple) <br>    // Code specific to Apple platform deployment<br>#endif<br> &lt;https://gist.github.com/erica/c9c11b540a2439696b2f514c2ffc6298#interop&gt;Interop<br></p><p>Swift&#39;s Objective-C compatibility enables developers to build mix-and-match projects with a mixed-language codebase. This proposal introduces a test to determine whether the Objective-C runtime is available for use. This test uses only one option, objc, although it could potentially expand to other scenarios, such as jvm, clr, and C++. <br></p><p>if (EnableObjCInterop)<br>    addPlatformConditionValue(&quot;_runtime&quot;, &quot;_ObjC&quot;);<br>else<br>    addPlatformConditionValue(&quot;_runtime&quot;, &quot;_Native&quot;)<br>Use:<br></p><p>#if interop(objc) <br>    // Code that depends on Objective-C<br>#endif<br> &lt;https://gist.github.com/erica/c9c11b540a2439696b2f514c2ffc6298#simulator-conditions&gt;Simulator Conditions<br></p><p>Xcode simulators enable developers to test code on a wide range of platforms without directly using physical devices. A simulator may not offer the full suite of modules available with device deployment or provide device-only hardware hooks like GPS. This proposal introduces a test for simulator platform conditions, enabling developers to omit references to unsupported features. It offers two options: simulator and device.<br></p><p>bool swift::tripleIsAnySimulator(const llvm::Triple &amp;triple) {<br>    return tripleIsiOSSimulator(triple) ||<br>    tripleIsWatchSimulator(triple) ||<br>    tripleIsAppleTVSimulator(triple);<br>}<br>This proposal uses a targetEnvironment test as target or platform are too valuable burn on this test.<br></p><p>Use:<br></p><p>#if targetEnvironment(simulator)<br>    // Code specific to simulator use<br>#endif<br>This condition test would reduce the fragility and special casing currently in use: <br></p><p>#if (arch(i386) || arch(x86_64)) &amp;&amp; os(iOS) <br>    print(&quot;Probably simulator&quot;)<br>#endif<br> &lt;https://gist.github.com/erica/c9c11b540a2439696b2f514c2ffc6298#impact-on-existing-code&gt;Impact on Existing Code<br></p><p>This proposal is additive and should not affect existing code. Some developers may refactor code as in the case of the simulator/device test.<br></p><p> &lt;https://gist.github.com/erica/c9c11b540a2439696b2f514c2ffc6298#alternatives-considered&gt;Alternatives Considered<br></p><p>Not accepting this proposal<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160616/dafe03ea/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>[DRAFT] Enhancing the Platform Configuration Test Suite for Conditional Compilation Blocks</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>June 16, 2016 at 06:00:00pm</p></header><div class="content"><p>Regarding &quot;Bitwidth describes the number of bits used to represent a<br>number. This proposal introduces a bitwidth test with two options: 32 and<br>64.&quot;...<br></p><p>I don&#39;t fully understand how this will work or in general how it will be<br>used.<br></p><p>   - &quot;used to represent a number&quot;... What &quot;number&quot; (e.g. what type)?<br>   - Is it just the width a pointer? Does this only relate to UnsafePointer?<br>   - Is it the width of something in the C realm? (e.g. CLong/long,<br>   CLongLong/long long, etc.)<br>   - How does it deal with variations of 64bit-ness of platforms (e.g.<br>   LP64, LLP64, etc.)<br>   - Inside of Swift (pure swift) does it serve any purpose not covered by<br>   the properties exposed on the various numeric types?<br>   - If for use in bridging C, etc. can it not be dealt with on the C side<br>   of things?<br></p><p>I personally think it needs to be specifically about pointer width or it<br>needs to allow for a compile query of the size of a given platform variable<br>width type (including C mapped ones).<br></p><p>-Shawn<br></p><p>On Thu, Jun 16, 2016 at 9:49 AM Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; This is an omnibus conditional compilation block proposal. It is built out<br>&gt; of Swift Evolution community requests and discussions dating back on<br>&gt; various threads to the genesis of the list.<br>&gt;<br>&gt;<br>&gt;    - This draft does not include tests for debug conditions. That was<br>&gt;    pitched under separate cover using runtime functions instead of conditional<br>&gt;    compilation blocks.<br>&gt;    - This draft does not include tests for OS versions, as that seems to<br>&gt;    be better addressed using the existing availability tests.<br>&gt;    - This draft is rewritten with respect to Jordan Rose&#39;s &quot;Rename &quot;build<br>&gt;    configurations&quot; to &quot;conditional compilation blocks&quot;&quot; swift commit<br>&gt;    &lt;https://github.com/apple/swift/commit/6272941c5cba9581a5ee93d92a6ee66e28c1bf13&gt; from<br>&gt;    12 February (rdar://problem/19812930).<br>&gt;    - It is offered as an omnibus because all the tests fall under the<br>&gt;    same &quot;conditional compilation block&quot; umbrella. Using an omnibus reduces<br>&gt;    list traffic and demands on core team resources. It&#39;s understood that the<br>&gt;    proposal is likely to be accepted with modifications (or rejected as a<br>&gt;    whole) due to the multiple tests.<br>&gt;<br>&gt;<br>&gt; -- Erica<br>&gt;<br>&gt; gist: https://gist.github.com/erica/c9c11b540a2439696b2f514c2ffc6298<br>&gt;<br>&gt; Enhancing the Platform Configuration Test Suite for Conditional<br>&gt; Compilation Blocks<br>&gt;<br>&gt;    - Proposal: TBD<br>&gt;    - Author: Erica Sadun &lt;http://github.com/erica&gt;<br>&gt;    - Status: TBD<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/c9c11b540a2439696b2f514c2ffc6298#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; This proposal introduces additional configuration tests to differentiate<br>&gt; platform conditions in conditional compilation blocks.<br>&gt;<br>&gt; This proposal was first discussed on-list in the [Draft] Introducing<br>&gt; Build Configuration Tests for Platform Conditions<br>&gt; &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/12140/focus=12267&gt; thread<br>&gt; and then re-pitched in TBD &lt;https://gist.github.com/erica/TBD&gt;.<br>&gt; &lt;https://gist.github.com/erica/c9c11b540a2439696b2f514c2ffc6298#note&gt;Note<br>&gt;<br>&gt; The term &quot;build configuration&quot; is subsumed by &quot;conditional compilation<br>&gt; block&quot;. See this accepted patch<br>&gt; &lt;https://github.com/apple/swift/commit/6272941c5cba9581a5ee93d92a6ee66e28c1bf13&gt;<br>&gt; &lt;https://gist.github.com/erica/c9c11b540a2439696b2f514c2ffc6298#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; Testing for platform conditions is a typical developer task. Although some<br>&gt; built-in features like CFByteOrderGetCurrentexist, it seems a natural<br>&gt; match for Swift to introduce conditional compilation blocks specific to<br>&gt; common platform conditions.<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/c9c11b540a2439696b2f514c2ffc6298#current-art&gt;Current<br>&gt; Art<br>&gt;<br>&gt; Swift currently supports the following platform configuration tests,<br>&gt; defined in lib/Basic/LangOptions.cpp.<br>&gt;<br>&gt;    - The literals true and false<br>&gt;    - The os() function that tests for OSX, iOS, watchOS, tvOS, Linux,<br>&gt;    Windows, Android, and FreeBSD<br>&gt;    - The arch() function that tests for x86_64, arm, arm64, i386,<br>&gt;    powerpc64, s390x, and powerpc64le<br>&gt;    - The swift() function that tests for specific Swift language<br>&gt;    releases, e.g. swift(&gt;=2.2)<br>&gt;<br>&gt; The following platform configuration test has been accepted in SE-0075<br>&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0075-import-test.md&gt; but<br>&gt; not yet implemented:<br>&gt;<br>&gt;    - The canImport() function that tests whether specific modules can be<br>&gt;    imported.<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/c9c11b540a2439696b2f514c2ffc6298#detailed-design&gt;Detailed<br>&gt; Design<br>&gt;<br>&gt; This proposal introduces several platform condition tests for use in<br>&gt; conditional compilation blocks: endianness, bitwidth, vendor, objc interop,<br>&gt; and simulator.<br>&gt; &lt;https://gist.github.com/erica/c9c11b540a2439696b2f514c2ffc6298#endianness&gt;<br>&gt; Endianness<br>&gt;<br>&gt; Endianness refers to the byte order used in memory. This proposal exposes<br>&gt; endian test conditions, promoting them from private underscored names to<br>&gt; public developer-referencable ones.<br>&gt;<br>&gt; // Set the &quot;_endian&quot; platform condition.<br>&gt;   switch (Target.getArch()) {<br>&gt;   case llvm::Triple::ArchType::arm:<br>&gt;   case llvm::Triple::ArchType::thumb:<br>&gt;     addPlatformConditionValue(&quot;_endian&quot;, &quot;little&quot;);<br>&gt;     break;<br>&gt;   case llvm::Triple::ArchType::aarch64:<br>&gt;     addPlatformConditionValue(&quot;_endian&quot;, &quot;little&quot;);<br>&gt;     break;<br>&gt;   case llvm::Triple::ArchType::ppc64:<br>&gt;     addPlatformConditionValue(&quot;_endian&quot;, &quot;big&quot;);<br>&gt;     break;<br>&gt;   case llvm::Triple::ArchType::ppc64le:<br>&gt;     addPlatformConditionValue(&quot;_endian&quot;, &quot;little&quot;);<br>&gt;     break;<br>&gt;   case llvm::Triple::ArchType::x86:<br>&gt;     addPlatformConditionValue(&quot;_endian&quot;, &quot;little&quot;);<br>&gt;     break;<br>&gt;   case llvm::Triple::ArchType::x86_64:<br>&gt;     addPlatformConditionValue(&quot;_endian&quot;, &quot;little&quot;);<br>&gt;     break;<br>&gt;   case llvm::Triple::ArchType::systemz:<br>&gt;     addPlatformConditionValue(&quot;_endian&quot;, &quot;big&quot;);<br>&gt;     break;<br>&gt;   default:<br>&gt;     llvm_unreachable(&quot;undefined architecture endianness&quot;);<br>&gt;<br>&gt; Under this proposal _endian is renamed to endian and made a public API.<br>&gt;<br>&gt; Use:<br>&gt;<br>&gt; #if endian(big)<br>&gt;     // Big endian code<br>&gt; #endif<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/c9c11b540a2439696b2f514c2ffc6298#bitwidth&gt;<br>&gt; Bitwidth<br>&gt;<br>&gt; Bitwidth describes the number of bits used to represent a number. This<br>&gt; proposal introduces a bitwidth test with two options: 32 and 64.<br>&gt;<br>&gt; Use:<br>&gt;<br>&gt; #if bitwidth(64)<br>&gt;     // 64-bit code<br>&gt; #endif<br>&gt;<br>&gt; List members briefly discussed whether it was better to measure pointer<br>&gt; width or the size of Int. William Dillon suggested renaming bitwidth to<br>&gt; either intwidth or intsize. Brent Royal-Gordon suggests intbits.<br>&gt; Alternatives include bitsand bitsize. This proposal avoids wordbits because<br>&gt; of the way, for example, Intel ends up doing “dword”, “qword”, and so forth<br>&gt; for backwards compatibility.<br>&gt; &lt;https://gist.github.com/erica/c9c11b540a2439696b2f514c2ffc6298#vendor&gt;<br>&gt; Vendor<br>&gt;<br>&gt; A vendor describes the corporate or other originator of a platform. This<br>&gt; proposal introduces a test that returns platform vendor, with one option at<br>&gt; this time: Apple. Apple deployment provides an umbrella case for wide<br>&gt; range of coding norms that may not be available on non-Apple platforms.<br>&gt; This &quot;family of targets&quot; provides a simpler test than looking for specific<br>&gt; modules or listing individual operating systems, both of which provide<br>&gt; fragile approaches to this requirement.<br>&gt;<br>&gt; This call would be supported in Swift&#39;s source-code by the existing<br>&gt; private getVendor() used in lib/Basic/LangOptions.cpp.<br>&gt;<br>&gt; Use:<br>&gt;<br>&gt; #if vendor(Apple)<br>&gt;     // Code specific to Apple platform deployment<br>&gt; #endif<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/c9c11b540a2439696b2f514c2ffc6298#interop&gt;<br>&gt; Interop<br>&gt;<br>&gt; Swift&#39;s Objective-C compatibility enables developers to build<br>&gt; mix-and-match projects with a mixed-language codebase. This proposal<br>&gt; introduces a test to determine whether the Objective-C runtime is available<br>&gt; for use. This test uses only one option, objc, although it could<br>&gt; potentially expand to other scenarios, such as jvm, clr, and C++.<br>&gt;<br>&gt; if (EnableObjCInterop)<br>&gt;     addPlatformConditionValue(&quot;_runtime&quot;, &quot;_ObjC&quot;);else<br>&gt;     addPlatformConditionValue(&quot;_runtime&quot;, &quot;_Native&quot;)<br>&gt;<br>&gt; Use:<br>&gt;<br>&gt; #if interop(objc)<br>&gt;     // Code that depends on Objective-C<br>&gt; #endif<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/c9c11b540a2439696b2f514c2ffc6298#simulator-conditions&gt;Simulator<br>&gt; Conditions<br>&gt;<br>&gt; Xcode simulators enable developers to test code on a wide range of<br>&gt; platforms without directly using physical devices. A simulator may not<br>&gt; offer the full suite of modules available with device deployment or provide<br>&gt; device-only hardware hooks like GPS. This proposal introduces a test for<br>&gt; simulator platform conditions, enabling developers to omit references to<br>&gt; unsupported features. It offers two options: simulator and device.<br>&gt;<br>&gt; bool swift::tripleIsAnySimulator(const llvm::Triple &amp;triple) {<br>&gt;     return tripleIsiOSSimulator(triple) ||<br>&gt;     tripleIsWatchSimulator(triple) ||<br>&gt;     tripleIsAppleTVSimulator(triple);<br>&gt; }<br>&gt;<br>&gt; This proposal uses a targetEnvironment test as target or platform are too<br>&gt; valuable burn on this test.<br>&gt;<br>&gt; Use:<br>&gt;<br>&gt; #if targetEnvironment(simulator)<br>&gt;     // Code specific to simulator use<br>&gt; #endif<br>&gt;<br>&gt; This condition test would reduce the fragility and special casing<br>&gt; currently in use:<br>&gt;<br>&gt; #if (arch(i386) || arch(x86_64)) &amp;&amp; os(iOS)<br>&gt;     print(&quot;Probably simulator&quot;)<br>&gt; #endif<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/c9c11b540a2439696b2f514c2ffc6298#impact-on-existing-code&gt;Impact<br>&gt; on Existing Code<br>&gt;<br>&gt; This proposal is additive and should not affect existing code. Some<br>&gt; developers may refactor code as in the case of the simulator/device test.<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/c9c11b540a2439696b2f514c2ffc6298#alternatives-considered&gt;Alternatives<br>&gt; Considered<br>&gt; Not accepting this proposal<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160616/e2abe50e/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>[DRAFT] Enhancing the Platform Configuration Test Suite for Conditional Compilation Blocks</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>June 28, 2016 at 11:00:00pm</p></header><div class="content"><p>+1 on getting this proposal reviewed soon; I ran into the lack of<br>TARGET_OS_SIMULATOR today (and was about to send an email, before I<br>searched a little harder and found this).<br></p><p>On Thu, Jun 16, 2016 at 9:49 AM, Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; This is an omnibus conditional compilation block proposal. It is built out<br>&gt; of Swift Evolution community requests and discussions dating back on<br>&gt; various threads to the genesis of the list.<br>&gt;<br>&gt;<br>&gt;    - This draft does not include tests for debug conditions. That was<br>&gt;    pitched under separate cover using runtime functions instead of conditional<br>&gt;    compilation blocks.<br>&gt;    - This draft does not include tests for OS versions, as that seems to<br>&gt;    be better addressed using the existing availability tests.<br>&gt;    - This draft is rewritten with respect to Jordan Rose&#39;s &quot;Rename &quot;build<br>&gt;    configurations&quot; to &quot;conditional compilation blocks&quot;&quot; swift commit<br>&gt;    &lt;https://github.com/apple/swift/commit/6272941c5cba9581a5ee93d92a6ee66e28c1bf13&gt; from<br>&gt;    12 February (rdar://problem/19812930).<br>&gt;    - It is offered as an omnibus because all the tests fall under the<br>&gt;    same &quot;conditional compilation block&quot; umbrella. Using an omnibus reduces<br>&gt;    list traffic and demands on core team resources. It&#39;s understood that the<br>&gt;    proposal is likely to be accepted with modifications (or rejected as a<br>&gt;    whole) due to the multiple tests.<br>&gt;<br>&gt;<br>&gt; -- Erica<br>&gt;<br>&gt; gist: https://gist.github.com/erica/c9c11b540a2439696b2f514c2ffc6298<br>&gt;<br>&gt; Enhancing the Platform Configuration Test Suite for Conditional<br>&gt; Compilation Blocks<br>&gt;<br>&gt;    - Proposal: TBD<br>&gt;    - Author: Erica Sadun &lt;http://github.com/erica&gt;<br>&gt;    - Status: TBD<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/c9c11b540a2439696b2f514c2ffc6298#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; This proposal introduces additional configuration tests to differentiate<br>&gt; platform conditions in conditional compilation blocks.<br>&gt;<br>&gt; This proposal was first discussed on-list in the [Draft] Introducing<br>&gt; Build Configuration Tests for Platform Conditions<br>&gt; &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/12140/focus=12267&gt; thread<br>&gt; and then re-pitched in TBD &lt;https://gist.github.com/erica/TBD&gt;.<br>&gt; &lt;https://gist.github.com/erica/c9c11b540a2439696b2f514c2ffc6298#note&gt;Note<br>&gt;<br>&gt; The term &quot;build configuration&quot; is subsumed by &quot;conditional compilation<br>&gt; block&quot;. See this accepted patch<br>&gt; &lt;https://github.com/apple/swift/commit/6272941c5cba9581a5ee93d92a6ee66e28c1bf13&gt;<br>&gt; &lt;https://gist.github.com/erica/c9c11b540a2439696b2f514c2ffc6298#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; Testing for platform conditions is a typical developer task. Although some<br>&gt; built-in features like CFByteOrderGetCurrentexist, it seems a natural<br>&gt; match for Swift to introduce conditional compilation blocks specific to<br>&gt; common platform conditions.<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/c9c11b540a2439696b2f514c2ffc6298#current-art&gt;Current<br>&gt; Art<br>&gt;<br>&gt; Swift currently supports the following platform configuration tests,<br>&gt; defined in lib/Basic/LangOptions.cpp.<br>&gt;<br>&gt;    - The literals true and false<br>&gt;    - The os() function that tests for OSX, iOS, watchOS, tvOS, Linux,<br>&gt;    Windows, Android, and FreeBSD<br>&gt;    - The arch() function that tests for x86_64, arm, arm64, i386,<br>&gt;    powerpc64, s390x, and powerpc64le<br>&gt;    - The swift() function that tests for specific Swift language<br>&gt;    releases, e.g. swift(&gt;=2.2)<br>&gt;<br>&gt; The following platform configuration test has been accepted in SE-0075<br>&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0075-import-test.md&gt; but<br>&gt; not yet implemented:<br>&gt;<br>&gt;    - The canImport() function that tests whether specific modules can be<br>&gt;    imported.<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/c9c11b540a2439696b2f514c2ffc6298#detailed-design&gt;Detailed<br>&gt; Design<br>&gt;<br>&gt; This proposal introduces several platform condition tests for use in<br>&gt; conditional compilation blocks: endianness, bitwidth, vendor, objc interop,<br>&gt; and simulator.<br>&gt; &lt;https://gist.github.com/erica/c9c11b540a2439696b2f514c2ffc6298#endianness&gt;<br>&gt; Endianness<br>&gt;<br>&gt; Endianness refers to the byte order used in memory. This proposal exposes<br>&gt; endian test conditions, promoting them from private underscored names to<br>&gt; public developer-referencable ones.<br>&gt;<br>&gt; // Set the &quot;_endian&quot; platform condition.<br>&gt;   switch (Target.getArch()) {<br>&gt;   case llvm::Triple::ArchType::arm:<br>&gt;   case llvm::Triple::ArchType::thumb:<br>&gt;     addPlatformConditionValue(&quot;_endian&quot;, &quot;little&quot;);<br>&gt;     break;<br>&gt;   case llvm::Triple::ArchType::aarch64:<br>&gt;     addPlatformConditionValue(&quot;_endian&quot;, &quot;little&quot;);<br>&gt;     break;<br>&gt;   case llvm::Triple::ArchType::ppc64:<br>&gt;     addPlatformConditionValue(&quot;_endian&quot;, &quot;big&quot;);<br>&gt;     break;<br>&gt;   case llvm::Triple::ArchType::ppc64le:<br>&gt;     addPlatformConditionValue(&quot;_endian&quot;, &quot;little&quot;);<br>&gt;     break;<br>&gt;   case llvm::Triple::ArchType::x86:<br>&gt;     addPlatformConditionValue(&quot;_endian&quot;, &quot;little&quot;);<br>&gt;     break;<br>&gt;   case llvm::Triple::ArchType::x86_64:<br>&gt;     addPlatformConditionValue(&quot;_endian&quot;, &quot;little&quot;);<br>&gt;     break;<br>&gt;   case llvm::Triple::ArchType::systemz:<br>&gt;     addPlatformConditionValue(&quot;_endian&quot;, &quot;big&quot;);<br>&gt;     break;<br>&gt;   default:<br>&gt;     llvm_unreachable(&quot;undefined architecture endianness&quot;);<br>&gt;<br>&gt; Under this proposal _endian is renamed to endian and made a public API.<br>&gt;<br>&gt; Use:<br>&gt;<br>&gt; #if endian(big)<br>&gt;     // Big endian code<br>&gt; #endif<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/c9c11b540a2439696b2f514c2ffc6298#bitwidth&gt;<br>&gt; Bitwidth<br>&gt;<br>&gt; Bitwidth describes the number of bits used to represent a number. This<br>&gt; proposal introduces a bitwidth test with two options: 32 and 64.<br>&gt;<br>&gt; Use:<br>&gt;<br>&gt; #if bitwidth(64)<br>&gt;     // 64-bit code<br>&gt; #endif<br>&gt;<br>&gt; List members briefly discussed whether it was better to measure pointer<br>&gt; width or the size of Int. William Dillon suggested renaming bitwidth to<br>&gt; either intwidth or intsize. Brent Royal-Gordon suggests intbits.<br>&gt; Alternatives include bitsand bitsize. This proposal avoids wordbits because<br>&gt; of the way, for example, Intel ends up doing “dword”, “qword”, and so forth<br>&gt; for backwards compatibility.<br>&gt; &lt;https://gist.github.com/erica/c9c11b540a2439696b2f514c2ffc6298#vendor&gt;<br>&gt; Vendor<br>&gt;<br>&gt; A vendor describes the corporate or other originator of a platform. This<br>&gt; proposal introduces a test that returns platform vendor, with one option at<br>&gt; this time: Apple. Apple deployment provides an umbrella case for wide<br>&gt; range of coding norms that may not be available on non-Apple platforms.<br>&gt; This &quot;family of targets&quot; provides a simpler test than looking for specific<br>&gt; modules or listing individual operating systems, both of which provide<br>&gt; fragile approaches to this requirement.<br>&gt;<br>&gt; This call would be supported in Swift&#39;s source-code by the existing<br>&gt; private getVendor() used in lib/Basic/LangOptions.cpp.<br>&gt;<br>&gt; Use:<br>&gt;<br>&gt; #if vendor(Apple)<br>&gt;     // Code specific to Apple platform deployment<br>&gt; #endif<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/c9c11b540a2439696b2f514c2ffc6298#interop&gt;<br>&gt; Interop<br>&gt;<br>&gt; Swift&#39;s Objective-C compatibility enables developers to build<br>&gt; mix-and-match projects with a mixed-language codebase. This proposal<br>&gt; introduces a test to determine whether the Objective-C runtime is available<br>&gt; for use. This test uses only one option, objc, although it could<br>&gt; potentially expand to other scenarios, such as jvm, clr, and C++.<br>&gt;<br>&gt; if (EnableObjCInterop)<br>&gt;     addPlatformConditionValue(&quot;_runtime&quot;, &quot;_ObjC&quot;);else<br>&gt;     addPlatformConditionValue(&quot;_runtime&quot;, &quot;_Native&quot;)<br>&gt;<br>&gt; Use:<br>&gt;<br>&gt; #if interop(objc)<br>&gt;     // Code that depends on Objective-C<br>&gt; #endif<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/c9c11b540a2439696b2f514c2ffc6298#simulator-conditions&gt;Simulator<br>&gt; Conditions<br>&gt;<br>&gt; Xcode simulators enable developers to test code on a wide range of<br>&gt; platforms without directly using physical devices. A simulator may not<br>&gt; offer the full suite of modules available with device deployment or provide<br>&gt; device-only hardware hooks like GPS. This proposal introduces a test for<br>&gt; simulator platform conditions, enabling developers to omit references to<br>&gt; unsupported features. It offers two options: simulator and device.<br>&gt;<br>&gt; bool swift::tripleIsAnySimulator(const llvm::Triple &amp;triple) {<br>&gt;     return tripleIsiOSSimulator(triple) ||<br>&gt;     tripleIsWatchSimulator(triple) ||<br>&gt;     tripleIsAppleTVSimulator(triple);<br>&gt; }<br>&gt;<br>&gt; This proposal uses a targetEnvironment test as target or platform are too<br>&gt; valuable burn on this test.<br>&gt;<br>&gt; Use:<br>&gt;<br>&gt; #if targetEnvironment(simulator)<br>&gt;     // Code specific to simulator use<br>&gt; #endif<br>&gt;<br>&gt; This condition test would reduce the fragility and special casing<br>&gt; currently in use:<br>&gt;<br>&gt; #if (arch(i386) || arch(x86_64)) &amp;&amp; os(iOS)<br>&gt;     print(&quot;Probably simulator&quot;)<br>&gt; #endif<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/c9c11b540a2439696b2f514c2ffc6298#impact-on-existing-code&gt;Impact<br>&gt; on Existing Code<br>&gt;<br>&gt; This proposal is additive and should not affect existing code. Some<br>&gt; developers may refactor code as in the case of the simulator/device test.<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/c9c11b540a2439696b2f514c2ffc6298#alternatives-considered&gt;Alternatives<br>&gt; Considered<br>&gt; Not accepting this proposal<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/7233fe5f/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
