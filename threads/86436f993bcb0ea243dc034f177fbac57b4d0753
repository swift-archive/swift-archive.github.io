<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/68f395178335ae23c492543a5af2599c?s=50"></div><header><strong>Generic `typealias`s</strong> from <string>Dapeng Gao</string> &lt;gdapeng at icloud.com&gt;<p>December  4, 2015 at 07:00:00pm</p></header><div class="content"><p>It would be handy if Swift can support generic `typealias`s, which would probably look like this:<br></p><p>typealias Handler&lt;Element&gt; = [Element] -&gt; Void<br></p><p>One common way to achieve this is to define a generic `struct` and use a nested `typealias`:<br></p><p>struct HandlerWrapper&lt;Element&gt; {<br>    typealias Hander = [Element] -&gt; Void<br>}<br></p><p>HandlerWrapper&lt;SomeType&gt;.Hander<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/86430753/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>Generic `typealias`s</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>December  4, 2015 at 11:00:00pm</p></header><div class="content"><p>I concur and I think that there is should be more to this idea. I, at<br>least, would want partial specialization as part of this.  Consider Either<br>and Result:<br></p><p>`enum Either {<br>    case .Left<br>    case .Right<br>}<br></p><p>typealias Result&lt;SuccessValue&gt; = Either&lt;NSError, SuccessValue&gt;`<br></p><p>How (can I?) specify just one of the types or, possibly, constrain the left<br>side so as to avoid the need to provide a concrete type &quot;NSError&quot; there?<br></p><p>This next bit is probably another proposal. Assuming that that gets sorted<br>out, it would be useful to alias methods, properties, cases, etc for the<br>new name. `&lt;Some keyword&gt; case Result.Success = case Either.Left`<br></p><p>TJ<br></p><p>On Fri, Dec 4, 2015 at 12:04 PM, Dapeng Gao &lt;gdapeng at icloud.com&gt; wrote:<br></p><p>&gt; It would be handy if Swift can support generic `typealias`s, which would<br>&gt; probably look like this:<br>&gt;<br>&gt; typealias Handler&lt;Element&gt; = [Element] -&gt; Void<br>&gt;<br>&gt; One common way to achieve this is to define a generic `struct` and use a<br>&gt; nested `typealias`:<br>&gt;<br>&gt; struct HandlerWrapper&lt;Element&gt; {<br>&gt;     typealias Hander = [Element] -&gt; Void<br>&gt; }<br>&gt;<br>&gt; HandlerWrapper&lt;SomeType&gt;.Hander<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/facbbe0e/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Generic `typealias`s</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December  4, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; On Dec 4, 2015, at 3:04 AM, Dapeng Gao &lt;gdapeng at icloud.com&gt; wrote:<br>&gt; <br>&gt; It would be handy if Swift can support generic `typealias`s, which would probably look like this:<br>&gt; <br>&gt; typealias Handler&lt;Element&gt; = [Element] -&gt; Void<br></p><p>Yes, this is definitely something that I (at least) would like to see.  Patches welcome :-)<br></p><p>-Chris<br></p><p><br>&gt; <br>&gt; One common way to achieve this is to define a generic `struct` and use a nested `typealias`:<br>&gt; <br>&gt; struct HandlerWrapper&lt;Element&gt; {<br>&gt;     typealias Hander = [Element] -&gt; Void<br>&gt; }<br>&gt; <br>&gt; HandlerWrapper&lt;SomeType&gt;.Hander<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/0ca8487b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Generic `typealias`s</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December  4, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; On Dec 4, 2015, at 3:04 AM, Dapeng Gao &lt;gdapeng at icloud.com&gt; wrote:<br>&gt; <br>&gt; It would be handy if Swift can support generic `typealias`s, which would probably look like this:<br>&gt; <br>&gt; typealias Handler&lt;Element&gt; = [Element] -&gt; Void<br>&gt; <br>&gt; One common way to achieve this is to define a generic `struct` and use a nested `typealias`:<br>&gt; <br>&gt; struct HandlerWrapper&lt;Element&gt; {<br>&gt;     typealias Hander = [Element] -&gt; Void<br>&gt; }<br>&gt; <br>&gt; HandlerWrapper&lt;SomeType&gt;.Hander<br></p><p>Definitely. I&#39;d say this falls under the (totally arbitrary) umbrella of &quot;obvious things that we didn&#39;t get around to implementing yet&quot; instead of formal changes to the language. If you (or anyone else!) were to implement this, we&#39;d consider the pull request immediately.<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/27240f64/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Generic `typealias`s</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December  4, 2015 at 05:00:00pm</p></header><div class="content"><p>I&#39;ve filed a ticket on bugs.swift.org to serve as a hint to any<br>interested party that this is something that is actively desired and<br>patches are welcome.<br></p><p>https://bugs.swift.org/browse/SR-64<br></p><p>I figure that&#39;s probably the right course of action for obvious<br>improvements that we know we want but aren&#39;t candidates for the full swift-<br>evolution process.<br></p><p>-Kevin Ballard<br></p><p>On Fri, Dec 4, 2015, at 04:08 PM, Joe Groff wrote:<br>&gt;<br>&gt;&gt; On Dec 4, 2015, at 3:04 AM, Dapeng Gao &lt;gdapeng at icloud.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; It would be handy if Swift can support generic `typealias`s, which<br>&gt;&gt; would probably look like this:<br>&gt;&gt;<br>&gt;&gt; typealias Handler&lt;Element&gt; = [Element] -&gt; Void<br>&gt;&gt;<br>&gt;&gt; One common way to achieve this is to define a generic `struct` and<br>&gt;&gt; use a nested `typealias`:<br>&gt;&gt;<br>&gt;&gt; struct HandlerWrapper&lt;Element&gt; { typealias Hander = [Element]<br>&gt;&gt; -&gt; Void }<br>&gt;&gt;<br>&gt;&gt; HandlerWrapper&lt;SomeType&gt;.Hander<br>&gt;<br>&gt; Definitely. I&#39;d say this falls under the (totally arbitrary) umbrella<br>&gt; of &quot;obvious things that we didn&#39;t get around to implementing yet&quot;<br>&gt; instead of formal changes to the language. If you (or anyone else!)<br>&gt; were to implement this, we&#39;d consider the pull request immediately.<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt;<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/ec386144/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Generic `typealias`s</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>December  4, 2015 at 08:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On Dec 4, 2015, at 4:08 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 4, 2015, at 3:04 AM, Dapeng Gao &lt;gdapeng at icloud.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; It would be handy if Swift can support generic `typealias`s, which would probably look like this:<br>&gt;&gt; <br>&gt;&gt; typealias Handler&lt;Element&gt; = [Element] -&gt; Void<br>&gt;&gt; <br>&gt;&gt; One common way to achieve this is to define a generic `struct` and use a nested `typealias`:<br>&gt;&gt; <br>&gt;&gt; struct HandlerWrapper&lt;Element&gt; {<br>&gt;&gt;     typealias Hander = [Element] -&gt; Void<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; HandlerWrapper&lt;SomeType&gt;.Hander<br>&gt; <br>&gt; Definitely. I&#39;d say this falls under the (totally arbitrary) umbrella of &quot;obvious things that we didn&#39;t get around to implementing yet&quot; instead of formal changes to the language. If you (or anyone else!) were to implement this, we&#39;d consider the pull request immediately.<br></p><p>I would rather not have such an umbrella, because how would one know what&#39;s in it and who gets to decide? Even &quot;obvious&quot; things need design, and some things that might sound like obvious goodness can benefit from review. ++ sounded like obvious goodness at one point in time, too. <br></p><p>  - Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/7e3ff8f0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Generic `typealias`s</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>December  4, 2015 at 09:00:00pm</p></header><div class="content"><p>Perhaps we should &quot;formalize&quot; a proposal as a starting point for further discussion/development.<br></p><p>Currently, Swift supports defining an alias for an existing non-generic or fully bound generic type using the &#39;typealias&#39; keyword:<br></p><p>typealias Foo = Int<br>typealias Bar = Dictionary&lt;String : Int&gt;<br></p><p>In this example, the type referred to by the identifier &#39;Foo&#39; is exactly equivalent to the existing type Int. Any occurrence of the type identifier &quot;Int&quot; can be replaced in a Swift source code text by the typealias identifier &quot;Foo&quot; without changing the behavior of the program.<br></p><p>When a typealias is defined, the underlying type can be the underlying type of another typealias:<br></p><p>typealias Baz = Foo // Baz is typealias of Int now<br></p><p>However, the typealias mechanism does not allow an unbound generic type to be typealiased:<br></p><p>// This fails<br>typealias MyArray = Array<br>// as does this<br>typealias MyArray&lt;T&gt; = Array&lt;T&gt;<br></p><p>There are at least two potential ways to extend the typealias mechanism to support typealiasing unbound generic types.<br></p><p>1. Allow an unbound generic type to be directly typealiased to a different identifier. The alias can then be used in place of the original generic type identifier anywhere where the latter would have been valid, in such a way that a direct textual substitution of the original identifier for the new identifier (or vice versa) would not change the meaning of a Swift program.<br></p><p>typealias HashMap = Dictionary<br>let x : HashMap&lt;String, Int&gt; = [&quot;hello&quot; : 1234]	// identical to x : Dictionary&lt;String : Int&gt; = ...<br></p><p>2. Allow an identifier to serve as a typealias to a partially specialized or fully unspecialized generic type. When declaring the typealias identifier, type parameter aliases can be declared as well within a generic type signature, akin to the &quot;&lt;&gt;&quot; generic type signature supported by type decls and function decls. When declaring the underlying type, unbound generic type parameters can then be bound to the type parameter aliases defined alongside the typealias identifier. Instead of an type parameter identifier, a concrete type can be used to partially specialize the type referred to by the typealias. For example:<br></p><p>typealias HomogenousDict&lt;T&gt; = Dictionary&lt;T, T&gt;<br>// A declaration of HomogenousDict&lt;Int&gt; is exactly equivalent to a declaration of Dictionary&lt;Int, Int&gt;.<br>typealias DontDoThis&lt;U, T&gt; = Dictionary&lt;T, U&gt;<br>// A declaration of DontDoThis&lt;String, Int&gt; is exactly equivalent to a declaration of Dictionary&lt;Int, String&gt;.<br>// This might be a potential issue.<br>typealias IntKeyDicts&lt;Value&gt; = Dictionary&lt;Int, Value&gt;<br>// A declaration of IntKeyDicts&lt;String&gt; is then exactly equivalent to a declaration of Dictionary&lt;Int, String&gt;<br></p><p>I hope this can serve as a starting point for discussion of the design of this feature, as well as identification of potential semantic and implementation issues.<br></p><p>Best,<br>Austin<br></p><p><br>&gt; On Dec 4, 2015, at 8:35 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt; On Dec 4, 2015, at 4:08 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 4, 2015, at 3:04 AM, Dapeng Gao &lt;gdapeng at icloud.com &lt;mailto:gdapeng at icloud.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It would be handy if Swift can support generic `typealias`s, which would probably look like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; typealias Handler&lt;Element&gt; = [Element] -&gt; Void<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One common way to achieve this is to define a generic `struct` and use a nested `typealias`:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct HandlerWrapper&lt;Element&gt; {<br>&gt;&gt;&gt;     typealias Hander = [Element] -&gt; Void<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; HandlerWrapper&lt;SomeType&gt;.Hander<br>&gt;&gt; <br>&gt;&gt; Definitely. I&#39;d say this falls under the (totally arbitrary) umbrella of &quot;obvious things that we didn&#39;t get around to implementing yet&quot; instead of formal changes to the language. If you (or anyone else!) were to implement this, we&#39;d consider the pull request immediately.<br>&gt; <br>&gt; I would rather not have such an umbrella, because how would one know what&#39;s in it and who gets to decide? Even &quot;obvious&quot; things need design, and some things that might sound like obvious goodness can benefit from review. ++ sounded like obvious goodness at one point in time, too. <br>&gt; <br>&gt;   - Doug<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/f6860ad6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Generic `typealias`s</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>December  4, 2015 at 10:00:00pm</p></header><div class="content"><p>A few clarifying addenda:<br></p><p>1. the comment &quot;// identical to x : Dictionary&lt;String : Int&gt; = ...&quot; should be &quot;// identical to x : Dictionary&lt;String, Int&gt; = ...&quot;<br></p><p>2. For proposal #2, the compiler should require that all type parameter aliases declared on the LHS of the &quot;=&quot; be used when declaring the underlying type on the RHS of the &quot;=&quot;.<br></p><p>3. For proposal #2, the only valid values for the type arguments when declaring the underlying type on the RHS of the &quot;=&quot; are type parameter aliases declared on the LHS, and valid concrete types.<br></p><p>Best,<br>Austin<br></p><p>&gt; On Dec 4, 2015, at 9:57 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; Perhaps we should &quot;formalize&quot; a proposal as a starting point for further discussion/development.<br>&gt; <br>&gt; Currently, Swift supports defining an alias for an existing non-generic or fully bound generic type using the &#39;typealias&#39; keyword:<br>&gt; <br>&gt; typealias Foo = Int<br>&gt; typealias Bar = Dictionary&lt;String : Int&gt;<br>&gt; <br>&gt; In this example, the type referred to by the identifier &#39;Foo&#39; is exactly equivalent to the existing type Int. Any occurrence of the type identifier &quot;Int&quot; can be replaced in a Swift source code text by the typealias identifier &quot;Foo&quot; without changing the behavior of the program.<br>&gt; <br>&gt; When a typealias is defined, the underlying type can be the underlying type of another typealias:<br>&gt; <br>&gt; typealias Baz = Foo // Baz is typealias of Int now<br>&gt; <br>&gt; However, the typealias mechanism does not allow an unbound generic type to be typealiased:<br>&gt; <br>&gt; // This fails<br>&gt; typealias MyArray = Array<br>&gt; // as does this<br>&gt; typealias MyArray&lt;T&gt; = Array&lt;T&gt;<br>&gt; <br>&gt; There are at least two potential ways to extend the typealias mechanism to support typealiasing unbound generic types.<br>&gt; <br>&gt; 1. Allow an unbound generic type to be directly typealiased to a different identifier. The alias can then be used in place of the original generic type identifier anywhere where the latter would have been valid, in such a way that a direct textual substitution of the original identifier for the new identifier (or vice versa) would not change the meaning of a Swift program.<br>&gt; <br>&gt; typealias HashMap = Dictionary<br>&gt; let x : HashMap&lt;String, Int&gt; = [&quot;hello&quot; : 1234]	// identical to x : Dictionary&lt;String : Int&gt; = ...<br>&gt; <br>&gt; 2. Allow an identifier to serve as a typealias to a partially specialized or fully unspecialized generic type. When declaring the typealias identifier, type parameter aliases can be declared as well within a generic type signature, akin to the &quot;&lt;&gt;&quot; generic type signature supported by type decls and function decls. When declaring the underlying type, unbound generic type parameters can then be bound to the type parameter aliases defined alongside the typealias identifier. Instead of an type parameter identifier, a concrete type can be used to partially specialize the type referred to by the typealias. For example:<br>&gt; <br>&gt; typealias HomogenousDict&lt;T&gt; = Dictionary&lt;T, T&gt;<br>&gt; // A declaration of HomogenousDict&lt;Int&gt; is exactly equivalent to a declaration of Dictionary&lt;Int, Int&gt;.<br>&gt; typealias DontDoThis&lt;U, T&gt; = Dictionary&lt;T, U&gt;<br>&gt; // A declaration of DontDoThis&lt;String, Int&gt; is exactly equivalent to a declaration of Dictionary&lt;Int, String&gt;.<br>&gt; // This might be a potential issue.<br>&gt; typealias IntKeyDicts&lt;Value&gt; = Dictionary&lt;Int, Value&gt;<br>&gt; // A declaration of IntKeyDicts&lt;String&gt; is then exactly equivalent to a declaration of Dictionary&lt;Int, String&gt;<br>&gt; <br>&gt; I hope this can serve as a starting point for discussion of the design of this feature, as well as identification of potential semantic and implementation issues.<br>&gt; <br>&gt; Best,<br>&gt; Austin<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 4, 2015, at 8:35 PM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt; On Dec 4, 2015, at 4:08 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 4, 2015, at 3:04 AM, Dapeng Gao &lt;gdapeng at icloud.com &lt;mailto:gdapeng at icloud.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It would be handy if Swift can support generic `typealias`s, which would probably look like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; typealias Handler&lt;Element&gt; = [Element] -&gt; Void<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One common way to achieve this is to define a generic `struct` and use a nested `typealias`:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct HandlerWrapper&lt;Element&gt; {<br>&gt;&gt;&gt;&gt;     typealias Hander = [Element] -&gt; Void<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; HandlerWrapper&lt;SomeType&gt;.Hander<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Definitely. I&#39;d say this falls under the (totally arbitrary) umbrella of &quot;obvious things that we didn&#39;t get around to implementing yet&quot; instead of formal changes to the language. If you (or anyone else!) were to implement this, we&#39;d consider the pull request immediately.<br>&gt;&gt; <br>&gt;&gt; I would rather not have such an umbrella, because how would one know what&#39;s in it and who gets to decide? Even &quot;obvious&quot; things need design, and some things that might sound like obvious goodness can benefit from review. ++ sounded like obvious goodness at one point in time, too. <br>&gt;&gt; <br>&gt;&gt;   - Doug<br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/d8743261/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
