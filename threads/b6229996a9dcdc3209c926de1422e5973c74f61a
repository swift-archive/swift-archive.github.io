<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Pre-proposal] Forward/Reverse Only Indexing Methods</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>May 31, 2016 at 01:00:00pm</p></header><div class="content"><p>So for Swift 3 we’re going to have the great new indexing model that performs index manipulation through the collection to which an index belongs.<br></p><p>However, it retains one of the things I didn’t like about the old model, which is that the distinction between forward/backward only types is a bit fuzzy, since the single advancedBy() method, now the index(:offsetBy:) method, was used for both forward and backward movement, which seems contradictory compared to the forward/backward only single-step methods.<br></p><p>Anyway, I’m wondering what people’s thoughts would be on tweaking the formula slightly such that there are methods that only work in a particular direction, i.e- we’d have three main variations of the methods like so:<br></p><p>    public func index(_ index:Index, advancedBy:Index.Distance) -&gt; Index { … } // Available on forward and bidirectional collections<br>    public func index(_ index:Index, reversedBy:Index.Distance) -&gt; Index { … } // Available on reverse and bidirectional collections<br>    public func index(_ index:Index, offsetBy:Index.Distance) -&gt; Index { … } // Available only on bidirectional collections<br></p><p>(note, the naming isn’t definite, as reversed may not be clear enough, it’s just an example for now)<br></p><p>There are three reasons I’d prefer this:<br></p><p>The first is that I can pass the same distance into either of the first two methods, and any negation etc. is handled internally. In essence I shouldn’t have to handle negative distances at all when working with the first two methods. So if I’m working with a step size of 5, I can just pass that into the appropriate method, I never have to do anything with it the value itself.<br></p><p>The second benefit is that there should be no uncertainty about the capabilities of the type you’re using; if it doesn’t have the index(:reversedBy:) method then you can’t go backwards, same as index(before:) and index(after:).<br></p><p>The third and main benefit is that the methods are just more explicit about what they do, and what direction you can go in; passing negatives into either of the first two would produce errors outright, allowing you to pick on mistakes in these cases.<br></p><p>The other main thing is that offsetBy doesn’t indicate whether a type supports forward-only offsets, you have to read the documentation to determine this either in the method itself or the type, whereas the presence or absence of the first two variants are pretty clear.<br></p><p>Currently the offsetBy, and the previous advancedBy(), methods require forward-only types to produce fatal errors if handed a negative distance, and vice versa for backward-only types, which can only produce errors at runtime, whereas the presence or absence of the first two methods can be handled during development. You could still pass a negative value and end up with a runtime error instead of course, but for the types of common uses they’re intended for you should be unlikely to produce one.<br></p><p>The offsetBy form would still exist for bidirectional collections, but would only really be used when you need to do more complex index/distance manipulation outside of the type where a calculation might produce either positive or negative values (e.g- if you&#39;re calculating the distance and don’t know where two indices are in relation to each other), the rest of the time you should try to use the more specific, single-direction forms as they clarify your intent and can help to catch mistakes if you’ve incorrectly generated a distance for example.<br></p><p><br>Just curious what other people’s thoughts are about this?<br></p><p>I intended to mention this a lot sooner (to change advancedBy), but then I find out about the new indexing model so thought I’d wait until afterwards, then completely forgot =)<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/b622f61a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Pre-proposal] Forward/Reverse Only Indexing Methods</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>June  1, 2016 at 06:00:00am</p></header><div class="content"><p>I like this idea. The problem is that it would require that we have an Index.NonNegativeDistance as argument to really make it statically safe. And we would have to have methods producing these, probably as optional return values.<br>Otherwise we won&#39;t have achieved statically safety but effectively just better documentation about the capabilities of the respective collection.<br></p><p>-Thorsten <br></p><p><br>&gt; Am 31.05.2016 um 14:46 schrieb Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; So for Swift 3 we’re going to have the great new indexing model that performs index manipulation through the collection to which an index belongs.<br>&gt; <br>&gt; However, it retains one of the things I didn’t like about the old model, which is that the distinction between forward/backward only types is a bit fuzzy, since the single advancedBy() method, now the index(:offsetBy:) method, was used for both forward and backward movement, which seems contradictory compared to the forward/backward only single-step methods.<br>&gt; <br>&gt; Anyway, I’m wondering what people’s thoughts would be on tweaking the formula slightly such that there are methods that only work in a particular direction, i.e- we’d have three main variations of the methods like so:<br>&gt; <br>&gt;     public func index(_ index:Index, advancedBy:Index.Distance) -&gt; Index { … } // Available on forward and bidirectional collections<br>&gt;     public func index(_ index:Index, reversedBy:Index.Distance) -&gt; Index { … } // Available on reverse and bidirectional collections<br>&gt;     public func index(_ index:Index, offsetBy:Index.Distance) -&gt; Index { … } // Available only on bidirectional collections<br>&gt; <br>&gt; (note, the naming isn’t definite, as reversed may not be clear enough, it’s just an example for now)<br>&gt; <br>&gt; There are three reasons I’d prefer this:<br>&gt; <br>&gt; The first is that I can pass the same distance into either of the first two methods, and any negation etc. is handled internally. In essence I shouldn’t have to handle negative distances at all when working with the first two methods. So if I’m working with a step size of 5, I can just pass that into the appropriate method, I never have to do anything with it the value itself.<br>&gt; <br>&gt; The second benefit is that there should be no uncertainty about the capabilities of the type you’re using; if it doesn’t have the index(:reversedBy:) method then you can’t go backwards, same as index(before:) and index(after:).<br>&gt; <br>&gt; The third and main benefit is that the methods are just more explicit about what they do, and what direction you can go in; passing negatives into either of the first two would produce errors outright, allowing you to pick on mistakes in these cases.<br>&gt; <br>&gt; The other main thing is that offsetBy doesn’t indicate whether a type supports forward-only offsets, you have to read the documentation to determine this either in the method itself or the type, whereas the presence or absence of the first two variants are pretty clear.<br>&gt; <br>&gt; Currently the offsetBy, and the previous advancedBy(), methods require forward-only types to produce fatal errors if handed a negative distance, and vice versa for backward-only types, which can only produce errors at runtime, whereas the presence or absence of the first two methods can be handled during development. You could still pass a negative value and end up with a runtime error instead of course, but for the types of common uses they’re intended for you should be unlikely to produce one.<br>&gt; <br>&gt; The offsetBy form would still exist for bidirectional collections, but would only really be used when you need to do more complex index/distance manipulation outside of the type where a calculation might produce either positive or negative values (e.g- if you&#39;re calculating the distance and don’t know where two indices are in relation to each other), the rest of the time you should try to use the more specific, single-direction forms as they clarify your intent and can help to catch mistakes if you’ve incorrectly generated a distance for example.<br>&gt; <br>&gt; <br>&gt; Just curious what other people’s thoughts are about this?<br>&gt; <br>&gt; I intended to mention this a lot sooner (to change advancedBy), but then I find out about the new indexing model so thought I’d wait until afterwards, then completely forgot =)<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160601/253970f9/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Pre-proposal] Forward/Reverse Only Indexing Methods</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>June  3, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On 1 Jun 2016, at 05:51, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; I like this idea. The problem is that it would require that we have an Index.NonNegativeDistance as argument to really make it statically safe. And we would have to have methods producing these, probably as optional return values.<br>&gt; Otherwise we won&#39;t have achieved statically safety but effectively just better documentation about the capabilities of the respective collection.<br>&gt; <br>&gt; -Thorsten <br></p><p>So you’d see something like:<br></p><p>	public func distance(from start:Index, advancedTo end:Index) -&gt; Index.NonNegativeDistance? { … }<br>	public func distance(from start:Index, reversedTo end:Index) -&gt; Index.NonNegativeDistance? { … }<br></p><p>Or something to that effect anyway, with the single-direction index (and formIndex etc.) methods taking the same type?. That’s clever, eliminates the run-time error for distance in many cases with a type-check at compile time instead, neat!<br></p><p>This could actually present an interesting possibility by designing around the fixed direction methods first, e.g- the NonNegativeDistance could be a Uint, and regular Distance would be an enum with .Forward(UInt) and .Backward(UInt) cases. I’m currently porting some of my simpler collections to Swift 3 to get some more experience with the new indexing model and other changes, and this would be a nice way to do it for some of these, rather than relying on a regular Int.<br></p><p>&gt; Am 31.05.2016 um 14:46 schrieb Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; <br>&gt;&gt; So for Swift 3 we’re going to have the great new indexing model that performs index manipulation through the collection to which an index belongs.<br>&gt;&gt; <br>&gt;&gt; However, it retains one of the things I didn’t like about the old model, which is that the distinction between forward/backward only types is a bit fuzzy, since the single advancedBy() method, now the index(:offsetBy:) method, was used for both forward and backward movement, which seems contradictory compared to the forward/backward only single-step methods.<br>&gt;&gt; <br>&gt;&gt; Anyway, I’m wondering what people’s thoughts would be on tweaking the formula slightly such that there are methods that only work in a particular direction, i.e- we’d have three main variations of the methods like so:<br>&gt;&gt; <br>&gt;&gt;     public func index(_ index:Index, advancedBy:Index.Distance) -&gt; Index { … } // Available on forward and bidirectional collections<br>&gt;&gt;     public func index(_ index:Index, reversedBy:Index.Distance) -&gt; Index { … } // Available on reverse and bidirectional collections<br>&gt;&gt;     public func index(_ index:Index, offsetBy:Index.Distance) -&gt; Index { … } // Available only on bidirectional collections<br>&gt;&gt; <br>&gt;&gt; (note, the naming isn’t definite, as reversed may not be clear enough, it’s just an example for now)<br>&gt;&gt; <br>&gt;&gt; There are three reasons I’d prefer this:<br>&gt;&gt; <br>&gt;&gt; The first is that I can pass the same distance into either of the first two methods, and any negation etc. is handled internally. In essence I shouldn’t have to handle negative distances at all when working with the first two methods. So if I’m working with a step size of 5, I can just pass that into the appropriate method, I never have to do anything with it the value itself.<br>&gt;&gt; <br>&gt;&gt; The second benefit is that there should be no uncertainty about the capabilities of the type you’re using; if it doesn’t have the index(:reversedBy:) method then you can’t go backwards, same as index(before:) and index(after:).<br>&gt;&gt; <br>&gt;&gt; The third and main benefit is that the methods are just more explicit about what they do, and what direction you can go in; passing negatives into either of the first two would produce errors outright, allowing you to pick on mistakes in these cases.<br>&gt;&gt; <br>&gt;&gt; The other main thing is that offsetBy doesn’t indicate whether a type supports forward-only offsets, you have to read the documentation to determine this either in the method itself or the type, whereas the presence or absence of the first two variants are pretty clear.<br>&gt;&gt; <br>&gt;&gt; Currently the offsetBy, and the previous advancedBy(), methods require forward-only types to produce fatal errors if handed a negative distance, and vice versa for backward-only types, which can only produce errors at runtime, whereas the presence or absence of the first two methods can be handled during development. You could still pass a negative value and end up with a runtime error instead of course, but for the types of common uses they’re intended for you should be unlikely to produce one.<br>&gt;&gt; <br>&gt;&gt; The offsetBy form would still exist for bidirectional collections, but would only really be used when you need to do more complex index/distance manipulation outside of the type where a calculation might produce either positive or negative values (e.g- if you&#39;re calculating the distance and don’t know where two indices are in relation to each other), the rest of the time you should try to use the more specific, single-direction forms as they clarify your intent and can help to catch mistakes if you’ve incorrectly generated a distance for example.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Just curious what other people’s thoughts are about this?<br>&gt;&gt; <br>&gt;&gt; I intended to mention this a lot sooner (to change advancedBy), but then I find out about the new indexing model so thought I’d wait until afterwards, then completely forgot =)<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160603/b58a625d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Pre-proposal] Forward/Reverse Only Indexing Methods</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>June  4, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; Am 03.06.2016 um 21:20 schrieb Haravikk &lt;swift-evolution at haravikk.me&gt;:<br>&gt; <br>&gt;&gt; On 1 Jun 2016, at 05:51, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I like this idea. The problem is that it would require that we have an Index.NonNegativeDistance as argument to really make it statically safe. And we would have to have methods producing these, probably as optional return values.<br>&gt;&gt; Otherwise we won&#39;t have achieved statically safety but effectively just better documentation about the capabilities of the respective collection.<br>&gt;&gt; <br>&gt;&gt; -Thorsten <br>&gt; <br>&gt; So you’d see something like:<br>&gt; <br>&gt; 	public func distance(from start:Index, advancedTo end:Index) -&gt; Index.NonNegativeDistance? { … }<br>&gt; 	public func distance(from start:Index, reversedTo end:Index) -&gt; Index.NonNegativeDistance? { … }<br>&gt; <br>&gt; Or something to that effect anyway, with the single-direction index (and formIndex etc.) methods taking the same type?. That’s clever, eliminates the run-time error for distance in many cases with a type-check at compile time instead, neat!<br></p><p>Yes, that&#39;s what I meant.<br></p><p>&gt; <br>&gt; This could actually present an interesting possibility by designing around the fixed direction methods first, e.g- the NonNegativeDistance could be a Uint, and regular Distance would be an enum with .Forward(UInt) and .Backward(UInt) cases. I’m<br></p><p>That&#39;s a good idea! I&#39;d like to see how some real algorithms would look like with that approach.<br></p><p>-Thorsten <br></p><p>&gt; currently porting some of my simpler collections to Swift 3 to get some more experience with the new indexing model and other changes, and this would be a nice way to do it for some of these, rather than relying on a regular Int.<br>&gt; <br>&gt;&gt;&gt; Am 31.05.2016 um 14:46 schrieb Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So for Swift 3 we’re going to have the great new indexing model that performs index manipulation through the collection to which an index belongs.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However, it retains one of the things I didn’t like about the old model, which is that the distinction between forward/backward only types is a bit fuzzy, since the single advancedBy() method, now the index(:offsetBy:) method, was used for both forward and backward movement, which seems contradictory compared to the forward/backward only single-step methods.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Anyway, I’m wondering what people’s thoughts would be on tweaking the formula slightly such that there are methods that only work in a particular direction, i.e- we’d have three main variations of the methods like so:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     public func index(_ index:Index, advancedBy:Index.Distance) -&gt; Index { … } // Available on forward and bidirectional collections<br>&gt;&gt;&gt;     public func index(_ index:Index, reversedBy:Index.Distance) -&gt; Index { … } // Available on reverse and bidirectional collections<br>&gt;&gt;&gt;     public func index(_ index:Index, offsetBy:Index.Distance) -&gt; Index { … } // Available only on bidirectional collections<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (note, the naming isn’t definite, as reversed may not be clear enough, it’s just an example for now)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are three reasons I’d prefer this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The first is that I can pass the same distance into either of the first two methods, and any negation etc. is handled internally. In essence I shouldn’t have to handle negative distances at all when working with the first two methods. So if I’m working with a step size of 5, I can just pass that into the appropriate method, I never have to do anything with it the value itself.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The second benefit is that there should be no uncertainty about the capabilities of the type you’re using; if it doesn’t have the index(:reversedBy:) method then you can’t go backwards, same as index(before:) and index(after:).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The third and main benefit is that the methods are just more explicit about what they do, and what direction you can go in; passing negatives into either of the first two would produce errors outright, allowing you to pick on mistakes in these cases.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The other main thing is that offsetBy doesn’t indicate whether a type supports forward-only offsets, you have to read the documentation to determine this either in the method itself or the type, whereas the presence or absence of the first two variants are pretty clear.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Currently the offsetBy, and the previous advancedBy(), methods require forward-only types to produce fatal errors if handed a negative distance, and vice versa for backward-only types, which can only produce errors at runtime, whereas the presence or absence of the first two methods can be handled during development. You could still pass a negative value and end up with a runtime error instead of course, but for the types of common uses they’re intended for you should be unlikely to produce one.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The offsetBy form would still exist for bidirectional collections, but would only really be used when you need to do more complex index/distance manipulation outside of the type where a calculation might produce either positive or negative values (e.g- if you&#39;re calculating the distance and don’t know where two indices are in relation to each other), the rest of the time you should try to use the more specific, single-direction forms as they clarify your intent and can help to catch mistakes if you’ve incorrectly generated a distance for example.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Just curious what other people’s thoughts are about this?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I intended to mention this a lot sooner (to change advancedBy), but then I find out about the new indexing model so thought I’d wait until afterwards, then completely forgot =)<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160604/988bfd97/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
