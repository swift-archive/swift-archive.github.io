<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/dd033b3ed46d65c7d7394eab52d53e6b?s=50"></div><header><strong>[Proposal] Allow using optional binding to upgrade self from a weak to strong reference</strong> from <string>Evan Maloney</string> &lt;emaloney at gilt.com&gt;<p>February 20, 2016 at 12:00:00am</p></header><div class="content"><p>Hello,<br></p><p>This is an update to the &quot;Allow upgrading weak self to strong self by assignment&quot; proposal I sent earlier. Rewritten to be explicitly limited to optional binding, thanks to some feedback from plx.<br></p><p>Proposal link here:<br></p><p>https://gist.github.com/emaloney/4bfcb21aaced15af8884 &lt;https://gist.github.com/emaloney/4bfcb21aaced15af8884&gt;<br></p><p>The text follows below.<br></p><p>E.<br></p><p>---<br></p><p>Allow using optional binding to upgrade self from a weak to strong reference<br></p><p>Proposal: TBD<br>Author: Evan Maloney &lt;https://github.com/emaloney&gt;<br>Status: Draft<br>Review manager: TBD<br> &lt;https://gist.github.com/emaloney/4bfcb21aaced15af8884#introduction&gt;Introduction<br></p><p>When working with escaping Swift closures, it is a common pattern to have the closure capture self weakly to avoid creating an object reference cycle.<br></p><p>For example, let’s say you have a view controller that displays the result of a network operation. When the view controller is placed onscreen, it starts the operation and provides a closure to be executed upon completion.<br></p><p>The fact that a network operation may be in-flight should not prevent user from navigating away from that view controller. Similarly, we don’t want a pending network operation to prevent our view controller from being deallocated after it goes offscreen. In other words, we only care about the network operation while the view controller is alive; once the view controller has been deallocated, we can safely ignore the result of any network request it initiated.<br></p><p>To achieve this, the networking code might look something like:<br></p><p>networkRequest.fetchData() { [weak self] result in<br>    guard let strongSelf = self else { return }<br></p><p>    switch result {<br>    case .Succeeded(let data):<br>        strongSelf.processData(data)<br></p><p>    case .Failed(let err):<br>        strongSelf.handleError(err)<br>    }<br>}<br>When it comes time to execute this closure, the guard statement effectively asks the question, “Is the view controller represented by self still alive?” If the answer is no, the guard forces a return and the rest of the closure does not execute.<br></p><p>If self is still alive, then the weakly-captured self will be non-nil and it will be converted into a strong reference held by strongSelf for the duration of the closure’s execution.<br></p><p>When the closure finishes, strongSelf goes away, once again making the view controller represented by self eligible for deallocation if no other references are held.<br></p><p> &lt;https://gist.github.com/emaloney/4bfcb21aaced15af8884#the-problem&gt;The Problem<br></p><p>The only available mechanism for upgrading a weak self to a strong reference requires the creation of a self-like variable with an arbitrary name—in the example above, strongSelf.<br></p><p>Because there is no compiler-level mechanism for enforcing a consistent name across an entire codebase, in some instances strongSelf may be ss or it may be s or it may be a random sequence of characters that captures the developer’s mood of the moment.<br></p><p>This lack of consistency adds noise to the codebase, and makes code harder to reason about, especially in cases where the strong reference is held by a variable with a name more cryptic than strongSelf.<br></p><p>Being able to upgrade self from a weak reference to a strong reference while retaining the name self would be ideal, and it would be consistent with the existing Swift convention of optional binding that reuses the name of the optional variable, eg.:<br></p><p>// foo is an optional here<br>if let foo = foo {<br>    // foo is non-optional here;<br>    // the optional foo is masked within this scope<br>}<br>// foo is once again an optional here<br> &lt;https://gist.github.com/emaloney/4bfcb21aaced15af8884#proposed-solution&gt;Proposed Solution<br></p><p>The proposed solution entails allowing self to be upgraded from a weak reference to a strong reference using optional binding.<br></p><p>In any scope where self is a weak reference, the compiler will accept an if or guard statement containing an optional binding that upgrades self to a strong reference.<br></p><p>This would allow self to keep its meaningful name instead of being renamed to something arbitrary.<br></p><p>With this feature, the code above could be rewritten as:<br></p><p>networkRequest.fetchData() { [weak self] result in<br>    guard let self = self else { return }<br></p><p>    switch result {<br>    case .Succeeded(let data):<br>        self.processData(data)<br></p><p>    case .Failed(let err):<br>        self.handleError(err)<br>    }<br>}<br>The following would also be legal:<br></p><p>networkRequest.fetchData() { [weak self] result in<br>    if let self = self {<br>        switch result {<br>        case .Succeeded(let data):<br>            self.processData(data)<br></p><p>        case .Failed(let err):<br>            self.handleError(err)<br>        }<br>    }<br>}<br> &lt;https://gist.github.com/emaloney/4bfcb21aaced15af8884#behavior&gt;Behavior<br></p><p>Regardless of which notation is used for this feature, the behavior is the same:<br></p><p>Once bound, the strong self follows the same scoping rules as any other optionally-bound variable.<br></p><p>While the strong self is in scope, it masks the weak self variable. If the strong reference to self goes out of scope before the weak self reference does, the weak self will once again be visible to code.<br></p><p> &lt;https://gist.github.com/emaloney/4bfcb21aaced15af8884#restrictions&gt;Restrictions<br></p><p>To ensure safety, the compiler will enforce certain restrictions on the use of this feature:<br></p><p>Attempting to use this feature in a context where self is not a weak reference will cause a compiler error. <br></p><p>Binding of self may only be used with let; attempting to bind self to a var is an error. (Because this feature only works with object references and not value types, this restriction does not affect the mutability of self.)<br></p><p> &lt;https://gist.github.com/emaloney/4bfcb21aaced15af8884#impact-on-existing-code&gt;Impact on Existing Code<br></p><p>None, since this does not affect any existing constructs. Implementation of this proposal will not result in any code breakage.<br></p><p> &lt;https://gist.github.com/emaloney/4bfcb21aaced15af8884#alternatives-considered&gt;Alternatives Considered<br></p><p> &lt;https://gist.github.com/emaloney/4bfcb21aaced15af8884#status-quo&gt;Status Quo<br></p><p>The primary alternative is to do nothing, requiring developers to add boilerplate guard code and handle upgrading the weak-to-strong references manually.<br></p><p>As stated above, this leads to needless boilerplate that can easily be factored out by the compiler. Also, the use of a self-like variable with an arbitrary name makes it more difficult to exhaustively find such uses in large projects.<br></p><p>Finally, the need to declare and use alternate names to capture values that already have existing names adds visual clutter to code and serves to obscure the code’s original intent, making it harder to reason about.<br></p><p> &lt;https://gist.github.com/emaloney/4bfcb21aaced15af8884#adding-a-new-guard-capture-type&gt;Adding a new guard capture type<br></p><p>An alternate to this proposal involves adding a new capture type, called guard &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440&gt;, which would automatically handle upgrading self (and other references) from weak to strong.<br></p><p>Although the alternate proposal received a favorable response from the Swift Evolution mailing list, the community seemed split between the approach outlined in that proposal, and the one outlined here.<br></p><p> &lt;https://gist.github.com/emaloney/4bfcb21aaced15af8884#citations&gt;Citations<br></p><p>Variations on this proposal were discussed earlier in the following swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt; threads:<br></p><p>Wanted: syntactic sugar for [weak self] callbacks &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160201/008713.html&gt;<br>Allowing guard let self = self else { … } for weakly captured self in a closure. &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160201/009023.html&gt;<br>[Draft Proposal] A simplified notation for avoiding the weak/strong dance with closure capture lists &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160201/009241.html&gt;<br>[Proposal Update 1] A simplified notation for avoiding the weak/strong dance with closure capture lists &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160208/009972.html&gt;<br>[Proposal] Allow upgrading weak self to strong self by assignment &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160215/010691.html&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160220/7d93a8be/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>[Proposal] Allow using optional binding to upgrade self from a weak to strong reference</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>February 20, 2016 at 05:00:00am</p></header><div class="content"><p>I like this proposal. It allows the most freedom in how to deal with now<br>nil captured weak references and does it in a simple language consistent<br>way.<br></p><p>-Shawn<br>On Fri, Feb 19, 2016 at 9:04 PM Evan Maloney &lt;emaloney at gilt.com&gt; wrote:<br></p><p>&gt; Hello,<br>&gt;<br>&gt; This is an update to the &quot;Allow upgrading weak self to strong self by<br>&gt; assignment&quot; proposal I sent earlier. Rewritten to be explicitly limited to<br>&gt; optional binding, thanks to some feedback from plx.<br>&gt;<br>&gt; Proposal link here:<br>&gt;<br>&gt; https://gist.github.com/emaloney/4bfcb21aaced15af8884<br>&gt;<br>&gt; The text follows below.<br>&gt;<br>&gt; E.<br>&gt;<br>&gt; ---<br>&gt;<br>&gt; Allow using optional binding to upgrade self from a weak to strong<br>&gt; reference<br>&gt;<br>&gt;    - Proposal: TBD<br>&gt;    - Author: Evan Maloney &lt;https://github.com/emaloney&gt;<br>&gt;    - Status: *Draft*<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt; &lt;https://gist.github.com/emaloney/4bfcb21aaced15af8884#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; When working with escaping Swift closures, it is a common pattern to have<br>&gt; the closure capture self weakly to avoid creating an object reference<br>&gt; cycle.<br>&gt;<br>&gt; For example, let’s say you have a view controller that displays the result<br>&gt; of a network operation. When the view controller is placed onscreen, it<br>&gt; starts the operation and provides a closure to be executed upon completion.<br>&gt;<br>&gt; The fact that a network operation may be in-flight should not prevent user<br>&gt; from navigating away from that view controller. Similarly, we don’t want a<br>&gt; pending network operation to prevent our view controller from being<br>&gt; deallocated after it goes offscreen. In other words, we only care about the<br>&gt; network operation while the view controller is alive; once the view<br>&gt; controller has been deallocated, we can safely ignore the result of any<br>&gt; network request it initiated.<br>&gt;<br>&gt; To achieve this, the networking code might look something like:<br>&gt;<br>&gt; networkRequest.fetchData() { [weak self] result in<br>&gt;     guard let strongSelf = self else { return }<br>&gt;<br>&gt;     switch result {<br>&gt;     case .Succeeded(let data):<br>&gt;         strongSelf.processData(data)<br>&gt;<br>&gt;     case .Failed(let err):<br>&gt;         strongSelf.handleError(err)<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; When it comes time to execute this closure, the guard statement<br>&gt; effectively asks the question, “Is the view controller represented by self still<br>&gt; alive?” If the answer is no, the guard forces a return and the rest of the<br>&gt; closure does not execute.<br>&gt;<br>&gt; If self *is* still alive, then the weakly-captured self will be non-nil and<br>&gt; it will be converted into a strong reference held by strongSelf for the<br>&gt; duration of the closure’s execution.<br>&gt;<br>&gt; When the closure finishes, strongSelf goes away, once again making the<br>&gt; view controller represented by self eligible for deallocation if no other<br>&gt; references are held.<br>&gt; &lt;https://gist.github.com/emaloney/4bfcb21aaced15af8884#the-problem&gt;The<br>&gt; Problem<br>&gt;<br>&gt; The only available mechanism for upgrading a weak self to a strong<br>&gt; reference requires the creation of a self-like variable with an arbitrary<br>&gt; name—in the example above, strongSelf.<br>&gt;<br>&gt; Because there is no compiler-level mechanism for enforcing a consistent<br>&gt; name across an entire codebase, in some instances strongSelf may be ss or<br>&gt; it may be s or it may be a random sequence of characters that captures<br>&gt; the developer’s mood of the moment.<br>&gt;<br>&gt; This lack of consistency adds noise to the codebase, and makes code harder<br>&gt; to reason about, especially in cases where the strong reference is held by<br>&gt; a variable with a name more cryptic than strongSelf.<br>&gt;<br>&gt; Being able to upgrade self from a weak reference to a strong reference<br>&gt; while retaining the name self would be ideal, and it would be consistent<br>&gt; with the existing Swift convention of optional binding that reuses the name<br>&gt; of the optional variable, eg.:<br>&gt;<br>&gt; // foo is an optional hereif let foo = foo {<br>&gt;     // foo is non-optional here;<br>&gt;     // the optional foo is masked within this scope<br>&gt; }// foo is once again an optional here<br>&gt;<br>&gt; &lt;https://gist.github.com/emaloney/4bfcb21aaced15af8884#proposed-solution&gt;Proposed<br>&gt; Solution<br>&gt;<br>&gt; The proposed solution entails allowing self to be upgraded from a weak<br>&gt; reference to a strong reference using optional binding.<br>&gt;<br>&gt; In any scope where self is a weak reference, the compiler will accept an<br>&gt; if or guard statement containing an optional binding that upgrades self to<br>&gt; a strong reference.<br>&gt;<br>&gt; This would allow self to keep its meaningful name instead of being<br>&gt; renamed to something arbitrary.<br>&gt;<br>&gt; With this feature, the code above could be rewritten as:<br>&gt;<br>&gt; networkRequest.fetchData() { [weak self] result in<br>&gt;     guard let self = self else { return }<br>&gt;<br>&gt;     switch result {<br>&gt;     case .Succeeded(let data):<br>&gt;         self.processData(data)<br>&gt;<br>&gt;     case .Failed(let err):<br>&gt;         self.handleError(err)<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; The following would also be legal:<br>&gt;<br>&gt; networkRequest.fetchData() { [weak self] result in<br>&gt;     if let self = self {<br>&gt;         switch result {<br>&gt;         case .Succeeded(let data):<br>&gt;             self.processData(data)<br>&gt;<br>&gt;         case .Failed(let err):<br>&gt;             self.handleError(err)<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; &lt;https://gist.github.com/emaloney/4bfcb21aaced15af8884#behavior&gt;Behavior<br>&gt;<br>&gt; Regardless of which notation is used for this feature, the behavior is the<br>&gt; same:<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    Once bound, the strong self follows the same scoping rules as any<br>&gt;    other optionally-bound variable.<br>&gt;    -<br>&gt;<br>&gt;    While the strong self is in scope, it masks the weak self variable. If<br>&gt;    the strong reference to self goes out of scope before the weak self reference<br>&gt;    does, the weak self will once again be visible to code.<br>&gt;<br>&gt; &lt;https://gist.github.com/emaloney/4bfcb21aaced15af8884#restrictions&gt;<br>&gt; Restrictions<br>&gt;<br>&gt; To ensure safety, the compiler will enforce certain restrictions on the<br>&gt; use of this feature:<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    Attempting to use this feature in a context where self is not a weak<br>&gt;    reference will cause a compiler error.<br>&gt;    -<br>&gt;<br>&gt;    Binding of self may only be used with let; attempting to bind self to<br>&gt;    a var is an error. (Because this feature only works with object<br>&gt;    references and not value types, this restriction does not affect the<br>&gt;    mutability of self.)<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/emaloney/4bfcb21aaced15af8884#impact-on-existing-code&gt;Impact<br>&gt; on Existing Code<br>&gt;<br>&gt; None, since this does not affect any existing constructs. Implementation<br>&gt; of this proposal will not result in any code breakage.<br>&gt;<br>&gt; &lt;https://gist.github.com/emaloney/4bfcb21aaced15af8884#alternatives-considered&gt;Alternatives<br>&gt; Considered<br>&gt; &lt;https://gist.github.com/emaloney/4bfcb21aaced15af8884#status-quo&gt;Status<br>&gt; Quo<br>&gt;<br>&gt; The primary alternative is to do nothing, requiring developers to add<br>&gt; boilerplate guard code and handle upgrading the weak-to-strong references<br>&gt; manually.<br>&gt;<br>&gt; As stated above, this leads to needless boilerplate that can easily be<br>&gt; factored out by the compiler. Also, the use of a self-like variable with<br>&gt; an arbitrary name makes it more difficult to exhaustively find such uses in<br>&gt; large projects.<br>&gt;<br>&gt; Finally, the need to declare and use alternate names to capture values<br>&gt; that already have existing names adds visual clutter to code and serves to<br>&gt; obscure the code’s original intent, making it harder to reason about.<br>&gt;<br>&gt; &lt;https://gist.github.com/emaloney/4bfcb21aaced15af8884#adding-a-new-guard-capture-type&gt;Adding<br>&gt; a new guard capture type<br>&gt;<br>&gt; An alternate to this proposal involves adding a new capture type, called<br>&gt; guard &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440&gt;, which<br>&gt; would automatically handle upgrading self (and other references) from<br>&gt; weak to strong.<br>&gt;<br>&gt; Although the alternate proposal received a favorable response from the<br>&gt; Swift Evolution mailing list, the community seemed split between the<br>&gt; approach outlined in that proposal, and the one outlined here.<br>&gt; &lt;https://gist.github.com/emaloney/4bfcb21aaced15af8884#citations&gt;Citations<br>&gt;<br>&gt; Variations on this proposal were discussed earlier in the following<br>&gt; swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  threads:<br>&gt;<br>&gt;    - Wanted: syntactic sugar for [weak self] callbacks<br>&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160201/008713.html&gt;<br>&gt;    - Allowing guard let self = self else { … } for weakly captured self<br>&gt;    in a closure.<br>&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160201/009023.html&gt;<br>&gt;    - [Draft Proposal] A simplified notation for avoiding the weak/strong<br>&gt;    dance with closure capture lists<br>&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160201/009241.html&gt;<br>&gt;    - [Proposal Update 1] A simplified notation for avoiding the<br>&gt;    weak/strong dance with closure capture lists<br>&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160208/009972.html&gt;<br>&gt;    - [Proposal] Allow upgrading weak self to strong self by assignment<br>&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160215/010691.html&gt;<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160220/e02a029c/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/27ca9066ad05bd8aa9ec366115f3cd38?s=50"></div><header><strong>[Proposal] Allow using optional binding to upgrade self from a weak to strong reference</strong> from <string>Kurt Werle</string> &lt;kurt at circlew.org&gt;<p>February 19, 2016 at 10:00:00pm</p></header><div class="content"><p>On Fri, Feb 19, 2016 at 9:04 PM, Evan Maloney &lt;emaloney at gilt.com&gt; wrote:<br></p><p>...<br></p><p>&gt; With this feature, the code above could be rewritten as:<br>&gt;<br>&gt; networkRequest.fetchData() { [weak self] result in<br>&gt;     guard let self = self else { return }<br>&gt;<br>&gt; If you&#39;re going to have boilerplate like that, then the following seems<br>like it accomplishes the same thing [in this specific case] without<br>changing anything:<br></p><p>networkRequest.fetchData() { [unowned self] result in<br>&gt;     guard self != nil else { return }<br>&gt;<br>&gt;<br>Kurt<br>-- <br>kurt at CircleW.org<br>http://www.CircleW.org/kurt/<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160219/4c199f4f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>[Proposal] Allow using optional binding to upgrade self from a weak to strong reference</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>February 20, 2016 at 07:00:00am</p></header><div class="content"><p>True, however only if unowned works in terms of the desired object life<br>time / &quot;ownership&quot; for self. It isn&#39;t always sufficient so weak is needed<br>to avoid the retain cycle while safely supporting self becoming nil (e.g.<br>allowing the object referenced by self to go away while the block may still<br>be outstanding). The proposal outlines at least one example of that need<br>and is written assuming you need to use weak.<br>On Fri, Feb 19, 2016 at 10:15 PM Kurt Werle &lt;kurt at circlew.org&gt; wrote:<br></p><p>&gt; On Fri, Feb 19, 2016 at 9:04 PM, Evan Maloney &lt;emaloney at gilt.com&gt; wrote:<br>&gt;<br>&gt; ...<br>&gt;<br>&gt;&gt; With this feature, the code above could be rewritten as:<br>&gt;&gt;<br>&gt;&gt; networkRequest.fetchData() { [weak self] result in<br>&gt;&gt;     guard let self = self else { return }<br>&gt;&gt;<br>&gt;&gt; If you&#39;re going to have boilerplate like that, then the following seems<br>&gt; like it accomplishes the same thing [in this specific case] without<br>&gt; changing anything:<br>&gt;<br>&gt; networkRequest.fetchData() { [unowned self] result in<br>&gt;&gt;     guard self != nil else { return }<br>&gt;&gt;<br>&gt;&gt;<br>&gt; Kurt<br>&gt; --<br>&gt; kurt at CircleW.org<br>&gt; http://www.CircleW.org/kurt/<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160220/ed2b8d3b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/27ca9066ad05bd8aa9ec366115f3cd38?s=50"></div><header><strong>[Proposal] Allow using optional binding to upgrade self from a weak to strong reference</strong> from <string>Kurt Werle</string> &lt;kurt at circlew.org&gt;<p>February 19, 2016 at 11:00:00pm</p></header><div class="content"><p>Arg!  My mistake - I did not realize you can&#39;t test an unowned to be nil<br>like you can an implicitly unwrapped variable.<br></p><p>On Fri, Feb 19, 2016 at 11:03 PM, Shawn Erickson &lt;shawnce at gmail.com&gt; wrote:<br></p><p>&gt; True, however only if unowned works in terms of the desired object life<br>&gt; time / &quot;ownership&quot; for self. It isn&#39;t always sufficient so weak is needed<br>&gt; to avoid the retain cycle while safely supporting self becoming nil (e.g.<br>&gt; allowing the object referenced by self to go away while the block may still<br>&gt; be outstanding). The proposal outlines at least one example of that need<br>&gt; and is written assuming you need to use weak.<br>&gt;<br>&gt; On Fri, Feb 19, 2016 at 10:15 PM Kurt Werle &lt;kurt at circlew.org&gt; wrote:<br>&gt;<br>&gt;&gt; On Fri, Feb 19, 2016 at 9:04 PM, Evan Maloney &lt;emaloney at gilt.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; ...<br>&gt;&gt;<br>&gt;&gt;&gt; With this feature, the code above could be rewritten as:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; networkRequest.fetchData() { [weak self] result in<br>&gt;&gt;&gt;     guard let self = self else { return }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If you&#39;re going to have boilerplate like that, then the following seems<br>&gt;&gt; like it accomplishes the same thing [in this specific case] without<br>&gt;&gt; changing anything:<br>&gt;&gt;<br>&gt;&gt; networkRequest.fetchData() { [unowned self] result in<br>&gt;&gt;&gt;     guard self != nil else { return }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; Kurt<br>&gt;&gt; --<br>&gt;&gt; kurt at CircleW.org<br>&gt;&gt; http://www.CircleW.org/kurt/<br>&gt;&gt;<br>&gt;<br></p><p><br>-- <br>kurt at CircleW.org<br>http://www.CircleW.org/kurt/<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160219/cf43f6c2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>[Proposal] Allow using optional binding to upgrade self from a weak to strong reference</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>February 20, 2016 at 01:00:00pm</p></header><div class="content"><p>Even if that would be possible, you’d need to ensure that the RC of the object is not reduced to zero between your check and the end of the closure (that was the criticism with the first version of Evan’s proposal). I also read your comment sin the other thread and they seem quite focused on the unowned self case. I am not sure that its that frequent. When you sue closures for callbacks and/or signals, using weak self makes more sense to me. Another problem I have with the alternative proposal (guard self in the capture list) is that it does not offer an obvious way to remove the closure once the object leaves the scope. Imagine that I am using closures for some sort of observing or notification mechanism. There can potentially be many short-lived objects who receive notifications from a single source. With Evan’s proposal, I can do something like this:<br></p><p>guard self = self  else  { remove the current closure from the notification list; return }<br></p><p>I don’t see an obvious way to accomplish this in the alternative proposal. <br></p><p>Best, <br></p><p> Taras <br></p><p><br>&gt; On 20 Feb 2016, at 08:52, Kurt Werle &lt;kurt at circlew.org&gt; wrote:<br>&gt; <br>&gt; Arg!  My mistake - I did not realize you can&#39;t test an unowned to be nil like you can an implicitly unwrapped variable.<br>&gt; <br>&gt; On Fri, Feb 19, 2016 at 11:03 PM, Shawn Erickson &lt;shawnce at gmail.com &lt;mailto:shawnce at gmail.com&gt;&gt; wrote:<br>&gt; True, however only if unowned works in terms of the desired object life time / &quot;ownership&quot; for self. It isn&#39;t always sufficient so weak is needed to avoid the retain cycle while safely supporting self becoming nil (e.g. allowing the object referenced by self to go away while the block may still be outstanding). The proposal outlines at least one example of that need and is written assuming you need to use weak.<br>&gt; <br>&gt; On Fri, Feb 19, 2016 at 10:15 PM Kurt Werle &lt;kurt at circlew.org &lt;mailto:kurt at circlew.org&gt;&gt; wrote:<br>&gt; On Fri, Feb 19, 2016 at 9:04 PM, Evan Maloney &lt;emaloney at gilt.com &lt;mailto:emaloney at gilt.com&gt;&gt; wrote:<br>&gt; <br>&gt; ... <br>&gt; With this feature, the code above could be rewritten as:<br>&gt; <br>&gt; networkRequest.fetchData() { [weak self] result in<br>&gt;     guard let self = self else { return }<br>&gt; If you&#39;re going to have boilerplate like that, then the following seems like it accomplishes the same thing [in this specific case] without changing anything:<br>&gt; <br>&gt; networkRequest.fetchData() { [unowned self] result in<br>&gt;     guard self != nil else { return }<br>&gt;  <br>&gt; Kurt<br>&gt; -- <br>&gt; kurt at CircleW.org<br>&gt; http://www.CircleW.org/kurt/ &lt;http://www.circlew.org/kurt/&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; kurt at CircleW.org<br>&gt; http://www.CircleW.org/kurt/ &lt;http://www.circlew.org/kurt/&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160220/42d6db27/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
