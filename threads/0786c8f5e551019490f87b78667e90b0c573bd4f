<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0735d3bf1d76c0385258ac7a2a22d6fe?s=50"></div><header><strong>[Review] SE-0117: Default classes to benon-subclassable publicly</strong> from <string>Károly Lőrentey</string> &lt;karoly at lorentey.hu&gt;<p>July 12, 2016 at 12:00:00am</p></header><div class="content"><p>On 2016-07-11 08:42:33 +0000, Tino Heth via swift-evolution said:<br></p><p>&gt; <br>&gt;&gt; The justification for this proposal is all about supporting the people <br>&gt;&gt; who are working to design library APIs right, and about maintaining <br>&gt;&gt; consistency with the design philosophy of Swift. To wit: in Swift, <br>&gt;&gt; where there’s a default choice, it’s the safe one;<br>&gt; I challenge this claim:<br>&gt; Safety is valued, but Swift cares (and should care!) about pragmatism <br>&gt; as well… the most obvious example that comes to my mind are arrays, <br>&gt; which have no safeguards that stop you from accessing elements that <br>&gt; aren&#39;t there.<br></p><p>I&#39;m not sure I understand this point. First, a guaranteed runtime trap <br>on an out-of-bounds index is a *massive* safety improvement over what <br>we had in C/C++/Objective-C.<br>Second, safety is explicitly goal #1 for Swift; it&#39;s even more <br>important than performance and expressiveness (although fortunately <br>these aren&#39;t always at odds).<br></p><p>&gt;&gt; where there’s a consequential design decision, it’s explicit.<br>&gt; When there is no explicit statement about subclassiblily, it&#39;s <br>&gt; reasonable to assume that there hasn&#39;t been a consequential design <br>&gt; decision… but sadly, discussion like this mainly driven by dogmatism, <br>&gt; because there is no evidence for either side.<br></p><p>I&#39;ve made some notes of the arguments (pro and con) that I&#39;ve seen in <br>this thread and elsewhere; see them below. I think we have seen ample <br>evidence in support for most of them, from both sides. As usual, our <br>differences are difficult/impossible to reconcile. People may have <br>become a bit theatrical at times, but the discussions I&#39;ve read have <br>been far from dogmatic.<br></p><p>Thankfully we can rely on the core team to break the stalemate. (I <br>think it&#39;s safe to say that despite all the drama, things will turn out <br>OK either way. Things generally do.)<br></p><p>I&#39;m firmly in the +1 camp, so take my summary of the arguments against <br>the proposal with a grain of salt. For what it&#39;s worth, I am <br>sympathetic to most of the -1 arguments; I just find them less <br>convincing in contrast. Some of the labels are somewhat bombastic; <br>sorry about that.<br></p><p><br></p><p><br></p><p>## Arguments for SE-0117<br></p><p>- Doctrine: Safety is the most important design goal of Swift, and <br>having to opt-in to cross-module subclassing has been demonstrated to <br>be the safer choice.<br></p><p>- Authority: We&#39;ve seen that in some OOP communities, &quot;Explicitly <br>design for subclassing or else prohibit it&quot; has been a well-known and <br>highly regarded API design advice for decades.<br></p><p>- Precedent: Kotlin&#39;s designers made the (admittedly questionable) <br>decision of making final classes the default; the world didn&#39;t end. <br>(And SE-0117 proposes a much better approach than that.) Moreover, Rust <br>and Go are examples of popular languages that have decided to <br>completely get rid of (implementation) inheritance; again, the sky did <br>not fall on the heads of their designers: these languages have grown <br>quite popular regardless of this decision. (Note though that nobody is <br>suggesting to remove subclassing from Swift.)<br></p><p>- Convenience: For small-scale library developers, it becomes a little <br>easier to create and maintain well-designed reusable Swift modules, by <br>not having to remember to disable external subclassing whenever a new <br>public class is created. Large-scale framework developers like Apple <br>will remain able to do whatever they want, regardless of this proposal.<br></p><p>- Sensible Defaults: Accidentally leaving a class sealed can be easily <br>fixed in a point release; accidentally leaving a class open can only be <br>fixed by a major API version bump, because closing a class may break <br>existing client code. (Provided that you care about strict API <br>versioning.) So it makes sense to make the less damaging choice the <br>default.<br></p><p>- Design Variety: Allowing sealed classes (either opt-in or opt-out) <br>makes it possible to make class-hierarchies public without the burden <br>of preparing for external subclasses. This makes certain API design <br>patterns easier to implement in Swift. Ironically, introducing sealed <br>classes may thus make subclassing *more* popular in carefully designed <br>Swift packages.<br></p><p>- Performance: Sealing classes by default may enable the compiler to <br>eliminate dynamic dispatch in more cases where allowing overrides was <br>never intended. This may sometimes lead to meaningfully faster code.<br></p><p>- Limited Scope: Because the proposal only restricts subclassing across <br>module boundaries, and because Swift already has a clear bias towards <br>value types and protocol-oriented programming, and because final is <br>already in widespread use in the language, many or most Swift users <br>would not actually be significantly affected by this change.<br></p><p>- Education: The proposal gently encourages Swift users to think about <br>ways other than subclassing to solve problems. Previous experience with <br>the complexity of subclassing has lead to it gaining something of a bad <br>reputation. This has made it unfashionable in the trendier section of <br>the programming community, who are always very enthusiastic to offer <br>advice about better approaches, and some of whom aren&#39;t even shy about <br>showing their monads in public.<br></p><p>- Auditing: Some coding conventions discourage the use of subclassing <br>in public APIs. Modules that expose APIs where the user *needs* to <br>subclass would become easier to spot if this proposal was accepted. <br>Programmers who&#39;re particularly pedantic and/or battle-scarred would be <br>able to easily spot open classes and treat them as an obvious code <br>smell.<br></p><p><br></p><p>## Arguments against SE-0117<br></p><p>- Pragmatism: Working around bugs by monkey patching closed-source <br>libraries becomes even harder to pull off than it already is. An <br>ecosystem of carefully designed and bug-free modules is a pipe dream; <br>in the real world, packages are quickly hacked together with little if <br>any consideration to concerns of the ivory tower people. My <br>dependencies are full of bugs that upstream authors cannot or will not <br>fix in time for my next release.<br></p><p>- Extendability: Subclassing is an important way to extend third-party <br>classes with new functionality, and this proposal would often remove <br>people&#39;s ability to do this. Library authors will never be able to <br>predict all the ways their code will need to be extended. Some <br>important classes of functionality cannot easily be added via class <br>extensions and/or composition. Library authors should expect no right <br>to restrict the ways their library may or may not be used and extended.<br></p><p>- Senseless Defaults: The design as proposed arguably provides a slight <br>benefit to authors of well-designed libraries, but it will make subpar <br>libraries *much* worse. Lazy library authors will leave subclassing <br>disabled even though they might not object against subclassing at all. <br>This will lead to a plague of one-liner pull requests to open up <br>classes.<br></p><p>- Tradition: Mainstream 80s/90s-era OOP languages invariably leave <br>classes open by default. Newcomers would be shocked to find that Swift <br>is doing otherwise. The proposal introduces a frustrating quirk into <br>the language with at best marginal benefits in exchange.<br></p><p>- Annoyance: People will need to remember to manually add an extra <br>keyword to their public classes whenever they want to allow <br>subclassing. People who want to always allow cross-module subclassing <br>will always have to add the keyword. The extra work to do this would be <br>annoying and pointless, and the proliferation of such additional <br>keywords would make Swift needlessly wordy.<br></p><p>- Unit testing: The common (if messy) Objective-C / Java approach to <br>mocking an external class by subclassing it and overriding every method <br>becomes even more impossible in Swift. (I can&#39;t recall anyone actually <br>making this argument, but it would&#39;ve been an interesting point.)<br></p><p>- Incompleteness: This proposal does not go far enough; if we prefer to <br>go in this direction, nothing less than requiring a formal description <br>of the subclass-superclass API will do. Enabling module-external <br>subclassing by the simple addition of a keyword would be irresponsible.<br></p><p>- Slippery Slope: SE-0117 adds yet another entry to the already huge <br>list of things in Swift that subtly or openly discourage people from <br>subclassing. How far are we from someone seriously proposing to <br>outright rip inheritance out of the language? Enough is enough. Stop <br>with the anti-subclassing propaganda. Implementation inheritance is a <br>hugely important core language feature whose popularity should be <br>preserved and whose use should be encouraged and celebrated.<br></p><p>- Heresy: Some people don&#39;t like programming languages that take away <br>their freedom to do however they please. People should be trusted to <br>use their tools well; even if they&#39;re slightly dangerous. Freedom over <br>bureaucracy!<br></p><p>- The Weirdo Argument: This list represents a very curious subset of <br>Swift developers, who are very different to the vast majority of people <br>using Swift. Normal people just want to get their work done, and they <br>would be infuriated if such a change would be implemented. This list is <br>a quite exotic bubble, and it can be fatal to assume that it is <br>representative for the mass of developers that have to deal with the <br>consequences of its discussions. Programming languages are best evolved <br>in a strictly democratic manner.<br></p><p>* * *<br></p><p>Sorry if I left something off, or if I misrepresented an argument. <br>(This is a huge thread.) I had some trouble making sense of the last <br>two or three arguments, so they&#39;re especially unlikely to represent <br>people&#39;s actual opinions.<br></p><p>-- <br>Károly<br>@lorentey<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c65faa002b79348ac10e1fb9c1a9ad83?s=50"></div><header><strong>[Review] SE-0117: Default classes to benon-subclassable publicly</strong> from <string>Colin Cornaby</string> &lt;colin.cornaby at mac.com&gt;<p>July 11, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; - Slippery Slope: SE-0117 adds yet another entry to the already huge list of things in Swift that subtly or openly discourage people from subclassing. How far are we from someone seriously proposing to outright rip inheritance out of the language? Enough is enough. Stop with the anti-subclassing propaganda. Implementation inheritance is a hugely important core language feature whose popularity should be preserved and whose use should be encouraged and celebrated.<br></p><p>This is another reason I’m unclear on the reasoning behind this proposal, but I could be missing something… Structs have been pushed in Swift primarily as classes without polymorphism. One would think that one of the primary reasons to adopt a class structure in Swift is polymorphism. It seems backwards to make the point of a class primarily polymorphism, and then disable it by default.<br></p><p>I suppose you could make the case you’d want to inherit from a parent class but not allow other classes to inherit from you. This just seems like more of a mess though. I could have vendors shipping me view controllers that I can’t inherit from, complicating my own designs.<br></p><p>(The other big reason I still use a lot of classes in Swift is Cocoa compatibility, but I’m assuming Obj-C compatible Swift objects won’t support final or final-by-default anyway.)<br></p><p>Someone correct me if I’m missing something big here though.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0735d3bf1d76c0385258ac7a2a22d6fe?s=50"></div><header><strong>[Review] SE-0117: Default classes to benon-subclassable publicly</strong> from <string>Károly Lőrentey</string> &lt;karoly at lorentey.hu&gt;<p>July 12, 2016 at 02:00:00am</p></header><div class="content"><p>&gt; On 2016-07-12, at 01:54, Colin Cornaby &lt;colin.cornaby at mac.com&gt; wrote:<br>&gt; <br>&gt;&gt; - Slippery Slope: SE-0117 adds yet another entry to the already huge list of things in Swift that subtly or openly discourage people from subclassing. How far are we from someone seriously proposing to outright rip inheritance out of the language? Enough is enough. Stop with the anti-subclassing propaganda. Implementation inheritance is a hugely important core language feature whose popularity should be preserved and whose use should be encouraged and celebrated.<br>&gt; <br>&gt; This is another reason I’m unclear on the reasoning behind this proposal, but I could be missing something… Structs have been pushed in Swift primarily as classes without polymorphism. One would think that one of the primary reasons to adopt a class structure in Swift is polymorphism. It seems backwards to make the point of a class primarily polymorphism, and then disable it by default.<br></p><p>Classes are the only way to create a reference type in Swift. In idiomatic Swift code, classes are frequently employed for this exact feature alone (to e.g. implement copy-on-write storage).<br></p><p>Subtype polymorphism is an additional feature that is (while obviously important and useful elsewhere) frequently unwanted in this context. One can easily imagine a bizarro alternate universe where Swift classes do not support subclassing at all, and they would still remain a quite useful construct. Polymorphism (when needed) is often better achieved using protocols rather than subclassing, anyway.<br></p><p>(Note that we clearly do not live in that universe. I don’t think it would be a good idea to remove subclassing from Swift.)<br></p><p>&gt; I suppose you could make the case you’d want to inherit from a parent class but not allow other classes to inherit from you. This just seems like more of a mess though. I could have vendors shipping me view controllers that I can’t inherit from, complicating my own designs.<br></p><p>We already have final, so this is already the case today. For what it’s worth, I’ve already made many of my own view controllers final; but I’m not vending them out to people.<br></p><p>&gt; (The other big reason I still use a lot of classes in Swift is Cocoa compatibility, but I’m assuming Obj-C compatible Swift objects won’t support final or final-by-default anyway.)<br></p><p>That is a good question; @objc and final are not mutually exclusive today. I think cross-module subclassibility should work the same way.<br></p><p>&gt; Someone correct me if I’m missing something big here though.<br></p><p><br>-- <br>Karoly<br>@lorentey<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Review] SE-0117: Default classes to benon-subclassable publicly</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>July 12, 2016 at 08:00:00am</p></header><div class="content"><p>&gt;&gt; Safety is valued, but Swift cares (and should care!) about pragmatism as well… the most obvious example that comes to my mind are arrays, which have no safeguards that stop you from accessing elements that aren&#39;t there.<br>&gt; <br>&gt; I&#39;m not sure I understand this point. First, a guaranteed runtime trap on an out-of-bounds index is a *massive* safety improvement over what we had in C/C++/Objective-C.<br>… but still, it wouldn&#39;t it be much safer to return an optional?<br></p><p>&gt; Second, safety is explicitly goal #1 for Swift; it&#39;s even more important than performance and expressiveness (although fortunately these aren&#39;t always at odds).<br>Reality is more complicated, and it&#39;s hard to measure safety — sometimes it is not even possible to compare two different solutions in terms of general safety.<br>In the array-example, safety doesn&#39;t trump over performance &amp; convenience, and I wouldn&#39;t want to use a language without such exceptions (which would mean that even a infinitesimally increase in safety would justify a huge loss in performance, expressiveness and convenience).<br></p><p>&gt; I&#39;ve made some notes of the arguments (pro and con) that I&#39;ve seen in this thread and elsewhere; see them below. I think we have seen ample evidence in support for most of them, from both sides. As usual, our differences are difficult/impossible to reconcile. People may have become a bit theatrical at times, but the discussions I&#39;ve read have been far from dogmatic.<br>Well, there are some of us who could reconcile their differences — simply be choosing neither sealed nor extendable to be the default… imho this would be the best match for the situation, but &quot;force override&quot; doesn&#39;t seem to gain much interest.<br></p><p>I would have chosen a different order, but overall, imho your list looks like you honestly tried to avoid bias — and maybe even achieved this high goal.<br>Only two tiny additions:<br>&gt; - The Weirdo Argument: This list represents a very curious subset of Swift developers, who are very different to the vast majority of people using Swift. Normal people just want to get their work done, and they would be infuriated if such a change would be implemented. This list is a quite exotic bubble, and it can be fatal to assume that it is representative for the mass of developers that have to deal with the consequences of its discussions. Programming languages are best evolved in a strictly democratic manner.<br>As this point closely matches my wording, I have to correct it.<br>I never said Swift should be evolved in a democratic manner at all, and I absolutely don&#39;t think it should.<br>What I said is that the members of this list are not representative for the majority of developers using Swift, because only a small and somewhat uniform subset is inclined to take part in the discussions.<br>I guess it&#39;s save to assume that there some common characteristics which are much less dominant outside this circle:<br>- Interest in language design<br>- A certain degree of theoretical background<br>- A stable opinion on how software should be written<br>- Spending time for theoretical discussions instead of developing actual software ;-)<br>So, this list is definitely some sort of ivory tower, and there is a constant danger for Swift to become a language that pleases a small elite, but ignores the needs of the majority — and I think that Swift specifically aims for the majority.<br>I myself enjoy over-engineering my code and discard working solutions in favor for a more elegant design, but I know that this is not representative, and I accept reality… and that is that there are many projects built in a fashion that is completely different from how it&#39;s said in the books.<br>&quot;Design for inheritance&quot; is a good idea (not only in theory), but many codebases have hardly any design at all, simply because its author doesn&#39;t have enough knowledge to do better.<br>There is a good motivation to punish bad design, but bad design is quite indifferent about torture, so the only perception of the uninformed developer is that he himself is punished by the language for reasons beyond his interest:<br>The compiler cannot educate its users, because all they perceive is an annoying call to switch to another file and perform a trivial change.<br></p><p>That&#39;s already more text than I wanted to write, but there&#39;s still an argument left that&#39;s particular important to me:<br>Choice of defaults is a statement, and therefor relevant for the character of the language — and what this proposal says about Swift is &quot;keep control to yourself, restrict other developers and focus on concealment&quot;.<br>For me, those aren&#39;t traits worth striving for.<br></p><p>Tino<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>[Review] SE-0117: Default classes to benon-subclassable publicly</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>July 12, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On 12 Jul 2016, at 4:53 PM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; Safety is valued, but Swift cares (and should care!) about pragmatism as well… the most obvious example that comes to my mind are arrays, which have no safeguards that stop you from accessing elements that aren&#39;t there.<br>&gt;&gt; <br>&gt;&gt; I&#39;m not sure I understand this point. First, a guaranteed runtime trap on an out-of-bounds index is a *massive* safety improvement over what we had in C/C++/Objective-C.<br>&gt; … but still, it wouldn&#39;t it be much safer to return an optional?\<br></p><p>Tino,<br></p><p>This argument comes up often, but I side with some of the smartest people in the industry who say the safest thing to do is actually crash, just like Swift does in this case.<br></p><p>If you are accessing an element in an array that doesn’t exist, you didn’t reason about the contents of said array correctly. Therefore, whatever you were planning to do, something in your logic is seriously wrong. It’s safer to say “Stop!” at this stage, rather than let you proceed further into the bug infested mess you’re about to walk into. Other side effects might occur, both in your model code, and you may also be leaving your UI in a completely random and inconsistent state. Flow on effects could even include deleting incorrect files from disk if you’re using the array to store file URLs, and because you don’t know your indexes correctly, you’re risking deleting the wrong file.<br></p><p>Experience has shown that it is safer to bring your software to a very abrupt stop rather than hope you can handle this situation. After all… you clearly don’t know about your current state, so how can you know how to correctly recover from it?<br></p><p>From what I understand, this was the Core Team’s reasoning for not returning optionals from array indexes, and I support that decision.<br></p><p>As an aside, I actually do have my own personal “ifExists:” subscript that runs the correct checks and returns an optional. I have specific use cases for it where it does make sense. But I can see the danger of including something like that in the Standard Library. It’s a rare case, and would open up the can of worms when everyone starts using it, instead of actually correctly reasoning about their code.<br></p><p>- Rod<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[Review] SE-0117: Default classes to benon-subclassable publicly</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>July 12, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; After all… you clearly don’t know about your current state, so how can you know how to correctly recover from it?<br></p><p>This a bit of a stretch, it is often the case but      not a necessary conclusion. Both C++ and Java have a model where it is not uncommon to recover from exceptions instead of crashing. You might know enough about your context to be able to go back to a safe point in time/app lifecycle and resume from there. <br></p><p>Also, the more scenarios we want to code in pure Swift in the more cases in which other languages offer features we do not want in Swift now we are going to encounter. The pragmatic voice in engineers will start asking &quot;why do I need to jump through hoops for purity&#39;s sake&quot;? <br></p><p>Sent from my iPhone<br></p><p>&gt; On 12 Jul 2016, at 09:10, Rod Brown via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; After all… you clearly don’t know about your current state, so how can you know how to correctly recover from it?<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>[Review] SE-0117: Default classes to benon-subclassable publicly</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>July 12, 2016 at 06:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br>On 12 Jul. 2016, at 6:19 pm, Goffredo Marocchi &lt;panajev at gmail.com&gt; wrote:<br></p><p>&gt;&gt; After all… you clearly don’t know about your current state, so how can you know how to correctly recover from it?<br>&gt; <br>&gt; This a bit of a stretch, it is often the case but      not a necessary conclusion. Both C++ and Java have a model where it is not uncommon to recover from exceptions instead of crashing. You might know enough about your context to be able to go back to a safe point in time/app lifecycle and resume from there. <br></p><p>I was not meaning to state that as an absolute, but as a generalisation. As I mentioned later, I do have cases where it&#39;s appropriate to use an ifExists subscript.<br></p><p>That said, Swift&#39;s safety isn&#39;t generally built around &quot;safe from crashes&quot;. After all, unwrapping an optional in Swift is a fatal error, and sending a message to nil in Obj-C is a no-op! So Obj-C is safer! ... um... no. It&#39;s safer in that it forces you to reason about your code rather than letting nil be no-op. That sounds remarkably similar to making someone reason about accessing an array and crashing, rather than just letting it be a no-op.<br></p><p>You&#39;ll also notice that Swift doesn&#39;t have the exception handling that C++ and Java do, as you referenced. Again, this appears to be in the same train of thought: if you&#39;ve met an exception, you didn&#39;t reason about your code, and the safest thing to do is quit. Swift does have error handling, on the other hand, understanding that errors can occur that are not related to inconsistent reasoning about your code.<br></p><p>Are there ways you could recover? Sure, in some circumstances. I could say the same thing about incorrectly unwrapping nil, or any other error of logic. I think Swift comes down hard on the side of &quot;if there are errors in logic, just crash now, it&#39;s the best overall choice.&quot;<br></p><p>Do I agree with it? Personally, I do, as I think it&#39;s a pragmatic decision overall. I can definitely see why others may disagree, and please feel free to add ifExists subscript in your projects like I have.<br></p><p>&gt; <br>&gt; Also, the more scenarios we want to code in pure Swift in the more cases in which other languages offer features we do not want in Swift now we are going to encounter. The pragmatic voice in engineers will start asking &quot;why do I need to jump through hoops for purity&#39;s sake&quot;? <br></p><p>I don&#39;t think this is a purity issue. It seems pragmatic to crash as it&#39;s almost always a programmer error that would cause this situation. A simple check on count would fix this in any other cases. Encouraging people to Handle programmer errors rather than simply Fix them seems rather odd to me.<br></p><p>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt;&gt; On 12 Jul 2016, at 09:10, Rod Brown via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; After all… you clearly don’t know about your current state, so how can you know how to correctly recover from it?<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Review] SE-0117: Default classes to benon-subclassable publicly</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>July 12, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; This argument comes up often, but I side with some of the smartest people in the industry who say the safest thing to do is actually crash, just like Swift does in this case.<br>I don&#39;t like supporting positions with claims like &quot;the smartest people say&quot;, and I personally renounce from doing so — even when I can cite a tangible name… and I think that you are walking on thin ice here in an attempt to prove something wrong just because it&#39;s coming from the other party in an discussion:<br>If being forced to check for existence of data is really less safe than crashing, a major element of Swift is nonsense.<br>Imho it&#39;s smarter to admit that this is a case where Swift does not want to pay the price for a little increase in safety — after all, this is only a sideshow with little effect on the actual topic.<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review] SE-0117: Default classes to benon-subclassable publicly</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>July 13, 2016 at 06:00:00am</p></header><div class="content"><p>&gt; On Jul 11, 2016, at 3:51 PM, Károly Lőrentey via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; - Annoyance: People will need to remember to manually add an extra keyword to their public classes whenever they want to allow subclassing. People who want to always allow cross-module subclassing will always have to add the keyword. The extra work to do this would be annoying and pointless, and the proliferation of such additional keywords would make Swift needlessly wordy.<br></p><p>There will be no need for an *extra* keyword if we use a keyword that replaces `public`, like the proposed keywords or my preferred `open`. It would merely be a *different* keyword.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
