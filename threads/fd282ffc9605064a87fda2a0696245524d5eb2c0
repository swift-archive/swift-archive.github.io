<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fd5bd4566ee1f286333b7dbf2df6fadb?s=50"></div><header><strong>Proposal: SwiftPM Support for Language Versions</strong> from <string>Anders Bertelrud</string> &lt;anders at apple.com&gt;<p>July 27, 2016 at 12:00:00am</p></header><div class="content"><p>Hello,<br></p><p>This is a proposal to enhance the SwiftPM package selection logic so that packages can be differentiated based on Swift version in addition to package version.  It does not introduce any source-breaking changes, but defines a way for package authors to annotate repositories and package manifests so that SwiftPM can exclude those that are usable only for particular versions of Swift.<br></p><p>You can find the proposal here:<br></p><p>https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md<br></p><p>and the current text is also included below.<br></p><p>Time is short, but feedback on this proposal is very welcome.<br></p><p>Thanks,<br></p><p>Anders<br></p><p>Package Manager Support for Language Versions<br></p><p>Proposal: SE-NNNN &lt;https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md&gt;<br>Author: Anders Bertelrud &lt;https://github.com/abertelrud&gt;<br>Status: Awaiting Review<br>Review manager: TBD<br> &lt;https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md#introduction&gt;Introduction<br></p><p>As new, source-incompatible versions of Swift come into use, there is a growing need for packages to be authored in a way that makes them usable from multiple versions of Swift. While package authors want to adopt new Swift versions as soon as possible, they also need to support their existing clients.<br></p><p>Source incompatibilities can arise not only from changes to the language syntax, but also from changes to the Swift Standard Library and the Package Description API of the Swift Package Manager itself.<br></p><p>Support for multiple Swift versions could in theory be implemented using #if directives in the package source code, but that approach can become unwieldy when the required code differences are significant.<br></p><p>The Swift Package Manager should therefore provide facilities that make it as easy as possible for package authors to support clients using different versions of Swift. The proposal described here intends to solve an immediate need for Swift Package Manager 3; the need for version-specific packages will hopefully diminish as the language and libraries stabilize. We can revisit the need for this support in a future version of Swift.<br></p><p> &lt;https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md#motivation&gt;Motivation<br></p><p>It is important to allow Swift users to migrate to new Swift versions as easily as possible. At the same time, packages need to stay compatible with existing clients who are not yet ready to migrate.<br></p><p>A new version of Swift means a new version of the language, the Standard Library API, and SwiftPM&#39;s own Package Description API. In some cases it&#39;s possible to use #if directives to let a single source base build using different versions of Swift. When the code differences are significant, however, it&#39;s impractical to use conditional code, and some other way to differentiate is needed. This is particularly true for new versions of the Swift Package Manager, as the manifest format evolves.<br></p><p>Making this practical requires some improvements to the Package Manager, but to see why, it is useful to look at why current workarounds would be impractical:<br></p><p> &lt;https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md#impractical-workaround-1&gt;Impractical workaround #1:<br></p><p>A strategy that wouldn&#39;t require any Swift Package Manager changes would be to require package authors to tie the semantic versions(1 &lt;http://semver.org/&gt;) of their packages to specific versions of Swift itself. For example, a package author could decide that version 1 of their package would work only with Swift 2.3, and package version 2 would work only with Swift 3.<br></p><p>Using different package versions for the different Swift versions would take advantage of the Package Manager&#39;s existing version matching logic to make sure that the right package is chosen, and the right package for the Swift version would automatically be chosen.<br></p><p>However, this doesn&#39;t seem like a particularly acceptable restriction, since it ties the release cycles of packages to those of Swift itself. This coupling between new Swift versions and new versions of all packages in use by a client would introduce significant revlock, which may seriously impact adoption. In particular, a client that wanted or needed to migrate to a new version of a package couldn&#39;t do so until they also migrated to a new version of Swift itself. In addition, they would at the same time have to migrate to newer versions of any other package on which they depend (assuming that such newer versions even exist).<br></p><p>This is particularly unfortunate in cases in which only the package manifest needs to be different, since that would cause a package that could otherwise support multiple Swift versions to have to bifurcate.<br></p><p>What is needed is a way to allow differentiation of packages by not just their own semantic version, but also the version of Swift being used.<br></p><p> &lt;https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md#impractical-workaround-2&gt;Impractical workaround #2:<br></p><p>Another possible strategy would be to choose package version numbers that also incorporate the version of Swift they require, thereby &quot;flattening&quot; the two version numbers involved (package version and Swift version) into one.<br></p><p>One could come up with various schemes for this, such as assigning odd-valued package version numbers to prerelease versions of the Swift language, and even-valued package version numbers to release versions of the Swift language.<br></p><p>But this would pollute the version space, and it also sends the wrong message about semantic versioning (which is a strategy that we want package authors to use). Encouraging the abuse of the major version number for other things than the package API is not in the best interest of the maintainability of the package ecosystem.<br></p><p> &lt;https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md#solution-goals&gt;Solution Goals<br></p><p>The solution needs to:<br></p><p>ensure that the established package ecosystem graph continues to work as-is, even as packages supporting new Swift versions are published<br></p><p>support parallel co-existence of actively maintained package graphs for:<br></p><p>the latest stable (release) version of Swift<br></p><p>the most recent pre-release version of Swift<br></p><p>any older versions of Swift that still need to be supported<br></p><p>(note that &quot;Swift version&quot; here includes not just the syntax of the language, but also the Standard Library API and the Package Description API)<br></p><p>The Swift Package Manager should make it as easy as possible for a package to support multiple Swift versions using a single package repository, when that is possible with respect to the magnitude of the requires source differences).<br></p><p>An additional, more abstract goal, is to encourage the whole Swift ecosystem to move forward as quickly as possible. This means optimizing for a workflow that involves latest-GM, current-prerelease, and current-development version, but ideally not a long tail of old GM versions.<br></p><p> &lt;https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md#proposed-solution&gt;Proposed Solution<br></p><p>There are two parts to the proposed solution:<br></p><p>provide package authors with a way to differentiate package repository version tags by Swift version, to support multiple editions of a single semantic package version<br></p><p>provide package authors with a way to provide multiple package manifests for a single package version tag, differentiated by Swift version<br></p><p>In both cases, version-based name suffixes are used to allow Package Manager to resolve dependencies based on package version as well as Swift version.<br></p><p> &lt;https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md#version-differentiated-package-tags&gt;Version-differentiated package tags<br></p><p>When selecting the version of a package dependency to use for a particular client, the Swift Package Manager uses a repository tag naming convention based on the specified version restrictions of the package.<br></p><p>For example, a client that specifies this dependency in its Package.swift:<br></p><p>.Package(url: &quot;https://github.com/apple/example-package-deckofplayingcards.git&quot;,<br>         majorVersion: 2)<br>causes the package manager to look for tags in the form of a semantic version (see semver.org &lt;http://semver.org/&gt; for more information).<br></p><p>In this example, only tags having a major version number of 2 are considered, and the highest version among them is the one that is selected.<br></p><p>Other restrictions involving minor versions and version ranges can be specified in the client&#39;s Package.swift manifest.<br></p><p>Regardless of how the desired version restrictions are specified, the highest semantic version that matches the restrictions is the one that is selected when resolving dependencies.<br></p><p>This proposal would allow an optional Swift version to appended to the package version, separated from it by a @swift-string.<br></p><p>This can be used to provide two separate tags for the same package version, differentiated only by Swift version. For example, version 1.0 of MyPackage could have a 1.0 at swift-2.3 tag and a 1.0 at swift-3 tag.<br></p><p>The expected use case for this is when the differences required to support two or more versions of Swift are large enough that it would be impractical to implement them in the same checkout of the repository.<br></p><p>The new logic would first look for tag names having such a Swift version suffix that matches the version of Swift the client wants to use, and if found, omits from consideration any tags that do not have that suffix. The existing logic would be applied to the remaining set of tag candidates.<br></p><p>The format of the swift version is not itself a semantic version, but instead follows the Swift marketing versions used. For matching, the number of digits specified affects the precision of the matching; for example, @swift-3 would match any version Swift 3.x.x version, while @swift-3.0 would match only Swift 3.0.x but not Swift 3.1 etc.<br></p><p>The most specific version suffix matching the client&#39;s Swift version is used. For example, if both a @swift-3 and a @swift-3.1 tag are found, Swift 3.1 would use the latter and Swift 3.2 would use the former.<br></p><p>If no tag names have the Swift version suffix, the matching would work as it currently does, using only the package version restrictions.<br></p><p> &lt;https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md#version-differentiated-package-manifests&gt;Version-differentiated package manifests<br></p><p>Creating Swift-versioned tags for a particular package version has maintenance consequences. When possible, it&#39;s more maintainable for a package to support multiple Swift versions in a single tag of a repository. In the ideal case, no source changes are required at all in order to support two different Swift versions (this is the case, for example, between Swift 2.2 and Swift 2.3).<br></p><p>When the required changes are minimal and a single package manifest can be used, #if directives in the source code can be used to support any other differences between the Swift versions. This already works today.<br></p><p>For the Package.swift manifest itself, though, it can be somewhat unwieldy to express differences using only #ifdirectives. This is the case whether the differences are due to language syntax changes (recall that Package.swiftmanifests are actually Swift source files) or due to changes in the Package Description API.<br></p><p>To support this, this proposal would allow a Swift version to be appended to the base Package base name, separated from it by the string @swift-. For example, a package manifest specific to Swift 2.3 would have the file namePackage at swift-2.3.swift, while one that worked for any Swift 3.x version would be Package at swift-3.swift.<br></p><p>As with versioned tags, in the absence of a version-specific Package.swift file, the Package Manager would use the regular Package.swift file.<br></p><p>Often, a package author would use either version-differentiated package tags or version-differentiated package manifests, but they could also be used together when that makes sense.<br></p><p>It is hoped that as the Swift language stabilizes and packages eventually drop support for older versions of Swift, many packages will be able to discard the version-specific variants and keep only Package.swift.<br></p><p> &lt;https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md#impact-on-existing-code&gt;Impact on existing code<br></p><p>There is not expected to be any impact on existing code, since this proposal adds on top of existing functionality.<br></p><p> &lt;https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md#alternatives&gt;Alternatives<br></p><p>Do nothing and let package authors invent their own ways. For the reasons spelled out in the Motivation section, this very undesirable. However, given how close we are to Swift 3&#39;s completion date, there is a possibility that there will not be time to implement this proposal for Swift 3.<br></p><p>The consequence would be that future changes to the Package Description API would cause existing packages to break, which could significantly obstruct package adoption of new versions of Swift.<br></p><p>Add declarations to the Package.swift manifest to specify the required Swift version or version range. This has a number of problems, including the fact that all of the various manifests would need to be checked out before deciding which to exclude from consideration. Another problems is that such minimum-version requirement declarations would have to be able to be parsed by older versions of the Package Manager, and this is not a guarantee we can make (the manifest might not be parseable using an older version of Swift).<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160727/fd28b2c0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc38aef146f886571b3c445851add884?s=50"></div><header><strong>Proposal: SwiftPM Support for Language Versions</strong> from <string>Honza Dvorsky</string> &lt;jan.dvorsky at me.com&gt;<p>July 27, 2016 at 08:00:00pm</p></header><div class="content"><p>Hi Anders,<br></p><p>thanks for the proposal, I agree this is something to be supported<br>explicitly in SwiftPM. I really like the Goals section and mostly support<br>the Solutions you proposed. Just a few comments below:<br></p><p><br>*&gt; The new logic would first look for tag names having such a Swift version<br>suffix that matches the version of Swift the client wants to use, and if<br>found, omits from consideration any tags that do not have that suffix. The<br>existing logic would be applied to the remaining set of tag candidates.*<br></p><p>Do I understand correctly that if we have the tag list: [2.1, 2.2, 2.3] and<br>we&#39;re compiling swift-3, all three tags will be considered; when we add<br>2.1 at swift-3, we now have [2.1, 2.1 at swift-3, 2.2, 2.3] and only [2.1 at swift-3]<br>will be considered? If so, I&#39;m not sure I like that non-continuity that<br>suddenly takes away 2.2 and 2.3 from considered tags by adding 2.1 at swift-3.<br>The alternative would be that when 2.1 at swift-3 is added, the considered<br>list would be [2.1 at swift-3, 2.2, 2.3] (only the non-specific 2.1 was not<br>considered now). I could imagine this emerging when a security fix is<br>needed in 2.1 and the fix needs Swift version-specific code to be applied.<br>I think I&#39;d like that behavior better, but please do let me know if you&#39;ve<br>already considered this.<br></p><p>*&gt; 2. support parallel co-existence of actively maintained package graphs<br>for:*<br></p><p>   -<br></p><p>   *the most recent pre-release version of Swift*<br></p><p>Would that work for snapshots in the form of<br>swift-DEVELOPMENT-SNAPSHOT-2016-07-25-a as well? For pre-release Swift, in<br>my projects I release new minor versions for each new snapshot, until we<br>get to the final release. Being able to have a tag of<br>1.2.3 at swift-DEVELOPMENT-SNAPSHOT-2016-07-25-a is not pretty, but it would<br>definitely help many projects that adopt the latest snapshot at all times,<br>while not breaking older projects paused on older snapshots. If it is<br>intended to work with snapshot names, not just full Swift versions, than<br>I&#39;m happy with it.<br></p><p>Thanks!<br>Honza<br></p><p><br>On Wed, Jul 27, 2016 at 9:54 AM Anders Bertelrud via swift-build-dev &lt;<br>swift-build-dev at swift.org&gt; wrote:<br></p><p>&gt; Hello,<br>&gt;<br>&gt; This is a proposal to enhance the SwiftPM package selection logic so that<br>&gt; packages can be differentiated based on Swift version in addition to<br>&gt; package version.  It does not introduce any source-breaking changes, but<br>&gt; defines a way for package authors to annotate repositories and package<br>&gt; manifests so that SwiftPM can exclude those that are usable only for<br>&gt; particular versions of Swift.<br>&gt;<br>&gt; You can find the proposal here:<br>&gt;<br>&gt;<br>&gt; https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md<br>&gt;<br>&gt; and the current text is also included below.<br>&gt;<br>&gt; Time is short, but feedback on this proposal is very welcome.<br>&gt;<br>&gt; Thanks,<br>&gt;<br>&gt; Anders<br>&gt;<br>&gt; Package Manager Support for Language Versions<br>&gt;<br>&gt;    - Proposal: SE-NNNN<br>&gt;    &lt;https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md&gt;<br>&gt;    - Author: Anders Bertelrud &lt;https://github.com/abertelrud&gt;<br>&gt;    - Status: Awaiting Review<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; As new, source-incompatible versions of Swift come into use, there is a<br>&gt; growing need for packages to be authored in a way that makes them usable<br>&gt; from multiple versions of Swift. While package authors want to adopt new<br>&gt; Swift versions as soon as possible, they also need to support their<br>&gt; existing clients.<br>&gt;<br>&gt; Source incompatibilities can arise not only from changes to the language<br>&gt; syntax, but also from changes to the Swift Standard Library and the Package<br>&gt; Description API of the Swift Package Manager itself.<br>&gt;<br>&gt; Support for multiple Swift versions could in theory be implemented using<br>&gt; #if directives in the package source code, but that approach can become<br>&gt; unwieldy when the required code differences are significant.<br>&gt;<br>&gt; The Swift Package Manager should therefore provide facilities that make it<br>&gt; as easy as possible for package authors to support clients using different<br>&gt; versions of Swift. The proposal described here intends to solve an<br>&gt; immediate need for Swift Package Manager 3; the need for version-specific<br>&gt; packages will hopefully diminish as the language and libraries stabilize.<br>&gt; We can revisit the need for this support in a future version of Swift.<br>&gt;<br>&gt; &lt;https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; It is important to allow Swift users to migrate to new Swift versions as<br>&gt; easily as possible. At the same time, packages need to stay compatible with<br>&gt; existing clients who are not yet ready to migrate.<br>&gt;<br>&gt; A new version of Swift means a new version of the language, the Standard<br>&gt; Library API, and SwiftPM&#39;s own Package Description API. In some cases it&#39;s<br>&gt; possible to use #if directives to let a single source base build using<br>&gt; different versions of Swift. When the code differences are significant,<br>&gt; however, it&#39;s impractical to use conditional code, and some other way to<br>&gt; differentiate is needed. This is particularly true for new versions of the<br>&gt; Swift Package Manager, as the manifest format evolves.<br>&gt;<br>&gt; Making this practical requires some improvements to the Package Manager,<br>&gt; but to see why, it is useful to look at why current workarounds would be<br>&gt; impractical:<br>&gt;<br>&gt; &lt;https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md#impractical-workaround-1&gt;Impractical<br>&gt; workaround #1:<br>&gt;<br>&gt; A strategy that wouldn&#39;t require any Swift Package Manager changes would<br>&gt; be to require package authors to tie the semantic versions(1<br>&gt; &lt;http://semver.org/&gt;) of their packages to specific versions of Swift<br>&gt; itself. For example, a package author could decide that version 1 of their<br>&gt; package would work only with Swift 2.3, and package version 2 would work<br>&gt; only with Swift 3.<br>&gt;<br>&gt; Using different package versions for the different Swift versions would<br>&gt; take advantage of the Package Manager&#39;s existing version matching logic to<br>&gt; make sure that the right package is chosen, and the right package for the<br>&gt; Swift version would automatically be chosen.<br>&gt;<br>&gt; However, this doesn&#39;t seem like a particularly acceptable restriction,<br>&gt; since it ties the release cycles of packages to those of Swift itself. This<br>&gt; coupling between new Swift versions and new versions of all packages in use<br>&gt; by a client would introduce significant revlock, which may seriously impact<br>&gt; adoption. In particular, a client that wanted or needed to migrate to a new<br>&gt; version of a package couldn&#39;t do so until they also migrated to a new<br>&gt; version of Swift itself. In addition, they would at the same time have to<br>&gt; migrate to newer versions of any other package on which they depend<br>&gt; (assuming that such newer versions even exist).<br>&gt;<br>&gt; This is particularly unfortunate in cases in which only the package<br>&gt; manifest needs to be different, since that would cause a package that could<br>&gt; otherwise support multiple Swift versions to have to bifurcate.<br>&gt;<br>&gt; What is needed is a way to allow differentiation of packages by not just<br>&gt; their own semantic version, but also the version of Swift being used.<br>&gt;<br>&gt; &lt;https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md#impractical-workaround-2&gt;Impractical<br>&gt; workaround #2:<br>&gt;<br>&gt; Another possible strategy would be to choose package version numbers that<br>&gt; also incorporate the version of Swift they require, thereby &quot;flattening&quot;<br>&gt; the two version numbers involved (package version and Swift version) into<br>&gt; one.<br>&gt;<br>&gt; One could come up with various schemes for this, such as assigning<br>&gt; odd-valued package version numbers to prerelease versions of the Swift<br>&gt; language, and even-valued package version numbers to release versions of<br>&gt; the Swift language.<br>&gt;<br>&gt; But this would pollute the version space, and it also sends the wrong<br>&gt; message about semantic versioning (which is a strategy that we want package<br>&gt; authors to use). Encouraging the abuse of the major version number for<br>&gt; other things than the package API is not in the best interest of the<br>&gt; maintainability of the package ecosystem.<br>&gt;<br>&gt; &lt;https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md#solution-goals&gt;Solution<br>&gt; Goals<br>&gt;<br>&gt; The solution needs to:<br>&gt;<br>&gt;    1.<br>&gt;<br>&gt;    ensure that the established package ecosystem graph continues to work<br>&gt;    as-is, even as packages supporting new Swift versions are published<br>&gt;    2.<br>&gt;<br>&gt;    support parallel co-existence of actively maintained package graphs<br>&gt;    for:<br>&gt;    -<br>&gt;<br>&gt;       the latest stable (release) version of Swift<br>&gt;       -<br>&gt;<br>&gt;       the most recent pre-release version of Swift<br>&gt;       -<br>&gt;<br>&gt;       any older versions of Swift that still need to be supported<br>&gt;<br>&gt; (note that &quot;Swift version&quot; here includes not just the syntax of the<br>&gt; language, but also the Standard Library API and the Package Description API)<br>&gt;<br>&gt; The Swift Package Manager should make it as easy as possible for a package<br>&gt; to support multiple Swift versions using a single package repository, when<br>&gt; that is possible with respect to the magnitude of the requires source<br>&gt; differences).<br>&gt;<br>&gt; An additional, more abstract goal, is to encourage the whole Swift<br>&gt; ecosystem to move forward as quickly as possible. This means optimizing for<br>&gt; a workflow that involves latest-GM, current-prerelease, and<br>&gt; current-development version, but ideally not a long tail of old GM versions.<br>&gt;<br>&gt; &lt;https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md#proposed-solution&gt;Proposed<br>&gt; Solution<br>&gt;<br>&gt; There are two parts to the proposed solution:<br>&gt;<br>&gt;    1.<br>&gt;<br>&gt;    provide package authors with a way to differentiate package repository<br>&gt;    version tags by Swift version, to support multiple editions of a single<br>&gt;    semantic package version<br>&gt;    2.<br>&gt;<br>&gt;    provide package authors with a way to provide multiple package<br>&gt;    manifests for a single package version tag, differentiated by Swift version<br>&gt;<br>&gt; In both cases, version-based name suffixes are used to allow Package<br>&gt; Manager to resolve dependencies based on package version as well as Swift<br>&gt; version.<br>&gt;<br>&gt; &lt;https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md#version-differentiated-package-tags&gt;Version-differentiated<br>&gt; package tags<br>&gt;<br>&gt; When selecting the version of a package dependency to use for a particular<br>&gt; client, the Swift Package Manager uses a repository tag naming convention<br>&gt; based on the specified version restrictions of the package.<br>&gt;<br>&gt; For example, a client that specifies this dependency in its Package.swift:<br>&gt;<br>&gt; .Package(url: &quot;https://github.com/apple/example-package-deckofplayingcards.git&quot;,<br>&gt;          majorVersion: 2)<br>&gt;<br>&gt; causes the package manager to look for tags in the form of a semantic<br>&gt; version (see semver.org for more information).<br>&gt;<br>&gt; In this example, only tags having a major version number of 2 are<br>&gt; considered, and the highest version among them is the one that is selected.<br>&gt;<br>&gt; Other restrictions involving minor versions and version ranges can be<br>&gt; specified in the client&#39;s Package.swift manifest.<br>&gt;<br>&gt; Regardless of how the desired version restrictions are specified, the<br>&gt; highest semantic version that matches the restrictions is the one that is<br>&gt; selected when resolving dependencies.<br>&gt;<br>&gt; This proposal would allow an optional Swift version to appended to the<br>&gt; package version, separated from it by a @swift-string.<br>&gt;<br>&gt; This can be used to provide two separate tags for the same package<br>&gt; version, differentiated only by Swift version. For example, version 1.0 of<br>&gt; MyPackage could have a 1.0 at swift-2.3 tag and a 1.0 at swift-3 tag.<br>&gt;<br>&gt; The expected use case for this is when the differences required to support<br>&gt; two or more versions of Swift are large enough that it would be impractical<br>&gt; to implement them in the same checkout of the repository.<br>&gt;<br>&gt; The new logic would first look for tag names having such a Swift version<br>&gt; suffix that matches the version of Swift the client wants to use, and if<br>&gt; found, omits from consideration any tags that do not have that suffix. The<br>&gt; existing logic would be applied to the remaining set of tag candidates.<br>&gt;<br>&gt; The format of the swift version is not itself a semantic version, but<br>&gt; instead follows the Swift marketing versions used. For matching, the number<br>&gt; of digits specified affects the precision of the matching; for example,<br>&gt; @swift-3 would match any version Swift 3.x.x version, while @swift-3.0 would<br>&gt; match only Swift 3.0.x but not Swift 3.1 etc.<br>&gt;<br>&gt; The most specific version suffix matching the client&#39;s Swift version is<br>&gt; used. For example, if both a @swift-3 and a @swift-3.1 tag are found,<br>&gt; Swift 3.1 would use the latter and Swift 3.2 would use the former.<br>&gt;<br>&gt; If no tag names have the Swift version suffix, the matching would work as<br>&gt; it currently does, using only the package version restrictions.<br>&gt;<br>&gt; &lt;https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md#version-differentiated-package-manifests&gt;Version-differentiated<br>&gt; package manifests<br>&gt;<br>&gt; Creating Swift-versioned tags for a particular package version has<br>&gt; maintenance consequences. When possible, it&#39;s more maintainable for a<br>&gt; package to support multiple Swift versions in a single tag of a repository.<br>&gt; In the ideal case, no source changes are required at all in order to<br>&gt; support two different Swift versions (this is the case, for example,<br>&gt; between Swift 2.2 and Swift 2.3).<br>&gt;<br>&gt; When the required changes are minimal and a single package manifest can be<br>&gt; used, #if directives in the source code can be used to support any other<br>&gt; differences between the Swift versions. This already works today.<br>&gt;<br>&gt; For the Package.swift manifest itself, though, it can be somewhat<br>&gt; unwieldy to express differences using only #ifdirectives. This is the<br>&gt; case whether the differences are due to language syntax changes (recall<br>&gt; that Package.swiftmanifests are actually Swift source files) or due to<br>&gt; changes in the Package Description API.<br>&gt;<br>&gt; To support this, this proposal would allow a Swift version to be appended<br>&gt; to the base Package base name, separated from it by the string @swift-.<br>&gt; For example, a package manifest specific to Swift 2.3 would have the file<br>&gt; namePackage at swift-2.3.swift, while one that worked for any Swift 3.x<br>&gt; version would be Package at swift-3.swift.<br>&gt;<br>&gt; As with versioned tags, in the absence of a version-specific Package.swift file,<br>&gt; the Package Manager would use the regular Package.swift file.<br>&gt;<br>&gt; Often, a package author would use either version-differentiated package<br>&gt; tags or version-differentiated package manifests, but they could also be<br>&gt; used together when that makes sense.<br>&gt;<br>&gt; It is hoped that as the Swift language stabilizes and packages eventually<br>&gt; drop support for older versions of Swift, many packages will be able to<br>&gt; discard the version-specific variants and keep only Package.swift.<br>&gt;<br>&gt; &lt;https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md#impact-on-existing-code&gt;Impact<br>&gt; on existing code<br>&gt;<br>&gt; There is not expected to be any impact on existing code, since this<br>&gt; proposal adds on top of existing functionality.<br>&gt;<br>&gt; &lt;https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md#alternatives&gt;<br>&gt; Alternatives<br>&gt;<br>&gt;    1.<br>&gt;<br>&gt;    Do nothing and let package authors invent their own ways. For the<br>&gt;    reasons spelled out in the *Motivation* section, this very<br>&gt;    undesirable. However, given how close we are to Swift 3&#39;s completion date,<br>&gt;    there is a possibility that there will not be time to implement this<br>&gt;    proposal for Swift 3.<br>&gt;<br>&gt;    The consequence would be that future changes to the Package<br>&gt;    Description API would cause existing packages to break, which could<br>&gt;    significantly obstruct package adoption of new versions of Swift.<br>&gt;    2.<br>&gt;<br>&gt;    Add declarations to the Package.swift manifest to specify the required<br>&gt;    Swift version or version range. This has a number of problems, including<br>&gt;    the fact that all of the various manifests would need to be checked out<br>&gt;    before deciding which to exclude from consideration. Another problems is<br>&gt;    that such minimum-version requirement declarations would have to be able to<br>&gt;    be parsed by older versions of the Package Manager, and this is not a<br>&gt;    guarantee we can make (the manifest might not be parseable using an older<br>&gt;    version of Swift).<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160727/7c4cf42b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fd5bd4566ee1f286333b7dbf2df6fadb?s=50"></div><header><strong>Proposal: SwiftPM Support for Language Versions</strong> from <string>Anders Bertelrud</string> &lt;anders at apple.com&gt;<p>July 27, 2016 at 03:00:00pm</p></header><div class="content"><p>Hello Honza,<br></p><p>&gt; On 2016-07-27, at 13.06, Honza Dvorsky &lt;jan.dvorsky at me.com&gt; wrote:<br>&gt; <br>&gt; thanks for the proposal, I agree this is something to be supported explicitly in SwiftPM. I really like the Goals section and mostly support the Solutions<br></p><p>Great!  Thanks for taking the time to comment.  Responses inline.<br></p><p>&gt; you proposed. Just a few comments below:<br>&gt; <br>&gt; &gt; The new logic would first look for tag names having such a Swift version suffix that matches the version of Swift the client wants to use, and if found, omits from consideration any tags that do not have that suffix. The existing logic would be applied to the remaining set of tag candidates.<br>&gt; <br>&gt; Do I understand correctly that if we have the tag list: [2.1, 2.2, 2.3] and we&#39;re compiling swift-3, all three tags will be considered; when we add 2.1 at swift-3, we now have [2.1, 2.1 at swift-3, 2.2, 2.3] and only [2.1 at swift-3] will be considered?<br></p><p>In your example, would 2.1 be the only one that has to have a SwiftPM 3 specific edition?  I wonder how realistic that is... would 2.2 and 2.3 have been modified to support both SwiftPM 3 and SwiftPM 4, or would 2.2 and 2.3 have dropped support for SwiftPM 3?<br></p><p>&gt; If so, I&#39;m not sure I like that non-continuity that suddenly takes away 2.2 and 2.3 from considered tags by adding 2.1 at swift-3.<br></p><p>I agree that it does feel a bit odd, but at least it&#39;s entirely under the package author&#39;s control.  Once they start needing to differentiate based on Swift version, they might need to add more differentiation to existing tags, that&#39;s true.<br></p><p>&gt; The alternative would be that when 2.1 at swift-3 is added, the considered list would be [2.1 at swift-3, 2.2, 2.3] (only the non-specific 2.1 was not considered now). I could imagine this emerging when a security fix is needed in 2.1 and the fix needs Swift version-specific code to be applied.<br></p><p>For small fixes, we expect that a multi version project would be a much better solution, so in that case the tag shouldn&#39;t be versioned at all.  Versioning the tag is really quite a big hammer, as the proposal notes.<br></p><p>&gt; I think I&#39;d like that behavior better, but please do let me know if you&#39;ve already considered this.<br></p><p>We did indeed consider this, and the problem is that in this case, SwiftPM 3 won&#39;t know that it cannot use 2.2 or 2.3 (assuming that that&#39;s the case).  So there would be no way to say that the highest version that SwiftPM 3 can match against is 2.1, but SwiftPM 4 (for example) could use 2.2 or 2.3.<br></p><p>&gt; &gt; 2. support parallel co-existence of actively maintained package graphs for:<br>&gt; the most recent pre-release version of Swift<br>&gt; <br>&gt; Would that work for snapshots in the form of swift-DEVELOPMENT-SNAPSHOT-2016-07-25-a as well? For pre-release Swift, in my projects I release new minor versions for each new snapshot, until we get to the final release. Being able to have a tag of 1.2.3 at swift-DEVELOPMENT-SNAPSHOT-2016-07-25-a is not pretty, but it would definitely help many projects that adopt the latest snapshot at all times, while not breaking older projects paused on older snapshots. If it is intended to work with snapshot names, not just full Swift versions, than I&#39;m happy with it.<br></p><p>We discussed this, but that is not currently a part of the proposal.  Part of the problem is that the naming of snapshots isn&#39;t a formal format.  The proposal as written is definitely geared toward major versions, with the expectation that people will update to new snapshots fairly quickly (much quicker than going from a stable GM release to a prerelease).<br></p><p>Anders<br></p><p>&gt; Thanks!<br>&gt; Honza<br>&gt; <br>&gt; <br>&gt; On Wed, Jul 27, 2016 at 9:54 AM Anders Bertelrud via swift-build-dev &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt; Hello,<br>&gt; <br>&gt; This is a proposal to enhance the SwiftPM package selection logic so that packages can be differentiated based on Swift version in addition to package version.  It does not introduce any source-breaking changes, but defines a way for package authors to annotate repositories and package manifests so that SwiftPM can exclude those that are usable only for particular versions of Swift.<br>&gt; <br>&gt; You can find the proposal here:<br>&gt; <br>&gt; https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md &lt;https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md&gt;<br>&gt; <br>&gt; and the current text is also included below.<br>&gt; <br>&gt; Time is short, but feedback on this proposal is very welcome.<br>&gt; <br>&gt; Thanks,<br>&gt; <br>&gt; Anders<br>&gt; <br>&gt; Package Manager Support for Language Versions<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md&gt;<br>&gt; Author: Anders Bertelrud &lt;https://github.com/abertelrud&gt;<br>&gt; Status: Awaiting Review<br>&gt; Review manager: TBD<br>&gt;  &lt;https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md#introduction&gt;Introduction<br>&gt; <br>&gt; As new, source-incompatible versions of Swift come into use, there is a growing need for packages to be authored in a way that makes them usable from multiple versions of Swift. While package authors want to adopt new Swift versions as soon as possible, they also need to support their existing clients.<br>&gt; <br>&gt; Source incompatibilities can arise not only from changes to the language syntax, but also from changes to the Swift Standard Library and the Package Description API of the Swift Package Manager itself.<br>&gt; <br>&gt; Support for multiple Swift versions could in theory be implemented using #if directives in the package source code, but that approach can become unwieldy when the required code differences are significant.<br>&gt; <br>&gt; The Swift Package Manager should therefore provide facilities that make it as easy as possible for package authors to support clients using different versions of Swift. The proposal described here intends to solve an immediate need for Swift Package Manager 3; the need for version-specific packages will hopefully diminish as the language and libraries stabilize. We can revisit the need for this support in a future version of Swift.<br>&gt; <br>&gt;  &lt;https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md#motivation&gt;Motivation<br>&gt; <br>&gt; It is important to allow Swift users to migrate to new Swift versions as easily as possible. At the same time, packages need to stay compatible with existing clients who are not yet ready to migrate.<br>&gt; <br>&gt; A new version of Swift means a new version of the language, the Standard Library API, and SwiftPM&#39;s own Package Description API. In some cases it&#39;s possible to use #if directives to let a single source base build using different versions of Swift. When the code differences are significant, however, it&#39;s impractical to use conditional code, and some other way to differentiate is needed. This is particularly true for new versions of the Swift Package Manager, as the manifest format evolves.<br>&gt; <br>&gt; Making this practical requires some improvements to the Package Manager, but to see why, it is useful to look at why current workarounds would be impractical:<br>&gt; <br>&gt;  &lt;https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md#impractical-workaround-1&gt;Impractical workaround #1:<br>&gt; <br>&gt; A strategy that wouldn&#39;t require any Swift Package Manager changes would be to require package authors to tie the semantic versions(1 &lt;http://semver.org/&gt;) of their packages to specific versions of Swift itself. For example, a package author could decide that version 1 of their package would work only with Swift 2.3, and package version 2 would work only with Swift 3.<br>&gt; <br>&gt; Using different package versions for the different Swift versions would take advantage of the Package Manager&#39;s existing version matching logic to make sure that the right package is chosen, and the right package for the Swift version would automatically be chosen.<br>&gt; <br>&gt; However, this doesn&#39;t seem like a particularly acceptable restriction, since it ties the release cycles of packages to those of Swift itself. This coupling between new Swift versions and new versions of all packages in use by a client would introduce significant revlock, which may seriously impact adoption. In particular, a client that wanted or needed to migrate to a new version of a package couldn&#39;t do so until they also migrated to a new version of Swift itself. In addition, they would at the same time have to migrate to newer versions of any other package on which they depend (assuming that such newer versions even exist).<br>&gt; <br>&gt; This is particularly unfortunate in cases in which only the package manifest needs to be different, since that would cause a package that could otherwise support multiple Swift versions to have to bifurcate.<br>&gt; <br>&gt; What is needed is a way to allow differentiation of packages by not just their own semantic version, but also the version of Swift being used.<br>&gt; <br>&gt;  &lt;https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md#impractical-workaround-2&gt;Impractical workaround #2:<br>&gt; <br>&gt; Another possible strategy would be to choose package version numbers that also incorporate the version of Swift they require, thereby &quot;flattening&quot; the two version numbers involved (package version and Swift version) into one.<br>&gt; <br>&gt; One could come up with various schemes for this, such as assigning odd-valued package version numbers to prerelease versions of the Swift language, and even-valued package version numbers to release versions of the Swift language.<br>&gt; <br>&gt; But this would pollute the version space, and it also sends the wrong message about semantic versioning (which is a strategy that we want package authors to use). Encouraging the abuse of the major version number for other things than the package API is not in the best interest of the maintainability of the package ecosystem.<br>&gt; <br>&gt;  &lt;https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md#solution-goals&gt;Solution Goals<br>&gt; <br>&gt; The solution needs to:<br>&gt; <br>&gt; ensure that the established package ecosystem graph continues to work as-is, even as packages supporting new Swift versions are published<br>&gt; <br>&gt; support parallel co-existence of actively maintained package graphs for:<br>&gt; <br>&gt; the latest stable (release) version of Swift<br>&gt; <br>&gt; the most recent pre-release version of Swift<br>&gt; <br>&gt; any older versions of Swift that still need to be supported<br>&gt; <br>&gt; (note that &quot;Swift version&quot; here includes not just the syntax of the language, but also the Standard Library API and the Package Description API)<br>&gt; <br>&gt; The Swift Package Manager should make it as easy as possible for a package to support multiple Swift versions using a single package repository, when that is possible with respect to the magnitude of the requires source differences).<br>&gt; <br>&gt; An additional, more abstract goal, is to encourage the whole Swift ecosystem to move forward as quickly as possible. This means optimizing for a workflow that involves latest-GM, current-prerelease, and current-development version, but ideally not a long tail of old GM versions.<br>&gt; <br>&gt;  &lt;https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md#proposed-solution&gt;Proposed Solution<br>&gt; <br>&gt; There are two parts to the proposed solution:<br>&gt; <br>&gt; provide package authors with a way to differentiate package repository version tags by Swift version, to support multiple editions of a single semantic package version<br>&gt; <br>&gt; provide package authors with a way to provide multiple package manifests for a single package version tag, differentiated by Swift version<br>&gt; <br>&gt; In both cases, version-based name suffixes are used to allow Package Manager to resolve dependencies based on package version as well as Swift version.<br>&gt; <br>&gt;  &lt;https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md#version-differentiated-package-tags&gt;Version-differentiated package tags<br>&gt; <br>&gt; When selecting the version of a package dependency to use for a particular client, the Swift Package Manager uses a repository tag naming convention based on the specified version restrictions of the package.<br>&gt; <br>&gt; For example, a client that specifies this dependency in its Package.swift:<br>&gt; <br>&gt; .Package(url: &quot;https://github.com/apple/example-package-deckofplayingcards.git &lt;https://github.com/apple/example-package-deckofplayingcards.git&gt;&quot;,<br>&gt;          majorVersion: 2)<br>&gt; causes the package manager to look for tags in the form of a semantic version (see semver.org &lt;http://semver.org/&gt; for more information).<br>&gt; <br>&gt; In this example, only tags having a major version number of 2 are considered, and the highest version among them is the one that is selected.<br>&gt; <br>&gt; Other restrictions involving minor versions and version ranges can be specified in the client&#39;s Package.swift manifest.<br>&gt; <br>&gt; Regardless of how the desired version restrictions are specified, the highest semantic version that matches the restrictions is the one that is selected when resolving dependencies.<br>&gt; <br>&gt; This proposal would allow an optional Swift version to appended to the package version, separated from it by a @swift-string.<br>&gt; <br>&gt; This can be used to provide two separate tags for the same package version, differentiated only by Swift version. For example, version 1.0 of MyPackage could have a 1.0 at swift-2.3 tag and a 1.0 at swift-3 tag.<br>&gt; <br>&gt; The expected use case for this is when the differences required to support two or more versions of Swift are large enough that it would be impractical to implement them in the same checkout of the repository.<br>&gt; <br>&gt; The new logic would first look for tag names having such a Swift version suffix that matches the version of Swift the client wants to use, and if found, omits from consideration any tags that do not have that suffix. The existing logic would be applied to the remaining set of tag candidates.<br>&gt; <br>&gt; The format of the swift version is not itself a semantic version, but instead follows the Swift marketing versions used. For matching, the number of digits specified affects the precision of the matching; for example, @swift-3 would match any version Swift 3.x.x version, while @swift-3.0 would match only Swift 3.0.x but not Swift 3.1 etc.<br>&gt; <br>&gt; The most specific version suffix matching the client&#39;s Swift version is used. For example, if both a @swift-3 and a @swift-3.1 tag are found, Swift 3.1 would use the latter and Swift 3.2 would use the former.<br>&gt; <br>&gt; If no tag names have the Swift version suffix, the matching would work as it currently does, using only the package version restrictions.<br>&gt; <br>&gt;  &lt;https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md#version-differentiated-package-manifests&gt;Version-differentiated package manifests<br>&gt; <br>&gt; Creating Swift-versioned tags for a particular package version has maintenance consequences. When possible, it&#39;s more maintainable for a package to support multiple Swift versions in a single tag of a repository. In the ideal case, no source changes are required at all in order to support two different Swift versions (this is the case, for example, between Swift 2.2 and Swift 2.3).<br>&gt; <br>&gt; When the required changes are minimal and a single package manifest can be used, #if directives in the source code can be used to support any other differences between the Swift versions. This already works today.<br>&gt; <br>&gt; For the Package.swift manifest itself, though, it can be somewhat unwieldy to express differences using only #ifdirectives. This is the case whether the differences are due to language syntax changes (recall that Package.swiftmanifests are actually Swift source files) or due to changes in the Package Description API.<br>&gt; <br>&gt; To support this, this proposal would allow a Swift version to be appended to the base Package base name, separated from it by the string @swift-. For example, a package manifest specific to Swift 2.3 would have the file namePackage at swift-2.3.swift &lt;mailto:Package at swift-2.3.swift&gt;, while one that worked for any Swift 3.x version would be Package at swift-3.swift &lt;mailto:Package at swift-3.swift&gt;.<br>&gt; <br>&gt; As with versioned tags, in the absence of a version-specific Package.swift file, the Package Manager would use the regular Package.swift file.<br>&gt; <br>&gt; Often, a package author would use either version-differentiated package tags or version-differentiated package manifests, but they could also be used together when that makes sense.<br>&gt; <br>&gt; It is hoped that as the Swift language stabilizes and packages eventually drop support for older versions of Swift, many packages will be able to discard the version-specific variants and keep only Package.swift.<br>&gt; <br>&gt;  &lt;https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; There is not expected to be any impact on existing code, since this proposal adds on top of existing functionality.<br>&gt; <br>&gt;  &lt;https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md#alternatives&gt;Alternatives<br>&gt; <br>&gt; Do nothing and let package authors invent their own ways. For the reasons spelled out in the Motivation section, this very undesirable. However, given how close we are to Swift 3&#39;s completion date, there is a possibility that there will not be time to implement this proposal for Swift 3.<br>&gt; <br>&gt; The consequence would be that future changes to the Package Description API would cause existing packages to break, which could significantly obstruct package adoption of new versions of Swift.<br>&gt; <br>&gt; Add declarations to the Package.swift manifest to specify the required Swift version or version range. This has a number of problems, including the fact that all of the various manifests would need to be checked out before deciding which to exclude from consideration. Another problems is that such minimum-version requirement declarations would have to be able to be parsed by older versions of the Package Manager, and this is not a guarantee we can make (the manifest might not be parseable using an older version of Swift).<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev &lt;https://lists.swift.org/mailman/listinfo/swift-build-dev&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160727/13d12664/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/79d9ba388d6b6cf4ec7310cad9fa8c8a?s=50"></div><header><strong>Proposal: SwiftPM Support for Language Versions</strong> from <string>Rob Allen</string> &lt;rob at akrabat.com&gt;<p>July 28, 2016 at 08:00:00am</p></header><div class="content"><p>Hi,<br></p><p>Does this tie-in with the post from Ted?<br></p><p>The subject line &quot;[swift-dev] End of source-breaking changes for Swift 3&quot; where he says:<br>&quot;The Swift team at Apple has reflected on this and decided what it &quot;means&quot; for Swift 3 to be source compatible with Swift 4 and later releases going forward. Our goal is to allow app developers to combine a mix of Swift modules (e.g., SwiftPM packages), where each module is known to compile with a specific version of the language (module A works with Swift 3, module B works with Swift 3.1, etc.), then combine those modules into a single binary. The key feature is that a module can be migrated from Swift 3 to 3.1 to 4 (and beyond) independently of its dependencies.&quot;<br></p><p>[...]<br></p><p>&quot;To make this more concrete, suppose an application is written to use Swift 4, but uses packages via SwiftPM that are written using Swift 3. A single compiler would build both the app and the packages — thus ensuring that all the compiled sources are binary compatible.&quot;<br></p><p><br>Regards,<br></p><p>Rob...<br></p><p><br>&gt; On 27 Jul 2016, at 09:54, Anders Bertelrud via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello,<br>&gt; <br>&gt; This is a proposal to enhance the SwiftPM package selection logic so that packages can be differentiated based on Swift version in addition to package version.  It does not introduce any source-breaking changes, but defines a way for package authors to annotate repositories and package manifests so that SwiftPM can exclude those that are usable only for particular versions of Swift.<br>&gt; <br>&gt; You can find the proposal here:<br>&gt; <br>&gt; https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md &lt;https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md&gt;<br>&gt; <br>&gt; and the current text is also included below.<br>&gt; <br>&gt; Time is short, but feedback on this proposal is very welcome.<br>&gt; <br>&gt; Thanks,<br>&gt; <br>&gt; Anders<br>&gt; <br>&gt; Package Manager Support for Language Versions<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md&gt;<br>&gt; Author: Anders Bertelrud &lt;https://github.com/abertelrud&gt;<br>&gt; Status: Awaiting Review<br>&gt; Review manager: TBD<br>&gt;  &lt;https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md#introduction&gt;Introduction<br>&gt; <br>&gt; As new, source-incompatible versions of Swift come into use, there is a growing need for packages to be authored in a way that makes them usable from multiple versions of Swift. While package authors want to adopt new Swift versions as soon as possible, they also need to support their existing clients.<br>&gt; <br>&gt; Source incompatibilities can arise not only from changes to the language syntax, but also from changes to the Swift Standard Library and the Package Description API of the Swift Package Manager itself.<br>&gt; <br>&gt; Support for multiple Swift versions could in theory be implemented using #if directives in the package source code, but that approach can become unwieldy when the required code differences are significant.<br>&gt; <br>&gt; The Swift Package Manager should therefore provide facilities that make it as easy as possible for package authors to support clients using different versions of Swift. The proposal described here intends to solve an immediate need for Swift Package Manager 3; the need for version-specific packages will hopefully diminish as the language and libraries stabilize. We can revisit the need for this support in a future version of Swift.<br>&gt; <br>&gt;  &lt;https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md#motivation&gt;Motivation<br>&gt; <br>&gt; It is important to allow Swift users to migrate to new Swift versions as easily as possible. At the same time, packages need to stay compatible with existing clients who are not yet ready to migrate.<br>&gt; <br>&gt; A new version of Swift means a new version of the language, the Standard Library API, and SwiftPM&#39;s own Package Description API. In some cases it&#39;s possible to use #if directives to let a single source base build using different versions of Swift. When the code differences are significant, however, it&#39;s impractical to use conditional code, and some other way to differentiate is needed. This is particularly true for new versions of the Swift Package Manager, as the manifest format evolves.<br>&gt; <br>&gt; Making this practical requires some improvements to the Package Manager, but to see why, it is useful to look at why current workarounds would be impractical:<br>&gt; <br>&gt;  &lt;https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md#impractical-workaround-1&gt;Impractical workaround #1:<br>&gt; <br>&gt; A strategy that wouldn&#39;t require any Swift Package Manager changes would be to require package authors to tie the semantic versions(1 &lt;http://semver.org/&gt;) of their packages to specific versions of Swift itself. For example, a package author could decide that version 1 of their package would work only with Swift 2.3, and package version 2 would work only with Swift 3.<br>&gt; <br>&gt; Using different package versions for the different Swift versions would take advantage of the Package Manager&#39;s existing version matching logic to make sure that the right package is chosen, and the right package for the Swift version would automatically be chosen.<br>&gt; <br>&gt; However, this doesn&#39;t seem like a particularly acceptable restriction, since it ties the release cycles of packages to those of Swift itself. This coupling between new Swift versions and new versions of all packages in use by a client would introduce significant revlock, which may seriously impact adoption. In particular, a client that wanted or needed to migrate to a new version of a package couldn&#39;t do so until they also migrated to a new version of Swift itself. In addition, they would at the same time have to migrate to newer versions of any other package on which they depend (assuming that such newer versions even exist).<br>&gt; <br>&gt; This is particularly unfortunate in cases in which only the package manifest needs to be different, since that would cause a package that could otherwise support multiple Swift versions to have to bifurcate.<br>&gt; <br>&gt; What is needed is a way to allow differentiation of packages by not just their own semantic version, but also the version of Swift being used.<br>&gt; <br>&gt;  &lt;https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md#impractical-workaround-2&gt;Impractical workaround #2:<br>&gt; <br>&gt; Another possible strategy would be to choose package version numbers that also incorporate the version of Swift they require, thereby &quot;flattening&quot; the two version numbers involved (package version and Swift version) into one.<br>&gt; <br>&gt; One could come up with various schemes for this, such as assigning odd-valued package version numbers to prerelease versions of the Swift language, and even-valued package version numbers to release versions of the Swift language.<br>&gt; <br>&gt; But this would pollute the version space, and it also sends the wrong message about semantic versioning (which is a strategy that we want package authors to use). Encouraging the abuse of the major version number for other things than the package API is not in the best interest of the maintainability of the package ecosystem.<br>&gt; <br>&gt;  &lt;https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md#solution-goals&gt;Solution Goals<br>&gt; <br>&gt; The solution needs to:<br>&gt; <br>&gt; ensure that the established package ecosystem graph continues to work as-is, even as packages supporting new Swift versions are published<br>&gt; <br>&gt; support parallel co-existence of actively maintained package graphs for:<br>&gt; <br>&gt; the latest stable (release) version of Swift<br>&gt; <br>&gt; the most recent pre-release version of Swift<br>&gt; <br>&gt; any older versions of Swift that still need to be supported<br>&gt; <br>&gt; (note that &quot;Swift version&quot; here includes not just the syntax of the language, but also the Standard Library API and the Package Description API)<br>&gt; <br>&gt; The Swift Package Manager should make it as easy as possible for a package to support multiple Swift versions using a single package repository, when that is possible with respect to the magnitude of the requires source differences).<br>&gt; <br>&gt; An additional, more abstract goal, is to encourage the whole Swift ecosystem to move forward as quickly as possible. This means optimizing for a workflow that involves latest-GM, current-prerelease, and current-development version, but ideally not a long tail of old GM versions.<br>&gt; <br>&gt;  &lt;https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md#proposed-solution&gt;Proposed Solution<br>&gt; <br>&gt; There are two parts to the proposed solution:<br>&gt; <br>&gt; provide package authors with a way to differentiate package repository version tags by Swift version, to support multiple editions of a single semantic package version<br>&gt; <br>&gt; provide package authors with a way to provide multiple package manifests for a single package version tag, differentiated by Swift version<br>&gt; <br>&gt; In both cases, version-based name suffixes are used to allow Package Manager to resolve dependencies based on package version as well as Swift version.<br>&gt; <br>&gt;  &lt;https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md#version-differentiated-package-tags&gt;Version-differentiated package tags<br>&gt; <br>&gt; When selecting the version of a package dependency to use for a particular client, the Swift Package Manager uses a repository tag naming convention based on the specified version restrictions of the package.<br>&gt; <br>&gt; For example, a client that specifies this dependency in its Package.swift:<br>&gt; <br>&gt; .Package(url: &quot;https://github.com/apple/example-package-deckofplayingcards.git &lt;https://github.com/apple/example-package-deckofplayingcards.git&gt;&quot;,<br>&gt;          majorVersion: 2)<br>&gt; causes the package manager to look for tags in the form of a semantic version (see semver.org &lt;http://semver.org/&gt; for more information).<br>&gt; <br>&gt; In this example, only tags having a major version number of 2 are considered, and the highest version among them is the one that is selected.<br>&gt; <br>&gt; Other restrictions involving minor versions and version ranges can be specified in the client&#39;s Package.swift manifest.<br>&gt; <br>&gt; Regardless of how the desired version restrictions are specified, the highest semantic version that matches the restrictions is the one that is selected when resolving dependencies.<br>&gt; <br>&gt; This proposal would allow an optional Swift version to appended to the package version, separated from it by a @swift-string.<br>&gt; <br>&gt; This can be used to provide two separate tags for the same package version, differentiated only by Swift version. For example, version 1.0 of MyPackage could have a 1.0 at swift-2.3 tag and a 1.0 at swift-3 tag.<br>&gt; <br>&gt; The expected use case for this is when the differences required to support two or more versions of Swift are large enough that it would be impractical to implement them in the same checkout of the repository.<br>&gt; <br>&gt; The new logic would first look for tag names having such a Swift version suffix that matches the version of Swift the client wants to use, and if found, omits from consideration any tags that do not have that suffix. The existing logic would be applied to the remaining set of tag candidates.<br>&gt; <br>&gt; The format of the swift version is not itself a semantic version, but instead follows the Swift marketing versions used. For matching, the number of digits specified affects the precision of the matching; for example, @swift-3 would match any version Swift 3.x.x version, while @swift-3.0 would match only Swift 3.0.x but not Swift 3.1 etc.<br>&gt; <br>&gt; The most specific version suffix matching the client&#39;s Swift version is used. For example, if both a @swift-3 and a @swift-3.1 tag are found, Swift 3.1 would use the latter and Swift 3.2 would use the former.<br>&gt; <br>&gt; If no tag names have the Swift version suffix, the matching would work as it currently does, using only the package version restrictions.<br>&gt; <br>&gt;  &lt;https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md#version-differentiated-package-manifests&gt;Version-differentiated package manifests<br>&gt; <br>&gt; Creating Swift-versioned tags for a particular package version has maintenance consequences. When possible, it&#39;s more maintainable for a package to support multiple Swift versions in a single tag of a repository. In the ideal case, no source changes are required at all in order to support two different Swift versions (this is the case, for example, between Swift 2.2 and Swift 2.3).<br>&gt; <br>&gt; When the required changes are minimal and a single package manifest can be used, #if directives in the source code can be used to support any other differences between the Swift versions. This already works today.<br>&gt; <br>&gt; For the Package.swift manifest itself, though, it can be somewhat unwieldy to express differences using only #ifdirectives. This is the case whether the differences are due to language syntax changes (recall that Package.swiftmanifests are actually Swift source files) or due to changes in the Package Description API.<br>&gt; <br>&gt; To support this, this proposal would allow a Swift version to be appended to the base Package base name, separated from it by the string @swift-. For example, a package manifest specific to Swift 2.3 would have the file namePackage at swift-2.3.swift &lt;mailto:Package at swift-2.3.swift&gt;, while one that worked for any Swift 3.x version would be Package at swift-3.swift &lt;mailto:Package at swift-3.swift&gt;.<br>&gt; <br>&gt; As with versioned tags, in the absence of a version-specific Package.swift file, the Package Manager would use the regular Package.swift file.<br>&gt; <br>&gt; Often, a package author would use either version-differentiated package tags or version-differentiated package manifests, but they could also be used together when that makes sense.<br>&gt; <br>&gt; It is hoped that as the Swift language stabilizes and packages eventually drop support for older versions of Swift, many packages will be able to discard the version-specific variants and keep only Package.swift.<br>&gt; <br>&gt;  &lt;https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; There is not expected to be any impact on existing code, since this proposal adds on top of existing functionality.<br>&gt; <br>&gt;  &lt;https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md#alternatives&gt;Alternatives<br>&gt; <br>&gt; Do nothing and let package authors invent their own ways. For the reasons spelled out in the Motivation section, this very undesirable. However, given how close we are to Swift 3&#39;s completion date, there is a possibility that there will not be time to implement this proposal for Swift 3.<br>&gt; <br>&gt; The consequence would be that future changes to the Package Description API would cause existing packages to break, which could significantly obstruct package adoption of new versions of Swift.<br>&gt; <br>&gt; Add declarations to the Package.swift manifest to specify the required Swift version or version range. This has a number of problems, including the fact that all of the various manifests would need to be checked out before deciding which to exclude from consideration. Another problems is that such minimum-version requirement declarations would have to be able to be parsed by older versions of the Package Manager, and this is not a guarantee we can make (the manifest might not be parseable using an older version of Swift).<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br></p><p>-- <br>Development thoughts at http://akrabat.com<br>Daily Jotter for Mac OS X at http://dailyjotter.com<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160728/d9e6382c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>Proposal: SwiftPM Support for Language Versions</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>July 28, 2016 at 09:00:00am</p></header><div class="content"><p>Can you clarify your question. What do you mean &quot;does this tie-in&quot;?<br></p><p>Yes, they definitely interact. However, this proposal is largely targeted at making sure SwiftPM 3.0 _can_ remain viable for some period of time, and it will not have the features mentioned here. So what we need is a mechanism by which package authors can make the graph continue to work with SwiftPM 3.0 while still being able to move forward. Does that help clarify?<br></p><p> - Daniel<br></p><p>&gt; On Jul 27, 2016, at 11:11 PM, Rob Allen via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; Does this tie-in with the post from Ted?<br>&gt; <br>&gt; The subject line &quot;[swift-dev] End of source-breaking changes for Swift 3&quot; where he says:<br>&gt; &quot;The Swift team at Apple has reflected on this and decided what it &quot;means&quot; for Swift 3 to be source compatible with Swift 4 and later releases going forward. Our goal is to allow app developers to combine a mix of Swift modules (e.g., SwiftPM packages), where each module is known to compile with a specific version of the language (module A works with Swift 3, module B works with Swift 3.1, etc.), then combine those modules into a single binary. The key feature is that a module can be migrated from Swift 3 to 3.1 to 4 (and beyond) independently of its dependencies.&quot;<br>&gt; <br>&gt; [...]<br>&gt; <br>&gt; &quot;To make this more concrete, suppose an application is written to use Swift 4, but uses packages via SwiftPM that are written using Swift 3. A single compiler would build both the app and the packages — thus ensuring that all the compiled sources are binary compatible.&quot;<br>&gt; <br>&gt; <br>&gt; Regards,<br>&gt; <br>&gt; Rob...<br>&gt; <br>&gt; <br>&gt;&gt; On 27 Jul 2016, at 09:54, Anders Bertelrud via swift-build-dev &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello,<br>&gt;&gt; <br>&gt;&gt; This is a proposal to enhance the SwiftPM package selection logic so that packages can be differentiated based on Swift version in addition to package version.  It does not introduce any source-breaking changes, but defines a way for package authors to annotate repositories and package manifests so that SwiftPM can exclude those that are usable only for particular versions of Swift.<br>&gt;&gt; <br>&gt;&gt; You can find the proposal here:<br>&gt;&gt; <br>&gt;&gt; https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md &lt;https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md&gt;<br>&gt;&gt; <br>&gt;&gt; and the current text is also included below.<br>&gt;&gt; <br>&gt;&gt; Time is short, but feedback on this proposal is very welcome.<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; <br>&gt;&gt; Anders<br>&gt;&gt; <br>&gt;&gt; Package Manager Support for Language Versions<br>&gt;&gt; <br>&gt;&gt; Proposal: SE-NNNN &lt;https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md&gt;<br>&gt;&gt; Author: Anders Bertelrud &lt;https://github.com/abertelrud&gt;<br>&gt;&gt; Status: Awaiting Review<br>&gt;&gt; Review manager: TBD<br>&gt;&gt;  &lt;https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md#introduction&gt;Introduction<br>&gt;&gt; <br>&gt;&gt; As new, source-incompatible versions of Swift come into use, there is a growing need for packages to be authored in a way that makes them usable from multiple versions of Swift. While package authors want to adopt new Swift versions as soon as possible, they also need to support their existing clients.<br>&gt;&gt; <br>&gt;&gt; Source incompatibilities can arise not only from changes to the language syntax, but also from changes to the Swift Standard Library and the Package Description API of the Swift Package Manager itself.<br>&gt;&gt; <br>&gt;&gt; Support for multiple Swift versions could in theory be implemented using #if directives in the package source code, but that approach can become unwieldy when the required code differences are significant.<br>&gt;&gt; <br>&gt;&gt; The Swift Package Manager should therefore provide facilities that make it as easy as possible for package authors to support clients using different versions of Swift. The proposal described here intends to solve an immediate need for Swift Package Manager 3; the need for version-specific packages will hopefully diminish as the language and libraries stabilize. We can revisit the need for this support in a future version of Swift.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md#motivation&gt;Motivation<br>&gt;&gt; <br>&gt;&gt; It is important to allow Swift users to migrate to new Swift versions as easily as possible. At the same time, packages need to stay compatible with existing clients who are not yet ready to migrate.<br>&gt;&gt; <br>&gt;&gt; A new version of Swift means a new version of the language, the Standard Library API, and SwiftPM&#39;s own Package Description API. In some cases it&#39;s possible to use #if directives to let a single source base build using different versions of Swift. When the code differences are significant, however, it&#39;s impractical to use conditional code, and some other way to differentiate is needed. This is particularly true for new versions of the Swift Package Manager, as the manifest format evolves.<br>&gt;&gt; <br>&gt;&gt; Making this practical requires some improvements to the Package Manager, but to see why, it is useful to look at why current workarounds would be impractical:<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md#impractical-workaround-1&gt;Impractical workaround #1:<br>&gt;&gt; <br>&gt;&gt; A strategy that wouldn&#39;t require any Swift Package Manager changes would be to require package authors to tie the semantic versions(1 &lt;http://semver.org/&gt;) of their packages to specific versions of Swift itself. For example, a package author could decide that version 1 of their package would work only with Swift 2.3, and package version 2 would work only with Swift 3.<br>&gt;&gt; <br>&gt;&gt; Using different package versions for the different Swift versions would take advantage of the Package Manager&#39;s existing version matching logic to make sure that the right package is chosen, and the right package for the Swift version would automatically be chosen.<br>&gt;&gt; <br>&gt;&gt; However, this doesn&#39;t seem like a particularly acceptable restriction, since it ties the release cycles of packages to those of Swift itself. This coupling between new Swift versions and new versions of all packages in use by a client would introduce significant revlock, which may seriously impact adoption. In particular, a client that wanted or needed to migrate to a new version of a package couldn&#39;t do so until they also migrated to a new version of Swift itself. In addition, they would at the same time have to migrate to newer versions of any other package on which they depend (assuming that such newer versions even exist).<br>&gt;&gt; <br>&gt;&gt; This is particularly unfortunate in cases in which only the package manifest needs to be different, since that would cause a package that could otherwise support multiple Swift versions to have to bifurcate.<br>&gt;&gt; <br>&gt;&gt; What is needed is a way to allow differentiation of packages by not just their own semantic version, but also the version of Swift being used.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md#impractical-workaround-2&gt;Impractical workaround #2:<br>&gt;&gt; <br>&gt;&gt; Another possible strategy would be to choose package version numbers that also incorporate the version of Swift they require, thereby &quot;flattening&quot; the two version numbers involved (package version and Swift version) into one.<br>&gt;&gt; <br>&gt;&gt; One could come up with various schemes for this, such as assigning odd-valued package version numbers to prerelease versions of the Swift language, and even-valued package version numbers to release versions of the Swift language.<br>&gt;&gt; <br>&gt;&gt; But this would pollute the version space, and it also sends the wrong message about semantic versioning (which is a strategy that we want package authors to use). Encouraging the abuse of the major version number for other things than the package API is not in the best interest of the maintainability of the package ecosystem.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md#solution-goals&gt;Solution Goals<br>&gt;&gt; <br>&gt;&gt; The solution needs to:<br>&gt;&gt; <br>&gt;&gt; ensure that the established package ecosystem graph continues to work as-is, even as packages supporting new Swift versions are published<br>&gt;&gt; <br>&gt;&gt; support parallel co-existence of actively maintained package graphs for:<br>&gt;&gt; <br>&gt;&gt; the latest stable (release) version of Swift<br>&gt;&gt; <br>&gt;&gt; the most recent pre-release version of Swift<br>&gt;&gt; <br>&gt;&gt; any older versions of Swift that still need to be supported<br>&gt;&gt; <br>&gt;&gt; (note that &quot;Swift version&quot; here includes not just the syntax of the language, but also the Standard Library API and the Package Description API)<br>&gt;&gt; <br>&gt;&gt; The Swift Package Manager should make it as easy as possible for a package to support multiple Swift versions using a single package repository, when that is possible with respect to the magnitude of the requires source differences).<br>&gt;&gt; <br>&gt;&gt; An additional, more abstract goal, is to encourage the whole Swift ecosystem to move forward as quickly as possible. This means optimizing for a workflow that involves latest-GM, current-prerelease, and current-development version, but ideally not a long tail of old GM versions.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md#proposed-solution&gt;Proposed Solution<br>&gt;&gt; <br>&gt;&gt; There are two parts to the proposed solution:<br>&gt;&gt; <br>&gt;&gt; provide package authors with a way to differentiate package repository version tags by Swift version, to support multiple editions of a single semantic package version<br>&gt;&gt; <br>&gt;&gt; provide package authors with a way to provide multiple package manifests for a single package version tag, differentiated by Swift version<br>&gt;&gt; <br>&gt;&gt; In both cases, version-based name suffixes are used to allow Package Manager to resolve dependencies based on package version as well as Swift version.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md#version-differentiated-package-tags&gt;Version-differentiated package tags<br>&gt;&gt; <br>&gt;&gt; When selecting the version of a package dependency to use for a particular client, the Swift Package Manager uses a repository tag naming convention based on the specified version restrictions of the package.<br>&gt;&gt; <br>&gt;&gt; For example, a client that specifies this dependency in its Package.swift:<br>&gt;&gt; <br>&gt;&gt; .Package(url: &quot;https://github.com/apple/example-package-deckofplayingcards.git &lt;https://github.com/apple/example-package-deckofplayingcards.git&gt;&quot;,<br>&gt;&gt;          majorVersion: 2)<br>&gt;&gt; causes the package manager to look for tags in the form of a semantic version (see semver.org &lt;http://semver.org/&gt; for more information).<br>&gt;&gt; <br>&gt;&gt; In this example, only tags having a major version number of 2 are considered, and the highest version among them is the one that is selected.<br>&gt;&gt; <br>&gt;&gt; Other restrictions involving minor versions and version ranges can be specified in the client&#39;s Package.swift manifest.<br>&gt;&gt; <br>&gt;&gt; Regardless of how the desired version restrictions are specified, the highest semantic version that matches the restrictions is the one that is selected when resolving dependencies.<br>&gt;&gt; <br>&gt;&gt; This proposal would allow an optional Swift version to appended to the package version, separated from it by a @swift-string.<br>&gt;&gt; <br>&gt;&gt; This can be used to provide two separate tags for the same package version, differentiated only by Swift version. For example, version 1.0 of MyPackage could have a 1.0 at swift-2.3 tag and a 1.0 at swift-3 tag.<br>&gt;&gt; <br>&gt;&gt; The expected use case for this is when the differences required to support two or more versions of Swift are large enough that it would be impractical to implement them in the same checkout of the repository.<br>&gt;&gt; <br>&gt;&gt; The new logic would first look for tag names having such a Swift version suffix that matches the version of Swift the client wants to use, and if found, omits from consideration any tags that do not have that suffix. The existing logic would be applied to the remaining set of tag candidates.<br>&gt;&gt; <br>&gt;&gt; The format of the swift version is not itself a semantic version, but instead follows the Swift marketing versions used. For matching, the number of digits specified affects the precision of the matching; for example, @swift-3 would match any version Swift 3.x.x version, while @swift-3.0 would match only Swift 3.0.x but not Swift 3.1 etc.<br>&gt;&gt; <br>&gt;&gt; The most specific version suffix matching the client&#39;s Swift version is used. For example, if both a @swift-3 and a @swift-3.1 tag are found, Swift 3.1 would use the latter and Swift 3.2 would use the former.<br>&gt;&gt; <br>&gt;&gt; If no tag names have the Swift version suffix, the matching would work as it currently does, using only the package version restrictions.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md#version-differentiated-package-manifests&gt;Version-differentiated package manifests<br>&gt;&gt; <br>&gt;&gt; Creating Swift-versioned tags for a particular package version has maintenance consequences. When possible, it&#39;s more maintainable for a package to support multiple Swift versions in a single tag of a repository. In the ideal case, no source changes are required at all in order to support two different Swift versions (this is the case, for example, between Swift 2.2 and Swift 2.3).<br>&gt;&gt; <br>&gt;&gt; When the required changes are minimal and a single package manifest can be used, #if directives in the source code can be used to support any other differences between the Swift versions. This already works today.<br>&gt;&gt; <br>&gt;&gt; For the Package.swift manifest itself, though, it can be somewhat unwieldy to express differences using only #ifdirectives. This is the case whether the differences are due to language syntax changes (recall that Package.swiftmanifests are actually Swift source files) or due to changes in the Package Description API.<br>&gt;&gt; <br>&gt;&gt; To support this, this proposal would allow a Swift version to be appended to the base Package base name, separated from it by the string @swift-. For example, a package manifest specific to Swift 2.3 would have the file namePackage at swift-2.3.swift &lt;mailto:Package at swift-2.3.swift&gt;, while one that worked for any Swift 3.x version would be Package at swift-3.swift &lt;mailto:Package at swift-3.swift&gt;.<br>&gt;&gt; <br>&gt;&gt; As with versioned tags, in the absence of a version-specific Package.swift file, the Package Manager would use the regular Package.swift file.<br>&gt;&gt; <br>&gt;&gt; Often, a package author would use either version-differentiated package tags or version-differentiated package manifests, but they could also be used together when that makes sense.<br>&gt;&gt; <br>&gt;&gt; It is hoped that as the Swift language stabilizes and packages eventually drop support for older versions of Swift, many packages will be able to discard the version-specific variants and keep only Package.swift.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt; <br>&gt;&gt; There is not expected to be any impact on existing code, since this proposal adds on top of existing functionality.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/abertelrud/swift-evolution/blob/swiftpm-language-version-support/proposals/NNNN-package-manager-support-for-language-versions.md#alternatives&gt;Alternatives<br>&gt;&gt; <br>&gt;&gt; Do nothing and let package authors invent their own ways. For the reasons spelled out in the Motivation section, this very undesirable. However, given how close we are to Swift 3&#39;s completion date, there is a possibility that there will not be time to implement this proposal for Swift 3.<br>&gt;&gt; <br>&gt;&gt; The consequence would be that future changes to the Package Description API would cause existing packages to break, which could significantly obstruct package adoption of new versions of Swift.<br>&gt;&gt; <br>&gt;&gt; Add declarations to the Package.swift manifest to specify the required Swift version or version range. This has a number of problems, including the fact that all of the various manifests would need to be checked out before deciding which to exclude from consideration. Another problems is that such minimum-version requirement declarations would have to be able to be parsed by older versions of the Package Manager, and this is not a guarantee we can make (the manifest might not be parseable using an older version of Swift).<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-build-dev mailing list<br>&gt;&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br>&gt; <br>&gt; -- <br>&gt; Development thoughts at http://akrabat.com &lt;http://akrabat.com/&gt;<br>&gt; Daily Jotter for Mac OS X at http://dailyjotter.com &lt;http://dailyjotter.com/&gt;<br>&gt; _______________________________________________<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160728/236daef2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/79d9ba388d6b6cf4ec7310cad9fa8c8a?s=50"></div><header><strong>Proposal: SwiftPM Support for Language Versions</strong> from <string>Rob Allen</string> &lt;rob at akrabat.com&gt;<p>July 29, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On 28 Jul 2016, at 18:37, Daniel Dunbar &lt;daniel_dunbar at apple.com&gt; wrote:<br>&gt; <br>&gt; Can you clarify your question. What do you mean &quot;does this tie-in&quot;?<br>&gt; <br>&gt; Yes, they definitely interact. However, this proposal is largely targeted at making sure SwiftPM 3.0 _can_ remain viable for some period of time, and it will not have the features mentioned here. So what we need is a mechanism by which package authors can make the graph continue to work with SwiftPM 3.0 while still being able to move forward. Does that help clarify?<br></p><p>It does, thanks.<br></p><p>Rob...<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
