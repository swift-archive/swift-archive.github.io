<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[RFC] UnsafeBytePointer API for In-Memory Layout</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>May  9, 2016 at 11:00:00am</p></header><div class="content"><p>Hello Swift evolution,<br></p><p>I sent this to swift-dev last week. Sorry to post on two lists!<br></p><p>Swift does a great job of protecting against undefined behavior--as long as you avoid &quot;unsafe&quot; APIs, that is. However, unsafe APIs are important for giving developers control over implementation details and performance. Naturally, the contract between unsafe APIs and the optimizer is crucial. When a developer uses an unsafe API, the rules governing safe, well-defined behavior must be clear. On the opposite end, the optimizer must know which assumptions it can make based on those rules. Simply saying that anything goes because &quot;unsafe&quot; is in the name is not helpful to this effort.<br></p><p>For a long time, I&#39;ve wanted these rules nailed down. We have more users taking advantage of advanced features, and more optimizations that take advantage of assumptions guided by the type system. This seems like a particularly good time to resolve UnsafePointer semantics, considering the type system and UnsafePointer work that&#39;s been going on recently. Strict aliasing is something I would like addressed. If we do nothing here, then we will end up by default inheriting C/C++ semantics, as with any language that relies on a C/C++ backend. In other words, developers will be forced to write code with technically undefined behavior and rely on the compiler to be smart enough to recognize and recover from common patterns. Or we can take advantage of this opportunity and instead adopt a sound memory model with respect to aliasing.<br></p><p>This proposal is only an RFC at this point. I&#39;m sending it out now to allow for plenty of time for discussion (or advance warning). Keep in mind that it could change considerably before it goes up for review.<br></p><p>-Andy<br></p><p><br>UnsafeBytePointer API for In-Memory Layout<br></p><p>Proposal: SE-NNNN &lt;https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsafebytepointer.md&gt;<br>Author(s): Andrew Trick &lt;https://github.com/atrick&gt;<br>Status: Awaiting review &lt;https://github.com/atrick/swift-evolution/tree/voidpointer/proposals#rationale&gt;<br>Review manager: TBD<br> &lt;https://github.com/atrick/swift-evolution/tree/voidpointer/proposals#introduction&gt;Introduction<br></p><p>UnsafePointer and UnsafeMutable refer to a typed region of memory, and the compiler must be able to assume that UnsafePointer element (Pointee) type is consistent with other access to the same memory. See proposed Type Safe Memory Access documentation &lt;https://github.com/atrick/swift/blob/type-safe-mem-docs/docs/TypeSafeMemory.rst&gt;. Consequently, inferred conversion between UnsafePointer element types exposes an easy way to abuse the type system. No alternative currently exists for manual memory layout and direct access to untyped memory, and that leads to an overuse of UnsafePointer. These uses of UnsafePointer, which depend on pointer type conversion, make accidental type punning likely. Type punning via UnsafePointer is semantically undefined behavior and de facto undefined behavior given the optimizer&#39;s long-time treatment of UnsafePointer.<br></p><p>In this document, all mentions of UnsafePointer also apply to UnsafeMutablePointer.<br></p><p> &lt;https://github.com/atrick/swift-evolution/tree/voidpointer/proposals#motivation&gt;Motivation<br></p><p>To avoid accidental type punning, we should prohibit inferred conversion between UnsafePointer&lt;T&gt; and UnsafePointer&lt;U&gt; unless the target of the conversion is an untyped or nondereferenceable pointer (currently represented as UnsafePointer&lt;Void&gt;).<br></p><p>To support this change we should introduce a new pointer type that does not bind the type of its Pointee. Such a new pointer type would provide an ideal foundation for an API that allows byte-wise pointer arithmetic and a legal, well-defined means to access an untyped region of memory.<br></p><p>As motivation for such an API, consider that an UnsafePointer&lt;Void&gt; or OpaquePointer may be currently be obtained from an external API. However, the developer may know the memory layout and may want to read or write elements whose types are compatible with that layout. This a reasonable use case, but unless the developer can guarantee that all accesses to the same memory location have the same type, then they cannot use UnsafePointer to access the memory without risking undefined behavior.<br></p><p>An UnsafeBytePointer example, using a new proposed API is included below.<br></p><p> &lt;https://github.com/atrick/swift-evolution/tree/voidpointer/proposals#proposed-solution&gt;Proposed solution<br></p><p>Introduce an UnsafeBytePointer type along with an API for obtaining a UnsafeBytePointer value at a relative byte offset and loading and storing arbitrary types at that location.<br></p><p>Statically prohibit inferred UnsafePointer conversion while allowing inferred UnsafePointer to UnsafeBytePointerconversion.<br></p><p>UnsafeBytePointer meets multiple requirements:<br></p><p>An untyped pointer to memory<br>Pointer arithmetic within byte-addressable memory<br>Type-unsafe access to memory (legal type punning)<br>UnsafeBytePointer will replace UnsafeMutablePointer&lt;Void&gt; as the representation for untyped memory. For API clarify we could consider a typealias for VoidPointer. I don&#39;t think a separate VoidPointer type would be useful--there&#39;s no danger that UnsafeBytePointer will be casually dereferenced, and don&#39;t see the danger in allowing pointer arithmetic since the only reasonable interpretation is that of a byte-addressable memory.<br></p><p>Providing an API for type-unsafe memory access would not serve a purpose without the ability to compute byte offsets. Of course, we could require users to convert back and forth using bitPatterns, but I think that would be awkward and only obscure the purpose of the UnsafeBytePointer type.<br></p><p>In this proposal, UnsafeBytePointer does not specify mutability. Adding an UnsafeMutableBytePointer would be straightforward, but adding another pointer type needs strong justification. I expect to get input from the community on this. If we agree that the imported type for const void* should be UnsafeBytePointer, then we probably need UnsafeMutablePointer to handle interoperability.<br></p><p> &lt;https://github.com/atrick/swift-evolution/tree/voidpointer/proposals#detailed-design&gt;Detailed design<br></p><p>The public API is shown here. For details and comments, see the unsafeptr_convert branch &lt;https://github.com/atrick/swift/commits/unsafeptr_convert&gt;.<br></p><p>struct UnsafeBytePointer : Hashable, _Pointer {<br></p><p>  let _rawValue: Builtin.RawPointer<br></p><p>  var hashValue: Int {...}<br></p><p>  init&lt;T&gt;(_ : UnsafePointer&lt;T&gt;)<br>  init&lt;T&gt;(_ : UnsafeMutablePointer&lt;T&gt;)<br>  init?&lt;T&gt;(_ : UnsafePointer&lt;T&gt;?)<br>  init?&lt;T&gt;(_ : UnsafeMutablePointer&lt;T&gt;?)<br></p><p>  init&lt;T&gt;(_ : OpaquePointer&lt;T&gt;)<br>  init?&lt;T&gt;(_ : OpaquePointer&lt;T&gt;?)<br></p><p>  init?(bitPattern: Int)<br>  init?(bitPattern: UInt)<br></p><p>  func load&lt;T&gt;(_ : T.Type) -&gt; T<br></p><p>  @warn_unused_result<br>  init(allocatingBytes size: Int, alignedTo: Int)<br></p><p>  @warn_unused_result<br>  init&lt;T&gt;(allocatingCapacity count: Int, of: T.Type)<br></p><p>  func deallocateBytes(_ size: Int, alignedTo: Int)<br></p><p>  func deallocateCapacity&lt;T&gt;(_ num: Int, of: T.Type)<br></p><p>  // Returns a pointer one byte after the initialized memory.<br>  func initialize&lt;T&gt;(with newValue: T, count: Int = 1) -&gt; UnsafeBytePointer<br></p><p>  // Returns a pointer one byte after the initialized memory.<br>  func initialize&lt;T&gt;(from: UnsafePointer&lt;T&gt;, count: Int) -&gt; UnsafeBytePointer<br></p><p>  func initializeBackward&lt;T&gt;(from source: UnsafePointer&lt;T&gt;, count: Int)<br></p><p>  func deinitialize&lt;T&gt;(_ : T.Type, count: Int = 1)<br>}<br></p><p>extension OpaquePointer {<br>  init(_ : UnsafeBytePointer)<br>}<br></p><p>extension Int {<br>  init(bitPattern: UnsafeBytePointer)<br>}<br></p><p>extension UInt {<br>  init(bitPattern: UnsafeBytePointer)<br>}<br></p><p>extension UnsafeBytePointer : RandomAccessIndex {<br>  typealias Distance = Int<br></p><p>  func successor() -&gt; UnsafeBytePointer<br>  func predecessor() -&gt; UnsafeBytePointer<br>  func distance(to : UnsafeBytePointer) -&gt; Int<br>  func advanced(by : Int) -&gt; UnsafeBytePointer<br>}<br></p><p>func == (lhs: UnsafeBytePointer, rhs: UnsafeBytePointer) -&gt; Bool<br></p><p>func &lt; (lhs: UnsafeBytePointer, rhs: UnsafeBytePointer) -&gt; Bool<br></p><p>func + (lhs: UnsafeBytePointer, rhs: Int) -&gt; UnsafeBytePointer<br></p><p>func + (lhs: Int, rhs: UnsafeBytePointer) -&gt; UnsafeBytePointer<br></p><p>func - (lhs: UnsafeBytePointer, rhs: Int) -&gt; UnsafeBytePointer<br></p><p>func - (lhs: UnsafeBytePointer, rhs: UnsafeBytePointer) -&gt; Int<br></p><p>func += (lhs: inout UnsafeBytePointer, rhs: Int)<br></p><p>func -= (lhs: inout UnsafeBytePointer, rhs: Int)<br>Occasionally, we need to convert from a UnsafeBytePointer to an UnsafePointer. This should only be done in very rare circumstances when the author understands the compiler&#39;s strict type rules for UnsafePointer. Although this could be done by casting through an OpaquePointer, an explicit, designated unsafe pointer cast API would makes the risks more obvious and self-documenting. For example:<br></p><p>extension UnsafePointer {<br>  init(_ from: UnsafeBytePointer, toPointee: Pointee.type)<br>}<br>extension UnsafeMutablePointer {<br>  init(_ from: UnsafeBytePointer, toPointee: Pointee.type)<br>}<br>Similarly, conversion between UnsafePointer types must now be spelled with an explicitly Pointee type:<br></p><p>extension UnsafePointer {<br>  init&lt;U&gt;(_ from: UnsafePointer&lt;U&gt;, toPointee: Pointee.Type)<br>  init&lt;U&gt;(_ from: UnsafeMutablePointer&lt;U&gt;, toPointee: Pointee.Type)<br>}<br>extension UnsafeMutablePointer {<br>  init&lt;U&gt;(_ from: UnsafeMutablePointer&lt;U&gt;, toPointee: Pointee.Type)<br>}<br> &lt;https://github.com/atrick/swift-evolution/tree/voidpointer/proposals#impact-on-existing-code&gt;Impact on existing code<br></p><p>The largest impact of this change is that void* and const void* are imported as UnsafeBytePointer. This impacts many public APIs, but with implicit argument conversion should not affect typical uses of those APIs.<br></p><p>Any Swift projects that rely on type inference to convert between UnsafePointer types will need to take action. The developer needs to determine whether type punning is necessary. If so, they must migrate to the UnsafeBytePointer API. Otherwise, they can work around the new restriction by using a toPointee, or mutating label.<br></p><p>Disallowing inferred UnsafePointer direct conversion requires some standard library code to use an explicit toPointeelabel for unsafe conversions that may violate strict aliasing.<br></p><p>All occurrences of Unsafe[Mutable]Pointer&lt;Void&gt; in the standard library are converted to UnsafeBytePointer. e.g. unsafeAddress() now returns UnsafeBytePointer, not UnsafePointer&lt;Void&gt;.<br></p><p>Some occurrences of Unsafe[Mutable]Pointer&lt;Pointee&gt; in the standard library are replaced with UnsafeBytePointer, either because the code was playing too loosely with strict aliasing rules, or because the code actually wanted to perform pointer arithmetic on byte-addresses.<br></p><p>StringCore.baseAddress changes from OpaquePointer to UnsafeBytePointer because it is computing byte offsets and accessing the memory. OpaquePointer is meant for bridging, but should be truly opaque; that is, nondereferenceable and not involved in address computation.<br></p><p>The StringCore implementation does a considerable amount of casting between different views of the String storage. The current implementation already demonstrates some awareness of strict aliasing rules. The rules are generally followed by ensuring that the StringBuffer only be accessed using the appropriate CodeUnit within Swift code. For interoperability and optimization, String buffers frequently need to be cast to and from CChar. This is valid as long access to the buffer from Swift is guarded by dynamic checks of the encoding type. These unsafe, but dynamically legal conversion points will now be labeled with toPointee.<br></p><p>CoreAudio utilities now use an UnsafeBytePointer.<br></p><p> &lt;https://github.com/atrick/swift-evolution/tree/voidpointer/proposals#implementation-status&gt;Implementation status<br></p><p>On my unsafeptr_convert branch &lt;https://github.com/atrick/swift/commits/unsafeptr_convert&gt;, I&#39;ve made most of the necessary changes to support the addition of UnsafeBytePointerand the removal of inferred UnsafePointer conversion.<br></p><p>There are a several things going on here in order to make it possible to build the standard library with the changes:<br></p><p>A new UnsafeBytePointer type is defined.<br></p><p>The type system imports void* as UnsafeBytePointer.<br></p><p>The type system handles implicit conversions to UnsafeBytePointer.<br></p><p>UnsafeBytePointer replaces both UnsafePointer&lt;Void&gt; and UnsafeMutablePointer&lt;Void&gt;.<br></p><p>The standard library was relying on inferred UnsafePointer conversion in over 100 places. Most of these conversions now either take an explicit label, such as &#39;toPointee&#39;, &#39;mutating&#39;. Some have been rewritten.<br></p><p>Several places in the standard library that were playing loosely with strict aliasing or doing bytewise pointer arithmetic now use UnsafeBytePointer instead.<br></p><p>Explicit labeled Unsafe[Mutable]Pointer initializers are added.<br></p><p>The inferred Unsafe[Mutable]Pointer conversion is removed.<br></p><p>TODO:<br></p><p>Once this proposal is accepted, and the rules for casting between pointers types have been decided, we need to finish implementing the type system support. The current implementation (intentionally) breaks a few tests in pointer_conversion.swift. We also need to ensure that interoperability requirements are met. Currently, many argument casts to be explicitly labeled. The current implementation also makes it easy for users to hit an &quot;ambiguous use of &#39;init&#39;&quot; error when relying on implicit argument conversion.<br></p><p>Additionally:<br></p><p>A name mangled abbreviation needs to be created for UnsafeBytePointer.<br></p><p>The StringAPI tests should probably be rewritten with UnsafeBytePointer.<br></p><p>The NSStringAPI utilities and tests may need to be ported to UnsafeBytePointer<br></p><p>The CoreAudio utilities and tests may need to be ported to UnsafeBytePointer.<br></p><p> &lt;https://github.com/atrick/swift-evolution/tree/voidpointer/proposals#alternatives-considered&gt;Alternatives considered<br></p><p> &lt;https://github.com/atrick/swift-evolution/tree/voidpointer/proposals#existing-workaround&gt;Existing workaround<br></p><p>In some cases, developers can safely reinterpret values to achieve the same effect as type punning:<br></p><p>let ptrI32 = UnsafeMutablePointer&lt;Int32&gt;(allocatingCapacity: 1)<br>ptrI32[0] = Int32()<br>let u = unsafeBitCast(ptrI32[0], to: UInt32.self)<br>Note that all access to the underlying memory is performed with the same element type. This is perfectly legitimate, but simply isn&#39;t a complete solution. It also does not eliminate the inherent danger in declaring a typed pointer and expecting it to point to values of a different type.<br></p><p> &lt;https://github.com/atrick/swift-evolution/tree/voidpointer/proposals#discarded-alternatives&gt;Discarded alternatives<br></p><p>We considered adding a typePunnedMemory property to the existing Unsafe[Mutabale]Pointer API. This would provide a legal way to access a potentially type punned Unsafe[Mutabale]Pointer. However, it would certainly cause confusion without doing much to reduce likelihood of programmer error. Furthermore, there are no good use cases for such a property evident in the standard library.<br></p><p>The opaque _RawByte struct is a technique that allows for byte-addressable buffers while hiding the dangerous side effects of type punning (a _RawByte could be loaded but it&#39;s value cannot be directly inspected). UnsafePointer&lt;_RawByte&gt; is a clever alternative to UnsafeBytePointer. However, it doesn&#39;t do enough to prevent undefined behavior. The loaded _RawByte would naturally be accessed via unsafeBitCast, which would mislead the author into thinking that they have legally bypassed the type system. In actuality, this API blatantly violates strict aliasing. It theoretically results in undefined behavior as it stands, and may actually exhibit undefined behavior if the user recovers the loaded value.<br></p><p>To solve the safety problem with UnsafePointer&lt;_RawByte&gt;, the compiler could associate special semantics with a UnsafePointer bound to this concrete generic parameter type. Statically enforcing casting rules would be difficult if not impossible without new language features. It would also be impossible to distinguish between typed and untyped pointer APIs. For example, UnsafePointer&lt;T&gt;.load&lt;U&gt; would be a nonsensical vestige.<br></p><p> &lt;https://github.com/atrick/swift-evolution/tree/voidpointer/proposals#alternate-proposal-for-void-type&gt;Alternate proposal for void* type<br></p><p>Changing the imported type for void* will be somewhat disruptive. Furthermore, this proposal currently drops the distinction between void* and const void*--an obvious loss of API information.<br></p><p>We could continue to import void* as UnsafeMutablePointer&lt;Void&gt; and const void* as UnsafePointer&lt;Void&gt;, which will continue to serve as an &quot;opaque&quot; untyped pointer. Converting to UnsafeBytePointer would be necesarry to perform pointer arithmetic or to conservatively handle possible type punning.<br></p><p>This alternative is much less disruptive, but we are left with two forms of untyped pointer, one of which (UnsafePointer) the type system somewhat conflates with typed pointers.<br></p><p>Given the current restrictions of the language, it&#39;s not clear how to statically enforce the necessary rules for castingUnsafePointer&lt;Void&gt; once general UnsafePointer&lt;T&gt; conversions are disallowed. The following conversions should be inferred, and implied for function arguments (ignoring mutability):<br></p><p>UnsafePointer&lt;T&gt; to UnsafePointer&lt;Void&gt;<br></p><p>UnsafePointer&lt;Void&gt; to UnsafeBytePointer<br></p><p>I did not implement this simpler design because my primary goal was to enforce legal pointer conversion and rid Swift code of undefined behavior. I can&#39;t do that while allowing UnsafePointer conversions.<br></p><p> &lt;https://github.com/atrick/swift-evolution/tree/voidpointer/proposals#api-improvements&gt;API improvements<br></p><p>As proposed, the initialize API infers the stored value:<br></p><p>func initialize&lt;T&gt;(with newValue: T, count: Int = 1) -&gt; UnsafeBytePointer<br>This is somewhat dangerous because the developer may not realize the size of the object(s) that will be written to memory. This can be easily asserted by checking the return pointer:<br></p><p>let newptr = ptr.initialize(with: 3)<br>assert(newptr - ptr == 8)<br>As an alternative, we could force the user to provide the expected type name in the initialize invocation:<br></p><p>func initialize&lt;T&gt;(_ T.Type, with newValue: T, count: Int = 1)<br>  -&gt; UnsafeBytePointer<br> &lt;https://github.com/atrick/swift-evolution/tree/voidpointer/proposals#future-improvements&gt;Future improvements<br></p><p>UnsafeBytePointer should eventually support unaligned memory access. I believe that we will eventually have a modifier that allows &quot;packed&quot; struct members. At that time we may also want to add a &quot;packed&quot; flag to UnsafeBytePointer&#39;s load and initialize methods.<br></p><p>When accessing a memory buffer, it is generally convenient to cast to a type with known layout and compute offsets relative to the type&#39;s size. This is how UnsafePointer&lt;Pointee&gt; works. A generic UnsafeTypePunnedPointer&lt;Pointee&gt; could be introduced with the same interface as UnsafePointer&lt;Pointer&gt;, but without the strict aliasing requirements. This seems like an overdesign simply to avoid calling strideof() in an rare use case, but nothing prevents adding this type later.<br></p><p> &lt;https://github.com/atrick/swift-evolution/tree/voidpointer/proposals#unsafebytepointer-example&gt;UnsafeBytePointer example<br></p><p>/// An example of using UnsafeBytePointer to implement manual memory layout.<br></p><p>/// A Buffer for reading and writing basic types at a fixed address.<br>/// Indirection allows the buffer to refer to mutable state elsewhere.<br>struct MessageBuffer {<br>  let ptr: UnsafeBytePointer<br></p><p>  enum IndirectFlag { case Direct, Indirect }<br></p><p>  private func getPointer(atOffset n: Int, _ isIndirect: IndirectFlag)<br>  -&gt; UnsafeBytePointer {<br>    switch isIndirect {<br>    case .Indirect:<br>      return (ptr + n).load(UnsafeBytePointer.self)<br>    case .Direct:<br>      return ptr + n<br>    }<br>  }<br></p><p>  func readUInt32(atOffset n: Int, _ isIndirect: IndirectFlag) -&gt; UInt32 {<br>    return getPointer(atOffset: n, isIndirect).load(UInt32.self)<br>  }<br>  func readFloat32(atOffset n: Int, _ isIndirect: IndirectFlag) -&gt; Float32 {<br>    return getPointer(atOffset: n, isIndirect).load(Float32.self)<br>  }<br></p><p>  func writeUInt32(_ val: UInt32, atOffset n: Int) {<br>    getPointer(atOffset: n, .Direct).initialize(with: val)<br>  }<br>  func writeFloat32(_ val: Float32, atOffset n: Int) {<br>    getPointer(atOffset: n, .Direct).initialize(with: val)<br>  }<br>  func writeIndirect(_ ptr: UnsafeBytePointer, atOffset n: Int) {<br>    getPointer(atOffset: n, .Direct).initialize(with: ptr)<br>  }<br>}<br></p><p>/// Encoded message format.<br>struct MessageFormat : Sequence, IteratorProtocol {<br>  typealias Element = MessageFormat<br></p><p>  private static let maxFormatFields = 32 / 4<br>  static let maxBufferBytes = maxFormatFields * strideof(UInt)<br></p><p>  var formatCode: UInt32 = 0<br>  var elementCode: UInt32 = 0<br>  var offset: Int = 0<br></p><p>  init(bitPattern: UInt32) {<br>    formatCode = bitPattern<br>  }<br></p><p>  enum Kind {<br>    case None, Reserved, UInt32, Float32, IndirectUInt32, IndirectFloat32<br>  }<br></p><p>  /// The first field&#39;s kind.<br>  var kind : Kind {<br>    get {<br>      switch elementCode {<br>      case 0x0: return Kind.None<br>      case 0x2: return Kind.UInt32<br>      case 0x3: return Kind.Float32<br>      case 0x6: return Kind.IndirectUInt32<br>      case 0x7: return Kind.IndirectFloat32<br>      default:  return Kind.Reserved<br>      }<br>    }<br>  }<br></p><p>  func elementStride() -&gt; Int {<br>    return (elementCode &amp; 0x4) != 0 ? strideof(UInt) : 4<br>  }<br></p><p>  /// Get the format for the next element.<br>  mutating func next() -&gt; Element? {<br>    if elementCode != 0 {<br>      offset += elementStride()<br>    }<br>    elementCode = formatCode &amp; 0xF<br>    formatCode &gt;&gt;= 4<br>    if kind == .None {<br>      return nil<br>    }<br>    // align to the next element size<br>    let offsetMask = elementStride() - 1<br>    offset = (offset + offsetMask) &amp; ~offsetMask<br>    return self<br>  }<br>}<br></p><p>func createBuffer() -&gt; MessageBuffer {<br>  return MessageBuffer(ptr: UnsafeBytePointer(<br>      allocatingBytes: MessageFormat.maxBufferBytes, alignedTo: strideof(UInt)))<br>}<br></p><p>func destroy(buffer: MessageBuffer) {<br>  buffer.ptr.deallocateBytes(MessageFormat.maxBufferBytes,<br>    alignedTo: strideof(UInt))<br>}<br></p><p>var sharedInt: UInt32 = 42<br>var sharedFloat: Float32 = 16.25<br></p><p>func generateMessage(inBuffer mb: MessageBuffer) -&gt; MessageFormat {<br>  let mf = MessageFormat(bitPattern: 0x06727632)<br>  for field in mf {<br>    switch field.kind {<br>    case .UInt32:<br>      mb.writeUInt32(66, atOffset: field.offset)<br>    case .Float32:<br>      mb.writeFloat32(41.625, atOffset: field.offset)<br>    case .IndirectUInt32:<br>      mb.writeIndirect(&amp;sharedInt, atOffset: field.offset)<br>    case .IndirectFloat32:<br>      mb.writeIndirect(&amp;sharedFloat, atOffset: field.offset)<br>    case .None:<br>      fallthrough<br>    case .Reserved:<br>      return MessageFormat(bitPattern: 0)<br>    }<br>  }<br>  return mf<br>}<br></p><p>func handleMessage(buffer mb: MessageBuffer, format: MessageFormat) -&gt; Bool {<br>  for field in format {<br>    switch field.kind {<br>    case .UInt32:<br>      print(mb.readUInt32(atOffset: field.offset, .Direct))<br>    case .Float32:<br>      print(mb.readFloat32(atOffset: field.offset, .Direct))<br>    case .IndirectUInt32:<br>      print(mb.readUInt32(atOffset: field.offset, .Indirect))<br>    case .IndirectFloat32:<br>      print(mb.readFloat32(atOffset: field.offset, .Indirect))<br>    case .None:<br>      fallthrough<br>    case .Reserved:<br>      return false<br>    }<br>  }<br>  return true<br>}<br></p><p>func runProgram() {<br>  let mb = createBuffer()<br>  let mf = generateMessage(inBuffer: mb)<br>  if handleMessage(buffer: mb, format: mf) {<br>    print(&quot;Done&quot;)<br>  }<br>  destroy(buffer: mb)<br>}<br>runProgram()<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160509/ea1f6d86/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4db4fede2f4e473341b873406b68e4e1?s=50"></div><header><strong>[RFC] UnsafeBytePointer API for In-Memory Layout</strong> from <string>Geordie Jay</string> &lt;geojay at gmail.com&gt;<p>May  9, 2016 at 07:00:00pm</p></header><div class="content"><p>I read this proposal and I&#39;m a bit unsure what its purpose would be:<br></p><p>Basically you want to prevent UnsafePointer&lt;XYZ&gt;(UnsafePointer&lt;Void&gt;)<br>conversions and/or vice-versa? And you&#39;d achieve this by replacing<br>UnsafePointer&lt;Void&gt; with UnsafeBytePointer that has no bound pointer type?<br></p><p>In one sense the change seems fine to me, but as someone who uses a lot of<br>C APIs and a lot of CoreAudio/CoreMIDI in Swift already I can&#39;t really see<br>what benefit it&#39;d bring. Presumably we&#39;d still want an option of converting<br>UnsafeBytePointer to UnsafePointer&lt;SomeActualType&gt; for things like C<br>function pointer callback &quot;context&quot;/&quot;userInfo&quot; uses, so it&#39;s not like we&#39;d<br>be preventing programmer error in that way.<br></p><p>Call me conservative but to me the current system seems to work as well as<br>it can. If anything it&#39;s already enough boilerplate going through hoops<br>converting an UnsafeMutablePointer&lt;Void&gt; into a [Float] even when I know<br>and the C API knows perfectly well what it actually contains... Would<br>happily be convinced otherwise about this proposal though, I&#39;m pretty new<br>at all this.<br></p><p>Geordie<br>Andrew Trick via swift-evolution &lt;swift-evolution at swift.org&gt; schrieb am<br>Mo., 9. Mai 2016 um 20:15:<br></p><p>&gt; Hello Swift evolution,<br>&gt;<br>&gt; I sent this to swift-dev last week. Sorry to post on two lists!<br>&gt;<br>&gt; Swift does a great job of protecting against undefined behavior--as long<br>&gt; as you avoid &quot;unsafe&quot; APIs, that is. However, unsafe APIs are important for<br>&gt; giving developers control over implementation details and performance.<br>&gt; Naturally, the contract between unsafe APIs and the optimizer is crucial.<br>&gt; When a developer uses an unsafe API, the rules governing safe, well-defined<br>&gt; behavior must be clear. On the opposite end, the optimizer must know which<br>&gt; assumptions it can make based on those rules. Simply saying that anything<br>&gt; goes because &quot;unsafe&quot; is in the name is not helpful to this effort.<br>&gt;<br>&gt; For a long time, I&#39;ve wanted these rules nailed down. We have more users<br>&gt; taking advantage of advanced features, and more optimizations that take<br>&gt; advantage of assumptions guided by the type system. This seems like a<br>&gt; particularly good time to resolve UnsafePointer semantics, considering the<br>&gt; type system and UnsafePointer work that&#39;s been going on recently. Strict<br>&gt; aliasing is something I would like addressed. If we do nothing here, then<br>&gt; we will end up by default inheriting C/C++ semantics, as with any language<br>&gt; that relies on a C/C++ backend. In other words, developers will be forced<br>&gt; to write code with technically undefined behavior and rely on the compiler<br>&gt; to be smart enough to recognize and recover from common patterns. Or we can<br>&gt; take advantage of this opportunity and instead adopt a sound memory model<br>&gt; with respect to aliasing.<br>&gt;<br>&gt; This proposal is only an RFC at this point. I&#39;m sending it out now to<br>&gt; allow for plenty of time for discussion (or advance warning). Keep in mind<br>&gt; that it could change considerably before it goes up for review.<br>&gt;<br>&gt; -Andy<br>&gt;<br>&gt;<br>&gt; UnsafeBytePointer API for In-Memory Layout<br>&gt;<br>&gt;    - Proposal: SE-NNNN<br>&gt;    &lt;https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsafebytepointer.md&gt;<br>&gt;    - Author(s): Andrew Trick &lt;https://github.com/atrick&gt;<br>&gt;    - Status: Awaiting review<br>&gt;    &lt;https://github.com/atrick/swift-evolution/tree/voidpointer/proposals#rationale&gt;<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/atrick/swift-evolution/tree/voidpointer/proposals#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; UnsafePointer and UnsafeMutable refer to a typed region of memory, and<br>&gt; the compiler must be able to assume that UnsafePointer element (Pointee)<br>&gt; type is consistent with other access to the same memory. See proposed<br>&gt; Type Safe Memory Access documentation<br>&gt; &lt;https://github.com/atrick/swift/blob/type-safe-mem-docs/docs/TypeSafeMemory.rst&gt;.<br>&gt; Consequently, inferred conversion between UnsafePointer element types<br>&gt; exposes an easy way to abuse the type system. No alternative currently<br>&gt; exists for manual memory layout and direct access to untyped memory, and<br>&gt; that leads to an overuse of UnsafePointer. These uses of UnsafePointer,<br>&gt; which depend on pointer type conversion, make accidental type punning<br>&gt; likely. Type punning via UnsafePointer is semantically undefined behavior<br>&gt; and de facto undefined behavior given the optimizer&#39;s long-time treatment<br>&gt; of UnsafePointer.<br>&gt;<br>&gt; In this document, all mentions of UnsafePointer also apply to<br>&gt; UnsafeMutablePointer.<br>&gt;<br>&gt; &lt;https://github.com/atrick/swift-evolution/tree/voidpointer/proposals#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; To avoid accidental type punning, we should prohibit inferred conversion<br>&gt; between UnsafePointer&lt;T&gt; and UnsafePointer&lt;U&gt; unless the target of the<br>&gt; conversion is an untyped or nondereferenceable pointer (currently<br>&gt; represented as UnsafePointer&lt;Void&gt;).<br>&gt;<br>&gt; To support this change we should introduce a new pointer type that does<br>&gt; not bind the type of its Pointee. Such a new pointer type would provide<br>&gt; an ideal foundation for an API that allows byte-wise pointer arithmetic and<br>&gt; a legal, well-defined means to access an untyped region of memory.<br>&gt;<br>&gt; As motivation for such an API, consider that an UnsafePointer&lt;Void&gt; or<br>&gt; OpaquePointer may be currently be obtained from an external API. However,<br>&gt; the developer may know the memory layout and may want to read or write<br>&gt; elements whose types are compatible with that layout. This a reasonable use<br>&gt; case, but unless the developer can guarantee that all accesses to the same<br>&gt; memory location have the same type, then they cannot use UnsafePointer to<br>&gt; access the memory without risking undefined behavior.<br>&gt;<br>&gt; An UnsafeBytePointer example, using a new proposed API is included below.<br>&gt;<br>&gt; &lt;https://github.com/atrick/swift-evolution/tree/voidpointer/proposals#proposed-solution&gt;Proposed<br>&gt; solution<br>&gt;<br>&gt; Introduce an UnsafeBytePointer type along with an API for obtaining a<br>&gt; UnsafeBytePointer value at a relative byte offset and loading and storing<br>&gt; arbitrary types at that location.<br>&gt;<br>&gt; Statically prohibit inferred UnsafePointer conversion while allowing<br>&gt; inferred UnsafePointer to UnsafeBytePointerconversion.<br>&gt;<br>&gt; UnsafeBytePointer meets multiple requirements:<br>&gt;<br>&gt;    1. An untyped pointer to memory<br>&gt;    2. Pointer arithmetic within byte-addressable memory<br>&gt;    3. Type-unsafe access to memory (legal type punning)<br>&gt;<br>&gt; UnsafeBytePointer will replace UnsafeMutablePointer&lt;Void&gt; as the<br>&gt; representation for untyped memory. For API clarify we could consider a<br>&gt; typealias for VoidPointer. I don&#39;t think a separate VoidPointer type<br>&gt; would be useful--there&#39;s no danger that UnsafeBytePointer will be<br>&gt; casually dereferenced, and don&#39;t see the danger in allowing pointer<br>&gt; arithmetic since the only reasonable interpretation is that of a<br>&gt; byte-addressable memory.<br>&gt;<br>&gt; Providing an API for type-unsafe memory access would not serve a purpose<br>&gt; without the ability to compute byte offsets. Of course, we could require<br>&gt; users to convert back and forth using bitPatterns, but I think that would<br>&gt; be awkward and only obscure the purpose of the UnsafeBytePointer type.<br>&gt;<br>&gt; In this proposal, UnsafeBytePointer does not specify mutability. Adding an<br>&gt; UnsafeMutableBytePointer would be straightforward, but adding another<br>&gt; pointer type needs strong justification. I expect to get input from the<br>&gt; community on this. If we agree that the imported type for const void* should<br>&gt; be UnsafeBytePointer, then we probably need UnsafeMutablePointer to handle<br>&gt; interoperability.<br>&gt;<br>&gt; &lt;https://github.com/atrick/swift-evolution/tree/voidpointer/proposals#detailed-design&gt;Detailed<br>&gt; design<br>&gt;<br>&gt; The public API is shown here. For details and comments, see the unsafeptr_convert<br>&gt; branch &lt;https://github.com/atrick/swift/commits/unsafeptr_convert&gt;.<br>&gt;<br>&gt; struct UnsafeBytePointer : Hashable, _Pointer {<br>&gt;<br>&gt;   let _rawValue: Builtin.RawPointer<br>&gt;<br>&gt;   var hashValue: Int {...}<br>&gt;<br>&gt;   init&lt;T&gt;(_ : UnsafePointer&lt;T&gt;)<br>&gt;   init&lt;T&gt;(_ : UnsafeMutablePointer&lt;T&gt;)<br>&gt;   init?&lt;T&gt;(_ : UnsafePointer&lt;T&gt;?)<br>&gt;   init?&lt;T&gt;(_ : UnsafeMutablePointer&lt;T&gt;?)<br>&gt;<br>&gt;   init&lt;T&gt;(_ : OpaquePointer&lt;T&gt;)<br>&gt;   init?&lt;T&gt;(_ : OpaquePointer&lt;T&gt;?)<br>&gt;<br>&gt;   init?(bitPattern: Int)<br>&gt;   init?(bitPattern: UInt)<br>&gt;<br>&gt;   func load&lt;T&gt;(_ : T.Type) -&gt; T<br>&gt;<br>&gt;   @warn_unused_result<br>&gt;   init(allocatingBytes size: Int, alignedTo: Int)<br>&gt;<br>&gt;   @warn_unused_result<br>&gt;   init&lt;T&gt;(allocatingCapacity count: Int, of: T.Type)<br>&gt;<br>&gt;   func deallocateBytes(_ size: Int, alignedTo: Int)<br>&gt;<br>&gt;   func deallocateCapacity&lt;T&gt;(_ num: Int, of: T.Type)<br>&gt;<br>&gt;   // Returns a pointer one byte after the initialized memory.<br>&gt;   func initialize&lt;T&gt;(with newValue: T, count: Int = 1) -&gt; UnsafeBytePointer<br>&gt;<br>&gt;   // Returns a pointer one byte after the initialized memory.<br>&gt;   func initialize&lt;T&gt;(from: UnsafePointer&lt;T&gt;, count: Int) -&gt; UnsafeBytePointer<br>&gt;<br>&gt;   func initializeBackward&lt;T&gt;(from source: UnsafePointer&lt;T&gt;, count: Int)<br>&gt;<br>&gt;   func deinitialize&lt;T&gt;(_ : T.Type, count: Int = 1)<br>&gt; }<br>&gt; extension OpaquePointer {<br>&gt;   init(_ : UnsafeBytePointer)<br>&gt; }<br>&gt; extension Int {<br>&gt;   init(bitPattern: UnsafeBytePointer)<br>&gt; }<br>&gt; extension UInt {<br>&gt;   init(bitPattern: UnsafeBytePointer)<br>&gt; }<br>&gt; extension UnsafeBytePointer : RandomAccessIndex {<br>&gt;   typealias Distance = Int<br>&gt;<br>&gt;   func successor() -&gt; UnsafeBytePointer<br>&gt;   func predecessor() -&gt; UnsafeBytePointer<br>&gt;   func distance(to : UnsafeBytePointer) -&gt; Int<br>&gt;   func advanced(by : Int) -&gt; UnsafeBytePointer<br>&gt; }<br>&gt; func == (lhs: UnsafeBytePointer, rhs: UnsafeBytePointer) -&gt; Bool<br>&gt; func &lt; (lhs: UnsafeBytePointer, rhs: UnsafeBytePointer) -&gt; Bool<br>&gt; func + (lhs: UnsafeBytePointer, rhs: Int) -&gt; UnsafeBytePointer<br>&gt; func + (lhs: Int, rhs: UnsafeBytePointer) -&gt; UnsafeBytePointer<br>&gt; func - (lhs: UnsafeBytePointer, rhs: Int) -&gt; UnsafeBytePointer<br>&gt; func - (lhs: UnsafeBytePointer, rhs: UnsafeBytePointer) -&gt; Int<br>&gt; func += (lhs: inout UnsafeBytePointer, rhs: Int)<br>&gt; func -= (lhs: inout UnsafeBytePointer, rhs: Int)<br>&gt;<br>&gt; Occasionally, we need to convert from a UnsafeBytePointer to an<br>&gt; UnsafePointer. This should only be done in very rare circumstances when<br>&gt; the author understands the compiler&#39;s strict type rules for UnsafePointer.<br>&gt; Although this could be done by casting through an OpaquePointer, an<br>&gt; explicit, designated unsafe pointer cast API would makes the risks more<br>&gt; obvious and self-documenting. For example:<br>&gt;<br>&gt; extension UnsafePointer {<br>&gt;   init(_ from: UnsafeBytePointer, toPointee: Pointee.type)<br>&gt; }extension UnsafeMutablePointer {<br>&gt;   init(_ from: UnsafeBytePointer, toPointee: Pointee.type)<br>&gt; }<br>&gt;<br>&gt; Similarly, conversion between UnsafePointer types must now be spelled<br>&gt; with an explicitly Pointee type:<br>&gt;<br>&gt; extension UnsafePointer {<br>&gt;   init&lt;U&gt;(_ from: UnsafePointer&lt;U&gt;, toPointee: Pointee.Type)<br>&gt;   init&lt;U&gt;(_ from: UnsafeMutablePointer&lt;U&gt;, toPointee: Pointee.Type)<br>&gt; }extension UnsafeMutablePointer {<br>&gt;   init&lt;U&gt;(_ from: UnsafeMutablePointer&lt;U&gt;, toPointee: Pointee.Type)<br>&gt; }<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/atrick/swift-evolution/tree/voidpointer/proposals#impact-on-existing-code&gt;Impact<br>&gt; on existing code<br>&gt;<br>&gt; The largest impact of this change is that void* and const void* are<br>&gt; imported as UnsafeBytePointer. This impacts many public APIs, but with<br>&gt; implicit argument conversion should not affect typical uses of those APIs.<br>&gt;<br>&gt; Any Swift projects that rely on type inference to convert between<br>&gt; UnsafePointer types will need to take action. The developer needs to<br>&gt; determine whether type punning is necessary. If so, they must migrate to<br>&gt; the UnsafeBytePointer API. Otherwise, they can work around the new<br>&gt; restriction by using a toPointee, or mutating label.<br>&gt;<br>&gt; Disallowing inferred UnsafePointer direct conversion requires some<br>&gt; standard library code to use an explicit toPointeelabel for unsafe<br>&gt; conversions that may violate strict aliasing.<br>&gt;<br>&gt; All occurrences of Unsafe[Mutable]Pointer&lt;Void&gt; in the standard library<br>&gt; are converted to UnsafeBytePointer. e.g. unsafeAddress() now returns<br>&gt; UnsafeBytePointer, not UnsafePointer&lt;Void&gt;.<br>&gt;<br>&gt; Some occurrences of Unsafe[Mutable]Pointer&lt;Pointee&gt; in the standard<br>&gt; library are replaced with UnsafeBytePointer, either because the code was<br>&gt; playing too loosely with strict aliasing rules, or because the code<br>&gt; actually wanted to perform pointer arithmetic on byte-addresses.<br>&gt;<br>&gt; StringCore.baseAddress changes from OpaquePointer to UnsafeBytePointer because<br>&gt; it is computing byte offsets and accessing the memory. OpaquePointer is<br>&gt; meant for bridging, but should be truly opaque; that is, nondereferenceable<br>&gt; and not involved in address computation.<br>&gt;<br>&gt; The StringCore implementation does a considerable amount of casting<br>&gt; between different views of the String storage. The current implementation<br>&gt; already demonstrates some awareness of strict aliasing rules. The rules are<br>&gt; generally followed by ensuring that the StringBuffer only be accessed<br>&gt; using the appropriate CodeUnit within Swift code. For interoperability<br>&gt; and optimization, String buffers frequently need to be cast to and from<br>&gt; CChar. This is valid as long access to the buffer from Swift is guarded<br>&gt; by dynamic checks of the encoding type. These unsafe, but dynamically legal<br>&gt; conversion points will now be labeled with toPointee.<br>&gt;<br>&gt; CoreAudio utilities now use an UnsafeBytePointer.<br>&gt;<br>&gt; &lt;https://github.com/atrick/swift-evolution/tree/voidpointer/proposals#implementation-status&gt;Implementation<br>&gt; status<br>&gt;<br>&gt; On my unsafeptr_convert branch<br>&gt; &lt;https://github.com/atrick/swift/commits/unsafeptr_convert&gt;, I&#39;ve made<br>&gt; most of the necessary changes to support the addition of UnsafeBytePointerand<br>&gt; the removal of inferred UnsafePointer conversion.<br>&gt;<br>&gt; There are a several things going on here in order to make it possible to<br>&gt; build the standard library with the changes:<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    A new UnsafeBytePointer type is defined.<br>&gt;    -<br>&gt;<br>&gt;    The type system imports void* as UnsafeBytePointer.<br>&gt;    -<br>&gt;<br>&gt;    The type system handles implicit conversions to UnsafeBytePointer.<br>&gt;    -<br>&gt;<br>&gt;    UnsafeBytePointer replaces both UnsafePointer&lt;Void&gt; and<br>&gt;    UnsafeMutablePointer&lt;Void&gt;.<br>&gt;    -<br>&gt;<br>&gt;    The standard library was relying on inferred UnsafePointer conversion<br>&gt;    in over 100 places. Most of these conversions now either take an explicit<br>&gt;    label, such as &#39;toPointee&#39;, &#39;mutating&#39;. Some have been rewritten.<br>&gt;    -<br>&gt;<br>&gt;    Several places in the standard library that were playing loosely with<br>&gt;    strict aliasing or doing bytewise pointer arithmetic now use<br>&gt;    UnsafeBytePointer instead.<br>&gt;    -<br>&gt;<br>&gt;    Explicit labeled Unsafe[Mutable]Pointer initializers are added.<br>&gt;    -<br>&gt;<br>&gt;    The inferred Unsafe[Mutable]Pointer conversion is removed.<br>&gt;<br>&gt; TODO:<br>&gt;<br>&gt; Once this proposal is accepted, and the rules for casting between pointers<br>&gt; types have been decided, we need to finish implementing the type system<br>&gt; support. The current implementation (intentionally) breaks a few tests in<br>&gt; pointer_conversion.swift. We also need to ensure that interoperability<br>&gt; requirements are met. Currently, many argument casts to be explicitly<br>&gt; labeled. The current implementation also makes it easy for users to hit an<br>&gt; &quot;ambiguous use of &#39;init&#39;&quot; error when relying on implicit argument<br>&gt; conversion.<br>&gt;<br>&gt; Additionally:<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    A name mangled abbreviation needs to be created for UnsafeBytePointer.<br>&gt;    -<br>&gt;<br>&gt;    The StringAPI tests should probably be rewritten with UnsafeBytePointer<br>&gt;    .<br>&gt;    -<br>&gt;<br>&gt;    The NSStringAPI utilities and tests may need to be ported to<br>&gt;    UnsafeBytePointer<br>&gt;    -<br>&gt;<br>&gt;    The CoreAudio utilities and tests may need to be ported to<br>&gt;    UnsafeBytePointer.<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/atrick/swift-evolution/tree/voidpointer/proposals#alternatives-considered&gt;Alternatives<br>&gt; considered<br>&gt; &lt;https://github.com/atrick/swift-evolution/tree/voidpointer/proposals#existing-workaround&gt;Existing<br>&gt; workaround<br>&gt;<br>&gt; In some cases, developers can safely reinterpret values to achieve the<br>&gt; same effect as type punning:<br>&gt;<br>&gt; let ptrI32 = UnsafeMutablePointer&lt;Int32&gt;(allocatingCapacity: 1)<br>&gt; ptrI32[0] = Int32()let u = unsafeBitCast(ptrI32[0], to: UInt32.self)<br>&gt;<br>&gt; Note that all access to the underlying memory is performed with the same<br>&gt; element type. This is perfectly legitimate, but simply isn&#39;t a complete<br>&gt; solution. It also does not eliminate the inherent danger in declaring a<br>&gt; typed pointer and expecting it to point to values of a different type.<br>&gt;<br>&gt; &lt;https://github.com/atrick/swift-evolution/tree/voidpointer/proposals#discarded-alternatives&gt;Discarded<br>&gt; alternatives<br>&gt;<br>&gt; We considered adding a typePunnedMemory property to the existing<br>&gt; Unsafe[Mutabale]Pointer API. This would provide a legal way to access a<br>&gt; potentially type punned Unsafe[Mutabale]Pointer. However, it would<br>&gt; certainly cause confusion without doing much to reduce likelihood of<br>&gt; programmer error. Furthermore, there are no good use cases for such a<br>&gt; property evident in the standard library.<br>&gt;<br>&gt; The opaque _RawByte struct is a technique that allows for<br>&gt; byte-addressable buffers while hiding the dangerous side effects of type<br>&gt; punning (a _RawByte could be loaded but it&#39;s value cannot be directly<br>&gt; inspected). UnsafePointer&lt;_RawByte&gt; is a clever alternative to<br>&gt; UnsafeBytePointer. However, it doesn&#39;t do enough to prevent undefined<br>&gt; behavior. The loaded _RawByte would naturally be accessed via<br>&gt; unsafeBitCast, which would mislead the author into thinking that they<br>&gt; have legally bypassed the type system. In actuality, this API blatantly<br>&gt; violates strict aliasing. It theoretically results in undefined behavior as<br>&gt; it stands, and may actually exhibit undefined behavior if the user recovers<br>&gt; the loaded value.<br>&gt;<br>&gt; To solve the safety problem with UnsafePointer&lt;_RawByte&gt;, the compiler<br>&gt; could associate special semantics with a UnsafePointer bound to this<br>&gt; concrete generic parameter type. Statically enforcing casting rules would<br>&gt; be difficult if not impossible without new language features. It would also<br>&gt; be impossible to distinguish between typed and untyped pointer APIs. For<br>&gt; example, UnsafePointer&lt;T&gt;.load&lt;U&gt; would be a nonsensical vestige.<br>&gt;<br>&gt; &lt;https://github.com/atrick/swift-evolution/tree/voidpointer/proposals#alternate-proposal-for-void-type&gt;Alternate<br>&gt; proposal for void* type<br>&gt;<br>&gt; Changing the imported type for void* will be somewhat disruptive.<br>&gt; Furthermore, this proposal currently drops the distinction between void*<br>&gt;  and const void*--an obvious loss of API information.<br>&gt;<br>&gt; We could continue to import void* as UnsafeMutablePointer&lt;Void&gt; and const<br>&gt; void* as UnsafePointer&lt;Void&gt;, which will continue to serve as an &quot;opaque&quot;<br>&gt; untyped pointer. Converting to UnsafeBytePointer would be necesarry to<br>&gt; perform pointer arithmetic or to conservatively handle possible type<br>&gt; punning.<br>&gt;<br>&gt; This alternative is *much* less disruptive, but we are left with two<br>&gt; forms of untyped pointer, one of which (UnsafePointer) the type system<br>&gt; somewhat conflates with typed pointers.<br>&gt;<br>&gt; Given the current restrictions of the language, it&#39;s not clear how to<br>&gt; statically enforce the necessary rules for castingUnsafePointer&lt;Void&gt; once<br>&gt; general<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160509/4042023d/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[RFC] UnsafeBytePointer API for In-Memory Layout</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>May  9, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On May 9, 2016, at 12:38 PM, Geordie Jay via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I read this proposal and I&#39;m a bit unsure what its purpose would be:<br>&gt; <br>&gt; Basically you want to prevent UnsafePointer&lt;XYZ&gt;(UnsafePointer&lt;Void&gt;) conversions and/or vice-versa? And you&#39;d achieve this by replacing UnsafePointer&lt;Void&gt; with UnsafeBytePointer that has no bound pointer type?<br>&gt; <br>&gt; In one sense the change seems fine to me, but as someone who uses a lot of C APIs and a lot of CoreAudio/CoreMIDI in Swift already I can&#39;t really see what benefit it&#39;d bring. Presumably we&#39;d still want an option of converting UnsafeBytePointer to UnsafePointer&lt;SomeActualType&gt; for things like C function pointer callback &quot;context&quot;/&quot;userInfo&quot; uses, so it&#39;s not like we&#39;d be preventing programmer error in that way.<br>&gt; <br>&gt; Call me conservative but to me the current system seems to work as well as it can. If anything it&#39;s already enough boilerplate going through hoops converting an UnsafeMutablePointer&lt;Void&gt; into a [Float] even when I know and the C API knows perfectly well what it actually contains... Would happily be convinced otherwise about this proposal though, I&#39;m pretty new at all this.<br>&gt; <br>&gt; Geordie<br></p><p>&gt; On May 9, 2016, at 12:57 PM, Guillaume Lessard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I’m sympathetic to the elimination of UnsafePointer&lt;Void&gt; as general shorthand for an arbitrary pointer, but I lose the plot of this very long proposal. It seems to me that this increases API surface, yet everything I could do before, I could still do; it just involves more typing. What exactly does this make better?<br>&gt; <br>&gt; Cheers,<br>&gt; Guillaume Lessard<br></p><p>Andy, I think it&#39;s worth clarifying the primary purpose of this proposal. Our main goal here is to provide a legal means for &quot;type-punning&quot; memory access. Like C and C++, it&#39;s technically undefined behavior in Swift to cast an UnsafePointer&lt;T&gt; to an UnsafePointer&lt;U&gt; of a different type and load a value out of memory that&#39;s of a different type from what was stored there. We don&#39;t take much advantage of this yet in Swift&#39;s optimizer, since we don&#39;t have good alternative API. UnsafeBytePointer seeks to fill this gap by providing a type that can safely do type-punned loads and stores.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4db4fede2f4e473341b873406b68e4e1?s=50"></div><header><strong>[RFC] UnsafeBytePointer API for In-Memory Layout</strong> from <string>Geordie Jay</string> &lt;geojay at gmail.com&gt;<p>May  9, 2016 at 08:00:00pm</p></header><div class="content"><p>So what&#39;s in it for us as Swift devs?<br></p><p>It may be technically undefined behaviour (by that I think you mean there&#39;s<br>no real knowing what could happen), but it seems to be rampant throughout<br>pretty much all the C code I&#39;ve come in contact with (I&#39;m less familiar<br>with C++).<br></p><p>If we lose type information by calling a C API that takes a void pointer,<br>how can we hope to retrieve it in any safe way, other than saying &quot;we<br>assume with good reason and hope to hell that this is what we say it is&quot;.<br>And if we can&#39;t do that, what advantage does this proposal provide over<br>what we already have?<br>Joe Groff &lt;jgroff at apple.com&gt; schrieb am Mo., 9. Mai 2016 um 22:16:<br></p><p>&gt;<br>&gt; &gt; On May 9, 2016, at 12:38 PM, Geordie Jay via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I read this proposal and I&#39;m a bit unsure what its purpose would be:<br>&gt; &gt;<br>&gt; &gt; Basically you want to prevent UnsafePointer&lt;XYZ&gt;(UnsafePointer&lt;Void&gt;)<br>&gt; conversions and/or vice-versa? And you&#39;d achieve this by replacing<br>&gt; UnsafePointer&lt;Void&gt; with UnsafeBytePointer that has no bound pointer type?<br>&gt; &gt;<br>&gt; &gt; In one sense the change seems fine to me, but as someone who uses a lot<br>&gt; of C APIs and a lot of CoreAudio/CoreMIDI in Swift already I can&#39;t really<br>&gt; see what benefit it&#39;d bring. Presumably we&#39;d still want an option of<br>&gt; converting UnsafeBytePointer to UnsafePointer&lt;SomeActualType&gt; for things<br>&gt; like C function pointer callback &quot;context&quot;/&quot;userInfo&quot; uses, so it&#39;s not<br>&gt; like we&#39;d be preventing programmer error in that way.<br>&gt; &gt;<br>&gt; &gt; Call me conservative but to me the current system seems to work as well<br>&gt; as it can. If anything it&#39;s already enough boilerplate going through hoops<br>&gt; converting an UnsafeMutablePointer&lt;Void&gt; into a [Float] even when I know<br>&gt; and the C API knows perfectly well what it actually contains... Would<br>&gt; happily be convinced otherwise about this proposal though, I&#39;m pretty new<br>&gt; at all this.<br>&gt; &gt;<br>&gt; &gt; Geordie<br>&gt;<br>&gt; &gt; On May 9, 2016, at 12:57 PM, Guillaume Lessard via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I’m sympathetic to the elimination of UnsafePointer&lt;Void&gt; as general<br>&gt; shorthand for an arbitrary pointer, but I lose the plot of this very long<br>&gt; proposal. It seems to me that this increases API surface, yet everything I<br>&gt; could do before, I could still do; it just involves more typing. What<br>&gt; exactly does this make better?<br>&gt; &gt;<br>&gt; &gt; Cheers,<br>&gt; &gt; Guillaume Lessard<br>&gt;<br>&gt; Andy, I think it&#39;s worth clarifying the primary purpose of this proposal.<br>&gt; Our main goal here is to provide a legal means for &quot;type-punning&quot; memory<br>&gt; access. Like C and C++, it&#39;s technically undefined behavior in Swift to<br>&gt; cast an UnsafePointer&lt;T&gt; to an UnsafePointer&lt;U&gt; of a different type and<br>&gt; load a value out of memory that&#39;s of a different type from what was stored<br>&gt; there. We don&#39;t take much advantage of this yet in Swift&#39;s optimizer, since<br>&gt; we don&#39;t have good alternative API. UnsafeBytePointer seeks to fill this<br>&gt; gap by providing a type that can safely do type-punned loads and stores.<br>&gt;<br>&gt; -Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160509/d18f0f9d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[RFC] UnsafeBytePointer API for In-Memory Layout</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>May  9, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On May 9, 2016, at 1:25 PM, Geordie Jay &lt;geojay at gmail.com&gt; wrote:<br>&gt; <br>&gt; So what&#39;s in it for us as Swift devs?<br>&gt; <br>&gt; It may be technically undefined behaviour (by that I think you mean there&#39;s no real knowing what could happen), but it seems to be rampant throughout pretty much all the C code I&#39;ve come in contact with (I&#39;m less familiar with C++).<br></p><p>Undefined behavior means that the compiler can optimize as if it couldn&#39;t happen. For example, in this C code:<br></p><p>	int foo(int *x, float *y) {<br>		*x = 2;<br>		*y = 3.0;<br>		return *x;<br>	}<br></p><p>the compiler will likely optimize &#39;foo&#39; to always return 2, since it&#39;s allowed to assume its pointer parameters x and y are different types so don&#39;t alias, If code calls `foo` with aliasing pointers such as `foo(&amp;x, (float*)&amp;x)`, it&#39;ll break.<br></p><p>&gt; If we lose type information by calling a C API that takes a void pointer, how can we hope to retrieve it in any safe way, other than saying &quot;we assume with good reason and hope to hell that this is what we say it is&quot;.<br></p><p>This doesn&#39;t change anything in that respect. The aliasing rules in C and Swift refer to the type of value that&#39;s dynamically stored in memory, not the static type of a pointer. It&#39;s legal to cast a pointer from T* to void* and back to T*, and load a T from the resulting pointer, so long as a T value resides in the referenced memory at the time the load occurs.<br></p><p>&gt; And if we can&#39;t do that, what advantage does this proposal provide over what we already have?<br></p><p>This API gives you a way to legally perform pointer type punning, when you do want to reinterpret memory as a different type. In C and C++ the only standard way to do so is to `memcpy`.<br></p><p>-Joe<br></p><p>&gt; Joe Groff &lt;jgroff at apple.com&gt; schrieb am Mo., 9. Mai 2016 um 22:16:<br>&gt; <br>&gt; &gt; On May 9, 2016, at 12:38 PM, Geordie Jay via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I read this proposal and I&#39;m a bit unsure what its purpose would be:<br>&gt; &gt;<br>&gt; &gt; Basically you want to prevent UnsafePointer&lt;XYZ&gt;(UnsafePointer&lt;Void&gt;) conversions and/or vice-versa? And you&#39;d achieve this by replacing UnsafePointer&lt;Void&gt; with UnsafeBytePointer that has no bound pointer type?<br>&gt; &gt;<br>&gt; &gt; In one sense the change seems fine to me, but as someone who uses a lot of C APIs and a lot of CoreAudio/CoreMIDI in Swift already I can&#39;t really see what benefit it&#39;d bring. Presumably we&#39;d still want an option of converting UnsafeBytePointer to UnsafePointer&lt;SomeActualType&gt; for things like C function pointer callback &quot;context&quot;/&quot;userInfo&quot; uses, so it&#39;s not like we&#39;d be preventing programmer error in that way.<br>&gt; &gt;<br>&gt; &gt; Call me conservative but to me the current system seems to work as well as it can. If anything it&#39;s already enough boilerplate going through hoops converting an UnsafeMutablePointer&lt;Void&gt; into a [Float] even when I know and the C API knows perfectly well what it actually contains... Would happily be convinced otherwise about this proposal though, I&#39;m pretty new at all this.<br>&gt; &gt;<br>&gt; &gt; Geordie<br>&gt; <br>&gt; &gt; On May 9, 2016, at 12:57 PM, Guillaume Lessard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I’m sympathetic to the elimination of UnsafePointer&lt;Void&gt; as general shorthand for an arbitrary pointer, but I lose the plot of this very long proposal. It seems to me that this increases API surface, yet everything I could do before, I could still do; it just involves more typing. What exactly does this make better?<br>&gt; &gt;<br>&gt; &gt; Cheers,<br>&gt; &gt; Guillaume Lessard<br>&gt; <br>&gt; Andy, I think it&#39;s worth clarifying the primary purpose of this proposal. Our main goal here is to provide a legal means for &quot;type-punning&quot; memory access. Like C and C++, it&#39;s technically undefined behavior in Swift to cast an UnsafePointer&lt;T&gt; to an UnsafePointer&lt;U&gt; of a different type and load a value out of memory that&#39;s of a different type from what was stored there. We don&#39;t take much advantage of this yet in Swift&#39;s optimizer, since we don&#39;t have good alternative API. UnsafeBytePointer seeks to fill this gap by providing a type that can safely do type-punned loads and stores.<br>&gt; <br>&gt; -Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4db4fede2f4e473341b873406b68e4e1?s=50"></div><header><strong>[RFC] UnsafeBytePointer API for In-Memory Layout</strong> from <string>Geordie Jay</string> &lt;geojay at gmail.com&gt;<p>May  9, 2016 at 08:00:00pm</p></header><div class="content"><p>Thanks for your patient clarification Joe.<br></p><p>My understanding was that type punning == your example with T* -&gt; Void* -&gt;<br>T* -&gt; T. Assuming it&#39;s not, I now imagine you&#39;re talking about<br>reinterpreting the layout of C structs and the like for some horrifically<br>beautiful optimisation or low-level trick purpose, which sounds nice but is<br>way beyond my level of understanding or needs.<br></p><p>I&#39;ll take your word for it that the example with aliasing pointers is<br>something that might actually happen, as it stands it just looks like an<br>unfortunate programmer error, not sure if that was your point (to catch<br>that kind of thing before it happens).<br>Joe Groff &lt;jgroff at apple.com&gt; schrieb am Mo., 9. Mai 2016 um 22:48:<br></p><p>&gt;<br>&gt; &gt; On May 9, 2016, at 1:25 PM, Geordie Jay &lt;geojay at gmail.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; So what&#39;s in it for us as Swift devs?<br>&gt; &gt;<br>&gt; &gt; It may be technically undefined behaviour (by that I think you mean<br>&gt; there&#39;s no real knowing what could happen), but it seems to be rampant<br>&gt; throughout pretty much all the C code I&#39;ve come in contact with (I&#39;m less<br>&gt; familiar with C++).<br>&gt;<br>&gt; Undefined behavior means that the compiler can optimize as if it couldn&#39;t<br>&gt; happen. For example, in this C code:<br>&gt;<br>&gt;         int foo(int *x, float *y) {<br>&gt;                 *x = 2;<br>&gt;                 *y = 3.0;<br>&gt;                 return *x;<br>&gt;         }<br>&gt;<br>&gt; the compiler will likely optimize &#39;foo&#39; to always return 2, since it&#39;s<br>&gt; allowed to assume its pointer parameters x and y are different types so<br>&gt; don&#39;t alias, If code calls `foo` with aliasing pointers such as `foo(&amp;x,<br>&gt; (float*)&amp;x)`, it&#39;ll break.<br>&gt;<br>&gt; &gt; If we lose type information by calling a C API that takes a void<br>&gt; pointer, how can we hope to retrieve it in any safe way, other than saying<br>&gt; &quot;we assume with good reason and hope to hell that this is what we say it<br>&gt; is&quot;.<br>&gt;<br>&gt; This doesn&#39;t change anything in that respect. The aliasing rules in C and<br>&gt; Swift refer to the type of value that&#39;s dynamically stored in memory, not<br>&gt; the static type of a pointer. It&#39;s legal to cast a pointer from T* to void*<br>&gt; and back to T*, and load a T from the resulting pointer, so long as a T<br>&gt; value resides in the referenced memory at the time the load occurs.<br>&gt;<br>&gt; &gt; And if we can&#39;t do that, what advantage does this proposal provide over<br>&gt; what we already have?<br>&gt;<br>&gt; This API gives you a way to legally perform pointer type punning, when you<br>&gt; do want to reinterpret memory as a different type. In C and C++ the only<br>&gt; standard way to do so is to `memcpy`.<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt; &gt; Joe Groff &lt;jgroff at apple.com&gt; schrieb am Mo., 9. Mai 2016 um 22:16:<br>&gt; &gt;<br>&gt; &gt; &gt; On May 9, 2016, at 12:38 PM, Geordie Jay via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; I read this proposal and I&#39;m a bit unsure what its purpose would be:<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Basically you want to prevent UnsafePointer&lt;XYZ&gt;(UnsafePointer&lt;Void&gt;)<br>&gt; conversions and/or vice-versa? And you&#39;d achieve this by replacing<br>&gt; UnsafePointer&lt;Void&gt; with UnsafeBytePointer that has no bound pointer type?<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; In one sense the change seems fine to me, but as someone who uses a<br>&gt; lot of C APIs and a lot of CoreAudio/CoreMIDI in Swift already I can&#39;t<br>&gt; really see what benefit it&#39;d bring. Presumably we&#39;d still want an option of<br>&gt; converting UnsafeBytePointer to UnsafePointer&lt;SomeActualType&gt; for things<br>&gt; like C function pointer callback &quot;context&quot;/&quot;userInfo&quot; uses, so it&#39;s not<br>&gt; like we&#39;d be preventing programmer error in that way.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Call me conservative but to me the current system seems to work as<br>&gt; well as it can. If anything it&#39;s already enough boilerplate going through<br>&gt; hoops converting an UnsafeMutablePointer&lt;Void&gt; into a [Float] even when I<br>&gt; know and the C API knows perfectly well what it actually contains... Would<br>&gt; happily be convinced otherwise about this proposal though, I&#39;m pretty new<br>&gt; at all this.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Geordie<br>&gt; &gt;<br>&gt; &gt; &gt; On May 9, 2016, at 12:57 PM, Guillaume Lessard via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; I’m sympathetic to the elimination of UnsafePointer&lt;Void&gt; as general<br>&gt; shorthand for an arbitrary pointer, but I lose the plot of this very long<br>&gt; proposal. It seems to me that this increases API surface, yet everything I<br>&gt; could do before, I could still do; it just involves more typing. What<br>&gt; exactly does this make better?<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Cheers,<br>&gt; &gt; &gt; Guillaume Lessard<br>&gt; &gt;<br>&gt; &gt; Andy, I think it&#39;s worth clarifying the primary purpose of this<br>&gt; proposal. Our main goal here is to provide a legal means for &quot;type-punning&quot;<br>&gt; memory access. Like C and C++, it&#39;s technically undefined behavior in Swift<br>&gt; to cast an UnsafePointer&lt;T&gt; to an UnsafePointer&lt;U&gt; of a different type and<br>&gt; load a value out of memory that&#39;s of a different type from what was stored<br>&gt; there. We don&#39;t take much advantage of this yet in Swift&#39;s optimizer, since<br>&gt; we don&#39;t have good alternative API. UnsafeBytePointer seeks to fill this<br>&gt; gap by providing a type that can safely do type-punned loads and stores.<br>&gt; &gt;<br>&gt; &gt; -Joe<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160509/7718cf6d/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[RFC] UnsafeBytePointer API for In-Memory Layout</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>May  9, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On May 9, 2016, at 1:16 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; Andy, I think it&#39;s worth clarifying the primary purpose of this proposal. Our main goal here is to provide a legal means for &quot;type-punning&quot; memory access. Like C and C++, it&#39;s technically undefined behavior in Swift to cast an UnsafePointer&lt;T&gt; to an UnsafePointer&lt;U&gt; of a different type and load a value out of memory that&#39;s of a different type from what was stored there. We don&#39;t take much advantage of this yet in Swift&#39;s optimizer, since we don&#39;t have good alternative API. UnsafeBytePointer seeks to fill this gap by providing a type that can safely do type-punned loads and stores.<br></p><p>Absolutely, that’s the main point. I’ll work on the proposal&#39;s language. But I should point out that the optimizer has taken advantage of UnsafePointer’s type for a long time. We’re only saved because when we convert UMP types, we usually pass the memory off to an external C function, which acts as a boundary to optimization.<br></p><p>The current proposal grew out of my auditing the standard library, attempting to weed out undefined behavior.<br></p><p>Also note that I initially wanted to propose a much less ambitious API that allowed type punning, but otherwise left UMP unchanged. However, I got some strong feedback early on that if converting UMP types leads to undefined behavior, then it should be prohibited in the API, unless the programming explicitly requests the conversion. I happen to agree with that feedback. Since you and others also wanted a more complete API for manual memory layout, I saw that as one solution to both problems.<br></p><p>-Andy<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160509/7f8e4728/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[RFC] UnsafeBytePointer API for In-Memory Layout</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>May  9, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On May 9, 2016, at 12:38 PM, Geordie Jay &lt;geojay at gmail.com&gt; wrote:<br>&gt; <br>&gt; I read this proposal and I&#39;m a bit unsure what its purpose would be:<br>&gt; <br>&gt; Basically you want to prevent UnsafePointer&lt;XYZ&gt;(UnsafePointer&lt;Void&gt;) conversions and/or vice-versa? And you&#39;d achieve this by replacing UnsafePointer&lt;Void&gt; with UnsafeBytePointer that has no bound pointer type?<br></p><p>I want to prevent UnsafePointer&lt;U&gt;(UnsafePointer&lt;T&gt;) *except* when the destination is UnsafePointer&lt;Void&gt;.<br></p><p>UnsafePointer&lt;Void&gt;(UnsafePointer&lt;T&gt;) is fine.<br></p><p>UnsafeBytePointer provides two thing:<br>- A means to prevent the conversion above<br>- An API for legal type punning, which does not exist today<br></p><p>&gt; In one sense the change seems fine to me, but as someone who uses a lot of C APIs and a lot of CoreAudio/CoreMIDI in Swift already I can&#39;t really see what benefit it&#39;d bring. Presumably we&#39;d still want an option of converting UnsafeBytePointer to UnsafePointer&lt;SomeActualType&gt; for things like C function pointer callback &quot;context&quot;/&quot;userInfo&quot; uses, so it&#39;s not like we&#39;d be preventing programmer error in that way.<br></p><p>It’s possible to cast UnsafeBytePointer to UnsafePointer&lt;SomeActualType&gt;. I want the programmer to make their intent explicit  by writing a cast and spelling SomeActualType at the point of the cast. In the proposal, that’s done using a labeled initializer.<br></p><p>&gt; Call me conservative but to me the current system seems to work as well as it can. If anything it&#39;s already enough boilerplate going through hoops converting an UnsafeMutablePointer&lt;Void&gt; into a [Float] even when I know and the C API knows perfectly well what it actually contains... Would happily be convinced otherwise about this proposal though, I&#39;m pretty new at all this.<br></p><p>I think you are asking for implicit conversions when calling C APIs. That’s good feedback. When implementing this proposal I tried to allow implicit conversions in reasonable cases, but leaned toward being conservative. I would rather see more explicit casts now and eliminate them if people find it awkward.<br></p><p>I&#39;m looking for some consensus on core aspects of the proposal, then we can take into consideration precisely which implicit conversions should be supported.<br></p><p>-Andy<br></p><p>&gt; Geordie<br>&gt; Andrew Trick via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; schrieb am Mo., 9. Mai 2016 um 20:15:<br>&gt; Hello Swift evolution,<br>&gt; <br>&gt; I sent this to swift-dev last week. Sorry to post on two lists!<br>&gt; <br>&gt; Swift does a great job of protecting against undefined behavior--as long as you avoid &quot;unsafe&quot; APIs, that is. However, unsafe APIs are important for giving developers control over implementation details and performance. Naturally, the contract between unsafe APIs and the optimizer is crucial. When a developer uses an unsafe API, the rules governing safe, well-defined behavior must be clear. On the opposite end, the optimizer must know which assumptions it can make based on those rules. Simply saying that anything goes because &quot;unsafe&quot; is in the name is not helpful to this effort.<br>&gt; <br>&gt; For a long time, I&#39;ve wanted these rules nailed down. We have more users taking advantage of advanced features, and more optimizations that take advantage of assumptions guided by the type system. This seems like a particularly good time to resolve UnsafePointer semantics, considering the type system and UnsafePointer work that&#39;s been going on recently. Strict aliasing is something I would like addressed. If we do nothing here, then we will end up by default inheriting C/C++ semantics, as with any language that relies on a C/C++ backend. In other words, developers will be forced to write code with technically undefined behavior and rely on the compiler to be smart enough to recognize and recover from common patterns. Or we can take advantage of this opportunity and instead adopt a sound memory model with respect to aliasing.<br>&gt; <br>&gt; This proposal is only an RFC at this point. I&#39;m sending it out now to allow for plenty of time for discussion (or advance warning). Keep in mind that it could change considerably before it goes up for review.<br>&gt; <br>&gt; -Andy<br>&gt; <br>&gt; <br>&gt; UnsafeBytePointer API for In-Memory Layout<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsafebytepointer.md&gt;<br>&gt; Author(s): Andrew Trick &lt;https://github.com/atrick&gt;<br>&gt; Status: Awaiting review &lt;https://github.com/atrick/swift-evolution/tree/voidpointer/proposals#rationale&gt;<br>&gt; Review manager: TBD<br>&gt;  &lt;https://github.com/atrick/swift-evolution/tree/voidpointer/proposals#introduction&gt;Introduction<br>&gt; <br>&gt; UnsafePointer and UnsafeMutable refer to a typed region of memory, and the compiler must be able to assume that UnsafePointer element (Pointee) type is consistent with other access to the same memory. See proposed Type Safe Memory Access documentation &lt;https://github.com/atrick/swift/blob/type-safe-mem-docs/docs/TypeSafeMemory.rst&gt;. Consequently, inferred conversion between UnsafePointer element types exposes an easy way to abuse the type system. No alternative currently exists for manual memory layout and direct access to untyped memory, and that leads to an overuse of UnsafePointer. These uses of UnsafePointer, which depend on pointer type conversion, make accidental type punning likely. Type punning via UnsafePointer is semantically undefined behavior and de facto undefined behavior given the optimizer&#39;s long-time treatment of UnsafePointer.<br>&gt; <br>&gt; In this document, all mentions of UnsafePointer also apply to UnsafeMutablePointer.<br>&gt; <br>&gt;  &lt;https://github.com/atrick/swift-evolution/tree/voidpointer/proposals#motivation&gt;Motivation<br>&gt; <br>&gt; To avoid accidental type punning, we should prohibit inferred conversion between UnsafePointer&lt;T&gt; and UnsafePointer&lt;U&gt; unless the target of the conversion is an untyped or nondereferenceable pointer (currently represented as UnsafePointer&lt;Void&gt;).<br>&gt; <br>&gt; To support this change we should introduce a new pointer type that does not bind the type of its Pointee. Such a new pointer type would provide an ideal foundation for an API that allows byte-wise pointer arithmetic and a legal, well-defined means to access an untyped region of memory.<br>&gt; <br>&gt; As motivation for such an API, consider that an UnsafePointer&lt;Void&gt; or OpaquePointer may be currently be obtained from an external API. However, the developer may know the memory layout and may want to read or write elements whose types are compatible with that layout. This a reasonable use case, but unless the developer can guarantee that all accesses to the same memory location have the same type, then they cannot use UnsafePointer to access the memory without risking undefined behavior.<br>&gt; <br>&gt; An UnsafeBytePointer example, using a new proposed API is included below.<br>&gt; <br>&gt;  &lt;https://github.com/atrick/swift-evolution/tree/voidpointer/proposals#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; Introduce an UnsafeBytePointer type along with an API for obtaining a UnsafeBytePointer value at a relative byte offset and loading and storing arbitrary types at that location.<br>&gt; <br>&gt; Statically prohibit inferred UnsafePointer conversion while allowing inferred UnsafePointer to UnsafeBytePointerconversion.<br>&gt; <br>&gt; UnsafeBytePointer meets multiple requirements:<br>&gt; <br>&gt; An untyped pointer to memory<br>&gt; Pointer arithmetic within byte-addressable memory<br>&gt; Type-unsafe access to memory (legal type punning)<br>&gt; UnsafeBytePointer will replace UnsafeMutablePointer&lt;Void&gt; as the representation for untyped memory. For API clarify we could consider a typealias for VoidPointer. I don&#39;t think a separate VoidPointer type would be useful--there&#39;s no danger that UnsafeBytePointer will be casually dereferenced, and don&#39;t see the danger in allowing pointer arithmetic since the only reasonable interpretation is that of a byte-addressable memory.<br>&gt; <br>&gt; Providing an API for type-unsafe memory access would not serve a purpose without the ability to compute byte offsets. Of course, we could require users to convert back and forth using bitPatterns, but I think that would be awkward and only obscure the purpose of the UnsafeBytePointer type.<br>&gt; <br>&gt; In this proposal, UnsafeBytePointer does not specify mutability. Adding an UnsafeMutableBytePointer would be straightforward, but adding another pointer type needs strong justification. I expect to get input from the community on this. If we agree that the imported type for const void* should be UnsafeBytePointer, then we probably need UnsafeMutablePointer to handle interoperability.<br>&gt; <br>&gt;  &lt;https://github.com/atrick/swift-evolution/tree/voidpointer/proposals#detailed-design&gt;Detailed design<br>&gt; <br>&gt; The public API is shown here. For details and comments, see the unsafeptr_convert branch &lt;https://github.com/atrick/swift/commits/unsafeptr_convert&gt;.<br>&gt; <br>&gt; struct UnsafeBytePointer : Hashable, _Pointer {<br>&gt; <br>&gt;   let _rawValue: Builtin.RawPointer<br>&gt; <br>&gt;   var hashValue: Int {...}<br>&gt; <br>&gt;   init&lt;T&gt;(_ : UnsafePointer&lt;T&gt;)<br>&gt;   init&lt;T&gt;(_ : UnsafeMutablePointer&lt;T&gt;)<br>&gt;   init?&lt;T&gt;(_ : UnsafePointer&lt;T&gt;?)<br>&gt;   init?&lt;T&gt;(_ : UnsafeMutablePointer&lt;T&gt;?)<br>&gt; <br>&gt;   init&lt;T&gt;(_ : OpaquePointer&lt;T&gt;)<br>&gt;   init?&lt;T&gt;(_ : OpaquePointer&lt;T&gt;?)<br>&gt; <br>&gt;   init?(bitPattern: Int)<br>&gt;   init?(bitPattern: UInt)<br>&gt; <br>&gt;   func load&lt;T&gt;(_ : T.Type) -&gt; T<br>&gt; <br>&gt;   @warn_unused_result<br>&gt;   init(allocatingBytes size: Int, alignedTo: Int)<br>&gt; <br>&gt;   @warn_unused_result<br>&gt;   init&lt;T&gt;(allocatingCapacity count: Int, of: T.Type)<br>&gt; <br>&gt;   func deallocateBytes(_ size: Int, alignedTo: Int)<br>&gt; <br>&gt;   func deallocateCapacity&lt;T&gt;(_ num: Int, of: T.Type)<br>&gt; <br>&gt;   // Returns a pointer one byte after the initialized memory.<br>&gt;   func initialize&lt;T&gt;(with newValue: T, count: Int = 1) -&gt; UnsafeBytePointer<br>&gt; <br>&gt;   // Returns a pointer one byte after the initialized memory.<br>&gt;   func initialize&lt;T&gt;(from: UnsafePointer&lt;T&gt;, count: Int) -&gt; UnsafeBytePointer<br>&gt; <br>&gt;   func initializeBackward&lt;T&gt;(from source: UnsafePointer&lt;T&gt;, count: Int)<br>&gt; <br>&gt;   func deinitialize&lt;T&gt;(_ : T.Type, count: Int = 1)<br>&gt; }<br>&gt; <br>&gt; extension OpaquePointer {<br>&gt;   init(_ : UnsafeBytePointer)<br>&gt; }<br>&gt; <br>&gt; extension Int {<br>&gt;   init(bitPattern: UnsafeBytePointer)<br>&gt; }<br>&gt; <br>&gt; extension UInt {<br>&gt;   init(bitPattern: UnsafeBytePointer)<br>&gt; }<br>&gt; <br>&gt; extension UnsafeBytePointer : RandomAccessIndex {<br>&gt;   typealias Distance = Int<br>&gt; <br>&gt;   func successor() -&gt; UnsafeBytePointer<br>&gt;   func predecessor() -&gt; UnsafeBytePointer<br>&gt;   func distance(to : UnsafeBytePointer) -&gt; Int<br>&gt;   func advanced(by : Int) -&gt; UnsafeBytePointer<br>&gt; }<br>&gt; <br>&gt; func == (lhs: UnsafeBytePointer, rhs: UnsafeBytePointer) -&gt; Bool<br>&gt; <br>&gt; func &lt; (lhs: UnsafeBytePointer, rhs: UnsafeBytePointer) -&gt; Bool<br>&gt; <br>&gt; func + (lhs: UnsafeBytePointer, rhs: Int) -&gt; UnsafeBytePointer<br>&gt; <br>&gt; func + (lhs: Int, rhs: UnsafeBytePointer) -&gt; UnsafeBytePointer<br>&gt; <br>&gt; func - (lhs: UnsafeBytePointer, rhs: Int) -&gt; UnsafeBytePointer<br>&gt; <br>&gt; func - (lhs: UnsafeBytePointer, rhs: UnsafeBytePointer) -&gt; Int<br>&gt; <br>&gt; func += (lhs: inout UnsafeBytePointer, rhs: Int)<br>&gt; <br>&gt; func -= (lhs: inout UnsafeBytePointer, rhs: Int)<br>&gt; Occasionally, we need to convert from a UnsafeBytePointer to an UnsafePointer. This should only be done in very rare circumstances when the author understands the compiler&#39;s strict type rules for UnsafePointer. Although this could be done by casting through an OpaquePointer, an explicit, designated unsafe pointer cast API would makes the risks more obvious and self-documenting. For example:<br>&gt; <br>&gt; extension UnsafePointer {<br>&gt;   init(_ from: UnsafeBytePointer, toPointee: Pointee.type)<br>&gt; }<br>&gt; extension UnsafeMutablePointer {<br>&gt;   init(_ from: UnsafeBytePointer, toPointee: Pointee.type)<br>&gt; }<br>&gt; Similarly, conversion between UnsafePointer types must now be spelled with an explicitly Pointee type:<br>&gt; <br>&gt; extension UnsafePointer {<br>&gt;   init&lt;U&gt;(_ from: UnsafePointer&lt;U&gt;, toPointee: Pointee.Type)<br>&gt;   init&lt;U&gt;(_ from: UnsafeMutablePointer&lt;U&gt;, toPointee: Pointee.Type)<br>&gt; }<br>&gt; extension UnsafeMutablePointer {<br>&gt;   init&lt;U&gt;(_ from: UnsafeMutablePointer&lt;U&gt;, toPointee: Pointee.Type)<br>&gt; }<br>&gt;  &lt;https://github.com/atrick/swift-evolution/tree/voidpointer/proposals#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; The largest impact of this change is that void* and const void* are imported as UnsafeBytePointer. This impacts many public APIs, but with implicit argument conversion should not affect typical uses of those APIs.<br>&gt; <br>&gt; Any Swift projects that rely on type inference to convert between UnsafePointer types will need to take action. The developer needs to determine whether type punning is necessary. If so, they must migrate to the UnsafeBytePointer API. Otherwise, they can work around the new restriction by using a toPointee, or mutating label.<br>&gt; <br>&gt; Disallowing inferred UnsafePointer direct conversion requires some standard library code to use an explicit toPointeelabel for unsafe conversions that may violate strict aliasing.<br>&gt; <br>&gt; All occurrences of Unsafe[Mutable]Pointer&lt;Void&gt; in the standard library are converted to UnsafeBytePointer. e.g. unsafeAddress() now returns UnsafeBytePointer, not UnsafePointer&lt;Void&gt;.<br>&gt; <br>&gt; Some occurrences of Unsafe[Mutable]Pointer&lt;Pointee&gt; in the standard library are replaced with UnsafeBytePointer, either because the code was playing too loosely with strict aliasing rules, or because the code actually wanted to perform pointer arithmetic on byte-addresses.<br>&gt; <br>&gt; StringCore.baseAddress changes from OpaquePointer to UnsafeBytePointer because it is computing byte offsets and accessing the memory. OpaquePointer is meant for bridging, but should be truly opaque; that is, nondereferenceable and not involved in address computation.<br>&gt; <br>&gt; The StringCore implementation does a considerable amount of casting between different views of the String storage. The current implementation already demonstrates some awareness of strict aliasing rules. The rules are generally followed by ensuring that the StringBuffer only be accessed using the appropriate CodeUnit within Swift code. For interoperability and optimization, String buffers frequently need to be cast to and from CChar. This is valid as long access to the buffer from Swift is guarded by dynamic checks of the encoding type. These unsafe, but dynamically legal conversion points will now be labeled with toPointee.<br>&gt; <br>&gt; CoreAudio utilities now use an UnsafeBytePointer.<br>&gt; <br>&gt;  &lt;https://github.com/atrick/swift-evolution/tree/voidpointer/proposals#implementation-status&gt;Implementation status<br>&gt; <br>&gt; On my unsafeptr_convert branch &lt;https://github.com/atrick/swift/commits/unsafeptr_convert&gt;, I&#39;ve made most of the necessary changes to support the addition of UnsafeBytePointerand the removal of inferred UnsafePointer conversion.<br>&gt; <br>&gt; There are a several things going on here in order to make it possible to build the standard library with the changes:<br>&gt; <br>&gt; A new UnsafeBytePointer type is defined.<br>&gt; <br>&gt; The type system imports void* as UnsafeBytePointer.<br>&gt; <br>&gt; The type system handles implicit conversions to UnsafeBytePointer.<br>&gt; <br>&gt; UnsafeBytePointer replaces both UnsafePointer&lt;Void&gt; and UnsafeMutablePointer&lt;Void&gt;.<br>&gt; <br>&gt; The standard library was relying on inferred UnsafePointer conversion in over 100 places. Most of these conversions now either take an explicit label, such as &#39;toPointee&#39;, &#39;mutating&#39;. Some have been rewritten.<br>&gt; <br>&gt; Several places in the standard library that were playing loosely with strict aliasing or doing bytewise pointer arithmetic now use UnsafeBytePointer instead.<br>&gt; <br>&gt; Explicit labeled Unsafe[Mutable]Pointer initializers are added.<br>&gt; <br>&gt; The inferred Unsafe[Mutable]Pointer conversion is removed.<br>&gt; <br>&gt; TODO:<br>&gt; <br>&gt; Once this proposal is accepted, and the rules for casting between pointers types have been decided, we need to finish implementing the type system support. The current implementation (intentionally) breaks a few tests in pointer_conversion.swift. We also need to ensure that interoperability requirements are met. Currently, many argument casts to be explicitly labeled. The current implementation also makes it easy for users to hit an &quot;ambiguous use of &#39;init&#39;&quot; error when relying on implicit argument conversion.<br>&gt; <br>&gt; Additionally:<br>&gt; <br>&gt; A name mangled abbreviation needs to be created for UnsafeBytePointer.<br>&gt; <br>&gt; The StringAPI tests should probably be rewritten with UnsafeBytePointer.<br>&gt; <br>&gt; The NSStringAPI utilities and tests may need to be ported to UnsafeBytePointer<br>&gt; <br>&gt; The CoreAudio utilities and tests may need to be ported to UnsafeBytePointer.<br>&gt; <br>&gt;  &lt;https://github.com/atrick/swift-evolution/tree/voidpointer/proposals#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt;  &lt;https://github.com/atrick/swift-evolution/tree/voidpointer/proposals#existing-workaround&gt;Existing workaround<br>&gt; <br>&gt; In some cases, developers can safely reinterpret values to achieve the same effect as type punning:<br>&gt; <br>&gt; let ptrI32 = UnsafeMutablePointer&lt;Int32&gt;(allocatingCapacity: 1)<br>&gt; ptrI32[0] = Int32()<br>&gt; let u = unsafeBitCast(ptrI32[0], to: UInt32.self)<br>&gt; Note that all access to the underlying memory is performed with the same element type. This is perfectly legitimate, but simply isn&#39;t a complete solution. It also does not eliminate the inherent danger in declaring a typed pointer and expecting it to point to values of a different type.<br>&gt; <br>&gt;  &lt;https://github.com/atrick/swift-evolution/tree/voidpointer/proposals#discarded-alternatives&gt;Discarded alternatives<br>&gt; <br>&gt; We considered adding a typePunnedMemory property to the existing Unsafe[Mutabale]Pointer API. This would provide a legal way to access a potentially type punned Unsafe[Mutabale]Pointer. However, it would certainly cause confusion without doing much to reduce likelihood of programmer error. Furthermore, there are no good use cases for such a property evident in the standard library.<br>&gt; <br>&gt; The opaque _RawByte struct is a technique that allows for byte-addressable buffers while hiding the dangerous side effects of type punning (a _RawByte could be loaded but it&#39;s value cannot be directly inspected). UnsafePointer&lt;_RawByte&gt; is a clever alternative to UnsafeBytePointer. However, it doesn&#39;t do enough to prevent undefined behavior. The loaded _RawByte would naturally be accessed via unsafeBitCast, which would mislead the author into thinking that they have legally bypassed the type system. In actuality, this API blatantly violates strict aliasing. It theoretically results in undefined behavior as it stands, and may actually exhibit undefined behavior if the user recovers the loaded value.<br>&gt; <br>&gt; To solve the safety problem with UnsafePointer&lt;_RawByte&gt;, the compiler could associate special semantics with a UnsafePointer bound to this concrete generic parameter type. Statically enforcing casting rules would be difficult if not impossible without new language features. It would also be impossible to distinguish between typed and untyped pointer APIs. For example, UnsafePointer&lt;T&gt;.load&lt;U&gt; would be a nonsensical vestige.<br>&gt; <br>&gt;  &lt;https://github.com/atrick/swift-evolution/tree/voidpointer/proposals#alternate-proposal-for-void-type&gt;Alternate proposal for void* type<br>&gt; <br>&gt; Changing the imported type for void* will be somewhat disruptive. Furthermore, this proposal currently drops the distinction between void* and const void*--an obvious loss of API information.<br>&gt; <br>&gt; We could continue to import void* as UnsafeMutablePointer&lt;Void&gt; and const void* as UnsafePointer&lt;Void&gt;, which will continue to serve as an &quot;opaque&quot; untyped pointer. Converting to UnsafeBytePointer would be necesarry to perform pointer arithmetic or to conservatively handle possible type punning.<br>&gt; <br>&gt; This alternative is much less disruptive, but we are left with two forms of untyped pointer, one of which (UnsafePointer) the type system somewhat conflates with typed pointers.<br>&gt; <br>&gt; Given the current restrictions of the language, it&#39;s not clear how to statically enforce the necessary rules for castingUnsafePointer&lt;Void&gt; once general <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160509/53e3368c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4db4fede2f4e473341b873406b68e4e1?s=50"></div><header><strong>[RFC] UnsafeBytePointer API for In-Memory Layout</strong> from <string>Geordie Jay</string> &lt;geojay at gmail.com&gt;<p>May  9, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; Am 09.05.2016 um 23:04 schrieb Andrew Trick &lt;atrick at apple.com&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; On May 9, 2016, at 12:38 PM, Geordie Jay &lt;geojay at gmail.com &lt;mailto:geojay at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I read this proposal and I&#39;m a bit unsure what its purpose would be:<br>&gt;&gt; <br>&gt;&gt; Basically you want to prevent UnsafePointer&lt;XYZ&gt;(UnsafePointer&lt;Void&gt;) conversions and/or vice-versa? And you&#39;d achieve this by replacing UnsafePointer&lt;Void&gt; with UnsafeBytePointer that has no bound pointer type?<br>&gt; <br>&gt; I want to prevent UnsafePointer&lt;U&gt;(UnsafePointer&lt;T&gt;) *except* when the destination is UnsafePointer&lt;Void&gt;.<br>&gt; <br>&gt; UnsafePointer&lt;Void&gt;(UnsafePointer&lt;T&gt;) is fine.<br>&gt; <br>&gt; UnsafeBytePointer provides two thing:<br>&gt; - A means to prevent the conversion above<br>&gt; - An API for legal type punning, which does not exist today<br></p><p>So you mean to enable UnsafePointer&lt;Void&gt; aka. UnsafeBytePointer(UnsafePointer&lt;T&gt;), but disable other type-to-type pointer recasts? I guess that’s a worthy goal at some level, but is there anything stopping someone just saying UnsafePointer(UnsafeBytePointer(myPointerToMemoryContainingTypeT), toPointee: U.type)?<br></p><p>It still just seems like we can do the same thing spelled differently. I don’t see how changing how that happens could benefit us or the compiler, but maybe this is one we should just take your word on.<br></p><p>Assuming the likely case that this is just beyond my understanding, I do wonder why we’d need to change the API. I guess there are a lot of assumptions made about both UnsafePointer&lt;Void&gt; and UnsafePointer&lt;T&gt; that don’t necessarily apply to both to an equal degree?<br></p><p>&gt; <br>&gt;&gt; In one sense the change seems fine to me, but as someone who uses a lot of C APIs and a lot of CoreAudio/CoreMIDI in Swift already I can&#39;t really see what benefit it&#39;d bring. Presumably we&#39;d still want an option of converting UnsafeBytePointer to UnsafePointer&lt;SomeActualType&gt; for things like C function pointer callback &quot;context&quot;/&quot;userInfo&quot; uses, so it&#39;s not like we&#39;d be preventing programmer error in that way.<br>&gt; <br>&gt; It’s possible to cast UnsafeBytePointer to UnsafePointer&lt;SomeActualType&gt;. I want the programmer to make their intent explicit  by writing a cast and spelling SomeActualType at the point of the cast. In the proposal, that’s done using a labeled initializer.<br></p><p>How is this different from what we do now, namely UnsafePointer&lt;SomeActualType&gt;(myUnsafePointer) &lt;— I’m also spelling out SomeActualType there. I think I’m still misunderstanding something critical here.<br></p><p>From your email that just came in:<br></p><p>&gt; if converting UMP types leads to undefined behavior, then it should be prohibited in the API, unless the programming explicitly requests the conversion<br></p><p><br>This is the point I’d really like to try and understand: can you clarify how the new API is any more or less explicit than the old one?<br></p><p>&gt; <br>&gt;&gt; Call me conservative but to me the current system seems to work as well as it can. If anything it&#39;s already enough boilerplate going through hoops converting an UnsafeMutablePointer&lt;Void&gt; into a [Float] even when I know and the C API knows perfectly well what it actually contains... Would happily be convinced otherwise about this proposal though, I&#39;m pretty new at all this.<br>&gt; <br>&gt; I think you are asking for implicit conversions when calling C APIs. That’s good feedback. When implementing this proposal I tried to allow implicit conversions in reasonable cases, but leaned toward being conservative. I would rather see more explicit casts now and eliminate them if people find it awkward.<br></p><p>Maybe, but I’m not sure how that’d look under this proposal. I mean Strings and literals currently being accepted as UnsafePointer&lt;CChar&gt; is a nice touch, and last I checked I can use [T, T, T, ...] array literals in place of UnsafePointer&lt;T&gt;, I certainly wouldn’t want to go below that level of conservatism here.<br></p><p>&gt; <br>&gt; I&#39;m looking for some consensus on core aspects of the proposal, then we can take into consideration precisely which implicit conversions should be supported.<br>&gt; <br>&gt; -Andy<br>&gt; <br>&gt;&gt; Geordie<br>&gt;&gt; Andrew Trick via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; schrieb am Mo., 9. Mai 2016 um 20:15:<br>&gt;&gt; Hello Swift evolution,<br>&gt;&gt; <br>&gt;&gt; I sent this to swift-dev last week. Sorry to post on two lists!<br>&gt;&gt; <br>&gt;&gt; Swift does a great job of protecting against undefined behavior--as long as you avoid &quot;unsafe&quot; APIs, that is. However, unsafe APIs are important for giving developers control over implementation details and performance. Naturally, the contract between unsafe APIs and the optimizer is crucial. When a developer uses an unsafe API, the rules governing safe, well-defined behavior must be clear. On the opposite end, the optimizer must know which assumptions it can make based on those rules. Simply saying that anything goes because &quot;unsafe&quot; is in the name is not helpful to this effort.<br>&gt;&gt; <br>&gt;&gt; For a long time, I&#39;ve wanted these rules nailed down. We have more users taking advantage of advanced features, and more optimizations that take advantage of assumptions guided by the type system. This seems like a particularly good time to resolve UnsafePointer semantics, considering the type system and UnsafePointer work that&#39;s been going on recently. Strict aliasing is something I would like addressed. If we do nothing here, then we will end up by default inheriting C/C++ semantics, as with any language that relies on a C/C++ backend. In other words, developers will be forced to write code with technically undefined behavior and rely on the compiler to be smart enough to recognize and recover from common patterns. Or we can take advantage of this opportunity and instead adopt a sound memory model with respect to aliasing.<br>&gt;&gt; <br>&gt;&gt; This proposal is only an RFC at this point. I&#39;m sending it out now to allow for plenty of time for discussion (or advance warning). Keep in mind that it could change considerably before it goes up for review.<br>&gt;&gt; <br>&gt;&gt; -Andy<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; UnsafeBytePointer API for In-Memory Layout<br>&gt;&gt; <br>&gt;&gt; Proposal: SE-NNNN &lt;https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsafebytepointer.md&gt;<br>&gt;&gt; Author(s): Andrew Trick &lt;https://github.com/atrick&gt;<br>&gt;&gt; Status: Awaiting review &lt;https://github.com/atrick/swift-evolution/tree/voidpointer/proposals#rationale&gt;<br>&gt;&gt; Review manager: TBD<br>&gt;&gt;  &lt;https://github.com/atrick/swift-evolution/tree/voidpointer/proposals#introduction&gt;Introduction<br>&gt;&gt; <br>&gt;&gt; UnsafePointer and UnsafeMutable refer to a typed region of memory, and the compiler must be able to assume that UnsafePointer element (Pointee) type is consistent with other access to the same memory. See proposed Type Safe Memory Access documentation &lt;https://github.com/atrick/swift/blob/type-safe-mem-docs/docs/TypeSafeMemory.rst&gt;. Consequently, inferred conversion between UnsafePointer element types exposes an easy way to abuse the type system. No alternative currently exists for manual memory layout and direct access to untyped memory, and that leads to an overuse of UnsafePointer. These uses of UnsafePointer, which depend on pointer type conversion, make accidental type punning likely. Type punning via UnsafePointer is semantically undefined behavior and de facto undefined behavior given the optimizer&#39;s long-time treatment of UnsafePointer.<br>&gt;&gt; <br>&gt;&gt; In this document, all mentions of UnsafePointer also apply to UnsafeMutablePointer.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/atrick/swift-evolution/tree/voidpointer/proposals#motivation&gt;Motivation<br>&gt;&gt; <br>&gt;&gt; To avoid accidental type punning, we should prohibit inferred conversion between UnsafePointer&lt;T&gt; and UnsafePointer&lt;U&gt; unless the target of the conversion is an untyped or nondereferenceable pointer (currently represented as UnsafePointer&lt;Void&gt;).<br>&gt;&gt; <br>&gt;&gt; To support this change we should introduce a new pointer type that does not bind the type of its Pointee. Such a new pointer type would provide an ideal foundation for an API that allows byte-wise pointer arithmetic and a legal, well-defined means to access an untyped region of memory.<br>&gt;&gt; <br>&gt;&gt; As motivation for such an API, consider that an UnsafePointer&lt;Void&gt; or OpaquePointer may be currently be obtained from an external API. However, the developer may know the memory layout and may want to read or write elements whose types are compatible with that layout. This a reasonable use case, but unless the developer can guarantee that all accesses to the same memory location have the same type, then they cannot use UnsafePointer to access the memory without risking undefined behavior.<br>&gt;&gt; <br>&gt;&gt; An UnsafeBytePointer example, using a new proposed API is included below.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/atrick/swift-evolution/tree/voidpointer/proposals#proposed-solution&gt;Proposed solution<br>&gt;&gt; <br>&gt;&gt; Introduce an UnsafeBytePointer type along with an API for obtaining a UnsafeBytePointer value at a relative byte offset and loading and storing arbitrary types at that location.<br>&gt;&gt; <br>&gt;&gt; Statically prohibit inferred UnsafePointer conversion while allowing inferred UnsafePointer to UnsafeBytePointerconversion.<br>&gt;&gt; <br>&gt;&gt; UnsafeBytePointer meets multiple requirements:<br>&gt;&gt; <br>&gt;&gt; An untyped pointer to memory<br>&gt;&gt; Pointer arithmetic within byte-addressable memory<br>&gt;&gt; Type-unsafe access to memory (legal type punning)<br>&gt;&gt; UnsafeBytePointer will replace UnsafeMutablePointer&lt;Void&gt; as the representation for untyped memory. For API clarify we could consider a typealias for VoidPointer. I don&#39;t think a separate VoidPointer type would be useful--there&#39;s no danger that UnsafeBytePointer will be casually dereferenced, and don&#39;t see the danger in allowing pointer arithmetic since the only reasonable interpretation is that of a byte-addressable memory.<br>&gt;&gt; <br>&gt;&gt; Providing an API for type-unsafe memory access would not serve a purpose without the ability to compute byte offsets. Of course, we could require users to convert back and forth using bitPatterns, but I think that would be awkward and only obscure the purpose of the UnsafeBytePointer type.<br>&gt;&gt; <br>&gt;&gt; In this proposal, UnsafeBytePointer does not specify mutability. Adding an UnsafeMutableBytePointer would be straightforward, but adding another pointer type needs strong justification. I expect to get input from the community on this. If we agree that the imported type for const void* should be UnsafeBytePointer, then we probably need UnsafeMutablePointer to handle interoperability.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/atrick/swift-evolution/tree/voidpointer/proposals#detailed-design&gt;Detailed design<br>&gt;&gt; <br>&gt;&gt; The public API is shown here. For details and comments, see the unsafeptr_convert branch &lt;https://github.com/atrick/swift/commits/unsafeptr_convert&gt;.<br>&gt;&gt; <br>&gt;&gt; struct UnsafeBytePointer : Hashable, _Pointer {<br>&gt;&gt; <br>&gt;&gt;   let _rawValue: Builtin.RawPointer<br>&gt;&gt; <br>&gt;&gt;   var hashValue: Int {...}<br>&gt;&gt; <br>&gt;&gt;   init&lt;T&gt;(_ : UnsafePointer&lt;T&gt;)<br>&gt;&gt;   init&lt;T&gt;(_ : UnsafeMutablePointer&lt;T&gt;)<br>&gt;&gt;   init?&lt;T&gt;(_ : UnsafePointer&lt;T&gt;?)<br>&gt;&gt;   init?&lt;T&gt;(_ : UnsafeMutablePointer&lt;T&gt;?)<br>&gt;&gt; <br>&gt;&gt;   init&lt;T&gt;(_ : OpaquePointer&lt;T&gt;)<br>&gt;&gt;   init?&lt;T&gt;(_ : OpaquePointer&lt;T&gt;?)<br>&gt;&gt; <br>&gt;&gt;   init?(bitPattern: Int)<br>&gt;&gt;   init?(bitPattern: UInt)<br>&gt;&gt; <br>&gt;&gt;   func load&lt;T&gt;(_ : T.Type) -&gt; T<br>&gt;&gt; <br>&gt;&gt;   @warn_unused_result<br>&gt;&gt;   init(allocatingBytes size: Int, alignedTo: Int)<br>&gt;&gt; <br>&gt;&gt;   @warn_unused_result<br>&gt;&gt;   init&lt;T&gt;(allocatingCapacity count: Int, of: T.Type)<br>&gt;&gt; <br>&gt;&gt;   func deallocateBytes(_ size: Int, alignedTo: Int)<br>&gt;&gt; <br>&gt;&gt;   func deallocateCapacity&lt;T&gt;(_ num: Int, of: T.Type)<br>&gt;&gt; <br>&gt;&gt;   // Returns a pointer one byte after the initialized memory.<br>&gt;&gt;   func initialize&lt;T&gt;(with newValue: T, count: Int = 1) -&gt; UnsafeBytePointer<br>&gt;&gt; <br>&gt;&gt;   // Returns a pointer one byte after the initialized memory.<br>&gt;&gt;   func initialize&lt;T&gt;(from: UnsafePointer&lt;T&gt;, count: Int) -&gt; UnsafeBytePointer<br>&gt;&gt; <br>&gt;&gt;   func initializeBackward&lt;T&gt;(from source: UnsafePointer&lt;T&gt;, count: Int)<br>&gt;&gt; <br>&gt;&gt;   func deinitialize&lt;T&gt;(_ : T.Type, count: Int = 1)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension OpaquePointer {<br>&gt;&gt;   init(_ : UnsafeBytePointer)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension Int {<br>&gt;&gt;   init(bitPattern: UnsafeBytePointer)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension UInt {<br>&gt;&gt;   init(bitPattern: UnsafeBytePointer)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension UnsafeBytePointer : RandomAccessIndex {<br>&gt;&gt;   typealias Distance = Int<br>&gt;&gt; <br>&gt;&gt;   func successor() -&gt; UnsafeBytePointer<br>&gt;&gt;   func predecessor() -&gt; UnsafeBytePointer<br>&gt;&gt;   func distance(to : UnsafeBytePointer) -&gt; Int<br>&gt;&gt;   func advanced(by : Int) -&gt; UnsafeBytePointer<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func == (lhs: UnsafeBytePointer, rhs: UnsafeBytePointer) -&gt; Bool<br>&gt;&gt; <br>&gt;&gt; func &lt; (lhs: UnsafeBytePointer, rhs: UnsafeBytePointer) -&gt; Bool<br>&gt;&gt; <br>&gt;&gt; func + (lhs: UnsafeBytePointer, rhs: Int) -&gt; UnsafeBytePointer<br>&gt;&gt; <br>&gt;&gt; func + (lhs: Int, rhs: UnsafeBytePointer) -&gt; UnsafeBytePointer<br>&gt;&gt; <br>&gt;&gt; func - (lhs: UnsafeBytePointer, rhs: Int) -&gt; UnsafeBytePointer<br>&gt;&gt; <br>&gt;&gt; func - (lhs: UnsafeBytePointer, rhs: UnsafeBytePointer) -&gt; Int<br>&gt;&gt; <br>&gt;&gt; func += (lhs: inout UnsafeBytePointer, rhs: Int)<br>&gt;&gt; <br>&gt;&gt; func -= (lhs: inout UnsafeBytePointer, rhs: Int)<br>&gt;&gt; Occasionally, we need to convert from a UnsafeBytePointer to an UnsafePointer. This should only be done in very rare circumstances when the author understands the compiler&#39;s strict type rules for UnsafePointer. Although this could be done by casting through an OpaquePointer, an explicit, designated unsafe pointer cast API would makes the risks more obvious and self-documenting. For example:<br>&gt;&gt; <br>&gt;&gt; extension UnsafePointer {<br>&gt;&gt;   init(_ from: UnsafeBytePointer, toPointee: Pointee.type)<br>&gt;&gt; }<br>&gt;&gt; extension UnsafeMutablePointer {<br>&gt;&gt;   init(_ from: UnsafeBytePointer, toPointee: Pointee.type)<br>&gt;&gt; }<br>&gt;&gt; Similarly, conversion between UnsafePointer types must now be spelled with an explicitly Pointee type:<br>&gt;&gt; <br>&gt;&gt; extension UnsafePointer {<br>&gt;&gt;   init&lt;U&gt;(_ from: UnsafePointer&lt;U&gt;, toPointee: Pointee.Type)<br>&gt;&gt;   init&lt;U&gt;(_ from: UnsafeMutablePointer&lt;U&gt;, toPointee: Pointee.Type)<br>&gt;&gt; }<br>&gt;&gt; extension UnsafeMutablePointer {<br>&gt;&gt;   init&lt;U&gt;(_ from: UnsafeMutablePointer&lt;U&gt;, toPointee: Pointee.Type)<br>&gt;&gt; }<br>&gt;&gt;  &lt;https://github.com/atrick/swift-evolution/tree/voidpointer/proposals#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt; <br>&gt;&gt; The largest impact of this change is that void* and const void* are imported as UnsafeBytePointer. This impacts many public APIs, but with implicit argument conversion should not affect typical uses of those APIs.<br>&gt;&gt; <br>&gt;&gt; Any Swift projects that rely on type inference to convert between UnsafePointer types will need to take action. The developer needs to determine whether type punning is necessary. If so, they must migrate to the UnsafeBytePointer API. Otherwise, they can work around the new restriction by using a toPointee, or mutating label.<br>&gt;&gt; <br>&gt;&gt; Disallowing inferred UnsafePointer direct conversion requires some standard library code to use an explicit toPointeelabel for unsafe conversions that may violate strict aliasing.<br>&gt;&gt; <br>&gt;&gt; All occurrences of Unsafe[Mutable]Pointer&lt;Void&gt; in the standard library are converted to UnsafeBytePointer. e.g. unsafeAddress() now returns UnsafeBytePointer, not UnsafePointer&lt;Void&gt;.<br>&gt;&gt; <br>&gt;&gt; Some occurrences of Unsafe[Mutable]Pointer&lt;Pointee&gt; in the standard library are replaced with UnsafeBytePointer, either because the code was playing too loosely with strict aliasing rules, or because the code actually wanted to perform pointer arithmetic on byte-addresses.<br>&gt;&gt; <br>&gt;&gt; StringCore.baseAddress changes from OpaquePointer to UnsafeBytePointer because it is computing byte offsets and accessing the memory. OpaquePointer is meant for bridging, but should be truly opaque; that is, nondereferenceable and not involved in address computation.<br>&gt;&gt; <br>&gt;&gt; The StringCore implementation does a considerable amount of casting between different views of the String storage. The current implementation already demonstrates some awareness of strict aliasing rules. The rules are generally followed by ensuring that the StringBuffer only be accessed using the appropriate CodeUnit within Swift code. For interoperability and optimization, String buffers frequently need to be cast to and from CChar. This is valid as long access to the buffer from Swift is guarded by dynamic checks of the encoding type. These unsafe, but dynamically legal conversion points will now be labeled with toPointee.<br>&gt;&gt; <br>&gt;&gt; CoreAudio utilities now use an UnsafeBytePointer.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/atrick/swift-evolution/tree/voidpointer/proposals#implementation-status&gt;Implementation status<br>&gt;&gt; <br>&gt;&gt; On my unsafeptr_convert branch &lt;https://github.com/atrick/swift/commits/unsafeptr_convert&gt;, I&#39;ve made most of the necessary changes to support the addition of UnsafeBytePointerand the removal of inferred UnsafePointer conversion.<br>&gt;&gt; <br>&gt;&gt; There are a several things going on here in order to make it possible to build the standard library with the changes:<br>&gt;&gt; <br>&gt;&gt; A new UnsafeBytePointer type is defined.<br>&gt;&gt; <br>&gt;&gt; The type system imports void* as UnsafeBytePointer.<br>&gt;&gt; <br>&gt;&gt; The type system handles implicit conversions to UnsafeBytePointer.<br>&gt;&gt; <br>&gt;&gt; UnsafeBytePointer replaces both UnsafePointer&lt;Void&gt; and UnsafeMutablePointer&lt;Void&gt;.<br>&gt;&gt; <br>&gt;&gt; The standard library was relying on inferred UnsafePointer conversion in over 100 places. Most of these conversions now either take an explicit label, such as &#39;toPointee&#39;, &#39;mutating&#39;. Some have been rewritten.<br>&gt;&gt; <br>&gt;&gt; Several places in the standard library that were playing loosely with strict aliasing or doing bytewise pointer arithmetic now use UnsafeBytePointer instead.<br>&gt;&gt; <br>&gt;&gt; Explicit labeled Unsafe[Mutable]Pointer initializers are added.<br>&gt;&gt; <br>&gt;&gt; The inferred Unsafe[Mutable]Pointer conversion is removed.<br>&gt;&gt; <br>&gt;&gt; TODO:<br>&gt;&gt; <br>&gt;&gt; Once this proposal is accepted, and the rules for casting between pointers types have been decided, we need to finish implementing the type system support. The current implementation (intentionally) breaks a few tests in pointer_conversion.swift. We also need to ensure that interoperability requirements are met. Currently, many argument casts to be explicitly labeled. The current implementation also makes it easy for users to hit an &quot;ambiguous use of &#39;init&#39;&quot; error when relying on implicit argument conversion.<br>&gt;&gt; <br>&gt;&gt; Additionally:<br>&gt;&gt; <br>&gt;&gt; A name mangled abbreviation needs to be created for UnsafeBytePointer.<br>&gt;&gt; <br>&gt;&gt; The StringAPI tests should probably be rewritten with UnsafeBytePointer.<br>&gt;&gt; <br>&gt;&gt; The NSStringAPI utilities and tests may need to be ported to UnsafeBytePointer<br>&gt;&gt; <br>&gt;&gt; The CoreAudio utilities and tests may need to be ported to UnsafeBytePointer.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/atrick/swift-evolution/tree/voidpointer/proposals#alternatives-considered&gt;Alternatives considered<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/atrick/swift-evolution/tree/voidpointer/proposals#existing-workaround&gt;Existing workaround<br>&gt;&gt; <br>&gt;&gt; In some cases, developers can safely reinterpret values to achieve the same effect as type punning:<br>&gt;&gt; <br>&gt;&gt; let ptrI32 = UnsafeMutablePointer&lt;Int32&gt;(allocatingCapacity: 1)<br>&gt;&gt; ptrI32[0] = Int32()<br>&gt;&gt; let u = unsafeBitCast(ptrI32[0], to: UInt32.self)<br>&gt;&gt; Note that all access to the underlying memory is performed with the same element type. This is perfectly legitimate, but simply isn&#39;t a complete solution. It also does not eliminate the inherent danger in declaring a typed pointer and expecting it to point to values of a different type.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/atrick/swift-evolution/tree/voidpointer/proposals#discarded-alternatives&gt;Discarded alternatives<br>&gt;&gt; <br>&gt;&gt; We considered adding a typePunnedMemory property to the existing Unsafe[Mutabale]Pointer API. This would provide a legal way to access a potentially type punned Unsafe[Mutabale]Pointer. However, it would certainly cause confusion without doing much to reduce likelihood of programmer error. Furthermore, there are no good use cases for such a property evident in the standard library.<br>&gt;&gt; <br>&gt;&gt; The opaque _RawByte struct is a technique that allows for byte-addressable buffers while hiding the dangerous side effects of type punning (a _RawByte could be loaded but it&#39;s value cannot be directly inspected). UnsafePointer&lt;_RawByte&gt; is a clever alternative to UnsafeBytePointer. However, it doesn&#39;t do enough to prevent undefined behavior. The loaded _RawByte would naturally be accessed via unsafeBitCast, which would mislead the author into thinking that they have legally bypassed the type system. In actuality, this API blatantly violates strict aliasing. It theoretically results in undefined behavior as it stands, and may actually exhibit undefined behavior if the user recovers the loaded value.<br>&gt;&gt; <br>&gt;&gt; To solve the safety problem with UnsafePointer&lt;_RawByte&gt;, the compiler could associate special semantics with a UnsafePointer bound to this concrete generic parameter type. Statically enforcing casting rules would be difficult if not impossible without new language features. It would also be impossible to distinguish between typed and untyped pointer APIs. For example, UnsafePointer&lt;T&gt;.load&lt;U&gt; would be a nonsensical vestige.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/atrick/swift-evolution/tree/voidpointer/proposals#alternate-proposal-for-void-type&gt;Alternate proposal for void* type<br>&gt;&gt; <br>&gt;&gt; Changing the imported type for void* will be somewhat disruptive. Furthermore, this proposal currently drops the distinction between void* and const void*--an obvious loss of API information.<br>&gt;&gt; <br>&gt;&gt; We could continue to import void* as UnsafeMutablePointer&lt;Void&gt; and const void* as UnsafePointer&lt;Void&gt;, which will continue to serve as an &quot;opaque&quot; untyped pointer. Converting to UnsafeBytePointer would be necesarry to perform pointer arithmetic or to conservatively handle possible type punning.<br>&gt;&gt; <br>&gt;&gt; This alternative is much less disruptive, but we are left with two forms of untyped pointer, one of which (UnsafePointer) the type system somewhat conflates with typed pointers.<br>&gt;&gt; <br>&gt;&gt; Given the current restrictions of the language, it&#39;s not clear how to statically enforce the necessary rules for castingUnsafePointer&lt;Void&gt; once general<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160509/aac8e996/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 455 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160509/aac8e996/attachment.sig&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[RFC] UnsafeBytePointer API for In-Memory Layout</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>May 10, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On May 9, 2016, at 2:43 PM, Geordie J &lt;geojay at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Am 09.05.2016 um 23:04 schrieb Andrew Trick &lt;atrick at apple.com &lt;mailto:atrick at apple.com&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 9, 2016, at 12:38 PM, Geordie Jay &lt;geojay at gmail.com &lt;mailto:geojay at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I read this proposal and I&#39;m a bit unsure what its purpose would be:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Basically you want to prevent UnsafePointer&lt;XYZ&gt;(UnsafePointer&lt;Void&gt;) conversions and/or vice-versa? And you&#39;d achieve this by replacing UnsafePointer&lt;Void&gt; with UnsafeBytePointer that has no bound pointer type?<br>&gt;&gt; <br>&gt;&gt; I want to prevent UnsafePointer&lt;U&gt;(UnsafePointer&lt;T&gt;) *except* when the destination is UnsafePointer&lt;Void&gt;.<br>&gt;&gt; <br>&gt;&gt; UnsafePointer&lt;Void&gt;(UnsafePointer&lt;T&gt;) is fine.<br>&gt;&gt; <br>&gt;&gt; UnsafeBytePointer provides two thing:<br>&gt;&gt; - A means to prevent the conversion above<br>&gt;&gt; - An API for legal type punning, which does not exist today<br>&gt; <br>&gt; So you mean to enable UnsafePointer&lt;Void&gt; aka. UnsafeBytePointer(UnsafePointer&lt;T&gt;), but disable other type-to-type pointer recasts? I guess that’s a worthy goal at some level, but is there anything stopping someone just saying UnsafePointer(UnsafeBytePointer(myPointerToMemoryContainingTypeT), toPointee: U.type)?<br></p><p>Nothing prevents that. But I want to be able to see when it happens and want it to be very deliberate.<br></p><p>&gt; It still just seems like we can do the same thing spelled differently. I don’t see how changing how that happens could benefit us or the compiler, but maybe this is one we should just take your word on.<br>&gt; <br>&gt; Assuming the likely case that this is just beyond my understanding, I do wonder why we’d need to change the API. I guess there are a lot of assumptions made about both UnsafePointer&lt;Void&gt; and UnsafePointer&lt;T&gt; that don’t necessarily apply to both to an equal degree?<br></p><p>Just to reiterate. There’s currently no way to legally type pun. UnsafeBytePointer solves that problem. I’m looking for feedback on whether it should also replace UnsafePointer&lt;Void&gt;. However, if UnsafeBytePointer does not replace UnsafePointer&lt;Void&gt; then I can’t enforce the casting rules that I want. I’ll dedicate the rest of this message to that problem..<br></p><p>&gt;&gt;&gt; In one sense the change seems fine to me, but as someone who uses a lot of C APIs and a lot of CoreAudio/CoreMIDI in Swift already I can&#39;t really see what benefit it&#39;d bring. Presumably we&#39;d still want an option of converting UnsafeBytePointer to UnsafePointer&lt;SomeActualType&gt; for things like C function pointer callback &quot;context&quot;/&quot;userInfo&quot; uses, so it&#39;s not like we&#39;d be preventing programmer error in that way.<br>&gt;&gt; <br>&gt;&gt; It’s possible to cast UnsafeBytePointer to UnsafePointer&lt;SomeActualType&gt;. I want the programmer to make their intent explicit  by writing a cast and spelling SomeActualType at the point of the cast. In the proposal, that’s done using a labeled initializer.<br>&gt; <br>&gt; How is this different from what we do now, namely UnsafePointer&lt;SomeActualType&gt;(myUnsafePointer) &lt;— I’m also spelling out SomeActualType there. I think I’m still misunderstanding something critical here.<br></p><p>I&#39;d be fine with UnsafePointer&lt;ToType&gt;(p), but type inference means that you can usually omit the generic parameter. I do also find the label helpful. I think a standalone function for converting pointer types would work, but I feel like we&#39;ve been moving toward initializers for conversion.<br></p><p>I used the term &quot;inferred initialization&quot; in the proposal without defining it.  What I mean by an &quot;inferred initializer&quot; is that the generic type being initialized is inferred by the argument type and/or the overloaded initializer itself is resolved based on the argument type. These behaviors can be prevented by providing an argument label and requiring the initialized type parameter to be passed as an argument.<br></p><p>Here&#39;s an example of initializing generic UnsafePointer via inferrence:<br></p><p>func takesUMP(_ p: UnsafeMutablePointer&lt;UInt&gt;) -&gt; UInt {<br>  return p[0]<br>}<br></p><p>func scary(q: UnsafeMutablePointer&lt;Int&gt;) -&gt; UInt {<br>  return takesUMP(UnsafeMutablePointer(q))<br>}<br></p><p>I don&#39;t see any cues that &#39;scary&#39; may be introducing undefined behavior.<br></p><p>What I&#39;m proposing with UnsafePointer initialization is the same thing that we do with unsafeBitCast. The destination of the cast can usually be inferred, but we want the developer to explicitly state the expected destination type both because type inferrence can be surprising, and because it&#39;s important to the reader for code comprehension.<br></p><p>&quot;How does this make the developer&#39;s life easier&quot; is the wrong question. I&#39;m trying to make something that developer&#39;s probably shouldn&#39;t be doing harder to do. Type punning is not a normal use case for UnsafePointer. It&#39;s likely going to lead to undefined behavior. For that reason, it should not be something that users of UnsafePointer fall into unaware. I also think it&#39;s critical for code inspection to be able to identify points where this conversion happens. The pointer conversion by itself is not undefined behavior, but it is the only point in code where we can identify possible type punning. It&#39;s the only anchor we have for finding code that makes extremely subtle assumptions about types and requires intense scrutiny.<br></p><p>I had to sift through hundreds of occurrences in the standard library of type inferred UnsafePointer intializers of the form: UnsafePointer(p). Most of those were not actually doing &quot;unsafe&quot; conversion, but I had no way of knowing. <br></p><p>Most of the conversion in the standard library turned out to be:<br>- to and from UnsafePointer&lt;Void&gt;<br>- to and from mutating pointers<br>- to and from Autoreleasing pointers<br></p><p>I cannot emphasize enough how much easier it would have been for me to understand the code if each cast&#39;s intention had been spelled out.<br></p><p>&gt; <br>&gt; From your email that just came in:<br>&gt; <br>&gt;&gt; if converting UMP types leads to undefined behavior, then it should be prohibited in the API, unless the programming explicitly requests the conversion<br>&gt; <br>&gt; <br>&gt; This is the point I’d really like to try and understand: can you clarify how the new API is any more or less explicit than the old one?<br></p><p>Let me first claim that we should not rely on implicit argument conversion to indicate which casts are safe. Clearly an implicit conversion should be safe. But implicit argument conversion doesn&#39;t apply everywhere, and writing an explicit initialization doesn&#39;t tell me that something unsafe is happening. I maintain that it is reasonable to write &quot;UnsafePointer(p)&quot; whenever the programmer wants to be explicit about the expression&#39;s type, and that should not by itself indicate any unsafe conversion is happening. <br></p><p>So with that in mind, I&#39;ll make everything explicit in this example:<br></p><p>func takesVoid  (_: UnsafePointer&lt;Void&gt;) {}<br>func takesUP_T  (_: UnsafePointer&lt;T&gt;) {}<br>func takesUP_X  (_: UnsafePointer&lt;X&gt;) {}<br>func takesUMP_T (_: UnsafeMutablePointer&lt;T&gt;) {}<br>func takesUMP_X (_: UnsafeMutablePointer&lt;X&gt;) {}<br></p><p>let p = UnsafePointer&lt;T&gt;(...)<br></p><p>Before:<br></p><p>takesVoid(UnsafePointer(p))<br></p><p>takesUP_T(UnsafePointer(p))<br></p><p>takesUP_X(UnsafePointer(p))<br></p><p>takesUMP_T(UnsafeMutablePointer(p))<br></p><p>takesUMP_X(UnsafeMutablePointer(p))<br></p><p>After:<br></p><p>takesVoid(UnsafeBytePointer(p))<br></p><p>takesUP_T(UnsafePointer(p))<br></p><p>takesUP_X(UnsafePointer(p, to: X.self))<br></p><p>takesUMP_T(UnsafeMutablePointer(mutating: p))<br></p><p>takesUMP_X(UnsafeMutablePointer(mutating: UnsafePointer(p, to: X.self)))<br></p><p>(I admit the &quot;.self&quot; syntax is ugly and it would be nice if it went away).<br></p><p>This will result in redundancies such as:<br></p><p>-    self = String.decodeCString(UnsafePointer(cString), as: UTF8.self,<br>+    self = String.decodeCString(UnsafePointer(cString, to: UTF8.CodeUnit.self), as: UTF8.self,<br></p><p>In this case the API was designed for inferred initializers, and we could probably do away with the &#39;as&#39; label now. But keep in mind that my goal is not to make type punning look pretty. Let&#39;s expose its ugliness.<br></p><p>&gt;&gt; <br>&gt;&gt;&gt; Call me conservative but to me the current system seems to work as well as it can. If anything it&#39;s already enough boilerplate going through hoops converting an UnsafeMutablePointer&lt;Void&gt; into a [Float] even when I know and the C API knows perfectly well what it actually contains... Would happily be convinced otherwise about this proposal though, I&#39;m pretty new at all this.<br>&gt;&gt; <br>&gt;&gt; I think you are asking for implicit conversions when calling C APIs. That’s good feedback. When implementing this proposal I tried to allow implicit conversions in reasonable cases, but leaned toward being conservative. I would rather see more explicit casts now and eliminate them if people find it awkward.<br>&gt; <br>&gt; Maybe, but I’m not sure how that’d look under this proposal. I mean Strings and literals currently being accepted as UnsafePointer&lt;CChar&gt; is a nice touch, and last I checked I can use [T, T, T, ...] array literals in place of UnsafePointer&lt;T&gt;, I certainly wouldn’t want to go below that level of conservatism here.<br></p><p>Right. Implicit conversion from String and Array literals to UnsafeBytePointer is one of the main things I didn&#39;t implement yet (it still works the same<br>for UnsafePointer). I can do that, but wanted feedback on other parts of the proposal first.<br></p><p>-Andy<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; I&#39;m looking for some consensus on core aspects of the proposal, then we can take into consideration precisely which implicit conversions should be supported.<br>&gt;&gt; <br>&gt;&gt; -Andy<br>&gt;&gt; <br>&gt;&gt;&gt; Geordie<br>&gt;&gt;&gt; Andrew Trick via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; schrieb am Mo., 9. Mai 2016 um 20:15:<br>&gt;&gt;&gt; Hello Swift evolution,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I sent this to swift-dev last week. Sorry to post on two lists!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift does a great job of protecting against undefined behavior--as long as you avoid &quot;unsafe&quot; APIs, that is. However, unsafe APIs are important for giving developers control over implementation details and performance. Naturally, the contract between unsafe APIs and the optimizer is crucial. When a developer uses an unsafe API, the rules governing safe, well-defined behavior must be clear. On the opposite end, the optimizer must know which assumptions it can make based on those rules. Simply saying that anything goes because &quot;unsafe&quot; is in the name is not helpful to this effort.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For a long time, I&#39;ve wanted these rules nailed down. We have more users taking advantage of advanced features, and more optimizations that take advantage of assumptions guided by the type system. This seems like a particularly good time to resolve UnsafePointer semantics, considering the type system and UnsafePointer work that&#39;s been going on recently. Strict aliasing is something I would like addressed. If we do nothing here, then we will end up by default inheriting C/C++ semantics, as with any language that relies on a C/C++ backend. In other words, developers will be forced to write code with technically undefined behavior and rely on the compiler to be smart enough to recognize and recover from common patterns. Or we can take advantage of this opportunity and instead adopt a sound memory model with respect to aliasing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This proposal is only an RFC at this point. I&#39;m sending it out now to allow for plenty of time for discussion (or advance warning). Keep in mind that it could change considerably before it goes up for review.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Andy<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; UnsafeBytePointer API for In-Memory Layout<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposal: SE-NNNN &lt;https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsafebytepointer.md&gt;<br>&gt;&gt;&gt; Author(s): Andrew Trick &lt;https://github.com/atrick&gt;<br>&gt;&gt;&gt; Status: Awaiting review &lt;https://github.com/atrick/swift-evolution/tree/voidpointer/proposals#rationale&gt;<br>&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt;  &lt;https://github.com/atrick/swift-evolution/tree/voidpointer/proposals#introduction&gt;Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; UnsafePointer and UnsafeMutable refer to a typed region of memory, and the compiler must be able to assume that UnsafePointer element (Pointee) type is consistent with other access to the same memory. See proposed Type Safe Memory Access documentation &lt;https://github.com/atrick/swift/blob/type-safe-mem-docs/docs/TypeSafeMemory.rst&gt;. Consequently, inferred conversion between UnsafePointer element types exposes an easy way to abuse the type system. No alternative currently exists for manual memory layout and direct access to untyped memory, and that leads to an overuse of UnsafePointer. These uses of UnsafePointer, which depend on pointer type conversion, make accidental type punning likely. Type punning via UnsafePointer is semantically undefined behavior and de facto undefined behavior given the optimizer&#39;s long-time treatment of UnsafePointer.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In this document, all mentions of UnsafePointer also apply to UnsafeMutablePointer.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/atrick/swift-evolution/tree/voidpointer/proposals#motivation&gt;Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To avoid accidental type punning, we should prohibit inferred conversion between UnsafePointer&lt;T&gt; and UnsafePointer&lt;U&gt; unless the target of the conversion is an untyped or nondereferenceable pointer (currently represented as UnsafePointer&lt;Void&gt;).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To support this change we should introduce a new pointer type that does not bind the type of its Pointee. Such a new pointer type would provide an ideal foundation for an API that allows byte-wise pointer arithmetic and a legal, well-defined means to access an untyped region of memory.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As motivation for such an API, consider that an UnsafePointer&lt;Void&gt; or OpaquePointer may be currently be obtained from an external API. However, the developer may know the memory layout and may want to read or write elements whose types are compatible with that layout. This a reasonable use case, but unless the developer can guarantee that all accesses to the same memory location have the same type, then they cannot use UnsafePointer to access the memory without risking undefined behavior.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; An UnsafeBytePointer example, using a new proposed API is included below.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/atrick/swift-evolution/tree/voidpointer/proposals#proposed-solution&gt;Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Introduce an UnsafeBytePointer type along with an API for obtaining a UnsafeBytePointer value at a relative byte offset and loading and storing arbitrary types at that location.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Statically prohibit inferred UnsafePointer conversion while allowing inferred UnsafePointer to UnsafeBytePointerconversion.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; UnsafeBytePointer meets multiple requirements:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; An untyped pointer to memory<br>&gt;&gt;&gt; Pointer arithmetic within byte-addressable memory<br>&gt;&gt;&gt; Type-unsafe access to memory (legal type punning)<br>&gt;&gt;&gt; UnsafeBytePointer will replace UnsafeMutablePointer&lt;Void&gt; as the representation for untyped memory. For API clarify we could consider a typealias for VoidPointer. I don&#39;t think a separate VoidPointer type would be useful--there&#39;s no danger that UnsafeBytePointer will be casually dereferenced, and don&#39;t see the danger in allowing pointer arithmetic since the only reasonable interpretation is that of a byte-addressable memory.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Providing an API for type-unsafe memory access would not serve a purpose without the ability to compute byte offsets. Of course, we could require users to convert back and forth using bitPatterns, but I think that would be awkward and only obscure the purpose of the UnsafeBytePointer type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In this proposal, UnsafeBytePointer does not specify mutability. Adding an UnsafeMutableBytePointer would be straightforward, but adding another pointer type needs strong justification. I expect to get input from the community on this. If we agree that the imported type for const void* should be UnsafeBytePointer, then we probably need UnsafeMutablePointer to handle interoperability.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/atrick/swift-evolution/tree/voidpointer/proposals#detailed-design&gt;Detailed design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The public API is shown here. For details and comments, see the unsafeptr_convert branch &lt;https://github.com/atrick/swift/commits/unsafeptr_convert&gt;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct UnsafeBytePointer : Hashable, _Pointer {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   let _rawValue: Builtin.RawPointer<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   var hashValue: Int {...}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   init&lt;T&gt;(_ : UnsafePointer&lt;T&gt;)<br>&gt;&gt;&gt;   init&lt;T&gt;(_ : UnsafeMutablePointer&lt;T&gt;)<br>&gt;&gt;&gt;   init?&lt;T&gt;(_ : UnsafePointer&lt;T&gt;?)<br>&gt;&gt;&gt;   init?&lt;T&gt;(_ : UnsafeMutablePointer&lt;T&gt;?)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   init&lt;T&gt;(_ : OpaquePointer&lt;T&gt;)<br>&gt;&gt;&gt;   init?&lt;T&gt;(_ : OpaquePointer&lt;T&gt;?)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   init?(bitPattern: Int)<br>&gt;&gt;&gt;   init?(bitPattern: UInt)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   func load&lt;T&gt;(_ : T.Type) -&gt; T<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   @warn_unused_result<br>&gt;&gt;&gt;   init(allocatingBytes size: Int, alignedTo: Int)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   @warn_unused_result<br>&gt;&gt;&gt;   init&lt;T&gt;(allocatingCapacity count: Int, of: T.Type)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   func deallocateBytes(_ size: Int, alignedTo: Int)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   func deallocateCapacity&lt;T&gt;(_ num: Int, of: T.Type)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   // Returns a pointer one byte after the initialized memory.<br>&gt;&gt;&gt;   func initialize&lt;T&gt;(with newValue: T, count: Int = 1) -&gt; UnsafeBytePointer<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   // Returns a pointer one byte after the initialized memory.<br>&gt;&gt;&gt;   func initialize&lt;T&gt;(from: UnsafePointer&lt;T&gt;, count: Int) -&gt; UnsafeBytePointer<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   func initializeBackward&lt;T&gt;(from source: UnsafePointer&lt;T&gt;, count: Int)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   func deinitialize&lt;T&gt;(_ : T.Type, count: Int = 1)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension OpaquePointer {<br>&gt;&gt;&gt;   init(_ : UnsafeBytePointer)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Int {<br>&gt;&gt;&gt;   init(bitPattern: UnsafeBytePointer)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension UInt {<br>&gt;&gt;&gt;   init(bitPattern: UnsafeBytePointer)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension UnsafeBytePointer : RandomAccessIndex {<br>&gt;&gt;&gt;   typealias Distance = Int<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   func successor() -&gt; UnsafeBytePointer<br>&gt;&gt;&gt;   func predecessor() -&gt; UnsafeBytePointer<br>&gt;&gt;&gt;   func distance(to : UnsafeBytePointer) -&gt; Int<br>&gt;&gt;&gt;   func advanced(by : Int) -&gt; UnsafeBytePointer<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func == (lhs: UnsafeBytePointer, rhs: UnsafeBytePointer) -&gt; Bool<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func &lt; (lhs: UnsafeBytePointer, rhs: UnsafeBytePointer) -&gt; Bool<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func + (lhs: UnsafeBytePointer, rhs: Int) -&gt; UnsafeBytePointer<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func + (lhs: Int, rhs: UnsafeBytePointer) -&gt; UnsafeBytePointer<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func - (lhs: UnsafeBytePointer, rhs: Int) -&gt; UnsafeBytePointer<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func - (lhs: UnsafeBytePointer, rhs: UnsafeBytePointer) -&gt; Int<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func += (lhs: inout UnsafeBytePointer, rhs: Int)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func -= (lhs: inout UnsafeBytePointer, rhs: Int)<br>&gt;&gt;&gt; Occasionally, we need to convert from a UnsafeBytePointer to an UnsafePointer. This should only be done in very rare circumstances when the author understands the compiler&#39;s strict type rules for UnsafePointer. Although this could be done by casting through an OpaquePointer, an explicit, designated unsafe pointer cast API would makes the risks more obvious and self-documenting. For example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension UnsafePointer {<br>&gt;&gt;&gt;   init(_ from: UnsafeBytePointer, toPointee: Pointee.type)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; extension UnsafeMutablePointer {<br>&gt;&gt;&gt;   init(_ from: UnsafeBytePointer, toPointee: Pointee.type)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; Similarly, conversion between UnsafePointer types must now be spelled with an explicitly Pointee type:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension UnsafePointer {<br>&gt;&gt;&gt;   init&lt;U&gt;(_ from: UnsafePointer&lt;U&gt;, toPointee: Pointee.Type)<br>&gt;&gt;&gt;   init&lt;U&gt;(_ from: UnsafeMutablePointer&lt;U&gt;, toPointee: Pointee.Type)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; extension UnsafeMutablePointer {<br>&gt;&gt;&gt;   init&lt;U&gt;(_ from: UnsafeMutablePointer&lt;U&gt;, toPointee: Pointee.Type)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;  &lt;https://github.com/atrick/swift-evolution/tree/voidpointer/proposals#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The largest impact of this change is that void* and const void* are imported as UnsafeBytePointer. This impacts many public APIs, but with implicit argument conversion should not affect typical uses of those APIs.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Any Swift projects that rely on type inference to convert between UnsafePointer types will need to take action. The developer needs to determine whether type punning is necessary. If so, they must migrate to the UnsafeBytePointer API. Otherwise, they can work around the new restriction by using a toPointee, or mutating label.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Disallowing inferred UnsafePointer direct conversion requires some standard library code to use an explicit toPointeelabel for unsafe conversions that may violate strict aliasing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; All occurrences of Unsafe[Mutable]Pointer&lt;Void&gt; in the standard library are converted to UnsafeBytePointer. e.g. unsafeAddress() now returns UnsafeBytePointer, not UnsafePointer&lt;Void&gt;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Some occurrences of Unsafe[Mutable]Pointer&lt;Pointee&gt; in the standard library are replaced with UnsafeBytePointer, either because the code was playing too loosely with strict aliasing rules, or because the code actually wanted to perform pointer arithmetic on byte-addresses.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; StringCore.baseAddress changes from OpaquePointer to UnsafeBytePointer because it is computing byte offsets and accessing the memory. OpaquePointer is meant for bridging, but should be truly opaque; that is, nondereferenceable and not involved in address computation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The StringCore implementation does a considerable amount of casting between different views of the String storage. The current implementation already demonstrates some awareness of strict aliasing rules. The rules are generally followed by ensuring that the StringBuffer only be accessed using the appropriate CodeUnit within Swift code. For interoperability and optimization, String buffers frequently need to be cast to and from CChar. This is valid as long access to the buffer from Swift is guarded by dynamic checks of the encoding type. These unsafe, but dynamically legal conversion points will now be labeled with toPointee.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; CoreAudio utilities now use an UnsafeBytePointer.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/atrick/swift-evolution/tree/voidpointer/proposals#implementation-status&gt;Implementation status<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On my unsafeptr_convert branch &lt;https://github.com/atrick/swift/commits/unsafeptr_convert&gt;, I&#39;ve made most of the necessary changes to support the addition of UnsafeBytePointerand the removal of inferred UnsafePointer conversion.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are a several things going on here in order to make it possible to build the standard library with the changes:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A new UnsafeBytePointer type is defined.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The type system imports void* as UnsafeBytePointer.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The type system handles implicit conversions to UnsafeBytePointer.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; UnsafeBytePointer replaces both UnsafePointer&lt;Void&gt; and UnsafeMutablePointer&lt;Void&gt;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The standard library was relying on inferred UnsafePointer conversion in over 100 places. Most of these conversions now either take an explicit label, such as &#39;toPointee&#39;, &#39;mutating&#39;. Some have been rewritten.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Several places in the standard library that were playing loosely with strict aliasing or doing bytewise pointer arithmetic now use UnsafeBytePointer instead.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Explicit labeled Unsafe[Mutable]Pointer initializers are added.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The inferred Unsafe[Mutable]Pointer conversion is removed.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; TODO:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Once this proposal is accepted, and the rules for casting between pointers types have been decided, we need to finish implementing the type system support. The current implementation (intentionally) breaks a few tests in pointer_conversion.swift. We also need to ensure that interoperability requirements are met. Currently, many argument casts to be explicitly labeled. The current implementation also makes it easy for users to hit an &quot;ambiguous use of &#39;init&#39;&quot; error when relying on implicit argument conversion.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Additionally:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A name mangled abbreviation needs to be created for UnsafeBytePointer.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The StringAPI tests should probably be rewritten with UnsafeBytePointer.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The NSStringAPI utilities and tests may need to be ported to UnsafeBytePointer<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The CoreAudio utilities and tests may need to be ported to UnsafeBytePointer.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/atrick/swift-evolution/tree/voidpointer/proposals#alternatives-considered&gt;Alternatives considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/atrick/swift-evolution/tree/voidpointer/proposals#existing-workaround&gt;Existing workaround<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In some cases, developers can safely reinterpret values to achieve the same effect as type punning:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let ptrI32 = UnsafeMutablePointer&lt;Int32&gt;(allocatingCapacity: 1)<br>&gt;&gt;&gt; ptrI32[0] = Int32()<br>&gt;&gt;&gt; let u = unsafeBitCast(ptrI32[0], to: UInt32.self)<br>&gt;&gt;&gt; Note that all access to the underlying memory is performed with the same element type. This is perfectly legitimate, but simply isn&#39;t a complete solution. It also does not eliminate the inherent danger in declaring a typed pointer and expecting it to point to values of a different type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/atrick/swift-evolution/tree/voidpointer/proposals#discarded-alternatives&gt;Discarded alternatives<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We considered adding a typePunnedMemory property to the existing Unsafe[Mutabale]Pointer API. This would provide a legal way to access a potentially type punned Unsafe[Mutabale]Pointer. However, it would certainly cause confusion without doing much to reduce likelihood of programmer error. Furthermore, there are no good use cases for such a property evident in the standard library.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The opaque _RawByte struct is a technique that allows for byte-addressable buffers while hiding the dangerous side effects of type punning (a _RawByte could be loaded but it&#39;s value cannot be directly inspected). UnsafePointer&lt;_RawByte&gt; is a clever alternative to UnsafeBytePointer. However, it doesn&#39;t do enough to prevent undefined behavior. The loaded _RawByte would naturally be accessed via unsafeBitCast, which would mislead the author into thinking that they have legally bypassed the type system. In actuality, this API blatantly violates strict aliasing. It theoretically results in undefined behavior as it stands, and may actually exhibit undefined behavior if the user recovers the loaded value.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To solve the safety problem with UnsafePointer&lt;_RawByte&gt;, the compiler could associate special semantics with a UnsafePointer bound to this concrete generic parameter type. Statically enforcing casting rules would be difficult if not impossible without new language features. It would also be impossible to distinguish between typed and untyped pointer APIs. For example, UnsafePointer&lt;T&gt;.load&lt;U&gt; would be a nonsensical vestige.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/atrick/swift-evolution/tree/voidpointer/proposals#alternate-proposal-for-void-type&gt;Alternate proposal for void* type<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Changing the imported type for void* will be somewhat disruptive. Furthermore, this proposal currently drops the distinction between void* and const void*--an obvious loss of API information.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We could continue to import void* as UnsafeMutablePointer&lt;Void&gt; and const void* as UnsafePointer&lt;Void&gt;, which will continue to serve as an &quot;opaque&quot; untyped pointer. Converting to UnsafeBytePointer would be necesarry to perform pointer arithmetic or to conservatively handle possible type punning.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This alternative is much less disruptive, but we are left with two forms of untyped pointer, one of which (UnsafePointer) the type system somewhat conflates with typed pointers.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Given the current restrictions of the language, it&#39;s not clear how to statically enforce the necessary rules for castingUnsafePointer&lt;Void&gt; once general <br>&gt;&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160510/6236dcac/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7abf2ce34651dd5e97cd97b16ce21bae?s=50"></div><header><strong>[RFC] UnsafeBytePointer API for In-Memory Layout</strong> from <string>Guillaume Lessard</string> &lt;glessard at tffenterprises.com&gt;<p>May  9, 2016 at 01:00:00pm</p></header><div class="content"><p>I’m sympathetic to the elimination of UnsafePointer&lt;Void&gt; as general shorthand for an arbitrary pointer, but I lose the plot of this very long proposal. It seems to me that this increases API surface, yet everything I could do before, I could still do; it just involves more typing. What exactly does this make better?<br></p><p>Cheers,<br>Guillaume Lessard<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[RFC] UnsafeBytePointer API for In-Memory Layout</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>May  9, 2016 at 01:00:00pm</p></header><div class="content"><p>Regarding the UnsafeBytePointer API:<br></p><p>&gt; struct UnsafeBytePointer : Hashable, _Pointer {<br>&gt; <br>&gt;   let _rawValue: Builtin.RawPointer<br>&gt; <br>&gt;   var hashValue: Int {...}<br>&gt; <br>&gt;   init&lt;T&gt;(_ : UnsafePointer&lt;T&gt;)<br>&gt;   init&lt;T&gt;(_ : UnsafeMutablePointer&lt;T&gt;)<br>&gt;   init?&lt;T&gt;(_ : UnsafePointer&lt;T&gt;?)<br>&gt;   init?&lt;T&gt;(_ : UnsafeMutablePointer&lt;T&gt;?)<br>&gt; <br>&gt;   init&lt;T&gt;(_ : OpaquePointer&lt;T&gt;)<br>&gt;   init?&lt;T&gt;(_ : OpaquePointer&lt;T&gt;?)<br>&gt; <br>&gt;   init?(bitPattern: Int)<br>&gt;   init?(bitPattern: UInt)<br>&gt; <br>&gt;   func load&lt;T&gt;(_ : T.Type) -&gt; T<br>&gt; <br>&gt;   @warn_unused_result<br>&gt;   init(allocatingBytes size: Int, alignedTo: Int)<br>&gt; <br>&gt;   @warn_unused_result<br>&gt;   init&lt;T&gt;(allocatingCapacity count: Int, of: T.Type)<br>&gt; <br>&gt;   func deallocateBytes(_ size: Int, alignedTo: Int)<br>&gt; <br>&gt;   func deallocateCapacity&lt;T&gt;(_ num: Int, of: T.Type)<br>&gt; <br>&gt;   // Returns a pointer one byte after the initialized memory.<br>&gt;   func initialize&lt;T&gt;(with newValue: T, count: Int = 1) -&gt; UnsafeBytePointer<br>&gt; <br>&gt;   // Returns a pointer one byte after the initialized memory.<br>&gt;   func initialize&lt;T&gt;(from: UnsafePointer&lt;T&gt;, count: Int) -&gt; UnsafeBytePointer<br>&gt; <br>&gt;   func initializeBackward&lt;T&gt;(from source: UnsafePointer&lt;T&gt;, count: Int)<br>&gt; <br>&gt;   func deinitialize&lt;T&gt;(_ : T.Type, count: Int = 1)<br>&gt; }<br></p><p>Should we also have &#39;assign&#39; methods, matching &#39;initialize&#39;? Should &#39;deinitialize&#39; be called &#39;destroy&#39;, matching &#39;UnsafeMutablePointer&#39;s API?<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160509/217db9ca/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[RFC] UnsafeBytePointer API for In-Memory Layout</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May  9, 2016 at 03:00:00pm</p></header><div class="content"><p>Along similar lines, with the indexing model change, isn&#39;t the following<br>outdated?<br></p><p>```<br></p><p>extension UnsafeBytePointer : RandomAccessIndex {<br>  typealias Distance = Int<br></p><p>  func successor() -&gt; UnsafeBytePointer<br>  func predecessor() -&gt; UnsafeBytePointer<br>  func distance(to : UnsafeBytePointer) -&gt; Int<br>  func advanced(by : Int) -&gt; UnsafeBytePointer<br>}<br></p><p>```<br></p><p><br>On Mon, May 9, 2016 at 3:20 PM, Joe Groff via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Regarding the UnsafeBytePointer API:<br>&gt;<br>&gt; struct UnsafeBytePointer : Hashable, _Pointer {<br>&gt;<br>&gt;   let _rawValue: Builtin.RawPointer<br>&gt;<br>&gt;   var hashValue: Int {...}<br>&gt;<br>&gt;   init&lt;T&gt;(_ : UnsafePointer&lt;T&gt;)<br>&gt;   init&lt;T&gt;(_ : UnsafeMutablePointer&lt;T&gt;)<br>&gt;   init?&lt;T&gt;(_ : UnsafePointer&lt;T&gt;?)<br>&gt;   init?&lt;T&gt;(_ : UnsafeMutablePointer&lt;T&gt;?)<br>&gt;<br>&gt;   init&lt;T&gt;(_ : OpaquePointer&lt;T&gt;)<br>&gt;   init?&lt;T&gt;(_ : OpaquePointer&lt;T&gt;?)<br>&gt;<br>&gt;   init?(bitPattern: Int)<br>&gt;   init?(bitPattern: UInt)<br>&gt;<br>&gt;   func load&lt;T&gt;(_ : T.Type) -&gt; T<br>&gt;<br>&gt;   @warn_unused_result<br>&gt;   init(allocatingBytes size: Int, alignedTo: Int)<br>&gt;<br>&gt;   @warn_unused_result<br>&gt;   init&lt;T&gt;(allocatingCapacity count: Int, of: T.Type)<br>&gt;<br>&gt;   func deallocateBytes(_ size: Int, alignedTo: Int)<br>&gt;<br>&gt;   func deallocateCapacity&lt;T&gt;(_ num: Int, of: T.Type)<br>&gt;<br>&gt;   // Returns a pointer one byte after the initialized memory.<br>&gt;   func initialize&lt;T&gt;(with newValue: T, count: Int = 1) -&gt; UnsafeBytePointer<br>&gt;<br>&gt;   // Returns a pointer one byte after the initialized memory.<br>&gt;   func initialize&lt;T&gt;(from: UnsafePointer&lt;T&gt;, count: Int) -&gt; UnsafeBytePointer<br>&gt;<br>&gt;   func initializeBackward&lt;T&gt;(from source: UnsafePointer&lt;T&gt;, count: Int)<br>&gt;<br>&gt;   func deinitialize&lt;T&gt;(_ : T.Type, count: Int = 1)<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Should we also have &#39;assign&#39; methods, matching &#39;initialize&#39;? Should<br>&gt; &#39;deinitialize&#39; be called &#39;destroy&#39;, matching &#39;UnsafeMutablePointer&#39;s API?<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160509/03795ca1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[RFC] UnsafeBytePointer API for In-Memory Layout</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>May  9, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On May 9, 2016, at 1:23 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; Along similar lines, with the indexing model change, isn&#39;t the following outdated?<br></p><p>Yes. Thanks. I’m working on updating both the proposal and implementation.<br>-Andy<br></p><p>&gt; <br>&gt; ```<br>&gt; extension UnsafeBytePointer : RandomAccessIndex {<br>&gt;   typealias Distance = Int<br>&gt; <br>&gt;   func successor() -&gt; UnsafeBytePointer<br>&gt;   func predecessor() -&gt; UnsafeBytePointer<br>&gt;   func distance(to : UnsafeBytePointer) -&gt; Int<br>&gt;   func advanced(by : Int) -&gt; UnsafeBytePointer<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; <br>&gt; On Mon, May 9, 2016 at 3:20 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Regarding the UnsafeBytePointer API:<br>&gt; <br>&gt;&gt; struct UnsafeBytePointer : Hashable, _Pointer {<br>&gt;&gt; <br>&gt;&gt;   let _rawValue: Builtin.RawPointer<br>&gt;&gt; <br>&gt;&gt;   var hashValue: Int {...}<br>&gt;&gt; <br>&gt;&gt;   init&lt;T&gt;(_ : UnsafePointer&lt;T&gt;)<br>&gt;&gt;   init&lt;T&gt;(_ : UnsafeMutablePointer&lt;T&gt;)<br>&gt;&gt;   init?&lt;T&gt;(_ : UnsafePointer&lt;T&gt;?)<br>&gt;&gt;   init?&lt;T&gt;(_ : UnsafeMutablePointer&lt;T&gt;?)<br>&gt;&gt; <br>&gt;&gt;   init&lt;T&gt;(_ : OpaquePointer&lt;T&gt;)<br>&gt;&gt;   init?&lt;T&gt;(_ : OpaquePointer&lt;T&gt;?)<br>&gt;&gt; <br>&gt;&gt;   init?(bitPattern: Int)<br>&gt;&gt;   init?(bitPattern: UInt)<br>&gt;&gt; <br>&gt;&gt;   func load&lt;T&gt;(_ : T.Type) -&gt; T<br>&gt;&gt; <br>&gt;&gt;   @warn_unused_result<br>&gt;&gt;   init(allocatingBytes size: Int, alignedTo: Int)<br>&gt;&gt; <br>&gt;&gt;   @warn_unused_result<br>&gt;&gt;   init&lt;T&gt;(allocatingCapacity count: Int, of: T.Type)<br>&gt;&gt; <br>&gt;&gt;   func deallocateBytes(_ size: Int, alignedTo: Int)<br>&gt;&gt; <br>&gt;&gt;   func deallocateCapacity&lt;T&gt;(_ num: Int, of: T.Type)<br>&gt;&gt; <br>&gt;&gt;   // Returns a pointer one byte after the initialized memory.<br>&gt;&gt;   func initialize&lt;T&gt;(with newValue: T, count: Int = 1) -&gt; UnsafeBytePointer<br>&gt;&gt; <br>&gt;&gt;   // Returns a pointer one byte after the initialized memory.<br>&gt;&gt;   func initialize&lt;T&gt;(from: UnsafePointer&lt;T&gt;, count: Int) -&gt; UnsafeBytePointer<br>&gt;&gt; <br>&gt;&gt;   func initializeBackward&lt;T&gt;(from source: UnsafePointer&lt;T&gt;, count: Int)<br>&gt;&gt; <br>&gt;&gt;   func deinitialize&lt;T&gt;(_ : T.Type, count: Int = 1)<br>&gt;&gt; }<br>&gt; <br>&gt; Should we also have &#39;assign&#39; methods, matching &#39;initialize&#39;? Should &#39;deinitialize&#39; be called &#39;destroy&#39;, matching &#39;UnsafeMutablePointer&#39;s API?<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160509/2289ce25/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[RFC] UnsafeBytePointer API for In-Memory Layout</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>May  9, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On May 9, 2016, at 1:20 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; Regarding the UnsafeBytePointer API:<br>&gt; <br>&gt;&gt; struct UnsafeBytePointer : Hashable, _Pointer {<br>&gt;&gt; <br>&gt;&gt;   let _rawValue: Builtin.RawPointer<br>&gt;&gt; <br>&gt;&gt;   var hashValue: Int {...}<br>&gt;&gt; <br>&gt;&gt;   init&lt;T&gt;(_ : UnsafePointer&lt;T&gt;)<br>&gt;&gt;   init&lt;T&gt;(_ : UnsafeMutablePointer&lt;T&gt;)<br>&gt;&gt;   init?&lt;T&gt;(_ : UnsafePointer&lt;T&gt;?)<br>&gt;&gt;   init?&lt;T&gt;(_ : UnsafeMutablePointer&lt;T&gt;?)<br>&gt;&gt; <br>&gt;&gt;   init&lt;T&gt;(_ : OpaquePointer&lt;T&gt;)<br>&gt;&gt;   init?&lt;T&gt;(_ : OpaquePointer&lt;T&gt;?)<br>&gt;&gt; <br>&gt;&gt;   init?(bitPattern: Int)<br>&gt;&gt;   init?(bitPattern: UInt)<br>&gt;&gt; <br>&gt;&gt;   func load&lt;T&gt;(_ : T.Type) -&gt; T<br>&gt;&gt; <br>&gt;&gt;   @warn_unused_result<br>&gt;&gt;   init(allocatingBytes size: Int, alignedTo: Int)<br>&gt;&gt; <br>&gt;&gt;   @warn_unused_result<br>&gt;&gt;   init&lt;T&gt;(allocatingCapacity count: Int, of: T.Type)<br>&gt;&gt; <br>&gt;&gt;   func deallocateBytes(_ size: Int, alignedTo: Int)<br>&gt;&gt; <br>&gt;&gt;   func deallocateCapacity&lt;T&gt;(_ num: Int, of: T.Type)<br>&gt;&gt; <br>&gt;&gt;   // Returns a pointer one byte after the initialized memory.<br>&gt;&gt;   func initialize&lt;T&gt;(with newValue: T, count: Int = 1) -&gt; UnsafeBytePointer<br>&gt;&gt; <br>&gt;&gt;   // Returns a pointer one byte after the initialized memory.<br>&gt;&gt;   func initialize&lt;T&gt;(from: UnsafePointer&lt;T&gt;, count: Int) -&gt; UnsafeBytePointer<br>&gt;&gt; <br>&gt;&gt;   func initializeBackward&lt;T&gt;(from source: UnsafePointer&lt;T&gt;, count: Int)<br>&gt;&gt; <br>&gt;&gt;   func deinitialize&lt;T&gt;(_ : T.Type, count: Int = 1)<br>&gt;&gt; }<br>&gt; <br>&gt; Should we also have &#39;assign&#39; methods, matching &#39;initialize&#39;? Should &#39;deinitialize&#39; be called &#39;destroy&#39;, matching &#39;UnsafeMutablePointer&#39;s API?<br></p><p>I was wondering if anyone would ask for ‘assign’. It presumes that you are storing the same type of object that was previously stored in your buffer. I didn’t want to proactively support that case because it’s a convenience and not really consistent with the pointer being type punned. You can always call deinitialize() first if you need to before calling ‘initialize&#39;. I  used ‘deinitialize’ to be consistent with UnsafeMutablePointer.<br></p><p>-Andy<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160509/addbd0bb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[RFC] UnsafeBytePointer API for In-Memory Layout</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>May  9, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On May 9, 2016, at 2:18 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On May 9, 2016, at 1:20 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Regarding the UnsafeBytePointer API:<br>&gt;&gt; <br>&gt;&gt;&gt; struct UnsafeBytePointer : Hashable<br>&gt;&gt;&gt; , _Pointer {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   <br>&gt;&gt;&gt; let _rawValue: Builtin.<br>&gt;&gt;&gt; RawPointer<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   <br>&gt;&gt;&gt; var hashValue: Int {...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   <br>&gt;&gt;&gt; init&lt;T&gt;(_ : UnsafePointer&lt;T&gt;<br>&gt;&gt;&gt; )<br>&gt;&gt;&gt;   <br>&gt;&gt;&gt; init&lt;T&gt;(_ : UnsafeMutablePointer&lt;T&gt;<br>&gt;&gt;&gt; )<br>&gt;&gt;&gt;   <br>&gt;&gt;&gt; init?&lt;T&gt;(_ : UnsafePointer&lt;T&gt;<br>&gt;&gt;&gt; ?)<br>&gt;&gt;&gt;   <br>&gt;&gt;&gt; init?&lt;T&gt;(_ : UnsafeMutablePointer&lt;T&gt;<br>&gt;&gt;&gt; ?)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   <br>&gt;&gt;&gt; init&lt;T&gt;(_ : OpaquePointer&lt;T&gt;<br>&gt;&gt;&gt; )<br>&gt;&gt;&gt;   <br>&gt;&gt;&gt; init?&lt;T&gt;(_ : OpaquePointer&lt;T&gt;<br>&gt;&gt;&gt; ?)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   <br>&gt;&gt;&gt; init?(bitPattern: Int<br>&gt;&gt;&gt; )<br>&gt;&gt;&gt;   <br>&gt;&gt;&gt; init?(bitPattern: UInt<br>&gt;&gt;&gt; )<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   <br>&gt;&gt;&gt; func load&lt;T&gt;(_ : T.Type) -&gt;<br>&gt;&gt;&gt;  T<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   <br>&gt;&gt;&gt; @warn_unused_result<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   <br>&gt;&gt;&gt; init(allocatingBytes size: Int, alignedTo: Int<br>&gt;&gt;&gt; )<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   <br>&gt;&gt;&gt; @warn_unused_result<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   <br>&gt;&gt;&gt; init&lt;T&gt;(allocatingCapacity count: Int, of: T.Type<br>&gt;&gt;&gt; )<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   <br>&gt;&gt;&gt; func deallocateBytes(_ size: Int, alignedTo: Int<br>&gt;&gt;&gt; )<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   <br>&gt;&gt;&gt; func deallocateCapacity&lt;T&gt;(_ num: Int, of: T.Type<br>&gt;&gt;&gt; )<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   <br>&gt;&gt;&gt; // Returns a pointer one byte after the initialized memory.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   <br>&gt;&gt;&gt; func initialize&lt;T&gt;(with newValue: T, count: Int = 1) -&gt;<br>&gt;&gt;&gt;  UnsafeBytePointer<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   <br>&gt;&gt;&gt; // Returns a pointer one byte after the initialized memory.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   <br>&gt;&gt;&gt; func initialize&lt;T&gt;(from: UnsafePointer&lt;T&gt;, count: Int) -&gt;<br>&gt;&gt;&gt;  UnsafeBytePointer<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   <br>&gt;&gt;&gt; func initializeBackward&lt;T&gt;(from source: UnsafePointer&lt;T&gt;, count: Int<br>&gt;&gt;&gt; )<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   <br>&gt;&gt;&gt; func deinitialize&lt;T&gt;(_ : T.Type, count: Int = 1<br>&gt;&gt;&gt; )<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Should we also have &#39;assign&#39; methods, matching &#39;initialize&#39;? Should &#39;deinitialize&#39; be called &#39;destroy&#39;, matching &#39;UnsafeMutablePointer&#39;s API?<br>&gt; <br>&gt; I was wondering if anyone would ask for ‘assign’. It presumes that you are storing the same type of object that was previously stored in your buffer. I didn’t want to proactively support that case because it’s a convenience and not really consistent with the pointer being type punned. You can always call deinitialize() first if you need to before calling ‘initialize&#39;.<br></p><p>I see. I guess it makes sense that, once you&#39;ve initialized as the new type, you can cast to UMP and type-safe-ly reassign via that interface.<br></p><p>&gt;  I  used ‘deinitialize’ to be consistent with UnsafeMutablePointer.<br></p><p>My mistake, I hadn&#39;t noticed that &#39;destroy&#39; was renamed there too.<br></p><p>-Joe<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[RFC] UnsafeBytePointer API for In-Memory Layout</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>May 12, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; Future improvements<br>&gt; <br>&gt; UnsafeBytePointer should eventually support unaligned memory access. I believe that we will eventually have a modifier that allows &quot;packed&quot; struct members. At that time we may also want to add a &quot;packed&quot; flag to UnsafeBytePointer&#39;s load and initialize methods.<br></p><p>We should probably call out the fact that `load` and `initialize` require alignment in the meantime.<br></p><p>&gt; When accessing a memory buffer, it is generally convenient to cast to a type with known layout and compute offsets relative to the type&#39;s size. This is how UnsafePointer&lt;Pointee&gt; works. A generic UnsafeTypePunnedPointer&lt;Pointee&gt; could be introduced with the same interface as UnsafePointer&lt;Pointer&gt;, but without the strict aliasing requirements. This seems like an overdesign simply to avoid calling strideof() in an rare use case, but nothing prevents adding this type later.<br></p><p>This need could also be addressed with some additional convenience methods on UnsafeBytePointer to load or store at a given index, something like:<br></p><p>	func load&lt;T&gt;(asArrayOf type: T.Type, at index: Int) -&gt; T {<br>		return (self + strideof(T) * index).load(T)<br>	}<br>	func initialize(asArrayOf type: T.Type, initialValue: T, at index: Int) {<br>		return (self + strideof(T) * index).initialize(initialValue)<br>	}<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[RFC] UnsafeBytePointer API for In-Memory Layout</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>May 12, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On May 12, 2016, at 8:41 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; Future improvements<br>&gt;&gt; <br>&gt;&gt; UnsafeBytePointer should eventually support unaligned memory access. I believe that we will eventually have a modifier that allows &quot;packed&quot; struct members. At that time we may also want to add a &quot;packed&quot; flag to UnsafeBytePointer&#39;s load and initialize methods.<br>&gt; <br>&gt; We should probably call out the fact that `load` and `initialize` require alignment in the meantime.<br></p><p>Will do.<br></p><p>&gt;&gt; When accessing a memory buffer, it is generally convenient to cast to a type with known layout and compute offsets relative to the type&#39;s size. This is how UnsafePointer&lt;Pointee&gt; works. A generic UnsafeTypePunnedPointer&lt;Pointee&gt; could be introduced with the same interface as UnsafePointer&lt;Pointer&gt;, but without the strict aliasing requirements. This seems like an overdesign simply to avoid calling strideof() in an rare use case, but nothing prevents adding this type later.<br>&gt; <br>&gt; This need could also be addressed with some additional convenience methods on UnsafeBytePointer to load or store at a given index, something like:<br>&gt; <br>&gt; 	func load&lt;T&gt;(asArrayOf type: T.Type, at index: Int) -&gt; T {<br>&gt; 		return (self + strideof(T) * index).load(T)<br>&gt; 	}<br>&gt; 	func initialize(asArrayOf type: T.Type, initialValue: T, at index: Int) {<br>&gt; 		return (self + strideof(T) * index).initialize(initialValue)<br>&gt; 	}<br></p><p>Yep. I like that.<br></p><p>-Andy<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[RFC] UnsafeBytePointer API for In-Memory Layout</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>May 12, 2016 at 06:00:00pm</p></header><div class="content"><p>Responding to this on the swift-evolution thread...<br>https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsafebytepointer.md &lt;https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsafebytepointer.md&gt;<br></p><p>&gt; On May 12, 2016, at 9:27 AM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; Some concerns with UnsafeBytePointer:<br>&gt; <br>&gt; - I was concerned about having a store() to go with load(). It’s just deinitialize + initialize with a count of 1, but that’s easily the common case when you do need to write to something. That said, I’m not sure which people are more likely to mess up: using initialize and forgetting to deinitialize before, or using store when there wasn’t anything there before.<br></p><p>store() is definitely a common case, but it is subtly broken if the user doesn&#39;t realize that the overwritten value must be exactly the same type. The problem is that this API is advertised as supporting type punning. The only way to make it safe as advertised is to force users to deinitialize&lt;T&gt;() + initialize&lt;U&gt;. I think this needs to be clearly explained in the API comments.<br></p><p>+  ///<br>+  /// - Note: The converse of loading a value, storing a value `T` into<br>+  /// initialized memory requires the user to know the previously initialized<br>+  /// value&#39;s type. Full &#39;store&#39; semantics can be achieved with:<br>+  /// `deinitialize(PreviousType)`<br>+  /// `initialize(NewType, with: value)`<br>+  /// If the previosly initialized type cannot reference any managed objects,<br>+  /// then the `deinitialize` call can be skipped.<br>   public func load&lt;T&gt;(_ : T.Type) -&gt; T {<br></p><p>&gt; - I am concerned about eliminating the distinction between mutable and immutable memory. That is, I think we’ll want the Mutable variant to be a separate type.<br></p><p>Yes. I haven&#39;t gotten feedback yet on that, or on importing &#39;void*&#39; as UnsafeBytePointer. If the feeling on both is positive, then I think it&#39;s worth ammending my proposal at this point to include UnsafeMutableBytePointer.<br></p><p>&gt; - Is there a good way to do a mass copy or move from an UnsafeBytePointer?<br></p><p>I didn’t add ‘move’ from UnsafeBytePointer for the same reason that I didn’t add ‘store’.<br></p><p>I could add the following functions to Unsafe[Mutable]Pointer though for completeness:<br></p><p>- initialize(from: UnsafeBytePointer, count)<br>- assign(from: UnsafeBytePointer, count)<br></p><p>I could also add a mass move from UnsafePointer *to* UnsafeBytePointer.<br></p><p>  func moveInitializeFrom&lt;T&gt;(_ source: UnsafePointer&lt;T&gt;, count: Int) {<br>  func moveInitializeBackwardFrom&lt;T&gt;(_ source: UnsafePointer&lt;T&gt;, count: Int) {<br></p><p>-Andy<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160512/8677e065/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[RFC] UnsafeBytePointer API for In-Memory Layout</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>May 19, 2016 at 12:00:00am</p></header><div class="content"><p>Hello Swift evolution,<br></p><p>I&#39;m sending this proposal out again for another round of RFC. The first round did not get much specific feedback, and nothing has fundamentally changed. In this updated version I beefed up the explanation a bit and clarified the language.<br></p><p>-Andy<br></p><p>&gt; On May 9, 2016, at 11:14 AM, Andrew Trick via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift evolution,<br>&gt; <br>&gt; I sent this to swift-dev last week. Sorry to post on two lists!<br>&gt; <br>&gt; Swift does a great job of protecting against undefined behavior--as long as you avoid &quot;unsafe&quot; APIs, that is. However, unsafe APIs are important for giving developers control over implementation details and performance. Naturally, the contract between unsafe APIs and the optimizer is crucial. When a developer uses an unsafe API, the rules governing safe, well-defined behavior must be clear. On the opposite end, the optimizer must know which assumptions it can make based on those rules. Simply saying that anything goes because &quot;unsafe&quot; is in the name is not helpful to this effort.<br>&gt; <br>&gt; For a long time, I&#39;ve wanted these rules nailed down. We have more users taking advantage of advanced features, and more optimizations that take advantage of assumptions guided by the type system. This seems like a particularly good time to resolve UnsafePointer semantics, considering the type system and UnsafePointer work that&#39;s been going on recently. Strict aliasing is something I would like addressed. If we do nothing here, then we will end up by default inheriting C/C++ semantics, as with any language that relies on a C/C++ backend. In other words, developers will be forced to write code with technically undefined behavior and rely on the compiler to be smart enough to recognize and recover from common patterns. Or we can take advantage of this opportunity and instead adopt a sound memory model with respect to aliasing.<br>&gt; <br>&gt; This proposal is only an RFC at this point. I&#39;m sending it out now to allow for plenty of time for discussion (or advance warning). Keep in mind that it could change considerably before it goes up for review.<br>&gt; <br>&gt; -Andy<br>&gt; <br></p><p>UnsafeBytePointer API for In-Memory Layout<br></p><p>Proposal: SE-NNNN &lt;https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsafebytepointer.md&gt;<br>Author(s): Andrew Trick &lt;https://github.com/atrick&gt;<br>Status: Awaiting review &lt;https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsafebytepointer.md#rationale&gt;<br>Review manager: TBD<br> &lt;https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsafebytepointer.md#introduction&gt;Introduction<br></p><p>UnsafePointer and UnsafeMutable refer to a typed region of memory, and the compiler must be able to assume that UnsafePointer element (Pointee) type is consistent with other access to the same memory. See proposed Type Safe Memory Access documentation &lt;https://github.com/atrick/swift/blob/type-safe-mem-docs/docs/TypeSafeMemory.rst&gt;. Consequently, conversion between UnsafePointer element types exposes an easy way to abuse the type system.<br></p><p>In the following example, takesUIntPtr accesses a memory location as a UInt, which is incompatible with the declared type of the pointer passed to takesIntPtr, yet the statement that performs the pointer conversion provides no indication that type punning may be taking place:<br></p><p>func takesUIntPtr(_ p: UnsafeMutablePointer&lt;UInt&gt;) -&gt; UInt {<br>  return p[0]<br>}<br>func takesIntPtr(q: UnsafeMutablePointer&lt;Int&gt;) -&gt; UInt {<br>  return takesUIntPtr(UnsafeMutablePointer(q))<br>}<br>If this pointer conversion was accidental, then it is likely a serious bug. Type punning via UnsafePointer is semantically undefined behavior and de facto undefined behavior given the optimizer&#39;s long-time treatment of UnsafePointer.<br></p><p>If the user&#39;s intention is to perform type punning, then UnsafePointer is the wrong API. Swift does not currently provide an API that permits safe, legal, type punning.<br></p><p>Swift-evolution thread: [RFC] UnsafeBytePointer API for In-Memory Layout &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160509/thread.html#16909&gt;<br>In this document, all mentions of UnsafePointer also apply to UnsafeMutablePointer.<br></p><p> &lt;https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsafebytepointer.md#motivation&gt;Motivation<br></p><p>Type punning is not a normal use case for UnsafePointer and will likely lead to undefined behavior. To avoid accidental type punning, we should prohibit inferred conversion between UnsafePointer&lt;T&gt; and UnsafePointer&lt;U&gt; unless the target of the conversion is an untyped or nondereferenceable pointer (currently represented as UnsafePointer&lt;Void&gt;). An &quot;inferred conversion&quot; is one in which a generic type is initialized via type inferrence without the need to spell the destination type:<br></p><p>struct S {<br>  let ptr : UnsafePointer&lt;T&gt;<br>}<br></p><p>let p = UnsafePointer&lt;U&gt;(...)<br>S(ptr: UnsafePointer(p))<br>To support this change we should introduce a new pointer type that does not bind the type of its Pointee. Such a new pointer type would allow inferred and implicit conversion from typed to untyped pointers, which is the common, safe use case for UnsafePointer conversion. More importantly it would provide an ideal foundation for an API that allows byte-wise pointer arithmetic and a legal, well-defined means to access an untyped region of memory (safe type punning). No alternative currently exists for manual memory layout and direct access to untyped memory. Not only is this a legitimate use case that Swift should support, but the lack a proper API has already lead to dangerous overuse of UnsafePointer.<br></p><p>As motivation for such an API, consider that an UnsafePointer&lt;Void&gt; or OpaquePointer may be currently be obtained from an external API. However, the developer may know the memory layout and may want to read or write elements whose types are compatible with that layout. This a reasonable use case, but unless the developer can guarantee that all accesses to the same memory location have the same type, then they cannot use UnsafePointer to access the memory without risking undefined behavior.<br></p><p>An example based on the proposed new UnsafeBytePointer API is included below.<br></p><p> &lt;https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsafebytepointer.md#proposed-solution&gt;Proposed solution<br></p><p>This proposal introduces UnsafeBytePointer and UnsafeMutableBytePointer types, along with an API for obtaining an UnsafeMutableBytePointer value at a relative byte offset and loading and storing arbitrary types at that location.<br></p><p>UnsafePointer&lt;T&gt; to UnsafeBytePointer conversion will be allowed via an unlabeled initializer and in some cases may be implicit. However, inferred UnsafePointer&lt;T&gt; conversion will now be statically prohibited. Converting arbitrary UnsafePointer&lt;T&gt; types will instead require a labeled initializer that accepts the destination type:<br></p><p>struct S {<br>  let ptr : UnsafePointer&lt;T&gt;<br>}<br></p><p>let p = UnsafePointer&lt;U&gt;(...)<br>S(ptr: UnsafePointer(p, to: T))<br>Just as with unsafeBitCast, although the destination of the cast can usually be inferred, we want the developer to explicitly state the intended destination type, both because type inferrence can be surprising, and because it&#39;s important to the reader for code comprehension.<br></p><p>While the new UnsafeBytePointer type supports the removal of dangerous UnsafePointer conversion, it&#39;s API also meets multiple requirements:<br></p><p>An untyped pointer to memory<br>Type-unsafe access to memory (legal type punning)<br>Pointer arithmetic within byte-addressable memory<br>UnsafeMutableBytePointer will replace UnsafeMutablePointer&lt;Void&gt; and UnsafeBytePointer will replace UnsafePointer&lt;Void&gt; as the standard representations for untyped memory. The Swift imported type for void* and const void* will be UnsafeMutableBytePointer and UnsafeBytePointer respectively.<br></p><p>Note: For API clarity we could consider a typealias for VoidPointer. A separate VoidPointer type would not be very useful--there&#39;s no danger that UnsafeBytePointer will be casually dereferenced, and no danger in allowing pointer arithmetic since the only reasonable interpretation is that of a byte-addressable memory.<br></p><p>Loading from and storing to memory via an Unsafe[Mutable]BytePointer is safe independent of the type of value being loaded or stored and independent of the memory&#39;s allocated type as long as layout guarantees are met (per the ABI). This allows legal type punning within Swift and allows Swift code to access a common region of memory that may be shared across an external interface that does not provide type safety guarantees. Accessing type punned memory directly through a designated Unsafe[Mutable]BytePointer type provides sound basis for compiler implementation of strict aliasing. This is in contrast with the approach of simply providing a special unsafe pointer cast operation for bypassing type safety, which cannot be reliably implemented.<br></p><p>Providing an API for type-unsafe memory access would not serve much purpose without the ability to compute byte offsets. Of course, we could require users to convert back and forth using bitPatterns, but that would be awkward and only obscure the purpose of the UnsafeBytePointer type.<br></p><p> &lt;https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsafebytepointer.md#detailed-design&gt;Detailed design<br></p><p>The public API is shown here. For details, see the unsafeptr_convert branch &lt;https://github.com/atrick/swift/commits/unsafeptr_convert&gt;.<br></p><p>struct UnsafeMutableBytePointer : Hashable, _Pointer {<br></p><p>  let _rawValue: Builtin.RawPointer<br></p><p>  var hashValue: Int {...}<br></p><p>  init&lt;T&gt;(_ : UnsafePointer&lt;T&gt;)<br>  init&lt;T&gt;(_ : UnsafeMutablePointer&lt;T&gt;)<br>  init?&lt;T&gt;(_ : UnsafePointer&lt;T&gt;?)<br>  init?&lt;T&gt;(_ : UnsafeMutablePointer&lt;T&gt;?)<br></p><p>  init&lt;T&gt;(_ : OpaquePointer&lt;T&gt;)<br>  init?&lt;T&gt;(_ : OpaquePointer&lt;T&gt;?)<br></p><p>  init?(bitPattern: Int)<br>  init?(bitPattern: UInt)<br></p><p>  /// Load a single `T` value from memory.<br>  ///<br>  /// - Precondition: The underlying pointer is properly aligned for<br>  ///                 accessing `T`.<br>  ///<br>  /// - Note: The converse of loading a value, storing a value `T` into<br>  /// initialized memory requires the user to know the previously initialized<br>  /// value&#39;s type. Full &#39;store&#39; semantics can be achieved with:<br>  /// `deinitialize(PreviousType)`<br>  /// `initialize(NewType, with: value)`<br>  /// If the previosly initialized type cannot reference any managed objects,<br>  /// then the `deinitialize` call can be skipped.<br>  func load&lt;T&gt;(_ : T.Type) -&gt; T<br></p><p>  /// Load a `T` value at the specified `index` from `self` as if it<br>  /// contains at least `index` + 1 contiguous values of type `T`.<br>  ///<br>  /// - Precondition: The underlying pointer is properly aligned for<br>  ///                 accessing `T`.<br>  func load&lt;T&gt;(asArrayOf _: T.Type, at index: Int) -&gt; T<br></p><p>  /// Initialize this memory location with `count` consecutive copies<br>  /// of `newValue`<br>  ///<br>  /// Returns a `UnsafeBytePointer` to memory one byte past the last<br>  /// initialized value.<br>  ///<br>  /// - Precondition: The memory is not initialized.<br>  ///<br>  /// - Precondition: The underlying pointer is properly aligned for<br>  ///                 accessing `T`.<br>  ///<br>  /// - Precondition: `count` is non-negative.<br>  ///<br>  /// - Postcondition: The memory is initialized; the value should eventually<br>  ///   be destroyed or moved from to avoid leaks.<br>  func initialize&lt;T&gt;(_: T.Type, with newValue: T, count: Int = 1)<br>    -&gt; UnsafeBytePointer<br></p><p>  /// Initialize the memory location at `index` with `newValue` as if `self`<br>  /// holds at least `index` + 1 contiguous values of type `T`.<br>  ///<br>  /// Returns a `UnsafeBytePointer` to memory one byte past the<br>  /// initialized value.<br>  ///<br>  /// - Precondition: The memory at `index` is not initialized.<br>  ///<br>  /// - Precondition: The underlying pointer is properly aligned for<br>  ///                 accessing `T`.<br>  ///<br>  /// - Postcondition: The memory is initialized; the value should eventually<br>  ///   be destroyed or moved from to avoid leaks.<br>  func initialize&lt;T&gt;(asArrayOf _: T.Type, initialValue: T, at index: Int)<br>    -&gt; UnsafeBytePointer<br></p><p>  /// De-initialize the `count` `T`s starting at `self`, returning<br>  /// their memory to an uninitialized state.<br>  ///<br>  /// - Precondition: The `T`s at `self..&lt;self + count` are initialized.<br>  ///<br>  /// - Postcondition: The memory is uninitialized.<br>  func deinitialize&lt;T&gt;(_ : T.Type, count: Int = 1)<br></p><p>  /// De-initialize `T` at the memory location `index` as if `self` holds at<br>  /// least `index` + 1 contiguous values of type `T`, returning<br>  /// the memory to an uninitialized state.<br>  ///<br>  /// - Precondition: The `T` value at `index` is initialized.<br>  ///<br>  /// - Postcondition: The memory at `index` is uninitialized.<br>  func deinitialize&lt;T&gt;(asArrayOf _: T.Type, at index: Int)<br></p><p>  /// Allocate and point at uninitialized memory for `size` bytes with<br>  /// `alignedTo` alignment.<br>  ///<br>  /// - Postcondition: The memory is allocated, but not initialized.<br>  @warn_unused_result<br>  init(allocatingBytes size: Int, alignedTo: Int)<br></p><p>  /// Allocate and point at uninitialized memory for `count` values of `T`.<br>  ///<br>  /// - Postcondition: The memory is allocated, but not initialized.<br>  @warn_unused_result<br>  init&lt;T&gt;(allocatingCapacity count: Int, of: T.Type)<br></p><p>  /// Deallocate uninitialized memory allocated for `size` bytes with<br>  /// `alignedTo` alignment.<br>  ///<br>  /// - Precondition: The memory is not initialized.<br>  ///<br>  /// - Postcondition: The memory has been deallocated.<br>  func deallocateBytes(_ size: Int, alignedTo: Int)<br></p><p>  /// Deallocate uninitialized memory allocated for `count` values of `T`.<br>  ///<br>  /// - Precondition: The memory is not initialized.<br>  ///<br>  /// - Postcondition: The memory has been deallocated.<br>  func deallocateCapacity&lt;T&gt;(_ num: Int, of: T.Type)<br></p><p>  /// Omitting comments for the following convenient variations on<br>  /// intitialize...<br></p><p>  func initialize&lt;T&gt;(from: UnsafePointer&lt;T&gt;, count: Int) -&gt; UnsafeBytePointer<br></p><p>  func initializeBackward&lt;T&gt;(from source: UnsafePointer&lt;T&gt;, count: Int)<br></p><p>  func moveInitialize&lt;T&gt;(from source: UnsafeMutablePointer&lt;T&gt;, count: Int) {<br></p><p>  func moveInitializeBackward&lt;T&gt;(from source: UnsafeMutablePointer&lt;T&gt;,<br>    count: Int)<br>}<br></p><p>extension OpaquePointer {<br>  init(_ : UnsafeBytePointer)<br>}<br></p><p>extension Int {<br>  init(bitPattern: UnsafeBytePointer)<br>}<br></p><p>extension UInt {<br>  init(bitPattern: UnsafeBytePointer)<br>}<br></p><p>extension UnsafeBytePointer : Strideable {<br>  func distance(to : UnsafeBytePointer) -&gt; Int<br>  func advanced(by : Int) -&gt; UnsafeBytePointer<br>}<br></p><p>func == (lhs: UnsafeBytePointer, rhs: UnsafeBytePointer) -&gt; Bool<br></p><p>func &lt; (lhs: UnsafeBytePointer, rhs: UnsafeBytePointer) -&gt; Bool<br></p><p>func + (lhs: Int, rhs: UnsafeBytePointer) -&gt; UnsafeBytePointer<br></p><p>func - (lhs: UnsafeBytePointer, rhs: UnsafeBytePointer) -&gt; Int<br>UnsafeBytePointer provides the same interface as UnsafeMutablePointer except for store, variations on initialize, and deinitialize.<br></p><p>Occasionally, we need to convert from a UnsafeBytePointer to an UnsafePointer. This should only be done in very rare circumstances when the author understands the compiler&#39;s strict type rules for UnsafePointer. Although this could be done by casting through an OpaquePointer, an explicit, designated unsafe pointer cast API would makes the risks more obvious and self-documenting. For example:<br></p><p>extension UnsafePointer {<br>  init(_ from: UnsafeBytePointer, to: Pointee.type)<br>}<br>extension UnsafeMutablePointer {<br>  init(_ from: UnsafeBytePointer, to: Pointee.type)<br>}<br>Similarly, conversion between UnsafePointer types must now be spelled with an explicitly Pointee type:<br></p><p>extension UnsafePointer {<br>  init&lt;U&gt;(_ from: UnsafePointer&lt;U&gt;, to: Pointee.Type)<br>  init&lt;U&gt;(_ from: UnsafeMutablePointer&lt;U&gt;, to: Pointee.Type)<br>}<br>extension UnsafeMutablePointer {<br>  init&lt;U&gt;(_ from: UnsafeMutablePointer&lt;U&gt;, to: Pointee.Type)<br>}<br>Some existing conversions between UnsafePointer types do not convert Pointee types but instead coerce an UnsafePointer to an UnsafeMutablePointer. This is no longer an inferred conversion, but must be explicitly requested:<br></p><p>extension UnsafeMutablePointer {<br>  init(mutating from: UnsafePointer&lt;Pointee&gt;)<br>}<br> &lt;https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsafebytepointer.md#impact-on-existing-code&gt;Impact on existing code<br></p><p>The largest impact of this change is that void* and const void* are imported as UnsafeMutableBytePointer and UnsafeBytePointer. This impacts many public APIs, but with implicit argument conversion should not affect typical uses of those APIs.<br></p><p>Any Swift projects that rely on type inference to convert between UnsafePointer types will need to take action. The developer needs to determine whether type punning is necessary. If so, they must migrate to the UnsafeBytePointer API. Otherwise, they can work around the new restriction by using a to: Pointee, or mutating label.<br></p><p>Disallowing inferred UnsafePointer direct conversion requires some standard library code to use an explicit to: Pointee label for unsafe conversions that may violate strict aliasing.<br></p><p>All occurrences of Unsafe[Mutable]Pointer&lt;Void&gt; in the standard library are converted to UnsafeBytePointer. e.g. unsafeAddress() now returns UnsafeBytePointer, not UnsafePointer&lt;Void&gt;.<br></p><p>Some occurrences of Unsafe[Mutable]Pointer&lt;Pointee&gt; in the standard library are replaced with UnsafeBytePointer, either because the code was playing too loosely with strict aliasing rules, or because the code actually wanted to perform pointer arithmetic on byte-addresses.<br></p><p>StringCore.baseAddress changes from OpaquePointer to UnsafeBytePointer because it is computing byte offsets and accessing the memory. OpaquePointer is meant for bridging, but should be truly opaque; that is, nondereferenceable and not involved in address computation.<br></p><p>The StringCore implementation does a considerable amount of casting between different views of the String storage. The current implementation already demonstrates some awareness of strict aliasing rules. The rules are generally followed by ensuring that the StringBuffer only be accessed using the appropriate CodeUnit within Swift code. For interoperability and optimization, String buffers frequently need to be cast to and from CChar. This is valid as long access to the buffer from Swift is guarded by dynamic checks of the encoding type. These unsafe, but dynamically legal conversion points will now be labeled with to: Pointee.<br></p><p>CoreAudio utilities now use an UnsafeBytePointer.<br></p><p> &lt;https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsafebytepointer.md#implementation-status&gt;Implementation status<br></p><p>On my unsafeptr_convert branch &lt;https://github.com/atrick/swift/commits/unsafeptr_convert&gt;, I&#39;ve made most of the necessary changes to support the addition of UnsafeBytePointerand the removal of inferred UnsafePointer conversion.<br></p><p>There are a several things going on here in order to make it possible to build the standard library with the changes:<br></p><p>A new UnsafeBytePointer type is defined.<br></p><p>The type system imports void* as UnsafeBytePointer.<br></p><p>The type system handles implicit conversions to UnsafeBytePointer.<br></p><p>UnsafeBytePointer replaces both UnsafePointer&lt;Void&gt; and UnsafeMutablePointer&lt;Void&gt; (Recent feedback suggestes that UnsafeMutablePointer should also be introduced).<br></p><p>The standard library was relying on inferred UnsafePointer conversion in over 100 places. Most of these conversions now either take an explicit label, such as to: Pointee, mutating. Some have been rewritten.<br></p><p>Several places in the standard library that were playing loosely with strict aliasing or doing bytewise pointer arithmetic now use UnsafeBytePointer instead.<br></p><p>Explicit labeled Unsafe[Mutable]Pointer initializers are added.<br></p><p>The inferred Unsafe[Mutable]Pointer conversion is removed.<br></p><p>TODO:<br></p><p>Once this proposal is accepted, and the rules for casting between pointers types have been decided, we need to finish implementing the type system support. The current implementation (intentionally) breaks a few tests in pointer_conversion.swift. We also need to ensure that interoperability requirements are met. Currently, many argument casts to be explicitly labeled. The current implementation also makes it easy for users to hit an &quot;ambiguous use of &#39;init&#39;&quot; error when relying on implicit argument conversion.<br></p><p>Additionally:<br></p><p>UnsafeMutableBytePointer needs to be introduced, and we need to distinguish between void* and const void*import types.<br></p><p>A name mangled abbreviation needs to be created for UnsafeBytePointer.<br></p><p>The StringAPI tests should probably be rewritten with UnsafeBytePointer.<br></p><p>The NSStringAPI utilities and tests may need to be ported to UnsafeBytePointer<br></p><p>The CoreAudio utilities and tests may need to be ported to UnsafeBytePointer.<br></p><p> &lt;https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsafebytepointer.md#alternatives-considered&gt;Alternatives considered<br></p><p> &lt;https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsafebytepointer.md#existing-workaround&gt;Existing workaround<br></p><p>In some cases, developers can safely reinterpret values to achieve the same effect as type punning:<br></p><p>let ptrI32 = UnsafeMutablePointer&lt;Int32&gt;(allocatingCapacity: 1)<br>ptrI32[0] = Int32()<br>let u = unsafeBitCast(ptrI32[0], to: UInt32.self)<br>Note that all access to the underlying memory is performed with the same element type. This is perfectly legitimate, but simply isn&#39;t a complete solution. It also does not eliminate the inherent danger in declaring a typed pointer and expecting it to point to values of a different type.<br></p><p> &lt;https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsafebytepointer.md#discarded-alternatives&gt;Discarded alternatives<br></p><p>We considered adding a typePunnedMemory property to the existing Unsafe[Mutabale]Pointer API. This would provide a legal way to access a potentially type punned Unsafe[Mutabale]Pointer. However, it would certainly cause confusion without doing much to reduce likelihood of programmer error. Furthermore, there are no good use cases for such a property evident in the standard library.<br></p><p>The opaque _RawByte struct is a technique that allows for byte-addressable buffers while hiding the dangerous side effects of type punning (a _RawByte could be loaded but it&#39;s value cannot be directly inspected). UnsafePointer&lt;_RawByte&gt; is a clever alternative to UnsafeBytePointer. However, it doesn&#39;t do enough to prevent undefined behavior. The loaded _RawByte would naturally be accessed via unsafeBitCast, which would mislead the author into thinking that they have legally bypassed the type system. In actuality, this API blatantly violates strict aliasing. It theoretically results in undefined behavior as it stands, and may actually exhibit undefined behavior if the user recovers the loaded value.<br></p><p>To solve the safety problem with UnsafePointer&lt;_RawByte&gt;, the compiler could associate special semantics with a UnsafePointer bound to this concrete generic parameter type. Statically enforcing casting rules would be difficult if not impossible without new language features. It would also be impossible to distinguish between typed and untyped pointer APIs. For example, UnsafePointer&lt;T&gt;.load&lt;U&gt; would be a nonsensical vestige.<br></p><p> &lt;https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsafebytepointer.md#alternate-proposal-for-void-type&gt;Alternate proposal for void* type<br></p><p>Changing the imported type for void* will be somewhat disruptive. Furthermore, this proposal currently drops the distinction between void* and const void*--an obvious loss of API information.<br></p><p>We could continue to import void* as UnsafeMutablePointer&lt;Void&gt; and const void* as UnsafePointer&lt;Void&gt;, which will continue to serve as an &quot;opaque&quot; untyped pointer. Converting to UnsafeBytePointer would be necesarry to perform pointer arithmetic or to conservatively handle possible type punning.<br></p><p>This alternative is much less disruptive, but we are left with two forms of untyped pointer, one of which (UnsafePointer) the type system somewhat conflates with typed pointers.<br></p><p>Given the current restrictions of the language, it&#39;s not clear how to statically enforce the necessary rules for castingUnsafePointer&lt;Void&gt; once general UnsafePointer&lt;T&gt; conversions are disallowed. The following conversions should be inferred, and implied for function arguments (ignoring mutability):<br></p><p>UnsafePointer&lt;T&gt; to UnsafePointer&lt;Void&gt;<br></p><p>UnsafePointer&lt;Void&gt; to UnsafeBytePointer<br></p><p>I did not implement this simpler design because my primary goal was to enforce legal pointer conversion and rid Swift code of undefined behavior. I can&#39;t do that while allowing UnsafePointer conversions.<br></p><p> &lt;https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsafebytepointer.md#future-improvements&gt;Future improvements<br></p><p>UnsafeBytePointer should eventually support unaligned memory access. I believe that we will eventually have a modifier that allows &quot;packed&quot; struct members. At that time we may also want to add a &quot;packed&quot; flag to UnsafeBytePointer&#39;s load and initialize methods.<br></p><p> &lt;https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsafebytepointer.md#unsafebytepointer-example&gt;UnsafeBytePointer example<br></p><p>/// An example of using UnsafeMutableBytePointer to implement manual memory<br>/// layout.<br></p><p>/// A Buffer for reading and writing basic types at a fixed address.<br>/// Indirection allows the buffer to refer to mutable state elsewhere.<br>struct MessageBuffer {<br>  let ptr: UnsafeMutableBytePointer<br></p><p>  enum IndirectFlag { case Direct, Indirect }<br></p><p>  private func getPointer(atOffset n: Int, _ isIndirect: IndirectFlag)<br>  -&gt; UnsafeMutableBytePointer {<br>    switch isIndirect {<br>    case .Indirect:<br>      return (ptr + n).load(UnsafeMutableBytePointer.self)<br>    case .Direct:<br>      return ptr + n<br>    }<br>  }<br></p><p>  func readUInt32(atOffset n: Int, _ isIndirect: IndirectFlag) -&gt; UInt32 {<br>    return getPointer(atOffset: n, isIndirect).load(UInt32.self)<br>  }<br>  func readFloat32(atOffset n: Int, _ isIndirect: IndirectFlag) -&gt; Float32 {<br>    return getPointer(atOffset: n, isIndirect).load(Float32.self)<br>  }<br></p><p>  func writeUInt32(_ val: UInt32, atOffset n: Int) {<br>    getPointer(atOffset: n, .Direct).initialize(with: val)<br>  }<br>  func writeFloat32(_ val: Float32, atOffset n: Int) {<br>    getPointer(atOffset: n, .Direct).initialize(with: val)<br>  }<br>  func writeIndirect(_ ptr: UnsafeMutableBytePointer, atOffset n: Int) {<br>    getPointer(atOffset: n, .Direct).initialize(with: ptr)<br>  }<br>}<br></p><p>/// Encoded message format.<br>struct MessageFormat : Sequence, IteratorProtocol {<br>  typealias Element = MessageFormat<br></p><p>  private static let maxFormatFields = 32 / 4<br>  static let maxBufferBytes = maxFormatFields * strideof(UInt)<br></p><p>  var formatCode: UInt32 = 0<br>  var elementCode: UInt32 = 0<br>  var offset: Int = 0<br></p><p>  init(bitPattern: UInt32) {<br>    formatCode = bitPattern<br>  }<br></p><p>  enum Kind {<br>    case None, Reserved, UInt32, Float32, IndirectUInt32, IndirectFloat32<br>  }<br></p><p>  /// The first field&#39;s kind.<br>  var kind : Kind {<br>    get {<br>      switch elementCode {<br>      case 0x0: return Kind.None<br>      case 0x2: return Kind.UInt32<br>      case 0x3: return Kind.Float32<br>      case 0x6: return Kind.IndirectUInt32<br>      case 0x7: return Kind.IndirectFloat32<br>      default:  return Kind.Reserved<br>      }<br>    }<br>  }<br></p><p>  func elementStride() -&gt; Int {<br>    return (elementCode &amp; 0x4) != 0 ? strideof(UInt) : 4<br>  }<br></p><p>  /// Get the format for the next element.<br>  mutating func next() -&gt; Element? {<br>    if elementCode != 0 {<br>      offset += elementStride()<br>    }<br>    elementCode = formatCode &amp; 0xF<br>    formatCode &gt;&gt;= 4<br>    if kind == .None {<br>      return nil<br>    }<br>    // align to the next element size<br>    let offsetMask = elementStride() - 1<br>    offset = (offset + offsetMask) &amp; ~offsetMask<br>    return self<br>  }<br>}<br></p><p>func createBuffer() -&gt; MessageBuffer {<br>  return MessageBuffer(ptr: UnsafeMutableBytePointer(<br>      allocatingBytes: MessageFormat.maxBufferBytes, alignedTo: strideof(UInt)))<br>}<br></p><p>func destroy(buffer: MessageBuffer) {<br>  buffer.ptr.deallocateBytes(MessageFormat.maxBufferBytes,<br>    alignedTo: strideof(UInt))<br>}<br></p><p>var sharedInt: UInt32 = 42<br>var sharedFloat: Float32 = 16.25<br></p><p>func generateMessage(inBuffer mb: MessageBuffer) -&gt; MessageFormat {<br>  let mf = MessageFormat(bitPattern: 0x06727632)<br>  for field in mf {<br>    switch field.kind {<br>    case .UInt32:<br>      mb.writeUInt32(66, atOffset: field.offset)<br>    case .Float32:<br>      mb.writeFloat32(41.625, atOffset: field.offset)<br>    case .IndirectUInt32:<br>      mb.writeIndirect(&amp;sharedInt, atOffset: field.offset)<br>    case .IndirectFloat32:<br>      mb.writeIndirect(&amp;sharedFloat, atOffset: field.offset)<br>    case .None:<br>      fallthrough<br>    case .Reserved:<br>      return MessageFormat(bitPattern: 0)<br>    }<br>  }<br>  return mf<br>}<br></p><p>func handleMessage(buffer mb: MessageBuffer, format: MessageFormat) -&gt; Bool {<br>  for field in format {<br>    switch field.kind {<br>    case .UInt32:<br>      print(mb.readUInt32(atOffset: field.offset, .Direct))<br>    case .Float32:<br>      print(mb.readFloat32(atOffset: field.offset, .Direct))<br>    case .IndirectUInt32:<br>      print(mb.readUInt32(atOffset: field.offset, .Indirect))<br>    case .IndirectFloat32:<br>      print(mb.readFloat32(atOffset: field.offset, .Indirect))<br>    case .None:<br>      fallthrough<br>    case .Reserved:<br>      return false<br>    }<br>  }<br>  return true<br>}<br></p><p>func runProgram() {<br>  let mb = createBuffer()<br>  let mf = generateMessage(inBuffer: mb)<br>  if handleMessage(buffer: mb, format: mf) {<br>    print(&quot;Done&quot;)<br>  }<br>  destroy(buffer: mb)<br>}<br>runProgram()<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160519/ee7b1dff/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[RFC] UnsafeBytePointer API for In-Memory Layout</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 19, 2016 at 09:00:00pm</p></header><div class="content"><p>I think this is a good change with an admirable premise: that unsafety should not necessarily be a binary proposition - either avoid it completely, or use it and silently run into all sorts of potential UB pitfalls. (This is compounded by the problem that exactly what UB is is poorly understood - for example, how many engineers working with C assume that signed integer overflow must wrap? What happens when unsigned integers overflow?)<br></p><p>While it is not possible (or desirable) to protect developers from making any possible mistake, it would be great if Swift eventually reached a state where there were only a few straightforward ways to use the APIs to produce UB, and those few ways could be learned by developers wishing to work with the unsafe APIs.<br></p><p>Someone with more experience working with C APIs or raw memory will have to comment on the ergonomics of the change, and whether or not it introduces any unforeseen problems therein.<br></p><p>Austin<br></p><p>P.S. On an unrelated note, it might be better to host a proposal in a Gist or elsewhere; the first time I sent this message the mailing list software caused it to bounce. I suspect the same might have happened to other people&#39;s responses.<br></p><p>&gt; On May 19, 2016, at 12:08 AM, Andrew Trick via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift evolution,<br>&gt; <br>&gt; I&#39;m sending this proposal out again for another round of RFC. The first round did not get much specific feedback, and nothing has fundamentally changed. In this updated version I beefed up the explanation a bit and clarified the language.<br>&gt; <br>&gt; -Andy<br>&gt; <br>&gt;&gt; On May 9, 2016, at 11:14 AM, Andrew Trick via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello Swift evolution,<br>&gt;&gt; <br>&gt;&gt; I sent this to swift-dev last week. Sorry to post on two lists!<br>&gt;&gt; <br>&gt;&gt; Swift does a great job of protecting against undefined behavior--as long as you avoid &quot;unsafe&quot; APIs, that is. However, unsafe APIs are important for giving developers control over implementation details and performance. Naturally, the contract between unsafe APIs and the optimizer is crucial. When a developer uses an unsafe API, the rules governing safe, well-defined behavior must be clear. On the opposite end, the optimizer must know which assumptions it can make based on those rules. Simply saying that anything goes because &quot;unsafe&quot; is in the name is not helpful to this effort.<br>&gt;&gt; <br>&gt;&gt; For a long time, I&#39;ve wanted these rules nailed down. We have more users taking advantage of advanced features, and more optimizations that take advantage of assumptions guided by the type system. This seems like a particularly good time to resolve UnsafePointer semantics, considering the type system and UnsafePointer work that&#39;s been going on recently. Strict aliasing is something I would like addressed. If we do nothing here, then we will end up by default inheriting C/C++ semantics, as with any language that relies on a C/C++ backend. In other words, developers will be forced to write code with technically undefined behavior and rely on the compiler to be smart enough to recognize and recover from common patterns. Or we can take advantage of this opportunity and instead adopt a sound memory model with respect to aliasing.<br>&gt;&gt; <br>&gt;&gt; This proposal is only an RFC at this point. I&#39;m sending it out now to allow for plenty of time for discussion (or advance warning). Keep in mind that it could change considerably before it goes up for review.<br>&gt;&gt; <br>&gt;&gt; -Andy<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160519/f6d84eb7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[RFC] UnsafeBytePointer API for In-Memory Layout</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>May 19, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On May 19, 2016, at 9:46 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; P.S. On an unrelated note, it might be better to host a proposal in a Gist or elsewhere; the first time I sent this message the mailing list software caused it to bounce. I suspect the same might have happened to other people&#39;s responses.<br></p><p>I totally agree, and was only trying to follow convention. From now on I’ll attach the text and only provide a link that renders a page:<br></p><p>https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsafebytepointer.md &lt;https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsafebytepointer.md&gt;<br></p><p>-Andy<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160519/3513ce31/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[RFC] UnsafeBytePointer API for In-Memory Layout</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 19, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On May 19, 2016, at 12:08 AM, Andrew Trick via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift evolution,<br>&gt; <br>&gt; I&#39;m sending this proposal out again for another round of RFC. The first round did not get much specific feedback, and nothing has fundamentally changed. In this updated version I beefed up the explanation a bit and clarified the language.<br></p><p>Hi Andy,<br></p><p>I think this is a reasonable proposal.  It seems like the real win here is to be able to define TBAA rules for Unsafe[Mutable]Pointer references, instead of having to treat them *all* conservatively (something I’m generally supportive of).  A few questions/observations:<br></p><p>- It seems like the proposal should include a discussion about that, because that’s a pretty substantial change to the programming model.<br></p><p>- Does TBAA for these accesses actually produce better performance in practice on any existing known use cases?<br></p><p>- Would it be possible for tools like UBSAN to catch violations of this?  I’m not familiar with what ubsan does for C TBAA violations (if anything).<br></p><p>- It isn’t clear to me why it is important to change how &quot;void*” is imported.  Since you can’t deference an UnsafePointer&lt;Void&gt; anyway, why does it matter for this proposal?<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[RFC] UnsafeBytePointer API for In-Memory Layout</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>May 19, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On May 19, 2016, at 10:21 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 19, 2016, at 12:08 AM, Andrew Trick via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello Swift evolution,<br>&gt;&gt; <br>&gt;&gt; I&#39;m sending this proposal out again for another round of RFC. The first round did not get much specific feedback, and nothing has fundamentally changed. In this updated version I beefed up the explanation a bit and clarified the language.<br>&gt; <br>&gt; Hi Andy,<br>&gt; <br>&gt; I think this is a reasonable proposal.  It seems like the real win here is to be able to define TBAA rules for Unsafe[Mutable]Pointer references, instead of having to treat them *all* conservatively (something I’m generally supportive of).  A few questions/observations:<br>&gt; <br>&gt; - It seems like the proposal should include a discussion about that, because that’s a pretty substantial change to the programming model.<br></p><p>Right, although we don’t have a formal spec, I thought it was worthwhile to capture Swift’s notion of TBAA rules for the sake of discussion. This design document is based on today’s reality, not the proposed change:<br>https://github.com/atrick/swift/blob/type-safe-mem-docs/docs/TypeSafeMemory.rst &lt;https://github.com/atrick/swift/blob/type-safe-mem-docs/docs/TypeSafeMemory.rst&gt;<br>(and there’s an even lower-level SIL description)<br></p><p>&gt; - Does TBAA for these accesses actually produce better performance in practice on any existing known use cases?<br></p><p>Yes, but I’d have to rerun the numbers. Under the hood we do a lot of conversion to UnsafePointer. My feeling is that UnsafePointer is intended to be a tool for building low-level, high-performance data structures.<br></p><p>&gt; - Would it be possible for tools like UBSAN to catch violations of this?  I’m not familiar with what ubsan does for C TBAA violations (if anything).<br></p><p>Yes, we definitely want to be able to feed TBAA information to a sanitizer. That’s a big part of my argument for clarifying the rules for safe/unsafe operation. But I think it’s quite different from the things that UBSAN checks now. <br></p><p>&gt; - It isn’t clear to me why it is important to change how &quot;void*” is imported.  Since you can’t deference an UnsafePointer&lt;Void&gt; anyway, why does it matter for this proposal?<br></p><p>Briefly, it’s not essential for the TBAA story. That has to do with allowing safe casts to be inferred and implicit, while type-unsafe casts require explicit conversion. Also, the UnsafeMutablePointer API is nonsense with a Void Pointee.<br></p><p>Whether it’s part of this proposal, or done later really depends on how we want to handle migration. Here’s how it plays out:<br>- I got strong feedback that I should first be able to prevent UnsafePointer&lt;T&gt; to UnsafePointer&lt;U&gt; coercion before introducing a new aliasing pointer type<br>- Wherever users are attempting that conversion, some additional cast will need to be introduced<br>- A lot of UnsafePointer conversion is actually safe conversion to UnsafePointer&lt;Void&gt;, it would be a shame to penalize all that code<br>- Changing the import type of UnsafePointer&lt;Void&gt; allows that code to be migrated without introducing useless casts<br></p><p>It might be nice to introduce UsafeBytePointer first without restricting UnsafePointer conversion, then there’s no immediate need to change the import type. Leaving the API in that state just don’t make as much sense conceptually. I also actually tried this and was not able to implement all the expected implicit pointer conversions without running into ambiguous overloads. I think eliminating the UnsafePointer&lt;T&gt; conversion nicely simplifies the type checker’s job.<br></p><p>-Andy<br></p><p>&gt; -Chris<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160519/4a7116ae/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>[RFC] UnsafeBytePointer API for In-Memory Layout</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>May 19, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; <br>&gt; UnsafeBytePointer API for In-Memory Layout<br>&gt; <br>&gt; UnsafePointer and UnsafeMutable refer to a typed region of memory, and the compiler must be able to assume that UnsafePointer element (Pointee) type is consistent with other access to the same memory. See proposed Type Safe Memory Access documentation &lt;https://github.com/atrick/swift/blob/type-safe-mem-docs/docs/TypeSafeMemory.rst&gt;. Consequently, conversion between UnsafePointer element types exposes an easy way to abuse the type system.<br>&gt; <br></p><p>I don’t necessarily disagree with the proposal but I think we should clearly answer the following question:<br></p><p>Why doesn’t UnsafePointer&lt;T&gt;(_: UnsafePointer&lt;U&gt;) read as UnsafePointer&lt;T&gt;(_: UnsafePointer&lt;Void&gt;). That is to say you can only “type pun” through a Void pointer. A convenience method could be offered, something like UnsafePointer.reinterpretBytes&lt;U&gt;(_ ptr: UnsafePointer&lt;U&gt;, as: U.Type) -&gt; U so all valid cases of type punning can be explicit.<br></p><p><br></p><p><br>&gt; As motivation for such an API, consider that an UnsafePointer&lt;Void&gt; or OpaquePointer may be currently be obtained from an external API. However, the developer may know the memory layout and may want to read or write elements whose types are compatible with that layout. This a reasonable use case, but unless the developer can guarantee that all accesses to the same memory location have the same type, then they cannot use UnsafePointer to access the memory without risking undefined behavior.<br>&gt; <br>IMHO if we had a @packed attribute a lot of this nonsense could be made explicit by defining a Swift struct that had the appropriate memory layout. This is how a lot of “PInvoke” stuff was done in the C# world. It also gives you an “out” if you need a very specific layout in memory for some other reason.<br></p><p><br></p><p><br></p><p>&gt; Just as with unsafeBitCast, although the destination of the cast can usually be inferred, we want the developer to explicitly state the intended destination type, both because type inferrence can be surprising, and because it&#39;s important to the reader for code comprehension.<br>&gt; <br>I’d definitely prefer a labelled initializer, especially one with an uncommon name. IMHO It should immediately stand out in code reviews.<br></p><p><br></p><p>&gt; Note: For API clarity we could consider a typealias for VoidPointer. A separate VoidPointer type would not be very useful--there&#39;s no danger that UnsafeBytePointer will be casually dereferenced, and no danger in allowing pointer arithmetic since the only reasonable interpretation is that of a byte-addressable memory.<br>&gt; <br>Agreed; even today messing with UnsafeMutablePointer&lt;Void&gt; requires you to understand that the size corresponds to bytes which is not intuitive.<br></p><p><br></p><p>&gt; Loading from and storing to memory via an Unsafe[Mutable]BytePointer is safe independent of the type of value being loaded or stored and independent of the memory&#39;s allocated type as long as layout guarantees are met (per the ABI). This allows legal type punning within Swift and allows Swift code to access a common region of memory that may be shared across an external interface that does not provide type safety guarantees. Accessing type punned memory directly through a designated Unsafe[Mutable]BytePointer type provides sound basis for compiler implementation of strict aliasing. This is in contrast with the approach of simply providing a special unsafe pointer cast operation for bypassing type safety, which cannot be reliably implemented.<br>&gt; <br></p><p>I’m not sure how to word it but I feel like some of this might help if it were included at the very beginning so people understand why this is a problem. I also think the stdlib docs should have a lot more to say about the rules, undefined behavior, and the consequences thereof. That will be all that a lot of developers ever bother to learn on the subject (a shame but out of scope for a swift evolution proposal :) )<br></p><p><br>Russ<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160519/79f6a7c3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[RFC] UnsafeBytePointer API for In-Memory Layout</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>May 20, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On May 19, 2016, at 10:35 PM, Russ Bishop &lt;xenadu at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; UnsafeBytePointer API for In-Memory Layout<br>&gt;&gt; <br>&gt;&gt; UnsafePointer and UnsafeMutable refer to a typed region of memory, and the compiler must be able to assume that UnsafePointer element (Pointee) type is consistent with other access to the same memory. See proposed Type Safe Memory Access documentation &lt;https://github.com/atrick/swift/blob/type-safe-mem-docs/docs/TypeSafeMemory.rst&gt;. Consequently, conversion between UnsafePointer element types exposes an easy way to abuse the type system.<br>&gt;&gt; <br>&gt; <br>&gt; I don’t necessarily disagree with the proposal but I think we should clearly answer the following question:<br></p><p>I think these are two questions:<br></p><p>&gt; Why doesn’t UnsafePointer&lt;T&gt;(_: UnsafePointer&lt;U&gt;) read as UnsafePointer&lt;T&gt;(_: UnsafePointer&lt;Void&gt;). That is to say you can only “type pun” through a Void pointer.<br></p><p>That’s a reasonable request and would definitely ease migration. However, it still communicates to the user that type punning is a normal, expected use of UnsafePointer. Also, it doesn’t allow all uses of potentially type punning to be identified through code inspection. I know how helpful that feature is because I’ve been auditing code for potential undefined behavior.<br></p><p>&gt; A convenience method could be offered, something like UnsafePointer.reinterpretBytes&lt;U&gt;(_ ptr: UnsafePointer&lt;U&gt;, as: U.Type) -&gt; U so all valid cases of type punning can be explicit.<br></p><p>Maybe you mean UnsafePointer.reinterpretBytes&lt;U&gt;(as: U.Type) -&gt; U <br></p><p>That’s a possibility. It’s slightly reminiscent of my first attempt to deal with this problem.<br></p><p>However, simply as a convenience it’s too similar to unsafeBitCast(p[0], to: U.self) assuming you know the types are layout compatible.<br></p><p>With my proposal you could now do UnsafeBytePointer(p).load(U.self), which is overall a much more clear, safer design.<br></p><p>&gt;&gt; As motivation for such an API, consider that an UnsafePointer&lt;Void&gt; or OpaquePointer may be currently be obtained from an external API. However, the developer may know the memory layout and may want to read or write elements whose types are compatible with that layout. This a reasonable use case, but unless the developer can guarantee that all accesses to the same memory location have the same type, then they cannot use UnsafePointer to access the memory without risking undefined behavior.<br>&gt;&gt; <br>&gt; IMHO if we had a @packed attribute a lot of this nonsense could be made explicit by defining a Swift struct that had the appropriate memory layout. This is how a lot of “PInvoke” stuff was done in the C# world. It also gives you an “out” if you need a very specific layout in memory for some other reason.<br></p><p>I think think that’s complementary and addresses the usability of doing manual layout.<br></p><p>&gt;&gt; Just as with unsafeBitCast, although the destination of the cast can usually be inferred, we want the developer to explicitly state the intended destination type, both because type inferrence can be surprising, and because it&#39;s important to the reader for code comprehension.<br>&gt;&gt; <br>&gt; I’d definitely prefer a labelled initializer, especially one with an uncommon name. IMHO It should immediately stand out in code reviews.<br></p><p>Well, I agree with that sentiment. I would even be fine with a freestanding function to make it really clear, but that defies convention. I’m looking for people to weigh in.<br></p><p>Once of the reasons I finished migrating the stdlib (multiple times), is so that proposal reviewers can look at my branch see the real effects of the proposal. My first implementation was something like UnsafePointer.init(unsafePointerCast: p). I’ve actually gotten strong feedback to force the destination type to be spelled, and shorten the label. I could probably dig up an earlier version of the changes.<br></p><p>I have to admit though that the UnsafePointer(p, to: U.self) syntax tends to read better and at least there’s an easy regex that can pick up on it.<br></p><p>&gt;&gt; Note: For API clarity we could consider a typealias for VoidPointer. A separate VoidPointer type would not be very useful--there&#39;s no danger that UnsafeBytePointer will be casually dereferenced, and no danger in allowing pointer arithmetic since the only reasonable interpretation is that of a byte-addressable memory.<br>&gt;&gt; <br>&gt; Agreed; even today messing with UnsafeMutablePointer&lt;Void&gt; requires you to understand that the size corresponds to bytes which is not intuitive.<br></p><p>Ah, that’s good feedback in favor of replacing UnsafePointer&lt;Void&gt; and its status as imported type!<br></p><p>&gt;&gt; Loading from and storing to memory via an Unsafe[Mutable]BytePointer is safe independent of the type of value being loaded or stored and independent of the memory&#39;s allocated type as long as layout guarantees are met (per the ABI). This allows legal type punning within Swift and allows Swift code to access a common region of memory that may be shared across an external interface that does not provide type safety guarantees. Accessing type punned memory directly through a designated Unsafe[Mutable]BytePointer type provides sound basis for compiler implementation of strict aliasing. This is in contrast with the approach of simply providing a special unsafe pointer cast operation for bypassing type safety, which cannot be reliably implemented.<br>&gt;&gt; <br>&gt; <br>&gt; I’m not sure how to word it but I feel like some of this might help if it were included at the very beginning so people understand why this is a problem. I also think the stdlib docs should have a lot more to say about the rules, undefined behavior, and the consequences thereof. That will be all that a lot of developers ever bother to learn on the subject (a shame but out of scope for a swift evolution proposal :) )<br></p><p>I thought that including the link to proposed Type Safe Memory Access documentation &lt;https://github.com/atrick/swift/blob/type-safe-mem-docs/docs/TypeSafeMemory.rst&gt; in the first paragraph was sufficient. But reviewers seem to be skipping over it!<br></p><p>Andy<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/736bec27/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
