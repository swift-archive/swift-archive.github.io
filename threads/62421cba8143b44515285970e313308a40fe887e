<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Having 64-bit swift_retain/release ignore all negative pointer values</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March  1, 2016 at 01:00:00pm</p></header><div class="content"><p>In swift_retain/release, we have an early-exit check to pass through a nil pointer. Since we&#39;re already burning branch, I&#39;m thinking we could pass through not only zero but negative pointer values too on 64-bit systems, since negative pointers are never valid userspace pointers on our 64-bit targets. This would give us room for tagged-pointer-like optimizations, for instance to avoid allocations for tiny closure contexts.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>Having 64-bit swift_retain/release ignore all negative pointer values</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>March  1, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Mar 1, 2016, at 1:33 PM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; In swift_retain/release, we have an early-exit check to pass through a nil pointer. Since we&#39;re already burning branch, I&#39;m thinking we could pass through not only zero but negative pointer values too on 64-bit systems, since negative pointers are never valid userspace pointers on our 64-bit targets. This would give us room for tagged-pointer-like optimizations, for instance to avoid allocations for tiny closure contexts.<br></p><p>We can&#39;t do that unless we can get a guarantee from the OS folks that a &quot;negative&quot; pointer will never be a valid userspace pointer in any future OS version.<br></p><p><br>-- <br>Greg Parker     gparker at apple.com     Runtime Wrangler<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Having 64-bit swift_retain/release ignore all negative pointer values</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>March  1, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Mar 1, 2016, at 3:05 PM, Greg Parker via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; On Mar 1, 2016, at 1:33 PM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; In swift_retain/release, we have an early-exit check to pass through a nil pointer. Since we&#39;re already burning branch, I&#39;m thinking we could pass through not only zero but negative pointer values too on 64-bit systems, since negative pointers are never valid userspace pointers on our 64-bit targets. This would give us room for tagged-pointer-like optimizations, for instance to avoid allocations for tiny closure contexts.<br>&gt; <br>&gt; We can&#39;t do that unless we can get a guarantee from the OS folks that a &quot;negative&quot; pointer will never be a valid userspace pointer in any future OS version.<br></p><p>We have that guarantee, actually.  The top eight bits are guaranteed to be clear in the user space on both ARM64 and x86-64.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/44330516abe967fb36e6fac4ec419b99?s=50"></div><header><strong>Having 64-bit swift_retain/release ignore all negative pointer values</strong> from <string>Bryan Chan</string> &lt;bryan.chan at ca.ibm.com&gt;<p>March  8, 2016 at 05:00:00am</p></header><div class="content"><p>John McCall via swift-dev &lt;swift-dev at swift.org&gt; wrote on 2016-03-01<br>06:23:24 PM:<br></p><p>&gt; &gt; On Mar 1, 2016, at 3:05 PM, Greg Parker via swift-dev &lt;swift-<br>&gt; dev at swift.org&gt; wrote:<br>&gt; &gt;&gt; On Mar 1, 2016, at 1:33 PM, Joe Groff via swift-dev &lt;swift-<br>&gt; dev at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; In swift_retain/release, we have an early-exit check to pass<br>&gt; through a nil pointer. Since we&#39;re already burning branch, I&#39;m<br>&gt; thinking we could pass through not only zero but negative pointer<br>&gt; values too on 64-bit systems, since negative pointers are never<br>&gt; valid userspace pointers on our 64-bit targets. This would give us<br>&gt; room for tagged-pointer-like optimizations, for instance to avoid<br>&gt; allocations for tiny closure contexts.<br>&gt; &gt;<br>&gt; &gt; We can&#39;t do that unless we can get a guarantee from the OS folks<br>&gt; that a &quot;negative&quot; pointer will never be a valid userspace pointer in<br>&gt; any future OS version.<br>&gt;<br>&gt; We have that guarantee, actually.  The top eight bits are guaranteed<br>&gt; to be clear in the user space on both ARM64 and x86-64.<br></p><p>This may be the case currently on Linux (even for non-x86 architectures),<br>but what I have heard is that the kernel architecture allows using more<br>levels of page tables, and the full 64-bit address space. The &quot;guarantee&quot;<br>may not hold true in the future.<br></p><p>Negative pointer values are also used on other operating systems, so I<br>would suggest not relying on this assumption for the sake of portability.<br></p><p>Bryan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160308/d249e8b2/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Having 64-bit swift_retain/release ignore all negative pointer values</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>October 13, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Mar 1, 2016, at 1:33 PM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; In swift_retain/release, we have an early-exit check to pass through a nil pointer. Since we&#39;re already burning branch, I&#39;m thinking we could pass through not only zero but negative pointer values too on 64-bit systems, since negative pointers are never valid userspace pointers on our 64-bit targets. This would give us room for tagged-pointer-like optimizations, for instance to avoid allocations for tiny closure contexts.<br></p><p>I&#39;d like to resurrect this thread as we look to locking down the ABI. There were portability concerns about doing this unilaterally for all 64-bit targets, but AFAICT it should be safe for x86-64 and Apple AArch64 targets. The x86-64 ABI limits the userland address space, per section 3.3.2:<br></p><p>Although the AMD64 architecture uses 64-bit pointers, implementations are only required to handle 48-bit addresses. Therefore, conforming processes may only use addresses from 0x00000000 00000000 to 0x00007fff ffffffff.<br></p><p>Apple&#39;s ARM64 platforms always enable the top-byte-ignore architectural feature, restricting the available address space to the low 56 bits of the full 64-bit address space in practice. Therefore, &quot;negative&quot; values should never be valid user-space references to Swift-refcountable objects. Taking advantage of this fact would enable us to optimize small closure contexts, Error objects, and, if we move to a reference-counted COW model for existentials, small `Any` values, which need to be refcountable for ABI reasons but don&#39;t semantically promise a unique identity like class instances do.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161013/e1048cd7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Having 64-bit swift_retain/release ignore all negative pointer values</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>October 13, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Oct 13, 2016, at 9:04 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 1, 2016, at 1:33 PM, Joe Groff via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; In swift_retain/release, we have an early-exit check to pass through a nil pointer. Since we&#39;re already burning branch, I&#39;m thinking we could pass through not only zero but negative pointer values too on 64-bit systems, since negative pointers are never valid userspace pointers on our 64-bit targets. This would give us room for tagged-pointer-like optimizations, for instance to avoid allocations for tiny closure contexts.<br>&gt; <br>&gt; I&#39;d like to resurrect this thread as we look to locking down the ABI. There were portability concerns about doing this unilaterally for all 64-bit targets, but AFAICT it should be safe for x86-64 and Apple AArch64 targets. The x86-64 ABI limits the userland address space, per section 3.3.2:<br>&gt; <br>&gt; Although the AMD64 architecture uses 64-bit pointers, implementations are only required to handle 48-bit addresses. Therefore, conforming processes may only use addresses from 0x00000000 00000000 to 0x00007fff ffffffff.<br>&gt; <br>&gt; Apple&#39;s ARM64 platforms always enable the top-byte-ignore architectural feature, restricting the available address space to the low 56 bits of the full 64-bit address space in practice. Therefore, &quot;negative&quot; values should never be valid user-space references to Swift-refcountable objects. Taking advantage of this fact would enable us to optimize small closure contexts, Error objects, and, if we move to a reference-counted COW model for existentials, small `Any` values, which need to be refcountable for ABI reasons but don&#39;t semantically promise a unique identity like class instances do.<br></p><p>This makes sense to me.  if (x &lt;= 0) return; should be just as cheap as is (x == 0) return;<br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161013/d0c28650/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>Having 64-bit swift_retain/release ignore all negative pointer values</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>October 13, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Oct 13, 2016, at 10:46 AM, John McCall via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Oct 13, 2016, at 9:04 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 1, 2016, at 1:33 PM, Joe Groff via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In swift_retain/release, we have an early-exit check to pass through a nil pointer. Since we&#39;re already burning branch, I&#39;m thinking we could pass through not only zero but negative pointer values too on 64-bit systems, since negative pointers are never valid userspace pointers on our 64-bit targets. This would give us room for tagged-pointer-like optimizations, for instance to avoid allocations for tiny closure contexts.<br>&gt;&gt; <br>&gt;&gt; I&#39;d like to resurrect this thread as we look to locking down the ABI. There were portability concerns about doing this unilaterally for all 64-bit targets, but AFAICT it should be safe for x86-64 and Apple AArch64 targets. The x86-64 ABI limits the userland address space, per section 3.3.2:<br>&gt;&gt; <br>&gt;&gt; Although the AMD64 architecture uses 64-bit pointers, implementations are only required to handle 48-bit addresses. Therefore, conforming processes may only use addresses from 0x00000000 00000000 to 0x00007fff ffffffff.<br>&gt;&gt; <br>&gt;&gt; Apple&#39;s ARM64 platforms always enable the top-byte-ignore architectural feature, restricting the available address space to the low 56 bits of the full 64-bit address space in practice. Therefore, &quot;negative&quot; values should never be valid user-space references to Swift-refcountable objects. Taking advantage of this fact would enable us to optimize small closure contexts, Error objects, and, if we move to a reference-counted COW model for existentials, small `Any` values, which need to be refcountable for ABI reasons but don&#39;t semantically promise a unique identity like class instances do.<br>&gt; <br>&gt; This makes sense to me.  if (x &lt;= 0) return; should be just as cheap as is (x == 0) return;<br></p><p>Conversely, I wanted to try to remove such nil checks. Currently they look haphazard: some functions have them and some do not.<br></p><p>Allowing ABI space for tagged pointer objects is a much bigger problem than the check in swift_retain/release. For example, all vtable and witness table dispatch sites to AnyObject or any other type that might someday have a tagged pointer subclass would need to compile in a fallback path now. You can&#39;t dereference a tagged pointer to get its class pointer. <br></p><p><br>-- <br>Greg Parker     gparker at apple.com &lt;mailto:gparker at apple.com&gt;     Runtime Wrangler<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161013/c1148a46/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Having 64-bit swift_retain/release ignore all negative pointer values</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>October 13, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Oct 13, 2016, at 1:18 PM, Greg Parker &lt;gparker at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 13, 2016, at 10:46 AM, John McCall via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 13, 2016, at 9:04 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mar 1, 2016, at 1:33 PM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In swift_retain/release, we have an early-exit check to pass through a nil pointer. Since we&#39;re already burning branch, I&#39;m thinking we could pass through not only zero but negative pointer values too on 64-bit systems, since negative pointers are never valid userspace pointers on our 64-bit targets. This would give us room for tagged-pointer-like optimizations, for instance to avoid allocations for tiny closure contexts.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;d like to resurrect this thread as we look to locking down the ABI. There were portability concerns about doing this unilaterally for all 64-bit targets, but AFAICT it should be safe for x86-64 and Apple AArch64 targets. The x86-64 ABI limits the userland address space, per section 3.3.2:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Although the AMD64 architecture uses 64-bit pointers, implementations are only required to handle 48-bit addresses. Therefore, conforming processes may only use addresses from 0x00000000 00000000 to 0x00007fff ffffffff.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Apple&#39;s ARM64 platforms always enable the top-byte-ignore architectural feature, restricting the available address space to the low 56 bits of the full 64-bit address space in practice. Therefore, &quot;negative&quot; values should never be valid user-space references to Swift-refcountable objects. Taking advantage of this fact would enable us to optimize small closure contexts, Error objects, and, if we move to a reference-counted COW model for existentials, small `Any` values, which need to be refcountable for ABI reasons but don&#39;t semantically promise a unique identity like class instances do.<br>&gt;&gt; <br>&gt;&gt; This makes sense to me.  if (x &lt;= 0) return; should be just as cheap as is (x == 0) return;<br>&gt; <br>&gt; Conversely, I wanted to try to remove such nil checks. Currently they look haphazard: some functions have them and some do not.<br>&gt; <br>&gt; Allowing ABI space for tagged pointer objects is a much bigger problem than the check in swift_retain/release. For example, all vtable and witness table dispatch sites to AnyObject or any other type that might someday have a tagged pointer subclass would need to compile in a fallback path now. You can&#39;t dereference a tagged pointer to get its class pointer. <br></p><p>True. I don&#39;t think we&#39;d want to use this optimization for class types; I was specifically thinking of other things for which we use nullable refcounted representations, particularly closure contexts. The ABI for function types requires the context to be refcountable by swift_retain/release, but it doesn&#39;t necessarily have to be a valid pointer, if the closure formation site and invocation function agree on a tagged-pointer representation. We could also do interesting things with enums; if one payload type is a class reference and the rest are trivial, we could lay the enum out in such a way that we can use swift_retain/release on it by setting the high bit when tagging the trivial representations, saving us the need to emit a switch. We wouldn&#39;t actually dereference the pointer representation without checking it first.<br></p><p>I know we&#39;ve discussed taking the nil check out of swift_retain/release, and possibly having separate variants that do include the null check for when we know we&#39;re working with Optionals. How much of difference would that really make, though? I&#39;d expect it to be a fairly easily predictable branch, since most objects are likely to be nonnull in practice.<br></p><p>-Joe<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6b81089e81d6bb1e14b5adb746725de1?s=50"></div><header><strong>Having 64-bit swift_retain/release ignore all negative pointer values</strong> from <string>Alexis</string> &lt;abeingessner at apple.com&gt;<p>October 13, 2016 at 05:00:00pm</p></header><div class="content"><p>Correct me if I’m wrong, but aren’t all kernel addresses negative on x64 and AArch64? Would this then mean any attempt to use Swift in kernel-space requires a distinct ABI?<br></p><p>&gt; On Oct 13, 2016, at 12:04 PM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 1, 2016, at 1:33 PM, Joe Groff via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; In swift_retain/release, we have an early-exit check to pass through a nil pointer. Since we&#39;re already burning branch, I&#39;m thinking we could pass through not only zero but negative pointer values too on 64-bit systems, since negative pointers are never valid userspace pointers on our 64-bit targets. This would give us room for tagged-pointer-like optimizations, for instance to avoid allocations for tiny closure contexts.<br>&gt; <br>&gt; I&#39;d like to resurrect this thread as we look to locking down the ABI. There were portability concerns about doing this unilaterally for all 64-bit targets, but AFAICT it should be safe for x86-64 and Apple AArch64 targets. The x86-64 ABI limits the userland address space, per section 3.3.2:<br>&gt; <br>&gt; Although the AMD64 architecture uses 64-bit pointers, implementations are only required to handle 48-bit addresses. Therefore, conforming processes may only use addresses from 0x00000000 00000000 to 0x00007fff ffffffff.<br>&gt; <br>&gt; Apple&#39;s ARM64 platforms always enable the top-byte-ignore architectural feature, restricting the available address space to the low 56 bits of the full 64-bit address space in practice. Therefore, &quot;negative&quot; values should never be valid user-space references to Swift-refcountable objects. Taking advantage of this fact would enable us to optimize small closure contexts, Error objects, and, if we move to a reference-counted COW model for existentials, small `Any` values, which need to be refcountable for ABI reasons but don&#39;t semantically promise a unique identity like class instances do.<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161013/953b5055/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Having 64-bit swift_retain/release ignore all negative pointer values</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>October 13, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Oct 13, 2016, at 2:04 PM, Alexis &lt;abeingessner at apple.com&gt; wrote:<br>&gt; <br>&gt; Correct me if I’m wrong, but aren’t all kernel addresses negative on x64 and AArch64? Would this then mean any attempt to use Swift in kernel-space requires a distinct ABI?<br></p><p>That&#39;s correct, but we&#39;d likely already have to have a separate &quot;kernel&quot; ABI due to our assumptions about spare bits in pointers. It also seems unlikely to me that kernel developers would want to use our refcounting scheme as is.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Having 64-bit swift_retain/release ignore all negative pointer values</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>October 13, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Oct 13, 2016, at 2:14 PM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 13, 2016, at 2:04 PM, Alexis &lt;abeingessner at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Correct me if I’m wrong, but aren’t all kernel addresses negative on x64 and AArch64? Would this then mean any attempt to use Swift in kernel-space requires a distinct ABI?<br>&gt; <br>&gt; That&#39;s correct, but we&#39;d likely already have to have a separate &quot;kernel&quot; ABI due to our assumptions about spare bits in pointers.<br></p><p>This is exactly my thinking.<br></p><p>John.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6b81089e81d6bb1e14b5adb746725de1?s=50"></div><header><strong>Having 64-bit swift_retain/release ignore all negative pointer values</strong> from <string>Alexis</string> &lt;abeingessner at apple.com&gt;<p>October 13, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Oct 13, 2016, at 5:14 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 13, 2016, at 2:04 PM, Alexis &lt;abeingessner at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Correct me if I’m wrong, but aren’t all kernel addresses negative on x64 and AArch64? Would this then mean any attempt to use Swift in kernel-space requires a distinct ABI?<br>&gt; <br>&gt; That&#39;s correct, but we&#39;d likely already have to have a separate &quot;kernel&quot; ABI due to our assumptions about spare bits in pointers. It also seems unlikely to me that kernel developers would want to use our refcounting scheme as is.<br></p><p>True, but the types being discussed here seem to mostly be language features that are implicitly falling back to reference counting when escape analysis fails. And specifically the tagging you’re proposing is for the cases where some special analysis passes and we can avoid the ref-counting machinery, right? Sounds like exactly the things they want. Although perhaps if they want to always avoid the ref-counting machinery, then we can actually have more aggressive pointer tagging tricks in the kernel ABI. <br></p><p>Well, as long as we’re aware that this is more complexity we’re adopting, seems fine.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161013/101959ff/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
