<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>[Proposal] Multiline string literals</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>May  6, 2016 at 10:00:00pm</p></header><div class="content"><p>Hi,<br></p><p>I propose adding multiline string literals to Swift 3.<br></p><p>I have written up a proposal as a Github Gist, here:<br>https://gist.github.com/michaelpeternell/a4da4185de78808f4575a836c50debbd &lt;https://gist.github.com/michaelpeternell/a4da4185de78808f4575a836c50debbd&gt;<br></p><p>Can someone with write-access push it to the swift-evolution repository, please?<br></p><p>Thanks..<br></p><p>Regards,<br>Michael<br></p><p>Multiline String literals<br></p><p>Proposal: SE-NNNN<br>Author: Michael Peternell &lt;https://www.github.com/michaelpeternell&gt;<br>Status: Awaiting review &lt;https://github.com/apple/swift-evolution/blob/master/0000-template.md#rationale&gt;<br>Review manager: TBD<br> &lt;https://gist.github.com/michaelpeternell/a4da4185de78808f4575a836c50debbd#introduction&gt;Introduction<br></p><p>Multi-line string literals allow text that may be multiple lines long, to be included verbatim into a string literal. The string may even contain quote characters (&quot; or &#39;), and they don&#39;t have to be especially escaped.<br></p><p> &lt;https://gist.github.com/michaelpeternell/a4da4185de78808f4575a836c50debbd#motivation&gt;Motivation<br></p><p>Including many lines of text in a program often looks not so well, e.g. a JSON-string where every quote needs to be escaped: &quot;{\&quot;response\&quot;:{\&quot;result\&quot;:\&quot;OK\&quot;}}&quot;. With multi-line string literals, we can write &quot;&quot;&quot;{&quot;response&quot;:{&quot;result&quot;:&quot;OK&quot;}}&quot;&quot;&quot; - note that every valid JSON can be pasted as-is into a &quot;&quot;&quot;3-quote string literal&quot;&quot;&quot;, because 3 quotes (&quot;&quot;&quot;) cannot appear in a valid JSON. (Why would you want to have a JSON-string in a program? Maybe you are writing unit tests for a JSON parser.) Another usage example is below.<br></p><p>Some people had concerns that a string block may break the indentation of the code. E.g.<br></p><p>            // some deeply indented code<br>            doSomeStuff(2, 33.1)<br>            print(&quot;&quot;&quot;Usage: \(program_name) &lt;PARAM-X&gt; &lt;PARAM-Y&gt; filename<br>Example: \(program_name) 3 1 countries.csv<br>This will print the 1st column of the 3rd non-empty non-header line from<br>countries.csv<br>&quot;&quot;&quot;)<br>            exit(2)<br>First, you don&#39;t have to use them. You can still use the former way of using normal double quote characters. But in order to fix the problem with multiline strings, you may use a HEREDOC-syntax. The example can be rewritten as:<br></p><p>            // some deeply indented code<br>            doSomeStuff(2, 33.1)<br>            print(&lt;&lt;USAGE_END)<br>                Example: \(program_name) 3 1 countries.csv<br>                This will print the 1st column of the 3rd non-empty<br>                non-header line from countries.csv<br></p><p>                USAGE_END<br>            exit(2)<br>This works unambiguously, as long as you don&#39;t mix tabs and spaces in your source code file.<br></p><p> &lt;https://gist.github.com/michaelpeternell/a4da4185de78808f4575a836c50debbd#proposed-solution&gt;Proposed solution<br></p><p>This proposal introduces four new forms of a String literal:<br></p><p> &lt;https://gist.github.com/michaelpeternell/a4da4185de78808f4575a836c50debbd#the-python-like-string-literal&gt;The Python-like string literal<br></p><p>Everything between &quot;&quot;&quot; and &quot;&quot;&quot; belongs to the string. Escape sequences (\n, \t, \\, etc.) and string interpolation work as usual. The rules are the same as for a normal double quoted (&quot;) string literal. However, a single &quot; doesn&#39;t need to be escaped, and therefore a string literal like &quot;&quot;&quot;&lt;a href=&quot;#&quot; onclick=&quot;openABCWindow(22);return false&quot;&gt;details&lt;/a&gt;&quot;&quot;&quot; would be valid Swift. Newline, spaces and tabs are not treated in any special way, so the following string<br></p><p>&quot;&quot;&quot;<br> test<br> test&quot;&quot;&quot;<br>could also be written as &quot;\n test\n test&quot;.<br></p><p> &lt;https://gist.github.com/michaelpeternell/a4da4185de78808f4575a836c50debbd#the-heredoc-with-string-interpolation&gt;The HEREDOC with string interpolation<br></p><p>The HEREDOC starts with a &lt;&lt;, followed by an identifier. The string literal starts in the next line and ends in the line that contains the HEREDOC identifier. Example:<br></p><p>print(&lt;&lt;USAGE)<br>    funnyProgram [-v] [-h]<br>    This program tells a joke. Possible options:<br>      -v | --version ... Shows version information<br>      -h | --help ...... Shows this list of options<br>USAGE<br>exit(2)<br>This string literal does not contain a trailing newline character. Otherwise, it would not be possible to create a HEREDOC-literal without trailing newline (The print()-function will add a newline though.) In the example above, each line is indented by 4 spaces. If you want to strip leading spaces on each line you have to indent the ending identifier with the same amount of whitespace. Thus, a better example would look like this:<br></p><p>print(&lt;&lt;USAGE)<br>    funnyProgram [-v] [-h]<br>    This program tells a joke. Possible options:<br>      -v | --version ... Shows version information<br>      -h | --help ...... Shows this list of options<br>    USAGE<br>exit(2)<br>The leading indentation has to be all-spaces or all-tabs, but never a mixture of them.<br></p><p> &lt;https://gist.github.com/michaelpeternell/a4da4185de78808f4575a836c50debbd#the-heredoc-without-string-interpolation&gt;The HEREDOC without string interpolation<br></p><p>To have no string interpolation or escape sequences at all, you can add single quotes around the HEREDOC-identifier. Example:<br></p><p>print(&lt;&lt;&#39;USAGE&#39;)<br>    funnyProgram [-v] [-h]<br>    This program tells a joke. Possible options:<br>      -v | --version ... Shows version information<br>      -h | --help ...... Shows this list of options<br>         \( ^^ don&#39;t worry, be happy :-)<br>    USAGE<br>exit(2)<br>In all other regards, this string literal behaves the same as the HEREDOC with string interpolation.<br></p><p> &lt;https://gist.github.com/michaelpeternell/a4da4185de78808f4575a836c50debbd#guillemets-and-english-typographical-quotes&gt;¬´Guillemets¬ª and English ‚Äútypographical quotes‚Äù<br></p><p>Swift already allows emojis in names of all sort. The following code is valid Swift:<br></p><p>for üêü in sea {<br>    üêü.makeSushi()<br>}<br>Swift is a playful language. Allowing ¬´Guillemets¬ª and ‚Äútypographical quotes‚Äù is the next logical step. To allow for both strings with interpolation and strings without interpolation, one should allow string interpolation and escape sequences while the other should not. I propose that ¬´Guillemets¬ª are used for strings without interpolation, so ¬´\¬ª is a valid string literal consisting of one escape character. ‚Äú&quot;\(localizedName)&quot;‚Äù is a string containing a double quote character (&quot;) followed by whatever the contents of localizedName is, followed by another double quote character (&quot;). (Note that the reverse is already possible: &quot;‚Äú\(localizedName)‚Äù&quot;.)<br></p><p>These literals behave the same as the Python-like string literal above.<br></p><p> &lt;https://gist.github.com/michaelpeternell/a4da4185de78808f4575a836c50debbd#detailed-design&gt;Detailed design<br></p><p>Python-strings, Guillemets and English typographical quotes are already described in detail above. The only thing that may cause misunderstandings are the HEREDOCs.<br></p><p>The following code should be invalid:<br></p><p>    print(&lt;&lt;EOT)<br>    hello world<br>        is this a proper string literal?<br>        EOT<br>because the ending EOT has more indentation than one of the lines in the string literal.<br></p><p>The following code is valid though:<br></p><p>    // I replaced spaces with _underscores_ below:<br>____print(&lt;&lt;EOT)<br>________hello world<br>____<br>________is this a valid string?<br>________EOT<br>Although the second line has less indentation than the other lines, this is not a problem because the line is empty.<br></p><p>The following string literal contains 3 spaces in the second line, and it ends with a single newline character:<br></p><p>    // I replaced spaces with _underscores_ below:<br>____print(&lt;&lt;EOT)<br>________hello world<br>___________<br>________is this a valid string?<br></p><p>________EOT<br>The following string literal is invalid:<br></p><p>    // I replaced spaces with _underscores_ below.<br>    // I replaced tab characters with TAB! below.<br>____print(&lt;&lt;EOT)<br>________hello world<br>____<br>TAB!____is this a valid string<br>________EOT<br>    // =&gt; no<br>With tabs configured to look exactly like 4 spaces, the code above looks valid but it is not. There is no sane way to decide wether (TAB + 4 spaces) is (less than, the same amount, or more than) 8 spaces. Such code should be discarded.<br></p><p>The authors opinion is that tabs and spaces should not be mixed, and that this will not be a problem in almost all use cases.<br></p><p>The following HEREDOC is also invalid, although the amount of whitespace is consistent:<br></p><p>    // I replaced spaces with _underscores_ below.<br>    // I replaced tab characters with TAB! below.<br>____print(&lt;&lt;EOT)<br>____TAB!hello world<br>____TAB!<br>____TAB!is this a valid string?<br>____TAB!__good question.<br>____TAB!EOT<br>Tabs and spaces just shouldn&#39;t be mixed. The following snippet is fine though, although inconsistent in it&#39;s tab/spaces use:<br></p><p>    // I replaced spaces with _underscores_ below:<br>    // I replaced tab characters with TAB! below.<br>____print(&lt;&lt;EOT)<br>________hello world<br>________<br>________is this a valid string?<br>________TAB!Yes, indeed, even though this line started with a tab<br>________EOT<br>In the example above, the leading space on each line consists of 8 spaces. Everything after these 8 spaces should become part of the string literal as-is.<br></p><p> &lt;https://gist.github.com/michaelpeternell/a4da4185de78808f4575a836c50debbd#impact-on-existing-code&gt;Impact on existing code<br></p><p>This is an add-on feature. Code that uses these multi-line string literals didn&#39;t even compile with previous versions of Swift, so no existing code can break because of this change.<br></p><p> &lt;https://gist.github.com/michaelpeternell/a4da4185de78808f4575a836c50debbd#alternatives-consiedered&gt;Alternatives consiedered<br></p><p>Introduce just the &quot;&quot;&quot;Python-like string literal&quot;&quot;&quot;<br></p><p>Do nothing.<br></p><p> &lt;https://gist.github.com/michaelpeternell/a4da4185de78808f4575a836c50debbd#rationale&gt;Rationale<br></p><p>...<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160506/cbe94622/attachment.html&gt;<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
