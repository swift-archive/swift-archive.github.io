<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: Closures capture weak by default</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December  8, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; <br>&gt; On Dec 8, 2015, at 9:28 AM, Gwendal Roué &lt;gwendal.roue at gmail.com&gt; wrote:<br>&gt; <br>&gt; I’m really not found at all of having `let` properties captured by closures when used without explicit `self`.<br>&gt; <br>&gt; Three reasons:<br>&gt; <br>&gt; REASON 1. When `self` is not mandatory, then adding self should have no impact whatsoever.<br>&gt; <br>&gt; Why should one add a self that is not mandatory?<br>&gt; <br>&gt; 1. for symmetry (1):<br>&gt; <br>&gt; 	self.foo = other.foo<br>&gt; 	let delta = self.x - other.x<br>&gt; <br>&gt; 2. for symmetry (2):<br>&gt; 	<br>&gt; 	init(a:String, index:Int) {<br>&gt; 		self.name = name<br>&gt; 		self.position = index+1	// keep 1-based value for implementation reasons<br>&gt; 	}<br>&gt; <br>&gt; 3. add your own reasons to use an explicit self even when not required, and I’m sure you did.<br>&gt; <br>&gt; So generally speaking, using self when not mandatory should have no impact on the program at all.<br>&gt; <br>&gt; <br>&gt; REASON 2. What happens when a property starts its life as `let`, but turns `var` eventually? For example, the property eventually becomes lazy. OK now it’s is illegal to use the property without explicit `self` in closures, and you break a bunch of code. And you need to bump the major version of your package. Just because you turn a `let foo: String` into `lazy var foo: String = …`.<br>&gt; <br>&gt; That’s not good at all.<br>&gt; REASON 3. It’s simply not clear. Clever, terse, smart, brilliant, but not clear.<br>&gt; <br>&gt; Compare to:<br>&gt; <br>&gt; 	// Obviously only `foo` is captured, and not self:<br>&gt; 	let foo = self.foo<br>&gt; 	performClosure { foo }<br></p><p><br>These are good points, but re: reason 2, turning a public &#39;let&#39; into a &#39;var&#39; is already a non-resilient, semantics-breaking change, since you&#39;re taking back a promise you made about immutability. You should publish a public &#39;var&#39; with a private setter if you want to reserve the right to publish mutability in the future.<br></p><p>As for reason 3, the only noticeable difference between capturing an immutable property and capturing its container is that the container&#39;s lifetime might be shorter than it otherwise needs to be, so you save some memory, and weak references maybe null out sooner. If you were going to capture a weak reference to break a cycle anyway, the latter isn&#39;t a problem, and capturing the immutable value directly is preferable, since instead of disappearing, it will still be independently held by the closure.<br></p><p>-Joe<br></p><p>&gt; My two cents.<br>&gt; Gwendal Roué<br>&gt; <br>&gt; <br>&gt;&gt; Le 8 déc. 2015 à 18:01, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt;&gt; For &#39;let&#39; properties of classes, it&#39;d be reasonable to propose having closures capture the *property* directly by default in this way instead of capturing ‘self&#39;<br>&gt;&gt; <br>&gt;&gt; That would be fantastic.<br>&gt;&gt; <br>&gt;&gt; I’ve also wondered whether there’s a tidy way for a closure to be tied to the lifecycle of self, so that when self goes away, the closure goes away too. That’s often the desired behavior. On a casual thinking through, though, it seems like a can of worms — and the “guard let self = self else { return }” proposal on another thread gives most of the same benefit.<br>&gt;&gt; <br>&gt;&gt; P<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/064e1f29/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>Proposal: Closures capture weak by default</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>December  8, 2015 at 07:00:00pm</p></header><div class="content"><p>&gt;&gt; I’m really not found at all of having `let` properties captured by closures when used without explicit `self`.<br>&gt;&gt; <br>&gt;&gt; Three reasons […]<br>&gt;&gt; <br>&gt;&gt; REASON 2. What happens when a property starts its life as `let`, but turns `var` eventually? For example, the property eventually becomes lazy. OK now it’s is illegal to use the property without explicit `self` in closures, and you break a bunch of code. And you need to bump the major version of your package. Just because you turn a `let foo: String` into `lazy var foo: String = …`.<br>&gt;&gt; <br>&gt;&gt; That’s not good at all.<br>&gt; <br>&gt; These are good points, but re: reason 2, turning a public &#39;let&#39; into a &#39;var&#39; is already a non-resilient, semantics-breaking change, since you&#39;re taking back a promise you made about immutability. You should publish a public &#39;var&#39; with a private setter if you want to reserve the right to publish mutability in the future.<br></p><p>Is it so sure? I don’t see any difference, API-wise, between `let foo` and `lazy var foo`. Maybe I forgot the private(set), but in this case please be nice and follow me: I’m talking about a public getter that starts its life as `let` and ends its life as `lazy var`. There is no API difference in this case, and no reason to bump the major version of a package that would expose such a getter.<br></p><p>Besides, a non-lazy property that starts its life as `let foo` and ends as `private(set) var foo` is in the same category: there is *no* difference in the public API, and *no* reason for bumping the major version of the lib.<br></p><p>And this is why I keep standing against your proposal of having the presence or absence of `self` change the capture mode of such properties in closures, despite the fact it looks smart at 1st sight.<br></p><p>&gt;&gt; REASON 3. It’s simply not clear. Clever, terse, smart, brilliant, but not clear.<br>&gt;&gt; <br>&gt;&gt; Compare to:<br>&gt;&gt; <br>&gt;&gt; 	// Obviously only `foo` is captured, and not self:<br>&gt;&gt; 	let foo = self.foo<br>&gt;&gt; 	performClosure { foo }<br>&gt; <br>&gt; As for reason 3, the only noticeable difference between capturing an immutable property and capturing its container is that the container&#39;s lifetime might be shorter than it otherwise needs to be, so you save some memory, and weak references maybe null out sooner. If you were going to capture a weak reference to break a cycle anyway, the latter isn&#39;t a problem, and capturing the immutable value directly is preferable, since instead of disappearing, it will still be independently held by the closure.<br></p><p>This does not address my point. My point is that the current state of the language makes it crystal clear about the captured objects, when your proposal makes it 1. unclear, and 2. breaks the fact that the non-mandatory `self` should remain *discretionary*.<br></p><p>I’ve given symmetry examples above. Here is one another:<br></p><p>	let foo = self.foo	// discretionary foo<br>	self.foo = nil<br>	// Now self.foo is nil and can expose its new clean state to other objects, for example an eventual delegate.<br>	// Yet foo is still usable, for whatever purpose.<br></p><p>Without the discretionary self, we’d have to use ugly variable names like `theFoo`, `aFoo`, `myFoo`, or whatever funny names that are nor required today:<br></p><p>	let theFoo = foo<br>	foo = nil<br></p><p>To sum up: non-mandatory `self.` should remain discretionary. Hence any idea that is based on the absence or presence of an explicit `self.` is a bad idea.<br></p><p>Gwendal Roué<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: Closures capture weak by default</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December  8, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 8, 2015, at 10:48 AM, Gwendal Roué &lt;gwendal.roue at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; I’m really not found at all of having `let` properties captured by closures when used without explicit `self`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Three reasons […]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; REASON 2. What happens when a property starts its life as `let`, but turns `var` eventually? For example, the property eventually becomes lazy. OK now it’s is illegal to use the property without explicit `self` in closures, and you break a bunch of code. And you need to bump the major version of your package. Just because you turn a `let foo: String` into `lazy var foo: String = …`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That’s not good at all.<br>&gt;&gt; <br>&gt;&gt; These are good points, but re: reason 2, turning a public &#39;let&#39; into a &#39;var&#39; is already a non-resilient, semantics-breaking change, since you&#39;re taking back a promise you made about immutability. You should publish a public &#39;var&#39; with a private setter if you want to reserve the right to publish mutability in the future.<br>&gt; <br>&gt; Is it so sure? I don’t see any difference, API-wise, between `let foo` and `lazy var foo`. Maybe I forgot the private(set), but in this case please be nice and follow me: I’m talking about a public getter that starts its life as `let` and ends its life as `lazy var`. There is no API difference in this case, and no reason to bump the major version of a package that would expose such a getter.<br>&gt; <br>&gt; Besides, a non-lazy property that starts its life as `let foo` and ends as `private(set) var foo` is in the same category: there is *no* difference in the public API, and *no* reason for bumping the major version of the lib.<br></p><p>There *is* an important difference in API between &quot;nobody can mutate this&quot; and &quot;you can&#39;t mutate this, but others may be able to.&quot; The former is a much stronger guarantee that can&#39;t be safely weakened without breaking code.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>Proposal: Closures capture weak by default</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>December  8, 2015 at 07:00:00pm</p></header><div class="content"><p>&gt; Le 8 déc. 2015 à 19:51, Joe Groff &lt;jgroff at apple.com&gt; a écrit :<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 8, 2015, at 10:48 AM, Gwendal Roué &lt;gwendal.roue at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m really not found at all of having `let` properties captured by closures when used without explicit `self`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Three reasons […]<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; REASON 2. What happens when a property starts its life as `let`, but turns `var` eventually? For example, the property eventually becomes lazy. OK now it’s is illegal to use the property without explicit `self` in closures, and you break a bunch of code. And you need to bump the major version of your package. Just because you turn a `let foo: String` into `lazy var foo: String = …`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That’s not good at all.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; These are good points, but re: reason 2, turning a public &#39;let&#39; into a &#39;var&#39; is already a non-resilient, semantics-breaking change, since you&#39;re taking back a promise you made about immutability. You should publish a public &#39;var&#39; with a private setter if you want to reserve the right to publish mutability in the future.<br>&gt;&gt; <br>&gt;&gt; Is it so sure? I don’t see any difference, API-wise, between `let foo` and `lazy var foo`. Maybe I forgot the private(set), but in this case please be nice and follow me: I’m talking about a public getter that starts its life as `let` and ends its life as `lazy var`. There is no API difference in this case, and no reason to bump the major version of a package that would expose such a getter.<br>&gt;&gt; <br>&gt;&gt; Besides, a non-lazy property that starts its life as `let foo` and ends as `private(set) var foo` is in the same category: there is *no* difference in the public API, and *no* reason for bumping the major version of the lib.<br>&gt; <br>&gt; There *is* an important difference in API between &quot;nobody can mutate this&quot; and &quot;you can&#39;t mutate this, but others may be able to.&quot; The former is a much stronger guarantee that can&#39;t be safely weakened without breaking code.<br></p><p>This is true, you are right. The property could be mutated by the package internals.<br></p><p>This paves the way for another swift evolution request, actually. The `var` in lazy and the `private(set)` are often plasters on properties that are *intended* to be immutable, but can not be because of the current limitations of the language.<br></p><p>Gwendal<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: Closures capture weak by default</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December  8, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; This paves the way for another swift evolution request, actually. The `var` in lazy and the `private(set)` are often plasters on properties that are *intended* to be immutable, but can not be because of the current limitations of the language.<br></p><p>And even worse is the need to declare things as Optional var members (usually IUO) when they can&#39;t be fully initialized in phase 1 due to dependency issues.<br></p><p>I would love to see proposals aimed at solving these problems.<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
