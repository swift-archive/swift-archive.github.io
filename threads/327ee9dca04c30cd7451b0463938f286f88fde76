<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Foundation and value types</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 10, 2015 at 06:00:00pm</p></header><div class="content"><p>I am very happy that Swift 3 is placing a priority on portability, especially including a robust library enabling real work to be done.  <br></p><p>Adopting Foundation as the library interface is an obvious choice for many reasons.  Despite that I find it rather unfortunate that we are tied to an API designed in a different language without the rich feature set Swift has to offer, especially expressive and highly functional value types.  <br></p><p>Many of the types in Foundation would naturally be designed as value types in Swift, evidenced by the fact that String, Array, Dictionary and Set are implemented this way in Swift&#39;s standard library.  I&#39;m sure it would be out of scope for Swift 3, but I am wondering if there are plans to design Swift-native value types corresponding to the Foundation types where that makes sense (Date, URL, etc).<br></p><p>I am also wondering how this would interact with the decision to drop the NS prefixes from the names of Foundation types.  For example, if a hypothetical Date value type exists in a future version of Swift and NSDate is also named Date in Swift any code importing both Foundation and the module containing the Swift-native Date type (would this be in the standard library?) would need to manually resolve the name ambiguity every time it was used.  This is obviously less than ideal.  <br></p><p>I am guessing there is at least a vague conception of a more Swifty Foundation and a plan to somehow address the issue of conflicting names.  If there is I am interested in having some idea of where we are headed.<br></p><p>I ask partly out of a desire to use value types for things that are naturally values and partly because I am wondering if there is anything the community can reasonbly do in the near term to expedite the process of getting to a more Swifty Foundation API beyond helping to complete a robust and well tested corelibs implementation of Foundation.<br></p><p>Thanks,<br>Matthew<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Foundation and value types</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December 10, 2015 at 04:00:00pm</p></header><div class="content"><p>On Thu, Dec 10, 2015 at 4:09 PM, Matthew Johnson via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; I am very happy that Swift 3 is placing a priority on portability, especially including a robust library enabling real work to be done.<br>&gt;<br>&gt; Adopting Foundation as the library interface is an obvious choice for many reasons.  Despite that I find it rather unfortunate that we are tied to an API designed in a different language without the rich feature set Swift has to offer, especially expressive and highly functional value types.<br>&gt;<br>&gt; Many of the types in Foundation would naturally be designed as value types in Swift, evidenced by the fact that String, Array, Dictionary and Set are implemented this way in Swift&#39;s standard library.  I&#39;m sure it would be out of scope for Swift 3, but I am wondering if there are plans to design Swift-native value types corresponding to the Foundation types where that makes sense (Date, URL, etc).<br></p><p>It seems to be an area of the library where value types would make a<br>lot of sense, so I&#39;d like this conversation to continue.  Tony, what<br>do you think?<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be4c3c3b76631a155e1358db48066692?s=50"></div><header><strong>Foundation and value types</strong> from <string>Tony Parker</string> &lt;anthony.parker at apple.com&gt;<p>December 10, 2015 at 05:00:00pm</p></header><div class="content"><p>Our primary goal for Swift 3 is to achieve API parity with Darwin Foundation.<br></p><p>That said, if we want to talk about value types then the conversation has to start with how the bridging is supposed to work. The vast majority of frameworks on OS X and iOS are implemented in Objective-C and will expect existing Foundation class types in their APIs (e.g. Date and URL).<br></p><p>- Tony<br></p><p>&gt; On Dec 10, 2015, at 4:38 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Thu, Dec 10, 2015 at 4:09 PM, Matthew Johnson via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; I am very happy that Swift 3 is placing a priority on portability, especially including a robust library enabling real work to be done.<br>&gt;&gt; <br>&gt;&gt; Adopting Foundation as the library interface is an obvious choice for many reasons.  Despite that I find it rather unfortunate that we are tied to an API designed in a different language without the rich feature set Swift has to offer, especially expressive and highly functional value types.<br>&gt;&gt; <br>&gt;&gt; Many of the types in Foundation would naturally be designed as value types in Swift, evidenced by the fact that String, Array, Dictionary and Set are implemented this way in Swift&#39;s standard library.  I&#39;m sure it would be out of scope for Swift 3, but I am wondering if there are plans to design Swift-native value types corresponding to the Foundation types where that makes sense (Date, URL, etc).<br>&gt; <br>&gt; It seems to be an area of the library where value types would make a<br>&gt; lot of sense, so I&#39;d like this conversation to continue.  Tony, what<br>&gt; do you think?<br>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Foundation and value types</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December 10, 2015 at 05:00:00pm</p></header><div class="content"><p>Bridging definitely has to be an important part of the proposal.  But<br>I want to note that we have existing tools to solve bridging issues<br>that we use with existing types -- researching how to apply them would<br>be a good start.<br></p><p>Dmitri<br></p><p>On Thu, Dec 10, 2015 at 5:02 PM, Tony Parker &lt;anthony.parker at apple.com&gt; wrote:<br>&gt; Our primary goal for Swift 3 is to achieve API parity with Darwin Foundation.<br>&gt;<br>&gt; That said, if we want to talk about value types then the conversation has to start with how the bridging is supposed to work. The vast majority of frameworks on OS X and iOS are implemented in Objective-C and will expect existing Foundation class types in their APIs (e.g. Date and URL).<br>&gt;<br>&gt; - Tony<br>&gt;<br>&gt;&gt; On Dec 10, 2015, at 4:38 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Thu, Dec 10, 2015 at 4:09 PM, Matthew Johnson via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; I am very happy that Swift 3 is placing a priority on portability, especially including a robust library enabling real work to be done.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Adopting Foundation as the library interface is an obvious choice for many reasons.  Despite that I find it rather unfortunate that we are tied to an API designed in a different language without the rich feature set Swift has to offer, especially expressive and highly functional value types.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Many of the types in Foundation would naturally be designed as value types in Swift, evidenced by the fact that String, Array, Dictionary and Set are implemented this way in Swift&#39;s standard library.  I&#39;m sure it would be out of scope for Swift 3, but I am wondering if there are plans to design Swift-native value types corresponding to the Foundation types where that makes sense (Date, URL, etc).<br>&gt;&gt;<br>&gt;&gt; It seems to be an area of the library where value types would make a<br>&gt;&gt; lot of sense, so I&#39;d like this conversation to continue.  Tony, what<br>&gt;&gt; do you think?<br>&gt;&gt;<br>&gt;&gt; Dmitri<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;<br></p><p><br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be4c3c3b76631a155e1358db48066692?s=50"></div><header><strong>Foundation and value types</strong> from <string>Tony Parker</string> &lt;anthony.parker at apple.com&gt;<p>December 10, 2015 at 05:00:00pm</p></header><div class="content"><p>I’m not particularly happy with the existing bridging.<br></p><p>First, it’s not available on all platforms. <br></p><p>Second, it’s often inefficient (c.f. https://github.com/apple/swift/blob/master/stdlib/public/core/String.swift#L476, https://github.com/apple/swift/blob/master/stdlib/public/core/ArrayCast.swift#L159, others).<br></p><p>Third, it causes confusing API discrepancies. e.g. here: (https://github.com/apple/swift-corelibs-foundation/blob/master/Foundation/NSError.swift#L47)<br></p><p>    /// - Experiment: This is a draft API currently under consideration for official import into Foundation<br>    /// - Note: This API differs from Darwin because it uses [String : Any] as a type instead of [String : AnyObject]. This allows the use of Swift value types.<br>    private var _userInfo: [String : Any]?<br></p><p><br>On Darwin this is [String: AnyObject] - but then, why does it accept Swift.String, which is clearly not an object? Because of magic stuff happening behind your back (which, because of #1, does not happen on Linux).<br></p><p>I don’t have any silver bullet proposal, but before we go head first into expanding this pattern across many more class/value types, I believe we need a much better answer.<br></p><p>- Tony<br></p><p>&gt; On Dec 10, 2015, at 5:05 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt; Bridging definitely has to be an important part of the proposal.  But<br>&gt; I want to note that we have existing tools to solve bridging issues<br>&gt; that we use with existing types -- researching how to apply them would<br>&gt; be a good start.<br>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; On Thu, Dec 10, 2015 at 5:02 PM, Tony Parker &lt;anthony.parker at apple.com&gt; wrote:<br>&gt;&gt; Our primary goal for Swift 3 is to achieve API parity with Darwin Foundation.<br>&gt;&gt; <br>&gt;&gt; That said, if we want to talk about value types then the conversation has to start with how the bridging is supposed to work. The vast majority of frameworks on OS X and iOS are implemented in Objective-C and will expect existing Foundation class types in their APIs (e.g. Date and URL).<br>&gt;&gt; <br>&gt;&gt; - Tony<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 10, 2015, at 4:38 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Thu, Dec 10, 2015 at 4:09 PM, Matthew Johnson via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; I am very happy that Swift 3 is placing a priority on portability, especially including a robust library enabling real work to be done.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Adopting Foundation as the library interface is an obvious choice for many reasons.  Despite that I find it rather unfortunate that we are tied to an API designed in a different language without the rich feature set Swift has to offer, especially expressive and highly functional value types.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Many of the types in Foundation would naturally be designed as value types in Swift, evidenced by the fact that String, Array, Dictionary and Set are implemented this way in Swift&#39;s standard library.  I&#39;m sure it would be out of scope for Swift 3, but I am wondering if there are plans to design Swift-native value types corresponding to the Foundation types where that makes sense (Date, URL, etc).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It seems to be an area of the library where value types would make a<br>&gt;&gt;&gt; lot of sense, so I&#39;d like this conversation to continue.  Tony, what<br>&gt;&gt;&gt; do you think?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Dmitri<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/32a42e97/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Foundation and value types</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December 10, 2015 at 05:00:00pm</p></header><div class="content"><p>On Thu, Dec 10, 2015 at 5:19 PM, Tony Parker &lt;anthony.parker at apple.com&gt; wrote:<br>&gt; I’m not particularly happy with the existing bridging.<br>&gt;<br>&gt; First, it’s not available on all platforms.<br>&gt;<br>&gt; Second, it’s often inefficient (c.f.<br>&gt; https://github.com/apple/swift/blob/master/stdlib/public/core/String.swift#L476,<br></p><p>This is not an issue with bridging.  String needs a different hash<br>code because it implements == differently, and hash code and equality<br>semantics have to match.<br></p><p>&gt; https://github.com/apple/swift/blob/master/stdlib/public/core/ArrayCast.swift#L159,<br></p><p>In this case, the user explicitly asked to check whether a cast is<br>possible using &#39;as?&#39;, there is no other way to implement this.  When<br>it is possible to do a cast lazily, we do it lazily.<br></p><p>&gt; others).<br>&gt;<br>&gt; Third, it causes confusing API discrepancies. e.g. here:<br>&gt; (https://github.com/apple/swift-corelibs-foundation/blob/master/Foundation/NSError.swift#L47)<br>&gt;<br>&gt;     /// - Experiment: This is a draft API currently under consideration for<br>&gt; official import into Foundation<br>&gt;     /// - Note: This API differs from Darwin because it uses [String : Any]<br>&gt; as a type instead of [String : AnyObject]. This allows the use of Swift<br>&gt; value types.<br>&gt;     private var _userInfo: [String : Any]?<br>&gt;<br>&gt;<br>&gt; On Darwin this is [String: AnyObject] - but then, why does it accept<br>&gt; Swift.String, which is clearly not an object? Because of magic stuff<br>&gt; happening behind your back (which, because of #1, does not happen on Linux).<br></p><p>Yes, we need to make it consistent.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7ba3c93f9350613c243eeb87c602935e?s=50"></div><header><strong>Foundation and value types</strong> from <string>David Smith</string> &lt;david_smith at apple.com&gt;<p>December 10, 2015 at 05:00:00pm</p></header><div class="content"><p>There&#39;s certainly plenty of room for optimization in bridging of specific types, which could help these general cases (e.g. an Array&lt;NSString&gt; being cast to Array&lt;String&gt; would be sped up by improvements to NSString-&gt;String bridging performance, and so on). I&#39;ve identified various improvements that could be made over the last year or so, and I&#39;m sure profiling would turn up more in short order.<br></p><p>	David<br></p><p>&gt; On Dec 10, 2015, at 5:24 PM, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Thu, Dec 10, 2015 at 5:19 PM, Tony Parker &lt;anthony.parker at apple.com &lt;mailto:anthony.parker at apple.com&gt;&gt; wrote:<br>&gt;&gt; I’m not particularly happy with the existing bridging.<br>&gt;&gt; <br>&gt;&gt; First, it’s not available on all platforms.<br>&gt;&gt; <br>&gt;&gt; Second, it’s often inefficient (c.f.<br>&gt;&gt; https://github.com/apple/swift/blob/master/stdlib/public/core/String.swift#L476 &lt;https://github.com/apple/swift/blob/master/stdlib/public/core/String.swift#L476&gt;,<br>&gt; <br>&gt; This is not an issue with bridging.  String needs a different hash<br>&gt; code because it implements == differently, and hash code and equality<br>&gt; semantics have to match.<br>&gt; <br>&gt;&gt; https://github.com/apple/swift/blob/master/stdlib/public/core/ArrayCast.swift#L159 &lt;https://github.com/apple/swift/blob/master/stdlib/public/core/ArrayCast.swift#L159&gt;,<br>&gt; <br>&gt; In this case, the user explicitly asked to check whether a cast is<br>&gt; possible using &#39;as?&#39;, there is no other way to implement this.  When<br>&gt; it is possible to do a cast lazily, we do it lazily.<br>&gt; <br>&gt;&gt; others).<br>&gt;&gt; <br>&gt;&gt; Third, it causes confusing API discrepancies. e.g. here:<br>&gt;&gt; (https://github.com/apple/swift-corelibs-foundation/blob/master/Foundation/NSError.swift#L47)<br>&gt;&gt; <br>&gt;&gt;    /// - Experiment: This is a draft API currently under consideration for<br>&gt;&gt; official import into Foundation<br>&gt;&gt;    /// - Note: This API differs from Darwin because it uses [String : Any]<br>&gt;&gt; as a type instead of [String : AnyObject]. This allows the use of Swift<br>&gt;&gt; value types.<br>&gt;&gt;    private var _userInfo: [String : Any]?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Darwin this is [String: AnyObject] - but then, why does it accept<br>&gt;&gt; Swift.String, which is clearly not an object? Because of magic stuff<br>&gt;&gt; happening behind your back (which, because of #1, does not happen on Linux).<br>&gt; <br>&gt; Yes, we need to make it consistent.<br>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt;*/<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/f04628d1/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/00f9939846257c9db8ddc42ce61ec6d1?s=50"></div><header><strong>Foundation and value types</strong> from <string>Philippe Hausler</string> &lt;phausler at apple.com&gt;<p>December 10, 2015 at 05:00:00pm</p></header><div class="content"><p>I think some may have a more persuasive argument than others: NSDate for example seems much more cut and dry since it is basically just a simple wrapper around a Double. It is worth mentioning that one of the distinct advantages of the class versions is that they are subclassable. Granted that may not apply to all users but it is a pretty useful thing to have a good concrete base class to derive from that works well with other APIs. NSOperation for example probably would not be a good candidate since most all cases of it’s usage is a subclass. URL I am on the fence because one of the major issues with going to a struct type is that it would likely loose the functionality granted by lower level APIs like CFURLRef which some of that nuances I would hope would be developed in one canonical location.<br></p><p>&gt; On Dec 10, 2015, at 5:02 PM, Tony Parker via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Our primary goal for Swift 3 is to achieve API parity with Darwin Foundation.<br>&gt; <br>&gt; That said, if we want to talk about value types then the conversation has to start with how the bridging is supposed to work. The vast majority of frameworks on OS X and iOS are implemented in Objective-C and will expect existing Foundation class types in their APIs (e.g. Date and URL).<br>&gt; <br>&gt; - Tony<br>&gt; <br>&gt;&gt; On Dec 10, 2015, at 4:38 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Thu, Dec 10, 2015 at 4:09 PM, Matthew Johnson via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; I am very happy that Swift 3 is placing a priority on portability, especially including a robust library enabling real work to be done.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Adopting Foundation as the library interface is an obvious choice for many reasons.  Despite that I find it rather unfortunate that we are tied to an API designed in a different language without the rich feature set Swift has to offer, especially expressive and highly functional value types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Many of the types in Foundation would naturally be designed as value types in Swift, evidenced by the fact that String, Array, Dictionary and Set are implemented this way in Swift&#39;s standard library.  I&#39;m sure it would be out of scope for Swift 3, but I am wondering if there are plans to design Swift-native value types corresponding to the Foundation types where that makes sense (Date, URL, etc).<br>&gt;&gt; <br>&gt;&gt; It seems to be an area of the library where value types would make a<br>&gt;&gt; lot of sense, so I&#39;d like this conversation to continue.  Tony, what<br>&gt;&gt; do you think?<br>&gt;&gt; <br>&gt;&gt; Dmitri<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
