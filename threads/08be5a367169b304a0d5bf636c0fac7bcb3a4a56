<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d1b8a67b310b1a2bb0de75b08159b2a8?s=50"></div><header><strong>[Proposal] Conditional Conformance on Protocols/Generic Types</strong> from <string>Dan Zimmerman</string> &lt;daniel.zimmerman at me.com&gt;<p>June  4, 2016 at 04:00:00pm</p></header><div class="content"><p>Hey,<br></p><p>I was interested in adopting the ability for a type that&#39;s generic in some sense (either via generics or via associated types, in the case of protocols) to conform to other protocols conditionally based on its type parameter/associated type. For example:<br></p><p>```<br>extension CollectionType: Equatable where Generator.Element: Equatable {}<br></p><p>func ==&lt;Collection: CollectionType where Collection.Generator.Element: Equatable&gt;(left: Collection, right: Collection) -&gt; Bool {<br>  return zip(left, right).reduce(true) { accumulator, tuple in accumulator &amp;&amp; (tuple.0 == tuple.1) }<br>}<br>```<br></p><p>If this has already been proposed and knocked out/accepted please direct me to the right place.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Proposal] Conditional Conformance on Protocols/Generic Types</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>June  4, 2016 at 02:00:00pm</p></header><div class="content"><p>Hello Dan,<br></p><p>You&#39;ll be pleased to learn that conforming generic types conditionally to protocols is on the roadmap (and is one of the highest priority items for the versions of Swift following 3.0): https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances- &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-&gt;<br></p><p>However, it&#39;s unlikely that protocols will gain conditional conformance: https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-via-protocol-extensions &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-via-protocol-extensions&gt;<br></p><p>That document originates from a mailing list post made some time ago, and is a decent overview as to what sorts of type system features the Swift core developers are interested in building.<br></p><p>Best,<br>Austin<br></p><p>&gt; On Jun 4, 2016, at 2:12 PM, Dan Zimmerman via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hey,<br>&gt; <br>&gt; I was interested in adopting the ability for a type that&#39;s generic in some sense (either via generics or via associated types, in the case of protocols) to conform to other protocols conditionally based on its type parameter/associated type. For example:<br>&gt; <br>&gt; ```<br>&gt; extension CollectionType: Equatable where Generator.Element: Equatable {}<br>&gt; <br>&gt; func ==&lt;Collection: CollectionType where Collection.Generator.Element: Equatable&gt;(left: Collection, right: Collection) -&gt; Bool {<br>&gt;  return zip(left, right).reduce(true) { accumulator, tuple in accumulator &amp;&amp; (tuple.0 == tuple.1) }<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; If this has already been proposed and knocked out/accepted please direct me to the right place.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160604/337fa6f5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d1b8a67b310b1a2bb0de75b08159b2a8?s=50"></div><header><strong>[Proposal] Conditional Conformance on Protocols/Generic Types</strong> from <string>Dan Zimmerman</string> &lt;daniel.zimmerman at me.com&gt;<p>June  4, 2016 at 04:00:00pm</p></header><div class="content"><p>Hey- <br>Thanks for the quick response and for pointing me in the right direction!<br></p><p>Dan<br></p><p>&gt; On Jun 4, 2016, at 4:18 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; Hello Dan,<br>&gt; <br>&gt; You&#39;ll be pleased to learn that conforming generic types conditionally to protocols is on the roadmap (and is one of the highest priority items for the versions of Swift following 3.0): https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances- &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-&gt;<br>&gt; <br>&gt; However, it&#39;s unlikely that protocols will gain conditional conformance: https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-via-protocol-extensions &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-via-protocol-extensions&gt;<br>&gt; <br>&gt; That document originates from a mailing list post made some time ago, and is a decent overview as to what sorts of type system features the Swift core developers are interested in building.<br>&gt; <br>&gt; Best,<br>&gt; Austin<br>&gt; <br>&gt;&gt; On Jun 4, 2016, at 2:12 PM, Dan Zimmerman via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hey,<br>&gt;&gt; <br>&gt;&gt; I was interested in adopting the ability for a type that&#39;s generic in some sense (either via generics or via associated types, in the case of protocols) to conform to other protocols conditionally based on its type parameter/associated type. For example:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; extension CollectionType: Equatable where Generator.Element: Equatable {}<br>&gt;&gt; <br>&gt;&gt; func ==&lt;Collection: CollectionType where Collection.Generator.Element: Equatable&gt;(left: Collection, right: Collection) -&gt; Bool {<br>&gt;&gt;  return zip(left, right).reduce(true) { accumulator, tuple in accumulator &amp;&amp; (tuple.0 == tuple.1) }<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; If this has already been proposed and knocked out/accepted please direct me to the right place.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160604/4d52d471/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Proposal] Conditional Conformance on Protocols/Generic Types</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>June  5, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; Am 04.06.2016 um 23:18 schrieb Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Hello Dan,<br>&gt; <br>&gt; You&#39;ll be pleased to learn that conforming generic types conditionally to protocols is on the roadmap (and is one of the highest priority items for the versions of Swift following 3.0): https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances- &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-&gt;<br>&gt; <br>&gt; However, it&#39;s unlikely that protocols will gain conditional conformance: https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-via-protocol-extensions &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-via-protocol-extensions&gt;<br>&quot;However, similar to private conformances, it puts a major burden on the dynamic-casting runtime to chase down arbitrarily long and potentially cyclic chains of conformances, which makes efficient implementation nearly impossible.“<br></p><p>I’ve been wondering what the problem with the implementation is. I mean instead of using an extension the same conformance could have been declared beforehand, i.e. instead of<br></p><p>protocol P { func foo() }<br>protocol Q { func bar() }<br>extension Q : P { func foo() { bar() } }<br></p><p>we could have written the allowed<br></p><p>protocol P { func foo() }<br>protocol Q : P { func foo() { bar() } }<br></p><p>with the exact same effect.<br></p><p>The only difference would be that the extension might have been in another module than Q. <br>Is having to cross module boundaries causing the cited problems? Would the same problems exist if in the second example Q would be defined in another module?<br></p><p>-Thorsten<br></p><p><br>&gt; <br>&gt; That document originates from a mailing list post made some time ago, and is a decent overview as to what sorts of type system features the Swift core developers are interested in building.<br>&gt; <br>&gt; Best,<br>&gt; Austin<br>&gt; <br>&gt;&gt; On Jun 4, 2016, at 2:12 PM, Dan Zimmerman via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hey,<br>&gt;&gt; <br>&gt;&gt; I was interested in adopting the ability for a type that&#39;s generic in some sense (either via generics or via associated types, in the case of protocols) to conform to other protocols conditionally based on its type parameter/associated type. For example:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; extension CollectionType: Equatable where Generator.Element: Equatable {}<br>&gt;&gt; <br>&gt;&gt; func ==&lt;Collection: CollectionType where Collection.Generator.Element: Equatable&gt;(left: Collection, right: Collection) -&gt; Bool {<br>&gt;&gt;  return zip(left, right).reduce(true) { accumulator, tuple in accumulator &amp;&amp; (tuple.0 == tuple.1) }<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; If this has already been proposed and knocked out/accepted please direct me to the right place.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160605/ed883af3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Proposal] Conditional Conformance on Protocols/Generic Types</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  5, 2016 at 12:00:00pm</p></header><div class="content"><p>The issue is to decide on the applicability scope. Thinking &#39;my app/their stuff&#39; is an illusion. To the compiler &amp; runtime there is only code split into modules, some in source code and others as dylibs (.dll, .so, ...). Any extension based conditional refines a protocol everywhere. What&#39;s hard is to compute the complete effects of these changes predictably, reliably and fast. Because when we consider &#39;but look, i have a single small extension&#39;, the compiler&amp;runtime must be ready to deal symetrically with anything we throw at it. They can&#39;t start building 15 different ways the compute the side effects based on many different scenarios because it will be un-ruly code, and too complex to try to explain to us what we will see.<br>The circular redefinitions case is one of the knightmares that hides in there... would mean having to assign priority to scopes, when there is no scopes yet. At the moment, the binary conformance table contains records for 3 types of conformances. First step would be to add a new type to match extension based conformance, and then record where it came from, and add some priority scheme to be able to navigate any conformance chain(remember that the pb grows everytime we decide &#39;oh cool, lets use a Padleft module rather than write my own 15 lines to do it - see the recent pb with nodejs). Not a simple task even with time, which they do not have now.<br></p><p>@core_team i know this is a coarse explanation, but hopefully at least in the right ballpark.<br></p><p>&gt; On Jun 5, 2016, at 9:49 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Am 04.06.2016 um 23:18 schrieb Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; Hello Dan,<br>&gt;&gt; <br>&gt;&gt; You&#39;ll be pleased to learn that conforming generic types conditionally to protocols is on the roadmap (and is one of the highest priority items for the versions of Swift following 3.0): https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-<br>&gt;&gt; <br>&gt;&gt; However, it&#39;s unlikely that protocols will gain conditional conformance: https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-via-protocol-extensions<br>&gt; <br>&gt; &quot;However, similar to private conformances, it puts a major burden on the dynamic-casting runtime to chase down arbitrarily long and potentially cyclic chains of conformances, which makes efficient implementation nearly impossible.“<br>&gt; <br>&gt; I’ve been wondering what the problem with the implementation is. I mean instead of using an extension the same conformance could have been declared beforehand, i.e. instead of<br>&gt; <br>&gt; protocol P { func foo() }<br>&gt; protocol Q { func bar() }<br>&gt; extension Q : P { func foo() { bar() } }<br>&gt; <br>&gt; we could have written the allowed<br>&gt; <br>&gt; protocol P { func foo() }<br>&gt; protocol Q : P { func foo() { bar() } }<br>&gt; <br>&gt; with the exact same effect.<br>&gt; <br>&gt; The only difference would be that the extension might have been in another module than Q. <br>&gt; Is having to cross module boundaries causing the cited problems? Would the same problems exist if in the second example Q would be defined in another module?<br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; That document originates from a mailing list post made some time ago, and is a decent overview as to what sorts of type system features the Swift core developers are interested in building.<br>&gt;&gt; <br>&gt;&gt; Best,<br>&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 4, 2016, at 2:12 PM, Dan Zimmerman via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hey,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I was interested in adopting the ability for a type that&#39;s generic in some sense (either via generics or via associated types, in the case of protocols) to conform to other protocols conditionally based on its type parameter/associated type. For example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; extension CollectionType: Equatable where Generator.Element: Equatable {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func ==&lt;Collection: CollectionType where Collection.Generator.Element: Equatable&gt;(left: Collection, right: Collection) -&gt; Bool {<br>&gt;&gt;&gt;  return zip(left, right).reduce(true) { accumulator, tuple in accumulator &amp;&amp; (tuple.0 == tuple.1) }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If this has already been proposed and knocked out/accepted please direct me to the right place.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160605/8feeaee1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal] Conditional Conformance on Protocols/Generic Types</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>June  6, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jun 5, 2016, at 3:24 AM, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The issue is to decide on the applicability scope. Thinking &#39;my app/their stuff&#39; is an illusion. To the compiler &amp; runtime there is only code split into modules, some in source code and others as dylibs (.dll, .so, ...). Any extension based conditional refines a protocol everywhere. What&#39;s hard is to compute the complete effects of these changes predictably, reliably and fast. Because when we consider &#39;but look, i have a single small extension&#39;, the compiler&amp;runtime must be ready to deal symetrically with anything we throw at it. They can&#39;t start building 15 different ways the compute the side effects based on many different scenarios because it will be un-ruly code, and too complex to try to explain to us what we will see.<br>&gt; The circular redefinitions case is one of the knightmares that hides in there... would mean having to assign priority to scopes, when there is no scopes yet. At the moment, the binary conformance table contains records for 3 types of conformances. First step would be to add a new type to match extension based conformance, and then record where it came from, and add some priority scheme to be able to navigate any conformance chain(remember that the pb grows everytime we decide &#39;oh cool, lets use a Padleft module rather than write my own 15 lines to do it - see the recent pb with nodejs). Not a simple task even with time, which they do not have now.<br>&gt; <br>&gt; @core_team i know this is a coarse explanation, but hopefully at least in the right ballpark.<br></p><p>Roughly, yes. The specific problem regards answering the question “where must the runtime look to determine whether a given type X conforms to protocol P?”. Right now, the runtime conceptually needs to look:<br></p><p>	1) Into a list of known protocol conformances for the type X, and<br>	2) If X is a class type, the list of known protocol conformances for the superclass of X (recursively)<br></p><p>If we add the ability for a protocol extension to add a conformance to another protocol, add to that:<br></p><p>	3) Into the list of protocol extensions of other protocols Q that provide conformance to P<br></p><p>That’s a fairly significant expansion, and for each of the protocol extensions in (3), we need to evaluate whether X conforms to the extended protocol Q (and any additional constraints placed on that protocol extension).<br></p><p>	- Doug<br></p><p><br>&gt; <br>&gt; On Jun 5, 2016, at 9:49 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Am 04.06.2016 um 23:18 schrieb Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello Dan,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You&#39;ll be pleased to learn that conforming generic types conditionally to protocols is on the roadmap (and is one of the highest priority items for the versions of Swift following 3.0): https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances- &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However, it&#39;s unlikely that protocols will gain conditional conformance: https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-via-protocol-extensions &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-via-protocol-extensions&gt;<br>&gt;&gt; &quot;However, similar to private conformances, it puts a major burden on the dynamic-casting runtime to chase down arbitrarily long and potentially cyclic chains of conformances, which makes efficient implementation nearly impossible.“<br>&gt;&gt; <br>&gt;&gt; I’ve been wondering what the problem with the implementation is. I mean instead of using an extension the same conformance could have been declared beforehand, i.e. instead of<br>&gt;&gt; <br>&gt;&gt; protocol P { func foo() }<br>&gt;&gt; protocol Q { func bar() }<br>&gt;&gt; extension Q : P { func foo() { bar() } }<br>&gt;&gt; <br>&gt;&gt; we could have written the allowed<br>&gt;&gt; <br>&gt;&gt; protocol P { func foo() }<br>&gt;&gt; protocol Q : P { func foo() { bar() } }<br>&gt;&gt; <br>&gt;&gt; with the exact same effect.<br>&gt;&gt; <br>&gt;&gt; The only difference would be that the extension might have been in another module than Q. <br>&gt;&gt; Is having to cross module boundaries causing the cited problems? Would the same problems exist if in the second example Q would be defined in another module?<br>&gt;&gt; <br>&gt;&gt; -Thorsten<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That document originates from a mailing list post made some time ago, and is a decent overview as to what sorts of type system features the Swift core developers are interested in building.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Best,<br>&gt;&gt;&gt; Austin<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 4, 2016, at 2:12 PM, Dan Zimmerman via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hey,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I was interested in adopting the ability for a type that&#39;s generic in some sense (either via generics or via associated types, in the case of protocols) to conform to other protocols conditionally based on its type parameter/associated type. For example:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; extension CollectionType: Equatable where Generator.Element: Equatable {}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func ==&lt;Collection: CollectionType where Collection.Generator.Element: Equatable&gt;(left: Collection, right: Collection) -&gt; Bool {<br>&gt;&gt;&gt;&gt;  return zip(left, right).reduce(true) { accumulator, tuple in accumulator &amp;&amp; (tuple.0 == tuple.1) }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If this has already been proposed and knocked out/accepted please direct me to the right place.<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160606/2722c774/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Proposal] Conditional Conformance on Protocols/Generic Types</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>June  6, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; Am 06.06.2016 um 18:51 schrieb Douglas Gregor &lt;dgregor at apple.com&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 5, 2016, at 3:24 AM, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The issue is to decide on the applicability scope. Thinking &#39;my app/their stuff&#39; is an illusion. To the compiler &amp; runtime there is only code split into modules, some in source code and others as dylibs (.dll, .so, ...). Any extension based conditional refines a protocol everywhere. What&#39;s hard is to compute the complete effects of these changes predictably, reliably and fast. Because when we consider &#39;but look, i have a single small extension&#39;, the compiler&amp;runtime must be ready to deal symetrically with anything we throw at it. They can&#39;t start building 15 different ways the compute the side effects based on many different scenarios because it will be un-ruly code, and too complex to try to explain to us what we will see.<br>&gt;&gt; The circular redefinitions case is one of the knightmares that hides in there... would mean having to assign priority to scopes, when there is no scopes yet. At the moment, the binary conformance table contains records for 3 types of conformances. First step would be to add a new type to match extension based conformance, and then record where it came from, and add some priority scheme to be able to navigate any conformance chain(remember that the pb grows everytime we decide &#39;oh cool, lets use a Padleft module rather than write my own 15 lines to do it - see the recent pb with nodejs). Not a simple task even with time, which they do not have now.<br>&gt;&gt; <br>&gt;&gt; @core_team i know this is a coarse explanation, but hopefully at least in the right ballpark.<br>&gt; <br>&gt; Roughly, yes. The specific problem regards answering the question “where must the runtime look to determine whether a given type X conforms to protocol P?”. Right now, the runtime conceptually needs to look:<br>&gt; <br>&gt; 	1) Into a list of known protocol conformances for the type X, and<br>&gt; 	2) If X is a class type, the list of known protocol conformances for the superclass of X (recursively)<br>&gt; <br>&gt; If we add the ability for a protocol extension to add a conformance to another protocol, add to that:<br>&gt; <br>&gt; 	3) Into the list of protocol extensions of other protocols Q that provide conformance to P<br></p><p>So, the difference is that in the case<br></p><p>protocol P { ... }<br>protocol Q : P { ... }<br>struct X : Q {...}<br></p><p>X&#39;s list of known protocol conformances already contains Q and P, <br>whereas in the case<br></p><p>protocol P { ... }<br>protocol Q { ... }<br>struct X : Q {...}<br>extension Q : P<br></p><p>X&#39;s list of known protocol conformances just contains Q and is not extended by P as a result of the extension?<br>Did I understand this right? Is that (not being able to extend the conformance lists of all types as a result of an extension) a restriction of having module boundaries? Or is it simply not feasible for other reasons?<br></p><p>-Thorsten <br></p><p><br>&gt; <br>&gt; That’s a fairly significant expansion, and for each of the protocol extensions in (3), we need to evaluate whether X conforms to the extended protocol Q (and any additional constraints placed on that protocol extension).<br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jun 5, 2016, at 9:49 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 04.06.2016 um 23:18 schrieb Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hello Dan,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You&#39;ll be pleased to learn that conforming generic types conditionally to protocols is on the roadmap (and is one of the highest priority items for the versions of Swift following 3.0): https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; However, it&#39;s unlikely that protocols will gain conditional conformance: https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-via-protocol-extensions<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &quot;However, similar to private conformances, it puts a major burden on the dynamic-casting runtime to chase down arbitrarily long and potentially cyclic chains of conformances, which makes efficient implementation nearly impossible.“<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’ve been wondering what the problem with the implementation is. I mean instead of using an extension the same conformance could have been declared beforehand, i.e. instead of<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol P { func foo() }<br>&gt;&gt;&gt; protocol Q { func bar() }<br>&gt;&gt;&gt; extension Q : P { func foo() { bar() } }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; we could have written the allowed<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol P { func foo() }<br>&gt;&gt;&gt; protocol Q : P { func foo() { bar() } }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; with the exact same effect.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The only difference would be that the extension might have been in another module than Q. <br>&gt;&gt;&gt; Is having to cross module boundaries causing the cited problems? Would the same problems exist if in the second example Q would be defined in another module?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That document originates from a mailing list post made some time ago, and is a decent overview as to what sorts of type system features the Swift core developers are interested in building.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Best,<br>&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 4, 2016, at 2:12 PM, Dan Zimmerman via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hey,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I was interested in adopting the ability for a type that&#39;s generic in some sense (either via generics or via associated types, in the case of protocols) to conform to other protocols conditionally based on its type parameter/associated type. For example:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt; extension CollectionType: Equatable where Generator.Element: Equatable {}<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func ==&lt;Collection: CollectionType where Collection.Generator.Element: Equatable&gt;(left: Collection, right: Collection) -&gt; Bool {<br>&gt;&gt;&gt;&gt;&gt;  return zip(left, right).reduce(true) { accumulator, tuple in accumulator &amp;&amp; (tuple.0 == tuple.1) }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If this has already been proposed and knocked out/accepted please direct me to the right place.<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160606/7ce22ca6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal] Conditional Conformance on Protocols/Generic Types</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>June  6, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jun 6, 2016, at 12:12 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Am 06.06.2016 um 18:51 schrieb Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt;:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 5, 2016, at 3:24 AM, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The issue is to decide on the applicability scope. Thinking &#39;my app/their stuff&#39; is an illusion. To the compiler &amp; runtime there is only code split into modules, some in source code and others as dylibs (.dll, .so, ...). Any extension based conditional refines a protocol everywhere. What&#39;s hard is to compute the complete effects of these changes predictably, reliably and fast. Because when we consider &#39;but look, i have a single small extension&#39;, the compiler&amp;runtime must be ready to deal symetrically with anything we throw at it. They can&#39;t start building 15 different ways the compute the side effects based on many different scenarios because it will be un-ruly code, and too complex to try to explain to us what we will see.<br>&gt;&gt;&gt; The circular redefinitions case is one of the knightmares that hides in there... would mean having to assign priority to scopes, when there is no scopes yet. At the moment, the binary conformance table contains records for 3 types of conformances. First step would be to add a new type to match extension based conformance, and then record where it came from, and add some priority scheme to be able to navigate any conformance chain(remember that the pb grows everytime we decide &#39;oh cool, lets use a Padleft module rather than write my own 15 lines to do it - see the recent pb with nodejs). Not a simple task even with time, which they do not have now.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; @core_team i know this is a coarse explanation, but hopefully at least in the right ballpark.<br>&gt;&gt; <br>&gt;&gt; Roughly, yes. The specific problem regards answering the question “where must the runtime look to determine whether a given type X conforms to protocol P?”. Right now, the runtime conceptually needs to look:<br>&gt;&gt; <br>&gt;&gt; 	1) Into a list of known protocol conformances for the type X, and<br>&gt;&gt; 	2) If X is a class type, the list of known protocol conformances for the superclass of X (recursively)<br>&gt;&gt; <br>&gt;&gt; If we add the ability for a protocol extension to add a conformance to another protocol, add to that:<br>&gt;&gt; <br>&gt;&gt; 	3) Into the list of protocol extensions of other protocols Q that provide conformance to P<br>&gt; <br>&gt; So, the difference is that in the case<br>&gt; <br>&gt; protocol P { ... }<br>&gt; protocol Q : P { ... }<br>&gt; struct X : Q {...}<br>&gt; <br>&gt; X&#39;s list of known protocol conformances already contains Q and P, <br>&gt; whereas in the case<br>&gt; <br>&gt; protocol P { ... }<br>&gt; protocol Q { ... }<br>&gt; struct X : Q {...}<br>&gt; extension Q : P<br>&gt; <br>&gt; X&#39;s list of known protocol conformances just contains Q and is not extended by P as a result of the extension?<br>&gt; Did I understand this right?<br></p><p>Yes, that’s correct.<br></p><p>&gt; Is that (not being able to extend the conformance lists of all types as a result of an extension) a restriction of having module boundaries?<br></p><p>Effectively, yes: you can’t simply enumerate all of the cases because some other module might add a new types/protocol extensions/conformances. It has to be dynamically discoverable.<br></p><p>&gt; Or is it simply not feasible for other reasons?<br></p><p>It’s feasible, in the sense that it can be implemented. The concern is that it’s potentially very expensive, and is very likely to introduce ambiguities where there are two different protocol conformances to satisfy the query “X conforms to P”.<br></p><p>	- Doug<br></p><p>&gt; <br>&gt; -Thorsten <br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; That’s a fairly significant expansion, and for each of the protocol extensions in (3), we need to evaluate whether X conforms to the extended protocol Q (and any additional constraints placed on that protocol extension).<br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jun 5, 2016, at 9:49 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 04.06.2016 um 23:18 schrieb Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hello Dan,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; You&#39;ll be pleased to learn that conforming generic types conditionally to protocols is on the roadmap (and is one of the highest priority items for the versions of Swift following 3.0): https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances- &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; However, it&#39;s unlikely that protocols will gain conditional conformance: https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-via-protocol-extensions &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-via-protocol-extensions&gt;<br>&gt;&gt;&gt;&gt; &quot;However, similar to private conformances, it puts a major burden on the dynamic-casting runtime to chase down arbitrarily long and potentially cyclic chains of conformances, which makes efficient implementation nearly impossible.“<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’ve been wondering what the problem with the implementation is. I mean instead of using an extension the same conformance could have been declared beforehand, i.e. instead of<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol P { func foo() }<br>&gt;&gt;&gt;&gt; protocol Q { func bar() }<br>&gt;&gt;&gt;&gt; extension Q : P { func foo() { bar() } }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; we could have written the allowed<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol P { func foo() }<br>&gt;&gt;&gt;&gt; protocol Q : P { func foo() { bar() } }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; with the exact same effect.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The only difference would be that the extension might have been in another module than Q. <br>&gt;&gt;&gt;&gt; Is having to cross module boundaries causing the cited problems? Would the same problems exist if in the second example Q would be defined in another module?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That document originates from a mailing list post made some time ago, and is a decent overview as to what sorts of type system features the Swift core developers are interested in building.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Best,<br>&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 4, 2016, at 2:12 PM, Dan Zimmerman via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Hey,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I was interested in adopting the ability for a type that&#39;s generic in some sense (either via generics or via associated types, in the case of protocols) to conform to other protocols conditionally based on its type parameter/associated type. For example:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt; extension CollectionType: Equatable where Generator.Element: Equatable {}<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func ==&lt;Collection: CollectionType where Collection.Generator.Element: Equatable&gt;(left: Collection, right: Collection) -&gt; Bool {<br>&gt;&gt;&gt;&gt;&gt;&gt;  return zip(left, right).reduce(true) { accumulator, tuple in accumulator &amp;&amp; (tuple.0 == tuple.1) }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If this has already been proposed and knocked out/accepted please direct me to the right place.<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160606/09e6d987/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Proposal] Conditional Conformance on Protocols/Generic Types</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  6, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Jun 6, 2016, at 9:34 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 6, 2016, at 12:12 PM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Am 06.06.2016 um 18:51 schrieb Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 5, 2016, at 3:24 AM, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The issue is to decide on the applicability scope. Thinking &#39;my app/their stuff&#39; is an illusion. To the compiler &amp; runtime there is only code split into modules, some in source code and others as dylibs (.dll, .so, ...). Any extension based conditional refines a protocol everywhere. What&#39;s hard is to compute the complete effects of these changes predictably, reliably and fast. Because when we consider &#39;but look, i have a single small extension&#39;, the compiler&amp;runtime must be ready to deal symetrically with anything we throw at it. They can&#39;t start building 15 different ways the compute the side effects based on many different scenarios because it will be un-ruly code, and too complex to try to explain to us what we will see.<br>&gt;&gt;&gt;&gt; The circular redefinitions case is one of the knightmares that hides in there... would mean having to assign priority to scopes, when there is no scopes yet. At the moment, the binary conformance table contains records for 3 types of conformances. First step would be to add a new type to match extension based conformance, and then record where it came from, and add some priority scheme to be able to navigate any conformance chain(remember that the pb grows everytime we decide &#39;oh cool, lets use a Padleft module rather than write my own 15 lines to do it - see the recent pb with nodejs). Not a simple task even with time, which they do not have now.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; @core_team i know this is a coarse explanation, but hopefully at least in the right ballpark.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Roughly, yes. The specific problem regards answering the question “where must the runtime look to determine whether a given type X conforms to protocol P?”. Right now, the runtime conceptually needs to look:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	1) Into a list of known protocol conformances for the type X, and<br>&gt;&gt;&gt; 	2) If X is a class type, the list of known protocol conformances for the superclass of X (recursively)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If we add the ability for a protocol extension to add a conformance to another protocol, add to that:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	3) Into the list of protocol extensions of other protocols Q that provide conformance to P<br>&gt;&gt; <br>&gt;&gt; So, the difference is that in the case<br>&gt;&gt; <br>&gt;&gt; protocol P { ... }<br>&gt;&gt; protocol Q : P { ... }<br>&gt;&gt; struct X : Q {...}<br>&gt;&gt; <br>&gt;&gt; X&#39;s list of known protocol conformances already contains Q and P, <br>&gt;&gt; whereas in the case<br>&gt;&gt; <br>&gt;&gt; protocol P { ... }<br>&gt;&gt; protocol Q { ... }<br>&gt;&gt; struct X : Q {...}<br>&gt;&gt; extension Q : P<br>&gt;&gt; <br>&gt;&gt; X&#39;s list of known protocol conformances just contains Q and is not extended by P as a result of the extension?<br>&gt;&gt; Did I understand this right?<br>&gt; <br>&gt; Yes, that’s correct.<br>&gt; <br>&gt;&gt; Is that (not being able to extend the conformance lists of all types as a result of an extension) a restriction of having module boundaries?<br>&gt; <br>&gt; Effectively, yes: you can’t simply enumerate all of the cases because some other module might add a new types/protocol extensions/conformances. It has to be dynamically discoverable.<br></p><p>yes… for each new module added to a known mix, the final conformances list can be completely different. <br></p><p>&gt; <br>&gt;&gt; Or is it simply not feasible for other reasons?<br>&gt; <br>&gt; It’s feasible, in the sense that it can be implemented. The concern is that it’s potentially very expensive, and is very likely to introduce ambiguities where there are two different protocol conformances to satisfy the query “X conforms to P”.<br></p><p>that’s what I thought would motivate some sort of prioritization scheme.. but I guess (or judge from experience with the static/dynsmic dispatch story with extensions, or the so called ‘defender’ methods in java) anytime one scheme is picked, there are people to question that it is the right one. Then I keep circling back to the idea of being able to subdivide a module into separate sections (call-em namespace or submodule) which would limit the scope of conformance baring extensions. From a 10mile high view, I thought the the current TEXT segments could be duplicated (one per namespace/submodule), leaving the current one to be the de-facto module’s namespace. Granted it would complicate the loading code, it would not destroy whole-module optimization. Alternatively it would be nice if Xcode was retrofitted with a simple support for creating quartz-like module-inside-module structures. But either way, we circle back to defining a type hierarchy to simplify the problem… which is usually summarized by layers as “do not ask a question for which you do not know the answer”… chasing a compliance chain can be a open-ended problem as people would become more daring with the feature and projects would rely on more and more pre-canned modules.<br></p><p>thank you for your patient explanations.<br></p><p>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt;&gt; <br>&gt;&gt; -Thorsten <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That’s a fairly significant expansion, and for each of the protocol extensions in (3), we need to evaluate whether X conforms to the extended protocol Q (and any additional constraints placed on that protocol extension).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 5, 2016, at 9:49 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Am 04.06.2016 um 23:18 schrieb Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Hello Dan,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; You&#39;ll be pleased to learn that conforming generic types conditionally to protocols is on the roadmap (and is one of the highest priority items for the versions of Swift following 3.0): https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances- &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; However, it&#39;s unlikely that protocols will gain conditional conformance: https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-via-protocol-extensions &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-via-protocol-extensions&gt;<br>&gt;&gt;&gt;&gt;&gt; &quot;However, similar to private conformances, it puts a major burden on the dynamic-casting runtime to chase down arbitrarily long and potentially cyclic chains of conformances, which makes efficient implementation nearly impossible.“<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’ve been wondering what the problem with the implementation is. I mean instead of using an extension the same conformance could have been declared beforehand, i.e. instead of<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; protocol P { func foo() }<br>&gt;&gt;&gt;&gt;&gt; protocol Q { func bar() }<br>&gt;&gt;&gt;&gt;&gt; extension Q : P { func foo() { bar() } }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; we could have written the allowed<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; protocol P { func foo() }<br>&gt;&gt;&gt;&gt;&gt; protocol Q : P { func foo() { bar() } }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; with the exact same effect.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The only difference would be that the extension might have been in another module than Q. <br>&gt;&gt;&gt;&gt;&gt; Is having to cross module boundaries causing the cited problems? Would the same problems exist if in the second example Q would be defined in another module?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; That document originates from a mailing list post made some time ago, and is a decent overview as to what sorts of type system features the Swift core developers are interested in building.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Best,<br>&gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160606/4836fdde/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Proposal] Conditional Conformance on Protocols/Generic Types</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>June  7, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; Am 06.06.2016 um 22:13 schrieb L Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt;:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Jun 6, 2016, at 9:34 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jun 6, 2016, at 12:12 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 06.06.2016 um 18:51 schrieb Douglas Gregor &lt;dgregor at apple.com&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 5, 2016, at 3:24 AM, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The issue is to decide on the applicability scope. Thinking &#39;my app/their stuff&#39; is an illusion. To the compiler &amp; runtime there is only code split into modules, some in source code and others as dylibs (.dll, .so, ...). Any extension based conditional refines a protocol everywhere. What&#39;s hard is to compute the complete effects of these changes predictably, reliably and fast. Because when we consider &#39;but look, i have a single small extension&#39;, the compiler&amp;runtime must be ready to deal symetrically with anything we throw at it. They can&#39;t start building 15 different ways the compute the side effects based on many different scenarios because it will be un-ruly code, and too complex to try to explain to us what we will see.<br>&gt;&gt;&gt;&gt;&gt; The circular redefinitions case is one of the knightmares that hides in there... would mean having to assign priority to scopes, when there is no scopes yet. At the moment, the binary conformance table contains records for 3 types of conformances. First step would be to add a new type to match extension based conformance, and then record where it came from, and add some priority scheme to be able to navigate any conformance chain(remember that the pb grows everytime we decide &#39;oh cool, lets use a Padleft module rather than write my own 15 lines to do it - see the recent pb with nodejs). Not a simple task even with time, which they do not have now.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; @core_team i know this is a coarse explanation, but hopefully at least in the right ballpark.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Roughly, yes. The specific problem regards answering the question “where must the runtime look to determine whether a given type X conforms to protocol P?”. Right now, the runtime conceptually needs to look:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	1) Into a list of known protocol conformances for the type X, and<br>&gt;&gt;&gt;&gt; 	2) If X is a class type, the list of known protocol conformances for the superclass of X (recursively)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If we add the ability for a protocol extension to add a conformance to another protocol, add to that:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	3) Into the list of protocol extensions of other protocols Q that provide conformance to P<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So, the difference is that in the case<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol P { ... }<br>&gt;&gt;&gt; protocol Q : P { ... }<br>&gt;&gt;&gt; struct X : Q {...}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; X&#39;s list of known protocol conformances already contains Q and P, <br>&gt;&gt;&gt; whereas in the case<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol P { ... }<br>&gt;&gt;&gt; protocol Q { ... }<br>&gt;&gt;&gt; struct X : Q {...}<br>&gt;&gt;&gt; extension Q : P<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; X&#39;s list of known protocol conformances just contains Q and is not extended by P as a result of the extension?<br>&gt;&gt;&gt; Did I understand this right?<br>&gt;&gt; <br>&gt;&gt; Yes, that’s correct.<br>&gt;&gt; <br>&gt;&gt;&gt; Is that (not being able to extend the conformance lists of all types as a result of an extension) a restriction of having module boundaries?<br>&gt;&gt; <br>&gt;&gt; Effectively, yes: you can’t simply enumerate all of the cases because some other module might add a new types/protocol extensions/conformances. It has to be dynamically discoverable.<br>&gt; <br>&gt; yes… for each new module added to a known mix, the final conformances list can be completely different. <br></p><p>But this is information known at compile time and does not have to be determined at runtime. <br>An extension should be only effective in the module in which it is defined and in modules using that module. All of these get to know the extension at compile time.<br>There should be no need to have extensions affect modules that do not see them. This should be similar to the Classboxes module system proposed for Smalltalk (http://scg.unibe.ch/research/classboxes) AFAIR.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Or is it simply not feasible for other reasons?<br>&gt;&gt; <br>&gt;&gt; It’s feasible, in the sense that it can be implemented. The concern is that it’s potentially very expensive, and is very likely to introduce ambiguities where there are two different protocol conformances to satisfy the query “X conforms to P”.<br></p><p>Ambiguities should have to be solved at compile time by the programmer. I&#39;m not a fan of fancy ordering schemes e.g. for Mixins but prefer manual resolvement which makes it understandable what happens. Cecil from the University of Washington did that well (http://www.cs.washington.edu/research/projects/cecil/pubs/).<br></p><p>&gt; <br>&gt; that’s what I thought would motivate some sort of prioritization scheme.. but I guess (or judge from experience with the static/dynsmic dispatch story with extensions, or the so called ‘defender’ methods in java) anytime one scheme is picked, there are people to question that it is the right one. Then I keep circling back to the idea of being able to subdivide a module into separate sections (call-em namespace or submodule) which would limit the scope of conformance baring extensions. From a 10mile high view, I thought the the current TEXT segments could be duplicated (one per namespace/submodule), leaving the current one to be the de-facto module’s namespace. Granted it would complicate the loading code, it would not destroy whole-module optimization. Alternatively it would be nice if Xcode was retrofitted with a simple support for creating quartz-like module-inside-module structures. But either way, we circle back to defining a type hierarchy to simplify the problem… which is usually summarized by layers as “do not ask a question for which you do not know the answer”… chasing a compliance chain can be a open-ended problem as people would become more daring with the feature and projects would rely on more and more pre-canned modules.<br>&gt; <br>&gt; thank you for your patient explanations.<br></p><p>Many thanks from me as well. I, too, appreciate that very much!<br></p><p>-Thorsten <br></p><p><br>&gt; <br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That’s a fairly significant expansion, and for each of the protocol extensions in (3), we need to evaluate whether X conforms to the extended protocol Q (and any additional constraints placed on that protocol extension).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 5, 2016, at 9:49 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 04.06.2016 um 23:18 schrieb Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello Dan,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; You&#39;ll be pleased to learn that conforming generic types conditionally to protocols is on the roadmap (and is one of the highest priority items for the versions of Swift following 3.0): https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; However, it&#39;s unlikely that protocols will gain conditional conformance: https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-via-protocol-extensions<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &quot;However, similar to private conformances, it puts a major burden on the dynamic-casting runtime to chase down arbitrarily long and potentially cyclic chains of conformances, which makes efficient implementation nearly impossible.“<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I’ve been wondering what the problem with the implementation is. I mean instead of using an extension the same conformance could have been declared beforehand, i.e. instead of<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; protocol P { func foo() }<br>&gt;&gt;&gt;&gt;&gt;&gt; protocol Q { func bar() }<br>&gt;&gt;&gt;&gt;&gt;&gt; extension Q : P { func foo() { bar() } }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; we could have written the allowed<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; protocol P { func foo() }<br>&gt;&gt;&gt;&gt;&gt;&gt; protocol Q : P { func foo() { bar() } }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; with the exact same effect.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The only difference would be that the extension might have been in another module than Q. <br>&gt;&gt;&gt;&gt;&gt;&gt; Is having to cross module boundaries causing the cited problems? Would the same problems exist if in the second example Q would be defined in another module?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; That document originates from a mailing list post made some time ago, and is a decent overview as to what sorts of type system features the Swift core developers are interested in building.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Best,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160607/45f24c6f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal] Conditional Conformance on Protocols/Generic Types</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>June  6, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Jun 6, 2016, at 10:08 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Am 06.06.2016 um 22:13 schrieb L Mihalkovic &lt;laurent.mihalkovic at gmail.com &lt;mailto:laurent.mihalkovic at gmail.com&gt;&gt;:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 6, 2016, at 9:34 PM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 6, 2016, at 12:12 PM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 06.06.2016 um 18:51 schrieb Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 5, 2016, at 3:24 AM, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The issue is to decide on the applicability scope. Thinking &#39;my app/their stuff&#39; is an illusion. To the compiler &amp; runtime there is only code split into modules, some in source code and others as dylibs (.dll, .so, ...). Any extension based conditional refines a protocol everywhere. What&#39;s hard is to compute the complete effects of these changes predictably, reliably and fast. Because when we consider &#39;but look, i have a single small extension&#39;, the compiler&amp;runtime must be ready to deal symetrically with anything we throw at it. They can&#39;t start building 15 different ways the compute the side effects based on many different scenarios because it will be un-ruly code, and too complex to try to explain to us what we will see.<br>&gt;&gt;&gt;&gt;&gt;&gt; The circular redefinitions case is one of the knightmares that hides in there... would mean having to assign priority to scopes, when there is no scopes yet. At the moment, the binary conformance table contains records for 3 types of conformances. First step would be to add a new type to match extension based conformance, and then record where it came from, and add some priority scheme to be able to navigate any conformance chain(remember that the pb grows everytime we decide &#39;oh cool, lets use a Padleft module rather than write my own 15 lines to do it - see the recent pb with nodejs). Not a simple task even with time, which they do not have now.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; @core_team i know this is a coarse explanation, but hopefully at least in the right ballpark.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Roughly, yes. The specific problem regards answering the question “where must the runtime look to determine whether a given type X conforms to protocol P?”. Right now, the runtime conceptually needs to look:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	1) Into a list of known protocol conformances for the type X, and<br>&gt;&gt;&gt;&gt;&gt; 	2) If X is a class type, the list of known protocol conformances for the superclass of X (recursively)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If we add the ability for a protocol extension to add a conformance to another protocol, add to that:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	3) Into the list of protocol extensions of other protocols Q that provide conformance to P<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So, the difference is that in the case<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol P { ... }<br>&gt;&gt;&gt;&gt; protocol Q : P { ... }<br>&gt;&gt;&gt;&gt; struct X : Q {...}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; X&#39;s list of known protocol conformances already contains Q and P, <br>&gt;&gt;&gt;&gt; whereas in the case<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol P { ... }<br>&gt;&gt;&gt;&gt; protocol Q { ... }<br>&gt;&gt;&gt;&gt; struct X : Q {...}<br>&gt;&gt;&gt;&gt; extension Q : P<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; X&#39;s list of known protocol conformances just contains Q and is not extended by P as a result of the extension?<br>&gt;&gt;&gt;&gt; Did I understand this right?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, that’s correct.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Is that (not being able to extend the conformance lists of all types as a result of an extension) a restriction of having module boundaries?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Effectively, yes: you can’t simply enumerate all of the cases because some other module might add a new types/protocol extensions/conformances. It has to be dynamically discoverable.<br>&gt;&gt; <br>&gt;&gt; yes… for each new module added to a known mix, the final conformances list can be completely different. <br>&gt; <br>&gt; But this is information known at compile time and does not have to be determined at runtime. <br>&gt; An extension should be only effective in the module in which it is defined and in modules using that module. All of these get to know the extension at compile time.<br></p><p>That’s not the model that Swift uses today. You can discover protocol conformances introduce by modules—whether you knew about those modules at compile time (but at launch time you end up with newer versions) or whether those modules were unknown, you see the conformances. The standard library’s “print” facility depends on this behavior to find CustomStringConvertible conformances.<br></p><p>Yes, we could make it all statically determined, but IMO that’s not the direction that Swift has been going.<br></p><p>	- Doug<br></p><p>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Thorsten <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That’s a fairly significant expansion, and for each of the protocol extensions in (3), we need to evaluate whether X conforms to the extended protocol Q (and any additional constraints placed on that protocol extension).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 5, 2016, at 9:49 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 04.06.2016 um 23:18 schrieb Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello Dan,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; You&#39;ll be pleased to learn that conforming generic types conditionally to protocols is on the roadmap (and is one of the highest priority items for the versions of Swift following 3.0): https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances- &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; However, it&#39;s unlikely that protocols will gain conditional conformance: https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-via-protocol-extensions &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-via-protocol-extensions&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;However, similar to private conformances, it puts a major burden on the dynamic-casting runtime to chase down arbitrarily long and potentially cyclic chains of conformances, which makes efficient implementation nearly impossible.“<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I’ve been wondering what the problem with the implementation is. I mean instead of using an extension the same conformance could have been declared beforehand, i.e. instead of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol P { func foo() }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol Q { func bar() }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; extension Q : P { func foo() { bar() } }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; we could have written the allowed<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol P { func foo() }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol Q : P { func foo() { bar() } }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; with the exact same effect.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The only difference would be that the extension might have been in another module than Q. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Is having to cross module boundaries causing the cited problems? Would the same problems exist if in the second example Q would be defined in another module?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That document originates from a mailing list post made some time ago, and is a decent overview as to what sorts of type system features the Swift core developers are interested in building.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Best,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160606/77114949/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Proposal] Conditional Conformance on Protocols/Generic Types</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  7, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; On Jun 7, 2016, at 7:14 AM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 6, 2016, at 10:08 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Am 06.06.2016 um 22:13 schrieb L Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 6, 2016, at 9:34 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 6, 2016, at 12:12 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 06.06.2016 um 18:51 schrieb Douglas Gregor &lt;dgregor at apple.com&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 5, 2016, at 3:24 AM, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The issue is to decide on the applicability scope. Thinking &#39;my app/their stuff&#39; is an illusion. To the compiler &amp; runtime there is only code split into modules, some in source code and others as dylibs (.dll, .so, ...). Any extension based conditional refines a protocol everywhere. What&#39;s hard is to compute the complete effects of these changes predictably, reliably and fast. Because when we consider &#39;but look, i have a single small extension&#39;, the compiler&amp;runtime must be ready to deal symetrically with anything we throw at it. They can&#39;t start building 15 different ways the compute the side effects based on many different scenarios because it will be un-ruly code, and too complex to try to explain to us what we will see.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The circular redefinitions case is one of the knightmares that hides in there... would mean having to assign priority to scopes, when there is no scopes yet. At the moment, the binary conformance table contains records for 3 types of conformances. First step would be to add a new type to match extension based conformance, and then record where it came from, and add some priority scheme to be able to navigate any conformance chain(remember that the pb grows everytime we decide &#39;oh cool, lets use a Padleft module rather than write my own 15 lines to do it - see the recent pb with nodejs). Not a simple task even with time, which they do not have now.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; @core_team i know this is a coarse explanation, but hopefully at least in the right ballpark.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Roughly, yes. The specific problem regards answering the question “where must the runtime look to determine whether a given type X conforms to protocol P?”. Right now, the runtime conceptually needs to look:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	1) Into a list of known protocol conformances for the type X, and<br>&gt;&gt;&gt;&gt;&gt;&gt; 	2) If X is a class type, the list of known protocol conformances for the superclass of X (recursively)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If we add the ability for a protocol extension to add a conformance to another protocol, add to that:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	3) Into the list of protocol extensions of other protocols Q that provide conformance to P<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; So, the difference is that in the case<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; protocol P { ... }<br>&gt;&gt;&gt;&gt;&gt; protocol Q : P { ... }<br>&gt;&gt;&gt;&gt;&gt; struct X : Q {...}<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; X&#39;s list of known protocol conformances already contains Q and P, <br>&gt;&gt;&gt;&gt;&gt; whereas in the case<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; protocol P { ... }<br>&gt;&gt;&gt;&gt;&gt; protocol Q { ... }<br>&gt;&gt;&gt;&gt;&gt; struct X : Q {...}<br>&gt;&gt;&gt;&gt;&gt; extension Q : P<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; X&#39;s list of known protocol conformances just contains Q and is not extended by P as a result of the extension?<br>&gt;&gt;&gt;&gt;&gt; Did I understand this right?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, that’s correct.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Is that (not being able to extend the conformance lists of all types as a result of an extension) a restriction of having module boundaries?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Effectively, yes: you can’t simply enumerate all of the cases because some other module might add a new types/protocol extensions/conformances. It has to be dynamically discoverable.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; yes… for each new module added to a known mix, the final conformances list can be completely different. <br>&gt;&gt; <br>&gt;&gt; But this is information known at compile time and does not have to be determined at runtime. <br>&gt;&gt; An extension should be only effective in the module in which it is defined and in modules using that module. All of these get to know the extension at compile time.<br></p><p>The idea of swift 3/4 is that the stdlib ABI should be stable enough that it will be in the system rather than embedded in each app. Which means that the conformance table must be runtime discoverable from the module exporting it (in a section of the text segment), and its final effects computed by the runtime when the module gets loaded (again coarse grained expl) by each binary using it. This also lets them define new module boundaries in the system that we can transitively inherit.<br></p><p>Baking the final conformance statically into the module would leave us wondering why our code might seem to be &#39;frozen&#39; and not using newer system defined conformances. Mind you... this may not be a stupid idea at all, as it might align better with the practice of linking against specific SDKs to get a predictable level of behavior. <br></p><p>As for scope, my limited understanding of the loader is that there is no &#39;source&#39; field in these conformance records that would allow the runtime to treat them hierarchically. <br></p><p><br>&gt; <br>&gt; That’s not the model that Swift uses today. You can discover protocol conformances introduce by modules—whether you knew about those modules at compile time (but at launch time you end up with newer versions) or whether those modules were unknown, you see the conformances. The standard library’s “print” facility depends on this behavior to find CustomStringConvertible conformances.<br>&gt; <br>&gt; Yes, we could make it all statically determined, but IMO that’s not the direction that Swift has been going.<br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Thorsten <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; That’s a fairly significant expansion, and for each of the protocol extensions in (3), we need to evaluate whether X conforms to the extended protocol Q (and any additional constraints placed on that protocol extension).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 5, 2016, at 9:49 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 04.06.2016 um 23:18 schrieb Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello Dan,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; You&#39;ll be pleased to learn that conforming generic types conditionally to protocols is on the roadmap (and is one of the highest priority items for the versions of Swift following 3.0): https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; However, it&#39;s unlikely that protocols will gain conditional conformance: https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-via-protocol-extensions<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;However, similar to private conformances, it puts a major burden on the dynamic-casting runtime to chase down arbitrarily long and potentially cyclic chains of conformances, which makes efficient implementation nearly impossible.“<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I’ve been wondering what the problem with the implementation is. I mean instead of using an extension the same conformance could have been declared beforehand, i.e. instead of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol P { func foo() }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol Q { func bar() }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; extension Q : P { func foo() { bar() } }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; we could have written the allowed<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol P { func foo() }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol Q : P { func foo() { bar() } }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; with the exact same effect.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The only difference would be that the extension might have been in another module than Q. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Is having to cross module boundaries causing the cited problems? Would the same problems exist if in the second example Q would be defined in another module?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That document originates from a mailing list post made some time ago, and is a decent overview as to what sorts of type system features the Swift core developers are interested in building.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Best,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160607/65316597/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Proposal] Conditional Conformance on Protocols/Generic Types</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>June  8, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; Am 07.06.2016 um 07:55 schrieb LM &lt;laurent.mihalkovic at gmail.com&gt;:<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Jun 7, 2016, at 7:14 AM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 6, 2016, at 10:08 PM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 06.06.2016 um 22:13 schrieb L Mihalkovic &lt;laurent.mihalkovic at gmail.com &lt;mailto:laurent.mihalkovic at gmail.com&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 6, 2016, at 9:34 PM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 6, 2016, at 12:12 PM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Am 06.06.2016 um 18:51 schrieb Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 5, 2016, at 3:24 AM, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The issue is to decide on the applicability scope. Thinking &#39;my app/their stuff&#39; is an illusion. To the compiler &amp; runtime there is only code split into modules, some in source code and others as dylibs (.dll, .so, ...). Any extension based conditional refines a protocol everywhere. What&#39;s hard is to compute the complete effects of these changes predictably, reliably and fast. Because when we consider &#39;but look, i have a single small extension&#39;, the compiler&amp;runtime must be ready to deal symetrically with anything we throw at it. They can&#39;t start building 15 different ways the compute the side effects based on many different scenarios because it will be un-ruly code, and too complex to try to explain to us what we will see.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The circular redefinitions case is one of the knightmares that hides in there... would mean having to assign priority to scopes, when there is no scopes yet. At the moment, the binary conformance table contains records for 3 types of conformances. First step would be to add a new type to match extension based conformance, and then record where it came from, and add some priority scheme to be able to navigate any conformance chain(remember that the pb grows everytime we decide &#39;oh cool, lets use a Padleft module rather than write my own 15 lines to do it - see the recent pb with nodejs). Not a simple task even with time, which they do not have now.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; @core_team i know this is a coarse explanation, but hopefully at least in the right ballpark.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Roughly, yes. The specific problem regards answering the question “where must the runtime look to determine whether a given type X conforms to protocol P?”. Right now, the runtime conceptually needs to look:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	1) Into a list of known protocol conformances for the type X, and<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	2) If X is a class type, the list of known protocol conformances for the superclass of X (recursively)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; If we add the ability for a protocol extension to add a conformance to another protocol, add to that:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	3) Into the list of protocol extensions of other protocols Q that provide conformance to P<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; So, the difference is that in the case<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; protocol P { ... }<br>&gt;&gt;&gt;&gt;&gt;&gt; protocol Q : P { ... }<br>&gt;&gt;&gt;&gt;&gt;&gt; struct X : Q {...}<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; X&#39;s list of known protocol conformances already contains Q and P, <br>&gt;&gt;&gt;&gt;&gt;&gt; whereas in the case<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; protocol P { ... }<br>&gt;&gt;&gt;&gt;&gt;&gt; protocol Q { ... }<br>&gt;&gt;&gt;&gt;&gt;&gt; struct X : Q {...}<br>&gt;&gt;&gt;&gt;&gt;&gt; extension Q : P<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; X&#39;s list of known protocol conformances just contains Q and is not extended by P as a result of the extension?<br>&gt;&gt;&gt;&gt;&gt;&gt; Did I understand this right?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yes, that’s correct.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Is that (not being able to extend the conformance lists of all types as a result of an extension) a restriction of having module boundaries?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Effectively, yes: you can’t simply enumerate all of the cases because some other module might add a new types/protocol extensions/conformances. It has to be dynamically discoverable.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; yes… for each new module added to a known mix, the final conformances list can be completely different. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But this is information known at compile time and does not have to be determined at runtime. <br>&gt;&gt;&gt; An extension should be only effective in the module in which it is defined and in modules using that module. All of these get to know the extension at compile time.<br>&gt; <br>&gt; The idea of swift 3/4 is that the stdlib ABI should be stable enough that it will be in the system rather than embedded in each app. Which means that the conformance table must be runtime discoverable from the module exporting it (in a section of the text segment), and its final effects computed by the runtime when the module gets loaded (again coarse grained expl) by each binary using it. This also lets them define new module boundaries in the system that we can transitively inherit.<br>&gt; <br>&gt; Baking the final conformance statically into the module would leave us wondering why our code might seem to be &#39;frozen&#39; and not using newer system defined conformances.<br></p><p>Good argument. So that would mean that the analysis would have to be done at linking time. This (like doing it at runtime) does open a can of worms about ambiguity, though: what happens when the new system version of a library suddenly defines an extension that conflicts with an extension in our module? Seems like that such a change should be confined to the system module unless doing a recompile, so we are back to my suggestion of resolving extensions at compile time?<br></p><p>-Thorsten<br></p><p><br></p><p>&gt; Mind you... this may not be a stupid idea at all, as it might align better with the practice of linking against specific SDKs to get a predictable level of behavior. <br>&gt; <br>&gt; As for scope, my limited understanding of the loader is that there is no &#39;source&#39; field in these conformance records that would allow the runtime to treat them hierarchically. <br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; That’s not the model that Swift uses today. You can discover protocol conformances introduce by modules—whether you knew about those modules at compile time (but at launch time you end up with newer versions) or whether those modules were unknown, you see the conformances. The standard library’s “print” facility depends on this behavior to find CustomStringConvertible conformances.<br>&gt;&gt; <br>&gt;&gt; Yes, we could make it all statically determined, but IMO that’s not the direction that Swift has been going.<br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Thorsten <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; That’s a fairly significant expansion, and for each of the protocol extensions in (3), we need to evaluate whether X conforms to the extended protocol Q (and any additional constraints placed on that protocol extension).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 5, 2016, at 9:49 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 04.06.2016 um 23:18 schrieb Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello Dan,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; You&#39;ll be pleased to learn that conforming generic types conditionally to protocols is on the roadmap (and is one of the highest priority items for the versions of Swift following 3.0): https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances- &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; However, it&#39;s unlikely that protocols will gain conditional conformance: https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-via-protocol-extensions &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-via-protocol-extensions&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;However, similar to private conformances, it puts a major burden on the dynamic-casting runtime to chase down arbitrarily long and potentially cyclic chains of conformances, which makes efficient implementation nearly impossible.“<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I’ve been wondering what the problem with the implementation is. I mean instead of using an extension the same conformance could have been declared beforehand, i.e. instead of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol P { func foo() }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol Q { func bar() }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; extension Q : P { func foo() { bar() } }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; we could have written the allowed<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol P { func foo() }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol Q : P { func foo() { bar() } }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; with the exact same effect.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The only difference would be that the extension might have been in another module than Q. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Is having to cross module boundaries causing the cited problems? Would the same problems exist if in the second example Q would be defined in another module?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That document originates from a mailing list post made some time ago, and is a decent overview as to what sorts of type system features the Swift core developers are interested in building.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Best,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Austin<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160608/c42fb0b9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal] Conditional Conformance on Protocols/Generic Types</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>June  8, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jun 8, 2016, at 11:52 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Am 07.06.2016 um 07:55 schrieb LM &lt;laurent.mihalkovic at gmail.com &lt;mailto:laurent.mihalkovic at gmail.com&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Jun 7, 2016, at 7:14 AM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 6, 2016, at 10:08 PM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 06.06.2016 um 22:13 schrieb L Mihalkovic &lt;laurent.mihalkovic at gmail.com &lt;mailto:laurent.mihalkovic at gmail.com&gt;&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 6, 2016, at 9:34 PM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 6, 2016, at 12:12 PM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 06.06.2016 um 18:51 schrieb Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 5, 2016, at 3:24 AM, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The issue is to decide on the applicability scope. Thinking &#39;my app/their stuff&#39; is an illusion. To the compiler &amp; runtime there is only code split into modules, some in source code and others as dylibs (.dll, .so, ...). Any extension based conditional refines a protocol everywhere. What&#39;s hard is to compute the complete effects of these changes predictably, reliably and fast. Because when we consider &#39;but look, i have a single small extension&#39;, the compiler&amp;runtime must be ready to deal symetrically with anything we throw at it. They can&#39;t start building 15 different ways the compute the side effects based on many different scenarios because it will be un-ruly code, and too complex to try to explain to us what we will see.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The circular redefinitions case is one of the knightmares that hides in there... would mean having to assign priority to scopes, when there is no scopes yet. At the moment, the binary conformance table contains records for 3 types of conformances. First step would be to add a new type to match extension based conformance, and then record where it came from, and add some priority scheme to be able to navigate any conformance chain(remember that the pb grows everytime we decide &#39;oh cool, lets use a Padleft module rather than write my own 15 lines to do it - see the recent pb with nodejs). Not a simple task even with time, which they do not have now.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; @core_team i know this is a coarse explanation, but hopefully at least in the right ballpark.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Roughly, yes. The specific problem regards answering the question “where must the runtime look to determine whether a given type X conforms to protocol P?”. Right now, the runtime conceptually needs to look:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	1) Into a list of known protocol conformances for the type X, and<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	2) If X is a class type, the list of known protocol conformances for the superclass of X (recursively)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If we add the ability for a protocol extension to add a conformance to another protocol, add to that:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	3) Into the list of protocol extensions of other protocols Q that provide conformance to P<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; So, the difference is that in the case<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol P { ... }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol Q : P { ... }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; struct X : Q {...}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; X&#39;s list of known protocol conformances already contains Q and P, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; whereas in the case<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol P { ... }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol Q { ... }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; struct X : Q {...}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; extension Q : P<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; X&#39;s list of known protocol conformances just contains Q and is not extended by P as a result of the extension?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Did I understand this right?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Yes, that’s correct.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Is that (not being able to extend the conformance lists of all types as a result of an extension) a restriction of having module boundaries?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Effectively, yes: you can’t simply enumerate all of the cases because some other module might add a new types/protocol extensions/conformances. It has to be dynamically discoverable.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; yes… for each new module added to a known mix, the final conformances list can be completely different. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But this is information known at compile time and does not have to be determined at runtime. <br>&gt;&gt;&gt;&gt; An extension should be only effective in the module in which it is defined and in modules using that module. All of these get to know the extension at compile time.<br>&gt;&gt; <br>&gt;&gt; The idea of swift 3/4 is that the stdlib ABI should be stable enough that it will be in the system rather than embedded in each app. Which means that the conformance table must be runtime discoverable from the module exporting it (in a section of the text segment), and its final effects computed by the runtime when the module gets loaded (again coarse grained expl) by each binary using it. This also lets them define new module boundaries in the system that we can transitively inherit.<br>&gt;&gt; <br>&gt;&gt; Baking the final conformance statically into the module would leave us wondering why our code might seem to be &#39;frozen&#39; and not using newer system defined conformances. <br>&gt; <br>&gt; Good argument. So that would mean that the analysis would have to be done at linking time. This (like doing it at runtime) does open a can of worms about ambiguity, though: what happens when the new system version of a library suddenly defines an extension that conflicts with an extension in our module? Seems like that such a change should be confined to the system module unless doing a recompile, so we are back to my suggestion of resolving extensions at compile time?<br></p><p>There isn’t likely to be a perfect answer here. Resolving extensions at compile time cuts of various opportunities for dynamic discovery (e.g., the standard library’s print() looking for various conformances) that I, personally, am not willing to give up. Load-time resolution introduces the possibility of ambiguities—which we will likely need to detect or resolve in some way.<br></p><p>	- Doug<br></p><p>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; Mind you... this may not be a stupid idea at all, as it might align better with the practice of linking against specific SDKs to get a predictable level of behavior. <br>&gt;&gt; <br>&gt;&gt; As for scope, my limited understanding of the loader is that there is no &#39;source&#39; field in these conformance records that would allow the runtime to treat them hierarchically. <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That’s not the model that Swift uses today. You can discover protocol conformances introduce by modules—whether you knew about those modules at compile time (but at launch time you end up with newer versions) or whether those modules were unknown, you see the conformances. The standard library’s “print” facility depends on this behavior to find CustomStringConvertible conformances.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, we could make it all statically determined, but IMO that’s not the direction that Swift has been going.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Thorsten <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That’s a fairly significant expansion, and for each of the protocol extensions in (3), we need to evaluate whether X conforms to the extended protocol Q (and any additional constraints placed on that protocol extension).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 5, 2016, at 9:49 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 04.06.2016 um 23:18 schrieb Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello Dan,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; You&#39;ll be pleased to learn that conforming generic types conditionally to protocols is on the roadmap (and is one of the highest priority items for the versions of Swift following 3.0): https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances- &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; However, it&#39;s unlikely that protocols will gain conditional conformance: https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-via-protocol-extensions &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-via-protocol-extensions&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;However, similar to private conformances, it puts a major burden on the dynamic-casting runtime to chase down arbitrarily long and potentially cyclic chains of conformances, which makes efficient implementation nearly impossible.“<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I’ve been wondering what the problem with the implementation is. I mean instead of using an extension the same conformance could have been declared beforehand, i.e. instead of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol P { func foo() }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol Q { func bar() }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; extension Q : P { func foo() { bar() } }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; we could have written the allowed<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol P { func foo() }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol Q : P { func foo() { bar() } }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; with the exact same effect.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The only difference would be that the extension might have been in another module than Q. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Is having to cross module boundaries causing the cited problems? Would the same problems exist if in the second example Q would be defined in another module?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That document originates from a mailing list post made some time ago, and is a decent overview as to what sorts of type system features the Swift core developers are interested in building.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Best,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Austin<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160608/f6a51fc1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Proposal] Conditional Conformance on Protocols/Generic Types</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  9, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jun 8, 2016, at 10:34 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Jun 8, 2016, at 11:52 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 07.06.2016 um 07:55 schrieb LM &lt;laurent.mihalkovic at gmail.com&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jun 7, 2016, at 7:14 AM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 6, 2016, at 10:08 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Am 06.06.2016 um 22:13 schrieb L Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 6, 2016, at 9:34 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 6, 2016, at 12:12 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 06.06.2016 um 18:51 schrieb Douglas Gregor &lt;dgregor at apple.com&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 5, 2016, at 3:24 AM, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The issue is to decide on the applicability scope. Thinking &#39;my app/their stuff&#39; is an illusion. To the compiler &amp; runtime there is only code split into modules, some in source code and others as dylibs (.dll, .so, ...). Any extension based conditional refines a protocol everywhere. What&#39;s hard is to compute the complete effects of these changes predictably, reliably and fast. Because when we consider &#39;but look, i have a single small extension&#39;, the compiler&amp;runtime must be ready to deal symetrically with anything we throw at it. They can&#39;t start building 15 different ways the compute the side effects based on many different scenarios because it will be un-ruly code, and too complex to try to explain to us what we will see.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The circular redefinitions case is one of the knightmares that hides in there... would mean having to assign priority to scopes, when there is no scopes yet. At the moment, the binary conformance table contains records for 3 types of conformances. First step would be to add a new type to match extension based conformance, and then record where it came from, and add some priority scheme to be able to navigate any conformance chain(remember that the pb grows everytime we decide &#39;oh cool, lets use a Padleft module rather than write my own 15 lines to do it - see the recent pb with nodejs). Not a simple task even with time, which they do not have now.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; @core_team i know this is a coarse explanation, but hopefully at least in the right ballpark.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Roughly, yes. The specific problem regards answering the question “where must the runtime look to determine whether a given type X conforms to protocol P?”. Right now, the runtime conceptually needs to look:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	1) Into a list of known protocol conformances for the type X, and<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	2) If X is a class type, the list of known protocol conformances for the superclass of X (recursively)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If we add the ability for a protocol extension to add a conformance to another protocol, add to that:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	3) Into the list of protocol extensions of other protocols Q that provide conformance to P<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; So, the difference is that in the case<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol P { ... }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol Q : P { ... }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; struct X : Q {...}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; X&#39;s list of known protocol conformances already contains Q and P, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; whereas in the case<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol P { ... }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol Q { ... }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; struct X : Q {...}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; extension Q : P<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; X&#39;s list of known protocol conformances just contains Q and is not extended by P as a result of the extension?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Did I understand this right?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes, that’s correct.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Is that (not being able to extend the conformance lists of all types as a result of an extension) a restriction of having module boundaries?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Effectively, yes: you can’t simply enumerate all of the cases because some other module might add a new types/protocol extensions/conformances. It has to be dynamically discoverable.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; yes… for each new module added to a known mix, the final conformances list can be completely different. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; But this is information known at compile time and does not have to be determined at runtime. <br>&gt;&gt;&gt;&gt;&gt; An extension should be only effective in the module in which it is defined and in modules using that module. All of these get to know the extension at compile time.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The idea of swift 3/4 is that the stdlib ABI should be stable enough that it will be in the system rather than embedded in each app. Which means that the conformance table must be runtime discoverable from the module exporting it (in a section of the text segment), and its final effects computed by the runtime when the module gets loaded (again coarse grained expl) by each binary using it. This also lets them define new module boundaries in the system that we can transitively inherit.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Baking the final conformance statically into the module would leave us wondering why our code might seem to be &#39;frozen&#39; and not using newer system defined conformances. <br>&gt;&gt; <br>&gt;&gt; Good argument. So that would mean that the analysis would have to be done at linking time.<br>&gt;&gt; This (like doing it at runtime) does open a can of worms about ambiguity, though: what happens when the new system version of a library suddenly defines an extension that conflicts with an extension in our module? Seems like that such a change should be confined to the system module unless doing a recompile, so we are back to my suggestion of resolving extensions at compile time?<br></p><p>What u call link is mostly a particular subcase of dynamic, so the choices are basically compile or dynamic. Doug has explained what the cost of compile would be. And it is not even something that macros would solve, because we would still have a whole for dynamically formed format patterns.<br></p><p>In the end, I think that compile time without a better scoping story (currently module or nothing, global conformance only, ...) is not much of a step either.<br></p><p>&gt; There isn’t likely to be a perfect answer here. Resolving extensions at compile time cuts of various opportunities for dynamic discovery (e.g., the standard library’s print() looking for various conformances) that I, personally, am not willing to give up. Load-time resolution introduces the possibility of ambiguities—which we will likely need to detect or resolve in some way.<br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt;&gt; -Thorsten<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Mind you... this may not be a stupid idea at all, as it might align better with the practice of linking against specific SDKs to get a predictable level of behavior. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As for scope, my limited understanding of the loader is that there is no &#39;source&#39; field in these conformance records that would allow the runtime to treat them hierarchically. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That’s not the model that Swift uses today. You can discover protocol conformances introduce by modules—whether you knew about those modules at compile time (but at launch time you end up with newer versions) or whether those modules were unknown, you see the conformances. The standard library’s “print” facility depends on this behavior to find CustomStringConvertible conformances.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, we could make it all statically determined, but IMO that’s not the direction that Swift has been going.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Thorsten <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That’s a fairly significant expansion, and for each of the protocol extensions in (3), we need to evaluate whether X conforms to the extended protocol Q (and any additional constraints placed on that protocol extension).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 5, 2016, at 9:49 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 04.06.2016 um 23:18 schrieb Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello Dan,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; You&#39;ll be pleased to learn that conforming generic types conditionally to protocols is on the roadmap (and is one of the highest priority items for the versions of Swift following 3.0): https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; However, it&#39;s unlikely that protocols will gain conditional conformance: https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-via-protocol-extensions<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;However, similar to private conformances, it puts a major burden on the dynamic-casting runtime to chase down arbitrarily long and potentially cyclic chains of conformances, which makes efficient implementation nearly impossible.“<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I’ve been wondering what the problem with the implementation is. I mean instead of using an extension the same conformance could have been declared beforehand, i.e. instead of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol P { func foo() }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol Q { func bar() }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; extension Q : P { func foo() { bar() } }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; we could have written the allowed<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol P { func foo() }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol Q : P { func foo() { bar() } }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; with the exact same effect.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The only difference would be that the extension might have been in another module than Q. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Is having to cross module boundaries causing the cited problems? Would the same problems exist if in the second example Q would be defined in another module?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That document originates from a mailing list post made some time ago, and is a decent overview as to what sorts of type system features the Swift core developers are interested in building.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Best,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/edb26699/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Proposal] Conditional Conformance on Protocols/Generic Types</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  6, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jun 6, 2016, at 6:51 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jun 5, 2016, at 3:24 AM, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The issue is to decide on the applicability scope. Thinking &#39;my app/their stuff&#39; is an illusion. To the compiler &amp; runtime there is only code split into modules, some in source code and others as dylibs (.dll, .so, ...). Any extension based conditional refines a protocol everywhere. What&#39;s hard is to compute the complete effects of these changes predictably, reliably and fast. Because when we consider &#39;but look, i have a single small extension&#39;, the compiler&amp;runtime must be ready to deal symetrically with anything we throw at it. They can&#39;t start building 15 different ways the compute the side effects based on many different scenarios because it will be un-ruly code, and too complex to try to explain to us what we will see.<br>&gt;&gt; The circular redefinitions case is one of the knightmares that hides in there... would mean having to assign priority to scopes, when there is no scopes yet. At the moment, the binary conformance table contains records for 3 types of conformances. First step would be to add a new type to match extension based conformance, and then record where it came from, and add some priority scheme to be able to navigate any conformance chain(remember that the pb grows everytime we decide &#39;oh cool, lets use a Padleft module rather than write my own 15 lines to do it - see the recent pb with nodejs). Not a simple task even with time, which they do not have now.<br>&gt;&gt; <br>&gt;&gt; @core_team i know this is a coarse explanation, but hopefully at least in the right ballpark.<br>&gt; <br>&gt; Roughly, yes. The specific problem regards answering the question “where must the runtime look to determine whether a given type X conforms to protocol P?”. Right now, the runtime conceptually needs to look:<br>&gt; <br>&gt; 	1) Into a list of known protocol conformances for the type X, and<br>&gt; 	2) If X is a class type, the list of known protocol conformances for the superclass of X (recursively)<br>&gt; <br>&gt; If we add the ability for a protocol extension to add a conformance to another protocol, add to that:<br></p><p>I was under the impression that extension defined conformance would fit neither NormalProtocolConformance (nominal) nor SpecializedProtocolConformance (generic) and that a StrawmanExtensionProtocolConformance would then be required.<br></p><p>&gt; <br>&gt; 	3) Into the list of protocol extensions of other protocols Q that provide conformance to P<br>&gt; <br>&gt; That’s a fairly significant expansion, and for each of the protocol extensions in (3), we need to evaluate whether X conforms to the extended protocol Q (and any additional constraints placed on that protocol extension).<br></p><p>because of the potential for contradictory definitions or redefinitions, I was under the impression that it might be useful to define some sort of prioritization for deciding which should be applied first. But that’s probably because I don’t understand the topic as much as you do. That is also why I was thinking that aside from priority, the structures might also have to be tagged with something to tell where they come from (maybe priority is just how these scope source are read). I guess this is also a requirement that would stem from supporting private/local conformance.<br></p><p>&gt; 	- Doug<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jun 5, 2016, at 9:49 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 04.06.2016 um 23:18 schrieb Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hello Dan,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You&#39;ll be pleased to learn that conforming generic types conditionally to protocols is on the roadmap (and is one of the highest priority items for the versions of Swift following 3.0): https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances- &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; However, it&#39;s unlikely that protocols will gain conditional conformance: https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-via-protocol-extensions &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-via-protocol-extensions&gt;<br>&gt;&gt;&gt; &quot;However, similar to private conformances, it puts a major burden on the dynamic-casting runtime to chase down arbitrarily long and potentially cyclic chains of conformances, which makes efficient implementation nearly impossible.“<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’ve been wondering what the problem with the implementation is. I mean instead of using an extension the same conformance could have been declared beforehand, i.e. instead of<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol P { func foo() }<br>&gt;&gt;&gt; protocol Q { func bar() }<br>&gt;&gt;&gt; extension Q : P { func foo() { bar() } }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; we could have written the allowed<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol P { func foo() }<br>&gt;&gt;&gt; protocol Q : P { func foo() { bar() } }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; with the exact same effect.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The only difference would be that the extension might have been in another module than Q. <br>&gt;&gt;&gt; Is having to cross module boundaries causing the cited problems? Would the same problems exist if in the second example Q would be defined in another module?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That document originates from a mailing list post made some time ago, and is a decent overview as to what sorts of type system features the Swift core developers are interested in building.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Best,<br>&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 4, 2016, at 2:12 PM, Dan Zimmerman via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hey,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I was interested in adopting the ability for a type that&#39;s generic in some sense (either via generics or via associated types, in the case of protocols) to conform to other protocols conditionally based on its type parameter/associated type. For example:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt; extension CollectionType: Equatable where Generator.Element: Equatable {}<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func ==&lt;Collection: CollectionType where Collection.Generator.Element: Equatable&gt;(left: Collection, right: Collection) -&gt; Bool {<br>&gt;&gt;&gt;&gt;&gt;  return zip(left, right).reduce(true) { accumulator, tuple in accumulator &amp;&amp; (tuple.0 == tuple.1) }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If this has already been proposed and knocked out/accepted please direct me to the right place.<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160606/b5faa662/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal] Conditional Conformance on Protocols/Generic Types</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>June  6, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jun 6, 2016, at 12:37 PM, L Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jun 6, 2016, at 6:51 PM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jun 5, 2016, at 3:24 AM, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The issue is to decide on the applicability scope. Thinking &#39;my app/their stuff&#39; is an illusion. To the compiler &amp; runtime there is only code split into modules, some in source code and others as dylibs (.dll, .so, ...). Any extension based conditional refines a protocol everywhere. What&#39;s hard is to compute the complete effects of these changes predictably, reliably and fast. Because when we consider &#39;but look, i have a single small extension&#39;, the compiler&amp;runtime must be ready to deal symetrically with anything we throw at it. They can&#39;t start building 15 different ways the compute the side effects based on many different scenarios because it will be un-ruly code, and too complex to try to explain to us what we will see.<br>&gt;&gt;&gt; The circular redefinitions case is one of the knightmares that hides in there... would mean having to assign priority to scopes, when there is no scopes yet. At the moment, the binary conformance table contains records for 3 types of conformances. First step would be to add a new type to match extension based conformance, and then record where it came from, and add some priority scheme to be able to navigate any conformance chain(remember that the pb grows everytime we decide &#39;oh cool, lets use a Padleft module rather than write my own 15 lines to do it - see the recent pb with nodejs). Not a simple task even with time, which they do not have now.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; @core_team i know this is a coarse explanation, but hopefully at least in the right ballpark.<br>&gt;&gt; <br>&gt;&gt; Roughly, yes. The specific problem regards answering the question “where must the runtime look to determine whether a given type X conforms to protocol P?”. Right now, the runtime conceptually needs to look:<br>&gt;&gt; <br>&gt;&gt; 	1) Into a list of known protocol conformances for the type X, and<br>&gt;&gt; 	2) If X is a class type, the list of known protocol conformances for the superclass of X (recursively)<br>&gt;&gt; <br>&gt;&gt; If we add the ability for a protocol extension to add a conformance to another protocol, add to that:<br>&gt; <br>&gt; I was under the impression that extension defined conformance would fit neither NormalProtocolConformance (nominal) nor SpecializedProtocolConformance (generic) and that a StrawmanExtensionProtocolConformance would then be required.<br></p><p>Well, that’s an implementation detail of the AST itself. We’d probably be able to leverage NormalProtocolConformance for this.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; 	3) Into the list of protocol extensions of other protocols Q that provide conformance to P<br>&gt;&gt; <br>&gt;&gt; That’s a fairly significant expansion, and for each of the protocol extensions in (3), we need to evaluate whether X conforms to the extended protocol Q (and any additional constraints placed on that protocol extension).<br>&gt; <br>&gt; because of the potential for contradictory definitions or redefinitions, I was under the impression that it might be useful to define some sort of prioritization for deciding which should be applied first. But that’s probably because I don’t understand the topic as much as you do. That is also why I was thinking that aside from priority, the structures might also have to be tagged with something to tell where they come from (maybe priority is just how these scope source are read). I guess this is also a requirement that would stem from supporting private/local conformance.<br></p><p>Yes, if we admit multiple conformances of the same type X to a protocol P, we need some way to resolve the ambiguity *at runtime*. That has a cost, which could be significant depending on the chosen scheme. Personally, I don’t think we ever want to admit multiple/private/local conformances.<br></p><p>	- Doug<br></p><p>&gt; <br>&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jun 5, 2016, at 9:49 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 04.06.2016 um 23:18 schrieb Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hello Dan,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; You&#39;ll be pleased to learn that conforming generic types conditionally to protocols is on the roadmap (and is one of the highest priority items for the versions of Swift following 3.0): https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances- &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; However, it&#39;s unlikely that protocols will gain conditional conformance: https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-via-protocol-extensions &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-via-protocol-extensions&gt;<br>&gt;&gt;&gt;&gt; &quot;However, similar to private conformances, it puts a major burden on the dynamic-casting runtime to chase down arbitrarily long and potentially cyclic chains of conformances, which makes efficient implementation nearly impossible.“<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’ve been wondering what the problem with the implementation is. I mean instead of using an extension the same conformance could have been declared beforehand, i.e. instead of<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol P { func foo() }<br>&gt;&gt;&gt;&gt; protocol Q { func bar() }<br>&gt;&gt;&gt;&gt; extension Q : P { func foo() { bar() } }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; we could have written the allowed<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol P { func foo() }<br>&gt;&gt;&gt;&gt; protocol Q : P { func foo() { bar() } }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; with the exact same effect.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The only difference would be that the extension might have been in another module than Q. <br>&gt;&gt;&gt;&gt; Is having to cross module boundaries causing the cited problems? Would the same problems exist if in the second example Q would be defined in another module?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That document originates from a mailing list post made some time ago, and is a decent overview as to what sorts of type system features the Swift core developers are interested in building.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Best,<br>&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 4, 2016, at 2:12 PM, Dan Zimmerman via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Hey,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I was interested in adopting the ability for a type that&#39;s generic in some sense (either via generics or via associated types, in the case of protocols) to conform to other protocols conditionally based on its type parameter/associated type. For example:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt; extension CollectionType: Equatable where Generator.Element: Equatable {}<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func ==&lt;Collection: CollectionType where Collection.Generator.Element: Equatable&gt;(left: Collection, right: Collection) -&gt; Bool {<br>&gt;&gt;&gt;&gt;&gt;&gt;  return zip(left, right).reduce(true) { accumulator, tuple in accumulator &amp;&amp; (tuple.0 == tuple.1) }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If this has already been proposed and knocked out/accepted please direct me to the right place.<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160606/267f78f8/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
