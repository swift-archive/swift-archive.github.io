<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a503f14866aaa083332c81264860ac8e?s=50"></div><header><strong>Proposal: weakStrong self in completion handler closures</strong> from <string>Robert Vojta</string> &lt;rvojta at me.com&gt;<p>December  5, 2015 at 12:00:00pm</p></header><div class="content"><p>Hi all,<br></p><p>let’s say we have a completion handler closure for some function (networking, …) and we have [weak self] there. Example …<br></p><p>doSomething() { [weak self] result in<br>  …<br>}<br></p><p>… then we can use self?.whatever to access self properties, methods. Or we can try to check if self exists ...<br></p><p>guard let strongSelf = self else { return }<br></p><p>… and use strongSelf.<br></p><p>Can we introduce [weakStrong self] with following behavior:<br></p><p> - self is a weak reference<br> - when the closure is going to be executed, all weakStrong weak references are checked if they do exist<br> - if they do exist, they’re strong referenced for the closure and the closure is executed<br> - if they don’t exist, closure is not executed<br></p><p>doSomething() { [weakStrong self] result in<br>  // Closure code is not executed if self no longer exists<br>  // self is a strong reference now<br>}<br></p><p>What do you think? Does it make sense?<br></p><p>My motivation is to get rid off of the repetitive code like this one:<br></p><p>doSomething() { [weak self] result in<br>  guard let strongSelf = self else { return }<br>  strongSelf.doSomethingWithResult(result)<br>}<br></p><p>Robert<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Proposal: weakStrong self in completion handler closures</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>December  5, 2015 at 07:00:00pm</p></header><div class="content"><p>Another approach would be to simply allow<br></p><p>guard let self = self else { return }<br>On Sat, Dec 5, 2015 at 3:48 AM Robert Vojta &lt;rvojta at me.com&gt; wrote:<br></p><p>&gt; Hi all,<br>&gt;<br>&gt; let’s say we have a completion handler closure for some function<br>&gt; (networking, …) and we have [weak self] there. Example …<br>&gt;<br>&gt; doSomething() { [weak self] result in<br>&gt;   …<br>&gt; }<br>&gt;<br>&gt; … then we can use self?.whatever to access self properties, methods. Or we<br>&gt; can try to check if self exists ...<br>&gt;<br>&gt; guard let strongSelf = self else { return }<br>&gt;<br>&gt; … and use strongSelf.<br>&gt;<br>&gt; Can we introduce [weakStrong self] with following behavior:<br>&gt;<br>&gt;  - self is a weak reference<br>&gt;  - when the closure is going to be executed, all weakStrong weak<br>&gt; references are checked if they do exist<br>&gt;  - if they do exist, they’re strong referenced for the closure and the<br>&gt; closure is executed<br>&gt;  - if they don’t exist, closure is not executed<br>&gt;<br>&gt; doSomething() { [weakStrong self] result in<br>&gt;   // Closure code is not executed if self no longer exists<br>&gt;   // self is a strong reference now<br>&gt; }<br>&gt;<br>&gt; What do you think? Does it make sense?<br>&gt;<br>&gt; My motivation is to get rid off of the repetitive code like this one:<br>&gt;<br>&gt; doSomething() { [weak self] result in<br>&gt;   guard let strongSelf = self else { return }<br>&gt;   strongSelf.doSomethingWithResult(result)<br>&gt; }<br>&gt;<br>&gt; Robert<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/f22d5fa4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c0eafab7106ab63b8db4025e57c1a8d2?s=50"></div><header><strong>Proposal: weakStrong self in completion handler closures</strong> from <string>Javier Soto</string> &lt;javier.api at gmail.com&gt;<p>December  5, 2015 at 09:00:00pm</p></header><div class="content"><p>My understanding was that [weak variable] behaved that way in Swift already<br>(but now I&#39;m not certain and can&#39;t find a definitive answer on the book),<br>creating a strong reference. Otherwise this turns into inconsistent<br>behavior, where the variable could deallocate and become nil at any point<br>inside the closure.<br></p><p>Those semantics are also important in a case with a closure within a<br>closure:<br></p><p>function1(){ [weak self] in<br>function2() {<br>// the value (If present) inside Optional&lt;Self&gt; is a strong reference here<br>}<br>}<br>On Sat, Dec 5, 2015 at 11:22 AM Jacob Bandes-Storch via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Another approach would be to simply allow<br>&gt;<br>&gt; guard let self = self else { return }<br>&gt; On Sat, Dec 5, 2015 at 3:48 AM Robert Vojta &lt;rvojta at me.com&gt; wrote:<br>&gt;<br>&gt;&gt; Hi all,<br>&gt;&gt;<br>&gt;&gt; let’s say we have a completion handler closure for some function<br>&gt;&gt; (networking, …) and we have [weak self] there. Example …<br>&gt;&gt;<br>&gt;&gt; doSomething() { [weak self] result in<br>&gt;&gt;   …<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; … then we can use self?.whatever to access self properties, methods. Or<br>&gt;&gt; we can try to check if self exists ...<br>&gt;&gt;<br>&gt;&gt; guard let strongSelf = self else { return }<br>&gt;&gt;<br>&gt;&gt; … and use strongSelf.<br>&gt;&gt;<br>&gt;&gt; Can we introduce [weakStrong self] with following behavior:<br>&gt;&gt;<br>&gt;&gt;  - self is a weak reference<br>&gt;&gt;  - when the closure is going to be executed, all weakStrong weak<br>&gt;&gt; references are checked if they do exist<br>&gt;&gt;  - if they do exist, they’re strong referenced for the closure and the<br>&gt;&gt; closure is executed<br>&gt;&gt;  - if they don’t exist, closure is not executed<br>&gt;&gt;<br>&gt;&gt; doSomething() { [weakStrong self] result in<br>&gt;&gt;   // Closure code is not executed if self no longer exists<br>&gt;&gt;   // self is a strong reference now<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; What do you think? Does it make sense?<br>&gt;&gt;<br>&gt;&gt; My motivation is to get rid off of the repetitive code like this one:<br>&gt;&gt;<br>&gt;&gt; doSomething() { [weak self] result in<br>&gt;&gt;   guard let strongSelf = self else { return }<br>&gt;&gt;   strongSelf.doSomethingWithResult(result)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Robert<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-- <br>Javier Soto<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/e452bd29/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0f5e460daedc625457bc16580ecdbc04?s=50"></div><header><strong>Proposal: weakStrong self in completion handler closures</strong> from <string>Davide De Franceschi</string> &lt;defrenz98 at hotmail.com&gt;<p>December  6, 2015 at 10:00:00am</p></header><div class="content"><p>I agree that &quot;weak-strong&quot; is a commonly used (and correct) pattern, and I also wish that there were an easier way to do that. I also did file a radar myself about that.<br></p><p>But I don&#39;t have any idea of the correct way of implementing it because the actually desired behaviour in the &quot;failing&quot; case can change depending on your use-case.<br></p><p>Most of the times you just want to `guard let strongSelf = self else { return }`, but that works when you return `Void` and you don&#39;t want to manage this &quot;failure&quot; in any other way...<br>Should `weak-strong` be allowed only for closures that `-&gt; Void`?<br>What if you want to fire a &quot;completionBlock&quot; anyway?<br></p><p>While the need to remove this common boilerplate feels strong, I&#39;m not certain this would be the right way. Can&#39;t really suggest a better alternative though.<br></p><p><br>&gt; On 5 Dec 2015, at 19:21, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Another approach would be to simply allow<br>&gt; <br>&gt; guard let self = self else { return }<br>&gt; On Sat, Dec 5, 2015 at 3:48 AM Robert Vojta &lt;rvojta at me.com &lt;mailto:rvojta at me.com&gt;&gt; wrote:<br>&gt; Hi all,<br>&gt; <br>&gt; let’s say we have a completion handler closure for some function (networking, …) and we have [weak self] there. Example …<br>&gt; <br>&gt; doSomething() { [weak self] result in<br>&gt;   …<br>&gt; }<br>&gt; <br>&gt; … then we can use self?.whatever to access self properties, methods. Or we can try to check if self exists ...<br>&gt; <br>&gt; guard let strongSelf = self else { return }<br>&gt; <br>&gt; … and use strongSelf.<br>&gt; <br>&gt; Can we introduce [weakStrong self] with following behavior:<br>&gt; <br>&gt;  - self is a weak reference<br>&gt;  - when the closure is going to be executed, all weakStrong weak references are checked if they do exist<br>&gt;  - if they do exist, they’re strong referenced for the closure and the closure is executed<br>&gt;  - if they don’t exist, closure is not executed<br>&gt; <br>&gt; doSomething() { [weakStrong self] result in<br>&gt;   // Closure code is not executed if self no longer exists<br>&gt;   // self is a strong reference now<br>&gt; }<br>&gt; <br>&gt; What do you think? Does it make sense?<br>&gt; <br>&gt; My motivation is to get rid off of the repetitive code like this one:<br>&gt; <br>&gt; doSomething() { [weak self] result in<br>&gt;   guard let strongSelf = self else { return }<br>&gt;   strongSelf.doSomethingWithResult(result)<br>&gt; }<br>&gt; <br>&gt; Robert<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/adf18456/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a503f14866aaa083332c81264860ac8e?s=50"></div><header><strong>Proposal: weakStrong self in completion handler closures</strong> from <string>Robert Vojta</string> &lt;rvojta at me.com&gt;<p>December  6, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; On 6. 12. 2015, at 11:01, Davide De Franceschi via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Most of the times you just want to `guard let strongSelf = self else { return }`, but that works when you return `Void` and you don&#39;t want to manage this &quot;failure&quot; in any other way...<br>&gt; Should `weak-strong` be allowed only for closures that `-&gt; Void`?<br></p><p>Can be and result will be optional. But it complicates things and makes it unclear. Which is not good.<br></p><p>&gt; What if you want to fire a &quot;completionBlock&quot; anyway?<br></p><p>Then don&#39;t use weakStrong and use weak strong dance.<br></p><p>&gt; While the need to remove this common boilerplate feels strong, I&#39;m not certain this would be the right way. Can&#39;t really suggest a better alternative though.<br></p><p>Agree with you. I just wanted to start discussion about it, but not convinced about weakStrong as well.<br></p><p>Probably what Jacob proposed would be enough. Just allow &quot;guard let self = self ...&quot; at least to remove strongSelf, this, ...<br></p><p>Robert<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: weakStrong self in completion handler closures</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December  6, 2015 at 12:00:00am</p></header><div class="content"><p>How would weakStrong work if the closure has a non-Void return type?<br></p><p>Personally, I just use<br></p><p>guard let this = self else { return }<br></p><p>in this scenario. It&#39;s not much trouble to type `this.foo` instead of<br>`self.foo` (it&#39;s even the same number of letters).<br></p><p>-Kevin Ballrd<br></p><p>On Sat, Dec 5, 2015, at 03:48 AM, Robert Vojta wrote:<br>&gt; Hi all,<br>&gt; <br>&gt; let’s say we have a completion handler closure for some function<br>&gt; (networking, …) and we have [weak self] there. Example …<br>&gt; <br>&gt; doSomething() { [weak self] result in<br>&gt;   …<br>&gt; }<br>&gt; <br>&gt; … then we can use self?.whatever to access self properties, methods. Or<br>&gt; we can try to check if self exists ...<br>&gt; <br>&gt; guard let strongSelf = self else { return }<br>&gt; <br>&gt; … and use strongSelf.<br>&gt; <br>&gt; Can we introduce [weakStrong self] with following behavior:<br>&gt; <br>&gt;  - self is a weak reference<br>&gt;  - when the closure is going to be executed, all weakStrong weak<br>&gt;  references are checked if they do exist<br>&gt;  - if they do exist, they’re strong referenced for the closure and the<br>&gt;  closure is executed<br>&gt;  - if they don’t exist, closure is not executed<br>&gt; <br>&gt; doSomething() { [weakStrong self] result in<br>&gt;   // Closure code is not executed if self no longer exists<br>&gt;   // self is a strong reference now<br>&gt; }<br>&gt; <br>&gt; What do you think? Does it make sense?<br>&gt; <br>&gt; My motivation is to get rid off of the repetitive code like this one:<br>&gt; <br>&gt; doSomething() { [weak self] result in<br>&gt;   guard let strongSelf = self else { return }<br>&gt;   strongSelf.doSomethingWithResult(result)<br>&gt; }<br>&gt; <br>&gt; Robert<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a503f14866aaa083332c81264860ac8e?s=50"></div><header><strong>Proposal: weakStrong self in completion handler closures</strong> from <string>Robert Vojta</string> &lt;rvojta at me.com&gt;<p>December  6, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On 06 Dec 2015, at 09:19, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; How would weakStrong work if the closure has a non-Void return type?<br></p><p>Allowed only for optional (closure) parameters?<br></p><p>doSmth(handler: (() -&gt; Bool)?) { [weakStrong self] in<br>}<br></p><p>weakStrong makes sense for async only where self (or anything else) can disappear. It does not make sense for @noescape, ...<br></p><p>&gt; Personally, I just use<br>&gt; <br>&gt; guard let this = self else { return }<br>&gt; <br>&gt; in this scenario. It&#39;s not much trouble to type `this.foo` instead of<br>&gt; `self.foo` (it&#39;s even the same number of letters).<br></p><p>Way to do. But if you decide to move code outside the closure you&#39;re forced to replace this. with self. or delete this. The code shouldn&#39;t differ (this vs self vs strongSelf) if it&#39;s in the closure or outside of it.<br></p><p>Robert<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
