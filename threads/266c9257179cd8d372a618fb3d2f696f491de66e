<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Reconsidering SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January 28, 2016 at 02:00:00pm</p></header><div class="content"><p>on Thu Jan 28 2016, Kevin Ballard &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Oh man, huge +1 from me here.<br>&gt;<br>&gt; Apparently I never actually read that proposal. I was under the<br>&gt; impression it only removed var from function parameters. And while I<br>&gt; find that mildly annoying, I was ok with it because of the argument<br>&gt; for removing as many keywords as possible from function parameter<br>&gt; lists (e.g. to open up those keywords to be used as external parameter<br>&gt; names). Though I&#39;d really prefer to keep var anyway.<br>&gt;<br>&gt; But I didn&#39;t realize until now that it also prohibits `var` from _all_<br>&gt; pattern matching, such as if-let, guard-let, etc. And I find that<br>&gt; incredibly restrictive. I am not ok at all with that restriction. It<br>&gt; makes no sense to me, and it makes a lot of very clean code become<br>&gt; much messier by the addition of completely spurious `var foo = foo`<br>&gt; lines everywhere. What&#39;s more, you can&#39;t even add lines like that<br>&gt; everywhere because of Swift&#39;s prohibition from shadowing variables<br>&gt; from the same scope (e.g. you can&#39;t shadow the variable bound from<br>&gt; `guard let` because it&#39;s in the same scope).<br>&gt;<br>&gt; I see Dave Abrahams arguing that this feature is tripping some people<br>&gt; up. <br></p><p>I&#39;m really making others&#39; arguments for them here.  It is a fact that it<br>has tripped some people up.  I still don&#39;t support removing it.<br></p><p>&gt; But I don&#39;t see that as appropriate grounds for removing it from the<br>&gt; language. If people don&#39;t understand `if var` or `for var x in` then<br>&gt; they can just not write code that uses that feature. And if the<br>&gt; argument is that people might have to read other code that uses that,<br>&gt; well, there&#39;s plenty of stuff in Swift that you have to actually learn<br>&gt; about before you can understand how it works, and using `var` in<br>&gt; patterns does not seem like one of the trickiest things. And if the<br>&gt; confusion stems from not understanding the difference between `var`<br>&gt; and `inout`, I don&#39;t see how preventing someone from writing `if var`<br>&gt; will solve that confusion, because the same person would presumably<br>&gt; have the same confusion about `var foo = bar`.<br>&gt;<br>&gt; -Kevin Ballard<br>&gt;<br>&gt; On Fri, Jan 22, 2016, at 09:26 AM, David Farler via swift-evolution wrote:<br>&gt;&gt; Hello everyone,<br>&gt;&gt; <br>&gt;&gt; I&#39;d like to reconsider SE-0003 for Swift 3 and propose cancelling the change in its entirety. After collecting feedback since Swift&#39;s open source launch, I no longer feel this is a good move and there are a few reasons why.<br>&gt;&gt; <br>&gt;&gt; There are two main patterns that the removal penalizes:<br>&gt;&gt; <br>&gt;&gt; - Get-Modify-Reassign<br>&gt;&gt; - Get-Modify-Return<br>&gt;&gt; <br>&gt;&gt; I&#39;ve found that many of the problems with this proposal stem from the uses before and after the &quot;Modify&quot; part, before returning or reassigning with the new value.<br>&gt;&gt; <br>&gt;&gt; I&#39;ve seen a few common responses to the var removal. Consider a `Rectangle` struct:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; struct Rectangle {<br>&gt;&gt;  var origin: (x: Double, y: Double)<br>&gt;&gt;  var size: (width: Double, height: Double)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Even with mutable variables `origin` and `size`, this pattern would be impossible:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; var selection = getRectangularSelection()<br>&gt;&gt; if var rect = selection?.rect {<br>&gt;&gt;  // Mutate `rect` ...<br>&gt;&gt;  selection.rect = rect<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; So, one might shadow the variable, which is not ideal:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; var selection = getRectangularSelection()<br>&gt;&gt; if let rect = selection?.rect {<br>&gt;&gt;  var rect = rect // Not so great<br>&gt;&gt;  // Mutate `rect` ...<br>&gt;&gt;  selection.rect = rect<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Or, you might make a transformation function on `Rect`:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; struct Rectangle {<br>&gt;&gt;  var origin: (x: Double, y: Double)<br>&gt;&gt;  var size: (width: Double, height: Double)<br>&gt;&gt;  func withOrigin(x: Double, y: Double) -&gt; Rect {<br>&gt;&gt;    var r = self<br>&gt;&gt;    r.origin = (x, y)<br>&gt;&gt;    return r<br>&gt;&gt;  }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; This is a much better solution than shadowing but you would need one of these for any property that you want to mutate and I think you&#39;ll agree that it doesn&#39;t scale with the language we have today. This response begs for a kind of initializer that takes all of the fields of the original struct except any that you want to override:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; if let rect = selection?.rect.with(origin: newOrigin) {<br>&gt;&gt;  // ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Straw syntax, but maybe you&#39;ll see something along these lines on swift-evolution in the future, which would provide a clear alternative to direct mutation patterns. Even then, I think having complementary patterns in the language isn&#39;t a bad thing.<br>&gt;&gt; <br>&gt;&gt; These problems come up with the other variable bindings but the one that ended up bothering me the most was `guard var`:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; func transform(selection: Rect?) {<br>&gt;&gt;  guard let rect = selection else { return }<br>&gt;&gt;  var _rect = rect<br>&gt;&gt;  // Mutate `_rect` ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; One of the guard statement&#39;s main purposes is to conditionally bind a value as a peer in its own scope, not an inner scope like if statements. Not having var makes the guard statement much weaker.<br>&gt;&gt; <br>&gt;&gt; There is certainly a bit of confusion about the nuances between value and reference semantics, who owns a value and when, how effects are propagated back to values, but I think we can attack the problem with more finesse.<br>&gt;&gt; <br>&gt;&gt; Value types are one of the attractive features of Swift â€“ because of their semantics, mutating algorithms are written in a familiar style but keeping effects limited to your unique reference. I don&#39;t think we should give that up now to address confusion about semantics, out of principle, or in anticipation of new language features. I propose cancelling this change for Swift 3 and continue to allow `var` in the grammar everywhere it occurs in Swift 2.2.<br>&gt;&gt; <br>&gt;&gt; Regards,<br>&gt;&gt; David<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>-Dave<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
