<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>April 19, 2016 at 02:00:00pm</p></header><div class="content"><p>Hello Swift community,<br></p><p>The review of &quot;SE-0067: Enhanced Floating Point Protocols&quot; begins now and runs through April 25. The proposal is available here:<br></p><p>	https://github.com/apple/swift-evolution/blob/master/proposals/0067-floating-point-protocols.md<br></p><p>Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br></p><p>	https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>or, if you would like to keep your feedback private, directly to the review manager.<br></p><p>What goes into a review?<br></p><p>The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br></p><p>	* What is your evaluation of the proposal?<br>	* Is the problem being addressed significant enough to warrant a change to Swift?<br>	* Does this proposal fit well with the feel and direction of Swift?<br>	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>More information about the Swift evolution process is available at<br></p><p>	https://github.com/apple/swift-evolution/blob/master/process.md<br></p><p>Thank you,<br></p><p>-Chris Lattner<br>Review Manager<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a6a2eebe83a60a4b42395145484cda15?s=50"></div><header><strong>[Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Daniel Vollmer</string> &lt;lists at maven.de&gt;<p>April 20, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On 19 Apr 2016, at 23:16, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0067: Enhanced Floating Point Protocols&quot; begins now and runs through April 25. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0067-floating-point-protocols.md<br></p><p>This looks pretty nice, but I have to admit I’m unaware of pretty much anything about the current floating-point protocols.<br></p><p>A question, if I may:<br>&gt; /// A signalling NaN (not-a-number).<br>&gt; @warn_unused_result<br>&gt; static fun signalingNaN: Self { get }<br></p><p>Why is this a static func compared to a static var for nan? Representation only known at run-time? Why is the second N in NaN capitalised?<br></p><p>	Daniel.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c965d88fab90b7e85514d0e3011c3caf?s=50"></div><header><strong>[Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Tim Hawkins</string> &lt;tim.thawkins at gmail.com&gt;<p>April 20, 2016 at 08:00:00am</p></header><div class="content"><p>&quot;NaN&quot; with the shown capitalisation is the standard way of showing this<br>constant in every other language that I know of, changing it to &quot;Nan&quot; would<br>cause confusion and risks people not recognising it for what it is.  The<br>form is reasonable given that it is the acronym for &quot;Not a Number&quot;.<br>On Apr 20, 2016 6:12 AM, &quot;Daniel Vollmer via swift-evolution&quot; &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On 19 Apr 2016, at 23:16, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Hello Swift community,<br>&gt; &gt;<br>&gt; &gt; The review of &quot;SE-0067: Enhanced Floating Point Protocols&quot; begins now<br>&gt; and runs through April 25. The proposal is available here:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0067-floating-point-protocols.md<br>&gt;<br>&gt; This looks pretty nice, but I have to admit I’m unaware of pretty much<br>&gt; anything about the current floating-point protocols.<br>&gt;<br>&gt; A question, if I may:<br>&gt; &gt; /// A signalling NaN (not-a-number).<br>&gt; &gt; @warn_unused_result<br>&gt; &gt; static fun signalingNaN: Self { get }<br>&gt;<br>&gt; Why is this a static func compared to a static var for nan? Representation<br>&gt; only known at run-time? Why is the second N in NaN capitalised?<br>&gt;<br>&gt;         Daniel.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160420/56f5caea/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>April 19, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Apr 19, 2016, at 7:50 PM, Tim Hawkins via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; &quot;NaN&quot; with the shown capitalisation is the standard way of showing this constant in every other language that I know of, changing it to &quot;Nan&quot; would cause confusion and risks people not recognising it for what it is.  The form is reasonable given that it is the acronym for &quot;Not a Number&quot;.<br>&gt; <br>I&#39;m inclined to agree.<br></p><p>- Dave Sweeris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160419/b5c15d38/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>[Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>April 20, 2016 at 06:00:00am</p></header><div class="content"><p>On Apr 19, 2016, at 6:11 PM, Daniel Vollmer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Why is this a static func compared to a static var for nan? Representation only known at run-time? Why is the second N in NaN capitalised?<br></p><p>This is a typo in the changes that were made to the draft.  It should be:<br></p><p>	static var signalingNan: Self { get }<br></p><p>– Steve<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160420/030428bd/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April 19, 2016 at 05:00:00pm</p></header><div class="content"><p>* What is your evaluation of the proposal?<br></p><p>+1 in intent. Specifics require further refinement. For example:<br></p><p>Internal inconsistencies in capitalization:<br>* `signalingNaN` but `isSignalingNan` and `isNan`<br></p><p>Parameter labels, or whatever they&#39;re called now, do not reflect newly<br>adopted Swift syntax in SE-0046:<br>* `static func maximum(x: Self, _ y: Self) -&gt; Self` should be `static<br>func maximum(_ x: Self, _ y: Self) -&gt; Self`, etc.<br></p><p>Infelicitous use of prepositions to conform superficially to new<br>naming guidelines:<br>* `isEqual(to:)` is fine, but for consistency there&#39;s<br>`isLessThanOrEqual(to:)`, which is not fine, because the preposition<br>&quot;to&quot; applies only to &quot;equal&quot; and not to &quot;less than&quot;<br></p><p>Since `adding(_:)` is instead now an operator in the current version<br>of the proposal, could comparison functions also be operators only?<br></p><p>Incorrect nomenclature in an attempt to correct previously misleading<br>nomenclature:<br>* `leastMagnitude` should be `leastPositive` or `minPositive`, because<br>magnitudes can be zero: it&#39;s bonkers that<br>`Double.minimumMagnitude(0.0, Double.leastMagnitude) &lt;<br>Double.leastMagnitude`!<br>(Likewise, `leastNormalMagnitude` should be `leastNormalPositive` or<br>`minPositive`, and `greatestFiniteMagnitude` should be<br>`greatestFinite` or `maxFinite`)<br></p><p>Inconsistencies with Integer protocols (at least, as they are currently):<br>* properties named &quot;least...&quot; or &quot;greatest...&quot; are inconsistent with<br>conceptually similar properties such as `Int.min` and `Int.max`<br></p><p>Use of one term-of-art (`ulp`), as Swift naming guidelines allow and<br>even encourage, but failure to use more widely understood terms of<br>art:<br>* `squareRoot()` should be `sqrt()`<br>* something really ought to be done about<br>`truncatingRemainder(dividingBy:)`--the fact that the comments tell<br>the reader that `truncatingRemainder(dividingBy:)` is equivalent to C<br>`fmod` suggests to me that `fmod` may be a widely understood<br>term-of-art<br></p><p>I argue strongly that Swift&#39;s naming guidelines about terms-of-art<br>should be understood to encourage terms used widely in other languages<br>for basic mathematical functions instead of written-out English<br>equivalents--e.g. `asinh` instead of`inverseHyperbolicSine`. Looking<br>to other C-style languages, all seem to accept these shorter terms<br>as-is without writing them out.<br></p><p><br> * Is the problem being addressed significant enough to warrant a<br>change to Swift?<br></p><p>Yes. Several pain points exist with current FloatingPoint protocols<br>that are addressed in this proposal.<br></p><p><br> * Does this proposal fit well with the feel and direction of Swift?<br></p><p>Partially. In addressing pain points, yes. Some of the proposed method<br>names could stand improvement for accuracy and for consistency with<br>the rest of the language, as outlined above.<br></p><p><br> * If you have you used other languages or libraries with a similar<br>feature, how do you feel that this proposal compares to those?<br></p><p>I believe this proposal brings the FloatingPoint protocol up to a<br>similar level of comprehensiveness as the approximate equivalents in<br>C-family languages such as C# and Java; however, I think some further<br>clean-up of the proposed names should be considered.<br></p><p><br> * How much effort did you put into your review? A glance, a quick<br>reading, or an in-depth study?<br></p><p>Followed the original discussion of draft proposal carefully; have<br>used floating point protocols extensively in (current) Swift and in<br>other languages.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>[Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>April 20, 2016 at 06:00:00am</p></header><div class="content"><p>Hi Xiaodi —<br></p><p>Thanks for the detailed comments.  Some thoughts inline.<br></p><p>&gt; On Apr 19, 2016, at 6:34 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; * What is your evaluation of the proposal?<br>&gt; <br>&gt; +1 in intent. Specifics require further refinement. For example:<br>&gt; <br>&gt; Internal inconsistencies in capitalization:<br>&gt; * `signalingNaN` but `isSignalingNan` and `isNan`<br></p><p>This is a typo.  Should be signalingNan.<br></p><p>&gt; Parameter labels, or whatever they&#39;re called now, do not reflect newly<br>&gt; adopted Swift syntax in SE-0046:<br>&gt; * `static func maximum(x: Self, _ y: Self) -&gt; Self` should be `static<br>&gt; func maximum(_ x: Self, _ y: Self) -&gt; Self`, etc.<br>&gt; <br>&gt; Infelicitous use of prepositions to conform superficially to new<br>&gt; naming guidelines:<br>&gt; * `isEqual(to:)` is fine, but for consistency there&#39;s<br>&gt; `isLessThanOrEqual(to:)`, which is not fine, because the preposition<br>&gt; &quot;to&quot; applies only to &quot;equal&quot; and not to &quot;less than”<br>&gt; <br>&gt; Since `adding(_:)` is instead now an operator in the current version<br>&gt; of the proposal, could comparison functions also be operators only?<br></p><p>They could, but you still need isUnordered(with: ) and isTotallyOrdered(with: ), as they don’t have operator equivalents.<br></p><p>&gt; Incorrect nomenclature in an attempt to correct previously misleading<br>&gt; nomenclature:<br>&gt; * `leastMagnitude` should be `leastPositive` or `minPositive`, because<br>&gt; magnitudes can be zero: it&#39;s bonkers that<br>&gt; `Double.minimumMagnitude(0.0, Double.leastMagnitude) &lt;<br>&gt; Double.leastMagnitude`!<br>&gt; (Likewise, `leastNormalMagnitude` should be `leastNormalPositive` or<br>&gt; `minPositive`, and `greatestFiniteMagnitude` should be<br>&gt; `greatestFinite` or `maxFinite`)<br>&gt; <br>&gt; Inconsistencies with Integer protocols (at least, as they are currently):<br>&gt; * properties named &quot;least...&quot; or &quot;greatest...&quot; are inconsistent with<br>&gt; conceptually similar properties such as `Int.min` and `Int.max`<br></p><p>`min` and `max` were deliberately avoided based on a discussion with the Apple standard library team; these properties don’t really behave like the integer bounds properties, so naming them similarly may be confusing.<br></p><p>Your point about magnitudes being non-zero is reasonable, but I think you’ve taken it a step to far; it could be corrected by simply changing `leastMagnitude` to either `leastPositiveMagnitude` or `leastNonzeroMagnitude`.<br></p><p>`leastNormalMagnitude` and `greatestFiniteMagnitude` are accurate as is.  (`minPositive`, on the other hand, would be exceedingly misleading).  Can you expand on why you want to change them?  It seems like you simply prefer “positive” to “magnitude”?<br></p><p>&gt; Use of one term-of-art (`ulp`), as Swift naming guidelines allow and<br>&gt; even encourage, but failure to use more widely understood terms of<br>&gt; art:<br>&gt; * `squareRoot()` should be `sqrt()`<br>&gt; * something really ought to be done about<br>&gt; `truncatingRemainder(dividingBy:)`--the fact that the comments tell<br>&gt; the reader that `truncatingRemainder(dividingBy:)` is equivalent to C<br>&gt; `fmod` suggests to me that `fmod` may be a widely understood<br>&gt; term-of-art<br>&gt; I argue strongly that Swift&#39;s naming guidelines about terms-of-art<br>&gt; should be understood to encourage terms used widely in other languages<br>&gt; for basic mathematical functions instead of written-out English<br>&gt; equivalents--e.g. `asinh` instead of`inverseHyperbolicSine`. Looking<br>&gt; to other C-style languages, all seem to accept these shorter terms<br>&gt; as-is without writing them out.<br></p><p>sqrt( ) I could support, but fmod( ) is an absolutely terrible name for a relatively rarely-used function.  If there were a good term-of-art, I would want to use it, but AFAIK there isn’t.<br></p><p>I should note that the free functions sqrt( ) and fmod( ) won’t go away with this proposal.  They will continue to be supplied by the math overlay for Float, Double, CGFloat, just not for the FloatingPoint protocol.  So why do we need them in the FloatingPoint protocol at all?<br></p><p>The squareRoot( ) and remainder( ) methods are distinct from most of the other &lt;math.h&gt; functions in that IEEE 754 considers them to be &quot;basic operations” as defined by clause 5 of the standard (IEEE 754 spells out the name “squareRoot” FWIW, though there’s no requirement that we follow that).  Because of this it makes sense to require them as methods in the FloatingPoint protocol, rather than only as free functions.  [truncatingRemainder( ) is not required by IEEE 754, but it doesn’t impose a significant implementation burden and eases the transition for folks currently using operator %.]<br></p><p>– Steve<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April 20, 2016 at 11:00:00am</p></header><div class="content"><p>On Wed, Apr 20, 2016 at 5:38 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt; Hi Xiaodi —<br>&gt;<br>&gt; Thanks for the detailed comments.  Some thoughts inline.<br>&gt;<br>&gt;&gt; On Apr 19, 2016, at 6:34 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt;<br>&gt;&gt; +1 in intent. Specifics require further refinement. For example:<br>&gt;&gt;<br>&gt;&gt; Internal inconsistencies in capitalization:<br>&gt;&gt; * `signalingNaN` but `isSignalingNan` and `isNan`<br>&gt;<br>&gt; This is a typo.  Should be signalingNan.<br>&gt;<br>&gt;&gt; Parameter labels, or whatever they&#39;re called now, do not reflect newly<br>&gt;&gt; adopted Swift syntax in SE-0046:<br>&gt;&gt; * `static func maximum(x: Self, _ y: Self) -&gt; Self` should be `static<br>&gt;&gt; func maximum(_ x: Self, _ y: Self) -&gt; Self`, etc.<br>&gt;&gt;<br>&gt;&gt; Infelicitous use of prepositions to conform superficially to new<br>&gt;&gt; naming guidelines:<br>&gt;&gt; * `isEqual(to:)` is fine, but for consistency there&#39;s<br>&gt;&gt; `isLessThanOrEqual(to:)`, which is not fine, because the preposition<br>&gt;&gt; &quot;to&quot; applies only to &quot;equal&quot; and not to &quot;less than”<br>&gt;&gt;<br>&gt;&gt; Since `adding(_:)` is instead now an operator in the current version<br>&gt;&gt; of the proposal, could comparison functions also be operators only?<br>&gt;<br>&gt; They could, but you still need isUnordered(with: ) and isTotallyOrdered(with: ), as they don’t have operator equivalents.<br></p><p>My two cents are that the comparison functions that have operators<br>should stick with those operators only instead of the names.<br>Stylistically, I think `isLessThanOrEqual(to:)` is less than<br>cromulent.<br></p><p>Some thoughts on `isUnordered(with:)` and `isTotallyOrdered(with:)`--<br></p><p>1. As you mention below, implementations are free to expose<br>IEEE754-mandated operations with names that differ from the<br>specification. Looking to Java and C# as examples of how other C-style<br>languages implement floating point types, C-style languages have taken<br>a free hand in how they deal with comparison with NaN.<br></p><p>So long as we&#39;re not going down the road of having methods that expose<br>distinct unordered-quiet and unordered-signaling comparison predicates<br>as defined in IEEE754 (do any C-style languages do that?), there&#39;s<br>probably some freedom to determine whether `isUnordered(with:)` is<br>necessary as a standalone method or whether it&#39;s already sufficiently<br>provided for by other methods. In the end, `x.isUnordered(with: y)` is<br>really equivalent to `x.isNan || y.isNan`, which can be immediately<br>grokked by any reader of code.<br></p><p>2. `isTotallyOrdered(with:)` isn&#39;t quite apt as a name. As I<br>understand it, totalOrder(x, y) &quot;reflects&quot; a total ordering such that,<br>when x is ordered &quot;below&quot; y, the return value is true. (Both quoted<br>words reflect the terminology used in the specification.) So perhaps<br>`isTotallyOrdered(below:)` or even just `isOrdered(below:)` would be<br>more apt. Certainly `with` is not the correct label for the parameter,<br>as any two values that don&#39;t compare unordered should be &quot;totally<br>ordered with&quot; each other. This is especially problematic if we&#39;re<br>going to keep `isUnordered(with:)`, since those two methods would<br>suggest a complementary logical relationship that just isn&#39;t there.<br></p><p><br>&gt;<br>&gt;&gt; Incorrect nomenclature in an attempt to correct previously misleading<br>&gt;&gt; nomenclature:<br>&gt;&gt; * `leastMagnitude` should be `leastPositive` or `minPositive`, because<br>&gt;&gt; magnitudes can be zero: it&#39;s bonkers that<br>&gt;&gt; `Double.minimumMagnitude(0.0, Double.leastMagnitude) &lt;<br>&gt;&gt; Double.leastMagnitude`!<br>&gt;&gt; (Likewise, `leastNormalMagnitude` should be `leastNormalPositive` or<br>&gt;&gt; `minPositive`, and `greatestFiniteMagnitude` should be<br>&gt;&gt; `greatestFinite` or `maxFinite`)<br>&gt;&gt;<br>&gt;&gt; Inconsistencies with Integer protocols (at least, as they are currently):<br>&gt;&gt; * properties named &quot;least...&quot; or &quot;greatest...&quot; are inconsistent with<br>&gt;&gt; conceptually similar properties such as `Int.min` and `Int.max`<br>&gt;<br>&gt; `min` and `max` were deliberately avoided based on a discussion with the Apple standard library team; these properties don’t really behave like the integer bounds properties, so naming them similarly may be confusing.<br></p><p>I agree absolutely that `min` and `max`, standalone, are misleading<br>and shouldn&#39;t be used. That said, I would argue that `maxFinite` is<br>demonstrably the correct name because it&#39;s the most succinct one<br>that&#39;s both accurate and consistent with other usage. Adding<br>&quot;magnitude&quot; clarifies nothing here and in fact made me do a<br>double-take on first reading: I had to think for a split second<br>whether there exists a greater floating point value that&#39;s a finite<br>non-magnitude: it&#39;s of course absurd, but you have to think about it<br>the first time. Meanwhile, `greatestFinite` means exactly the same<br>thing as `maxFinite`, but now you&#39;re introducing a different word<br>where it&#39;s not necessary to clarify the meaning or differentiate from<br>standalone `max`.<br></p><p>&gt;<br>&gt; Your point about magnitudes being non-zero is reasonable, but I think you’ve taken it a step to far; it could be corrected by simply changing `leastMagnitude` to either `leastPositiveMagnitude` or `leastNonzeroMagnitude`.<br>&gt;<br></p><p>By the same reasoning here, `minPositive` (instead of<br>`leastMagnitude`) is equally accurate, more consistent with usage<br>elsewhere, and probably more accessible to non-native English<br>speakers. Throughout the IEEE specification, &quot;magnitude&quot; is used in<br>relation to absolute values, which is not really in play here.<br></p><p>In any case, we agree that `leastMagnitude` must at minimum be renamed<br>to exclude zero.<br></p><p>&gt; `leastNormalMagnitude` and `greatestFiniteMagnitude` are accurate as is.  (`minPositive`, on the other hand, would be exceedingly misleading).  Can you expand on why you want to change them?  It seems like you simply prefer “positive” to “magnitude”?<br></p><p>I made a typo here (I blame jetlag): `minPositiveNormal` was what I<br>meant to type. Again, my rationale is that it is the least deviation<br>from `min` that accurately describes what&#39;s going on using the<br>simplest words. Here, the distinction between normal and subnormal is<br>unavoidable, but we don&#39;t need to talk about magnitudes, and there<br>really is no difference between &quot;min&quot; and &quot;least&quot;.<br></p><p>Also potentially useful (actually, definitely useful in implementing<br>floating point strides) would be the properties `maxExactInteger`<br>(and, I suppose, a corresponding `minExactInteger`).<br></p><p><br>&gt;<br>&gt;&gt; Use of one term-of-art (`ulp`), as Swift naming guidelines allow and<br>&gt;&gt; even encourage, but failure to use more widely understood terms of<br>&gt;&gt; art:<br>&gt;&gt; * `squareRoot()` should be `sqrt()`<br>&gt;&gt; * something really ought to be done about<br>&gt;&gt; `truncatingRemainder(dividingBy:)`--the fact that the comments tell<br>&gt;&gt; the reader that `truncatingRemainder(dividingBy:)` is equivalent to C<br>&gt;&gt; `fmod` suggests to me that `fmod` may be a widely understood<br>&gt;&gt; term-of-art<br>&gt;&gt; I argue strongly that Swift&#39;s naming guidelines about terms-of-art<br>&gt;&gt; should be understood to encourage terms used widely in other languages<br>&gt;&gt; for basic mathematical functions instead of written-out English<br>&gt;&gt; equivalents--e.g. `asinh` instead of`inverseHyperbolicSine`. Looking<br>&gt;&gt; to other C-style languages, all seem to accept these shorter terms<br>&gt;&gt; as-is without writing them out.<br>&gt;<br>&gt; sqrt( ) I could support, but fmod( ) is an absolutely terrible name for a relatively rarely-used function.  If there were a good term-of-art, I would want to use it, but AFAIK there isn’t.<br>&gt;<br>&gt; I should note that the free functions sqrt( ) and fmod( ) won’t go away with this proposal.  They will continue to be supplied by the math overlay for Float, Double, CGFloat, just not for the FloatingPoint protocol.  So why do we need them in the FloatingPoint protocol at all?<br>&gt;<br>&gt; The squareRoot( ) and remainder( ) methods are distinct from most of the other &lt;math.h&gt; functions in that IEEE 754 considers them to be &quot;basic operations” as defined by clause 5 of the standard (IEEE 754 spells out the name “squareRoot” FWIW, though there’s no requirement that we follow that).<br></p><p>Even IEEE754 is interestingly inconsistent here. Throughout, it&#39;s<br>written as &quot;squareRoot&quot;, but when it comes to &quot;recommended&quot; functions,<br>the reciprocal of the square root is written &quot;rSqrt&quot; (see table 9.1).<br>I&#39;d highly recommend setting a good example of when things are<br>terms-of-art by going with &quot;sqrt&quot;.<br></p><p>While we&#39;re on the topic of IEEE754 section 5 functions, we&#39;re missing<br>abs(x) in the protocol.<br></p><p>And speaking of absolute value functions, IEEE754 calls it &quot;minNumMag&quot;<br>and &quot;maxNumMag&quot; when comparing two values but, when it comes to<br>summing, recommends a function called &quot;sumAbs&quot;. A missed opportunity<br>for consistency, IMO. When implementing in Swift, then, was there a<br>rationale for having `minimumMagnitude` instead of the much shorter<br>but equally grokkable `minAbs` (abs being, IMO, a term-of-art like<br>sqrt)?<br></p><p>And then speaking of implementations of IEEE minNum and maxNum--are<br>those static methods necessary in the protocol? What is gained over<br>having just the comparison operators?<br></p><p><br>&gt; Because of this it makes sense to require them as methods in the FloatingPoint protocol, rather than only as free functions.  [truncatingRemainder( ) is not required by IEEE 754, but it doesn’t impose a significant implementation burden and eases the transition for folks currently using operator %.]<br></p><p>I&#39;m not sure I buy the &quot;ease&quot; argument. Surely, if folks are using<br>operator %, it&#39;s equivalently difficult to transition either to the<br>free function or to `truncatingRemainder()`? Suppose you deprecate %<br>and recommend fmod(), then just leave `truncatingRemainder()` out of<br>the protocol. After all, the rationale for deprecation is that people<br>aren&#39;t using it correctly...<br></p><p>&gt;<br>&gt; – Steve<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>[Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>April 20, 2016 at 12:00:00pm</p></header><div class="content"><p>Comments inline.<br></p><p>&gt; On Apr 20, 2016, at 12:04 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Wed, Apr 20, 2016 at 5:38 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;&gt; Hi Xiaodi —<br>&gt;&gt; <br>&gt;&gt; Thanks for the detailed comments.  Some thoughts inline.<br>&gt;&gt; <br>&gt;&gt;&gt; On Apr 19, 2016, at 6:34 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +1 in intent. Specifics require further refinement. For example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Internal inconsistencies in capitalization:<br>&gt;&gt;&gt; * `signalingNaN` but `isSignalingNan` and `isNan`<br>&gt;&gt; <br>&gt;&gt; This is a typo.  Should be signalingNan.<br>&gt;&gt; <br>&gt;&gt;&gt; Parameter labels, or whatever they&#39;re called now, do not reflect newly<br>&gt;&gt;&gt; adopted Swift syntax in SE-0046:<br>&gt;&gt;&gt; * `static func maximum(x: Self, _ y: Self) -&gt; Self` should be `static<br>&gt;&gt;&gt; func maximum(_ x: Self, _ y: Self) -&gt; Self`, etc.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Infelicitous use of prepositions to conform superficially to new<br>&gt;&gt;&gt; naming guidelines:<br>&gt;&gt;&gt; * `isEqual(to:)` is fine, but for consistency there&#39;s<br>&gt;&gt;&gt; `isLessThanOrEqual(to:)`, which is not fine, because the preposition<br>&gt;&gt;&gt; &quot;to&quot; applies only to &quot;equal&quot; and not to &quot;less than”<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Since `adding(_:)` is instead now an operator in the current version<br>&gt;&gt;&gt; of the proposal, could comparison functions also be operators only?<br>&gt;&gt; <br>&gt;&gt; They could, but you still need isUnordered(with: ) and isTotallyOrdered(with: ), as they don’t have operator equivalents.<br>&gt; <br>&gt; My two cents are that the comparison functions that have operators<br>&gt; should stick with those operators only instead of the names.<br>&gt; Stylistically, I think `isLessThanOrEqual(to:)` is less than<br>&gt; cromulent.<br>&gt; <br>&gt; Some thoughts on `isUnordered(with:)` and `isTotallyOrdered(with:)`--<br>&gt; <br>&gt; 1. As you mention below, implementations are free to expose<br>&gt; IEEE754-mandated operations with names that differ from the<br>&gt; specification. Looking to Java and C# as examples of how other C-style<br>&gt; languages implement floating point types, C-style languages have taken<br>&gt; a free hand in how they deal with comparison with NaN.<br>&gt; <br>&gt; So long as we&#39;re not going down the road of having methods that expose<br>&gt; distinct unordered-quiet and unordered-signaling comparison predicates<br>&gt; as defined in IEEE754 (do any C-style languages do that?), there&#39;s<br>&gt; probably some freedom to determine whether `isUnordered(with:)` is<br>&gt; necessary as a standalone method or whether it&#39;s already sufficiently<br>&gt; provided for by other methods. In the end, `x.isUnordered(with: y)` is<br>&gt; really equivalent to `x.isNan || y.isNan`, which can be immediately<br>&gt; grokked by any reader of code.<br>&gt; <br>&gt; 2. `isTotallyOrdered(with:)` isn&#39;t quite apt as a name. As I<br>&gt; understand it, totalOrder(x, y) &quot;reflects&quot; a total ordering such that,<br>&gt; when x is ordered &quot;below&quot; y, the return value is true. (Both quoted<br>&gt; words reflect the terminology used in the specification.) So perhaps<br>&gt; `isTotallyOrdered(below:)` or even just `isOrdered(below:)` would be<br>&gt; more apt. Certainly `with` is not the correct label for the parameter,<br>&gt; as any two values that don&#39;t compare unordered should be &quot;totally<br>&gt; ordered with&quot; each other. This is especially problematic if we&#39;re<br>&gt; going to keep `isUnordered(with:)`, since those two methods would<br>&gt; suggest a complementary logical relationship that just isn&#39;t there.<br></p><p>Yes, if we drop isUnordered(with:), then renaming this isOrdered(below:) would work.  I’m OK with this approach.<br></p><p>&gt;&gt;&gt; Incorrect nomenclature in an attempt to correct previously misleading<br>&gt;&gt;&gt; nomenclature:<br>&gt;&gt;&gt; * `leastMagnitude` should be `leastPositive` or `minPositive`, because<br>&gt;&gt;&gt; magnitudes can be zero: it&#39;s bonkers that<br>&gt;&gt;&gt; `Double.minimumMagnitude(0.0, Double.leastMagnitude) &lt;<br>&gt;&gt;&gt; Double.leastMagnitude`!<br>&gt;&gt;&gt; (Likewise, `leastNormalMagnitude` should be `leastNormalPositive` or<br>&gt;&gt;&gt; `minPositive`, and `greatestFiniteMagnitude` should be<br>&gt;&gt;&gt; `greatestFinite` or `maxFinite`)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Inconsistencies with Integer protocols (at least, as they are currently):<br>&gt;&gt;&gt; * properties named &quot;least...&quot; or &quot;greatest...&quot; are inconsistent with<br>&gt;&gt;&gt; conceptually similar properties such as `Int.min` and `Int.max`<br>&gt;&gt; <br>&gt;&gt; `min` and `max` were deliberately avoided based on a discussion with the Apple standard library team; these properties don’t really behave like the integer bounds properties, so naming them similarly may be confusing.<br>&gt; <br>&gt; I agree absolutely that `min` and `max`, standalone, are misleading<br>&gt; and shouldn&#39;t be used. That said, I would argue that `maxFinite` is<br>&gt; demonstrably the correct name because it&#39;s the most succinct one<br>&gt; that&#39;s both accurate and consistent with other usage. Adding<br>&gt; &quot;magnitude&quot; clarifies nothing here and in fact made me do a<br>&gt; double-take on first reading: I had to think for a split second<br>&gt; whether there exists a greater floating point value that&#39;s a finite<br>&gt; non-magnitude: it&#39;s of course absurd, but you have to think about it<br>&gt; the first time. Meanwhile, `greatestFinite` means exactly the same<br>&gt; thing as `maxFinite`, but now you&#39;re introducing a different word<br>&gt; where it&#39;s not necessary to clarify the meaning or differentiate from<br>&gt; standalone `max`.<br></p><p>My biggest concern with `maxFinite` is that it would seem to also require a `minFinite`, which would then be easily confused with e.g. DBL_MIN (which means something radically different), and also implies that they might not be symmetric after all.  To my ear, “magnitude” more readily suggests the existing symmetry: namely that I can get the finite bounds as +/-.greatestFiniteMagnitude.<br></p><p>FWIW, 754 actually explicitly describes least[Positive]Magnitude as “the positive number of least magnitude” (the definition of nextUp, 5.3.1).<br></p><p>&gt;&gt; Your point about magnitudes being non-zero is reasonable, but I think you’ve taken it a step to far; it could be corrected by simply changing `leastMagnitude` to either `leastPositiveMagnitude` or `leastNonzeroMagnitude`.<br>&gt; <br>&gt; By the same reasoning here, `minPositive` (instead of<br>&gt; `leastMagnitude`) is equally accurate, more consistent with usage<br>&gt; elsewhere, and probably more accessible to non-native English<br>&gt; speakers. Throughout the IEEE specification, &quot;magnitude&quot; is used in<br>&gt; relation to absolute values, which is not really in play here.<br>&gt; <br>&gt; In any case, we agree that `leastMagnitude` must at minimum be renamed<br>&gt; to exclude zero.<br>&gt; <br>&gt;&gt; `leastNormalMagnitude` and `greatestFiniteMagnitude` are accurate as is.  (`minPositive`, on the other hand, would be exceedingly misleading).  Can you expand on why you want to change them?  It seems like you simply prefer “positive” to “magnitude”?<br>&gt; <br>&gt; I made a typo here (I blame jetlag): `minPositiveNormal` was what I<br>&gt; meant to type. Again, my rationale is that it is the least deviation<br>&gt; from `min` that accurately describes what&#39;s going on using the<br>&gt; simplest words. Here, the distinction between normal and subnormal is<br>&gt; unavoidable, but we don&#39;t need to talk about magnitudes, and there<br>&gt; really is no difference between &quot;min&quot; and &quot;least”.<br></p><p>One is a word, the other is an abbreviation.  The swift guidelines, for better or worse, counsel us to “avoid abbreviations”.  The fact that “min&quot; is a term of art makes it plausible, but I don’t think we’re desperate to save two characters in the name.<br></p><p>&gt; Also potentially useful (actually, definitely useful in implementing<br>&gt; floating point strides) would be the properties `maxExactInteger`<br>&gt; (and, I suppose, a corresponding `minExactInteger`).<br></p><p>An early draft of the protocol had these.  Naming this property is *hard*, because every floating-point value larger than `maxExactInteger` is … an exact integer.  If you want to be unambiguously precise, you end up with something horrible.  Ultimately I punted on this issue, but I would definitely support adding it in the future if an appropriate name can be found, or if a compelling use case arises (I don’t think it’s actually needed for implementing strides).<br></p><p>&gt;&gt;&gt; Use of one term-of-art (`ulp`), as Swift naming guidelines allow and<br>&gt;&gt;&gt; even encourage, but failure to use more widely understood terms of<br>&gt;&gt;&gt; art:<br>&gt;&gt;&gt; * `squareRoot()` should be `sqrt()`<br>&gt;&gt;&gt; * something really ought to be done about<br>&gt;&gt;&gt; `truncatingRemainder(dividingBy:)`--the fact that the comments tell<br>&gt;&gt;&gt; the reader that `truncatingRemainder(dividingBy:)` is equivalent to C<br>&gt;&gt;&gt; `fmod` suggests to me that `fmod` may be a widely understood<br>&gt;&gt;&gt; term-of-art<br>&gt;&gt;&gt; I argue strongly that Swift&#39;s naming guidelines about terms-of-art<br>&gt;&gt;&gt; should be understood to encourage terms used widely in other languages<br>&gt;&gt;&gt; for basic mathematical functions instead of written-out English<br>&gt;&gt;&gt; equivalents--e.g. `asinh` instead of`inverseHyperbolicSine`. Looking<br>&gt;&gt;&gt; to other C-style languages, all seem to accept these shorter terms<br>&gt;&gt;&gt; as-is without writing them out.<br>&gt;&gt; <br>&gt;&gt; sqrt( ) I could support, but fmod( ) is an absolutely terrible name for a relatively rarely-used function.  If there were a good term-of-art, I would want to use it, but AFAIK there isn’t.<br>&gt;&gt; <br>&gt;&gt; I should note that the free functions sqrt( ) and fmod( ) won’t go away with this proposal.  They will continue to be supplied by the math overlay for Float, Double, CGFloat, just not for the FloatingPoint protocol.  So why do we need them in the FloatingPoint protocol at all?<br>&gt;&gt; <br>&gt;&gt; The squareRoot( ) and remainder( ) methods are distinct from most of the other &lt;math.h&gt; functions in that IEEE 754 considers them to be &quot;basic operations” as defined by clause 5 of the standard (IEEE 754 spells out the name “squareRoot” FWIW, though there’s no requirement that we follow that).<br>&gt; <br>&gt; Even IEEE754 is interestingly inconsistent here. Throughout, it&#39;s<br>&gt; written as &quot;squareRoot&quot;, but when it comes to &quot;recommended&quot; functions,<br>&gt; the reciprocal of the square root is written &quot;rSqrt&quot; (see table 9.1).<br>&gt; I&#39;d highly recommend setting a good example of when things are<br>&gt; terms-of-art by going with &quot;sqrt”.<br></p><p>Clause 9, being non-normative, didn&#39;t receive nearly as much editorial attention.<br></p><p>&gt; While we&#39;re on the topic of IEEE754 section 5 functions, we&#39;re missing<br>&gt; abs(x) in the protocol.<br></p><p>abs() would have come from SignedArithmetic, but you’re right that it’s now missing and should be added to FloatingPoint.<br></p><p>&gt; And speaking of absolute value functions, IEEE754 calls it &quot;minNumMag&quot;<br>&gt; and &quot;maxNumMag&quot; when comparing two values but, when it comes to<br>&gt; summing, recommends a function called &quot;sumAbs&quot;. A missed opportunity<br>&gt; for consistency, IMO. When implementing in Swift, then, was there a<br>&gt; rationale for having `minimumMagnitude` instead of the much shorter<br>&gt; but equally grokkable `minAbs` (abs being, IMO, a term-of-art like<br>&gt; sqrt)?<br></p><p>maxAbs is unclear (to me);  I could easily imagine that it returns max(abs(x), abs(y)).  Given that these methods have no precedent in C-family languages, there isn’t an actual term of art to follow, and the meaning of maxAbs isn’t particularly obvious.<br></p><p>&gt; And then speaking of implementations of IEEE minNum and maxNum--are<br>&gt; those static methods necessary in the protocol? What is gained over<br>&gt; having just the comparison operators?<br></p><p>While one can write these operations in terms of the comparison operators, it’s a bit unwieldy to do so, and requires some heroics from the optimizer to turn such an expanded definition into e.g. the arm64 FMAXNM instruction or the AVX-512 VRANGE instruction.  It’s somewhat easier to wire up those optimizations this way.<br></p><p>Similarly, having these methods directly available is a useful optimization hook for user-defined types that conform to the protocol (though the protocol *will* provide default implementations, so you’re not obligated to do so).<br></p><p>&gt;&gt; Because of this it makes sense to require them as methods in the FloatingPoint protocol, rather than only as free functions.  [truncatingRemainder( ) is not required by IEEE 754, but it doesn’t impose a significant implementation burden and eases the transition for folks currently using operator %.]<br>&gt; <br>&gt; I&#39;m not sure I buy the &quot;ease&quot; argument. Surely, if folks are using<br>&gt; operator %, it&#39;s equivalently difficult to transition either to the<br>&gt; free function or to `truncatingRemainder()`? Suppose you deprecate %<br>&gt; and recommend fmod(), then just leave `truncatingRemainder()` out of<br>&gt; the protocol. After all, the rationale for deprecation is that people<br>&gt; aren&#39;t using it correctly...<br></p><p>fmod() wraps the C stdlib fmod(), so only exists for types supported by the C stdlib.  The truncatingRemainder() method is available for all FloatingPoint types (these two sets of types are equivalent for Swift today, but if someone wants to write a library type that conforms to FloatingPoint, it would provide truncatingRemainder).<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April 20, 2016 at 12:00:00pm</p></header><div class="content"><p>On Wed, Apr 20, 2016 at 11:37 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt; Comments inline.<br>&gt;<br>&gt;&gt; On Apr 20, 2016, at 12:04 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Wed, Apr 20, 2016 at 5:38 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;&gt;&gt; Hi Xiaodi —<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Thanks for the detailed comments.  Some thoughts inline.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Apr 19, 2016, at 6:34 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; +1 in intent. Specifics require further refinement. For example:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Internal inconsistencies in capitalization:<br>&gt;&gt;&gt;&gt; * `signalingNaN` but `isSignalingNan` and `isNan`<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This is a typo.  Should be signalingNan.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Parameter labels, or whatever they&#39;re called now, do not reflect newly<br>&gt;&gt;&gt;&gt; adopted Swift syntax in SE-0046:<br>&gt;&gt;&gt;&gt; * `static func maximum(x: Self, _ y: Self) -&gt; Self` should be `static<br>&gt;&gt;&gt;&gt; func maximum(_ x: Self, _ y: Self) -&gt; Self`, etc.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Infelicitous use of prepositions to conform superficially to new<br>&gt;&gt;&gt;&gt; naming guidelines:<br>&gt;&gt;&gt;&gt; * `isEqual(to:)` is fine, but for consistency there&#39;s<br>&gt;&gt;&gt;&gt; `isLessThanOrEqual(to:)`, which is not fine, because the preposition<br>&gt;&gt;&gt;&gt; &quot;to&quot; applies only to &quot;equal&quot; and not to &quot;less than”<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Since `adding(_:)` is instead now an operator in the current version<br>&gt;&gt;&gt;&gt; of the proposal, could comparison functions also be operators only?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; They could, but you still need isUnordered(with: ) and isTotallyOrdered(with: ), as they don’t have operator equivalents.<br>&gt;&gt;<br>&gt;&gt; My two cents are that the comparison functions that have operators<br>&gt;&gt; should stick with those operators only instead of the names.<br>&gt;&gt; Stylistically, I think `isLessThanOrEqual(to:)` is less than<br>&gt;&gt; cromulent.<br>&gt;&gt;<br>&gt;&gt; Some thoughts on `isUnordered(with:)` and `isTotallyOrdered(with:)`--<br>&gt;&gt;<br>&gt;&gt; 1. As you mention below, implementations are free to expose<br>&gt;&gt; IEEE754-mandated operations with names that differ from the<br>&gt;&gt; specification. Looking to Java and C# as examples of how other C-style<br>&gt;&gt; languages implement floating point types, C-style languages have taken<br>&gt;&gt; a free hand in how they deal with comparison with NaN.<br>&gt;&gt;<br>&gt;&gt; So long as we&#39;re not going down the road of having methods that expose<br>&gt;&gt; distinct unordered-quiet and unordered-signaling comparison predicates<br>&gt;&gt; as defined in IEEE754 (do any C-style languages do that?), there&#39;s<br>&gt;&gt; probably some freedom to determine whether `isUnordered(with:)` is<br>&gt;&gt; necessary as a standalone method or whether it&#39;s already sufficiently<br>&gt;&gt; provided for by other methods. In the end, `x.isUnordered(with: y)` is<br>&gt;&gt; really equivalent to `x.isNan || y.isNan`, which can be immediately<br>&gt;&gt; grokked by any reader of code.<br>&gt;&gt;<br>&gt;&gt; 2. `isTotallyOrdered(with:)` isn&#39;t quite apt as a name. As I<br>&gt;&gt; understand it, totalOrder(x, y) &quot;reflects&quot; a total ordering such that,<br>&gt;&gt; when x is ordered &quot;below&quot; y, the return value is true. (Both quoted<br>&gt;&gt; words reflect the terminology used in the specification.) So perhaps<br>&gt;&gt; `isTotallyOrdered(below:)` or even just `isOrdered(below:)` would be<br>&gt;&gt; more apt. Certainly `with` is not the correct label for the parameter,<br>&gt;&gt; as any two values that don&#39;t compare unordered should be &quot;totally<br>&gt;&gt; ordered with&quot; each other. This is especially problematic if we&#39;re<br>&gt;&gt; going to keep `isUnordered(with:)`, since those two methods would<br>&gt;&gt; suggest a complementary logical relationship that just isn&#39;t there.<br>&gt;<br>&gt; Yes, if we drop isUnordered(with:), then renaming this isOrdered(below:) would work.  I’m OK with this approach.<br>&gt;<br>&gt;&gt;&gt;&gt; Incorrect nomenclature in an attempt to correct previously misleading<br>&gt;&gt;&gt;&gt; nomenclature:<br>&gt;&gt;&gt;&gt; * `leastMagnitude` should be `leastPositive` or `minPositive`, because<br>&gt;&gt;&gt;&gt; magnitudes can be zero: it&#39;s bonkers that<br>&gt;&gt;&gt;&gt; `Double.minimumMagnitude(0.0, Double.leastMagnitude) &lt;<br>&gt;&gt;&gt;&gt; Double.leastMagnitude`!<br>&gt;&gt;&gt;&gt; (Likewise, `leastNormalMagnitude` should be `leastNormalPositive` or<br>&gt;&gt;&gt;&gt; `minPositive`, and `greatestFiniteMagnitude` should be<br>&gt;&gt;&gt;&gt; `greatestFinite` or `maxFinite`)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Inconsistencies with Integer protocols (at least, as they are currently):<br>&gt;&gt;&gt;&gt; * properties named &quot;least...&quot; or &quot;greatest...&quot; are inconsistent with<br>&gt;&gt;&gt;&gt; conceptually similar properties such as `Int.min` and `Int.max`<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; `min` and `max` were deliberately avoided based on a discussion with the Apple standard library team; these properties don’t really behave like the integer bounds properties, so naming them similarly may be confusing.<br>&gt;&gt;<br>&gt;&gt; I agree absolutely that `min` and `max`, standalone, are misleading<br>&gt;&gt; and shouldn&#39;t be used. That said, I would argue that `maxFinite` is<br>&gt;&gt; demonstrably the correct name because it&#39;s the most succinct one<br>&gt;&gt; that&#39;s both accurate and consistent with other usage. Adding<br>&gt;&gt; &quot;magnitude&quot; clarifies nothing here and in fact made me do a<br>&gt;&gt; double-take on first reading: I had to think for a split second<br>&gt;&gt; whether there exists a greater floating point value that&#39;s a finite<br>&gt;&gt; non-magnitude: it&#39;s of course absurd, but you have to think about it<br>&gt;&gt; the first time. Meanwhile, `greatestFinite` means exactly the same<br>&gt;&gt; thing as `maxFinite`, but now you&#39;re introducing a different word<br>&gt;&gt; where it&#39;s not necessary to clarify the meaning or differentiate from<br>&gt;&gt; standalone `max`.<br>&gt;<br>&gt; My biggest concern with `maxFinite` is that it would seem to also require a `minFinite`, which would then be easily confused with e.g. DBL_MIN (which means something radically different), and also implies that they might not be symmetric after all.  To my ear, “magnitude” more readily suggests the existing symmetry: namely that I can get the finite bounds as +/-.greatestFiniteMagnitude.<br></p><p>That&#39;s a fair point.<br></p><p>&gt;<br>&gt; FWIW, 754 actually explicitly describes least[Positive]Magnitude as “the positive number of least magnitude” (the definition of nextUp, 5.3.1).<br>&gt;<br>&gt;&gt;&gt; Your point about magnitudes being non-zero is reasonable, but I think you’ve taken it a step to far; it could be corrected by simply changing `leastMagnitude` to either `leastPositiveMagnitude` or `leastNonzeroMagnitude`.<br>&gt;&gt;<br>&gt;&gt; By the same reasoning here, `minPositive` (instead of<br>&gt;&gt; `leastMagnitude`) is equally accurate, more consistent with usage<br>&gt;&gt; elsewhere, and probably more accessible to non-native English<br>&gt;&gt; speakers. Throughout the IEEE specification, &quot;magnitude&quot; is used in<br>&gt;&gt; relation to absolute values, which is not really in play here.<br>&gt;&gt;<br>&gt;&gt; In any case, we agree that `leastMagnitude` must at minimum be renamed<br>&gt;&gt; to exclude zero.<br>&gt;&gt;<br>&gt;&gt;&gt; `leastNormalMagnitude` and `greatestFiniteMagnitude` are accurate as is.  (`minPositive`, on the other hand, would be exceedingly misleading).  Can you expand on why you want to change them?  It seems like you simply prefer “positive” to “magnitude”?<br>&gt;&gt;<br>&gt;&gt; I made a typo here (I blame jetlag): `minPositiveNormal` was what I<br>&gt;&gt; meant to type. Again, my rationale is that it is the least deviation<br>&gt;&gt; from `min` that accurately describes what&#39;s going on using the<br>&gt;&gt; simplest words. Here, the distinction between normal and subnormal is<br>&gt;&gt; unavoidable, but we don&#39;t need to talk about magnitudes, and there<br>&gt;&gt; really is no difference between &quot;min&quot; and &quot;least”.<br>&gt;<br>&gt; One is a word, the other is an abbreviation.  The swift guidelines, for better or worse, counsel us to “avoid abbreviations”.  The fact that “min&quot; is a term of art makes it plausible, but I don’t think we’re desperate to save two characters in the name.<br>&gt;<br>&gt;&gt; Also potentially useful (actually, definitely useful in implementing<br>&gt;&gt; floating point strides) would be the properties `maxExactInteger`<br>&gt;&gt; (and, I suppose, a corresponding `minExactInteger`).<br>&gt;<br>&gt; An early draft of the protocol had these.  Naming this property is *hard*, because every floating-point value larger than `maxExactInteger` is … an exact integer.  If you want to be unambiguously precise, you end up with something horrible.  Ultimately I punted on this issue, but I would definitely support adding it in the future if an appropriate name can be found, or if a compelling use case arises (I don’t think it’s actually needed for implementing strides).<br></p><p>Ouch, yes, this isn&#39;t trivial to name. The best I have is<br>`greatestUnitDecrementableInteger`, which is awful.<br></p><p>&gt;&gt;&gt;&gt; Use of one term-of-art (`ulp`), as Swift naming guidelines allow and<br>&gt;&gt;&gt;&gt; even encourage, but failure to use more widely understood terms of<br>&gt;&gt;&gt;&gt; art:<br>&gt;&gt;&gt;&gt; * `squareRoot()` should be `sqrt()`<br>&gt;&gt;&gt;&gt; * something really ought to be done about<br>&gt;&gt;&gt;&gt; `truncatingRemainder(dividingBy:)`--the fact that the comments tell<br>&gt;&gt;&gt;&gt; the reader that `truncatingRemainder(dividingBy:)` is equivalent to C<br>&gt;&gt;&gt;&gt; `fmod` suggests to me that `fmod` may be a widely understood<br>&gt;&gt;&gt;&gt; term-of-art<br>&gt;&gt;&gt;&gt; I argue strongly that Swift&#39;s naming guidelines about terms-of-art<br>&gt;&gt;&gt;&gt; should be understood to encourage terms used widely in other languages<br>&gt;&gt;&gt;&gt; for basic mathematical functions instead of written-out English<br>&gt;&gt;&gt;&gt; equivalents--e.g. `asinh` instead of`inverseHyperbolicSine`. Looking<br>&gt;&gt;&gt;&gt; to other C-style languages, all seem to accept these shorter terms<br>&gt;&gt;&gt;&gt; as-is without writing them out.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; sqrt( ) I could support, but fmod( ) is an absolutely terrible name for a relatively rarely-used function.  If there were a good term-of-art, I would want to use it, but AFAIK there isn’t.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I should note that the free functions sqrt( ) and fmod( ) won’t go away with this proposal.  They will continue to be supplied by the math overlay for Float, Double, CGFloat, just not for the FloatingPoint protocol.  So why do we need them in the FloatingPoint protocol at all?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The squareRoot( ) and remainder( ) methods are distinct from most of the other &lt;math.h&gt; functions in that IEEE 754 considers them to be &quot;basic operations” as defined by clause 5 of the standard (IEEE 754 spells out the name “squareRoot” FWIW, though there’s no requirement that we follow that).<br>&gt;&gt;<br>&gt;&gt; Even IEEE754 is interestingly inconsistent here. Throughout, it&#39;s<br>&gt;&gt; written as &quot;squareRoot&quot;, but when it comes to &quot;recommended&quot; functions,<br>&gt;&gt; the reciprocal of the square root is written &quot;rSqrt&quot; (see table 9.1).<br>&gt;&gt; I&#39;d highly recommend setting a good example of when things are<br>&gt;&gt; terms-of-art by going with &quot;sqrt”.<br>&gt;<br>&gt; Clause 9, being non-normative, didn&#39;t receive nearly as much editorial attention.<br>&gt;<br>&gt;&gt; While we&#39;re on the topic of IEEE754 section 5 functions, we&#39;re missing<br>&gt;&gt; abs(x) in the protocol.<br>&gt;<br>&gt; abs() would have come from SignedArithmetic, but you’re right that it’s now missing and should be added to FloatingPoint.<br>&gt;<br>&gt;&gt; And speaking of absolute value functions, IEEE754 calls it &quot;minNumMag&quot;<br>&gt;&gt; and &quot;maxNumMag&quot; when comparing two values but, when it comes to<br>&gt;&gt; summing, recommends a function called &quot;sumAbs&quot;. A missed opportunity<br>&gt;&gt; for consistency, IMO. When implementing in Swift, then, was there a<br>&gt;&gt; rationale for having `minimumMagnitude` instead of the much shorter<br>&gt;&gt; but equally grokkable `minAbs` (abs being, IMO, a term-of-art like<br>&gt;&gt; sqrt)?<br>&gt;<br>&gt; maxAbs is unclear (to me);  I could easily imagine that it returns max(abs(x), abs(y)).  Given that these methods have no precedent in C-family languages, there isn’t an actual term of art to follow, and the meaning of maxAbs isn’t particularly obvious.<br></p><p>Actually, now that you point it out, `max(abs(x), abs(y))` is exactly<br>what I thought maxNumMag would do, which it does not. I&#39;m not sure<br>`minimumMagnitude()` helps in this respect. I kind of want to suggest<br>a more descriptive name, something like `minimumComparingMagnitude()`<br>or `minimumIgnoringSign()`.<br></p><p>&gt;<br>&gt;&gt; And then speaking of implementations of IEEE minNum and maxNum--are<br>&gt;&gt; those static methods necessary in the protocol? What is gained over<br>&gt;&gt; having just the comparison operators?<br>&gt;<br>&gt; While one can write these operations in terms of the comparison operators, it’s a bit unwieldy to do so, and requires some heroics from the optimizer to turn such an expanded definition into e.g. the arm64 FMAXNM instruction or the AVX-512 VRANGE instruction.  It’s somewhat easier to wire up those optimizations this way.<br>&gt;<br>&gt; Similarly, having these methods directly available is a useful optimization hook for user-defined types that conform to the protocol (though the protocol *will* provide default implementations, so you’re not obligated to do so).<br>&gt;<br>&gt;&gt;&gt; Because of this it makes sense to require them as methods in the FloatingPoint protocol, rather than only as free functions.  [truncatingRemainder( ) is not required by IEEE 754, but it doesn’t impose a significant implementation burden and eases the transition for folks currently using operator %.]<br>&gt;&gt;<br>&gt;&gt; I&#39;m not sure I buy the &quot;ease&quot; argument. Surely, if folks are using<br>&gt;&gt; operator %, it&#39;s equivalently difficult to transition either to the<br>&gt;&gt; free function or to `truncatingRemainder()`? Suppose you deprecate %<br>&gt;&gt; and recommend fmod(), then just leave `truncatingRemainder()` out of<br>&gt;&gt; the protocol. After all, the rationale for deprecation is that people<br>&gt;&gt; aren&#39;t using it correctly...<br>&gt;<br>&gt; fmod() wraps the C stdlib fmod(), so only exists for types supported by the C stdlib.  The truncatingRemainder() method is available for all FloatingPoint types (these two sets of types are equivalent for Swift today, but if someone wants to write a library type that conforms to FloatingPoint, it would provide truncatingRemainder).<br></p><p>I suppose the salient question here is, given that fmod-like behavior<br>is usually not an ideal choice for floating point types, do we want to<br>make it available (or, if no default implementation will be provided,<br>force it to be made available) for those floating point types outside<br>the C stdlib?<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>April 20, 2016 at 10:00:00am</p></header><div class="content"><p>&gt;<br>&gt; The review of &quot;SE-0067: Enhanced Floating Point Protocols&quot; begins now and<br>&gt; runs through April 25. The proposal is available here:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0067-floating-point-protocols.md<br>&gt;<br>&gt;<br>&gt;         * What is your evaluation of the proposal?<br>&gt;<br></p><p>+1, a valuable addition, with a few details I think could be improved:<br></p><p>    1. Consistent naming:<br>        1.a. Use the xxxed form of naming rather than mixing xxxed and<br>xxxing, e.g. in Arithmetic use added instead of adding to be consistent<br>with divided etc. Both name forms are allowed in the guidelines but it is<br>odd to mix them in the same API. Also see point 2 below.<br>        1.b. Use isXxx or hasXxx if that reads better for methods that<br>return Bool<br>    2. For the Arithmetic protocol use symbols instead of names, e.g.<br>`infix +` instead of `added`.<br></p><p><br>&gt;         * Is the problem being addressed significant enough to warrant a<br>&gt; change to Swift?<br>&gt;<br></p><p>Yes, I have needed this a number of times<br></p><p><br>&gt;         * Does this proposal fit well with the feel and direction of Swift?<br>&gt;<br></p><p>Yes<br></p><p><br>&gt;         * If you have you used other languages or libraries with a similar<br>&gt; feature, how do you feel that this proposal compares to those?<br>&gt;<br></p><p>Yes, e.g. Java, very handy<br></p><p><br>&gt;         * How much effort did you put into your review? A glance, a quick<br>&gt; reading, or an in-depth study?<br>&gt;<br></p><p>Read the proposal and corresponded on Swift-Evolution and previously on the<br>old Apple-dev forums about this issue.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160420/10ff42c0/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>April 21, 2016 at 06:00:00pm</p></header><div class="content"><p>[Proposal: https://github.com/apple/swift-evolution/blob/master/proposals/0067-floating-point-protocols.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0067-floating-point-protocols.md&gt;]<br></p><p>This is super impressive. I do have several bits I’m uncomfortable with, however. I’ll try to separate that into “semantic” and “naming” sections.<br></p><p>Semantic<br></p><p>static var radix: Int { get }<br></p><p>Does it ever make sense to have a model type that allows different instances to have different radices?<br></p><p>Is there an algorithm that makes use of a model’s radix, or is this just in here for “completeness”?<br></p><p><br>  /// A signaling NaN (not-a-number).<br>  @warn_unused_result<br>  static func signalingNaN: Self { get }<br></p><p>I’m not sure it really makes sense for a Bignum / APFloat type to support such a value. But really I think this is just underspecified. What does it mean, in terms of this protocol and its uses, for a NaN to be signaling? Is it just a specific “color&quot; of NaN, with no semantic requirements other than being distinguishable?<br></p><p>(Also, is ‘signalingNan.isNan’ true? I assume so but since ’nan’ is implied to be a non-signaling NaN I’m not sure anymore.)<br></p><p><br>  var signBit: Bool { get }<br></p><p>Unlike Chris, I’m strongly against this property as it stands. You should not be able to write “if someValue.signBit”; a bit is not a boolean value. (Citation: &quot;Uses of Boolean methods and properties should read as assertions about the receiver &lt;https://swift.org/documentation/api-design-guidelines/#strive-for-fluent-usage&gt;.”)<br></p><p>I’d be okay with Greg’s idea of changing the type to an enum. I’d also be okay with renaming this to a predicate, whatever the name ends up being. (“isSignBitSet”, “isSignNegative”, etc.)<br></p><p><br>  var exponent: Int { get }<br></p><p>Nitpick: it’s probably worth noting in the doc comment that this is the unbiased exponent value.<br></p><p>Also, does it matter that this is insufficient for bignums, which may have an exponent of greater than `sizeof(Int.self)` bits? (This is also a concern for a number of members of BinaryFloatingPoint, like ‘significantBitCount&#39;.)<br></p><p><br>Naming<br></p><p>On “NaN” vs. “Nan”: I’m not convinced that ignoring the case is the right way to go here. IMHO the clearest lowercase form is “nan” and the clearest capitalized form is “NaN”.<br></p><p>The current draft API guidelines &lt;https://swift.org/documentation/api-design-guidelines/#general-conventions&gt; don’t cover this case, but if I were to add something for this, I’d say “when a word is normally written with mixed case, the lowercase form should be fully-lowercased if the first letter is naturally uppercase, and the capitalized form should have the first letter uppercased only.” That rule produces “iPhone/IPhone”, “next/NeXT”, and “nan/NaN”. (The “if the first letter is naturally uppercase” could be thrown out as well.)<br></p><p><br>On &#39;isLessThanOrEqual(to:)’: I agree with Xiaodi that the argument label is problematic here. I think the problem is that we have two prepositions that apply to the argument, and “pick the second one” leaves the base name feeling unbalanced. (Remember that we allow referring to a method by its basename alone when using it as a function value.)<br></p><p><br>On &#39;isTotallyOrdered(with:)’: I lost track of who said it, but I agree that this sounds like it’s “!isUnordered(with: other)”. The only name that’s coming to mind is ‘isTotallyOrderedBefore(_:)’, which isn’t great.<br></p><p><br>On ‘binade’: At first I thought this was a confusing term and there had to be a better one, but now I think it’s an “if you don’t know what this is, you don’t need to use it” case. :-)<br></p><p><br>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160421/edcf6e3b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9db7e0c3d3ce86e2bf80675a61fbc49c?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>James Berry</string> &lt;jberry at rogueorbit.com&gt;<p>April 21, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Apr 21, 2016, at 6:13 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On &#39;isLessThanOrEqual(to:)’: I agree with Xiaodi that the argument label is problematic here. I think the problem is that we have two prepositions that apply to the argument, and “pick the second one” leaves the base name feeling unbalanced. (Remember that we allow referring to a method by its basename alone when using it as a function value.)<br></p><p>Maybe: isLessThanOrEqualTo(value:) ??<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160421/353537b3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>April 21, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Apr 21, 2016, at 19:58, James Berry &lt;jberry at rogueorbit.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 21, 2016, at 6:13 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On &#39;isLessThanOrEqual(to:)’: I agree with Xiaodi that the argument label is problematic here. I think the problem is that we have two prepositions that apply to the argument, and “pick the second one” leaves the base name feeling unbalanced. (Remember that we allow referring to a method by its basename alone when using it as a function value.)<br>&gt; <br>&gt; Maybe: isLessThanOrEqualTo(value:) ??<br></p><p>At that point the argument label doesn’t add anything that isn’t already provided by the type.<br></p><p>&quot;Otherwise, if the first argument forms part of a grammatical phrase, omit its label.&quot;<br></p><p>The “otherwise” comes after &quot;When the first argument forms part of a prepositional phrase”, but in this case it forms part of two prepositional phrases.<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160421/805f541c/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>April 22, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Apr 21, 2016, at 9:13 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; [Proposal: https://github.com/apple/swift-evolution/blob/master/proposals/0067-floating-point-protocols.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0067-floating-point-protocols.md&gt;]<br>&gt; <br>&gt; This is super impressive. I do have several bits I’m uncomfortable with, however. I’ll try to separate that into “semantic” and “naming” sections.<br>&gt; <br>&gt; Semantic<br>&gt; <br>&gt; static var radix: Int { get }<br>&gt; <br>&gt; Does it ever make sense to have a model type that allows different instances to have different radices?<br></p><p>No.<br></p><p>&gt; Is there an algorithm that makes use of a model’s radix, or is this just in here for “completeness”?<br></p><p>If you know ulp, radix, and exponent range, you can infer basically all the other numerical details of the type.  One good example would be the constant that Dave mentioned, “maxResultOfAdding1”.  You can compute this if you know radix and ulp.  The radix is also the bound on how large the relative spacing between consecutive numbers can get, which is sometimes important for computing accurate bounds.  These are all somewhat niche, but the problem is that there’s no good way to get this value if you don’t have it, and it imposes “zero” implementation burden.<br></p><p>&gt;   /// A signaling NaN (not-a-number).<br>&gt;   @warn_unused_result<br>&gt;   static func signalingNaN: Self { get }<br>&gt; <br>&gt; I’m not sure it really makes sense for a Bignum / APFloat type to support such a value. But really I think this is just underspecified. What does it mean, in terms of this protocol and its uses, for a NaN to be signaling? Is it just a specific “color&quot; of NaN, with no semantic requirements other than being distinguishable?<br></p><p>There are a variety of means that a softfloat type could use to implement signaling NaNs.  Here are two of the simpler ones:<br></p><p>(a) if running on HW with hard-float support, use native-precision hard-float instructions to set flags as needed.<br>(b) provide operation variants that take an inout flags / parameter:<br></p><p>	mutating func add(rhs: Self, inout flags: Flags)<br></p><p>&gt; (Also, is ‘signalingNan.isNan’ true? I assume so but since ’nan’ is implied to be a non-signaling NaN I’m not sure anymore.)<br></p><p>Yup, that should be clarified.<br></p><p>&gt;   var signBit: Bool { get }<br>&gt; <br>&gt; Unlike Chris, I’m strongly against this property as it stands. You should not be able to write “if someValue.signBit”; a bit is not a boolean value. (Citation: &quot;Uses of Boolean methods and properties should read as assertions about the receiver &lt;https://swift.org/documentation/api-design-guidelines/#strive-for-fluent-usage&gt;.”)<br>&gt; <br>&gt; I’d be okay with Greg’s idea of changing the type to an enum. I’d also be okay with renaming this to a predicate, whatever the name ends up being. (“isSignBitSet”, “isSignNegative”, etc.)<br></p><p>Making it a predicate is weird, because then the three properties making up the number become `isSignBitSet`, `exponent`, and `significand`; one of these things is not like the other ones.  If `signBit: Bool` were ruled out, I would rather go with Greg’s enum proposal.<br></p><p>&gt;   var exponent: Int { get }<br>&gt; <br>&gt; Nitpick: it’s probably worth noting in the doc comment that this is the unbiased exponent value.<br>&gt; <br>&gt; Also, does it matter that this is insufficient for bignums, which may have an exponent of greater than `sizeof(Int.self)` bits? (This is also a concern for a number of members of BinaryFloatingPoint, like ‘significantBitCount’.)<br></p><p>An exponent of Int.max encodes a number &gt;= 2**Int.max.  This is a staggeringly huge quantity, even when Int is 32 bits (it’s approximately 1e646456992).  There are a few extremely niche applications that require numbers with greater magnitude, but they are *extremely* rare.  To a good approximation, `Int` is more than enough bits, and a reasonable tradeoff.<br></p><p>Ditto `significandBitCount`.  I haven’t seen usage of floating-point types with more than a few thousand significand bits; billions of bits is enough.  It is plausible that one could build a type that runs into this limit on a 32-bit system, but it wouldn’t be very useful; on a 64-bit system, you can’t allocate the storage for even one such value.<br></p><p>&gt; Naming<br>&gt; <br>&gt; On “NaN” vs. “Nan”: I’m not convinced that ignoring the case is the right way to go here. IMHO the clearest lowercase form is “nan” and the clearest capitalized form is “NaN”.<br>&gt; <br>&gt; The current draft API guidelines &lt;https://swift.org/documentation/api-design-guidelines/#general-conventions&gt; don’t cover this case, but if I were to add something for this, I’d say “when a word is normally written with mixed case, the lowercase form should be fully-lowercased if the first letter is naturally uppercase, and the capitalized form should have the first letter uppercased only.” That rule produces “iPhone/IPhone”, “next/NeXT”, and “nan/NaN”. (The “if the first letter is naturally uppercase” could be thrown out as well.)<br></p><p>Yup, this seems like a sensible rule to me.<br></p><p>&gt; On &#39;isLessThanOrEqual(to:)’: I agree with Xiaodi that the argument label is problematic here. I think the problem is that we have two prepositions that apply to the argument, and “pick the second one” leaves the base name feeling unbalanced. (Remember that we allow referring to a method by its basename alone when using it as a function value.)<br>&gt; <br>&gt; On &#39;isTotallyOrdered(with:)’: I lost track of who said it, but I agree that this sounds like it’s “!isUnordered(with: other)”. The only name that’s coming to mind is ‘isTotallyOrderedBefore(_:)’, which isn’t great.<br>&gt; <br>&gt; On ‘binade’: At first I thought this was a confusing term and there had to be a better one, but now I think it’s an “if you don’t know what this is, you don’t need to use it” case. :-)<br></p><p>Yup.<br></p><p>– Steve<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160422/6d6e76b6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April 22, 2016 at 09:00:00am</p></header><div class="content"><p>On Fri, Apr 22, 2016 at 9:13 AM, Stephen Canon via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Apr 21, 2016, at 9:13 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;<br>&gt; [Proposal:<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0067-floating-point-protocols.md]<br>&gt;<br>&gt; This is super impressive. I do have several bits I’m uncomfortable with,<br>&gt; however. I’ll try to separate that into “semantic” and “naming” sections.<br>&gt;<br>&gt; Semantic<br>&gt;<br>&gt; static var radix: Int { get }<br>&gt;<br>&gt;<br>&gt; Does it ever make sense to have a model type that allows different instances<br>&gt; to have different radices?<br>&gt;<br>&gt;<br>&gt; No.<br>&gt;<br>&gt; Is there an algorithm that makes use of a model’s radix, or is this just in<br>&gt; here for “completeness”?<br>&gt;<br>&gt;<br>&gt; If you know ulp, radix, and exponent range, you can infer basically all the<br>&gt; other numerical details of the type.  One good example would be the constant<br>&gt; that Dave mentioned, “maxResultOfAdding1”.  You can compute this if you know<br>&gt; radix and ulp.  The radix is also the bound on how large the relative<br>&gt; spacing between consecutive numbers can get, which is sometimes important<br>&gt; for computing accurate bounds.  These are all somewhat niche, but the<br>&gt; problem is that there’s no good way to get this value if you don’t have it,<br>&gt; and it imposes “zero” implementation burden.<br>&gt;<br>&gt;   /// A signaling NaN (not-a-number).<br>&gt;   @warn_unused_result<br>&gt;   static func signalingNaN: Self { get }<br>&gt;<br>&gt;<br>&gt; I’m not sure it really makes sense for a Bignum / APFloat type to support<br>&gt; such a value. But really I think this is just underspecified. What does it<br>&gt; mean, in terms of this protocol and its uses, for a NaN to be signaling? Is<br>&gt; it just a specific “color&quot; of NaN, with no semantic requirements other than<br>&gt; being distinguishable?<br>&gt;<br>&gt;<br>&gt; There are a variety of means that a softfloat type could use to implement<br>&gt; signaling NaNs.  Here are two of the simpler ones:<br>&gt;<br>&gt; (a) if running on HW with hard-float support, use native-precision<br>&gt; hard-float instructions to set flags as needed.<br>&gt; (b) provide operation variants that take an inout flags / parameter:<br>&gt;<br>&gt; mutating func add(rhs: Self, inout flags: Flags)<br>&gt;<br>&gt; (Also, is ‘signalingNan.isNan’ true? I assume so but since ’nan’ is implied<br>&gt; to be a non-signaling NaN I’m not sure anymore.)<br>&gt;<br>&gt;<br>&gt; Yup, that should be clarified.<br>&gt;<br>&gt;   var signBit: Bool { get }<br>&gt;<br>&gt;<br>&gt; Unlike Chris, I’m strongly against this property as it stands. You should<br>&gt; not be able to write “if someValue.signBit”; a bit is not a boolean value.<br>&gt; (Citation: &quot;Uses of Boolean methods and properties should read as assertions<br>&gt; about the receiver.”)<br>&gt;<br>&gt; I’d be okay with Greg’s idea of changing the type to an enum. I’d also be<br>&gt; okay with renaming this to a predicate, whatever the name ends up being.<br>&gt; (“isSignBitSet”, “isSignNegative”, etc.)<br>&gt;<br>&gt;<br>&gt; Making it a predicate is weird, because then the three properties making up<br>&gt; the number become `isSignBitSet`, `exponent`, and `significand`; one of<br>&gt; these things is not like the other ones.  If `signBit: Bool` were ruled out,<br>&gt; I would rather go with Greg’s enum proposal.<br>&gt;<br>&gt;   var exponent: Int { get }<br>&gt;<br>&gt;<br>&gt; Nitpick: it’s probably worth noting in the doc comment that this is the<br>&gt; unbiased exponent value.<br>&gt;<br>&gt; Also, does it matter that this is insufficient for bignums, which may have<br>&gt; an exponent of greater than `sizeof(Int.self)` bits? (This is also a concern<br>&gt; for a number of members of BinaryFloatingPoint, like ‘significantBitCount’.)<br>&gt;<br>&gt;<br>&gt; An exponent of Int.max encodes a number &gt;= 2**Int.max.  This is a<br>&gt; staggeringly huge quantity, even when Int is 32 bits (it’s approximately<br>&gt; 1e646456992).  There are a few extremely niche applications that require<br>&gt; numbers with greater magnitude, but they are *extremely* rare.  To a good<br>&gt; approximation, `Int` is more than enough bits, and a reasonable tradeoff.<br></p><p>Naive question: is it necessary to make a trade-off here? Why not an<br>associated type Exponent that&#39;s Int for Float, Double, and Float80,<br>allowing for something else for bignums?<br></p><p>&gt; Ditto `significandBitCount`.  I haven’t seen usage of floating-point types<br>&gt; with more than a few thousand significand bits; billions of bits is enough.<br>&gt; It is plausible that one could build a type that runs into this limit on a<br>&gt; 32-bit system, but it wouldn’t be very useful; on a 64-bit system, you can’t<br>&gt; allocate the storage for even one such value.<br>&gt;<br>&gt; Naming<br>&gt;<br>&gt; On “NaN” vs. “Nan”: I’m not convinced that ignoring the case is the right<br>&gt; way to go here. IMHO the clearest lowercase form is “nan” and the clearest<br>&gt; capitalized form is “NaN”.<br>&gt;<br>&gt; The current draft API guidelines don’t cover this case, but if I were to add<br>&gt; something for this, I’d say “when a word is normally written with mixed<br>&gt; case, the lowercase form should be fully-lowercased if the first letter is<br>&gt; naturally uppercase, and the capitalized form should have the first letter<br>&gt; uppercased only.” That rule produces “iPhone/IPhone”, “next/NeXT”, and<br>&gt; “nan/NaN”. (The “if the first letter is naturally uppercase” could be thrown<br>&gt; out as well.)<br>&gt;<br>&gt;<br>&gt; Yup, this seems like a sensible rule to me.<br>&gt;<br>&gt; On &#39;isLessThanOrEqual(to:)’: I agree with Xiaodi that the argument label is<br>&gt; problematic here. I think the problem is that we have two prepositions that<br>&gt; apply to the argument, and “pick the second one” leaves the base name<br>&gt; feeling unbalanced. (Remember that we allow referring to a method by its<br>&gt; basename alone when using it as a function value.)<br>&gt;<br>&gt; On &#39;isTotallyOrdered(with:)’: I lost track of who said it, but I agree that<br>&gt; this sounds like it’s “!isUnordered(with: other)”. The only name that’s<br>&gt; coming to mind is ‘isTotallyOrderedBefore(_:)’, which isn’t great.<br>&gt;<br>&gt; On ‘binade’: At first I thought this was a confusing term and there had to<br>&gt; be a better one, but now I think it’s an “if you don’t know what this is,<br>&gt; you don’t need to use it” case. :-)<br>&gt;<br>&gt;<br>&gt; Yup.<br>&gt;<br>&gt; – Steve<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>April 22, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Apr 22, 2016, at 10:54 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; Naive question: is it necessary to make a trade-off here? Why not an<br>&gt; associated type Exponent that&#39;s Int for Float, Double, and Float80,<br>&gt; allowing for something else for bignums?<br></p><p>It’s an added (fairly minor) complexity to the API surface that confers approximately zero benefit.<br></p><p>– Steve<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160422/3528c6d6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April 22, 2016 at 10:00:00am</p></header><div class="content"><p>On Fri, Apr 22, 2016 at 9:56 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;<br>&gt; On Apr 22, 2016, at 10:54 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; Naive question: is it necessary to make a trade-off here? Why not an<br>&gt; associated type Exponent that&#39;s Int for Float, Double, and Float80,<br>&gt; allowing for something else for bignums?<br>&gt;<br>&gt;<br>&gt; It’s an added (fairly minor) complexity to the API surface that confers<br>&gt; approximately zero benefit.<br></p><p>Fair. I know it&#39;s silly, but it feels a little inelegant that for a<br>binary floating point type both `exponent` and `exponentBitCount` are<br>of type Int.<br></p><p>&gt;<br>&gt; – Steve<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April 22, 2016 at 10:00:00am</p></header><div class="content"><p>On Fri, Apr 22, 2016 at 9:56 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;<br>&gt; On Apr 22, 2016, at 10:54 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; Naive question: is it necessary to make a trade-off here? Why not an<br>&gt; associated type Exponent that&#39;s Int for Float, Double, and Float80,<br>&gt; allowing for something else for bignums?<br>&gt;<br>&gt;<br>&gt; It’s an added (fairly minor) complexity to the API surface that confers<br>&gt; approximately zero benefit.<br></p><p>Alternatively, could `exponent` could be of type Self, just as `significand` is?<br></p><p>&gt;<br>&gt; – Steve<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>April 22, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Apr 22, 2016, at 11:26 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Fri, Apr 22, 2016 at 9:56 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Apr 22, 2016, at 10:54 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Naive question: is it necessary to make a trade-off here? Why not an<br>&gt;&gt; associated type Exponent that&#39;s Int for Float, Double, and Float80,<br>&gt;&gt; allowing for something else for bignums?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; It’s an added (fairly minor) complexity to the API surface that confers<br>&gt;&gt; approximately zero benefit.<br>&gt; <br>&gt; Alternatively, could `exponent` could be of type Self, just as `significand` is?<br></p><p>IEEE 754 allows this (“If logBFormat is a floating-point format, then the following operations are homogeneous), but IMO this makes the property more awkward to use in practice.<br></p><p>– Steve<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April 22, 2016 at 10:00:00am</p></header><div class="content"><p>On Fri, Apr 22, 2016 at 10:31 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt; On Apr 22, 2016, at 11:26 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Fri, Apr 22, 2016 at 9:56 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Apr 22, 2016, at 10:54 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Naive question: is it necessary to make a trade-off here? Why not an<br>&gt;&gt;&gt; associated type Exponent that&#39;s Int for Float, Double, and Float80,<br>&gt;&gt;&gt; allowing for something else for bignums?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It’s an added (fairly minor) complexity to the API surface that confers<br>&gt;&gt;&gt; approximately zero benefit.<br>&gt;&gt;<br>&gt;&gt; Alternatively, could `exponent` could be of type Self, just as `significand` is?<br>&gt;<br>&gt; IEEE 754 allows this (“If logBFormat is a floating-point format, then the following operations are homogeneous), but IMO this makes the property more awkward to use in practice.<br></p><p>I wonder about that. Not sure what this property would be most<br>commonly used for, but if it&#39;s for subsequent FP calculations, being<br>of type Self here seems like it would be less rather than more<br>awkward.<br></p><p>Obviously, my motivation for suggesting this is that it gets around<br>the arbitrary (but admittedly generous) limit of Int exponents by<br>requiring only that the number of bits for the exponent is less than<br>or equal to the number of bits used for the significand, which IMO is<br>more defensible.<br></p><p>&gt;<br>&gt; – Steve<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>April 22, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Apr 22, 2016, at 11:58 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Fri, Apr 22, 2016 at 10:31 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Apr 22, 2016, at 11:26 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Fri, Apr 22, 2016 at 9:56 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Apr 22, 2016, at 10:54 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Naive question: is it necessary to make a trade-off here? Why not an<br>&gt;&gt;&gt;&gt; associated type Exponent that&#39;s Int for Float, Double, and Float80,<br>&gt;&gt;&gt;&gt; allowing for something else for bignums?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It’s an added (fairly minor) complexity to the API surface that confers<br>&gt;&gt;&gt;&gt; approximately zero benefit.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternatively, could `exponent` could be of type Self, just as `significand` is?<br>&gt;&gt; <br>&gt;&gt; IEEE 754 allows this (“If logBFormat is a floating-point format, then the following operations are homogeneous), but IMO this makes the property more awkward to use in practice.<br>&gt; <br>&gt; I wonder about that. Not sure what this property would be most<br>&gt; commonly used for, but if it&#39;s for subsequent FP calculations, being<br>&gt; of type Self here seems like it would be less rather than more<br>&gt; awkward.<br>&gt; <br>&gt; Obviously, my motivation for suggesting this is that it gets around<br>&gt; the arbitrary (but admittedly generous) limit of Int exponents by<br>&gt; requiring only that the number of bits for the exponent is less than<br>&gt; or equal to the number of bits used for the significand, which IMO is<br>&gt; more defensible.<br></p><p>This runs into exactly the same issues; in the (extremely rare) cases where such enormous exponents are used, they tend to be coupled with surprisingly modest significands, so I don’t think this fixes anything.<br></p><p>There was some discussion of such formats on the IEEE 754 list circa 2007 w.r.t. edge cases of some of the usual library functions that break down when enormous exponent ranges are paired with small significands, but (much like this discussion) it was almost entirely theoretical.  IIRC only one list member had actually ever had occasion to use such a format.<br></p><p>– Steve<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April 22, 2016 at 11:00:00am</p></header><div class="content"><p>On Fri, Apr 22, 2016 at 11:04 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt; On Apr 22, 2016, at 11:58 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Fri, Apr 22, 2016 at 10:31 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Apr 22, 2016, at 11:26 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Fri, Apr 22, 2016 at 9:56 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Apr 22, 2016, at 10:54 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Naive question: is it necessary to make a trade-off here? Why not an<br>&gt;&gt;&gt;&gt;&gt; associated type Exponent that&#39;s Int for Float, Double, and Float80,<br>&gt;&gt;&gt;&gt;&gt; allowing for something else for bignums?<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; It’s an added (fairly minor) complexity to the API surface that confers<br>&gt;&gt;&gt;&gt;&gt; approximately zero benefit.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Alternatively, could `exponent` could be of type Self, just as `significand` is?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; IEEE 754 allows this (“If logBFormat is a floating-point format, then the following operations are homogeneous), but IMO this makes the property more awkward to use in practice.<br>&gt;&gt;<br>&gt;&gt; I wonder about that. Not sure what this property would be most<br>&gt;&gt; commonly used for, but if it&#39;s for subsequent FP calculations, being<br>&gt;&gt; of type Self here seems like it would be less rather than more<br>&gt;&gt; awkward.<br>&gt;&gt;<br>&gt;&gt; Obviously, my motivation for suggesting this is that it gets around<br>&gt;&gt; the arbitrary (but admittedly generous) limit of Int exponents by<br>&gt;&gt; requiring only that the number of bits for the exponent is less than<br>&gt;&gt; or equal to the number of bits used for the significand, which IMO is<br>&gt;&gt; more defensible.<br>&gt;<br>&gt; This runs into exactly the same issues; in the (extremely rare) cases where such enormous exponents are used, they tend to be coupled with surprisingly modest significands, so I don’t think this fixes anything.<br>&gt;<br>&gt; There was some discussion of such formats on the IEEE 754 list circa 2007 w.r.t. edge cases of some of the usual library functions that break down when enormous exponent ranges are paired with small significands, but (much like this discussion) it was almost entirely theoretical.  IIRC only one list member had actually ever had occasion to use such a format.<br></p><p>Sorry, to be clear, I&#39;m not arguing for expanding FloatingPoint to<br>support pairing large exponents with small significands. In my mind,<br>it&#39;s a bonus and not a drawback if exponent bits are restricted to be<br>less than or equal to significand bits. It elegantly avoids the<br>excessiveness of returning exponents of type Int for Float, for<br>example.<br></p><p>&gt;<br>&gt; – Steve<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April 22, 2016 at 11:00:00am</p></header><div class="content"><p>On Fri, Apr 22, 2016 at 11:09 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; On Fri, Apr 22, 2016 at 11:04 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; On Apr 22, 2016, at 11:58 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Fri, Apr 22, 2016 at 10:31 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Apr 22, 2016, at 11:26 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Fri, Apr 22, 2016 at 9:56 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On Apr 22, 2016, at 10:54 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Naive question: is it necessary to make a trade-off here? Why not an<br>&gt;&gt;&gt;&gt;&gt;&gt; associated type Exponent that&#39;s Int for Float, Double, and Float80,<br>&gt;&gt;&gt;&gt;&gt;&gt; allowing for something else for bignums?<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; It’s an added (fairly minor) complexity to the API surface that confers<br>&gt;&gt;&gt;&gt;&gt;&gt; approximately zero benefit.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Alternatively, could `exponent` could be of type Self, just as `significand` is?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; IEEE 754 allows this (“If logBFormat is a floating-point format, then the following operations are homogeneous), but IMO this makes the property more awkward to use in practice.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I wonder about that. Not sure what this property would be most<br>&gt;&gt;&gt; commonly used for, but if it&#39;s for subsequent FP calculations, being<br>&gt;&gt;&gt; of type Self here seems like it would be less rather than more<br>&gt;&gt;&gt; awkward.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Obviously, my motivation for suggesting this is that it gets around<br>&gt;&gt;&gt; the arbitrary (but admittedly generous) limit of Int exponents by<br>&gt;&gt;&gt; requiring only that the number of bits for the exponent is less than<br>&gt;&gt;&gt; or equal to the number of bits used for the significand, which IMO is<br>&gt;&gt;&gt; more defensible.<br>&gt;&gt;<br>&gt;&gt; This runs into exactly the same issues; in the (extremely rare) cases where such enormous exponents are used, they tend to be coupled with surprisingly modest significands, so I don’t think this fixes anything.<br>&gt;&gt;<br>&gt;&gt; There was some discussion of such formats on the IEEE 754 list circa 2007 w.r.t. edge cases of some of the usual library functions that break down when enormous exponent ranges are paired with small significands, but (much like this discussion) it was almost entirely theoretical.  IIRC only one list member had actually ever had occasion to use such a format.<br>&gt;<br>&gt; Sorry, to be clear, I&#39;m not arguing for expanding FloatingPoint to<br>&gt; support pairing large exponents with small significands. In my mind,<br>&gt; it&#39;s a bonus and not a drawback if exponent bits are restricted to be<br>&gt; less than or equal to significand bits. It elegantly avoids the<br>&gt; excessiveness of returning exponents of type Int for Float, for<br>&gt; example.<br></p><p>To expand, the hypothetical use case I&#39;m trying to leave open is this:<br>suppose I want to implement a Float1024 type with 79 exponent bits and<br>944 fraction bits. Could I conform it to BinaryFloatingPoint? As<br>currently proposed, no. What would make it possible would be<br>`exponent` of type Self, pushing down RawSignificand to<br>BinaryFloatingPoint, and using that associated type for both<br>`exponentBitPattern` and `significandBitPattern` (perhaps renaming it<br>RawBitPattern).<br></p><p>&gt;&gt;<br>&gt;&gt; – Steve<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>April 22, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Apr 22, 2016, at 12:21 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; To expand, the hypothetical use case I&#39;m trying to leave open is this:<br>&gt; suppose I want to implement a Float1024 type with 79 exponent bits and<br>&gt; 944 fraction bits. Could I conform it to BinaryFloatingPoint? As<br>&gt; currently proposed, no. What would make it possible would be<br>&gt; `exponent` of type Self, pushing down RawSignificand to<br>&gt; BinaryFloatingPoint, and using that associated type for both<br>&gt; `exponentBitPattern` and `significandBitPattern` (perhaps renaming it<br>&gt; RawBitPattern).<br></p><p>Right, but why is this any different from a hypothetical FloatingPoint type with 79 exponent bits and 48 significand bits?  If we’re going to be completely general, we should do the completely general thing, not a halfway measure that makes other details more complicated.<br></p><p>– Steve<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160422/228c47af/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>April 22, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Apr 22, 2016, at 12:09 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; This runs into exactly the same issues; in the (extremely rare) cases where such enormous exponents are used, they tend to be coupled with surprisingly modest significands, so I don’t think this fixes anything.<br>&gt;&gt; <br>&gt;&gt; There was some discussion of such formats on the IEEE 754 list circa 2007 w.r.t. edge cases of some of the usual library functions that break down when enormous exponent ranges are paired with small significands, but (much like this discussion) it was almost entirely theoretical.  IIRC only one list member had actually ever had occasion to use such a format.<br>&gt; <br>&gt; Sorry, to be clear, I&#39;m not arguing for expanding FloatingPoint to<br>&gt; support pairing large exponents with small significands. In my mind,<br>&gt; it&#39;s a bonus and not a drawback if exponent bits are restricted to be<br>&gt; less than or equal to significand bits. It elegantly avoids the<br>&gt; excessiveness of returning exponents of type Int for Float, for<br>&gt; example.<br></p><p>Ah, in that case the rationale for the current state of affairs is much easier to explain:<br></p><p>1. `Int` is the preferred type for integer quantities in Swift.  It’s not excessive to use for the exponent of `Float`, even though only 9 bits are required.<br></p><p>2. It turns out that most of the operations you want to do on `exponent` are fundamentally integer operations, so it makes sense for it to be an integer type.<br></p><p>3. If `exponent` has type `Self`, then `init(sign, exponent, significand)` needs to define and handle non-integral values of `exponent`, which is a mess.  The “is this floating-point value integral” test is quite non-trivial on some hardware platforms, and more expensive than one would like it to be even when it is trivial.<br></p><p>– Steve<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160422/899b2b0b/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>April 22, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Apr 22, 2016, at 9:56 AM, Stephen Canon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 22, 2016, at 10:54 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Naive question: is it necessary to make a trade-off here? Why not an<br>&gt;&gt; associated type Exponent that&#39;s Int for Float, Double, and Float80,<br>&gt;&gt; allowing for something else for bignums?<br>&gt; <br>&gt; It’s an added (fairly minor) complexity to the API surface that confers approximately zero benefit.<br>&gt; <br></p><p>So you admit the benefit isn’t *actually* zero? :-)<br></p><p>Yes, it does add a small bit of complexity to the API’s surface, but it&#39;s on a part of the surface that I don’t think people look at very much. How often are people extracting a float’s exponent? Plus, I suspect there’s a fair bit of overlap between the group of people who even know what `.exponent` would get used for, and those who’d get a warm fuzzy feeling from seeing that the standard library has baked-in, low-level support for bignum / arbitrary precision types.<br></p><p>Embrace the warm fuzzies… make exponent be an associated type.<br></p><p>- Dave Sweeris (who, despite the light-hearted tone, thinks this is actually pretty important)<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160422/5bf98f15/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>April 22, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Apr 22, 2016, at 11:29 AM, David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Apr 22, 2016, at 9:56 AM, Stephen Canon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Apr 22, 2016, at 10:54 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Naive question: is it necessary to make a trade-off here? Why not an<br>&gt;&gt;&gt; associated type Exponent that&#39;s Int for Float, Double, and Float80,<br>&gt;&gt;&gt; allowing for something else for bignums?<br>&gt;&gt; <br>&gt;&gt; It’s an added (fairly minor) complexity to the API surface that confers approximately zero benefit.<br>&gt; <br>&gt; So you admit the benefit isn’t *actually* zero? :-)<br>&gt; <br>&gt; Yes, it does add a small bit of complexity to the API’s surface, but it&#39;s on a part of the surface that I don’t think people look at very much. How often are people extracting a float’s exponent? Plus, I suspect there’s a fair bit of overlap between the group of people who even know what `.exponent` would get used for, and those who’d get a warm fuzzy feeling from seeing that the standard library has baked-in, low-level support for bignum / arbitrary precision types.<br>&gt; <br>&gt; Embrace the warm fuzzies… make exponent be an associated type.<br>&gt; <br>&gt; - Dave Sweeris (who, despite the light-hearted tone, thinks this is actually pretty important)<br></p><p>The current design does not prevent bignum / arbitrary precision types.  It prevents soft-float types with ridiculously large exponent ranges, but such enormous numbers are generally better modeled by either a logarithmic number system or level-index arithmetic.<br></p><p>Making exponent an associated type makes implementing any future heterogeneous operations (including generic conversions) more complex.  This is a real cost, for a dubious theoretical benefit.<br></p><p>– Steve<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160422/c8d6c6a6/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April 22, 2016 at 10:00:00am</p></header><div class="content"><p>Two stray thoughts:<br></p><p>I agree with previous comments that `ulpOfOne` may not really be necessary.<br></p><p>Of the following--<br>```<br>  init(signBit: Bool, exponent: Int, significand: Self)<br>  init(magnitudeOf other: Self, signOf: Self)<br>```<br>--would it be more elegant to have the latter be `init(signOf: Self,<br>magnitudeOf other: Self)`?<br></p><p><br>On Fri, Apr 22, 2016 at 9:54 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; On Fri, Apr 22, 2016 at 9:13 AM, Stephen Canon via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Apr 21, 2016, at 9:13 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; [Proposal:<br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0067-floating-point-protocols.md]<br>&gt;&gt;<br>&gt;&gt; This is super impressive. I do have several bits I’m uncomfortable with,<br>&gt;&gt; however. I’ll try to separate that into “semantic” and “naming” sections.<br>&gt;&gt;<br>&gt;&gt; Semantic<br>&gt;&gt;<br>&gt;&gt; static var radix: Int { get }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Does it ever make sense to have a model type that allows different instances<br>&gt;&gt; to have different radices?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; No.<br>&gt;&gt;<br>&gt;&gt; Is there an algorithm that makes use of a model’s radix, or is this just in<br>&gt;&gt; here for “completeness”?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; If you know ulp, radix, and exponent range, you can infer basically all the<br>&gt;&gt; other numerical details of the type.  One good example would be the constant<br>&gt;&gt; that Dave mentioned, “maxResultOfAdding1”.  You can compute this if you know<br>&gt;&gt; radix and ulp.  The radix is also the bound on how large the relative<br>&gt;&gt; spacing between consecutive numbers can get, which is sometimes important<br>&gt;&gt; for computing accurate bounds.  These are all somewhat niche, but the<br>&gt;&gt; problem is that there’s no good way to get this value if you don’t have it,<br>&gt;&gt; and it imposes “zero” implementation burden.<br>&gt;&gt;<br>&gt;&gt;   /// A signaling NaN (not-a-number).<br>&gt;&gt;   @warn_unused_result<br>&gt;&gt;   static func signalingNaN: Self { get }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I’m not sure it really makes sense for a Bignum / APFloat type to support<br>&gt;&gt; such a value. But really I think this is just underspecified. What does it<br>&gt;&gt; mean, in terms of this protocol and its uses, for a NaN to be signaling? Is<br>&gt;&gt; it just a specific “color&quot; of NaN, with no semantic requirements other than<br>&gt;&gt; being distinguishable?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; There are a variety of means that a softfloat type could use to implement<br>&gt;&gt; signaling NaNs.  Here are two of the simpler ones:<br>&gt;&gt;<br>&gt;&gt; (a) if running on HW with hard-float support, use native-precision<br>&gt;&gt; hard-float instructions to set flags as needed.<br>&gt;&gt; (b) provide operation variants that take an inout flags / parameter:<br>&gt;&gt;<br>&gt;&gt; mutating func add(rhs: Self, inout flags: Flags)<br>&gt;&gt;<br>&gt;&gt; (Also, is ‘signalingNan.isNan’ true? I assume so but since ’nan’ is implied<br>&gt;&gt; to be a non-signaling NaN I’m not sure anymore.)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Yup, that should be clarified.<br>&gt;&gt;<br>&gt;&gt;   var signBit: Bool { get }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Unlike Chris, I’m strongly against this property as it stands. You should<br>&gt;&gt; not be able to write “if someValue.signBit”; a bit is not a boolean value.<br>&gt;&gt; (Citation: &quot;Uses of Boolean methods and properties should read as assertions<br>&gt;&gt; about the receiver.”)<br>&gt;&gt;<br>&gt;&gt; I’d be okay with Greg’s idea of changing the type to an enum. I’d also be<br>&gt;&gt; okay with renaming this to a predicate, whatever the name ends up being.<br>&gt;&gt; (“isSignBitSet”, “isSignNegative”, etc.)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Making it a predicate is weird, because then the three properties making up<br>&gt;&gt; the number become `isSignBitSet`, `exponent`, and `significand`; one of<br>&gt;&gt; these things is not like the other ones.  If `signBit: Bool` were ruled out,<br>&gt;&gt; I would rather go with Greg’s enum proposal.<br>&gt;&gt;<br>&gt;&gt;   var exponent: Int { get }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Nitpick: it’s probably worth noting in the doc comment that this is the<br>&gt;&gt; unbiased exponent value.<br>&gt;&gt;<br>&gt;&gt; Also, does it matter that this is insufficient for bignums, which may have<br>&gt;&gt; an exponent of greater than `sizeof(Int.self)` bits? (This is also a concern<br>&gt;&gt; for a number of members of BinaryFloatingPoint, like ‘significantBitCount’.)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; An exponent of Int.max encodes a number &gt;= 2**Int.max.  This is a<br>&gt;&gt; staggeringly huge quantity, even when Int is 32 bits (it’s approximately<br>&gt;&gt; 1e646456992).  There are a few extremely niche applications that require<br>&gt;&gt; numbers with greater magnitude, but they are *extremely* rare.  To a good<br>&gt;&gt; approximation, `Int` is more than enough bits, and a reasonable tradeoff.<br>&gt;<br>&gt; Naive question: is it necessary to make a trade-off here? Why not an<br>&gt; associated type Exponent that&#39;s Int for Float, Double, and Float80,<br>&gt; allowing for something else for bignums?<br>&gt;<br>&gt;&gt; Ditto `significandBitCount`.  I haven’t seen usage of floating-point types<br>&gt;&gt; with more than a few thousand significand bits; billions of bits is enough.<br>&gt;&gt; It is plausible that one could build a type that runs into this limit on a<br>&gt;&gt; 32-bit system, but it wouldn’t be very useful; on a 64-bit system, you can’t<br>&gt;&gt; allocate the storage for even one such value.<br>&gt;&gt;<br>&gt;&gt; Naming<br>&gt;&gt;<br>&gt;&gt; On “NaN” vs. “Nan”: I’m not convinced that ignoring the case is the right<br>&gt;&gt; way to go here. IMHO the clearest lowercase form is “nan” and the clearest<br>&gt;&gt; capitalized form is “NaN”.<br>&gt;&gt;<br>&gt;&gt; The current draft API guidelines don’t cover this case, but if I were to add<br>&gt;&gt; something for this, I’d say “when a word is normally written with mixed<br>&gt;&gt; case, the lowercase form should be fully-lowercased if the first letter is<br>&gt;&gt; naturally uppercase, and the capitalized form should have the first letter<br>&gt;&gt; uppercased only.” That rule produces “iPhone/IPhone”, “next/NeXT”, and<br>&gt;&gt; “nan/NaN”. (The “if the first letter is naturally uppercase” could be thrown<br>&gt;&gt; out as well.)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Yup, this seems like a sensible rule to me.<br>&gt;&gt;<br>&gt;&gt; On &#39;isLessThanOrEqual(to:)’: I agree with Xiaodi that the argument label is<br>&gt;&gt; problematic here. I think the problem is that we have two prepositions that<br>&gt;&gt; apply to the argument, and “pick the second one” leaves the base name<br>&gt;&gt; feeling unbalanced. (Remember that we allow referring to a method by its<br>&gt;&gt; basename alone when using it as a function value.)<br>&gt;&gt;<br>&gt;&gt; On &#39;isTotallyOrdered(with:)’: I lost track of who said it, but I agree that<br>&gt;&gt; this sounds like it’s “!isUnordered(with: other)”. The only name that’s<br>&gt;&gt; coming to mind is ‘isTotallyOrderedBefore(_:)’, which isn’t great.<br>&gt;&gt;<br>&gt;&gt; On ‘binade’: At first I thought this was a confusing term and there had to<br>&gt;&gt; be a better one, but now I think it’s an “if you don’t know what this is,<br>&gt;&gt; you don’t need to use it” case. :-)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Yup.<br>&gt;&gt;<br>&gt;&gt; – Steve<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April 22, 2016 at 10:00:00am</p></header><div class="content"><p>One more stray thought:<br>Is there a reason RawSignificand is declared in FloatingPoint but used<br>only in BinaryFloatingPoint?<br></p><p><br>On Fri, Apr 22, 2016 at 10:02 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; Two stray thoughts:<br>&gt;<br>&gt; I agree with previous comments that `ulpOfOne` may not really be necessary.<br>&gt;<br>&gt; Of the following--<br>&gt; ```<br>&gt;   init(signBit: Bool, exponent: Int, significand: Self)<br>&gt;   init(magnitudeOf other: Self, signOf: Self)<br>&gt; ```<br>&gt; --would it be more elegant to have the latter be `init(signOf: Self,<br>&gt; magnitudeOf other: Self)`?<br>&gt;<br>&gt;<br>&gt; On Fri, Apr 22, 2016 at 9:54 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt; On Fri, Apr 22, 2016 at 9:13 AM, Stephen Canon via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Apr 21, 2016, at 9:13 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; [Proposal:<br>&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0067-floating-point-protocols.md]<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This is super impressive. I do have several bits I’m uncomfortable with,<br>&gt;&gt;&gt; however. I’ll try to separate that into “semantic” and “naming” sections.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Semantic<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; static var radix: Int { get }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Does it ever make sense to have a model type that allows different instances<br>&gt;&gt;&gt; to have different radices?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; No.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Is there an algorithm that makes use of a model’s radix, or is this just in<br>&gt;&gt;&gt; here for “completeness”?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If you know ulp, radix, and exponent range, you can infer basically all the<br>&gt;&gt;&gt; other numerical details of the type.  One good example would be the constant<br>&gt;&gt;&gt; that Dave mentioned, “maxResultOfAdding1”.  You can compute this if you know<br>&gt;&gt;&gt; radix and ulp.  The radix is also the bound on how large the relative<br>&gt;&gt;&gt; spacing between consecutive numbers can get, which is sometimes important<br>&gt;&gt;&gt; for computing accurate bounds.  These are all somewhat niche, but the<br>&gt;&gt;&gt; problem is that there’s no good way to get this value if you don’t have it,<br>&gt;&gt;&gt; and it imposes “zero” implementation burden.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   /// A signaling NaN (not-a-number).<br>&gt;&gt;&gt;   @warn_unused_result<br>&gt;&gt;&gt;   static func signalingNaN: Self { get }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I’m not sure it really makes sense for a Bignum / APFloat type to support<br>&gt;&gt;&gt; such a value. But really I think this is just underspecified. What does it<br>&gt;&gt;&gt; mean, in terms of this protocol and its uses, for a NaN to be signaling? Is<br>&gt;&gt;&gt; it just a specific “color&quot; of NaN, with no semantic requirements other than<br>&gt;&gt;&gt; being distinguishable?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; There are a variety of means that a softfloat type could use to implement<br>&gt;&gt;&gt; signaling NaNs.  Here are two of the simpler ones:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; (a) if running on HW with hard-float support, use native-precision<br>&gt;&gt;&gt; hard-float instructions to set flags as needed.<br>&gt;&gt;&gt; (b) provide operation variants that take an inout flags / parameter:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; mutating func add(rhs: Self, inout flags: Flags)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; (Also, is ‘signalingNan.isNan’ true? I assume so but since ’nan’ is implied<br>&gt;&gt;&gt; to be a non-signaling NaN I’m not sure anymore.)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Yup, that should be clarified.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   var signBit: Bool { get }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Unlike Chris, I’m strongly against this property as it stands. You should<br>&gt;&gt;&gt; not be able to write “if someValue.signBit”; a bit is not a boolean value.<br>&gt;&gt;&gt; (Citation: &quot;Uses of Boolean methods and properties should read as assertions<br>&gt;&gt;&gt; about the receiver.”)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I’d be okay with Greg’s idea of changing the type to an enum. I’d also be<br>&gt;&gt;&gt; okay with renaming this to a predicate, whatever the name ends up being.<br>&gt;&gt;&gt; (“isSignBitSet”, “isSignNegative”, etc.)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Making it a predicate is weird, because then the three properties making up<br>&gt;&gt;&gt; the number become `isSignBitSet`, `exponent`, and `significand`; one of<br>&gt;&gt;&gt; these things is not like the other ones.  If `signBit: Bool` were ruled out,<br>&gt;&gt;&gt; I would rather go with Greg’s enum proposal.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   var exponent: Int { get }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Nitpick: it’s probably worth noting in the doc comment that this is the<br>&gt;&gt;&gt; unbiased exponent value.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Also, does it matter that this is insufficient for bignums, which may have<br>&gt;&gt;&gt; an exponent of greater than `sizeof(Int.self)` bits? (This is also a concern<br>&gt;&gt;&gt; for a number of members of BinaryFloatingPoint, like ‘significantBitCount’.)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; An exponent of Int.max encodes a number &gt;= 2**Int.max.  This is a<br>&gt;&gt;&gt; staggeringly huge quantity, even when Int is 32 bits (it’s approximately<br>&gt;&gt;&gt; 1e646456992).  There are a few extremely niche applications that require<br>&gt;&gt;&gt; numbers with greater magnitude, but they are *extremely* rare.  To a good<br>&gt;&gt;&gt; approximation, `Int` is more than enough bits, and a reasonable tradeoff.<br>&gt;&gt;<br>&gt;&gt; Naive question: is it necessary to make a trade-off here? Why not an<br>&gt;&gt; associated type Exponent that&#39;s Int for Float, Double, and Float80,<br>&gt;&gt; allowing for something else for bignums?<br>&gt;&gt;<br>&gt;&gt;&gt; Ditto `significandBitCount`.  I haven’t seen usage of floating-point types<br>&gt;&gt;&gt; with more than a few thousand significand bits; billions of bits is enough.<br>&gt;&gt;&gt; It is plausible that one could build a type that runs into this limit on a<br>&gt;&gt;&gt; 32-bit system, but it wouldn’t be very useful; on a 64-bit system, you can’t<br>&gt;&gt;&gt; allocate the storage for even one such value.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Naming<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On “NaN” vs. “Nan”: I’m not convinced that ignoring the case is the right<br>&gt;&gt;&gt; way to go here. IMHO the clearest lowercase form is “nan” and the clearest<br>&gt;&gt;&gt; capitalized form is “NaN”.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The current draft API guidelines don’t cover this case, but if I were to add<br>&gt;&gt;&gt; something for this, I’d say “when a word is normally written with mixed<br>&gt;&gt;&gt; case, the lowercase form should be fully-lowercased if the first letter is<br>&gt;&gt;&gt; naturally uppercase, and the capitalized form should have the first letter<br>&gt;&gt;&gt; uppercased only.” That rule produces “iPhone/IPhone”, “next/NeXT”, and<br>&gt;&gt;&gt; “nan/NaN”. (The “if the first letter is naturally uppercase” could be thrown<br>&gt;&gt;&gt; out as well.)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Yup, this seems like a sensible rule to me.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On &#39;isLessThanOrEqual(to:)’: I agree with Xiaodi that the argument label is<br>&gt;&gt;&gt; problematic here. I think the problem is that we have two prepositions that<br>&gt;&gt;&gt; apply to the argument, and “pick the second one” leaves the base name<br>&gt;&gt;&gt; feeling unbalanced. (Remember that we allow referring to a method by its<br>&gt;&gt;&gt; basename alone when using it as a function value.)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On &#39;isTotallyOrdered(with:)’: I lost track of who said it, but I agree that<br>&gt;&gt;&gt; this sounds like it’s “!isUnordered(with: other)”. The only name that’s<br>&gt;&gt;&gt; coming to mind is ‘isTotallyOrderedBefore(_:)’, which isn’t great.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On ‘binade’: At first I thought this was a confusing term and there had to<br>&gt;&gt;&gt; be a better one, but now I think it’s an “if you don’t know what this is,<br>&gt;&gt;&gt; you don’t need to use it” case. :-)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Yup.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; – Steve<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>April 22, 2016 at 11:00:00am</p></header><div class="content"><p>It was originally used for nan static function payload argument, but as that function has been removed from the FloatingPoint protocol, the associatedtype could also be moved down.<br></p><p>– Steve<br></p><p>&gt; On Apr 22, 2016, at 11:16 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; One more stray thought:<br>&gt; Is there a reason RawSignificand is declared in FloatingPoint but used<br>&gt; only in BinaryFloatingPoint?<br>&gt; <br>&gt; <br>&gt; On Fri, Apr 22, 2016 at 10:02 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt; Two stray thoughts:<br>&gt;&gt; <br>&gt;&gt; I agree with previous comments that `ulpOfOne` may not really be necessary.<br>&gt;&gt; <br>&gt;&gt; Of the following--<br>&gt;&gt; ```<br>&gt;&gt;  init(signBit: Bool, exponent: Int, significand: Self)<br>&gt;&gt;  init(magnitudeOf other: Self, signOf: Self)<br>&gt;&gt; ```<br>&gt;&gt; --would it be more elegant to have the latter be `init(signOf: Self,<br>&gt;&gt; magnitudeOf other: Self)`?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Fri, Apr 22, 2016 at 9:54 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt; On Fri, Apr 22, 2016 at 9:13 AM, Stephen Canon via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Apr 21, 2016, at 9:13 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; [Proposal:<br>&gt;&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0067-floating-point-protocols.md]<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is super impressive. I do have several bits I’m uncomfortable with,<br>&gt;&gt;&gt;&gt; however. I’ll try to separate that into “semantic” and “naming” sections.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Semantic<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; static var radix: Int { get }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Does it ever make sense to have a model type that allows different instances<br>&gt;&gt;&gt;&gt; to have different radices?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; No.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Is there an algorithm that makes use of a model’s radix, or is this just in<br>&gt;&gt;&gt;&gt; here for “completeness”?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If you know ulp, radix, and exponent range, you can infer basically all the<br>&gt;&gt;&gt;&gt; other numerical details of the type.  One good example would be the constant<br>&gt;&gt;&gt;&gt; that Dave mentioned, “maxResultOfAdding1”.  You can compute this if you know<br>&gt;&gt;&gt;&gt; radix and ulp.  The radix is also the bound on how large the relative<br>&gt;&gt;&gt;&gt; spacing between consecutive numbers can get, which is sometimes important<br>&gt;&gt;&gt;&gt; for computing accurate bounds.  These are all somewhat niche, but the<br>&gt;&gt;&gt;&gt; problem is that there’s no good way to get this value if you don’t have it,<br>&gt;&gt;&gt;&gt; and it imposes “zero” implementation burden.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  /// A signaling NaN (not-a-number).<br>&gt;&gt;&gt;&gt;  @warn_unused_result<br>&gt;&gt;&gt;&gt;  static func signalingNaN: Self { get }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m not sure it really makes sense for a Bignum / APFloat type to support<br>&gt;&gt;&gt;&gt; such a value. But really I think this is just underspecified. What does it<br>&gt;&gt;&gt;&gt; mean, in terms of this protocol and its uses, for a NaN to be signaling? Is<br>&gt;&gt;&gt;&gt; it just a specific “color&quot; of NaN, with no semantic requirements other than<br>&gt;&gt;&gt;&gt; being distinguishable?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are a variety of means that a softfloat type could use to implement<br>&gt;&gt;&gt;&gt; signaling NaNs.  Here are two of the simpler ones:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (a) if running on HW with hard-float support, use native-precision<br>&gt;&gt;&gt;&gt; hard-float instructions to set flags as needed.<br>&gt;&gt;&gt;&gt; (b) provide operation variants that take an inout flags / parameter:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; mutating func add(rhs: Self, inout flags: Flags)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (Also, is ‘signalingNan.isNan’ true? I assume so but since ’nan’ is implied<br>&gt;&gt;&gt;&gt; to be a non-signaling NaN I’m not sure anymore.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yup, that should be clarified.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  var signBit: Bool { get }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Unlike Chris, I’m strongly against this property as it stands. You should<br>&gt;&gt;&gt;&gt; not be able to write “if someValue.signBit”; a bit is not a boolean value.<br>&gt;&gt;&gt;&gt; (Citation: &quot;Uses of Boolean methods and properties should read as assertions<br>&gt;&gt;&gt;&gt; about the receiver.”)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’d be okay with Greg’s idea of changing the type to an enum. I’d also be<br>&gt;&gt;&gt;&gt; okay with renaming this to a predicate, whatever the name ends up being.<br>&gt;&gt;&gt;&gt; (“isSignBitSet”, “isSignNegative”, etc.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Making it a predicate is weird, because then the three properties making up<br>&gt;&gt;&gt;&gt; the number become `isSignBitSet`, `exponent`, and `significand`; one of<br>&gt;&gt;&gt;&gt; these things is not like the other ones.  If `signBit: Bool` were ruled out,<br>&gt;&gt;&gt;&gt; I would rather go with Greg’s enum proposal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  var exponent: Int { get }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Nitpick: it’s probably worth noting in the doc comment that this is the<br>&gt;&gt;&gt;&gt; unbiased exponent value.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Also, does it matter that this is insufficient for bignums, which may have<br>&gt;&gt;&gt;&gt; an exponent of greater than `sizeof(Int.self)` bits? (This is also a concern<br>&gt;&gt;&gt;&gt; for a number of members of BinaryFloatingPoint, like ‘significantBitCount’.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; An exponent of Int.max encodes a number &gt;= 2**Int.max.  This is a<br>&gt;&gt;&gt;&gt; staggeringly huge quantity, even when Int is 32 bits (it’s approximately<br>&gt;&gt;&gt;&gt; 1e646456992).  There are a few extremely niche applications that require<br>&gt;&gt;&gt;&gt; numbers with greater magnitude, but they are *extremely* rare.  To a good<br>&gt;&gt;&gt;&gt; approximation, `Int` is more than enough bits, and a reasonable tradeoff.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Naive question: is it necessary to make a trade-off here? Why not an<br>&gt;&gt;&gt; associated type Exponent that&#39;s Int for Float, Double, and Float80,<br>&gt;&gt;&gt; allowing for something else for bignums?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Ditto `significandBitCount`.  I haven’t seen usage of floating-point types<br>&gt;&gt;&gt;&gt; with more than a few thousand significand bits; billions of bits is enough.<br>&gt;&gt;&gt;&gt; It is plausible that one could build a type that runs into this limit on a<br>&gt;&gt;&gt;&gt; 32-bit system, but it wouldn’t be very useful; on a 64-bit system, you can’t<br>&gt;&gt;&gt;&gt; allocate the storage for even one such value.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Naming<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On “NaN” vs. “Nan”: I’m not convinced that ignoring the case is the right<br>&gt;&gt;&gt;&gt; way to go here. IMHO the clearest lowercase form is “nan” and the clearest<br>&gt;&gt;&gt;&gt; capitalized form is “NaN”.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The current draft API guidelines don’t cover this case, but if I were to add<br>&gt;&gt;&gt;&gt; something for this, I’d say “when a word is normally written with mixed<br>&gt;&gt;&gt;&gt; case, the lowercase form should be fully-lowercased if the first letter is<br>&gt;&gt;&gt;&gt; naturally uppercase, and the capitalized form should have the first letter<br>&gt;&gt;&gt;&gt; uppercased only.” That rule produces “iPhone/IPhone”, “next/NeXT”, and<br>&gt;&gt;&gt;&gt; “nan/NaN”. (The “if the first letter is naturally uppercase” could be thrown<br>&gt;&gt;&gt;&gt; out as well.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yup, this seems like a sensible rule to me.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On &#39;isLessThanOrEqual(to:)’: I agree with Xiaodi that the argument label is<br>&gt;&gt;&gt;&gt; problematic here. I think the problem is that we have two prepositions that<br>&gt;&gt;&gt;&gt; apply to the argument, and “pick the second one” leaves the base name<br>&gt;&gt;&gt;&gt; feeling unbalanced. (Remember that we allow referring to a method by its<br>&gt;&gt;&gt;&gt; basename alone when using it as a function value.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On &#39;isTotallyOrdered(with:)’: I lost track of who said it, but I agree that<br>&gt;&gt;&gt;&gt; this sounds like it’s “!isUnordered(with: other)”. The only name that’s<br>&gt;&gt;&gt;&gt; coming to mind is ‘isTotallyOrderedBefore(_:)’, which isn’t great.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On ‘binade’: At first I thought this was a confusing term and there had to<br>&gt;&gt;&gt;&gt; be a better one, but now I think it’s an “if you don’t know what this is,<br>&gt;&gt;&gt;&gt; you don’t need to use it” case. :-)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yup.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; – Steve<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>April 22, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Apr 22, 2016, at 8:13 AM, Stephen Canon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;   /// A signaling NaN (not-a-number).<br>&gt;&gt;   @warn_unused_result<br>&gt;&gt;   static func signalingNaN: Self { get }<br>&gt;&gt; <br>&gt;&gt; I’m not sure it really makes sense for a Bignum / APFloat type to support such a value. But really I think this is just underspecified. What does it mean, in terms of this protocol and its uses, for a NaN to be signaling? Is it just a specific “color&quot; of NaN, with no semantic requirements other than being distinguishable?<br></p><p>I’m confused in that I haven’t really had exposure to signaling NaNs before, and wasn’t really able to find hints on how they are used. Do math operations create signaling NaNs, or is it an explicitly set value?<br></p><p>My first expectation was that you would either have overflow operators where a NaN result would immediately raise an exception.<br></p><p>My second expectation if NaN was a valid value but use created exceptions is that floating point numbers are monadic. Specifically, floating point operations with soft NaN seem similar to optional, while Floats with signaling NaN seem similar to implicitly unwrapped optionals - but without the use of separate types to represent numbers and possibly-not-numbers.<br></p><p>That said, would use of an attribute on a floating point type, similar to what is planned for IUOs, be appropriate to indicate that the type should be treated as signaling?<br></p><p>-DW<br> <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160422/c9328c50/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April 22, 2016 at 05:00:00pm</p></header><div class="content"><p>Neither, actually. NaN is a valid value and even its use does not always<br>lead to exceptions. For example, it&#39;s possible (and a deliberate use case)<br>to assign NaN (even signaling NaN), and the IEEE 754 function maxNum(x, y)<br>(here proposed as `maximum`) will return x if x is not NaN and y is NaN.<br>On Fri, Apr 22, 2016 at 12:19 David Waite via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Apr 22, 2016, at 8:13 AM, Stephen Canon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt;   /// A signaling NaN (not-a-number).<br>&gt;   @warn_unused_result<br>&gt;   static func signalingNaN: Self { get }<br>&gt;<br>&gt;<br>&gt; I’m not sure it really makes sense for a Bignum / APFloat type to support<br>&gt; such a value. But really I think this is just underspecified. What does it<br>&gt; mean, in terms of this protocol and its uses, for a NaN to be signaling? Is<br>&gt; it just a specific “color&quot; of NaN, with no semantic requirements other than<br>&gt; being distinguishable?<br>&gt;<br>&gt;<br>&gt; I’m confused in that I haven’t really had exposure to signaling NaNs<br>&gt; before, and wasn’t really able to find hints on how they are used. Do math<br>&gt; operations create signaling NaNs, or is it an explicitly set value?<br>&gt;<br>&gt; My first expectation was that you would either have overflow operators<br>&gt; where a NaN result would immediately raise an exception.<br>&gt;<br>&gt; My second expectation if NaN was a valid value but use created exceptions<br>&gt; is that floating point numbers are monadic. Specifically, floating point<br>&gt; operations with soft NaN seem similar to optional, while Floats with<br>&gt; signaling NaN seem similar to implicitly unwrapped optionals - but without<br>&gt; the use of separate types to represent numbers and possibly-not-numbers.<br>&gt;<br>&gt; That said, would use of an attribute on a floating point type, similar to<br>&gt; what is planned for IUOs, be appropriate to indicate that the type should<br>&gt; be treated as signaling?<br>&gt;<br>&gt; -DW<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160422/ba368f9f/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>April 25, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Apr 22, 2016, at 7:13, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt;   /// A signaling NaN (not-a-number).<br>&gt;&gt;   @warn_unused_result<br>&gt;&gt;   static func signalingNaN: Self { get }<br>&gt;&gt; <br>&gt;&gt; I’m not sure it really makes sense for a Bignum / APFloat type to support such a value. But really I think this is just underspecified. What does it mean, in terms of this protocol and its uses, for a NaN to be signaling? Is it just a specific “color&quot; of NaN, with no semantic requirements other than being distinguishable?<br>&gt; <br>&gt; There are a variety of means that a softfloat type could use to implement signaling NaNs.  Here are two of the simpler ones:<br>&gt; <br>&gt; (a) if running on HW with hard-float support, use native-precision hard-float instructions to set flags as needed.<br>&gt; (b) provide operation variants that take an inout flags / parameter:<br>&gt; <br>&gt; 	mutating func add(rhs: Self, inout flags: Flags)<br>&gt; <br></p><p>Sorry, I think my question is more general than this. &quot;Signaling&quot; is a term of art in IEEE 754, but it doesn&#39;t actually mean anything in Swift, and none of the operations in the protocol have defined semantics for &quot;signaling&quot;. Maybe that&#39;s the real question: what must each of the operations of FloatingPoint and BinaryFloatingPoint do when operating on an SNaN? a QNaN?<br></p><p>(I know what IEEE 754 says. We need the same rules in Swift semantics: &quot;throws&quot;, &quot;traps&quot;, &quot;returns an unspecified result&quot;.)<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160425/f7194265/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>April 25, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Apr 25, 2016, at 2:12 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Apr 22, 2016, at 7:13, Stephen Canon &lt;scanon at apple.com &lt;mailto:scanon at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;   /// A signaling NaN (not-a-number).<br>&gt;&gt;&gt;   @warn_unused_result<br>&gt;&gt;&gt;   static func signalingNaN: Self { get }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m not sure it really makes sense for a Bignum / APFloat type to support such a value. But really I think this is just underspecified. What does it mean, in terms of this protocol and its uses, for a NaN to be signaling? Is it just a specific “color&quot; of NaN, with no semantic requirements other than being distinguishable?<br>&gt;&gt; <br>&gt;&gt; There are a variety of means that a softfloat type could use to implement signaling NaNs.  Here are two of the simpler ones:<br>&gt;&gt; <br>&gt;&gt; (a) if running on HW with hard-float support, use native-precision hard-float instructions to set flags as needed.<br>&gt;&gt; (b) provide operation variants that take an inout flags / parameter:<br>&gt;&gt; <br>&gt;&gt; 	mutating func add(rhs: Self, inout flags: Flags)<br>&gt;&gt; <br>&gt; <br>&gt; Sorry, I think my question is more general than this. &quot;Signaling&quot; is a term of art in IEEE 754, but it doesn&#39;t actually mean anything in Swift, and none of the operations in the protocol have defined semantics for &quot;signaling&quot;. Maybe that&#39;s the real question: what must each of the operations of FloatingPoint and BinaryFloatingPoint do when operating on an SNaN? a QNaN?<br>&gt; <br>&gt; (I know what IEEE 754 says. We need the same rules in Swift semantics: &quot;throws&quot;, &quot;traps&quot;, &quot;returns an unspecified result”.)<br></p><p>At present, I would say that by default they should raise the invalid floating-point flag, which is impossible to observe from raw Swift, but is observable via the C stdlib &lt;fenv.h&gt; functions; they might optionally set a flag in an explicit inout parameter or trap.  We should eventually have a specified floating-point environment model, but that’s (mostly) orthogonal to this API proposal.<br></p><p>– Steve<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160425/4f9e3f2b/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April 23, 2016 at 05:00:00pm</p></header><div class="content"><p>A few things…<br></p><p>First, something absent: I&#39;m a little bit concerned by the act that there&#39;s no means to convert between different concrete FloatingPoint types. Something like the IntMax mechanism in Swift 2&#39;s IntegerType might be useful, though there may be good reasons not to do that.<br></p><p>&gt; public protocol FloatingPoint: Comparable, IntegerLiteralConvertible {<br>&gt; public protocol BinaryFloatingPoint: FloatingPoint, FloatLiteralConvertible {<br></p><p>Any reason why FloatLiteralConvertible isn&#39;t on FloatingPoint?<br></p><p>&gt;   prefix func +(x: Self) -&gt; Self<br></p><p>Does this actually do anything, or is it a no-op? If the latter, should it just be a free function rather than part of the protocol? Or maybe even part of the literal syntax that can&#39;t be applied to variables at all?<br></p><p>&gt;   static func minimum(x: Self, _ y: Self) -&gt; Self<br>&gt;   static func maximum(x: Self, _ y: Self) -&gt; Self<br>&gt;   static func minimumMagnitude(x: Self, _ y: Self) -&gt; Self<br>&gt;   static func maximumMagnitude(x: Self, _ y: Self) -&gt; Self<br></p><p>These all take two operands, but I can&#39;t think of a reason for that. Might they be better off as variadic? (Or is the &quot;implementation hook&quot; comment meant to indicate that the variadic form of the `max` free function will use these calls?)<br></p><p>&gt;   func isEqual(to other: Self) -&gt; Bool<br>&gt;   func isLess(than other: Self) -&gt; Bool<br>&gt;   func isLessThanOrEqual(to other: Self) -&gt; Bool<br></p><p>I&#39;m still not sure why these are methods instead of operators.<br></p><p>(I also share others&#39; concern about the argument label on `isLessThanOrEqual`.)<br></p><p>&gt;   func isUnordered(with other: Self) -&gt; Bool<br>&gt;   func isTotallyOrdered(with other: Self) -&gt; Bool<br></p><p>I think these features should be folded into Comparable, but I&#39;ll start a different thread about that. For the moment, these seem fine.<br></p><p>&gt;   func isEqual&lt;Other: BinaryFloatingPoint&gt;(to other: Other) -&gt; Bool<br>&gt;   func isLess&lt;Other: BinaryFloatingPoint&gt;(than other: Other) -&gt; Bool<br>&gt;   func isLessThanOrEqual&lt;Other: BinaryFloatingPoint&gt;(to other: Other) -&gt; Bool<br>&gt;   func isUnordered&lt;Other: BinaryFloatingPoint&gt;(with other: Other) -&gt; Bool<br>&gt;   func isTotallyOrdered&lt;Other: BinaryFloatingPoint&gt;(with other: Other) -&gt; Bool<br></p><p>Can you provide some color on these? Loosening the typing in this way is quite unusual in Swift; you&#39;re not doing it for arithmetic operators, for instance.<br></p><p>&gt;   init(nan payload: Self.RawSignificand, signaling: Bool)<br></p><p><br>The discussion doesn&#39;t mention why this isn&#39;t part of the protocol. Any commentary? (I&#39;m guessing it&#39;s &quot;you need to know the type anyway to do anything useful with the payload&quot;, but I&#39;m not sure, and it&#39;s useful to document the reasons for these sorts of decisions)<br></p><p>&gt; 	* What is your evaluation of the proposal?<br></p><p>I think it&#39;s a huge improvement.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes. The current floating-point protocols are inadequate.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes.<br></p><p>&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>I don&#39;t have much experience with floating-point abstractions of this sort, but as far as the end-user APIs are concerned, I really like these APIs.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>Participated in the previous round of discussion as well as this one.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/49f329a0267f5a1773a77017882a82a8?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Rainer Brockerhoff</string> &lt;rainer at brockerhoff.net&gt;<p>April 24, 2016 at 10:00:00am</p></header><div class="content"><p>On 4/23/16 21:53, Brent Royal-Gordon via swift-evolution wrote:<br>&gt;&gt; public protocol FloatingPoint: Comparable, IntegerLiteralConvertible {<br>&gt;&gt; public protocol BinaryFloatingPoint: FloatingPoint, FloatLiteralConvertible {<br>&gt; <br>&gt; Any reason why FloatLiteralConvertible isn&#39;t on FloatingPoint?<br></p><p>While I&#39;m not competent to comment on the other points, I would venture<br>to suggest that, in order to accomodate a future Decimal type (and<br>DecimalFloatingPoint protocol), a BinaryFloatLiteralConvertible may be a<br>necessary subset of FloatLiteralConvertible - as some literals don&#39;t<br>have a lossless binary representation, etc.<br></p><p>-- <br>Rainer Brockerhoff  &lt;rainer at brockerhoff.net&gt;<br>Belo Horizonte, Brazil<br>&quot;In the affairs of others even fools are wise<br>In their own business even sages err.&quot;<br>http://brockerhoff.net/blog/<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>April 25, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Apr 23, 2016, at 8:53 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; A few things…<br>&gt; <br>&gt; First, something absent: I&#39;m a little bit concerned by the act that there&#39;s no means to convert between different concrete FloatingPoint types. Something like the IntMax mechanism in Swift 2&#39;s IntegerType might be useful, though there may be good reasons not to do that.<br></p><p>There are concrete conversions between all built in float types.  Those aren’t going away.  Are you saying that you want init(_ value: Float) etc to be protocol requirements?<br></p><p>&gt;&gt; public protocol FloatingPoint: Comparable, IntegerLiteralConvertible {<br>&gt;&gt; public protocol BinaryFloatingPoint: FloatingPoint, FloatLiteralConvertible {<br>&gt; <br>&gt; Any reason why FloatLiteralConvertible isn&#39;t on FloatingPoint?<br></p><p>It doesn’t make sense for non-radix-2 types; you would change bases multiple times.<br></p><p>&gt;&gt;  prefix func +(x: Self) -&gt; Self<br>&gt; <br>&gt; Does this actually do anything, or is it a no-op? If the latter, should it just be a free function rather than part of the protocol? Or maybe even part of the literal syntax that can&#39;t be applied to variables at all?<br>&gt; <br>&gt;&gt;  static func minimum(x: Self, _ y: Self) -&gt; Self<br>&gt;&gt;  static func maximum(x: Self, _ y: Self) -&gt; Self<br>&gt;&gt;  static func minimumMagnitude(x: Self, _ y: Self) -&gt; Self<br>&gt;&gt;  static func maximumMagnitude(x: Self, _ y: Self) -&gt; Self<br>&gt; <br>&gt; These all take two operands, but I can&#39;t think of a reason for that. Might they be better off as variadic? (Or is the &quot;implementation hook&quot; comment meant to indicate that the variadic form of the `max` free function will use these calls?)<br></p><p>Correct, the free functions will use these.<br></p><p>&gt;&gt;  func isEqual(to other: Self) -&gt; Bool<br>&gt;&gt;  func isLess(than other: Self) -&gt; Bool<br>&gt;&gt;  func isLessThanOrEqual(to other: Self) -&gt; Bool<br>&gt; <br>&gt; I&#39;m still not sure why these are methods instead of operators.<br>&gt; <br>&gt; (I also share others&#39; concern about the argument label on `isLessThanOrEqual`.)<br></p><p>There’s lots of concern, and very few suggestions of anything better.  The only thing that seems workable is maybe `isLessThanOrEqualTo(_:)`, which is inconsistent with the other comparisons, but maybe that’s the right thing to do anyway.<br></p><p>&gt;&gt;  func isUnordered(with other: Self) -&gt; Bool<br>&gt;&gt;  func isTotallyOrdered(with other: Self) -&gt; Bool<br>&gt; <br>&gt; I think these features should be folded into Comparable, but I&#39;ll start a different thread about that. For the moment, these seem fine.<br>&gt; <br>&gt;&gt;  func isEqual&lt;Other: BinaryFloatingPoint&gt;(to other: Other) -&gt; Bool<br>&gt;&gt;  func isLess&lt;Other: BinaryFloatingPoint&gt;(than other: Other) -&gt; Bool<br>&gt;&gt;  func isLessThanOrEqual&lt;Other: BinaryFloatingPoint&gt;(to other: Other) -&gt; Bool<br>&gt;&gt;  func isUnordered&lt;Other: BinaryFloatingPoint&gt;(with other: Other) -&gt; Bool<br>&gt;&gt;  func isTotallyOrdered&lt;Other: BinaryFloatingPoint&gt;(with other: Other) -&gt; Bool<br>&gt; <br>&gt; Can you provide some color on these? Loosening the typing in this way is quite unusual in Swift; you&#39;re not doing it for arithmetic operators, for instance.<br></p><p>Heterogeneous comparisons have an unambiguous result type and correct result.  Heterogeneous arithmetic does not (at least, not in all cases), so it’s a more difficult language design problem.<br></p><p>&gt;&gt;  init(nan payload: Self.RawSignificand, signaling: Bool)<br>&gt; <br>&gt; The discussion doesn&#39;t mention why this isn&#39;t part of the protocol. Any commentary? (I&#39;m guessing it&#39;s &quot;you need to know the type anyway to do anything useful with the payload&quot;, but I&#39;m not sure, and it&#39;s useful to document the reasons for these sorts of decisions)<br></p><p>Yup, that’s exactly right.  I’ll add a note.<br></p><p>&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt; <br>&gt; I think it&#39;s a huge improvement.<br>&gt; <br>&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; <br>&gt; Yes. The current floating-point protocols are inadequate.<br>&gt; <br>&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; Yes.<br>&gt; <br>&gt;&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; <br>&gt; I don&#39;t have much experience with floating-point abstractions of this sort, but as far as the end-user APIs are concerned, I really like these APIs.<br>&gt; <br>&gt;&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; Participated in the previous round of discussion as well as this one.<br></p><p>Thanks for the feedback!<br>– Steve<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April 25, 2016 at 06:00:00pm</p></header><div class="content"><p>On Mon, Apr 25, 2016 at 1:32 PM, Stephen Canon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Apr 23, 2016, at 8:53 PM, Brent Royal-Gordon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;  func isEqual(to other: Self) -&gt; Bool<br>&gt; &gt;&gt;  func isLess(than other: Self) -&gt; Bool<br>&gt; &gt;&gt;  func isLessThanOrEqual(to other: Self) -&gt; Bool<br>&gt; &gt;<br>&gt; &gt; I&#39;m still not sure why these are methods instead of operators.<br>&gt; &gt;<br>&gt; &gt; (I also share others&#39; concern about the argument label on<br>&gt; `isLessThanOrEqual`.)<br>&gt;<br>&gt; There’s lots of concern, and very few suggestions of anything better.  The<br>&gt; only thing that seems workable is maybe `isLessThanOrEqualTo(_:)`, which is<br>&gt; inconsistent with the other comparisons, but maybe that’s the right thing<br>&gt; to do anyway.<br>&gt;<br></p><p>My vote is with using operators, and perhaps actually introducing `&lt;=&gt;` for<br>total order as suggested elsewhere. Why invent method names for standard<br>operators?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160425/9315ec3d/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
