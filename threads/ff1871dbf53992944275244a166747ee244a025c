<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>References in Value Types (Deep-Copy-OnWrite)</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>December 18, 2015 at 12:00:00am</p></header><div class="content"><p>This isn&#39;t a proposal, more something to get a discussion started.<br></p><p>TL;DR: You can make a struct look like a class, a class look like a struct,<br>a mutable type appear immutable.<br></p><p>I think that Swift is doing these things as it should. However I think that<br>there is room for mistakes, and it would be nice to be aware of those<br>mistakes and guard against them.<br></p><p>Consider the following code:<br></p><p>private class MyClass {<br></p><p>    var value: Int<br></p><p>    init(value: Int) { self.value = value }<br></p><p>}<br></p><p>struct MyValue {<br></p><p>    private let reference: MyClass<br></p><p>    init(value: Int) {<br></p><p>        self.reference = MyClass(value: value)<br></p><p>    }<br></p><p>    var value: Int {<br></p><p>        get { return self.reference.value }<br></p><p>        set { self.reference.value = newValue }<br></p><p>    }<br></p><p>}<br></p><p><br>var myVariable = MyValue(value: 123)<br></p><p>print(myVariable.value) // &quot;123&quot;<br></p><p><br>let myOtherVariable = myVariable<br></p><p><br>myVariable.value = 456<br></p><p>print(myOtherVariable.value) // &quot;456&quot;!<br></p><p><br>Are all of our assumptions correct?<br> * Is myVariable&#39;s a value type? probably<br> * Is myVariable copy-on-write? perhaps<br> * Should we be able to write to myVariable.value despite reference being<br>let? probably<br> * Is this code unsafe, or misleading? yes. Can we prevent that? maybe<br></p><p>Some other code, this is not perfect but it mostly makes MyValue<br>copy-on-write:<br></p><p>protocol DeepCopier {<br></p><p>    typealias ObjectType: AnyObject<br></p><p>    static func deepCopy(that: ObjectType) -&gt; ObjectType<br></p><p>}<br></p><p>struct UniqueReference&lt;Copier: DeepCopier&gt; {<br></p><p>    private var _reference: Copier.ObjectType<br></p><p>    init(var reference: Copier.ObjectType) {<br></p><p>        if isUniquelyReferencedNonObjC(&amp;reference) {<br></p><p>            _reference = reference<br></p><p>        }<br></p><p>        else {<br></p><p>            _reference = Copier.deepCopy(reference)<br></p><p>        }<br></p><p>    }<br></p><p>    var reference: Copier.ObjectType { return self._reference }<br></p><p>    mutating func update(block: Copier.ObjectType -&gt; Void) {<br></p><p>        if !isUniquelyReferencedNonObjC(&amp;self._reference) {<br></p><p>            self._reference = Copier.deepCopy(self._reference)<br></p><p>        }<br></p><p>        block(self._reference)<br></p><p>    }<br></p><p>}<br></p><p><br>private class MyClass: NonObjectiveCBase {<br></p><p>    var value: Int<br></p><p>    init(value: Int) { self.value = value }<br></p><p>    func deepCopy() -&gt; MyClass {<br></p><p>        return MyClass(value: self.value)<br></p><p>    }<br></p><p>    private struct Copier: DeepCopier {<br></p><p>        static func deepCopy(that: MyClass) -&gt; MyClass {<br></p><p>            return MyClass(value: that.value)<br></p><p>        }<br></p><p>    }<br></p><p>}<br></p><p><br>struct MyValue {<br></p><p>    private var myReference: UniqueReference&lt;MyClass.Copier&gt;<br></p><p>    init(value: Int) {<br></p><p>        self.myReference = UniqueReference(reference: MyClass(value: value))<br></p><p>    }<br></p><p>    var value: Int {<br></p><p>        get { return self.myReference.reference.value }<br></p><p>        set { self.myReference.update { $0.value = newValue } }<br></p><p>    }<br></p><p>}<br></p><p><br>var myVariable = MyValue(value: 123)<br></p><p>print(myVariable.value) // &quot;123&quot;<br></p><p><br>let myOtherVariable = myVariable<br></p><p><br>myVariable.value = 456<br></p><p>print(myOtherVariable.value) // &quot;123&quot;<br></p><p>print(myVariable.value) // &quot;456&quot;<br></p><p><br>Even more code, I don&#39;t trust anything any more:<br></p><p>struct MyValue {<br></p><p>    init(value: Int) { }<br></p><p>    var value: Int {<br></p><p>        get { return Int(arc4random()) }<br></p><p>        set { }<br></p><p>    }<br></p><p>}<br></p><p><br>The public interface for MyValue in all these cases looks totally innocent:<br></p><p>struct MyValue {<br></p><p>    init(value: Int)<br></p><p>    var value: Int<br></p><p>}<br></p><p><br>Protocols are the same, they provide no guarantees about immutability, or<br>deep-copy-on-write:<br></p><p>protocol SomeValue {<br></p><p>    init(value: Int)<br></p><p>    var value: Int { get }<br></p><p>}<br></p><p><br>The results may be a bit surprising.<br></p><p> * Perhaps we could introduce a &quot;const&quot; keyword like in other languages, so<br>the class cannot be mutated (how do we even scope this?).<br> * Perhaps we could prevent structures from holding references (no classes,<br>non-pure blocks, no arc4random, no AnySequence, ...).<br> * Perhaps we can add a @copy_on_write keyword on structures that enforces<br>certain guarantees? (how?)<br> * Perhaps add language support for DeepCopier (with a better name,<br>probably a keyword rather than a protocol), that allows anything to be<br>copied like a structure (my preference).<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/ff18025c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>References in Value Types (Deep-Copy-OnWrite)</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 17, 2015 at 06:00:00am</p></header><div class="content"><p>&gt; TL;DR: You can make a struct look like a class, a class look like a struct, a mutable type appear immutable.<br></p><p>This is simply not possible to prevent, at least without turning structs into dumb data structures a la C. Here’s something that’s value types all the way down, but behaves like a reference type:<br>	<br>	struct MyValue {<br>	    private static var realValues: [Int] = []<br>	    private let index: Int<br></p><p>	    init(value: Int) {<br>	        self.index = MyValue.realValues.count<br>	        MyValue.realValues.append(value)<br>	    }<br>	    var value: Int {<br>	        get { return MyValue.realValues[index] }<br>	        set { MyValue.realValues[index] = newValue }<br>	    }<br>	}<br></p><p>Similarly, you can make reference types with value-like semantics—think of NSDate, which is a reference type, but is immutable and only provides operations which return a new instance. The ultimate proof of this is not in Swift but in Ruby, where even simple numbers are objects, but they offer no mutation operations so they behave just like value-typed numbers in other languages.<br></p><p>Ultimately, you just have to trust the person writing the type to provide the expected semantics, or to document any deviations. (GeneratorType, which does not require even struct-based generators to guarantee that they will iterate separately if you copy them, are an example of the latter.) This leaves room for mischief, but that’s life in a Turing machine.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>References in Value Types (Deep-Copy-OnWrite)</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>December 18, 2015 at 02:00:00am</p></header><div class="content"><p>I agree with pretty much everything you said, although I&#39;m not saying we<br>should &quot;solve&quot; this, but that we should discuss it. One thing we might be<br>able to do is instead of trusting the person writing the type to:<br></p><p>   - &quot;provide the expected semantics, or to document any deviations&quot;<br></p><p>we may trust the person writing the type to:<br></p><p>   - &quot;annotate the type with the expected semantics&quot;<br></p><p>If such annotations existed. It wouldn&#39;t force everything to be c-like, but<br>it could allow them to be predictable.<br></p><p>I&#39;m not saying annotations are the way to go, just that there is an issue,<br>you seem to agree, and that it&#39;d be nice to brainstorm it.<br></p><p><br></p><p>On Fri, Dec 18, 2015 at 1:42 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>wrote:<br></p><p>&gt; &gt; TL;DR: You can make a struct look like a class, a class look like a<br>&gt; struct, a mutable type appear immutable.<br>&gt;<br>&gt; This is simply not possible to prevent, at least without turning structs<br>&gt; into dumb data structures a la C. Here’s something that’s value types all<br>&gt; the way down, but behaves like a reference type:<br>&gt;<br>&gt;         struct MyValue {<br>&gt;             private static var realValues: [Int] = []<br>&gt;             private let index: Int<br>&gt;<br>&gt;             init(value: Int) {<br>&gt;                 self.index = MyValue.realValues.count<br>&gt;                 MyValue.realValues.append(value)<br>&gt;             }<br>&gt;             var value: Int {<br>&gt;                 get { return MyValue.realValues[index] }<br>&gt;                 set { MyValue.realValues[index] = newValue }<br>&gt;             }<br>&gt;         }<br>&gt;<br>&gt; Similarly, you can make reference types with value-like semantics—think of<br>&gt; NSDate, which is a reference type, but is immutable and only provides<br>&gt; operations which return a new instance. The ultimate proof of this is not<br>&gt; in Swift but in Ruby, where even simple numbers are objects, but they offer<br>&gt; no mutation operations so they behave just like value-typed numbers in<br>&gt; other languages.<br>&gt;<br>&gt; Ultimately, you just have to trust the person writing the type to provide<br>&gt; the expected semantics, or to document any deviations. (GeneratorType,<br>&gt; which does not require even struct-based generators to guarantee that they<br>&gt; will iterate separately if you copy them, are an example of the latter.)<br>&gt; This leaves room for mischief, but that’s life in a Turing machine.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/b2110870/attachment-0001.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2861bfeb71de9de58206bb6ae750bc2f?s=50"></div><header><strong>References in Value Types (Deep-Copy-OnWrite)</strong> from <string>ilya</string> &lt;ilya.nikokoshev at gmail.com&gt;<p>December 17, 2015 at 11:00:00pm</p></header><div class="content"><p>&gt; Is myVariable&#39;s a value type?<br></p><p>It&#39;s a struct, so an object that has a copy constuctor that works by<br>copying a reference. Does it help anyone to call it a &quot;value type&quot;? Maybe<br>not.<br></p><p>&gt; Is myVariable copy-on-write?<br></p><p>No, copy-on-write refers to the behavior of objects that have a shared<br>buffer that gets coped lazily, when a mutation is required. This is not the<br>behavior observed here.<br></p><p>&gt; Should we be able to write to myVariable.value despite reference being<br>let?<br></p><p>Yes. let a = ... means that a name a is bound to an expression; it doesn&#39;t<br>mean that this name refers to an object with immutable state. Just like we<br>write<br></p><p>let label = UILabel()<br></p><p>label.text = &quot;Some text&quot;<br>label.textColor = .redColor()<br>...<br></p><p>&gt; Is this code unsafe, or misleading? yes. Can we prevent that? maybe<br></p><p>It&#39;s very cryptic and mysterious when written with names like MyClass and<br>MyValue, but is should be more understandiable in a real-world situation:<br></p><p>private class MutableInternalBuffer {<br>    var value: [Int]<br>    init(value: [Int]) { self.value = value }<br>}<br></p><p>struct MutableBufferedData {<br></p><p>    private let internalBuffer: MutableInternalBuffer<br></p><p>    init(initialData value: Int) {<br>        internalBuffer = InternalBuffer(value: value)<br>    }<br></p><p>    var currentData: [Int] {<br>        get { return internalBuffer.value }<br>        set { internalBuffer.value = newValue }<br>    }<br>}<br></p><p>var myMutableData = MutableBufferedData(initialData: [1, 2, 3])<br>print(myMutableData.value)<br></p><p>let myOtherAccessor = myMutableData<br></p><p>myMutableData.value = [4, 5, 6]<br>print(myOtherAccessor.currentData)<br></p><p>On Thu, Dec 17, 2015 at 4:51 PM, Andrew Bennett via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; This isn&#39;t a proposal, more something to get a discussion started.<br>&gt;<br>&gt; TL;DR: You can make a struct look like a class, a class look like a<br>&gt; struct, a mutable type appear immutable.<br>&gt;<br>&gt; I think that Swift is doing these things as it should. However I think<br>&gt; that there is room for mistakes, and it would be nice to be aware of those<br>&gt; mistakes and guard against them.<br>&gt;<br>&gt; Consider the following code:<br>&gt;<br>&gt; private class MyClass {<br>&gt;<br>&gt;     var value: Int<br>&gt;<br>&gt;     init(value: Int) { self.value = value }<br>&gt;<br>&gt; }<br>&gt;<br>&gt; struct MyValue {<br>&gt;<br>&gt;     private let reference: MyClass<br>&gt;<br>&gt;     init(value: Int) {<br>&gt;<br>&gt;         self.reference = MyClass(value: value)<br>&gt;<br>&gt;     }<br>&gt;<br>&gt;     var value: Int {<br>&gt;<br>&gt;         get { return self.reference.value }<br>&gt;<br>&gt;         set { self.reference.value = newValue }<br>&gt;<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; var myVariable = MyValue(value: 123)<br>&gt;<br>&gt; print(myVariable.value) // &quot;123&quot;<br>&gt;<br>&gt;<br>&gt; let myOtherVariable = myVariable<br>&gt;<br>&gt;<br>&gt; myVariable.value = 456<br>&gt;<br>&gt; print(myOtherVariable.value) // &quot;456&quot;!<br>&gt;<br>&gt;<br>&gt; Are all of our assumptions correct?<br>&gt;  * Is myVariable&#39;s a value type? probably<br>&gt;  * Is myVariable copy-on-write? perhaps<br>&gt;  * Should we be able to write to myVariable.value despite reference being<br>&gt; let? probably<br>&gt;  * Is this code unsafe, or misleading? yes. Can we prevent that? maybe<br>&gt;<br>&gt; Some other code, this is not perfect but it mostly makes MyValue<br>&gt; copy-on-write:<br>&gt;<br>&gt; protocol DeepCopier {<br>&gt;<br>&gt;     typealias ObjectType: AnyObject<br>&gt;<br>&gt;     static func deepCopy(that: ObjectType) -&gt; ObjectType<br>&gt;<br>&gt; }<br>&gt;<br>&gt; struct UniqueReference&lt;Copier: DeepCopier&gt; {<br>&gt;<br>&gt;     private var _reference: Copier.ObjectType<br>&gt;<br>&gt;     init(var reference: Copier.ObjectType) {<br>&gt;<br>&gt;         if isUniquelyReferencedNonObjC(&amp;reference) {<br>&gt;<br>&gt;             _reference = reference<br>&gt;<br>&gt;         }<br>&gt;<br>&gt;         else {<br>&gt;<br>&gt;             _reference = Copier.deepCopy(reference)<br>&gt;<br>&gt;         }<br>&gt;<br>&gt;     }<br>&gt;<br>&gt;     var reference: Copier.ObjectType { return self._reference }<br>&gt;<br>&gt;     mutating func update(block: Copier.ObjectType -&gt; Void) {<br>&gt;<br>&gt;         if !isUniquelyReferencedNonObjC(&amp;self._reference) {<br>&gt;<br>&gt;             self._reference = Copier.deepCopy(self._reference)<br>&gt;<br>&gt;         }<br>&gt;<br>&gt;         block(self._reference)<br>&gt;<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; private class MyClass: NonObjectiveCBase {<br>&gt;<br>&gt;     var value: Int<br>&gt;<br>&gt;     init(value: Int) { self.value = value }<br>&gt;<br>&gt;     func deepCopy() -&gt; MyClass {<br>&gt;<br>&gt;         return MyClass(value: self.value)<br>&gt;<br>&gt;     }<br>&gt;<br>&gt;     private struct Copier: DeepCopier {<br>&gt;<br>&gt;         static func deepCopy(that: MyClass) -&gt; MyClass {<br>&gt;<br>&gt;             return MyClass(value: that.value)<br>&gt;<br>&gt;         }<br>&gt;<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; struct MyValue {<br>&gt;<br>&gt;     private var myReference: UniqueReference&lt;MyClass.Copier&gt;<br>&gt;<br>&gt;     init(value: Int) {<br>&gt;<br>&gt;         self.myReference = UniqueReference(reference: MyClass(value:<br>&gt; value))<br>&gt;<br>&gt;     }<br>&gt;<br>&gt;     var value: Int {<br>&gt;<br>&gt;         get { return self.myReference.reference.value }<br>&gt;<br>&gt;         set { self.myReference.update { $0.value = newValue } }<br>&gt;<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; var myVariable = MyValue(value: 123)<br>&gt;<br>&gt; print(myVariable.value) // &quot;123&quot;<br>&gt;<br>&gt;<br>&gt; let myOtherVariable = myVariable<br>&gt;<br>&gt;<br>&gt; myVariable.value = 456<br>&gt;<br>&gt; print(myOtherVariable.value) // &quot;123&quot;<br>&gt;<br>&gt; print(myVariable.value) // &quot;456&quot;<br>&gt;<br>&gt;<br>&gt; Even more code, I don&#39;t trust anything any more:<br>&gt;<br>&gt; struct MyValue {<br>&gt;<br>&gt;     init(value: Int) { }<br>&gt;<br>&gt;     var value: Int {<br>&gt;<br>&gt;         get { return Int(arc4random()) }<br>&gt;<br>&gt;         set { }<br>&gt;<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; The public interface for MyValue in all these cases looks totally innocent:<br>&gt;<br>&gt; struct MyValue {<br>&gt;<br>&gt;     init(value: Int)<br>&gt;<br>&gt;     var value: Int<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Protocols are the same, they provide no guarantees about immutability, or<br>&gt; deep-copy-on-write:<br>&gt;<br>&gt; protocol SomeValue {<br>&gt;<br>&gt;     init(value: Int)<br>&gt;<br>&gt;     var value: Int { get }<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; The results may be a bit surprising.<br>&gt;<br>&gt;  * Perhaps we could introduce a &quot;const&quot; keyword like in other languages,<br>&gt; so the class cannot be mutated (how do we even scope this?).<br>&gt;  * Perhaps we could prevent structures from holding references (no<br>&gt; classes, non-pure blocks, no arc4random, no AnySequence, ...).<br>&gt;  * Perhaps we can add a @copy_on_write keyword on structures that enforces<br>&gt; certain guarantees? (how?)<br>&gt;  * Perhaps add language support for DeepCopier (with a better name,<br>&gt; probably a keyword rather than a protocol), that allows anything to be<br>&gt; copied like a structure (my preference).<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/caaf3297/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
