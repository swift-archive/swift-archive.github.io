<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0089229ece6e648767cff4dc6c6d38ab?s=50"></div><header><strong>Optimization attributes</strong> from <string>Charles Kissinger</string> &lt;crk at akkyra.com&gt;<p>January  7, 2016 at 01:00:00pm</p></header><div class="content"><p>I wanted to float the idea of adding new attributes for function and method declarations that would allow various safety checks to be turned off (or on) at the level of individual functions. Examples of such attributes would be:<br></p><p>@uncheckedmath  // integer overflow<br>@uncheckedbounds  // array bounds<br>@unchecked      // no safety checks, equivalent to -Ounchecked<br>@fastmath         // if the —fastmath compiler option becomes available in the future<br></p><p>These attributes could have an argument with a value of true or false, allowing the global compiler option to be overridden for particular functions.<br></p><p>This is primarily motivated by the fact that the -Ounchecked compiler option is a very blunt instrument. It globally disables several unrelated safety checks such as integer overflow and array bounds checking. And it operates only at the level of an entire compilation unit. It is hard to reason about all the effects of this option across a large module, and isolating specific code to be compiled separately with -Ounchecked is inconvenient.<br></p><p>These new attributes would allow specific safety checks to be enabled or disabled on a per-function basis. I think the overall effect would be safer programs, because developers would be less likely to resort to the global -Ounchecked compiler option when searching for better performance.<br></p><p>Are optimization attributes such as these feasible?<br></p><p>-CK<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Optimization attributes</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>January  7, 2016 at 02:00:00pm</p></header><div class="content"><p>Would these be more appropriate as scoped modifiers similar to<br>#available(...)?<br></p><p>    func foo() {<br>        ...<br>        #unchecked {<br>            // stuff in here is unchecked<br>        }<br>    }<br></p><p><br>On Thu, Jan 7, 2016 at 1:55 PM, Charles Kissinger via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I wanted to float the idea of adding new attributes for function and<br>&gt; method declarations that would allow various safety checks to be turned off<br>&gt; (or on) at the level of individual functions. Examples of such attributes<br>&gt; would be:<br>&gt;<br>&gt; @uncheckedmath  // integer overflow<br>&gt; @uncheckedbounds  // array bounds<br>&gt; @unchecked      // no safety checks, equivalent to -Ounchecked<br>&gt; @fastmath         // if the —fastmath compiler option becomes available in<br>&gt; the future<br>&gt;<br>&gt; These attributes could have an argument with a value of true or false,<br>&gt; allowing the global compiler option to be overridden for particular<br>&gt; functions.<br>&gt;<br>&gt; This is primarily motivated by the fact that the -Ounchecked compiler<br>&gt; option is a very blunt instrument. It globally disables several unrelated<br>&gt; safety checks such as integer overflow and array bounds checking. And it<br>&gt; operates only at the level of an entire compilation unit. It is hard to<br>&gt; reason about all the effects of this option across a large module, and<br>&gt; isolating specific code to be compiled separately with -Ounchecked is<br>&gt; inconvenient.<br>&gt;<br>&gt; These new attributes would allow specific safety checks to be enabled or<br>&gt; disabled on a per-function basis. I think the overall effect would be safer<br>&gt; programs, because developers would be less likely to resort to the global<br>&gt; -Ounchecked compiler option when searching for better performance.<br>&gt;<br>&gt; Are optimization attributes such as these feasible?<br>&gt;<br>&gt; -CK<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/0e7fcb64/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0089229ece6e648767cff4dc6c6d38ab?s=50"></div><header><strong>Optimization attributes</strong> from <string>Charles Kissinger</string> &lt;crk at akkyra.com&gt;<p>January  7, 2016 at 02:00:00pm</p></header><div class="content"><p>Yes! (As far as I’m concerned.) Operating on scopes was what I originally had in mind, but I then overlooked the # modifier approach.<br></p><p>—CK<br></p><p>&gt; On Jan 7, 2016, at 2:10 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt; Would these be more appropriate as scoped modifiers similar to #available(...)?<br>&gt; <br>&gt;     func foo() {<br>&gt;         ...<br>&gt;         #unchecked {<br>&gt;             // stuff in here is unchecked<br>&gt;         }<br>&gt;     }<br>&gt; <br>&gt; <br>&gt; On Thu, Jan 7, 2016 at 1:55 PM, Charles Kissinger via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; I wanted to float the idea of adding new attributes for function and method declarations that would allow various safety checks to be turned off (or on) at the level of individual functions. Examples of such attributes would be:<br>&gt; <br>&gt; @uncheckedmath  // integer overflow<br>&gt; @uncheckedbounds  // array bounds<br>&gt; @unchecked      // no safety checks, equivalent to -Ounchecked<br>&gt; @fastmath         // if the —fastmath compiler option becomes available in the future<br>&gt; <br>&gt; These attributes could have an argument with a value of true or false, allowing the global compiler option to be overridden for particular functions.<br>&gt; <br>&gt; This is primarily motivated by the fact that the -Ounchecked compiler option is a very blunt instrument. It globally disables several unrelated safety checks such as integer overflow and array bounds checking. And it operates only at the level of an entire compilation unit. It is hard to reason about all the effects of this option across a large module, and isolating specific code to be compiled separately with -Ounchecked is inconvenient.<br>&gt; <br>&gt; These new attributes would allow specific safety checks to be enabled or disabled on a per-function basis. I think the overall effect would be safer programs, because developers would be less likely to resort to the global -Ounchecked compiler option when searching for better performance.<br>&gt; <br>&gt; Are optimization attributes such as these feasible?<br>&gt; <br>&gt; -CK<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/a6479f8c/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Optimization attributes</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January  7, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jan 7, 2016, at 1:55 PM, Charles Kissinger via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I wanted to float the idea of adding new attributes for function and method declarations that would allow various safety checks to be turned off (or on) at the level of individual functions. Examples of such attributes would be:<br>&gt; <br>&gt; @uncheckedmath  // integer overflow<br>&gt; @uncheckedbounds  // array bounds<br>&gt; @unchecked      // no safety checks, equivalent to -Ounchecked<br>&gt; @fastmath         // if the —fastmath compiler option becomes available in the future<br>&gt; <br>&gt; These attributes could have an argument with a value of true or false, allowing the global compiler option to be overridden for particular functions.<br>&gt; <br>&gt; This is primarily motivated by the fact that the -Ounchecked compiler option is a very blunt instrument. It globally disables several unrelated safety checks such as integer overflow and array bounds checking. And it operates only at the level of an entire compilation unit. It is hard to reason about all the effects of this option across a large module, and isolating specific code to be compiled separately with -Ounchecked is inconvenient.<br>&gt; <br>&gt; These new attributes would allow specific safety checks to be enabled or disabled on a per-function basis. I think the overall effect would be safer programs, because developers would be less likely to resort to the global -Ounchecked compiler option when searching for better performance.<br>&gt; <br>&gt; Are optimization attributes such as these feasible?<br></p><p>Scoped semantics changes like this are problematic. It&#39;s easy to accidentally change behavior you didn&#39;t intend to by applying the attributes too broadly, and it&#39;s harder for readers to understand the behavior within the contextual modifiers. It&#39;s also hard to define exactly what these mean, since many of the operations in question are defined as library functions. I think it&#39;s better in general to use explicitly unsafe operations, for instance, using &amp;+ instead of + to ignore overflow checks. You could theoretically get something like the scoped attribute effect by using scoped imports, which could bring in a different set of operations shadowing the standard ones:<br></p><p>do {<br>  import FastMath // FastMath.* now shadows Swift.*<br></p><p>  return 4*x*x + 2*x + 1<br>}<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0089229ece6e648767cff4dc6c6d38ab?s=50"></div><header><strong>Optimization attributes</strong> from <string>Charles Kissinger</string> &lt;crk at akkyra.com&gt;<p>January  7, 2016 at 06:00:00pm</p></header><div class="content"><p>Joe,<br></p><p>Thanks very much for the feedback. I accept your points, but just a few comments:<br></p><p>&gt; It&#39;s easy to accidentally change behavior you didn&#39;t intend to by applying the attributes too broadly<br>Yes, but this was exactly the reason for proposing this as an alternative to the global compiler switch.<br></p><p>&gt; It&#39;s also hard to define exactly what these mean, since many of the operations in question are defined as library functions.<br>But the -Ounchecked compiler switch already has a defined mechanism in place for eliding these function calls, correct?<br></p><p>&gt;  I think it&#39;s better in general to use explicitly unsafe operations, for instance, using &amp;+ instead of + to ignore overflow checks.<br>Agreed. The biggest problem with those operators is that they are a pain to scan through quickly and understand in even slightly more complex expressions. To take your equation below, translated to overflow operators:<br></p><p>return 4 &amp;* x &amp;* x &amp;+ 2 &amp;* x &amp;+ 1<br></p><p>Yuck! All I see are the ampersands unless I squint. I had to read through it three times just to convince myself I translated the equation correctly.<br></p><p>&gt; You could theoretically get something like the scoped attribute effect by using scoped imports, which could bring in a different set of operations shadowing the standard ones:<br>&gt; <br>&gt; do {<br>&gt;  import FastMath // FastMath.* now shadows Swift.*<br>&gt; <br>&gt;  return 4*x*x + 2*x + 1<br>&gt; }<br>Interesting approach. It would allow developers to implement a very limited set of “do-it-yourself” optimizations for some things. (I’m pretty sure DIY fast-math is out of the question though.)<br></p><p>Thanks again,<br>-CK<br></p><p>&gt; <br>&gt; On Jan 7, 2016, at 4:04 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 7, 2016, at 1:55 PM, Charles Kissinger via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I wanted to float the idea of adding new attributes for function and method declarations that would allow various safety checks to be turned off (or on) at the level of individual functions. Examples of such attributes would be:<br>&gt;&gt; <br>&gt;&gt; @uncheckedmath  // integer overflow<br>&gt;&gt; @uncheckedbounds  // array bounds<br>&gt;&gt; @unchecked      // no safety checks, equivalent to -Ounchecked<br>&gt;&gt; @fastmath         // if the —fastmath compiler option becomes available in the future<br>&gt;&gt; <br>&gt;&gt; These attributes could have an argument with a value of true or false, allowing the global compiler option to be overridden for particular functions.<br>&gt;&gt; <br>&gt;&gt; This is primarily motivated by the fact that the -Ounchecked compiler option is a very blunt instrument. It globally disables several unrelated safety checks such as integer overflow and array bounds checking. And it operates only at the level of an entire compilation unit. It is hard to reason about all the effects of this option across a large module, and isolating specific code to be compiled separately with -Ounchecked is inconvenient.<br>&gt;&gt; <br>&gt;&gt; These new attributes would allow specific safety checks to be enabled or disabled on a per-function basis. I think the overall effect would be safer programs, because developers would be less likely to resort to the global -Ounchecked compiler option when searching for better performance.<br>&gt;&gt; <br>&gt;&gt; Are optimization attributes such as these feasible?<br>&gt; <br>&gt; Scoped semantics changes like this are problematic. It&#39;s easy to accidentally change behavior you didn&#39;t intend to by applying the attributes too broadly, and it&#39;s harder for readers to understand the behavior within the contextual modifiers. It&#39;s also hard to define exactly what these mean, since many of the operations in question are defined as library functions. I think it&#39;s better in general to use explicitly unsafe operations, for instance, using &amp;+ instead of + to ignore overflow checks. You could theoretically get something like the scoped attribute effect by using scoped imports, which could bring in a different set of operations shadowing the standard ones:<br>&gt; <br>&gt; do {<br>&gt;  import FastMath // FastMath.* now shadows Swift.*<br>&gt; <br>&gt;  return 4*x*x + 2*x + 1<br>&gt; }<br>&gt; <br>&gt; -Joe<br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Optimization Attributes for Automatic Reordering of Functions</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>January  7, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jan 7, 2016, at 13:55, Charles Kissinger via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I wanted to float the idea of adding new attributes for function and method declarations that would allow various safety checks to be turned off (or on) at the level of individual functions. Examples of such attributes would be:<br>&gt; <br>&gt; @uncheckedmath  // integer overflow<br>&gt; @uncheckedbounds  // array bounds<br>&gt; @unchecked      // no safety checks, equivalent to -Ounchecked<br>&gt; @fastmath         // if the —fastmath compiler option becomes available in the future<br></p><p>Oh! That reminds me! Can we add @associative, @commutative, and @distributive attributes to functions? Or at least to operators? I know it wouldn’t change anything *right now*, but it’d lay the groundwork for an entire new class of compiler optimizations. I think. Maybe they can already figure out stuff like this and I just don’t know about it.<br></p><p>For example, if the compiler knew that “*” could be distributed over “+”, then the compiler could rewrite this:<br>	let y = x*foo + x*bar<br>to this:<br>	let y = x*(foo + bar)<br>if it thinks that’s more efficient (which, I think it pretty much always would be for the native numeric types).<br></p><p>There’s an obvious danger in that overflows/underflows could be generated that wouldn’t have otherwise happened. However, this kind of rewriting could just as easily prevent them from happening, depending on the details.<br></p><p>Maybe the syntax could be tacked on the end of the definitions like this?<br>func + (lhs: Integer, rhs: Integer) -&gt; Integer {<br>	…<br>} @commutative @associative<br></p><p>func * (lhs: Integer, rhs: Integer) -&gt; Integer {<br>	…<br>} @commutative @associative @distributive over (+ - * /) // whitespace-delimited so that it won’t matter if an operator ends with a comma <br></p><p>Or maybe make it kinda sorta similar to an extension? (Although separating “the rules that tell the compiler how it’s allowed to literally rewrite your code” from “the functions to which said rules apply&quot; seems like a bad idea)<br>@attributes infix operator + {<br>	func + (_: Integer, _: Integer) -&gt; Integer @commutative @associative<br>}<br>@attributes infix operator * {<br>	func * (_: Integer, _: Integer) -&gt; Integer @commutative @associative @distributive over (+ - * /)<br>}<br></p><p>I think my favorite would be between the return type and the opening curly brace:<br>func + (lhs: Integer, rhs: Integer) -&gt; Integer @commutative @associative {<br>	…<br>}<br>func * (lhs: Integer, rhs: Integer) -&gt; Integer @commutative @associative @distributive over (+ - * /) {<br>	…<br>}<br></p><p>Going a step (or two) further, for funcs/ops that *aren’t* &lt;any given attribute&gt;, it could conceivably help to be able to optionally express a way to sorta fake it. For instance, while “a-b” usually doesn’t equal “b-a”, it does equal “-(b-a)”. Similarly, a/b is equal to 1/(b/a). (I know commutativity isn’t a particularly good example, since that attribute doesn’t affect when values need to be known, operand grouping, or the total number of operations, but I couldn’t think of any examples of the other types.) I’m much less supportive of this part… I think it’d be *cool*, but I have no idea if it’d be *useful*. It just seems to me that the more metadata we can give the compiler, the more opportunities it’ll have to optimize our code.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0089229ece6e648767cff4dc6c6d38ab?s=50"></div><header><strong>Optimization Attributes for Automatic Reordering of Functions</strong> from <string>Charles Kissinger</string> &lt;crk at akkyra.com&gt;<p>January  8, 2016 at 10:00:00am</p></header><div class="content"><p>Modern optimizing compilers have a very robust understanding of algebraic rearrangement already built in, I think.<br></p><p>It can’t safely be done on floating point calculations, by the way, because the result of the calculation is likely to change (usually very slightly, sometimes catastrophically). Some compilers have a -fast-math option that (among other things) allows some floating point rearrangement for cases where the developer knows it is safe and gives acceptable results.<br></p><p>—CK<br></p><p>&gt; On Jan 7, 2016, at 5:36 PM, Dave via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 7, 2016, at 13:55, Charles Kissinger via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I wanted to float the idea of adding new attributes for function and method declarations that would allow various safety checks to be turned off (or on) at the level of individual functions. Examples of such attributes would be:<br>&gt;&gt; <br>&gt;&gt; @uncheckedmath  // integer overflow<br>&gt;&gt; @uncheckedbounds  // array bounds<br>&gt;&gt; @unchecked      // no safety checks, equivalent to -Ounchecked<br>&gt;&gt; @fastmath         // if the —fastmath compiler option becomes available in the future<br>&gt; <br>&gt; Oh! That reminds me! Can we add @associative, @commutative, and @distributive attributes to functions? Or at least to operators? I know it wouldn’t change anything *right now*, but it’d lay the groundwork for an entire new class of compiler optimizations. I think. Maybe they can already figure out stuff like this and I just don’t know about it.<br>&gt; <br>&gt; For example, if the compiler knew that “*” could be distributed over “+”, then the compiler could rewrite this:<br>&gt; 	let y = x*foo + x*bar<br>&gt; to this:<br>&gt; 	let y = x*(foo + bar)<br>&gt; if it thinks that’s more efficient (which, I think it pretty much always would be for the native numeric types).<br>&gt; <br>&gt; There’s an obvious danger in that overflows/underflows could be generated that wouldn’t have otherwise happened. However, this kind of rewriting could just as easily prevent them from happening, depending on the details.<br>&gt; <br>&gt; Maybe the syntax could be tacked on the end of the definitions like this?<br>&gt; func + (lhs: Integer, rhs: Integer) -&gt; Integer {<br>&gt; 	…<br>&gt; } @commutative @associative<br>&gt; <br>&gt; func * (lhs: Integer, rhs: Integer) -&gt; Integer {<br>&gt; 	…<br>&gt; } @commutative @associative @distributive over (+ - * /) // whitespace-delimited so that it won’t matter if an operator ends with a comma <br>&gt; <br>&gt; Or maybe make it kinda sorta similar to an extension? (Although separating “the rules that tell the compiler how it’s allowed to literally rewrite your code” from “the functions to which said rules apply&quot; seems like a bad idea)<br>&gt; @attributes infix operator + {<br>&gt; 	func + (_: Integer, _: Integer) -&gt; Integer @commutative @associative<br>&gt; }<br>&gt; @attributes infix operator * {<br>&gt; 	func * (_: Integer, _: Integer) -&gt; Integer @commutative @associative @distributive over (+ - * /)<br>&gt; }<br>&gt; <br>&gt; I think my favorite would be between the return type and the opening curly brace:<br>&gt; func + (lhs: Integer, rhs: Integer) -&gt; Integer @commutative @associative {<br>&gt; 	…<br>&gt; }<br>&gt; func * (lhs: Integer, rhs: Integer) -&gt; Integer @commutative @associative @distributive over (+ - * /) {<br>&gt; 	…<br>&gt; }<br>&gt; <br>&gt; Going a step (or two) further, for funcs/ops that *aren’t* &lt;any given attribute&gt;, it could conceivably help to be able to optionally express a way to sorta fake it. For instance, while “a-b” usually doesn’t equal “b-a”, it does equal “-(b-a)”. Similarly, a/b is equal to 1/(b/a). (I know commutativity isn’t a particularly good example, since that attribute doesn’t affect when values need to be known, operand grouping, or the total number of operations, but I couldn’t think of any examples of the other types.) I’m much less supportive of this part… I think it’d be *cool*, but I have no idea if it’d be *useful*. It just seems to me that the more metadata we can give the compiler, the more opportunities it’ll have to optimize our code.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
