<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1ca49cd3335ea901615e52fc87e71372?s=50"></div><header><strong>[Draft] Unify &quot;import Darwin/Glibc&quot; to simply &quot;Libc&quot;</strong> from <string>Sean Alling</string> &lt;allings at icloud.com&gt;<p>October 10, 2016 at 11:00:00am</p></header><div class="content"><p>Hey guys and girls and everything in between,<br></p><p>I was discussing this on Twitter.<br></p><p>Perhaps the first step to easing this import system is to allow import conditional operators:<br></p><p>&amp;&amp;<br>||<br></p><p>would be the two of most use (mostly ||).  We could perform the Darwin or Glibc import based on order of operations. Should the first import library fail than try the second, third, etc. elements until one has either been found or none. This avoids creating a whole pure swift library, although that may be a longer term goal to create a ecosystem of architecture independent libraries for pure swift use cross platform.  Import statements for Darwin/Glibc would end up looking like this:<br></p><p>```<br>import Darwin || Glibc<br>```<br></p><p>I feel this would be well within line with Swift syntax.<br></p><p>- Sean<br></p><p><br>-----------------<br>Sean Alling<br>Nuclear Engineer<br></p><p>&gt; &gt; It looks like there are 2 views being discussed<br>&gt; &gt; <br>&gt; &gt; Import System : just masks the difference in platform specific names<br>&gt; &gt; Import Libc : a true attempt at a swift specific view of credible c runtime equivalent<br>&gt; &gt; <br>&gt; &gt; The first one would be easy to do now and would alleviate all the mindless #if...#endif we have today.<br>&gt; &gt; <br>&gt; &gt; Regards<br>&gt; &gt; LM<br>&gt; &gt; (From mobile)<br>&gt; &gt; <br>&gt; &gt; &gt; On Jul 6, 2016, at 1:13 AM, Chris Lattner via swift-evolution&lt;swift-evolution at swift.org&gt;wrote:<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; On Jul 5, 2016, at 2:59 PM, Brian Gesiak via swift-evolution&lt;swift-evolution at swift.org&gt;wrote:<br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; Sorry to resurrect such an old thread! I understand getting this in Swift 3.0 might not be realistic anymore, but this is still something I’d love to see added to Swift. Could someone advise on whether it still makes sense to spend time on this proposal? Or is this part of Swift too solidified to change at this point?<br>&gt; &gt; &gt; It is definitely beyond Swift 3.0, but I’d love to see this happen at some point, we really need someone to drive the (surely to be contentious) design process.<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; -Chris<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; How much would Libc include? The standard C library? POSIX?<br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; Yes, I had originally anticipated this as including module C and module POSIX. I see that module CUUID was recently added as well, but I don’t think that should be included.<br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; there are differences (minor, but still) between Glibc and Darwin. Those should be either unified (if possible) or re-arranged so that the unified library shares unified functionality and then each separate one can have its own set of caveats.<br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; I don’t think the unified import C module should do anything besides obviate the need to write the following:<br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; #if os(Linux) || os(FreeBSD)<br>&gt; &gt; &gt; &gt; import Glibc<br>&gt; &gt; &gt; &gt; #else<br>&gt; &gt; &gt; &gt; import Darwin<br>&gt; &gt; &gt; &gt; #endif<br>&gt; &gt; &gt; &gt; If people feel strongly about unifying the overlay, perhaps we should discuss that in future swift-evolution proposals.<br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; Personally, I like “import C”, but at the end of the day I’m happy to call it whatever as long as it solves the problem.<br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; I couldn’t have said it better myself!<br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; /cc Saleem, since he may have Windows opinions.<br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; - Brian Gesiak<br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; On Wed, Mar 9, 2016 at 6:35 AM, Honza Dvorsky&lt;czechboy0 at gmail.com&gt;wrote:<br>&gt; &gt; &gt; &gt; &gt; A huge +1 on the proposal, I even have a code snippet to import the platform-appropriate C library. I try to write every new Swift library cross-platform-by-default now and this would definitely remove some friction. Not to mention it would future-proof many libraries which won&#39;t need to be updated when a new Swift platform is added.<br>&gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; Personally, I like &quot;import C&quot;, but at the end of the day I&#39;m happy to call it whatever as long as it solves the problem. I agree with Brian that with Swift scaling up to 4 or so platforms soon-ish, it&#39;s preferable to not put any extra burden on Swift users if there is an almost-uniform C API which can be used everywhere.<br>&gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; On Wed, Mar 9, 2016 at 2:03 AM Jordan Rose via swift-evolution&lt;swift-evolution at swift.org&gt;wrote:<br>&gt; &gt; &gt; &gt; &gt; &gt; One of the reasons we haven&#39;t picked this particular name is if the C or C++ committees ever adopted modules. Given that they just got punted from C++17, though, maybe that shouldn&#39;t hold us back.<br>&gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; Jordan<br>&gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; On Mar 8, 2016, at 11:13, Brian Gesiak via swift-evolution&lt;swift-evolution at swift.org&gt;wrote:<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; # Introduction<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; Currently, cross-platform Swift programs that rely on symbols defined in libc (`fputs`, `stderr`, etc.) must all write the same five lines of boilerplate code:<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; #if os(Linux) || os(FreeBSD)<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; import Glibc<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; #else<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; import Darwin<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; #endif<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; Instead, I propose the following, which will work on all platforms:<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; import Libc<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; # Motivation<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; Let&#39;s say we wanted to write a program that, on any platform, would print &quot;Hello world!&quot; to stderr. We&#39;d probably come up with this:<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; #if os(Linux) || os(FreeBSD)<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; import Glibc<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; #else<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; import Darwin<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; #endif<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; fputs(&quot;Hello world!&quot;, stderr)<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; The first five lines of this program are necessary to import the symbols `fputs` and `stderr`. Five lines may not be much, but these come with significant drawbacks:<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; - They must be written in each source file that relies on libc, which is tedious.<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; - It is subject to frequent change. As Swift is ported to more platforms, that initial check must change to `#if os(Linux) || os(FreeBSD) || os(Windows) || os(Android)`, and so on. End users of Swift may not be actively involved in its development, and so may be surprised when the latest release suddenly necessitates more `os()` conditions.<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; - These combined force users to make a conscious decision to write cross-platform code--as opposed to simply writing Swift and have it work on other platforms seamlessly.<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; It would be preferable if people writing Swift did not need to check for the current `os()` in order to write code that works across platforms.<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; # Proposed solution<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; Instead of conditionally importing Darwin or Glibc, I propose the following:<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; import Libc<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; This would import whichever libc implementation Swift was compiled with. For Ubuntu Linux releases, this would be Glibc. For OS X releases, this would be Darwin. For Android (coming soon in https://github.com/apple/swift/pull/1442), this would be Bionic.<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; This saves the end user from writing boilerplate code, and it isolates them from the rapid expansion of platforms on which Swift is able to be executed.<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; This idea is not novel: the Swift package manager already defines a &quot;libc&quot; package that is essentially the boilerplate `os()` check above: https://github.com/apple/swift-package-manager/blob/master/Sources/libc/libc.swift.<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; However, rather than determining which libc implementation to use at runtime (like SwiftPM does above), I propose we allow the Swift stdlib to be compiled with any arbitrary implementation of libc.<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; # Detailed design<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; It&#39;s my understanding that the majority of this change would take place in the Swift build scripts and CMake modules. Similar to how those scripts export a module named &quot;Glibc&quot; on Linux (see stdlib/public/core/Glibc), this proposal could be implementing by exporting a &quot;Libc&quot; on all platforms.<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; This would also be accompanied by a change to the Swift 3 migrator that could automatically convert conditional imports of Darwin/Glibc to the new `import Libc`.<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; We must also devise a strategy for the transient rollout period, when Swift defines a Libc module, but we don&#39;t have an OS X SDK that uses that name in the bundled module.map. We can add a compiler hack for that, to transparently translate the name.<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; # Alternatives considered<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; I believe there are two contentious points to this proposal:<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; 1. Whether to unify the module name across platforms.<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; 2. What to name the module.<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; Alternatives considered on point #1 (whether to unify) include:<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; 1a. The status quo: I consider this to be undesirable for the reasons stated in &quot;Motivation&quot;. To reiterate: the current system forces users to go out of their way to write cross-platform Swift code, as opposed to writing code that &quot;just works&quot; everywhere.<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; 1b. The current Darwin and Glibc modules are a combination of POSIX and the C standard library. We could export *two* modules. However I believe this introduces additional overhead for users, with only the marginal benefit of clean separation between libc and POSIX.<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; 1c. A special import statement, defined in the Swift stdlib, that would automatically get preprocessed to the five lines of boilerplate shown above. This has several downsides, most notably the added complexity to Swift syntax.<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; On point #2 (what to name it), I have spoken with people that raised concerns over the name &quot;Libc&quot;:<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; Another concern is about compatibility with the C++ modules proposal. If we want this module name to mean something, it should agree with the C++ spec.<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; I don&#39;t know which name was chosen in the C++ spec. I&#39;ve been searching WG21 papers with no luck--any advice on how to find out would be appreciated!<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; Aside from the above point, some concrete alternatives for point #2 (what to name it) include:<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; - `import System`: This is better suited to the idea that the module contains both POSIX and libc.<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; - `import C`: Drop the &quot;Lib&quot;--just &quot;C&quot;. It&#39;s cleaner. (https://www.youtube.com/watch?v=PEgk2v6KntY)<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; ---<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; Thanks for taking the time to read this proposal draft! Feedback (on its contents or on how to proceed with the evolution proposal process) is greatly appreciated.<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; - Brian Gesiak<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; _______________________________________________<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; swift-evolution mailing list<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; swift-evolution at swift.org<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; _______________________________________________<br>&gt; &gt; &gt; &gt; &gt; &gt; swift-evolution mailing list<br>&gt; &gt; &gt; &gt; &gt; &gt; swift-evolution at swift.org<br>&gt; &gt; &gt; &gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; _______________________________________________<br>&gt; &gt; &gt; &gt; swift-evolution mailing list<br>&gt; &gt; &gt; &gt; swift-evolution at swift.org<br>&gt; &gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; _______________________________________________<br>&gt; &gt; &gt; swift-evolution mailing list<br>&gt; &gt; &gt; swift-evolution at swift.org<br>&gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; <br>&gt; &gt; <br>&gt; &gt;  <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161010/147767f3/attachment.html&gt;<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
