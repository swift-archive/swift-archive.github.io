<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Custom equality/hash for Sets</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>February 18, 2016 at 02:00:00pm</p></header><div class="content"><p>Would it make sense for the standard library Set to provide variants (or<br>parallel versions of the same data structure) that take custom hashValue/==<br>implementations at init time (functions taking in Elements), rather than<br>relying on Hashable/Comparable protocols?<br></p><p>Use case: I want a set of objects that are compared for equality using ===<br>rather than ==. This doesn&#39;t seem possible today, using Set, without<br>creating some sort of wrapper object.<br></p><p>This particular case would be analogous to using NSHashTable with<br>NSPointerFunctionsObjectPointerPersonality. (Maybe all I&#39;m asking for is a<br>Swiftier API for NSHashTable — including ArrayLiteralConvertible, using<br>generics instead of UnsafePointer&lt;Void&gt;, etc.)<br></p><p>Similarly, C++&#39;s unordered_map<br>&lt;http://en.cppreference.com/w/cpp/container/unordered_map&gt; and friends have<br>template parameters specifying the hash function and equality comparator,<br>which use std::hash and == by default.<br></p><p>(Apologies if this has been discussed already; I haven&#39;t seen it.)<br>Jacob<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160218/7333d198/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Custom equality/hash for Sets</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>February 18, 2016 at 08:00:00pm</p></header><div class="content"><p>On Thu, Feb 18, 2016 at 2:58 PM, Jacob Bandes-Storch via<br>swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Would it make sense for the standard library Set to provide variants (or<br>&gt; parallel versions of the same data structure) that take custom hashValue/==<br>&gt; implementations at init time (functions taking in Elements), rather than<br>&gt; relying on Hashable/Comparable protocols?<br></p><p>It might make sense, but we should keep in mind that doing this will<br>prevent inlining of hashValue/== in most cases.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Custom equality/hash for Sets</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>February 19, 2016 at 04:00:00pm</p></header><div class="content"><p>Needing a Set of identical reference objects, i.e. comparing with ===, has come up quite regularly in the projects I have worked on (as well as indexing by identity in a Dictionary). This might be mitigated in Swift due to a more prominent role of value types but I would still expect it to be useful.<br></p><p>-Thorsten <br></p><p>&gt; Am 19.02.2016 um 05:39 schrieb Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; On Thu, Feb 18, 2016 at 2:58 PM, Jacob Bandes-Storch via<br>&gt; swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Would it make sense for the standard library Set to provide variants (or<br>&gt;&gt; parallel versions of the same data structure) that take custom hashValue/==<br>&gt;&gt; implementations at init time (functions taking in Elements), rather than<br>&gt;&gt; relying on Hashable/Comparable protocols?<br>&gt; <br>&gt; It might make sense, but we should keep in mind that doing this will<br>&gt; prevent inlining of hashValue/== in most cases.<br>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>Custom equality/hash for Sets</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>February 19, 2016 at 09:00:00am</p></header><div class="content"><p>I constantly run into this and I’m working on a Swift-only game project where I use value types as much as possible - but even there I find myself having to implement Equatable and Hashable on classes all the time just to add an == operator that just calls through to === / ObjectIdentity to get it to the work the way I need it to. Swift does a pretty good job eliminating boilerplate, but this is one area where it seems to stick out.<br></p><p>It might be potentially awesome to be able to do something like this and have the compiler generate an == function for me using the given function:<br></p><p>class MyClass: Equatable(===) {<br>// etc..<br>}<br></p><p>But there are likely ramifications to this that I’m not really thinking about.<br></p><p>l8r<br>Sean<br></p><p><br>&gt; On Feb 19, 2016, at 9:13 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Needing a Set of identical reference objects, i.e. comparing with ===, has come up quite regularly in the projects I have worked on (as well as indexing by identity in a Dictionary). This might be mitigated in Swift due to a more prominent role of value types but I would still expect it to be useful.<br>&gt; <br>&gt; -Thorsten <br>&gt; <br>&gt;&gt; Am 19.02.2016 um 05:39 schrieb Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; On Thu, Feb 18, 2016 at 2:58 PM, Jacob Bandes-Storch via<br>&gt;&gt; swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; Would it make sense for the standard library Set to provide variants (or<br>&gt;&gt;&gt; parallel versions of the same data structure) that take custom hashValue/==<br>&gt;&gt;&gt; implementations at init time (functions taking in Elements), rather than<br>&gt;&gt;&gt; relying on Hashable/Comparable protocols?<br>&gt;&gt; <br>&gt;&gt; It might make sense, but we should keep in mind that doing this will<br>&gt;&gt; prevent inlining of hashValue/== in most cases.<br>&gt;&gt; <br>&gt;&gt; Dmitri<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Custom equality/hash for Sets</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 19, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Feb 19, 2016, at 7:45 AM, Sean Heber via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I constantly run into this and I’m working on a Swift-only game project where I use value types as much as possible - but even there I find myself having to implement Equatable and Hashable on classes all the time just to add an == operator that just calls through to === / ObjectIdentity to get it to the work the way I need it to. Swift does a pretty good job eliminating boilerplate, but this is one area where it seems to stick out.<br>&gt; <br>&gt; It might be potentially awesome to be able to do something like this and have the compiler generate an == function for me using the given function:<br>&gt; <br>&gt; class MyClass: Equatable(===) {<br>&gt; // etc..<br>&gt; }<br>&gt; <br>&gt; But there are likely ramifications to this that I’m not really thinking about.<br></p><p>You could provide a default implementation constrained on `AnyObject`:<br></p><p>func ==&lt;T: AnyObject&gt;(x: T, y: T) -&gt; Bool { return x === y }<br></p><p>Then you just need to declare `class MyClass: Equatable` to pick up that implementation for Equatable conformance.<br></p><p>-Joe<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160219/dacd4be4/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>Custom equality/hash for Sets</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>February 19, 2016 at 08:00:00am</p></header><div class="content"><p>To me it seems like a future direction of the property behavior proposal.<br>There could be a behavior like &quot;pointerEquatable&quot; which is used as a transparent wrapper:<br></p><p>        bahavior pointerEquatable&lt;Value: AnyObject&gt; : Hashable {<br>                var value: Value<br></p><p>                var hashValue: Int {<br>                        // hash value from pointer<br>                }<br>                // omitting get/set<br>        }<br></p><p>        func == &lt;T&gt;(p1: pointerEquatable&lt;T&gt;, p2: pointerEquatable&lt;T&gt;) -&gt; Bool {<br>                return p1.value === p2.value<br>        }<br></p><p>        // possible usage<br>        let set: Set&lt;pointerEquatable&lt;MyClass&gt;&gt; = [MyClass(), MyClass()]<br></p><p>This solution could then be used for any type not only Sets.<br></p><p>Best regards<br>- Maximilian<br></p><p>&gt; Am 18.02.2016 um 23:58 schrieb Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Would it make sense for the standard library Set to provide variants (or parallel versions of the same data structure) that take custom hashValue/== implementations at init time (functions taking in Elements), rather than relying on Hashable/Comparable protocols?<br>&gt; <br>&gt; Use case: I want a set of objects that are compared for equality using === rather than ==. This doesn&#39;t seem possible today, using Set, without creating some sort of wrapper object.<br>&gt; <br>&gt; This particular case would be analogous to using NSHashTable with NSPointerFunctionsObjectPointerPersonality. (Maybe all I&#39;m asking for is a Swiftier API for NSHashTable — including ArrayLiteralConvertible, using generics instead of UnsafePointer&lt;Void&gt;, etc.)<br>&gt; <br>&gt; Similarly, C++&#39;s unordered_map and friends have template parameters specifying the hash function and equality comparator, which use std::hash and == by default.<br>&gt; <br>&gt; (Apologies if this has been discussed already; I haven&#39;t seen it.)<br>&gt; Jacob<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160219/5ecf6eb3/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Custom equality/hash for Sets</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 19, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Feb 18, 2016, at 2:58 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Would it make sense for the standard library Set to provide variants (or parallel versions of the same data structure) that take custom hashValue/== implementations at init time (functions taking in Elements), rather than relying on Hashable/Comparable protocols?<br>&gt; <br>&gt; Use case: I want a set of objects that are compared for equality using === rather than ==. This doesn&#39;t seem possible today, using Set, without creating some sort of wrapper object.<br>&gt; <br>&gt; This particular case would be analogous to using NSHashTable with NSPointerFunctionsObjectPointerPersonality. (Maybe all I&#39;m asking for is a Swiftier API for NSHashTable — including ArrayLiteralConvertible, using generics instead of UnsafePointer&lt;Void&gt;, etc.)<br>&gt; <br>&gt; Similarly, C++&#39;s unordered_map &lt;http://en.cppreference.com/w/cpp/container/unordered_map&gt; and friends have template parameters specifying the hash function and equality comparator, which use std::hash and == by default.<br>&gt; <br>&gt; (Apologies if this has been discussed already; I haven&#39;t seen it.)<br>&gt; Jacob<br></p><p>At an implementation level, we already pass a bundle of function pointers for the Equatable and Hashable conformances as part of the generic calling convention. In the implementation model, protocol conformances are independent entities, so technically the same type could conform to the same protocol multiple times in different ways. We could theoretically let you provide a scoped private conformance to Hashable overriding the default one:<br></p><p>func foo() {<br>  extension Int: private Hashable {<br>    var hashValue: Int { return myHash(self) }<br>  }<br></p><p>  // This dictionary would use the local Int: Hashable<br>  let dict: Foo&lt;Int, Int&gt; = [...]<br></p><p>  use(dict)<br>}<br></p><p>Now, there would definitely be weird effects to this, since it allows for types that look the same but are formally different, since the `Key: Hashable` conformance is an implicit parameter to the type. For example, this wouldn&#39;t work:<br></p><p>func returnMyWeirdDictionary() -&gt; Dictionary&lt;Int, Int&gt; {<br>  extension Int: private Hashable {<br>    var hashValue: Int { return myHash(self) }<br>  }<br></p><p>  // This dictionary would use the local Int: Hashable<br>  let dict: Foo&lt;Int, Int&gt; = [...]<br></p><p>  // ERROR: dict has type Dictionary&lt;Int, Int&gt; (using local Int: Hashable conformance),<br>  // but return type is declared Dictionary&lt;Int, Int&gt; (using default Int: Hashable conformance)<br>  return dict<br>}<br></p><p>It also has interesting interactions with the runtime&#39;s support for protocol conformance lookup via `x as? P` casts—if there&#39;s more than one P conformance for the dynamic type of x, which one should the runtime pick?<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160219/b550ff4e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Custom equality/hash for Sets</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>February 19, 2016 at 11:00:00pm</p></header><div class="content"><p>Thanks to everyone for a great discussion so far.<br></p><p>I&#39;m interested in Joe&#39;s idea of private/local protocol conformances. What I<br>think might work nicely is the ability to provide a specific protocol<br>witness (which I think is the right terminology for the &quot;bundle of function<br>pointers&quot;) for a conformance requirement of a type parameter. This would be<br>*part of the type*, so like Joe said, &quot;set1 == set2&quot; wouldn&#39;t work unless<br>they were using the same witness. That&#39;s totally fine and would be expected<br>behavior, as long as the difference between the types is obvious to the<br>user. I think you&#39;d want to require it be specified explicitly, rather than<br>inferring it from the existence of some local extension.<br></p><p>Maximilian&#39;s point about behaviors makes sense in this context too, and I<br>think we&#39;re kind of getting at the same idea. Instead of a &quot;var behavior&quot;,<br>it&#39;s more like a &quot;protocol behavior&quot;:<br></p><p>    // All protocol requirements must be specified here; this declaration<br>basically provides an explicit protocol witness<br>    private *protocol behavior* pointerEquatable&lt;AnyObject&gt;: Hashable,<br>Equatable {<br>        var hashValue: Int { return unsafeAddressOf(self).hashValue }<br>        func ==(lhs: Self, rhs: Self) -&gt; Bool { return lhs === rhs }<br>    }<br></p><p>    // This uses the witness provided by pointerEquatable instead of the<br>default one<br>    let objs = Set&lt;@pointerEquatable MyClass&gt; = []<br>    objs.insert(something)<br></p><p>Does this defeat possible optimizations, or cause issues like Joe mentioned<br>with &quot;as?&quot; lookups?<br></p><p>On Fri, Feb 19, 2016 at 11:11 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Feb 18, 2016, at 2:58 PM, Jacob Bandes-Storch via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Would it make sense for the standard library Set to provide variants (or<br>&gt; parallel versions of the same data structure) that take custom hashValue/==<br>&gt; implementations at init time (functions taking in Elements), rather than<br>&gt; relying on Hashable/Comparable protocols?<br>&gt;<br>&gt; Use case: I want a set of objects that are compared for equality using ===<br>&gt; rather than ==. This doesn&#39;t seem possible today, using Set, without<br>&gt; creating some sort of wrapper object.<br>&gt;<br>&gt; This particular case would be analogous to using NSHashTable with<br>&gt; NSPointerFunctionsObjectPointerPersonality. (Maybe all I&#39;m asking for is a<br>&gt; Swiftier API for NSHashTable — including ArrayLiteralConvertible, using<br>&gt; generics instead of UnsafePointer&lt;Void&gt;, etc.)<br>&gt;<br>&gt; Similarly, C++&#39;s unordered_map<br>&gt; &lt;http://en.cppreference.com/w/cpp/container/unordered_map&gt; and friends<br>&gt; have template parameters specifying the hash function and equality<br>&gt; comparator, which use std::hash and == by default.<br>&gt;<br>&gt; (Apologies if this has been discussed already; I haven&#39;t seen it.)<br>&gt; Jacob<br>&gt;<br>&gt;<br>&gt; At an implementation level, we already pass a bundle of function pointers<br>&gt; for the Equatable and Hashable conformances as part of the generic calling<br>&gt; convention. In the implementation model, protocol conformances are<br>&gt; independent entities, so technically the same type could conform to the<br>&gt; same protocol multiple times in different ways. We could theoretically let<br>&gt; you provide a scoped private conformance to Hashable overriding the default<br>&gt; one:<br>&gt;<br>&gt; func foo() {<br>&gt;   extension Int: private Hashable {<br>&gt;     var hashValue: Int { return myHash(self) }<br>&gt;   }<br>&gt;<br>&gt;   // This dictionary would use the local Int: Hashable<br>&gt;   let dict: Foo&lt;Int, Int&gt; = [...]<br>&gt;<br>&gt;   use(dict)<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Now, there would definitely be weird effects to this, since it allows for<br>&gt; types that look the same but are formally different, since the `Key:<br>&gt; Hashable` conformance is an implicit parameter to the type. For example,<br>&gt; this wouldn&#39;t work:<br>&gt;<br>&gt; func returnMyWeirdDictionary() -&gt; Dictionary&lt;Int, Int&gt; {<br>&gt;   extension Int: private Hashable {<br>&gt;     var hashValue: Int { return myHash(self) }<br>&gt;   }<br>&gt;<br>&gt;   // This dictionary would use the local Int: Hashable<br>&gt;   let dict: Foo&lt;Int, Int&gt; = [...]<br>&gt;<br>&gt;   // ERROR: dict has type Dictionary&lt;Int, Int&gt; (using local Int: Hashable<br>&gt; conformance),<br>&gt;   // but return type is declared Dictionary&lt;Int, Int&gt; (using default Int:<br>&gt; Hashable conformance)<br>&gt;   return dict<br>&gt; }<br>&gt;<br>&gt;<br>&gt; It also has interesting interactions with the runtime&#39;s support for<br>&gt; protocol conformance lookup via `x as? P` casts—if there&#39;s more than one P<br>&gt; conformance for the dynamic type of x, which one should the runtime pick?<br>&gt;<br>&gt; -Joe<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160219/5b1d3fa1/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>Custom equality/hash for Sets</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>February 19, 2016 at 01:00:00pm</p></header><div class="content"><p>I think the points already-made about the weak semantics of such a type are well-founded and should curtail the idea of changing `Set` itself to take in optional “customized” functions for equality/hash.<br></p><p>However, this scenario, I think, makes an *excellent* testbed for Swift 3’s hopefully-still-incoming &quot;conditional conformance” functionality (e.g. the thing that would let you say `Array:Equatable where Element:Equatable`).<br></p><p>Within Swift as it is right now, if you really want a “customizable set” as-requested, about the best you can do at this time is like so:<br></p><p>// step 1: a convenience protocol<br>protocol SetValueWrapper : Equatable, Hashable {<br>  typealias Value // note: it’s useful to require `:Equatable`, but not necessary<br>  var value: Value { get }<br>  init(_ value: Value)<br>}<br></p><p>// step 2: a convenience wrapper around `Set`<br>// <br>// re-implement as much of the `Set` APIs as you need,<br>// but in a way that lets you ignore internal use of `W`<br>// <br>// Note that in practice you may need to write this as<br>// struct WrappedValueSet&lt;V,W:SetValueWrapper where V==W.Value&gt;,<br>// as I’ve run into bugs where the compiler needs that `V` to figure things out.<br>// I’ve written it as it should be, not how it may need to be to use today.<br>struct WrappedValueSet&lt;W:SetValueWrapper&gt; {<br>   private var storage: Set&lt;W&gt;  <br></p><p>  // example re-implementations:<br>  //<br>  func contains(element: W.Element) -&gt; Bool { return self.storage.contains(W(element))<br></p><p>  mutating func insert(element: W.Element) { self.storage.insert(W(element))<br></p><p>}<br></p><p>// step 3: per each customized equality/hash you need, write a wrapper;<br>// e.g., here is a complete “ObjectPointer” wrapper as per the original request:<br>struct ObjectPointer&lt;T:AnyObject&gt; : SetValueWrapper {<br></p><p>  typealias Value: T<br></p><p>  let value: T<br>  <br>  init(_ value: T) { self.value = value }<br></p><p>  var hashValue: Int { return ObjectIdentifier(value).hashValue<br></p><p>}<br></p><p>func ==&lt;T&gt;(lhs: ObjectPointer&lt;T&gt;, rhs: ObjectPointer&lt;T&gt;) -&gt; Bool {<br>  return lhs.value === rhs.value<br>}<br></p><p>…and you’re done; the cost is basically one tedious session of re-implementing the Set-related APIs you want on your wrapper, and then one (short!) wrapper for each custom equality/hash combo you need.<br></p><p>This isn’t *great*, but it seems perfectly-reasonable to me when weighed against the drawbacks of a `Set`-like thing that took custom logic in its `init`.<br></p><p>With conditional-conformances in place, you can also improve your quality of life a lot; it’s a bit tricky, but you could — if conditional conformances work as I expect they will — use some trickery to “punch out” `Equatable` and `Hashable`, like so:<br></p><p>/// Basic protocol for “this is a wrapper”.<br>protocol ValueWrapper {<br>  typealias Value<br>  var value: Value { get }<br>  init(_ value: Value)<br>}<br></p><p>/// Specialized-wrapper-of-wrapper that is meant to source:<br>/// - Equatable, Hashable from the wrapped-value<br>/// - everything else (as needed) from the wrapped-value’s wrapped-value<br>///<br>/// …which means we can keep adding utility conformances here based on `W.Value`’s implementations,<br>/// while still having “punched-out” W’s native possible `==` and `hashValue` implementations in favor of<br>/// whatever implementations thereof are supplied by W.<br>struct WrapperWrapper&lt;W:protocol&lt;WrappedValue,Equatable,Hashable&gt; where W.Value:WrappedValue&gt; : WrappedValue {<br></p><p>  typealias Value = W.Value // note it somewhat hides the existence of the inner wrapper <br>  <br>  private let storage: W<br>  var value: Value { return self.storage.value }<br></p><p>  init(_ value: Value) { self.storage = W(value) }<br>  <br>  // note it uses the wrapper’s (customized) hashValue implementation<br>  var hashValue: Int {<br>   return self.storage.hashValue <br>  }<br></p><p>}<br></p><p>// note again this uses the *wrapper*’s implementation:<br>func ==&lt;W&gt;(lhs: WrapperWrapper&lt;W&gt;, rhs: WrapperWrapper&lt;W&gt;) -&gt; Bool {<br>  return lhs.storage == rhs.storage // use wrapper’s (customized) equality<br>}<br></p><p>// but now we can start adding nice-to-have conformances based on `W.Value`<br>extension WrapperWrapper:CustomStringConvertible where W.Value:CustomStringConvertible {<br>  <br>  var description: String { return self.value.description }<br></p><p>}<br></p><p>// and so on and so forth, as-needed...<br></p><p>Although this still doesn&#39;t free you up from writing the “custom ==/hash wrappers”, if you rewrite the set-wrapper from step 2 in terms of a `WrapperWrapper` (hopefully with a better name!), then the values that are stored in the Set will pick up protocol conformances of interest from the underlying value, and thus trigger any conditional-conformances that are defined e.g. on `Set`, making it easy for you to add them to your own wrapper if you want, and so on.<br></p><p>Is this *great*? Arguably not, but I think it’s a reasonable situation, especially since the tedious parts (set-wrapper, wrapper-wrapper) are each write-once, re-use often, and the per-customization chores are really short (~5-10 lines, mostly boilerplate).<br></p><p>And again, you don’t *need* the set-wrapper or wrapper-wrapper, they just streamline the sites-of-use of such constructs.<br></p><p>Some form of actual “struct inheritance” might reduce the need to manually emulate it with protocols like the above, but protocols + conditional-conformance let you emulate enough of that feature to work out “OK” in this case, I think. <br></p><p>&gt; On Feb 18, 2016, at 4:58 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Would it make sense for the standard library Set to provide variants (or parallel versions of the same data structure) that take custom hashValue/== implementations at init time (functions taking in Elements), rather than relying on Hashable/Comparable protocols?<br>&gt; <br>&gt; Use case: I want a set of objects that are compared for equality using === rather than ==. This doesn&#39;t seem possible today, using Set, without creating some sort of wrapper object.<br>&gt; <br>&gt; This particular case would be analogous to using NSHashTable with NSPointerFunctionsObjectPointerPersonality. (Maybe all I&#39;m asking for is a Swiftier API for NSHashTable — including ArrayLiteralConvertible, using generics instead of UnsafePointer&lt;Void&gt;, etc.)<br>&gt; <br>&gt; Similarly, C++&#39;s unordered_map &lt;http://en.cppreference.com/w/cpp/container/unordered_map&gt; and friends have template parameters specifying the hash function and equality comparator, which use std::hash and == by default.<br>&gt; <br>&gt; (Apologies if this has been discussed already; I haven&#39;t seen it.)<br>&gt; Jacob<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160219/df31b018/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
