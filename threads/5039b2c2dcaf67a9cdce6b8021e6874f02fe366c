<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552d80567b8f0241a53cee772470ddd0?s=50"></div><header><strong>Arrays Returning Optionals instead of Index Out of Bounds</strong> from <string>Rob Norback</string> &lt;rnorback at gmail.com&gt;<p>June  6, 2016 at 04:00:00pm</p></header><div class="content"><p>Hi Everyone!<br></p><p>This is my first time emailing the swift evolution list, so if this topic<br>has already been discussed please let me know.  I looked through all the<br>accepted and rejected proposals and it doesn&#39;t seem to be on there.<br></p><p>The main thought is that dictionaries return optionals, so why not arrays?<br>Or other CollectionTypes for that matter.  I would think this would be the<br>expected behavior in this situation:<br></p><p>var myArray:[String?] = []<br>print(myArray[4])<br>// EXC_BAD_INSTRUCTION, but could just be Optional(nil)<br></p><p>Then you could do things like<br></p><p>if let arrayValue = myArray[4] {<br>   // do something<br>}<br></p><p>Of course you could simply check with with the count, but considering<br>Swift&#39;s use of optionals to represent empty variables rather than erroring<br>out or returning an empty String, I think this functionality would be<br>appropriate to include in the Swift standard library.<br></p><p>And there&#39;s about 15,000 people who&#39;ve looked for this functionality in the<br>last year:<br>http://stackoverflow.com/questions/25329186/safe-bounds-checked-array-lookup-in-swift-through-optional-bindings<br>.<br></p><p>Please let me know what you think.<br></p><p>Best,<br>Rob Norback<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160606/5039366c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Arrays Returning Optionals instead of Index Out of Bounds</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>June  6, 2016 at 08:00:00pm</p></header><div class="content"><p>Please find this draft of proposal(hope this is correct link for latest <br>version):<br>https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md<br></p><p>The main idea is to introduce 2 new subscript methods:  [clamping:] and <br>[checking:]<br></p><p>There was discussion in &quot;[Proposal] More lenient subscript methods over <br>Collections&quot; and (older) &quot;[Proposal] Safer half-open range operator&quot;<br></p><p>On 06.06.2016 19:50, Rob Norback via swift-evolution wrote:<br>&gt; Hi Everyone!<br>&gt;<br>&gt; This is my first time emailing the swift evolution list, so if this topic<br>&gt; has already been discussed please let me know.  I looked through all the<br>&gt; accepted and rejected proposals and it doesn&#39;t seem to be on there.<br>&gt;<br>&gt; The main thought is that dictionaries return optionals, so why not arrays?<br>&gt; Or other CollectionTypes for that matter.  I would think this would be the<br>&gt; expected behavior in this situation:<br>&gt;<br>&gt; var myArray:[String?] = []<br>&gt; print(myArray[4])<br>&gt; // EXC_BAD_INSTRUCTION, but could just be Optional(nil)<br>&gt;<br>&gt; Then you could do things like<br>&gt;<br>&gt; if let arrayValue = myArray[4] {<br>&gt;    // do something<br>&gt; }<br>&gt;<br>&gt; Of course you could simply check with with the count, but considering<br>&gt; Swift&#39;s use of optionals to represent empty variables rather than erroring<br>&gt; out or returning an empty String, I think this functionality would be<br>&gt; appropriate to include in the Swift standard library.<br>&gt;<br>&gt; And there&#39;s about 15,000 people who&#39;ve looked for this functionality in the<br>&gt; last year:<br>&gt; http://stackoverflow.com/questions/25329186/safe-bounds-checked-array-lookup-in-swift-through-optional-bindings.<br>&gt;<br>&gt; Please let me know what you think.<br>&gt;<br>&gt; Best,<br>&gt; Rob Norback<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4a9841be165fb834d08296761b4a32e3?s=50"></div><header><strong>Arrays Returning Optionals instead of Index Out of Bounds</strong> from <string>Christopher Kornher</string> &lt;ckornher at me.com&gt;<p>June  6, 2016 at 11:00:00am</p></header><div class="content"><p>The proposal needs to discuss arrays of optionals  e.g.:  ```Array&lt;Int?&gt;```<br>These are not just legal, they are quite handy as well.<br></p><p>Dictionaries can also be declared with optional values, of course: ```Dictionary&lt;Int,Int?&gt;```<br>These can be pretty confusing to deal with and we should not add to confusion with arrays.<br></p><p>An example of the confusion:<br></p><p>var d = Dictionary&lt;Int,Int?&gt;<br>...<br>d[0] = nil		// Does this delete the element or set it to nil? Honestly, I forget. The point is, the syntax is ambiguous.<br></p><p>It would be nice to create a completely unambiguous syntax for collections with optional values.<br></p><p>- Chris K<br></p><p><br>&gt; On Jun 6, 2016, at 11:10 AM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Please find this draft of proposal(hope this is correct link for latest version):<br>&gt; https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md<br>&gt; <br>&gt; The main idea is to introduce 2 new subscript methods:  [clamping:] and [checking:]<br>&gt; <br>&gt; There was discussion in &quot;[Proposal] More lenient subscript methods over Collections&quot; and (older) &quot;[Proposal] Safer half-open range operator&quot;<br>&gt; <br>&gt; On 06.06.2016 19:50, Rob Norback via swift-evolution wrote:<br>&gt;&gt; Hi Everyone!<br>&gt;&gt; <br>&gt;&gt; This is my first time emailing the swift evolution list, so if this topic<br>&gt;&gt; has already been discussed please let me know.  I looked through all the<br>&gt;&gt; accepted and rejected proposals and it doesn&#39;t seem to be on there.<br>&gt;&gt; <br>&gt;&gt; The main thought is that dictionaries return optionals, so why not arrays?<br>&gt;&gt; Or other CollectionTypes for that matter.  I would think this would be the<br>&gt;&gt; expected behavior in this situation:<br>&gt;&gt; <br>&gt;&gt; var myArray:[String?] = []<br>&gt;&gt; print(myArray[4])<br>&gt;&gt; // EXC_BAD_INSTRUCTION, but could just be Optional(nil)<br>&gt;&gt; <br>&gt;&gt; Then you could do things like<br>&gt;&gt; <br>&gt;&gt; if let arrayValue = myArray[4] {<br>&gt;&gt;   // do something<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Of course you could simply check with with the count, but considering<br>&gt;&gt; Swift&#39;s use of optionals to represent empty variables rather than erroring<br>&gt;&gt; out or returning an empty String, I think this functionality would be<br>&gt;&gt; appropriate to include in the Swift standard library.<br>&gt;&gt; <br>&gt;&gt; And there&#39;s about 15,000 people who&#39;ve looked for this functionality in the<br>&gt;&gt; last year:<br>&gt;&gt; http://stackoverflow.com/questions/25329186/safe-bounds-checked-array-lookup-in-swift-through-optional-bindings.<br>&gt;&gt; <br>&gt;&gt; Please let me know what you think.<br>&gt;&gt; <br>&gt;&gt; Best,<br>&gt;&gt; Rob Norback<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1c20add0141a66d37f9bcb554d40084b?s=50"></div><header><strong>Arrays Returning Optionals instead of Index Out of Bounds</strong> from <string>Luis Henrique B. Sousa</string> &lt;lshsousa at gmail.com&gt;<p>June  6, 2016 at 06:00:00pm</p></header><div class="content"><p>Thanks Vladimir,<br></p><p>The correct link is this one (with the additional min/max operations in the<br>implementation):<br>https://github.com/luish/swift-evolution/blob/proposal-lenient-collection-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md<br></p><p>Here is the pull request on the swift-evolution repo:<br>https://github.com/apple/swift-evolution/pull/328<br></p><p>Any help or suggestion to improve the proposal is welcome. :-)<br></p><p>- Luis<br></p><p>On Mon, Jun 6, 2016 at 6:10 PM, Vladimir.S via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Please find this draft of proposal(hope this is correct link for latest<br>&gt; version):<br>&gt;<br>&gt; https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md<br>&gt;<br>&gt; The main idea is to introduce 2 new subscript methods:  [clamping:] and<br>&gt; [checking:]<br>&gt;<br>&gt; There was discussion in &quot;[Proposal] More lenient subscript methods over<br>&gt; Collections&quot; and (older) &quot;[Proposal] Safer half-open range operator&quot;<br>&gt;<br>&gt;<br>&gt; On 06.06.2016 19:50, Rob Norback via swift-evolution wrote:<br>&gt;<br>&gt;&gt; Hi Everyone!<br>&gt;&gt;<br>&gt;&gt; This is my first time emailing the swift evolution list, so if this topic<br>&gt;&gt; has already been discussed please let me know.  I looked through all the<br>&gt;&gt; accepted and rejected proposals and it doesn&#39;t seem to be on there.<br>&gt;&gt;<br>&gt;&gt; The main thought is that dictionaries return optionals, so why not arrays?<br>&gt;&gt; Or other CollectionTypes for that matter.  I would think this would be the<br>&gt;&gt; expected behavior in this situation:<br>&gt;&gt;<br>&gt;&gt; var myArray:[String?] = []<br>&gt;&gt; print(myArray[4])<br>&gt;&gt; // EXC_BAD_INSTRUCTION, but could just be Optional(nil)<br>&gt;&gt;<br>&gt;&gt; Then you could do things like<br>&gt;&gt;<br>&gt;&gt; if let arrayValue = myArray[4] {<br>&gt;&gt;    // do something<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Of course you could simply check with with the count, but considering<br>&gt;&gt; Swift&#39;s use of optionals to represent empty variables rather than erroring<br>&gt;&gt; out or returning an empty String, I think this functionality would be<br>&gt;&gt; appropriate to include in the Swift standard library.<br>&gt;&gt;<br>&gt;&gt; And there&#39;s about 15,000 people who&#39;ve looked for this functionality in<br>&gt;&gt; the<br>&gt;&gt; last year:<br>&gt;&gt;<br>&gt;&gt; http://stackoverflow.com/questions/25329186/safe-bounds-checked-array-lookup-in-swift-through-optional-bindings<br>&gt;&gt; .<br>&gt;&gt;<br>&gt;&gt; Please let me know what you think.<br>&gt;&gt;<br>&gt;&gt; Best,<br>&gt;&gt; Rob Norback<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160606/dc30a0e8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552d80567b8f0241a53cee772470ddd0?s=50"></div><header><strong>Arrays Returning Optionals instead of Index Out of Bounds</strong> from <string>Rob Norback</string> &lt;rnorback at gmail.com&gt;<p>June  6, 2016 at 06:00:00pm</p></header><div class="content"><p>First of all, thank you all for bringing me up to date so quickly.  I<br>looked over the proposal and it looks awesome.<br></p><p>But as Chris mentioned, this doesn&#39;t solve the expected behavior and<br>ambiguity of ```Array&lt;Int?&gt;```<br></p><p>In this case I would expect the default behavior (myArray[4]) without using<br>myArray[checking: 4] should return a nil in this case.<br></p><p>And Chris, I think it would make the most sense to have myArray[0] = nil to<br>be stored if the index is in Range, and for myArray[100] = nil to give a<br>warning of no assignment being made because index is out of range, kind of<br>like an unused variable.  Right now myArray[100] = nil gives you<br>EXC_BAD_INSTRUCTION.  Then if you assigned myArray[100] = 200, that would<br>have to simply change the Range.<br></p><p>Chris, I honestly have to think more about that ambiguity with dictionaries.<br></p><p>I can see that this would definitely need some further fleshing out, but it<br>seems to be sufficiently different from Luis&#39; proposal to perhaps merit<br>it&#39;s own proposal.<br></p><p>It&#39;s up to you Luis, but I think this might be a bit more controversial<br>then the changes you&#39;ve proposed, making it possible for your proposal<br>getting rejected.  (I want your proposal accepted, since I would use those<br>features today).  Partial acceptance of a proposal doesn&#39;t seem to be a<br>thing. (Once again please correct me if I&#39;m wrong).<br></p><p>On Mon, Jun 6, 2016 at 11:46 AM Luis Henrique B. Sousa &lt;lshsousa at gmail.com&gt;<br>wrote:<br></p><p>&gt; Thanks Vladimir,<br>&gt;<br>&gt; The correct link is this one (with the additional min/max operations in<br>&gt; the implementation):<br>&gt;<br>&gt; https://github.com/luish/swift-evolution/blob/proposal-lenient-collection-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md<br>&gt;<br>&gt; Here is the pull request on the swift-evolution repo:<br>&gt; https://github.com/apple/swift-evolution/pull/328<br>&gt;<br>&gt; Any help or suggestion to improve the proposal is welcome. :-)<br>&gt;<br>&gt; - Luis<br>&gt;<br>&gt; On Mon, Jun 6, 2016 at 6:10 PM, Vladimir.S via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Please find this draft of proposal(hope this is correct link for latest<br>&gt;&gt; version):<br>&gt;&gt;<br>&gt;&gt; https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md<br>&gt;&gt;<br>&gt;&gt; The main idea is to introduce 2 new subscript methods:  [clamping:] and<br>&gt;&gt; [checking:]<br>&gt;&gt;<br>&gt;&gt; There was discussion in &quot;[Proposal] More lenient subscript methods over<br>&gt;&gt; Collections&quot; and (older) &quot;[Proposal] Safer half-open range operator&quot;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On 06.06.2016 19:50, Rob Norback via swift-evolution wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Hi Everyone!<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This is my first time emailing the swift evolution list, so if this topic<br>&gt;&gt;&gt; has already been discussed please let me know.  I looked through all the<br>&gt;&gt;&gt; accepted and rejected proposals and it doesn&#39;t seem to be on there.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The main thought is that dictionaries return optionals, so why not<br>&gt;&gt;&gt; arrays?<br>&gt;&gt;&gt; Or other CollectionTypes for that matter.  I would think this would be<br>&gt;&gt;&gt; the<br>&gt;&gt;&gt; expected behavior in this situation:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; var myArray:[String?] = []<br>&gt;&gt;&gt; print(myArray[4])<br>&gt;&gt;&gt; // EXC_BAD_INSTRUCTION, but could just be Optional(nil)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Then you could do things like<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; if let arrayValue = myArray[4] {<br>&gt;&gt;&gt;    // do something<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Of course you could simply check with with the count, but considering<br>&gt;&gt;&gt; Swift&#39;s use of optionals to represent empty variables rather than<br>&gt;&gt;&gt; erroring<br>&gt;&gt;&gt; out or returning an empty String, I think this functionality would be<br>&gt;&gt;&gt; appropriate to include in the Swift standard library.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; And there&#39;s about 15,000 people who&#39;ve looked for this functionality in<br>&gt;&gt;&gt; the<br>&gt;&gt;&gt; last year:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; http://stackoverflow.com/questions/25329186/safe-bounds-checked-array-lookup-in-swift-through-optional-bindings<br>&gt;&gt;&gt; .<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Please let me know what you think.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Best,<br>&gt;&gt;&gt; Rob Norback<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160606/71154405/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552d80567b8f0241a53cee772470ddd0?s=50"></div><header><strong>Arrays Returning Optionals instead of Index Out of Bounds</strong> from <string>Rob Norback</string> &lt;rnorback at gmail.com&gt;<p>June  6, 2016 at 06:00:00pm</p></header><div class="content"><p>Apologies, please remove the line &quot;Right now myArray[100] = nil gives you<br>EXC_BAD_INSTRUCTION.&quot; from my previous email so it makes more sense to read.<br></p><p>On Mon, Jun 6, 2016 at 12:02 PM Rob Norback &lt;rnorback at gmail.com&gt; wrote:<br></p><p>&gt; First of all, thank you all for bringing me up to date so quickly.  I<br>&gt; looked over the proposal and it looks awesome.<br>&gt;<br>&gt; But as Chris mentioned, this doesn&#39;t solve the expected behavior and<br>&gt; ambiguity of ```Array&lt;Int?&gt;```<br>&gt;<br>&gt; In this case I would expect the default behavior (myArray[4]) without<br>&gt; using myArray[checking: 4] should return a nil in this case.<br>&gt;<br>&gt; And Chris, I think it would make the most sense to have myArray[0] = nil<br>&gt; to be stored if the index is in Range, and for myArray[100] = nil to give a<br>&gt; warning of no assignment being made because index is out of range, kind of<br>&gt; like an unused variable.  Right now myArray[100] = nil gives you<br>&gt; EXC_BAD_INSTRUCTION.  Then if you assigned myArray[100] = 200, that would<br>&gt; have to simply change the Range.<br>&gt;<br>&gt; Chris, I honestly have to think more about that ambiguity with<br>&gt; dictionaries.<br>&gt;<br>&gt; I can see that this would definitely need some further fleshing out, but<br>&gt; it seems to be sufficiently different from Luis&#39; proposal to perhaps merit<br>&gt; it&#39;s own proposal.<br>&gt;<br>&gt; It&#39;s up to you Luis, but I think this might be a bit more controversial<br>&gt; then the changes you&#39;ve proposed, making it possible for your proposal<br>&gt; getting rejected.  (I want your proposal accepted, since I would use those<br>&gt; features today).  Partial acceptance of a proposal doesn&#39;t seem to be a<br>&gt; thing. (Once again please correct me if I&#39;m wrong).<br>&gt;<br>&gt; On Mon, Jun 6, 2016 at 11:46 AM Luis Henrique B. Sousa &lt;lshsousa at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; Thanks Vladimir,<br>&gt;&gt;<br>&gt;&gt; The correct link is this one (with the additional min/max operations in<br>&gt;&gt; the implementation):<br>&gt;&gt;<br>&gt;&gt; https://github.com/luish/swift-evolution/blob/proposal-lenient-collection-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md<br>&gt;&gt;<br>&gt;&gt; Here is the pull request on the swift-evolution repo:<br>&gt;&gt; https://github.com/apple/swift-evolution/pull/328<br>&gt;&gt;<br>&gt;&gt; Any help or suggestion to improve the proposal is welcome. :-)<br>&gt;&gt;<br>&gt;&gt; - Luis<br>&gt;&gt;<br>&gt;&gt; On Mon, Jun 6, 2016 at 6:10 PM, Vladimir.S via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Please find this draft of proposal(hope this is correct link for latest<br>&gt;&gt;&gt; version):<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The main idea is to introduce 2 new subscript methods:  [clamping:] and<br>&gt;&gt;&gt; [checking:]<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; There was discussion in &quot;[Proposal] More lenient subscript methods over<br>&gt;&gt;&gt; Collections&quot; and (older) &quot;[Proposal] Safer half-open range operator&quot;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 06.06.2016 19:50, Rob Norback via swift-evolution wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Hi Everyone!<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This is my first time emailing the swift evolution list, so if this<br>&gt;&gt;&gt;&gt; topic<br>&gt;&gt;&gt;&gt; has already been discussed please let me know.  I looked through all the<br>&gt;&gt;&gt;&gt; accepted and rejected proposals and it doesn&#39;t seem to be on there.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The main thought is that dictionaries return optionals, so why not<br>&gt;&gt;&gt;&gt; arrays?<br>&gt;&gt;&gt;&gt; Or other CollectionTypes for that matter.  I would think this would be<br>&gt;&gt;&gt;&gt; the<br>&gt;&gt;&gt;&gt; expected behavior in this situation:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; var myArray:[String?] = []<br>&gt;&gt;&gt;&gt; print(myArray[4])<br>&gt;&gt;&gt;&gt; // EXC_BAD_INSTRUCTION, but could just be Optional(nil)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Then you could do things like<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; if let arrayValue = myArray[4] {<br>&gt;&gt;&gt;&gt;    // do something<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Of course you could simply check with with the count, but considering<br>&gt;&gt;&gt;&gt; Swift&#39;s use of optionals to represent empty variables rather than<br>&gt;&gt;&gt;&gt; erroring<br>&gt;&gt;&gt;&gt; out or returning an empty String, I think this functionality would be<br>&gt;&gt;&gt;&gt; appropriate to include in the Swift standard library.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; And there&#39;s about 15,000 people who&#39;ve looked for this functionality in<br>&gt;&gt;&gt;&gt; the<br>&gt;&gt;&gt;&gt; last year:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; http://stackoverflow.com/questions/25329186/safe-bounds-checked-array-lookup-in-swift-through-optional-bindings<br>&gt;&gt;&gt;&gt; .<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Please let me know what you think.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Best,<br>&gt;&gt;&gt;&gt; Rob Norback<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160606/6875f967/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1c20add0141a66d37f9bcb554d40084b?s=50"></div><header><strong>Arrays Returning Optionals instead of Index Out of Bounds</strong> from <string>Luis Henrique B. Sousa</string> &lt;lshsousa at gmail.com&gt;<p>June  6, 2016 at 07:00:00pm</p></header><div class="content"><p>Yes, Rob, even though our proposals are very related, I do think that yours<br>would fit better in a new proposal.<br></p><p>My first draft was also in regards to change the default behaviour - not<br>focused on optionals though. It went through a discussion about *masking*<br>the current fail fast behaviour (e.g. debugging would be more difficult,<br>could lead to some unexpected bugs, etc) so that we have changed it to<br>propose those additional subscript methods instead.<br></p><p>On the other hand, your proposal seems to be more consistent with the<br>existing *problem* and I think it should follow the path I had tried<br>initially, and hopefully it will get accepted. Considering my python/ruby<br>background, I really think we need more handy and lenient operations over<br>collections.<br></p><p>Let&#39;s keep the discussion going, but so far I am +1 for that initial idea.<br></p><p>- Luis<br></p><p><br>On Mon, Jun 6, 2016 at 7:02 PM, Rob Norback &lt;rnorback at gmail.com&gt; wrote:<br></p><p>&gt; First of all, thank you all for bringing me up to date so quickly.  I<br>&gt; looked over the proposal and it looks awesome.<br>&gt;<br>&gt; But as Chris mentioned, this doesn&#39;t solve the expected behavior and<br>&gt; ambiguity of ```Array&lt;Int?&gt;```<br>&gt;<br>&gt; In this case I would expect the default behavior (myArray[4]) without<br>&gt; using myArray[checking: 4] should return a nil in this case.<br>&gt;<br>&gt; And Chris, I think it would make the most sense to have myArray[0] = nil<br>&gt; to be stored if the index is in Range, and for myArray[100] = nil to give a<br>&gt; warning of no assignment being made because index is out of range, kind of<br>&gt; like an unused variable.  Right now myArray[100] = nil gives you<br>&gt; EXC_BAD_INSTRUCTION.  Then if you assigned myArray[100] = 200, that would<br>&gt; have to simply change the Range.<br>&gt;<br>&gt; Chris, I honestly have to think more about that ambiguity with<br>&gt; dictionaries.<br>&gt;<br>&gt; I can see that this would definitely need some further fleshing out, but<br>&gt; it seems to be sufficiently different from Luis&#39; proposal to perhaps merit<br>&gt; it&#39;s own proposal.<br>&gt;<br>&gt; It&#39;s up to you Luis, but I think this might be a bit more controversial<br>&gt; then the changes you&#39;ve proposed, making it possible for your proposal<br>&gt; getting rejected.  (I want your proposal accepted, since I would use those<br>&gt; features today).  Partial acceptance of a proposal doesn&#39;t seem to be a<br>&gt; thing. (Once again please correct me if I&#39;m wrong).<br>&gt;<br>&gt; On Mon, Jun 6, 2016 at 11:46 AM Luis Henrique B. Sousa &lt;lshsousa at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; Thanks Vladimir,<br>&gt;&gt;<br>&gt;&gt; The correct link is this one (with the additional min/max operations in<br>&gt;&gt; the implementation):<br>&gt;&gt;<br>&gt;&gt; https://github.com/luish/swift-evolution/blob/proposal-lenient-collection-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md<br>&gt;&gt;<br>&gt;&gt; Here is the pull request on the swift-evolution repo:<br>&gt;&gt; https://github.com/apple/swift-evolution/pull/328<br>&gt;&gt;<br>&gt;&gt; Any help or suggestion to improve the proposal is welcome. :-)<br>&gt;&gt;<br>&gt;&gt; - Luis<br>&gt;&gt;<br>&gt;&gt; On Mon, Jun 6, 2016 at 6:10 PM, Vladimir.S via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Please find this draft of proposal(hope this is correct link for latest<br>&gt;&gt;&gt; version):<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The main idea is to introduce 2 new subscript methods:  [clamping:] and<br>&gt;&gt;&gt; [checking:]<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; There was discussion in &quot;[Proposal] More lenient subscript methods over<br>&gt;&gt;&gt; Collections&quot; and (older) &quot;[Proposal] Safer half-open range operator&quot;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 06.06.2016 19:50, Rob Norback via swift-evolution wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Hi Everyone!<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This is my first time emailing the swift evolution list, so if this<br>&gt;&gt;&gt;&gt; topic<br>&gt;&gt;&gt;&gt; has already been discussed please let me know.  I looked through all the<br>&gt;&gt;&gt;&gt; accepted and rejected proposals and it doesn&#39;t seem to be on there.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The main thought is that dictionaries return optionals, so why not<br>&gt;&gt;&gt;&gt; arrays?<br>&gt;&gt;&gt;&gt; Or other CollectionTypes for that matter.  I would think this would be<br>&gt;&gt;&gt;&gt; the<br>&gt;&gt;&gt;&gt; expected behavior in this situation:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; var myArray:[String?] = []<br>&gt;&gt;&gt;&gt; print(myArray[4])<br>&gt;&gt;&gt;&gt; // EXC_BAD_INSTRUCTION, but could just be Optional(nil)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Then you could do things like<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; if let arrayValue = myArray[4] {<br>&gt;&gt;&gt;&gt;    // do something<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Of course you could simply check with with the count, but considering<br>&gt;&gt;&gt;&gt; Swift&#39;s use of optionals to represent empty variables rather than<br>&gt;&gt;&gt;&gt; erroring<br>&gt;&gt;&gt;&gt; out or returning an empty String, I think this functionality would be<br>&gt;&gt;&gt;&gt; appropriate to include in the Swift standard library.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; And there&#39;s about 15,000 people who&#39;ve looked for this functionality in<br>&gt;&gt;&gt;&gt; the<br>&gt;&gt;&gt;&gt; last year:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; http://stackoverflow.com/questions/25329186/safe-bounds-checked-array-lookup-in-swift-through-optional-bindings<br>&gt;&gt;&gt;&gt; .<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Please let me know what you think.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Best,<br>&gt;&gt;&gt;&gt; Rob Norback<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160606/faab646c/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4a9841be165fb834d08296761b4a32e3?s=50"></div><header><strong>Arrays Returning Optionals instead of Index Out of Bounds</strong> from <string>Christopher Kornher</string> &lt;ckornher at me.com&gt;<p>June  6, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jun 6, 2016, at 12:02 PM, Rob Norback via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; First of all, thank you all for bringing me up to date so quickly.  I looked over the proposal and it looks awesome.<br>&gt; <br>&gt; But as Chris mentioned, this doesn&#39;t solve the expected behavior and ambiguity of ```Array&lt;Int?&gt;```<br></p><p>I think that name is reserved word on this list :) Just to be clear, I am another Chris (Chris K).<br>I forgot to mention that I like the proposal.<br></p><p>&gt; In this case I would expect the default behavior (myArray[4]) without using myArray[checking: 4] should return a nil in this case.<br>&gt; <br>&gt; And Chris, I think it would make the most sense to have myArray[0] = nil to be stored if the index is in Range, and for myArray[100] = nil to give a warning of no assignment being made because index is out of range, kind of like an unused variable.  Right now myArray[100] = nil gives you EXC_BAD_INSTRUCTION.  Then if you assigned myArray[100] = 200, that would have to simply change the Range.<br></p><p>Yes, Arrays should store the value and I do not believe that the syntax for allays would be ambiguous. I do believe that since this is in the same general territory, the syntax for dictionaries should be improved at the same time, to simplify the story for usersâ€¦ perhaps with another keyword(?)<br></p><p>``` <br>var d = Dictionary&lt;Int,Int?&gt;<br>...<br>d[setting:0] = nil		// I did not give much thought to the name of the keyword.<br>```<br>A solution that uses the same new syntax should probably be in the same proposal. A separate proposal might be more appropriate for a different solution.  <br></p><p>&gt; <br>&gt; Chris, I honestly have to think more about that ambiguity with dictionaries.<br>&gt; <br>&gt; I can see that this would definitely need some further fleshing out, but it seems to be sufficiently different from Luis&#39; proposal to perhaps merit it&#39;s own proposal.<br>&gt; <br>&gt; It&#39;s up to you Luis, but I think this might be a bit more controversial then the changes you&#39;ve proposed, making it possible for your proposal getting rejected.  (I want your proposal accepted, since I would use those features today).  Partial acceptance of a proposal doesn&#39;t seem to be a thing. (Once again please correct me if I&#39;m wrong).<br>&gt; <br>&gt; On Mon, Jun 6, 2016 at 11:46 AM Luis Henrique B. Sousa &lt;lshsousa at gmail.com &lt;mailto:lshsousa at gmail.com&gt;&gt; wrote:<br>&gt; Thanks Vladimir,<br>&gt; <br>&gt; The correct link is this one (with the additional min/max operations in the implementation): <br>&gt; https://github.com/luish/swift-evolution/blob/proposal-lenient-collection-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md &lt;https://github.com/luish/swift-evolution/blob/proposal-lenient-collection-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md&gt;<br>&gt; <br>&gt; Here is the pull request on the swift-evolution repo: https://github.com/apple/swift-evolution/pull/328 &lt;https://github.com/apple/swift-evolution/pull/328&gt;<br>&gt; <br>&gt; Any help or suggestion to improve the proposal is welcome. :-)<br>&gt; <br>&gt; - Luis<br>&gt; <br>&gt; On Mon, Jun 6, 2016 at 6:10 PM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Please find this draft of proposal(hope this is correct link for latest version):<br>&gt; https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md &lt;https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md&gt;<br>&gt; <br>&gt; The main idea is to introduce 2 new subscript methods:  [clamping:] and [checking:]<br>&gt; <br>&gt; There was discussion in &quot;[Proposal] More lenient subscript methods over Collections&quot; and (older) &quot;[Proposal] Safer half-open range operator&quot;<br>&gt; <br>&gt; <br>&gt; On 06.06.2016 19:50, Rob Norback via swift-evolution wrote:<br>&gt; Hi Everyone!<br>&gt; <br>&gt; This is my first time emailing the swift evolution list, so if this topic<br>&gt; has already been discussed please let me know.  I looked through all the<br>&gt; accepted and rejected proposals and it doesn&#39;t seem to be on there.<br>&gt; <br>&gt; The main thought is that dictionaries return optionals, so why not arrays?<br>&gt; Or other CollectionTypes for that matter.  I would think this would be the<br>&gt; expected behavior in this situation:<br>&gt; <br>&gt; var myArray:[String?] = []<br>&gt; print(myArray[4])<br>&gt; // EXC_BAD_INSTRUCTION, but could just be Optional(nil)<br>&gt; <br>&gt; Then you could do things like<br>&gt; <br>&gt; if let arrayValue = myArray[4] {<br>&gt;    // do something<br>&gt; }<br>&gt; <br>&gt; Of course you could simply check with with the count, but considering<br>&gt; Swift&#39;s use of optionals to represent empty variables rather than erroring<br>&gt; out or returning an empty String, I think this functionality would be<br>&gt; appropriate to include in the Swift standard library.<br>&gt; <br>&gt; And there&#39;s about 15,000 people who&#39;ve looked for this functionality in the<br>&gt; last year:<br>&gt; http://stackoverflow.com/questions/25329186/safe-bounds-checked-array-lookup-in-swift-through-optional-bindings &lt;http://stackoverflow.com/questions/25329186/safe-bounds-checked-array-lookup-in-swift-through-optional-bindings&gt;.<br>&gt; <br>&gt; Please let me know what you think.<br>&gt; <br>&gt; Best,<br>&gt; Rob Norback<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160606/8a316e86/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Arrays Returning Optionals instead of Index Out of Bounds</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>June  7, 2016 at 02:00:00pm</p></header><div class="content"><p>On 06.06.2016 21:02, Rob Norback wrote:<br>&gt; First of all, thank you all for bringing me up to date so quickly.  I<br>&gt; looked over the proposal and it looks awesome.<br>&gt;<br>&gt; But as Chris mentioned, this doesn&#39;t solve the expected behavior and<br>&gt; ambiguity of ```Array&lt;Int?&gt;```<br>&gt;<br>&gt; In this case I would expect the default behavior (myArray[4]) without using<br>&gt; myArray[checking: 4] should return a nil in this case.<br></p><p>As Luis already noted, there was a discussion started with exactly the same <br>suggestion : return optional for wrong index/range. During the discussion <br>consensus was(I believe so) found that such proposal could not be <br>supported. But, as an alternative, special explicit syntax for <br>optional/checking results for index/range parameter was suggested. I&#39;d <br>recommend to read messages of these discussions.<br></p><p>As for [Int?], I believe we need no any additional solution for this <br>special case: you have to check if index is in array&#39;s bounds and if it is, <br>get value using standard subscript method.<br></p><p>&gt;<br>&gt; And Chris, I think it would make the most sense to have myArray[0] = nil to<br>&gt; be stored if the index is in Range, and for myArray[100] = nil to give a<br>&gt; warning of no assignment being made because index is out of range, kind of<br>&gt; like an unused variable.  Right now myArray[100] = nil gives you<br>&gt; EXC_BAD_INSTRUCTION.  Then if you assigned myArray[100] = 200, that would<br>&gt; have to simply change the Range.<br>&gt;<br>&gt; Chris, I honestly have to think more about that ambiguity with dictionaries.<br>&gt;<br>&gt; I can see that this would definitely need some further fleshing out, but it<br>&gt; seems to be sufficiently different from Luis&#39; proposal to perhaps merit<br>&gt; it&#39;s own proposal.<br>&gt;<br>&gt; It&#39;s up to you Luis, but I think this might be a bit more controversial<br>&gt; then the changes you&#39;ve proposed, making it possible for your proposal<br>&gt; getting rejected.  (I want your proposal accepted, since I would use those<br>&gt; features today).  Partial acceptance of a proposal doesn&#39;t seem to be a<br>&gt; thing. (Once again please correct me if I&#39;m wrong).<br>&gt;<br>&gt; On Mon, Jun 6, 2016 at 11:46 AM Luis Henrique B. Sousa &lt;lshsousa at gmail.com<br>&gt; &lt;mailto:lshsousa at gmail.com&gt;&gt; wrote:<br>&gt;<br>&gt;     Thanks Vladimir,<br>&gt;<br>&gt;     The correct link is this one (with the additional min/max operations in<br>&gt;     the implementation):<br>&gt;     https://github.com/luish/swift-evolution/blob/proposal-lenient-collection-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md<br>&gt;<br>&gt;     Here is the pull request on the swift-evolution<br>&gt;     repo: https://github.com/apple/swift-evolution/pull/328<br>&gt;<br>&gt;     Any help or suggestion to improve the proposal is welcome. :-)<br>&gt;<br>&gt;     - Luis<br>&gt;<br>&gt;     On Mon, Jun 6, 2016 at 6:10 PM, Vladimir.S via swift-evolution<br>&gt;     &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;<br>&gt;         Please find this draft of proposal(hope this is correct link for<br>&gt;         latest version):<br>&gt;         https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md<br>&gt;<br>&gt;         The main idea is to introduce 2 new subscript methods:  [clamping:]<br>&gt;         and [checking:]<br>&gt;<br>&gt;         There was discussion in &quot;[Proposal] More lenient subscript methods<br>&gt;         over Collections&quot; and (older) &quot;[Proposal] Safer half-open range<br>&gt;         operator&quot;<br>&gt;<br>&gt;<br>&gt;         On 06.06.2016 19:50, Rob Norback via swift-evolution wrote:<br>&gt;<br>&gt;             Hi Everyone!<br>&gt;<br>&gt;             This is my first time emailing the swift evolution list, so if<br>&gt;             this topic<br>&gt;             has already been discussed please let me know.  I looked<br>&gt;             through all the<br>&gt;             accepted and rejected proposals and it doesn&#39;t seem to be on there.<br>&gt;<br>&gt;             The main thought is that dictionaries return optionals, so why<br>&gt;             not arrays?<br>&gt;             Or other CollectionTypes for that matter.  I would think this<br>&gt;             would be the<br>&gt;             expected behavior in this situation:<br>&gt;<br>&gt;             var myArray:[String?] = []<br>&gt;             print(myArray[4])<br>&gt;             // EXC_BAD_INSTRUCTION, but could just be Optional(nil)<br>&gt;<br>&gt;             Then you could do things like<br>&gt;<br>&gt;             if let arrayValue = myArray[4] {<br>&gt;                // do something<br>&gt;             }<br>&gt;<br>&gt;             Of course you could simply check with with the count, but<br>&gt;             considering<br>&gt;             Swift&#39;s use of optionals to represent empty variables rather<br>&gt;             than erroring<br>&gt;             out or returning an empty String, I think this functionality<br>&gt;             would be<br>&gt;             appropriate to include in the Swift standard library.<br>&gt;<br>&gt;             And there&#39;s about 15,000 people who&#39;ve looked for this<br>&gt;             functionality in the<br>&gt;             last year:<br>&gt;             http://stackoverflow.com/questions/25329186/safe-bounds-checked-array-lookup-in-swift-through-optional-bindings.<br>&gt;<br>&gt;             Please let me know what you think.<br>&gt;<br>&gt;             Best,<br>&gt;             Rob Norback<br>&gt;<br>&gt;<br>&gt;             _______________________________________________<br>&gt;             swift-evolution mailing list<br>&gt;             swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;             https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;         _______________________________________________<br>&gt;         swift-evolution mailing list<br>&gt;         swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552d80567b8f0241a53cee772470ddd0?s=50"></div><header><strong>Arrays Returning Optionals instead of Index Out of Bounds</strong> from <string>Rob Norback</string> &lt;rnorback at gmail.com&gt;<p>June  7, 2016 at 07:00:00am</p></header><div class="content"><p>Vladimir, thank you for pointing me to the discussion again.  I read through the entire thing. And I didn&#39;t see a consensus around [Int?].<br></p><p>The main argument against was that it would allow the developer to be clumsy and remain unaware of a problem in the code because the choice is not explicit enough.<br></p><p>The main argument for is that dictionaries already do this, so why don&#39;t we have to explicitly check if a dictionary key is within bounds?<br></p><p>IMO casting an array to [Int?] is an explicit choice.  One I would expect to always return an optional from a subscript.  A [Int] array should still fail fast.  <br></p><p>I&#39;d like to clearly understand the downside of swift behaving this way, and why a proposal like this would not be supported.  Not to be confrontational, but simply to expand my own perspective.  Perhaps some more explicit examples of developer laziness that could cause major problems.  I find I always have to be much more careful when coding with optionals.<br></p><p>&gt; On Jun 7, 2016, at 5:48 AM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; On 06.06.2016 21:02, Rob Norback wrote:<br>&gt;&gt; First of all, thank you all for bringing me up to date so quickly.  I<br>&gt;&gt; looked over the proposal and it looks awesome.<br>&gt;&gt; <br>&gt;&gt; But as Chris mentioned, this doesn&#39;t solve the expected behavior and<br>&gt;&gt; ambiguity of ```Array&lt;Int?&gt;```<br>&gt;&gt; <br>&gt;&gt; In this case I would expect the default behavior (myArray[4]) without using<br>&gt;&gt; myArray[checking: 4] should return a nil in this case.<br>&gt; <br>&gt; As Luis already noted, there was a discussion started with exactly the same suggestion : return optional for wrong index/range. During the discussion consensus was(I believe so) found that such proposal could not be supported. But, as an alternative, special explicit syntax for optional/checking results for index/range parameter was suggested. I&#39;d recommend to read messages of these discussions.<br>&gt; <br>&gt; As for [Int?], I believe we need no any additional solution for this special case: you have to check if index is in array&#39;s bounds and if it is, get value using standard subscript method.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; And Chris, I think it would make the most sense to have myArray[0] = nil to<br>&gt;&gt; be stored if the index is in Range, and for myArray[100] = nil to give a<br>&gt;&gt; warning of no assignment being made because index is out of range, kind of<br>&gt;&gt; like an unused variable.  Right now myArray[100] = nil gives you<br>&gt;&gt; EXC_BAD_INSTRUCTION.  Then if you assigned myArray[100] = 200, that would<br>&gt;&gt; have to simply change the Range.<br>&gt;&gt; <br>&gt;&gt; Chris, I honestly have to think more about that ambiguity with dictionaries.<br>&gt;&gt; <br>&gt;&gt; I can see that this would definitely need some further fleshing out, but it<br>&gt;&gt; seems to be sufficiently different from Luis&#39; proposal to perhaps merit<br>&gt;&gt; it&#39;s own proposal.<br>&gt;&gt; <br>&gt;&gt; It&#39;s up to you Luis, but I think this might be a bit more controversial<br>&gt;&gt; then the changes you&#39;ve proposed, making it possible for your proposal<br>&gt;&gt; getting rejected.  (I want your proposal accepted, since I would use those<br>&gt;&gt; features today).  Partial acceptance of a proposal doesn&#39;t seem to be a<br>&gt;&gt; thing. (Once again please correct me if I&#39;m wrong).<br>&gt;&gt; <br>&gt;&gt; On Mon, Jun 6, 2016 at 11:46 AM Luis Henrique B. Sousa &lt;lshsousa at gmail.com<br>&gt;&gt; &lt;mailto:lshsousa at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;    Thanks Vladimir,<br>&gt;&gt; <br>&gt;&gt;    The correct link is this one (with the additional min/max operations in<br>&gt;&gt;    the implementation):<br>&gt;&gt;    https://github.com/luish/swift-evolution/blob/proposal-lenient-collection-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md<br>&gt;&gt; <br>&gt;&gt;    Here is the pull request on the swift-evolution<br>&gt;&gt;    repo: https://github.com/apple/swift-evolution/pull/328<br>&gt;&gt; <br>&gt;&gt;    Any help or suggestion to improve the proposal is welcome. :-)<br>&gt;&gt; <br>&gt;&gt;    - Luis<br>&gt;&gt; <br>&gt;&gt;    On Mon, Jun 6, 2016 at 6:10 PM, Vladimir.S via swift-evolution<br>&gt;&gt;    &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;        Please find this draft of proposal(hope this is correct link for<br>&gt;&gt;        latest version):<br>&gt;&gt;        https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md<br>&gt;&gt; <br>&gt;&gt;        The main idea is to introduce 2 new subscript methods:  [clamping:]<br>&gt;&gt;        and [checking:]<br>&gt;&gt; <br>&gt;&gt;        There was discussion in &quot;[Proposal] More lenient subscript methods<br>&gt;&gt;        over Collections&quot; and (older) &quot;[Proposal] Safer half-open range<br>&gt;&gt;        operator&quot;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;        On 06.06.2016 19:50, Rob Norback via swift-evolution wrote:<br>&gt;&gt; <br>&gt;&gt;            Hi Everyone!<br>&gt;&gt; <br>&gt;&gt;            This is my first time emailing the swift evolution list, so if<br>&gt;&gt;            this topic<br>&gt;&gt;            has already been discussed please let me know.  I looked<br>&gt;&gt;            through all the<br>&gt;&gt;            accepted and rejected proposals and it doesn&#39;t seem to be on there.<br>&gt;&gt; <br>&gt;&gt;            The main thought is that dictionaries return optionals, so why<br>&gt;&gt;            not arrays?<br>&gt;&gt;            Or other CollectionTypes for that matter.  I would think this<br>&gt;&gt;            would be the<br>&gt;&gt;            expected behavior in this situation:<br>&gt;&gt; <br>&gt;&gt;            var myArray:[String?] = []<br>&gt;&gt;            print(myArray[4])<br>&gt;&gt;            // EXC_BAD_INSTRUCTION, but could just be Optional(nil)<br>&gt;&gt; <br>&gt;&gt;            Then you could do things like<br>&gt;&gt; <br>&gt;&gt;            if let arrayValue = myArray[4] {<br>&gt;&gt;               // do something<br>&gt;&gt;            }<br>&gt;&gt; <br>&gt;&gt;            Of course you could simply check with with the count, but<br>&gt;&gt;            considering<br>&gt;&gt;            Swift&#39;s use of optionals to represent empty variables rather<br>&gt;&gt;            than erroring<br>&gt;&gt;            out or returning an empty String, I think this functionality<br>&gt;&gt;            would be<br>&gt;&gt;            appropriate to include in the Swift standard library.<br>&gt;&gt; <br>&gt;&gt;            And there&#39;s about 15,000 people who&#39;ve looked for this<br>&gt;&gt;            functionality in the<br>&gt;&gt;            last year:<br>&gt;&gt;            http://stackoverflow.com/questions/25329186/safe-bounds-checked-array-lookup-in-swift-through-optional-bindings.<br>&gt;&gt; <br>&gt;&gt;            Please let me know what you think.<br>&gt;&gt; <br>&gt;&gt;            Best,<br>&gt;&gt;            Rob Norback<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;            _______________________________________________<br>&gt;&gt;            swift-evolution mailing list<br>&gt;&gt;            swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;            https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt;        _______________________________________________<br>&gt;&gt;        swift-evolution mailing list<br>&gt;&gt;        swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;        https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Arrays Returning Optionals instead of Index Out of Bounds</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>June  7, 2016 at 05:00:00pm</p></header><div class="content"><p>It seems like you are mixing two proposals: optional result of non-optional <br>array and return value of optional array.<br></p><p>I&#39;m commenting the first - as it was already discussed earlier and based on <br>community reaction on it - I believe it will not be supported again. Array <br>is expected to fail fast when we access with wrong index.<br>But let&#39;s hear other opinions, may be I&#39;m wrong.<br></p><p>As for second proposal/problem with [Int?] - I don&#39;t remember such <br>discussion, so probably you should create a separate thread for it. It <br>seems like I don&#39;t understand the problem with [Int?] in details, so have <br>no opinion right now. IMO dictionary [Type1:Type2?] is a special case where <br>you need to use myDict.keys.contains(keyValue) first to determinate if you <br>have a value for key and after this you can get the value itself(which is <br>Optional).<br></p><p>On 07.06.2016 16:42, Rob Norback wrote:<br>&gt; Vladimir, thank you for pointing me to the discussion again.  I read through the entire thing. And I didn&#39;t see a consensus around [Int?].<br>&gt;<br>&gt; The main argument against was that it would allow the developer to be clumsy and remain unaware of a problem in the code because the choice is not explicit enough.<br>&gt;<br>&gt; The main argument for is that dictionaries already do this, so why don&#39;t we have to explicitly check if a dictionary key is within bounds?<br>&gt;<br>&gt; IMO casting an array to [Int?] is an explicit choice.  One I would expect to always return an optional from a subscript.  A [Int] array should still fail fast.<br>&gt;<br>&gt; I&#39;d like to clearly understand the downside of swift behaving this way, and why a proposal like this would not be supported.  Not to be confrontational, but simply to expand my own perspective.  Perhaps some more explicit examples of developer laziness that could cause major problems.  I find I always have to be much more careful when coding with optionals.<br>&gt;<br>&gt;&gt; On Jun 7, 2016, at 5:48 AM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; On 06.06.2016 21:02, Rob Norback wrote:<br>&gt;&gt;&gt; First of all, thank you all for bringing me up to date so quickly.  I<br>&gt;&gt;&gt; looked over the proposal and it looks awesome.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; But as Chris mentioned, this doesn&#39;t solve the expected behavior and<br>&gt;&gt;&gt; ambiguity of ```Array&lt;Int?&gt;```<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In this case I would expect the default behavior (myArray[4]) without using<br>&gt;&gt;&gt; myArray[checking: 4] should return a nil in this case.<br>&gt;&gt;<br>&gt;&gt; As Luis already noted, there was a discussion started with exactly the same suggestion : return optional for wrong index/range. During the discussion consensus was(I believe so) found that such proposal could not be supported. But, as an alternative, special explicit syntax for optional/checking results for index/range parameter was suggested. I&#39;d recommend to read messages of these discussions.<br>&gt;&gt;<br>&gt;&gt; As for [Int?], I believe we need no any additional solution for this special case: you have to check if index is in array&#39;s bounds and if it is, get value using standard subscript method.<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; And Chris, I think it would make the most sense to have myArray[0] = nil to<br>&gt;&gt;&gt; be stored if the index is in Range, and for myArray[100] = nil to give a<br>&gt;&gt;&gt; warning of no assignment being made because index is out of range, kind of<br>&gt;&gt;&gt; like an unused variable.  Right now myArray[100] = nil gives you<br>&gt;&gt;&gt; EXC_BAD_INSTRUCTION.  Then if you assigned myArray[100] = 200, that would<br>&gt;&gt;&gt; have to simply change the Range.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Chris, I honestly have to think more about that ambiguity with dictionaries.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I can see that this would definitely need some further fleshing out, but it<br>&gt;&gt;&gt; seems to be sufficiently different from Luis&#39; proposal to perhaps merit<br>&gt;&gt;&gt; it&#39;s own proposal.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It&#39;s up to you Luis, but I think this might be a bit more controversial<br>&gt;&gt;&gt; then the changes you&#39;ve proposed, making it possible for your proposal<br>&gt;&gt;&gt; getting rejected.  (I want your proposal accepted, since I would use those<br>&gt;&gt;&gt; features today).  Partial acceptance of a proposal doesn&#39;t seem to be a<br>&gt;&gt;&gt; thing. (Once again please correct me if I&#39;m wrong).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Mon, Jun 6, 2016 at 11:46 AM Luis Henrique B. Sousa &lt;lshsousa at gmail.com<br>&gt;&gt;&gt; &lt;mailto:lshsousa at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    Thanks Vladimir,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    The correct link is this one (with the additional min/max operations in<br>&gt;&gt;&gt;    the implementation):<br>&gt;&gt;&gt;    https://github.com/luish/swift-evolution/blob/proposal-lenient-collection-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    Here is the pull request on the swift-evolution<br>&gt;&gt;&gt;    repo: https://github.com/apple/swift-evolution/pull/328<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    Any help or suggestion to improve the proposal is welcome. :-)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    - Luis<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    On Mon, Jun 6, 2016 at 6:10 PM, Vladimir.S via swift-evolution<br>&gt;&gt;&gt;    &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;        Please find this draft of proposal(hope this is correct link for<br>&gt;&gt;&gt;        latest version):<br>&gt;&gt;&gt;        https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;        The main idea is to introduce 2 new subscript methods:  [clamping:]<br>&gt;&gt;&gt;        and [checking:]<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;        There was discussion in &quot;[Proposal] More lenient subscript methods<br>&gt;&gt;&gt;        over Collections&quot; and (older) &quot;[Proposal] Safer half-open range<br>&gt;&gt;&gt;        operator&quot;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;        On 06.06.2016 19:50, Rob Norback via swift-evolution wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;            Hi Everyone!<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;            This is my first time emailing the swift evolution list, so if<br>&gt;&gt;&gt;            this topic<br>&gt;&gt;&gt;            has already been discussed please let me know.  I looked<br>&gt;&gt;&gt;            through all the<br>&gt;&gt;&gt;            accepted and rejected proposals and it doesn&#39;t seem to be on there.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;            The main thought is that dictionaries return optionals, so why<br>&gt;&gt;&gt;            not arrays?<br>&gt;&gt;&gt;            Or other CollectionTypes for that matter.  I would think this<br>&gt;&gt;&gt;            would be the<br>&gt;&gt;&gt;            expected behavior in this situation:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;            var myArray:[String?] = []<br>&gt;&gt;&gt;            print(myArray[4])<br>&gt;&gt;&gt;            // EXC_BAD_INSTRUCTION, but could just be Optional(nil)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;            Then you could do things like<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;            if let arrayValue = myArray[4] {<br>&gt;&gt;&gt;               // do something<br>&gt;&gt;&gt;            }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;            Of course you could simply check with with the count, but<br>&gt;&gt;&gt;            considering<br>&gt;&gt;&gt;            Swift&#39;s use of optionals to represent empty variables rather<br>&gt;&gt;&gt;            than erroring<br>&gt;&gt;&gt;            out or returning an empty String, I think this functionality<br>&gt;&gt;&gt;            would be<br>&gt;&gt;&gt;            appropriate to include in the Swift standard library.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;            And there&#39;s about 15,000 people who&#39;ve looked for this<br>&gt;&gt;&gt;            functionality in the<br>&gt;&gt;&gt;            last year:<br>&gt;&gt;&gt;            http://stackoverflow.com/questions/25329186/safe-bounds-checked-array-lookup-in-swift-through-optional-bindings.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;            Please let me know what you think.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;            Best,<br>&gt;&gt;&gt;            Rob Norback<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;            _______________________________________________<br>&gt;&gt;&gt;            swift-evolution mailing list<br>&gt;&gt;&gt;            swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;            https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;        _______________________________________________<br>&gt;&gt;&gt;        swift-evolution mailing list<br>&gt;&gt;&gt;        swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;        https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552d80567b8f0241a53cee772470ddd0?s=50"></div><header><strong>Arrays of optionals retuning optionals for all indicies</strong> from <string>Rob Norback</string> &lt;rnorback at gmail.com&gt;<p>June  7, 2016 at 09:00:00am</p></header><div class="content"><p>I think you&#39;re right Vladimir.  After having this discussion I&#39;ve changed my opinion on normal arrays returning optionals.  I don&#39;t think that&#39;s a good idea as its not explicit and is unexpected behavior.<br></p><p>I&#39;d simply like to draft a proposal that has arrays of optionals returning optionals for all indicies with no &#39;Index out of bounds errors&#39; as I think it&#39;s explicit [Int?] and closer to expected behavior.<br></p><p>I&#39;d need to flesh out how assignment would behave differently for an array of optionals since assigning a value out of bounds would likely have a different expected effect as well.<br></p><p><br>&gt; On Jun 7, 2016, at 8:33 AM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt; <br>&gt; It seems like you are mixing two proposals: optional result of non-optional array and return value of optional array.<br>&gt; <br>&gt; I&#39;m commenting the first - as it was already discussed earlier and based on community reaction on it - I believe it will not be supported again. Array is expected to fail fast when we access with wrong index.<br>&gt; But let&#39;s hear other opinions, may be I&#39;m wrong.<br>&gt; <br>&gt; As for second proposal/problem with [Int?] - I don&#39;t remember such discussion, so probably you should create a separate thread for it. It seems like I don&#39;t understand the problem with [Int?] in details, so have no opinion right now. IMO dictionary [Type1:Type2?] is a special case where you need to use myDict.keys.contains(keyValue) first to determinate if you have a value for key and after this you can get the value itself(which is Optional).<br>&gt; <br>&gt;&gt; On 07.06.2016 16:42, Rob Norback wrote:<br>&gt;&gt; Vladimir, thank you for pointing me to the discussion again.  I read through the entire thing. And I didn&#39;t see a consensus around [Int?].<br>&gt;&gt; <br>&gt;&gt; The main argument against was that it would allow the developer to be clumsy and remain unaware of a problem in the code because the choice is not explicit enough.<br>&gt;&gt; <br>&gt;&gt; The main argument for is that dictionaries already do this, so why don&#39;t we have to explicitly check if a dictionary key is within bounds?<br>&gt;&gt; <br>&gt;&gt; IMO casting an array to [Int?] is an explicit choice.  One I would expect to always return an optional from a subscript.  A [Int] array should still fail fast.<br>&gt;&gt; <br>&gt;&gt; I&#39;d like to clearly understand the downside of swift behaving this way, and why a proposal like this would not be supported.  Not to be confrontational, but simply to expand my own perspective.  Perhaps some more explicit examples of developer laziness that could cause major problems.  I find I always have to be much more careful when coding with optionals.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 7, 2016, at 5:48 AM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 06.06.2016 21:02, Rob Norback wrote:<br>&gt;&gt;&gt;&gt; First of all, thank you all for bringing me up to date so quickly.  I<br>&gt;&gt;&gt;&gt; looked over the proposal and it looks awesome.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But as Chris mentioned, this doesn&#39;t solve the expected behavior and<br>&gt;&gt;&gt;&gt; ambiguity of ```Array&lt;Int?&gt;```<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In this case I would expect the default behavior (myArray[4]) without using<br>&gt;&gt;&gt;&gt; myArray[checking: 4] should return a nil in this case.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As Luis already noted, there was a discussion started with exactly the same suggestion : return optional for wrong index/range. During the discussion consensus was(I believe so) found that such proposal could not be supported. But, as an alternative, special explicit syntax for optional/checking results for index/range parameter was suggested. I&#39;d recommend to read messages of these discussions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As for [Int?], I believe we need no any additional solution for this special case: you have to check if index is in array&#39;s bounds and if it is, get value using standard subscript method.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And Chris, I think it would make the most sense to have myArray[0] = nil to<br>&gt;&gt;&gt;&gt; be stored if the index is in Range, and for myArray[100] = nil to give a<br>&gt;&gt;&gt;&gt; warning of no assignment being made because index is out of range, kind of<br>&gt;&gt;&gt;&gt; like an unused variable.  Right now myArray[100] = nil gives you<br>&gt;&gt;&gt;&gt; EXC_BAD_INSTRUCTION.  Then if you assigned myArray[100] = 200, that would<br>&gt;&gt;&gt;&gt; have to simply change the Range.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Chris, I honestly have to think more about that ambiguity with dictionaries.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I can see that this would definitely need some further fleshing out, but it<br>&gt;&gt;&gt;&gt; seems to be sufficiently different from Luis&#39; proposal to perhaps merit<br>&gt;&gt;&gt;&gt; it&#39;s own proposal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It&#39;s up to you Luis, but I think this might be a bit more controversial<br>&gt;&gt;&gt;&gt; then the changes you&#39;ve proposed, making it possible for your proposal<br>&gt;&gt;&gt;&gt; getting rejected.  (I want your proposal accepted, since I would use those<br>&gt;&gt;&gt;&gt; features today).  Partial acceptance of a proposal doesn&#39;t seem to be a<br>&gt;&gt;&gt;&gt; thing. (Once again please correct me if I&#39;m wrong).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mon, Jun 6, 2016 at 11:46 AM Luis Henrique B. Sousa &lt;lshsousa at gmail.com<br>&gt;&gt;&gt;&gt; &lt;mailto:lshsousa at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   Thanks Vladimir,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   The correct link is this one (with the additional min/max operations in<br>&gt;&gt;&gt;&gt;   the implementation):<br>&gt;&gt;&gt;&gt;   https://github.com/luish/swift-evolution/blob/proposal-lenient-collection-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   Here is the pull request on the swift-evolution<br>&gt;&gt;&gt;&gt;   repo: https://github.com/apple/swift-evolution/pull/328<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   Any help or suggestion to improve the proposal is welcome. :-)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   - Luis<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   On Mon, Jun 6, 2016 at 6:10 PM, Vladimir.S via swift-evolution<br>&gt;&gt;&gt;&gt;   &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       Please find this draft of proposal(hope this is correct link for<br>&gt;&gt;&gt;&gt;       latest version):<br>&gt;&gt;&gt;&gt;       https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       The main idea is to introduce 2 new subscript methods:  [clamping:]<br>&gt;&gt;&gt;&gt;       and [checking:]<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       There was discussion in &quot;[Proposal] More lenient subscript methods<br>&gt;&gt;&gt;&gt;       over Collections&quot; and (older) &quot;[Proposal] Safer half-open range<br>&gt;&gt;&gt;&gt;       operator&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       On 06.06.2016 19:50, Rob Norback via swift-evolution wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;           Hi Everyone!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;           This is my first time emailing the swift evolution list, so if<br>&gt;&gt;&gt;&gt;           this topic<br>&gt;&gt;&gt;&gt;           has already been discussed please let me know.  I looked<br>&gt;&gt;&gt;&gt;           through all the<br>&gt;&gt;&gt;&gt;           accepted and rejected proposals and it doesn&#39;t seem to be on there.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;           The main thought is that dictionaries return optionals, so why<br>&gt;&gt;&gt;&gt;           not arrays?<br>&gt;&gt;&gt;&gt;           Or other CollectionTypes for that matter.  I would think this<br>&gt;&gt;&gt;&gt;           would be the<br>&gt;&gt;&gt;&gt;           expected behavior in this situation:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;           var myArray:[String?] = []<br>&gt;&gt;&gt;&gt;           print(myArray[4])<br>&gt;&gt;&gt;&gt;           // EXC_BAD_INSTRUCTION, but could just be Optional(nil)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;           Then you could do things like<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;           if let arrayValue = myArray[4] {<br>&gt;&gt;&gt;&gt;              // do something<br>&gt;&gt;&gt;&gt;           }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;           Of course you could simply check with with the count, but<br>&gt;&gt;&gt;&gt;           considering<br>&gt;&gt;&gt;&gt;           Swift&#39;s use of optionals to represent empty variables rather<br>&gt;&gt;&gt;&gt;           than erroring<br>&gt;&gt;&gt;&gt;           out or returning an empty String, I think this functionality<br>&gt;&gt;&gt;&gt;           would be<br>&gt;&gt;&gt;&gt;           appropriate to include in the Swift standard library.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;           And there&#39;s about 15,000 people who&#39;ve looked for this<br>&gt;&gt;&gt;&gt;           functionality in the<br>&gt;&gt;&gt;&gt;           last year:<br>&gt;&gt;&gt;&gt;           http://stackoverflow.com/questions/25329186/safe-bounds-checked-array-lookup-in-swift-through-optional-bindings.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;           Please let me know what you think.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;           Best,<br>&gt;&gt;&gt;&gt;           Rob Norback<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;           _______________________________________________<br>&gt;&gt;&gt;&gt;           swift-evolution mailing list<br>&gt;&gt;&gt;&gt;           swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;           https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       _______________________________________________<br>&gt;&gt;&gt;&gt;       swift-evolution mailing list<br>&gt;&gt;&gt;&gt;       swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;       https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be09ed656d5d90501c958b001261f218?s=50"></div><header><strong>Arrays Returning Optionals instead of Index Out of Bounds</strong> from <string>Jeremy Pereira</string> &lt;jeremy.j.pereira at googlemail.com&gt;<p>June  7, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; IMO dictionary [Type1:Type2?] is a special case where you need to use myDict.keys.contains(keyValue) first to determinate if you have a value for key and after this you can get the value itself(which is Optional).<br></p><p>I donâ€™t understand why you think it is a special case. The return type of subscripting [ T1 : T2?] is T2?? or Optional&lt;Optional&lt;T2&gt;&gt;. You can do all the normal unwrapping you would expect except that one unwrapping results in another optional e.g.<br></p><p>---<br>var sqrt: [Int : Int?] = [ 1: 1, 4 : 2, 2 : nil]<br></p><p>func tellMeTheSquareRoot(n : Int) -&gt; String<br>{<br>    if let lookupResult = sqrt[n]<br>    {<br>        if let theSquareRoot = lookupResult<br>        {<br>            return &quot;\(n) has a square root and it is \(theSquareRoot)&quot;<br>        }<br>        else<br>        {<br>            return &quot;\(n) has a square root but it is not an integer&quot;<br>        }<br>    }<br>    else<br>    {<br>        return &quot;I can&#39;t imagine what the square root of \(n) might be&quot;<br>    }<br>}<br></p><p>print(tellMeTheSquareRoot(4))<br>print(tellMeTheSquareRoot(2))<br>print(tellMeTheSquareRoot(-1))<br>â€”<br></p><p>gives the results<br></p><p>4 has a square root and it is 2<br>2 has a square root but it is not an integer<br>I can&#39;t imagine what the square root of -1 might be<br></p><p>Comparing to nil is ambiguous to the human eye but the compiler makes a decision<br></p><p>sqrt[2] == nil // false (huh?)<br>sqrt[-1] == nil // true<br></p><p>The reason the first one is false is because the return result is not nil but<br></p><p> Optional&lt;Optional&lt;Int&gt;&gt;.Some(Optional&lt;Int&gt;.None&gt;)<br></p><p>A similar rule applies to assignment to a subscript, the compiler assumes the â€œtop levelâ€ of optional but you can force the addition of an element with a nil value by being explicit.<br></p><p>sqrt[2] = nil // [4: Optional(2), 1: Optional(1)] - 2 has been zapped<br></p><p>sqrt[2] = Optional&lt;Int&gt;.None // [2: nil, 4: Optional(2), 1: Optional(1)] - 2 has been re-added<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Arrays Returning Optionals instead of Index Out of Bounds</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>June  7, 2016 at 08:00:00pm</p></header><div class="content"><p>Yes, thank you Jeremy for pointing on this, my fault :-(, was confused by <br>initial description of the problem in proposal and in my fast test I got <br>&quot;Optional(nil)&quot; in console for existed &quot;nil&quot; value in dict, but didn&#39;t <br>realized that it should be printed just &quot;nil&quot;.<br></p><p>On 07.06.2016 19:06, Jeremy Pereira wrote:<br>&gt;<br>&gt;&gt; IMO dictionary [Type1:Type2?] is a special case where you need to use myDict.keys.contains(keyValue) first to determinate if you have a value for key and after this you can get the value itself(which is Optional).<br>&gt;<br>&gt; I donâ€™t understand why you think it is a special case. The return type of subscripting [ T1 : T2?] is T2?? or Optional&lt;Optional&lt;T2&gt;&gt;. You can do all the normal unwrapping you would expect except that one unwrapping results in another optional e.g.<br>&gt;<br>&gt; ---<br>&gt; var sqrt: [Int : Int?] = [ 1: 1, 4 : 2, 2 : nil]<br>&gt;<br>&gt; func tellMeTheSquareRoot(n : Int) -&gt; String<br>&gt; {<br>&gt;     if let lookupResult = sqrt[n]<br>&gt;     {<br>&gt;         if let theSquareRoot = lookupResult<br>&gt;         {<br>&gt;             return &quot;\(n) has a square root and it is \(theSquareRoot)&quot;<br>&gt;         }<br>&gt;         else<br>&gt;         {<br>&gt;             return &quot;\(n) has a square root but it is not an integer&quot;<br>&gt;         }<br>&gt;     }<br>&gt;     else<br>&gt;     {<br>&gt;         return &quot;I can&#39;t imagine what the square root of \(n) might be&quot;<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; print(tellMeTheSquareRoot(4))<br>&gt; print(tellMeTheSquareRoot(2))<br>&gt; print(tellMeTheSquareRoot(-1))<br>&gt; â€”<br>&gt;<br>&gt; gives the results<br>&gt;<br>&gt; 4 has a square root and it is 2<br>&gt; 2 has a square root but it is not an integer<br>&gt; I can&#39;t imagine what the square root of -1 might be<br>&gt;<br>&gt; Comparing to nil is ambiguous to the human eye but the compiler makes a decision<br>&gt;<br>&gt; sqrt[2] == nil // false (huh?)<br>&gt; sqrt[-1] == nil // true<br>&gt;<br>&gt; The reason the first one is false is because the return result is not nil but<br>&gt;<br>&gt;  Optional&lt;Optional&lt;Int&gt;&gt;.Some(Optional&lt;Int&gt;.None&gt;)<br>&gt;<br>&gt; A similar rule applies to assignment to a subscript, the compiler assumes the â€œtop levelâ€ of optional but you can force the addition of an element with a nil value by being explicit.<br>&gt;<br>&gt; sqrt[2] = nil // [4: Optional(2), 1: Optional(1)] - 2 has been zapped<br>&gt;<br>&gt; sqrt[2] = Optional&lt;Int&gt;.None // [2: nil, 4: Optional(2), 1: Optional(1)] - 2 has been re-added<br>&gt;<br>&gt;<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
